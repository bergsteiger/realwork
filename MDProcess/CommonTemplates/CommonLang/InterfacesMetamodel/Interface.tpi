////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/InterfacesMetamodel/Interface.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::CommonLang::InterfacesMetamodel::Interface
//
// Интерфейс
// ---
// Определяет простой интерфейс, с поддержкой фреймворка фабрик.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

: Interface::Class
? Интерфейс
? Определяет простой интерфейс, с поддержкой фреймворка фабрик.
> FactoryMemory::Class

= AbstractFacet::Class
= AbstractInterface::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
a raf
/ - тип абстракции
Y code_interface.gif
L code_interface
// Параметры визуализации
$ C 215,215,255
$ l 10,10,255
$ f 10,10,255

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

p author:s ? автор
p debug log:b=false ? включает генерацию вывода в лог обращений ко всем методам реализации интерфейса
p need UC:b=false ? явно включает генерацию дополнительных секций Юзер-Кода
p TODO:s ? напоминалка что-то сделать
p single impl:b=false ? Устанавливает ограничение на возможное количество реализаций интерфейса, Если значение = true, то реализация может быть только одна

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

%f _st_space_key
	MDP

%f _wiki_up_print
	%S%[AbstractFacet::Class]f_wiki_up_print()[{"%S{author}"!="%S{!author}"}%f_up_prefix(%S) *author* = *%S{author}* - автор
	][{"%S{debug log}"!="%S{!debug log}"}%f_up_prefix(%S) *debug log* = *%S{debug log}* - включает генерацию вывода в лог обращений ко всем методам реализации интерфейса
	][{"%S{need UC}"!="%S{!need UC}"}%f_up_prefix(%S) *need UC* = *%S{need UC}* - явно включает генерацию дополнительных секций Юзер-Кода
	][{"%S{TODO}"!="%S{!TODO}"}%f_up_prefix(%S) *TODO* = *%S{TODO}* - напоминалка что-то сделать
	][{"%S{single impl}"!="%S{!single impl}"}%f_up_prefix(%S) *single impl* = *%S{single impl}* - Устанавливает ограничение на возможное количество реализаций интерфейса, Если значение = true, то реализация может быть только одна
	]


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет, что элемент может реализовываться классом
%f _ClassImplementable
//#UC START# *49551CA202CFfor470F512D003E*
	true
//#UC END# *49551CA202CFfor470F512D003E*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет, что элемент является интерфейсом
%f _IsInterface
//#UC START# *49809333028Cfor470F512D003E*
	true
//#UC END# *49809333028Cfor470F512D003E*

// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for470F512D003E*
c                                                                               {}
r {<{}{"%RN"!="state machine"&"%RM"!="UMLPrimitive::Class"&%t_check_type(%R,"Facet::Class")=false&%t_check_type(%R,"ServerFacet::Class")=false&%t_check_type(%R,"StateMachine::Class")=false&%t_check_type(%R,"%SM")=false}{%RC}>!=0}:                           {%SS can realize only Facet, ServerFacet or StateMachine}
r {%Rx=true&<{}{}{%RC}>!=1}:                                                                                                                                                                                                                                     {%SS can't realize more than one elem}
r {%Sa!=abstract&<{}{%P{Full MDP}=true}{C}>!=0&<{}{%a#f_IsUseCase()=true}{C}>=0}:                                                                                                                                                                                          {%SS не используется ни в одном прецеденте}
r {%Sa!=abstract&<{}{"%RN"="state machine"&"%RM"="UMLPrimitive::Class"}{%RC}>!=0}:                                                                                                                                                                               {Только абстрактный интерфейс может реализовывать примитив "state machine"}
r {"%f_check_local_int(%S)"!=""}:                                                                                                                                                                                                                                {В одном пакете реализации на один конкретный интерфейс может существовать только один локальный интерфейс доопределяющий его}
r {%Sa=abstract&<{}{%SM=%ZM}{C}>=0&<{}{%SM=%LM}{C}>=0&<{}{%PN=shared&%PS=Project}{%P}>=0}:                                                                                                                                                                       {Абстрактный %SS должен иметь наследников}
r {""=""}:                                                                                                                                                                                                                                                       {%S%t_common_interface_constraint()}

//общие констрэйнты для Interface и LocalInterface
%t _common_interface_constraint
c                                                                                                                                           {}
r {<{}{%t_check_type(%G,"Facet::Class")=false&%t_check_type(%G,"ServerFacet::Class")=false&%t_check_type(%G,"%SM")=false}{%GC}>!=0}:        {%SS может наследоваться только от других %SS, или от Facet, или от ServerFacet}
r {<{}{%f_is_factory(%C)&%C%TS=FactoryMemory&%f_is_it_cached(%C)=false}{%CC}>!=0}:                                                          {Только кэшированные фабрики могут использовать общий кэш}
r {%Sa!=abstract&<{}{"%RN"="state machine"&"%RM"="UMLPrimitive::Class"}{%RC}>!=0}:                                                          {Только абстрактный %SS может реализовывать примитив "state machine"}
r {<{}{%aS=friend&%aC=Dependency&%a%PS!=%SS}{%aC}>!=0}:                                                                                     {%SS может быть другом только %SS}
r {<{}{%CV!=PublicAccess}{%CC}>!=0&<{}{%aS=friend&%aC=Dependency}{%aC}>=0}:                                                                 {%SS определяющий не публичные методы/фабрики должен иметь хотя бы одного "друга"}
r {<{}{%CC=Operation&%CS=multi factory}{%CC}>!=0&%f_factory_switch_count(%S)=0}:                                                            {%SS определяющий мульти-фабрику должен определять селектор !%f_factory_switch_count(%S)!}
r {%f_number_cmp("%f_factory_switch_count(%S)","1","\>")=1}:                                                                                {%SS может определять только один селектор}
r {%f_has_factory_methods(%S)=false&%Sa!=abstract&<{}{%LS=LocalInterface}{%LC}>=0}:                                                         {Неабстрактный %SS должен определять хотя бы одну фабрику}
r {%S{single impl}=true&%Lx=true&<{}{}{%LC}>!=1}:                                                                                           {На данный интерфейс установленно ограничение количества возможных реализаций = 1}

f _factory_switch_count
	%f_evaluate([{}{0}%f_factory_switch_count_self(%S)]+[{}{0}<{+}{%SS=%gS&%ga=abstract}%f_factory_switch_count_self(%g)>])

f _factory_switch_count_self
	<{}{%CC=Attribute&%CS=factory switch}{%CC}>

f _check_local_int
	%f_clear_list(LOCAL_INT_PACKS)\
	[<{, }{%LS=LocalInterface}[%L[{%f_exists_in_list(LOCAL_INT_PACKS,P)=true}{%f_add_to_list(LOCAL_INT_PACKS,P)}%SN]]>]

//проверяет на уникальность имена кэшированных фабрик
f _check_unique_factory_name
	[{"%f_check_unique_factory_name_i(%S)"!=""}{true}false]

f _check_unique_factory_name_i
	%f_clear_list(CACHED_LIST)\
	<{}{%f_is_factory(%C)&%f_is_it_cached(%C)=true}[{%f_exists_in_list(CACHED_LIST,"%CN")=false}{%CN, }%f_add_to_list(CACHED_LIST,"%CN")]>%f_clear_list(CACHED_LIST)

f _can_realize_sm_primitive
	[{%Sa=abstract&"%RN"!="state machine"&"%1M"!="UMLPrimitive::Class"}{false}true]
//#UC END# *4704C0E30186for470F512D003E*

// перекрытие базового стереотипа C++ Фабрики::MDAGenerator
// генератор файлов реализации для фабрик интерфейсов (.cpp)
+ fctr.cpp
//#UC START# *4705C54B01F4for470F512D003E*
= AbstractInterface::Class;fctr.cpp
//#UC END# *4705C54B01F4for470F512D003E*

// перекрытие базового стереотипа C++ Фабрики::MDAGenerator
// генератор заголовочных файлов для фабрик интерфейсов (.h)
+ fctr.h
//#UC START# *4705C5490109for470F512D003E*
= AbstractInterface::Class;fctr.h
//#UC END# *4705C5490109for470F512D003E*

// перекрытие базового стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор файлов реализации C++ (.cpp)
+ cpp
//#UC START# *47022CB8034Bfor470F512D003E*
F class %SN;
	%f_interface_implementation(%S)

f _dump_factory_impl_cpp
	<{}{"%f_is_factory(%C)"="true"}{%C}
	%CX
	><{}{"%ga"="abstract"}%g<{}{"%f_is_factory(%C)"="true"}{%C}
	%t_dump_derived_abstract_factory_cpp(%C)
	>>


t _dump_derived_abstract_factory_cpp
c                            {}
r "%SS"="factory":           {%{INT}%f_dump_factory_operation_cpp(%S)}
r "%SS"="multi factory":     {%{INT}%f_dump_multi_factory_operation_cpp(%S)}
r "%SS"="remover":           {%f_dump_remover_operation_cpp(%S)}
r ""="":                     {}

f _dump_inherited_factory_cpp
	[<{}{%f_is_interface(%R)=true}%f_set_var(FACTORY_PARENT,R)%R<{}{"%f_is_factory(%C)"="true"}{%C}
	%t_dump_derived_factory_cpp(%C)
	>%R<{}{"%ga"="abstract"}%g<{}{"%f_is_factory(%C)"="true"}{%C}
	%t_dump_derived_factory_cpp(%C)
	>>>]%f_set_var(SERV,"")

t _dump_derived_factory_cpp
c                            {}
r "%SS"="factory":           {%f_dump_derived_factory_operation_cpp(%S)}
r "%SS"="multi factory":     {%f_dump_derived_multi_factory_operation_cpp(%S)}
r "%SS"="remover":           {%f_dump_derived_remover_operation_cpp(%S)}
r ""="":                     {}

f _fctr_mng_fctr_cpp_impl
	%t_ret(%{INT},"[{%{INT}S!=ServerInterface}%f_factory_target_strereotype(%S,"%1N")]") %{INT}NFactoryManager::%SN%2N (<{, }%f_arg_full_decl(%C)>) [{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{throw (CORBA::SystemException, CoreSrv::NoActiveFactory[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)}/*throw (Core::Root::NoActiveFactory[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/] \
	{[{%f_is_it_cached(%S)=false}
		if (m_single_active_factory.is_nil()) {
			throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
		}
		%t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Ss]") ret_ = m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%1N=read-only}{false}true]]);
		GDS_ASSERT_MSG (ret_ != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
		[{%{INT}S=ServerInterface&%1N=read-only}{return [{%1N=read-only}{ret_}new %{INT}NConstWrapper (ret_)];}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (ret_);
		return wrapper-\>_this ();]
	][{%TS!=FactoryMemory}[{%f_is_it_cached(%S)=true}[{%Cx=true}
		GUARD(m_mutex_for_%SN);
		CachedObjectsFor%f_to_borland(%SN)::iterator f = m_cached_objects_for_%SN.find (ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>));
		if (f == m_cached_objects_for_%SN.end()[{%S{const_type}=combo|%S{const_type}=read-only} || f-\>second[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.ptr()] == 0]) {
		[{%S{const_type}=combo&%1N=read-only|%S{const_type}=read-only}{	if (m_single_active_factory.is_nil()) {
				throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
			}
			f = m_cached_objects_for_%SN.insert (
				CachedObjectsFor%f_to_borland(%SN)::value_type(
					ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
					, m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%1N=read-only}{false}true]])
/					,[{%S{const_type}!=read-write}{ m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}, [{%1N=read-only}{false}true]])} ComboData[{%Ss=synchro}{Var}Ptr] (m_single_active_factory-\>%SN (<{, }%CN>))]
				)
			).first;
			m_cached_objects_index_for_%SN.insert (
				CachedObjectsIndexFor%f_to_borland(%SN)::value_type (
					f-\>second[.%t_cache_postfix(%S,"read-write")][{%f_is_server_type(%{INT})=true}{[{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
					, f
				)
			);[{%Ss=synchro}
			return f-\>second[.%f_cache_postfix(%S,"%1N")];]
		}	if (f == m_cached_objects_for_%SN.end()) {
				if (m_single_active_factory.is_nil()) {
					throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
				}
				f = m_cached_objects_for_%SN.insert (
					CachedObjectsFor%f_to_borland(%SN)::value_type(
						ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
						, ComboData[{%Ss=synchro}{Var}Ptr] (m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%1N=read-only}{false}true]]))
					)
				).first;
				m_cached_objects_index_for_%SN.insert (
					CachedObjectsIndexFor%f_to_borland(%SN)::value_type (
						f-\>second[.%t_cache_postfix(%S,"read-write")][{%f_is_server_type(%{INT})=true}{[{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
						, f
					)
				);
				[{%{INT}S=ServerInterface}{f-\>second[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()]);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()]);
				f-\>second[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
				f-\>second.is_ro_first = true;[{%Ss=synchro}
				GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.in ()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
				return f-\>second[.%f_cache_postfix(%S,"read-only")];]
			} else if (f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr ()] == 0) {
				[{%{INT}S=ServerInterface&%S#f_is_export()=true}{f-\>second[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()])
				);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()])
				);
				f-\>second[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();][{%Ss=synchro}
				GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.in ()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
				return f-\>second[.%f_cache_postfix(%S,"read-only")];]
			}]
		}[{%f_is_ro_fctr_exists(%S)=true&%1N=read-write} else if (
			f != m_cached_objects_for_%SN.end()
			&& f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr ()] != 0
			&& f-\>second.is_ro_first == true
		) {
			f-\>second[.%f_cache_postfix(%S,"read-only")]-\>upgrade_rw ();
			f-\>second.is_ro_first = false;
		}]
		GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.in ()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
		return [{[{%{INT}S!=ServerInterface}{[{%S#f_is_export()=true}{true}false]}true]=true&%Ss!=synchro}{%{INT}N::_duplicate(f-\>second[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.in ()])}*f-\>second[.%f_cache_postfix(%S,"%1N")]];
	][{%Cx=false}
		if (m_cached_object_for_%SN[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.ptr()] == 0) {
			GUARD(m_mutex_for_%SN);
			if (m_cached_object_for_%SN[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.ptr()] == 0) {
			[{%S{const_type}=combo&%1N=read-only|%S{const_type}=read-only}{	if (m_single_active_factory.is_nil()) {
					throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
				}
				m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")] = m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%1N=read-only}{false}true]]);
			}	if (m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.ptr()] == 0) {
					if (m_single_active_factory.is_nil()) {
						throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
					}
					m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")] = m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%1N=read-only}{false}true]]);
					[{%{INT}S=ServerInterface&%S#f_is_export()=true}{m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
						m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
					);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
						m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
					);
					m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();][{%f_is_ro_fctr_exists(%S)=true}
					m_cached_object_for_%SN.is_ro_first = true;]
				} else {
					[{%{INT}S=ServerInterface&%S#f_is_export()=true}{m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
						%{INT}N::_duplicate (m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()])
					);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
						%{INT}N::_duplicate (m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()])
					);
					m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
				}
			]
				GDS_ASSERT_MSG (m_cached_object_for_%SN[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.ptr()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));[{%Ss=synchro}
				return m_cached_object_for_%SN[.%f_cache_postfix(%S,"%1N")];]
			}
		}[{%f_is_ro_fctr_exists(%S)=true&%1N=read-write}
		if (
			m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr()] != 0
			&& m_cached_object_for_%SN.is_ro_first == true
		) {
			m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")]-\>upgrade_rw ();
			m_cached_object_for_%SN.is_ro_first = false;
		}]
		return [{[{%{INT}S!=ServerInterface}{[{%S#f_is_export()!=true}{false}true]}true]=true&%Ss!=synchro}{%{INT}N::_duplicate(m_cached_object_for_%SN[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.in ()])}*m_cached_object_for_%SN[.%f_cache_postfix(%S,"%1N")]];
	]]][{%TS=FactoryMemory}
	%f_fctr_mng_mem_cpp(%S,"%1N")
	]}
//#UC END# *47022CB8034Bfor470F512D003E*

// перекрытие базового стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор заголовочных файлов C++ (.h)
+ h
//#UC START# *47022C88029Ffor470F512D003E*
F class %SN;
	%f_interface_declaration(%S)

f _dump_interface_friend
	[<{}{"%aM"="Interface::Class::friend::ClassDependency"}{Sp}[%f_get_all_consumer_list(%a%P)%a%P<{}{%f_is_empty(CONSUMER_LIST)=false}{W}%f_pop_first_to_var(CONSUMER_LIST,TEMP)[{%{TEMP}S=Servant}#	friend class %f_type(%{TEMP});
	]>]>][{<{}{%CV!=PublicAccess&[{%CC=Operation|%CC=Attribute}{false}true]=true}{%CC}>!=0}%f_get_all_consumer_list(%S)%f_set_var(INT,S)<{}{%f_is_empty(CONSUMER_LIST)=false}{W}%f_pop_first_to_var(CONSUMER_LIST,TEMP)[{%{TEMP}S=LocalInterface&%{TEMP}a!=abstract&[{%f_need_const_wrapper(%{TEMP})=true|%f_need_const_wrapper(%{INT})=true}{false}true]=true}#	friend class %f_type(%{TEMP})ConstWrapper;
	]>][{%f_need_const_wrapper(%S)=true&%f_has_factory_methods(%S)=true}#	friend class %f_type(%S)ConstWrapper;
	]
//#UC END# *47022C88029Ffor470F512D003E*

// перекрытие базового стереотипа Java::MDAGenerator
// генератор реализации фабрик интерфейсов на java (.java)
+ fctr.java
//#UC START# *470321C1038Afor470F512D003E*
= AbstractInterface::Class;fctr.java
//#UC END# *470321C1038Afor470F512D003E*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

: Interface::Class::factory_op::Operation*
? базовый стереотип для фабричных методов
= AbstractInterface::Class::factory::Operation

// Функции стереотипа
%f _st_space_key
	MDP


: Interface::Class::factory::Operation
? Фабрика (одиночная)
? Будет создан абстрактный интерфейс фабрики, который будут реализовывать конкретные фабрики (по одной на каждый сервант), создающие соответствующие серванты.
? Конкретные фабрики мугут инициализироваться своими специфичными параметрами. Созданные конкретные фабрики будут регистрироваться в менеджере фабрик.
? Последний осуществляет выбор нужной "активной" фабрики при получении запроса на создание экземпляра объекта.
? Для ОДИНОЧНОЙ фабрики - активной может быть только ОДНА такая фабрика - кто последний зарегистрировался тот и активен. Если указан тип фабричного метода, то это означает что данная фабрика будет использовать общую "память". Если фабрика, использующая "общую память", не содержит ни одного параметра-ключа, то считается что это т.н. "создающая" фабрика, т.е. фабрика, которая создает новый объект, и он при создании самостоятельно должен получить идентифицирующий его ключ.
= Interface::Class::factory_op::Operation

// Параметры стереотипа
v +#
/ - типы видимости
Y code_factory.gif
L code_factory
m f
/ - не может быть реализован/иметь перекрытую реализацию
A const|cached|const,cached|synchro
/ - стереотипы "цели" (типа/результата)

// Пользовательские свойства
p const_type=read-write|read-only|combo ? Тип константности фабрики: read-write - в этом случае возвращается объект с полными правами. read-only - в этом случае возвращается объект только для чтения, т.е без возможности вызвать изменяющие его операции. combo (комбинированая) - в этом случае реально будет сгенерированно две фабрики, read-write и read-only, но как-бы с "общей памятью", т.е. повторный вызов каждой из них вернет один и тот же объект, но с разными правами.
p force use const arg:b=false ? Если установлен флаг "force const arg", то все параметры в фабрики передаются как "in", в противном случае параметры передаются с указанными спецификаторами. Если установлен для фабрики флаг "force const arg" и фабрика емеет две версии RW и RO, то для серванта реализующего соответствующий интерфейс генериться 2 конструктора.

// Генераторы
// генератор файлов реализации C++ (.cpp)
+ cpp
//#UC START# *47022CB8034Bfor470F576D0203*
	%P%f_dump_factory_operation_cpp(%S)

f _dump_derived_factory_operation_cpp
	[{%S{const_type}=combo}{%f_dump_derived_factory_operation_cpp_impl(%S)}%f_dump_derived_factory_operation_cpp_impl(%S,"read-write")
	
	%f_dump_derived_factory_operation_cpp_impl(%S,"read-only","_ro")]

f _dump_derived_factory_operation_cpp_impl
	%f_set_var(OPERATION_CPP,"%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{SERV}NFactory::%SN%2N (%S%f_factory_params("%1N")) /*throw (Core::Root::NoActiveFactory, Core::Root::FactoryManagerWasDestroyed[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/ {")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_CPP}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_CPP}N}%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{SERV}NFactory::%SN%2N (\n\t<{\n\t, }%f_arg_full_decl(%C)>\n) /*throw (Core::Root::NoActiveFactory, Core::Root::FactoryManagerWasDestroyed[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/ {]
	%f_dump_derived_factory_return_impl(%S)
	}

f _dump_derived_factory_return_impl
	[{%{INT}S=LocalInterface&%{FACTORY_PARENT}S=ServerInterface}{\
	[{%{INT}U!=%{FACTORY_PARENT}U}{	return %f_type(%{FACTORY_PARENT})Factory::%SN%2N (<{, }%CN>);}\
	%f_set_var(__RET__,"%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")")")\
	[{%f_substr_from_end(%{__RET__}N,1)=%f_logic_and(%S)}{	%{__RET__}N ret = dynamic_cast\<%{__RET__}N\> (%f_type(%{FACTORY_PARENT})Factory::%SN%2N (<{, }%CN>));
		if (ret == 0) {
			throw Core::Root::NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
		}
		return ret;}\
		try {
			return dynamic_cast\<%{__RET__}N\> (%f_type(%{FACTORY_PARENT})Factory::%SN%2N (<{, }%CN>));
		} catch (std::bad_cast&) {
			throw Core::Root::NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
		}
	]]}\
	[{%f_is_it_cached(%S)=true}{\
			PortableServer::ServantBase_var serv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (
				%f_type(%{FACTORY_PARENT})Factory::%SN%2N (<{, }%CN>)
			);
			%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") ret = dynamic_cast\<%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")")\> (serv.in ());
			
			if (ret == 0) {
				throw Core::Root::NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
			}
			
			return ret;}	try {
			PortableServer::ServantBase_var serv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (
				&%f_type(%{FACTORY_PARENT})Factory::%SN%2N (<{, }%CN>)
			);
			return dynamic_cast\<%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")")\> (*serv.in ());
		} catch (std::bad_cast&) {
			throw Core::Root::NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
		}]]
//#UC END# *47022CB8034Bfor470F576D0203*

// генератор заголовочных файлов C++ (.h)
+ h
//#UC START# *47022C88029Ffor470F576D0203*
	%P%f_dump_factory_operation_h(%S)

f _factory_target_strereotype
	%t_factory_target_strereotype(%S,"%S{const_type}","%1N")

t _factory_target_strereotype
c                     {}    {read-write}  {read-only}     {combo}
r {%Ss=cached}:       {}    {%Ss}         {const,%Ss}     {%t_factory_target_strereotype(%S,"%2N")}
r {"%Ss"=""}:         {}    {%Ss}         {const}         {%t_factory_target_strereotype(%S,"%2N")}
r {syncro}:           {}    {%Ss}         {const}         {%t_factory_target_strereotype(%S,"%2N")}
//#UC END# *47022C88029Ffor470F576D0203*

// генератор классов, интерфейсов на java (.java)
+ java
//#UC START# *470321950119for470F576D0203*
	%f_docs(%S)\
	%S%f_dump_factory_operation()[{%S%f_is_cached()=true&%Cx=true}
	
	#public static java.util.Collection\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\> %f_to_java(get_cached_objects_for_%SN) () {
	#	[{%{FACTORY_PARENT}U!=%{INT}U}{return %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(get_cached_objects_for_%SN) ();}java.util.Collection\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\> res = new java.util.ArrayList\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\> ();
	#	for ([{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{FACTORY_PARENT})}java.lang.ref.WeakReference\<%t_ret(%{FACTORY_PARENT})\> ] item: %f_type(%{FACTORY_PARENT})FactoryManager.getInstance%{FACTORY_PARENT}U ().%f_to_java(get_cached_objects_for_%SN) ()) {
	#		%f_type(%{FACTORY_PARENT}) obj = item[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}.get ()];
	#		if (obj != null && (obj instanceof %f_type(%{INT}))) {
	#			[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{res.add ((%f_type(%{INT}))obj);}res.add (
	#				new java.lang.ref.WeakReference\<%f_type(%{INT})\> (
	#					(%f_type(%{INT}))obj
	#				)
	#			);]
	#		}
	#	}
	#	return res;]
	#}]

%f _abstract_factory_operation_java
	%f_set_var(SELF_FCTR_PARAMS,"%S%f_factory_params("%1N")")\
	%f_set_var(FCTR_MEM_PARAM,"[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}%t_arg(%T,"inout") memKey]")\
	%f_set_var(RO_PARAM,"[{%S{const_type}=combo}boolean roMode]")\
	%f_set_var(FCTR_ALL_PARAMS,"%f_merge_string(", ","%{SELF_FCTR_PARAMS}N","%{FCTR_MEM_PARAM}N","%{RO_PARAM}N")")\
			public %t_ret(%{INT}) %f_to_java(%SN)%2N (%{FCTR_ALL_PARAMS}N)[ throws <{, }%f_type(%E)>];

//#UC END# *470321950119for470F576D0203*

// Функции стереотипа
%f _st_space_key
	MDP

%f _wiki_up_print
	%S#[inherited][{"%S{const_type}"!="%S{!const_type}"}%f_up_prefix(%S) *const_type* = *%S{const_type}* - Тип константности фабрики: read-write - в этом случае возвращается объект с полными правами. read-only - в этом случае возвращается объект только для чтения, т.е без возможности вызвать изменяющие его операции. combo (комбинированая) - в этом случае реально будет сгенерированно две фабрики, read-write и read-only, но как-бы с "общей памятью", т.е. повторный вызов каждой из них вернет один и тот же объект, но с разными правами.
	][{"%S{force use const arg}"!="%S{!force use const arg}"}%f_up_prefix(%S) *force use const arg* = *%S{force use const arg}* - Если установлен флаг "force const arg", то все параметры в фабрики передаются как "in", в противном случае параметры передаются с указанными спецификаторами. Если установлен для фабрики флаг "force const arg" и фабрика емеет две версии RW и RO, то для серванта реализующего соответствующий интерфейс генериться 2 конструктора.
	]

// дампит код реализации фабричного метода ("создающего") для менеджера фабрик в случае
// использования общей памяти
%f _fctr_mng_factory_mem_create_impl
//#UC START# *4757C7C4005Afor470F576D0203*
	#		if (singleActiveFactory_ == null) {
	#			throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");
	#		}
	#		[{%2N!=read-only}{%t_ret(%{INT}) obj}res] = singleActiveFactory_.%f_to_java(%SN) (<%f_to_java(%CN), >memKey);[{%T%f_use_for_multi_factory()=true}
	#		memKey.keyArg_ = singleActiveFactory_.key ();]
	#		assert(%f_to_java(%TNMap)_.get (memKey) != null);
	[{%f_is_ro_fctr_exists(%S)=false}{%f_create_new_combo_data(%S,"%2N")}
	#		%f_to_java(%TNMap)_.put (memKey, [{%T%f_use_for_synchro_factory()=true}{res}new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (res)]);
	#		%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{[{%T%f_use_for_synchro_factory()=true}{res}res.hashCode ()]}res._hash (Integer.MAX_VALUE)], memKey);]

f _create_new_combo_data
	#		[{%T%f_use_for_multi_factory()=true}{%t_fctr_manager_cache_value(%{INT},"var",%S) data = new %t_fctr_manager_cache_value(%{INT},"var",%S) (
	#			[{%1N!=read-only}{obj}res]
	#		);[{%1N=read-only}
	#		data[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (data[.%f_cache_postfix(%S,"read-write")]);
	#		data.isRoFirst = true;]}%t_fctr_manager_cache_value(%{INT},"type",%S) data = new %t_fctr_manager_cache_value(%{INT},"type",%S) (
	#			new java.lang.ref.WeakReference\<%f_type(%{INT})\> ([{%1N!=read-only}{obj}res])
	#		);[{%1N=read-only}
	#		res = new %{INT}NConstWrapper (data[.%f_cache_postfix(%S,"read-write")].get ());
	#		data[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (res);
	#		data.isRoFirst = true;]]
	#		%f_to_java(%TNMap)_.put (memKey, data);
	#		%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{data[.%f_cache_postfix(%S,"read-write")][{%T%f_use_for_synchro_factory()=true}.hashCode ()]}data[.%f_cache_postfix(%S,"read-write")][{%T%f_use_for_synchro_factory()=true}.get ()]._hash (Integer.MAX_VALUE)], memKey);
//#UC END# *4757C7C4005Afor470F576D0203*

// дампит код реализации фабричного метода (не "создающего") для менеджера фабрик в случае
// использования общей памяти
%f _fctr_mng_factory_mem_java_impl
//#UC START# *4757C6DA0040for470F576D0203*
	#			[{%2N=read-only}{if (singleActiveFactory_ == null) {
	#				throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");
	#			}
	#			res = [{%T%f_use_for_synchro_factory()=false&%f_is_ro_fctr_exists(%S)=true}{singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>);}new %t_fctr_manager_cache_value(%{INT},"var",%S) (
	#				singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>)
	#			);][{%T%f_use_for_synchro_factory()=true}{
	#			%f_to_java(%TNMap)_.put (memKey, res);
	#			%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{res[.%f_cache_postfix(%S,"read-write")]}res[.%f_cache_postfix(%S,"read-write")]._hash (Integer.MAX_VALUE)], memKey);}
	#			ref = [{%f_is_ro_fctr_exists(%S)=true}{new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (res);}new %t_fctr_manager_cache_value(%{INT},"type",%S) (
	#				new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (res)
	#			);]
	#			%f_to_java(%TNMap)_.put (memKey, ref);
	#			%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{res.hashCode ()}ref[.%f_cache_postfix(%S,"read-write")].get ()._hash (Integer.MAX_VALUE)], memKey);\
	]}[{%T%f_use_for_synchro_factory()=true}{if (res != null && res[.%f_cache_postfix(%S,"read-write")] != null) {
	#				res[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (res[.%f_cache_postfix(%S,"read-write")]);
	#			} else {
	#				if (singleActiveFactory_ == null) {
	#					throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");
	#				}
	#				res = new %t_fctr_manager_cache_value(%{INT},"var",%S) (singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>));
	#				res[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (res[.%f_cache_postfix(%S,"read-write")]);
	#				res.isRoFirst = true;
	#				%f_to_java(%TNMap)_.put (memKey, res);
	#				%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{res[.%f_cache_postfix(%S,"read-write")]}res[.%f_cache_postfix(%S,"read-write")].get ()._hash (Integer.MAX_VALUE)], memKey);
	#			}\
	}if (ref != null && ref[.%f_cache_postfix(%S,"read-write")] != null && ref[.%f_cache_postfix(%S,"read-write")].get () != null) {
	#				res = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
	#				ref[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (res);
	#			} else {
	#				if (singleActiveFactory_ == null) {
	#					throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");
	#				}
	#				%t_ret(%{INT}) obj = singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>);
	#				ref = new %t_fctr_manager_cache_value(%{INT},"type",%S) (
	#					new java.lang.ref.WeakReference\<%f_type(%{INT})\> (obj)
	#				);
	#				res = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
	#				ref[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (res);
	#				ref.isRoFirst = true;
	#				%f_to_java(%TNMap)_.put (memKey, ref);
	#				%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{ref[.%f_cache_postfix(%S,"read-write")].get ().hashCode ()}obj._hash (Integer.MAX_VALUE)], memKey);
	#			}]]
//#UC END# *4757C6DA0040for470F576D0203*

// дампит код дополнительной  инициализации ключа общей памяти (инициализирует ключ фабрики
// серванта)
%f _init_factory_mem_key_java_impl
//#UC START# *4757C67E03A1for470F576D0203*
	[{%T%f_use_for_multi_factory()=true}\
	#		if (singleActiveFactory_ != null) {
	#			memKey.keyArg_ = singleActiveFactory_.key ();
	#		} else {
	#			throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");
	#		}]
//#UC END# *4757C67E03A1for470F576D0203*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа AbstractInterface::Class::factory::Operation
%f _is_factory
//#UC START# *4B794201038Afor470F576D0203*
	true
//#UC END# *4B794201038Afor470F576D0203*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// генерация  метода на интерфейсе абстрактной фабрики
%f _abstract_factory_operation
//#UC START# *4B793F8302B9for470F576D0203*
	[{%XU=fctr.java}%f_set_var(SELF_FCTR_PARAMS,"%S%f_factory_params("%1N")")\
	%f_set_var(FCTR_MEM_PARAM,"[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}%t_arg(%T,"inout") memKey]")\
	%f_set_var(RO_PARAM,"[{%S{const_type}=combo}boolean roMode]")\
	%f_set_var(FCTR_ALL_PARAMS,"%f_merge_string(", ","%{SELF_FCTR_PARAMS}N","%{FCTR_MEM_PARAM}N","%{RO_PARAM}N")")\
			public %t_ret(%{INT}) %f_to_java(%SN)%2N (%{FCTR_ALL_PARAMS}N)[ throws <{, }%f_type(%E)>];]
//#UC END# *4B793F8302B9for470F576D0203*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// генерация статического метода на фабрике инетрфейса
%f _dump_factory_operation
//#UC START# *4B793FC10112for470F576D0203*
	[{%S{const_type}=combo}{%S%f_dump_factory_operation_impl()}%S%f_dump_factory_operation_impl("read-write")
	
	%S%f_dump_factory_operation_impl("read-only","Ro")]

%f _dump_factory_operation_impl
	[{%XU=java}[{%S%f_is_cached()=true}#// Фабрика возвращает кэшированный экземпляр!
	]#%t_visibility(%S,"%XU")static %t_ret(%{INT},"%Ss") %f_to_java(%SN)%2N (%S%f_factory_params("%1N")) throws NoActiveFactory[{%f_need_conversion_exception(%S)=true}, ru.garant.shared.Core.Root.ImpossibleConversion]<, %f_type(%E)> {
	[{%{INT}U!=%{FACTORY_PARENT}U}{#	return %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN)%2N (<{, }%f_to_java(%CN)>);}\
	#	%f_type(%{FACTORY_PARENT}) ret = %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN)%2N (<{, }%f_to_java(%CN)>);
	#	if (ret instanceof %f_type(%{INT})) {
	#		return (%f_type(%{INT})) ret;
	#	} else {
	#		throw new NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
	#	}]
	#}]
//#UC END# *4B793FC10112for470F576D0203*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// дампит реализацию конкретной read-write или read-only фабрики для менеджера фабрик, в качестве
// дополнительного параметра передается read-write или read-only в зависимости от того, какую
// фабрику нужно сдампить
%f _factory_mng_factory_impl_java
//#UC START# *4B793D3F0059for470F576D0203*
	%f_set_var(SELF_FCTR_PARAMS,"%S%f_factory_params("%2N")")\
	%f_set_var(FCTR_MEM_PARAM,"[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}%t_arg(%T,"inout") memKey]")\
	%f_set_var(RO_PARAM,"[{%S{const_type}=combo}boolean roMode]")\
	%f_set_var(FCTR_ALL_PARAMS,"%f_merge_string(", ","%{SELF_FCTR_PARAMS}N","%{FCTR_MEM_PARAM}N","%{RO_PARAM}N")")\
		public %t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Ss]")[{%{INT}S!=ServerInterface&%2N=read-only}ConstWrapper] [{%{INT}S!=ServerInterface}{%SN%3N}%f_to_java(%SN%3N)] (%{SELF_FCTR_PARAMS}N) throws [{%f_is_server_type(%S)=true}ru.garant.shared.CoreSrv.]NoActiveFactory[{%f_need_conversion_exception(%S)=true}, ru.garant.shared.Core.Root.ImpossibleConversion]%S<, %f_type(%E)> {[{%f_is_it_cached(%S)=false}
			if (singleActiveFactory_ == null) {
				throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%{INT}%PN.%{INT}NFactory");
			}
			[{%f_is_server_type(%{INT})=true&%2N=read-only}{return [{%2N=read-only}{singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%S{const_type}=combo}[{%Cx=true}, ]false])}new %{INT}NConstWrapper (
				singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%S{const_type}=combo}[{%Cx=true}, ]true])
			)];}try {
				org.omg.CORBA.Object obj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(
					new %{INT}NConstWrapper (
						singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%S{const_type}=combo}[{%Cx=true}, ]true])
					)
				);
				return %f_type(%{INT})Helper.narrow (obj);
	[<{}{}{%E}\
			} catch (%f_type(%E) ex) {
				Logs.LOG_SEX(ex);
				throw ex;
	>]\
			} catch (Exception ex) {
				Logs.LOG_SEX(ex);
				throw new org.omg.CORBA.portable.UnknownException (ex);
			}]
	][{%f_is_it_cached(%S)=true}[{%TS!=FactoryMemory}{\n%f_fctr_mng_mem_java(%S,"%2N")}[{%Cx=true}
			synchronized (cachedObjectsFor%f_to_borland(%SN)) {
				ObjectCreationIdFor%f_to_borland(%SN) key = new ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%f_to_java(%CN)>);
				[{%Ss=synchro}{%t_fctr_manager_cache_value(%{INT},"var",%S)}%t_ret(%{INT})[{%2N=read-only}ConstWrapper]] ret = [{%Ss=synchro}{cachedObjectsFor%f_to_borland(%SN).get (key);}null;
				%t_fctr_manager_cache_value(%{INT},"type",%S) ref = cachedObjectsFor%f_to_borland(%SN).get (key);
				if (ref != null) {
					ret = ref[.%f_cache_postfix(%S,"%2N")].get ();
				}]
				if (ret == null[{%f_is_ro_fctr_exists(%S)=true&%Ss!=synchro} || ret[.%f_cache_postfix(%S,"%2N")] == null]) {
				[{%2N=read-only}{	if (singleActiveFactory_ == null) {
						throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%{INT}%PN.%{INT}NFactory");
					}
					ret = [{%Ss!=synchro&%f_is_ro_fctr_exists(%S)=true}{singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>)[{%S{const_type}=combo}[{%Cx=true}, ]false]}new %t_fctr_manager_cache_value(%{INT},"var",%S) (
						singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%S{const_type}=combo}[{%Cx=true}, ]false])
					)];[{%Ss=synchro}
					ref = [{%f_is_ro_fctr_exists(%S)=true}{new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (ret)}new %t_fctr_manager_cache_value(%{INT},"type",%S) (
						new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (ret)
					);]]
					cachedObjectsFor%f_to_borland(%SN).put (key, [{%Ss=synchro}{ret}ref]);
					cachedObjectsIndexFor%f_to_borland(%SN).put ([{%f_is_server_type(%{INT})=false}{ret[{%Ss!=synchro}[.%f_cache_postfix(%S,"read-write")]]._hash (Integer.MAX_VALUE)}[{%Ss=synchro}{ret}ref][.%f_cache_postfix(%S,"read-write")]], key);
				}	if ([{%Ss=synchro}{ret != null && ret[.%f_cache_postfix(%S,"read-write")] != null}ref != null && ref[.%f_cache_postfix(%S,"read-write")] != null && ref[.%f_cache_postfix(%S,"read-write")].get () != null]) {
						[{%{INT}S=ServerInterface}{[{%Ss=synchro}{ret[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (ret[.%f_cache_postfix(%S,"read-write")])}ret = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
						ref[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (
							ret
						)];}%{INT}NConstWrapper wrapper [{%Ss=synchro}{= new %{INT}NConstWrapper (ret[.%f_cache_postfix(%S,"read-write")])}ret = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
						= new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (
							ret
						)];
						try {
							org.omg.CORBA.Object refObj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(wrapper);
							[{%Ss=synchro}{ret[.%f_cache_postfix(%S,"read-only")]}ref[.%f_cache_postfix(%S,"read-only")]] = %f_type(%{INT})Helper.narrow (refObj);
	[<{}{}{%E}\
						} catch (%f_type(%E) ex) {
							Logs.LOG_SEX(ex);
							throw ex;
	>]\
						} catch (Exception ex) {
							Logs.LOG_SEX(ex);
							throw new org.omg.CORBA.portable.UnknownException (ex);
						}]
					} else {
						if (singleActiveFactory_ == null) {
							throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%{INT}%PN.%{INT}NFactory");
						}
						[{%Ss!=synchro}{%t_ret(%{INT}) obj}ret] = [{%Ss!=synchro&%f_is_ro_fctr_exists(%S)=true}{singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>)[{%S{const_type}=combo}[{%Cx=true}, ]true]}new %t_fctr_manager_cache_value(%{INT},"var",%S) (
							singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%S{const_type}=combo}[{%Cx=true}, ]true])
						)];[{%Ss=synchro}{
						[{%{INT}S=ServerInterface}{ret[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (ret[.%f_cache_postfix(%S,"read-write")]);}%{INT}NConstWrapper wrapper = new %{INT}NConstWrapper (ret[.%f_cache_postfix(%S,"read-write")]);
						try {
							org.omg.CORBA.Object refObj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(wrapper);
							ret[.%f_cache_postfix(%S,"read-only")] = %f_type(%{INT})Helper.narrow (refObj);
	[<{}{}{%E}\
						} catch (%f_type(%E) ex) {
							Logs.LOG_SEX(ex);
							throw ex;
	>]\
						} catch (Exception ex) {
							Logs.LOG_SEX(ex);
							throw new org.omg.CORBA.portable.UnknownException (ex);
						}]
						ret.isRoFirst = true;}
						ref = new %t_fctr_manager_cache_value(%{INT},"type",%S) (
							new java.lang.ref.WeakReference\<%f_type(%{INT})\> ([{%Ss!=synchro}{obj}ret])
						);
						ret = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
						ref[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (
							ret
						);
						ref.isRoFirst = true;]
						cachedObjectsFor%f_to_borland(%SN).put (key, [{%Ss=synchro}{ret}ref]);
						cachedObjectsIndexFor%f_to_borland(%SN).put ([{%f_is_server_type(%{INT})=false}{[{%Ss!=synchro}{obj}ret[.%f_cache_postfix(%S,"read-write")]]._hash (Integer.MAX_VALUE)}[{%Ss=synchro}{ret}ref][.%f_cache_postfix(%S,"read-write")][{%Ss=synchro}.hashCode ()]], key);
					}]
				}[{%f_is_ro_fctr_exists(%S)=true&%2N=read-write} else if (
					[{%Ss=synchro}{ret[.%f_cache_postfix(%S,"read-only")] != null
					&& ret.isRoFirst == true}ref != null
					&& ref[.%f_cache_postfix(%S,"read-only")] != null
					&& ref[.%f_cache_postfix(%S,"read-only")].get () != null
					&& ref.isRoFirst == true]
				) {
					[{%Ss=synchro}{ret[.%f_cache_postfix(%S,"read-only")].upgrade_rw ();
					ret.isRoFirst = false;}ref[.%f_cache_postfix(%S,"read-only")].get ().upgrade_rw ();
					ref.isRoFirst = false;]
				}]
/				[{%f_is_server_type(%{INT})=true&%2N=read-only&%Ss!=synchro}{return ret[{%Ss!=synchro}[.%f_cache_postfix(%S,"%2N")]];}try {
/					org.omg.CORBA.Object obj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(ret[{%Ss!=synchro}[.%f_cache_postfix(%S,"%2N")]]);
/					return %f_type(%{INT})Helper.narrow (obj);
/				} catch (Exception ex) {
/					Logs.LOG_SEX (ex);
/				}
/				return null;]
				return ret[{%Ss!=synchro}[.%f_cache_postfix(%S,"%2N")]];
			}
	][{%Cx=false}[{%Ss=synchro}
			%t_ret(%{INT})[{%2N=read-only}ConstWrapper] ret = null;]
			if (cachedObjectFor%f_to_borland(%SN) == null[{%f_is_ro_fctr_exists(%S)=false}{ || cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"%2N")] == null[{%Ss=synchro} || cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"%2N")].get () == null]}[{%Ss=synchro} || cachedObjectFor%f_to_borland(%SN).get () == null]]) {
				synchronized (sMutexFor%f_to_borland(%SN)) {
					if (cachedObjectFor%f_to_borland(%SN) == null[{%f_is_ro_fctr_exists(%S)=false}{ || cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"%2N")] == null[{%Ss=synchro} || cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"%2N")].get () == null]}[{%Ss=synchro} || cachedObjectFor%f_to_borland(%SN).get () == null]]) {
					[{%2N=read-only}{	if (singleActiveFactory_ == null) {
							throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%{INT}%PN.%{INT}NFactory");
						}
						[{%Ss=synchro}{cachedObjectFor%f_to_borland(%SN)}ret] = [{%f_is_ro_fctr_exists(%S)=true&%Ss!=synchro}{singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>);}new %t_fctr_manager_cache_value(%{INT},"var",%S) (
							singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>)
						);][{%f_is_server_type(%{INT})=true}
						cachedObjectHashFor%f_to_borland(%SN)_ = new Integer ([{%Ss=synchro}{cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")]}ret]._hash (Integer.MAX_VALUE));][{%Ss=synchro}
						cachedObjectFor%f_to_borland(%SN) = [{%f_is_ro_fctr_exists(%S)=true}{new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (ret)}new %t_fctr_manager_cache_value(%{INT},"type",%S) (
							new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (ret)
						)];]
					}	if (cachedObjectFor%f_to_borland(%SN) != null && cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")] != null[{%Ss=synchro} && cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")].get () != null]) {
							[{%{INT}S=ServerInterface}{[{%Ss=synchro}{cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")]);}ret = new %{INT}NConstWrapper(cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")].get ());
							cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (
								ret
							);]}%{INT}NConstWrapper wrapper = new %{INT}NConstWrapper (cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")]);
							try {
								org.omg.CORBA.Object refObj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(wrapper);
								cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-only")] = %f_type(%{INT})Helper.narrow (refObj);
	[<{}{}{%E}\
							} catch (%f_type(%E) ex) {
								Logs.LOG_SEX(ex);
								throw ex;
	>]\
							} catch (Exception ex) {
								Logs.LOG_SEX(ex);
								throw new org.omg.CORBA.portable.UnknownException (ex);
							}]
						} else {
							if (singleActiveFactory_ == null) {
								throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%{INT}%PN.%{INT}NFactory");
							}
							[{%Ss=synchro}{cachedObjectFor%f_to_borland(%SN)}%t_ret(%{INT}) obj] = [{%f_is_ro_fctr_exists(%S)=true&%Ss!=synchro}{singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%S{const_type}=combo}[{%Cx=true}, ]true]);}new %t_fctr_manager_cache_value(%{INT},"var",%S) (
								singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%S{const_type}=combo}[{%Cx=true}, ]true])
							);][{%f_is_server_type(%{INT})=true}[{%Ss!=synchro}
							%{INT}NConstWrapper wrapper = new %{INT}NConstWrapper (cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")]);
							try {
								org.omg.CORBA.Object refObj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(wrapper);
								cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"%2N")] = %f_type(%{INT})Helper.narrow (refObj);
	[<{}{}{%E}\
							} catch (%f_type(%E) ex) {
								Logs.LOG_SEX(ex);
								throw ex;
	>]\
							} catch (Exception ex) {
								Logs.LOG_SEX(ex);
								throw new org.omg.CORBA.portable.UnknownException (ex);
							}]
							cachedObjectHashFor%f_to_borland(%SN)_ = new Integer ([{%Ss=synchro}{cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")]}obj]._hash (Integer.MAX_VALUE));][{%Ss=synchro}
							cachedObjectFor%f_to_borland(%SN) = [{%f_is_ro_fctr_exists(%S)=true}{new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (ret)}new %t_fctr_manager_cache_value(%{INT},"type",%S) (
								new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (obj)
							)];
							ret = new %{INT}NConstWrapper (cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")].get ());
							cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-only")] = new [{%Ss=synchro}{%{INT}NConstWrapper (cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-write")])}java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (
								ret
							)];]
							cachedObjectFor%f_to_borland(%SN).isRoFirst = true;
						}
					]}
				}
			}[{%f_is_ro_fctr_exists(%S)=true&%2N=read-write}
			if (
				cachedObjectFor%f_to_borland(%SN) != null
				&& cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-only")] != null[{%Ss=synchro}
				&& cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-only")].get () != null]
				&& cachedObjectFor%f_to_borland(%SN).isRoFirst == true
			) {
				cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"read-only")][{%Ss=synchro}.get ()].upgrade_rw ();
				cachedObjectFor%f_to_borland(%SN).isRoFirst = false;
			}]
			return [{%Ss=synchro}{cachedObjectFor%f_to_borland(%SN)[.%f_cache_postfix(%S,"%2N")]}ret];
	]]]	}
//#UC END# *4B793D3F0059for470F576D0203*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// дампит реализацию фабрики для менеджера фабрик, осуществляет выбор дапить только read-only или
// read-write, или обе фабрики
%f _fctr_mng_factory_java
//#UC START# *4B793D420398for470F576D0203*
	[{%S{const_type}=combo}{%S%f_factory_mng_factory_impl_java(%S,"%S{const_type}")}%S%f_factory_mng_factory_impl_java(%S,"read-write")
	
	%S%f_factory_mng_factory_impl_java(%S,"read-only","_ro")][{%S%f_is_cached()=true&[{%SS=factory&%Cx=false}{true}false]=true}
	
		public java.util.Collection\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\> %f_to_java(get_cached_objects_for_%SN) () {
			synchronized ([{%TS!=FactoryMemory}{%f_to_java(%TNMap)_}cachedObjectsFor%f_to_borland(%SN)]) {
				[{%S{const_type}=read-only|%S{const_type}=combo}{return java.util.Collections.unmodifiableCollection (new java.util.HashSet\<%t_ret(%{INT})\> ([{%TS!=FactoryMemory}{%f_to_java(%TNMap)_}cachedObjectsFor%f_to_borland(%SN)].values ()));}java.util.Collection\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_fctr_manager_cache_value(%{INT},"var","")}%t_fctr_manager_cache_value(%{INT},"type","")]\> values = [{%TS!=FactoryMemory}{%f_to_java(%TNMap)_}cachedObjectsFor%f_to_borland(%SN)].values ();
				java.util.ArrayList\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\> res =
					new java.util.ArrayList\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\> ();
				for ([{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_fctr_manager_cache_value(%{INT},"var","")}%t_fctr_manager_cache_value(%{INT},"type","")] value: values) {
					res.add (value.rwData_);
				}
				return java.util.Collections.unmodifiableCollection (res);]
			}
		}]
//#UC END# *4B793D420398for470F576D0203*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// генерация для серванта
%f _for_servant
//#UC START# *4B7BABC802B8for470F576D0203*
//#UC END# *4B7BABC802B8for470F576D0203*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// генерация реализации для фабрики серванта
%f _for_servant_factory
//#UC START# *4B7BAB9E0209for470F576D0203*
//#UC END# *4B7BAB9E0209for470F576D0203*

// Вложенные стереотипы
: Interface::Class::factory::Operation::Parameter
? параметр фабричного метода
= AbstractFacet::Class::Operation::Parameter

// Функции стереотипа
%f _st_space_key
	MDP



: Interface::Class::remover::Operation
? Уничтожитель
? Метод обратный фабричному, т.е. метод приводящий к разрушению (временному или постоянному) созданного фабрикой объекта.
= AbstractFacet::Class::Operation

// Параметры стереотипа
v +-
/ - типы видимости
Y code_remover.gif
L code_remover
m f
/ - не может быть реализован/иметь перекрытую реализацию
A
/ - стереотипы "цели" (типа/результата)

// Генераторы
// генератор файлов реализации C++ (.cpp)
+ cpp
//#UC START# *47022CB8034Bfor470F5814038A*
/	%f_dump_remover_operation_cpp(%S)

f _dump_remover_operation_cpp
	%f_set_var(OPERATION_CPP,"void %{INT}NFactory::%SN (%t_arg(%{INT},"inout") obj_<, %CX>) /*throw (Core::Root::ForeignObject, Core::Root::FactoryManagerWasDestroyed<, %f_type(%E)>)*/ {")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_CPP}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_CPP}N}void %{INT}NFactory::%SN (\n\t%t_arg(%{INT},"inout") obj_<\n\t, %CX>\n) /*throw (Core::Root::ForeignObject, Core::Root::FactoryManagerWasDestroyed<, %f_type(%E)>)*/ {]
		return %{INT}NFactoryManager::Singleton::instance ()-\>%SN (obj_<, %CN>);
	}

f _dump_derived_remover_operation_cpp
	%f_set_var(OPERATION_CPP,"void %{SERV}NFactory::%SN (%t_arg(%{INT},"inout") obj_<, %CX>) /*throw (Core::Root::ForeignObject, Core::Root::FactoryManagerWasDestroyed<, %f_type(%E)>)*/ {")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_CPP}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_CPP}N}void %{INT}NFactory::%SN (\n\t%t_arg(%{INT},"inout") obj_<\n\t, %CX>\n) /*throw (Core::Root::ForeignObject, Core::Root::FactoryManagerWasDestroyed<, %f_type(%E)>)*/ {]
		return %f_type(%{INT})Factory::%SN (obj_<, %CN>);
	}
//#UC END# *47022CB8034Bfor470F5814038A*

// генератор заголовочных файлов C++ (.h)
+ h
//#UC START# *47022C88029Ffor470F5814038A*
	%f_dump_remover_operation_h(%S)

f _dump_remover_operation_h
	%f_docs(%S)\
	%f_set_var(OPERATION_H,"#virtual void %SN (<{, }%CX>) = 0")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_H}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_H}N\n#	/*throw (Core::Root::ForeignObject, Core::Root::FactoryManagerWasDestroyed<, %f_type(%E)>)*/;}\
	#virtual void %SN (<{\n\t\t, }%CX>\n\t) = 0/*throw (Core::Root::ForeignObject, Core::Root::FactoryManagerWasDestroyed<, %f_type(%E)>)*/;]

//#UC END# *47022C88029Ffor470F5814038A*

// генератор классов, интерфейсов на java (.java)
+ java
//#UC START# *470321950119for470F5814038A*
	%f_docs(%S)\
	#public [{%f_realize_srv_interface(%{INT})=false}{int}void] %SN (<{, }%CX>)[{%f_realize_srv_interface(%{INT})=true}{[throws <{, }%f_type(%E)>]} throws ru.garant.shared.CoreSrv.ForeignObject<, %f_type(%E)>];
//#UC END# *470321950119for470F5814038A*

// Функции стереотипа
%f _st_space_key
	MDP


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
%f _wiki_child_kind
//#UC START# *4705CBD6003Efor470F5814038A*
	mng
//#UC END# *4705CBD6003Efor470F5814038A*

// Вложенные стереотипы
: Interface::Class::remover::Operation::Parameter
? параметр
= AbstractFacet::Class::Operation::Parameter

// Генераторы
// Генерация модели в MDKnow
+ wiki
//#UC START# *46E6D4BB0339for470F643503B9*
//#UC END# *46E6D4BB0339for470F643503B9*

// генератор idl спецификаций (.idl)
+ idl
//#UC START# *47022BBE0261for470F643503B9*
//#UC END# *47022BBE0261for470F643503B9*

// генератор idl спецификаций для AMI (.idl)
+ idl_ami
//#UC START# *47022C0F01E4for470F643503B9*
//#UC END# *47022C0F01E4for470F643503B9*

// генератор inline файлов реализации C++ (.i.h)
+ i.h
//#UC START# *47022CCF00EAfor470F643503B9*
//#UC END# *47022CCF00EAfor470F643503B9*

// С++ TIE-обвязка для DLL (_tie.h)
+ dll.h
//#UC START# *47032EC4032Cfor470F643503B9*
//#UC END# *47032EC4032Cfor470F643503B9*

// С++ TIE-обвязка для DLL (_tie.cpp)
+ dll.cpp
//#UC START# *47032ED002DEfor470F643503B9*
//#UC END# *47032ED002DEfor470F643503B9*

// Родные Delphi интерфейсы (.pas)
+ intf.pas
R  
//#UC START# *470F1571031Cfor470F643503B9*
//#UC END# *470F1571031Cfor470F643503B9*

// Реализация на Delphi(.pas)
+ impl.pas
R  
//#UC START# *470F15B800CBfor470F643503B9*
//#UC END# *470F15B800CBfor470F643503B9*

// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
+ intf2.pas
R  
//#UC START# *477398E501C0for470F643503B9*
//#UC END# *477398E501C0for470F643503B9*

// 3-я секция интерфейса. Например поле для свойства.
+ intf3.pas
R  
//#UC START# *4774D2A20372for470F643503B9*
//#UC END# *4774D2A20372for470F643503B9*

// Генератор файлов форм (.dfm)
+ dfm
R  
//#UC START# *49F5795900ECfor470F643503B9*
//#UC END# *49F5795900ECfor470F643503B9*

// Ресурсы (.rc)
+ rc.pas
R  
//#UC START# *55B8D28B0157for470F643503B9*
//#UC END# *55B8D28B0157for470F643503B9*

// Скрипты в ресурсах (.rc.script)
+ rc.script.pas
R  
//#UC START# *55B8D2F80145for470F643503B9*
//#UC END# *55B8D2F80145for470F643503B9*

// Компилятор ресурса (.res.cmd)
+ res.cmd.pas
R  
//#UC START# *55B8DD9C0301for470F643503B9*
//#UC END# *55B8DD9C0301for470F643503B9*

// Функции стереотипа
%f _st_space_key
	MDP


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for470F643503B9*
c	{}
r {""=""}: {}
//#UC END# *4704C0E30186for470F643503B9*

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
%f _wiki_child_kind
//#UC START# *4705CBD6003Efor470F643503B9*
//#UC END# *4705CBD6003Efor470F643503B9*

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
%f _wiki_up_add_gen
//#UC START# *470484D50138for470F643503B9*
//#UC END# *470484D50138for470F643503B9*


: Interface::Class::factory switch::Attribute
? Селектор мультифабрики
? Определяет тип селектора и допустимые значения, в качестве селектора могут выступать все простые типы и перечисления (Enum).
= InterfaceGeneratorWithJava::MDAGenerator

// Параметры стереотипа
v +
/ - типы видимости
Y code_factory_switch.gif
L code_factory_switch
l a
/ - возможные типы связи атрибута

// Генераторы
// генератор заголовочных файлов C++ (.h)
+ h
//#UC START# *47022C88029Ffor47B13201031D*
//#UC END# *47022C88029Ffor47B13201031D*

// генератор файлов реализации C++ (.cpp)
+ cpp
//#UC START# *47022CB8034Bfor47B13201031D*
//#UC END# *47022CB8034Bfor47B13201031D*

// генератор реализации фабрик интерфейсов на java (.java)
+ fctr.java
//#UC START# *470321C1038Afor47B13201031D*
//#UC END# *470321C1038Afor47B13201031D*

// генератор заголовочных файлов для фабрик интерфейсов (.h)
+ fctr.h
//#UC START# *4705C5490109for47B13201031D*
//#UC END# *4705C5490109for47B13201031D*

// генератор файлов реализации для фабрик интерфейсов (.cpp)
+ fctr.cpp
//#UC START# *4705C54B01F4for47B13201031D*
//#UC END# *4705C54B01F4for47B13201031D*

// Функции стереотипа
%f _st_space_key
	MDP


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for47B13201031D*
c                                    {}
r {"%t_can_use_for_switch(%T)"="false"}:         {В качестве селектора могут выступать только простые типы и перечисления}
//#UC END# *4704C0E30186for47B13201031D*

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
%f _wiki_child_kind
//#UC START# *4705CBD6003Efor47B13201031D*
	property
//#UC END# *4705CBD6003Efor47B13201031D*

: Interface::Class::multi factory::Operation
? Фабрика (множественная)
? Будет создан абстрактный интерфейс фабрики, который будут реализовывать конкретные фабрики (по одной на каждый сервант), создающие соответствующие серванты.
? Конкретные фабрики мугут инициализироваться своими специфичными параметрами. Созданные конкретные фабрики будут регистрироваться в менеджере фабрик.
? Последний осуществляет выбор нужной "активной" фабрики при получении запроса на создание экземпляра объекта.
? Для МНОЖЕСТВЕННОЙ фабрики - активными являются ВСЕ зарегистрированные фабрики, выбор конкретной осущестьвляеться по ключу - дополнительному параметру. Если указан тип фабричного метода, то это означает что данная фабрика будет использовать общую "память". Если фабрика, использующая "общую память", не содержит ни одного параметра-ключа, то считается что это т.н. "создающая" фабрика, т.е. фабрика, которая создает новый объект, и он при создании самостоятельно должен получить идентифицирующий его ключ.
= Interface::Class::factory::Operation

// Пользовательские свойства
p transparent multy:b=false ? определяет, что выбор конкретной реализации будет реализован пользователем

// Генераторы
// генератор заголовочных файлов C++ (.h)
+ h
//#UC START# *47022C88029Ffor470F57A80119*
	%P%f_dump_multi_factory_operation_h(%S)

f _dump_multi_factory_operation_h_impl
	%S%f_dump_exceptions_client_fctr("EX_CLIENT_LIST")\
	[{%S{transparent multy}=false|"%S{transparent multy}"=""}%f_set_var(OPERATION_H,"#static %t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %SN%2N ([%S%f_factory_params("%1N"), ]%{INT}%f_dump_switch_arg_type() key)")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_H}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_H}N%S%f_dump_formated_exception_client_list("EX_CLIENT_LIST",", ","NEW_LINE");}#static %t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %SN%2N ([%S%f_factory_params("%1N","\n#\t","\n#"), ]%{INT}%f_dump_switch_arg_type() key\n\t)%S%f_dump_formated_exception_client_list("EX_CLIENT_LIST",", ");]][{%S{transparent multy}=true}\
	%f_set_var(OPERATION_H,"#static %t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %SN%2N (%S%f_factory_params("%1N"))")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_H}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_H}N%S%f_dump_formated_exception_client_list("EX_CLIENT_LIST",", ","NEW_LINE");}#static %t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %SN%2N (\n\t\t%S%f_factory_params("%1N","\n#\t","\n#")\n\t)%S%f_dump_formated_exception_client_list("EX_CLIENT_LIST",", ");]]

//#UC END# *47022C88029Ffor470F57A80119*

// генератор файлов реализации C++ (.cpp)
+ cpp
//#UC START# *47022CB8034Bfor470F57A80119*
	%P%f_dump_multi_factory_operation_cpp(%S)

f _dump_multi_factory_operation_cpp_impl
	%S%f_dump_exceptions_client_fctr("EX_CLIENT_LIST")\
	[{%S{transparent multy}=false|"%S{transparent multy}"=""}%f_set_var(OPERATION_CPP,"%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{INT}NFactory::%SN%2N (%S%f_factory_params("%1N")%{INT}%f_dump_switch_arg_type() key)%S%f_dump_formated_exception_client_list_cpp("EX_CLIENT_LIST",", ") {")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_CPP}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_CPP}N}%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{INT}NFactory::%SN%2N ([%S%f_factory_params("%1N","\n\t","\n\t"), ]%{INT}%f_dump_switch_arg_type() key\n)%S%f_dump_formated_exception_client_list_cpp("EX_CLIENT_LIST",", ","NEW_LINE") {]
		return %{INT}NFactoryManager::Singleton::instance ()-\>%SN%2N (<{}{%CS!=cache}%CN, >key);
	}][{%S{transparent multy}=true}\
	%f_set_var(OPERATION_CPP,"%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{INT}NFactory::%SN%2N (%S%f_factory_params("%1N"))%S%f_dump_formated_exception_client_list_cpp("EX_CLIENT_LIST",", ") {")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_CPP}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_CPP}N}%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{INT}NFactory::%SN%2N (%S%f_factory_params("%1N","\n\t","\n"))%S%f_dump_formated_exception_client_list_cpp("EX_CLIENT_LIST",", ","NEW_LINE") {]
		return %{INT}NFactoryManager::Singleton::instance ()-\>%SN%2N (<{, }{%CS!=cache}%CN>);
	}]

f _dump_derived_multi_factory_operation_cpp
	[{%S{const_type}=combo}{%f_dump_derived_multi_factory_operation_cpp_impl(%S)}%f_dump_derived_multi_factory_operation_cpp_impl(%S,"read-write")
	
	%f_dump_derived_multi_factory_operation_cpp_impl(%S,"read-only","_ro")]

f _dump_derived_multi_factory_operation_cpp_impl
	[{%S{transparent multy}=false|"%S{transparent multy}"=""}%f_set_var(OPERATION_CPP,"%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{SERV}NFactory::%SN%2N (<%CX, >%{INT}%f_dump_switch_arg_type() key) /*throw (Core::Root::UnknownFactoryKey, Core::Root::FactoryManagerWasDestroyed[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/ {")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_CPP}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_CPP}N}%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{SERV}NFactory::%SN%2N (\n\t<%CX\n\t, >%{INT}%f_dump_switch_arg_type() key\n) /*throw (Core::Root::UnknownFactoryKey, Core::Root::FactoryManagerWasDestroyed[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/ {]
	%f_dump_derived_multi_fctr_return_impl(%S)
	}][{%S{transparent multy}=true}\
	%f_set_var(OPERATION_CPP,"%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{SERV}NFactory::%SN%2N (<{, }%CX>) /*throw (Core::Root::NoActiveFactory, Core::Root::FactoryManagerWasDestroyed[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/ {")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_CPP}N")")\
	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_CPP}N}%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{SERV}NFactory::%SN%2N (\n\t<{\n\t, }%CX>\n) /*throw (Core::Root::NoActiveFactory, Core::Root::FactoryManagerWasDestroyed[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/ {]
	%f_dump_derived_multi_fctr_return_impl(%S)
	}]

f _dump_derived_multi_fctr_return_impl
	[{%{INT}S=LocalInterface&%{FACTORY_PARENT}S=ServerInterface}{\
	[{%{INT}U!=%{FACTORY_PARENT}U}{	return %f_type(%{FACTORY_PARENT})Factory::%SN%2N ([{%S{transparent multy}!=true}{<{, }%CN>}<%CN, >key]);}\
	%f_set_var(__RET__,"%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")")")\
	[{%f_substr_from_end(%{__RET__}N,1)=%f_logic_and(%S)}{	%{__RET__}N ret = dynamic_cast\<%{__RET__}N\> (%f_type(%{FACTORY_PARENT})Factory::%SN%2N ([{%S{transparent multy}!=true}{<{, }%CN>}<%CN, >key]));
		if (ret == 0) {
			throw Core::Root::NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
		}
		return ret;}\
		try {
			return dynamic_cast\<%{__RET__}N\> (%f_type(%{FACTORY_PARENT})Factory::%SN%2N ([{%S{transparent multy}!=true}{<{, }%CN>}<%CN, >key]));
		} catch (std::bad_cast&) {
			throw Core::Root::NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
		}
	]]}\
	[{%f_is_it_cached(%S)=true}{\
			PortableServer::ServantBase_var serv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (
				%f_type(%{FACTORY_PARENT})Factory::%SN%2N ([{%S{transparent multy}!=true}{<{, }%CN>}<%CN, >key])
			);
			%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") ret = dynamic_cast\<%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")")\> (serv.in ());
			if (ret == 0) {
				throw Core::Root::NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
			}
			return ret;}	try {
			PortableServer::ServantBase_var serv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (
				&%f_type(%{FACTORY_PARENT})Factory::%SN%2N ([{%S{transparent multy}!=true}{<{, }%CN>}<%CN, >key])
			);
			return dynamic_cast\<%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")")\> (*serv.in ());
		} catch (std::bad_cast&) {
			throw Core::Root::NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
		}]]
//#UC END# *47022CB8034Bfor470F57A80119*

// генератор классов, интерфейсов на java (.java)
+ java
//#UC START# *470321950119for470F57A80119*
	%f_docs(%S)\
	[{%S%f_is_cached()=true}#// Фабрика возвращает кэшированный экземпляр!
	][{%S{transparent multy}=false|"%S{transparent multy}"=""}\
//%S{transparent multy}=false
	#%t_visibility(%S,"%XU")static %t_ret(%{INT},"%Ss") %f_to_java(%SN) (<%f_arg_full_decl(%C), >%{INT}%f_dump_switch_type() key) throws UnknownFactoryKey[{%{INT}U!=%{FACTORY_PARENT}U}, NoActiveFactory][{%f_need_conversion_exception(%S)=true}, ru.garant.shared.Core.Root.ImpossibleConversion]<, %f_type(%E)> {
	[{%{INT}U!=%{FACTORY_PARENT}U}{#	return %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) (<%f_to_java(%CN), >key);}\
	#	%f_type(%{FACTORY_PARENT}) ret = %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) (<%f_to_java(%CN), >key);
	#	if (ret instanceof %f_type(%{INT})) {
	#		return (%f_type(%{INT})) ret;
	#	} else {
	#		throw new NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
	#	}]
	#}][{%S{transparent multy}=true}\
//%S{transparent multy}=true
	#%t_visibility(%S,"%XU")static %t_ret(%{INT},"%Ss") %f_to_java(%SN) (<{, }%f_arg_full_decl(%C)>) throws NoActiveFactory[{%f_need_conversion_exception(%S)=true}, ru.garant.shared.Core.Root.ImpossibleConversion]<, %f_type(%E)> {
	[{%{INT}U!=%{FACTORY_PARENT}U}{#	return %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) (<{, }%f_to_java(%CN)>);}\
	#	%f_type(%{FACTORY_PARENT}) ret = %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) (<{, }%f_to_java(%CN)>);
	#	if (ret instanceof %f_type(%{INT})) {
	#		return (%f_type(%{INT})) ret;
	#	} else {
	#		throw new NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
	#	}]
	#}][{%S%f_is_cached()=true&%Cx=true}
	
	#public static java.util.Collection\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\> %f_to_java(get_cached_objects_for_%SN) () {
	#	[{%{FACTORY_PARENT}U!=%{INT}U}{return %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(get_cached_objects_for_%SN) ();}java.util.Collection\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\> res = new java.util.ArrayList\<[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{INT})}java.lang.ref.WeakReference\<%t_ret(%{INT})\> ]\>();
	#	for ([{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{%t_ret(%{FACTORY_PARENT})}java.lang.ref.WeakReference\<%t_ret(%{FACTORY_PARENT})\> ] item: %f_type(%{FACTORY_PARENT})FactoryManager.getInstance%{FACTORY_PARENT}U ().%f_to_java(get_cached_objects_for_%SN) ()) {
	#		%f_type(%{FACTORY_PARENT}) obj = item[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}.get ()];
	#		if (obj != null && (obj instanceof %f_type(%{INT}))) {
	#			[{%TS=FactoryMemory&%T%f_use_for_synchro_factory()=true|%Ss=synchro}{res.add ((%f_type(%{INT}))obj);}res.add (
	#				new java.lang.ref.WeakReference\<%f_type(%{INT})\> (
	#					(%f_type(%{INT}))obj
	#				)
	#			);]
	#		}
	#	}
	#	return res;]
	#}]
//#UC END# *470321950119for470F57A80119*

// Функции стереотипа
%f _st_space_key
	MDP

%f _wiki_up_print
	%S#[inherited][{"%S{transparent multy}"!="%S{!transparent multy}"}%f_up_prefix(%S) *transparent multy* = *%S{transparent multy}* - определяет, что выбор конкретной реализации будет реализован пользователем
	]


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа Interface::Class::factory::Operation
// дампит код реализации фабричного метода ("создающего") для менеджера фабрик в случае
// использования общей памяти
%f _fctr_mng_factory_mem_create_impl
//#UC START# *4757C7C4005Afor470F57A80119*
	%S%f_init_factory_mem_key_java_impl()
	#		FactoryData fctData = factoriesMap_.get (key);
	#		if (fctData == null) {
	#			[{%S{transparent multy}=false|"%S{transparent multy}"=""}{throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");}throw new UnknownFactoryKey ("%P%P%PN::%P%PN::%PNFactory"[{%{INT}S!=ServerInterface}, key.toString ()]);]
	#		}
	#		[{%2N!=read-only}{%t_ret(%{INT}) obj}res] = fctData.factory_.%f_to_java(%SN) (<%f_to_java(%CN), >memKey);
	#		assert(%f_to_java(%TNMap)_.get (memKey) != null);
	[{%f_is_ro_fctr_exists(%S)=false}{%f_create_new_combo_data(%S,"%2N")}
	#		%f_to_java(%TNMap)_.put (memKey, [{%T%f_use_for_synchro_factory()=true}{res}new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (res)]);
	#		%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{[{%T%f_use_for_synchro_factory()=true}{res}res.hashCode ()]}res._hash (Integer.MAX_VALUE)], memKey);]
//#UC END# *4757C7C4005Afor470F57A80119*

// перекрытие базового стереотипа Interface::Class::factory::Operation
// дампит код реализации фабричного метода (не "создающего") для менеджера фабрик в случае
// использования общей памяти
%f _fctr_mng_factory_mem_java_impl
//#UC START# *4757C6DA0040for470F57A80119*
	[{%f_is_ro_fctr_exists(%S)=true&%2N=read-only}{#			FactoryData fctData = factoriesMap_.get (key);
	#			if (fctData == null) {
	#				[{%S{transparent multy}=false|"%S{transparent multy}"=""}{throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");}throw new UnknownFactoryKey ("%P%P%PN::%P%PN::%PNFactory"[{%{INT}S!=ServerInterface}, key.toString ()]);]
	#			}
	#			res = [{%T%f_use_for_synchro_factory()=false&%f_is_ro_fctr_exists(%S)=true}{fctData.factory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>);} new %t_fctr_manager_cache_value(%{INT},"var",%S) (
	#				fctData.factory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>)
	#			);][{%T%f_use_for_synchro_factory()=true}
	#			ref = [{%f_is_ro_fctr_exists(%S)=true}{new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (res);}new %t_fctr_manager_cache_value(%{INT},"type","") (
	#				new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (res)
	#			);]]
	#			%f_to_java(%TNMap)_.put (memKey, [{%T%f_use_for_synchro_factory()=true}{res}ref]);
	#			%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{res[{%T%f_use_for_synchro_factory()=true}{[.%f_cache_postfix(%S,"read-write")]}.hashCode ()]}res._hash (Integer.MAX_VALUE)], memKey);\
	}\
	#			[{%T%f_use_for_synchro_factory()=true}{if (res == null) {
	#				FactoryData fctData = factoriesMap_.get (key);
	#				if (fctData == null) {
	#					[{%S{transparent multy}=false|"%S{transparent multy}"=""}{throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");}throw new UnknownFactoryKey ("%P%P%PN::%P%PN::%PNFactory"[{%{INT}S!=ServerInterface}, key.toString ()]);]
	#				}
	#				res = new %t_fctr_manager_cache_value(%{INT},"var",%S) (
	#					fctData.factory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>)
	#				);
	#				res[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (res[.%f_cache_postfix(%S,"read-write")]);
	#				res.isRoFirst = true;
	#				%f_to_java(%TNMap)_.put (memKey, res);
	#				%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{res[.%f_cache_postfix(%S,"read-write")]}res[.%f_cache_postfix(%S,"read-write")]._hash (Integer.MAX_VALUE)], memKey);
	#			} else if (res[.%f_cache_postfix(%S,"read-only")] == null) {
	#				res[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (res[.%f_cache_postfix(%S,"read-write")]);
	#			}\
	}if (ref != null && ref[.%f_cache_postfix(%S,"read-write")] != null && ref[.%f_cache_postfix(%S,"read-write")].get () != null) {
	#				res = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
	#				ref[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (res);
	#			} else {
	#				FactoryData fctData = factoriesMap_.get (key);
	#				if (fctData == null) {
	#					[{%S{transparent multy}=false|"%S{transparent multy}"=""}{throw new [{%f_is_server_type(%{INT})=true}ru.garant.shared.CoreSrv.]NoActiveFactory ("%{INT}%P%PN.%PN.%SNFactory");}throw new UnknownFactoryKey ("%P%P%PN::%P%PN::%PNFactory"[{%{INT}S!=ServerInterface}, key.toString ()]);]
	#				}
	#				%t_ret(%{INT}) obj = fctData.factory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>);
	#				ref = new %t_fctr_manager_cache_value(%{INT},"type",%S) (
	#					new java.lang.ref.WeakReference\<%f_type(%{INT})\> (obj)
	#				);
	#				res = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
	#				ref[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (res);
	#				ref.isRoFirst = true;
	#				%f_to_java(%TNMap)_.put (memKey, ref);
	#				%f_to_java(%TNIndexMap)_.put ([{%f_is_server_type(%{INT})=true}{res.hashCode ()}ref[.%f_cache_postfix(%S,"read-write")]._hash (Integer.MAX_VALUE)], memKey);
	#			}]]
//#UC END# *4757C6DA0040for470F57A80119*

// перекрытие базового стереотипа Interface::Class::factory::Operation
// дампит код дополнительной  инициализации ключа общей памяти (инициализирует ключ фабрики
// серванта)
%f _init_factory_mem_key_java_impl
//#UC START# *4757C67E03A1for470F57A80119*
	[{%S{transparent multy}=true}#		%U[{_CUSTOM_SELECT_FACTORY_KEY}
	#		%S%f_dump_switch_key key;
	#		throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
	#		]
	]#		memKey.keyArg_ = key;
//#UC END# *4757C67E03A1for470F57A80119*

// перекрытие базового стереотипа Interface::Class::factory_op::Operation
// дампит реализацию конкретной read-write или read-only фабрики для менеджера фабрик, в качестве
// дополнительного параметра передается read-write или read-only в зависимости от того, какую
// фабрику нужно сдампить
%f _factory_mng_factory_impl_java
//#UC START# *4B793D3F0059for470F57A80119*
	[{%S{transparent multy}=false|"%S{transparent multy}"=""}\
//{%S{transparent multy}=false}
	#public %t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Ss]")[{%{INT}S!=ServerInterface&%2N=read-only}ConstWrapper] [{%{INT}S!=ServerInterface}{%SN%3N}%f_to_java(%SN%3N)] (%S<%f_arg_full_decl(%C), >%{INT}%f_dump_switch_type() key) throws UnknownFactoryKey[{%f_need_conversion_exception(%S)=true}, ru.garant.shared.Core.Root.ImpossibleConversion]%S<, %f_type(%E)> {[{%f_is_it_cached(%S)=false}
	#	FactoryData factoryData = factoriesMap_.get(key);
	#	%{INT}NAbstractFactory factory = factoryData != null ? factoryData.factory_ : null;
	#	if (null == factory) {
	#		throw new UnknownFactoryKey (
	#			"%f_dump_java_package(%{INT}).%{INT}NFactory"[{%{INT}S!=ServerInterface}
	#			, key.toString ()]
	#		);
	#	}
	#	[{%{INT}S=ServerInterface&%2N=read-only}{return [{%2N=read-only}{factory.%f_to_java(%SN) (%S<{, }%f_to_java(%CN)>)}new %{INT}NConstWrapper (factory.%f_to_java(%SN) (%S<{, }%f_to_java(%CN)>))];}try {
	#		org.omg.CORBA.Object obj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(
	#			new %{INT}NConstWrapper (factory.%f_to_java(%SN) (%S<{, }%f_to_java(%CN)>))
	#		);
	#		return %f_type(%{INT})Helper.narrow (obj);
	[<{}{}{%E}\
	#	} catch (%f_type(%E) ex) {
	#		Logs.LOG_SEX(ex);
	#		throw ex;
	>]\
	#	} catch (Exception ex) {
	#		Logs.LOG_SEX(ex);
	#		throw new org.omg.CORBA.portable.UnknownException (ex);
	#	}
	#	assert (false);
	#	return null;]
	][{%f_is_it_cached(%S)=true}[{%TS!=FactoryMemory}{\n%f_fctr_mng_mem_java(%S,"%2N")}
	#	synchronized (cachedObjectsFor%f_to_borland(%SN)) {
	#		ObjectCreationIdFor%f_to_borland(%SN) mapKey = new ObjectCreationIdFor%f_to_borland(%SN)(%S<{}{{"%CS"!="nokey"}}%f_to_java(%CN), >key);
	#		[{%Ss=synchro}{%t_fctr_manager_cache_value(%{INT},"var",%S)}%f_type(%{INT})[{%2N=read-only}ConstWrapper]] ret = [{%Ss=synchro}{cachedObjectsFor%f_to_borland(%SN).get (mapKey);}null;
	#		%t_fctr_manager_cache_value(%{INT},"type",%S) ref = cachedObjectsFor%f_to_borland(%SN).get (mapKey);
	#		if (ref != null) {
	#			ret = ref[.%f_cache_postfix(%S,"%2N")].get ();
	#		}]
	#		if (ret == null[{%Ss!=synchro&%f_is_ro_fctr_exists(%S)=true} || ret[.%f_cache_postfix(%S,"%2N")] == null]) {
	[{%2N=read-only}{\
	#			FactoryData factoryData = factoriesMap_.get(key);
	#			%{INT}NAbstractFactory factory = factoryData != null ? factoryData.factory_ : null;
	#			if (null == factory) {
	#				throw new UnknownFactoryKey (
	#					"%f_dump_java_package(%{INT}).%{INT}NFactory"[{%{INT}S!=ServerInterface}
	#					, key.toString ()]
	#				);
	#			}
	#			ret = [{%f_is_ro_fctr_exists(%S)=true&%Ss!=synchro}{factory.%f_to_java(%SN) (%S<{, }%CN>)}new %t_fctr_manager_cache_value(%{INT},"var",%S) (
	#				factory.%f_to_java(%SN) (%S<{, }%CN>)
	#			)];[{%Ss=synchro}
	#			ref = [{%f_is_ro_fctr_exists(%S)=true}{new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (ret)}new %t_fctr_manager_cache_value(%{INT},"type",%S) (
	#				new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (ret)
	#			);]]
	#			cachedObjectsFor%f_to_borland(%SN).put (mapKey, [{%Ss=synchro}{ret}ref]);
	#			cachedObjectsIndexFor%f_to_borland(%SN).put ([{%f_is_server_type(%{INT})=true}{[{%Ss=synchro}{ret}ref][.%f_cache_postfix(%S,"read-write")][{%Ss=synchro}.hashCode ()]}ret[{%Ss!=synchro}[.%f_cache_postfix(%S,"read-write")]]._hash (Integer.MAX_VALUE)], mapKey);\
	}[{%Ss=synchro}{\
	#			if (ret == null) {
	#				FactoryData factoryData = factoriesMap_.get(key);
	#				%{INT}NAbstractFactory factory = factoryData != null ? factoryData.factory_ : null;
	#				if (null == factory) {
	#					throw new UnknownFactoryKey (
	#						"%f_dump_java_package(%{INT}).%{INT}NFactory"[{%{INT}S!=ServerInterface}
	#						, key.toString ()]
	#					);
	#				}
	#				ret = new %t_fctr_manager_cache_value(%{INT},"var",%S) (
	#					factory.%f_to_java(%SN) (%S<{, }%CN>)
	#				);
	#				[{%{INT}S=ServerInterface}{ret[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (ret[.%f_cache_postfix(%S,"read-write")]);}try {
	#					org.omg.CORBA.Object obj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(
	#						new %{INT}NConstWrapper (ret[.%f_cache_postfix(%S,"read-write")])
	#					);
	#					ret[.%f_cache_postfix(%S,"read-only")] = %f_type(%{INT})Helper.narrow (obj);
	[<{}{}{%E}\
	#				} catch (%f_type(%E) ex) {
	#					Logs.LOG_SEX(ex);
	#					throw ex;
	>]\
	#				} catch (Exception ex) {
	#					Logs.LOG_SEX(ex);
	#					throw new org.omg.CORBA.portable.UnknownException (ex);
	#				}]
	#				ret.isRoFirst = true;
	#				cachedObjectsFor%f_to_borland(%SN).put (mapKey, [{%Ss=synchro}{ret}ref]);
	#				cachedObjectsIndexFor%f_to_borland(%SN).put ([{%f_is_server_type(%{INT})=true}{[{%Ss=synchro}{ret}ref][.%f_cache_postfix(%S,"read-write")][{%Ss=synchro}.hashCode ()]}ret[{%Ss!=synchro}[.%f_cache_postfix(%S,"read-write")]]._hash (Integer.MAX_VALUE)], mapKey);
	#			} else if (ret[.%f_cache_postfix(%S,"read-only")] == null) {
	#				[{%{INT}S=ServerInterface}{ret[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (ret[.%f_cache_postfix(%S,"read-write")]);}try {
	#					org.omg.CORBA.Object obj = %f_dump_java_package(%{INT}%P).LibHomeFactory.get().getOrbFacet().getRootPoa().servant_to_reference(
	#						new %{INT}NConstWrapper (ret[.%f_cache_postfix(%S,"read-write")])
	#					);
	#					ret[.%f_cache_postfix(%S,"read-only")] = %f_type(%{INT})Helper.narrow (obj);
	[<{}{}{%E}\
	#				} catch (%f_type(%E) ex) {
	#					Logs.LOG_SEX(ex);
	#					throw ex;
	>]\
	#				} catch (Exception ex) {
	#					Logs.LOG_SEX(ex);
	#					throw new org.omg.CORBA.portable.UnknownException (ex);
	#				}]
	#			}\
	}\
	#			if (ref != null && ref[.%f_cache_postfix(%S,"read-write")] != null && ref[.%f_cache_postfix(%S,"read-write")].get () != null) {
	#				ret = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
	#				ref[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (
	#					ret
	#				);
	#			} else {
	#				FactoryData factoryData = factoriesMap_.get(key);
	#				%{INT}NAbstractFactory factory = factoryData != null ? factoryData.factory_ : null;
	#				if (null == factory) {
	#					throw new UnknownFactoryKey (
	#						"%f_dump_java_package(%{INT}).%{INT}NFactory"[{%{INT}S!=ServerInterface}
	#						, key.toString ()]
	#					);
	#				}
	#				%t_ret(%{INT}) obj = factory.%f_to_java(%SN) (%S<{, }%CN>);
	#				ref = new %t_fctr_manager_cache_value(%{INT},"type",%S) (
	#					new java.lang.ref.WeakReference\<%f_type(%{INT})\> (obj)
	#				);
	#				ret = new %{INT}NConstWrapper (ref[.%f_cache_postfix(%S,"read-write")].get ());
	#				ref[.%f_cache_postfix(%S,"read-only")] = new java.lang.ref.WeakReference\<%{INT}NConstWrapper\> (
	#					ret
	#				);
	#				ref.isRoFirst = true;
	#				cachedObjectsFor%f_to_borland(%SN).put (mapKey, [{%Ss=synchro}{ret}ref]);
	#				cachedObjectsIndexFor%f_to_borland(%SN).put ([{%f_is_server_type(%{INT})=true}{[{%Ss=synchro}{ret}ref][.%f_cache_postfix(%S,"read-write")][{%Ss=synchro}.hashCode ()]}obj._hash (Integer.MAX_VALUE)], mapKey);
	#			}]]
	#		}[{%2N=read-write&%f_is_ro_fctr_exists(%S)=true} else if (
	#			[{%Ss=synchro}{ret != null
	#			&& ret[.%f_cache_postfix(%S,"read-only")] != null
	#			&& ret.isRoFirst == true}ref != null
	#			&& ref[.%f_cache_postfix(%S,"read-only")] != null
	#			&& ref[.%f_cache_postfix(%S,"read-only")].get () != null
	#			&& ref.isRoFirst == true]
	#		) {
	#			[{%Ss=synchro}{ret[.%f_cache_postfix(%S,"read-only")].upgrade_rw ();
	#			ret.isRoFirst = false;}ref[.%f_cache_postfix(%S,"read-only")].get ().upgrade_rw ();
	#			ref.isRoFirst = false;]
	#		}]
	#		return ret[{%Ss!=synchro}[.%f_cache_postfix(%S,"%2N")]];
	#	}
	]]#}][{%S{transparent multy}=true}\
//{%S{transparent multy}=true}\
	#public %t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Ss]")[{%2N=read-only}ConstWrapper] %f_to_java(%SN) (%S<{, }%f_arg_full_decl(%C)>) throws NoActiveFactory[{%f_need_conversion_exception(%S)=true}, ru.garant.shared.Core.Root.ImpossibleConversion]%S<, %f_type(%E)> {[{%f_is_it_cached(%S)=false}
	#	%{INT}NAbstractFactory factory = null;
	#	%U[{_CUSTOM_SELECT_FACTORY}
	#	]
	#	if (null == factory) {
	#		throw new NoActiveFactory ("%f_dump_java_package(%{INT}).%{INT}NFactory");
	#	}
	#	return factory.%f_to_java(%SN) (%S<{, }%f_to_java(%CN)>);
	][{%f_is_it_cached(%S)=true}[{%TS!=FactoryMemory}{\n%f_fctr_mng_mem_java(%S,"%2N")}
	#	synchronized (cachedObjectsFor%f_to_borland(%SN)) {
	#		ObjectCreationIdFor%f_to_borland(%SN) mapKey = new ObjectCreationIdFor%f_to_borland(%SN)(%S<{, }{{"%CS"!="nokey"}}%f_to_java(%CN)>);
	#		%t_ret(%{INT}) ret = [{%Ss=synchro}{cachedObjectsFor%f_to_borland(%SN).get (mapKey);}null;
	#		java.lang.ref.WeakReference\<%t_ret(%{INT})\> ref = cachedObjectsFor%f_to_borland(%SN).get (mapKey);
	#		if (ref != null) {
	#			ret = ref.get ();
	#		}]
	#		if (ret == null) {
	#			%{INT}NAbstractFactory factory =null;
	#			%U[{_CUSTOM_SELECT_FACTORY}
	#			]
	#			if (null == factory) {
	#				throw new NoActiveFactory ("%f_dump_java_package(%{INT}).%{INT}NFactory");
	#			}
	#			ret = factory.%f_to_java(%SN) (%S<{, }%f_to_java(%CN)>);[{%Ss=synchro}
	#			ref = new java.lang.ref.WeakReference\<%t_ret(%{INT})\> (ret);]
	#			cachedObjectsFor%f_to_borland(%SN).put (mapKey, [{%Ss=synchro}{ret}ref]);
	#			cachedObjectsIndexFor%f_to_borland(%SN).put ([{%f_is_server_type(%{INT})=true}{[{%Ss=synchro}{ret}ref][{%Ss=synchro}.hashCode ()]}ret[.%f_cache_postfix(%S,"read-write")]._hash (Integer.MAX_VALUE)], mapKey);
	#		}
	#		return ret;
	#	}
	]]#}]
//#UC END# *4B793D3F0059for470F57A80119*

// Вложенные стереотипы
: Interface::Class::multi factory::Operation::Parameter
? парметр
= AbstractFacet::Class::Operation::Parameter

// Генераторы
// Генерация модели в MDKnow
+ wiki
//#UC START# *46E6D4BB0339for470F640801B5*
//#UC END# *46E6D4BB0339for470F640801B5*

// генератор idl спецификаций (.idl)
+ idl
//#UC START# *47022BBE0261for470F640801B5*
//#UC END# *47022BBE0261for470F640801B5*

// генератор idl спецификаций для AMI (.idl)
+ idl_ami
//#UC START# *47022C0F01E4for470F640801B5*
//#UC END# *47022C0F01E4for470F640801B5*

// генератор inline файлов реализации C++ (.i.h)
+ i.h
//#UC START# *47022CCF00EAfor470F640801B5*
//#UC END# *47022CCF00EAfor470F640801B5*

// С++ TIE-обвязка для DLL (_tie.h)
+ dll.h
//#UC START# *47032EC4032Cfor470F640801B5*
//#UC END# *47032EC4032Cfor470F640801B5*

// С++ TIE-обвязка для DLL (_tie.cpp)
+ dll.cpp
//#UC START# *47032ED002DEfor470F640801B5*
//#UC END# *47032ED002DEfor470F640801B5*

// Родные Delphi интерфейсы (.pas)
+ intf.pas
R  
//#UC START# *470F1571031Cfor470F640801B5*
//#UC END# *470F1571031Cfor470F640801B5*

// Реализация на Delphi(.pas)
+ impl.pas
R  
//#UC START# *470F15B800CBfor470F640801B5*
//#UC END# *470F15B800CBfor470F640801B5*

// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
+ intf2.pas
R  
//#UC START# *477398E501C0for470F640801B5*
//#UC END# *477398E501C0for470F640801B5*

// 3-я секция интерфейса. Например поле для свойства.
+ intf3.pas
R  
//#UC START# *4774D2A20372for470F640801B5*
//#UC END# *4774D2A20372for470F640801B5*

// Генератор файлов форм (.dfm)
+ dfm
R  
//#UC START# *49F5795900ECfor470F640801B5*
//#UC END# *49F5795900ECfor470F640801B5*

// Ресурсы (.rc)
+ rc.pas
R  
//#UC START# *55B8D28B0157for470F640801B5*
//#UC END# *55B8D28B0157for470F640801B5*

// Скрипты в ресурсах (.rc.script)
+ rc.script.pas
R  
//#UC START# *55B8D2F80145for470F640801B5*
//#UC END# *55B8D2F80145for470F640801B5*

// Компилятор ресурса (.res.cmd)
+ res.cmd.pas
R  
//#UC START# *55B8DD9C0301for470F640801B5*
//#UC END# *55B8DD9C0301for470F640801B5*

// Функции стереотипа
%f _st_space_key
	MDP


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for470F640801B5*
c                                                           {}
r {""=""}:                                                  {}
//#UC END# *4704C0E30186for470F640801B5*

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
%f _wiki_child_kind
//#UC START# *4705CBD6003Efor470F640801B5*
	mng
//#UC END# *4705CBD6003Efor470F640801B5*

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
%f _wiki_up_add_gen
//#UC START# *470484D50138for470F640801B5*
//#UC END# *470484D50138for470F640801B5*


: Interface::Class::finder::Operation
? Finder
? Стереотип операции возвращающей экземпляр сущности (или список экземпляров) по заданным параметрам. Аналог стереотипа \<\<factory\>\>, но реализация логики создания конкретного экземпляра дана на откуп программисту
= Interface::Class::factory_op::Operation

// Пользовательские свойства
p multiplicity=0..1|0..* ? множественность - определяет возвращает ли finder один экземпляр (или 0, если ничего не найдено) или список экземпляров

// Генераторы
// генератор классов, интерфейсов на java (.java)
+ java
//#UC START# *470321950119for4B793D9001F1*
	%f_docs(%S)\
	%S%f_dump_factory_operation()
//#UC END# *470321950119for4B793D9001F1*

// Функции стереотипа
%f _st_space_key
	MDP

%f _wiki_up_print
	%S#[inherited][{"%S{multiplicity}"!="%S{!multiplicity}"}%f_up_prefix(%S) *multiplicity* = *%S{multiplicity}* - множественность - определяет возвращает ли finder один экземпляр (или 0, если ничего не найдено) или список экземпляров
	]

// генерит параметры файндера, добавляя ключ мультифкабрики, если нужно
%f _factory_params_with_key_if_needed
//#UC START# *4B7BAB460184for4B793D9001F1*
	[{%1%f_has_multi_factory()=true}{%S%f_factory_params("%1N")}%1%f_dump_switch_type() key[, %S%f_factory_params("%1N")]]
//#UC END# *4B7BAB460184for4B793D9001F1*

// генерит возвращаемый тип файндера
%f _ret
//#UC START# *4B7BA27C0223for4B793D9001F1*
	[{%S{multiplicity}=0..1}{java.util.List\<[{%1x=false}{%t_ret(%1,"%Ss")}%t_ret(%{INT},"%Ss")]\>}%t_ret(%{INT},"%Ss")]

%f _ret_for_servant
	[{%S{multiplicity}=0..1}{\
	[{%1a!=abstract}{\<T extends %t_ret(%{INT},"%Ss")\> java.util.List\<T\>}java.util.List\<%t_ret(%{INT},"%Ss")\>]\
	}%t_ret(%{INT},"%Ss")]

%f _ret_empty
	[{%S{multiplicity}=0..1}{new java.util.ArrayList\<[{%1x=false}{%t_ret(%1,"%Ss")}%t_ret(%{INT},"%Ss")]\> ()}%f_error("_ret_empty: Невозможно создать экземпляр интерфейса")]
//#UC END# *4B7BA27C0223for4B793D9001F1*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа AbstractInterface::Class::factory::Operation
%f _is_factory
//#UC START# *4B794201038Afor4B793D9001F1*
	true
//#UC END# *4B794201038Afor4B793D9001F1*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// генерация  метода на интерфейсе абстрактной фабрики
%f _abstract_factory_operation
//#UC START# *4B793F8302B9for4B793D9001F1*
	[{%XU=fctr.java}		public %S%f_ret() %f_to_java(%SN) (%S%f_factory_params("%1N"))[ throws <{, }%f_type(%E)>];]
//#UC END# *4B793F8302B9for4B793D9001F1*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// генерация статического метода на фабрике инетрфейса
%f _dump_factory_operation
//#UC START# *4B793FC10112for4B793D9001F1*
	[{%XU=java}#%t_visibility(%S,"%XU")static %S%f_ret() %f_to_java(%SN) (%S%f_factory_params_with_key_if_needed(%{INT}))[ throws <{, }%f_type(%E)>] {
	[{%{INT}U!=%{FACTORY_PARENT}U}{#	return %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) ([{%{INT}%f_has_multi_factory()=true}{<{, }%f_to_java(%CN)>}key<, %f_to_java(%CN)>]);}\
	[{%S{multiplicity}=0..1}{\
	#	%S%f_ret() ret = %S%f_ret_empty();
	#	for (%f_type(%{FACTORY_PARENT}) item: %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) ([{%{INT}%f_has_multi_factory()=true}{<{, }%f_to_java(%CN)>}key<, %f_to_java(%CN)>])) {
	#		if (item instanceof %f_type(%{INT})) {
	#			ret.add ((%f_type(%{INT})) item);
	#		}
	#	}
	#	
	#	return ret;}#	%f_type(%{FACTORY_PARENT}) ret = %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) ([{%{INT}%f_has_multi_factory()=true}{<{, }%f_to_java(%CN)>}key<, %f_to_java(%CN)>]);
	#	if (ret instanceof %f_type(%{INT})) {
	#		return (%f_type(%{INT})) ret;
	#	} else {
	#		return null;
	#	}]]
	#}]
//#UC END# *4B793FC10112for4B793D9001F1*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// дампит реализацию конкретной read-write или read-only фабрики для менеджера фабрик, в качестве
// дополнительного параметра передается read-write или read-only в зависимости от того, какую
// фабрику нужно сдампить
%f _factory_mng_factory_impl_java
//#UC START# *4B793D3F0059for4B793D9001F1*
//#UC END# *4B793D3F0059for4B793D9001F1*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// дампит реализацию фабрики для менеджера фабрик, осуществляет выбор дапить только read-only или
// read-write, или обе фабрики
%f _fctr_mng_factory_java
//#UC START# *4B793D420398for4B793D9001F1*
	[{%XU=fctr.java}#public %S%f_ret() %f_to_java(%SN) (%S%f_factory_params_with_key_if_needed(%{INT}))[throws <{, }%f_type(%E)>] {
	[{%{INT}%f_has_multi_factory()=true}{#	if (singleActiveFactory_ == null) {
	#		return null;
	#	}
	#	return singleActiveFactory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>);}\
	#	FactoryData factoryData = factoriesMap_.get (key);
	#	if (factoryData == null || factoryData.factory_ == null) {
	#		return null;
	#	}
	#	return factoryData.factory_.%f_to_java(%SN) (<{, }%f_to_java(%CN)>);]
	#}]
//#UC END# *4B793D420398for4B793D9001F1*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// генерация для серванта
%f _for_servant
//#UC START# *4B7BABC802B8for4B793D9001F1*
	[{%XU=java}#static %S%f_ret_for_servant(%1) %f_to_java(%SN) (%S%f_factory_params())[ throws <{, }%f_type(%E)>] {
	#	%U[{_FOR_%1U}
	#	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
	#	]
	#}]
//#UC END# *4B7BABC802B8for4B793D9001F1*

// реализация абстрактного стереотипа Interface::Class::factory_op::Operation
// генерация реализации для фабрики серванта
%f _for_servant_factory
//#UC START# *4B7BAB9E0209for4B793D9001F1*
// %1 - Сервант
	[{%XU=fctr.java}#public %S%f_ret() %f_to_java(%SN) (%S%f_factory_params())[ throws <{, }%f_type(%E)>] {
	#	return %f_type(%1).%f_to_java(%SN) (<{, }%f_to_java(%CN)>);
	#}]
//#UC END# *4B7BAB9E0209for4B793D9001F1*

// перекрытие базового стереотипа AbstractInterface::Class::factory::Operation
// возвращает true, если фабрика кэшированная (в том числе если это синхро-фабрика), иначе - false
%f _is_cached
//#UC START# *4A93E7EC0223for4B793D9001F1*
	false
//#UC END# *4A93E7EC0223for4B793D9001F1*

// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for4B793D9001F1*
c                          {}
r {"%TN"!="void"}:         {%SM не может определять тип результата: %TN}
//#UC END# *4704C0E30186for4B793D9001F1*

// Вложенные стереотипы
: Interface::Class::finder::Operation::Parameter
? параметр фабричного метода
= AbstractFacet::Class::Operation::Parameter

// Функции стереотипа
%f _st_space_key
	MDP




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

