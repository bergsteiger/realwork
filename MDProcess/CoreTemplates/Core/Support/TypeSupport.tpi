////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CoreTemplates/Core/Support/TypeSupport.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAUtilityPack::Class>> MDProcess$CoreTemplates::CoreTemplates::Core::Support::TypeSupport
//
// Методы (функции и трансформаторы) для типизации стеротипов, преобразования имен для различных
// генераторов, и т.д.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// возвращает true, если тип фиксированного размера, иначе false
t _fixed_type
//#UC START# *4714BF400203*
c                                  {}
r "%SN"="short":                   {true}
r "%SN"="size":                    {true}
r "%SN"="integer":                 {true}
r "%SN"="long":                    {true}
r "%SN"="atomic":                  {true}
r "%SN"="unsigned atomic":         {true}
r "%SN"="long long":               {true}
r "%SN"="unsigned short":          {true}
r "%SN"="unsigned integer":        {true}
r "%SN"="unsigned long":           {true}
r "%SN"="unsigned long long":      {true}
r "%SN"="unsigned char":           {true}
r "%SN"="float":                   {true}
r "%SN"="double":                  {true}
r "%SN"="boolean":                 {true}
r "%SN"="tribool":                 {true}
r "%SN"="char":                    {true}
r "%SN"="wchar":                   {true}
r "%SN"="hthread":                 {true}
r "%SN"="octet":                   {true}
r "%SN"="a-string":                {true}
r "%SN"="a-wstring":               {true}
r "%SN"="c-string":                {true}
r "%SN"="mutex":                   {true}
r "%SN"="rw-mutex":                {true}
r "%SM"="Enum::Class":             {true}
r "%SM"="BitMask::Class":        {true}
r "%SC"="Operation":               {true}
r "%SM"="Iterator::Class":         {true}
r "%SM"="Const Iterator::Class":   {true}
r "%SC"="Parameter"&"%PC"="Class": {[{%SS!=withref}{false}true]}
r "%SN"="string":                  {false}
r "%SN"="wstring":                 {false}
r "%SN"="any":                     {false}
r "%SN"="exception":               {false}
r {%t_refcounted(%S)=true}:        {false}
r "%SM"="Typedef::Class":          {[{%Gx=true}{true}%Gf]}
//#UC END# *4714BF400203*

// определяет интерфейсный тип или нет
t _interface
//#UC START# *4714BF48007D*
c                             {}
r {%S#f_IsInterface()=true}: {true}
r "%SN"="object":             {true}
r "%SN"="state machine":      {true}
r "%SM"="Interface::Class":   {true}
r "%SM"="ViewAreaController::Class":   {true}
r "%SM"="UseCaseController::Class":   {true}
r "%SM"="ServerFacet::Class":       {true}
r "%SM"="ServerInterface::Class":   {true}
r "%SM"="Typedef::Class":     {%t_interface(%G)}
r ""="":                      {false}
//#UC END# *4714BF48007D*

// выводит имя типа
t _n
//#UC START# *4714BF500203*
c                                  {idl}                {cpp}                             {CORBA_cpp}         {delphi}           {dll_cpp}                                                                  {java}
r "%SM"="Iterator::Class":         {ERROR}              {%t_n(%P,%1)::iterator}            {%t_n(%P,%1)::iterator}  {ERROR}        {ERROR}                                                                  {java.util.Iterator\<%f_data_dump(%S)\>}
r "%SM"="Const Iterator::Class":   {ERROR}              {%t_n(%P,%1)::const_iterator}      {%t_n(%P,%1)::const_iterator} {ERROR}   {ERROR}                                                                  {java.util.Iterator\<%f_data_dump(%S)\>}
r "%SN"="atomic":                  {ERROR}              {Core::AtomicOp\<long\>}          {Core::AtomicOp\<long\>}             {ERROR}            {ERROR}                                                   {java.util.concurrent.atomic.AtomicLong}
r "%SN"="unsigned atomic":         {ERROR}              {Core::AtomicOp\<unsigned long\>} {Core::AtomicOp\<unsigned long\>}             {ERROR}            {ERROR}                                          {java.util.concurrent.atomic.AtomicLong}
r "%SN"="mutex":                   {ERROR}              {Core::Mutex}                     {Core::Mutex}             {ERROR}            {ERROR}                                                              {java.util.concurrent.locks.ReentrantLock}
r "%SN"="rw-mutex":                {ERROR}              {Core::RWMutex}                   {Core::RWMutex}           {ERROR}            {ERROR}                                                              {java.util.concurrent.locks.ReentrantReadWriteLock}
r "%SN"="time":                    {ERROR}              {ACE_Time_Value}                  {ACE_Time_Value}             {ERROR}            {ERROR}                                                         {java.util.Date}
r "%SN"="void":                    {void}               {void}                            {void}              {}                 {void}                                                                     {void}
r "%SN"="size":                    {unsigned long}      {size_t}                          {CORBA::ULong}      {Cardinal}         {size_t}                                                                   {long}
r "%SN"="short":                   {short}              {short}                           {CORBA::Short}      {Smallint}         {short}                                                                    {short}
r {%SN=long}:                      {long}               {long}                            {CORBA::Long}       {Longint}          {long}                                                                     {int}
r "%SN"="long long":               {long long}          {long long}                       {CORBA::LongLong}   {Int64}            {long long}                                                                {long}
r "%SN"="integer":                 {long}               {int}                             {CORBA::Long}       {Longint}          {int}                                                                      {int}
r "%SN"="unsigned integer":        {unsigned long}      {unsigned int}                    {CORBA::ULong}      {Longint}          {unsigned int}                                                             {int}
r "%SN"="unsigned short":          {unsigned short}     {unsigned short}                  {CORBA::UShort}     {Word}             {unsigned short}                                                           {short}
r "%SN"="unsigned long":           {unsigned long}      {unsigned long}                   {CORBA::ULong}      {Longword}         {unsigned long}                                                            {int}
r "%SN"="unsigned long long":      {unsigned long long} {unsigned long long}              {CORBA::ULongLong}  {Int64}            {unsigned long long}                                                       {ERROR4_%SS::%SN}
r "%SN"="float":                   {float}              {float}                           {CORBA::Float}      {Single}           {float}                                                                    {float}
r "%SN"="double":                  {double}             {double}                          {CORBA::Double}     {Double}           {double}                                                                   {double}
r "%SN"="boolean":                 {boolean}            {bool}                            {CORBA::Boolean}    {Bytebool}         {bool}                                                                     {boolean}
r "%SN"="tribool":                 {ERROR}              {boost::tribool}                  {Boost::Tribool}    {ERROR}            {bool}                                                                     {ERROR}
r "%SN"="char":                    {char}               {char}                            {CORBA::Char}       {AnsiChar}         {char}                                                                     {char}
r "%SN"="unsigned char":           {unsigned char}      {unsigned char}                   {CORBA::UChar}      {AnsiChar}         {unsigned char}                                                            {ERROR5_%SS::%SN}
r "%SN"="wchar":                   {wchar}              {wchar_t}                         {CORBA::WChar}      {ERROR(wchar)}     {ERROR(wchar)}                                                             {ERROR6_%SS::%SN}
r "%SN"="octet":                   {octet}              {unsigned char}                   {CORBA::Octet}      {Byte}             {unsigned char}                                                            {byte}
r "%SN"="hthread":                 {ERROR}              {Core::ThreadHandle}              {Core::ThreadHandle}{????}             {???}                                                                      {java.lang.Thread}
r {%SN=string}:                    {string}             {char*}                           {char*}             {PAnsiChar}        {char*}                                                                    {String}
r "%SN"="a-string":                {ERROR}              {std::string}                     {std::string}       {ERROR}            {ERROR}                                                                    {String}
r "%SN"="a-wstring":               {ERROR}              {std::wstring}                    {std::wstring}      {ERROR}            {ERROR}                                                                    {String}
r "%SN"="c-string":                {ERROR}              {Core::ConstString}               {Core::ConstString} {ERROR}            {ERROR}                                                                    {String}
r "%SN"="wstring":                 {wstring}            {wchar_t*}                        {WChar*}            {ERROR(wstring)}   {ERROR(wstring)}                                                           {String}
r "%SN"="identifier":              {ERROR}              {std::string}                     {std::string}       {ERROR}            {ERROR}                                                                    {String}
r "%SN"="arbitrary string":        {ERROR}              {std::string}                     {std::string}       {ERROR}            {ERROR}                                                                    {String}
r "%SN"="object":                  {Object}             {Core::IObject}                   {CORBA::Object}     {IUnknown}         {Core::IIObject_tie}                                                        {java.lang.Object}
r "%SN"="any":                     {any}                {CORBA::Any}                      {CORBA::Any}        {ERROR(any)}       {ERROR(any)}                                                               {ERROR8_%SS::%SN}
r "%SN"="fixed":                   {fixed}              {fixed}                           {CORBA::Fixed}      {ERROR(fixed)}     {ERROR(fixed)}                                                             {ERROR9_%SS::%SN}
r "%SN"="pointer":                 {ERROR}              {void*}                           {void*}             {Pointer}          {void*}                                                                    {java.lang.Object}
r "%SN"="state machine":           {ERROR}              {FSM::IStateMachine}              {ERROR}             {Pointer}          {ERROR}                                                                    {ru.garant.shared.FSM.IStateMachine}
r "%SN"="exception":               {ERROR}              {Core::Exception}                 {ERROR}             {Pointer}          {ERROR}                                                                    {ru.garant.shared.FSM.IStateMachine}
r "%SM"="LexicalRule::Class":      {string}             {std::string}                     {std::string}       {PAnsiChar}        {ERROR}                                                                    {String}
r "%t_interface(%S)"="true":       {%S<%NN::>%SN}       {%S<%NN::>%SN}                    {%S<%NN::>%SN}      {%S<%NN.>I%SN}      {%S<%NN::>I%SN_tie}                                                       {[{%SM!=Typedef::Class}{%t_n(%G,"java")}%f_java_normalized_type(%S)]}
r "%t_is_container(%S)"="true":    {%S<%NN::>%SN}       {%S<%NN::>%SN}                    {%S<%NN::>%SN}      {%S<%NN.>I%SN}      {%S<%NN::>%SN[{"%t_dll_direct(%S)"="false"}_tie]}                         {[{%SM!=BitMask::Class}{%f_java_normalized_type(%S)}[{%SM!=Typedef::Class}{%t_n(%G,"java")}%f_java_normalized_type(%S)]]}
r "%t_impl_class(%S)"="true":      {ERROR(impl class)}  {%f_tn_cpp_impl_class(%S)}        {%S<%NN::>%SN}      {%S<%NN.>%SN}      {ERROR(impl class)}                                                        {[{%SM!=Typedef::Class}{%t_n(%G,"java")}%f_java_normalized_type(%S)]}
r "%t_sm_elements(%S)"="true":     {ERROR(impl class)}  {%f_tn_cpp_impl_class(%S)}        {%S<%NN::>%SN}      {%S<%NN.>%SN}      {ERROR(impl class)}                                                        {[{%SM!=Typedef::Class}{%t_n(%G,"java")}%f_java_normalized_type(%S)]}
r "%SM"="Exception::Class":        {%S<%NN::>%SN}       {%S<%NN::>%SN}                    {%S<%NN::>%SN}      {%S<%NN.>E%SN}     {%S<%NN::>%SN[{"%t_dll_direct(%S)"="false"}_tie]}                          {%f_java_normalized_type(%S)}
r "%SC"="Class":                   {%S<%NN::>%SN}       {%S<%NN::>%SN}                    {%S<%NN::>%SN}      {%S<%NN.>T%SN}     {%S<%NN::>%SN[{"%t_dll_direct(%S)"="false"}_tie]}                          {[{%SM!=BitMask::Class}{%f_java_normalized_type(%S)}[{%SM!=Typedef::Class}{%t_n(%G,"java")}%f_java_normalized_type(%S)]]}
r "%SC"="Parameter":               {%f_dump_param(%S)}       {%f_dump_param(%S)}                    {%f_dump_param(%S)}      {%S<%NN.>T%SN}     {%f_dump_param(%S)[{"%t_dll_direct(%S)"="false"}_tie]}      {%f_java_normalized_type(%S)}
r ""="":                           {ERROR}              {ERROR!%SN-%SS!}                           {ERROR}             {ERROR}            {ERROR}                                                                    {ERROR10_%SS::%SN}

f _type_tie
	[{%t_interface(%S)=true&%S{call way}!=back}{%f_type(%S)}[{%SN!=object}{Core::IObject_tie}%S<%NN::>%SN_tie]]
//#UC END# *4714BF500203*

// Определяет является ли аргумент стеротипов цели (для бинарной сборки)
t _target
//#UC START# *4714BF57002E*
c                             {}
r {%SM=ExeTarget::Category}: {true}
r {%SM=AdapterTarget::Category}: {true}
r {%SM=TestSuite::Category}: {true}
r {%SM=ComTarget::Category}: {true}
r ""="":                      {false}
//#UC END# *4714BF57002E*

// определяет простой тип или нет
t _simple
//#UC START# *4714BF5D00FA*
@ %SU
c                                  {}
r "%SN"="void":                    {undef}
r "%SM"="Enum::Class":             {true}
r "%SM"="BitMask::Class":             {true}
r "%SC"="Operation":               {true}
r "%SN"="short":                   {true}
r "%SN"="size":                    {true}
r "%SN"="integer":                 {true}
r "%SN"="long":                    {true}
r "%SN"="atomic":                  {true}
r "%SN"="hthread":                 {true}
r "%SN"="unsigned atomic":         {true}
r "%SN"="long long":               {true}
r "%SN"="unsigned short":          {true}
r "%SN"="unsigned integer":        {true}
r "%SN"="unsigned long":           {true}
r "%SN"="unsigned long long":      {true}
r "%SN"="unsigned char":           {true}
r "%SN"="float":                   {true}
r "%SN"="double":                  {true}
r "%SN"="boolean":                 {true}
r "%SN"="tribool":                 {true}
r "%SN"="char":                    {true}
r "%SN"="wchar":                   {true}
r "%SN"="octet":                   {true}
r "%SN"="string":                  {true}
r "%SN"="wstring":                 {true}
r "%SN"="pointer":                 {true}
r "%SN"="HWND":                    {true}
r "%SN"="WPARAM":                  {true}
r "%SN"="LPARAM":                  {true}
r "%SN"="BOOL":                    {true}
r "%SN"="LRESULT":                 {true}
r "%SN"="UINT":                    {true}
r "%SN"="HANDLE":                  {true}
r "%SN"="HHOOK":                   {true}
r "%S%PN"="Win32":                 {true}
r "%SM"="Typedef::Class":          {[{%Gx=true}{true}%t_simple(%G)]}
r "%SC"="Parameter"&"%PC"="Class": {[{%SS=primitive}{false}true]}
/r "%SM"="Struct::Class"&"<{}{"%t_simple(%C%T)"="false"}{%CC}>"="0":  {true}
r ""="":                           {false}

f _simple_impl
	[{"%{%1N}N"=""}%f_set_var(%1N,"%t_simple_impl(%S)")]\
	%{%1N}N

/c                                  {}
/r {true}:                         {%f_simple_impl(%S,"%SU_SIMPLE")}
/@ %SU
t _simple_impl
c                                  {}
r "%SN"="void":                    {undef}
r "%SM"="Enum::Class":             {true}
r "%SM"="BitMask::Class":             {true}
r "%SC"="Operation":               {true}
r "%SN"="short":                   {true}
r "%SN"="size":                    {true}
r "%SN"="integer":                 {true}
r "%SN"="long":                    {true}
r "%SN"="atomic":                  {true}
r "%SN"="hthread":                 {true}
r "%SN"="unsigned atomic":         {true}
r "%SN"="long long":               {true}
r "%SN"="unsigned short":          {true}
r "%SN"="unsigned integer":        {true}
r "%SN"="unsigned long":           {true}
r "%SN"="unsigned long long":      {true}
r "%SN"="float":                   {true}
r "%SN"="double":                  {true}
r "%SN"="boolean":                 {true}
r "%SN"="tribool":                 {true}
r "%SN"="char":                    {true}
r "%SN"="wchar":                   {true}
r "%SN"="octet":                   {true}
r "%SN"="string":                  {true}
r "%SN"="wstring":                 {true}
r "%SN"="pointer":                 {true}
r "%SN"="HWND":                    {true}
r "%SN"="WPARAM":                  {true}
r "%SN"="LPARAM":                  {true}
r "%SN"="BOOL":                    {true}
r "%SN"="LRESULT":                 {true}
r "%SN"="UINT":                    {true}
r "%SN"="HANDLE":                  {true}
r "%SN"="HHOOK":                   {true}
r "%S%PN"="Win32":                 {true}
r "%SM"="Typedef::Class":          {[{%Gx=true}{true}%t_simple(%G)]}
r "%SC"="Parameter"&"%PC"="Class": {[{%SS=primitive}{false}true]}
/r "%SM"="Struct::Class"&"<{}{"%t_simple(%C%T)"="false"}{%CC}>"="0":  {true}
r ""="":                           {false}
//#UC END# *4714BF5D00FA*

// Определяет является ли аргумент стеротипов цели (для бинарной сборки). Расширяет t_target
// дополнительными стеротипами
t _target_ex
//#UC START# *4714BF62037A*
c                             {}
r {%t_target(%S)=true}: {true}
r {%SM=KPluginTarget::Category}: {true}
r {%SM=InstallerTarget::Category}: {true}
r ""="":                      {false}
//#UC END# *4714BF62037A*

// выводит имя типа для класса реализации
f _tn_cpp_impl_class
//#UC START# *4714C3DA005D*
	%S<%NN::>%SN[{%XU!=h&%XU!=fctr.h}%f_templ_footer(%S)]
//#UC END# *4714C3DA005D*

// определяет нужно ли использовать "сервеный" тип для элемента
f _need_server_type_decl
//#UC START# *4714C42A00AB*
	[{<{}{%PS=ServerLibrary}{C}>!=0|"<%G<{}{%PS=ServerLibrary}.>>"!=""|"<%R<{}{%PS=ServerLibrary}.>>"!=""}{false}true]
//#UC END# *4714C42A00AB*

// выводит имя типа
f _tn
//#UC START# *4714C479032C*
@ %SU_%BU_%X{lid}_%XU
/	%f_tn_impl(%S,"%SU_%BU_%X{lid}_%XU_TN")
	[{%X{lid}=cpp}{%t_n(%S,"%X{lid}")}\
	[{%f_can_decl_as_server_type(%S)=true&%f_need_server_type_decl(%B)=true}{%t_n(%S,"%X{lid}")}%t_n(%S,"CORBA_cpp")]]

//проверяем, что тип можно деларировать как серверный
//например, если это тип параметра overloaded-метода (или возвращаемое значение),
//то должен сгенерится тот тип, который сгенерён у родителя метода
f _can_decl_as_server_type
	[{%SS=UMLPrimitive&%f_check_type_parent(%S)=true}{false}true]

f _check_type_parent
	[{"%{TYPE_PARENT}U"!=""}{true}[{%f_need_server_type_decl(%{TYPE_PARENT})=true}{false}true]]

f _tn_impl
	[{"%{%1N}N"=""}[{%X{lid}=cpp}{%f_set_var(%1N,"%t_n(%S,"%X{lid}")")}\
	[{%SS=UMLPrimitive&%f_need_server_type_decl(%B)=true}{%f_set_var(%1N,"%t_n(%S,"%X{lid}")")}%f_set_var(%1N,"%t_n(%S,"CORBA_cpp")")]]]\
	%{%1N}N
//#UC END# *4714C479032C*

// определяет является ли тип SimpleClass'ом (или typedef на него или InstanceDef)
t _simple_class
//#UC START# *4714C4BB01B5*
c                               {}
r {%S#f_IsSimpleClass()=true}: {true}
r "%SM"="SimpleClass::Class":   {true}
r "%SM"="Typedef::Class":       {%t_simple_class(%G)}
r "%SM"="InstanceDef::Class":   {%t_simple_class(%R)}
r ""="":                        {false}
//#UC END# *4714C4BB01B5*

// опредяеляет имеет ли должен ли элемент заданного типа иметь счётчик ссылок
t _refcounted
//#UC START# *4714C50100BB*
c                                                                 {}
r {%t_interface(%S)=true|%SS=LocalInterface}:                     {true}
r {%SM=Servant::Class}:                                           {true}
r {%SM=ComServant::Class}:                                        {true}
r {%SM=SimpleClass::Class&%S%f_has_refcount()=true}:              {true}
r {%SC=Parameter&%PC=Class&%SS=withref}:                          {true}
r {%SM=Typedef::Class}:                                           {%t_refcounted(%G)}
r {0=0}:                                                          {false}
//#UC END# *4714C50100BB*

// определяет ли тип типом реализации
t _impl_class
//#UC START# *4714C5340271*
c                                 {}
r "%SM"="SimpleClass::Class":     {true}
r "%SM"="Servant::Class":         {true}
r "%SM"="KMacroPlugin::Class":    {true}
r "%SM"="KJobPlugin::Class":      {true}
r "%SM"="KSpringPlugin::Class":   {true}
r "%SM"="KActionPlugin::Class":   {true}
r "%SM"="KLifecyclePlugin::Class":   {true}
r "%SM"="KExtractorPlugin::Class":   {true}
r "%SM"="KVelocityContextPlugin::Class":   {true}
r "%SM"="KComponentPlugin::Class":   {true}
r "%SM"="KListenerPlugin::Class":   {true}
r "%SM"="KServletPlugin::Class":   {true}
r "%SM"="ComServant::Class":      {true}
r "%SM"="Dialog::Class":          {true}
r "%SM"="GuiControl::Class":      {true}
r "%SM"="PropertyPage::Class":    {true}
r "%SM"="PropertySheet::Class":   {true}
r "%SM"="Typedef::Class":         {%t_impl_class(%G)}
r ""="":                          {false}

t _sm_elements
c                                                     {}
r "%SM"="StateMachine::Class::StateMachine::State":   {true}
r "%SC"="TransitionEvent":                            {true}
r "%SM"="Typedef::Class":                             {%t_impl_class(%G)}
r ""="":                                              {false}
//#UC END# *4714C5340271*

// выводит тип первого атрибута не фиксированного размера
f _dump_first_not_fixed_attr
//#UC START# *4714C5B902BF*
	[{%f_exists_in_list(NOT_FIXED_ATTRS,S)=false}%f_add_to_list(NOT_FIXED_ATTRS,S)<{}{%CC=Attribute}[{%f_is_not_fixed_complex(%C%T)=false}{%C%TU}%f_dump_first_not_fixed_attr(%C%T)]>]
//#UC END# *4714C5B902BF*

// возвращает true, если элемент имеет атрибуты не фиксированнаго размера
f _has_not_fixed_complex
//#UC START# *4714C5C1031C*
	%f_clear_list(NOT_FIXED_ATTRS)[{"%f_dump_first_not_fixed_attr(%S)"!=""}{false}true]%f_clear_list(NOT_FIXED_ATTRS)
//#UC END# *4714C5C1031C*

// class-like types
t _class_type
//#UC START# *4714C5CD0196*
c                               {}
r "%t_interface(%S)"="true":    {true}
r "%t_impl_class(%S)"="true":   {true}
r ""="":                        {false}
//#UC END# *4714C5CD0196*

// struct-like types
t _struct_type
//#UC START# *4714C5DE004E*
c                               {}
r "%SM"="Struct::Class":        {true}
r "%SM"="Typedef::Class":       {%t_struct_type(%G)}
r ""="":                        {false}
//#UC END# *4714C5DE004E*

// определяет является ли тип элемента серверным
f _is_server_type
//#UC START# *4714C5F300DA*
	[{%SS=ServerInterface|%SS=ServerFacet}{[{<{}{%PS=ServerInterfaces}{C}>!=0}{false}true]}true]
//#UC END# *4714C5F300DA*

// поределяет использует ли элемент как серверный
f _use_as_srv_type
//#UC START# *4714C612004E*
	[{%SS=ServerInterface|%SS=ServerFacet|%S<{}{%RS=ServerInterface|%RS=ServerFacet}{C}>!=0}{[{<{}{%PS=ServerInterfaces}{C}>!=0}{false}true]}true]

f _realize_srv_type
	[{%SS=ServerInterface|%SS=ServerFacet|%S<{}{%RS=ServerInterface|%RS=ServerFacet}{C}>!=0|%S<{}{%RS=LocalInterface&%R<{}{%f_is_server_type(%r)=true}{C}>!=0}{%RC}>!=0}{[{<{}{%PS=ServerInterfaces}{C}>!=0}{false}true]}true]
//#UC END# *4714C612004E*

// возвращает true, если для атрибута можно сгенерить НЕ константный get-акцессор
f _beaccessed
//#UC START# *4714C679003E*
	[{%TN=pointer|%t_class_type(%T)=true}{false}[{%f_is_server_type(%T)=false&%Ss!=const&%Ss!=const,cached&%Ss!=const,ref}{false}true]]
//#UC END# *4714C679003E*

// определяет будет ли элемент заданного типа иметь  "оператор меньше"
t _has_less
//#UC START# *4714C6B6001F*
c                             {}
r "%SN"="atomic":             {true}
r "%SN"="unsigned atomic":    {true}
r "%SN"="short":              {true}
r "%SN"="long":               {true}
r "%SN"="long long":          {true}
r "%SN"="unsigned short":     {true}
r "%SN"="unsigned long":      {true}
r "%SN"="unsigned long long": {true}
r "%SN"="integer":            {true}
r "%SN"="unsigned integer":   {true}
r "%SN"="float":              {true}
r "%SN"="double":             {true}
r "%SN"="boolean":            {true}
r "%SN"="tribool":            {true}
r "%SN"="char":               {true}
r "%SN"="wchar":              {true}
r "%SN"="unsigned char":      {true}
r "%SN"="a-string":           {true}
r "%SN"="w-string":           {true}
r "%SN"="c-string":           {true}
r "%SN"="octet":              {true}
r "%SN"="size":               {true}
r "%SM"="Enum::Class":        {true}
r "%SM"="Iterator::Class":         {true}
r "%SM"="Const Iterator::Class":   {true}
r "%SM"="Union::Class":   {%S{Need less}}
r "%SM"="Typedef::Class":     {%t_has_less(%G)}
r ""="":                      {false}
//#UC END# *4714C6B6001F*

// возвращает true, если не требуется дополнительный маппинг  для DLL
t _dll_direct
//#UC START# *4714C6E40119*
c                             {} 
r "%SN"="void":               {true}
r "%SN"="short":              {true}
r "%SN"="long":               {true}
r "%SN"="long long":          {true}
r "%SN"="unsigned short":     {true}
r "%SN"="unsigned long":      {true}
r "%SN"="unsigned long long": {true}
r "%SN"="unsigned integer":   {true}
r "%SN"="integer":            {true}
r "%SN"="float":              {true}
r "%SN"="double":             {true}
r "%SN"="boolean":            {true}
r "%SN"="char":               {true}
r "%SN"="unsigned char":      {true}
r "%SN"="wchar":              {true}
r "%SN"="octet":              {true}
r "%SN"="string":             {true}
r "%SN"="wstring":            {true}
r "%SN"="pointer":            {true}
r "%SN"="octet":              {true}
r "%SN"="fixed":              {true}
r "%SN"="size":               {true}
r "%SM"="Enum::Class":        {true}
r "%SM"="Struct::Class"&"<{}{"%t_dll_direct(%C%T)"="false"}{%CC}>"="0":  {true}
r "%SM"="Typedef::Class":     {%t_dll_direct(%G)}
r ""="":                      {false}
//#UC END# *4714C6E40119*

// возвращает true, если элемент имеет tie - обёртку
t _tied_elem
//#UC START# *4714C72601A5*
c                             {} 
r {%SS=Vector}:               {true}
r {%SS=Set}:                  {true}
r ""="":                      {false}
//#UC END# *4714C72601A5*

// возвращает true, если нужна tie-обёртка
f _need_tie
//#UC START# *4714C74200AB*
	[{"%t_dll_direct(%S)"="false"}{false}true]
//#UC END# *4714C74200AB*

// является ли тип фиксированным простым (по сути это все примитивные типы такие как long, short,
// boolean и т.д.)
f _is_fixed_simple
//#UC START# *4714C7670148*
@ %SU
	[{%t_simple(%S)=true&%Sf=true&%t_refcounted(%S)=false}{false}true]
//#UC END# *4714C7670148*

// является ли элемент составным типом, но ведущим себя как примитивный тип (обладающий свойством
// атомарности), это все структуры состоящие из fixedsimple или fixedcomplex и два типа строки a-
// string и c-string (константная строка).
f _is_fixed_complex
//#UC START# *4714C796001F*
@ %SU
	[{%t_simple(%S)=false&%Sf=true&%t_refcounted(%S)=false}{false}true]
//#UC END# *4714C796001F*

// является ли тип примитивным, не фиксированного размера, например указатель на массив символов
// (string) или указатель на блок памяти (pointer)
f _is_not_fixed_simple
//#UC START# *4714C7C600AB*
@ %SU
	[{%t_simple(%S)=true&%Sf=false&%t_refcounted(%S)=false}{false}true]
//#UC END# *4714C7C600AB*

// является ли тип составным типом содержащим в себе не фиксированные агрегаты, а так же
// СимплКлассы без счетчика ссылок.
f _is_not_fixed_complex
//#UC START# *4714C7DF0119*
@ %SU
	[{%t_simple(%S)=false&%Sf=false&%t_refcounted(%S)=false}{false}true]
//#UC END# *4714C7DF0119*

// генерация аргумента функции
f _arg
//#UC START# *4714C8180196*
@ %SU_%BU_%X{lid}_%XU
	[{%SN=void}%f_error("<{}{}{r}%PN::>%SN - void cant be passed as function argument")]\
/	%f_arg_impl(%S,"%SU_%BU_%X{lid}_%XU_TN")
	%t_arg(%T,"%SS",%S)

f _set_arg
	[{"%{%1N}N"=""}%f_set_var(%1N,"%t_arg(%T,"%SS",%S)")]

f _arg_impl
	[{"%{%1N}N"=""}%f_set_var(%1N,"%t_arg(%T,"%SS",%S)")]\
	%{%1N}N
//#UC END# *4714C8180196*

// генерация типа возвращаемого значения функции
f _ret
//#UC START# *4714C82B007D*
@ %SU_%{__SCOPE}U_%BU_%X{lid}_%XU
	%f_init_scope_for_ret(%S)\
/	%f_ret_impl(%S,"%SU_%{__SCOPE}U_%BU_%X{lid}_%XU_TN")
	%t_ret(%T,"%Ss")%f_set_var(TYPE_PARENT,"")%f_set_var(__SCOPE,"")

f _init_scope_for_ret
	[{%t_class_type(%P)=true}{%f_set_var(__SCOPE,P)%f_set_var(TYPE_PARENT,P)}\
	%f_set_var(__SCOPE,{SERV})%f_set_var(TYPE_PARENT,P)]

f _ret_impl
	[{"%{%1N}N"=""}%f_set_var(%1N,"%t_ret(%T,"%Ss")")]\
	%{%1N}N
//#UC END# *4714C82B007D*

// генерация типа атрибута
f _attr
//#UC START# *4714C843005D*
	%t_attr(%T,"%Sl[-%Ss]",%S)\
	[{%SN=void}%f_error("<{}{}{r}%PN::>%SN - void cant be used as data attribute")]
//#UC END# *4714C843005D*

// генерация константного get-метода доустпа к атрибуту
f _iget_attr
//#UC START# *4714C851032C*
	%t_ret(%T,"%f_accessor_ret_st(%S)")

/	[{%f_use_as_srv_type(%B)=false}{%t_ret(%T,"")}[{%Sl=agr}{%t_ret(%T,"const")}%t_ret(%T,"const,cached")]]

f _accessor_ret_st
	[{%f_use_as_srv_type(%B)=false&%f_is_server_type(%P)=false}[{%Sl=agr}{const}const,cached]]
//#UC END# *4714C851032C*

// генерация НЕ константного get-метода доустпа к атрибуту
f _igetnc_attr
//#UC START# *4714C8800000*
	[{%Sl=agr&%t_class_type(%T)=true}{%t_ret(%T,"")}%t_ret(%T,"cached")]
//#UC END# *4714C8800000*

// генерация set-акцессора атрибута
f _iset_attr
//#UC START# *4714C89002FD*
	[{%Ss!=const&%t_refcounted(%T)=true&%f_is_server_type(%T)=false}{%t_arg(%T,"in",%S)}%t_arg(%T,"inout",%S)]
//#UC END# *4714C89002FD*

// выводит тип элемента
f _type
//#UC START# *4714C8CA01A5*
	%t_decl(%S,"typ")
//#UC END# *4714C8CA01A5*

// генерация Var'а для элемента
f _var
//#UC START# *4714C8DB02DE*
	%t_decl(%S,"var")
//#UC END# *4714C8DB02DE*

// генерация константного Var'а для элемента
f _cvar
//#UC START# *4714C8F100DA*
	%t_decl(%S,"cvar")
//#UC END# *4714C8F100DA*

// генерация параметра операции, дополнительно генерит значение по умолчанию (если есть)
f _arg_full_decl
//#UC START# *4714C9150280*
	[{%X{lid}!=delphi}{%f_arg(%S)[ = %f_init(%S)]}\
	%f_arg(%S) [{%X{lid}!=java}{%f_to_java(%SN)}%SN][{%XU=h&"%SI"!=""}[ = %f_init(%S)]]]
//#UC END# *4714C9150280*

// возвращаемое значение функции
f _cpp_ret
//#UC START# *4714C9780109*
	%f_with_gen_id(cpp,%f_ret(%S))
//#UC END# *4714C9780109*

// тип элемента
f _cpp_type
//#UC START# *4714C98F0242*
	%f_with_gen_id(cpp,%f_type(%S))
//#UC END# *4714C98F0242*

// выводит аргумент функции
t _arg
//#UC START# *4714C9A0031C*
c                         {}
r "%X{lid}"="cpp":        {%t_arg_cpp(%S,%1)}
r "%X{lid}"="dll_cpp":    {%t_arg_dll_cpp(%S,%1,%2)}
r "%X{lid}"="idl":        {%t_arg_idl(%S,%1)}
r "%X{lid}"="delphi":     {%t_arg_delphi(%S,%1,%2)}
r "%X{lid}"="java":       {%t_arg_java(%S,%1)}
r ""="":                  {%f_error("Arguments types maping is undefined for %XN")}

f _by_ref
	[{%t_size_of(%S)!=undef}{true}[{%f_number_cmp("%t_size_of(%S)","4","\>")=1}{false}true]]
//#UC END# *4714C9A0031C*

// деларация типа
t _decl
//#UC START# *4714C9C5004E*
c                       {}
r "%X{lid}"="cpp":      {%t_decl_cpp(%S,%1)}
r "%X{lid}"="dll_cpp":  {%t_decl_cpp(%S,%1)}
r "%X{lid}"="idl":      {%t_decl_idl(%S,%1)}
r "%X{lid}"="delphi":   {%t_decl_delphi(%S,%1)}
r "%X{lid}"="java":     {%t_decl_java(%S,%1)}
r ""="":                {%f_error("Decloration types maping (%SN) is undefined for %XN")}
//#UC END# *4714C9C5004E*

// выводит тип возвращаемого значения
t _ret
//#UC START# *4714C9CD0177*
c                      {}
r "%X{lid}"="cpp":     {%t_ret_cpp(%S,%1)}
r "%X{lid}"="dll_cpp": {%t_ret_cpp(%S,%1)}
r "%X{lid}"="idl":     {%t_ret_idl(%S,%1)}
r "%X{lid}"="delphi":  {%t_ret_delphi(%S,%1)}
r "%X{lid}"="java":    {%t_ret_java(%S,%1)}
r ""="":               {%f_error("Function returns types maping is undefined for %XN")}
//#UC END# *4714C9CD0177*

// выводит тип атрибута
t _attr
//#UC START# *4714C9ED0232*
c                        {}
r "%X{lid}"="cpp":       {%t_attr_cpp(%S,%1,%2)}
r "%X{lid}"="dll_cpp":   {%t_attr_cpp(%S,%1,%2)}
r "%X{lid}"="idl":       {%t_attr_idl(%S,%1,%2)}
r "%X{lid}"="delphi":    {%t_attr_delphi(%S,%1,%2)}
r "%X{lid}"="java":      {%t_attr_java(%S,%1,%2)}
r ""="":                 {%f_error("Attribute type maping is undefined for %XN")}
//#UC END# *4714C9ED0232*

// выводит тип аргумента (dll.cpp)
t _arg_dll_cpp
//#UC START# *4714CFDA00AB*
c                                                                  {in}                                                                  {inout}                                             {out}
r {%t_refcounted(%S)=true|%t_is_container(%S)=true}:               {[{%f_is_server_type(%S)=false}const ]%f_tn(%S)*}                     {%f_tn(%S)*[{%f_is_server_type(%S)=true}&]}         {%f_tn(%S)[{%f_is_server_type(%B)=false}{_out}*&]}
r "%f_is_fixed_simple(%S)"="true":                                 {%f_tn(%S)}                                                           {%f_tn(%S)&}                                        {%f_tn(%S)&}
r "%SN"="c-string":                                                {const %f_tn(%S)&}                                                    {%f_cstr_nconst(%S)}                                {%f_tn(%S)*&}
r "%f_is_fixed_complex(%S)"="true":                                {const %f_tn(%S)[{%f_by_ref(%S)=true}&]}                              {%f_tn(%S)&}                                        {%f_tn(%S)[{%f_is_server_type(%S)=false}{_out}&]}
r "%SN"="string":                                                  {const %f_tn(%S)}                                                     {%f_tn(%S)[{%f_is_server_type(%B)=true}&]}          {[{%f_is_server_type(%B)=false}{CORBA::String_out}%f_tn(%S)&]}
r {%SS=Typedef&%GN=string}:                                        {[{%f_use_as_srv_type(%B)=true}{const %f_tn(%S)}%f_tn(%S)_const]}     {%f_tn(%S)[{%f_is_server_type(%B)=true}&]}          {%f_tn(%S)[{%f_is_server_type(%B)=false}{_out}&]}
r "%f_is_not_fixed_simple(%S)"="true":                             {const %f_tn(%S)}                                                     {%f_tn(%S)}                                         {%f_tn(%S)&}
r "%f_is_not_fixed_complex(%S)"="true":                            {const %f_tn(%S)[%f_callback_prefix(%2)][{%f_by_ref(%S)=true}&]}       {%f_tn(%S)[%f_callback_prefix(%2)]&}                {%f_tn(%S)[%f_callback_prefix(%2)][{%f_is_server_type(%B)=false}{_out}&]}

f _callback_prefix
	[{%TS=Struct&%P%P{call way}=back}_for_callback]
//#UC END# *4714CFDA00AB*

// выводит тип агрумента (cpp)
t _arg_cpp
//#UC START# *4714CFF3001F*
c                                         {in}                                              {inout}              {out}                                                                                                     {nokey}                                  {inref}                                                {inoutref}                     {cache}
r "%f_is_fixed_simple(%S)"="true":        {%f_tn(%S)}                                       {%f_tn(%S)&}         {%f_tn(%S)&}                                                                                              {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r "%SM"="FactoryMemory::Class":           {%f_type(%P)FactoryManager::%S%f_factory_mem_key_name()}  {%f_type(%P)FactoryManager::%S%f_factory_mem_key_name()&}  {%f_type(%P)FactoryManager::%S%f_factory_mem_key_name()&}   {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r "%SN"="c-string":                       {const %f_tn(%S)&}                                {%f_cstr_nconst(%S)} {%f_tn(%S)*&}                                                                                             {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r "%f_is_fixed_complex(%S)"="true":       {const %f_tn(%S)&}                                {%f_tn(%S)&}         {%f_tn(%S)[{%f_is_server_type(%S)=false}{_out}*&]}                                                        {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r "%SN"="string":                         {const %f_tn(%S)}                                 {%f_tn(%S)[{%f_is_server_type(%B)=true}&]}          {[{%f_is_server_type(%B)=false}{CORBA::String_out}%f_tn(%S)&]}             {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r "%SN"="wstring":                        {const %f_tn(%S)}                                 {%f_tn(%S)[{%f_is_server_type(%B)=true}&]}          {[{%f_is_server_type(%B)=false}{CORBA::WString_out}%f_tn(%S)&]}            {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r {%SS=Typedef&%GN=string}:               {%f_tn(%S)_const}    {%f_tn(%S)[{%f_is_server_type(%B)=true}&]}          {%f_tn(%S)[{%f_is_server_type(%B)=false}{_out}&]}                                                       {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r "%f_is_not_fixed_simple(%S)"="true":    {const %f_tn(%S)}                                 {%f_tn(%S)}          {%f_tn(%S)&}                                                                                              {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r "%f_is_not_fixed_complex(%S)"="true":   {const %f_tn(%S)&}                                {%f_tn(%S)&}         {%f_tn(%S)[{%f_is_server_type(%B)=false}{_out}*&]}                                                        {%t_arg_cpp(%S,"in")}                    {%t_arg_cpp(%S,"in")}                                  {%t_arg_cpp(%S,"in")}          {%t_arg_cpp(%S,"in")}
r {%t_refcounted(%S)=true}:               {[{%f_is_server_type(%S)=false}const ]%f_tn(%S)*} {%f_tn(%S)*[{%f_is_server_type(%S)=true}&]}         {%f_tn(%S)[{%f_is_server_type(%B)=false}{_out}*&]}                         {%t_arg_cpp(%S,"in")}                    {[{%f_is_server_type(%S)=false}const ]%f_tn(%S)&}      {%f_tn(%S)&}                   {%t_arg_cpp(%S,"in")}
//#UC END# *4714CFF3001F*

// выводит тип агрумента (idl)
t _arg_idl
//#UC START# *4714D03A0157*
c                                         {in}            {inout}             {out}..............{nokey}                   {cache}
r "%SN"="c-string":                       {ERROR}         {ERROR}             {ERROR}............{%t_arg_idl(%S,"in")}     {%t_arg_idl(%S,"in")}
r ""="":                                  {in %f_tn(%S)}  {inout %f_tn(%S)}   {out %f_tn(%S)}....{%t_arg_idl(%S,"in")}     {%t_arg_idl(%S,"in")}
//#UC END# *4714D03A0157*

// выводит тип аргумента (java)
t _arg_java
//#UC START# *4714D0DE0196*
c                                                                                     {in}                                                            {inout}              {out}.................{nokey}                                                                                             {cache}
r {%f_is_string(%S)=true|%f_is_wstring(%S)=true}:                                     {[{%f_use_as_srv_type(%B)=false}final ]%t_attr_java(%S)}        {StringBuilder}      {StringBuilder}       {%t_arg_java(%S,"in")}                                                                              {%t_arg_java(%S,"in")}
r "%SM"="FactoryMemory::Class":                                                       {final %f_type(%P)FactoryManager.%S%f_factory_mem_key_name()}   {%f_type(%P)FactoryManager.%S%f_factory_mem_key_name()}  {%f_type(%P)FactoryManager.%S%f_factory_mem_key_name()}   {%t_arg_cpp(%S,"in")}       {%t_arg_java(%S,"in")}
r ""="":                                                                              {[{%f_use_as_srv_type(%B)=false}final ]%t_attr_java(%S)}        {%t_attr_java(%S)}   {%t_attr_java(%S)}....{%t_arg_java(%S,"in")}                                                                              {%t_arg_java(%S,"in")}
//#UC END# *4714D0DE0196*

// выводит тип аргумента (delphi)
t _arg_delphi
//#UC START# *4714D0F60186*
c                                         {in}                                      {inout}                                  {out}
r "%t_is_container(%S)"="true":           {const a%f_to_borland(%2N): %f_tn(%S)}    {const a%f_to_borland(%2N): %f_tn(%S)}   {out a[{"%2x"="true"}{Ret}%f_to_borland(%2N)] {: %f_tn(%S)}}
r "%f_is_fixed_simple(%S)"="true":        {a%f_to_borland(%2N): %f_tn(%S)}          {var a%f_to_borland(%2N): %f_tn(%S)}     {out a%f_to_borland(%2N): %f_tn(%S)}
r "%SN"="c-string":                       {ERROR}                                   {ERROR}                                  {ERROR}
r "%f_is_fixed_complex(%S)"="true":       {const a%f_to_borland(%2N): %f_tn(%S)}    {const a%f_to_borland(%2N): %f_tn(%S)}   {out a%f_to_borland(%2N): %f_tn(%S)}
r "%f_is_not_fixed_simple(%S)"="true":    {const a%f_to_borland(%2N): %f_tn(%S)}    {var a%f_to_borland(%2N): %f_tn(%S)}     {out a%f_to_borland(%2N): %f_tn(%S)}
r "%f_is_not_fixed_complex(%S)"="true":   {const a%f_to_borland(%2N): %f_tn(%S)}    {var a%f_to_borland(%2N): %f_tn(%S)}     {out a%f_to_borland(%2N): %f_tn(%S)}
r "%t_refcounted(%S)"="true":             {const a%f_to_borland(%2N): %f_tn(%S)}    {const a%f_to_borland(%2N): %f_tn(%S)}   {out a[{"%2x"="true"}{Ret}%f_to_borland(%2N)] {: %f_tn(%S)}}
//#UC END# *4714D0F60186*

// выводит сигнатуру для типа c-string, когда этот тип используется как НЕ константный
f _cstr_nconst
//#UC START# *4714D12300CB*
	%f_error("%B%PN::%BN - c-string cant be used as non const object")
//#UC END# *4714D12300CB*

// декларация тип (cpp)
t _decl_cpp
//#UC START# *4714D13001F4*
c                                                     {typ}         {var}                            {cvar}
r {%t_check_type(%S,"ComInterface::Class")=true}:     {%f_tn(%S)}   {ATL::CComPtr\<%f_tn(%S)\>}      {const ATL::CComPtr\<%f_tn(%S)\>}
r "%t_refcounted(%S)"="true":                         {%f_tn(%S)}   {%f_tn(%S)_var}                  {[{%f_is_server_type(%S)=false}{%t_decl_cpp(%S,"var")}const %f_tn(%S)_cvar]}
r "%t_refcounted(%S)"="false":                        {%f_tn(%S)}   {%f_tn(%S)}                      {[{%f_is_server_type(%S)=false}{%t_decl_cpp(%S,"var")}const %f_tn(%S)]}
//#UC END# *4714D13001F4*

// декларация типа (delphi)
t _decl_delphi
//#UC START# *4714D1420119*
c          {typ}         {var}            {cvar}
r ""="":   {%f_tn(%S)}   {%f_tn(%S)}      {%f_tn(%S)}
//#UC END# *4714D1420119*

// декларация типа (idl)
t _decl_idl
//#UC START# *4714D1510251*
c          {typ}         {var}            {cvar}
r ""="":   {%f_tn(%S)}   {%f_tn(%S)}      {%f_tn(%S)}
//#UC END# *4714D1510251*

// декларация типа (java)
t _decl_java
//#UC START# *4714D16A02EE*
c          {typ}         {var}            {cvar}
r ""="":   {%f_tn(%S)}   {%f_tn(%S)}      {%f_tn(%S)}
//#UC END# *4714D16A02EE*

// выводит тип возвращаемого значения функции (cpp)
t _ret_cpp
//#UC START# *4714D183003E*
c                                                       {}                                                                                              {const}                                                                 {cached}                        {const,cached}                                                                              {synchro}
r "%SN"="void":                                         {void}                                                                                          {ERROR}                                                                 {ERROR}                         {ERROR}                                                                                     {%t_ret_cpp(%S,"")}
r {%SS=Typedef&%GN=string}:                             {%f_tn(%S)}                                                                                     {%f_tn(%S)_const}                                                       {%f_tn(%S)&}                    {const %f_tn(%S)_const&}                                                                    {%t_ret_cpp(%S,"")}
r "%f_is_fixed_simple(%S)"="true":                      {%f_tn_prefix(%S)%f_tn(%S)}                                                                     {const %f_tn(%S)}                                                       {%f_tn(%S)&}                    {%f_tn(%S)}                                                                                 {%t_ret_cpp(%S,"")}
r "%SN"="c-string":                                     {%f_tn(%S)*}                                                                                    {const %f_tn(%S)}                                                       {%f_cstr_nconst(%S)}            {const %f_tn(%S)&}                                                                          {%t_ret_cpp(%S,"")}
r "%f_is_fixed_complex(%S)"="true":                     {%f_tn_prefix(%S)%f_tn(%S)[{%f_is_server_type(%S)=false|%t_is_container(%S)=true}*]}            {const %f_tn_prefix(%S)%f_tn(%S)}                                       {%f_tn_prefix(%S)%f_tn(%S)&}    {const %f_tn_prefix(%S)%f_tn(%S)&}                                                          {%t_ret_cpp(%S,"")}
r "%f_is_not_fixed_simple(%S)"="true":                  {%f_tn(%S)}                                                                                     {%f_nfs_cret(%S)}                                                       {%f_tn(%S)&}                    {const %f_tn(%S)}                                                                           {%t_ret_cpp(%S,"")}
r "%f_is_not_fixed_complex(%S)"="true":                 {%f_tn_prefix(%S)%f_tn(%S)*}                                                                    {%f_nfc_cret(%S)}                                                       {%f_tn_prefix(%S)%f_tn(%S)&}    {const %f_tn_prefix(%S)%f_tn(%S)&}                                                          {%t_ret_cpp(%S,"")}
r "%t_refcounted(%S)"="true":                           {%f_tn_prefix(%S)%f_tn(%S)*}                                                                    {[{%f_is_server_type(%S)=false}const ]%f_tn_prefix(%S)%f_tn(%S)*}       {%f_tn_prefix(%S)%f_tn(%S)&}    {[{%f_is_server_type(%S)=false}const ]%f_tn_prefix(%S)%f_tn(%S)&}                           {%t_ret_cpp(%S,"")}
/r "%SS"="ServerInterface":                             {%f_tn_prefix(%S)%f_tn(%S)_ptr}                                                                 {%f_tn_prefix(%S)%f_tn(%S)_ptr}                                         {%f_tn_prefix(%S)%f_tn(%S)&}    {%f_tn_prefix(%S)%f_tn(%S)&}                                                                {%t_ret_cpp(%S,"")}
/r "%t_refcounted(%S)"="true":                          {%f_tn_prefix(%S)%f_tn(%S)*}                                                                    {const %f_tn_prefix(%S)%f_tn(%S)*}                                      {%f_tn_prefix(%S)%f_tn(%S)&}    {const %f_tn_prefix(%S)%f_tn(%S)&}                                                          {%t_ret_cpp(%S,"")}
//#UC END# *4714D183003E*

// выводит тип возвращаемого значения функции (delphi)
t _ret_delphi
//#UC START# *4714D197000F*
c                                       {}           {const}       {cached}    {const,cached}   {synchro}
r "%SN"="void":                         {void}       {1ERROR}      {2ERROR}    {3ERROR}         {%t_ret_delphi(%S,"")}
r "%f_is_fixed_simple(%S)"="true":      {%f_tn(%S)}  {%f_tn(%S)}   {%f_tn(%S)} {%f_tn(%S)}      {%t_ret_delphi(%S,"")}
r "%f_is_not_fixed_simple(%S)"="true":  {4ERROR}     {%f_tn(%S)}   {%f_tn(%S)} {%f_tn(%S)}      {%t_ret_delphi(%S,"")}
r ""="":                                {6ERROR}     {7ERROR}      {8ERROR}    {9ERROR}         {%t_ret_delphi(%S,"")}
//#UC END# *4714D197000F*

// выводит тип возвращаемого значения функции (idl)
t _ret_idl
//#UC START# *4714D1AE02BF*
c           {}           {const}       {cached}      {const,cached}   {synchro}
r ""="":    {%f_tn(%S)}  {%f_tn(%S)}   {%f_tn(%S)}   {%f_tn(%S)}      {%t_ret_idl(%S,"")}
//#UC END# *4714D1AE02BF*

// выводит тип возвращаемого значения функции (java)
t _ret_java
//#UC START# *4714D1D701E4*
c           {}                   {const}              {cached}             {const,cached}         {synchro}
r ""="":    {%t_attr_java(%S)}   {%t_attr_java(%S)}   {%t_attr_java(%S)}   {%t_attr_java(%S)}     {%t_ret_java(%S,"")}
//#UC END# *4714D1D701E4*

// выводит константный тип возвращаемого значения функции для нефиксированного типа
f _nfc_cret
//#UC START# *4714D205002E*
	[{%S{Need assign op}!=true&%t_is_container(%S)=false}{const %f_tn_prefix(%S)%f_tn(%S)}%f_error("%B<{}{}{r}%PN::>%BN - Not fixed type (%SN) must have copy operator to be able to returned by const value")]
//#UC END# *4714D205002E*

// выводит сигнатуру НЕ фиксированого типа, используемого как возвращаемое НЕ константное значение
f _nfs_cret
//#UC START# *4714D2A300DA*
	%f_error("%B<{}{}{r}%PN::>%BN - Not fixed simple type (%SN) cant be returned as \<\<const\>\>. Use \<\<const,cached\>\> to return const cached pointers, or \<\<\>\> for return non const pointer to newly allocated data")
//#UC END# *4714D2A300DA*

// выводит тип Var'а
t _var_type
//#UC START# *4714D345037A*
c                                      {var}                                                                                                                     {cvar}
r "%f_is_server_type(%S)"="true":      {%f_tn_prefix(%S)]%f_tn(%S)_var}                                                                                          {%f_error("No cvar for server object%SN")}
r ""="":                               {[{%t_is_container(%{__SCOPE})=false}{Core::Var\<%f_tn_prefix(%S)%f_tn(%S)\>}%f_tn_prefix(%S)%f_tn(%S)_var]}                 {[{%t_is_container(%{__SCOPE})=false}{Core::Var\<const %f_tn_prefix(%S)%f_tn(%S)\>}%f_tn_prefix(%S)%f_tn(%S)_cvar]}
//#UC END# *4714D345037A*

// выводит тип атрибута (cpp)
t _attr_cpp
//#UC START# *4714D363031C*
c                                       {agr}                                              {agr-const}                                        {agr-ref}                                     {agr-const,ref}                                     {ref}                                                                                     {ref-const}                                     {lnk}                         {lnk-const}                        {lnk-ref}                      {lnk-const,ref}                      {}
r "%f_is_fixed_simple(%S)"="true":      {[{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)}         {const [{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)}   {[{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)&}   {const [{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)&}   {Core::Box\<[{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)\>}                                   {Core::Box\<const [{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)\>}                  {[{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)*}                  {const [{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)*}                 {[{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)*&}                  {const [{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)*&}                  {%f_error("Cant use this type of attributes (%BN::%SN,%1N)")}
r "%f_is_fixed_complex(%S)"="true":     {%f_tn_prefix(%S)%f_tn(%S)}                        {const %f_tn_prefix(%S)%f_tn(%S)}                  {%f_tn_prefix(%S)%f_tn(%S)&}                  {const %f_tn_prefix(%S)%f_tn(%S)&}                  {[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<%f_tn_prefix(%S)%f_tn(%S)\>}        {[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<const %f_tn_prefix(%S)%f_tn(%S)\>}  {%f_tn_prefix(%S)%f_tn(%S)*}  {const %f_tn_prefix(%S)%f_tn(%S)*} {%f_tn_prefix(%S)%f_tn(%S)*&}  {const %f_tn_prefix(%S)%f_tn(%S)*&}  {%f_error("Cant use this type of attributes (%BN::%SN,%1N)")}
r "%SN"="string":                       {%f_tn(%S)}                                        {const %f_tn(%S)}                                  {%f_tn(%S)&}                                  {const %f_tn(%S)&}                                  {[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<char\>}                             {[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<const char\>}                       {%f_tn(%S)*}                  {const %f_tn(%S)*}                 {%f_tn(%S)*&}                  {const %f_tn(%S)*&}                  {%f_error("Cant use this type of attributes (%BN::%SN,%1N)")}
r "%SN"="pointer":                      {%f_tn(%S)}                                        {const %f_tn(%S)}                                  {%f_tn(%S)&}                                  {const %f_tn(%S)&}                                  {[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]x\<void\>}                            {[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<const void\>}                       {%f_tn(%S)*}                  {const %f_tn(%S)*}                 {%f_tn(%S)*&}                  {const %f_tn(%S)*&}                  {%f_error("Cant use this type of attributes (%BN::%SN,%1N)")}
r "%f_is_not_fixed_simple(%S)"="true":  {%f_tn_prefix(%S)%f_tn(%S)}                        {const %f_tn_prefix(%S)%f_tn(%S)}                  {%f_tn_prefix(%S)%f_tn(%S)&}                  {const %f_tn_prefix(%S)%f_tn(%S)&}                  {[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<%f_tn_prefix(%S)%f_tn(%S)\>}        {[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<const %f_tn_prefix(%S)%f_tn(%S)\>}  {%f_tn_prefix(%S)%f_tn(%S)*}  {const %f_tn_prefix(%S)%f_tn(%S)*} {%f_tn_prefix(%S)%f_tn(%S)*&}  {const %f_tn_prefix(%S)%f_tn(%S)*&}  {%f_error("Cant use this type of attributes (%BN::%SN,%1N)")}
r "%f_is_not_fixed_complex(%S)"="true": {%f_tn_prefix(%S)%f_tn(%S)}                        {const %f_tn_prefix(%S)%f_tn(%S)}                  {%f_tn_prefix(%S)%f_tn(%S)&}                  {const %f_tn_prefix(%S)%f_tn(%S)&}                  {[{%f_is_server_type(%S)=false}{%t_var_type(%S,"var")}[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<%f_tn_prefix(%S)%f_tn(%S)\>]}  {[{%f_is_server_type(%S)=false}{%f_tn_prefix(%S)%f_tn(%S)_var}[{%2{smart pointer}!=true}{std::auto_ptr}Core::Box]\<const %f_tn_prefix(%S)%f_tn(%S)\>]}  {%f_tn_prefix(%S)%f_tn(%S)*}  {const %f_tn_prefix(%S)%f_tn(%S)*} {%f_tn_prefix(%S)%f_tn(%S)*&}  {const %f_tn_prefix(%S)%f_tn(%S)*&}  {%f_error("Cant use this type of attributes (%BN::%SN,%1N)")}
r "%t_refcounted(%S)"="true":           {%f_tn_prefix(%S)%f_refc_agr(%S,%2)}               {%f_refc_agr(%S,%2)}                               {%f_refc_agr(%S,%2)}                          {%f_refc_agr(%S,%2)}                                {%t_var_type(%S,"var")}           {%t_var_type(%S,"cvar")}                {%f_tn_prefix(%S)%f_tn(%S)*}  {const %f_tn_prefix(%S)%f_tn(%S)*} {%f_tn_prefix(%S)%f_tn(%S)*&}  {const %f_tn_prefix(%S)%f_tn(%S)*&}  {%f_error("Cant use this type of attributes (%BN::%SN,%1N)")}
//#UC END# *4714D363031C*

// выводит тип атрибута (idl)
t _attr_idl
//#UC START# *4714D372000F*
c                                   {}
r ""="":                            {[%2S ]attribute %f_tn(%S)}
//#UC END# *4714D372000F*

// выводит тип атрибута как указатель
t _pointer_attr
//#UC START# *4714D3900399*
c                                         {}
r "%f_is_fixed_simple(%S)"="true":        {[{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)}
r "%f_is_fixed_complex(%S)"="true":       {%f_tn_prefix(%S)%f_tn(%S)}
r "%SN"="string":                         {%f_tn(%S)}
r "%SN"="pointer":                        {%f_tn(%S)}
r {%SS=Struct}:                           {%f_tn(%S)}
r {%SS=Typedef&<{}{%GS=Struct}{%GC}>!=0}: {%f_tn(%S)}
r "%f_is_not_fixed_simple(%S)"="true":    {%f_tn_prefix(%S)%f_tn(%S)*}
r "%f_is_not_fixed_complex(%S)"="true":   {%f_tn_prefix(%S)%f_tn(%S)*}
r "%t_refcounted(%S)"="true":             {%f_tn_prefix(%S)%f_tn(%S)*}


t _tie_should_be_dereferenced
c                                   {}
r {%t_interface(%S)=true}:          {false}
r {%t_is_container(%S)=true}:       {false}
r {%SS=Struct}:                     {false}
r {%SS=Typedef}:                    {%t_tie_should_be_dereferenced(%G)}
r {}:                               {true}
//#UC END# *4714D3900399*

// возвращает true, если атрибут можно инициализировать
f _can_be_init
//#UC START# *4714D3C103B9*
	%t_is_container(%T)
//#UC END# *4714D3C103B9*

// генерит код инициализации атрибута
t _attr_init_java
//#UC START# *4714D3FB03D8*
c                                   {}
r "%SM"="Map::Class":               {java.util.TreeMap\<%t_key_dump_java(%S), %t_data_dump_java(%S)\>}
r "%SM"="UnsortedMap::Class":       {java.util.HashMap\<%t_key_dump_java(%S), %t_data_dump_java(%S)\>}
r "%SM"="Set::Class":               {java.util.TreeSet\<%t_data_dump_java(%S)\>}
r "%SM"="UnsortedSet::Class":       {java.util.HashSet\<%t_data_dump_java(%S)\>}
r "%SM"="Vector::Class":            {java.util.Vector\<%t_data_dump_java(%S)\>}
r "%SM"="List::Class":              {java.util.ArrayList\<%t_data_dump_java(%S)\>}
r "%SM"="Queue::Class":             {java.util.LinkedList\<%t_data_dump_java(%S)\>}
r ""="":                            {}
//#UC END# *4714D3FB03D8*

// генерит код инициализации атрибута
f _attr_init_java
//#UC START# *4714D45C005D*
	[new %t_attr_init_java(%T) (%t_init_constr_java(%T))]

t _init_constr_java
c                                   {}
r "%SM"="Map::Class":               {<{}{%CS=compare}new %f_type(%C%T) ()>}
r "%SM"="UnsortedMap::Class":       {}
r "%SM"="Set::Class":               {<{}{%CS=compare}new %f_type(%C%T) ()>}
r "%SM"="UnsortedSet::Class":       {}
r "%SM"="Vector::Class":            {}
r "%SM"="List::Class":              {}
r "%SM"="Queue::Class":             {}
r ""="":                            {}
//#UC END# *4714D45C005D*

// генерация ключа ассоциативного контэйнера
t _key_dump_java
//#UC START# *4714D4CD0251*
c                                  {}
r "%f_key_dump(%S)"="int":         {Integer}
r "%f_key_dump(%S)"="long":        {Long}
r "%f_key_dump(%S)"="boolean":     {Boolean}
r "%f_key_dump(%S)"="char":        {Character}
r ""="":                           {%f_key_dump(%S)}

t _data_dump_java
//#UC START# *4714D4CD0251*
c                                  {}
r "%f_data_dump(%S)"="int":         {Integer}
r "%f_data_dump(%S)"="long":        {Long}
r "%f_data_dump(%S)"="boolean":     {Boolean}
r "%f_data_dump(%S)"="char":        {Character}
r "%f_data_dump(%S)"="byte":        {Byte}
r "%f_data_dump(%S)"="short":       {Short}
r "%f_data_dump(%S)"="double":      {Double}
r "%f_data_dump(%S)"="float":       {Float}
r ""="":                            {%f_data_dump(%S)}
//#UC END# *4714D4CD0251*

// выводит тип атрибута (java)
t _attr_java
//#UC START# *4714D4ED01E4*
c                                   {}
r "%SM"="Map::Class":               {java.util.Map\<%t_key_dump_java(%S), %t_data_dump_java(%S)\>}
r "%SM"="UnsortedMap::Class":       {java.util.Map\<%t_key_dump_java(%S), %t_data_dump_java(%S)\>}
r "%SM"="Set::Class":               {java.util.Set\<%t_data_dump_java(%S)\>}
r "%SM"="UnsortedSet::Class":       {java.util.Set\<%t_data_dump_java(%S)\>}
r "%SM"="Vector::Class":            {[{%f_is_server_type(%S)=false}{%f_data_dump(%S)\[\]}java.util.List\<%t_data_dump_java(%S)\>]}
r "%SM"="List::Class":              {[{%f_is_server_type(%S)=false}{%f_data_dump(%S)\[\]}java.util.List\<%t_data_dump_java(%S)\>]}
r "%SM"="Queue::Class":             {java.util.Queue\<%t_data_dump_java(%S)\>}
r ""="":                            {%f_tn(%S)}
//#UC END# *4714D4ED01E4*

// выводит сигнатуру агрегированного типа со счетчиком ссылок
f _refc_agr
//#UC START# *4714D508002E*
	%f_error("Refcounted type (%SN in %1%PS %1%PN) can't be agrigated")
//#UC END# *4714D508002E*

// выводит значение по умолчанию
t _init
//#UC START# *4714D54502FD*
c                                                      {}
r "%X{lid}"="cpp":                                     {%t_init_cpp(%S)}
r "%X{lid}"="java":                                    {%t_init_java(%S)}
r "%X{lid}"="idl":                                     {%t_init_idl(%S)}
r "%X{lid}"="delphi":                                  {%t_init_delphi(%S)}
r "%X{lid}"="dll_cpp":                                 {%t_init_dll_cpp(%S)}
r ""="":                                               {%f_error("Can't dump init value for %SN in %X{lid} language")}


t _init_java
c                                                                        {}
r "%SI"="EMPTY_STR":                                                     {""}
r "%SI"="NULL":                                                          {null}
r "%SI"="MAX":                                                           {ERROR}
r {%V%TS=Enum}:                                                          {%f_type(%V%T)[.%VN]}
r {%V%TS=Constants}:                                                     {[{%f_is_nested(%V%T%P)=true}{%f_type(%V%T)}%f_type(%V%T%P)][.%VN]}
r "%V%TN"="atomic"|"%V%TN"="unsigned atomic":                            {new %f_type(%V%T) (%VN)}
r "%V%TN"="time":                                                        {new %f_type(%V%T) (%VN)}
r {%f_is_string(%T)=true}:                                               {"%VN"}
r {%f_is_wstring(%T)=true}:                                              {"%VN"}
r {%TS=UMLPrimitive&%TN=void&%S{forced type}=string}:                    {"%VN"}
r ""="":                                                                 {%VN}

t _init_cpp
c                                                      {}
r {%V%TS=Enum}:                                        {%V%T<%NN::>%VN}
r {%V%TS=Constants}:                                   {[%V%T<%NN::>][%V%T{children prefix}_]%VN}
r "%SI"="EMPTY_STR":                                   {""}
r "%SI"="NULL":                                        {0}
r "%SI"="MAX":                                         {std::numeric_limits \<%f_type(%T)\>::max ()}
r {%f_is_string(%T)=true}:                             {"%VN"}
r {%f_is_wstring(%T)=true}:                            {L"%VN"}
r {%TS=UMLPrimitive&%TN=void&%S{forced type}=string}:  {"%VN"}
r ""="":                                               {%VN}

t _init_delphi
c                                                      {}
r "%SI"="EMPTY_STR":                                   {''}
r "%SI"="NULL":                                        {nil}
r "%SI"="MAX":                                         {ERROR}
r {%f_is_string(%T)=true}:                             {'%VN'}
r {%f_is_wstring(%T)=true}:                            {'%VN'}
r {%TS=UMLPrimitive&%TN=void&%S{forced type}=string}:  {'%VN'}
/r "%TN"="string"|"%TN"="a-string"|"%TN"="c-string":   {%SI}
r ""="":                                               {%SI}

t _init_dll_cpp
c                                                      {}
r "%SI"="EMPTY_STR":                                   {""}
r "%SI"="NULL":                                        {0}
r "%SI"="MAX":                                         {ERROR}
r {%f_is_string(%T)=true}:                             {"%VN"}
r {%f_is_wstring(%T)=true}:                            {"%VN"}
r {%TS=UMLPrimitive&%TN=void&%S{forced type}=string}:  {"%VN"}
r ""="":                                               {%SI}

t _init_idl
c                                                      {}
r "%SI"="EMPTY_STR":                                   {""}
r "%SI"="NULL":                                        {ERROR}
r "%SI"="MAX":                                         {ERROR}
r {%f_is_string(%T)=true}:                             {"%VN"}
r {%f_is_wstring(%T)=true}:                            {"%VN"}
r {%TS=UMLPrimitive&%TN=void&%S{forced type}=string}:  {"%VN"}
r ""="":                                               {%SI}
//#UC END# *4714D54502FD*

// выводит значение по умолчанию
f _init
//#UC START# *4714D55C01F4*
	[{"%SI"!=""}%t_init(%S)]
//#UC END# *4714D55C01F4*

// возвращает true, если тип определяет scope
t _nested_scope_def
//#UC START# *4714D573034B*
c                             {}
r {%t_impl_class(%S)=true}:   {true}
r {%SM=UtilityClass::Class}:  {true}
r {%SM=StateMachine::Class}:  {true}
r {%SM=KXWorkPlugin::Class}:  {true}
r {%SM=Typedef::Class}:       {%t_nested_scope_def(%T)}
r {""=""}:                    {false}
//#UC END# *4714D573034B*

// префикс имени типа
f _tn_prefix
//#UC START# *4714D58000CB*
	[{%PS!=TemplateFunctions}[{%XU=cpp}[{<{}{%PC=Class&%{__SCOPE}U=%PU}{%PC}>!=0|%f_set_var(__SP,P)%{__SCOPE}<{}{%PC=Class&%PU!={__SP}U}{%PC}>!=0}\
	[{<{}{%t_nested_scope_def(%P)=true}{r}%PU>!=<%NU>}<{}{%t_nested_scope_def(%P)=true}{r}%PN::>]]]]
//#UC END# *4714D58000CB*

// возвращает true, если элемент имеет реализацию
t _has_impl
//#UC START# *4714D59D0196*
c                                     {}
r "%SS"="Generator":                  {true}
r "%SS"="Predicate":                  {true}
r "%SS"="UnaryFunctor":               {true}
r "%SS"="BinaryFunctor":              {true}
r "%SS"="BinaryPredicate":            {true}
r "%SS"="FunctorBase":                {true}
r "%SS"="Exception":                  {true}
r "%SC"="Operation":                  {true}
r "%SM"="TemplateFunctions::Class":   {[{<{}{%t_has_impl(%C)=true}{C}>!=0}{false}true]}
r ""="":                              {false}
//#UC END# *4714D59D0196*

// возвращает количество шаблонных параметров
f _count_template_params
//#UC START# *4714D5C001B5*
	[<{, }{"%CC"="Parameter"}{C}>]
//#UC END# *4714D5C001B5*

// возвращает true, если элемент %S определяет все шаблонные параметры %1
f _template_specify
// параметры: who: void = %1
//#UC START# *4714D5F80213*
	[{%f_set_var(SELF,S)"%1<{, }{"%CC"="Parameter"}{%C}%f_set_var(ARG,C)[{"%{SELF}<{}{"%{ARG}N"="%CN"&"[{"%CC"="Parameter"|"[{"%CC"="Attribute"&"%CS"="template"}{false}true]"="true"}{false}true]"="true"}{C}>"!="1"}.]>"!=""}{true}false]
//#UC END# *4714D5F80213*

// выводит список шаблонных параметров
f _dump_parameterized_list
//#UC START# *4714D61001D4*
	[{"%SK"="ParameterizedClass"}\<%S<{, }{"%CC"="Parameter"}{%C}%f_set_var(ARG,C)%{SELF}<{}{"%{ARG}N"="%CN"&"[{"%CC"="Parameter"|"[{"%CC"="Attribute"&"%CS"="template"}{false}true]"="true"}{false}true]"="true"}[{"%Cs"="const"}const ]%f_type(%C%T)>>\>]
//#UC END# *4714D61001D4*

// возвращает true если хотя бы один из родителей является параметризированным
f _is_parent_parameterized
//#UC START# *4714D63F00CB*
	[{"%S<{}{"%NK"="ParameterizedClass"}{C}>"="0"}{true}false]
//#UC END# *4714D63F00CB*

// выводит массив родительских элементов необходимых и достаточных для указания полного имени
// элемента, относительно текущего элемента.
f _dump_normalized_scope
//#UC START# *4714D6810251*
	[{"%{SELF}K"="ParameterizedClass"&"%f_is_parent_parameterized(%S)"="true"}{%S<%NN::>}]
//#UC END# *4714D6810251*

// выводит тип шаблонного параметра
f _find_template_param
//#UC START# *4714D6B502BF*
	[%{SELF}<{}{"%CC"="Attribute"&"%CS"="template"}[{"%{PARAM}N"="%CN"}%f_type(%C%T)]>]
//#UC END# *4714D6B502BF*

// выводит тип параметра
f _dump_param
//#UC START# *4714D6BE000F*
	[{%PS!=TemplateFunctions}{%SN}%f_set_var(PARAM,S)[{"%f_find_template_param(%S)"!=""}{%{SELF}<{}{"%CC"="Parameter"}[{"%CN"="%{PARAM}N"}%f_dump_normalized_scope(%S)%CN]>}\
	%f_dump_normalized_scope(%S)%f_find_template_param(%S)]]
//#UC END# *4714D6BE000F*

// может ли элемент иметь страницу в К
t _have_k_page
//#UC START# *4714D70C038A*
c                                    {}
r %SS=Generator:                     {true}
r %SS=Predicate:                     {true}
r %SS=UnaryFunctor:                  {true}
r %SS=BinaryFunctor:                 {true}
r %SS=BinaryPredicate:               {true}
r "%SM"="KServletPlugin::Class":     {true}
r "%SM"="KListenerPlugin::Class":    {true}
r "%SM"="KMacroPlugin::Class":       {true}
r "%SM"="KComponentPlugin::Class":   {true}
r "%SM"="KJobPlugin::Class":         {true}
r "%SM"="KTriggerPlugin::Class":     {true}
r "%SM"="KVelocityContextPlugin::Class":  {true}
r "%SM"="VM::Class":                 {true}
r "%SM"="KXWorkPlugin::Class":       {true}
r "%SM"="KActionPlugin::Class":      {true}
r "%SM"="KSpringPlugin::Class":      {true}
r "%SM"="KExtractorPlugin::Class":   {true}
r "%SM"="KLifecyclePlugin::Class":   {true}
r "%SM"="WebItem::Class":            {true}
r "%SM"="Interface::Class":          {true}
r "%SM"="ComInterface::Class":       {true}
r "%SM"="Facet::Class":              {true}
r "%SM"="ServerFacet::Class":        {true}
r "%SM"="ServerInterface::Class":    {true}
r "%SM"="SimpleClass::Class":        {true}
r "%SM"="Servant::Class":            {true}
r "%SM"="ComServant::Class":         {true}
r "%SM"="Dialog::Class":             {true}
r "%SM"="PropertyPage::Class":       {true}
r "%SM"="PropertySheet::Class":      {true}
r "%SM"="GuiControl::Class":         {true}
r "%SM"="Deallocator::Class":        {true}
r "%SM"="Exception::Class":          {true}
r "%SM"="ClientInterceptor::Class":  {true}
r "%SM"="ServerInterceptor::Class":  {true}
r "%SM"="LibExecutor::Class":        {true}
r "%SM"="LibExecutor::Class":        {true}
r "%SM"="Struct::Class":             {true}
r "%SM"="Valuetype::Class":          {true}
r "%SM"="UtilityPack::Class":        {true}
r "%SM"="UtilityClass::Class":       {true}
//#UC END# *4714D70C038A*

// функция проверяет имеет ли элемент указанный тип (с учетом Typedef'а) или нет (нужный тип
// передаётся как второй параметр)
t _check_type
//#UC START# *4714D7240290*
c                                  {}
r "%SM"="%1N":                     {true}
r "%SM"="Typedef::Class":          {%t_check_type(%G,"%1N")}
r ""="":                           {false}
//#UC END# *4714D7240290*

// возвращает размер типа
t _size_of
//#UC START# *476657160244*
c                                  {}
r "%SM"="Enum::Class":             {4}
r "%SN"="short":                   {2}
r "%SN"="size":                    {4}
r "%SN"="integer":                 {4}
r "%SN"="long":                    {4}
r "%SN"="long long":               {8}
r "%SN"="unsigned short":          {2}
r "%SN"="unsigned integer":        {4}
r "%SN"="unsigned long":           {4}
r "%SN"="unsigned long long":      {8}
r "%SN"="float":                   {4}
r "%SN"="double":                  {8}
r "%SN"="boolean":                 {1}
r "%SN"="char":                    {1}
r "%SN"="wchar":                   {4}
r "%SN"="octet":                   {1}
r "%SN"="string":                  {4}
r "%SN"="a-string":                {undef}
r "%SN"="a-wstring":               {undef}
r "%SN"="pointer":                 {4}
r "%SN"="POINT":                   {8}
r "%SM"="Struct::Class":           {%f_collect_size_of_attr(%S)}
r "%SM"="Typedef::Class":          {[{%Gx=true}{undef}%t_size_of(%G)]}
r "%f_is_interface(%S)"="true":    {0}
r "%t_is_container(%S)"="true":    {undef}
r "%SC"="Class"&"%SS"!="UMLPrimitive":                   {%f_collect_size_of_attr(%S)}
r "%SN"="tribool":                 {undef}
r "%SN"="atomic":                  {undef}
r "%SN"="hthread":                 {undef}
r "%SN"="unsigned atomic":         {undef}
r "%SN"="void":                    {0}
r {""=""}:                         {undef}

f _collect_size_of_attr
	[{<{}{%CC=Attribute&%t_size_of(%C%T)=undef&%CS!=static}{%CC}>=0}{undef}%f_evaluate([{}{0}<{+}{%CC=Attribute&%CS!=static}{%C}[{%Cl=agr}{4}%t_size_of(%C%T)]>])]
//#UC END# *476657160244*

// Возвращает true, если для атрибута можно сгенерить акцессоры
t _can_be_accessed
//#UC START# *47C3C70D03AD*
c                                            {}
r {%S{is persistent}=true}:                  {true}
r {%t_struct_type(%T)=true}:                 {true}
r {%f_check_if_type(%T,"a-string")=true}:    {true}
r {%f_check_if_type(%T,"a-wstring")=true}:   {true}
r {""=""}:                                   {%t_simple(%T)}

t _is_accessor
c                                           {}
//это временно, потом static не будет определять акцессоров
r {%SC=Atribute&%SS=property}:              {true}
r {%SC=Atribute&%SS=writeonly}:             {true}
r {%SC=Atribute&%SS=readonly}:              {true}
r {%SC=Atribute&%SS=static property}:       {true}
r {%SC=Atribute&%SS=static writeonly}:      {true}
r {%SC=Atribute&%SS=static readonly}:       {true}
r {""=""}:                                  {false}

f _can_be_accessed
	[{%SC=Attribute&%SS!=template&%SS!=switch}{false}true]
//#UC END# *47C3C70D03AD*

// возвращает true - если элемент является строкой (string, a-string)
f _is_string
//#UC START# *4869B10300EE*
	[{%f_check_if_type(%S,"string")=true|%f_check_if_type(%S,"a-string")=true|%f_check_if_type(%S,"c-string")=true}{false}true]

f _is_identifier
	%f_check_if_type(%S,"identifier")
//#UC END# *4869B10300EE*

// возвращает true, если элемент является "расширенной" строкой (wstring, a-wstring)
f _is_wstring
//#UC START# *4869B1290176*
	[{%f_check_if_type(%S,"wstring")=true|%f_check_if_type(%S,"a-wstring")=true}{false}true]
//#UC END# *4869B1290176*

// проверяет является ли стереотип контейнером
t _is_container
//#UC START# *49F871160053*
c                               {}
r "%SM"="Map::Class":           {true}
r "%SM"="UnsortedMap::Class":   {true}
r "%SM"="HashMap::Class":       {true}
r "%SM"="Set::Class":           {true}
r "%SM"="UnsortedSet::Class":   {true}
r "%SM"="Vector::Class":        {true}
r "%SM"="List::Class":          {true}
r "%SM"="Queue::Class":         {true}
r {%SM=Typedef::Class}:         {%t_is_container(%G)}
r ""="":                        {false}
//#UC END# *49F871160053*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
