////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/DelphiSpecific/DelphiLang/Implementation/SimpleClass.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$ForDelphi::DelphiSpecific::DelphiLang::Implementation::SimpleClass
//
// Простой класс
// ---
// Абстракция простого класса в терминах ООП
// используется для опеределяения типов не являющихся ни интерфесйами, ни сервантами, ни
// структурами, ни производными от них, или патернами более высокого уровня (контейнеры,
// специализированные шаблоные типы и т.д.)
// 
// "Абстрактный" класс - не может быть создан (т.е. должен использоваться как примесь)
// "Финальный" класс, напротив не может быть использован в качестве базового класса.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

: SimpleClass::Class (redefinition)
? Простой класс
? Абстракция простого класса в терминах ООП
? используется для опеределяения типов не являющихся ни интерфесйами, ни сервантами, ни структурами, ни производными от них, или патернами более высокого уровня (контейнеры, специализированные шаблоные типы и т.д.)
? 
? "Абстрактный" класс - не может быть создан (т.е. должен использоваться как примесь)
? "Финальный" класс, напротив не может быть использован в качестве базового класса.
> SetOf::Class
> SetConst::Class
> Range::Class
> StaticObject::Class
> method::Class
> Constructor::Class
> Factory::Class
> LocalConst::Class
> Contract::Class

= StandardClassInclude::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

p needs InstanceR:tribool=undefined ? Нужно ли определять тип инстанцируемой примеси
p register in scripts:tribool=undefined ? 
p needs script:tribool=undefined ? Нужна скриптовая обвязка

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

%f _st_space_key
	SHD

%f _wiki_up_print
	[{"%S{needs InstanceR}"!="%S{!needs InstanceR}"}%f_up_prefix(%S) *needs InstanceR* = *%S{needs InstanceR}* - Нужно ли определять тип инстанцируемой примеси
	][{"%S{register in scripts}"!="%S{!register in scripts}"}%f_up_prefix(%S) *register in scripts* = *%S{register in scripts}*
	][{"%S{needs script}"!="%S{!needs script}"}%f_up_prefix(%S) *needs script* = *%S{needs script}* - Нужна скриптовая обвязка
	]


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит документацию для СЛОВА скрипта, которое представляет данный эелемент
%f _DoSpellKeywordDocumentation
// параметры: aSummoner: MDAClass = %1
//#UC START# *4F30D27300BAfor481EC6BD016B*
	%S%[inherited]f_DoSpellKeywordDocumentation(%1)\
	[{%S%f_NeedsKeywordDocumentation()=true}\
	%f_set_var(NAME,"%S%f_ScriptKeywordDocumentationName()")\
//	[{"%1<{}{%CN=%{NAME}N}{C}>"="0"}\
	%1%f_add_class(%SU_%1U,ScriptKeywordDocumentation,%{NAME}N,KeywordDocumentation_Inst)\
	%{KeywordDocumentation_Inst}%f_set_documentation(%f_str_replace(%f_str_replace(%f_str_replace(%f_str_replace(%f_str_replace(%SD, Пример:, *Пример:*),\n\n*Пример:*,\n *Пример:*),\n\nПример:,\n *Пример:*),\n*Пример:*,\n *Пример:*),\nПример:,\n *Пример:*))\
// WST = WasSpelledTo
	%{KeywordDocumentation_Inst}%f_set_var(WST,S)\
//	]\
	]
//#UC END# *4F30D27300BAfor481EC6BD016B*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Нужно ли документацию к слову скрипта, которое представляет элемента
%f _NeedsKeywordDocumentation
// возвращаемый результат: boolean
//#UC START# *4F30B869036Efor481EC6BD016B*
	[{%S%f_IsMixIn()=true|%Sa=abstract}{\
	[{%S{NeedsKeywordDoc}=true|%S%f_InheritsFrom("TtfwRegisterableWord")=true}{\
	false\
	}\
	true\
	]\
	}\
	false\
	]
//#UC END# *4F30B869036Efor481EC6BD016B*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
%f _ScriptKeywordDocumentationName
// возвращаемый результат: a-string
//#UC START# *4F30B8E60385for481EC6BD016B*
	[%P#f_pas_ElementPrefixBase()_]%f_cut_prefix(%f_cut_prefix(%f_N(%S),Tkw),_)
//#UC END# *4F30B8E60385for481EC6BD016B*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Создаёт документацию к словам скрипта
%f _SpellKeywordsDocumentation
// параметры: aSummoner: MDAClass = %1
//#UC START# *4F30B8A403DFfor481EC6BD016B*
	%S%[inherited]f_SpellKeywordsDocumentation(%1)
//#UC END# *4F30B8A403DFfor481EC6BD016B*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Добавляет файлы необходимые элементу с точки зрения метамодели
%f _pas_ImplUses
//#UC START# *4948EB2601FAfor481EC6BD016B*
	%S%[inherited]\
	<{}{%aC=Dependency&%aS=injects}{Sg}\
//	[{"%f_pas_UnitName(%a%P)"=""&%a%P%P#f_IsUnitFileProducer()=true}{\
	%f_pas_PutToUses(%a%P)\
//	}\
//	%f_pas_PutToUses(%a%P%P)\
//	]\
	>\
// - выводим собственные инъекции
	<{}{%t_interface(%R)=true}{}\
	%R<{}{%aC=Dependency&%aS=injects}{Sg}\
	%f_pas_PutToUses(%a%P)\
	>\
	>
// - выводим иньекции для интерфейсов, которые мы реализуем
//#UC END# *4948EB2601FAfor481EC6BD016B*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

: SimpleClass::Class::factory::Operation
? Фабричный метод.
? Создает экземпляр класса в виде указанного интерфейса/фасета.
= ClassBase::Class::static::Operation
= FactoryMixIn::Class

// Параметры стереотипа
v +
/ - типы видимости
a f
/ - тип абстракции
Y code_factory.gif
L code_factory

// Генераторы
// Генерация модели в MDKnow
+ wiki
//#UC START# *46E6D4BB0339for4787ED5E030C*
//#UC END# *46E6D4BB0339for4787ED5E030C*

// генератор реализации фабрик интерфейсов на java (.java)
+ fctr.java
//#UC START# *470321C1038Afor4787ED5E030C*
//#UC END# *470321C1038Afor4787ED5E030C*

// Функции стереотипа
%f _st_space_key
	SHD

%f _wiki_up_print
	%S%[ClassBase::Class::static::Operation]f_wiki_up_print()[{"%S{check nil}"!="%S{!check nil}"}%f_up_prefix(%S) *check nil* = *%S{check nil}* - Проверять, что первый параметр nil и не создавать объекта
	][{"%S{need As}"!="%S{!need As}"}%f_up_prefix(%S) *need As* = *%S{need As}* - Определяет, что нужно приводить класс к интерфейсу через As
	][{"%S{need AfterCreate}"!="%S{!need AfterCreate}"}%f_up_prefix(%S) *need AfterCreate* = *%S{need AfterCreate}*
	][{"%S{need Aggregate}"!="%S{!need Aggregate}"}%f_up_prefix(%S) *need Aggregate* = *%S{need Aggregate}*
	]


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
%f _wiki_up_add_gen
//#UC START# *470484D50138for4787ED5E030C*
//#UC END# *470484D50138for4787ED5E030C*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
%f _IsFactory
// возвращаемый результат: boolean
//#UC START# *4AE026A90143for4787ED5E030C*
	true
//#UC END# *4AE026A90143for4787ED5E030C*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит тело метода
// 
// Modification = get|set|area|areareaf|o|r|f
%f _pas_MethodBodyPrim
// параметры: Implementator: void = %1, Modification: void = %2, RealizeType: a-string = %3, aOverrider: MDAClass = %4
//#UC START# *494BB3A201A2for4787ED5E030C*
	%S%f_OutFactoryBody(%1,%2)
//#UC END# *494BB3A201A2for4787ED5E030C*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// выводит параметры и результат метода
%f _pas_MethodParams
// параметры: Modification: void = %1
//#UC START# *494BE0CC0226for4787ED5E030C*
	[{%t_interface(%T)!=true&%TS!=ImpurityParamType&%TN!=void}\
	%f_error("Фабрика %PN.%SN не может конструировать %TN: %TS")\
	]\
	%S%[inherited]
//#UC END# *494BE0CC0226for4787ED5E030C*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Параметры операции
%f _pas_Params
// параметры: Modification: void = %1
//#UC START# *494BDCF3030Efor4787ED5E030C*
	[{%P#f_IsVCMForm()!=true}{\
	[%S%[inherited];]\
	%S%f_pas_VCMFormFactoryParams()\
	}\
	%S%[inherited]\
	]
//#UC END# *494BDCF3030Efor4787ED5E030C*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Имя типа результата функции
%f _pas_ResultTypeName
// параметры: Modification: void = %1
//#UC START# *494BDD190361for4787ED5E030C*
@ %SU
	%S%f_OutFactoryResult()
//#UC END# *494BDD190361for4787ED5E030C*

: SimpleClass::Class::vctor::Operation
? виртуальный конструктор
= ClassBase::Class::ctor::Operation

// Параметры стереотипа
a r
/ - тип абстракции
T 
/ - может не иметь "цели" (типа/результата)
m t
/ - может быть реализован/иметь перекрытую реализацию

// Генераторы
// Генерация модели в MDKnow
+ wiki
//#UC START# *46E6D4BB0339for47A08DC70357*
//#UC END# *46E6D4BB0339for47A08DC70357*

// генератор реализации фабрик интерфейсов на java (.java)
+ fctr.java
//#UC START# *470321C1038Afor47A08DC70357*
//#UC END# *470321C1038Afor47A08DC70357*

// Функции стереотипа
%f _st_space_key
	SHD


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
%f _wiki_up_add_gen
//#UC START# *470484D50138for47A08DC70357*
//#UC END# *470484D50138for47A08DC70357*

: SimpleClass::Class::injects::ClassDependency
? Внедрение зависимости
= Delphi интерфейсы и реализация::MDAGenerator

// Пользовательские свойства
p injects as=interface|cursor|range|mapper ? 

// Генераторы
// Генерация модели в MDKnow
+ wiki
//#UC START# *46E6D4BB0339for53C7FB6D0337*
//#UC END# *46E6D4BB0339for53C7FB6D0337*

// Родные Delphi интерфейсы (.pas)
+ intf.pas
R  
//#UC START# *470F1571031Cfor53C7FB6D0337*
//#UC END# *470F1571031Cfor53C7FB6D0337*

// Реализация на Delphi(.pas)
+ impl.pas
R  
//#UC START# *470F15B800CBfor53C7FB6D0337*
//#UC END# *470F15B800CBfor53C7FB6D0337*

// Функции стереотипа
%f _st_space_key
	SHD

%f _wiki_up_print
	%S#[inherited][{"%S{injects as}"!="%S{!injects as}"}%f_up_prefix(%S) *injects as* = *%S{injects as}*
	]


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for53C7FB6D0337*
c          {}
r {""=""}: {}
//#UC END# *4704C0E30186for53C7FB6D0337*

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
%f _wiki_child_kind
//#UC START# *4705CBD6003Efor53C7FB6D0337*
//#UC END# *4705CBD6003Efor53C7FB6D0337*

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
%f _wiki_up_add_gen
//#UC START# *470484D50138for53C7FB6D0337*
//#UC END# *470484D50138for53C7FB6D0337*

: SimpleClass::Class::injects this::ClassDependency
= Delphi интерфейсы и реализация::MDAGenerator

// Пользовательские свойства
p needs processor:tribool=undefined ? 

// Генераторы
// Генерация модели в MDKnow
+ wiki
//#UC START# *46E6D4BB0339for53CE27910262*
//#UC END# *46E6D4BB0339for53CE27910262*

// Родные Delphi интерфейсы (.pas)
+ intf.pas
R  
//#UC START# *470F1571031Cfor53CE27910262*
//#UC END# *470F1571031Cfor53CE27910262*

// Реализация на Delphi(.pas)
+ impl.pas
R  
//#UC START# *470F15B800CBfor53CE27910262*
//#UC END# *470F15B800CBfor53CE27910262*

// Функции стереотипа
%f _st_space_key
	SHD

%f _wiki_up_print
	%S#[inherited][{"%S{needs processor}"!="%S{!needs processor}"}%f_up_prefix(%S) *needs processor* = *%S{needs processor}*
	]


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for53CE27910262*
c          {}
r {""=""}: {}
//#UC END# *4704C0E30186for53CE27910262*

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
%f _wiki_child_kind
//#UC START# *4705CBD6003Efor53CE27910262*
//#UC END# *4705CBD6003Efor53CE27910262*

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
%f _wiki_up_add_gen
//#UC START# *470484D50138for53CE27910262*
//#UC END# *470484D50138for53CE27910262*


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

