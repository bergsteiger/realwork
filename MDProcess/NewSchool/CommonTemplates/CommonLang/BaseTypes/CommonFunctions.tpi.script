////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/BaseTypes/CommonFunctions.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAUtilityPack::Class>> MDProcess$Templates::CommonTemplates::CommonLang::BaseTypes::CommonFunctions
//
// вспомогательнные функции для генерации
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// генерация реализуемых и перегруженных методов, атрибутов
//f _dump_cpp_derrived_impl_cpp
: dump_cpp_derrived_impl_cpp OBJECT IN %S
//#UC START# *4714D7D00167*
//	%f_set_var(SERV,S)%f_set_var(NEED_UPDATE_RW,"0")%f_has_combo_fctr(%S)\
 [%f] set_var %( 'SERV' %, 'S' )% [%f] set_var %( 'NEED_UPDATE_RW' %, 0 )% [%f] has_combo_fctr %( %S )% 
//	%f_clear_list(SERV_OPS)\
 [%f] clear_list %( 'SERV_OPS' )% 
//	%f_collect_self_operations_signature(%S,"SERV_OPS")\
 [%f] collect_self_operations_signature %( %S %, 'SERV_OPS' )% 
//	[
 if NOT-EMPTY
 begin
  #13#10

//	[//////////////////////////////////////////////////////////////////////////////////////////
  if NOT-EMPTY
  begin
   '//////////////////////////////////////////////////////////////////////////////////////////'
//	// implemented interface's methods\
   '// implemented interface''s methods'
//	<{}{%{SERV}%f_additional_condition(%o)=true}{Sp}[
   INTEGER VAR l_Counter l_Counter := 0
   for %S%op
   begin
    OBJECT IN %o
    if ( ( ( get_global_var ( 'SERV' ) %f additional_condition %( %o )% ) ) %==  true ) then
    begin
     if NOT-EMPTY
     begin
      #13#10

//	
      #13#10

//	%f_dump_implemented_method_cpp(%o,"SERV_OPS")]>][{%f_has_overloaded_methods(%S)=true}
      [%f] dump_implemented_method_cpp %( %o %, 'SERV_OPS' )% 
     end // if
     NOP

     ++! l_Counter
    end // if
   end // for o
  end // if
  NOP
  if ( ( [%f] has_overloaded_methods %( %S )% ) %==  true ) then
  begin
   #13#10

//	//////////////////////////////////////////////////////////////////////////////////////////
   '//////////////////////////////////////////////////////////////////////////////////////////'
//	// overloaded base methods<{}{"%OS"!="ctor"}{Sp}[
   '// overloaded base methods'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Op
   begin
    OBJECT IN %O
    if ( ( %O |S ) %!= 'ctor' ) then
    begin
     if NOT-EMPTY
     begin
      #13#10

//	
      #13#10

//	%f_dump_overloaded_method_cpp(%O,"SERV_OPS")]>
      [%f] dump_overloaded_method_cpp %( %O %, 'SERV_OPS' )% 
     end // if
     NOP

     ++! l_Counter
    end // if
   end // for O
//	]][{%{NEED_UPDATE_RW}N=1}
  end // if
 end // if
 NOP
 if ( ( ( get_global_var ( 'NEED_UPDATE_RW' ) |N ) ) %== 1 ) then
 begin
  #13#10

//	void %SN::upgrade_rw () {
  'void '
  %S |N '::upgrade_rw () {'
//		%U[{_UPDATE_RW}
  '	'
  %Usersection (
   '_UPDATE_RW' 
  )
  (
   #13#10

//		]
   '	' 
  ) // Usersection
 //	}]
  '}' 
 end // if
//#UC END# *4714D7D00167*
; // dump_cpp_derrived_impl_cpp


// вывыодит объявление реализуемого метода
//f _dump_implemented_method
: dump_implemented_method OBJECT IN %S
//#UC START# *4714D7F200EA*
//	%f_set_var(__METHODS__,"%f_dump_implemented_method_impl(%S,%1)")\
 [%f] set_var %( '__METHODS__' %, [%f] dump_implemented_method_impl %( %S %, %1 )% )% 
//	[{"%{__METHODS__}N"!=""}#// implemented method from %f_type(%S%P)
 if ( ( ( get_global_var ( '__METHODS__' ) |N ) ) %!= '' ) then
 begin
  out_indent '// implemented method from '
  [%f] type %( %S ->P  )% 
//	%{__METHODS__}N]
  ( get_global_var ( '__METHODS__' ) |N ) 
 end // if

//f _dump_implemented_method_impl
; // dump_implemented_method

: dump_implemented_method_impl OBJECT IN %S
//	[{"%SC"="Attribute"}{[{"%SC"="Operation"}%f_servant_cpp_operation_h(%S)]}\
 if ( ( %S |C ) %== 'Attribute' ) then
 begin
//	%f_clear_list(__OP_LIST__)\
  [%f] clear_list %( '__OP_LIST__' )% 
//	%f_copy_list(%1N,__OP_LIST__)\
  [%f] copy_list %( %1 |N %, '__OP_LIST__' )% 
//	%f_set_var(__SELF_R__,"%f_read_accessor_signature(%S)")%f_set_var(__SELF_W__,"%f_write_accessor_signature(%S)")\
  [%f] set_var %( '__SELF_R__' %, [%f] read_accessor_signature %( %S )% )% [%f] set_var %( '__SELF_W__' %, [%f] write_accessor_signature %( %S )% )% 
//	%f_set_var(__NEED_R__,"[{"%1N!=""}{true}[{%f_exists_in_list(__OP_LIST__,"%{__SELF_R__}N")=false}{false}true]]")\
  [%f] set_var %( '__NEED_R__' %, if ( ( %1 |N ) %!= '' ) then
  begin
   if ( ( [%f] exists_in_list %( '__OP_LIST__' %, ( get_global_var ( '__SELF_R__' ) |N ) )% ) %==  false ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // if
  else
  begin
    true 
  end // else
)% //	%f_set_var(__NEED_W__,"[{"%1N!=""}{true}[{%f_exists_in_list(__OP_LIST__,"%{__SELF_W__}N")=false}{false}true]]")\
  [%f] set_var %( '__NEED_W__' %, if ( ( %1 |N ) %!= '' ) then
  begin
   if ( ( [%f] exists_in_list %( '__OP_LIST__' %, ( get_global_var ( '__SELF_W__' ) |N ) )% ) %==  false ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // if
  else
  begin
    true 
  end // else
)% //	%f_servant_cpp_attribute_h(%S,"%{__NEED_R__}N","%{__NEED_W__}N")]
  [%f] servant_cpp_attribute_h %( %S %, ( get_global_var ( '__NEED_R__' ) |N ) %, ( get_global_var ( '__NEED_W__' ) |N ) )% 
 end // if
 else
 begin
  if ( ( %S |C ) %== 'Operation' ) then
  begin
   [%f] servant_cpp_operation_h %( %S )% 
  end // if
 end // else

//f _dump_implemented_method_cpp
; // dump_implemented_method_impl

: dump_implemented_method_cpp OBJECT IN %S
//	%f_set_var(__METHODS__,"%f_dump_implemented_method_impl_cpp(%S,%1)")\
 [%f] set_var %( '__METHODS__' %, [%f] dump_implemented_method_impl_cpp %( %S %, %1 )% )% 
//	[{"%{__METHODS__}N"!=""}// implemented method from %f_type(%S%P)
 if ( ( ( get_global_var ( '__METHODS__' ) |N ) ) %!= '' ) then
 begin
  '// implemented method from '
  [%f] type %( %S ->P  )% 
//	%{__METHODS__}N]
  ( get_global_var ( '__METHODS__' ) |N ) 
 end // if

//f _dump_implemented_method_impl_cpp
; // dump_implemented_method_cpp

: dump_implemented_method_impl_cpp OBJECT IN %S
//	%f_clear_list(__OP_LIST__)\
 [%f] clear_list %( '__OP_LIST__' )% 
//	%f_copy_list(%1N,__OP_LIST__)\
 [%f] copy_list %( %1 |N %, '__OP_LIST__' )% 
//	[{"%SC"="Attribute"}{[{"%SC"="Operation"}%{SERV}%f_servant_cpp_operation_cpp_base(%S)]}\
 if ( ( %S |C ) %== 'Attribute' ) then
 begin
//	%f_set_var(__SELF_R__,"%f_read_accessor_signature(%S)")%f_set_var(__SELF_W__,"%f_write_accessor_signature(%S)")\
  [%f] set_var %( '__SELF_R__' %, [%f] read_accessor_signature %( %S )% )% [%f] set_var %( '__SELF_W__' %, [%f] write_accessor_signature %( %S )% )% 
//	%f_set_var(__NEED_R__,"[{"%1N!=""}{true}[{%f_exists_in_list(__OP_LIST__,"%{__SELF_R__}N")=false}{false}true]]")\
  [%f] set_var %( '__NEED_R__' %, if ( ( %1 |N ) %!= '' ) then
  begin
   if ( ( [%f] exists_in_list %( '__OP_LIST__' %, ( get_global_var ( '__SELF_R__' ) |N ) )% ) %==  false ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // if
  else
  begin
    true 
  end // else
)% //	%f_set_var(__NEED_W__,"[{"%1N!=""}{true}[{%f_exists_in_list(__OP_LIST__,"%{__SELF_W__}N")=false}{false}true]]")\
  [%f] set_var %( '__NEED_W__' %, if ( ( %1 |N ) %!= '' ) then
  begin
   if ( ( [%f] exists_in_list %( '__OP_LIST__' %, ( get_global_var ( '__SELF_W__' ) |N ) )% ) %==  false ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // if
  else
  begin
    true 
  end // else
)% //	%{SERV}%f_servant_cpp_attribute_cpp_base(%S,"%{__NEED_R__}N","%{__NEED_W__}N")]
  ( get_global_var ( 'SERV' ) %f servant_cpp_attribute_cpp_base %( %S %, ( get_global_var ( '__NEED_R__' ) |N ) %, ( get_global_var ( '__NEED_W__' ) |N ) )% ) 
 end // if
 else
 begin
  if ( ( %S |C ) %== 'Operation' ) then
  begin
   ( get_global_var ( 'SERV' ) %f servant_cpp_operation_cpp_base %( %S )% ) 
  end // if
 end // else

//f _dump_overloaded_method_h
; // dump_implemented_method_impl_cpp

: dump_overloaded_method_h OBJECT IN %S
//	%f_set_var(__METHODS__,"%f_dump_implemented_method_impl(%S,%1)")\
 [%f] set_var %( '__METHODS__' %, [%f] dump_implemented_method_impl %( %S %, %1 )% )% 
//	[{"%{__METHODS__}N"!=""}#// overloaded method from %f_type(%S%P)
 if ( ( ( get_global_var ( '__METHODS__' ) |N ) ) %!= '' ) then
 begin
  out_indent '// overloaded method from '
  [%f] type %( %S ->P  )% 
//	%{__METHODS__}N]
  ( get_global_var ( '__METHODS__' ) |N ) 
 end // if

//f _dump_overloaded_method_cpp
; // dump_overloaded_method_h

: dump_overloaded_method_cpp OBJECT IN %S
//	%f_set_var(__METHODS__,"%f_dump_implemented_method_impl_cpp(%S,%1)")\
 [%f] set_var %( '__METHODS__' %, [%f] dump_implemented_method_impl_cpp %( %S %, %1 )% )% 
//	[{"%{__METHODS__}N"!=""}// overloaded method from %f_type(%S%P)
 if ( ( ( get_global_var ( '__METHODS__' ) |N ) ) %!= '' ) then
 begin
  '// overloaded method from '
  [%f] type %( %S ->P  )% 
//	%{__METHODS__}N]
  ( get_global_var ( '__METHODS__' ) |N ) 
 end // if
//#UC END# *4714D7F200EA*
; // dump_overloaded_method_cpp


// геенрация зоголовков реализуемых методов, атрибутов
//f _dump_cpp_derrived_impl_h
: dump_cpp_derrived_impl_h OBJECT IN %S
//#UC START# *4714D8170399*
//	%f_set_var(SERV,S)%f_set_var(NEED_UPDATE_RW,"0")%f_has_combo_fctr(%S)\
 [%f] set_var %( 'SERV' %, 'S' )% [%f] set_var %( 'NEED_UPDATE_RW' %, 0 )% [%f] has_combo_fctr %( %S )% 
//	%f_clear_list(SERV_OPS)\
 [%f] clear_list %( 'SERV_OPS' )% 
//	%f_collect_self_operations_signature(%S,"SERV_OPS")\
 [%f] collect_self_operations_signature %( %S %, 'SERV_OPS' )% 
//	[
 if NOT-EMPTY
 begin
  #13#10

//	[{%ox=true&%{SERV}%f_additional_condition(%o,"COUNT")=true}#//////////////////////////////////////////////////////////////////////////////////////////
  if ( ( %o |x ) %==  true AND 
    ( ( ( get_global_var ( 'SERV' ) %f additional_condition %( %o %, 'COUNT' )% ) ) %==  true  ) ) then
  begin
   out_indent '//////////////////////////////////////////////////////////////////////////////////////////'
//	#// implemented interface's methods
   out_indent '// implemented interface's methods'
//	[{%t_simple_class(%S)=false}#protected:<{}{%{SERV}%f_additional_condition(%o)=true}{%oSp}[
   if ( ( [%t] simple_class %( %S )% ) %==  false ) then
   begin
    out_indent 'protected:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%op
    begin
     OBJECT IN %o
     if ( ( ( get_global_var ( 'SERV' ) %f additional_condition %( %o )% ) ) %==  true ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	
       #13#10

//	%f_dump_implemented_method(%o,"SERV_OPS")]>][{%t_simple_class(%S)=true}[#public:<{}{%oV=PublicAccess&%t_simple_class(%o%P)=true}{Sp}[
       [%f] dump_implemented_method %( %o %, 'SERV_OPS' )% 
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for o
   end // if
   if ( ( [%t] simple_class %( %S )% ) %==  true ) then
   begin
    if NOT-EMPTY
    begin
     out_indent 'public:'
     INTEGER VAR l_Counter l_Counter := 0
     for %S%op
     begin
      OBJECT IN %o
      if ( ( %o |V ) %== 'PublicAccess' AND 
       ( ( [%t] simple_class %( %o ->P  )% ) %==  true  ) ) then
      begin
       if NOT-EMPTY
       begin
        #13#10

//	
        #13#10

//	%f_dump_implemented_method(%o,"SERV_OPS")]>][{<{}{%oV=ProtectedAccess|%t_simple_class(%o%P)=false}{C}>!=0}\
        [%f] dump_implemented_method %( %o %, 'SERV_OPS' )% 
       end // if
       NOP

       ++! l_Counter
      end // if
     end // for o
    end // if
    NOP
    if ( 
     INTEGER VAR l_Counter l_Counter := 0
     for %S%o
     begin
      OBJECT IN %o
      if ( ( %o |V ) %== 'ProtectedAccess' OR 
       ( ( [%t] simple_class %( %o ->P  )% ) %==  false  ) ) then
      begin

       ++! l_Counter
      end // if
     end // for o
     l_Counter
     %!= 0 ) then
    begin
//	[{<{}{%oV=PublicAccess&%t_simple_class(%o%P)=true}{C}>!=0}\n]#protected:<{}{%oV=ProtectedAccess|%t_simple_class(%o%P)=false}{Sp}[
     if ( 
      INTEGER VAR l_Counter l_Counter := 0
      for %S%o
      begin
       OBJECT IN %o
       if ( ( %o |V ) %== 'PublicAccess' AND 
        ( ( [%t] simple_class %( %o ->P  )% ) %==  true  ) ) then
       begin

        ++! l_Counter
       end // if
      end // for o
      l_Counter
      %!= 0 ) then
     begin
      #13#10 
     end // if
     out_indent 'protected:'
     INTEGER VAR l_Counter l_Counter := 0
     for %S%op
     begin
      OBJECT IN %o
      if ( ( %o |V ) %== 'ProtectedAccess' OR 
       ( ( [%t] simple_class %( %o ->P  )% ) %==  false  ) ) then
      begin
       if NOT-EMPTY
       begin
        #13#10

//	
        #13#10

//	%f_dump_implemented_method(%o,"SERV_OPS")]>][{<{}{%oV=PrivateAccess&%t_simple_class(%o%P)=true}{C}>!=0}\
        [%f] dump_implemented_method %( %o %, 'SERV_OPS' )% 
       end // if
       NOP

       ++! l_Counter
      end // if
     end // for o
    end // if
    if ( 
     INTEGER VAR l_Counter l_Counter := 0
     for %S%o
     begin
      OBJECT IN %o
      if ( ( %o |V ) %== 'PrivateAccess' AND 
       ( ( [%t] simple_class %( %o ->P  )% ) %==  true  ) ) then
      begin

       ++! l_Counter
      end // if
     end // for o
     l_Counter
     %!= 0 ) then
    begin
//	[{<{}{%oV=PublicAccess&%t_simple_class(%o%P)=true}{C}>!=0|<{}{%oV=ProtectedAccess|%t_simple_class(%o%P)=false}{C}>!=0}\n]\
     if ( 
      INTEGER VAR l_Counter l_Counter := 0
      for %S%o
      begin
       OBJECT IN %o
       if ( ( %o |V ) %== 'PublicAccess' AND 
        ( ( [%t] simple_class %( %o ->P  )% ) %==  true  ) ) then
       begin

        ++! l_Counter
       end // if
      end // for o
      l_Counter
      %!= 0 OR 
       ( 
      INTEGER VAR l_Counter l_Counter := 0
      for %S%o
      begin
       OBJECT IN %o
       if ( ( %o |V ) %== 'ProtectedAccess' OR 
        ( ( [%t] simple_class %( %o ->P  )% ) %==  false  ) ) then
       begin

        ++! l_Counter
       end // if
      end // for o
      l_Counter
      %!= 0  ) ) then
     begin
      #13#10 
     end // if
//	#private:<{}{%oV=PrivateAccess&%t_simple_class(%o%P)=true}{Sp}[
     out_indent 'private:'
     INTEGER VAR l_Counter l_Counter := 0
     for %S%op
     begin
      OBJECT IN %o
      if ( ( %o |V ) %== 'PrivateAccess' AND 
       ( ( [%t] simple_class %( %o ->P  )% ) %==  true  ) ) then
      begin
       if NOT-EMPTY
       begin
        #13#10

//	
        #13#10

//	%f_dump_implemented_method(%o,"SERV_OPS")]>]]][{%f_has_overloaded_methods(%S)=true}
        [%f] dump_implemented_method %( %o %, 'SERV_OPS' )% 
       end // if
       NOP

       ++! l_Counter
      end // if
     end // for o
    end // if
   end // if
  end // if
  if ( ( [%f] has_overloaded_methods %( %S )% ) %==  true ) then
  begin
   #13#10

//	#//////////////////////////////////////////////////////////////////////////////////////////
   out_indent '//////////////////////////////////////////////////////////////////////////////////////////'
//	#// overloaded base methods
   out_indent '// overloaded base methods'
//	[#public:<{}{"%OV"="PublicAccess"&"%t_interface(%O%P)"="false"&"%OS"!="ctor"}{Sp}[
   if NOT-EMPTY
   begin
    out_indent 'public:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Op
    begin
     OBJECT IN %O
     if ( ( %O |V ) %== 'PublicAccess' AND 
      ( ( [%t] interface %( %O ->P  )% ) %== false  ) AND 
      ( ( %O |S ) %!= 'ctor'  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	
       #13#10

//	%f_dump_overloaded_method_h(%O,"SERV_OPS")]>][
       [%f] dump_overloaded_method_h %( %O %, 'SERV_OPS' )% 
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for O
   end // if
   NOP
   if NOT-EMPTY
   begin
    #13#10

//	#protected:<{}{"%OV"="ProtectedAccess"|"%t_interface(%O%P)"="true"&"%OS"!="ctor"}{Sp}[
    out_indent 'protected:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Op
    begin
     OBJECT IN %O
     if ( ( %O |V ) %== 'ProtectedAccess' OR 
      ( ( [%t] interface %( %O ->P  )% ) %== true  ) AND 
      ( ( %O |S ) %!= 'ctor'  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	
       #13#10

//	%f_dump_overloaded_method_h(%O,"SERV_OPS")]>][
       [%f] dump_overloaded_method_h %( %O %, 'SERV_OPS' )% 
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for O
   end // if
   NOP
   if NOT-EMPTY
   begin
    #13#10

//	#private:<{}{"%OV"="PrivateAccess"&"%OS"!="ctor"}{Sp}[
    out_indent 'private:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Op
    begin
     OBJECT IN %O
     if ( ( %O |V ) %== 'PrivateAccess' AND 
      ( ( %O |S ) %!= 'ctor'  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	
       #13#10

//	%f_dump_overloaded_method_h(%O,"SERV_OPS")]>]
       [%f] dump_overloaded_method_h %( %O %, 'SERV_OPS' )% 
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for O
   end // if
   NOP
//	]][{%{NEED_UPDATE_RW}N=1}
  end // if
 end // if
 NOP
 if ( ( ( get_global_var ( 'NEED_UPDATE_RW' ) |N ) ) %== 1 ) then
 begin
  #13#10

//	
  #13#10

//	#protected:
  out_indent 'protected:'
//		virtual void upgrade_rw ();]
  '	virtual void upgrade_rw ();' 
 end // if

//f _is_property
; // dump_cpp_derrived_impl_h

: is_property OBJECT IN %S
//	[{%SC=Attribute}{false}[{%SS=property|%SS=readonly|%SS=writeonly}{false}true]]
 if ( ( %S |C ) %== 'Attribute' ) then
 begin
  if ( ( %S |S ) %== 'property' OR 
    ( ( %S |S ) %== 'readonly'  ) OR 
    ( ( %S |S ) %== 'writeonly'  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
 end // if
 else
 begin
   false 
 end // else

//f _self_have_same_method
; // is_property

: self_have_same_method OBJECT IN %S
//	[{%SC=Operation}[]%f_exists_in_list(%1N,"%SN (<%f_arg(%C)>")]
 if ( ( %S |C ) %== 'Operation' ) then
 begin
  if NOT-EMPTY
  begin
  end // if
  NOP
  [%f] exists_in_list %( %1 |N %, %S |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    [%f] arg %( %C )% 
    ++! l_Counter
   end // if
  end // for C
)%  end // if

//собираем сигнатуры операций БЕЗ возвращаемого значения!
//f _collect_self_operations_signature
; // self_have_same_method

: collect_self_operations_signature OBJECT IN %S
//	[{""="%1N"}%f_error("_collect_self_operations_signature: Не задан идентификатор списка!")]\
 if ( '' %== ( %1 |N ) ) then
 begin
  [%f] error %( '_collect_self_operations_signature: Не задан идентификатор списка!' )% 
 end // if
//	%f_set_var(LIST_ID,1)\
 [%f] set_var %( 'LIST_ID' %, 1 )% 
//	<{}{%CC=Operation}%f_add_to_list(%{LIST_ID}N,"%f_operation_signature(%C)")>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Operation' ) then
  begin
   [%f] add_to_list %( ( get_global_var ( 'LIST_ID' ) |N ) %, [%f] operation_signature %( %C )% )% 
   ++! l_Counter
  end // if
 end // for C
//	<{}{%f_is_property(%C)=true}[{%CS!=writeonly}%f_add_to_list(%{LIST_ID}N,"%f_read_accessor_signature(%C)")]\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_property %( %C )% ) %==  true ) then
  begin
   if ( ( %C |S ) %!= 'writeonly' ) then
   begin
    [%f] add_to_list %( ( get_global_var ( 'LIST_ID' ) |N ) %, [%f] read_accessor_signature %( %C )% )% 
   end // if
//	[{%CS!=readonly}%f_add_to_list(%{LIST_ID}N,"%f_write_accessor_signature(%C)")]>
   if ( ( %C |S ) %!= 'readonly' ) then
   begin
    [%f] add_to_list %( ( get_global_var ( 'LIST_ID' ) |N ) %, [%f] write_accessor_signature %( %C )% )% 
   end // if

   ++! l_Counter
  end // if
 end // for C

//f _collect_implemented_attrs
; // collect_self_operations_signature

: collect_implemented_attrs OBJECT IN %S
//	[{""="%1N"}%f_error("_collect_implemented_attrs: Не задан идентификатор списка!")]\
 if ( '' %== ( %1 |N ) ) then
 begin
  [%f] error %( '_collect_implemented_attrs: Не задан идентификатор списка!' )% 
 end // if
//	%f_set_var(LIST_ID,1)\
 [%f] set_var %( 'LIST_ID' %, 1 )% 
//	<{}{%f_is_property(%o)=true}%f_add_to_list(%{LIST_ID}N,o)>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( [%f] is_property %( %o )% ) %==  true ) then
  begin
   [%f] add_to_list %( ( get_global_var ( 'LIST_ID' ) |N ) %, 'o' )% 
   ++! l_Counter
  end // if
 end // for o

//f _operation_signature
; // collect_implemented_attrs

: operation_signature OBJECT IN %S
//	%SN (<%f_arg(%C)>)[ [{%SS!=chg&%SS!=oneway,chg&%SS!=static&%P#f_IsUtilityPack()!=true&"[{%PS=TemplateFunctions&%P%P#f_IsUtilityPack()=true}{false}true]"="false"}const]]
 %S |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   [%f] arg %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ')'
 if NOT-EMPTY
 begin
  ' '
  if ( ( %S |S ) %!= 'chg' AND 
    ( ( %S |S ) %!= 'oneway,chg'  ) AND 
    ( ( %S |S ) %!= 'static'  ) AND 
    ( ( %P %?f IsUtilityPack %( )% ) %!=  true  ) AND 
    ( if ( ( %P |S ) %== 'TemplateFunctions' AND 
     ( ( %P ->P %?f IsUtilityPack %( )%  ) %==  true  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %== false  ) ) then
  begin
   'const' 
  end // if
 end // if
 NOP

//f _read_accessor_signature
; // operation_signature

: read_accessor_signature OBJECT IN %S
//	get_%SN (<%f_arg(%C)>) const
 'get_'
 %S |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   [%f] arg %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ') const'

//f _write_accessor_signature
; // read_accessor_signature

: write_accessor_signature OBJECT IN %S
//	set_%SN (%t_arg(%T,"%f_arg_specificator(%S)")<%f_arg(%C)>)
 'set_'
 %S |N ' ('
 [%t] arg %( %T %, [%f] arg_specificator %( %S )% )% 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   [%f] arg %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ')'

//может ли %S пресдавлен элементом 
//f _can_represented_by
; // write_accessor_signature

: can_represented_by OBJECT IN %S
//#UC END# *4714D8170399*
; // can_represented_by


// генерация обявлений переопределённых конструкторов
//f _dump_cpp_derrived_constr_h
: dump_cpp_derrived_constr_h OBJECT IN %S
//#UC START# *4714D84200DA*
//	%f_set_var(SERV,S)[{%f_has_overloaded_ctors(%S)=true}[#public:
 [%f] set_var %( 'SERV' %, 'S' )% if ( ( [%f] has_overloaded_ctors %( %S )% ) %==  true ) then
 begin
  if NOT-EMPTY
  begin
   out_indent 'public:'
//	<{}{"%OV"="PublicAccess"&"%OS"="ctor"}{Sp}#	// inherited from %O%PN
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Op
   begin
    OBJECT IN %O
    if ( ( %O |V ) %== 'PublicAccess' AND 
     ( ( %O |S ) %== 'ctor'  ) ) then
    begin
     out_indent '	// inherited from '
     %O ->P |N  
//	%OX
     %O |X 
//	
     #13#10

//	>][#protected:

     ++! l_Counter
    end // if
   end // for O
  end // if
  NOP
  if NOT-EMPTY
  begin
   out_indent 'protected:'
//	<{}{"%OV"="ProtectedAccess"&"%OS"="ctor"}{Sp}#	// inherited from %O%PN
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Op
   begin
    OBJECT IN %O
    if ( ( %O |V ) %== 'ProtectedAccess' AND 
     ( ( %O |S ) %== 'ctor'  ) ) then
    begin
     out_indent '	// inherited from '
     %O ->P |N  
//	%OX
     %O |X 
//	
     #13#10

//	>]]

     ++! l_Counter
    end // if
   end // for O
  end // if
  NOP
 end // if
//#UC END# *4714D84200DA*
; // dump_cpp_derrived_constr_h


// генерация обявлений переопределённых конструкторов серванта
//f _dump_cpp_servant_derrived_constr_h
: dump_cpp_servant_derrived_constr_h OBJECT IN %S
//#UC START# *4714D8670119*
//	%f_set_var(SERV,S)<{}{"%OS"="ctor"}{Sp}#	// inherited from %O%PN
 [%f] set_var %( 'SERV' %, 'S' )% 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%Op
 begin
  OBJECT IN %O
  if ( ( %O |S ) %== 'ctor' ) then
  begin
   out_indent '	// inherited from '
   %O ->P |N  
//	%OX
   %O |X 
//	
   #13#10

//	>

   ++! l_Counter
  end // if
 end // for O
//#UC END# *4714D8670119*
; // dump_cpp_servant_derrived_constr_h


// генерация переопределённых конструкторов серванта
//f _dump_cpp_servant_derrived_constr_java
: dump_cpp_servant_derrived_constr_java OBJECT IN %S
//#UC START# *4714D88F007D*
//	%f_set_var(SERV,S)<{}{"%OS"="ctor"}{Sp}#	// inherited from %O%PN
 [%f] set_var %( 'SERV' %, 'S' )% 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%Op
 begin
  OBJECT IN %O
  if ( ( %O |S ) %== 'ctor' ) then
  begin
   out_indent '	// inherited from '
   %O ->P |N  
//	%OX
   %O |X 
//	
   #13#10

//	>

   ++! l_Counter
  end // if
 end // for O
//#UC END# *4714D88F007D*
; // dump_cpp_servant_derrived_constr_java


// генерация реализации переопределённых конструкторов
//f _dump_cpp_derrived_constr_cpp
: dump_cpp_derrived_constr_cpp OBJECT IN %S
//#UC START# *4714D8A1038A*
//	%f_set_var(SERV,S)<{}{"%OS"="ctor"}{Sp}// inherited from %O%PN
 [%f] set_var %( 'SERV' %, 'S' )% 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%Op
 begin
  OBJECT IN %O
  if ( ( %O |S ) %== 'ctor' ) then
  begin
   '// inherited from '
   %O ->P |N  
//	%OX
   %O |X 
//	
   #13#10

//	>

   ++! l_Counter
  end // if
 end // for O
//#UC END# *4714D8A1038A*
; // dump_cpp_derrived_constr_cpp


// есть ли ппереопределённые методы (кроме констукторов)
//f _has_overloaded_methods
: has_overloaded_methods OBJECT IN %S
//#UC START# *4714D8CF0167*
//	[{"<{}{%OS!=ctor}{C}>"!="0"}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%O
  begin
   OBJECT IN %O
   if ( ( %O |S ) %!= 'ctor' ) then
   begin

    ++! l_Counter
   end // if
  end // for O
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714D8CF0167*
; // has_overloaded_methods


// есть ли переопределённые конструкторы
//f _has_overloaded_ctors
: has_overloaded_ctors OBJECT IN %S
//#UC START# *4714D8F2003E*
//	[{"<{}{%OS=ctor}{C}>"!="0"}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%O
  begin
   OBJECT IN %O
   if ( ( %O |S ) %== 'ctor' ) then
   begin

    ++! l_Counter
   end // if
  end // for O
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714D8F2003E*
; // has_overloaded_ctors


// выводит COM-идентификатор
//f _comiid
: comiid OBJECT IN %S
//#UC START# *4714D90A01E4*
//	%f_str_conv("%SG","%8s-%4s-%4s-%2s%2s-%2s%2s%2s%2s%2s%2s","0x%s, 0x%s, 0x%s, {0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s}")
 [%f] str_conv %( %S |G %, %8 |s '-'
 %4 |s '-'
 %4 |s '-'
 %2 |s %2 |s '-'
 %2 |s %2 |s %2 |s %2 |s %2 |s %2 |s %, 0 'x'
 %s %, ' 0x'
 %s %, ' 0x'
 %s %, ' {0x'
 %s %, ' 0x'
 %s %, ' 0x'
 %s %, ' 0x'
 %s %, ' 0x'
 %s %, ' 0x'
 %s %, ' 0x'
 %s %, ' 0x'
 %s '}' )% 
//#UC END# *4714D90A01E4*
; // comiid


// есть ли фабричные методы
//f _has_factory_methods
: has_factory_methods OBJECT IN %S
//#UC START# *4714D9D600DA*
//	[{"%Sa"!="abstract"}{false}%f_has_self_factory_methods(%S)]
 if ( ( %S |a ) %!= 'abstract' ) then
 begin
  [%f] has_self_factory_methods %( %S )% 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714D9D600DA*
; // has_factory_methods


// есть ли фабричные методы
//f _has_self_factory_methods
: has_self_factory_methods OBJECT IN %S
//#UC START# *4714D9F20203*
//	[{%SM!=Servant::Class&%SM!=LocalInterface::Class}{[{"<{}{"%f_is_factory(%C)"="true"}{%CC}>"="0"}{true}%f_has_realize_factory_methods(%S)]}[{"<{}{"%f_is_factory(%C)"="true"}{%CC}>"="0"}{true}%f_has_base_factory_methods(%S)]]
 if ( ( %S |M ) %!= 'Servant::Class' AND 
   ( ( %S |M ) %!= 'LocalInterface::Class'  ) ) then
 begin
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( [%f] is_factory %( %C )% ) %== true ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %== 0 ) then
  begin
   [%f] has_base_factory_methods %( %S )% 
  end // if
  else
  begin
    true 
  end // else
 end // if
 else
 begin
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( [%f] is_factory %( %C )% ) %== true ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %== 0 ) then
  begin
   [%f] has_realize_factory_methods %( %S )% 
  end // if
  else
  begin
    true 
  end // else
 end // else
//#UC END# *4714D9F20203*
; // has_self_factory_methods


// есть ли фабричные методы среди базоввых элементов
//f _has_base_factory_methods
: has_base_factory_methods OBJECT IN %S
//#UC START# *4714DA02034B*
//	[{"<{}{"%f_has_self_factory_methods(%g)"="true"&"%ga"="abstract"}{%GC}>"="0"}{true}false]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if ( ( [%f] has_self_factory_methods %( %g )% ) %== true AND 
    ( ( %g |a ) %== 'abstract'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for G
  l_Counter
  %== 0 ) then
 begin
   false 
 end // if
 else
 begin
   true 
 end // else
//#UC END# *4714DA02034B*
; // has_base_factory_methods


// есть ли фабричные методы у реализуемых (рекурсивно) элементов
//f _has_realize_factory_methods
: has_realize_factory_methods OBJECT IN %S
//#UC START# *4714DA1900AB*
//	[{"<{}{"%f_has_self_factory_methods(%r)"="true"}{%rC}>"="0"}{true}false]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%r
  begin
   OBJECT IN %r
   if ( ( [%f] has_self_factory_methods %( %r )% ) %== true ) then
   begin

    ++! l_Counter
   end // if
  end // for r
  l_Counter
  %== 0 ) then
 begin
   false 
 end // if
 else
 begin
   true 
 end // else
//#UC END# *4714DA1900AB*
; // has_realize_factory_methods


// является ли элемент фабрикой
//f _is_factory
: is_factory OBJECT IN %S
//#UC START# *4714DA5203C8*
//@ %SU
//	[{"%SS"="factory"|"%SS"="multi factory"|%S#f_is_factory()=true}{false}true]
 if ( ( %S |S ) %== 'factory' OR 
   ( ( %S |S ) %== 'multi factory'  ) OR 
   ( ( %S %?f is_factory %( )% ) %==  true  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714DA5203C8*
; // is_factory


// генерация атрибутов и операций интерфейса, реализуемых сервантом
//f _servant_cpp_attribute_h
: servant_cpp_attribute_h OBJECT IN %S
//#UC START# *4714DA740000*
//	[{[{%t_need_ro(%S)=true&[{%1N!=false|%f_beaccessed(%S)=true}{false}true]=true}{false}true]=true|[{%t_need_rw(%S)=true&%2N!=false}{false}true]=true}%f_docs(%S)]\
 if ( if ( ( [%t] need_ro %( %S )% ) %==  true AND 
    ( if ( ( %1 |N ) %!=  false OR 
     ( ( [%f] beaccessed %( %S )% ) %==  true  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %==  true  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
  %==  true OR 
   ( if ( ( [%t] need_rw %( %S )% ) %==  true AND 
    ( ( %2 |N ) %!=  false  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
  %==  true  ) ) then
 begin
  [%f] docs %( %S )% 
 end // if
//	[{%t_need_ro(%S)=true}[{%1N!=false}	[{"%{SERV}a"!="final"|%t_interface(%{SERV})=true}virtual ]\
 if ( ( [%t] need_ro %( %S )% ) %==  true ) then
 begin
  if ( ( %1 |N ) %!=  false ) then
  begin
   '	'
   if ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final' OR 
     ( ( [%t] interface %( ( get_global_var ( 'SERV' ) ) )% ) %==  true  ) ) then
   begin
    'virtual ' 
   end // if
//	%f_iget_attr(%S) get_%SN (%S%f_accessor_args("true"))[ %f_op_const_spec(%S)][{%f_realize_srv_interface(%S)=false}{\n\t\tthrow (CORBA::SystemException<, %E<%NN::>%EN>)}[
   [%f] iget_attr %( %S )% ' get_'
   %S |N ' ('
   %S %f accessor_args %( true )% ')'
   if NOT-EMPTY
   begin
    ' '
    [%f] op_const_spec %( %S )% 
   end // if
   NOP
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
   begin
    if NOT-EMPTY
    begin
     #13#10

//			/*throw (<{, }%E<%NN::>%EN>)*/]];][{"%f_beaccessed(%S)"="true"}[{%1N!=false}
     '		/*throw ('
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %E
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%N
        begin
         OBJECT IN %N
         if true then
         begin
          %N |N '::' 
          ++! l_Counter
         end // if
        end // for N

       ) // bind
        %E |N 
       ++! l_Counter
      end // if
     end // for E
     ')*/' 
    end // if
    NOP
   end // if
   else
   begin
    #13#10#9#9'throw (CORBA::SystemException'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      ', '
      %E
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %E |N 
      ++! l_Counter
     end // if
    end // for E
    ')' 
   end // else
   ';' 
  end // if
  if ( ( [%f] beaccessed %( %S )% ) %== true ) then
  begin
   if ( ( %1 |N ) %!=  false ) then
   begin
    #13#10

//	]	[{"%{SERV}a"!="final"|%t_interface(%{SERV})=true}virtual ]%f_igetnc_attr(%S) get_%SN (%S%f_accessor_args())[{%f_realize_srv_interface(%S)=false}{\n\t\tthrow (CORBA::SystemException<, %E<%NN::>%EN>)}[
   end // if
   '	'
   if ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final' OR 
     ( ( [%t] interface %( ( get_global_var ( 'SERV' ) ) )% ) %==  true  ) ) then
   begin
    'virtual ' 
   end // if
   [%f] igetnc_attr %( %S )% ' get_'
   %S |N ' ('
   %S %f accessor_args %( )% ')'
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
   begin
    if NOT-EMPTY
    begin
     #13#10

//			/*throw (<{, }%E<%NN::>%EN>)*/]];]][{%t_need_rw(%S)=true&%2N!=false}[{%t_need_ro(%S)=true}\n\n]	[{"%{SERV}a"!="final"|%t_interface(%{SERV})=true}virtual ]void set_%SN (%f_iset_attr(%S) %SN[, %S%f_accessor_args()])[{%f_realize_srv_interface(%S)=false}{\n\t\tthrow (CORBA::SystemException<, %e<%NN::>%eN>)}[
     '		/*throw ('
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %E
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%N
        begin
         OBJECT IN %N
         if true then
         begin
          %N |N '::' 
          ++! l_Counter
         end // if
        end // for N

       ) // bind
        %E |N 
       ++! l_Counter
      end // if
     end // for E
     ')*/' 
    end // if
    NOP
   end // if
   else
   begin
    #13#10#9#9'throw (CORBA::SystemException'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      ', '
      %E
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %E |N 
      ++! l_Counter
     end // if
    end // for E
    ')' 
   end // else
   ';' 
  end // if
 end // if
 if ( ( [%t] need_rw %( %S )% ) %==  true AND 
   ( ( %2 |N ) %!=  false  ) ) then
 begin
  if ( ( [%t] need_ro %( %S )% ) %==  true ) then
  begin
   #13#10#13#10 
  end // if
  '	'
  if ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final' OR 
    ( ( [%t] interface %( ( get_global_var ( 'SERV' ) ) )% ) %==  true  ) ) then
  begin
   'virtual ' 
  end // if
  'void set_'
  %S |N ' ('
  [%f] iset_attr %( %S )% ' '
  %S |N if NOT-EMPTY
  begin
   ', '
   %S %f accessor_args %( )% 
  end // if
  NOP
  ')'
  if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//			/*throw (<{, }%e<%NN::>%eN>)*/]];]
    '		/*throw ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%e
    begin
     OBJECT IN %e
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      %e
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %e |N 
      ++! l_Counter
     end // if
    end // for e
    ')*/' 
   end // if
   NOP
  end // if
  else
  begin
   #13#10#9#9'throw (CORBA::SystemException'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     ', '
     %e
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%N
      begin
       OBJECT IN %N
       if true then
       begin
        %N |N '::' 
        ++! l_Counter
       end // if
      end // for N

     ) // bind
      %e |N 
     ++! l_Counter
    end // if
   end // for e
   ')' 
  end // else
  ';' 
 end // if
//#UC END# *4714DA740000*
; // servant_cpp_attribute_h


// возвращает true, если у элемента есть атрибут с заданным именем и видимостью "Implemented"
//f _is_impl_atrr
: is_impl_atrr OBJECT IN %S
// параметры: attr: void = %1
//#UC START# *4714DA96036B*
//	[{"<{}{"%CC"="Attribute"&"%CN"="%1N"&"%CV"="ImplementationAccess"}{%CC}>"!="0"}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Attribute' AND 
    ( ( %C |N ) %== ( %1 |N )  ) AND 
    ( ( %C |V ) %== 'ImplementationAccess'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714DA96036B*
; // is_impl_atrr


// генерация атрибутов и операций интерфейса, реализуемых сервантом
//f _servant_cpp_attribute_cpp
: servant_cpp_attribute_cpp OBJECT IN %S
//#UC START# *4714DA9E01F4*
//	%f_set_var(LINE_FEED,"")\
 [%f] set_var %( 'LINE_FEED' %, '' )% 
//	[{[{%t_need_ro(%S)=true&[{%1N!=false|%f_beaccessed(%S)=true}{false}true]=true}{false}true]=true|[{%t_need_rw(%S)=true&%2N!=false}{false}true]=true}%f_docs(%S)]\
 if ( if ( ( [%t] need_ro %( %S )% ) %==  true AND 
    ( if ( ( %1 |N ) %!=  false OR 
     ( ( [%f] beaccessed %( %S )% ) %==  true  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %==  true  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
  %==  true OR 
   ( if ( ( [%t] need_rw %( %S )% ) %==  true AND 
    ( ( %2 |N ) %!=  false  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
  %==  true  ) ) then
 begin
  [%f] docs %( %S )% 
 end // if
//	[{%t_need_ro(%S)=true}[{%1N!=false}%f_set_var(LINE_FEED,"\n\n")\
 if ( ( [%t] need_ro %( %S )% ) %==  true ) then
 begin
  if ( ( %1 |N ) %!=  false ) then
  begin
   [%f] set_var %( 'LINE_FEED' %, #13#10#13#10 )% 
//	%f_templ_header(%{SERV})%f_iget_attr(%S) %{SERV}N%f_templ_footer(%{SERV})::get_%SN (%S%f_accessor_args("true"))[ %f_op_const_spec(%S)][{%f_realize_srv_interface(%S)=false}{\n	throw (CORBA::SystemException<, %E<%NN::>%EN>)\n}[{%Ex=true}{ }
   [%f] templ_header %( ( get_global_var ( 'SERV' ) ) )% [%f] iget_attr %( %S )% ' '
   ( get_global_var ( 'SERV' ) |N ) [%f] templ_footer %( ( get_global_var ( 'SERV' ) ) )% '::get_'
   %S |N ' ('
   %S %f accessor_args %( true )% ')'
   if NOT-EMPTY
   begin
    ' '
    [%f] op_const_spec %( %S )% 
   end // if
   NOP
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
   begin
    if ( ( %E |x ) %==  true ) then
    begin
     #13#10

//		/*throw (<{, }%E<%NN::>%EN>)*/
     '	/*throw ('
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %E
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%N
        begin
         OBJECT IN %N
         if true then
         begin
          %N |N '::' 
          ++! l_Counter
         end // if
        end // for N

       ) // bind
        %E |N 
       ++! l_Counter
      end // if
     end // for E
     ')*/'
//	]]{%f_start_func_cpp(%S,"%{SERV}N::get_%SN const")%f_set_var(OP,S)
    end // if
    else
    begin
     ' ' 
    end // else
   end // if
   else
   begin
    #13#10'	throw (CORBA::SystemException'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      ', '
      %E
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %E |N 
      ++! l_Counter
     end // if
    end // for E
    ')'#13#10 
   end // else
   '{'
   [%f] start_func_cpp %( %S %, ( get_global_var ( 'SERV' ) |N ) '::get_'
   %S |N ' const' )% [%f] set_var %( 'OP' %, 'S' )% 
//		[{%f_is_impl_atrr(%{SERV},%S)=true}{%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U_GET]}
   '	'
   if ( ( [%f] is_impl_atrr %( ( get_global_var ( 'SERV' ) ) %, %S )% ) %==  true ) then
   begin
    'return m_'
    %S |N ';' 
   end // if
   else
   begin
    %Usersection (
     if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
     begin
      '_'
      ( get_global_var ( 'SERV' ) |U ) '_GET' 
     end // if

    )
    (
     #13#10

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
     '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]}return m_%SN;]
     '	' 
    ) // Usersection
    end // else
//	}][{"%f_beaccessed(%S)"="true"}%{LINE_FEED}N\
   '}' 
  end // if
  if ( ( [%f] beaccessed %( %S )% ) %== true ) then
  begin
   ( get_global_var ( 'LINE_FEED' ) |N ) 
//	%f_set_var(LINE_FEED,"\n\n")\
   [%f] set_var %( 'LINE_FEED' %, #13#10#13#10 )% 
//	%f_templ_header(%{SERV})%f_igetnc_attr(%S) %{SERV}N%f_templ_footer(%{SERV})::get_%SN (%S%f_accessor_args())[{%f_realize_srv_interface(%S)=false}{\n	throw (CORBA::SystemException<, %E<%NN::>%EN>)\n}[{%Ex=true}{ }
   [%f] templ_header %( ( get_global_var ( 'SERV' ) ) )% [%f] igetnc_attr %( %S )% ' '
   ( get_global_var ( 'SERV' ) |N ) [%f] templ_footer %( ( get_global_var ( 'SERV' ) ) )% '::get_'
   %S |N ' ('
   %S %f accessor_args %( )% ')'
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
   begin
    if ( ( %E |x ) %==  true ) then
    begin
     #13#10

//		/*throw (<{, }%E<%NN::>%EN>)*/
     '	/*throw ('
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %E
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%N
        begin
         OBJECT IN %N
         if true then
         begin
          %N |N '::' 
          ++! l_Counter
         end // if
        end // for N

       ) // bind
        %E |N 
       ++! l_Counter
      end // if
     end // for E
     ')*/'
//	]]{%f_start_func_cpp(%S,"%{SERV}N::get_%SN")
    end // if
    else
    begin
     ' ' 
    end // else
   end // if
   else
   begin
    #13#10'	throw (CORBA::SystemException'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      ', '
      %E
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %E |N 
      ++! l_Counter
     end // if
    end // for E
    ')'#13#10 
   end // else
   '{'
   [%f] start_func_cpp %( %S %, ( get_global_var ( 'SERV' ) |N ) '::get_'
   %S |N )% 
//		[{%S{force use const arg}=true}{return const_cast\<%f_igetnc_attr(%S)\>(((const %{SERV}N*)this)-\>get_%SN (<{, }%CN>));}%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U_GET_NC]}
   '	'
   if ( ( %S get_up ( 'force use const arg' ) ) %==  true ) then
   begin
    %Usersection (
     if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
     begin
      '_'
      ( get_global_var ( 'SERV' ) |U ) '_GET_NC' 
     end // if

    )
    (
     #13#10

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
     '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]]
     '	' 
    ) // Usersection
    end // if
   else
   begin
    'return const_cast<'
    [%f] igetnc_attr %( %S )% '>(((const '
    ( get_global_var ( 'SERV' ) |N ) '*)this)->get_'
    %S |N ' ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      %C |N 
      ++! l_Counter
     end // if
    end // for C
    '));' 
   end // else
//	}]][{%t_need_rw(%S)=true&%2N!=false}%{LINE_FEED}N\
   '}' 
  end // if
 end // if
 if ( ( [%t] need_rw %( %S )% ) %==  true AND 
   ( ( %2 |N ) %!=  false  ) ) then
 begin
  ( get_global_var ( 'LINE_FEED' ) |N ) 
//	%f_templ_header(%{SERV})void %{SERV}N%f_templ_footer(%{SERV})::set_%SN (%f_iset_attr(%S) %SN[, %S%f_accessor_args()])[{%f_realize_srv_interface(%S)=false}{\n	throw (CORBA::SystemException<, %e<%NN::>%eN>)\n}[{%ex=true}{ }
  [%f] templ_header %( ( get_global_var ( 'SERV' ) ) )% 'void '
  ( get_global_var ( 'SERV' ) |N ) [%f] templ_footer %( ( get_global_var ( 'SERV' ) ) )% '::set_'
  %S |N ' ('
  [%f] iset_attr %( %S )% ' '
  %S |N if NOT-EMPTY
  begin
   ', '
   %S %f accessor_args %( )% 
  end // if
  NOP
  ')'
  if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
  begin
   if ( ( %e |x ) %==  true ) then
   begin
    #13#10

//		/*throw (<{, }%e<%NN::>%eN>)*/
    '	/*throw ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%e
    begin
     OBJECT IN %e
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      %e
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %e |N 
      ++! l_Counter
     end // if
    end // for e
    ')*/'
//	]]{%f_start_func_cpp(%S,"%{SERV}N::set_%SN")
   end // if
   else
   begin
    ' ' 
   end // else
  end // if
  else
  begin
   #13#10'	throw (CORBA::SystemException'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     ', '
     %e
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%N
      begin
       OBJECT IN %N
       if true then
       begin
        %N |N '::' 
        ++! l_Counter
       end // if
      end // for N

     ) // bind
      %e |N 
     ++! l_Counter
    end // if
   end // for e
   ')'#13#10 
  end // else
  '{'
  [%f] start_func_cpp %( %S %, ( get_global_var ( 'SERV' ) |N ) '::set_'
  %S |N )% 
//		[{%f_is_impl_atrr(%{SERV},%S)=true}{%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U_SET]}
  '	'
  if ( ( [%f] is_impl_atrr %( ( get_global_var ( 'SERV' ) ) %, %S )% ) %==  true ) then
  begin
   'm_'
   %S |N ' = '
   %S |N ';' 
  end // if
  else
  begin
   %Usersection (
    if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
    begin
     '_'
     ( get_global_var ( 'SERV' ) |U ) '_SET' 
    end // if

   )
   (
    #13#10

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
    '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]}m_%SN = %SN;]
    '	' 
   ) // Usersection
   end // else
//	}]
  '}' 
 end // if
//#UC END# *4714DA9E01F4*
; // servant_cpp_attribute_cpp


// генерация oneway операции
//f _servant_cpp_oneway_operation_thr_h
: servant_cpp_oneway_operation_thr_h OBJECT IN %S
//#UC START# *4714DAAE02EE*
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	]#static void thr_%SN_ (void* arg);[
 end // if
 NOP
 out_indent 'static void thr_'
 %S |N '_ (void* arg);'
 if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4714DAAE02EE*
; // servant_cpp_oneway_operation_thr_h


// генерация oneway операции
//f _servant_cpp_oneway_operation_impl_h
: servant_cpp_oneway_operation_impl_h OBJECT IN %S
//#UC START# *4714DAC403B9*
//	%f_set_var(ONEWAY_OP,"#[{"%Sa"="abstract"|"%Sa"="regular"&"%{SERV}a"!="final"}virtual ]%f_ret(%S) %SN_ (<{, }%f_arg_full_decl(%C)>)[{%SS!=oneway,chg} const][{"%Sa"="abstract"&"%PU"="%{SERV}U"} = 0];")\
 [%f] set_var %( 'ONEWAY_OP' %, out_indent if ( ( %S |a ) %== 'abstract' OR 
   ( ( %S |a ) %== 'regular'  ) AND 
   ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final'  ) ) then
 begin
  'virtual ' 
 end // if
 [%f] ret %( %S )% ' '
 %S |N '_ ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ')'
 if ( ( %S |S ) %!= 'oneway,chg' ) then
 begin
  ' const' 
 end // if
 if ( ( %S |a ) %== 'abstract' AND 
   ( ( %P |U ) %== ( ( get_global_var ( 'SERV' ) |U ) )  ) ) then
 begin
  ' = 0' 
 end // if
 ';' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{ONEWAY_OP}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'ONEWAY_OP' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{ONEWAY_OP}N}#[{"%Sa"="abstract"|"%Sa"="regular"&"%{SERV}a"!="final"}virtual ]%f_ret(%S) %SN_ (\n\t\t<{\n\t\t, }%f_arg_full_decl(%C)>\n\t)[{%SS!=oneway,chg} const][{"%Sa"="abstract"&"%PU"="%{SERV}U"} = 0];]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  out_indent if ( ( %S |a ) %== 'abstract' OR 
    ( ( %S |a ) %== 'regular'  ) AND 
    ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final'  ) ) then
  begin
   'virtual ' 
  end // if
  [%f] ret %( %S )% ' '
  %S |N '_ ('#13#10#9#9
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( #13#10#9#9', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  #13#10#9')'
  if ( ( %S |S ) %!= 'oneway,chg' ) then
  begin
   ' const' 
  end // if
  if ( ( %S |a ) %== 'abstract' AND 
    ( ( %P |U ) %== ( ( get_global_var ( 'SERV' ) |U ) )  ) ) then
  begin
   ' = 0' 
  end // if
  ';' 
 end // if
 else
 begin
  ( get_global_var ( 'ONEWAY_OP' ) |N ) 
 end // else

//#UC END# *4714DAC403B9*
; // servant_cpp_oneway_operation_impl_h


// генерация конструктора для струтуры параметров oneway-операции
//f _oneway_params_ctor
: oneway_params_ctor OBJECT IN %S
//#UC START# *4714DADE02FD*
//	%f_set_var(ONEWAY_PARAMS_CTOR,"%f_to_borland(%SN)Params_ ([{%SS!=oneway,chg}const ]%PN* self_<, %f_arg(%C) %CN_>) : self([{%t_refcounted(%P)=true}{self_}%PN::_duplicate(self_)])<, %CN([{%t_refcounted(%C%T)=true}{%CN_}%f_type(%C%T)::_duplicate([{%CS=inref|%CS=inoutref}&]%CN_)])> {")\
 [%f] set_var %( 'ONEWAY_PARAMS_CTOR' %, [%f] to_borland %( %S |N )% 'Params_ ('
 if ( ( %S |S ) %!= 'oneway,chg' ) then
 begin
  'const ' 
 end // if
 %P |N '* self_'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   [%f] arg %( %C )% ' '
   %C |N '_' 
   ++! l_Counter
  end // if
 end // for C
 ') : self('
 if ( ( [%t] refcounted %( %P )% ) %==  true ) then
 begin
  %P |N '::_duplicate(self_)' 
 end // if
 else
 begin
  'self_' 
 end // else
 ')'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   %C |N '('
   if ( ( [%t] refcounted %( %C ->T  )% ) %==  true ) then
   begin
    [%f] type %( %C ->T  )% '::_duplicate('
    if ( ( %C |S ) %== 'inref' OR 
      ( ( %C |S ) %== 'inoutref'  ) ) then
    begin
     '&' 
    end // if
    %C |N '_)' 
   end // if
   else
   begin
    %C |N '_' 
   end // else
   ')' 
   ++! l_Counter
  end // if
 end // for C
 ' {' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{ONEWAY_PARAMS_CTOR}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'ONEWAY_PARAMS_CTOR' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{ONEWAY_PARAMS_CTOR}N}%f_to_borland(%SN)Params_ (\n\t\t[{%SS!=oneway,chg}const ]%PN* self_<\n\t\t, %f_arg(%C) %CN_>\n\t) :\n\t\tself([{%t_refcounted(%P)=true}{self_}%PN::_duplicate(self_)])<\n\t\t, %CN([{%t_refcounted(%C%T)=true}{%CN_}%f_type(%C%T)::_duplicate([{%CS=inref|%CS=inoutref}&]%CN_)])>\n\t{]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  [%f] to_borland %( %S |N )% 'Params_ ('#13#10#9#9
  if ( ( %S |S ) %!= 'oneway,chg' ) then
  begin
   'const ' 
  end // if
  %P |N '* self_'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    #13#10#9#9', '
    [%f] arg %( %C )% ' '
    %C |N '_' 
    ++! l_Counter
   end // if
  end // for C
  #13#10#9') :'#13#10#9#9'self('
  if ( ( [%t] refcounted %( %P )% ) %==  true ) then
  begin
   %P |N '::_duplicate(self_)' 
  end // if
  else
  begin
   'self_' 
  end // else
  ')'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    #13#10#9#9', '
    %C |N '('
    if ( ( [%t] refcounted %( %C ->T  )% ) %==  true ) then
    begin
     [%f] type %( %C ->T  )% '::_duplicate('
     if ( ( %C |S ) %== 'inref' OR 
       ( ( %C |S ) %== 'inoutref'  ) ) then
     begin
      '&' 
     end // if
     %C |N '_)' 
    end // if
    else
    begin
     %C |N '_' 
    end // else
    ')' 
    ++! l_Counter
   end // if
  end // for C
  #13#10#9'{' 
 end // if
 else
 begin
  ( get_global_var ( 'ONEWAY_PARAMS_CTOR' ) |N ) 
 end // else

//#UC END# *4714DADE02FD*
; // oneway_params_ctor


// генерация oneway операции
//f _servant_cpp_oneway_operation_thr_cpp
: servant_cpp_oneway_operation_thr_cpp OBJECT IN %S
//#UC START# *4714DB000186*
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	]struct %f_to_borland(%SN)Params_ {
 end // if
 NOP
 'struct '
 [%f] to_borland %( %S |N )% 'Params_ {'
//		%PN[{%t_refcounted(%P)=true}{[{%SS!=oneway,chg} const]*}_[{%SS!=oneway,chg}c]var] self;
 '	'
 %P |N if ( ( [%t] refcounted %( %P )% ) %==  true ) then
 begin
  '_'
  if ( ( %S |S ) %!= 'oneway,chg' ) then
  begin
   'c' 
  end // if
  'var' 
 end // if
 else
 begin
  if ( ( %S |S ) %!= 'oneway,chg' ) then
  begin
   ' const' 
  end // if
  '*' 
 end // else
 ' self;'
//	<{}{}{%C}	[{%f_check_if_type(%C%T,"string")=true}{[{%f_check_if_type(%C%T,"wstring")=true}{[{%CS=in|%CS=inref}{%f_var(%C%T)}%f_cvar(%C%T)] %CN}%f_var("a-wstring") %CN];}%f_var("a-string") %CN;]
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   '	'
   if ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  true ) then
   begin
    [%f] var %( 'a-string' )% ' '
    %C |N ';' 
   end // if
   else
   begin
    if ( ( [%f] check_if_type %( %C ->T  %, 'wstring' )% ) %==  true ) then
    begin
     [%f] var %( 'a-wstring' )% ' '
     %C |N 
    end // if
    else
    begin
     if ( ( %C |S ) %== 'in' OR 
       ( ( %C |S ) %== 'inref'  ) ) then
     begin
      [%f] cvar %( %C ->T  )% 
     end // if
     else
     begin
      [%f] var %( %C ->T  )% 
     end // else
     ' '
     %C |N 
    end // else
    ';' 
   end // else
//	>	%f_oneway_params_ctor(%S)

   ++! l_Counter
  end // if
 end // for C
 '	'
 [%f] oneway_params_ctor %( %S )% 
//		}
 '	}'
//	};
 '};'
//	
//	%f_templ_header(%{SERV})void %f_function_scope(%{SERV})thr_%SN_ (void* arg) {%f_start_func_cpp(%S,"%{SERV}N::%SN")
 [%f] templ_header %( ( get_global_var ( 'SERV' ) ) )% 'void '
 [%f] function_scope %( ( get_global_var ( 'SERV' ) ) )% 'thr_'
 %S |N '_ (void* arg) {'
 [%f] start_func_cpp %( %S %, ( get_global_var ( 'SERV' ) |N ) '::'
 %S |N )% 
//		try {
 '	try {'
//			Core::Aptr\<%f_to_borland(%SN)Params_\> arg_ (reinterpret_cast\<%f_to_borland(%SN)Params_*\>(arg));
 '		Core::Aptr<'
 [%f] to_borland %( %S |N )% 'Params_> arg_ (reinterpret_cast<'
 [%f] to_borland %( %S |N )% 'Params_*>(arg));'
//			arg_-\>self-\>%SN_ (<{, }[{%CS=inref|%CS=inoutref}*]arg_-\>%CN[{%C%TN=string|%C%T%GN=string}{[{%t_refcounted(%C%T)=true}.in ()]}.data ()]>);
 '		arg_->self->'
 %S |N '_ ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   if ( ( %C |S ) %== 'inref' OR 
     ( ( %C |S ) %== 'inoutref'  ) ) then
   begin
    '*' 
   end // if
   'arg_->'
   %C |N if ( ( %C ->T |N  ) %== 'string' OR 
     ( ( %C ->T ->G |N   ) %== 'string'  ) ) then
   begin
    '.data ()' 
   end // if
   else
   begin
    if ( ( [%t] refcounted %( %C ->T  )% ) %==  true ) then
    begin
     '.in ()' 
    end // if
   end // else

   ++! l_Counter
  end // if
 end // for C
 ');'
//		} catch (Core::Exception& ex) {
 '	} catch (Core::Exception& ex) {'
//			LOG_SEX ((ex, "while execute %PN::%SN oneway function"));
 '		LOG_SEX ((ex, "while execute '
 %P |N '::'
 %S |N ' oneway function"));'
//		} catch (...) {
 '	} catch (...) {'
//			LOG_UEX (("while execute %PN::%SN oneway function"));
 '		LOG_UEX (("while execute '
 %P |N '::'
 %S |N ' oneway function"));'
//		}
 '	}'
//	%f_end_func_cpp(%S)}[
 [%f] end_func_cpp %( %S )% '}'
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4714DB000186*
; // servant_cpp_oneway_operation_thr_cpp


// генерация заголовка oneway операции
//f _servant_oneway_operation_header_impl_cpp
: servant_oneway_operation_header_impl_cpp OBJECT IN %S
//#UC START# *4714DB1402DE*
//	%f_set_var(ONEWAY_OP,"/*oneway*/ %f_templ_header(%{SERV})Core::ThreadHandle %f_function_scope(%{SERV})%SN (<{, }%f_arg_full_decl(%C)>)[{%SS!=oneway,chg} const] {")\
 [%f] set_var %( 'ONEWAY_OP' %, '/*oneway*/ '
 [%f] templ_header %( ( get_global_var ( 'SERV' ) ) )% 'Core::ThreadHandle '
 [%f] function_scope %( ( get_global_var ( 'SERV' ) ) )% %S |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ')'
 if ( ( %S |S ) %!= 'oneway,chg' ) then
 begin
  ' const' 
 end // if
 ' {' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{ONEWAY_OP}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'ONEWAY_OP' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{ONEWAY_OP}N}/*oneway*/ %f_templ_header(%{SERV})Core::ThreadHandle %f_function_scope(%{SERV})%SN (\n\t<{\n\t, }%f_arg_full_decl(%C)>\n)[{%SS!=oneway,chg} const] {]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  '/*oneway*/ '
  [%f] templ_header %( ( get_global_var ( 'SERV' ) ) )% 'Core::ThreadHandle '
  [%f] function_scope %( ( get_global_var ( 'SERV' ) ) )% %S |N ' ('#13#10#9
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( #13#10#9', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  #13#10')'
  if ( ( %S |S ) %!= 'oneway,chg' ) then
  begin
   ' const' 
  end // if
  ' {' 
 end // if
 else
 begin
  ( get_global_var ( 'ONEWAY_OP' ) |N ) 
 end // else

//#UC END# *4714DB1402DE*
; // servant_oneway_operation_header_impl_cpp


// генерация oneway операции
//f _servant_cpp_oneway_operation_impl_cpp
: servant_cpp_oneway_operation_impl_cpp OBJECT IN %S
//#UC START# *4714DB2D035B*
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	]%f_servant_oneway_operation_header_impl_cpp(%S)%f_start_func_cpp(%S,"%{SERV}N::%SN")
 end // if
 NOP
 [%f] servant_oneway_operation_header_impl_cpp %( %S )% [%f] start_func_cpp %( %S %, ( get_global_var ( 'SERV' ) |N ) '::'
 %S |N )% 
//		Core::Aptr\<%f_to_borland(%SN)Params_\> arg = new %f_to_borland(%SN)Params_ (this<, %CN>);
 '	Core::Aptr<'
 [%f] to_borland %( %S |N )% 'Params_> arg = new '
 [%f] to_borland %( %S |N )% 'Params_ (this'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   %C |N 
   ++! l_Counter
  end // if
 end // for C
 ');'
//		Core::ThreadHandle ret = [{%S{separate thread pool}=none}{m_objects_thread_pool-\>}Core::ThreadPoolFactory::def().]spawn_thread (
 '	Core::ThreadHandle ret = '
 if ( ( %S get_up ( 'separate thread pool' ) ) %== 'none' ) then
 begin
  'Core::ThreadPoolFactory::def().' 
 end // if
 else
 begin
  'm_objects_thread_pool->' 
 end // else
 'spawn_thread ('
//			reinterpret_cast\<ACE_THR_FUNC\> (%f_function_scope(%{SERV})thr_%SN_), arg.in ()
 '		reinterpret_cast<ACE_THR_FUNC> ('
 [%f] function_scope %( ( get_global_var ( 'SERV' ) ) )% 'thr_'
 %S |N '_), arg.in ()'
//		);
 '	);'
//		if (ret == 0) {
 '	if (ret == 0) {'
//			throw; //CantSpawnThread ();
 '		throw; //CantSpawnThread ();'
//		} else {
 '	} else {'
//			arg.forget ();
 '		arg.forget ();'
//		}
 '	}'
//		return ret;
 '	return ret;'
//	%f_end_func_cpp(%S)}[
 [%f] end_func_cpp %( %S )% '}'
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4714DB2D035B*
; // servant_cpp_oneway_operation_impl_cpp


// генерация операции серванта
//f _servant_cpp_operation_h_i
: servant_cpp_operation_h_i OBJECT IN %S
//#UC START# *4714DB4301E4*
//	%f_set_var(SERVANT_OPERATION,"#[{%SS=static|%SV=PrivateAccess&%P#f_IsUtilityPack()=true}static ][{%SS=oneway&%PU=%{SERV}U|%SS=oneway,chg&%PU=%{SERV}U}{[{%t_interface(%{SERV})=true|%Sa=abstract&%{SERV}a!=final|%Sa=regular&%{SERV}a!=final&%SS!=static&%PS!=TemplateFunctions}virtual ]%f_ret(%S) }/*oneway*/ Core::ThreadHandle ]%SN[{%PS!=ServerInterface&%PS!=ServerFacet}[{%SS=oneway&%PU!=%{SERV}U|%SS=oneway,chg&%PU!=%{SERV}U}_]] (<{, }%f_arg_full_decl(%C)>)[ %f_op_const_spec(%S)][{%f_realize_srv_interface(%S)=false}{ throw (CORBA::SystemException<, %E<%NN::>%EN>)}[ /*throw (<{, }%E<%NN::>%EN>)*/]][{%Sa=abstract&%PU=%{SERV}U&%SS!=oneway&%SS!=oneway,chg} = 0];")\
 [%f] set_var %( 'SERVANT_OPERATION' %, out_indent if ( ( %S |S ) %== 'static' OR 
   ( ( %S |V ) %== 'PrivateAccess'  ) AND 
   ( ( %P %?f IsUtilityPack %( )% ) %==  true  ) ) then
 begin
  'static ' 
 end // if
 if ( ( %S |S ) %== 'oneway' AND 
   ( ( %P |U ) %== ( ( get_global_var ( 'SERV' ) |U ) )  ) OR 
   ( ( %S |S ) %== 'oneway,chg'  ) AND 
   ( ( %P |U ) %== ( ( get_global_var ( 'SERV' ) |U ) )  ) ) then
 begin
  '/*oneway*/ Core::ThreadHandle ' 
 end // if
 else
 begin
  if ( ( [%t] interface %( ( get_global_var ( 'SERV' ) ) )% ) %==  true OR 
    ( ( %S |a ) %== 'abstract'  ) AND 
    ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final'  ) OR 
    ( ( %S |a ) %== 'regular'  ) AND 
    ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final'  ) AND 
    ( ( %S |S ) %!= 'static'  ) AND 
    ( ( %P |S ) %!= 'TemplateFunctions'  ) ) then
  begin
   'virtual ' 
  end // if
  [%f] ret %( %S )% ' ' 
 end // else
 %S |N if ( ( %P |S ) %!= 'ServerInterface' AND 
   ( ( %P |S ) %!= 'ServerFacet'  ) ) then
 begin
  if ( ( %S |S ) %== 'oneway' AND 
    ( ( %P |U ) %!= ( ( get_global_var ( 'SERV' ) |U ) )  ) OR 
    ( ( %S |S ) %== 'oneway,chg'  ) AND 
    ( ( %P |U ) %!= ( ( get_global_var ( 'SERV' ) |U ) )  ) ) then
  begin
   '_' 
  end // if
 end // if
 ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ')'
 if NOT-EMPTY
 begin
  ' '
  [%f] op_const_spec %( %S )% 
 end // if
 NOP
 if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
 begin
  if NOT-EMPTY
  begin
   ' /*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %E
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%N
      begin
       OBJECT IN %N
       if true then
       begin
        %N |N '::' 
        ++! l_Counter
       end // if
      end // for N

     ) // bind
      %E |N 
     ++! l_Counter
    end // if
   end // for E
   ')*/' 
  end // if
  NOP
 end // if
 else
 begin
  ' throw (CORBA::SystemException'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    %E
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%N
     begin
      OBJECT IN %N
      if true then
      begin
       %N |N '::' 
       ++! l_Counter
      end // if
     end // for N

    ) // bind
     %E |N 
    ++! l_Counter
   end // if
  end // for E
  ')' 
 end // else
 if ( ( %S |a ) %== 'abstract' AND 
   ( ( %P |U ) %== ( ( get_global_var ( 'SERV' ) |U ) )  ) AND 
   ( ( %S |S ) %!= 'oneway'  ) AND 
   ( ( %S |S ) %!= 'oneway,chg'  ) ) then
 begin
  ' = 0' 
 end // if
 ';' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{SERVANT_OPERATION}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'SERVANT_OPERATION' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{SERVANT_OPERATION}N}#[{%SS"="static|%SV=PrivateAccess&%P#f_IsUtilityPack()=true}static ][{%SS=oneway&%PU=%{SERV}U|%SS=oneway,chg&%PU=%{SERV}U}{[{%t_interface(%{SERV})=true|%Sa=abstract&%{SERV}a!=final|%Sa=regular&%{SERV}a!=final&%SS!=static&%PS!=TemplateFunctions}virtual ]%f_ret(%S) }/*oneway*/ Core::ThreadHandle ]%SN[{%PS!=ServerInterface&%PS!=ServerFacet}[{%SS=oneway&%PU!=%{SERV}U|%SS=oneway,chg&%PU!=%{SERV}U}_]] (\n\t\t<{\n\t\t, }%f_arg_full_decl(%C)>\n\t)[ %f_op_const_spec(%S)][{%f_realize_srv_interface(%S)=false}{ throw (\n\t\tCORBA::SystemException<\n\t\t, %E<%NN::>%EN>\n\t)}[ /*throw (\n\t\t<{\n\t\t, }%E<%NN::>%EN>\n\t)*/]][{%Sa=abstract&%PU=%{SERV}U&%SS!=oneway&%SS!="oneway,chg} = 0];]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  out_indent if ( ( %S |S ) %== 'static' OR 
    ( ( %S |V ) %== 'PrivateAccess'  ) AND 
    ( ( %P %?f IsUtilityPack %( )% ) %==  true  ) ) then
  begin
   'static ' 
  end // if
  if ( ( %S |S ) %== 'oneway' AND 
    ( ( %P |U ) %== ( ( get_global_var ( 'SERV' ) |U ) )  ) OR 
    ( ( %S |S ) %== 'oneway,chg'  ) AND 
    ( ( %P |U ) %== ( ( get_global_var ( 'SERV' ) |U ) )  ) ) then
  begin
   '/*oneway*/ Core::ThreadHandle ' 
  end // if
  else
  begin
   if ( ( [%t] interface %( ( get_global_var ( 'SERV' ) ) )% ) %==  true OR 
     ( ( %S |a ) %== 'abstract'  ) AND 
     ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final'  ) OR 
     ( ( %S |a ) %== 'regular'  ) AND 
     ( ( ( get_global_var ( 'SERV' ) |a ) ) %!= 'final'  ) AND 
     ( ( %S |S ) %!= 'static'  ) AND 
     ( ( %P |S ) %!= 'TemplateFunctions'  ) ) then
   begin
    'virtual ' 
   end // if
   [%f] ret %( %S )% ' ' 
  end // else
  %S |N if ( ( %P |S ) %!= 'ServerInterface' AND 
    ( ( %P |S ) %!= 'ServerFacet'  ) ) then
  begin
   if ( ( %S |S ) %== 'oneway' AND 
     ( ( %P |U ) %!= ( ( get_global_var ( 'SERV' ) |U ) )  ) OR 
     ( ( %S |S ) %== 'oneway,chg'  ) AND 
     ( ( %P |U ) %!= ( ( get_global_var ( 'SERV' ) |U ) )  ) ) then
   begin
    '_' 
   end // if
  end // if
  ' ('#13#10#9#9
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( #13#10#9#9', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  #13#10#9')'
  if NOT-EMPTY
  begin
   ' '
   [%f] op_const_spec %( %S )% 
  end // if
  NOP
  if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    ' /*throw ('#13#10#9#9
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      if ( l_Counter >0 ) then ( #13#10#9#9', ' )
      %E
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %E |N 
      ++! l_Counter
     end // if
    end // for E
    #13#10#9')*/' 
   end // if
   NOP
  end // if
  else
  begin
   ' throw ('#13#10#9#9'CORBA::SystemException'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     #13#10#9#9', '
     %E
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%N
      begin
       OBJECT IN %N
       if true then
       begin
        %N |N '::' 
        ++! l_Counter
       end // if
      end // for N

     ) // bind
      %E |N 
     ++! l_Counter
    end // if
   end // for E
   #13#10#9')' 
  end // else
  if ( ( %S |a ) %== 'abstract' AND 
    ( ( %P |U ) %== ( ( get_global_var ( 'SERV' ) |U ) )  ) AND 
    ( ( %S |S ) %!= 'oneway'  ) AND 
    ( ( %S |S ) %!= 'oneway,chg'  ) ) then
  begin
   ' = 0' 
  end // if
  ';' 
 end // if
 else
 begin
  ( get_global_var ( 'SERVANT_OPERATION' ) |N ) 
 end // else

//дампит если нужно спецификатор const
//f _op_const_spec
; // servant_cpp_operation_h_i

: op_const_spec OBJECT IN %S
//	[{%SS!=chg&%SS!=oneway,chg&%SS!=static&%P#f_IsUtilityPack()!=true&%PM!=ServerInterface::Class&%PM!=ServerFacet::Class&"[{%PS=TemplateFunctions&%P%P#f_IsUtilityPack()=true}{false}true]"="false"}const]
 if ( ( %S |S ) %!= 'chg' AND 
   ( ( %S |S ) %!= 'oneway,chg'  ) AND 
   ( ( %S |S ) %!= 'static'  ) AND 
   ( ( %P %?f IsUtilityPack %( )% ) %!=  true  ) AND 
   ( ( %P |M ) %!= 'ServerInterface::Class'  ) AND 
   ( ( %P |M ) %!= 'ServerFacet::Class'  ) AND 
   ( if ( ( %P |S ) %== 'TemplateFunctions' AND 
    ( ( %P ->P %?f IsUtilityPack %( )%  ) %==  true  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
  %== false  ) ) then
 begin
  'const' 
 end // if
//#UC END# *4714DB4301E4*
; // op_const_spec


// генерация операции серванта
//f _servant_cpp_operation_h
: servant_cpp_operation_h OBJECT IN %S
//#UC START# *4714DB580261*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	][{%PS=TemplateFunctions}#%f_templ_header(%P)]\
 end // if
 NOP
 if ( ( %P |S ) %== 'TemplateFunctions' ) then
 begin
  out_indent [%f] templ_header %( %P )% 
 end // if
//	%f_servant_cpp_operation_h_i(%S)[
 [%f] servant_cpp_operation_h_i %( %S )% if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4714DB580261*
; // servant_cpp_operation_h


// генерация операции серванта
//f _servant_cpp_operation_cpp_i
: servant_cpp_operation_cpp_i OBJECT IN %S
//#UC START# *4714DB66035B*
//	%f_set_var(SERVANT_OPERATION,"%f_ret(%S) %f_function_scope(%{SERV})%SN[{%PS!=ServerInterface&%PS!=ServerFacet}[{%SS=oneway|%SS=oneway,chg}_]] (<{, }%f_arg_full_decl(%C)>)[{%SS!=chg&%SS!=oneway,chg&%SS!=static&%P#f_IsUtilityPack()!=true&%PM!=ServerInterface::Class&%PM!=ServerFacet::Class&"[{%PS=TemplateFunctions&%P%P#f_IsUtilityPack()=true}{false}true]"="false"} const] [{%f_realize_srv_interface(%S)=false}{throw (CORBA::SystemException<, %E<%NN::>%EN>) }[/*throw (<{, }%E<%NN::>%EN>)*/ ]]")\
 [%f] set_var %( 'SERVANT_OPERATION' %, [%f] ret %( %S )% ' '
 [%f] function_scope %( ( get_global_var ( 'SERV' ) ) )% %S |N if ( ( %P |S ) %!= 'ServerInterface' AND 
   ( ( %P |S ) %!= 'ServerFacet'  ) ) then
 begin
  if ( ( %S |S ) %== 'oneway' OR 
    ( ( %S |S ) %== 'oneway,chg'  ) ) then
  begin
   '_' 
  end // if
 end // if
 ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ')'
 if ( ( %S |S ) %!= 'chg' AND 
   ( ( %S |S ) %!= 'oneway,chg'  ) AND 
   ( ( %S |S ) %!= 'static'  ) AND 
   ( ( %P %?f IsUtilityPack %( )% ) %!=  true  ) AND 
   ( ( %P |M ) %!= 'ServerInterface::Class'  ) AND 
   ( ( %P |M ) %!= 'ServerFacet::Class'  ) AND 
   ( if ( ( %P |S ) %== 'TemplateFunctions' AND 
    ( ( %P ->P %?f IsUtilityPack %( )%  ) %==  true  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
  %== false  ) ) then
 begin
  ' const' 
 end // if
 ' '
 if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
 begin
  if NOT-EMPTY
  begin
   '/*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %E
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%N
      begin
       OBJECT IN %N
       if true then
       begin
        %N |N '::' 
        ++! l_Counter
       end // if
      end // for N

     ) // bind
      %E |N 
     ++! l_Counter
    end // if
   end // for E
   ')*/ ' 
  end // if
  NOP
 end // if
 else
 begin
  'throw (CORBA::SystemException'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    %E
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%N
     begin
      OBJECT IN %N
      if true then
      begin
       %N |N '::' 
       ++! l_Counter
      end // if
     end // for N

    ) // bind
     %E |N 
    ++! l_Counter
   end // if
  end // for E
  ') ' 
 end // else
)% //	%f_set_var(OP_LEN,"%f_string_length("%{SERVANT_OPERATION}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'SERVANT_OPERATION' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{SERVANT_OPERATION}N}%f_ret(%S) %f_function_scope(%{SERV})%SN[{%PS!=ServerInterface&%PS!=ServerFacet}[{%SS=oneway|%SS=oneway,chg}_]] (\n\t<{\n\t, }%f_arg_full_decl(%C)>\n)[{%SS!=chg&%SS!=oneway,chg&%SS!=static&%P#f_IsUtilityPack()!=true&%PM!=ServerInterface::Class&%PM!=ServerFacet::Class&"[{%PS=TemplateFunctions&%P%P#f_IsUtilityPack()=true}{false}true]"="false"} const] [{%f_realize_srv_interface(%S)=false}{throw (\n\tCORBA::SystemException<\n\t, %E<%NN::>%EN>\n) }[/*throw (\n\t<{\n\t, }%E<%NN::>%EN>\n)*/ ]]]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  [%f] ret %( %S )% ' '
  [%f] function_scope %( ( get_global_var ( 'SERV' ) ) )% %S |N if ( ( %P |S ) %!= 'ServerInterface' AND 
    ( ( %P |S ) %!= 'ServerFacet'  ) ) then
  begin
   if ( ( %S |S ) %== 'oneway' OR 
     ( ( %S |S ) %== 'oneway,chg'  ) ) then
   begin
    '_' 
   end // if
  end // if
  ' ('#13#10#9
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( #13#10#9', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  #13#10')'
  if ( ( %S |S ) %!= 'chg' AND 
    ( ( %S |S ) %!= 'oneway,chg'  ) AND 
    ( ( %S |S ) %!= 'static'  ) AND 
    ( ( %P %?f IsUtilityPack %( )% ) %!=  true  ) AND 
    ( ( %P |M ) %!= 'ServerInterface::Class'  ) AND 
    ( ( %P |M ) %!= 'ServerFacet::Class'  ) AND 
    ( if ( ( %P |S ) %== 'TemplateFunctions' AND 
     ( ( %P ->P %?f IsUtilityPack %( )%  ) %==  true  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %== false  ) ) then
  begin
   ' const' 
  end // if
  ' '
  if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    '/*throw ('#13#10#9
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      if ( l_Counter >0 ) then ( #13#10#9', ' )
      %E
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %E |N 
      ++! l_Counter
     end // if
    end // for E
    #13#10')*/ ' 
   end // if
   NOP
  end // if
  else
  begin
   'throw ('#13#10#9'CORBA::SystemException'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     #13#10#9', '
     %E
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%N
      begin
       OBJECT IN %N
       if true then
       begin
        %N |N '::' 
        ++! l_Counter
       end // if
      end // for N

     ) // bind
      %E |N 
     ++! l_Counter
    end // if
   end // for E
   #13#10') ' 
  end // else
 end // if
 else
 begin
  ( get_global_var ( 'SERVANT_OPERATION' ) |N ) 
 end // else
//#UC END# *4714DB66035B*
; // servant_cpp_operation_cpp_i


// генерация операции серванта
//f _servant_cpp_operation_cpp
: servant_cpp_operation_cpp OBJECT IN %S
//#UC START# *4714DB750119*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	]%f_templ_header(%{SERV})\
 end // if
 NOP
 [%f] templ_header %( ( get_global_var ( 'SERV' ) ) )% 
//	[{%PS=TemplateFunctions}%f_templ_header(%P)]\
 if ( ( %P |S ) %== 'TemplateFunctions' ) then
 begin
  [%f] templ_header %( %P )% 
 end // if
//	%f_servant_cpp_operation_cpp_i(%S){%f_start_func_cpp(%S,"%{SERV}N::%SN")
 [%f] servant_cpp_operation_cpp_i %( %S )% '{'
 [%f] start_func_cpp %( %S %, ( get_global_var ( 'SERV' ) |N ) '::'
 %S |N )% 
//		%f_s_c_op_c_uc(%S)
 '	'
 [%f] s_c_op_c_uc %( %S )% 
//	%f_end_func_cpp(%S)}[
 [%f] end_func_cpp %( %S )% '}'
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4714DB750119*
; // servant_cpp_operation_cpp


// Возвращает true если роделем является ServerInterface или ServerFacet.
//f _realize_srv_interface
: realize_srv_interface OBJECT IN %S
//#UC START# *4714DB8F036B*
//	[{%PM=ServerFacet::Class|%PM=ServerInterface::Class}{false}true]
 if ( ( %P |M ) %== 'ServerFacet::Class' OR 
   ( ( %P |M ) %== 'ServerInterface::Class'  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714DB8F036B*
; // realize_srv_interface


// генерация юзер-секции для операции
//f _s_c_op_c_uc
: s_c_op_c_uc OBJECT IN %S
//#UC START# *4714DC090261*
//	%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U]!cpp!}
 %Usersection (
  if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
  begin
   '_'
   ( get_global_var ( 'SERV' ) |U ) 
  end // if
  '!cpp!' 
 )
 (
  #13#10

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
  '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]
  '	' 
 ) // Usersection
 //#UC END# *4714DC090261*
; // s_c_op_c_uc


// выводит необходимый scope для метода
//f _function_scope
: function_scope OBJECT IN %S
//#UC START# *4714DC1E032C*
//	[{%S#f_IsUtilityPack()!=true}<{}{%t_nested_scope_def(%P)=true}{r}%PN::>%SN%f_templ_footer(%S)::]
 if ( ( %S %?f IsUtilityPack %( )% ) %!=  true ) then
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for downto %S%P
  begin
   OBJECT IN %P
   if ( ( [%t] nested_scope_def %( %P )% ) %==  true ) then
   begin
    %P |N '::' 
    ++! l_Counter
   end // if
  end // for P
  %S |N [%f] templ_footer %( %S )% '::' 
 end // if
//#UC END# *4714DC1E032C*
; // function_scope


// выводит заголовок шаблона
//f _templ_header
: templ_header OBJECT IN %S
//#UC START# *4714DC2802FD*
//	[{"%SK"="ParameterizedClass"}template \<<{, }{"%CC"="Parameter"}%CX>\>
 if ( ( %S |K ) %== 'ParameterizedClass' ) then
 begin
  'template <'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Parameter' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |X 
    ++! l_Counter
   end // if
  end // for C
  '>'
//	]
 end // if
//#UC END# *4714DC2802FD*
; // templ_header


// выводит специализацию шаблона
//f _templ_footer
: templ_footer OBJECT IN %S
//#UC START# *4714DC92001F*
//	[{"%SK"="ParameterizedClass"}\<<{, }{"%CC"="Parameter"}%CN>\>]
 if ( ( %S |K ) %== 'ParameterizedClass' ) then
 begin
  '<'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Parameter' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  '>' 
 end // if
//#UC END# *4714DC92001F*
; // templ_footer


// генерация кэшированного атрибута
//f _cached_servant_attribute_h
: cached_servant_attribute_h OBJECT IN %S
//#UC START# *4714DCC70203*
//	// cached attribute impl
 '// cached attribute impl'
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#%f_attr(%S) get_%SN_ (); // return cached value		
 out_indent [%f] attr %( %S )% ' get_'
 %S |N '_ (); // return cached value		'
//	#void invalidate_%SN_ (); // invalidate cached value
 out_indent 'void invalidate_'
 %S |N '_ (); // invalidate cached value'
//	#%f_attr(%S) load_%SN_ (); // load value into cache (callback)
 out_indent [%f] attr %( %S )% ' load_'
 %S |N '_ (); // load value into cache (callback)'
//#UC END# *4714DCC70203*
; // cached_servant_attribute_h


// генерация кэшированного атрибута
//f _cached_servant_attribute_cpp
: cached_servant_attribute_cpp OBJECT IN %S
//#UC START# *4714DD390000*
//	// cached attribute impl
 '// cached attribute impl'
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	%f_attr(%S) %PN::get_%SN_ () {
 [%f] attr %( %S )% ' '
 %P |N '::get_'
 %S |N '_ () {'
//		return s_cache.get_%SN (this);
 '	return s_cache.get_'
 %S |N ' (this);'
//	}
 '}'
//	
//	void %PN::invalidate_%SN_ () {
 'void '
 %P |N '::invalidate_'
 %S |N '_ () {'
//		s_cache.invalidate_%SN (this);
 '	s_cache.invalidate_'
 %S |N ' (this);'
//	}
 '}'
//	
//	%f_attr(%S) %PN::load_%SN_ () {
 [%f] attr %( %S )% ' '
 %P |N '::load_'
 %S |N '_ () {'
//		%U[
 '	'
 %Usersection (

 )
 (
  #13#10

//		]
  '	' 
 ) // Usersection
 //	}
 '}'
//#UC END# *4714DD390000*
; // cached_servant_attribute_cpp


// генерация деструктора
//f _servant_cpp_destructor_cpp
: servant_cpp_destructor_cpp OBJECT IN %S
//#UC START# *4714DD52035B*
//	%f_templ_header(%S)%f_function_scope(%S)~%SN () {%f_start_func_cpp(%S,"%SN::~%SN")
 [%f] templ_header %( %S )% [%f] function_scope %( %S )% '~'
 %S |N ' () {'
 [%f] start_func_cpp %( %S %, %S |N '::~'
 %S |N )% 
//		%U[{_DESTR_BODY!cpp!}
 '	'
 %Usersection (
  '_DESTR_BODY!cpp!' 
 )
 (
  #13#10

//		]
  '	' 
 ) // Usersection
 //	%f_end_func_cpp(%S)}
 [%f] end_func_cpp %( %S )% '}'
//#UC END# *4714DD52035B*
; // servant_cpp_destructor_cpp


// регистрация всех фабрик серванта
//f _reg_all_factories
: reg_all_factories OBJECT IN %S
//#UC START# *4714DD640177*
//	%f_set_var(SELF,S)void register_all_factories () {
 [%f] set_var %( 'SELF' %, 'S' )% 'void register_all_factories () {'
//	#	%U[{_ENVIRONMENTS_CONFIG}
 out_indent '	'
 %Usersection (
  '_ENVIRONMENTS_CONFIG' 
 )
 (
  #13#10

//	#	]
  out_indent '	' 
 ) // Usersection
 //	<{}{"%AM"="Servant::Class"&"%f_has_factory_methods(%A)"="true"&"%A{Factory auto reg}"="true"}
 INTEGER VAR l_Counter l_Counter := 0
 for %S%A
 begin
  OBJECT IN %A
  if ( ( %A |M ) %== 'Servant::Class' AND 
   ( ( [%f] has_factory_methods %( %A )% ) %== true  ) AND 
   ( ( %A get_up ( 'Factory auto reg' ) ) %== true  ) ) then
  begin
   #13#10

//	#	{
   out_indent '	{'
//	#		[{"%S{is namespace}"="true"}%SN::]%f_type(%A)_factory_var fctr = new [{"%S{is namespace}"="true"}%SN::]%f_type(%A)_factory ();
   out_indent '		'
   if ( ( %S get_up ( 'is namespace' ) ) %== true ) then
   begin
    %S |N '::' 
   end // if
   [%f] type %( %A )% '_factory_var fctr = new '
   if ( ( %S get_up ( 'is namespace' ) ) %== true ) then
   begin
    %S |N '::' 
   end // if
   [%f] type %( %A )% '_factory ();'
//	#		fctr-\>registrate_me([{}{0}%A{factory priority}]);
   out_indent '		fctr->registrate_me('
   if NOT-EMPTY
   begin
    %A get_up ( 'factory priority' ) 
   end // if
   NOP
   else
   begin
    0 
   end // else
   ');'
//	#	}
   out_indent '	}'
//	#	><%d<{}{"%AM"="Servant::Class"&"%f_has_factory_methods(%A)"="true"&"%A{Factory auto reg}"="true"}
   out_indent '	' 
   ++! l_Counter
  end // if
 end // for A
 INTEGER VAR l_Counter l_Counter := 0
 for %S%d
 begin
  OBJECT IN %d
  if true then
  begin
   %d
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%A
    begin
     OBJECT IN %A
     if ( ( %A |M ) %== 'Servant::Class' AND 
      ( ( [%f] has_factory_methods %( %A )% ) %== true  ) AND 
      ( ( %A get_up ( 'Factory auto reg' ) ) %== true  ) ) then
     begin
      #13#10

//	#	{
      out_indent '	{'
//	#		%f_type(%A)_factory_var fctr = new %f_type(%A)_factory ();
      out_indent '		'
      [%f] type %( %A )% '_factory_var fctr = new '
      [%f] type %( %A )% '_factory ();'
//	#		fctr-\>registrate_me([{}{0}%A{factory priority}]);
      out_indent '		fctr->registrate_me('
      if NOT-EMPTY
      begin
       %A get_up ( 'factory priority' ) 
      end // if
      NOP
      else
      begin
       0 
      end // else
      ');'
//	#	}
      out_indent '	}'
//	#	>>
      out_indent '	' 
      ++! l_Counter
     end // if
    end // for A

   ) // bind
 
   ++! l_Counter
  end // if
 end // for d
//	#	%U[{_CUSTOM_REGISTRATE}
 out_indent '	'
 %Usersection (
  '_CUSTOM_REGISTRATE' 
 )
 (
  #13#10

//	#	]
  out_indent '	' 
 ) // Usersection
 //	#}
 out_indent '}'
//#UC END# *4714DD640177*
; // reg_all_factories


// генерит форвард декларацию для типов, используемых как функтор
//f _dump_cpp_functors_h_fd
: dump_cpp_functors_h_fd OBJECT IN %S
//#UC START# *4714DD8B0242*
//	<{}{%f_used_as_compare_func(%s)=true}{%s}%f_set_compare_key_type(%s)[{"%{COMP_KEY}%TM"!="UMLPrimitive::Class"}#[{"%{COMP_KEY}%TM"="Struct::Class"}{class}struct] %f_type(%{COMP_KEY}%T);
 INTEGER VAR l_Counter l_Counter := 0
 for %S%s
 begin
  OBJECT IN %s
  if ( ( [%f] used_as_compare_func %( %s )% ) %==  true ) then
  begin
   [%f] set_compare_key_type %( %s )% if ( ( ( get_global_var ( 'COMP_KEY' )  ->T |M ) ) %!= 'UMLPrimitive::Class' ) then
   begin
    out_indent if ( ( ( get_global_var ( 'COMP_KEY' )  ->T |M ) ) %== 'Struct::Class' ) then
    begin
     'struct' 
    end // if
    else
    begin
     'class' 
    end // else
    ' '
    [%f] type %( ( get_global_var ( 'COMP_KEY' )  ->T ) )% ';'
//	]><{}{%f_used_as_hash_func(%s)=true}{%s}%f_set_hash_key_type(%s)[{"%t_simple(%{COMP_KEY}%T)"="false"}#[{"%{COMP_KEY}%TM"="Struct::Class"}{class}struct] %f_type(%{COMP_KEY}%T);
   end // if

   ++! l_Counter
  end // if
 end // for s
 INTEGER VAR l_Counter l_Counter := 0
 for %S%s
 begin
  OBJECT IN %s
  if ( ( [%f] used_as_hash_func %( %s )% ) %==  true ) then
  begin
   [%f] set_hash_key_type %( %s )% if ( ( [%t] simple %( ( get_global_var ( 'COMP_KEY' )  ->T ) )% ) %== false ) then
   begin
    out_indent if ( ( ( get_global_var ( 'COMP_KEY' )  ->T |M ) ) %== 'Struct::Class' ) then
    begin
     'struct' 
    end // if
    else
    begin
     'class' 
    end // else
    ' '
    [%f] type %( ( get_global_var ( 'COMP_KEY' )  ->T ) )% ';'
//	]>
   end // if

   ++! l_Counter
  end // if
 end // for s
//#UC END# *4714DD8B0242*
; // dump_cpp_functors_h_fd


// какие-то манипуляции с глобальными переменными
//f _reset_unic
: reset_unic OBJECT IN %S
//#UC START# *4714DD920399*
//	%f_set_var(_SAVED_COMP_KEY,M)%f_set_var(_SAVED_S,M)
 [%f] set_var %( '_SAVED_COMP_KEY' %, 'M' )% [%f] set_var %( '_SAVED_S' %, 'M' )% 
//#UC END# *4714DD920399*
; // reset_unic


// какие-то манипуляции с глобальными переменными
//f _test_unic
: test_unic OBJECT IN %S
//#UC START# *4714DD9E000F*
//	[{"%{COMP_KEY}%TU"="%{_SAVED_COMP_KEY}%TU"&%{COMP_KEY}l=%{_SAVED_COMP_KEY}l&"%SU"="%{_SAVED_S}U"}{true%f_set_var(_SAVED_COMP_KEY,{COMP_KEY})%f_set_var(_SAVED_S,S)}false]
 if ( ( ( get_global_var ( 'COMP_KEY' )  ->T |U ) ) %== ( ( get_global_var ( '_SAVED_COMP_KEY' )  ->T |U ) ) AND 
   ( ( ( get_global_var ( 'COMP_KEY' ) |l ) ) %== ( ( get_global_var ( '_SAVED_COMP_KEY' ) |l ) )  ) AND 
   ( ( %S |U ) %== ( ( get_global_var ( '_SAVED_S' ) |U ) )  ) ) then
 begin
   false 
 end // if
 else
 begin
   true [%f] set_var %( '_SAVED_COMP_KEY' %, '{COMP_KEY}' )% [%f] set_var %( '_SAVED_S' %, 'S' )% 
 end // else
//#UC END# *4714DD9E000F*
; // test_unic


// какие-то манипуляции с глобальными переменными
//f _test_unic_dbg
: test_unic_dbg OBJECT IN %S
//#UC START# *4714DDA60290*
//	%{COMP_KEY}%TN = %{_SAVED_COMP_KEY}%TN & %SN = %{_SAVED_S}N
 ( get_global_var ( 'COMP_KEY' )  ->T |N ) ' = '
 ( get_global_var ( '_SAVED_COMP_KEY' )  ->T |N ) ' & '
 %S |N ' = '
 ( get_global_var ( '_SAVED_S' ) |N ) 
//#UC END# *4714DDA60290*
; // test_unic_dbg


// выводит аргументы функтора сравнения
//f _comp_funct_arg
: comp_funct_arg OBJECT IN %S
//#UC START# *4714DDAD001F*
//	[{%TN!=c-string}{%t_attr(%T,"%Sl-const",%S)[{%Sl!=lnk}&]}[{%f_is_not_fixed_simple(%T)=true&%Sl!=ref}{const %f_with_gen_id(h,%f_attr(%S))[{%Sl!=lnk}&]}[{%Sl=agr}{%f_with_gen_id(h,%f_attr(%S)) const}[{%Ss!=const}const ]%f_with_gen_id(h,%f_attr(%S))]]]
 if ( ( %T |N ) %!= 'c-string' ) then
 begin
  if ( ( [%f] is_not_fixed_simple %( %T )% ) %==  true AND 
    ( ( %S |l ) %!= 'ref'  ) ) then
  begin
   if ( ( %S |l ) %== 'agr' ) then
   begin
    if ( ( %S |s ) %!= 'const' ) then
    begin
     'const ' 
    end // if
    [%f] with_gen_id %( 'h' %, [%f] attr %( %S )% )% 
   end // if
   else
   begin
    [%f] with_gen_id %( 'h' %, [%f] attr %( %S )% )% ' const' 
   end // else
  end // if
  else
  begin
   'const '
   [%f] with_gen_id %( 'h' %, [%f] attr %( %S )% )% if ( ( %S |l ) %!= 'lnk' ) then
   begin
    '&' 
   end // if
  end // else
 end // if
 else
 begin
  [%t] attr %( %T %, %S |l '-const"' %, %S )% if ( ( %S |l ) %!= 'lnk' ) then
  begin
   '&' 
  end // if
 end // else
//#UC END# *4714DDAD001F*
; // comp_funct_arg


// генерация функтора
//f _dump_cpp_functors_h
: dump_cpp_functors_h OBJECT IN %S
//#UC START# *4714DDB4035B*
//	<{}{%f_used_as_compare_func(%s)=true}{%s}%f_set_compare_key_type(%s)\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%s
 begin
  OBJECT IN %s
  if ( ( [%f] used_as_compare_func %( %s )% ) %==  true ) then
  begin
   [%f] set_compare_key_type %( %s )% 
//	[{%f_test_unic(%S)=true}#	bool operator () (%f_comp_funct_arg(%{COMP_KEY}) x, %f_comp_funct_arg(%{COMP_KEY}) y) const;
   if ( ( [%f] test_unic %( %S )% ) %==  true ) then
   begin
    out_indent '	bool operator () ('
    [%f] comp_funct_arg %( ( get_global_var ( 'COMP_KEY' ) ) )% ' x, '
    [%f] comp_funct_arg %( ( get_global_var ( 'COMP_KEY' ) ) )% ' y) const;'
//	
    #13#10

//	]>%f_reset_unic(%S)<{}{%f_used_as_hash_func(%s)=true}{%s}%f_set_hash_key_type(%s)[{%f_test_unic(%S)=true}#	size_t operator () (%f_comp_funct_arg(%{COMP_KEY}) x) const;
   end // if

   ++! l_Counter
  end // if
 end // for s
 [%f] reset_unic %( %S )% 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%s
 begin
  OBJECT IN %s
  if ( ( [%f] used_as_hash_func %( %s )% ) %==  true ) then
  begin
   [%f] set_hash_key_type %( %s )% if ( ( [%f] test_unic %( %S )% ) %==  true ) then
   begin
    out_indent '	size_t operator () ('
    [%f] comp_funct_arg %( ( get_global_var ( 'COMP_KEY' ) ) )% ' x) const;'
//	
    #13#10

//	]>%f_reset_unic(%S)<{}{%f_used_as_deallocator_func(%s)=true}{%s}#	static void destroy (%f_type(%s%P%G)* content) {
   end // if

   ++! l_Counter
  end // if
 end // for s
 [%f] reset_unic %( %S )% 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%s
 begin
  OBJECT IN %s
  if ( ( [%f] used_as_deallocator_func %( %s )% ) %==  true ) then
  begin
   out_indent '	static void destroy ('
   [%f] type %( %s ->P ->G   )% '* content) {'
//	#		%U[
   out_indent '		'
   %Usersection (

   )
   (
    #13#10

//	#		throw Core::Root::MDAGenNotImplemented (GDS_CURRENT_FUNCTION);
    out_indent '		throw Core::Root::MDAGenNotImplemented (GDS_CURRENT_FUNCTION);'
//	#		]
    out_indent '		' 
   ) // Usersection
 //	#	}
   out_indent '	}'
//	
   #13#10

//	>[{%f_need_less_func(%S)=true}#	bool operator \< (const %SN& y) const;

   ++! l_Counter
  end // if
 end // for s
 if ( ( [%f] need_less_func %( %S )% ) %==  true ) then
 begin
  out_indent '	bool operator < (const '
  %S |N '& y) const;'
//	]
 end // if
//#UC END# *4714DDB4035B*
; // dump_cpp_functors_h


// генерация функтора
//f _dump_cpp_functors_cpp
: dump_cpp_functors_cpp OBJECT IN %S
//#UC START# *4714DDC60167*
//	<{}{%f_used_as_compare_func(%s)=true}{%s}%f_set_compare_key_type(%s)\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%s
 begin
  OBJECT IN %s
  if ( ( [%f] used_as_compare_func %( %s )% ) %==  true ) then
  begin
   [%f] set_compare_key_type %( %s )% 
//	[{%f_test_unic(%S)=true}%f_templ_header(%S)bool %f_function_scope(%S)operator () (%f_comp_funct_arg(%{COMP_KEY}) x, %f_comp_funct_arg(%{COMP_KEY}) y) const {
   if ( ( [%f] test_unic %( %S )% ) %==  true ) then
   begin
    [%f] templ_header %( %S )% 'bool '
    [%f] function_scope %( %S )% 'operator () ('
    [%f] comp_funct_arg %( ( get_global_var ( 'COMP_KEY' ) ) )% ' x, '
    [%f] comp_funct_arg %( ( get_global_var ( 'COMP_KEY' ) ) )% ' y) const {'
//		%U[{_%{COMP_KEY}U_COMP}
    '	'
    %Usersection (
     '_'
     ( get_global_var ( 'COMP_KEY' ) |U ) '_COMP' 
    )
    (
     #13#10

//		throw Core::Root::MDAGenNotImplemented (GDS_CURRENT_FUNCTION);
     '	throw Core::Root::MDAGenNotImplemented (GDS_CURRENT_FUNCTION);'
//		]
     '	' 
    ) // Usersection
 //	}
    '}'
//	
    #13#10

//	]>%f_reset_unic(%S)<{}{%f_used_as_hash_func(%s)=true}{%s}%f_set_hash_key_type(%s)\
   end // if

   ++! l_Counter
  end // if
 end // for s
 [%f] reset_unic %( %S )% 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%s
 begin
  OBJECT IN %s
  if ( ( [%f] used_as_hash_func %( %s )% ) %==  true ) then
  begin
   [%f] set_hash_key_type %( %s )% 
//	[{%f_test_unic(%S)=true}%f_templ_header(%S)size_t %f_function_scope(%S)operator () (%f_comp_funct_arg(%{COMP_KEY}) x) const {
   if ( ( [%f] test_unic %( %S )% ) %==  true ) then
   begin
    [%f] templ_header %( %S )% 'size_t '
    [%f] function_scope %( %S )% 'operator () ('
    [%f] comp_funct_arg %( ( get_global_var ( 'COMP_KEY' ) ) )% ' x) const {'
//		%U[{_%{COMP_KEY}U_HASH}
    '	'
    %Usersection (
     '_'
     ( get_global_var ( 'COMP_KEY' ) |U ) '_HASH' 
    )
    (
     #13#10

//		throw Core::Root::MDAGenNotImplemented (GDS_CURRENT_FUNCTION);
     '	throw Core::Root::MDAGenNotImplemented (GDS_CURRENT_FUNCTION);'
//		]
     '	' 
    ) // Usersection
 //	}
    '}'
//	
    #13#10

//	]>%f_reset_unic(%S)[{%f_need_less_func(%S)=true}%f_templ_header(%S)bool %f_function_scope(%S)operator \< (const %SN& y) const {
   end // if

   ++! l_Counter
  end // if
 end // for s
 [%f] reset_unic %( %S )% if ( ( [%f] need_less_func %( %S )% ) %==  true ) then
 begin
  [%f] templ_header %( %S )% 'bool '
  [%f] function_scope %( %S )% 'operator < (const '
  %S |N '& y) const {'
//		%U[{_LESS}
  '	'
  %Usersection (
   '_LESS' 
  )
  (
   #13#10

//		throw Core::Root::MDAGenNotImplemented (GDS_CURRENT_FUNCTION);
   '	throw Core::Root::MDAGenNotImplemented (GDS_CURRENT_FUNCTION);'
//		]
   '	' 
  ) // Usersection
 //	}
  '}'
//	
  #13#10

//	]
 end // if
//#UC END# *4714DDC60167*
; // dump_cpp_functors_cpp


// записывает в переменную COMP_KEY атрибут-ключ для ассоциативных контэйнеров
//f _set_compare_key_type
: set_compare_key_type OBJECT IN %S
//#UC START# *4714DDE50196*
//	[{%f_kind_of(P,Map::Class)=true}%P<{}{%C%Cx=true}%C[%f_set_var(COMP_KEY,C)]>]\
 if ( ( [%f] kind_of %( 'P' %, 'Map::Class' )% ) %==  true ) then
 begin
  %P
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C ->C |x  ) %==  true ) then
    begin
     %C
     bind ( 
      OBJECT VAR %S
      if NOT-EMPTY
      begin
       [%f] set_var %( 'COMP_KEY' %, 'C' )% 
      end // if
      NOP

     ) // bind
 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
  end // if
//	[{%f_kind_of(P,Set::Class)=true}%P<{}{"%CS"=""}{%C}%f_set_var(COMP_KEY,C)>]
 if ( ( [%f] kind_of %( 'P' %, 'Set::Class' )% ) %==  true ) then
 begin
  %P
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== '' ) then
    begin
     [%f] set_var %( 'COMP_KEY' %, 'C' )% 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
  end // if
//#UC END# *4714DDE50196*
; // set_compare_key_type


// записывает в переменную COMP_KEY атрибут, используемых в качестве хэш-ключа
//f _set_hash_key_type
: set_hash_key_type OBJECT IN %S
//#UC START# *4714DDEC000F*
//	[{%f_kind_of(P,UnsortedSet::Class)=true|%f_kind_of(P,UnsortedMap::Class)=true}%P<{}{%C%Cx=true}%C[%f_set_var(COMP_KEY,C)]>]
 if ( ( [%f] kind_of %( 'P' %, 'UnsortedSet::Class' )% ) %==  true OR 
   ( ( [%f] kind_of %( 'P' %, 'UnsortedMap::Class' )% ) %==  true  ) ) then
 begin
  %P
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C ->C |x  ) %==  true ) then
    begin
     %C
     bind ( 
      OBJECT VAR %S
      if NOT-EMPTY
      begin
       [%f] set_var %( 'COMP_KEY' %, 'C' )% 
      end // if
      NOP

     ) // bind
 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
  end // if
//#UC END# *4714DDEC000F*
; // set_hash_key_type


// возвращает true если элемент используется как фукнтор сравнения
//f _used_as_compare_func
: used_as_compare_func OBJECT IN %S
//#UC START# *4714DDFC029F*
//	[{%SS=compare}{false}true]
 if ( ( %S |S ) %== 'compare' ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714DDFC029F*
; // used_as_compare_func


// возвращает true если элемент используется как хэш-функция
//f _used_as_hash_func
: used_as_hash_func OBJECT IN %S
//#UC START# *4714DE0B006D*
//	[{%SS=hasher}{false}true]
 if ( ( %S |S ) %== 'hasher' ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714DE0B006D*
; // used_as_hash_func


// возвращает true если элемент используется как деаллокатор
//f _used_as_deallocator_func
: used_as_deallocator_func OBJECT IN %S
//#UC START# *4714DE1202BF*
//	[{%SS=deallocator}{false}true]
 if ( ( %S |S ) %== 'deallocator' ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714DE1202BF*
; // used_as_deallocator_func


// возвращае true, сли нужен оператор "меньше"
//f _need_less_func
: need_less_func OBJECT IN %S
//#UC START# *4714DE1A030D*
//	[{"<{}{%f_need_less_func_for_(%s,%S)=true}{%sC}>"="0"}{true}false]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%s
  begin
   OBJECT IN %s
   if ( ( [%f] need_less_func_for_ %( %s %, %S )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for s
  l_Counter
  %== 0 ) then
 begin
   false 
 end // if
 else
 begin
   true 
 end // else
//#UC END# *4714DE1A030D*
; // need_less_func


// нужно
//f _need_less_func_for_
: need_less_func_for_ OBJECT IN %S
//#UC START# *4714DE3301F4*
//	[{%f_kind_of(P,Set::Class)=true}{%f_need_less_func_for_map(%S,%1)}%P[{"<{}{%CS=compare}{C}>"="0"&"<{}{"%CS"=""&"%Cl"="agr"&"%CU"="%1U"}{C}>"="1"}{false}true]]
 if ( ( [%f] kind_of %( 'P' %, 'Set::Class' )% ) %==  true ) then
 begin
  %P
  bind ( 
   OBJECT VAR %S
   if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %== 'compare' ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %== 0 AND 
     ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %== '' AND 
      ( ( %C |l ) %== 'agr'  ) AND 
      ( ( %C |U ) %== ( %1 |U )  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %== 1  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else

  ) // bind
  end // if
 else
 begin
  [%f] need_less_func_for_map %( %S %, %1 )% 
 end // else
//#UC END# *4714DE3301F4*
; // need_less_func_for_


// возвращае true, сли нужен оператор "меньше"
//f _need_less_func_for_map
: need_less_func_for_map OBJECT IN %S
//#UC START# *4714DE6803C8*
//	%P[{%f_kind_of(P,Map::Class)=true}{false}%P[{"<{}{%CS=compare}{C}>"="0"&"<{}{"%C%Cx"="true"&"%C%Cl"="agr"&"%C%C%TU"="%3U"}{%CC}>"="1"}{false}true]]
 %P
 bind ( 
  OBJECT VAR %S
  if ( ( [%f] kind_of %( 'P' %, 'Map::Class' )% ) %==  true ) then
  begin
   %P
   bind ( 
    OBJECT VAR %S
    if ( 
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'compare' ) then
      begin

       ++! l_Counter
      end // if
     end // for C
     l_Counter
     %== 0 AND 
      ( 
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C ->C |x  ) %== true AND 
       ( ( %C ->C |l  ) %== 'agr'  ) AND 
       ( ( %C ->C ->T |U   ) %== ( %3 |U )  ) ) then
      begin

       ++! l_Counter
      end // if
     end // for C
     l_Counter
     %== 1  ) ) then
    begin
      true 
    end // if
    else
    begin
      false 
    end // else

   ) // bind
   end // if
  else
  begin
    false 
  end // else

 ) // bind
 //#UC END# *4714DE6803C8*
; // need_less_func_for_map


// возвращает true, если элемент или его родители являются "стандартными"
//f _is_standart
: is_standart OBJECT IN %S
//#UC START# *4714DE8D01E4*
//	[{"<{}{%P{is standart}=true}{%PC}>"!="0"}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P get_up ( 'is standart' ) ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for P
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714DE8D01E4*
; // is_standart


// выводит путь для include
//f _dump_include_path
: dump_include_path OBJECT IN %S
//#UC START# *4714DED40119*
//	[{"%SN"!=""}{}[{%f_is_standart(%1)=false&%S{is standart}!=true}{\<%SN\>}"%SN"]]
 if ( ( %S |N ) %!= '' ) then
 begin
  if ( ( [%f] is_standart %( %1 )% ) %==  false AND 
    ( ( %S get_up ( 'is standart' ) ) %!=  true  ) ) then
  begin
   %S |N 
  end // if
  else
  begin
   '<'
   %S |N '>' 
  end // else
 end // if
 else
 begin
 end // else
//#UC END# *4714DED40119*
; // dump_include_path


// определяет зависит ли элемент от серверной части
//f _use_server
: use_server OBJECT IN %S
//#UC START# *4714DF01029F*
//	[{%SS!=ServerLibrary&%S{force use server}!=true}{true}[{%f_with_gen_id(h,<{}{%dS=ServerLibrary}{C}>)!=0|<{}{%dS=ServerLibrary|%S{force use server}=true}{C}>!=0}{false}true]]
 if ( ( %S |S ) %!= 'ServerLibrary' AND 
   ( ( %S get_up ( 'force use server' ) ) %!=  true  ) ) then
 begin
  if ( ( [%f] with_gen_id %( 'h' %, 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%d
   begin
    OBJECT IN %d
    if ( ( %d |S ) %== 'ServerLibrary' ) then
    begin

     ++! l_Counter
    end // if
   end // for d
   l_Counter
)% )    %!= 0 OR 
    ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%d
   begin
    OBJECT IN %d
    if ( ( %d |S ) %== 'ServerLibrary' OR 
     ( ( %S get_up ( 'force use server' ) ) %==  true  ) ) then
    begin

     ++! l_Counter
    end // if
   end // for d
   l_Counter
   %!= 0  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
 end // if
 else
 begin
   true 
 end // else

//f _use_event_service
; // use_server

: use_event_service OBJECT IN %S
//	[{%S{force use event service}!=true}{true}[{<{}{"%d<{}{%AM=ServerEvent::Class}{%A}.>"!=""}{%dC}>!=0}true]]
 if ( ( %S get_up ( 'force use event service' ) ) %!=  true ) then
 begin
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%d
   begin
    OBJECT IN %d
    if ( ( %d
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%A
     begin
      OBJECT IN %A
      if ( ( %A |M ) %== 'ServerEvent::Class' ) then
      begin
       '.' 
       ++! l_Counter
      end // if
     end // for A

    ) // bind
 )     %!= '' ) then
    begin

     ++! l_Counter
    end // if
   end // for d
   l_Counter
   %!= 0 ) then
  begin
    true 
  end // if
 end // if
 else
 begin
   true 
 end // else

//#UC END# *4714DF01029F*
; // use_event_service


// генерит include'ы в зависимости от вложенных элементов
//f _includes_by_contents
: includes_by_contents OBJECT IN %S
//#UC START# *4714DF75035B*
//	[{"<{}{"%A%TN"="tribool"}{C}>"!="0"}\#include "boost/logic/tribool.hpp"
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A ->T |N  ) %== 'tribool' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include "boost/logic/tribool.hpp"'
//	][{<{}{%AM=Function::Class}{C}>!=0}\#include "boost/function.hpp"
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'Function::Class' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include "boost/function.hpp"'
//	][{<{}{%AM=FixedArray::Class}{C}>!=0}\#include "boost/array.hpp"
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'FixedArray::Class' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include "boost/array.hpp"'
//	]\
 end // if

//	[{"<{}{"%AM"="Queue::Class"}{C}>"!="0"}\#include \<queue\>
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'Queue::Class' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include <queue>'
//	]\
 end // if

//	[{"<{}{"%AM"="Deque::Class"}{C}>"!="0"}\#include \<deque\>
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'Deque::Class' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include <deque>'
//	]\
 end // if

//	[{"<{}{"%AM"="Set::Class"}{C}>"!="0"}\#include \<set\>
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'Set::Class' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include <set>'
//	][{"<{}{"%AM"="Map::Class"|"%AM"="MultiMap::Class"}{C}>"!="0"}\#include \<map\>
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'Map::Class' OR 
    ( ( %A |M ) %== 'MultiMap::Class'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include <map>'
//	][{"<{}{"%AM"="Vector::Class"}{C}>"!="0"|<{}{%C#f_has_multi_factory()=true&%Ca!=abstract}{%CC}>!=0}\#include \<vector\>
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'Vector::Class' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f has_multi_factory %( )% ) %==  true AND 
    ( ( %C |a ) %!= 'abstract'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0  ) ) then
 begin
  '#include <vector>'
//	][{"<{}{"%AM"="List::Class"}{C}>"!="0"}\#include \<list\>
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'List::Class' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include <list>'
//	][{"%S{singleton}"="true"|"%S{Servant Pool}"="obj"}\#include "ace/Singleton.h"
 end // if
 if ( ( %S get_up ( 'singleton' ) ) %== true OR 
   ( ( %S get_up ( 'Servant Pool' ) ) %== 'obj'  ) ) then
 begin
  '#include "ace/Singleton.h"'
//	][{"%S{Servant Pool}"="mem"}\#include "shared/Core/mng/PoolMemoryManager.h"
 end // if
 if ( ( %S get_up ( 'Servant Pool' ) ) %== 'mem' ) then
 begin
  '#include "shared/Core/mng/PoolMemoryManager.h"'
//	][{"%S{Servant Pool}"="obj"}\#include "shared/Core/mng/PoolObjectManager.h"
 end // if
 if ( ( %S get_up ( 'Servant Pool' ) ) %== 'obj' ) then
 begin
  '#include "shared/Core/mng/PoolObjectManager.h"'
//	][{"<{}{"%AM"="TypeConvertor::Class"&"%A{is sorted}"="true"}{C}>"!="0"}\#include "shared/Core/data/SortedTypeConverter.h"
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'TypeConvertor::Class' AND 
    ( ( %A get_up ( 'is sorted' ) ) %== true  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include "shared/Core/data/SortedTypeConverter.h"'
//	][{"<{}{"%AM"="TypeConvertor::Class"&"%A{is sorted}"="false"}{C}>"!="0"}\#include "shared/Core/data/UnsortedTypeConverter.h"
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'TypeConvertor::Class' AND 
    ( ( %A get_up ( 'is sorted' ) ) %== false  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include "shared/Core/data/UnsortedTypeConverter.h"'
//	][{<{}{%AM=UnsortedMap::Class|%AM=UnsortedSet::Class}{C}>!=0}\#include "shared/Core/data/unsorted_containers.h"
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'UnsortedMap::Class' OR 
    ( ( %A |M ) %== 'UnsortedSet::Class'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include "shared/Core/data/unsorted_containers.h"'
//	][{<{}{%AM=Array::Class}{C}>!=0}\#include "shared/Core/data/Array.h"
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%A
  begin
   OBJECT IN %A
   if ( ( %A |M ) %== 'Array::Class' ) then
   begin

    ++! l_Counter
   end // if
  end // for A
  l_Counter
  %!= 0 ) then
 begin
  '#include "shared/Core/data/Array.h"'
//	]%f_dump_includes_by_containers(%S)
 end // if
 [%f] dump_includes_by_containers %( %S )% 

//f _dump_includes_by_containers
; // includes_by_contents

: dump_includes_by_containers OBJECT IN %S
//	%f_clear_list(CONT_DATA)%f_set_var(OWNER,S)\
 [%f] clear_list %( 'CONT_DATA' )% [%f] set_var %( 'OWNER' %, 'S' )% 
//	%f_collect_includes_by_containers(%S,"CONT_DATA")\
 [%f] collect_includes_by_containers %( %S %, 'CONT_DATA' )% 
//	[<{}{%f_is_empty(CONT_DATA)=false}{W}[%f_pop_first_to_var(CONT_DATA,FWD)\#include %f_dump_include_path(%{FWD}L,%{FWD})
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  while true
  begin
   if ( ( [%f] is_empty %( 'CONT_DATA' )% ) %==  false ) then
   begin
    if NOT-EMPTY
    begin
     [%f] pop_first_to_var %( 'CONT_DATA' %, 'FWD' )% '#include '
     [%f] dump_include_path %( ( get_global_var ( 'FWD' ) |L ) %, ( get_global_var ( 'FWD' ) ) )% 
//	]>]
    end // if
    NOP

    ++! l_Counter
   end // if
   else
    break
  end // while
 end // if
 NOP

//f _collect_includes_by_containers
; // dump_includes_by_containers

: collect_includes_by_containers OBJECT IN %S
//	%f_set_var(LIST_ID,"%1N")%f_set_var(OWNER,S)\
 [%f] set_var %( 'LIST_ID' %, %1 |N )% [%f] set_var %( 'OWNER' %, 'S' )% 
//	%f_collect_includes_by_containers_i(%S)\
 [%f] collect_includes_by_containers_i %( %S )% //	<{}{%CC=Attribute&%CS=extern}{%C}%f_collect_includes_by_containers_i(%C%T)>\

//	%f_sort_list(%{LIST_ID}N,u)%f_unique_list(%{LIST_ID}N)\
 [%f] sort_list %( ( get_global_var ( 'LIST_ID' ) |N ) %, 'u' )% [%f] unique_list %( ( get_global_var ( 'LIST_ID' ) |N ) )% 
//	%f_fill_used_elements(%S,"%{LIST_ID}N","USED")\
 [%f] fill_used_elements %( %S %, ( get_global_var ( 'LIST_ID' ) |N ) %, 'USED' )% 
//	%f_remove_range(%S,"%{LIST_ID}N","USED")
 [%f] remove_range %( %S %, ( get_global_var ( 'LIST_ID' ) |N ) %, 'USED' )% 

//f _collect_includes_by_containers_i
; // collect_includes_by_containers

: collect_includes_by_containers_i OBJECT IN %S
//	<{}{%CC=Attribute&%Cl=agr&%t_is_container(%C%T)=true}%C%T[{%SW!=%{OWNER}W&%C%TW!=%{OWNER}W&%f_need_includes_by_containers(%C)=true}%C%T[%f_set_var(TYPE,S)][{%{OWNER}<{}{%wU=%{TYPE}U}{%wC}>=0}%f_add_to_list(%{LIST_ID}N,{TYPE})]]>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Attribute' AND 
   ( ( %C |l ) %== 'agr'  ) AND 
   ( ( [%t] is_container %( %C ->T  )% ) %==  true  ) ) then
  begin
   %C ->T
   bind ( 
    OBJECT VAR %S
    if ( ( %S |W ) %!= ( ( get_global_var ( 'OWNER' ) |W ) ) AND 
      ( ( %C ->T |W  ) %!= ( ( get_global_var ( 'OWNER' ) |W ) )  ) AND 
      ( ( [%f] need_includes_by_containers %( %C )% ) %==  true  ) ) then
    begin
     %C ->T
     bind ( 
      OBJECT VAR %S
      if NOT-EMPTY
      begin
       [%f] set_var %( 'TYPE' %, 'S' )% 
      end // if
      NOP

     ) // bind
       if ( ( ( get_global_var ( 'OWNER' ) ) 
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%w
       begin
        OBJECT IN %w
        if ( ( %w |U ) %== ( ( get_global_var ( 'TYPE' ) |U ) ) ) then
        begin

         ++! l_Counter
        end // if
       end // for w
       l_Counter

      ) // bind
)       %== 0 ) then
     begin
      [%f] add_to_list %( ( get_global_var ( 'LIST_ID' ) |N ) %, '{TYPE}' )% 
     end // if
    end // if

   ) // bind
  
   ++! l_Counter
  end // if
 end // for C

//формирует список элементов, которые используются данным (как типы контейнеров) и, которые сами явно зависят от данного элемента
//f _fill_used_elements
; // collect_includes_by_containers_i

: fill_used_elements OBJECT IN %S
//	%f_set_var(OWNER,S)\
 [%f] set_var %( 'OWNER' %, 'S' )% 
//	%f_copy_list(%1N,TEMP)\
 [%f] copy_list %( %1 |N %, 'TEMP' )% 
//	%f_clear_list(%2N)\
 [%f] clear_list %( %2 |N )% 
//	<{}{%f_is_empty(TEMP)=false}{W}[%f_pop_first_to_var(TEMP,FWD)\
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'TEMP' )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( 'TEMP' %, 'FWD' )% 
//	[{%{FWD}<{}{%IL=%{OWNER}L}{%IC}>!=0}%f_add_to_list(%2N,{FWD})]]>
    if ( ( ( get_global_var ( 'FWD' ) ) 
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%I
      begin
       OBJECT IN %I
       if ( ( %I |L ) %== ( ( get_global_var ( 'OWNER' ) |L ) ) ) then
       begin

        ++! l_Counter
       end // if
      end // for I
      l_Counter

     ) // bind
)      %!= 0 ) then
    begin
     [%f] add_to_list %( %2 |N %, '{FWD}' )% 
    end // if
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while

//удаляет из исходного списка все элементы, из заданного диапазона
//f _remove_range
; // fill_used_elements

: remove_range OBJECT IN %S
//	%f_copy_list(%2N,TEMP)\
 [%f] copy_list %( %2 |N %, 'TEMP' )% 
//	<{}{%f_is_empty(TEMP)=false}{W}[%f_pop_first_to_var(TEMP,FWD)%f_remove_from_list(%1N,{FWD})]>
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'TEMP' )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( 'TEMP' %, 'FWD' )% [%f] remove_from_list %( %1 |N %, '{FWD}' )% 
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while

//f _need_includes_by_containers
; // remove_range

: need_includes_by_containers OBJECT IN %S
//	[{%TS=DataElement}{[{%Sl=agr}{false}true]}true]
 if ( ( %T |S ) %== 'DataElement' ) then
 begin
   true 
 end // if
 else
 begin
  if ( ( %S |l ) %== 'agr' ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
 end // else
//#UC END# *4714DF75035B*
; // need_includes_by_containers


// генерит include к фабрикам по связи uses
//f _include_factory_by_uses
: include_factory_by_uses OBJECT IN %S
//#UC START# *4714DF94034B*
//	[{<{}{%RK=ParameterizedClass}{C}>!=0}[// by \<\<uses\>\> dependencies
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( %R |K ) %== 'ParameterizedClass' ) then
   begin

    ++! l_Counter
   end // if
  end // for R
  l_Counter
  %!= 0 ) then
 begin
  if NOT-EMPTY
  begin
   '// by <<uses>> dependencies'
//	<{}{"%AS"="uses"&"%AC"="Dependency"}[{%A%TS=Servant|%A%TS=SrvServant}\#include %f_dump_include_path(%f_with_gen_id(fctr.h,%A%TW),%A%T)
   INTEGER VAR l_Counter l_Counter := 0
   for %S%A
   begin
    OBJECT IN %A
    if ( ( %A |S ) %== 'uses' AND 
     ( ( %A |C ) %== 'Dependency'  ) ) then
    begin
     if ( ( %A ->T |S  ) %== 'Servant' OR 
       ( ( %A ->T |S  ) %== 'SrvServant'  ) ) then
     begin
      '#include '
      [%f] dump_include_path %( [%f] with_gen_id %( 'fctr.h' %, %A ->T |W  )% %, %A ->T  )% 
//	]>]]
     end // if

     ++! l_Counter
    end // if
   end // for A
  end // if
  NOP
 end // if
//#UC END# *4714DF94034B*
; // include_factory_by_uses


// генерация incluede'а стандартного заголовка
//f _std_inc
: std_inc OBJECT IN %S
//#UC START# *4714DFD102FD*
//	[{<{}{%PN=Core}{C}>=0}\#include "[{<{}{%f_use_server(%P)=true}{C}>=0}{\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P |N ) %== 'Core' ) then
   begin

    ++! l_Counter
   end // if
  end // for P
  l_Counter
  %== 0 ) then
 begin
  '#include "'
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%P
   begin
    OBJECT IN %P
    if ( ( [%f] use_server %( %P )% ) %==  true ) then
    begin

     ++! l_Counter
    end // if
   end // for P
   l_Counter
   %== 0 ) then
  begin
   'shared/Core/sys/std_inc.h' 
  end // if
  else
  begin
//	[{%XU!=h|%PS=Impl|<{}{%PN=CoreSrv}{C}>=0}{shared/Core/sys/std_inc.h}shared/CoreSrv/sys/std_inc.h]}shared/Core/sys/std_inc.h]"][{<{}{%PN=Core}{C}>!=0}\
   if ( ( %X |U ) %!= 'h' OR 
     ( ( %P |S ) %== 'Impl'  ) OR 
     ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%P
    begin
     OBJECT IN %P
     if ( ( %P |N ) %== 'CoreSrv' ) then
     begin

      ++! l_Counter
     end // if
    end // for P
    l_Counter
    %== 0  ) ) then
   begin
    'shared/CoreSrv/sys/std_inc.h' 
   end // if
   else
   begin
    'shared/Core/sys/std_inc.h' 
   end // else
  end // else
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P |N ) %== 'Core' ) then
   begin

    ++! l_Counter
   end // if
  end // for P
  l_Counter
  %!= 0 ) then
 begin
//	[{%S#f_IsInterfaces()=true}{\#include "ace/ACE.h"}\#include "shared/Core/sys/core_std_inc.h"[{%XU=fctr.h|%XU=fctr.cpp}
  if ( ( %S %?f IsInterfaces %( )% ) %==  true ) then
  begin
   '#include "shared/Core/sys/core_std_inc.h"'
   if ( ( %X |U ) %== 'fctr.h' OR 
     ( ( %X |U ) %== 'fctr.cpp'  ) ) then
   begin
    #13#10

//	\#include "shared/Core/Root/Root.h"][{<{}{%AS=oneway|%AS=oneway,chg}{%AC}>!=0}
    '#include "shared/Core/Root/Root.h' 
   end // if
   if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%A
    begin
     OBJECT IN %A
     if ( ( %A |S ) %== 'oneway' OR 
      ( ( %A |S ) %== 'oneway,chg'  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for A
    l_Counter
    %!= 0 ) then
   begin
    #13#10

//	\#include "shared/Core/mt/mt.h"]]]
    '#include "shared/Core/mt/mt.h' 
   end // if
  end // if
  else
  begin
   '#include "ace/ACE.h' 
  end // else
 end // if
//#UC END# *4714DFD102FD*
; // std_inc


// метод дампит имя пакета по правилам java (имя пакета должено соответствовать файловой системе)
//f _dump_java_package
: dump_java_package OBJECT IN %S
//#UC START# *4714E01E009C*
//	%f_set_var(ARG,S)%f_set_var(RES,"[{%Se=false|"%SL"=""}{%SL}<{}{%PM=Project::Category}%P{package prefix}.>%S<{.}{%P{is namespace}=true|%PM=Project::Category|%PM=KPlugins::Category|%PM=DataDef::Category|%f_is_nested(%P)=true}{%Pr}%PN>]")[{%SC=State|%SM=State::Class}{%{RES}N}<{}{%PM=StateMachine::Class}%f_str_replace(%{RES}N,.%PN,.sm.%PN)>]
 [%f] set_var %( 'ARG' %, 'S' )% [%f] set_var %( 'RES' %, if ( ( %S |e ) %==  false OR 
   ( ( %S |L ) %== ''  ) ) then
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P |M ) %== 'Project::Category' ) then
   begin
    %P get_up ( 'package prefix' ) '.' 
    ++! l_Counter
   end // if
  end // for P
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for downto %S%P
   begin
    OBJECT IN %P
    if ( ( %P get_up ( 'is namespace' ) ) %==  true OR 
     ( ( %P |M ) %== 'Project::Category'  ) OR 
     ( ( %P |M ) %== 'KPlugins::Category'  ) OR 
     ( ( %P |M ) %== 'DataDef::Category'  ) OR 
     ( ( [%f] is_nested %( %P )% ) %==  true  ) ) then
    begin
     if ( l_Counter >0 ) then ( '.' )
     %P |N 
     ++! l_Counter
    end // if
   end // for P

  ) // bind
  end // if
 else
 begin
  %S |L 
 end // else
)%  if ( ( %S |C ) %== 'State' OR 
   ( ( %S |M ) %== 'State::Class'  ) ) then
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P |M ) %== 'StateMachine::Class' ) then
   begin
    [%f] str_replace %( ( get_global_var ( 'RES' ) |N ) %, '.'
    %P |N %, '.sm.'
    %P |N )% 
    ++! l_Counter
   end // if
  end // for P
 end // if
 else
 begin
  ( get_global_var ( 'RES' ) |N ) 
 end // else

//f _is_nested
; // dump_java_package

: is_nested OBJECT IN %S
//	[{%t_nested_scope_def(%S)=true&%{ARG}M!=State::Class}{false}true]
 if ( ( [%t] nested_scope_def %( %S )% ) %==  true AND 
   ( ( ( get_global_var ( 'ARG' ) |M ) ) %!= 'State::Class'  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714E01E009C*
; // is_nested


// метод дампит имя пакета по правилам java (имя пакета должено соответствовать файловой системе) -
// более правильная версия dump_java_package (), впоследствии должна заменить её полностью
//f _dump_java_package_ex
: dump_java_package_ex OBJECT IN %S
//#UC START# *4714E02B033C*
//	[{%Se=false|"%SL"=""}{%SL}\
 if ( ( %S |e ) %==  false OR 
   ( ( %S |L ) %== ''  ) ) then
 begin
//	<{}{%PM=Project::Category}%f_str_replace(%P{package prefix}/%PN%f_delsubstr_from_begin(%Sd,%f_string_length(%Pd)),/,.)>]
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P |M ) %== 'Project::Category' ) then
   begin
    [%f] str_replace %( %P get_up ( 'package prefix' ) '/'
    %P |N [%f] delsubstr_from_begin %( %S |d %, [%f] string_length %( %P |d )% )% %, '/' %, '.' )% 
    ++! l_Counter
   end // if
  end // for P
 end // if
 else
 begin
  %S |L 
 end // else
//#UC END# *4714E02B033C*
; // dump_java_package_ex


// включает все часто (всегда) используемые импорты в джава коде
//f _dump_std_java_imports
: dump_std_java_imports OBJECT IN %S
//#UC START# *4714E06003C8*
//	import ru.garant.shared.Core.Logs;[{<{}{%PS=KLibrary}{%PC}>!=0}
 'import ru.garant.shared.Core.Logs;'
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P |S ) %== 'KLibrary' ) then
   begin

    ++! l_Counter
   end // if
  end // for P
  l_Counter
  %!= 0 ) then
 begin
  #13#10

//	import ru.garant.shared.ConfluenceCore.Helpers.*;
  'import ru.garant.shared.ConfluenceCore.Helpers.*;'
//	import ru.garant.shared.ConfluenceCore.UserSupport.*;
  'import ru.garant.shared.ConfluenceCore.UserSupport.*;'
//	import ru.garant.shared.ConfluenceCore.SpaceSupport.*;]
  'import ru.garant.shared.ConfluenceCore.SpaceSupport.*;' 
 end // if
//#UC END# *4714E06003C8*
; // dump_std_java_imports


// генерация видимоти элемента
//t _visibility
<<transformator>> visibility OBJECT IN %S
//#UC START# *4714E07C001F*
//c                            {java}                                      {}
//r "%SV"="PublicAccess":      {public }                                   {public }
//r "%SV"="PrivateAccess":     {[{%Sa!=abstract}{protected }private ]}     {[{%Sa!=abstract}{protected }private ]}
//r "%SV"="ProtectedAccess":   {protected }                                {protected }
//r ""="":                     {public }                                   {public }
//#UC END# *4714E07C001F*
; // visibility


// генерация типа абстракции (используется при генерации в java)
//t _abstract_type
<<transformator>> abstract_type OBJECT IN %S
//#UC START# *4714E098007D*
//c                                                {}
//r "<{}{%CC=Operation&%Ca=abstract}{%CC}>"!="0":    {abstract }
//r "%Sa"="regular":                               {}
//r "%Sa"="abstract":                              {abstract }
//r "%Sa"="final":                                 {final }
//r ""="":                                         {}
//#UC END# *4714E098007D*
; // abstract_type


// генерация метода
//f _servant_java_operation
: servant_java_operation OBJECT IN %S
//#UC START# *4714E0D400AB*
//	[{%SS!=oneway&%SS!=oneway,chg}{%f_oneway_operation_impl_java(%S)}%f_docs(%S)\
 if ( ( %S |S ) %!= 'oneway' AND 
   ( ( %S |S ) %!= 'oneway,chg'  ) ) then
 begin
  [%f] docs %( %S )% 
//	[%S#f_dump_annotations("#")
  if NOT-EMPTY
  begin
   %S %?f dump_annotations %( out_indent )% 
//	]#%t_visibility(%S,"XU")[{%S%f_is_static()=true}static ][{"%1N"!="interface"}%t_abstract_type(%S)]%f_ret(%S) %f_to_java(%SN) (<{, }%f_arg_full_decl(%C)>)[ throws <{, }%f_type(%E)>][{%Sa!=abstract}{;} {
  end // if
  NOP
  out_indent [%t] visibility %( %S %, 'XU' )% if ( ( %S %f is_static %( )% ) %==  true ) then
  begin
   'static ' 
  end // if
  if ( ( %1 |N ) %!= 'interface' ) then
  begin
   [%t] abstract_type %( %S )% 
  end // if
  [%f] ret %( %S )% ' '
  [%f] to_java %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ')'
  if NOT-EMPTY
  begin
   ' throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
  end // if
  NOP
  if ( ( %S |a ) %!= 'abstract' ) then
  begin
   ' {'
//	#	%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U]!java!}
   out_indent '	'
   %Usersection (
    if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
    begin
     '_'
     ( get_global_var ( 'SERV' ) |U ) 
    end // if
    '!java!' 
   )
   (
    #13#10

//	#	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
    out_indent '	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();'
//	#	]
    out_indent '	' 
   ) // Usersection
 //	#}]]
   out_indent '}' 
  end // if
  else
  begin
   ';' 
  end // else
 end // if
 else
 begin
  [%f] oneway_operation_impl_java %( %S )% 
 end // else
//#UC END# *4714E0D400AB*
; // servant_java_operation


// генерация переопределенного метода
//f _servant_java_derived_operation
: servant_java_derived_operation OBJECT IN %S
//#UC START# *4714E0E2034B*
//	[{%f_need_oneway_impl(%S)=false}%f_docs(%S)\
 if ( ( [%f] need_oneway_impl %( %S )% ) %==  false ) then
 begin
  [%f] docs %( %S )% 
//	[%S#f_dump_annotations("#","true")
  if NOT-EMPTY
  begin
   %S %?f dump_annotations %( out_indent %, true )% 
//	]#[[{"%1N"!="interface"|[{%PS=Interface|%PS=LocalInterface|%PS=Facet|%PS=ServerFacet|%PS=Interface}{true}false]=true}{public }%t_visibility(%S)][{%SS=static}static ][{"%1N"!="interface"}%t_abstract_type(%S)]%f_ret(%S) [{%PS!=ServerInterface&%PS!=ServerFacet}{%SN}%f_to_java(%SN)] (<{, }%f_arg_full_decl(%C)>)[ throws <{, }%f_type(%E)>] {
  end // if
  NOP
  out_indent if NOT-EMPTY
  begin
   if ( ( %1 |N ) %!= 'interface' OR 
     ( if ( ( %P |S ) %== 'Interface' OR 
      ( ( %P |S ) %== 'LocalInterface'  ) OR 
      ( ( %P |S ) %== 'Facet'  ) OR 
      ( ( %P |S ) %== 'ServerFacet'  ) OR 
      ( ( %P |S ) %== 'Interface'  ) ) then
    begin
      false 
    end // if
    else
    begin
      true 
    end // else
    %==  true  ) ) then
   begin
    [%t] visibility %( %S )% 
   end // if
   else
   begin
    'public ' 
   end // else
   if ( ( %S |S ) %== 'static' ) then
   begin
    'static ' 
   end // if
   if ( ( %1 |N ) %!= 'interface' ) then
   begin
    [%t] abstract_type %( %S )% 
   end // if
   [%f] ret %( %S )% ' '
   if ( ( %P |S ) %!= 'ServerInterface' AND 
     ( ( %P |S ) %!= 'ServerFacet'  ) ) then
   begin
    [%f] to_java %( %S |N )% 
   end // if
   else
   begin
    %S |N 
   end // else
   ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] arg_full_decl %( %C )% 
     ++! l_Counter
    end // if
   end // for C
   ')'
   if NOT-EMPTY
   begin
    ' throws '
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] type %( %E )% 
      ++! l_Counter
     end // if
    end // for E
   end // if
   NOP
   ' {'
//	#	%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U]!java!}
   out_indent '	'
   %Usersection (
    if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
    begin
     '_'
     ( get_global_var ( 'SERV' ) |U ) 
    end // if
    '!java!' 
   )
   (
    #13#10

//	#	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
    out_indent '	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();'
//	#	]
    out_indent '	' 
   ) // Usersection
 //	#}]][{%f_need_oneway_impl(%S)=true}#//oneway implementation
   out_indent '}' 
  end // if
  NOP
 end // if
 if ( ( [%f] need_oneway_impl %( %S )% ) %==  true ) then
 begin
  out_indent '//oneway implementation'
//	#[{"%1N"!="interface"|[{%PS=Interface|%PS=LocalInterface|%PS=Facet|%PS=ServerFacet|%PS=Interface}{true}false]=true}{public }%t_visibility(%S)][{"%1N"!="interface"}%t_abstract_type(%S)]void [{%PS!=ServerInterface&%PS!=ServerFacet}{%SN}%f_to_java(%SN)] (<{, }%f_arg_full_decl(%C)>)[ throws <{, }%f_type(%E)>] {
  out_indent if ( ( %1 |N ) %!= 'interface' OR 
    ( if ( ( %P |S ) %== 'Interface' OR 
     ( ( %P |S ) %== 'LocalInterface'  ) OR 
     ( ( %P |S ) %== 'Facet'  ) OR 
     ( ( %P |S ) %== 'ServerFacet'  ) OR 
     ( ( %P |S ) %== 'Interface'  ) ) then
   begin
     false 
   end // if
   else
   begin
     true 
   end // else
   %==  true  ) ) then
  begin
   [%t] visibility %( %S )% 
  end // if
  else
  begin
   'public ' 
  end // else
  if ( ( %1 |N ) %!= 'interface' ) then
  begin
   [%t] abstract_type %( %S )% 
  end // if
  'void '
  if ( ( %P |S ) %!= 'ServerInterface' AND 
    ( ( %P |S ) %!= 'ServerFacet'  ) ) then
  begin
   [%f] to_java %( %S |N )% 
  end // if
  else
  begin
   %S |N 
  end // else
  ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ')'
  if NOT-EMPTY
  begin
   ' throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
  end // if
  NOP
  ' {'
//	#	java.util.concurrent.Executor executor = ru.garant.shared.Core.Concurrent.ThreadPool.Factory.def ();
  out_indent '	java.util.concurrent.Executor executor = ru.garant.shared.Core.Concurrent.ThreadPool.Factory.def ();'
//	#	Runnable eval = new Runnable () {
  out_indent '	Runnable eval = new Runnable () {'
//	#		public void run() {
  out_indent '		public void run() {'
//	#			%f_to_java(%SNImpl) (<{, }%f_to_java(%CN)>);
  out_indent '			'
  [%f] to_java %( %S |N 'Impl' )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] to_java %( %C |N )% 
    ++! l_Counter
   end // if
  end // for C
  ');'
//	#		}
  out_indent '		}'
//	#	};
  out_indent '	};'
//	#	executor.execute(eval);
  out_indent '	executor.execute(eval);'
//	#}
  out_indent '}'
//	
  #13#10

//	%f_docs(%S)\
  [%f] docs %( %S )% 
//	[%S#f_dump_annotations("#","true")
  if NOT-EMPTY
  begin
   %S %?f dump_annotations %( out_indent %, true )% 
//	]#[{%SV!=PrivateAccess}{private}protected] [{"%1N"!="interface"}%t_abstract_type(%S)]%f_ret(%S) %f_to_java(%SNImpl) (<{, }%f_arg_full_decl(%C)>)[ throws <{, }%f_type(%E)>] {
  end // if
  NOP
  out_indent if ( ( %S |V ) %!= 'PrivateAccess' ) then
  begin
   'protected' 
  end // if
  else
  begin
   'private' 
  end // else
  ' '
  if ( ( %1 |N ) %!= 'interface' ) then
  begin
   [%t] abstract_type %( %S )% 
  end // if
  [%f] ret %( %S )% ' '
  [%f] to_java %( %S |N 'Impl' )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ')'
  if NOT-EMPTY
  begin
   ' throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
  end // if
  NOP
  ' {'
//	#	%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U]!java!}
  out_indent '	'
  %Usersection (
   if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
   begin
    '_'
    ( get_global_var ( 'SERV' ) |U ) 
   end // if
   '!java!' 
  )
  (
   #13#10

//	#	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
   out_indent '	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();'
//	#	]
   out_indent '	' 
  ) // Usersection
 //	#}]
  out_indent '}' 
 end // if

//f _need_oneway_impl
; // servant_java_derived_operation

: need_oneway_impl OBJECT IN %S
//	[{%f_is_server_type(%P)=false&[{%SS=oneway|%SS=oneway,chg}true]=true}{false}true]
 if ( ( [%f] is_server_type %( %P )% ) %==  false AND 
   ( if ( ( %S |S ) %== 'oneway' OR 
    ( ( %S |S ) %== 'oneway,chg'  ) ) then
  begin
    true 
  end // if
  %==  true  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714E0E2034B*
; // need_oneway_impl


// генерация атрибута
//f _servant_java_attribute
: servant_java_attribute OBJECT IN %S
//#UC START# *4714E0F303A9*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%t_need_ro(%S)=true}\
 if ( ( [%t] need_ro %( %S )% ) %==  true ) then
 begin
//	[%S#f_dump_annotations("#")
  if NOT-EMPTY
  begin
   %S %?f dump_annotations %( out_indent )% 
//	]#%f_templ_header(%{SERV})[{"%1N"!="interface"|[{%PS=Interface|%PS=LocalInterface|%PS=Facet|%PS=ServerFacet|%PS=Interface}{true}false]=true}{public }%t_visibility(%S)]%f_ret(%S) get[{%PS!=ServerInterface&%PS!=ServerFacet}{_%SN}%f_to_borland(%SN)] (%S%f_accessor_args())[
  end // if
  NOP
  out_indent [%f] templ_header %( ( get_global_var ( 'SERV' ) ) )% if ( ( %1 |N ) %!= 'interface' OR 
    ( if ( ( %P |S ) %== 'Interface' OR 
     ( ( %P |S ) %== 'LocalInterface'  ) OR 
     ( ( %P |S ) %== 'Facet'  ) OR 
     ( ( %P |S ) %== 'ServerFacet'  ) OR 
     ( ( %P |S ) %== 'Interface'  ) ) then
   begin
     false 
   end // if
   else
   begin
     true 
   end // else
   %==  true  ) ) then
  begin
   [%t] visibility %( %S )% 
  end // if
  else
  begin
   'public ' 
  end // else
  [%f] ret %( %S )% ' get'
  if ( ( %P |S ) %!= 'ServerInterface' AND 
    ( ( %P |S ) %!= 'ServerFacet'  ) ) then
  begin
   [%f] to_borland %( %S |N )% 
  end // if
  else
  begin
   '_'
   %S |N 
  end // else
  ' ('
  %S %f accessor_args %( )% ')'
  if NOT-EMPTY
  begin
   #13#10

//	#	throws <{, }%f_type(%E)>
   out_indent '	throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
//	#][{%Ex=false} ]{%f_start_func_cpp(%S,"get%f_to_borland(%SN)")%f_set_var(OP,S)
   out_indent 
  end // if
  NOP
  if ( ( %E |x ) %==  false ) then
  begin
   ' ' 
  end // if
  '{'
  [%f] start_func_cpp %( %S %, 'get'
  [%f] to_borland %( %S |N )% )% [%f] set_var %( 'OP' %, 'S' )% 
//	#	[{%f_is_impl_atrr(%{SERV},%S)=true}{%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U_GET]}
  out_indent '	'
  if ( ( [%f] is_impl_atrr %( ( get_global_var ( 'SERV' ) ) %, %S )% ) %==  true ) then
  begin
   'return this.'
   [%f] to_java %( %S |N )% '_;' 
  end // if
  else
  begin
   %Usersection (
    if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
    begin
     '_'
     ( get_global_var ( 'SERV' ) |U ) '_GET' 
    end // if

   )
   (
    #13#10

//	#	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
    out_indent '	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();'
//	#	]}return this.%f_to_java(%SN)_;]
    out_indent '	' 
   ) // Usersection
   end // else
//	#}
  out_indent '}'
//	][{%t_need_rw(%S)=true}[{%t_need_ro(%S)=true}\n]\
 end // if
 if ( ( [%t] need_rw %( %S )% ) %==  true ) then
 begin
  if ( ( [%t] need_ro %( %S )% ) %==  true ) then
  begin
   #13#10 
  end // if
//	[%S#f_dump_annotations("#")
  if NOT-EMPTY
  begin
   %S %?f dump_annotations %( out_indent )% 
//	]#[{"%1N"!="interface"|[{%PS=Interface|%PS=LocalInterface|%PS=Facet|%PS=ServerFacet|%PS=Interface}{true}false]=true}{public }%t_visibility(%S)]void set[{%PS!=ServerInterface&%PS!=ServerFacet}{_%SN}%f_to_borland(%SN)] (%f_iset_attr(%S) %f_to_java(%SN)[, %S%f_accessor_args()])[
  end // if
  NOP
  out_indent if ( ( %1 |N ) %!= 'interface' OR 
    ( if ( ( %P |S ) %== 'Interface' OR 
     ( ( %P |S ) %== 'LocalInterface'  ) OR 
     ( ( %P |S ) %== 'Facet'  ) OR 
     ( ( %P |S ) %== 'ServerFacet'  ) OR 
     ( ( %P |S ) %== 'Interface'  ) ) then
   begin
     false 
   end // if
   else
   begin
     true 
   end // else
   %==  true  ) ) then
  begin
   [%t] visibility %( %S )% 
  end // if
  else
  begin
   'public ' 
  end // else
  'void set'
  if ( ( %P |S ) %!= 'ServerInterface' AND 
    ( ( %P |S ) %!= 'ServerFacet'  ) ) then
  begin
   [%f] to_borland %( %S |N )% 
  end // if
  else
  begin
   '_'
   %S |N 
  end // else
  ' ('
  [%f] iset_attr %( %S )% ' '
  [%f] to_java %( %S |N )% if NOT-EMPTY
  begin
   ', '
   %S %f accessor_args %( )% 
  end // if
  NOP
  ')'
  if NOT-EMPTY
  begin
   #13#10

//	#	throws <{, }%f_type(%e)>
   out_indent '	throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %e )% 
     ++! l_Counter
    end // if
   end // for e
//	#][{%ex=false} ]{%f_start_func_cpp(%S,"%{SERV}N::set_%SN")
   out_indent 
  end // if
  NOP
  if ( ( %e |x ) %==  false ) then
  begin
   ' ' 
  end // if
  '{'
  [%f] start_func_cpp %( %S %, ( get_global_var ( 'SERV' ) |N ) '::set_'
  %S |N )% 
//	#	[{%f_is_impl_atrr(%{SERV},%S)=true}{%U[{[{"%{SERV}U"!="%PU"}_%{SERV}U_SET]}
  out_indent '	'
  if ( ( [%f] is_impl_atrr %( ( get_global_var ( 'SERV' ) ) %, %S )% ) %==  true ) then
  begin
   'this.'
   [%f] to_java %( %S |N )% '_ = '
   [%f] to_java %( %S |N )% ';' 
  end // if
  else
  begin
   %Usersection (
    if ( ( ( get_global_var ( 'SERV' ) |U ) ) %!= ( %P |U ) ) then
    begin
     '_'
     ( get_global_var ( 'SERV' ) |U ) '_SET' 
    end // if

   )
   (
    #13#10

//	#	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
    out_indent '	throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();'
//	#	]}this.%f_to_java(%SN)_ = %f_to_java(%SN);]
    out_indent '	' 
   ) // Usersection
   end // else
//	#}]
  out_indent '}' 
 end // if
//#UC END# *4714E0F303A9*
; // servant_java_attribute


// генерация реализуемых и перегруженных методов, атрибутов
//f _dump_java_derrived_impl
: dump_java_derrived_impl OBJECT IN %S
//#UC START# *4714E102033C*
//	%f_set_var(SERV,S)%f_set_var(NEED_UPDATE_RW,"0")%f_has_combo_fctr(%S)[
 [%f] set_var %( 'SERV' %, 'S' )% [%f] set_var %( 'NEED_UPDATE_RW' %, 0 )% [%f] has_combo_fctr %( %S )% if NOT-EMPTY
 begin
  #13#10

//	[#//////////////////////////////////////////////////////////////////////////////////////////
  if NOT-EMPTY
  begin
   out_indent '//////////////////////////////////////////////////////////////////////////////////////////'
//	#// implemented interface's methods
   out_indent '// implemented interface's methods'
//	[<{\n}{}{Sp}\
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%op
    begin
     OBJECT IN %o
     if true then
     begin
      if ( l_Counter >0 ) then ( #13#10 )
//	
      #13#10

//	#	// implemented method from %f_type(%o%P)
      out_indent '	// implemented method from '
      [%f] type %( %o ->P  )% 
//	[{"%oC"="Attribute"}%f_servant_java_attribute(%o,"interface")][{"%oC"="Operation"}%f_servant_java_derived_operation(%o,"interface")]>]][{%f_has_overloaded_methods(%S)=true}
      if ( ( %o |C ) %== 'Attribute' ) then
      begin
       [%f] servant_java_attribute %( %o %, 'interface' )% 
      end // if
      if ( ( %o |C ) %== 'Operation' ) then
      begin
       [%f] servant_java_derived_operation %( %o %, 'interface' )% 
      end // if

      ++! l_Counter
     end // if
    end // for o
   end // if
   NOP
  end // if
  NOP
  if ( ( [%f] has_overloaded_methods %( %S )% ) %==  true ) then
  begin
   #13#10

//	#//////////////////////////////////////////////////////////////////////////////////////////
   out_indent '//////////////////////////////////////////////////////////////////////////////////////////'
//	#// overloaded base methods
   out_indent '// overloaded base methods'
//	[#<{}{"%OV"="PublicAccess"&"%t_interface(%O%P)"="false"&"%OS"!="ctor"}{Sp}
   if NOT-EMPTY
   begin
    out_indent 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Op
    begin
     OBJECT IN %O
     if ( ( %O |V ) %== 'PublicAccess' AND 
      ( ( [%t] interface %( %O ->P  )% ) %== false  ) AND 
      ( ( %O |S ) %!= 'ctor'  ) ) then
     begin
      #13#10

//	
      #13#10

//	#	// overloaded method from %f_type(%O%P)
      out_indent '	// overloaded method from '
      [%f] type %( %O ->P  )% 
//	[{"%OC"="Attribute"}%f_servant_java_attribute(%O,"interface")][{"%OC"="Operation"}%f_servant_java_derived_operation(%O,"interface")]>][\
      if ( ( %O |C ) %== 'Attribute' ) then
      begin
       [%f] servant_java_attribute %( %O %, 'interface' )% 
      end // if
      if ( ( %O |C ) %== 'Operation' ) then
      begin
       [%f] servant_java_derived_operation %( %O %, 'interface' )% 
      end // if

      ++! l_Counter
     end // if
    end // for O
   end // if
   NOP
   if NOT-EMPTY
   begin
//	#<{}{"%OV"="ProtectedAccess"|"%t_interface(%O%P)"="true"&"%OS"!="ctor"}{Sp}
    out_indent 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Op
    begin
     OBJECT IN %O
     if ( ( %O |V ) %== 'ProtectedAccess' OR 
      ( ( [%t] interface %( %O ->P  )% ) %== true  ) AND 
      ( ( %O |S ) %!= 'ctor'  ) ) then
     begin
      #13#10

//	
      #13#10

//	#	// overloaded method from %f_type(%O%P)
      out_indent '	// overloaded method from '
      [%f] type %( %O ->P  )% 
//	[{"%OC"="Attribute"}%f_servant_java_attribute(%O,"interface")][{"%OC"="Operation"}%f_servant_java_derived_operation(%O,"interface")]>][\
      if ( ( %O |C ) %== 'Attribute' ) then
      begin
       [%f] servant_java_attribute %( %O %, 'interface' )% 
      end // if
      if ( ( %O |C ) %== 'Operation' ) then
      begin
       [%f] servant_java_derived_operation %( %O %, 'interface' )% 
      end // if

      ++! l_Counter
     end // if
    end // for O
   end // if
   NOP
   if NOT-EMPTY
   begin
//	#<{}{"%OV"="PrivateAccess"&"%OS"!="ctor"}{Sp}
    out_indent 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Op
    begin
     OBJECT IN %O
     if ( ( %O |V ) %== 'PrivateAccess' AND 
      ( ( %O |S ) %!= 'ctor'  ) ) then
     begin
      #13#10

//	
      #13#10

//	#	// overloaded method from %f_type(%O%P)
      out_indent '	// overloaded method from '
      [%f] type %( %O ->P  )% 
//	[{"%OC"="Attribute"}%f_servant_java_attribute(%O,"interface")][{"%OC"="Operation"}%f_servant_java_derived_operation(%O,"interface")]>]
      if ( ( %O |C ) %== 'Attribute' ) then
      begin
       [%f] servant_java_attribute %( %O %, 'interface' )% 
      end // if
      if ( ( %O |C ) %== 'Operation' ) then
      begin
       [%f] servant_java_derived_operation %( %O %, 'interface' )% 
      end // if

      ++! l_Counter
     end // if
    end // for O
   end // if
   NOP
//	]][{%{NEED_UPDATE_RW}N=1}
  end // if
 end // if
 NOP
 if ( ( ( get_global_var ( 'NEED_UPDATE_RW' ) |N ) ) %== 1 ) then
 begin
  #13#10

//	
  #13#10

//	#	public void upgrade_rw () {
  out_indent '	public void upgrade_rw () {'
//	#		%U[{_UPDATE_RW}
  out_indent '		'
  %Usersection (
   '_UPDATE_RW' 
  )
  (
   #13#10

//	#		throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
   out_indent '		throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();'
//	#		]
   out_indent '		' 
  ) // Usersection
 //	#	}]
  out_indent '	}' 
 end // if
//#UC END# *4714E102033C*
; // dump_java_derrived_impl


// генерация всех собственных методов элемента
//f _dump_java_self_impl
: dump_java_self_impl OBJECT IN %S
//#UC START# *4714E11F02AF*
//	[[#<{}{"%CC"!="Attribute"}{Sp}
 if NOT-EMPTY
 begin
  if NOT-EMPTY
  begin
   out_indent 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Cp
   begin
    OBJECT IN %C
    if ( ( %C |C ) %!= 'Attribute' ) then
    begin
     #13#10

//	[{"%CC"="Operation"}%f_servant_java_operation(%C)]>]]
     if ( ( %C |C ) %== 'Operation' ) then
     begin
      [%f] servant_java_operation %( %C )% 
     end // if

     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
 end // if
 NOP
//#UC END# *4714E11F02AF*
; // dump_java_self_impl


// генерация импортов по вложенным типам
//f _includes_by_contents_java
: includes_by_contents_java OBJECT IN %S
//#UC START# *4714E1410280*
//#UC END# *4714E1410280*
; // includes_by_contents_java


// возвращает true, если нужно дописывать POA
//f _need_poa
: need_poa OBJECT IN %S
//#UC START# *4714E16B0261*
//	[{%SS=ServerInterface|%SS=ServerFacet}{false}true]
 if ( ( %S |S ) %== 'ServerInterface' OR 
   ( ( %S |S ) %== 'ServerFacet'  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714E16B0261*
; // need_poa


// возвращает true, если тип является серверным
//f _is_server_type_java
: is_server_type_java OBJECT IN %S
//#UC START# *4714E1750399*
//	[{%f_is_server_type(%S)=true&%t_simple(%S)=false}{false}true]
 if ( ( [%f] is_server_type %( %S )% ) %==  true AND 
   ( ( [%t] simple %( %S )% ) %==  false  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714E1750399*
; // is_server_type_java


// генерация импорта на java
//f _java_import
: java_import OBJECT IN %S
//#UC START# *4714E1820138*
//	[{%Se=false}{[{"%SL"!=""}import %SL;]}[{"%So"!=""|%t_nested_scope_def(%P)=true|%f_is_server_type_java(%S)=true}import %f_dump_java_package(%S).%SN[{%XU=fctr.java}FactoryImpl][{%f_need_poa(%S)=true&"%1S"!="uses"}POA;\nimport %f_dump_java_package(%S).%SN];]]
 if ( ( %S |e ) %==  false ) then
 begin
  if ( ( %S |o ) %!= '' OR 
    ( ( [%t] nested_scope_def %( %P )% ) %==  true  ) OR 
    ( ( [%f] is_server_type_java %( %S )% ) %==  true  ) ) then
  begin
   'import '
   [%f] dump_java_package %( %S )% '.'
   %S |N if ( ( %X |U ) %== 'fctr.java' ) then
   begin
    'FactoryImpl' 
   end // if
   if ( ( [%f] need_poa %( %S )% ) %==  true AND 
     ( ( %1 |S ) %!= 'uses'  ) ) then
   begin
    'POA;'#13#10'import '
    [%f] dump_java_package %( %S )% '.'
    %S |N 
   end // if
   ';' 
  end // if
 end // if
 else
 begin
  if ( ( %S |L ) %!= '' ) then
  begin
   'import '
   %S |L ';' 
  end // if
 end // else
//#UC END# *4714E1820138*
; // java_import


// генерация импорта основных исключений
//f _java_core_exceptions
: java_core_exceptions OBJECT IN %S
//#UC START# *4714E1A502EE*
//	[{%f_is_server_type(%S)=false}{import ru.garant.shared.CoreSrv.UnknownFactoryKey;
 if ( ( [%f] is_server_type %( %S )% ) %==  false ) then
 begin
  'import ru.garant.shared.Core.Root.UnknownFactoryKey;'
//	import ru.garant.shared.Core.Root.NoActiveFactory;]
  'import ru.garant.shared.Core.Root.NoActiveFactory;' 
 end // if
 else
 begin
  'import ru.garant.shared.CoreSrv.UnknownFactoryKey;'
//	import ru.garant.shared.CoreSrv.NoActiveFactory;}import ru.garant.shared.Core.Root.UnknownFactoryKey;
  'import ru.garant.shared.CoreSrv.NoActiveFactory;' 
 end // else
//	import ru.garant.shared.Core.Root.DuplicatedFactoryKey;
 'import ru.garant.shared.Core.Root.DuplicatedFactoryKey;'
//#UC END# *4714E1A502EE*
; // java_core_exceptions


// генерация возвращаемого значения функции (нужно чтобы после генерации java код собирался без
// ошибок)
//f _java_return
: java_return OBJECT IN %S
//#UC START# *4714E1C903A9*
//	[return %t_java_return(%S);]
 if NOT-EMPTY
 begin
  'return '
  [%t] java_return %( %S )% ';' 
 end // if
 NOP
//#UC END# *4714E1C903A9*
; // java_return


// генерация возвращаемого значения функции (нужно чтобы после генерации java код собирался без
// ошибок)
//t _java_return
<<transformator>> java_return OBJECT IN %S
//#UC START# *4714E2100280*
//c                                  {}
//r "%SN"="void":                    {}
//r "%SM"="BitMask::Class":          {true}
//r "%SC"="Operation":               {true}
//r "%SN"="short":                   {0}
//r "%SN"="size":                    {0}
//r "%SN"="integer":                 {0}
//r "%SN"="long":                    {0}
//r "%SN"="atomic":                  {0}
//r "%SN"="hthread":                 {0}
//r "%SN"="unsigned atomic":         {0}
//r "%SN"="long long":               {0}
//r "%SN"="unsigned short":          {0}
//r "%SN"="unsigned integer":        {0}
//r "%SN"="unsigned long":           {0}
//r "%SN"="unsigned long long":      {0}
//r "%SN"="float":                   {0.0}
//r "%SN"="double":                  {0.0}
//r "%SN"="boolean":                 {true}
//r "%SN"="char":                    {0}
//r "%SN"="wchar":                   {0}
//r "%SN"="octet":                   {0}
//r "%SN"="string":                  {""}
//r "%SN"="pointer":                 {null}
//r "%SN"="HWND":                    {null}
//r "%SN"="WPARAM":                  {null}
//r "%SN"="LPARAM":                  {null}
//r "%SN"="BOOL":                    {true}
//r "%SN"="LRESULT":                 {null}
//r "%SN"="UINT":                    {0}
//r "%SN"="HANDLE":                  {0}
//r "%SN"="HHOOK":                   {null}
//r "%S%PN"="Win32":                 {0}
//r "%SM"="Typedef::Class":          {[{%Gx=true}{true}%t_java_return(%G)]}
//r ""="":                           {null}
//#UC END# *4714E2100280*
; // java_return


// возвращает пакет где определен дом библиотек
//f _dump_lib_home
: dump_lib_home OBJECT IN %S
//#UC START# *4714E2240148*
//	%f_dump_java_package(%S).%SN
 [%f] dump_java_package %( %S )% '.'
 %S |N 
//#UC END# *4714E2240148*
; // dump_lib_home


// регистрация домов библиотек
//f _reg_all_dep_java
: reg_all_dep_java OBJECT IN %S
//#UC START# *4714E24D030D*
//	%f_clear_list(REG_ALL_DEP)\
 [%f] clear_list %( 'REG_ALL_DEP' )% 
//	%f_clear_list(REG_ALL_DEP_SERVER)\
 [%f] clear_list %( 'REG_ALL_DEP_SERVER' )% 
//	%f_collect_reg_all_dep_java(%S)\
 [%f] collect_reg_all_dep_java %( %S )% 
//	%f_sort_list(REG_ALL_DEP,u)\
 [%f] sort_list %( 'REG_ALL_DEP' %, 'u' )% 
//	<{}{%f_is_empty(REG_ALL_DEP)=false}{W}%f_pop_first_to_var(REG_ALL_DEP,CYCLE_ITEM)\
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'REG_ALL_DEP' )% ) %==  false ) then
  begin
   [%f] pop_first_to_var %( 'REG_ALL_DEP' %, 'CYCLE_ITEM' )% 
//			lhm.registrateLibHome (%f_dump_lib_home(%{CYCLE_ITEM}).LibHomeFactory.get());[{%f_exists_in_list(REG_ALL_DEP_SERVER,{CYCLE_ITEM})=true}
   '		lhm.registrateLibHome ('
   [%f] dump_lib_home %( ( get_global_var ( 'CYCLE_ITEM' ) ) )% '.LibHomeFactory.get());'
   if ( ( [%f] exists_in_list %( 'REG_ALL_DEP_SERVER' %, '{CYCLE_ITEM}' )% ) %==  true ) then
   begin
    #13#10

//			lhm.registrateLibHome (%f_dump_lib_home(%{CYCLE_ITEM}).ServerLibHomeFactory.get());]
    '		lhm.registrateLibHome ('
    [%f] dump_lib_home %( ( get_global_var ( 'CYCLE_ITEM' ) ) )% '.ServerLibHomeFactory.get());' 
   end // if
//	]>%f_clear_list(REG_ALL_DEP)%f_clear_list(REG_ALL_DEP_SERVER)
   ']' 
   ++! l_Counter
  end // if
  else
   break
 end // while
 [%f] clear_list %( 'REG_ALL_DEP' )% [%f] clear_list %( 'REG_ALL_DEP_SERVER' )% 

//f _collect_reg_all_dep_java
; // reg_all_dep_java

: collect_reg_all_dep_java OBJECT IN %S
//	<{}{%De=false&%D{old gcm}!=true&%DS!=Requirements&%DS!=KCustomize}[{%f_exists_in_list(REG_ALL_DEP,D)=false}%f_add_to_list(REG_ALL_DEP,D)]\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%D
 begin
  OBJECT IN %D
  if ( ( %D |e ) %==  false AND 
   ( ( %D get_up ( 'old gcm' ) ) %!=  true  ) AND 
   ( ( %D |S ) %!= 'Requirements'  ) AND 
   ( ( %D |S ) %!= 'KCustomize'  ) ) then
  begin
   if ( ( [%f] exists_in_list %( 'REG_ALL_DEP' %, 'D' )% ) %==  false ) then
   begin
    [%f] add_to_list %( 'REG_ALL_DEP' %, 'D' )% 
   end // if
//	[{%DS=ServerLibrary&%t_target_ex(%S)=true}[{%f_exists_in_list(REG_ALL_DEP_SERVER,D)=false}%f_add_to_list(REG_ALL_DEP_SERVER,D)]\
   if ( ( %D |S ) %== 'ServerLibrary' AND 
     ( ( [%t] target_ex %( %S )% ) %==  true  ) ) then
   begin
    if ( ( [%f] exists_in_list %( 'REG_ALL_DEP_SERVER' %, 'D' )% ) %==  false ) then
    begin
     [%f] add_to_list %( 'REG_ALL_DEP_SERVER' %, 'D' )% 
    end // if
//	][{%DS!=ServerLibrary|%t_target_ex(%S)=true}%f_collect_reg_all_dep_java(%D)]>
   end // if
   if ( ( %D |S ) %!= 'ServerLibrary' OR 
     ( ( [%t] target_ex %( %S )% ) %==  true  ) ) then
   begin
    [%f] collect_reg_all_dep_java %( %D )% 
   end // if

   ++! l_Counter
  end // if
 end // for D
//#UC END# *4714E24D030D*
; // collect_reg_all_dep_java


// генерация акцессоров
//f _self_data_accessor
: self_data_accessor OBJECT IN %S
//#UC START# *4714E25C0119*
//	[{%XU=h}[
 if ( ( %X |U ) %== 'h' ) then
 begin
  if NOT-EMPTY
  begin
   #13#10

//	//////////////////////////////////////////////////////////////////////////////////////////
   '//////////////////////////////////////////////////////////////////////////////////////////'
//	// self data accessors
   '// self data accessors'
//	%f_collect_implemented_attrs(%S,"SERV_OPS")\
   [%f] collect_implemented_attrs %( %S %, 'SERV_OPS' )% 
//	[public:<{}{%f_can_be_accessed(%C)=true&%CV=PublicAccess&%t_is_static_accessor(%C)!=true}{Sn}[
   if NOT-EMPTY
   begin
    'public:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PublicAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_h(%C,"SERV_OPS")
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_h %( %C %, 'SERV_OPS' )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_h(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_h %( %C )% 
//	]]>][protected:<{}{%f_can_be_accessed(%C)=true&%CV=ProtectedAccess&%t_is_static_accessor(%C)!=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    'protected:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'ProtectedAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_h(%C,"SERV_OPS")
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_h %( %C %, 'SERV_OPS' )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_h(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_h %( %C )% 
//	]]>][private:<{}{%f_can_be_accessed(%C)=true&%CV=PrivateAccess&%t_is_static_accessor(%C)!=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    'private:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PrivateAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_h(%C,"SERV_OPS")
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_h %( %C %, 'SERV_OPS' )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_h(%C,"SERV_OPS")
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_h %( %C %, 'SERV_OPS' )% 
//	]]>]]][{%XU=cpp|%XU=i.h}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
  end // if
  NOP
 end // if
 if ( ( %X |U ) %== 'cpp' OR 
   ( ( %X |U ) %== 'i.h'  ) ) then
 begin
  if NOT-EMPTY
  begin
   #13#10

//	//////////////////////////////////////////////////////////////////////////////////////////
   '//////////////////////////////////////////////////////////////////////////////////////////'
//	// self data accessors
   '// self data accessors'
//	%f_collect_implemented_attrs(%S,"SERV_OPS")\
   [%f] collect_implemented_attrs %( %S %, 'SERV_OPS' )% 
//	[<{}{%f_can_be_accessed(%C)=true&%CV=PublicAccess&%t_is_static_accessor(%C)!=true}{Sn}[
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PublicAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_cpp(%C,"SERV_OPS")
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_cpp %( %C %, 'SERV_OPS' )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_cpp(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_cpp %( %C )% 
//	]]>][<{}{%f_can_be_accessed(%C)=true&%CV=ProtectedAccess&%t_is_static_accessor(%C)!=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'ProtectedAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_cpp(%C,"SERV_OPS")
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_cpp %( %C %, 'SERV_OPS' )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_cpp(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_cpp %( %C )% 
//	]]>][<{}{%f_can_be_accessed(%C)=true&%CV=PrivateAccess&%t_is_static_accessor(%C)!=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PrivateAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_cpp(%C,"SERV_OPS")
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_cpp %( %C %, 'SERV_OPS' )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_cpp(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_cpp %( %C )% 
//	]]>]]][{%XU=java}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
  end // if
  NOP
 end // if
 if ( ( %X |U ) %== 'java' ) then
 begin
  if NOT-EMPTY
  begin
   #13#10

//	#	//////////////////////////////////////////////////////////////////////////////////////////
   out_indent '	//////////////////////////////////////////////////////////////////////////////////////////'
//	#	// self data accessors
   out_indent '	// self data accessors'
//	[<{}{%f_can_be_accessed(%C)=true&%CV=PublicAccess&%t_is_static_accessor(%C)!=true}{Sn}[
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PublicAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_java(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_java %( %C )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_java(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_java %( %C )% 
//	]]>][<{}{%f_can_be_accessed(%C)=true&%CV=ProtectedAccess&%t_is_static_accessor(%C)!=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'ProtectedAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_java(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_java %( %C )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_java(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_java %( %C )% 
//	]]>][<{}{%f_can_be_accessed(%C)=true&%CV=PrivateAccess&%t_is_static_accessor(%C)!=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PrivateAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %!=  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_java(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_java %( %C )% 
//	][{%t_need_rw(%C)=true}[{%t_need_ro(%C)=true}\n]%f_write_accessor_java(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        if ( ( [%t] need_ro %( %C )% ) %==  true ) then
        begin
         #13#10 
        end // if
        [%f] write_accessor_java %( %C )% 
//	]]>]]]
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
  end // if
  NOP
 end // if

//f _static_data_accessor
; // self_data_accessor

: static_data_accessor OBJECT IN %S
//	[{%XU=h}[
 if ( ( %X |U ) %== 'h' ) then
 begin
  if NOT-EMPTY
  begin
   #13#10

//	//////////////////////////////////////////////////////////////////////////////////////////
   '//////////////////////////////////////////////////////////////////////////////////////////'
//	// static data accessors
   '// static data accessors'
//	[public:<{}{%f_can_be_accessed(%C)=true&%CV=PublicAccess&%t_is_static_accessor(%C)=true}{Sn}[
   if NOT-EMPTY
   begin
    'public:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PublicAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_h(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_h %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_h(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_h %( %C )% 
//	]]>][protected:<{}{%f_can_be_accessed(%C)=true&%CV=ProtectedAccess&%t_is_static_accessor(%C)=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    'protected:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'ProtectedAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_h(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_h %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_h(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_h %( %C )% 
//	]]>][private:<{}{%f_can_be_accessed(%C)=true&%CV=PrivateAccess&%t_is_static_accessor(%C)=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    'private:'
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PrivateAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_h(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_h %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_h(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_h %( %C )% 
//	]]>]]][{%XU=cpp|%XU=i.h}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
  end // if
  NOP
 end // if
 if ( ( %X |U ) %== 'cpp' OR 
   ( ( %X |U ) %== 'i.h'  ) ) then
 begin
  if NOT-EMPTY
  begin
   #13#10

//	//////////////////////////////////////////////////////////////////////////////////////////
   '//////////////////////////////////////////////////////////////////////////////////////////'
//	// static data accessors
   '// static data accessors'
//	[<{}{%f_can_be_accessed(%C)=true&%CV=PublicAccess&%t_is_static_accessor(%C)=true}{Sn}[
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PublicAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_cpp(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_cpp %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_cpp(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_cpp %( %C )% 
//	]]>][<{}{%f_can_be_accessed(%C)=true&%CV=ProtectedAccess&%t_is_static_accessor(%C)=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'ProtectedAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_cpp(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_cpp %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_cpp(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_cpp %( %C )% 
//	]]>][<{}{%f_can_be_accessed(%C)=true&%CV=PrivateAccess&%t_is_static_accessor(%C)=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PrivateAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_cpp(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_cpp %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_cpp(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_cpp %( %C )% 
//	]]>]]][{%XU=java}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
  end // if
  NOP
 end // if
 if ( ( %X |U ) %== 'java' ) then
 begin
  if NOT-EMPTY
  begin
   #13#10

//	#	//////////////////////////////////////////////////////////////////////////////////////////
   out_indent '	//////////////////////////////////////////////////////////////////////////////////////////'
//	#	// static data accessors
   out_indent '	// static data accessors'
//	[<{}{%f_can_be_accessed(%C)=true&%CV=PublicAccess&%t_is_static_accessor(%C)=true}{Sn}[
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PublicAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_java(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_java %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_java(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_java %( %C )% 
//	]]>][<{}{%f_can_be_accessed(%C)=true&%CV=ProtectedAccess&%t_is_static_accessor(%C)=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'ProtectedAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_java(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_java %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_java(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_java %( %C )% 
//	]]>][<{}{%f_can_be_accessed(%C)=true&%CV=PrivateAccess&%t_is_static_accessor(%C)=true}{Sn}[
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%Cn
    begin
     OBJECT IN %C
     if ( ( [%f] can_be_accessed %( %C )% ) %==  true AND 
      ( ( %C |V ) %== 'PrivateAccess'  ) AND 
      ( ( [%t] is_static_accessor %( %C )% ) %==  true  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	[{%t_need_ro(%C)=true}%f_read_accessor_java(%C)
       if ( ( [%t] need_ro %( %C )% ) %==  true ) then
       begin
        [%f] read_accessor_java %( %C )% 
//	][{%t_need_rw(%C)=true}%f_write_accessor_java(%C)
       end // if
       if ( ( [%t] need_rw %( %C )% ) %==  true ) then
       begin
        [%f] write_accessor_java %( %C )% 
//	]]>]]]
       end // if
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
  end // if
  NOP
 end // if

//f _read_accessor_java1
; // static_data_accessor

: read_accessor_java1 OBJECT IN %S
//	#final %t_visibility(%S)[{%SS=static}static ]%f_attr(%S) %f_to_java(get_%SN) () {
 out_indent 'final '
 [%t] visibility %( %S )% if ( ( %S |S ) %== 'static' ) then
 begin
  'static ' 
 end // if
 [%f] attr %( %S )% ' '
 [%f] to_java %( 'get_'
 %S |N )% ' () {'
//	#	%U[{_GET_ACCESSOR}
 out_indent '	'
 %Usersection (
  '_GET_ACCESSOR' 
 )
 (
  #13#10

//	#	return %f_to_java([{%SS=static}s_]%SN)_;
  out_indent '	return '
  [%f] to_java %( if ( ( %S |S ) %== 'static' ) then
  begin
   's_' 
  end // if
  %S |N )% '_;'
//	#	]
  out_indent '	' 
 ) // Usersection
 //	#}
 out_indent '}'

//f _write_accessor_java1
; // read_accessor_java1

: write_accessor_java1 OBJECT IN %S
//	#final %t_visibility(%S)[{%SS=static}static ]void %f_to_java(set_%SN) (final %f_attr(%S) %f_to_java(%SN)) {
 out_indent 'final '
 [%t] visibility %( %S )% if ( ( %S |S ) %== 'static' ) then
 begin
  'static ' 
 end // if
 'void '
 [%f] to_java %( 'set_'
 %S |N )% ' (final '
 [%f] attr %( %S )% ' '
 [%f] to_java %( %S |N )% ') {'
//	#	%U[{_SET_ACCESSOR}
 out_indent '	'
 %Usersection (
  '_SET_ACCESSOR' 
 )
 (
  #13#10

//	#	%f_to_java([{%SS=static}s_]%SN)_ = %f_to_java(%SN);
  out_indent '	'
  [%f] to_java %( if ( ( %S |S ) %== 'static' ) then
  begin
   's_' 
  end // if
  %S |N )% '_ = '
  [%f] to_java %( %S |N )% ';'
//	#	]
  out_indent '	' 
 ) // Usersection
 //	#}
 out_indent '}'
//#UC END# *4714E25C0119*
; // write_accessor_java1


// выводит полное имя элемента (с учетом нэймспейсов)
//f _full_name
: full_name OBJECT IN %S
//#UC START# *4714E28A0251*
//	<{}{%P{is namespace}=true}{r}%PN::>%SN
 INTEGER VAR l_Counter l_Counter := 0
 for downto %S%P
 begin
  OBJECT IN %P
  if ( ( %P get_up ( 'is namespace' ) ) %==  true ) then
  begin
   %P |N '::' 
   ++! l_Counter
  end // if
 end // for P
 %S |N 
//#UC END# *4714E28A0251*
; // full_name


// что-то не понятно, используется при выводе элементов, которые используют данный
//f _is_rg_derived
: is_rg_derived OBJECT IN %S
//#UC START# *4714E2F80109*
//	%f_set_var(TEMP_ARG,1)[{<{}{%GU=%{TEMP_ARG}U}{C}>!=0|<{}{%RU=%{TEMP_ARG}U}{C}>!=0}{false}true]
 [%f] set_var %( 'TEMP_ARG' %, 1 )% if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if ( ( %G |U ) %== ( ( get_global_var ( 'TEMP_ARG' ) |U ) ) ) then
   begin

    ++! l_Counter
   end // if
  end // for G
  l_Counter
  %!= 0 OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( %R |U ) %== ( ( get_global_var ( 'TEMP_ARG' ) |U ) ) ) then
   begin

    ++! l_Counter
   end // if
  end // for R
  l_Counter
  %!= 0  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4714E2F80109*
; // is_rg_derived


// фукнция сравнивает output-файл элемента и его родителя, если они совпадают вызывает f_error
//f _output_constraint
: output_constraint OBJECT IN %S
//#UC START# *4714E300004E*
//	[{%So=%Po&"%So"!=""}%f_error("Error, because output file for element \<\<%SS\>\>%SN is equal to output file his parent (\<\<%PS\>\>%SN)")]
 if ( ( %S |o ) %== ( %P |o ) AND 
   ( ( %S |o ) %!= ''  ) ) then
 begin
  [%f] error %( 'Error' %, ' because output file for element <<'
  %S |S '>>'
  %S |N ' is equal to output file his parent (<<'
  %P |S '>>'
  %S |N ')' )% 
 end // if
//#UC END# *4714E300004E*
; // output_constraint


// выводит относительный путь до рутовой папки проекта
//f _root_relative_path
: root_relative_path OBJECT IN %S
//#UC START# *4714E312032C*
//	%f_clear_list(ROOT_RELATIVE_PATH)\
 [%f] clear_list %( 'ROOT_RELATIVE_PATH' )% 
//	%f_split_to_list(ROOT_RELATIVE_PATH,%Sd,/)\
 [%f] split_to_list %( 'ROOT_RELATIVE_PATH' %, %S |d %, '/' )% 
//	<{}{%f_is_empty(ROOT_RELATIVE_PATH)=false}{W}%f_pop_first_to_var(ROOT_RELATIVE_PATH,PATH_ITEM)%f_str_replace(%{PATH_ITEM}N,%{PATH_ITEM}N,../)>%f_clear_list(ROOT_RELATIVE_PATH)
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'ROOT_RELATIVE_PATH' )% ) %==  false ) then
  begin
   [%f] pop_first_to_var %( 'ROOT_RELATIVE_PATH' %, 'PATH_ITEM' )% [%f] str_replace %( ( get_global_var ( 'PATH_ITEM' ) |N ) %, ( get_global_var ( 'PATH_ITEM' ) |N ) %, '../' )% 
   ++! l_Counter
  end // if
  else
   break
 end // while
 [%f] clear_list %( 'ROOT_RELATIVE_PATH' )% 
//#UC END# *4714E312032C*
; // root_relative_path


// проверяет совпадает ли имя типа с заданным, с учетом, что тип может быть получен как typedef
//f _check_if_type
: check_if_type OBJECT IN %S
//#UC START# *4715E8B102CE*
//	[{"%SN"="%1N"|"%SM"="Typedef::Class"&"%S[%GN]"="%1N"}{false}true]
 if ( ( %S |N ) %== ( %1 |N ) OR 
   ( ( %S |M ) %== 'Typedef::Class'  ) AND 
   ( ( %S
  bind ( 
   OBJECT VAR %S
   if NOT-EMPTY
   begin
    %G |N 
   end // if
   NOP

  ) // bind
 )   %== ( %1 |N )  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4715E8B102CE*
; // check_if_type


// используется для преобразования в булевый тип результата сравнения строк (функци string_cmp)
//f _true
: true OBJECT IN %S
//#UC START# *4715E8F701A5*
//	[{%SN=1}{false}true]
 if ( ( %S |N ) %== 1 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4715E8F701A5*
; // true


// возвращает true, если элемент реализует более одного серверного фасета или интерфейса
//f _realize_more_than_one_facet
: realize_more_than_one_facet OBJECT IN %S
//#UC START# *4716ED3F0203*
//	[{<{}{%RS=ServerFacet|%RS=ServerInterface}{C}>!=0&<{}{%RS=ServerFacet|%RS=ServerInterface}{C}>!=1}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( %R |S ) %== 'ServerFacet' OR 
    ( ( %R |S ) %== 'ServerInterface'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for R
  l_Counter
  %!= 0 AND 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( %R |S ) %== 'ServerFacet' OR 
    ( ( %R |S ) %== 'ServerInterface'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for R
  l_Counter
  %!= 1  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4716ED3F0203*
; // realize_more_than_one_facet


// возвращает true, если элемент является сервантом или симпл-классом
//f _servant_or_simpleclass
: servant_or_simpleclass OBJECT IN %S
//#UC START# *4716EDD70271*
//	[{%SS=Servant|%S#f_IsSimpleClass()=true}{false}true]
 if ( ( %S |S ) %== 'Servant' OR 
   ( ( %S %?f IsSimpleClass %( )% ) %==  true  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4716EDD70271*
; // servant_or_simpleclass


// префикс IDL
//f _idl_prefix
: idl_prefix OBJECT IN %S
//#UC START# *47189F5B02FD*
//	garant.ru
 'garant.ru'
//#UC END# *47189F5B02FD*
; // idl_prefix


// дампит спец. дефайны для IDL-файлов
//f _idl_pre_include
: idl_pre_include OBJECT IN %S
//#UC START# *47189F7402AF*
//	\#define CORBA3
 '#define CORBA3'
//#UC END# *47189F7402AF*
; // idl_pre_include


// начало тела функции
//f _start_func_cpp
: start_func_cpp OBJECT IN %S
//#UC START# *47189F8001A5*
//	[{"%S{debug log}"="true"|"%P{debug log}"="true"}\n\tLOG_D (("%1N"));]
 if ( ( %S get_up ( 'debug log' ) ) %== true OR 
   ( ( %P get_up ( 'debug log' ) ) %== true  ) ) then
 begin
  #13#10#9'LOG_D (("'
  %1 |N '));' 
 end // if
//#UC END# *47189F8001A5*
; // start_func_cpp


// конец тела функции
//f _end_func_cpp
: end_func_cpp OBJECT IN %S
//#UC START# *47189F89008C*
//#UC END# *47189F89008C*
; // end_func_cpp


// проверяет использованность элемента
//f _is_used
: is_used OBJECT IN %S
//#UC START# *4721B2480203*
//	[{%M{force usage}=false&%S{force usage}=false&%ax=false}{true}false]
 if ( ( %M get_up ( 'force usage' ) ) %==  false AND 
   ( ( %S get_up ( 'force usage' ) ) %==  false  ) AND 
   ( ( %a |x ) %==  false  ) ) then
 begin
   false 
 end // if
 else
 begin
   true 
 end // else
//#UC END# *4721B2480203*
; // is_used


// Заголовок - шапка для h-файлов
//f _h_header
: h_header OBJECT IN %S
//#UC START# *47382FE9009C*
//	%f_header(%S)
 [%f] header %( %S )% 
//	%f_set_var(DEFINE,"%f_str_replace(%f_get_define(%S), ,_)")\
 [%f] set_var %( 'DEFINE' %, [%f] str_replace %( [%f] get_define %( %S )% %, ' ' %, '_' )% )% 
//	\#ifndef %{DEFINE}N
 '#ifndef '
 ( get_global_var ( 'DEFINE' ) |N ) 
//	\#define %{DEFINE}N
 '#define '
 ( get_global_var ( 'DEFINE' ) |N ) 
//	%f_set_var(DEFINE,"")
 [%f] set_var %( 'DEFINE' %, '' )% 

//f _get_define
; // h_header

: get_define OBJECT IN %S
//	__<{_}{"%Pr"="true"&"%P#f_IsProjectGroup()"!="true"}{r}%f_to_upper(%PN)>_%f_to_upper(%SN)_%X{ifdef_suffix}__
 '__'
 INTEGER VAR l_Counter l_Counter := 0
 for downto %S%P
 begin
  OBJECT IN %P
  if ( ( %P |r ) %== true AND 
   ( ( %P %?f IsProjectGroup %( )% ) %!= true  ) ) then
  begin
   if ( l_Counter >0 ) then ( '_' )
   [%f] to_upper %( %P |N )% 
   ++! l_Counter
  end // if
 end // for P
 '_'
 [%f] to_upper %( %S |N )% '_'
 %X get_up ( 'ifdef_suffix' ) '__'
//#UC END# *47382FE9009C*
; // get_define


// финальная часть h-файлов
//f _h_footer
: h_footer OBJECT IN %S
//#UC START# *47382FF701E4*
//	[
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]\
  %S %f close_ifdef %( )% 
 end // if
 NOP
//	%f_set_var(DEFINE,"%f_str_replace(%f_get_define(%S), ,_)")\
 [%f] set_var %( 'DEFINE' %, [%f] str_replace %( [%f] get_define %( %S )% %, ' ' %, '_' )% )% 
//	\n\#endif //%{DEFINE}N
 #13#10'#endif //'
 ( get_global_var ( 'DEFINE' ) |N ) 
//	%f_footer(%S,"false")%f_set_var(DEFINE,"")
 [%f] footer %( %S %, false )% [%f] set_var %( 'DEFINE' %, '' )% 
//#UC END# *47382FF701E4*
; // h_footer


// сортирует список строк по длине:
// %f_sort_strings_by_length(%S,"LIST_ID"), где LIST_ID - идентификатор списка строк
//f _sort_strings_by_length
: sort_strings_by_length OBJECT IN %S
//#UC START# *48A16F79022A*
//определяем максимальное число разрядов в числе = длине строки элемента списка
//например для списка "abcd", "abcdefgadfer" MAX_LEN = 2 (str_length(str_length"abcdefgadfer")))
//	%f_set_var(MAX_LEN,"0")\
 [%f] set_var %( 'MAX_LEN' %, 0 )% 
//	%f_clear_list(TEMP_SORT_STRINGS_BY_LENGTH)\
 [%f] clear_list %( 'TEMP_SORT_STRINGS_BY_LENGTH' )% 
//	%f_copy_list(%1N,TEMP_SORT_STRINGS_BY_LENGTH)\
 [%f] copy_list %( %1 |N %, 'TEMP_SORT_STRINGS_BY_LENGTH' )% 
//	<{}{%f_is_empty(TEMP_SORT_STRINGS_BY_LENGTH)=false}{W}[%f_pop_first_to_var(TEMP_SORT_STRINGS_BY_LENGTH,ITEM)\
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'TEMP_SORT_STRINGS_BY_LENGTH' )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( 'TEMP_SORT_STRINGS_BY_LENGTH' %, 'ITEM' )% 
//	[{%f_number_cmp("%{MAX_LEN}N","%f_string_length(%f_string_length(%{ITEM}N))","\<")=1}%f_set_var(MAX_LEN,"%f_string_length(%f_string_length(%{ITEM}N))")]]>\
    if ( ( [%f] number_cmp %( ( get_global_var ( 'MAX_LEN' ) |N ) %, [%f] string_length %( [%f] string_length %( ( get_global_var ( 'ITEM' ) |N ) )% )% %, '<' )% ) %== 1 ) then
    begin
     [%f] set_var %( 'MAX_LEN' %, [%f] string_length %( [%f] string_length %( ( get_global_var ( 'ITEM' ) |N ) )% )% )% 
    end // if
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//	%f_sort_list(%1N,"%f_formated_len(%S,"%{MAX_LEN}N")")
 [%f] sort_list %( %1 |N %, [%f] formated_len %( %S %, ( get_global_var ( 'MAX_LEN' ) |N ) )% )% 

//"добивает" слева число, записанное в виде строки нулями, чтобы длина получившеёся строки была равна %1N
//f _formated_len
; // sort_strings_by_length

: formated_len OBJECT IN %S
//	%f_set_var(KEY_LEN,"%f_string_length(%f_string_length(%SN))")\
 [%f] set_var %( 'KEY_LEN' %, [%f] string_length %( [%f] string_length %( %S |N )% )% )% 
//	%f_set_var(INDEX,"%f_evaluate(%1N - %{KEY_LEN}N)")\
 [%f] set_var %( 'INDEX' %, [%f] evaluate %( %1 |N ' - '
 ( get_global_var ( 'KEY_LEN' ) |N ) )% )% 
//	<{}{%f_number_cmp("%{INDEX}N","0","\>")=1}{W}%f_dump_0(%S)%f_set_var(INDEX,"%f_evaluate(%{INDEX}N - 1)")>%f_string_length(%SN)
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] number_cmp %( ( get_global_var ( 'INDEX' ) |N ) %, 0 %, '>' )% ) %== 1 ) then
  begin
   [%f] dump_0 %( %S )% [%f] set_var %( 'INDEX' %, [%f] evaluate %( ( get_global_var ( 'INDEX' ) |N ) ' - 1' )% )% 
   ++! l_Counter
  end // if
  else
   break
 end // while
 [%f] string_length %( %S |N )% 
//#UC END# *48A16F79022A*
; // formated_len


// сортирует список чисел, представленых в виде строк (т.е "1","2","3"):
// %fsort_strings_as_integer(%S,"LIST_ID"), где LIST_ID - идентификатор списка, который нужно
// отсортировать
//f _sort_strings_as_integer
: sort_strings_as_integer OBJECT IN %S
//#UC START# *48A16FD003A9*
//разбиваем исходный список на 2: один содержащем положиетльные только положительные числа, другой - только отрицательные
//	%f_clear_list(POSITIVE)\
 [%f] clear_list %( 'POSITIVE' )% 
//	%f_clear_list(NEGATIVE)\
 [%f] clear_list %( 'NEGATIVE' )% 
//	<{}{%f_is_empty(%1N)=false}{W}[%f_pop_first_to_var(%1N,ITEM)\
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( %1 |N )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( %1 |N %, 'ITEM' )% 
//	[{%f_number_cmp("%{ITEM}N","0","\<")=1}{%f_add_to_list(POSITIVE,"%{ITEM}N")}%f_add_to_list(NEGATIVE,"%f_str_replace(%{ITEM}N,-,)")]]>\
    if ( ( [%f] number_cmp %( ( get_global_var ( 'ITEM' ) |N ) %, 0 %, '<' )% ) %== 1 ) then
    begin
     [%f] add_to_list %( 'NEGATIVE' %, [%f] str_replace %( ( get_global_var ( 'ITEM' ) |N ) %, '-' %, )% )% 
    end // if
    else
    begin
     [%f] add_to_list %( 'POSITIVE' %, ( get_global_var ( 'ITEM' ) |N ) )% 
    end // else
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//соритурем два полученных списка
//	%f_sort_strings_as_unsigned_integer_impl(%S,"POSITIVE")\
 [%f] sort_strings_as_unsigned_integer_impl %( %S %, 'POSITIVE' )% 
//	%f_sort_strings_as_unsigned_integer_impl(%S,"NEGATIVE")\
 [%f] sort_strings_as_unsigned_integer_impl %( %S %, 'NEGATIVE' )% 
//	%f_dump_list(%S,"NEGATIVE")
//сливаем их в исходный список
//	%f_clear_list(%1N)\
 [%f] clear_list %( %1 |N )% 
//	<{}{%f_is_empty(NEGATIVE)=false}{W}[%f_pop_last_to_var(NEGATIVE,ITEM)%f_add_to_list(%1N,"-%{ITEM}N")]>\
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'NEGATIVE' )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_last_to_var %( 'NEGATIVE' %, 'ITEM' )% [%f] add_to_list %( %1 |N %, '-'
    ( get_global_var ( 'ITEM' ) |N ) )% 
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//	<{}{%f_is_empty(POSITIVE)=false}{W}[%f_pop_first_to_var(POSITIVE,ITEM)%f_add_to_list(%1N,"%{ITEM}N")]>
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'POSITIVE' )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( 'POSITIVE' %, 'ITEM' )% [%f] add_to_list %( %1 |N %, ( get_global_var ( 'ITEM' ) |N ) )% 
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//	%f_dump_list(%S,"%1N")

//f _sort_strings_as_unsigned_integer_impl
; // sort_strings_as_integer

: sort_strings_as_unsigned_integer_impl OBJECT IN %S
//	%f_set_var(MAX_LEN,"0")\
 [%f] set_var %( 'MAX_LEN' %, 0 )% 
//	%f_clear_list(TEMP_SORT_STRINGS_AS_UNSIGNED_INTEGER_IMPL)\
 [%f] clear_list %( 'TEMP_SORT_STRINGS_AS_UNSIGNED_INTEGER_IMPL' )% 
//	%f_copy_list(%1N,TEMP_SORT_STRINGS_AS_UNSIGNED_INTEGER_IMPL)\
 [%f] copy_list %( %1 |N %, 'TEMP_SORT_STRINGS_AS_UNSIGNED_INTEGER_IMPL' )% 
//	<{}{%f_is_empty(TEMP_SORT_STRINGS_AS_UNSIGNED_INTEGER_IMPL)=false}{W}[%f_pop_first_to_var(TEMP_SORT_STRINGS_AS_UNSIGNED_INTEGER_IMPL,ITEM)\
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'TEMP_SORT_STRINGS_AS_UNSIGNED_INTEGER_IMPL' )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( 'TEMP_SORT_STRINGS_AS_UNSIGNED_INTEGER_IMPL' %, 'ITEM' )% 
//	[{%f_number_cmp("%{MAX_LEN}N","%f_string_length(%{ITEM}N)","\<")=1}%f_set_var(MAX_LEN,"%f_string_length(%{ITEM}N)")]]>\
    if ( ( [%f] number_cmp %( ( get_global_var ( 'MAX_LEN' ) |N ) %, [%f] string_length %( ( get_global_var ( 'ITEM' ) |N ) )% %, '<' )% ) %== 1 ) then
    begin
     [%f] set_var %( 'MAX_LEN' %, [%f] string_length %( ( get_global_var ( 'ITEM' ) |N ) )% )% 
    end // if
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//	%f_sort_list(%1N,"%f_formated_len_for_uint(%S,"%{MAX_LEN}N")")
 [%f] sort_list %( %1 |N %, [%f] formated_len_for_uint %( %S %, ( get_global_var ( 'MAX_LEN' ) |N ) )% )% 

//f _formated_len_for_uint
; // sort_strings_as_unsigned_integer_impl

: formated_len_for_uint OBJECT IN %S
//	%f_set_var(KEY_LEN,"%f_string_length(%SN)")\
 [%f] set_var %( 'KEY_LEN' %, [%f] string_length %( %S |N )% )% 
//	%f_set_var(INDEX,"%f_evaluate(%1N - %{KEY_LEN}N)")\
 [%f] set_var %( 'INDEX' %, [%f] evaluate %( %1 |N ' - '
 ( get_global_var ( 'KEY_LEN' ) |N ) )% )% 
//	<{}{%f_number_cmp("%{INDEX}N","0","\>")=1}{W}%f_dump_0(%S)%f_set_var(INDEX,"%f_evaluate(%{INDEX}N - 1)")>%SN
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] number_cmp %( ( get_global_var ( 'INDEX' ) |N ) %, 0 %, '>' )% ) %== 1 ) then
  begin
   [%f] dump_0 %( %S )% [%f] set_var %( 'INDEX' %, [%f] evaluate %( ( get_global_var ( 'INDEX' ) |N ) ' - 1' )% )% 
   ++! l_Counter
  end // if
  else
   break
 end // while
 %S |N 

//повторяет переданную строку n раз и выводит результат
//например: %f_repeat_str("1","5")
//выведет: 11111
//f _repeat_str
; // formated_len_for_uint

: repeat_str OBJECT IN %S
//	[{%f_number_cmp("%1N","0","\<")=1}%f_error("_repeat_str: repeate count must be positive number")]\
 if ( ( [%f] number_cmp %( %1 |N %, 0 %, '<' )% ) %== 1 ) then
 begin
  [%f] error %( '_repeat_str: repeate count must be positive number' )% 
 end // if
//	%f_set_var(__COUNTER__,"%1N")\
 [%f] set_var %( '__COUNTER__' %, %1 |N )% 
//	<{}{%f_number_cmp("%{__COUNTER__}N","0","\>")=1}{W}%f_set_var(__COUNTER__,"%f_evaluate(%{__COUNTER__}N - 1)")%SN>
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] number_cmp %( ( get_global_var ( '__COUNTER__' ) |N ) %, 0 %, '>' )% ) %== 1 ) then
  begin
   [%f] set_var %( '__COUNTER__' %, [%f] evaluate %( ( get_global_var ( '__COUNTER__' ) |N ) ' - 1' )% )% %S |N 
   ++! l_Counter
  end // if
  else
   break
 end // while
//#UC END# *48A16FD003A9*
; // repeat_str


// Правила преобразования спецификатора параметра для read-only и read-write операций. Для read-
// only все не out параметры преобразуются в in - параметры, для read-write - преобразование не
// выолняется.
//t _r_w_param_specificator
<<transformator>> r_w_param_specificator OBJECT IN %S
//#UC START# *4979637901EB*
//c                   {read-only}         {read-write}
//r "%SN"!="out":     {in}                {[{}{in}%SN]}
//r ""="":            {[{}{in}%SN]}       {[{}{in}%SN]N}
//#UC END# *4979637901EB*
; // r_w_param_specificator


// мержит строки с использованием заданного разделителя (пустые строки, кроме первой исключаются):
// %0 - разделитель
// %1..%9 - строки
// Например результат работы %f_string(":","A","","B") -> A:B
//f _merge_string
: merge_string OBJECT IN %S
//#UC START# *4979935E01C9*
//	%1N[{"%2N"!=""}%0N%2N][{"%3N"!=""}%0N%3N][{"%4N"!=""}%0N%4N][{"%5N"!=""}%0N%5N]\
//	[{"%6N"!=""}%0N%6N][{"%7N"!=""}%0N%8N][{"%9N"!=""}%0N%9N]
//	%f_clear_list(__FUNCTION_ARGS__)\
 [%f] clear_list %( '__FUNCTION_ARGS__' )% 
//	%f_add_to_function_args_list("%1N")\
 [%f] add_to_function_args_list %( %1 |N )% 
//	%f_add_to_function_args_list("%2N")\
 [%f] add_to_function_args_list %( %2 |N )% 
//	%f_add_to_function_args_list("%3N")\
 [%f] add_to_function_args_list %( %3 |N )% 
//	%f_add_to_function_args_list("%4N")\
 [%f] add_to_function_args_list %( %4 |N )% 
//	%f_add_to_function_args_list("%5N")\
 [%f] add_to_function_args_list %( %5 |N )% 
//	%f_add_to_function_args_list("%6N")\
 [%f] add_to_function_args_list %( %6 |N )% 
//	%f_add_to_function_args_list("%7N")\
 [%f] add_to_function_args_list %( %7 |N )% 
//	%f_add_to_function_args_list("%8N")\
 [%f] add_to_function_args_list %( %8 |N )% 
//	%f_add_to_function_args_list("%9N")\
 [%f] add_to_function_args_list %( %9 |N )% 
//	<{%0N}{%f_is_empty(__FUNCTION_ARGS__)=false}{W}[%f_pop_first_to_var(__FUNCTION_ARGS__,__F_ARG__)%{__F_ARG__}N]>\
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( '__FUNCTION_ARGS__' )% ) %==  false ) then
  begin
   if ( l_Counter >0 ) then ( %0 |N )
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( '__FUNCTION_ARGS__' %, '__F_ARG__' )% ( get_global_var ( '__F_ARG__' ) |N ) 
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//	%f_clear_list(__FUNCTION_ARGS__)
 [%f] clear_list %( '__FUNCTION_ARGS__' )% 

//f _add_to_function_args_list
; // merge_string

: add_to_function_args_list OBJECT IN %S
//	[{"%SN"!=""}%f_add_to_list(__FUNCTION_ARGS__,"%SN")]
 if ( ( %S |N ) %!= '' ) then
 begin
  [%f] add_to_list %( '__FUNCTION_ARGS__' %, %S |N )% 
 end // if
//#UC END# *4979935E01C9*
; // add_to_function_args_list


// конвертирует сроку согласну стилю оформления текущего языка
//t _language_style
<<transformator>> language_style OBJECT IN %S
//#UC START# *497993D203D1*
//c                                 {}
//r {%X{lid}=cpp|%X{lid}=idl}:      {%SN}
//r {%X{lid}=java}:                 {%f_to_java(%SN)}
//r {""=""}:                        {%f_to_borland(%SN)}
//#UC END# *497993D203D1*
; // language_style


// Возвращает true если проект использует библиотеку с данными, false в противном случае.
//f _use_db_lib
: use_db_lib OBJECT IN %S
//#UC START# *49B0E76A024C*
//	[{<{}{%dS=Library&%d%f_check_db_data()=true}{C}>!=0}{false}true]]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%d
  begin
   OBJECT IN %d
   if ( ( %d |S ) %== 'Library' AND 
    ( ( %d %f check_db_data %( )% ) %==  true  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for d
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
 ']'
//#UC END# *49B0E76A024C*
; // use_db_lib


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
