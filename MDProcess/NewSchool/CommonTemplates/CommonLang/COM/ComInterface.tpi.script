////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/COM/ComInterface.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::CommonLang::COM::ComInterface
//
// COM-интерфейс
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: ComInterface::Class
implementation @ <<ComInterface>>
//? COM-интерфейс
//< *::Class,*::Category

//= WikiImplClass::Class
//= COM::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//Y code_com_interface.gif
//L code_com_interface
// Параметры визуализации
//$ C 215,215,255
//$ f 10,10,255

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p ThreadingModel=Apartment|Free|Both ? определяет потоковую модель. Возможные значения: "Both" - указывает на то, что класс может выполняться как в МТА, так и в STA, "Free" - указывает, что класс может выполняться только в МТА, "Apartment" - указывает, что класс может выполняться только в STA. Отсутствие ThreadingModel означает, что класс может выполняться только в главном STA. Главный STA определяется как первый STA, который должен быть инициализирован в процессе

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Трансформаторы стереотипа

// возвращает базовый клосс для потоковой модели в заивисмости от установленного свойства:
// CComSingleThreadModel, CComMultiThreadModel
//%t _thread_model
<<transformator>> thread_model OBJECT IN %S
//#UC START# *470F75AA01B5for470F75220177*
//c                                       {}
//r "%S{ThreadingModel}"="Apartment":     {ATL::CComSingleThreadModel}
//r "%S{ThreadingModel}"="Free":	        {ATL::CComMultiThreadModel}
//r "%S{ThreadingModel}"="Both":	        {ATL::CComMultiThreadModel}
//#UC END# *470F75AA01B5for470F75220177*
; // thread_model


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{ThreadingModel}"!="%S{!ThreadingModel}"}%f_up_prefix(%S) *ThreadingModel* = *%S{ThreadingModel}* - определяет потоковую модель. Возможные значения: "Both" - указывает на то, что класс может выполняться как в МТА, так и в STA, "Free" - указывает, что класс может выполняться только в МТА, "Apartment" - указывает, что класс может выполняться только в STA. Отсутствие ThreadingModel означает, что класс может выполняться только в главном STA. Главный STA определяется как первый STA, который должен быть инициализирован в процессе
 ?inherited
 if ( ( %S get_up ( 'ThreadingModel' ) ) %!= ( %S get_up_def ( 'ThreadingModel' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *ThreadingModel* = *'
  %S get_up ( 'ThreadingModel' ) '* - определяет потоковую модель. Возможные значения: "Both" - указывает на то, что класс может выполняться как в МТА, так и в STA, "Free" - указывает, что класс может выполняться только в МТА, "Apartment" - указывает, что класс может выполняться только в STA. Отсутствие ThreadingModel означает, что класс может выполняться только в главном STA. Главный STA определяется как первый STA, который должен быть инициализирован в процессе'
//	]
 end // if


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
; // wiki_up_print

<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for470F75220177*
//c                              {}
//r {<{}{%P{Full MDP}=true}{C}>!=0&<{}{%a#f_IsUseCase()=true}{C}>=0}:	{%SS не используется ни одним прецедентом}
//#UC END# *4704C0E30186for470F75220177*
; // constraint


// реализация абстрактного стереотипа COM::MDAGenerator
// генератор ODL-файла спецификации COM-интерфейса (.odl)
//+ odl
<<generator>> odl OBJECT IN %S
//#UC START# *47032097038Afor470F75220177*
//	#\[
 out_indent '['
//	#	object
 out_indent '	object'
//	#	, uuid (%SG)
 out_indent '	, uuid ('
 %S |G ')'
//	#	, dual
 out_indent '	, dual'
//	#	, helpstring("%SN Interface")
 out_indent '	, helpstring("'
 %S |N ' Interface")'
//	#	, pointer_default(unique)
 out_indent '	, pointer_default(unique)'
//	#\]
 out_indent ']'
//	#interface %SN : [{}{IDispatch}<{, }%f_type(%G)>] {
 out_indent 'interface '
 %S |N ' : '
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] type %( %G )% 
    ++! l_Counter
   end // if
  end // for G
 end // if
 NOP
 else
 begin
  'IDispatch' 
 end // else
 ' {'
//	%U[
 %Usersection (

 )
 (
  #13#10

//	]

 ) // Usersection
 //	#};	
 out_indent '};	'
//	#\[
 out_indent '['
//	#	uuid (%f_str_conv("%SG","%8s-%4s-%4s-%2s%2s-%2s%2s%2s%2s%2s%2s","%8s-%4s-%4s-%2s%2s-%2s%2s%2s%2s%2s")99)
 out_indent '	uuid ('
 [%f] str_conv %( %S |G %, %8 |s '-'
 %4 |s '-'
 %4 |s '-'
 %2 |s %2 |s '-'
 %2 |s %2 |s %2 |s %2 |s %2 |s %2 |s %, %8 |s '-'
 %4 |s '-'
 %4 |s '-'
 %2 |s %2 |s '-'
 %2 |s %2 |s %2 |s %2 |s %2 |s )% '99)'
//	#	, helpstring ("Co%SN Class")
 out_indent '	, helpstring ("Co'
 %S |N ' Class")'
//	#\]
 out_indent ']'
//	#coclass Co%SN {
 out_indent 'coclass Co'
 %S |N ' {'
//	#	\[default\] interface %SN;
 out_indent '	[default] interface '
 %S |N ';'
//	#};\n
 out_indent '};'#13#10
//#UC END# *47032097038Afor470F75220177*
; // odl


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: ComInterface::Class::property::Attribute
end. // <<ComInterface>>

implementation @ :: <<ComInterface>> <<property>> ;
//? атрибут
//= AbstractFacet::Class::property::Attribute

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


//: ComInterface::Class::readonly::Attribute
; // st_space_key

end. // :: <<ComInterface>> <<property>> ;

implementation @ :: <<ComInterface>> <<readonly>> ;
//? Атрибут только для чтения
//? для данного атрибута будет сгенерирован только метод получения его значения. Если тип атрибута интерфейс - то он будет возвращаться как константный.
//= AbstractFacet::Class::readonly::Attribute

// Параметры стереотипа
//e g
// - возможность использовать исключения
//Y code_attr.gif
//L code_attr

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


//: ComInterface::Class::writeonly::Attribute
; // st_space_key

end. // :: <<ComInterface>> <<readonly>> ;

implementation @ :: <<ComInterface>> <<writeonly>> ;
//? Атрибут только для записи
//? для данного атрибута будут сгенерирован только метод установки его значения.
//= AbstractFacet::Class::writeonly::Attribute

// Параметры стереотипа
//e s
// - возможность использовать исключения

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


//: ComInterface::Class::Operation
; // st_space_key

end. // :: <<ComInterface>> <<writeonly>> ;

implementation @ :: <<ComInterface>> <<Operation>> ;
//? Константный метод интерфейса
//? По умолчанию все методы константные. Для того что бы разрешить методу изменять свой объект, необходимо присвуоить ему стереотип <<chg>>. Если используется константный интерфейс, то на нем могут быть вызванны только константные методы.
//= AbstractFacet::Class::Operation

// Параметры стереотипа
//v +
// - типы видимости
//e g
// - возможность использовать исключения
//a a
// - тип абстракции
//Y code_const_method.gif
//L code_const_method
//T 
// - может не иметь "цели" (типа/результата)
//m t
// - может быть реализован/иметь перекрытую реализацию
//A const|cached|const,cached
// - стереотипы "цели" (типа/результата)

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


// Вложенные стереотипы
//: ComInterface::Class::Operation::Parameter
; // st_space_key

end. // :: <<ComInterface>> <<Operation>> ;

implementation @ :: <<ComInterface>> <<Operation>> ;
//? параметр операции
//= AbstractFacet::Class::Operation::Parameter

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



//: ComInterface::Class::friend::ClassDependency
; // st_space_key

end. // :: <<ComInterface>> <<Operation>> ;

implementation @ :: <<ComInterface>> <<friend>> ;
//? Друг
//? Определяет что интерфейс (источник) использует указанный объект (цель) как друг. Т.е. ЦЕЛЬ открывает свои свои скрытые данные и методы ИСТОЧНИКУ.
//? ВНИМАНИЕ!!! ИМЕННО ИСТОЧНИК БУДЕТ ДРУГОМ ЦЕЛИ А НЕ НАООБОРОТ!
//= AbstractFacet::Class::friend::ClassDependency

// Параметры стереотипа
//Y code_dep_friend.gif
//L code_dep_friend

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


//: ComInterface::Class::chg::Operation
; // st_space_key

end. // :: <<ComInterface>> <<friend>> ;

implementation @ :: <<ComInterface>> <<chg>> ;
//? Неконстантный метод
//? Метод который может изменять состояние своего объекта
//= AbstractFacet::Class::chg::Operation

// Параметры стереотипа
//Y code_method.gif
//L code_method

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; // st_space_key

end. // :: <<ComInterface>> <<chg>> ;

