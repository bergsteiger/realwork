////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/Functors/FunctorBase.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::CommonLang::Functors::FunctorBase
//
// Базовый стереотип функтора
// ---
// Определяет функтор (нуль-функтор) без параметров и заданным типом результата
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: FunctorBase::Class
implementation @ <<FunctorBase>>
//? Базовый стереотип функтора
//? Определяет функтор (нуль-функтор) без параметров и заданным типом результата
//< *::Class,*::Category

//= C++ интерфейсы и реализация::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//v +#-
// - типы видимости
//a r
// - тип абстракции
//Y code_functor.gif
//L code_functor
// Параметры визуализации
//$ C 240,205,240
//$ l 120,40,120
//$ f 120,40,120

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p const functor:b=true ? указывает что метод функтора будет сгенерирован как константный
//p force usage:b=false ? явно определяет, что элемент будет кем-то использован (нужно для проверки)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{const functor}"!="%S{!const functor}"}%f_up_prefix(%S) *const functor* = *%S{const functor}* - указывает что метод функтора будет сгенерирован как константный
 ?inherited
 if ( ( %S get_up ( 'const functor' ) ) %!= ( %S get_up_def ( 'const functor' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *const functor* = *'
  %S get_up ( 'const functor' ) '* - указывает что метод функтора будет сгенерирован как константный'
//	][{"%S{force usage}"!="%S{!force usage}"}%f_up_prefix(%S) *force usage* = *%S{force usage}* - явно определяет, что элемент будет кем-то использован (нужно для проверки)
 end // if
 if ( ( %S get_up ( 'force usage' ) ) %!= ( %S get_up_def ( 'force usage' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *force usage* = *'
  %S get_up ( 'force usage' ) '* - явно определяет, что элемент будет кем-то использован (нужно для проверки)'
//	]
 end // if

// дампит базовый класс функтора
//%f _base_decl_h
; // wiki_up_print

: base_decl_h OBJECT IN %S
//#UC START# *486345750387for4713197703A9*
//#UC END# *486345750387for4713197703A9*
; // base_decl_h


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for4713197703A9*
//c                                      {}
//r {%S{force usage}=false&%ax=false}:   {%SS ни кем не используется}
//r {"%f_check_ctor_unique(%S)"!=""}:    {Дублирование конструкторов (конструкторы с такой сигнатурой сгенерятся по атрибутам функтора): %f_check_ctor_unique(%S)}

//f _check_ctor_unique
; // constraint

end. // <<FunctorBase>>

: check_ctor_unique OBJECT IN %S
//	%f_clear_list(ATTRS_CTOR)\
 [%f] clear_list %( 'ATTRS_CTOR' )% 
//	%f_add_to_list(ATTRS_CTOR,"<{, }{%CC=Attribute&"%CS"=""}%C%TU>")\
 [%f] add_to_list %( 'ATTRS_CTOR' %, 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Attribute' AND 
   ( ( %C |S ) %== ''  ) ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C ->T |U  
   ++! l_Counter
  end // if
 end // for C
)% //	%f_remove_from_list(ATTRS_CTOR,"")\
 [%f] remove_from_list %( 'ATTRS_CTOR' %, '' )% 
//	<{, }{%CC=Operation&%CS=ctor}[{%f_exists_in_list(ATTRS_CTOR,"%C<{, }{}%C%TU>")=true}%CN (%C<{, }%CN: %C%TN>)]>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Operation' AND 
   ( ( %C |S ) %== 'ctor'  ) ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   if ( ( [%f] exists_in_list %( 'ATTRS_CTOR' %, %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C ->T |U  
       ++! l_Counter
      end // if
     end // for C

    ) // bind
 )% )     %==  true ) then
   begin
    %C |N ' ('
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |N ': '
       %C ->T |N  
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     ')' 
   end // if

   ++! l_Counter
  end // if
 end // for C
//	%f_clear_list(ATTRS_CTOR)
 [%f] clear_list %( 'ATTRS_CTOR' )% 
//#UC END# *4704C0E30186for4713197703A9*
; // check_ctor_unique


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
implementation @ <<FunctorBase>>
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor4713197703A9*
//#UC END# *4705CBD6003Efor4713197703A9*
; // wiki_child_kind


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for4713197703A9*
//#UC END# *470484D50138for4713197703A9*
; // wiki_up_add_gen


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor4713197703A9*
//P
//	%f_set_var(SERV,S)\
 [%f] set_var %( 'SERV' %, 'S' )% 
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	][%f_functor_impl_body(%S)[{%P#f_IsInterfaces()=true}\n\n]]][
 end // if
 NOP
 if NOT-EMPTY
 begin
  [%f] functor_impl_body %( %S )% if ( ( %P %?f IsInterfaces %( )% ) %==  true ) then
  begin
   #13#10#13#10 
  end // if
 end // if
 NOP
 ']'
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *47022CB8034Bfor4713197703A9*
; // cpp


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor4713197703A9*
//F struct %SN;
//	%f_set_var(SERV,S)\
 [%f] set_var %( 'SERV' %, 'S' )% 
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	][<#%FF
 end // if
 NOP
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%F
  begin
   OBJECT IN %F
   if true then
   begin
    out_indent %F |F 
//	>]%f_docs(%S)\

    ++! l_Counter
   end // if
  end // for F
 end // if
 NOP
 [%f] docs %( %S )% 
//	#struct %SN [%S%f_base_decl_h() ]{
 out_indent 'struct '
 %S |N ' '
 if NOT-EMPTY
 begin
  %S %f base_decl_h %( )% ' ' 
 end // if
 NOP
 '{'
//	#	%t_functor_ret(%S) operator () %t_functor_functor(%S);
 out_indent '	'
 [%t] functor_ret %( %S )% ' operator () '
 [%t] functor_functor %( %S )% ';'
//	%f_h_dump_def_init_ctor(%S)[{<{}{%CC=Attribute&"%CS"=""}{C}>!=0}
 [%f] h_dump_def_init_ctor %( %S )% if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Attribute' AND 
    ( ( %C |S ) %== ''  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
  #13#10

//	#	%SN (<{, }{%CC=Attribute&"%CS"=""}%t_arg(%C%T,"%f_get_arg_specifier(%C)") %CN_>);
  out_indent '	'
  %S |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Attribute' AND 
    ( ( %C |S ) %== ''  ) ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%t] arg %( %C ->T  %, [%f] get_arg_specifier %( %C )% )% ' '
    %C |N '_' 
    ++! l_Counter
   end // if
  end // for C
  ');'
//	]<{}{%CC=Operation&%CS=ctor}
 end // if
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Operation' AND 
   ( ( %C |S ) %== 'ctor'  ) ) then
  begin
   #13#10

//	%CX
   %C |X 
//	><{}{%CC=Attribute&"%CS"=""&%CV=PublicAccess}

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Attribute' AND 
   ( ( %C |S ) %== ''  ) AND 
   ( ( %C |V ) %== 'PublicAccess'  ) ) then
  begin
   #13#10

//	%f_docs(%C)\
   [%f] docs %( %C )% 
//	#	%f_attr(%C) [{}{%f_to_omg(%C%TN)}%CN];
   out_indent '	'
   [%f] attr %( %C )% ' '
   if NOT-EMPTY
   begin
    %C |N 
   end // if
   NOP
   else
   begin
    [%f] to_omg %( %C ->T |N  )% 
   end // else
   ';'
//	>[

   ++! l_Counter
  end // if
 end // for C
 if NOT-EMPTY
 begin
  #13#10

//	private:
  'private:'
//	<{}{%CC=Attribute&"%CS"=""&%CV=PrivateAccess}%f_docs(%C)\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Attribute' AND 
    ( ( %C |S ) %== ''  ) AND 
    ( ( %C |V ) %== 'PrivateAccess'  ) ) then
   begin
    [%f] docs %( %C )% 
//	#	%f_attr(%C) [{}{%f_to_omg(%C%TN)}%CN];
    out_indent '	'
    [%f] attr %( %C )% ' '
    if NOT-EMPTY
    begin
     %C |N 
    end // if
    NOP
    else
    begin
     [%f] to_omg %( %C ->T |N  )% 
    end // else
    ';'
//	>]#};[

    ++! l_Counter
   end // if
  end // for C
 end // if
 NOP
 out_indent '};'
 if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP

//f _get_arg_specifier
; // h

end. // <<FunctorBase>>

: get_arg_specifier OBJECT IN %S
//	[{%Sl=lnk}{in}%t_get_arg_specifier(%S)]
 if ( ( %S |l ) %== 'lnk' ) then
 begin
  [%t] get_arg_specifier %( %S )% 
 end // if
 else
 begin
  'in' 
 end // else

//t _get_arg_specifier
; // get_arg_specifier

<<transformator>> get_arg_specifier OBJECT IN %S
//c                                                                                                                           {}
//r {"%f_prefix(%t_arg(%T,"in"),const)"="const"&"%f_suffix(%t_arg(%T,"in"),%f_dump_apersand(%S))"="%f_dump_apersand(%S)"}:    {[{%Ss=const}{inout}in]}
//r {"%f_prefix(%t_arg(%T,"in"),const)"="const"&"%f_suffix(%t_arg(%T,"in"),*)"="*"}:                                          {[{%Ss=const}{inout}in]}
//r {""=""}:                                                                                                                  {in}

//f _dump_apersand
; // get_arg_specifier

: dump_apersand OBJECT IN %S
//	&
 '&'
//#UC END# *47022C88029Ffor4713197703A9*
; // dump_apersand


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор inline файлов реализации C++ (.i.h)
//+ i.h
implementation @ <<FunctorBase>>
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor4713197703A9*
//P
//	[%f_functor_impl_body(%S)]
 if NOT-EMPTY
 begin
  [%f] functor_impl_body %( %S )% 
 end // if
 NOP
//#UC END# *47022CCF00EAfor4713197703A9*
; // i.h


// реализация абстрактного стереотипа Документация::MDAGenerator
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for4713197703A9*
//G %PU
//#UC END# *46E6D4BB0339for4713197703A9*
; // wiki


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: FunctorBase::Class::Attribute
end. // <<FunctorBase>>

implementation @ :: <<FunctorBase>> <<Attribute>> ;
//? Атрибут данных
// Параметры стереотипа
//v -+
// - типы видимости
//Y code_attr.gif
//L code_attr
//A const
// - стереотипы "цели" (типа/результата)
//l alr
// - возможные типы связи атрибута

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for4713261D0109*
//#UC END# *46E6D4BB0339for4713261D0109*
; // wiki


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor4713261D0109*
//#UC END# *47022C88029Ffor4713261D0109*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor4713261D0109*
//#UC END# *47022CB8034Bfor4713261D0109*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor4713261D0109*
//#UC END# *47022CCF00EAfor4713261D0109*
; // i.h


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


//: FunctorBase::Class::uses::ClassDependency
; // st_space_key

end. // :: <<FunctorBase>> <<Attribute>> ;

implementation @ :: <<FunctorBase>> <<uses>> ;
//? Использование
//? Определяет что источник использует указанный объект (цель) каким-либо образом.
//? На основе данной связи будет сгенерированы пути включения файлов используемого объекта.
// Параметры стереотипа
//Y code_dep_uses.gif
//L code_dep_uses

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for471326540280*
//#UC END# *46E6D4BB0339for471326540280*
; // wiki


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor471326540280*
//#UC END# *47022C88029Ffor471326540280*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor471326540280*
//#UC END# *47022CB8034Bfor471326540280*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor471326540280*
//#UC END# *47022CCF00EAfor471326540280*
; // i.h


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


//: FunctorBase::Class::ctor::Operation
; // st_space_key

end. // :: <<FunctorBase>> <<uses>> ;

implementation @ :: <<FunctorBase>> <<ctor>> ;
//? Конструктор
//= ClassBase::Class::ctor::Operation

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for482BD31C000D*
//#UC END# *46E6D4BB0339for482BD31C000D*
; // wiki


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor482BD31C000D*
//#UC END# *470321C1038Afor482BD31C000D*
; // fctr.java


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for482BD31C000D*
//#UC END# *477398E501C0for482BD31C000D*
; // intf2.pas


// Ресурсы (.rc)
//+ rc.pas
<<generator>> rc.pas OBJECT IN %S
//R  
//#UC START# *55B8D28B0157for482BD31C000D*
//#UC END# *55B8D28B0157for482BD31C000D*
; // rc.pas


// Скрипты в ресурсах (.rc.script)
//+ rc.script.pas
<<generator>> rc.script.pas OBJECT IN %S
//R  
//#UC START# *55B8D2F80145for482BD31C000D*
//#UC END# *55B8D2F80145for482BD31C000D*
; // rc.script.pas


// Компилятор ресурса (.res.cmd)
//+ res.cmd.pas
<<generator>> res.cmd.pas OBJECT IN %S
//R  
//#UC START# *55B8DD9C0301for482BD31C000D*
//#UC END# *55B8DD9C0301for482BD31C000D*
; // res.cmd.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
; // st_space_key

: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for482BD31C000D*
//#UC END# *470484D50138for482BD31C000D*
; // wiki_up_add_gen



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<FunctorBase>> <<ctor>> ;

