////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/InterfaceTypes/Support.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAUtilityPack::Class>> MDProcess$Templates::CommonTemplates::CommonLang::InterfaceTypes::Support
//
// набор вспомогательных функций
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// просто выводит кавычки - нужно дял использования в условиях
//f _dump_q
: dump_q OBJECT IN %S
//#UC START# *47174AF60167*
//	"
 '"'
//#UC END# *47174AF60167*
; // dump_q


// выводит заескейпенные кавычки
//f _dump_escq
: dump_escq OBJECT IN %S
//#UC START# *47174AFC00AB*
//	\\"
 '\"'
//#UC END# *47174AFC00AB*
; // dump_escq


// выводит реалиазцию атрибутов для callback - TIE-обертки
//f _cb_tie_attribute_dll_cpp
: cb_tie_attribute_dll_cpp OBJECT IN %S
//#UC START# *471753140261*
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	][{"%SS"!="writeonly"}
 end // if
 NOP
 if ( ( %S |S ) %!= 'writeonly' ) then
 begin
  #13#10

//	#%f_dll_cpp_attr_ret(%S) %{OWNER}N_callback_tie::get_%SN (%f_dll_cpp_attr_get(%S))[{"%t_interface(%T)"="false"} const][ /*throw (<{, }%f_type(%E)>)*/] {
  out_indent [%f] dll_cpp_attr_ret %( %S )% ' '
  ( get_global_var ( 'OWNER' ) |N ) '_callback_tie::get_'
  %S |N ' ('
  [%f] dll_cpp_attr_get %( %S )% ')'
  if ( ( [%t] interface %( %T )% ) %== false ) then
  begin
   ' const' 
  end // if
  if NOT-EMPTY
  begin
   ' /*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
   ')*/' 
  end // if
  NOP
  ' {'
//	_DLL_TRY[{%f_need_tie_log(%S)=true}
  '_DLL_TRY'
  if ( ( [%f] need_tie_log %( %S )% ) %==  true ) then
  begin
   #13#10

//		LOG_D(("%{OWNER}N_callback_tie::get_%SN"));][{"%P{native definition}"!="C++ interface"}{
   '	LOG_D(("'
   ( get_global_var ( 'OWNER' ) |N ) '_callback_tie::get_'
   %S |N '));' 
  end // if
  if ( ( %P get_up ( 'native definition' ) ) %!= 'C++ interface' ) then
  begin
   #13#10

//		[{"%Tf"="false"}{return m_impl-\>get_%SN();}%f_cpp_type(%T)* ret = m_impl-\>get_%SN();
   '	'
   if ( ( %T |f ) %== false ) then
   begin
    [%f] cpp_type %( %T )% '* ret = m_impl->get_'
    %S |N '();'
//		%f_type_tie(%T)::make_tie (ret, %SN);]]
    '	'
    [%f] type_tie %( %T )% '::make_tie (ret, '
    %S |N ');' 
   end // if
   else
   begin
    'return m_impl->get_'
    %S |N '();' 
   end // else
  end // if
  else
  begin
   #13#10

//		%U[{_NATIVE_GET}
   '	'
   %Usersection (
    '_NATIVE_GET' 
   )
   (
    #13#10

//		]}
    '	' 
   ) // Usersection
   end // else
//	_DLL_CATCH
  '_DLL_CATCH'
//	}][{"%SS"!="readonly"}
  '}' 
 end // if
 if ( ( %S |S ) %!= 'readonly' ) then
 begin
  #13#10

//	#void %{OWNER}N_callback_tie::set_%SN (%f_dll_cpp_attr_set(%S))[ /*throw (<{, }%f_type(%e)>)*/] {
  out_indent 'void '
  ( get_global_var ( 'OWNER' ) |N ) '_callback_tie::set_'
  %S |N ' ('
  [%f] dll_cpp_attr_set %( %S )% ')'
  if NOT-EMPTY
  begin
   ' /*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %e )% 
     ++! l_Counter
    end // if
   end // for e
   ')*/' 
  end // if
  NOP
  ' {'
//	_DLL_TRY[{%f_need_tie_log(%S)=true}
  '_DLL_TRY'
  if ( ( [%f] need_tie_log %( %S )% ) %==  true ) then
  begin
   #13#10

//		LOG_D(("%{OWNER}N_callback_tie::set_%SN"));][{"%P{native definition}"!="C++ interface"}{
   '	LOG_D(("'
   ( get_global_var ( 'OWNER' ) |N ) '_callback_tie::set_'
   %S |N '));' 
  end // if
  if ( ( %P get_up ( 'native definition' ) ) %!= 'C++ interface' ) then
  begin
   #13#10

//		m_impl-\>set_%SN([{"%Tf"="false"}{%SN}[{"%T{call way}"="back"}{%SN ? %SN-\>m_impl : 0}%f_type(%T)::make_callback_tie(%SN)]]);]
   '	m_impl->set_'
   %S |N '('
   if ( ( %T |f ) %== false ) then
   begin
    if ( ( %T get_up ( 'call way' ) ) %== 'back' ) then
    begin
     [%f] type %( %T )% '::make_callback_tie('
     %S |N ')' 
    end // if
    else
    begin
     %S |N ' ? '
     %S |N '->m_impl : 0' 
    end // else
   end // if
   else
   begin
    %S |N 
   end // else
   ');' 
  end // if
  else
  begin
   #13#10

//		%U[{_NATIVE_SET}
   '	'
   %Usersection (
    '_NATIVE_SET' 
   )
   (
    #13#10

//		]}
    '	' 
   ) // Usersection
   end // else
//	_DLL_CATCH
  '_DLL_CATCH'
//	}][
  '}' 
 end // if
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *471753140261*
; // cb_tie_attribute_dll_cpp


// реалиазция операции для TIE-обертки в случае, когда параметры операции являются простыми типами
// не требующими TIE-оберток
//f _cb_tie_complex_operation_dll_cpp
: cb_tie_complex_operation_dll_cpp OBJECT IN %S
//#UC START# *4717531D00EA*
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	]<{}{"%f_need_tie(%C%T)"="true"}	[{"%t_interface(%C%T)"="true"|%t_is_container(%C%T)=true}{%f_type(%C%T)[{%C%TS=Struct}_for_callback]}::Core::Var\<%f_type(%C%T)\>] %CN_;[{"%CS"!="out"}
 end // if
 NOP
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] need_tie %( %C ->T  )% ) %== true ) then
  begin
   '	'
   if ( ( [%t] interface %( %C ->T  )% ) %== true OR 
     ( ( [%t] is_container %( %C ->T  )% ) %==  true  ) ) then
   begin
    '::Core::Var<'
    [%f] type %( %C ->T  )% '>' 
   end // if
   else
   begin
    [%f] type %( %C ->T  )% if ( ( %C ->T |S  ) %== 'Struct' ) then
    begin
     '_for_callback' 
    end // if
   end // else
   ' '
   %C |N '_;'
   if ( ( %C |S ) %!= 'out' ) then
   begin
    #13#10

//		%f_type_tie(%C%T)[{%C%TS=Struct}_for_callback]::make_tie(%CN, %CN_[{"%t_interface(%C%T)"="true"|%t_is_container(%C%T)=true}.out()][{%t_interface(%C%T)=true}, true /*addref*/]);]
    '	'
    [%f] type_tie %( %C ->T  )% if ( ( %C ->T |S  ) %== 'Struct' ) then
    begin
     '_for_callback' 
    end // if
    '::make_tie('
    %C |N ', '
    %C |N '_'
    if ( ( [%t] interface %( %C ->T  )% ) %== true OR 
      ( ( [%t] is_container %( %C ->T  )% ) %==  true  ) ) then
    begin
     '.out()' 
    end // if
    if ( ( [%t] interface %( %C ->T  )% ) %==  true ) then
    begin
     ', true /*addref*/' 
    end // if
    ');' 
   end // if
//	>[{"%t_simple(%T)"="false"}	::Core::[{"%t_interface(%T)"="true"}{Aptr}Var]\<%f_type(%T)\> ret_;

   ++! l_Counter
  end // if
 end // for C
 if ( ( [%t] simple %( %T )% ) %== false ) then
 begin
  '	::Core::'
  if ( ( [%t] interface %( %T )% ) %== true ) then
  begin
   'Var' 
  end // if
  else
  begin
   'Aptr' 
  end // else
  '<'
  [%f] type %( %T )% '> ret_;'
//	]
 end // if
//		[{"%t_simple(%T)"="true"}%f_type(%T) ret_ = ]m_impl-\>%SN_%SU(<{, }%CN[{"%f_need_tie(%C%T)"="true"}_][{"%t_interface(%C%T)"="true"|%t_is_container(%C%T)=true}[{"%CS"="out"}{.in()}.out()]]>[{"%t_simple(%T)"="false"}[{"%Cx"="true"}, ][{"%Tf"="true"}{ret_.out()}*ret_]]);
 '	'
 if ( ( [%t] simple %( %T )% ) %== true ) then
 begin
  [%f] type %( %T )% ' ret_ = ' 
 end // if
 'm_impl->'
 %S |N '_'
 %S |U '('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |N if ( ( [%f] need_tie %( %C ->T  )% ) %== true ) then
   begin
    '_' 
   end // if
   if ( ( [%t] interface %( %C ->T  )% ) %== true OR 
     ( ( [%t] is_container %( %C ->T  )% ) %==  true  ) ) then
   begin
    if ( ( %C |S ) %== 'out' ) then
    begin
     '.out()' 
    end // if
    else
    begin
     '.in()' 
    end // else
   end // if

   ++! l_Counter
  end // if
 end // for C
 if ( ( [%t] simple %( %T )% ) %== false ) then
 begin
  if ( ( %C |x ) %== true ) then
  begin
   ', ' 
  end // if
  if ( ( %T |f ) %== true ) then
  begin
   '*ret_' 
  end // if
  else
  begin
   'ret_.out()' 
  end // else
 end // if
 ');'
//	
//	<{}{"%f_need_tie(%C%T)"="true"&"%CS"="out"}	%f_type_tie(%C%T)::make_cpp(_%CN, %CN);
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] need_tie %( %C ->T  )% ) %== true AND 
   ( ( %C |S ) %== 'out'  ) ) then
  begin
   '	'
   [%f] type_tie %( %C ->T  )% '::make_cpp(_'
   %C |N ', '
   %C |N ');'
//	>[{"%t_simple(%T)"="false"}{[{"%TN"!="void"}	return ret_;]}	[{"%f_need_tie(%T)"="true"}{return ret_._retn();}%f_cpp_type(%T)* ret = NULL;

   ++! l_Counter
  end // if
 end // for C
 if ( ( [%t] simple %( %T )% ) %== false ) then
 begin
  '	'
  if ( ( [%f] need_tie %( %T )% ) %== true ) then
  begin
   [%f] cpp_type %( %T )% '* ret = NULL;'
//		%f_type_tie(%T)::make_cpp(ret_.in (), ret[{%t_refcounted(%T)=true}, true]);
   '	'
   [%f] type_tie %( %T )% '::make_cpp(ret_.in (), ret'
   if ( ( [%t] refcounted %( %T )% ) %==  true ) then
   begin
    ', true' 
   end // if
   ');'
//		return ret;]][
   '	return ret;' 
  end // if
  else
  begin
   'return ret_._retn();' 
  end // else
 end // if
 else
 begin
  if ( ( %T |N ) %!= 'void' ) then
  begin
   '	return ret_;' 
  end // if
 end // else
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4717531D00EA*
; // cb_tie_complex_operation_dll_cpp


// генерит определение операции для TIE-обёртки
//f _cb_tie_operation_dll_cpp
: cb_tie_operation_dll_cpp OBJECT IN %S
//#UC START# *4717532502AF*
//	%f_set_var(SERV_TMP,{SERV})\
 [%f] set_var %( 'SERV_TMP' %, '{SERV}' )% 
//	%f_set_var(SERV,{OWNER})\
 [%f] set_var %( 'SERV' %, '{OWNER}' )% 
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	]\
 end // if
 NOP
//	%f_set_gen_id(cpp)%f_str_replace(%f_servant_cpp_operation_cpp_i(%S),%{OWNER}N::%SN,%{OWNER}N_callback_tie::%SN)%f_set_gen_id(dll.cpp){[{%f_need_tie_log(%S)=true}
 [%f] set_gen_id %( 'cpp' )% [%f] str_replace %( [%f] servant_cpp_operation_cpp_i %( %S )% %, ( get_global_var ( 'OWNER' ) |N ) '::'
 %S |N %, ( get_global_var ( 'OWNER' ) |N ) '_callback_tie::'
 %S |N )% [%f] set_gen_id %( 'dll.cpp' )% '{'
 if ( ( [%f] need_tie_log %( %S )% ) %==  true ) then
 begin
  #13#10

//		LOG_D(("%{OWNER}N_callback_tie::%SN"));]
  '	LOG_D(("'
  ( get_global_var ( 'OWNER' ) |N ) '_callback_tie::'
  %S |N '));' 
 end // if
//	[{"%f_is_simple_call(%S)"="true"}{%f_cb_tie_complex_operation_dll_cpp(%S)}	[{"%TN"!="void"}return ]m_impl-\>%SN_%SU (<{, }%CN[{"%Cf"="false"}-\>m_impl]>);]
 if ( ( [%f] is_simple_call %( %S )% ) %== true ) then
 begin
  '	'
  if ( ( %T |N ) %!= 'void' ) then
  begin
   'return ' 
  end // if
  'm_impl->'
  %S |N '_'
  %S |U ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N if ( ( %C |f ) %== false ) then
    begin
     '->m_impl' 
    end // if

    ++! l_Counter
   end // if
  end // for C
  ');' 
 end // if
 else
 begin
  [%f] cb_tie_complex_operation_dll_cpp %( %S )% 
 end // else
//	}[
 '}'
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]%f_set_var(SERV,{SERV_TMP})
  %S %f close_ifdef %( )% 
 end // if
 NOP
 [%f] set_var %( 'SERV' %, '{SERV_TMP}' )% 

//#UC END# *4717532502AF*
; // cb_tie_operation_dll_cpp


// генерит объявление компаратора для кэшированных фабрик
//f _comparator_for_cached_object
: comparator_for_cached_object OBJECT IN %S
//#UC START# *4717532F01B5*
//	#static class ObjectCreationIdFor%f_to_borland(%SN)Comparator implements java.util.Comparator\<ObjectCreationIdFor%f_to_borland(%SN)\> {
 out_indent 'static class ObjectCreationIdFor'
 [%f] to_borland %( %S |N )% 'Comparator implements java.util.Comparator<ObjectCreationIdFor'
 [%f] to_borland %( %S |N )% '> {'
//	#	public int compare (ObjectCreationIdFor%f_to_borland(%SN) a, ObjectCreationIdFor%f_to_borland(%SN) b) {
 out_indent '	public int compare (ObjectCreationIdFor'
 [%f] to_borland %( %S |N )% ' a, ObjectCreationIdFor'
 [%f] to_borland %( %S |N )% ' b) {'
//	[{%SS=multi factory&%S{transparent multy}!=true}#		int aKeyArgHash = a.keyArg_.hashCode ();
 if ( ( %S |S ) %== 'multi factory' AND 
   ( ( %S get_up ( 'transparent multy' ) ) %!=  true  ) ) then
 begin
  out_indent '		int aKeyArgHash = a.keyArg_.hashCode ();'
//	#		int bKeyArgHash = b.keyArg_.hashCode ();
  out_indent '		int bKeyArgHash = b.keyArg_.hashCode ();'
//	#		if (aKeyArgHash \< bKeyArgHash) {
  out_indent '		if (aKeyArgHash < bKeyArgHash) {'
//	#			return 1;
  out_indent '			return 1;'
//	#		} else if (aKeyArgHash \> bKeyArgHash) {
  out_indent '		} else if (aKeyArgHash > bKeyArgHash) {'
//	#			return -1;
  out_indent '			return -1;'
//	#		}
  out_indent '		}'
//	]<{}{"%CS"!="nokey"}#		int a%f_to_borland(%CN)ArgHash = %t_to_object_type(%C,"a.%f_to_java(%CN)Arg").hashCode ();
 end // if
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %!= 'nokey' ) then
  begin
   out_indent '		int a'
   [%f] to_borland %( %C |N )% 'ArgHash = '
   [%t] to_object_type %( %C %, 'a.'
   [%f] to_java %( %C |N )% 'Arg' )% '.hashCode ();'
//	#		int b%f_to_borland(%CN)ArgHash = %t_to_object_type(%C,"b.%f_to_java(%CN)Arg").hashCode ();
   out_indent '		int b'
   [%f] to_borland %( %C |N )% 'ArgHash = '
   [%t] to_object_type %( %C %, 'b.'
   [%f] to_java %( %C |N )% 'Arg' )% '.hashCode ();'
//	#		if (a%f_to_borland(%CN)ArgHash \< b%f_to_borland(%CN)ArgHash) {
   out_indent '		if (a'
   [%f] to_borland %( %C |N )% 'ArgHash < b'
   [%f] to_borland %( %C |N )% 'ArgHash) {'
//	#			return 1;
   out_indent '			return 1;'
//	#		} else if (a%f_to_borland(%CN)ArgHash \> b%f_to_borland(%CN)ArgHash) {
   out_indent '		} else if (a'
   [%f] to_borland %( %C |N )% 'ArgHash > b'
   [%f] to_borland %( %C |N )% 'ArgHash) {'
//	#			return -1;
   out_indent '			return -1;'
//	#		}
   out_indent '		}'
//	>

   ++! l_Counter
  end // if
 end // for C
//	#		return 0;
 out_indent '		return 0;'
//	#	}
 out_indent '	}'
//	#}
 out_indent '}'
//#UC END# *4717532F01B5*
; // comparator_for_cached_object


// генерит код операции для TIE-обёртки
//f _complex_tie_call
: complex_tie_call OBJECT IN %S
//#UC START# *471753370186*
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	]<{}{%f_need_tie(%C%T)=true|%CS=out&%t_simple(%C%T)=false&%C%Tf=false}	%f_cpp_ret_holder(%C) %CN_[{"%CS"="out"} = 0];[{"%CS"!="out"}
 end // if
 NOP
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] need_tie %( %C ->T  )% ) %==  true OR 
   ( ( %C |S ) %== 'out'  ) AND 
   ( ( [%t] simple %( %C ->T  )% ) %==  false  ) AND 
   ( ( %C ->T |f  ) %==  false  ) ) then
  begin
   '	'
   [%f] cpp_ret_holder %( %C )% ' '
   %C |N '_'
   if ( ( %C |S ) %== 'out' ) then
   begin
    ' = 0' 
   end // if
   ';'
   if ( ( %C |S ) %!= 'out' ) then
   begin
    #13#10

//		%f_type_tie(%C%T)::make_cpp(%CN, %CN_[{%t_cpp_ret_holder_impl(%C)=_var}.out ()]);]
    '	'
    [%f] type_tie %( %C ->T  )% '::make_cpp('
    %C |N ', '
    %C |N '_'
    if ( ( [%t] cpp_ret_holder_impl %( %C )% ) %== '_var' ) then
    begin
     '.out ()' 
    end // if
    ');' 
   end // if
//	>

   ++! l_Counter
  end // if
 end // for C
//		[{%Tx=true&%TN!=void}\
 '	'
 if ( ( %T |x ) %==  true AND 
   ( ( %T |N ) %!= 'void'  ) ) then
 begin
//	%f_set_var(RET_TYPE,"[{%Ss!=cached&%Ss!=const,cached}[{%t_interface(%T)=true|%t_simple(%T)=true}{::Core::Aptr\<%f_cpp_type(%T)\>}%f_cpp_ret(%S)]]\
  [%f] set_var %( 'RET_TYPE' %, if ( ( %S |s ) %!= 'cached' AND 
    ( ( %S |s ) %!= 'const,cached'  ) ) then
  begin
   if ( ( [%t] interface %( %T )% ) %==  true OR 
     ( ( [%t] simple %( %T )% ) %==  true  ) ) then
   begin
    [%f] cpp_ret %( %S )% 
   end // if
   else
   begin
    '::Core::Aptr<'
    [%f] cpp_type %( %T )% '>' 
   end // else
  end // if
//	[{%Ss=cached|%Ss=const,cached}%f_cpp_ret(%S)]")\
  if ( ( %S |s ) %== 'cached' OR 
    ( ( %S |s ) %== 'const,cached'  ) ) then
  begin
   [%f] cpp_ret %( %S )% 
  end // if
)% //	%{RET_TYPE}N ret = ][{}{m_impl}(%f_with_gen_id(cpp,%f_ambiguous_resolve(%{OWNER},%S))(m_impl))]-\>%SN(<{, }[{%t_is_container(%C%T)=true&%CS!=out}*]%CN[{%f_need_tie(%C%T)=true|%CS=out&%t_simple(%C%T)=false&%C%Tf=false}_[{%CS=out&%t_simple(%C%T)=false&%t_interface(%C%T)=false}{[{%t_cpp_ret_holder_impl(%C)=_var}.in ()]}.out()]]>);
  ( get_global_var ( 'RET_TYPE' ) |N ) ' ret = ' 
 end // if
 if NOT-EMPTY
 begin
  '('
  [%f] with_gen_id %( 'cpp' %, [%f] ambiguous_resolve %( ( get_global_var ( 'OWNER' ) ) %, %S )% )% '(m_impl))' 
 end // if
 NOP
 else
 begin
  'm_impl' 
 end // else
 '->'
 %S |N '('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   if ( ( [%t] is_container %( %C ->T  )% ) %==  true AND 
     ( ( %C |S ) %!= 'out'  ) ) then
   begin
    '*' 
   end // if
   %C |N if ( ( [%f] need_tie %( %C ->T  )% ) %==  true OR 
     ( ( %C |S ) %== 'out'  ) AND 
     ( ( [%t] simple %( %C ->T  )% ) %==  false  ) AND 
     ( ( %C ->T |f  ) %==  false  ) ) then
   begin
    '_'
    if ( ( %C |S ) %== 'out' AND 
      ( ( [%t] simple %( %C ->T  )% ) %==  false  ) AND 
      ( ( [%t] interface %( %C ->T  )% ) %==  false  ) ) then
    begin
     '.out()' 
    end // if
    else
    begin
     if ( ( [%t] cpp_ret_holder_impl %( %C )% ) %== '_var' ) then
     begin
      '.in ()' 
     end // if
    end // else
   end // if

   ++! l_Counter
  end // if
 end // for C
 ');'

//	<{}{%f_need_tie(%C%T)=true&%CS!=in}[{%t_interface(%C%T)=false|%CS=out}	%f_type_tie(%C%T)::make_tie([{%CS=out&%t_interface(%C%T)=false&%t_is_container(%C%T)=false}*]%CN_[{%CS=out&%t_is_container(%C%T)=true}._retn()], %CN);
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] need_tie %( %C ->T  )% ) %==  true AND 
   ( ( %C |S ) %!= 'in'  ) ) then
  begin
   if ( ( [%t] interface %( %C ->T  )% ) %==  false OR 
     ( ( %C |S ) %== 'out'  ) ) then
   begin
    '	'
    [%f] type_tie %( %C ->T  )% '::make_tie('
    if ( ( %C |S ) %== 'out' AND 
      ( ( [%t] interface %( %C ->T  )% ) %==  false  ) AND 
      ( ( [%t] is_container %( %C ->T  )% ) %==  false  ) ) then
    begin
     '*' 
    end // if
    %C |N '_'
    if ( ( %C |S ) %== 'out' AND 
      ( ( [%t] is_container %( %C ->T  )% ) %==  true  ) ) then
    begin
     '._retn()' 
    end // if
    ', '
    %C |N ');'
//	]]>\
   end // if
   ']' 
   ++! l_Counter
  end // if
 end // for C
//	<{}{%CS=out&%f_need_tie(%C%T)=false&%C%Tf=false&%t_simple(%C%T)=false}	if (%CN_.ptr()) {
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== 'out' AND 
   ( ( [%f] need_tie %( %C ->T  )% ) %==  false  ) AND 
   ( ( %C ->T |f  ) %==  false  ) AND 
   ( ( [%t] simple %( %C ->T  )% ) %==  false  ) ) then
  begin
   '	if ('
   %C |N '_.ptr()) {'
//			%CN = *_%CN;
   '		'
   %C |N ' = *_'
   %C |N ';'
//		}
   '	}'
//	>[{%Tx=true&%TN!=void}	[{"%f_need_tie(%T)"="true"}{\

   ++! l_Counter
  end // if
 end // for C
 if ( ( %T |x ) %==  true AND 
   ( ( %T |N ) %!= 'void'  ) ) then
 begin
  '	'
  if ( ( [%f] need_tie %( %T )% ) %== true ) then
  begin
   [%f] type_tie %( %T )% '::make_tie('
   if ( ( [%t] interface %( %T )% ) %==  false AND 
     ( ( [%t] tied_elem %( %T )% ) %==  false  ) AND 
     ( ( %S |s ) %!= 'cached'  ) AND 
     ( ( %S |s ) %!= 'const,cached'  ) ) then
   begin
    '*' 
   end // if
   'ret'
   if ( ( [%t] tied_elem %( %T )% ) %==  true AND 
     ( ( [%f] prefix %( ( get_global_var ( 'RET_TYPE' ) |N ) %, '::Core::Aptr' )% ) %== '::Core::Aptr'  ) ) then
   begin
    '._retn()' 
   end // if
//	, ret_[{%Ss=cached|%Ss=const,cached}, this]);]
   ', ret_'
   if ( ( %S |s ) %== 'cached' OR 
     ( ( %S |s ) %== 'const,cached'  ) ) then
   begin
    ', this' 
   end // if
   ');' 
  end // if
  else
  begin
//	[{"%t_simple(%T)"="false"}{return ret;}[{%Ss!=cached&%Ss!=const,cached}if (ret.ptr()) {
   if ( ( [%t] simple %( %T )% ) %== false ) then
   begin
    if ( ( %S |s ) %!= 'cached' AND 
      ( ( %S |s ) %!= 'const,cached'  ) ) then
    begin
     'if (ret.ptr()) {'
//			[{%t_interface(%{CONT_TYPE})=false&%f_suffix(%t_arg(%T,"out"),%f_dump_apersand(%S))!=%f_dump_apersand(%S)}*]ret_ = *ret;
     '		'
     if ( ( [%t] interface %( ( get_global_var ( 'CONT_TYPE' ) ) )% ) %==  false AND 
       ( ( [%f] suffix %( [%t] arg %( %T %, 'out' )% %, [%f] dump_apersand %( %S )% )% ) %!= ( [%f] dump_apersand %( %S )% )  ) ) then
     begin
      '*' 
     end // if
     'ret_ = *ret;'
//		}][{%Ss=cached|%Ss=const,cached}[{%t_interface(%{CONT_TYPE})=false}*]ret_ = ret;]]\
     '	}' 
    end // if
    if ( ( %S |s ) %== 'cached' OR 
      ( ( %S |s ) %== 'const,cached'  ) ) then
    begin
     if ( ( [%t] interface %( ( get_global_var ( 'CONT_TYPE' ) ) )% ) %==  false ) then
     begin
      '*' 
     end // if
     'ret_ = ret;' 
    end // if
   end // if
   else
   begin
    'return ret;' 
   end // else
//	}%f_type_tie(%T)::make_tie([{%t_interface(%T)=false&%t_tied_elem(%T)=false&%Ss!=cached&%Ss!=const,cached}*]ret[{%t_tied_elem(%T)=true&"%f_prefix(%{RET_TYPE}N,::Core::Aptr)"="::Core::Aptr"}._retn()]\
  end // else
//	][
 end // if
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *471753370186*
; // complex_tie_call


// генерит операции для TIE-обёртки callback-интерфейса
//f _cpp_children_cb_tie_h
: cpp_children_cb_tie_h OBJECT IN %S
//#UC START# *4717533F035B*
//	%f_set_gen_id(h)[{"%SC"="Operation"}{%f_servant_cpp_attribute_h(%S)}%f_servant_cpp_operation_h(%S)]%f_set_gen_id(dll.h)
 [%f] set_gen_id %( 'h' )% if ( ( %S |C ) %== 'Operation' ) then
 begin
  [%f] servant_cpp_operation_h %( %S )% 
 end // if
 else
 begin
  [%f] servant_cpp_attribute_h %( %S )% 
 end // else
 [%f] set_gen_id %( 'dll.h' )% 
//#UC END# *4717533F035B*
; // cpp_children_cb_tie_h


// генерит тип, который будет управлять временем жизни TIE-обертки
//f _cpp_ret_holder
: cpp_ret_holder OBJECT IN %S
//#UC START# *4717534902AF*
//	[{"%SS"!="out"}{[{"%t_interface(%T)"="false"&"%Tf"="false"&"%t_simple(%T)"="false"}{[{"%Tf"="false"}{::Core::Aptr\<%f_cpp_type(%T)\>}%f_cpp_type(%T)*]}::Core::Aptr\<%f_cpp_type(%T)\>]}%f_cpp_type(%T)[%t_cpp_ret_holder_impl(%S)]]
 if ( ( %S |S ) %!= 'out' ) then
 begin
  [%f] cpp_type %( %T )% if NOT-EMPTY
  begin
   [%t] cpp_ret_holder_impl %( %S )% 
  end // if
  NOP
 end // if
 else
 begin
  if ( ( [%t] interface %( %T )% ) %== false AND 
    ( ( %T |f ) %== false  ) AND 
    ( ( [%t] simple %( %T )% ) %== false  ) ) then
  begin
   '::Core::Aptr<'
   [%f] cpp_type %( %T )% '>' 
  end // if
  else
  begin
   if ( ( %T |f ) %== false ) then
   begin
    [%f] cpp_type %( %T )% '*' 
   end // if
   else
   begin
    '::Core::Aptr<'
    [%f] cpp_type %( %T )% '>' 
   end // else
  end // else
 end // else

//t _cpp_ret_holder_impl
; // cpp_ret_holder

<<transformator>> cpp_ret_holder_impl OBJECT IN %S
//c                                               {}
//r "%t_interface(%T)"="true":                     {[{"%T{call way}"!="back"}{_var}*]}
//r "%t_is_container(%T)"="true":                  {*}
//r ""="":                                       {}
//#UC END# *4717534902AF*
; // cpp_ret_holder_impl


// генерит параметры операции
//f _delphi_op_params
: delphi_op_params OBJECT IN %S
//#UC START# *471753580177*
//	[\n#\t<{;\n#\t}%f_arg_full_decl(%C)>[{"%t_simple(%T,"")"="false"}[{"%Cx"="true"};\n#\t]%t_arg(%T,"out")]\n#]
 if NOT-EMPTY
 begin
  #13#10
  out_indent #9
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ';'#13#10
    out_indent #9 )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  if ( ( [%t] simple %( %T %, '' )% ) %== false ) then
  begin
   if ( ( %C |x ) %== true ) then
   begin
    ';'#13#10
    out_indent #9 
   end // if
   [%t] arg %( %T %, 'out' )% 
  end // if
  #13#10
  out_indent 
 end // if
 NOP
//#UC END# *471753580177*
; // delphi_op_params


// генерит, если нужно спецификатор overload
//f _delphi_overload
: delphi_overload OBJECT IN %S
//#UC START# *47175360035B*
//@ %SU_%XU
//	[{%S{force overload}=true|%P{force overload}=true}{\
 if ( ( %S get_up ( 'force overload' ) ) %==  true OR 
   ( ( %P get_up ( 'force overload' ) ) %==  true  ) ) then
 begin
//	 overload;\
  ' overload;'
//	]
 end // if
 else
 begin
//	[{%S#f_IsModuleOperation()!=true&%P#f_IsModuleOperation()!=true}\
  if ( ( %S %?f IsModuleOperation %( )% ) %!=  true AND 
    ( ( %P %?f IsModuleOperation %( )% ) %!=  true  ) ) then
  begin


//	[{"%1N"!=""}{\
   if ( ( %1 |N ) %!= '' ) then
   begin
//	%f_set_var(PARENT,1)\
    [%f] set_var %( 'PARENT' %, 1 )% 
//	]\
   end // if
   else
   begin
//	%f_set_var(PARENT,P)\
    [%f] set_var %( 'PARENT' %, 'P' )% 
//	}\
   end // else


//	[{%{PARENT}#f_IsMethod()=true}{\
   if ( ( ( get_global_var ( 'PARENT' ) ) ) out_indent 'f_IsMethod()' %==  true ) then
   begin


//	[{"%{PARENT}%P<{}{"%f_N(%C)"="%f_N(%1%P)"&"%C#f_IsClassInner()"="true"&"%C#f_IsModuleOperation()"!="true"}{C}>"!="1"}\
    if ( ( ( get_global_var ( 'PARENT' )  ->P
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( [%f] N %( %C )% ) %== ( [%f] N %( %1 ->P  )% ) AND 
        ( ( %C %?f IsClassInner %( )% ) %== true  ) AND 
        ( ( %C %?f IsModuleOperation %( )% ) %!= true  ) ) then
       begin

        ++! l_Counter
       end // if
      end // for C
      l_Counter

     ) // bind
 ) )      %!= 1 ) then
    begin
//	 overload;\
     ' overload;'
//	]\
    end // if


//	]\
   end // if
   else
   begin


//	[{"%{PARENT}<{}{"%f_N(%C)"="%f_N(%1)"&"%C#f_IsClassInner()"="true"&"%C#f_IsModuleOperation()"!="true"}{C}>"!="1"}\
    if ( ( ( get_global_var ( 'PARENT' ) ) 
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( [%f] N %( %C )% ) %== ( [%f] N %( %1 )% ) AND 
        ( ( %C %?f IsClassInner %( )% ) %== true  ) AND 
        ( ( %C %?f IsModuleOperation %( )% ) %!= true  ) ) then
       begin

        ++! l_Counter
       end // if
      end // for C
      l_Counter

     ) // bind
)      %!= 1 ) then
    begin
//	 overload;]\
     ' overload;' 
    end // if
//	}\
   end // else
//	]\
  end // if
//	}\
 end // else
//#UC END# *47175360035B*
; // delphi_overload


// генерит код перехвата исключения
//f _DLL_CATCH
: DLL_CATCH OBJECT IN %S
//#UC START# *4717536B0261*
//	[{"%S{Must throw in error}"!="false"}{_DLL_CATCH_RETURNED}_DLL_CATCH]
 if ( ( %S get_up ( 'Must throw in error' ) ) %!= false ) then
 begin
  '_DLL_CATCH' 
 end // if
 else
 begin
  '_DLL_CATCH_RETURNED' 
 end // else
//#UC END# *4717536B0261*
; // DLL_CATCH


// если атрибут не может быть получен через возвращаемый параметр функции генерит out-параметр
//f _dll_cpp_attr_get
: dll_cpp_attr_get OBJECT IN %S
//#UC START# *471753740251*
//	[{%t_simple(%T)=false}%t_arg(%T,"out") ret_]
 if ( ( [%t] simple %( %T )% ) %==  false ) then
 begin
  [%t] arg %( %T %, 'out' )% ' ret_' 
 end // if
//#UC END# *471753740251*
; // dll_cpp_attr_get


// генерит тип возвращаемого значения, если такой тип можно возвращать таким образом, из метода TIE-
// обёртки
//f _dll_cpp_attr_ret
: dll_cpp_attr_ret OBJECT IN %S
//#UC START# *471753810119*
//	[{%t_simple(%T)=true}{void}%f_iget_attr(%S)]
 if ( ( [%t] simple %( %T )% ) %==  true ) then
 begin
  [%f] iget_attr %( %S )% 
 end // if
 else
 begin
  'void' 
 end // else
//#UC END# *471753810119*
; // dll_cpp_attr_ret


// генерит тип параметра для доустепа к атрибуту для TIE-обёртки
//f _dll_cpp_attr_set
: dll_cpp_attr_set OBJECT IN %S
//#UC START# *471753890157*
//	[{%t_tied_elem(%T)=true}{%f_iset_attr(%S)}%t_attr(%T,"lnk-const")] %SN
 if ( ( [%t] tied_elem %( %T )% ) %==  true ) then
 begin
  [%t] attr %( %T %, 'lnk-const' )% 
 end // if
 else
 begin
  [%f] iset_attr %( %S )% 
 end // else
 ' '
 %S |N 
//#UC END# *471753890157*
; // dll_cpp_attr_set


// генерация параметров метода для TIE-обёртки
//f _dll_cpp_params_cpp
: dll_cpp_params_cpp OBJECT IN %S
//#UC START# *471753910232*
//	%f_dll_cpp_params_h(%S)
 [%f] dll_cpp_params_h %( %S )% 
//#UC END# *471753910232*
; // dll_cpp_params_cpp


// список параметров метода для TIE-обёртки
//f _dll_cpp_params_h
: dll_cpp_params_h OBJECT IN %S
//#UC START# *4717539A0203*
//	[\n#\t<{\n#\t, }%f_arg_full_decl(%C)>[{"%t_simple(%T)"="false"}[{"%Cx"="true"}\n#\t, ]%t_arg(%T,"out") ret_]\n#]
 if NOT-EMPTY
 begin
  #13#10
  out_indent #9
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( #13#10
    out_indent #9', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  if ( ( [%t] simple %( %T )% ) %== false ) then
  begin
   if ( ( %C |x ) %== true ) then
   begin
    #13#10
    out_indent #9', ' 
   end // if
   [%t] arg %( %T %, 'out' )% ' ret_' 
  end // if
  #13#10
  out_indent 
 end // if
 NOP
//#UC END# *4717539A0203*
; // dll_cpp_params_h


// список параметров метода для TIE-обёртки
//f _dll_cpp_ret
: dll_cpp_ret OBJECT IN %S
//#UC START# *471753A301D4*
//	[{"%t_simple(%T)"="true"}{void}%f_ret(%S)]
 if ( ( [%t] simple %( %T )% ) %== true ) then
 begin
  [%f] ret %( %S )% 
 end // if
 else
 begin
  'void' 
 end // else
//#UC END# *471753A301D4*
; // dll_cpp_ret


// тип возвращаемого значения
//f _dll_pas_ret
: dll_pas_ret OBJECT IN %S
//#UC START# *471753B101A5*
//	[{"%t_simple(%T)"="true"}[{%TN!=void}: %f_ret(%S)]]
 if ( ( [%t] simple %( %T )% ) %== true ) then
 begin
  if ( ( %T |N ) %!= 'void' ) then
  begin
   ': '
   [%f] ret %( %S )% 
  end // if
 end // if
//#UC END# *471753B101A5*
; // dll_pas_ret


// генерит чисто виртульный метод-фабрику для AbstractFactory, соответствующего интерфейса
//f _dump_abstract_factory_h
: dump_abstract_factory_h OBJECT IN %S
//#UC START# *471753BB0290*
//	%f_dump_abstract_factory_h_impl(%S,"read-write")[{%S%f_has_two_different_signatures()=true}
 [%f] dump_abstract_factory_h_impl %( %S %, 'read-write' )% if ( ( %S %f has_two_different_signatures %( )% ) %==  true ) then
 begin
  #13#10

//	
  #13#10

//		%f_dump_abstract_factory_h_impl(%S,"read-only")]
  '	'
  [%f] dump_abstract_factory_h_impl %( %S %, 'read-only' )% 
 end // if

//f _dump_abstract_factory_h_impl
; // dump_abstract_factory_h

: dump_abstract_factory_h_impl OBJECT IN %S
//	[{%SS!=remover}\
 if ( ( %S |S ) %!= 'remover' ) then
 begin
//	%f_set_var(HAS_MEM_KEY,"0")\
  [%f] set_var %( 'HAS_MEM_KEY' %, 0 )% 
//	%f_set_var(OPERATION_FACTORY,"virtual %t_ret(%{INT}) %SN ([{"%{INT}M"="Entity::Class"}{%S%f_factory_params("%1N","","","servant")}const SEA::DatabaseAPI::StateInfo& si[{%Cx=true&<{}{"%C%TS"!="Identity"|"%CS"="nokey"}{C}>!=0}, ]%S<{, }{"%C%TS"!="Identity"|"%CS"="nokey"}%f_arg_full_decl(%C)>][{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}[{%Cx=true}, ]%f_set_var(HAS_MEM_KEY,"1")%t_arg(%T,"inout") mem_key][{%f_is_ro_fctr_exists(%S)=true}[{%{HAS_MEM_KEY}N=1|%Cx=true}, ]bool ro_mode])[ /*throw (%S<{, }%f_type(%E)>)*/] = 0;")\
  [%f] set_var %( 'OPERATION_FACTORY' %, 'virtual '
  [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' '
  %S |N ' ('
  if ( ( ( get_global_var ( 'INT' ) |M ) ) %== 'Entity::Class' ) then
  begin
   'const SEA::DatabaseAPI::StateInfo& si'
   if ( ( %C |x ) %==  true AND 
     ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C ->T |S  ) %!= 'Identity' OR 
      ( ( %C |S ) %== 'nokey'  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %!= 0  ) ) then
   begin
    ', ' 
   end // if
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C ->T |S  ) %!= 'Identity' OR 
      ( ( %C |S ) %== 'nokey'  ) ) then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] arg_full_decl %( %C )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
   end // if
  else
  begin
   %S %f factory_params %( %1 |N %, '' %, '' %, 'servant' )% 
  end // else
  if ( ( %T |S ) %== 'FactoryMemory' AND 
    ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %== 0  ) ) then
  begin
   if ( ( %C |x ) %==  true ) then
   begin
    ', ' 
   end // if
   [%f] set_var %( 'HAS_MEM_KEY' %, 1 )% [%t] arg %( %T %, 'inout' )% ' mem_key' 
  end // if
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
  begin
   if ( ( ( get_global_var ( 'HAS_MEM_KEY' ) |N ) ) %== 1 OR 
     ( ( %C |x ) %==  true  ) ) then
   begin
    ', ' 
   end // if
   'bool ro_mode' 
  end // if
  ')'
  if NOT-EMPTY
  begin
   ' /*throw ('
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] type %( %E )% 
      ++! l_Counter
     end // if
    end // for E

   ) // bind
    ')*/' 
  end // if
  NOP
  ' = 0;' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_FACTORY}N")")\
  [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_FACTORY' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
  [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_FACTORY}N}virtual %t_ret(%{INT}) %SN ([{"%{INT}M"="Entity::Class"}{%S%f_factory_params("%1N","\n\t\t","","servant")}\n\t\tconst SEA::DatabaseAPI::StateInfo& si[{%Cx=true&<{}{"%C%TS"!="Identity"|"%CS"="nokey"}{C}>!=0}\n\t\t, ]%S<{\n\t\t, }{"%C%TS"!="Identity"|"%CS"="nokey"}%f_arg_full_decl(%C)>][{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}[{%Cx=true}\n\t\t, ]%t_arg(%T,"inout") mem_key][{%f_is_ro_fctr_exists(%S)=true}[{%{HAS_MEM_KEY}N=1|%Cx=true}\n\t\t, ]bool ro_mode]\n\t)[ /*throw (%S<{, }%f_type(%E)>)*/] = 0;]]\
  if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
    ( ( %C |x ) %==  true  ) ) then
  begin
   'virtual '
   [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' '
   %S |N ' ('
   if ( ( ( get_global_var ( 'INT' ) |M ) ) %== 'Entity::Class' ) then
   begin
    #13#10#9#9'const SEA::DatabaseAPI::StateInfo& si'
    if ( ( %C |x ) %==  true AND 
      ( 
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C ->T |S  ) %!= 'Identity' OR 
       ( ( %C |S ) %== 'nokey'  ) ) then
      begin

       ++! l_Counter
      end // if
     end // for C
     l_Counter
     %!= 0  ) ) then
    begin
     #13#10#9#9', ' 
    end // if
    %S
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C ->T |S  ) %!= 'Identity' OR 
       ( ( %C |S ) %== 'nokey'  ) ) then
      begin
       if ( l_Counter >0 ) then ( #13#10#9#9', ' )
       [%f] arg_full_decl %( %C )% 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
    end // if
   else
   begin
    %S %f factory_params %( %1 |N %, #13#10#9#9'"' %, '' %, 'servant' )% 
   end // else
   if ( ( %T |S ) %== 'FactoryMemory' AND 
     ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %!= 'nokey' ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %== 0  ) ) then
   begin
    if ( ( %C |x ) %==  true ) then
    begin
     #13#10#9#9', ' 
    end // if
    [%t] arg %( %T %, 'inout' )% ' mem_key' 
   end // if
   if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
   begin
    if ( ( ( get_global_var ( 'HAS_MEM_KEY' ) |N ) ) %== 1 OR 
      ( ( %C |x ) %==  true  ) ) then
    begin
     #13#10#9#9', ' 
    end // if
    'bool ro_mode' 
   end // if
   #13#10#9')'
   if NOT-EMPTY
   begin
    ' /*throw ('
    %S
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E

    ) // bind
     ')*/' 
   end // if
   NOP
   ' = 0;' 
  end // if
  else
  begin
   ( get_global_var ( 'OPERATION_FACTORY' ) |N ) 
  end // else
 end // if
//	[{%SS=remover}\
 if ( ( %S |S ) %== 'remover' ) then
 begin
//	%f_set_var(OPERATION_FACTORY,"virtual [{%f_is_server_type(%{INT})=false}{int}void] %SN (%t_arg(%{INT},"in") obj_%S<, %f_arg_full_decl(%C)>)[ /*throw (%S<{, }%f_type(%E)>)*/] = 0;")\
  [%f] set_var %( 'OPERATION_FACTORY' %, 'virtual '
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) then
  begin
   'void' 
  end // if
  else
  begin
   'int' 
  end // else
  ' '
  %S |N ' ('
  [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj_'
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     ', '
     [%f] arg_full_decl %( %C )% 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
   ')'
  if NOT-EMPTY
  begin
   ' /*throw ('
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] type %( %E )% 
      ++! l_Counter
     end // if
    end // for E

   ) // bind
    ')*/' 
  end // if
  NOP
  ' = 0;' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_FACTORY}N")")\
  [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_FACTORY' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
  [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_FACTORY}N}virtual [{%f_is_server_type(%{INT})=false}{int}void] %SN (\n\t\t%t_arg(%{INT},"in") obj_%S<\n\t\t, %f_arg_full_decl(%C)>\n\t)[ /*throw (%S<{, }%f_type(%E)>)*/] = 0;]
  if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
    ( ( %C |x ) %==  true  ) ) then
  begin
   'virtual '
   if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) then
   begin
    'void' 
   end // if
   else
   begin
    'int' 
   end // else
   ' '
   %S |N ' ('#13#10#9#9
   [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj_'
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      #13#10#9#9', '
      [%f] arg_full_decl %( %C )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
    #13#10#9')'
   if NOT-EMPTY
   begin
    ' /*throw ('
    %S
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E

    ) // bind
     ')*/' 
   end // if
   NOP
   ' = 0;' 
  end // if
  else
  begin
   ( get_global_var ( 'OPERATION_FACTORY' ) |N ) 
  end // else
//	]
 end // if
//#UC END# *471753BB0290*
; // dump_abstract_factory_h_impl


// генерит объявление фабрики интерфейса
//f _dump_factory
: dump_factory OBJECT IN %S
//#UC START# *471753C602EE*
//	[{"%f_has_factory_methods(%S)"="true"}/// factory interface for %SN
 if ( ( [%f] has_factory_methods %( %S )% ) %== true ) then
 begin
  '/// factory interface for '
  %S |N 
//	[%S%f_open_ifdef()
  if NOT-EMPTY
  begin
   %S %f open_ifdef %( )% 
//	]class %SNFactory {
  end // if
  NOP
  'class '
  %S |N 'Factory {'
//	[<{}{"%aM"="Interface::Class::friend::ClassDependency"}{Sp}%f_get_all_consumer_list(%a%P)<{}{%f_is_empty(CONSUMER_LIST)=false}{W}%f_pop_first_to_var(CONSUMER_LIST,TEMP)[{%{TEMP}S=Servant}#	friend class %f_type(%{TEMP}); //friend's servants
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%ap
   begin
    OBJECT IN %a
    if ( ( %a |M ) %== 'Interface::Class::friend::ClassDependency' ) then
    begin
     [%f] get_all_consumer_list %( %a ->P  )% 
     INTEGER VAR l_Counter l_Counter := 0
     while true
     begin
      if ( ( [%f] is_empty %( 'CONSUMER_LIST' )% ) %==  false ) then
      begin
       [%f] pop_first_to_var %( 'CONSUMER_LIST' %, 'TEMP' )% if ( ( ( get_global_var ( 'TEMP' ) |S ) ) %== 'Servant' ) then
       begin
        out_indent '	friend class '
        [%f] type %( ( get_global_var ( 'TEMP' ) ) )% '; //friend's servants'
//	]>><{}{"%ga"="abstract"}%g<{}{"%aM"="Interface::Class::friend::ClassDependency"}{Sp}%a%P<	friend class %f_type(%l); // friend's servants
       end // if

       ++! l_Counter
      end // if
      else
       break
     end // while

     ++! l_Counter
    end // if
   end // for a
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%ap
      begin
       OBJECT IN %a
       if ( ( %a |M ) %== 'Interface::Class::friend::ClassDependency' ) then
       begin
        %a ->P
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%l
         begin
          OBJECT IN %l
          if true then
          begin
           '	friend class '
           [%f] type %( %l )% '; // friend's servants'
//	>>>

           ++! l_Counter
          end // if
         end // for l

        ) // bind
  
        ++! l_Counter
       end // if
      end // for a

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
//	]\
  end // if
  NOP
//	[{%S%f_has_multi_factory()=true&%Sa!=abstract}public:
  if ( ( %S %f has_multi_factory %( )% ) %==  true AND 
    ( ( %S |a ) %!= 'abstract'  ) ) then
  begin
   'public:'
//	%f_shift_intend(1)%S%f_dump_interface_factory_keys_method()%f_shift_intend(-1)
   [%f] shift_intend %( 1 )% %S %f dump_interface_factory_keys_method %( )% [%f] shift_intend %( -1 )% 
//	]%f_factory_impl(%S)\
  end // if
  [%f] factory_impl %( %S )% 
//	[{%SS=LocalInterface}%f_inherited_factory(%S)]\
  if ( ( %S |S ) %== 'LocalInterface' ) then
  begin
   [%f] inherited_factory %( %S )% 
  end // if
//	[%S%f_additional_fctr_def()]\
  if NOT-EMPTY
  begin
   %S %f additional_fctr_def %( )% 
  end // if
  NOP
//	};[
  '};'
  if NOT-EMPTY
  begin
   #13#10

//	%S%f_close_ifdef()]]
   %S %f close_ifdef %( )% 
  end // if
  NOP
 end // if

//f _is_public_factory
; // dump_factory

: is_public_factory OBJECT IN %S
//	[{%SV=PublicAccess|%SV=ImplementationAccess}{false}true]
 if ( ( %S |V ) %== 'PublicAccess' OR 
   ( ( %S |V ) %== 'ImplementationAccess'  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else

//f _factory_impl
; // is_public_factory

: factory_impl OBJECT IN %S
//	[%f_set_var(INT,S)public:<{}{"%CS"="factory"&%f_is_public_factory(%C)=true}{%C}
 if NOT-EMPTY
 begin
  [%f] set_var %( 'INT' %, 'S' )% 'public:'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' AND 
    ( ( [%f] is_public_factory %( %C )% ) %==  true  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&%f_is_public_factory(%C)=true}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'factory' AND 
       ( ( [%f] is_public_factory %( %C )% ) %==  true  ) ) then
      begin
       #13#10

//	%{INT}%f_dump_factory_operation_h(%C)
       ( get_global_var ( 'INT' ) %f dump_factory_operation_h %( %C )% ) 
//	>>][protected:<{}{"%CS"="factory"&%f_is_public_factory(%C)=false}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP
 if NOT-EMPTY
 begin
  'protected:'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' AND 
    ( ( [%f] is_public_factory %( %C )% ) %==  false  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&%f_is_public_factory(%C)=false}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'factory' AND 
       ( ( [%f] is_public_factory %( %C )% ) %==  false  ) ) then
      begin
       #13#10

//	%{INT}%f_dump_factory_operation_h(%C)
       ( get_global_var ( 'INT' ) %f dump_factory_operation_h %( %C )% ) 
//	>>][public:<{}{"%CS"="multi factory"&%f_is_public_factory(%C)=true}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP
 if NOT-EMPTY
 begin
  'public:'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'multi factory' AND 
    ( ( [%f] is_public_factory %( %C )% ) %==  true  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&%f_is_public_factory(%C)=true}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'multi factory' AND 
       ( ( [%f] is_public_factory %( %C )% ) %==  true  ) ) then
      begin
       #13#10

//	%{INT}%f_dump_multi_factory_operation_h(%C)
       ( get_global_var ( 'INT' ) %f dump_multi_factory_operation_h %( %C )% ) 
//	>>][protected:<{}{"%CS"="multi factory"&%f_is_public_factory(%C)=false}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP
 if NOT-EMPTY
 begin
  'protected:'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'multi factory' AND 
    ( ( [%f] is_public_factory %( %C )% ) %==  false  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&%f_is_public_factory(%C)=false}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'multi factory' AND 
       ( ( [%f] is_public_factory %( %C )% ) %==  false  ) ) then
      begin
       #13#10

//	%{INT}%f_dump_multi_factory_operation_h(%C)
       ( get_global_var ( 'INT' ) %f dump_multi_factory_operation_h %( %C )% ) 
//	>>]

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP

//f _inherited_factory
; // factory_impl

: inherited_factory OBJECT IN %S
//	[<{}{%f_is_interface(%R)=true}[public:%R<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( [%f] is_interface %( %R )% ) %==  true ) then
   begin
    if NOT-EMPTY
    begin
     'public:'
     %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'factory' AND 
        ( ( %C |V ) %== 'PublicAccess'  ) ) then
       begin
        #13#10

//	%{INT}%f_dump_factory_operation_h(%C)
        ( get_global_var ( 'INT' ) %f dump_factory_operation_h %( %C )% ) 
//	>%R<{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}

        ++! l_Counter
       end // if
      end // for C

     ) // bind
      %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%g
      begin
       OBJECT IN %g
       if ( ( %g |a ) %== 'abstract' ) then
       begin
        %g
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%C
         begin
          OBJECT IN %C
          if ( ( %C |S ) %== 'factory' AND 
           ( ( %C |V ) %== 'PublicAccess'  ) ) then
          begin
           #13#10

//	%{INT}%f_dump_factory_operation_h(%C)
           ( get_global_var ( 'INT' ) %f dump_factory_operation_h %( %C )% ) 
//	>>][protected:%R<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}

           ++! l_Counter
          end // if
         end // for C

        ) // bind
 
        ++! l_Counter
       end // if
      end // for g

     ) // bind
     end // if
    NOP
    if NOT-EMPTY
    begin
     'protected:'
     %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'factory' AND 
        ( ( %C |V ) %!= 'PublicAccess'  ) ) then
       begin
        #13#10

//	%{INT}%f_dump_factory_operation_h(%C)
        ( get_global_var ( 'INT' ) %f dump_factory_operation_h %( %C )% ) 
//	>%R<{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}

        ++! l_Counter
       end // if
      end // for C

     ) // bind
      %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%g
      begin
       OBJECT IN %g
       if ( ( %g |a ) %== 'abstract' ) then
       begin
        %g
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%C
         begin
          OBJECT IN %C
          if ( ( %C |S ) %== 'factory' AND 
           ( ( %C |V ) %!= 'PublicAccess'  ) ) then
          begin
           #13#10

//	%{INT}%f_dump_factory_operation_h(%C)
           ( get_global_var ( 'INT' ) %f dump_factory_operation_h %( %C )% ) 
//	>>][public:%R<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}

           ++! l_Counter
          end // if
         end // for C

        ) // bind
 
        ++! l_Counter
       end // if
      end // for g

     ) // bind
     end // if
    NOP
    if NOT-EMPTY
    begin
     'public:'
     %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'multi factory' AND 
        ( ( %C |V ) %== 'PublicAccess'  ) ) then
       begin
        #13#10

//	%{INT}%f_dump_multi_factory_operation_h(%C)
        ( get_global_var ( 'INT' ) %f dump_multi_factory_operation_h %( %C )% ) 
//	>%R<{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}

        ++! l_Counter
       end // if
      end // for C

     ) // bind
      %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%g
      begin
       OBJECT IN %g
       if ( ( %g |a ) %== 'abstract' ) then
       begin
        %g
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%C
         begin
          OBJECT IN %C
          if ( ( %C |S ) %== 'multi factory' AND 
           ( ( %C |V ) %== 'PublicAccess'  ) ) then
          begin
           #13#10

//	%{INT}%f_dump_multi_factory_operation_h(%C)
           ( get_global_var ( 'INT' ) %f dump_multi_factory_operation_h %( %C )% ) 
//	>>][protected:%R<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}

           ++! l_Counter
          end // if
         end // for C

        ) // bind
 
        ++! l_Counter
       end // if
      end // for g

     ) // bind
     end // if
    NOP
    if NOT-EMPTY
    begin
     'protected:'
     %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'multi factory' AND 
        ( ( %C |V ) %!= 'PublicAccess'  ) ) then
       begin
        #13#10

//	%{INT}%f_dump_multi_factory_operation_h(%C)
        ( get_global_var ( 'INT' ) %f dump_multi_factory_operation_h %( %C )% ) 
//	>%R<{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}

        ++! l_Counter
       end // if
      end // for C

     ) // bind
      %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%g
      begin
       OBJECT IN %g
       if ( ( %g |a ) %== 'abstract' ) then
       begin
        %g
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%C
         begin
          OBJECT IN %C
          if ( ( %C |S ) %== 'multi factory' AND 
           ( ( %C |V ) %!= 'PublicAccess'  ) ) then
          begin
           #13#10

//	%{INT}%f_dump_multi_factory_operation_h(%C)
           ( get_global_var ( 'INT' ) %f dump_multi_factory_operation_h %( %C )% ) 
//	>>][%f_set_var(INT,S)public:%R<{}{"%ga"="abstract"}%g<{}{"%CS"="remover"&"%CV"="PublicAccess"}{%C}

           ++! l_Counter
          end // if
         end // for C

        ) // bind
 
        ++! l_Counter
       end // if
      end // for g

     ) // bind
     end // if
    NOP
    if NOT-EMPTY
    begin
     [%f] set_var %( 'INT' %, 'S' )% 'public:'
     %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%g
      begin
       OBJECT IN %g
       if ( ( %g |a ) %== 'abstract' ) then
       begin
        %g
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%C
         begin
          OBJECT IN %C
          if ( ( %C |S ) %== 'remover' AND 
           ( ( %C |V ) %== 'PublicAccess'  ) ) then
          begin
           #13#10

//	%f_dump_remover_operation_h(%C)
           [%f] dump_remover_operation_h %( %C )% 
//	>>][protected:%R<{}{"%ga"="abstract"}%g<{}{"%CS"="remover"&"%CV"!="PublicAccess"}{%C}

           ++! l_Counter
          end // if
         end // for C

        ) // bind
 
        ++! l_Counter
       end // if
      end // for g

     ) // bind
     end // if
    NOP
    if NOT-EMPTY
    begin
     'protected:'
     %R
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%g
      begin
       OBJECT IN %g
       if ( ( %g |a ) %== 'abstract' ) then
       begin
        %g
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%C
         begin
          OBJECT IN %C
          if ( ( %C |S ) %== 'remover' AND 
           ( ( %C |V ) %!= 'PublicAccess'  ) ) then
          begin
           #13#10

//	%f_dump_remover_operation_h(%C)
           [%f] dump_remover_operation_h %( %C )% 
//	>>]>]

           ++! l_Counter
          end // if
         end // for C

        ) // bind
 
        ++! l_Counter
       end // if
      end // for g

     ) // bind
     end // if
    NOP

    ++! l_Counter
   end // if
  end // for R
 end // if
 NOP
//#UC END# *471753C602EE*
; // inherited_factory


// генерит объявление мульти фабрики на менеджере фабрик
//f _dump_factory_manager_multi_factory_h
: dump_factory_manager_multi_factory_h OBJECT IN %S
//#UC START# *471753CE038A*
//	[{%S{const_type}=combo}{%f_dump_factory_manager_multi_factory_h_impl(%S)}%f_dump_factory_manager_multi_factory_h_impl(%S,"read-write")
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] dump_factory_manager_multi_factory_h_impl %( %S %, 'read-write' )% 
//	
  #13#10

//	#%f_dump_factory_manager_multi_factory_h_impl(%S,"read-only","_ro")]
  out_indent [%f] dump_factory_manager_multi_factory_h_impl %( %S %, 'read-only"' %, '_ro' )% 
 end // if
 else
 begin
  [%f] dump_factory_manager_multi_factory_h_impl %( %S )% 
 end // else

//f _dump_factory_manager_multi_factory_h_impl
; // dump_factory_manager_multi_factory_h

: dump_factory_manager_multi_factory_h_impl OBJECT IN %S
//	%f_clear_list(EXCEPTIONS)\
 [%f] clear_list %( 'EXCEPTIONS' )% 
//	%S%f_dump_exceptions_multi_fctr_mngr("EXCEPTIONS")\
 %S %f dump_exceptions_multi_fctr_mngr %( 'EXCEPTIONS' )% 
//	[{%S{transparent multy}=false|"%S{transparent multy}"=""}\
 if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
   ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
 begin

////%S{transparent multy}=false
//	%f_set_var(OP_PARAMS,"%S%f_factory_params("%1N")")\
  [%f] set_var %( 'OP_PARAMS' %, %S %f factory_params %( %1 |N )% )% 
//	%f_set_var(OPERATION_FACTORY,"%t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%f_factory_target_strereotype(%S,"%1N")]") %SN%2N ([{"%{OP_PARAMS}N"!=""}%{OP_PARAMS}N, ]%{INT}%f_dump_switch_arg_type() key) [{%f_realize_srv_interface(%S)=false}{throw (%S%f_dump_formated_exception_list("EXCEPTIONS",", "))}/*throw (%S%f_dump_formated_exception_list("EXCEPTIONS",", "))*/];")\
  [%f] set_var %( 'OPERATION_FACTORY' %, [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
    ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
  begin
   [%f] factory_target_strereotype %( %S %, %1 |N )% 
  end // if
)%   ' '
  %S |N %2 |N ' ('
  if ( ( ( get_global_var ( 'OP_PARAMS' ) |N ) ) %!= '' ) then
  begin
   ( get_global_var ( 'OP_PARAMS' ) |N ) ', ' 
  end // if
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key) '
  if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
  begin
   '/*throw ('
   %S %f dump_formated_exception_list %( 'EXCEPTIONS"' %, %, ' ' )% ')*/' 
  end // if
  else
  begin
   'throw ('
   %S %f dump_formated_exception_list %( 'EXCEPTIONS"' %, %, ' ' )% ')' 
  end // else
  ';' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_FACTORY}N")")\
  [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_FACTORY' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
  [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_FACTORY}N}%t_ret(%{INT},"[{%{INT}S!=ServerInterface}%f_factory_target_strereotype(%S,"%1N")]") %SN%2N ([{"%{OP_PARAMS}N"!=""}%S%f_factory_params("%1N","\n\t\t","\n\t\t"), ]%{INT}%f_dump_switch_arg_type() key\n\t) [{%f_realize_srv_interface(%S)=false}{throw (%S%f_dump_formated_exception_list("EXCEPTIONS",", ","NEW_LINE"))}/*throw (%S%f_dump_formated_exception_list("EXCEPTIONS",", ","NEW_LINE"))*/];]][{%S{transparent multy}=true}\
  if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
    ( ( %C |x ) %==  true  ) ) then
  begin
   [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' ) then
   begin
    [%f] factory_target_strereotype %( %S %, %1 |N )% 
   end // if
)%    ' '
   %S |N %2 |N ' ('
   if ( ( ( get_global_var ( 'OP_PARAMS' ) |N ) ) %!= '' ) then
   begin
    %S %f factory_params %( %1 |N %, #13#10#9#9'"' %, #13#10#9#9 )% ', ' 
   end // if
   ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key'#13#10#9') '
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
   begin
    '/*throw ('
    %S %f dump_formated_exception_list %( 'EXCEPTIONS"' %, %, ' "' %, 'NEW_LINE' )% ')*/' 
   end // if
   else
   begin
    'throw ('
    %S %f dump_formated_exception_list %( 'EXCEPTIONS"' %, %, ' "' %, 'NEW_LINE' )% ')' 
   end // else
   ';' 
  end // if
  else
  begin
   ( get_global_var ( 'OPERATION_FACTORY' ) |N ) 
  end // else
 end // if
 if ( ( %S get_up ( 'transparent multy' ) ) %==  true ) then
 begin

////%S{transparent multy}=true
//	%f_set_var(OPERATION_FACTORY,"%t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%f_factory_target_strereotype(%S,"%1N")]") %SN%2N (%S%f_factory_params("%1N")) [{%f_realize_srv_interface(%S)=false}{throw (%S%f_dump_formated_exception_list("EXCEPTIONS",", "))}/*throw (%S%f_dump_formated_exception_list("EXCEPTIONS",", "))*/];")\
  [%f] set_var %( 'OPERATION_FACTORY' %, [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
    ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
  begin
   [%f] factory_target_strereotype %( %S %, %1 |N )% 
  end // if
)%   ' '
  %S |N %2 |N ' ('
  %S %f factory_params %( %1 |N )% ') '
  if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
  begin
   '/*throw ('
   %S %f dump_formated_exception_list %( 'EXCEPTIONS"' %, %, ' ' )% ')*/' 
  end // if
  else
  begin
   'throw ('
   %S %f dump_formated_exception_list %( 'EXCEPTIONS"' %, %, ' ' )% ')' 
  end // else
  ';' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_FACTORY}N")")\
  [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_FACTORY' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
  [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_FACTORY}N}%t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%f_factory_target_strereotype(%S,"%1N")]") %SN%2N (%S%f_factory_params("%1N","\n\t\t","\n\t")) [{%f_realize_srv_interface(%S)=false}{throw (%S%f_dump_formated_exception_list("EXCEPTIONS",", ","NEW_LINE"))}/*throw (%S%f_dump_formated_exception_list("EXCEPTIONS",", ","NEW_LINE"))*/];]]
  if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
    ( ( %C |x ) %==  true  ) ) then
  begin
   [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
     ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
   begin
    [%f] factory_target_strereotype %( %S %, %1 |N )% 
   end // if
)%    ' '
   %S |N %2 |N ' ('
   %S %f factory_params %( %1 |N %, #13#10#9#9'"' %, #13#10#9 )% ') '
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
   begin
    '/*throw ('
    %S %f dump_formated_exception_list %( 'EXCEPTIONS"' %, %, ' "' %, 'NEW_LINE' )% ')*/' 
   end // if
   else
   begin
    'throw ('
    %S %f dump_formated_exception_list %( 'EXCEPTIONS"' %, %, ' "' %, 'NEW_LINE' )% ')' 
   end // else
   ';' 
  end // if
  else
  begin
   ( get_global_var ( 'OPERATION_FACTORY' ) |N ) 
  end // else
 end // if
//#UC END# *471753CE038A*
; // dump_factory_manager_multi_factory_h_impl


// генерит объявление ремувера на менеджере фабрик
//f _dump_factory_manager_remover_h
: dump_factory_manager_remover_h OBJECT IN %S
//#UC START# *471753D602BF*
//	%f_set_var(OPERATION_FACTORY,"[%1N ]void %SN[{"%1N"!="static"}_i] (%t_arg(%{INT},"in") obj_%S<, %f_arg_full_decl(%C)>) [{%f_realize_srv_interface(%S)=false}{throw (CORBA::SystemException, CoreSrv::ForeignObject%S<, %f_type(%E)>)}/*throw (Core::Root::ForeignObject%S<, %f_type(%E)>)*/];")\
 [%f] set_var %( 'OPERATION_FACTORY' %, if NOT-EMPTY
 begin
  %1 |N ' ' 
 end // if
 NOP
 'void '
 %S |N if ( ( %1 |N ) %!= 'static' ) then
 begin
  '_i' 
 end // if
 ' ('
 [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj_'
 %S
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    ', '
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C

 ) // bind
  ') '
 if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
 begin
  '/*throw (Core::Root::ForeignObject'
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     ', '
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E

  ) // bind
   ')*/' 
 end // if
 else
 begin
  'throw (CORBA::SystemException, CoreSrv::ForeignObject'
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     ', '
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E

  ) // bind
   ')' 
 end // else
 ';' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_FACTORY}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_FACTORY' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_FACTORY}N}[%1N ]void %SN[{"%1N"!="static"}_i] (\n\t\t%t_arg(%{INT},"in") obj_%S<\n\t\t, %f_arg_full_decl(%C)>) [{%f_realize_srv_interface(%S)=false}{throw (CORBA::SystemException, CoreSrv::ForeignObject%S<, %f_type(%E)>)}/*throw (CoreSrv::ForeignObject%S<, %f_type(%E)>)*/];]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  if NOT-EMPTY
  begin
   %1 |N ' ' 
  end // if
  NOP
  'void '
  %S |N if ( ( %1 |N ) %!= 'static' ) then
  begin
   '_i' 
  end // if
  ' ('#13#10#9#9
  [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj_'
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     #13#10#9#9', '
     [%f] arg_full_decl %( %C )% 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
   ') '
  if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
  begin
   '/*throw (CoreSrv::ForeignObject'
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      ', '
      [%f] type %( %E )% 
      ++! l_Counter
     end // if
    end // for E

   ) // bind
    ')*/' 
  end // if
  else
  begin
   'throw (CORBA::SystemException, CoreSrv::ForeignObject'
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      ', '
      [%f] type %( %E )% 
      ++! l_Counter
     end // if
    end // for E

   ) // bind
    ')' 
  end // else
  ';' 
 end // if
 else
 begin
  ( get_global_var ( 'OPERATION_FACTORY' ) |N ) 
 end // else

//#UC END# *471753D602BF*
; // dump_factory_manager_remover_h


// генерит объявление ремувера на менеджере фабрик
//f _dump_factory_manager_remover_java
: dump_factory_manager_remover_java OBJECT IN %S
//#UC START# *471753DD02DE*
//	#protected void %f_to_java(%SNImpl) (%t_arg(%{INT},"in") obj%S<, %f_arg_full_decl(%C)>)[{%f_is_server_type(%S)=true}{[ throws <{, }%f_type(%E)>]} throws ru.garant.shared.CoreSrv.ForeignObject<, %f_type(%E)>] {
 out_indent 'protected void '
 [%f] to_java %( %S |N 'Impl' )% ' ('
 [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj'
 %S
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    ', '
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C

 ) // bind
  ')'
 if ( ( [%f] is_server_type %( %S )% ) %==  true ) then
 begin
  ' throws ru.garant.shared.CoreSrv.ForeignObject'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
 end // if
 else
 begin
  if NOT-EMPTY
  begin
   ' throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
  end // if
  NOP
 end // else
 ' {'
//	[{%f_is_server_type(%S)=true}[{%f_need_obj_hash(%{INT})=true}#	int objHash = obj._hash (Integer.MAX_VALUE);
 if ( ( [%f] is_server_type %( %S )% ) %==  true ) then
 begin
  if ( ( [%f] need_obj_hash %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   out_indent '	int objHash = obj._hash (Integer.MAX_VALUE);'
//	]]%f_clear_list(CACHE_LIST)%f_dump_clear_cache_java(%{INT})%{INT}<{}{%ga=abstract}[
  end // if
 end // if
 [%f] clear_list %( 'CACHE_LIST' )% [%f] dump_clear_cache_java %( ( get_global_var ( 'INT' ) ) )% ( get_global_var ( 'INT' ) ) 
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    if NOT-EMPTY
    begin
     #13#10

//	%f_dump_clear_cache_java(%g)]>%f_clear_list(CACHE_LIST)
     [%f] dump_clear_cache_java %( %g )% 
    end // if
    NOP

    ++! l_Counter
   end // if
  end // for g

 ) // bind
 [%f] clear_list %( 'CACHE_LIST' )% 
//	#}
 out_indent '}'

//f _need_obj_hash
; // dump_factory_manager_remover_java

: need_obj_hash OBJECT IN %S
//	[{%f_need_obj_hash_impl(%S)=true|"<{}{%ga=abstract&%f_need_obj_hash_impl(%g)=true}.>"!=""}{false}true]
 if ( ( [%f] need_obj_hash_impl %( %S )% ) %==  true OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' AND 
    ( ( [%f] need_obj_hash_impl %( %g )% ) %==  true  ) ) then
   begin
    '.' 
    ++! l_Counter
   end // if
  end // for g
  %!= ''  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else

//f _need_obj_hash_impl
; // need_obj_hash

: need_obj_hash_impl OBJECT IN %S
//	[{<{}{%f_is_factory(%C)=true&%f_is_it_cached(%C)=true&[{%C%Cx=true|%CS=multi factory}{false}true]=true}{%CC}>!=0}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  true AND 
    ( ( [%f] is_it_cached %( %C )% ) %==  true  ) AND 
    ( if ( ( %C ->C |x  ) %==  true OR 
     ( ( %C |S ) %== 'multi factory'  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %==  true  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *471753DD02DE*
; // need_obj_hash_impl


// генерит объявление фабрики на менеджере фабрик
//f _dump_factory_manager_single_factory_h
: dump_factory_manager_single_factory_h OBJECT IN %S
//#UC START# *471753E5007D*
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	][{%S{const_type}=combo}{%f_dump_factory_manager_single_factory_h_impl(%S)}\
 end // if
 NOP
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
//	%f_dump_factory_manager_single_factory_h_impl(%S,"read-write")
  [%f] dump_factory_manager_single_factory_h_impl %( %S %, 'read-write' )% 
//	
  #13#10

//	#%f_dump_factory_manager_single_factory_h_impl(%S,"read-only","_ro")][
  out_indent [%f] dump_factory_manager_single_factory_h_impl %( %S %, 'read-only"' %, '_ro' )% 
 end // if
 else
 begin
  [%f] dump_factory_manager_single_factory_h_impl %( %S )% 
 end // else
 if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP

//f _dump_factory_manager_single_factory_h_impl
; // dump_factory_manager_single_factory_h

: dump_factory_manager_single_factory_h_impl OBJECT IN %S
//	%f_set_var(OPERATION_FACTORY,"%t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%f_factory_target_strereotype(%S,"%1N")]") %SN%2N (%S%f_factory_params("%1N")) %S%f_dump_exceptions();")\
 [%f] set_var %( 'OPERATION_FACTORY' %, [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
   ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
 begin
  [%f] factory_target_strereotype %( %S %, %1 |N )% 
 end // if
)%  ' '
 %S |N %2 |N ' ('
 %S %f factory_params %( %1 |N )% ') '
 %S %f dump_exceptions %( )% ';' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_FACTORY}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_FACTORY' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_FACTORY}N}%t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%f_factory_target_strereotype(%S,"%1N")]") %SN%2N (%S%f_factory_params("%1N","\n\t\t","\n\t")) %S%f_dump_exceptions();]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
    ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
  begin
   [%f] factory_target_strereotype %( %S %, %1 |N )% 
  end // if
)%   ' '
  %S |N %2 |N ' ('
  %S %f factory_params %( %1 |N %, #13#10#9#9'"' %, #13#10#9 )% ') '
  %S %f dump_exceptions %( )% ';' 
 end // if
 else
 begin
  ( get_global_var ( 'OPERATION_FACTORY' ) |N ) 
 end // else
//#UC END# *471753E5007D*
; // dump_factory_manager_single_factory_h_impl


// генерит реалиазцию мульти фабрики на менеджере фабрик
//f _dump_fctr_mng_m_fctr_java
: dump_fctr_mng_m_fctr_java OBJECT IN %S
//#UC START# *471753EE031C*
//	[{%S{transparent multy}=false|"%S{transparent multy}"=""}\
 if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
   ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
 begin

//{%S{transparent multy}=false}
//	#public %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%Ss]") %f_to_java(%SN) (%S<%f_arg_full_decl(%C), >String key) throws UnknownFactoryKey%S<, %f_type(%E)> {[{%Ss!=cached&%Ss!=const,cached}
  out_indent 'public '
  [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
    ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
  begin
   %S |s 
  end // if
)%   ' '
  [%f] to_java %( %S |N )% ' ('
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     [%f] arg_full_decl %( %C )% ', ' 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
   'String key) throws UnknownFactoryKey'
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     ', '
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E

  ) // bind
   ' {'
  if ( ( %S |s ) %!= 'cached' AND 
    ( ( %S |s ) %!= 'const,cached'  ) ) then
  begin
   #13#10

//	#	FactoryData factoryData = factoriesMap_.get(key);
   out_indent '	FactoryData factoryData = factoriesMap_.get(key);'
//	#	%{INT}NAbstractFactory factory = factoryData != null ? factoryData.factory_ : null;
   out_indent '	'
   ( get_global_var ( 'INT' ) |N ) 'AbstractFactory factory = factoryData != null ? factoryData.factory_ : null;'
//	#	if (null == factory) {
   out_indent '	if (null == factory) {'
//	#		throw new UnknownFactoryKey (
   out_indent '		throw new UnknownFactoryKey ('
//	#			"%f_dump_java_package(%{INT}).%{INT}NFactory"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}
   out_indent '			"'
   [%f] dump_java_package %( ( get_global_var ( 'INT' ) ) )% '.'
   ( get_global_var ( 'INT' ) |N ) 'Factory"'
   if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
     ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
   begin
    #13#10

//	#			, key.toString ()]
    out_indent '			, key.toString ()' 
   end // if
//	#			);
   out_indent '			);'
//	#	}
   out_indent '	}'
//	#	return factory.%f_to_java(%SN) (%S<{, }%f_to_java(%CN)>);
   out_indent '	return factory.'
   [%f] to_java %( %S |N )% ' ('
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
    ');'
//	][{%Ss=cached|%Ss=const,cached}
  end // if
  if ( ( %S |s ) %== 'cached' OR 
    ( ( %S |s ) %== 'const,cached'  ) ) then
  begin
   #13#10

//	#	ObjectCreationIdFor%f_to_borland(%SN) mapKey = new ObjectCreationIdFor%f_to_borland(%SN)(%S<{}{{"%CS"!="nokey"}}%f_to_java(%CN), >key);
   out_indent '	ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% ' mapKey = new ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '('
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( '{"( '
     %C |S ) %!= 'nokey' ) then
     begin
      '}'
      [%f] to_java %( %C |N )% ', ' 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
    'key);'
//	#	%t_ret(%{INT}) ret = cachedObjectsFor%f_to_borland(%SN).get (mapKey);
   out_indent '	'
   [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' ret = cachedObjectsFor'
   [%f] to_borland %( %S |N )% '.get (mapKey);'
//	#	if (ret == null) {
   out_indent '	if (ret == null) {'
//	#		FactoryData factoryData = factoriesMap_.get(key);
   out_indent '		FactoryData factoryData = factoriesMap_.get(key);'
//	#		%{INT}NAbstractFactory factory = factoryData != null ? factoryData.factory_ : null;
   out_indent '		'
   ( get_global_var ( 'INT' ) |N ) 'AbstractFactory factory = factoryData != null ? factoryData.factory_ : null;'
//	#		if (null == factory) {
   out_indent '		if (null == factory) {'
//	#			throw new UnknownFactoryKey (
   out_indent '			throw new UnknownFactoryKey ('
//	#			"%f_dump_java_package(%{INT}).%{INT}NFactory"[{%{INT}S!=ServerInterface}
   out_indent '			"'
   [%f] dump_java_package %( ( get_global_var ( 'INT' ) ) )% '.'
   ( get_global_var ( 'INT' ) |N ) 'Factory"'
   if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' ) then
   begin
    #13#10

//	#			, key.toString ()]
    out_indent '			, key.toString ()' 
   end // if
//	#			);
   out_indent '			);'
//	#		}
   out_indent '		}'
//	#		ret = factory.%f_to_java(%SN) (%S<{, }%CN>);
   out_indent '		ret = factory.'
   [%f] to_java %( %S |N )% ' ('
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      %C |N 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
    ');'
//	#		cachedObjectsFor%f_to_borland(%SN).put (mapKey, ret);
   out_indent '		cachedObjectsFor'
   [%f] to_borland %( %S |N )% '.put (mapKey, ret);'
//	#		cachedObjectsIndexFor%f_to_borland(%SN).put (ret[{%f_is_server_type(%{INT})=true}._hash (Integer.MAX_VALUE)], mapKey);
   out_indent '		cachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% '.put (ret'
   if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
   begin
    '._hash (Integer.MAX_VALUE)' 
   end // if
   ', mapKey);'
//	#	}
   out_indent '	}'
//	#	return ret;
   out_indent '	return ret;'
//	]#}][{%S{transparent multy}=true}\
  end // if
  out_indent '}' 
 end // if
 if ( ( %S get_up ( 'transparent multy' ) ) %==  true ) then
 begin

//{%S{transparent multy}=true}\
//	#public %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%Ss]") %f_to_java(%SN) (%S<{, }%f_arg_full_decl(%C)>) throws NoActiveFactory%S<, %f_type(%E)> {[{%Ss!=cached&%Ss!=const,cached}
  out_indent 'public '
  [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
    ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
  begin
   %S |s 
  end // if
)%   ' '
  [%f] to_java %( %S |N )% ' ('
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] arg_full_decl %( %C )% 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
   ') throws NoActiveFactory'
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     ', '
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E

  ) // bind
   ' {'
  if ( ( %S |s ) %!= 'cached' AND 
    ( ( %S |s ) %!= 'const,cached'  ) ) then
  begin
   #13#10

//	#	%{INT}NAbstractFactory factory = null;
   out_indent '	'
   ( get_global_var ( 'INT' ) |N ) 'AbstractFactory factory = null;'
//	#	%U[{_CUSTOM_SELECT_FACTORY}
   out_indent '	'
   %Usersection (
    '_CUSTOM_SELECT_FACTORY' 
   )
   (
    #13#10

//	#	]
    out_indent '	' 
   ) // Usersection
 //	#	if (null == factory) {
   out_indent '	if (null == factory) {'
//	#		throw new NoActiveFactory ("%f_dump_java_package(%{INT}).%{INT}NFactory");
   out_indent '		throw new NoActiveFactory ("'
   [%f] dump_java_package %( ( get_global_var ( 'INT' ) ) )% '.'
   ( get_global_var ( 'INT' ) |N ) 'Factory");'
//	#	}
   out_indent '	}'
//	#	return factory.%f_to_java(%SN) (%S<{, }%f_to_java(%CN)>);
   out_indent '	return factory.'
   [%f] to_java %( %S |N )% ' ('
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
    ');'
//	][{%Ss=cached|%Ss=const,cached}
  end // if
  if ( ( %S |s ) %== 'cached' OR 
    ( ( %S |s ) %== 'const,cached'  ) ) then
  begin
   #13#10

//	#	ObjectCreationIdFor%f_to_borland(%SN) mapKey = new ObjectCreationIdFor%f_to_borland(%SN)(%S<{, }{{"%CS"!="nokey"}}%f_to_java(%CN)>);
   out_indent '	ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% ' mapKey = new ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '('
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( '{"( '
     %C |S ) %!= 'nokey' ) then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      '}'
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
    ');'
//	#	%t_ret(%{INT}) ret = cachedObjectsFor%f_to_borland(%SN).get (mapKey);
   out_indent '	'
   [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' ret = cachedObjectsFor'
   [%f] to_borland %( %S |N )% '.get (mapKey);'
//	#	if (ret == null) {
   out_indent '	if (ret == null) {'
//	#		%{INT}NAbstractFactory factory =null;
   out_indent '		'
   ( get_global_var ( 'INT' ) |N ) 'AbstractFactory factory =null;'
//	#		%U[{_CUSTOM_SELECT_FACTORY}
   out_indent '		'
   %Usersection (
    '_CUSTOM_SELECT_FACTORY' 
   )
   (
    #13#10

//	#		]
    out_indent '		' 
   ) // Usersection
 //	#		if (null == factory) {
   out_indent '		if (null == factory) {'
//	#			throw new NoActiveFactory ("%f_dump_java_package(%{INT}).%{INT}NFactory");
   out_indent '			throw new NoActiveFactory ("'
   [%f] dump_java_package %( ( get_global_var ( 'INT' ) ) )% '.'
   ( get_global_var ( 'INT' ) |N ) 'Factory");'
//	#		}
   out_indent '		}'
//	#		ret = factory.%f_to_java(%SN) (%S<{, }%f_to_java(%CN)>);
   out_indent '		ret = factory.'
   [%f] to_java %( %S |N )% ' ('
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
    ');'
//	#		cachedObjectsFor%f_to_borland(%SN).put (mapKey, ret);
   out_indent '		cachedObjectsFor'
   [%f] to_borland %( %S |N )% '.put (mapKey, ret);'
//	#		cachedObjectsIndexFor%f_to_borland(%SN).put (ret[{%f_is_server_type(%{INT})=true}._hash (Integer.MAX_VALUE)], mapKey);
   out_indent '		cachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% '.put (ret'
   if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
   begin
    '._hash (Integer.MAX_VALUE)' 
   end // if
   ', mapKey);'
//	#	}
   out_indent '	}'
//	#	return ret;
   out_indent '	return ret;'
//	]#}]
  end // if
  out_indent '}' 
 end // if
//#UC END# *471753EE031C*
; // dump_fctr_mng_m_fctr_java


// генерит фабрику интерфейса
//f _dump_java_factory
: dump_java_factory OBJECT IN %S
//#UC START# *471753FA0290*
//	[{"%f_has_factory_methods(%S)"="true"}	/// factory interface for %SN
 if ( ( [%f] has_factory_methods %( %S )% ) %== true ) then
 begin
  '	/// factory interface for '
  %S |N 
///////////фабрика интерфейса обявлена как вложенный в него класс
//		public static class Factory {
  '	public static class Factory {'
//	%f_set_var(INT,S)%f_set_var(FACTORY_PARENT,S)\
  [%f] set_var %( 'INT' %, 'S' )% [%f] set_var %( 'FACTORY_PARENT' %, 'S' )% 
//	[{%S%f_has_multi_factory()=true}
  if ( ( %S %f has_multi_factory %( )% ) %==  true ) then
  begin
   #13#10

//		
   '	'
//	%f_shift_intend(1)%S%f_dump_interface_factory_keys_method()%f_shift_intend(-1)
   [%f] shift_intend %( 1 )% %S %f dump_interface_factory_keys_method %( )% [%f] shift_intend %( -1 )% 
//			]%f_java_factory_impl(%S)[{%SS=LocalInterface}%f_java_inherited_factory(%S)]%S%f_additional_fctr_def_java()
   '		' 
  end // if
  [%f] java_factory_impl %( %S )% if ( ( %S |S ) %== 'LocalInterface' ) then
  begin
   [%f] java_inherited_factory %( %S )% 
  end // if
  %S %f additional_fctr_def_java %( )% 
//		}// factory interface for %SN][{%SS=LocalInterface&<{}{%f_use_as_srv_type(%R)=true}{C}>!=0}
  '	}// factory interface for '
  %S |N 
 end // if
 if ( ( %S |S ) %== 'LocalInterface' AND 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( [%f] use_as_srv_type %( %R )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for R
  l_Counter
  %!= 0  ) ) then
 begin
  #13#10

//	
  #13#10

//		// Helper for %SN
  '	// Helper for '
  %S |N 
//		public static class Helper {
  '	public static class Helper {'
//	%f_set_var(INT,S)<{}{%f_use_as_srv_type(%R)=true}		public static %f_type(%R) narrow (%SN obj)
  [%f] set_var %( 'INT' %, 'S' )% 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( [%f] use_as_srv_type %( %R )% ) %==  true ) then
   begin
    '		public static '
    [%f] type %( %R )% ' narrow ('
    %S |N ' obj)'
//				throws org.omg.PortableServer.POAPackage.ServantNotActive, org.omg.PortableServer.POAPackage.WrongPolicy
    '			throws org.omg.PortableServer.POAPackage.ServantNotActive, org.omg.PortableServer.POAPackage.WrongPolicy'
//			{
    '		{'
//				if (obj instanceof org.omg.PortableServer.Servant) {
    '			if (obj instanceof org.omg.PortableServer.Servant) {'
//					return %f_type(%R)Helper.narrow(
    '				return '
    [%f] type %( %R )% 'Helper.narrow('
//						%{INT}<{}{%PM=Library::Category|%PM=ServerLibrary::Category}{%P}%f_dump_java_package(%P).%PN.LibHomeFactory>.get().getOrbFacet().getRootPoa().servant_to_reference(
    '					'
    ( get_global_var ( 'INT' ) ) 
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%P
     begin
      OBJECT IN %P
      if ( ( %P |M ) %== 'Library::Category' OR 
       ( ( %P |M ) %== 'ServerLibrary::Category'  ) ) then
      begin
       [%f] dump_java_package %( %P )% '.'
       %P |N '.LibHomeFactory' 
       ++! l_Counter
      end // if
     end // for P

    ) // bind
    '.get().getOrbFacet().getRootPoa().servant_to_reference('
//							(org.omg.PortableServer.Servant)obj)
    '						(org.omg.PortableServer.Servant)obj)'
//					);
    '				);'
//				}
    '			}'
//				
    '			'
//				return null;
    '			return null;'
//			}
    '		}'
//	>

    ++! l_Counter
   end // if
  end // for R
//		}]
  '	}' 
 end // if

//f _java_factory_impl
; // dump_java_factory

: java_factory_impl OBJECT IN %S
//	%f_java_factory_impl_call_tpl(%S,"factory")\
 [%f] java_factory_impl_call_tpl %( %S %, 'factory' )% 
//	%f_java_factory_impl_call_tpl(%S,"multi factory")\
 [%f] java_factory_impl_call_tpl %( %S %, 'multi factory' )% 
//	%f_java_factory_impl_call_tpl(%S,"finder")
 [%f] java_factory_impl_call_tpl %( %S %, 'finder' )% 

//f _
; // java_factory_impl

:  OBJECT IN %S
//	[<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' AND 
    ( ( %C |V ) %== 'PublicAccess'  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'factory' AND 
       ( ( %C |V ) %== 'PublicAccess'  ) ) then
      begin
       #13#10

//	%CX
       %C |X 
//	>>][<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' AND 
    ( ( %C |V ) %!= 'PublicAccess'  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'factory' AND 
       ( ( %C |V ) %!= 'PublicAccess'  ) ) then
      begin
       #13#10

//	%CX
       %C |X 
//	>>][<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'multi factory' AND 
    ( ( %C |V ) %== 'PublicAccess'  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'multi factory' AND 
       ( ( %C |V ) %== 'PublicAccess'  ) ) then
      begin
       #13#10

//	%CX
       %C |X 
//	>>][<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'multi factory' AND 
    ( ( %C |V ) %!= 'PublicAccess'  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'multi factory' AND 
       ( ( %C |V ) %!= 'PublicAccess'  ) ) then
      begin
       #13#10

//	%CX
       %C |X 
//	>>]

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP

//f _java_factory_impl_call_tpl
; // 

: java_factory_impl_call_tpl OBJECT IN %S
//	[<{}{"%CS"="%1N"&"%CV"="PublicAccess"}{%C}
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== ( %1 |N ) AND 
    ( ( %C |V ) %== 'PublicAccess'  ) ) then
   begin
    #13#10

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="%2N"&"%CV"="PublicAccess"}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== ( %2 |N ) AND 
       ( ( %C |V ) %== 'PublicAccess'  ) ) then
      begin
       #13#10

//	%CX
       %C |X 
//	>>]

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
 end // if
 NOP
//f _java_inherited_factory
; // java_factory_impl_call_tpl

: java_inherited_factory OBJECT IN %S
//	[<{}{%f_is_interface(%R)=true}%f_set_var(FACTORY_PARENT,R)%f_java_factory_impl(%R)>]
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( [%f] is_interface %( %R )% ) %==  true ) then
   begin
    [%f] set_var %( 'FACTORY_PARENT' %, 'R' )% [%f] java_factory_impl %( %R )% 
    ++! l_Counter
   end // if
  end // for R
 end // if
 NOP
//#UC END# *471753FA0290*
; // java_inherited_factory


// генерит объявление менеджера фабрик для интерфейса
//f _fctr_mng_fctr_h
: fctr_mng_fctr_h OBJECT IN %S
//#UC START# *4717540A02EE*
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	]	// for cached factory %SN[{%Cx=true}
 end // if
 NOP
 '	// for cached factory '
 %S |N if ( ( %C |x ) %==  true ) then
 begin
  #13#10

//		struct ObjectCreationIdFor%f_to_borland(%SN) {
  '	struct ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' {'
//	<{}{"%CS"!="nokey"}		%S%f_cache_attr(%C)_arg;
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    '		'
    %S %f cache_attr %( %C )% '_arg;'
//	>

    ++! l_Counter
   end // if
  end // for C
//			ObjectCreationIdFor%f_to_borland(%SN) (<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>)[ : <{, }{"%CS"!="nokey"}%CN_arg (%CN)>] {
  '		ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ')'
  if NOT-EMPTY
  begin
   ' : '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N '_arg ('
     %C |N ')' 
     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
  ' {'
//			}
  '		}'
//	
  #13#10

//			bool operator \< (const ObjectCreationIdFor%f_to_borland(%SN)& c) const {
  '		bool operator < (const ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '& c) const {'
//				return [{}{false}<{ ? true : }{"%CS"!="nokey"}%CN_arg \< c.%CN_arg>];
  '			return '
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ' ? true : ' )
     %C |N '_arg < c.'
     %C |N '_arg' 
     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
  else
  begin
    false 
  end // else
  ';'
//			}
  '		}'
//		};
  '	};'
//	
  #13#10

//		typedef std::map\<ObjectCreationIdFor%f_to_borland(%SN), [{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)]\> CachedObjectsFor%f_to_borland(%SN);
  '	typedef std::map<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
  end // if
  else
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
  end // else
  '> CachedObjectsFor'
  [%f] to_borland %( %S |N )% ';'
//		typedef std::map\<[{%f_is_server_type(%{INT})=false}{CORBA::ULong}const %f_type(%{INT})*], CachedObjectsFor%f_to_borland(%SN)::iterator\> CachedObjectsIndexFor%f_to_borland(%SN);
  '	typedef std::map<'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) then
  begin
   'const '
   [%f] type %( ( get_global_var ( 'INT' ) ) )% '*' 
  end // if
  else
  begin
   'CORBA::ULong' 
  end // else
  ', CachedObjectsFor'
  [%f] to_borland %( %S |N )% '::iterator> CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ';'
//		CachedObjectsFor%f_to_borland(%SN) m_cached_objects_for_%SN;
  '	CachedObjectsFor'
  [%f] to_borland %( %S |N )% ' m_cached_objects_for_'
  %S |N ';'
//		CachedObjectsIndexFor%f_to_borland(%SN) m_cached_objects_index_for_%SN;][{%Cx=false}
  '	CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ' m_cached_objects_index_for_'
  %S |N ';' 
 end // if
 if ( ( %C |x ) %==  false ) then
 begin
  #13#10

//		[{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)] m_cached_object_for_%SN;]
  '	'
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
  end // if
  else
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
  end // else
  ' m_cached_object_for_'
  %S |N ';' 
 end // if
//	
//		Core::Mutex m_mutex_for_%SN;[
 '	Core::Mutex m_mutex_for_'
 %S |N ';'
 if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4717540A02EE*
; // fctr_mng_fctr_h


// генерит определение менеджера фабрик для интерфейса
//f _fctr_mng_fctr_java
: fctr_mng_fctr_java OBJECT IN %S
//#UC START# *4717541C02BF*
//		// for cached factory %SN[{%Cx=true}
 '	// for cached factory '
 %S |N if ( ( %C |x ) %==  true ) then
 begin
  #13#10

//		static class ObjectCreationIdFor%f_to_borland(%SN) {
  '	static class ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' {'
//	<{}{"%CS"!="nokey"}		[{%f_check_if_type(%C%T,"string")=false}{String %f_to_java(%CN)Arg;}%f_arg_full_decl(%C)Arg;]
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    '		'
    if ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  false ) then
    begin
     [%f] arg_full_decl %( %C )% 'Arg;' 
    end // if
    else
    begin
     'String '
     [%f] to_java %( %C |N )% 'Arg;' 
    end // else
//	>

    ++! l_Counter
   end // if
  end // for C
//			ObjectCreationIdFor%f_to_borland(%SN) (<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>) {
  '		ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ') {'
//	[<{}{"%CS"!="nokey"}			this.%f_to_java(%CN)Arg = %f_to_java(%CN);
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     '			this.'
     [%f] to_java %( %C |N )% 'Arg = '
     [%f] to_java %( %C |N )% ';'
//	>]		}

     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
  '		}'
//		}
  '	}'
//	
  #13#10

//	%f_comparator_for_cached_object(%S)
  [%f] comparator_for_cached_object %( %S )% 
//	
  #13#10

//		private java.util.Map\<ObjectCreationIdFor%f_to_borland(%SN), [{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)]\> cachedObjectsFor%f_to_borland(%SN) = 
  '	private java.util.Map<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
  end // if
  else
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
  end // else
  '> cachedObjectsFor'
  [%f] to_borland %( %S |N )% ' = '
//			new java.util.TreeMap\<ObjectCreationIdFor%f_to_borland(%SN), [{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)]\> (new ObjectCreationIdFor%f_to_borland(%SN)Comparator ());
  '		new java.util.TreeMap<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
  end // if
  else
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
  end // else
  '> (new ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% 'Comparator ());'
//		private [{%f_is_server_type(%{INT})=false}{java.util.Map\<Integer,ObjectCreationIdFor%f_to_borland(%SN)\> cachedObjectsIndexFor%f_to_borland(%SN) = 
  '	private '
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) then
  begin
   'java.util.Map<'
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    [%f] type %( ( get_global_var ( 'INT' ) ) )% 
   end // if
   else
   begin
    'Integer' 
   end // else
   ', ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '> cachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% ' = '
//			new java.util.IdentityHashMap\<[{%Ss!=synchro}{Integer}%f_type(%{INT})], ObjectCreationIdFor%f_to_borland(%SN)\> ();]][{%Cx=false}
   '		new java.util.IdentityHashMap<'
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    [%f] type %( ( get_global_var ( 'INT' ) ) )% 
   end // if
   else
   begin
    'Integer' 
   end // else
   ', ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '> ();' 
  end // if
  else
  begin
   'java.util.Map<Integer,ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '> cachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% ' = '
//			new java.util.IdentityHashMap\<Integer,ObjectCreationIdFor%f_to_borland(%SN)\> ();
   '		new java.util.IdentityHashMap<Integer,ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '> ();'
//		}java.util.Map\<[{%Ss!=synchro}{Integer}%f_type(%{INT})], ObjectCreationIdFor%f_to_borland(%SN)\> cachedObjectsIndexFor%f_to_borland(%SN) = 
   '	' 
  end // else
 end // if
 if ( ( %C |x ) %==  false ) then
 begin
  #13#10

//		private [{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)] cachedObjectFor%f_to_borland(%SN);
  '	private '
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
  end // if
  else
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
  end // else
  ' cachedObjectFor'
  [%f] to_borland %( %S |N )% ';'
//		[{%f_is_server_type(%{INT})=true}private Integer cachedObjectHashFor%f_to_borland(%SN)_ = new Integer (0);
  '	'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   'private Integer cachedObjectHashFor'
   [%f] to_borland %( %S |N )% '_ = new Integer (0);'
//		]private static Boolean sMutexFor%f_to_borland(%SN) = new Boolean (true);]
   '	' 
  end // if
  'private static Boolean sMutexFor'
  [%f] to_borland %( %S |N )% ' = new Boolean (true);' 
 end // if

//f _fctr_mng_remover_java
; // fctr_mng_fctr_java

: fctr_mng_remover_java OBJECT IN %S
//	#public static void %f_to_java(%SN) (%t_arg(%{INT},"in") obj%S<, %f_arg_full_decl(%C)>)[{%f_is_server_type(%S)=true}{[ throws <{, }%f_type(%E)>]} throws ru.garant.shared.CoreSrv.ForeignObject<, %f_type(%E)>] {
 out_indent 'public static void '
 [%f] to_java %( %S |N )% ' ('
 [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj'
 %S
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    ', '
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C

 ) // bind
  ')'
 if ( ( [%f] is_server_type %( %S )% ) %==  true ) then
 begin
  ' throws ru.garant.shared.CoreSrv.ForeignObject'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
 end // if
 else
 begin
  if NOT-EMPTY
  begin
   ' throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
  end // if
  NOP
 end // else
 ' {'
//	#	%{INT}NFactoryManager.%{INT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SNImpl) (obj<, %CN>);
 out_indent '	'
 ( get_global_var ( 'INT' ) |N ) 'FactoryManager.'
 ( get_global_var ( 'INT' ) %f fctr_mng_get_instance_name %( )% ) ' ().'
 [%f] to_java %( %S |N 'Impl' )% ' (obj'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   %C |N 
   ++! l_Counter
  end // if
 end // for C
 ');'
//	#}
 out_indent '}'
//#UC END# *4717541C02BF*
; // fctr_mng_remover_java


// генерит объявление мульти фабрики на менеджере фабрик
//f _fctr_mng_m_fctr_h
: fctr_mng_m_fctr_h OBJECT IN %S
//#UC START# *4717542C0196*
//	[{%S{transparent multy}=false|"%S{transparent multy}"=""}\
 if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
   ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
 begin

////[{%S{transparent multy}=false}\
//		// for cached factory %SN
  '	// for cached factory '
  %S |N 
//		struct ObjectCreationIdFor%f_to_borland(%SN) {
  '	struct ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' {'
//	<{}{"%CS"!="nokey"}		%S%f_cache_attr(%C)_arg;
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    '		'
    %S %f cache_attr %( %C )% '_arg;'
//	>		[{%{INT}%f_dump_switch_type_name()!=string}{std::string}%{INT}%f_dump_switch_type()] key_arg;

    ++! l_Counter
   end // if
  end // for C
  '		'
  if ( ( ( get_global_var ( 'INT' ) %f dump_switch_type_name %( )% ) ) %!= 'string' ) then
  begin
   ( get_global_var ( 'INT' ) %f dump_switch_type %( )% ) 
  end // if
  else
  begin
   'std::string' 
  end // else
  ' key_arg;'
//	
  #13#10

//			ObjectCreationIdFor%f_to_borland(%SN) (<{}{"%CS"!="nokey"}%f_arg_full_decl(%C), >%{INT}%f_dump_switch_arg_type() key) : <{}{"%CS"!="nokey"}%CN_arg (%CN), >key_arg(key) {
  '		ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    [%f] arg_full_decl %( %C )% ', ' 
    ++! l_Counter
   end // if
  end // for C
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key) : '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    %C |N '_arg ('
    %C |N '), ' 
    ++! l_Counter
   end // if
  end // for C
  'key_arg(key) {'
//			}
  '		}'
//	
  #13#10

//			bool operator \< (const ObjectCreationIdFor%f_to_borland(%SN)& c) const {
  '		bool operator < (const ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '& c) const {'
//				return <{}{"%CS"!="nokey"}%CN_arg \< c.%CN_arg ? true : > key_arg \< c.key_arg;
  '			return '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    %C |N '_arg < c.'
    %C |N '_arg ? true : ' 
    ++! l_Counter
   end // if
  end // for C
  ' key_arg < c.key_arg;'
//			}
  '		}'
//		};
  '	};'
//	
  #13#10

//		typedef std::map\<ObjectCreationIdFor%f_to_borland(%SN), [{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)]\> CachedObjectsFor%f_to_borland(%SN);
  '	typedef std::map<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
  end // if
  else
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
  end // else
  '> CachedObjectsFor'
  [%f] to_borland %( %S |N )% ';'
//		typedef std::map\<[{%f_is_server_type(%{INT})=false}{CORBA::ULong}const %f_type(%{INT})*], CachedObjectsFor%f_to_borland(%SN)::iterator\> CachedObjectsIndexFor%f_to_borland(%SN);
  '	typedef std::map<'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) then
  begin
   'const '
   [%f] type %( ( get_global_var ( 'INT' ) ) )% '*' 
  end // if
  else
  begin
   'CORBA::ULong' 
  end // else
  ', CachedObjectsFor'
  [%f] to_borland %( %S |N )% '::iterator> CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ';'
//		CachedObjectsFor%f_to_borland(%SN) m_cached_objects_for_%SN;
  '	CachedObjectsFor'
  [%f] to_borland %( %S |N )% ' m_cached_objects_for_'
  %S |N ';'
//		CachedObjectsIndexFor%f_to_borland(%SN) m_cached_objects_index_for_%SN;
  '	CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ' m_cached_objects_index_for_'
  %S |N ';'
//	
  #13#10

//		Core::Mutex m_mutex_for_%SN;][{%S{transparent multy}=true}\
  '	Core::Mutex m_mutex_for_'
  %S |N ';' 
 end // if
 if ( ( %S get_up ( 'transparent multy' ) ) %==  true ) then
 begin

////[{%S{transparent multy}=true}\
//		// for cached factory %SN
  '	// for cached factory '
  %S |N 
//		struct ObjectCreationIdFor%f_to_borland(%SN) {
  '	struct ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' {'
//	<{}{"%CS"!="nokey"}		%S%f_cache_attr(%C)_arg;
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    '		'
    %S %f cache_attr %( %C )% '_arg;'
//	>

    ++! l_Counter
   end // if
  end // for C
//			ObjectCreationIdFor%f_to_borland(%SN) (<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>) : <{, }{"%CS"!="nokey"}%CN_arg (%CN)> {
  '		ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ') : '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N '_arg ('
    %C |N ')' 
    ++! l_Counter
   end // if
  end // for C
  ' {'
//			}
  '		}'
//	
  #13#10

//			bool operator \< (const ObjectCreationIdFor%f_to_borland(%SN)& c) const {
  '		bool operator < (const ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '& c) const {'
//				return <{ ? true : }{"%CS"!="nokey"}%CN_arg \< c.%CN_arg>;
  '			return '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    if ( l_Counter >0 ) then ( ' ? true : ' )
    %C |N '_arg < c.'
    %C |N '_arg' 
    ++! l_Counter
   end // if
  end // for C
  ';'
//			}
  '		}'
//		};
  '	};'
//	
  #13#10

//		typedef std::map\<ObjectCreationIdFor%f_to_borland(%SN), [{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)]\> CachedObjectsFor%f_to_borland(%SN);
  '	typedef std::map<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
  end // if
  else
  begin
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
  end // else
  '> CachedObjectsFor'
  [%f] to_borland %( %S |N )% ';'
//		typedef std::map\<[{%f_is_server_type(%{INT})=false}{CORBA::ULong}const %f_type(%{INT})*], CachedObjectsFor%f_to_borland(%SN)::iterator\> CachedObjectsIndexFor%f_to_borland(%SN);
  '	typedef std::map<'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) then
  begin
   'const '
   [%f] type %( ( get_global_var ( 'INT' ) ) )% '*' 
  end // if
  else
  begin
   'CORBA::ULong' 
  end // else
  ', CachedObjectsFor'
  [%f] to_borland %( %S |N )% '::iterator> CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ';'
//		CachedObjectsFor%f_to_borland(%SN) m_cached_objects_for_%SN;
  '	CachedObjectsFor'
  [%f] to_borland %( %S |N )% ' m_cached_objects_for_'
  %S |N ';'
//		CachedObjectsIndexFor%f_to_borland(%SN) m_cached_objects_index_for_%SN;
  '	CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ' m_cached_objects_index_for_'
  %S |N ';'
//	
  #13#10

//		Core::Mutex m_mutex_for_%SN;]
  '	Core::Mutex m_mutex_for_'
  %S |N ';' 
 end // if
//#UC END# *4717542C0196*
; // fctr_mng_m_fctr_h


// генерит релизацию мульти фабрики на менеджере фабрик
//f _fctr_mng_m_fctr_java
: fctr_mng_m_fctr_java OBJECT IN %S
//#UC START# *4717543402CE*
//	[{%S{transparent multy}=false|"%S{transparent multy}"=""}\
 if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
   ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
 begin

////{%S{transparent multy}=false}\
//		// for cached factory %SN
  '	// for cached factory '
  %S |N 
//		static class ObjectCreationIdFor%f_to_borland(%SN) {
  '	static class ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' {'
//	<{}{"%CS"!="nokey"}		[{%f_check_if_type(%C%T,"string")=false}{String %f_to_java(%CN)Arg;}%f_arg_full_decl(%C)Arg;]
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    '		'
    if ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  false ) then
    begin
     [%f] arg_full_decl %( %C )% 'Arg;' 
    end // if
    else
    begin
     'String '
     [%f] to_java %( %C |N )% 'Arg;' 
    end // else
//	>		%P%f_dump_switch_type() keyArg_;

    ++! l_Counter
   end // if
  end // for C
  '		'
  %P %f dump_switch_type %( )% ' keyArg_;'
//	
  #13#10

//			ObjectCreationIdFor%f_to_borland(%SN) (<{}{"%CS"!="nokey"}%f_arg_full_decl(%C), >%P%f_dump_switch_type() key) {
  '		ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    [%f] arg_full_decl %( %C )% ', ' 
    ++! l_Counter
   end // if
  end // for C
  %P %f dump_switch_type %( )% ' key) {'
//	[<{}{"%CS"!="nokey"}			this.%f_to_java(%CN)Arg = %f_to_java(%CN);
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     '			this.'
     [%f] to_java %( %C |N )% 'Arg = '
     [%f] to_java %( %C |N )% ';'
//	>]			this.keyArg_ = key;

     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
  '			this.keyArg_ = key;'
//			}
  '		}'
//		}
  '	}'
//	
  #13#10

//	%f_comparator_for_cached_object(%S)
  [%f] comparator_for_cached_object %( %S )% 
//	][{%S{transparent multy}=true}\
 end // if
 if ( ( %S get_up ( 'transparent multy' ) ) %==  true ) then
 begin

////{%S{transparent multy}=true}\
//		// for cached factory %SN
  '	// for cached factory '
  %S |N 
//		static class ObjectCreationIdFor%f_to_borland(%SN) {
  '	static class ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' {'
//	<{}{"%CS"!="nokey"}		[{%f_check_if_type(%C%T,"string")=false}{String %f_to_java(%CN)Arg;}%f_arg_full_decl(%C)Arg;]
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    '		'
    if ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  false ) then
    begin
     [%f] arg_full_decl %( %C )% 'Arg;' 
    end // if
    else
    begin
     'String '
     [%f] to_java %( %C |N )% 'Arg;' 
    end // else
//	>

    ++! l_Counter
   end // if
  end // for C
//			ObjectCreationIdFor%f_to_borland(%SN) (<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>) {
  '		ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ') {'
//	[<{}{"%CS"!="nokey"}			this.%f_to_java(%CN)Arg = %f_to_java(%CN);
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     '			this.'
     [%f] to_java %( %C |N )% 'Arg = '
     [%f] to_java %( %C |N )% ';'
//	>]

     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
//			}
  '		}'
//		}
  '	}'
//	
  #13#10

//	%f_comparator_for_cached_object(%S)
  [%f] comparator_for_cached_object %( %S )% 
//	]
 end // if
//		private java.util.Map\<ObjectCreationIdFor%f_to_borland(%SN), [{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)]\> cachedObjectsFor%f_to_borland(%SN)
 '	private java.util.Map<ObjectCreationIdFor'
 [%f] to_borland %( %S |N )% ', '
 if ( ( %S |s ) %!= 'synchro' ) then
 begin
  [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
 end // if
 else
 begin
  [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
 end // else
 '> cachedObjectsFor'
 [%f] to_borland %( %S |N )% 
//			= new java.util.TreeMap\<ObjectCreationIdFor%f_to_borland(%SN), [{%Ss!=synchro}{%t_fctr_manager_cache_value(%{INT},"type",%S)}%t_fctr_manager_cache_value(%{INT},"var",%S)]\> (new ObjectCreationIdFor%f_to_borland(%SN)Comparator ());\
 '		= new java.util.TreeMap<ObjectCreationIdFor'
 [%f] to_borland %( %S |N )% ', '
 if ( ( %S |s ) %!= 'synchro' ) then
 begin
  [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, %S )% 
 end // if
 else
 begin
  [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, %S )% 
 end // else
 '> (new ObjectCreationIdFor'
 [%f] to_borland %( %S |N )% 'Comparator ());'
//	
//		private [{%f_is_server_type(%{INT})=false}{java.util.Map\<Integer,ObjectCreationIdFor%f_to_borland(%SN)\> cachedObjectsIndexFor%f_to_borland(%SN) = 
 '	private '
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) then
 begin
  'java.util.Map<'
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%f] type %( ( get_global_var ( 'INT' ) ) )% 
  end // if
  else
  begin
   'Integer' 
  end // else
  ', ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '> cachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ' = '
//			new java.util.IdentityHashMap\<[{%Ss!=synchro}{Integer}%f_type(%{INT})], ObjectCreationIdFor%f_to_borland(%SN)\> ();\
  '		new java.util.IdentityHashMap<'
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   [%f] type %( ( get_global_var ( 'INT' ) ) )% 
  end // if
  else
  begin
   'Integer' 
  end // else
  ', ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '> ();'
//	]
 end // if
 else
 begin
  'java.util.Map<Integer,ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '> cachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ' = '
//			new java.util.IdentityHashMap\<Integer,ObjectCreationIdFor%f_to_borland(%SN)\> ();
  '		new java.util.IdentityHashMap<Integer,ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '> ();'
//		}java.util.Map\<[{%Ss!=synchro}{Integer}%f_type(%{INT})], ObjectCreationIdFor%f_to_borland(%SN)\> cachedObjectsIndexFor%f_to_borland(%SN) = 
  '	' 
 end // else
//#UC END# *4717543402CE*
; // fctr_mng_m_fctr_java


// генерит релизацию ремувер на менеджере фабрик
//f _fctr_mng_rm_cpp
: fctr_mng_rm_cpp OBJECT IN %S
//#UC START# *47175443000F*
//	void %{INT}NFactoryManager::%SN (%t_arg(%{INT},"in") obj_<, %f_arg_full_decl(%C)>) [{%f_realize_srv_interface(%S)=false}{throw (CORBA::SystemException, CoreSrv::ForeignObject<, %f_type(%E)>)}/*throw (Core::Root::ForeignObject<, %f_type(%E)>)*/] \
 'void '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManager::'
 %S |N ' ('
 [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj_'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ') '
 if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
 begin
  '/*throw (Core::Root::ForeignObject'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
  ')*/' 
 end // if
 else
 begin
  'throw (CORBA::SystemException, CoreSrv::ForeignObject'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
  ')' 
 end // else
 ' '
//	{
 '{'
//		Singleton::instance ()-\>%SN_i (obj_<, %CN>);
 '	Singleton::instance ()->'
 %S |N '_i (obj_'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   %C |N 
   ++! l_Counter
  end // if
 end // for C
 ');'
//	}
 '}'
//	
//	void %{INT}NFactoryManager::%SN_i (%t_arg(%{INT},"in") obj_<, %f_arg_full_decl(%C)>) [{%f_realize_srv_interface(%S)=false}{throw (CORBA::SystemException, CoreSrv::ForeignObject<, %f_type(%E)>)}/*throw (Core::Root::ForeignObject<, %f_type(%E)>)*/] \
 'void '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManager::'
 %S |N '_i ('
 [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj_'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ') '
 if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
 begin
  '/*throw (Core::Root::ForeignObject'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
  ')*/' 
 end // if
 else
 begin
  'throw (CORBA::SystemException, CoreSrv::ForeignObject'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
  ')' 
 end // else
 ' '
//	{
 '{'
//		{[{%f_is_server_type(%S)=true}[{%f_need_obj_hash(%{INT})=true}
 '	{'
 if ( ( [%f] is_server_type %( %S )% ) %==  true ) then
 begin
  if ( ( [%f] need_obj_hash %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   #13#10

//			CORBA::ULong obj_hash = obj_-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ());]]
   '		CORBA::ULong obj_hash = obj_->_hash (std::numeric_limits<CORBA::ULong>::max ());' 
  end // if
 end // if
//			%f_clear_list(CACHE_LIST)%f_dump_clear_cache(%{INT})%{INT}<{}{%ga=abstract}[
 '		'
 [%f] clear_list %( 'CACHE_LIST' )% [%f] dump_clear_cache %( ( get_global_var ( 'INT' ) ) )% ( get_global_var ( 'INT' ) ) 
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    if NOT-EMPTY
    begin
     #13#10

//			%f_dump_clear_cache(%g)]>%f_clear_list(CACHE_LIST)
     '		'
     [%f] dump_clear_cache %( %g )% 
    end // if
    NOP

    ++! l_Counter
   end // if
  end // for g

 ) // bind
 [%f] clear_list %( 'CACHE_LIST' )% 
//		}
 '	}'
//	}
 '}'

//f _dump_clear_cache_java
; // fctr_mng_rm_cpp

: dump_clear_cache_java OBJECT IN %S
//	<{}{%f_is_factory(%C)=true&%f_is_it_cached(%C)=true&%Cs!=synchro}[{%C%TS!=FactoryMemory}[{%C%Cx=true|%CS=multi factory}{
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  true AND 
   ( ( [%f] is_it_cached %( %C )% ) %==  true  ) AND 
   ( ( %C |s ) %!= 'synchro'  ) ) then
  begin
   if ( ( %C ->T |S  ) %!= 'FactoryMemory' ) then
   begin
    if ( ( %C ->C |x  ) %==  true OR 
      ( ( %C |S ) %== 'multi factory'  ) ) then
    begin
     #13#10

//			synchronized (cachedObjectsFor%f_to_borland(%CN)) \{
     '		synchronized (cachedObjectsFor'
     [%f] to_borland %( %C |N )% ') {'
//	%f_shift_intend(2)%f_dump_clear_fctr_cache_java(%C)%f_shift_intend(-2)
     [%f] shift_intend %( 2 )% [%f] dump_clear_fctr_cache_java %( %C )% [%f] shift_intend %( '-2' )% 
//			\}
     '		}'
//		]][{%C%TS=FactoryMemory&%f_exists_in_list(CACHE_LIST,"%C%TN")=false}%f_add_to_list(CACHE_LIST,"%C%TN")
     '	' 
    end // if
    else
    begin
     #13#10

//			synchronized (sMutexFor%f_to_borland(%CN)) \{
     '		synchronized (sMutexFor'
     [%f] to_borland %( %C |N )% ') {'
//				if (cachedObjectFor%f_to_borland(%CN) != null && cachedObjectFor%f_to_borland(%CN)[{%f_is_server_type(%{INT})=true}{ == obj}._is_equivalent(obj)]) \{
     '			if (cachedObjectFor'
     [%f] to_borland %( %C |N )% ' != null && cachedObjectFor'
     [%f] to_borland %( %C |N )% if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
     begin
      '._is_equivalent(obj)' 
     end // if
     else
     begin
      ' == obj' 
     end // else
     ') {'
//					cachedObjectFor%f_to_borland(%CN) = null;
     '				cachedObjectFor'
     [%f] to_borland %( %C |N )% ' = null;'
//				\}
     '			}'
//			\}}
     '		}' 
    end // else
   end // if
   if ( ( %C ->T |S  ) %== 'FactoryMemory' AND 
     ( ( [%f] exists_in_list %( 'CACHE_LIST' %, %C ->T |N  )% ) %==  false  ) ) then
   begin
    [%f] add_to_list %( 'CACHE_LIST' %, %C ->T |N  )% 
//			synchronized (%f_to_borland(%C%TNMap)_) \{
    '		synchronized ('
    [%f] to_borland %( %C ->T |N  'Map' )% '_) {'
//	%f_shift_intend(2)%f_dump_clear_fctr_common_mem_cache_java(%C)%f_shift_intend(-2)
    [%f] shift_intend %( 2 )% [%f] dump_clear_fctr_common_mem_cache_java %( %C )% [%f] shift_intend %( '-2' )% 
//			\}
    '		}'
//		]>
    '	' 
   end // if

   ++! l_Counter
  end // if
 end // for C
//f _dump_clear_fctr_cache_java
; // dump_clear_cache_java

: dump_clear_fctr_cache_java OBJECT IN %S
//	#ObjectCreationIdFor%f_to_borland(%SN) key  = cachedObjectsIndexFor%f_to_borland(%SN).get (obj[{%f_is_server_type(%{INT})=true}Hash]);
 out_indent 'ObjectCreationIdFor'
 [%f] to_borland %( %S |N )% ' key  = cachedObjectsIndexFor'
 [%f] to_borland %( %S |N )% '.get (obj'
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
 begin
  'Hash' 
 end // if
 ');'
//	#if (key != null) {
 out_indent 'if (key != null) {'
//	#	cachedObjectsFor%f_to_borland(%SN).remove (key);
 out_indent '	cachedObjectsFor'
 [%f] to_borland %( %S |N )% '.remove (key);'
//	#	cachedObjectsIndexFor%f_to_borland(%SN).remove (obj[{%f_is_server_type(%{INT})=true}Hash]);
 out_indent '	cachedObjectsIndexFor'
 [%f] to_borland %( %S |N )% '.remove (obj'
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
 begin
  'Hash' 
 end // if
 ');'
//	#}
 out_indent '}'

//f _dump_clear_fctr_common_mem_cache_java
; // dump_clear_fctr_cache_java

: dump_clear_fctr_common_mem_cache_java OBJECT IN %S
//	#%T%f_factory_mem_key_name() key = %f_to_borland(%TNIndexMap)_.get (obj[{%f_is_server_type(%{INT})=true}Hash]);
 out_indent %T %f factory_mem_key_name %( )% ' key = '
 [%f] to_borland %( %T |N 'IndexMap' )% '_.get (obj'
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
 begin
  'Hash' 
 end // if
 ');'
//	#if (key != null) {
 out_indent 'if (key != null) {'
//	#	%f_to_borland(%TNMap)_.remove (key);
 out_indent '	'
 [%f] to_borland %( %T |N 'Map' )% '_.remove (key);'
//	#	%f_to_borland(%TNIndexMap)_.remove (obj[{%f_is_server_type(%{INT})=true}Hash]);
 out_indent '	'
 [%f] to_borland %( %T |N 'IndexMap' )% '_.remove (obj'
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
 begin
  'Hash' 
 end // if
 ');'
//	#}
 out_indent '}'

//f _dump_clear_cache
; // dump_clear_fctr_common_mem_cache_java

: dump_clear_cache OBJECT IN %S
//	<{}{%f_is_factory(%C)=true&%f_is_it_cached(%C)=true}[{%C%TS!=FactoryMemory}[{%C%Cx=true|%CS=multi factory}{
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  true AND 
   ( ( [%f] is_it_cached %( %C )% ) %==  true  ) ) then
  begin
   if ( ( %C ->T |S  ) %!= 'FactoryMemory' ) then
   begin
    if ( ( %C ->C |x  ) %==  true OR 
      ( ( %C |S ) %== 'multi factory'  ) ) then
    begin
     #13#10

//			\{
     '		{'
//				GUARD(m_mutex_for_%CN);
     '			GUARD(m_mutex_for_'
     %C |N ');'
//	%f_shift_intend(2)%f_dump_clear_fctr_cache(%C)%f_shift_intend(-2)
     [%f] shift_intend %( 2 )% [%f] dump_clear_fctr_cache %( %C )% [%f] shift_intend %( '-2' )% 
//			\}
     '		}'
//		]][{%C%TS=FactoryMemory&%f_exists_in_list(CACHE_LIST,"%C%TN")=false}%f_add_to_list(CACHE_LIST,"%C%TN")
     '	' 
    end // if
    else
    begin
     #13#10

//			\{
     '		{'
//				GUARD(m_mutex_for_%CN);
     '			GUARD(m_mutex_for_'
     %C |N ');'
//				if (!!m_cached_object_for_%CN && m_cached_object_for_%CN[{%f_is_server_type(%{INT})=true}{[{%Cs!=synchro}.ptr ()] == obj_}-\>_is_equivalent(obj_)]) \{
     '			if (!!m_cached_object_for_'
     %C |N ' && m_cached_object_for_'
     %C |N if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
     begin
      '->_is_equivalent(obj_)' 
     end // if
     else
     begin
      if ( ( %C |s ) %!= 'synchro' ) then
      begin
       '.ptr ()' 
      end // if
      ' == obj_' 
     end // else
     ') {'
//					m_cached_object_for_%CN = 0;
     '				m_cached_object_for_'
     %C |N ' = 0;'
//				\}
     '			}'
//			\}}
     '		}' 
    end // else
   end // if
   if ( ( %C ->T |S  ) %== 'FactoryMemory' AND 
     ( ( [%f] exists_in_list %( 'CACHE_LIST' %, %C ->T |N  )% ) %==  false  ) ) then
   begin
    [%f] add_to_list %( 'CACHE_LIST' %, %C ->T |N  )% 
//			\{
    '		{'
//				GUARD(m_mutex_for_%f_to_omg(%C%TN));
    '			GUARD(m_mutex_for_'
    [%f] to_omg %( %C ->T |N  )% ');'
//	%f_shift_intend(2)%f_dump_clear_fctr_common_mem_cache(%C)%f_shift_intend(-2)
    [%f] shift_intend %( 2 )% [%f] dump_clear_fctr_common_mem_cache %( %C )% [%f] shift_intend %( '-2' )% 
//			\}
    '		}'
//		]>
    '	' 
   end // if

   ++! l_Counter
  end // if
 end // for C

//f _dump_clear_fctr_cache
; // dump_clear_cache

: dump_clear_fctr_cache OBJECT IN %S
//	[{%f_is_server_type(%{INT})=false&%f_need_const_wrapper(%{INT})=true}#const %f_type(%{INT})ConstWrapper* wrapper = dynamic_cast\<const %f_type(%{INT})ConstWrapper*\> (obj_);
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false AND 
   ( ( [%f] need_const_wrapper %( ( get_global_var ( 'INT' ) ) )% ) %==  true  ) ) then
 begin
  out_indent 'const '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% 'ConstWrapper* wrapper = dynamic_cast<const '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% 'ConstWrapper*> (obj_);'
//	#obj_ = wrapper != 0 ? wrapper-\>m_impl.ptr () : obj_;]
  out_indent 'obj_ = wrapper != 0 ? wrapper->m_impl.ptr () : obj_;' 
 end // if
//	#CachedObjectsIndexFor%f_to_borland(%SN)::iterator it = m_cached_objects_index_for_%SN.find (obj_[{%f_is_server_type(%{INT})=true}hash]);
 out_indent 'CachedObjectsIndexFor'
 [%f] to_borland %( %S |N )% '::iterator it = m_cached_objects_index_for_'
 %S |N '.find (obj_'
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
 begin
  'hash' 
 end // if
 ');'
//	#if (it != m_cached_objects_index_for_%SN.end ()) {
 out_indent 'if (it != m_cached_objects_index_for_'
 %S |N '.end ()) {'
//	#	m_cached_objects_for_%SN.erase (it-\>second);
 out_indent '	m_cached_objects_for_'
 %S |N '.erase (it->second);'
//	#	m_cached_objects_index_for_%SN.erase (it);
 out_indent '	m_cached_objects_index_for_'
 %S |N '.erase (it);'
//	#}
 out_indent '}'

//f _dump_clear_fctr_common_mem_cache
; // dump_clear_fctr_cache

: dump_clear_fctr_common_mem_cache OBJECT IN %S
//	#%f_to_borland(%TNIndexMap)::iterator it = m_%f_to_omg(%TN)_index.find (obj_[{%f_is_server_type(%{INT})=true}hash]);
 out_indent [%f] to_borland %( %T |N 'IndexMap' )% '::iterator it = m_'
 [%f] to_omg %( %T |N )% '_index.find (obj_'
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
 begin
  'hash' 
 end // if
 ');'
//	#if (it != m_%f_to_omg(%TN)_index.end ()) {
 out_indent 'if (it != m_'
 [%f] to_omg %( %T |N )% '_index.end ()) {'
//	#	m_%f_to_omg(%TN).erase (it-\>second);
 out_indent '	m_'
 [%f] to_omg %( %T |N )% '.erase (it->second);'
//	#	m_%f_to_omg(%TN)_index.erase (it);
 out_indent '	m_'
 [%f] to_omg %( %T |N )% '_index.erase (it);'
//	#}
 out_indent '}'
//#UC END# *47175443000F*
; // dump_clear_fctr_common_mem_cache


// генерация атрибута интерфейса
//f _interface_attribute_h
: interface_attribute_h OBJECT IN %S
//#UC START# *4717544B004E*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	][{%t_need_ro(%S)=true}#virtual %f_iget_attr(%S) get_%SN (%S%f_accessor_args("true")) const[
 end // if
 NOP
 if ( ( [%t] need_ro %( %S )% ) %==  true ) then
 begin
  out_indent 'virtual '
  [%f] iget_attr %( %S )% ' get_'
  %S |N ' ('
  %S %f accessor_args %( true )% ') const'
  if NOT-EMPTY
  begin
   #13#10

//	#	/*throw (<{, }%E<%NN::>%EN>)*/] = 0;[{"%f_beaccessed(%S)"="true"}
   out_indent '	/*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %E
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%N
      begin
       OBJECT IN %N
       if true then
       begin
        %N |N '::' 
        ++! l_Counter
       end // if
      end // for N

     ) // bind
      %E |N 
     ++! l_Counter
    end // if
   end // for E
   ')*/' 
  end // if
  NOP
  ' = 0;'
  if ( ( [%f] beaccessed %( %S )% ) %== true ) then
  begin
   #13#10

//	#virtual %f_igetnc_attr(%S) get_%SN (%S%f_accessor_args())[
   out_indent 'virtual '
   [%f] igetnc_attr %( %S )% ' get_'
   %S |N ' ('
   %S %f accessor_args %( )% ')'
   if NOT-EMPTY
   begin
    #13#10

//	#	/*throw (<{, }%E<%NN::>%EN>)*/] = 0;]][{%t_need_rw(%S)=true}[{%t_need_ro(%S)=true}\n\n]#virtual void set_%SN (%f_iset_attr(%S) %SN[, %S%f_accessor_args()])[
    out_indent '	/*throw ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      %E
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       %E |N 
      ++! l_Counter
     end // if
    end // for E
    ')*/' 
   end // if
   NOP
   ' = 0;' 
  end // if
 end // if
 if ( ( [%t] need_rw %( %S )% ) %==  true ) then
 begin
  if ( ( [%t] need_ro %( %S )% ) %==  true ) then
  begin
   #13#10#13#10 
  end // if
  out_indent 'virtual void set_'
  %S |N ' ('
  [%f] iset_attr %( %S )% ' '
  %S |N if NOT-EMPTY
  begin
   ', '
   %S %f accessor_args %( )% 
  end // if
  NOP
  ')'
  if NOT-EMPTY
  begin
   #13#10

//	#	/*throw (<{, }%e<%NN::>%eN>)*/] = 0;][
   out_indent '	/*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %e
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%N
      begin
       OBJECT IN %N
       if true then
       begin
        %N |N '::' 
        ++! l_Counter
       end // if
      end // for N

     ) // bind
      %e |N 
     ++! l_Counter
    end // if
   end // for e
   ')*/' 
  end // if
  NOP
  ' = 0;' 
 end // if
 if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4717544B004E*
; // interface_attribute_h


// генерация атрибута интерфейса
//f _interface_attribute_java
: interface_attribute_java OBJECT IN %S
//#UC START# *471754530157*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%t_need_ro(%S)=true}#%f_ret(%S) %f_to_java(get_%SN) (%S%f_accessor_args())[
 if ( ( [%t] need_ro %( %S )% ) %==  true ) then
 begin
  out_indent [%f] ret %( %S )% ' '
  [%f] to_java %( 'get_'
  %S |N )% ' ('
  %S %f accessor_args %( )% ')'
  if NOT-EMPTY
  begin
   #13#10

//	#	throws <{, }%f_type(%E)>];][{%t_need_rw(%S)=true}[{%t_need_ro(%S)=true}\n\n]#void %f_to_java(set_%SN) (%f_iset_attr(%S) %f_to_java(%SN)[%S%f_accessor_args()])[
   out_indent '	throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
  end // if
  NOP
  ';' 
 end // if
 if ( ( [%t] need_rw %( %S )% ) %==  true ) then
 begin
  if ( ( [%t] need_ro %( %S )% ) %==  true ) then
  begin
   #13#10#13#10 
  end // if
  out_indent 'void '
  [%f] to_java %( 'set_'
  %S |N )% ' ('
  [%f] iset_attr %( %S )% ' '
  [%f] to_java %( %S |N )% if NOT-EMPTY
  begin
   %S %f accessor_args %( )% 
  end // if
  NOP
  ')'
  if NOT-EMPTY
  begin
   #13#10

//	#	throws <{, }%f_type(%e)>];]
   out_indent '	throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %e )% 
     ++! l_Counter
    end // if
   end // for e
  end // if
  NOP
  ';' 
 end // if
//#UC END# *471754530157*
; // interface_attribute_java


// генерация операции интерфейса
//f _interface_java_operation
: interface_java_operation OBJECT IN %S
//#UC START# *471754620271*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#public %f_ret(%S) %f_to_java(%SN) (<{, }%f_arg_full_decl(%C)>)[ throws <{, }%f_type(%E)>];
 out_indent 'public '
 [%f] ret %( %S )% ' '
 [%f] to_java %( %S |N )% ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ')'
 if NOT-EMPTY
 begin
  ' throws '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
 end // if
 NOP
 ';'
//#UC END# *471754620271*
; // interface_java_operation


// возвращает true, если элемент кэшированный (для фабрик)
//f _is_it_cached
: is_it_cached OBJECT IN %S
//#UC START# *4717546A02EE*
//	[{%Ss=cached|%Ss=const,cached|%Ss=synchro}{false}true]
 if ( ( %S |s ) %== 'cached' OR 
   ( ( %S |s ) %== 'const,cached'  ) OR 
   ( ( %S |s ) %== 'synchro'  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4717546A02EE*
; // is_it_cached


// тут похоже возвращает true, если тип элемента требует TIE-обёртки, т.е не может быть напрямую
// передан или получен из/в длл
//f _is_simple_call
: is_simple_call OBJECT IN %S
//#UC START# *4717547403C8*
//	[{"%t_simple(%T)"="true"&"<{}{"%f_need_tie(%C%T)"="true"}{%CC}>"="0"}{false}true]
 if ( ( [%t] simple %( %T )% ) %== true AND 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] need_tie %( %C ->T  )% ) %== true ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %== 0  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4717547403C8*
; // is_simple_call


// генерация атрибута для TIE-обертки
//f _tie_attribute_dll_cpp
: tie_attribute_dll_cpp OBJECT IN %S
//#UC START# *4717547D0109*
//	[{"%SS"!="writeonly"}
 if ( ( %S |S ) %!= 'writeonly' ) then
 begin
  #13#10

//	#%f_dll_cpp_attr_ret(%S) __stdcall %{OWNER}N_tie::get_%SN (%f_dll_cpp_attr_get(%S))[{"%t_interface(%T)"="false"} const][ /*throw (<{, }%f_type(%E)>)*/] {
  out_indent [%f] dll_cpp_attr_ret %( %S )% ' __stdcall '
  ( get_global_var ( 'OWNER' ) |N ) '_tie::get_'
  %S |N ' ('
  [%f] dll_cpp_attr_get %( %S )% ')'
  if ( ( [%t] interface %( %T )% ) %== false ) then
  begin
   ' const' 
  end // if
  if NOT-EMPTY
  begin
   ' /*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
   ')*/' 
  end // if
  NOP
  ' {'
//	_DLL_TRY[{%f_need_tie_log(%S)=true}
  '_DLL_TRY'
  if ( ( [%f] need_tie_log %( %S )% ) %==  true ) then
  begin
   #13#10

//		LOG_D(("%{OWNER}N_tie::get_%SN"));][{"%P{native definition}"!="C++ interface"}{
   '	LOG_D(("'
   ( get_global_var ( 'OWNER' ) |N ) '_tie::get_'
   %S |N '));' 
  end // if
  if ( ( %P get_up ( 'native definition' ) ) %!= 'C++ interface' ) then
  begin
   #13#10

//		[{"%f_need_tie(%T)"="true"}{[{%t_simple(%T)=true}{ret_ =}return] m_impl-\>get_%SN();}%f_type_tie(%T)::make_tie ([{%Sl!=agr&"[{%f_is_fixed_simple(%T)=true|%f_is_fixed_complex(%T)=true}{false}true]"="true"}&]m_impl-\>get_%SN(), ret_[{%Sl=agr}, this]);]]
   '	'
   if ( ( [%f] need_tie %( %T )% ) %== true ) then
   begin
    [%f] type_tie %( %T )% '::make_tie ('
    if ( ( %S |l ) %!= 'agr' AND 
      ( if ( ( [%f] is_fixed_simple %( %T )% ) %==  true OR 
       ( ( [%f] is_fixed_complex %( %T )% ) %==  true  ) ) then
     begin
       true 
     end // if
     else
     begin
       false 
     end // else
     %== true  ) ) then
    begin
     '&' 
    end // if
    'm_impl->get_'
    %S |N '(), ret_'
    if ( ( %S |l ) %== 'agr' ) then
    begin
     ', this' 
    end // if
    ');' 
   end // if
   else
   begin
    if ( ( [%t] simple %( %T )% ) %==  true ) then
    begin
     'return' 
    end // if
    else
    begin
     'ret_ =' 
    end // else
    ' m_impl->get_'
    %S |N '();' 
   end // else
  end // if
  else
  begin
   #13#10

//		%U[{_NATIVE_GET}
   '	'
   %Usersection (
    '_NATIVE_GET' 
   )
   (
    #13#10

//		]}
    '	' 
   ) // Usersection
   end // else
//	_DLL_CATCH
  '_DLL_CATCH'
//	}][{"%SS"!="readonly"}
  '}' 
 end // if
 if ( ( %S |S ) %!= 'readonly' ) then
 begin
  #13#10

//	#void __stdcall %{OWNER}N_tie::set_%SN (%f_dll_cpp_attr_set(%S))[ /*throw (<{, }%f_type(%e)>)*/] {
  out_indent 'void __stdcall '
  ( get_global_var ( 'OWNER' ) |N ) '_tie::set_'
  %S |N ' ('
  [%f] dll_cpp_attr_set %( %S )% ')'
  if NOT-EMPTY
  begin
   ' /*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %e )% 
     ++! l_Counter
    end // if
   end // for e
   ')*/' 
  end // if
  NOP
  ' {'
//	_DLL_TRY[{%f_need_tie_log(%S)=true}
  '_DLL_TRY'
  if ( ( [%f] need_tie_log %( %S )% ) %==  true ) then
  begin
   #13#10

//		LOG_D(("%{OWNER}N_tie::set_%SN"));][{"%P{native definition}"!="C++ interface"}{
   '	LOG_D(("'
   ( get_global_var ( 'OWNER' ) |N ) '_tie::set_'
   %S |N '));' 
  end // if
  if ( ( %P get_up ( 'native definition' ) ) %!= 'C++ interface' ) then
  begin
   #13#10

//		[{"%f_need_tie(%T)"="true"}{m_impl-\>set_%SN(%SN);}[{%t_tied_elem(%T)=true}{%f_cpp_type(%T)}%TN*][{"%t_interface(%T)"="true"}[{"%T{call way}"="back"}{*}_var]] %SN_;
   '	'
   if ( ( [%f] need_tie %( %T )% ) %== true ) then
   begin
    if ( ( [%t] tied_elem %( %T )% ) %==  true ) then
    begin
     %T |N '*' 
    end // if
    else
    begin
     [%f] cpp_type %( %T )% 
    end // else
    if ( ( [%t] interface %( %T )% ) %== true ) then
    begin
     if ( ( %T get_up ( 'call way' ) ) %== 'back' ) then
     begin
      '_var' 
     end // if
     else
     begin
      '*' 
     end // else
    end // if
    ' '
    %S |N '_;'
//		%f_type_tie(%T)::make_cpp(%SN, %SN_[{"%T{call way}"="back"}.out()]);
    '	'
    [%f] type_tie %( %T )% '::make_cpp('
    %S |N ', '
    %S |N '_'
    if ( ( %T get_up ( 'call way' ) ) %== 'back' ) then
    begin
     '.out()' 
    end // if
    ');'
//		m_impl-\>set_%SN([{%t_tied_elem(%T)=true}*]%SN_[{"%t_interface(%T)"="true"}[{"%T{call way}"="back"}.in ()]]);]]
    '	m_impl->set_'
    %S |N '('
    if ( ( [%t] tied_elem %( %T )% ) %==  true ) then
    begin
     '*' 
    end // if
    %S |N '_'
    if ( ( [%t] interface %( %T )% ) %== true ) then
    begin
     if ( ( %T get_up ( 'call way' ) ) %== 'back' ) then
     begin
      '.in ()' 
     end // if
    end // if
    ');' 
   end // if
   else
   begin
    'm_impl->set_'
    %S |N '('
    %S |N ');' 
   end // else
  end // if
  else
  begin
   #13#10

//		%U[{_NATIVE_SET}
   '	'
   %Usersection (
    '_NATIVE_SET' 
   )
   (
    #13#10

//		]}
    '	' 
   ) // Usersection
   end // else
//	_DLL_CATCH
  '_DLL_CATCH'
//	}]
  '}' 
 end // if
//#UC END# *4717547D0109*
; // tie_attribute_dll_cpp


// генерация атрибута для TIE-обертки
//f _tie_attribute_dll_h
: tie_attribute_dll_h OBJECT IN %S
//#UC START# *47175484033C*
//	[{"%SS"!="writeonly"}
 if ( ( %S |S ) %!= 'writeonly' ) then
 begin
  #13#10

//	#virtual %f_dll_cpp_attr_ret(%S) __stdcall get_%SN (%f_dll_cpp_attr_get(%S))[{"%t_interface(%T)"="false"} const][ /*throw (<{, }%f_type(%E)>)*/][{%1N=interface}{[{"%P{call way}"="back"} = 0]} = 0];][{"%SS"!="readonly"}
  out_indent 'virtual '
  [%f] dll_cpp_attr_ret %( %S )% ' __stdcall get_'
  %S |N ' ('
  [%f] dll_cpp_attr_get %( %S )% ')'
  if ( ( [%t] interface %( %T )% ) %== false ) then
  begin
   ' const' 
  end // if
  if NOT-EMPTY
  begin
   ' /*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
   ')*/' 
  end // if
  NOP
  if ( ( %1 |N ) %== 'interface' ) then
  begin
   ' = 0' 
  end // if
  else
  begin
   if ( ( %P get_up ( 'call way' ) ) %== 'back' ) then
   begin
    ' = 0' 
   end // if
  end // else
  ';' 
 end // if
 if ( ( %S |S ) %!= 'readonly' ) then
 begin
  #13#10

//	#virtual void __stdcall set_%SN (%f_dll_cpp_attr_set(%S))[ /*throw (<{, }%f_type(%e)>)*/][{%1N=interface}{[{"%P{call way}"="back"} = 0]} = 0];]
  out_indent 'virtual void __stdcall set_'
  %S |N ' ('
  [%f] dll_cpp_attr_set %( %S )% ')'
  if NOT-EMPTY
  begin
   ' /*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %e )% 
     ++! l_Counter
    end // if
   end // for e
   ')*/' 
  end // if
  NOP
  if ( ( %1 |N ) %== 'interface' ) then
  begin
   ' = 0' 
  end // if
  else
  begin
   if ( ( %P get_up ( 'call way' ) ) %== 'back' ) then
   begin
    ' = 0' 
   end // if
  end // else
  ';' 
 end // if

//#UC END# *47175484033C*
; // tie_attribute_dll_h


// генерация операции для TIE-обертки
//f _tie_operation_dll_cpp
: tie_operation_dll_cpp OBJECT IN %S
//#UC START# *4717548C02AF*
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	]%f_dll_cpp_ret(%S) __stdcall %{OWNER}N_tie::%SN_%SU (%f_dll_cpp_params_cpp(%S))[{"%SS"!="chg"&"%SS"!="oneway,chg"} const][ /*throw (<{, }%f_type(%E)>)*/] {
 end // if
 NOP
 [%f] dll_cpp_ret %( %S )% ' __stdcall '
 ( get_global_var ( 'OWNER' ) |N ) '_tie::'
 %S |N '_'
 %S |U ' ('
 [%f] dll_cpp_params_cpp %( %S )% ')'
 if ( ( %S |S ) %!= 'chg' AND 
   ( ( %S |S ) %!= 'oneway,chg'  ) ) then
 begin
  ' const' 
 end // if
 if NOT-EMPTY
 begin
  ' /*throw ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
  ')*/' 
 end // if
 NOP
 ' {'
//	_DLL_TRY[{%f_need_tie_log(%S)=true}
 '_DLL_TRY'
 if ( ( [%f] need_tie_log %( %S )% ) %==  true ) then
 begin
  #13#10

//		LOG_D(("%{OWNER}N_tie::%SN_%SU"));][{"%P{native definition}"!="C++ interface"}{
  '	LOG_D(("'
  ( get_global_var ( 'OWNER' ) |N ) '_tie::'
  %S |N '_'
  %S |U '));' 
 end // if
 if ( ( %P get_up ( 'native definition' ) ) %!= 'C++ interface' ) then
 begin
  #13#10

//	[{"%f_is_simple_call(%S)"!="true"}{	[{"%TN"!="void"}return ][{}{m_impl}(%f_with_gen_id(cpp,%f_ambiguous_resolve(%{OWNER},%S))(m_impl))]-\>%SN (<{, }%CN>);
  if ( ( [%f] is_simple_call %( %S )% ) %!= true ) then
  begin
   [%f] complex_tie_call %( %S )% 
  end // if
  else
  begin
   '	'
   if ( ( %T |N ) %!= 'void' ) then
   begin
    'return ' 
   end // if
   if NOT-EMPTY
   begin
    '('
    [%f] with_gen_id %( 'cpp' %, [%f] ambiguous_resolve %( ( get_global_var ( 'OWNER' ) ) %, %S )% )% '(m_impl))' 
   end // if
   NOP
   else
   begin
    'm_impl' 
   end // else
   '->'
   %S |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   ');'
//	}%f_complex_tie_call(%S)]]%f_DLL_CATCH(%S)
  end // else
 end // if
 else
 begin
  #13#10

//		%U[{_NATIVE}
  '	'
  %Usersection (
   '_NATIVE' 
  )
  (
   #13#10

//		]
   '	' 
  ) // Usersection
 //	}
 end // else
 [%f] DLL_CATCH %( %S )% 
//	}[
 '}'
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP

///S - интерфейс для которого нужно специфицировать операцию
///1 - оперция, которую нужно специфицировать
//f _specify_operation
; // tie_operation_dll_cpp

: specify_operation OBJECT IN %S
//	[{<{}{%CU=%1U}{C}>=0&%f_inherit_more_than_one(%S)=true}%f_type(%1%P)::]

//f _ambiguous_resolve
; // specify_operation

: ambiguous_resolve OBJECT IN %S
//	[{%SU!=%1%PU&%f_inherit_more_than_one(%S)=true&%f_inherit_more_than_one_op(%S,%1)=true}dynamic_cast\<%f_type(%1%P)*\>]
 if ( ( %S |U ) %!= ( %1 ->P |U  ) AND 
   ( ( [%f] inherit_more_than_one %( %S )% ) %==  true  ) AND 
   ( ( [%f] inherit_more_than_one_op %( %S %, %1 )% ) %==  true  ) ) then
 begin
  'dynamic_cast<'
  [%f] type %( %1 ->P  )% '*>' 
 end // if

//f _inherit_more_than_one
; // ambiguous_resolve

: inherit_more_than_one OBJECT IN %S
//	[{%Gx=true&%Rx=true}{[{%Gx=true&<{}{}{%GC}>!=1}{[{%Rx=true&<{}{}{%RC}>!=1}{false}true]}true]}true]
 if ( ( %G |x ) %==  true AND 
   ( ( %R |x ) %==  true  ) ) then
 begin
   true 
 end // if
 else
 begin
  if ( ( %G |x ) %==  true AND 
    ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%G
   begin
    OBJECT IN %G
    if true then
    begin

     ++! l_Counter
    end // if
   end // for G
   l_Counter
   %!= 1  ) ) then
  begin
    true 
  end // if
  else
  begin
   if ( ( %R |x ) %==  true AND 
     ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%R
    begin
     OBJECT IN %R
     if true then
     begin

      ++! l_Counter
     end // if
    end // for R
    l_Counter
    %!= 1  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // else
 end // else

//f _inherit_more_than_one_op
; // inherit_more_than_one

: inherit_more_than_one_op OBJECT IN %S
//	%f_with_gen_id(h,%f_inherit_more_than_one_op_impl(%S,%1))
 [%f] with_gen_id %( 'h' %, [%f] inherit_more_than_one_op_impl %( %S %, %1 )% )% 

//f _inherit_more_than_one_op_impl
; // inherit_more_than_one_op

: inherit_more_than_one_op_impl OBJECT IN %S
//	%f_clear_list(INHERITED_OPS)%f_set_var(ARG,1)\
 [%f] clear_list %( 'INHERITED_OPS' )% [%f] set_var %( 'ARG' %, 1 )% 
//	<%G<{}{%CC=Operation&%f_is_factory(%C)=false}%f_add_to_list(INHERITED_OPS,"%f_op_impl(%C)")>>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |C ) %== 'Operation' AND 
      ( ( [%f] is_factory %( %C )% ) %==  false  ) ) then
     begin
      [%f] add_to_list %( 'INHERITED_OPS' %, [%f] op_impl %( %C )% )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for G
//	<%R<{}{%CC=Operation&%f_is_factory(%C)=false}%f_add_to_list(INHERITED_OPS,"%f_op_impl(%C)")>>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%R
 begin
  OBJECT IN %R
  if true then
  begin
   %R
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |C ) %== 'Operation' AND 
      ( ( [%f] is_factory %( %C )% ) %==  false  ) ) then
     begin
      [%f] add_to_list %( 'INHERITED_OPS' %, [%f] op_impl %( %C )% )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for R
//	[{%f_count_in_list(INHERITED_OPS,"%f_op_impl(%{ARG})")!=0&%f_count_in_list(INHERITED_OPS,"%f_op_impl(%{ARG})")!=1}{false}true]%f_clear_list(INHERITED_OPS)
 if ( ( [%f] count_in_list %( 'INHERITED_OPS' %, [%f] op_impl %( ( get_global_var ( 'ARG' ) ) )% )% ) %!= 0 AND 
   ( ( [%f] count_in_list %( 'INHERITED_OPS' %, [%f] op_impl %( ( get_global_var ( 'ARG' ) ) )% )% ) %!= 1  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
 [%f] clear_list %( 'INHERITED_OPS' )% 

//f _op_impl
; // inherit_more_than_one_op_impl

: op_impl OBJECT IN %S
//	[%f_ret(%S),%SN,%SS (<%f_arg_full_decl(%C)>)]
 if NOT-EMPTY
 begin
  [%f] ret %( %S )% ','
  %S |N ','
  %S |S ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ')' 
 end // if
 NOP
//#UC END# *4717548C02AF*
; // op_impl


// конвертирует простой тип вобъектный (для java)
//t _to_object_type
<<transformator>> to_object_type OBJECT IN %S
//#UC START# *4717549602BF*
//c                                                    {}
//r %f_check_if_type(%T,"integer")=true:               {new Integer (%1N)}
//r %f_check_if_type(%T,"long")=true:                  {new Integer (%1N)}
//r %f_check_if_type(%T,"unsigned integer")=true:      {new Integer (%1N)}
//r %f_check_if_type(%T,"unsigned long")=true:         {new Integer (%1N)}
//r %f_check_if_type(%T,"long long")=true:             {new Long (%1N)}
//r %f_check_if_type(%T,"booolean")=true:              {new Boolean (%1N)}
//r %f_check_if_type(%T,"char")=true:                  {new Character (%1N)}
//r %f_check_if_type(%T,"short")=true:                 {new Short (%1N)}
//r %f_check_if_type(%T,"unsigned short")=true:        {new Short (%1N)}
//r %f_check_if_type(%T,"unsigned char")=true:         {new Character (%1N)}
//r %f_check_if_type(%T,"double")=true:                {new Double (%1N)}
//r %f_check_if_type(%T,"float")=true:                 {new Float (%1N)}
//r %f_check_if_type(%T,"boolean")=true:               {new Boolean (%1N)}
//r ""="":                                             {%1N}

//t _convert_to_object_type
; // to_object_type

<<transformator>> convert_to_object_type OBJECT IN %S
//c                                                    {}
//r %f_check_if_type(%S,"integer")=true:               {Integer}
//r %f_check_if_type(%S,"long")=true:                  {Integer}
//r %f_check_if_type(%S,"unsigned integer")=true:      {Integer}
//r %f_check_if_type(%S,"unsigned long")=true:         {Integer}
//r %f_check_if_type(%S,"long long")=true:             {Long}
//r %f_check_if_type(%S,"booolean")=true:              {Boolean}
//r %f_check_if_type(%S,"char")=true:                  {Character}
//r %f_check_if_type(%S,"short")=true:                 {Short}
//r %f_check_if_type(%S,"unsigned short")=true:        {Short}
//r %f_check_if_type(%S,"unsigned char")=true:         {Character}
//r %f_check_if_type(%S,"double")=true:                {Double}
//r %f_check_if_type(%S,"float")=true:                 {Float}
//r %f_check_if_type(%S,"boolean")=true:               {Boolean}
//r ""="":                                             {%f_type(%S)}
//#UC END# *4717549602BF*
; // convert_to_object_type


// генерит параметры для InstanceDef
//f _instdef_args
: instdef_args OBJECT IN %S
//#UC START# *471839B9037A*
//	%f_clear_list(__TPL_PARAMS__)\
 [%f] clear_list %( '__TPL_PARAMS__' )% 
//	%f_set_var(NON_DEF,"false")\
 [%f] set_var %( 'NON_DEF' %, false )% 
//	%f_set_var(SELF,S)%R<{}{"%CC"="Parameter"}{r}%f_set_var(ARG,C)%f_add_to_list(__TPL_PARAMS__,"[{}{[{%{NON_DEF}N=true}%CI]}%{SELF}<{}{"%{ARG}N"="%CN"}%f_type(%C%T)%f_set_var(NON_DEF,"true")>]")>\
 [%f] set_var %( 'SELF' %, 'S' )% %R
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for downto %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Parameter' ) then
   begin
    [%f] set_var %( 'ARG' %, 'C' )% [%f] add_to_list %( '__TPL_PARAMS__' %, if NOT-EMPTY
    begin
     ( get_global_var ( 'SELF' ) ) 
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( ( get_global_var ( 'ARG' ) |N ) ) %== ( %C |N ) ) then
       begin
        [%f] type %( %C ->T  )% [%f] set_var %( 'NON_DEF' %, true )% 
        ++! l_Counter
       end // if
      end // for C

     ) // bind
    end // if
    NOP
    else
    begin
     if ( ( ( get_global_var ( 'NON_DEF' ) |N ) ) %==  true ) then
     begin
      %C |I 
     end // if
    end // else
)% 
    ++! l_Counter
   end // if
  end // for C

 ) // bind
 //	%f_remove_from_list(__TPL_PARAMS__,"")\
 [%f] remove_from_list %( '__TPL_PARAMS__' %, '' )% 
//	<{, }{%f_is_empty(__TPL_PARAMS__)=false}{W}[%f_pop_last_to_var(__TPL_PARAMS__,__PARAM__)%{__PARAM__}N]>
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( '__TPL_PARAMS__' )% ) %==  false ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   if NOT-EMPTY
   begin
    [%f] pop_last_to_var %( '__TPL_PARAMS__' %, '__PARAM__' )% ( get_global_var ( '__PARAM__' ) |N ) 
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//#UC END# *471839B9037A*
; // instdef_args


// генерит типы для менеджра фабрик серверного интерфейса
//f _srv_fctr_mng_fctr_h
: srv_fctr_mng_fctr_h OBJECT IN %S
//#UC START# *47183BA201C5*
//		// for cached factory %SN[{[{<{}{%CS!=cache}{%CC}>!=0}{false}true]=true||%SS=multi factory}
 '	// for cached factory '
 %S |N if ( if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'cache' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
  %==  true OR 
   (  ) OR 
   ( ( %S |S ) %== 'multi factory'  ) ) then
 begin
  #13#10

//		struct ObjectCreationIdFor%f_to_borland(%SN) {
  '	struct ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' {'
//	<{}{"%CS"!="nokey"&%CS!=cache}		%S%f_cache_attr(%C)_arg;
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' AND 
    ( ( %C |S ) %!= 'cache'  ) ) then
   begin
    '		'
    %S %f cache_attr %( %C )% '_arg;'
//	>

    ++! l_Counter
   end // if
  end // for C
//			ObjectCreationIdFor%f_to_borland(%SN) (<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>)[ : <{, }{"%CS"!="nokey"}%CN_arg (%CN)>] {
  '		ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ')'
  if NOT-EMPTY
  begin
   ' : '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N '_arg ('
     %C |N ')' 
     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
  ' {'
//			}
  '		}'
//	
  #13#10

//			bool operator \< (const ObjectCreationIdFor%f_to_borland(%SN)& c) const {
  '		bool operator < (const ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '& c) const {'
//				return [{}{false}<{ ? true : }{"%CS"!="nokey"}%CN_arg \< c.%CN_arg>];
  '			return '
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ' ? true : ' )
     %C |N '_arg < c.'
     %C |N '_arg' 
     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
  else
  begin
    false 
  end // else
  ';'
//			}
  '		}'
//		};
  '	};'
//	
  #13#10

//		typedef std::map\<ObjectCreationIdFor%f_to_borland(%SN), %f_var(%{INT})\> CachedObjectsFor%f_to_borland(%SN);
  '	typedef std::map<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  [%f] var %( ( get_global_var ( 'INT' ) ) )% '> CachedObjectsFor'
  [%f] to_borland %( %S |N )% ';'
//		typedef std::map\<CORBA::ULong, CachedObjectsFor%f_to_borland(%SN)::iterator\> CachedObjectsIndexFor%f_to_borland(%SN);
  '	typedef std::map<CORBA::ULong, CachedObjectsFor'
  [%f] to_borland %( %S |N )% '::iterator> CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ';'
//		typedef ACE_Singleton \<CachedObjectsFor%f_to_borland(%SN), ACE_SYNCH_RECURSIVE_MUTEX\> CachedObjectsFor%f_to_borland(%SN)Sngl;
  '	typedef ACE_Singleton <CachedObjectsFor'
  [%f] to_borland %( %S |N )% ', ACE_SYNCH_RECURSIVE_MUTEX> CachedObjectsFor'
  [%f] to_borland %( %S |N )% 'Sngl;'
//		typedef ACE_Singleton \<CachedObjectsIndexFor%f_to_borland(%SN), ACE_SYNCH_RECURSIVE_MUTEX\> CachedObjectsIndexFor%f_to_borland(%SN)Sngl;][{[{<{}{%CS!=cache}{%CC}>!=0}{false}true]=false}
  '	typedef ACE_Singleton <CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ', ACE_SYNCH_RECURSIVE_MUTEX> CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% 'Sngl;' 
 end // if
 if ( if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'cache' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
  %==  false ) then
 begin
  #13#10

//		typedef ACE_Singleton \<%f_var(%{INT}), ACE_SYNCH_RECURSIVE_MUTEX\> CachedObjectFor%f_to_borland(%SN);
  '	typedef ACE_Singleton <'
  [%f] var %( ( get_global_var ( 'INT' ) ) )% ', ACE_SYNCH_RECURSIVE_MUTEX> CachedObjectFor'
  [%f] to_borland %( %S |N )% ';'
//		static CORBA::ULong s_cached_object_hash_for_%SN;]
  '	static CORBA::ULong s_cached_object_hash_for_'
  %S |N ';' 
 end // if
//	
//		static Core::Mutex s_mutex_for_%SN;
 '	static Core::Mutex s_mutex_for_'
 %S |N ';'
//#UC END# *47183BA201C5*
; // srv_fctr_mng_fctr_h


// генерит типы для менеджра фабрик серверного интерфейса
//f _srv_fctr_mng_fctr_java
: srv_fctr_mng_fctr_java OBJECT IN %S
//#UC START# *47183BAA008C*
//		// for cached factory %SN[{%Cx=true|%SS=multi factory}
 '	// for cached factory '
 %S |N if ( ( %C |x ) %==  true OR 
   ( ( %S |S ) %== 'multi factory'  ) ) then
 begin
  #13#10

//		static class ObjectCreationIdFor%f_to_borland(%SN) {
  '	static class ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' {'
//	<{}{"%CS"!="nokey"}		[{%f_check_if_type(%C%T,"string")=false}{String %f_to_java(%CN)Arg;}%f_arg_full_decl(%C)Arg;]
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    '		'
    if ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  false ) then
    begin
     [%f] arg_full_decl %( %C )% 'Arg;' 
    end // if
    else
    begin
     'String '
     [%f] to_java %( %C |N )% 'Arg;' 
    end // else
//	>

    ++! l_Counter
   end // if
  end // for C
//			ObjectCreationIdFor%f_to_borland(%SN) (<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>) {
  '		ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] arg_full_decl %( %C )% 
    ++! l_Counter
   end // if
  end // for C
  ') {'
//	[<{}{"%CS"!="nokey"}			this.%f_to_java(%CN)Arg = %f_to_java(%CN);
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     '			this.'
     [%f] to_java %( %C |N )% 'Arg = '
     [%f] to_java %( %C |N )% ';'
//	>]		}

     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
  '		}'
//		}
  '	}'
//	
  #13#10

//	%f_comparator_for_cached_object(%S)
  [%f] comparator_for_cached_object %( %S )% 
//	
  #13#10

//		static class CachedObjectsFor%f_to_borland(%SN)Sngl {
  '	static class CachedObjectsFor'
  [%f] to_borland %( %S |N )% 'Sngl {'
//			private static java.util.Map\<ObjectCreationIdFor%f_to_borland(%SN), %f_type(%{INT})\> CachedObjectsFor%f_to_borland(%SN) = null;
  '		private static java.util.Map<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% '> CachedObjectsFor'
  [%f] to_borland %( %S |N )% ' = null;'
//	
  #13#10

//			public static synchronized java.util.Map\<ObjectCreationIdFor%f_to_borland(%SN), %f_type(%{INT})\> instance () {
  '		public static synchronized java.util.Map<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% '> instance () {'
//				if (CachedObjectsFor%f_to_borland(%SN) == null) {
  '			if (CachedObjectsFor'
  [%f] to_borland %( %S |N )% ' == null) {'
//					CachedObjectsFor%f_to_borland(%SN) =
  '				CachedObjectsFor'
  [%f] to_borland %( %S |N )% ' ='
//						new java.util.TreeMap\<ObjectCreationIdFor%f_to_borland(%SN), %f_type(%{INT})\> (new ObjectCreationIdFor%f_to_borland(%SN)Comparator ());
  '					new java.util.TreeMap<ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% ', '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% '> (new ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% 'Comparator ());'
//				}
  '			}'
//				return CachedObjectsFor%f_to_borland(%SN);
  '			return CachedObjectsFor'
  [%f] to_borland %( %S |N )% ';'
//			}
  '		}'
//		}
  '	}'
//		
  '	'
//		static class CachedObjectsIndexFor%f_to_borland(%SN)Sngl {
  '	static class CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% 'Sngl {'
//			private static java.util.Map\<Integer, ObjectCreationIdFor%f_to_borland(%SN)\> CachedObjectsIndexFor%f_to_borland(%SN) = null;
  '		private static java.util.Map<Integer, ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '> CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ' = null;'
//	
  #13#10

//			public static synchronized java.util.Map\<Integer, ObjectCreationIdFor%f_to_borland(%SN)\> instance () {
  '		public static synchronized java.util.Map<Integer, ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '> instance () {'
//				if (CachedObjectsIndexFor%f_to_borland(%SN) == null) {
  '			if (CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ' == null) {'
//					CachedObjectsIndexFor%f_to_borland(%SN) =
  '				CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ' ='
//						new java.util.TreeMap\<Integer, ObjectCreationIdFor%f_to_borland(%SN)\> ();
  '					new java.util.TreeMap<Integer, ObjectCreationIdFor'
  [%f] to_borland %( %S |N )% '> ();'
//				}
  '			}'
//				return CachedObjectsIndexFor%f_to_borland(%SN);
  '			return CachedObjectsIndexFor'
  [%f] to_borland %( %S |N )% ';'
//			}
  '		}'
//		}][{%Cx=false}
  '	}' 
 end // if
 if ( ( %C |x ) %==  false ) then
 begin
  #13#10

//		static class CachedObjectFor%f_to_borland(%SN) {
  '	static class CachedObjectFor'
  [%f] to_borland %( %S |N )% ' {'
//			private static %f_type(%{INT}) INSTANCE = null;
  '		private static '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% ' INSTANCE = null;'
//			
  '		'
//			public static %t_ret(%{INT}) instance () {
  '		public static '
  [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' instance () {'
//				return INSTANCE;
  '			return INSTANCE;'
//			}
  '		}'
//			
  '		'
//			public static void setInstance (%f_type(%{INT}) inst) {
  '		public static void setInstance ('
  [%f] type %( ( get_global_var ( 'INT' ) ) )% ' inst) {'
//				INSTANCE = inst;
  '			INSTANCE = inst;'
//			}
  '		}'
//		}
  '	}'
//		
  '	'
//		private static Integer cachedObjectHashFor%f_to_borland(%SN)_ = new Integer (0);]
  '	private static Integer cachedObjectHashFor'
  [%f] to_borland %( %S |N )% '_ = new Integer (0);' 
 end // if
//#UC END# *47183BAA008C*
; // srv_fctr_mng_fctr_java


// генерит конструктор по-умолчению для структуры
// TODO: Надо бы перенести на стереотип
//f _dump_def_init_ctor
: dump_def_init_ctor OBJECT IN %S
//#UC START# *4718465203B9*
//	[{<{}{"%CI"!=""&%CC=Attribute}{C}>!=0}%f_dump_def_init_ctor_header(%S)
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |I ) %!= '' AND 
    ( ( %C |C ) %== 'Attribute'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
  [%f] dump_def_init_ctor_header %( %S )% 
//	#		%U[{_DEF_INIT_CTOR!cpp!}
  out_indent '		'
  %Usersection (
   '_DEF_INIT_CTOR!cpp!' 
  )
  (
   #13#10

//	#		]
   out_indent '		' 
  ) // Usersection
 //	#	}
  out_indent '	}'
//	]
 end // if

//f _dump_def_init_ctor_header
; // dump_def_init_ctor

: dump_def_init_ctor_header OBJECT IN %S
//	%f_set_var(HEADER,"#	%SN () : <{, }{"%CI"!=""&%CC=Attribute}%CN(%f_init(%C))> {")\
 [%f] set_var %( 'HEADER' %, out_indent '	'
 %S |N ' () : '
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |I ) %!= '' AND 
   ( ( %C |C ) %== 'Attribute'  ) ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |N '('
   [%f] init %( %C )% ')' 
   ++! l_Counter
  end // if
 end // for C
 ' {' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{HEADER}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'HEADER' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","100","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 100 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true}{%{HEADER}N}#	%SN ()
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true ) then
 begin
  out_indent '	'
  %S |N ' ()'
//	#		: <{#		, }{"%CI"!=""&%CC=Attribute}%CN(%f_init(%C))
  out_indent '		: '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |I ) %!= '' AND 
    ( ( %C |C ) %== 'Attribute'  ) ) then
   begin
    if ( l_Counter >0 ) then ( out_indent '		, ' )
    %C |N '('
    [%f] init %( %C )% ')'
//	>#	{]

    ++! l_Counter
   end // if
  end // for C
  out_indent '	{' 
 end // if
 else
 begin
  ( get_global_var ( 'HEADER' ) |N ) 
 end // else

//f _struct_init_ctor_header_h
; // dump_def_init_ctor_header

: struct_init_ctor_header_h OBJECT IN %S
//	%f_set_var(HEADER,"#	%SN (<{, }{%CC=Attribute}[{%Cl!=lnk}{%f_attr(%C)}%t_arg(%C%T,"in")] %CN_>);")\
 [%f] set_var %( 'HEADER' %, out_indent '	'
 %S |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Attribute' ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   if ( ( %C |l ) %!= 'lnk' ) then
   begin
    [%t] arg %( %C ->T  %, 'in' )% 
   end // if
   else
   begin
    [%f] attr %( %C )% 
   end // else
   ' '
   %C |N '_' 
   ++! l_Counter
  end // if
 end // for C
 ');' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{HEADER}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'HEADER' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","100","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 100 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true}{%{HEADER}N}#	%SN (
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true ) then
 begin
  out_indent '	'
  %S |N ' ('
//	#		<{#		, }{%CC=Attribute}[{%Cl!=lnk}{%f_attr(%C)}%t_arg(%C%T,"in")] %CN_
  out_indent '		'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Attribute' ) then
   begin
    if ( l_Counter >0 ) then ( out_indent '		, ' )
    if ( ( %C |l ) %!= 'lnk' ) then
    begin
     [%t] arg %( %C ->T  %, 'in' )% 
    end // if
    else
    begin
     [%f] attr %( %C )% 
    end // else
    ' '
    %C |N '_'
//	>#	);]

    ++! l_Counter
   end // if
  end // for C
  out_indent '	);' 
 end // if
 else
 begin
  ( get_global_var ( 'HEADER' ) |N ) 
 end // else

//f _struct_init_ctor_header_cpp
; // struct_init_ctor_header_h

: struct_init_ctor_header_cpp OBJECT IN %S
//	%f_set_var(HEADER,"%f_templ_header(%S)%f_function_scope(%S)%SN (<{, }{%CC=Attribute}[{%Cl!=lnk}{%f_with_gen_id(h,%f_attr(%C))}%t_arg(%C%T,"in")] %CN_>)")\
 [%f] set_var %( 'HEADER' %, [%f] templ_header %( %S )% [%f] function_scope %( %S )% %S |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Attribute' ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   if ( ( %C |l ) %!= 'lnk' ) then
   begin
    [%t] arg %( %C ->T  %, 'in' )% 
   end // if
   else
   begin
    [%f] with_gen_id %( 'h' %, [%f] attr %( %C )% )% 
   end // else
   ' '
   %C |N '_' 
   ++! l_Counter
  end // if
 end // for C
 ')' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{HEADER}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'HEADER' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","100","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 100 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true}{%{HEADER}N}%f_templ_header(%S)%f_function_scope(%S)%SN (
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true ) then
 begin
  [%f] templ_header %( %S )% [%f] function_scope %( %S )% %S |N ' ('
//		<{	, }{%CC=Attribute}[{%Cl!=lnk}{%f_with_gen_id(h,%f_attr(%C))}%t_arg(%C%T,"in")] %CN_
  '	'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Attribute' ) then
   begin
    if ( l_Counter >0 ) then ( '	, ' )
    if ( ( %C |l ) %!= 'lnk' ) then
    begin
     [%t] arg %( %C ->T  %, 'in' )% 
    end // if
    else
    begin
     [%f] with_gen_id %( 'h' %, [%f] attr %( %C )% )% 
    end // else
    ' '
    %C |N '_'
//	>)]

    ++! l_Counter
   end // if
  end // for C
  ')' 
 end // if
 else
 begin
  ( get_global_var ( 'HEADER' ) |N ) 
 end // else
//#UC END# *4718465203B9*
; // struct_init_ctor_header_cpp


// генерит конструктор по-умолчению для структуры
// TODO: Надо бы перенести на стереотип
//f _dump_def_init_ctor_java
: dump_def_init_ctor_java OBJECT IN %S
//#UC START# *4718465A0290*
//	[{<{}{"%CI"!=""&%CC=Attribute}{C}>!=0}#	public %SN () {
//	<{\n}{"%CI"!=""&%CC=Attribute}#		this.%f_to_java(%CN)_ = %f_init(%C);>
//	#		%U[{_DEF_INIT_CTOR!java!}
//	#		]
//	#	}
//	]
//#UC END# *4718465A0290*
; // dump_def_init_ctor_java


// генерит конструктор по-умолчению для функтора
// TODO: Надо бы перенести на стереотип
//f _h_dump_def_init_ctor
: h_dump_def_init_ctor OBJECT IN %S
//#UC START# *4718466202AF*
//	[{<{}{"%CI"!=""&%CC=Attribute}{C}>!=0}#	%SN ();
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |I ) %!= '' AND 
    ( ( %C |C ) %== 'Attribute'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
  out_indent '	'
  %S |N ' ();'
//	]
 end // if
//#UC END# *4718466202AF*
; // h_dump_def_init_ctor


// генерит конструктор по-умолчению для функтора
// TODO: Надо бы перенести на стереотип
//f _impl_dump_def_init_ctor
: impl_dump_def_init_ctor OBJECT IN %S
//#UC START# *4718466B009C*
//	[{<{}{"%CI"!=""&%CC=Attribute}{C}>!=0}%SN::%SN () : <{, }{"%CI"!=""&%CC=Attribute}%CN(%CI)> {
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |I ) %!= '' AND 
    ( ( %C |C ) %== 'Attribute'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
  %S |N '::'
  %S |N ' () : '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |I ) %!= '' AND 
    ( ( %C |C ) %== 'Attribute'  ) ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N '('
    %C |I ')' 
    ++! l_Counter
   end // if
  end // for C
  ' {'
//		%U[{_DEF_INIT_CTOR!cpp!}
  '	'
  %Usersection (
   '_DEF_INIT_CTOR!cpp!' 
  )
  (
   #13#10

//		]
   '	' 
  ) // Usersection
 //	}
  '}'
//	]
 end // if
//#UC END# *4718466B009C*
; // impl_dump_def_init_ctor


// не понятно...
//f _has_it_cc
: has_it_cc OBJECT IN %S
//#UC START# *471847200177*
//	[{%SS=Set|%SS=Map|%SS=UnsortedSet|%SS=UnsortedMap|%SS=Vector|%SS=Queue|%SS=HashMap|%SS=Box|%SN=a-string|%SN=c-string|%SN=a-wstring}{false}true]
 if ( ( %S |S ) %== 'Set' OR 
   ( ( %S |S ) %== 'Map'  ) OR 
   ( ( %S |S ) %== 'UnsortedSet'  ) OR 
   ( ( %S |S ) %== 'UnsortedMap'  ) OR 
   ( ( %S |S ) %== 'Vector'  ) OR 
   ( ( %S |S ) %== 'Queue'  ) OR 
   ( ( %S |S ) %== 'HashMap'  ) OR 
   ( ( %S |S ) %== 'Box'  ) OR 
   ( ( %S |N ) %== 'a-string'  ) OR 
   ( ( %S |N ) %== 'c-string'  ) OR 
   ( ( %S |N ) %== 'a-wstring'  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *471847200177*
; // has_it_cc


// дампит реализацию фабричного метода для менеджера фабрик при использовании общей памяти
//f _fctr_mng_mem_cpp
: fctr_mng_mem_cpp OBJECT IN %S
//#UC START# *4755043603A1*
//		GUARD(m_mutex_for_%f_to_omg(%TN));
 '	GUARD(m_mutex_for_'
 [%f] to_omg %( %T |N )% ');'
//	[{<{}{"%CS"!="nokey"}{%CC}>!=0}	[%f_type(%T%P)FactoryManager::]%T%f_factory_mem_key_name() mem_key[{%T%Cx=true}{ (<{, }{"%CS"!="nokey"}%CN>)} ([%f_type(%T%P)FactoryManager::]%T%f_transfomator_name()::%SN_to_id (<{, }{%CS!=nokey}%CN>))];[
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
  '	'
  if NOT-EMPTY
  begin
   [%f] type %( %T ->P  )% 'FactoryManager::' 
  end // if
  NOP
  %T %f factory_mem_key_name %( )% ' mem_key'
  if ( ( %T ->C |x  ) %==  true ) then
  begin
   ' ('
   if NOT-EMPTY
   begin
    [%f] type %( %T ->P  )% 'FactoryManager::' 
   end // if
   NOP
   %T %f transfomator_name %( )% '::'
   %S |N '_to_id ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   '))' 
  end // if
  else
  begin
   ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   ')' 
  end // else
  ';'
  if NOT-EMPTY
  begin
   #13#10

//	%t_init_factory_key(%S)]
   [%t] init_factory_key %( %S )% 
  end // if
  NOP
//		%f_to_borland(%TNMap)::iterator f = m_%f_to_omg(%TN).find (mem_key);
  '	'
  [%f] to_borland %( %T |N 'Map' )% '::iterator f = m_'
  [%f] to_omg %( %T |N )% '.find (mem_key);'
//		if (f ==  m_%f_to_omg(%TN).end ()[{%S{const_type}=combo|%S{const_type}=read-only} || f-\>second[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.ptr()] == 0]) {
  '	if (f ==  m_'
  [%f] to_omg %( %T |N )% '.end ()'
  if ( ( %S get_up ( 'const_type' ) ) %== 'combo' OR 
    ( ( %S get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
  begin
   ' || f->second'
   if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, %1 |N )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.ptr()' 
   end // if
   ' == 0' 
  end // if
  ') {'
//	%t_select_mng_factory_mem_cpp_impl(%S,"","%1N")[{%Ss=synchro}
  [%t] select_mng_factory_mem_cpp_impl %( %S %, '' %, %1 |N )% if ( ( %S |s ) %== 'synchro' ) then
  begin
   #13#10

//			return f-\>second[.%f_cache_postfix(%S,"%1N")];]
   '		return f->second'
   if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, %1 |N )% 
   end // if
   NOP
   ';' 
  end // if
//		}[{%f_is_ro_fctr_exists(%S)=true&%1N=read-write} else if (
  '	}'
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true AND 
    ( ( %1 |N ) %== 'read-write'  ) ) then
  begin
   ' else if ('
//			f != m_%f_to_omg(%TN).end ()
   '		f != m_'
   [%f] to_omg %( %T |N )% '.end ()'
//			&& f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr()] != 0
   '		&& f->second'
   if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.ptr()' 
   end // if
   ' != 0'
//			&& f-\>second.is_ro_first == true
   '		&& f->second.is_ro_first == true'
//		) {
   '	) {'
//			f-\>second[.%f_cache_postfix(%S,"read-only")]-\>upgrade_rw ();
   '		f->second'
   if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   '->upgrade_rw ();'
//			f-\>second.is_ro_first = false;
   '		f->second.is_ro_first = false;'
//		}
   '	}'
//	]][{<{}{"%CS"!="nokey"}{%CC}>=0}	[%f_type(%T%P)FactoryManager::]%T%f_factory_mem_key_name() mem_key;
  end // if
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %== 0 ) then
 begin
  '	'
  if NOT-EMPTY
  begin
   [%f] type %( %T ->P  )% 'FactoryManager::' 
  end // if
  NOP
  %T %f factory_mem_key_name %( )% ' mem_key;'
//		%f_to_borland(%TNMap)::iterator f;
  '	'
  [%f] to_borland %( %T |N 'Map' )% '::iterator f;'
//	%t_select_mng_factory_mem_create_cpp_impl(%S,"","%1N")
  [%t] select_mng_factory_mem_create_cpp_impl %( %S %, '' %, %1 |N )% 
//		GDS_ASSERT_MSG(insert_res.second != false, ("%P%P%PN::%P%PN::%PNFactory return duplicate memory key"))[{%Ss=synchro}
  '	GDS_ASSERT_MSG(insert_res.second != false, ("'
  %P ->P ->P |N   '::'
  %P ->P |N  '::'
  %P |N 'Factory return duplicate memory key"))'
  if ( ( %S |s ) %== 'synchro' ) then
  begin
   #13#10

//		GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"%1N")] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
   '	GDS_ASSERT_MSG (f->second'
   if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, %1 |N )% 
   end // if
   NOP
   ' != 0, ("'
   %P ->P ->P |N   '::'
   %P ->P |N  '::'
   %P |N 'Factory impl can''t return zerro"));'
//		return f-\>second[.%f_cache_postfix(%S,"%1N")];]
   '	return f->second'
   if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, %1 |N )% 
   end // if
   NOP
   ';' 
  end // if
//	][{<{}{"%CS"!="nokey"}{%CC}>!=0|%Ss!=synchro}
 end // if
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 OR 
   ( ( %S |s ) %!= 'synchro'  ) ) then
 begin
  #13#10

//		GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.in()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
  '	GDS_ASSERT_MSG (f->second'
  if NOT-EMPTY
  begin
   '.'
   [%f] cache_postfix %( %S %, %1 |N )% 
  end // if
  NOP
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   '.in()' 
  end // if
  ' != 0, ("'
  %P ->P ->P |N   '::'
  %P ->P |N  '::'
  %P |N 'Factory impl can''t return zerro"));'
//		return [{%{INT}S!=ServerInterface&%Ss!=synchro}{%{INT}N::_duplicate(f-\>second[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.in()])}*f-\>second[.%f_cache_postfix(%S,"%1N")]];]
  '	return '
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
    ( ( %S |s ) %!= 'synchro'  ) ) then
  begin
   '*f->second'
   if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, %1 |N )% 
   end // if
   NOP
  end // if
  else
  begin
   ( get_global_var ( 'INT' ) |N ) '::_duplicate(f->second'
   if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, %1 |N )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
   ')' 
  end // else
  ';' 
 end // if


//t _init_factory_key
; // fctr_mng_mem_cpp

<<transformator>> init_factory_key OBJECT IN %S
//c                                      {}
//r {%SS=multi factory&%S{transparent multy}=false}:     {%f_init_multi_factory_key_cpp_impl(%S)}
//r {%SS=multi factory&"%S{transparent multy}"=""}:      {%f_init_multi_factory_key_cpp_impl(%S)}
//r {%SS=multi factory&%S{transparent multy}=true}:      {%f_init_multi_factory_key_transp_cpp_impl(%S)}
//r {%T%f_use_for_multi_factory()=true}:                 {%f_init_factory_key_impl(%S)}
//r {}:                                                  {}

//f _init_multi_factory_key_cpp_impl
; // init_factory_key

: init_multi_factory_key_cpp_impl OBJECT IN %S
//		mem_key.key_arg = key;
 '	mem_key.key_arg = key;'

//f _init_factory_key_impl
; // init_multi_factory_key_cpp_impl

: init_factory_key_impl OBJECT IN %S
//		if (m_single_active_factory.is_nil() == false) {
 '	if (m_single_active_factory.is_nil() == false) {'
//			mem_key.key_arg = m_single_active_factory-\>key ();
 '		mem_key.key_arg = m_single_active_factory->key ();'
//		}
 '	}'

//f _init_multi_factory_key_transp_cpp_impl
; // init_factory_key_impl

: init_multi_factory_key_transp_cpp_impl OBJECT IN %S
//		%U[{_CUSTOM_SELECT_FACTORY_KEY}
 '	'
 %Usersection (
  '_CUSTOM_SELECT_FACTORY_KEY' 
 )
 (
  #13#10

//		std::string key;
  '	std::string key;'
//		]
  '	' 
 ) // Usersection
 //	%f_init_multi_factory_key_cpp_impl(%S)
 [%f] init_multi_factory_key_cpp_impl %( %S )% 

//t _select_mng_factory_mem_cpp_impl
; // init_multi_factory_key_transp_cpp_impl

<<transformator>> select_mng_factory_mem_cpp_impl OBJECT IN %S
//c                                                      {}
//r {%SS=factory}:                                       {%f_fctr_mng_factory_mem_cpp_impl(%S,"%2N")}
//r {%SS=multi factory}:                                 {%f_fctr_mng_multi_factory_mem_cpp_impl(%S,"%2N")}

//t _select_mng_factory_mem_create_cpp_impl
; // select_mng_factory_mem_cpp_impl

<<transformator>> select_mng_factory_mem_create_cpp_impl OBJECT IN %S
//c                                                      {}
//r {%SS=factory}:                                       {%f_fctr_mng_factory_mem_create_cpp_impl(%S,"%2N")}
//r {%SS=multi factory}:                                 {%f_fctr_mng_multi_factory_mem_create_cpp_impl(%S,"%2N")}


//f _fctr_mng_factory_mem_create_cpp_impl
; // select_mng_factory_mem_create_cpp_impl

: fctr_mng_factory_mem_create_cpp_impl OBJECT IN %S
//		if (m_single_active_factory.is_nil()) {
 '	if (m_single_active_factory.is_nil()) {'
//			throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
 '		throw Core::Root::NoActiveFactory ("'
 %P ->P ->P |N   '::'
 %P ->P |N  '::'
 %P |N 'Factory");'
//		}
 '	}'
//		%t_ret(%{INT}) ret_ = m_single_active_factory-\>%SN (<%CN, >mem_key[{%f_is_ro_fctr_exists(%S)=true}, [{%1N=read-only}{false}true]]);[{%T%f_use_for_multi_factory()=true}
 '	'
 [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' ret_ = m_single_active_factory->'
 %S |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C |N ', ' 
   ++! l_Counter
  end // if
 end // for C
 'mem_key'
 if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
 begin
  ', '
  if ( ( %1 |N ) %== 'read-only' ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
 end // if
 ');'
 if ( ( %T %f use_for_multi_factory %( )% ) %==  true ) then
 begin
  #13#10

//		mem_key.key_arg = m_single_active_factory-\>key ();]
  '	mem_key.key_arg = m_single_active_factory->key ();' 
 end // if
//		std::pair\<%f_to_borland(%TNMap)::iterator, bool\> insert_res = m_%f_to_omg(%TN).insert (
 '	std::pair<'
 [%f] to_borland %( %T |N 'Map' )% '::iterator, bool> insert_res = m_'
 [%f] to_omg %( %T |N )% '.insert ('
//			%f_to_borland(%TNMap)::value_type (
 '		'
 [%f] to_borland %( %T |N 'Map' )% '::value_type ('
//				mem_key
 '			mem_key'
//				, ret_
 '			, ret_'
//			)
 '		)'
//		);
 '	);'
//		if (insert_res.second == true) {
 '	if (insert_res.second == true) {'
//			m_%f_to_omg(%TN)_index.insert (
 '		m_'
 [%f] to_omg %( %T |N )% '_index.insert ('
//				%f_to_borland(%TNIndexMap)::value_type (
 '			'
 [%f] to_borland %( %T |N 'IndexMap' )% '::value_type ('
//					ret_[{%f_is_server_type(%{INT})=true}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
 '				ret_'
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
 begin
  '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
 end // if
//					, insert_res.first
 '				, insert_res.first'
//				)
 '			)'
//			);[{%f_is_ro_fctr_exists(%S)&%1N=read-only}
 '		);'
 if ( ( [%f] is_ro_fctr_exists %( %S )% ) AND 
   ( ( %1 |N ) %== 'read-only'  ) ) then
 begin
  #13#10

//			[{%{INT}S=ServerInterface}{f-\>second[.%t_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
  '		'
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
  begin
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//				f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
   '			f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
//			);
   '		);'
//			f-\>second[.%t_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
   '		f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = wrapper->_this ();' 
  end // if
  else
  begin
   'f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//				f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
   '			f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
//			);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
   '		);' 
  end // else
//			insert_res.first-\>second.is_ro_first = true;]
  '		insert_res.first->second.is_ro_first = true;' 
 end // if
//		}[{%Ss=synchro} else {
 '	}'
 if ( ( %S |s ) %== 'synchro' ) then
 begin
  ' else {'
//			ret_-\>release ();
  '		ret_->release ();'
//		}]
  '	}' 
 end // if
//		f = insert_res.first;
 '	f = insert_res.first;'

//f _fctr_mng_multi_factory_mem_create_cpp_impl
; // fctr_mng_factory_mem_create_cpp_impl

: fctr_mng_multi_factory_mem_create_cpp_impl OBJECT IN %S
//	%t_init_factory_key(%S)
 [%t] init_factory_key %( %S )% 
//		FactoryMap::iterator f_fct = m_factories_map.find (key);
 '	FactoryMap::iterator f_fct = m_factories_map.find (key);'
//		if (f_fct == m_factories_map.end()) {
 '	if (f_fct == m_factories_map.end()) {'
//			[{%S{transparent multy}=false|"%S{transparent multy}"=""}{throw [{%f_realize_srv_interface(%S)=false}{CoreSrv::NoActiveFactory}Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");]}throw Core::Root::UnknownFactoryKey ("%P%P%PN::%P%PN::%PNFactory", [{%f_need_lexical_cast(%{INT})=true}{key}boost::lexical_cast\<std::string\> (key).c_str ()]);]
 '		'
 if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
   ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
 begin
  'throw Core::Root::UnknownFactoryKey ("'
  %P ->P ->P |N   '::'
  %P ->P |N  '::'
  %P |N 'Factory", '
  if ( ( [%f] need_lexical_cast %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   'boost::lexical_cast<std::string> (key).c_str ()' 
  end // if
  else
  begin
   'key' 
  end // else
  ');' 
 end // if
 else
 begin
  'throw '
  if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
  begin
   'Core::Root::NoActiveFactory ("'
   %P ->P ->P |N   '::'
   %P ->P |N  '::'
   %P |N 'Factory");' 
  end // if
  else
  begin
   'CoreSrv::NoActiveFactory' 
  end // else
 end // else
//		}
 '	}'
//		%t_ret(%{INT}) ret_ = f_fct-\>second.factory-\>%SN (<%CN, >mem_key[{%f_is_ro_fctr_exists(%S)=true}, [{%1N=read-only}{false}true]]);
 '	'
 [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' ret_ = f_fct->second.factory->'
 %S |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C |N ', ' 
   ++! l_Counter
  end // if
 end // for C
 'mem_key'
 if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
 begin
  ', '
  if ( ( %1 |N ) %== 'read-only' ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
 end // if
 ');'
//		std::pair\<%f_to_borland(%TNMap)::iterator, bool\> insert_res = m_%f_to_omg(%TN).insert (
 '	std::pair<'
 [%f] to_borland %( %T |N 'Map' )% '::iterator, bool> insert_res = m_'
 [%f] to_omg %( %T |N )% '.insert ('
//			%f_to_borland(%TNMap)::value_type (
 '		'
 [%f] to_borland %( %T |N 'Map' )% '::value_type ('
//				mem_key
 '			mem_key'
//				, ret_
 '			, ret_'
//			)
 '		)'
//		);
 '	);'
//		if (insert_res.second == true) {
 '	if (insert_res.second == true) {'
//			m_%f_to_omg(%TN)_index.insert (
 '		m_'
 [%f] to_omg %( %T |N )% '_index.insert ('
//				%f_to_borland(%TNIndexMap)::value_type (
 '			'
 [%f] to_borland %( %T |N 'IndexMap' )% '::value_type ('
//					ret_[{%f_is_server_type(%{INT})=true}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
 '				ret_'
 if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
 begin
  '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
 end // if
//					, insert_res.first
 '				, insert_res.first'
//				)
 '			)'
//			);[{%f_is_ro_fctr_exists(%S)&%1N=read-only}
 '		);'
 if ( ( [%f] is_ro_fctr_exists %( %S )% ) AND 
   ( ( %1 |N ) %== 'read-only'  ) ) then
 begin
  #13#10

//			[{%{INT}S=ServerInterface}{f-\>second[.%t_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
  '		'
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
  begin
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//				f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
   '			f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
//			);
   '		);'
//			f-\>second[.%t_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
   '		f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = wrapper->_this ();' 
  end // if
  else
  begin
   'f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//				f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
   '			f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
//			);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
   '		);' 
  end // else
//			insert_res.first-\>second.is_ro_first = true;]
  '		insert_res.first->second.is_ro_first = true;' 
 end // if
//		}[{%Ss=synchro} else {
 '	}'
 if ( ( %S |s ) %== 'synchro' ) then
 begin
  ' else {'
//			ret_-\>release ();
  '		ret_->release ();'
//		}]
  '	}' 
 end // if
//		f = insert_res.first;
 '	f = insert_res.first;'

//f _fctr_mng_factory_mem_cpp_impl
; // fctr_mng_multi_factory_mem_create_cpp_impl

: fctr_mng_factory_mem_cpp_impl OBJECT IN %S
//	[{%1N=read-only}{		if (m_single_active_factory.is_nil()) {
 if ( ( %1 |N ) %== 'read-only' ) then
 begin
  #13#10

//			f = m_%f_to_omg(%TN).insert (
  '		f = m_'
  [%f] to_omg %( %T |N )% '.insert ('
//				%f_to_borland(%TNMap)::value_type (
  '			'
  [%f] to_borland %( %T |N 'Map' )% '::value_type ('
//					mem_key
  '				mem_key'
//					, m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}, [{%1N=read-only}{false}true]])
  '				, m_single_active_factory->'
  %S |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
  begin
   ', '
   if ( ( %1 |N ) %== 'read-only' ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // if
  ')'
//				)
  '			)'
//			).first;
  '		).first;'
//			m_%f_to_omg(%TN)_index.insert (
  '		m_'
  [%f] to_omg %( %T |N )% '_index.insert ('
//				%f_to_borland(%TNIndexMap)::value_type (
  '			'
  [%f] to_borland %( %T |N 'IndexMap' )% '::value_type ('
//					f-\>second[{%f_is_server_type(%{INT})=true}{[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
  '				f->second'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
  end // if
  else
  begin
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
  end // else
//					, f
  '				, f'
//				)
  '			)'
//			);\
  '		);'
//	}		if (f ==  m_%f_to_omg(%TN).end ()) {
  '}		if (f ==  m_'
  [%f] to_omg %( %T |N )% '.end ()) {'
//				if (m_single_active_factory.is_nil()) {
  '			if (m_single_active_factory.is_nil()) {'
//					throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
  '				throw Core::Root::NoActiveFactory ("'
  %P ->P ->P |N   '::'
  %P ->P |N  '::'
  %P |N 'Factory");'
//				}
  '			}'
//				f = m_%f_to_omg(%TN).insert (
  '			f = m_'
  [%f] to_omg %( %T |N )% '.insert ('
//					%f_to_borland(%TNMap)::value_type (
  '				'
  [%f] to_borland %( %T |N 'Map' )% '::value_type ('
//						mem_key
  '					mem_key'
//						, m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}, [{%1N=read-only}{false}true]])
  '					, m_single_active_factory->'
  %S |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
  begin
   ', '
   if ( ( %1 |N ) %== 'read-only' ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // if
  ')'
//					)
  '				)'
//				).first;
  '			).first;'
//				m_%f_to_omg(%TN)_index.insert (
  '			m_'
  [%f] to_omg %( %T |N )% '_index.insert ('
//					%f_to_borland(%TNIndexMap)::value_type (
  '				'
  [%f] to_borland %( %T |N 'IndexMap' )% '::value_type ('
//						f-\>second[{%f_is_server_type(%{INT})=true}{[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
  '					f->second'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
  end // if
  else
  begin
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
  end // else
//						, f
  '					, f'
//					)
  '				)'
//				);
  '			);'
//				[{%{INT}S=ServerInterface}{f-\>second[.%t_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
  '			'
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
  begin
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
   '				f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
//				);
   '			);'
//				f-\>second[.%t_cache_postfix(%S,"read-only")] = wrapper-\>_this ();][{%f_is_ro_fctr_exists(%S)&%1N=read-only}
   '			f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = wrapper->_this ();' 
  end // if
  else
  begin
   'f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
   '				f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
//				);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
   '			);' 
  end // else
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) AND 
    ( ( %1 |N ) %== 'read-only'  ) ) then
  begin
   #13#10

//				f-\>second.is_ro_first = true;]
   '			f->second.is_ro_first = true;' 
  end // if
//			} else if (f-\>second[.%t_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr()] == 0) {
  '		} else if (f->second'
  if NOT-EMPTY
  begin
   '.'
   [%t] cache_postfix %( %S %, 'read-only' )% 
  end // if
  NOP
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   '.ptr()' 
  end // if
  ' == 0) {'
//				[{%{INT}S=ServerInterface}{f-\>second[.%t_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
  '			'
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
  begin
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()])
   '				'
   ( get_global_var ( 'INT' ) |N ) '::_duplicate (f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
   ')'
//				);
   '			);'
//				f-\>second[.%t_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
   '			f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = wrapper->_this ();' 
  end // if
  else
  begin
   'f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()])
   '				'
   ( get_global_var ( 'INT' ) |N ) '::_duplicate (f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
   ')'
//				);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
   '			);' 
  end // else
//			} else {
  '		} else {'
//				GDS_ASSERT_MSG(false, ("%P%P%PN::%P%PN::%PNFactory object created already"))
  '			GDS_ASSERT_MSG(false, ("'
  %P ->P ->P |N   '::'
  %P ->P |N  '::'
  %P |N 'Factory object created already"))'
//			}]
  '		}' 
 end // if
 else
 begin
  '		if (m_single_active_factory.is_nil()) {'
//				throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
  '			throw Core::Root::NoActiveFactory ("'
  %P ->P ->P |N   '::'
  %P ->P |N  '::'
  %P |N 'Factory");'
//			}
  '		' 
 end // else

//f _fctr_mng_multi_factory_mem_cpp_impl
; // fctr_mng_factory_mem_cpp_impl

: fctr_mng_multi_factory_mem_cpp_impl OBJECT IN %S
//	[{%1N=read-only}{		FactoryMap::iterator f_fct = m_factories_map.find (key);
 if ( ( %1 |N ) %== 'read-only' ) then
 begin
  #13#10

//			f = m_%f_to_omg(%TN).insert (
  '		f = m_'
  [%f] to_omg %( %T |N )% '.insert ('
//				%f_to_borland(%TNMap)::value_type (
  '			'
  [%f] to_borland %( %T |N 'Map' )% '::value_type ('
//					mem_key
  '				mem_key'
//					, f_fct-\>second.factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}, [{%1N=read-only}{false}true]])
  '				, f_fct->second.factory->'
  %S |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
  begin
   ', '
   if ( ( %1 |N ) %== 'read-only' ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // if
  ')'
//				)
  '			)'
//			).first;
  '		).first;'
//			m_%f_to_omg(%TN)_index.insert (
  '		m_'
  [%f] to_omg %( %T |N )% '_index.insert ('
//				%f_to_borland(%TNIndexMap)::value_type (
  '			'
  [%f] to_borland %( %T |N 'IndexMap' )% '::value_type ('
//					f-\>second[{%f_is_server_type(%{INT})=true}{[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
  '				f->second'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
  end // if
  else
  begin
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
  end // else
//					, f
  '				, f'
//				)
  '			)'
//			);\
  '		);'
//	}		if (f ==  m_%f_to_omg(%TN).end ()) {
  '}		if (f ==  m_'
  [%f] to_omg %( %T |N )% '.end ()) {'
//				FactoryMap::iterator f_fct = m_factories_map.find (key);
  '			FactoryMap::iterator f_fct = m_factories_map.find (key);'
//				if (f_fct == m_factories_map.end()) {
  '			if (f_fct == m_factories_map.end()) {'
//					[{%S{transparent multy}=false|"%S{transparent multy}"=""}{throw [{%f_realize_srv_interface(%S)=false}{CoreSrv::NoActiveFactory}Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");]}throw Core::Root::UnknownFactoryKey ("%P%P%PN::%P%PN::%PNFactory", [{%f_need_lexical_cast(%{INT})=true}{key}boost::lexical_cast\<std::string\> (key).c_str ()]);]
  '				'
  if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
    ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
  begin
   'throw Core::Root::UnknownFactoryKey ("'
   %P ->P ->P |N   '::'
   %P ->P |N  '::'
   %P |N 'Factory", '
   if ( ( [%f] need_lexical_cast %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
   begin
    'boost::lexical_cast<std::string> (key).c_str ()' 
   end // if
   else
   begin
    'key' 
   end // else
   ');' 
  end // if
  else
  begin
   'throw '
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
   begin
    'Core::Root::NoActiveFactory ("'
    %P ->P ->P |N   '::'
    %P ->P |N  '::'
    %P |N 'Factory");' 
   end // if
   else
   begin
    'CoreSrv::NoActiveFactory' 
   end // else
  end // else
//				}
  '			}'
//				f = m_%f_to_omg(%TN).insert (
  '			f = m_'
  [%f] to_omg %( %T |N )% '.insert ('
//					%f_to_borland(%TNMap)::value_type (
  '				'
  [%f] to_borland %( %T |N 'Map' )% '::value_type ('
//						mem_key
  '					mem_key'
//						, f_fct-\>second.factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}, [{%1N=read-only}{false}true]])
  '					, f_fct->second.factory->'
  %S |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
  begin
   ', '
   if ( ( %1 |N ) %== 'read-only' ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
  end // if
  ')'
//					)
  '				)'
//				).first;
  '			).first;'
//				m_%f_to_omg(%TN)_index.insert (
  '			m_'
  [%f] to_omg %( %T |N )% '_index.insert ('
//					%f_to_borland(%TNIndexMap)::value_type (
  '				'
  [%f] to_borland %( %T |N 'IndexMap' )% '::value_type ('
//						f-\>second[{%f_is_server_type(%{INT})=true}{[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
  '					f->second'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
  end // if
  else
  begin
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
  end // else
//						, f
  '					, f'
//					)
  '				)'
//				);
  '			);'
//				[{%{INT}S=ServerInterface}{f-\>second[.%t_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
  '			'
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
  begin
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
   '				f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
//				);
   '			);'
//				f-\>second[.%t_cache_postfix(%S,"read-only")] = wrapper-\>_this ();][{%f_is_ro_fctr_exists(%S)&%1N=read-only}
   '			f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = wrapper->_this ();' 
  end // if
  else
  begin
   'f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
   '				f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
//				);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
   '			);' 
  end // else
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) AND 
    ( ( %1 |N ) %== 'read-only'  ) ) then
  begin
   #13#10

//				f-\>second.is_ro_first = true;]
   '			f->second.is_ro_first = true;' 
  end // if
//			} else if (f-\>second[.%t_cache_postfix(%S,"%1N")][{%Ss!=synchro}.ptr ()] == 0) {
  '		} else if (f->second'
  if NOT-EMPTY
  begin
   '.'
   [%t] cache_postfix %( %S %, %1 |N )% 
  end // if
  NOP
  if ( ( %S |s ) %!= 'synchro' ) then
  begin
   '.ptr ()' 
  end // if
  ' == 0) {'
//				[{%{INT}S=ServerInterface}{f-\>second[.%t_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
  '			'
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
  begin
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()])
   '				'
   ( get_global_var ( 'INT' ) |N ) '::_duplicate (f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
   ')'
//				);
   '			);'
//				f-\>second[.%t_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
   '			f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = wrapper->_this ();' 
  end // if
  else
  begin
   'f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-only' )% 
   end // if
   NOP
   ' = new '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()])
   '				'
   ( get_global_var ( 'INT' ) |N ) '::_duplicate (f->second'
   if NOT-EMPTY
   begin
    '.'
    [%t] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( %S |s ) %!= 'synchro' ) then
   begin
    '.in()' 
   end // if
   ')'
//				);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
   '			);' 
  end // else
//			} else {
  '		} else {'
//				GDS_ASSERT_MSG(false, ("%P%P%PN::%P%PN::%PNFactory object created already"))
  '			GDS_ASSERT_MSG(false, ("'
  %P ->P ->P |N   '::'
  %P ->P |N  '::'
  %P |N 'Factory object created already"))'
//			}]
  '		}' 
 end // if
 else
 begin
  '		FactoryMap::iterator f_fct = m_factories_map.find (key);'
//			if (f_fct == m_factories_map.end()) {
  '		if (f_fct == m_factories_map.end()) {'
//				[{%S{transparent multy}=false|"%S{transparent multy}"=""}{throw [{%f_realize_srv_interface(%S)=false}{CoreSrv::NoActiveFactory}Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");]}throw Core::Root::UnknownFactoryKey ("%P%P%PN::%P%PN::%PNFactory", [{%f_need_lexical_cast(%{INT})=true}{key}boost::lexical_cast\<std::string\> (key).c_str ()]);]
  '			'
  if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
    ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
  begin
   'throw Core::Root::UnknownFactoryKey ("'
   %P ->P ->P |N   '::'
   %P ->P |N  '::'
   %P |N 'Factory", '
   if ( ( [%f] need_lexical_cast %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
   begin
    'boost::lexical_cast<std::string> (key).c_str ()' 
   end // if
   else
   begin
    'key' 
   end // else
   ');' 
  end // if
  else
  begin
   'throw '
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false ) then
   begin
    'Core::Root::NoActiveFactory ("'
    %P ->P ->P |N   '::'
    %P ->P |N  '::'
    %P |N 'Factory");' 
   end // if
   else
   begin
    'CoreSrv::NoActiveFactory' 
   end // else
  end // else
//			}
  '		' 
 end // else

//f _need_const_wrapper
; // fctr_mng_multi_factory_mem_cpp_impl

: need_const_wrapper OBJECT IN %S
//	[{%f_need_const_wrapper_impl(%S)=true|<{}{%ga=abstract&%f_need_const_wrapper_impl(%g)=true}{%gC}>!=0}{false}true]
 if ( ( [%f] need_const_wrapper_impl %( %S )% ) %==  true OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' AND 
    ( ( [%f] need_const_wrapper_impl %( %g )% ) %==  true  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for g
  l_Counter
  %!= 0  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//f _need_const_wrapper_impl
; // need_const_wrapper

: need_const_wrapper_impl OBJECT IN %S
//	[{<{}{%f_is_factory(%C)=true&"[{%C{const_type}=read-only|%C{const_type}=combo}{false}true]"="true"}{%CC}>!=0}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  true AND 
    ( if ( ( %C get_up ( 'const_type' ) ) %== 'read-only' OR 
     ( ( %C get_up ( 'const_type' ) ) %== 'combo'  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %== true  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else

//f _ptr
; // need_const_wrapper_impl

: ptr OBJECT IN %S
//	%t_ptr(%S,"%X{lid}")
 [%t] ptr %( %S %, %X get_up ( 'lid' ) )% 

//t _ptr
; // ptr

<<transformator>> ptr OBJECT IN %S
//c            {cpp}                  {java}
//r {""}:      {%f_type(%S)*}         {java.lang.ref.WeakReference\<%f_type(%S)\>}

//t _fctr_manager_cache_value
; // ptr

<<transformator>> fctr_manager_cache_value OBJECT IN %S
//c                                                                 {type}                  {var}
//r {"%2U"=""&%f_need_const_wrapper(%S)=true}:                      {ComboDataPtr}          {ComboDataVar}
//r {"%2U"=""}:                                                     {%f_ptr(%S)}            {%f_var(%S)}
//r {%2{const_type}=read-only|%2{const_type}=combo}:                {ComboDataPtr}          {ComboDataVar}
//r {""=""}:                                                        {%f_ptr(%S)}            {%f_var(%S)}


//f _interface_wrapper_func_java
; // fctr_manager_cache_value

: interface_wrapper_func_java OBJECT IN %S
//	#public [{%SS=oneway|%SS=oneway,chg}{%f_ret(%S) }/*oneway*/ Core::ThreadHandle ][{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}{%SN}%f_to_java(%SN)][{%PS!=ServerInterface&PS!=ServerFacet}[{%SS=oneway|%SS=oneway,chg}_]] (<{, }%f_arg_full_decl(%C)>) [throws <{, }%f_type(%E)> ]{
 out_indent 'public '
 if ( ( %S |S ) %== 'oneway' OR 
   ( ( %S |S ) %== 'oneway,chg'  ) ) then
 begin
  '/*oneway*/ Core::ThreadHandle ' 
 end // if
 else
 begin
  [%f] ret %( %S )% ' ' 
 end // else
 if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
   ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
 begin
  [%f] to_java %( %S |N )% 
 end // if
 else
 begin
  %S |N 
 end // else
 if ( ( %P |S ) %!= 'ServerInterface' AND 
   ( 'PS' %!= 'ServerFacet'  ) ) then
 begin
  if ( ( %S |S ) %== 'oneway' OR 
    ( ( %S |S ) %== 'oneway,chg'  ) ) then
  begin
   '_' 
  end // if
 end // if
 ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ') '
 if NOT-EMPTY
 begin
  'throws '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
  ' ' 
 end // if
 NOP
 '{'
//	#	[{%SS=oneway,chg|%SS=chg|%SS=remover}{[{%f_ret(%S)!=void}return ]impl_.[{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}{%SN}%f_to_java(%SN)][{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}[{%SS=oneway|%SS=oneway,chg}_]] (<{, }%CN>);}\
 out_indent '	'
 if ( ( %S |S ) %== 'oneway,chg' OR 
   ( ( %S |S ) %== 'chg'  ) OR 
   ( ( %S |S ) %== 'remover'  ) ) then
 begin
//	#	if (isRw_) {
  out_indent '	if (isRw_) {'
//	#		[{%f_ret(%S)!=void}return ]impl_.[{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}{%SN}%f_to_java(%SN)][{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}[{%SS=oneway|%SS=oneway,chg}_]] (<{, }%CN>);
  out_indent '		'
  if ( ( [%f] ret %( %S )% ) %!= 'void' ) then
  begin
   'return ' 
  end // if
  'impl_.'
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
    ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
  begin
   [%f] to_java %( %S |N )% 
  end // if
  else
  begin
   %S |N 
  end // else
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
    ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
  begin
   if ( ( %S |S ) %== 'oneway' OR 
     ( ( %S |S ) %== 'oneway,chg'  ) ) then
   begin
    '_' 
   end // if
  end // if
  ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  ');'
//	#	} else {
  out_indent '	} else {'
//	#		%f_throw_const_violation(%S)
  out_indent '		'
  [%f] throw_const_violation %( %S )% 
//	#	}]
  out_indent '	}' 
 end // if
 else
 begin
  if ( ( [%f] ret %( %S )% ) %!= 'void' ) then
  begin
   'return ' 
  end // if
  'impl_.'
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
    ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
  begin
   [%f] to_java %( %S |N )% 
  end // if
  else
  begin
   %S |N 
  end // else
  if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
    ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
  begin
   if ( ( %S |S ) %== 'oneway' OR 
     ( ( %S |S ) %== 'oneway,chg'  ) ) then
   begin
    '_' 
   end // if
  end // if
  ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  ');' 
 end // else
//	#}
 out_indent '}'

//f _interface_wrapper_attr_java
; // interface_wrapper_func_java

: interface_wrapper_attr_java OBJECT IN %S
//	[{"%SN"=""}%f_error("Can't dump attr without name %SS")][{"%SS"!="writeonly"}#public %f_ret(%S) %f_to_java(get_%SN) (%S%f_accessor_args())[
 if ( ( %S |N ) %== '' ) then
 begin
  [%f] error %( 'Can''t dump attr without name '
  %S |S )% 
 end // if
 if ( ( %S |S ) %!= 'writeonly' ) then
 begin
  out_indent 'public '
  [%f] ret %( %S )% ' '
  [%f] to_java %( 'get_'
  %S |N )% ' ('
  %S %f accessor_args %( )% ')'
  if NOT-EMPTY
  begin
   #13#10

//	#	throws <{, }%f_type(%E)>] {
   out_indent '	throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
  end // if
  NOP
  ' {'
//	#	return impl_.%f_to_java(get_%SN) (<{, }%f_to_java(%CN)>);
  out_indent '	return impl_.'
  [%f] to_java %( 'get_'
  %S |N )% ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] to_java %( %C |N )% 
    ++! l_Counter
   end // if
  end // for C
  ');'
//	#}][{"%SS"!="readonly"}[{"%SS"!="writeonly"}\n]#public void %f_to_java(set_%SN) (%f_iset_attr(%S) %f_to_java(%SN)[, %S%f_accessor_args()])[
  out_indent '}' 
 end // if
 if ( ( %S |S ) %!= 'readonly' ) then
 begin
  if ( ( %S |S ) %!= 'writeonly' ) then
  begin
   #13#10 
  end // if
  out_indent 'public void '
  [%f] to_java %( 'set_'
  %S |N )% ' ('
  [%f] iset_attr %( %S )% ' '
  [%f] to_java %( %S |N )% if NOT-EMPTY
  begin
   ', '
   %S %f accessor_args %( )% 
  end // if
  NOP
  ')'
  if NOT-EMPTY
  begin
   #13#10

//	#	throws <{, }%f_type(%e)>] {
   out_indent '	throws '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%e
   begin
    OBJECT IN %e
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %e )% 
     ++! l_Counter
    end // if
   end // for e
  end // if
  NOP
  ' {'
//	#	if (isRw_) {
  out_indent '	if (isRw_) {'
//	#		impl_.%f_to_java(set_%SN) (%f_to_java(%SN)<, %f_to_java(%CN)>);
  out_indent '		impl_.'
  [%f] to_java %( 'set_'
  %S |N )% ' ('
  [%f] to_java %( %S |N )% 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    ', '
    [%f] to_java %( %C |N )% 
    ++! l_Counter
   end // if
  end // for C
  ');'
//	#	} else {
  out_indent '	} else {'
//	#		%f_throw_const_violation(%S)
  out_indent '		'
  [%f] throw_const_violation %( %S )% 
//	#	}
  out_indent '	}'
//	#}]
  out_indent '}' 
 end // if

//f _interface_wrapper_remover_header
; // interface_wrapper_attr_java

: interface_wrapper_remover_header OBJECT IN %S
//	virtual %f_interface_wrapper_func_header(%S);
 'virtual '
 [%f] interface_wrapper_func_header %( %S )% ';'

//f _interface_wrapper_remover_impl_cpp
; // interface_wrapper_remover_header

: interface_wrapper_remover_impl_cpp OBJECT IN %S
//	%f_interface_wrapper_func_header(%S,"cpp") {
 [%f] interface_wrapper_func_header %( %S %, 'cpp' )% ' {'
//		if (is_rw) {
 '	if (is_rw) {'
//			return m_impl-\>%SN[{%PS!=ServerInterface&PS!=ServerFacet}[{%SS=oneway|%SS=oneway,chg}_]] (<{, }%f_arg_full_decl(%C)>);
 '		return m_impl->'
 %S |N if ( ( %P |S ) %!= 'ServerInterface' AND 
   ( 'PS' %!= 'ServerFacet'  ) ) then
 begin
  if ( ( %S |S ) %== 'oneway' OR 
    ( ( %S |S ) %== 'oneway,chg'  ) ) then
  begin
   '_' 
  end // if
 end // if
 ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ');'
//		} else {
 '	} else {'
//			%f_throw_const_violation(%S)
 '		'
 [%f] throw_const_violation %( %S )% 
//		}
 '	}'
//	}
 '}'
//	
//f _interface_wrapper_func_header
; // interface_wrapper_remover_impl_cpp

: interface_wrapper_func_header OBJECT IN %S
//	[{%SS=oneway|%SS=oneway,chg}{%f_ret(%S) }/*oneway*/ Core::ThreadHandle ][{%1N=cpp}%{INT}NConstWrapper::]%SN[{%PS!=ServerInterface&PS!=ServerFacet}[{%SS=oneway|%SS=oneway,chg}_]] (<{, }%f_arg_full_decl(%C)>)[{%f_is_server_type(%P)=false&%SS!=chg&%SS!=oneway,chg&%SS!=remover} const]
 if ( ( %S |S ) %== 'oneway' OR 
   ( ( %S |S ) %== 'oneway,chg'  ) ) then
 begin
  '/*oneway*/ Core::ThreadHandle ' 
 end // if
 else
 begin
  [%f] ret %( %S )% ' ' 
 end // else
 if ( ( %1 |N ) %== 'cpp' ) then
 begin
  ( get_global_var ( 'INT' ) |N ) 'ConstWrapper::' 
 end // if
 %S |N if ( ( %P |S ) %!= 'ServerInterface' AND 
   ( 'PS' %!= 'ServerFacet'  ) ) then
 begin
  if ( ( %S |S ) %== 'oneway' OR 
    ( ( %S |S ) %== 'oneway,chg'  ) ) then
  begin
   '_' 
  end // if
 end // if
 ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ')'
 if ( ( [%f] is_server_type %( %P )% ) %==  false AND 
   ( ( %S |S ) %!= 'chg'  ) AND 
   ( ( %S |S ) %!= 'oneway,chg'  ) AND 
   ( ( %S |S ) %!= 'remover'  ) ) then
 begin
  ' const' 
 end // if

//f _interface_wrapper_attr_header
; // interface_wrapper_func_header

: interface_wrapper_attr_header OBJECT IN %S
//	[{"%SS"!="writeonly"}#virtual %f_iget_attr(%S) get_%SN (%S%f_accessor_args("true")) const;[{"%f_beaccessed(%S)"="true"}
 if ( ( %S |S ) %!= 'writeonly' ) then
 begin
  out_indent 'virtual '
  [%f] iget_attr %( %S )% ' get_'
  %S |N ' ('
  %S %f accessor_args %( true )% ') const;'
  if ( ( [%f] beaccessed %( %S )% ) %== true ) then
  begin
   #13#10

//	#virtual %f_igetnc_attr(%S) get_%SN (%S%f_accessor_args());]][{"%SS"!="readonly"}[{"%SS"!="writeonly"}\n\n]#virtual void set_%SN (%f_iset_attr(%S) %SN[, %S%f_accessor_args()]);]
   out_indent 'virtual '
   [%f] igetnc_attr %( %S )% ' get_'
   %S |N ' ('
   %S %f accessor_args %( )% ');' 
  end // if
 end // if
 if ( ( %S |S ) %!= 'readonly' ) then
 begin
  if ( ( %S |S ) %!= 'writeonly' ) then
  begin
   #13#10#13#10 
  end // if
  out_indent 'virtual void set_'
  %S |N ' ('
  [%f] iset_attr %( %S )% ' '
  %S |N if NOT-EMPTY
  begin
   ', '
   %S %f accessor_args %( )% 
  end // if
  NOP
  ');' 
 end // if

//f _fctr_mng_interface_wrapper_attr_cpp
; // interface_wrapper_attr_header

: fctr_mng_interface_wrapper_attr_cpp OBJECT IN %S
//	[{"%SS"!="writeonly"}%f_iget_attr(%S) %{INT}NConstWrapper::get_%SN (%S%f_accessor_args("true")) const {
 if ( ( %S |S ) %!= 'writeonly' ) then
 begin
  [%f] iget_attr %( %S )% ' '
  ( get_global_var ( 'INT' ) |N ) 'ConstWrapper::get_'
  %S |N ' ('
  %S %f accessor_args %( true )% ') const {'
//		return m_impl-\>get_%SN (<{, }%CN>);
  '	return m_impl->get_'
  %S |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  ');'
//	}[{"%f_beaccessed(%S)"="true"}
  '}'
  if ( ( [%f] beaccessed %( %S )% ) %== true ) then
  begin
   #13#10

//	
   #13#10

//	%f_igetnc_attr(%S) %{INT}NConstWrapper::get_%SN (%S%f_accessor_args()) {
   [%f] igetnc_attr %( %S )% ' '
   ( get_global_var ( 'INT' ) |N ) 'ConstWrapper::get_'
   %S |N ' ('
   %S %f accessor_args %( )% ') {'
//		if (is_rw) {
   '	if (is_rw) {'
//			return m_impl-\>get_%SN (<{, }%CN>);
   '		return m_impl->get_'
   %S |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   ');'
//		} else {
   '	} else {'
//			%f_throw_const_violation(%S)
   '		'
   [%f] throw_const_violation %( %S )% 
//		}
   '	}'
//	}]][{"%SS"!="readonly"}[{"%SS"!="writeonly"}\n\n]void %{INT}NConstWrapper::set_%SN (%f_iset_attr(%S) %SN[, %S%f_accessor_args()]) {
   '}' 
  end // if
 end // if
 if ( ( %S |S ) %!= 'readonly' ) then
 begin
  if ( ( %S |S ) %!= 'writeonly' ) then
  begin
   #13#10#13#10 
  end // if
  'void '
  ( get_global_var ( 'INT' ) |N ) 'ConstWrapper::set_'
  %S |N ' ('
  [%f] iset_attr %( %S )% ' '
  %S |N if NOT-EMPTY
  begin
   ', '
   %S %f accessor_args %( )% 
  end // if
  NOP
  ') {'
//		if (is_rw) {
  '	if (is_rw) {'
//			m_impl-\>set_%SN (%SN<, %CN>);
  '		m_impl->set_'
  %S |N ' ('
  %S |N 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    ', '
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  ');'
//		} else {
  '	} else {'
//			%f_throw_const_violation(%S)
  '		'
  [%f] throw_const_violation %( %S )% 
//		}
  '	}'
//	}]
  '}' 
 end // if

//f _throw_const_violation
; // fctr_mng_interface_wrapper_attr_cpp

: throw_const_violation OBJECT IN %S
//	%t_throw_const_violation(%S,"%X{lid}");
 [%t] throw_const_violation %( %S %, %X get_up ( 'lid' ) )% ';'

//t _throw_const_violation
; // throw_const_violation

<<transformator>> throw_const_violation OBJECT IN %S
//c                                 {java}                                           {cpp}
//r {""=""}:                        {throw new ru.garant.shared.Core[{%f_is_server_type(%{INT})=true}{.Root}Srv.Exception].ConstViolation ()}   {throw Core[{%f_is_server_type(%{INT})=true}{::Root}Srv]::ConstViolation ()}


//f _cache_postfix
; // throw_const_violation

: cache_postfix OBJECT IN %S
//	%t_cache_postfix(%S,"%S{const_type}","%1N")
 [%t] cache_postfix %( %S %, %S get_up ( 'const_type' ) %, %1 |N )% 

//t _cache_postfix
; // cache_postfix

<<transformator>> cache_postfix OBJECT IN %S
//c                                                                                   {combo}                       {read-only}                          {read-write}
//r {%f_is_common_mem_const_wrapped(%S)=true&%S{const_type}=read-write&"%2N"!=""}:    {%t_cache_postfix(%S,"%2N")}  {%t_cache_postfix(%S,"%2N")}         {%t_cache_postfix(%S,"%2N")}
//r {%S{const_type}=read-write&%f_is_common_mem_const_wrapped(%S)=false}:             {}                            {}                                   {}
//r {"%2N"!=""}:                                                                      {%t_cache_postfix(%S,"%2N")}  {%t_cache_postfix(%S,"%2N")}         {%t_cache_postfix(%S,"%2N")}
//r {""=""}:                                                                          {%t_cache_postfix(%S,"%2N")}  {[{%X{lid}!=java}{roData_}ro_data]}  {[{%X{lid}!=java}{rwData_}rw_data]}

//f _is_common_mem_const_wrapped
; // cache_postfix

: is_common_mem_const_wrapped OBJECT IN %S
//	[{%TS=FactoryMemory&%f_need_const_wrapper(%P)=true}{false}true]
 if ( ( %T |S ) %== 'FactoryMemory' AND 
   ( ( [%f] need_const_wrapper %( %P )% ) %==  true  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else

//f _const_wrapper_operations_h
; // is_common_mem_const_wrapped

: const_wrapper_operations_h OBJECT IN %S
//	<{}{%f_is_factory(%C)=false&%CC=Operation&%CS!=remover}[
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  false AND 
   ( ( %C |C ) %== 'Operation'  ) AND 
   ( ( %C |S ) %!= 'remover'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//		virtual %f_interface_wrapper_func_header(%C);]
    '	virtual '
    [%f] interface_wrapper_func_header %( %C )% ';' 
   end // if
   NOP
//	><{}{%f_is_factory(%C)=false&%CC=Attribute&%CS!=factory switch}[

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  false AND 
   ( ( %C |C ) %== 'Attribute'  ) AND 
   ( ( %C |S ) %!= 'factory switch'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_interface_wrapper_attr_header(%C)]
    [%f] interface_wrapper_attr_header %( %C )% 
   end // if
   NOP
//	><{}{%f_is_factory(%o)=false&%oC=Operation}[

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( [%f] is_factory %( %o )% ) %==  false AND 
   ( ( %o |C ) %== 'Operation'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//		virtual %f_interface_wrapper_func_header(%o);]
    '	virtual '
    [%f] interface_wrapper_func_header %( %o )% ';' 
   end // if
   NOP
//	><{}{%f_is_factory(%o)=false&%oC=Attribute&%oS!=factory switch}[

   ++! l_Counter
  end // if
 end // for o
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( [%f] is_factory %( %o )% ) %==  false AND 
   ( ( %o |C ) %== 'Attribute'  ) AND 
   ( ( %o |S ) %!= 'factory switch'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_interface_wrapper_attr_header(%o)]
    [%f] interface_wrapper_attr_header %( %o )% 
   end // if
   NOP
//	><{}{%CS=remover&%CC=Operation}[

   ++! l_Counter
  end // if
 end // for o
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== 'remover' AND 
   ( ( %C |C ) %== 'Operation'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//		%f_interface_wrapper_remover_header(%C)]
    '	'
    [%f] interface_wrapper_remover_header %( %C )% 
   end // if
   NOP
//	><{}{%ga=abstract}%g<{}{%CS=remover&%CC=Operation}[

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if ( ( %g |a ) %== 'abstract' ) then
  begin
   %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %== 'remover' AND 
      ( ( %C |C ) %== 'Operation'  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//		%f_interface_wrapper_remover_header(%C)]
       '	'
       [%f] interface_wrapper_remover_header %( %C )% 
      end // if
      NOP
//	>>[{%f_need_upgrade_rw(%S)=true}

      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for g
 if ( ( [%f] need_upgrade_rw %( %S )% ) %==  true ) then
 begin
  #13#10

//		virtual void upgrade_rw ();
  '	virtual void upgrade_rw ();'
//	]
 end // if

//f _need_upgrade_rw
; // const_wrapper_operations_h

: need_upgrade_rw OBJECT IN %S
//	[{<{}{%f_is_factory(%C)=true&%C{const_type}=combo}{%CC}>!=0|<{}{%ga=abstract&%g<{}{%f_is_factory(%C)=true&%C{const_type}=combo}{%CC}>!=0}{%gC}>!=0}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  true AND 
    ( ( %C get_up ( 'const_type' ) ) %== 'combo'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' AND 
    ( ( %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( [%f] is_factory %( %C )% ) %==  true AND 
      ( ( %C get_up ( 'const_type' ) ) %== 'combo'  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter

   ) // bind
 )    %!= 0  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for g
  l_Counter
  %!= 0  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else


//f _const_wrapper_operations_cpp
; // need_upgrade_rw

: const_wrapper_operations_cpp OBJECT IN %S
//	<{}{%f_is_factory(%C)=false&%CC=Operation&%CS!=remover}
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  false AND 
   ( ( %C |C ) %== 'Operation'  ) AND 
   ( ( %C |S ) %!= 'remover'  ) ) then
  begin
   #13#10

//	%f_interface_wrapper_func_header(%C,"cpp") {
   [%f] interface_wrapper_func_header %( %C %, 'cpp' )% ' {'
//		[{%CS=oneway,chg|%CS=chg|%CS=remover}{return m_impl-\>%CN[{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}[{%CS=oneway|%CS=oneway,chg}_]] (%C<{, }%CN>);}\
   '	'
   if ( ( %C |S ) %== 'oneway,chg' OR 
     ( ( %C |S ) %== 'chg'  ) OR 
     ( ( %C |S ) %== 'remover'  ) ) then
   begin
//	if (is_rw) {
    'if (is_rw) {'
//			return m_impl-\>%CN[{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}[{%CS=oneway|%CS=oneway,chg}_]] (%C<{, }%CN>);
    '		return m_impl->'
    %C |N if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
      ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
    begin
     if ( ( %C |S ) %== 'oneway' OR 
       ( ( %C |S ) %== 'oneway,chg'  ) ) then
     begin
      '_' 
     end // if
    end // if
    ' ('
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |N 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     ');'
//		} else {
    '	} else {'
//			%f_throw_const_violation(%C)
    '		'
    [%f] throw_const_violation %( %C )% 
//		}]
    '	}' 
   end // if
   else
   begin
    'return m_impl->'
    %C |N if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
      ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
    begin
     if ( ( %C |S ) %== 'oneway' OR 
       ( ( %C |S ) %== 'oneway,chg'  ) ) then
     begin
      '_' 
     end // if
    end // if
    ' ('
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |N 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     ');' 
   end // else
//	}
   '}'
//	><{}{%f_is_factory(%C)=false&%CC=Attribute&%CS!=factory switch}[

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  false AND 
   ( ( %C |C ) %== 'Attribute'  ) AND 
   ( ( %C |S ) %!= 'factory switch'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_fctr_mng_interface_wrapper_attr_cpp(%C)
    [%f] fctr_mng_interface_wrapper_attr_cpp %( %C )% 
//	]><{}{%f_is_factory(%o)=false&%oC=Operation}
   end // if
   NOP

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( [%f] is_factory %( %o )% ) %==  false AND 
   ( ( %o |C ) %== 'Operation'  ) ) then
  begin
   #13#10

//	%f_interface_wrapper_func_header(%o,"cpp") {
   [%f] interface_wrapper_func_header %( %o %, 'cpp' )% ' {'
//		[{%oS=oneway,chg|%oS=chg|%oS=remover}{return m_impl-\>%oN[{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}[{%oS=oneway|%oS=oneway,chg}_]] (%o<{, }%CN>);}\
   '	'
   if ( ( %o |S ) %== 'oneway,chg' OR 
     ( ( %o |S ) %== 'chg'  ) OR 
     ( ( %o |S ) %== 'remover'  ) ) then
   begin
//	if (is_rw) {
    'if (is_rw) {'
//			return m_impl-\>%oN[{%{INT}S!=ServerInterface&%{INT}S!=ServerFacet}[{%oS=oneway|%oS=oneway,chg}_]] (%o<{, }%CN>);
    '		return m_impl->'
    %o |N if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
      ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
    begin
     if ( ( %o |S ) %== 'oneway' OR 
       ( ( %o |S ) %== 'oneway,chg'  ) ) then
     begin
      '_' 
     end // if
    end // if
    ' ('
    %o
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |N 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     ');'
//		} else {
    '	} else {'
//			%f_throw_const_violation(%o)
    '		'
    [%f] throw_const_violation %( %o )% 
//		}]
    '	}' 
   end // if
   else
   begin
    'return m_impl->'
    %o |N if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' AND 
      ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerFacet'  ) ) then
    begin
     if ( ( %o |S ) %== 'oneway' OR 
       ( ( %o |S ) %== 'oneway,chg'  ) ) then
     begin
      '_' 
     end // if
    end // if
    ' ('
    %o
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |N 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     ');' 
   end // else
//	}
   '}'
//	><{}{%f_is_factory(%o)=false&%oC=Attribute&%oS!=factory switch}[

   ++! l_Counter
  end // if
 end // for o
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( [%f] is_factory %( %o )% ) %==  false AND 
   ( ( %o |C ) %== 'Attribute'  ) AND 
   ( ( %o |S ) %!= 'factory switch'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_fctr_mng_interface_wrapper_attr_cpp(%o)
    [%f] fctr_mng_interface_wrapper_attr_cpp %( %o )% 
//	]><{}{%CS=remover&%CC=Operation}[
   end // if
   NOP

   ++! l_Counter
  end // if
 end // for o
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== 'remover' AND 
   ( ( %C |C ) %== 'Operation'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_interface_wrapper_remover_impl_cpp(%C)
    [%f] interface_wrapper_remover_impl_cpp %( %C )% 
//	]><{}{%ga=abstract}%g<{}{%CS=remover&%CC=Operation}[
   end // if
   NOP

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if ( ( %g |a ) %== 'abstract' ) then
  begin
   %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %== 'remover' AND 
      ( ( %C |C ) %== 'Operation'  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	%f_interface_wrapper_remover_impl_cpp(%C)
       [%f] interface_wrapper_remover_impl_cpp %( %C )% 
//	]>>[{%f_need_upgrade_rw(%S)=true}
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for g
 if ( ( [%f] need_upgrade_rw %( %S )% ) %==  true ) then
 begin
  #13#10

//	void %{INT}NConstWrapper::upgrade_rw () {
  'void '
  ( get_global_var ( 'INT' ) |N ) 'ConstWrapper::upgrade_rw () {'
//		m_impl-\>upgrade_rw ();
  '	m_impl->upgrade_rw ();'
//		is_rw = true;
  '	is_rw = true;'
//	}
  '}'
//	]
 end // if

//f _is_ro_fctr_exists
; // const_wrapper_operations_cpp

: is_ro_fctr_exists OBJECT IN %S
//	[{%S{const_type}=combo|%S{const_type}=read-only}{false}true]
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' OR 
   ( ( %S get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else

//f _const_wrapper_operations_java
; // is_ro_fctr_exists

: const_wrapper_operations_java OBJECT IN %S
//	<{}{%f_is_factory(%C)=false&%CC=Operation&%CS!=remover}[
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  false AND 
   ( ( %C |C ) %== 'Operation'  ) AND 
   ( ( %C |S ) %!= 'remover'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_interface_wrapper_func_java(%C)]
    [%f] interface_wrapper_func_java %( %C )% 
   end // if
   NOP
//	><{}{%f_is_factory(%C)=false&%CC=Attribute&%CS!=factory switch&%CS!=switch}[

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  false AND 
   ( ( %C |C ) %== 'Attribute'  ) AND 
   ( ( %C |S ) %!= 'factory switch'  ) AND 
   ( ( %C |S ) %!= 'switch'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_interface_wrapper_attr_java(%C)]
    [%f] interface_wrapper_attr_java %( %C )% 
   end // if
   NOP
//	><{}{%f_is_factory(%o)=false&%oC=Operation}[

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( [%f] is_factory %( %o )% ) %==  false AND 
   ( ( %o |C ) %== 'Operation'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_interface_wrapper_func_java(%o)]
    [%f] interface_wrapper_func_java %( %o )% 
   end // if
   NOP
//	><{}{%f_is_factory(%o)=false&%oC=Attribute&%oS!=factory switch&%oS!=switch}[

   ++! l_Counter
  end // if
 end // for o
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( [%f] is_factory %( %o )% ) %==  false AND 
   ( ( %o |C ) %== 'Attribute'  ) AND 
   ( ( %o |S ) %!= 'factory switch'  ) AND 
   ( ( %o |S ) %!= 'switch'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_interface_wrapper_attr_java(%o)]
    [%f] interface_wrapper_attr_java %( %o )% 
   end // if
   NOP
//	><{}{%CC=Operation&%CS=remover}[

   ++! l_Counter
  end // if
 end // for o
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Operation' AND 
   ( ( %C |S ) %== 'remover'  ) ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%f_interface_wrapper_func_java(%C)]
    [%f] interface_wrapper_func_java %( %C )% 
   end // if
   NOP
//	><{}{%ga=abstract}%g<{}{%CC=Operation&%CS=remover}[

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if ( ( %g |a ) %== 'abstract' ) then
  begin
   %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |C ) %== 'Operation' AND 
      ( ( %C |S ) %== 'remover'  ) ) then
     begin
      if NOT-EMPTY
      begin
       #13#10

//	%f_interface_wrapper_func_java(%C)]
       [%f] interface_wrapper_func_java %( %C )% 
      end // if
      NOP
//	>>[{%f_need_upgrade_rw(%S)=true}

      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for g
 if ( ( [%f] need_upgrade_rw %( %S )% ) %==  true ) then
 begin
  #13#10

//		public void upgrade_rw () {
  '	public void upgrade_rw () {'
//			impl_.upgrade_rw ();
  '		impl_.upgrade_rw ();'
//			isRw_ = true;
  '		isRw_ = true;'
//		}
  '	}'
//	]
 end // if

//f _need_private_def
; // const_wrapper_operations_java

: need_private_def OBJECT IN %S
//	[{<{}{%f_is_factory(%C)=false&%CV!=PublicAccess}{%CC}>!=0|%f_need_const_wrapper(%S)=true}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  false AND 
    ( ( %C |V ) %!= 'PublicAccess'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 OR 
   ( ( [%f] need_const_wrapper %( %S )% ) %==  true  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else

//f _interface_postfix
; // need_private_def

: interface_postfix OBJECT IN %S
//	[{%f_need_private_def(%S)=true}.%SNPrivate]
 if ( ( [%f] need_private_def %( %S )% ) %==  true ) then
 begin
  '.'
  %S |N 'Private' 
 end // if

//f _dump_private_interface_java
; // interface_postfix

: dump_private_interface_java OBJECT IN %S
//	[{%f_need_private_def(%S)=true}
 if ( ( [%f] need_private_def %( %S )% ) %==  true ) then
 begin
  #13#10

//	#public interface %SNPrivate
  out_indent 'public interface '
  %S |N 'Private'
//	#	extends %SN<{}{%f_need_private_def(%G)=true}
  out_indent '	extends '
  %S |N 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if ( ( [%f] need_private_def %( %G )% ) %==  true ) then
   begin
    #13#10

//	#	, %f_type(%G)[%f_interface_postfix(%G)]><{}{%f_need_private_def(%R)=true}
    out_indent '	, '
    [%f] type %( %G )% if NOT-EMPTY
    begin
     [%f] interface_postfix %( %G )% 
    end // if
    NOP

    ++! l_Counter
   end // if
  end // for G
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( [%f] need_private_def %( %R )% ) %==  true ) then
   begin
    #13#10

//	#	, %f_type(%R)[%f_interface_postfix(%R)]>
    out_indent '	, '
    [%f] type %( %R )% if NOT-EMPTY
    begin
     [%f] interface_postfix %( %R )% 
    end // if
    NOP

    ++! l_Counter
   end // if
  end // for R
//	#{[
  out_indent '{'
  if NOT-EMPTY
  begin
   #13#10

//	<{}{"%f_is_factory(%C)"="false"&%CV!=PublicAccess}[
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( [%f] is_factory %( %C )% ) %== false AND 
     ( ( %C |V ) %!= 'PublicAccess'  ) ) then
    begin
     if NOT-EMPTY
     begin
      #13#10

//	%CX
      %C |X 
//	]>][{<{}{%f_is_factory(%C)=true&%C{const_type}=combo}{%CC}>!=0}
     end // if
     NOP

     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( [%f] is_factory %( %C )% ) %==  true AND 
     ( ( %C get_up ( 'const_type' ) ) %== 'combo'  ) ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
   #13#10

//	#	//upgrade rw method
   out_indent '	//upgrade rw method'
//	#	void upgrade_rw ();]
   out_indent '	void upgrade_rw ();' 
  end // if
//	#};]
  out_indent '};' 
 end // if
//#UC END# *4755043603A1*
; // dump_private_interface_java


// Возвращает true, если нужно сгенерить логирование вызвова tie-метода. Логирование нужно: если у
// метода явно выставленна галка "debug tie log", или эта галка выставлена на интерфейсе/пакете
//f _need_tie_log
: need_tie_log OBJECT IN %S
//#UC START# *480C51F10161*
//	[{%S{debug tie log}=true|<{}{%P{debug tie log}=true}{%PC}>!=0}{false}true]
 if ( ( %S get_up ( 'debug tie log' ) ) %==  true OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P get_up ( 'debug tie log' ) ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for P
  l_Counter
  %!= 0  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *480C51F10161*
; // need_tie_log


// генерит объявлением интерфейса
//f _interface_declaration
: interface_declaration OBJECT IN %S
//#UC START# *4958F81400B8*
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	]#%SF
 end // if
 NOP
 out_indent %S |F 
//	#typedef ::Core::Var\<%SN\> %SN_var;
 out_indent 'typedef ::Core::Var<'
 %S |N '> '
 %S |N '_var;'
//	#typedef ::Core::Var\<const %SN\> %SN_cvar;
 out_indent 'typedef ::Core::Var<const '
 %S |N '> '
 %S |N '_cvar;'
//	[
 if NOT-EMPTY
 begin
  #13#10

//	<#%FF
  INTEGER VAR l_Counter l_Counter := 0
  for %S%F
  begin
   OBJECT IN %F
   if true then
   begin
    out_indent %F |F 
//	>

    ++! l_Counter
   end // if
  end // for F
//	]%f_set_var(SERV,S)%f_docs(%S)\
 end // if
 NOP
 [%f] set_var %( 'SERV' %, 'S' )% [%f] docs %( %S )% 
//	#class %SN[{"%S{native definition}"!="C++ interface"}{
 out_indent 'class '
 %S |N if ( ( %S get_up ( 'native definition' ) ) %!= 'C++ interface' ) then
 begin
  #13#10

//	#	: [{}{%S%f_is_virtual_inheritance() public ::Core::IObject}<{\n#\t, }%S%f_is_virtual_inheritance() public %f_type(%G)>[{%Gx=true&%Rx=true}\n#\t, ]<{\n#\t, }%S%f_is_virtual_inheritance() public [{%{SERV}S=LocalInterface&%f_use_as_srv_type(%R)=true}{%f_type(%R)}%f_dump_base_poa(%R)]>]
  out_indent '	: '
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%G
   begin
    OBJECT IN %G
    if true then
    begin
     if ( l_Counter >0 ) then ( #13#10
     out_indent #9', ' )
     %S %f is_virtual_inheritance %( )% ' public '
     [%f] type %( %G )% 
     ++! l_Counter
    end // if
   end // for G
   if ( ( %G |x ) %==  true AND 
     ( ( %R |x ) %==  true  ) ) then
   begin
    #13#10
    out_indent #9', ' 
   end // if
   INTEGER VAR l_Counter l_Counter := 0
   for %S%R
   begin
    OBJECT IN %R
    if true then
    begin
     if ( l_Counter >0 ) then ( #13#10
     out_indent #9', ' )
     %S %f is_virtual_inheritance %( )% ' public '
     if ( ( ( get_global_var ( 'SERV' ) |S ) ) %== 'LocalInterface' AND 
       ( ( [%f] use_as_srv_type %( %R )% ) %==  true  ) ) then
     begin
      [%f] dump_base_poa %( %R )% 
     end // if
     else
     begin
      [%f] type %( %R )% 
     end // else

     ++! l_Counter
    end // if
   end // for R
  end // if
  NOP
  else
  begin
   %S %f is_virtual_inheritance %( )% ' public ::Core::IObject' 
  end // else
//	#{
  out_indent '{'
//	[
  if NOT-EMPTY
  begin
   #13#10

//	#	// forward decls for friend interface's servant
   out_indent '	// forward decls for friend interface's servant'
//	%f_dump_interface_friend(%S)]%S%f_dump_methods_decl()[
   [%f] dump_interface_friend %( %S )% 
  end // if
  NOP
  %S %f dump_methods_decl %( )% if NOT-EMPTY
  begin
   #13#10

//	%S%f_additional_remover_declaration()
   %S %f additional_remover_declaration %( )% 
//	][{<{}{%f_is_factory(%C)=true&%C{const_type}=combo}{%CC}>!=0}
  end // if
  NOP
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( [%f] is_factory %( %C )% ) %==  true AND 
     ( ( %C get_up ( 'const_type' ) ) %== 'combo'  ) ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
   #13#10

//	//upgrade rw method
   '//upgrade rw method'
//		virtual void upgrade_rw () = 0;
   '	virtual void upgrade_rw () = 0;'
//	][
  end // if
  if NOT-EMPTY
  begin
   #13#10

//	// oneway methods impl
   '// oneway methods impl'
//	private:<{}{"%CC"="Operation"&"%CS"="oneway"|"%CS"="oneway,chg"}{Sn}
   'private:'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Cn
   begin
    OBJECT IN %C
    if ( ( %C |C ) %== 'Operation' AND 
     ( ( %C |S ) %== 'oneway'  ) OR 
     ( ( %C |S ) %== 'oneway,chg'  ) ) then
    begin
     #13#10

//	%f_servant_cpp_oneway_operation_thr_h(%C)
     [%f] servant_cpp_oneway_operation_thr_h %( %C )% 
//	>

     ++! l_Counter
    end // if
   end // for C
//	protected:<{}{"%CC"="Operation"&"%CS"="oneway"|"%CS"="oneway,chg"}{Sn}
   'protected:'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Cn
   begin
    OBJECT IN %C
    if ( ( %C |C ) %== 'Operation' AND 
     ( ( %C |S ) %== 'oneway'  ) OR 
     ( ( %C |S ) %== 'oneway,chg'  ) ) then
    begin
     #13#10

//	%f_servant_cpp_oneway_operation_impl_h(%C)
     [%f] servant_cpp_oneway_operation_impl_h %( %C )% 
//	>]]#};[

     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
 end // if
 else
 begin
  #13#10

//		// native cpp user's definition
  '	// native cpp user's definition'
//		%U[
  '	'
  %Usersection (

  )
  (
   #13#10

//		]
   '	' 
  ) // Usersection
 //	}
 end // else
 out_indent '};'
 if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]][
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP
 ']'
 if NOT-EMPTY
 begin
  #13#10

//	
  #13#10

//	%f_dump_factory(%S)]
  [%f] dump_factory %( %S )% 
 end // if
 NOP
//#UC END# *4958F81400B8*
; // interface_declaration


// генерит объявление реализации фабрики для менеджера фабрик
//f _dump_factory_operation_h_impl
: dump_factory_operation_h_impl OBJECT IN %S
//#UC START# *495A0DDB0390*
//	%f_set_var(OPERATION_H,"#static %t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %SN%2N (%S%f_factory_params("%1N"))")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_H}N")")\
 [%f] set_var %( 'OPERATION_H' %, out_indent 'static '
 [%t] ret %( ( get_global_var ( 'INT' ) ) %, [%f] factory_target_strereotype %( %S %, %1 |N )% )% ' '
 %S |N %2 |N ' ('
 %S %f factory_params %( %1 |N )% ')' )% [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_H' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_H}N%{SERV}%f_dump_exceptions(%S,"NEW_LINE")}#static %t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %SN (%S%f_factory_params("%1N","\n#\t","\n#"))%{SERV}%f_dump_exceptions(%S)]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  out_indent 'static '
  [%t] ret %( ( get_global_var ( 'INT' ) ) %, [%f] factory_target_strereotype %( %S %, %1 |N )% )% ' '
  %S |N ' ('
  %S %f factory_params %( %1 |N %, #13#10
  out_indent #9'"' %, #13#10
  out_indent )% ')'
  ( get_global_var ( 'SERV' ) %f dump_exceptions %( %S )% ) 
 end // if
 else
 begin
  ( get_global_var ( 'OPERATION_H' ) |N ) ( get_global_var ( 'SERV' ) %f dump_exceptions %( %S %, 'NEW_LINE' )% ) 
 end // else
//#UC END# *495A0DDB0390*
; // dump_factory_operation_h_impl


// генерит реализацию фабрики для менеджера фабрик
//f _dump_factory_operation_cpp_impl
: dump_factory_operation_cpp_impl OBJECT IN %S
//#UC START# *496B45F70257*
//	%f_set_var(OPERATION_CPP,"%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{INT}NFactory::%SN%2N (%S%f_factory_params("%1N"))%{SERV}%f_dump_exceptions(%S) {")%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_CPP}N")")\
 [%f] set_var %( 'OPERATION_CPP' %, [%t] ret %( ( get_global_var ( 'INT' ) ) %, [%f] factory_target_strereotype %( %S %, %1 |N )% )% ' '
 ( get_global_var ( 'INT' ) |N ) 'Factory::'
 %S |N %2 |N ' ('
 %S %f factory_params %( %1 |N )% ')'
 ( get_global_var ( 'SERV' ) %f dump_exceptions %( %S )% ) ' {' )% [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_CPP' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_CPP}N}%t_ret(%{INT},"%f_factory_target_strereotype(%S,"%1N")") %{INT}NFactory::%SN%2N (%S%f_factory_params("%1N","\n\t","\n"))%{SERV}%f_dump_exceptions(%S) {]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  [%t] ret %( ( get_global_var ( 'INT' ) ) %, [%f] factory_target_strereotype %( %S %, %1 |N )% )% ' '
  ( get_global_var ( 'INT' ) |N ) 'Factory::'
  %S |N %2 |N ' ('
  %S %f factory_params %( %1 |N %, #13#10#9'"' %, #13#10 )% ')'
  ( get_global_var ( 'SERV' ) %f dump_exceptions %( %S )% ) ' {' 
 end // if
 else
 begin
  ( get_global_var ( 'OPERATION_CPP' ) |N ) 
 end // else
//	[{%{INT}S=LocalInterface&%PS=ServerInterface}{	return %{INT}NFactoryManager::Singleton::instance ()-\>%SN%2N (<{, }{%CS!=cache}%CN>);}\
 if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'LocalInterface' AND 
   ( ( %P |S ) %== 'ServerInterface'  ) ) then
 begin
//		
  '	'
//	]
 end // if
 else
 begin
  '	return '
  ( get_global_var ( 'INT' ) |N ) 'FactoryManager::Singleton::instance ()->'
  %S |N %2 |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'cache' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  ');' 
 end // else
//	}
 '}'
//#UC END# *496B45F70257*
; // dump_factory_operation_cpp_impl


// генерит код реалиазции части интерфейса, например фабрик, и oneway методов
//f _interface_implementation
: interface_implementation OBJECT IN %S
//#UC START# *496D988A038C*
//	%f_set_var(INT,S)%f_set_var(SERV,S)\
 [%f] set_var %( 'INT' %, 'S' )% [%f] set_var %( 'SERV' %, 'S' )% 
//	[{"%f_has_factory_methods(%S)"="true"}// factory interface wrapper for %SN\
 if ( ( [%f] has_factory_methods %( %S )% ) %== true ) then
 begin
  '// factory interface wrapper for '
  %S |N 
//	%f_dump_factory_impl_cpp(%S)%S%f_additional_fctr_impl()[{%SS=LocalInterface}%f_set_var(INT,S)%f_set_var(SERV,S)%f_dump_inherited_factory_cpp(%S)]
  [%f] dump_factory_impl_cpp %( %S )% %S %f additional_fctr_impl %( )% if ( ( %S |S ) %== 'LocalInterface' ) then
  begin
   [%f] set_var %( 'INT' %, 'S' )% [%f] set_var %( 'SERV' %, 'S' )% [%f] dump_inherited_factory_cpp %( %S )% 
  end // if
//	][
 end // if
 if NOT-EMPTY
 begin
  #13#10

//	// oneway methods impl<{}{"%CC"="Operation"&"%CS"="oneway"|"%CS"="oneway,chg"}{Sn}
  '// oneway methods impl'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%Cn
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Operation' AND 
    ( ( %C |S ) %== 'oneway'  ) OR 
    ( ( %C |S ) %== 'oneway,chg'  ) ) then
   begin
    #13#10

//	%f_servant_cpp_oneway_operation_thr_cpp(%C)
    [%f] servant_cpp_oneway_operation_thr_cpp %( %C )% 
//	><{}{"%CC"="Operation"&"%CS"="oneway"|"%CS"="oneway,chg"}{Sn}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%Cn
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Operation' AND 
    ( ( %C |S ) %== 'oneway'  ) OR 
    ( ( %C |S ) %== 'oneway,chg'  ) ) then
   begin
    #13#10

//	%f_servant_cpp_oneway_operation_impl_cpp(%C)
    [%f] servant_cpp_oneway_operation_impl_cpp %( %C )% 
//	>][{%S%f_has_multi_factory()=true&%Sa!=abstract}

    ++! l_Counter
   end // if
  end // for C
 end // if
 NOP
 if ( ( %S %f has_multi_factory %( )% ) %==  true AND 
   ( ( %S |a ) %!= 'abstract'  ) ) then
 begin
  #13#10

//	%S%f_dump_interface_factory_keys_method()
  %S %f dump_interface_factory_keys_method %( )% 
//	
  #13#10

//	]
 end // if
//#UC END# *496D988A038C*
; // interface_implementation


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
