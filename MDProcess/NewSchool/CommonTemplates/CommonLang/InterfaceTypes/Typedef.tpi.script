////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/InterfaceTypes/Typedef.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::CommonLang::InterfaceTypes::Typedef
//
// Тип
// ---
// Декларация типа определяет производный тип как копию исходного. Исходный задаются как базовый
// класс (связь наследования).
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: Typedef::Class
implementation @ <<Typedef>>
//? Тип
//? Декларация типа определяет производный тип как копию исходного. Исходный задаются как базовый класс (связь наследования).
//> Iterator::Class
//> Const Iterator::Class

//= InterfaceGenerator::MDAGenerator
//= Генерация JavaScript::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//v +#-
// - типы видимости
//Y code_typedef.gif
//L code_typedef
// Параметры визуализации
//$ C 240,230,210
//$ l 100,75,35
//$ f 100,75,35

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p force usage:b=false ? явно определяет, что элемент будет кем-то использован (нужно для проверки)
//p is default ancestor:b=false ? является ли предком по-умолчанию
//p newRTTI:b=false ? генерировать ли новые данные для RTTI
//p isPointer:b=false ? Является ли TypeDef указателем на тип, а не самим типом (для переноса существующего кода).
//p isClassRef:b=false ? Определяет, что тип является ссылкой на класс.
//p register in scripts:tribool=undefined ? 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{force usage}"!="%S{!force usage}"}%f_up_prefix(%S) *force usage* = *%S{force usage}* - явно определяет, что элемент будет кем-то использован (нужно для проверки)
 ?inherited
 if ( ( %S get_up ( 'force usage' ) ) %!= ( %S get_up_def ( 'force usage' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *force usage* = *'
  %S get_up ( 'force usage' ) '* - явно определяет, что элемент будет кем-то использован (нужно для проверки)'
//	][{"%S{is default ancestor}"!="%S{!is default ancestor}"}%f_up_prefix(%S) *is default ancestor* = *%S{is default ancestor}* - является ли предком по-умолчанию
 end // if
 if ( ( %S get_up ( 'is default ancestor' ) ) %!= ( %S get_up_def ( 'is default ancestor' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *is default ancestor* = *'
  %S get_up ( 'is default ancestor' ) '* - является ли предком по-умолчанию'
//	][{"%S{newRTTI}"!="%S{!newRTTI}"}%f_up_prefix(%S) *newRTTI* = *%S{newRTTI}* - генерировать ли новые данные для RTTI
 end // if
 if ( ( %S get_up ( 'newRTTI' ) ) %!= ( %S get_up_def ( 'newRTTI' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *newRTTI* = *'
  %S get_up ( 'newRTTI' ) '* - генерировать ли новые данные для RTTI'
//	][{"%S{isPointer}"!="%S{!isPointer}"}%f_up_prefix(%S) *isPointer* = *%S{isPointer}* - Является ли TypeDef указателем на тип, а не самим типом (для переноса существующего кода).
 end // if
 if ( ( %S get_up ( 'isPointer' ) ) %!= ( %S get_up_def ( 'isPointer' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *isPointer* = *'
  %S get_up ( 'isPointer' ) '* - Является ли TypeDef указателем на тип, а не самим типом (для переноса существующего кода).'
//	][{"%S{isClassRef}"!="%S{!isClassRef}"}%f_up_prefix(%S) *isClassRef* = *%S{isClassRef}* - Определяет, что тип является ссылкой на класс.
 end // if
 if ( ( %S get_up ( 'isClassRef' ) ) %!= ( %S get_up_def ( 'isClassRef' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *isClassRef* = *'
  %S get_up ( 'isClassRef' ) '* - Определяет, что тип является ссылкой на класс.'
//	][{"%S{register in scripts}"!="%S{!register in scripts}"}%f_up_prefix(%S) *register in scripts* = *%S{register in scripts}*
 end // if
 if ( ( %S get_up ( 'register in scripts' ) ) %!= ( %S get_up_def ( 'register in scripts' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *register in scripts* = *'
  %S get_up ( 'register in scripts' ) '*'
//	]
 end // if


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
; // wiki_up_print

<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for470F144E000F*
//c                              {}
//r {<{}{}{%GC}>!=1}: {%SS должен наследоваться от одного типа}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}:                                                            {имя %SS, используемого в качестве серверного типа, не должно совпадать с именем родителя}
//r {%Cx=true&%t_is_container(%G)=false&%f_check_if_type(%G,"a-string")=false&%f_check_if_type(%G,"a-wstring")=false}:            {%SS может определять итераторы, только если является контэйнером (в том числе и a-string/a-wstring)}
//r {%M{force usage}=false&%S{force usage}=false&%S{is default ancestor}=false&%ax=false}:                                        {%SS ни кем не используется}

//#UC END# *4704C0E30186for470F144E000F*
; // constraint


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Добавляет файлы необходимые элементу с точки зрения метамодели
//%f _pas_ImplUses
: pas_ImplUses OBJECT IN %S
//#UC START# *4948EB2601FAfor470F144E000F*
//	%S%[inherited]\
 inherited
//	<{}{%aC=Dependency&%aS=injects}{Sg}\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%ag
 begin
  OBJECT IN %a
  if ( ( %a |C ) %== 'Dependency' AND 
   ( ( %a |S ) %== 'injects'  ) ) then
  begin
//	%f_pas_PutToUses(%a%P)\
   [%f] pas_PutToUses %( %a ->P  )% 
//	>

   ++! l_Counter
  end // if
 end // for a
//#UC END# *4948EB2601FAfor470F144E000F*
; // pas_ImplUses


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor470F144E000F*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	]#typedef %f_type(%G) %SN;[{%GN=string}
 end // if
 NOP
 out_indent 'typedef '
 [%f] type %( %G )% ' '
 %S |N ';'
 if ( ( %G |N ) %== 'string' ) then
 begin
  #13#10

//	#typedef const char* %SN_const;
  out_indent 'typedef const char* '
  %S |N '_const;'
//	][{%t_interface(%G)=true}
 end // if
 if ( ( [%t] interface %( %G )% ) %==  true ) then
 begin
  #13#10

//	#typedef %G<%NN::>%GN_var %SN_var;
  out_indent 'typedef '
  %G
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%N
   begin
    OBJECT IN %N
    if true then
    begin
     %N |N '::' 
     ++! l_Counter
    end // if
   end // for N

  ) // bind
   %G |N '_var '
  %S |N '_var;'
//	#typedef %G<%NN::>%GN_cvar %SN_cvar;][
  out_indent 'typedef '
  %G
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%N
   begin
    OBJECT IN %N
    if true then
    begin
     %N |N '::' 
     ++! l_Counter
    end // if
   end // for N

  ) // bind
   %G |N '_cvar '
  %S |N '_cvar;' 
 end // if
 if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP


//+ dll.h
; // h

<<generator>> dll.h OBJECT IN %S
//	[{%f_need_tie(%G)=true}[#%S%f_open_ifdef()
 if ( ( [%f] need_tie %( %G )% ) %==  true ) then
 begin
  if NOT-EMPTY
  begin
   out_indent %S %f open_ifdef %( )% 
//	]#typedef %f_type(%G) I%SN_tie;
  end // if
  NOP
  out_indent 'typedef '
  [%f] type %( %G )% ' I'
  %S |N '_tie;'
//	#typedef %f_str_replace(%f_type(%G),I%GN_tie,%GN_tie) %SN_tie;[
  out_indent 'typedef '
  [%f] str_replace %( [%f] type %( %G )% %, 'I'
  %G |N '_tie' %, %G |N '_tie' )% ' '
  %S |N '_tie;'
  if NOT-EMPTY
  begin
   #13#10

//	#%S%f_close_ifdef()]]
   out_indent %S %f close_ifdef %( )% 
  end // if
  NOP
 end // if
//#UC END# *47022C88029Ffor470F144E000F*
; // dll.h


// реализация абстрактного стереотипа CORBA IDL::MDAGenerator
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for470F144E000F*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#typedef %G<%NN::>%GN %SN;
 out_indent 'typedef '
 %G
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for %S%N
  begin
   OBJECT IN %N
   if true then
   begin
    %N |N '::' 
    ++! l_Counter
   end // if
  end // for N

 ) // bind
  %G |N ' '
 %S |N ';'
//#UC END# *47022BBE0261for470F144E000F*
; // idl


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor470F144E000F*
//	[{%SV!=PublicAccess}[%f_with_gen_id(intf.pas,%SX)\n]]
 if ( ( %S |V ) %!= 'PublicAccess' ) then
 begin
  if NOT-EMPTY
  begin
   [%f] with_gen_id %( 'intf.pas' %, %S |X )% #13#10 
  end // if
  NOP
 end // if
//#UC END# *470F15B800CBfor470F144E000F*
; // impl.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor470F144E000F*
//F [%SX\n]
//	[{%SN!=IUnknown&%SN!=BOOL&%SN!=Boolean&%SN!=Integer&%SN!=Pointer&%SN!=Cardinal}\
 if ( ( %S |N ) %!= 'IUnknown' AND 
   ( ( %S |N ) %!= 'BOOL'  ) AND 
   ( ( %S |N ) %!= 'Boolean'  ) AND 
   ( ( %S |N ) %!= 'Integer'  ) AND 
   ( ( %S |N ) %!= 'Pointer'  ) AND 
   ( ( %S |N ) %!= 'Cardinal'  ) ) then
 begin
//	[{%f_exists_in_list(GENERATED_INTF,S)!=true}\
  if ( ( [%f] exists_in_list %( 'GENERATED_INTF' %, 'S' )% ) %!=  true ) then
  begin
//	[{%f_exists_in_list(FORWARDED_INTF,S)!=true}\
   if ( ( [%f] exists_in_list %( 'FORWARDED_INTF' %, 'S' )% ) %!=  true ) then
   begin
//	%f_add_to_list(GENERATED_INTF,S)\
    [%f] add_to_list %( 'GENERATED_INTF' %, 'S' )% 
//	%f_add_to_list(FORWARDED_INTF,S)\
    [%f] add_to_list %( 'FORWARDED_INTF' %, 'S' )% 
//	%f_pas_OpenType(%S)\
    [%f] pas_OpenType %( %S )% 
//	[#%S%f_open_ifdef()\n]\
    if NOT-EMPTY
    begin
     out_indent %S %f open_ifdef %( )% #13#10 
    end // if
    NOP
//	[{%t_interface(%G)=true}\
    if ( ( [%t] interface %( %G )% ) %==  true ) then
    begin
//	[{%f_pas_IsSameUnit(%S,%G)=true}\
     if ( ( [%f] pas_IsSameUnit %( %S %, %G )% ) %==  true ) then
     begin
//	%GF\
      %G |F 
//	]\
     end // if
//	]\
    end // if
//	#%f_pas_TypeName(%S) = \
    out_indent [%f] pas_TypeName %( %S )% ' = '
//	[{%S{newRTTI}=true}type ]\
    if ( ( %S get_up ( 'newRTTI' ) ) %==  true ) then
    begin
     'type ' 
    end // if
//	[{%S{isPointer}=true}^]\
    if ( ( %S get_up ( 'isPointer' ) ) %==  true ) then
    begin
     '^' 
    end // if
//	[{%S{isClassRef}=true}class of ]\
    if ( ( %S get_up ( 'isClassRef' ) ) %==  true ) then
    begin
     'class of ' 
    end // if
//	[{%S{isPointer}!=true}[%f_pas_AncestorPrefix(%S).]]\
    if ( ( %S get_up ( 'isPointer' ) ) %!=  true ) then
    begin
     if NOT-EMPTY
     begin
      [%f] pas_AncestorPrefix %( %S )% '.' 
     end // if
     NOP
    end // if
//	%f_pas_TypeName(%G);\
    [%f] pas_TypeName %( %G )% ';'
//	[\n# \{* %SD \}]\
    if NOT-EMPTY
    begin
     #13#10
     out_indent ' {* '
     %S |D ' }' 
    end // if
    NOP
//	[\n#%S%f_close_ifdef()]\
    if NOT-EMPTY
    begin
     #13#10
     out_indent %S %f close_ifdef %( )% 
    end // if
    NOP
//	]\
   end // if

//	{%f_exists_in_list(FORWARDED_INTF,S)!=true}
//	]\
  end // if

//	{%f_exists_in_list(GENERATED_INTF,S)!=true}
//	]
 end // if
//	[{%SN!=IUnknown&%SN!=BOOL&%SN!=Boolean&%SN!=Integer&%SN!=Pointer&%SN!=Cardinal}
//#UC END# *470F1571031Cfor470F144E000F*
; // intf.pas


// реализация абстрактного стереотипа Дельфи-DLL Адаптер::MDAGenerator
// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor470F144E000F*
//F [{%t_interface(%S)=true}%S%f_interface_typedef_dump()]
//	[{%t_interface(%S)!=true}[%f_pas_OpenType(%S)\n]\
 if ( ( [%t] interface %( %S )% ) %!=  true ) then
 begin
  if NOT-EMPTY
  begin
   [%f] pas_OpenType %( %S )% #13#10 
  end // if
  NOP
//	%f_docs(%S)\
  [%f] docs %( %S )% 
//	#P%SN = ^T%SN;
  out_indent 'P'
  %S |N ' = ^T'
  %S |N ';'
//	#T%SN = %f_type(%G);]
  out_indent 'T'
  %S |N ' = '
  [%f] type %( %G )% ';' 
 end // if

//%f _interface_typedef_dump
; // pas

: interface_typedef_dump OBJECT IN %S
//	[%f_pas_OpenType(%S)\n]\
 if NOT-EMPTY
 begin
  [%f] pas_OpenType %( %S )% #13#10 
 end // if
 NOP
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#%f_type(%S) = %f_type(%G);
 out_indent [%f] type %( %S )% ' = '
 [%f] type %( %G )% ';'
//	#
 out_indent 
//	#
 out_indent 
//#UC END# *470F152700FAfor470F144E000F*
; // interface_typedef_dump


// реализация абстрактного стереотипа Документация::MDAGenerator
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for470F144E000F*
//G %PU
//#UC END# *46E6D4BB0339for470F144E000F*
; // wiki



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // <<Typedef>>

