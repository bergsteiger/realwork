////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/InterfacesMetamodel/AbstractInterface.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::CommonLang::InterfacesMetamodel::AbstractInterface
//
// Абстрактный стереотип интерфейса определяет реализацию общих генераторов для итерфейсов
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: AbstractInterface::Class
implementation @ <<AbstractInterface>>
//? Абстрактный стереотип интерфейса определяет реализацию общих генераторов для итерфейсов
//= WithFactory::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

// генерация дополнительных объявлений для фабрик (C++)
//%f _additional_fctr_def
; // st_space_key

: additional_fctr_def OBJECT IN %S
//#UC START# *471F2C3D0232for47174CE200AB*
//#UC END# *471F2C3D0232for47174CE200AB*
; // additional_fctr_def


// генерация дополнительных объявлений для фабрик (Java)
//%f _additional_fctr_def_java
: additional_fctr_def_java OBJECT IN %S
//#UC START# *471F2C4302FDfor47174CE200AB*
//#UC END# *471F2C4302FDfor47174CE200AB*
; // additional_fctr_def_java


// возвращает базовый менеджер фабрик (C++)
//%f _base_fctr_mng
: base_fctr_mng OBJECT IN %S
//#UC START# *471F2C4701E4for47174CE200AB*
//#UC END# *471F2C4701E4for47174CE200AB*
; // base_fctr_mng


// возвращает базовый менеджер фабрик (Java)
//%f _base_fctr_mng_java
: base_fctr_mng_java OBJECT IN %S
//#UC START# *471F2C4B008Cfor47174CE200AB*
//#UC END# *471F2C4B008Cfor47174CE200AB*
; // base_fctr_mng_java


// что это ??? (C++)
//%f _publish_self_cpp
: publish_self_cpp OBJECT IN %S
//#UC START# *471F2C4F03B9for47174CE200AB*
//#UC END# *471F2C4F03B9for47174CE200AB*
; // publish_self_cpp


// что это?  (C++)
//%f _publish_self_h
: publish_self_h OBJECT IN %S
//#UC START# *471F2C52032Cfor47174CE200AB*
//#UC END# *471F2C52032Cfor47174CE200AB*
; // publish_self_h


// что это?? (Java)
//%f _publish_self_java
: publish_self_java OBJECT IN %S
//#UC START# *471F2C56032Cfor47174CE200AB*
//#UC END# *471F2C56032Cfor47174CE200AB*
; // publish_self_java


// выводит тип селектора мульти фабрики
//%f _dump_switch_type
: dump_switch_type OBJECT IN %S
//#UC START# *47B137CB000Bfor47174CE200AB*
//	[{}{[{%GS=Interface|%GS=LocalInterface|%GS=ServerInterface|%GS=Entity}{[{%RS=Interface|%RS=LocalInterface|%RS=ServerInterface}%R%f_dump_switch_type()]}%G%f_dump_switch_type()]}<{}{%CC=Attribute&%CS=factory switch}[{%X{lid}!=java}{%t_convert_to_object_type(%C%T)}%f_type(%C%T)]>]
//	%f_set_var(SWITCH,"")\
 [%f] set_var %( 'SWITCH' %, '' )% 
//	%S%f_find_switch("SWITCH")\
 %S %f find_switch %( 'SWITCH' )% 
//	[{%X{lid}!=java}{%t_convert_to_object_type(%{SWITCH}%T)}%f_type(%{SWITCH}%T)]
 if ( ( %X get_up ( 'lid' ) ) %!= 'java' ) then
 begin
  [%f] type %( ( get_global_var ( 'SWITCH' )  ->T ) )% 
 end // if
 else
 begin
  [%t] convert_to_object_type %( ( get_global_var ( 'SWITCH' )  ->T ) )% 
 end // else

//%f _dump_switch_type_name
; // dump_switch_type

: dump_switch_type_name OBJECT IN %S
//	[{}{[{%GS=Interface|%GS=LocalInterface|%GS=ServerInterface|%GS=Entity}{[{%RS=Interface|%RS=LocalInterface|%RS=ServerInterface}%R%f_dump_switch_type_name()]}%G%f_dump_switch_type_name()]}<{}{%CC=Attribute&%CS=factory switch}[{%X{lid}!=java}{%t_convert_to_object_type(%C%T)}%C%TN]>]
//	%f_set_var(SWITCH,"")\
 [%f] set_var %( 'SWITCH' %, '' )% 
//	%S%f_find_switch("SWITCH")\
 %S %f find_switch %( 'SWITCH' )% 
//	%{SWITCH}%TN
 ( get_global_var ( 'SWITCH' )  ->T |N ) 

//%f _dump_switch_arg_type
; // dump_switch_type_name

: dump_switch_arg_type OBJECT IN %S
//	[{}{[{%GS=Interface|%GS=LocalInterface|%GS=ServerInterface|%GS=Entity}{[{%RS=Interface|%RS=LocalInterface|%RS=ServerInterface}%R%f_dump_switch_arg_type()]}%G%f_dump_switch_arg_type()]}<{}{%CC=Attribute&%CS=factory switch}[{%X{lid}!=java}{%t_convert_to_object_type(%C%T)}%t_arg(%C%T,"in")]>]
//	%f_set_var(SWITCH,"")\
 [%f] set_var %( 'SWITCH' %, '' )% 
//	%S%f_find_switch("SWITCH")\
 %S %f find_switch %( 'SWITCH' )% 
//	[{%X{lid}!=java}{%t_convert_to_object_type(%{SWITCH}%T)}%t_arg(%{SWITCH}%T,"in")]
 if ( ( %X get_up ( 'lid' ) ) %!= 'java' ) then
 begin
  [%t] arg %( ( get_global_var ( 'SWITCH' )  ->T ) %, 'in' )% 
 end // if
 else
 begin
  [%t] convert_to_object_type %( ( get_global_var ( 'SWITCH' )  ->T ) )% 
 end // else
//#UC END# *47B137CB000Bfor47174CE200AB*
; // dump_switch_arg_type


// Генерация фабричных методов
//%f _dump_factory_operation_h
: dump_factory_operation_h OBJECT IN %S
//#UC START# *496C411C0053for47174CE200AB*
//	%f_docs(%1)\
 [%f] docs %( %1 )% 
//	[#%1%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %1 %f open_ifdef %( )% 
//	]\
 end // if
 NOP
//	[{%1{const_type}=combo}{%f_dump_factory_operation_h_impl(%1)}%f_dump_factory_operation_h_impl(%1,"read-write")
 if ( ( %1 get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] dump_factory_operation_h_impl %( %1 %, 'read-write' )% 
//	
  #13#10

//	%f_dump_factory_operation_h_impl(%1,"read-only","_ro")]\
  [%f] dump_factory_operation_h_impl %( %1 %, 'read-only"' %, '_ro' )% 
 end // if
 else
 begin
  [%f] dump_factory_operation_h_impl %( %1 )% 
 end // else
//	[
 if NOT-EMPTY
 begin
  #13#10

//	#%1%f_close_ifdef()]
  out_indent %1 %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *496C411C0053for47174CE200AB*
; // dump_factory_operation_h


// Генерация реализации фабричных методов
//%f _additional_fctr_impl
: additional_fctr_impl OBJECT IN %S
//#UC START# *496C817B0097for47174CE200AB*
//#UC END# *496C817B0097for47174CE200AB*
; // additional_fctr_impl


// генерит реализацию фабрики интерфейса
//%f _dump_factory_operation_cpp
: dump_factory_operation_cpp OBJECT IN %S
//#UC START# *496D98690096for47174CE200AB*
//	[%1%f_open_ifdef()
 if NOT-EMPTY
 begin
  %1 %f open_ifdef %( )% 
//	][{%1{const_type}=combo}{%f_dump_factory_operation_cpp_impl(%1)}%f_dump_factory_operation_cpp_impl(%1,"read-write")
 end // if
 NOP
 if ( ( %1 get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] dump_factory_operation_cpp_impl %( %1 %, 'read-write' )% 
//	
  #13#10

//	%f_dump_factory_operation_cpp_impl(%1,"read-only","_ro")][
  [%f] dump_factory_operation_cpp_impl %( %1 %, 'read-only"' %, '_ro' )% 
 end // if
 else
 begin
  [%f] dump_factory_operation_cpp_impl %( %1 )% 
 end // else
 if NOT-EMPTY
 begin
  #13#10

//	%1%f_close_ifdef()]
  %1 %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *496D98690096for47174CE200AB*
; // dump_factory_operation_cpp


// генерит реалиазцию мульти-фабрики интерфейса
//%f _dump_multi_factory_operation_cpp
: dump_multi_factory_operation_cpp OBJECT IN %S
//#UC START# *496DB8B70199for47174CE200AB*
//	[%1%f_open_ifdef()
 if NOT-EMPTY
 begin
  %1 %f open_ifdef %( )% 
//	][{%1{const_type}=combo}{%f_dump_multi_factory_operation_cpp_impl(%1)}%f_dump_multi_factory_operation_cpp_impl(%1,"read-write")
 end // if
 NOP
 if ( ( %1 get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] dump_multi_factory_operation_cpp_impl %( %1 %, 'read-write' )% 
//	
  #13#10

//	%f_dump_multi_factory_operation_cpp_impl(%1,"read-only","_ro")][
  [%f] dump_multi_factory_operation_cpp_impl %( %1 %, 'read-only"' %, '_ro' )% 
 end // if
 else
 begin
  [%f] dump_multi_factory_operation_cpp_impl %( %1 )% 
 end // else
 if NOT-EMPTY
 begin
  #13#10

//	%1%f_close_ifdef()]
  %1 %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *496DB8B70199for47174CE200AB*
; // dump_multi_factory_operation_cpp


// Дополнительные объявления для производных стереотипов
//%f _additional_fctr_mng_declarations
: additional_fctr_mng_declarations OBJECT IN %S
//#UC START# *496DE7E202F7for47174CE200AB*
//#UC END# *496DE7E202F7for47174CE200AB*
; // additional_fctr_mng_declarations


// Генерация декларации мульти фабрик
//%f _dump_multi_factory_operation_h
: dump_multi_factory_operation_h OBJECT IN %S
//#UC START# *496EE097022Cfor47174CE200AB*
//	%f_docs(%1)\
 [%f] docs %( %1 )% 
//	[#%1%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %1 %f open_ifdef %( )% 
//	][{%1{const_type}=combo}{%f_dump_multi_factory_operation_h_impl(%1)}%f_dump_multi_factory_operation_h_impl(%1,"read-write")
 end // if
 NOP
 if ( ( %1 get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] dump_multi_factory_operation_h_impl %( %1 %, 'read-write' )% 
//	
  #13#10

//	%f_dump_multi_factory_operation_h_impl(%1,"read-only","_ro")][
  [%f] dump_multi_factory_operation_h_impl %( %1 %, 'read-only"' %, '_ro' )% 
 end // if
 else
 begin
  [%f] dump_multi_factory_operation_h_impl %( %1 )% 
 end // else
 if NOT-EMPTY
 begin
  #13#10

//	#%1%f_close_ifdef()]
  out_indent %1 %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *496EE097022Cfor47174CE200AB*
; // dump_multi_factory_operation_h


// Для дополнитешльной генерации фабрик в менеджере фабрик
//%f _additional_mgr_factory_mehods
: additional_mgr_factory_mehods OBJECT IN %S
//#UC START# *496EED59015Cfor47174CE200AB*
//#UC END# *496EED59015Cfor47174CE200AB*
; // additional_mgr_factory_mehods


// Реализация дополнительных методов
//%f _additional_mgr_factory_methods_impl
: additional_mgr_factory_methods_impl OBJECT IN %S
//#UC START# *496F0DDD00B6for47174CE200AB*
//#UC END# *496F0DDD00B6for47174CE200AB*
; // additional_mgr_factory_methods_impl


// Дополнительные абстрактные фабрики
//%f _additional_abstract_factories
: additional_abstract_factories OBJECT IN %S
//#UC START# *496F4112016Afor47174CE200AB*
//#UC END# *496F4112016Afor47174CE200AB*
; // additional_abstract_factories


// Дополнительная инициализация конструктора менеджера фабрик
//%f _additional_fctr_mng_ctor_initialization
: additional_fctr_mng_ctor_initialization OBJECT IN %S
//#UC START# *496F4CDE0178for47174CE200AB*
//#UC END# *496F4CDE0178for47174CE200AB*
; // additional_fctr_mng_ctor_initialization


// Реализация методов менеджера фабрик.
//%f _fctr_mng_fctr_cpp_impl
: fctr_mng_fctr_cpp_impl OBJECT IN %S
//#UC START# *4978567C01C5for47174CE200AB*
//	%1[%t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%f_factory_target_strereotype(%S,"%3N")]") %{INT}NFactoryManager::%SN%4N (%S%f_factory_params("%3N")) [{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{throw (CORBA::SystemException, CoreSrv::NoActiveFactory[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)}/*throw (Core::Root::NoActiveFactory[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/] \
 %1
 bind ( 
  OBJECT VAR %S
  if NOT-EMPTY
  begin
   [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
     ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
   begin
    [%f] factory_target_strereotype %( %S %, %3 |N )% 
   end // if
)%    ' '
   ( get_global_var ( 'INT' ) |N ) 'FactoryManager::'
   %S |N %4 |N ' ('
   %S %f factory_params %( %3 |N )% ') '
   if ( ( [%f] realize_srv_interface %( %S )% ) %==  false OR 
     ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
   begin
    '/*throw (Core::Root::NoActiveFactory'
    if ( ( [%f] need_conversion_exception %( %S )% ) %==  true ) then
    begin
     ', Core::Root::ImpossibleConversion' 
    end // if
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      ', '
      [%f] type %( %E )% 
      ++! l_Counter
     end // if
    end // for E
    ')*/' 
   end // if
   else
   begin
    'throw (CORBA::SystemException, CoreSrv::NoActiveFactory'
    if ( ( [%f] need_conversion_exception %( %S )% ) %==  true ) then
    begin
     ', Core::Root::ImpossibleConversion' 
    end // if
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      ', '
      [%f] type %( %E )% 
      ++! l_Counter
     end // if
    end // for E
    ')' 
   end // else
   ' '
//	{[{%f_is_it_cached(%S)=false}
   '{'
   if ( ( [%f] is_it_cached %( %S )% ) %==  false ) then
   begin
    #13#10

//		if (m_single_active_factory.is_nil()) {
    '	if (m_single_active_factory.is_nil()) {'
//			throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
    '		throw Core::Root::NoActiveFactory ("'
    %P ->P ->P |N   '::'
    %P ->P |N  '::'
    %P |N 'Factory");'
//		}
    '	}'
//		%t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Ss]") ret_ = m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]]);
    '	'
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' ) then
    begin
     %S |s 
    end // if
)%     ' ret_ = m_single_active_factory->'
    %S |N ' ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      %C |N 
      ++! l_Counter
     end // if
    end // for C
    if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
    begin
     if ( ( %C |x ) %==  true ) then
     begin
      ', ' 
     end // if
     if ( ( %3 |N ) %== 'read-only' ) then
     begin
       true 
     end // if
     else
     begin
       false 
     end // else
    end // if
    ');'
//		GDS_ASSERT_MSG (ret_ != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
    '	GDS_ASSERT_MSG (ret_ != 0, ("'
    %P ->P ->P |N   '::'
    %P ->P |N  '::'
    %P |N 'Factory impl can''t return zerro"));'
//		[{%{INT}S=ServerInterface&%2N=read-only}{return [{%3N=read-only}{ret_}new %{INT}NConstWrapper (ret_)];}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (ret_);
    '	'
    if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' AND 
      ( ( %2 |N ) %== 'read-only'  ) ) then
    begin
     ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
     ( get_global_var ( 'INT' ) |N ) 'ConstWrapper (ret_);'
//		return wrapper-\>_this ();]
     '	return wrapper->_this ();' 
    end // if
    else
    begin
     'return '
     if ( ( %3 |N ) %== 'read-only' ) then
     begin
      'new '
      ( get_global_var ( 'INT' ) |N ) 'ConstWrapper (ret_)' 
     end // if
     else
     begin
      'ret_' 
     end // else
     ';' 
    end // else
//	][{%TS!=FactoryMemory}[{%f_is_it_cached(%S)=true}[{%Cx=true}
   end // if
   if ( ( %T |S ) %!= 'FactoryMemory' ) then
   begin
    if ( ( [%f] is_it_cached %( %S )% ) %==  true ) then
    begin
     if ( ( %C |x ) %==  true ) then
     begin
      #13#10

//		GUARD(m_mutex_for_%SN);
      '	GUARD(m_mutex_for_'
      %S |N ');'
//		[{<{}{%CS=cache}{%CC}>!=0}<{}{%CS=cache}%S%f_cache_attr(%C);
      '	'
      if ( 
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C |S ) %== 'cache' ) then
        begin

         ++! l_Counter
        end // if
       end // for C
       l_Counter
       %!= 0 ) then
      begin
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C |S ) %== 'cache' ) then
        begin
         %S %f cache_attr %( %C )% ';'
//		>%U[{_INIT_CUSTOM_CACHE_ARGS}
         '	' 
         ++! l_Counter
        end // if
       end // for C
       %Usersection (
        '_INIT_CUSTOM_CACHE_ARGS' 
       )
       (
        #13#10

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
        '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]
        '	' 
       ) // Usersection
 //		]CachedObjectsFor%f_to_borland(%SN)::iterator f = m_cached_objects_for_%SN.find (ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>));
       '	' 
      end // if
      'CachedObjectsFor'
      [%f] to_borland %( %S |N )% '::iterator f = m_cached_objects_for_'
      %S |N '.find (ObjectCreationIdFor'
      [%f] to_borland %( %S |N )% '('
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %!= 'nokey' ) then
       begin
        if ( l_Counter >0 ) then ( ', ' )
        %C |N 
        ++! l_Counter
       end // if
      end // for C
      '));'
//		if (f == m_cached_objects_for_%SN.end()[{%S{const_type}=combo|%S{const_type}=read-only} || f-\>second[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.ptr()] == 0]) {
      '	if (f == m_cached_objects_for_'
      %S |N '.end()'
      if ( ( %S get_up ( 'const_type' ) ) %== 'combo' OR 
        ( ( %S get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
      begin
       ' || f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.ptr()' 
       end // if
       ' == 0' 
      end // if
      ') {'
//		[{%S{const_type}=combo&%3N=read-only|%S{const_type}=read-only}{	if (m_single_active_factory.is_nil()) {
      '	'
      if ( ( %S get_up ( 'const_type' ) ) %== 'combo' AND 
        ( ( %3 |N ) %== 'read-only'  ) OR 
        ( ( %S get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
      begin
       #13#10

//			f = m_cached_objects_for_%SN.insert (
       '		f = m_cached_objects_for_'
       %S |N '.insert ('
//				CachedObjectsFor%f_to_borland(%SN)::value_type(
       '			CachedObjectsFor'
       [%f] to_borland %( %S |N )% '::value_type('
//					ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
       '				ObjectCreationIdFor'
       [%f] to_borland %( %S |N )% '('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C |S ) %!= 'nokey' ) then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       ')'
//					, m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]])
       '				, m_single_active_factory->'
       %S |N ' ('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if true then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        if ( ( %C |x ) %==  true ) then
        begin
         ', ' 
        end // if
        if ( ( %3 |N ) %== 'read-only' ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // if
       ')'

//					,[{%S{const_type}!=read-write}{ m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}, [{%1N=read-only}{false}true]])} ComboData[{%Ss=synchro}{Var}Ptr] (m_single_active_factory-\>%SN (<{, }%CN>))]
//				)
       '			)'
//			).first;
       '		).first;'
//			m_cached_objects_index_for_%SN.insert (
       '		m_cached_objects_index_for_'
       %S |N '.insert ('
//				CachedObjectsIndexFor%f_to_borland(%SN)::value_type (
       '			CachedObjectsIndexFor'
       [%f] to_borland %( %S |N )% '::value_type ('
//					f-\>second[.%t_cache_postfix(%S,"read-write")][{%f_is_server_type(%{INT})=true}{[{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
       '				f->second'
       if NOT-EMPTY
       begin
        '.'
        [%t] cache_postfix %( %S %, 'read-write' )% 
       end // if
       NOP
       if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
       begin
        '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
       end // if
       else
       begin
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in()' 
        end // if
       end // else
//					, f
       '				, f'
//				)
       '			)'
//			);[{%Ss=synchro}
       '		);'
       if ( ( %S |s ) %== 'synchro' ) then
       begin
        #13#10

//			return f-\>second[.%f_cache_postfix(%S,"%3N")];]
        '		return f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, %3 |N )% 
        end // if
        NOP
        ';' 
       end // if
//		}	if (f == m_cached_objects_for_%SN.end()) {
       '	}	if (f == m_cached_objects_for_'
       %S |N '.end()) {'
//				if (m_single_active_factory.is_nil()) {
       '			if (m_single_active_factory.is_nil()) {'
//					throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
       '				throw Core::Root::NoActiveFactory ("'
       %P ->P ->P |N   '::'
       %P ->P |N  '::'
       %P |N 'Factory");'
//				}
       '			}'
//				f = m_cached_objects_for_%SN.insert (
       '			f = m_cached_objects_for_'
       %S |N '.insert ('
//					CachedObjectsFor%f_to_borland(%SN)::value_type(
       '				CachedObjectsFor'
       [%f] to_borland %( %S |N )% '::value_type('
//						ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
       '					ObjectCreationIdFor'
       [%f] to_borland %( %S |N )% '('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C |S ) %!= 'nokey' ) then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       ')'
//						, ComboData[{%Ss=synchro}{Var}Ptr] (m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]]))
       '					, ComboData'
       if ( ( %S |s ) %== 'synchro' ) then
       begin
        'Ptr' 
       end // if
       else
       begin
        'Var' 
       end // else
       ' (m_single_active_factory->'
       %S |N ' ('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if true then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        if ( ( %C |x ) %==  true ) then
        begin
         ', ' 
        end // if
        if ( ( %3 |N ) %== 'read-only' ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // if
       '))'
//					)
       '				)'
//				).first;
       '			).first;'
//				m_cached_objects_index_for_%SN.insert (
       '			m_cached_objects_index_for_'
       %S |N '.insert ('
//					CachedObjectsIndexFor%f_to_borland(%SN)::value_type (
       '				CachedObjectsIndexFor'
       [%f] to_borland %( %S |N )% '::value_type ('
//						f-\>second[.%t_cache_postfix(%S,"read-write")][{%f_is_server_type(%{INT})=true}{[{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
       '					f->second'
       if NOT-EMPTY
       begin
        '.'
        [%t] cache_postfix %( %S %, 'read-write' )% 
       end // if
       NOP
       if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
       begin
        '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
       end // if
       else
       begin
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in()' 
        end // if
       end // else
//						, f
       '					, f'
//					)
       '				)'
//				);
       '			);'
//				[{%{INT}S=ServerInterface&%S#f_is_exported()=true}{f-\>second[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()]);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()]);
       '			'
       if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' AND 
         ( ( %S %?f is_exported %( )% ) %==  true  ) ) then
       begin
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ');'
//				f-\>second[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
        '			f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = wrapper->_this ();' 
       end // if
       else
       begin
        'f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ');' 
       end // else
//				f-\>second.is_ro_first = true;[{%Ss=synchro}
       '			f->second.is_ro_first = true;'
       if ( ( %S |s ) %== 'synchro' ) then
       begin
        #13#10

//				GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.in ()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
        '			GDS_ASSERT_MSG (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ' != 0, ("'
        %P ->P ->P |N   '::'
        %P ->P |N  '::'
        %P |N 'Factory impl can''t return zerro"));'
//				return f-\>second[.%f_cache_postfix(%S,"read-only")];]
        '			return f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ';' 
       end // if
//			} else if (f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr ()] == 0) {
       '		} else if (f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, 'read-only' )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.ptr ()' 
       end // if
       ' == 0) {'
//				[{%{INT}S=ServerInterface&%S#f_is_exported()=true}{f-\>second[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
       '			'
       if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' AND 
         ( ( %S %?f is_exported %( )% ) %==  true  ) ) then
       begin
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()])
        '				'
        ( get_global_var ( 'INT' ) |N ) '::_duplicate (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ')'
//				);
        '			);'
//				f-\>second[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();][{%Ss=synchro}
        '			f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = wrapper->_this ();' 
       end // if
       else
       begin
        'f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()])
        '				'
        ( get_global_var ( 'INT' ) |N ) '::_duplicate (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ')'
//				);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
        '			);' 
       end // else
       if ( ( %S |s ) %== 'synchro' ) then
       begin
        #13#10

//				GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.in ()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
        '			GDS_ASSERT_MSG (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ' != 0, ("'
        %P ->P ->P |N   '::'
        %P ->P |N  '::'
        %P |N 'Factory impl can''t return zerro"));'
//				return f-\>second[.%f_cache_postfix(%S,"read-only")];]
        '			return f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ';' 
       end // if
//			}]
       '		}' 
      end // if
      else
      begin
       '	if (m_single_active_factory.is_nil()) {'
//				throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
       '			throw Core::Root::NoActiveFactory ("'
       %P ->P ->P |N   '::'
       %P ->P |N  '::'
       %P |N 'Factory");'
//			}
       '		' 
      end // else
//		}[{%f_is_ro_fctr_exists(%S)=true&%3N=read-write} else if (
      '	}'
      if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true AND 
        ( ( %3 |N ) %== 'read-write'  ) ) then
      begin
       ' else if ('
//			f != m_cached_objects_for_%SN.end()
       '		f != m_cached_objects_for_'
       %S |N '.end()'
//			&& f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr ()] != 0
       '		&& f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, 'read-only' )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.ptr ()' 
       end // if
       ' != 0'
//			&& f-\>second.is_ro_first == true
       '		&& f->second.is_ro_first == true'
//		) {
       '	) {'
//			f-\>second[.%f_cache_postfix(%S,"read-only")]-\>upgrade_rw ();
       '		f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, 'read-only' )% 
       end // if
       NOP
       '->upgrade_rw ();'
//			f-\>second.is_ro_first = false;
       '		f->second.is_ro_first = false;'
//		}]
       '	}' 
      end // if
//		GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.in ()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
      '	GDS_ASSERT_MSG (f->second'
      if NOT-EMPTY
      begin
       '.'
       [%f] cache_postfix %( %S %, %3 |N )% 
      end // if
      NOP
      if ( ( %S |s ) %!= 'synchro' ) then
      begin
       '.in ()' 
      end // if
      ' != 0, ("'
      %P ->P ->P |N   '::'
      %P ->P |N  '::'
      %P |N 'Factory impl can''t return zerro"));'
//		return [{[{%{INT}S!=ServerInterface}{[{%S#f_is_exported()!=true}{false}true]}true]=true&%Ss!=synchro}{%{INT}N::_duplicate(f-\>second[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.in ()])}*f-\>second[.%f_cache_postfix(%S,"%3N")]];
      '	return '
      if ( if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' ) then
       begin
         true 
       end // if
       else
       begin
        if ( ( %S %?f is_exported %( )% ) %!=  true ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // else
       %==  true AND 
        ( ( %S |s ) %!= 'synchro'  ) ) then
      begin
       '*f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
      end // if
      else
      begin
       ( get_global_var ( 'INT' ) |N ) '::_duplicate(f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.in ()' 
       end // if
       ')' 
      end // else
      ';'
//	][{%Cx=false}
     end // if
     if ( ( %C |x ) %==  false ) then
     begin
      #13#10

//		if (m_cached_object_for_%SN[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.ptr()] == 0) {
      '	if (m_cached_object_for_'
      %S |N if NOT-EMPTY
      begin
       '.'
       [%f] cache_postfix %( %S %, %3 |N )% 
      end // if
      NOP
      if ( ( %S |s ) %!= 'synchro' ) then
      begin
       '.ptr()' 
      end // if
      ' == 0) {'
//			GUARD(m_mutex_for_%SN);
      '		GUARD(m_mutex_for_'
      %S |N ');'
//			if (m_cached_object_for_%SN[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.ptr()] == 0) {
      '		if (m_cached_object_for_'
      %S |N if NOT-EMPTY
      begin
       '.'
       [%f] cache_postfix %( %S %, %3 |N )% 
      end // if
      NOP
      if ( ( %S |s ) %!= 'synchro' ) then
      begin
       '.ptr()' 
      end // if
      ' == 0) {'
//			[{%S{const_type}=combo&%3N=read-only|%S{const_type}=read-only}{	if (m_single_active_factory.is_nil()) {
      '		'
      if ( ( %S get_up ( 'const_type' ) ) %== 'combo' AND 
        ( ( %3 |N ) %== 'read-only'  ) OR 
        ( ( %S get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
      begin
       #13#10

//				m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")] = m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%2N=read-only}{false}true]]);
       '			m_cached_object_for_'
       %S |N if NOT-EMPTY
       begin
        '.'
        [%t] cache_postfix %( %S %, 'read-write' )% 
       end // if
       NOP
       ' = m_single_active_factory->'
       %S |N ' ('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if true then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        if ( ( %C |x ) %==  true ) then
        begin
         ', ' 
        end // if
        if ( ( %2 |N ) %== 'read-only' ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // if
       ');'
//			}	if (m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.ptr()] == 0) {
       '		}	if (m_cached_object_for_'
       %S |N if NOT-EMPTY
       begin
        '.'
        [%t] cache_postfix %( %S %, 'read-write' )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.ptr()' 
       end // if
       ' == 0) {'
//					if (m_single_active_factory.is_nil()) {
       '				if (m_single_active_factory.is_nil()) {'
//						throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
       '					throw Core::Root::NoActiveFactory ("'
       %P ->P ->P |N   '::'
       %P ->P |N  '::'
       %P |N 'Factory");'
//					}
       '				}'
//					m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")] = m_single_active_factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]]);
       '				m_cached_object_for_'
       %S |N if NOT-EMPTY
       begin
        '.'
        [%t] cache_postfix %( %S %, 'read-write' )% 
       end // if
       NOP
       ' = m_single_active_factory->'
       %S |N ' ('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if true then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        if ( ( %C |x ) %==  true ) then
        begin
         ', ' 
        end // if
        if ( ( %3 |N ) %== 'read-only' ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // if
       ');'
//					[{%{INT}S=ServerInterface&%S#f_is_exported()=true}{m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
       '				'
       if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' AND 
         ( ( %S %?f is_exported %( )% ) %==  true  ) ) then
       begin
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//						m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
        '					m_cached_object_for_'
        %S |N if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in()' 
        end // if
//					);
        '				);'
//					m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();][{%f_is_ro_fctr_exists(%S)=true}
        '				m_cached_object_for_'
        %S |N if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = wrapper->_this ();' 
       end // if
       else
       begin
        'm_cached_object_for_'
        %S |N if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//						m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()]
        '					m_cached_object_for_'
        %S |N if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in()' 
        end // if
//					);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
        '				);' 
       end // else
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        #13#10

//					m_cached_object_for_%SN.is_ro_first = true;]
        '				m_cached_object_for_'
        %S |N '.is_ro_first = true;' 
       end // if
//				} else {
       '			} else {'
//					[{%{INT}S=ServerInterface&%S#f_is_exported()=true}{m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
       '				'
       if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' AND 
         ( ( %S %?f is_exported %( )% ) %==  true  ) ) then
       begin
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//						%{INT}N::_duplicate (m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()])
        '					'
        ( get_global_var ( 'INT' ) |N ) '::_duplicate (m_cached_object_for_'
        %S |N if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in()' 
        end // if
        ')'
//					);
        '				);'
//					m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
        '				m_cached_object_for_'
        %S |N if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = wrapper->_this ();' 
       end // if
       else
       begin
        'm_cached_object_for_'
        %S |N if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//						%{INT}N::_duplicate (m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in()])
        '					'
        ( get_global_var ( 'INT' ) |N ) '::_duplicate (m_cached_object_for_'
        %S |N if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in()' 
        end // if
        ')'
//					);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
        '				);' 
       end // else
//				}
       '			}'
//			]
       '		' 
      end // if
      else
      begin
       '	if (m_single_active_factory.is_nil()) {'
//					throw Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory");
       '				throw Core::Root::NoActiveFactory ("'
       %P ->P ->P |N   '::'
       %P ->P |N  '::'
       %P |N 'Factory");'
//				}
       '			' 
      end // else
//				GDS_ASSERT_MSG (m_cached_object_for_%SN[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.ptr()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));[{%Ss=synchro}
      '			GDS_ASSERT_MSG (m_cached_object_for_'
      %S |N if NOT-EMPTY
      begin
       '.'
       [%f] cache_postfix %( %S %, %3 |N )% 
      end // if
      NOP
      if ( ( %S |s ) %!= 'synchro' ) then
      begin
       '.ptr()' 
      end // if
      ' != 0, ("'
      %P ->P ->P |N   '::'
      %P ->P |N  '::'
      %P |N 'Factory impl can''t return zerro"));'
      if ( ( %S |s ) %== 'synchro' ) then
      begin
       #13#10

//				return m_cached_object_for_%SN[.%f_cache_postfix(%S,"%3N")];]
       '			return m_cached_object_for_'
       %S |N if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
       ';' 
      end // if
//			}
      '		}'
//		}[{%f_is_ro_fctr_exists(%S)=true&%3N=read-write}
      '	}'
      if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true AND 
        ( ( %3 |N ) %== 'read-write'  ) ) then
      begin
       #13#10

//		if (
       '	if ('
//			m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr()] != 0
       '		m_cached_object_for_'
       %S |N if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, 'read-only' )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.ptr()' 
       end // if
       ' != 0'
//			&& m_cached_object_for_%SN.is_ro_first == true
       '		&& m_cached_object_for_'
       %S |N '.is_ro_first == true'
//		) {
       '	) {'
//			m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-only")]-\>upgrade_rw ();
       '		m_cached_object_for_'
       %S |N if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, 'read-only' )% 
       end // if
       NOP
       '->upgrade_rw ();'
//			m_cached_object_for_%SN.is_ro_first = false;
       '		m_cached_object_for_'
       %S |N '.is_ro_first = false;'
//		}]
       '	}' 
      end // if
//		return [{[{%{INT}S!=ServerInterface}{[{%S#f_is_exported()=true}{true}false]}true]=true&%Ss!=synchro}{%{INT}N::_duplicate(m_cached_object_for_%SN[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.in ()])}*m_cached_object_for_%SN[.%f_cache_postfix(%S,"%3N")]];
      '	return '
      if ( if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' ) then
       begin
         true 
       end // if
       else
       begin
        if ( ( %S %?f is_exported %( )% ) %==  true ) then
        begin
          false 
        end // if
        else
        begin
          true 
        end // else
       end // else
       %==  true AND 
        ( ( %S |s ) %!= 'synchro'  ) ) then
      begin
       '*m_cached_object_for_'
       %S |N if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
      end // if
      else
      begin
       ( get_global_var ( 'INT' ) |N ) '::_duplicate(m_cached_object_for_'
       %S |N if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.in ()' 
       end // if
       ')' 
      end // else
      ';'
//	]]][{%TS=FactoryMemory}
     end // if
    end // if
   end // if
   if ( ( %T |S ) %== 'FactoryMemory' ) then
   begin
    #13#10

//	%f_fctr_mng_mem_cpp(%S,"%3N")
    [%f] fctr_mng_mem_cpp %( %S %, %3 |N )% 
//	]}]
   end // if
   '}' 
  end // if
  NOP

 ) // bind
 //#UC END# *4978567C01C5for47174CE200AB*
; // fctr_mng_fctr_cpp_impl


// Дополнительные определения в public секции для менеджера фабрик
//%f _additional_mgr_public_declarations
: additional_mgr_public_declarations OBJECT IN %S
//#UC START# *4978702C00D9for47174CE200AB*
//#UC END# *4978702C00D9for47174CE200AB*
; // additional_mgr_public_declarations


// Базовая реализация мультифабрик для менеджера фабрик
//%f _fctr_mng_m_fctr_cpp_impl
: fctr_mng_m_fctr_cpp_impl OBJECT IN %S
//#UC START# *497870EF0151for47174CE200AB*
//	%1[[{%S{transparent multy}=false|"%S{transparent multy}"=""}\
 %1
 bind ( 
  OBJECT VAR %S
  if NOT-EMPTY
  begin
   if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
     ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
   begin

////%S{transparent multy}=false
//	%f_set_var(OP_PARAMS,"%S%f_factory_params("%1N")")\
    [%f] set_var %( 'OP_PARAMS' %, %S %f factory_params %( %1 |N )% )% 
//	%t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%f_factory_target_strereotype(%S,"%3N")]") %{INT}NFactoryManager::%SN%4N ([{"%{OP_PARAMS}N"!=""}%{OP_PARAMS}N, ]%{INT}%f_dump_switch_arg_type() key) [{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{throw (CORBA::SystemException, Core::Root::UnknownFactoryKey[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)}/*throw (Core::Root::UnknownFactoryKey[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]<, %f_type(%E)>)*/] {\
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
      ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
    begin
     [%f] factory_target_strereotype %( %S %, %3 |N )% 
    end // if
)%     ' '
    ( get_global_var ( 'INT' ) |N ) 'FactoryManager::'
    %S |N %4 |N ' ('
    if ( ( ( get_global_var ( 'OP_PARAMS' ) |N ) ) %!= '' ) then
    begin
     ( get_global_var ( 'OP_PARAMS' ) |N ) ', ' 
    end // if
    ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key) '
    if ( ( [%f] realize_srv_interface %( %S )% ) %==  false OR 
      ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
    begin
     '/*throw (Core::Root::UnknownFactoryKey'
     if ( ( [%f] need_conversion_exception %( %S )% ) %==  true ) then
     begin
      ', Core::Root::ImpossibleConversion' 
     end // if
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       ', '
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E
     ')*/' 
    end // if
    else
    begin
     'throw (CORBA::SystemException, Core::Root::UnknownFactoryKey'
     if ( ( [%f] need_conversion_exception %( %S )% ) %==  true ) then
     begin
      ', Core::Root::ImpossibleConversion' 
     end // if
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       ', '
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E
     ')' 
    end // else
    ' {'
//	[{%f_is_it_cached(%S)=false}
    if ( ( [%f] is_it_cached %( %S )% ) %==  false ) then
    begin
     #13#10

//		FactoryMap::iterator f = m_factories_map.find (key);
     '	FactoryMap::iterator f = m_factories_map.find (key);'
//		if (f == m_factories_map.end()) {
     '	if (f == m_factories_map.end()) {'
//			throw Core::Root::UnknownFactoryKey (
     '		throw Core::Root::UnknownFactoryKey ('
//				"%P%P%PN::%P%PN::%PNFactory"
     '			"'
     %P ->P ->P |N   '::'
     %P ->P |N  '::'
     %P |N 'Factory"'
//				, [{%f_need_lexical_cast(%{INT})=true}{key}boost::lexical_cast\<std::string\> (key).c_str ()]
     '			, '
     if ( ( [%f] need_lexical_cast %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
     begin
      'boost::lexical_cast<std::string> (key).c_str ()' 
     end // if
     else
     begin
      'key' 
     end // else
//			);
     '		);'
//		}
     '	}'
//		[{%{INT}S=ServerInterface&%3N=read-only}{return [{%3N=read-only}{f-\>second.factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]]);}new %{INT}NConstWrapper (f-\>second.factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]]));]}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
     '	'
     if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' AND 
       ( ( %3 |N ) %== 'read-only'  ) ) then
     begin
      ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
      ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//			f-\>second.factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ]true])
      '		f->second.factory->'
      %S |N ' ('
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if true then
       begin
        if ( l_Counter >0 ) then ( ', ' )
        %C |N 
        ++! l_Counter
       end // if
      end // for C
      if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
      begin
       if ( ( %C |x ) %==  true ) then
       begin
        ', ' 
       end // if
        true 
      end // if
      ')'
//		);
      '	);'
//		return wrapper-\>_this ();]
      '	return wrapper->_this ();' 
     end // if
     else
     begin
      'return '
      if ( ( %3 |N ) %== 'read-only' ) then
      begin
       'new '
       ( get_global_var ( 'INT' ) |N ) 'ConstWrapper (f->second.factory->'
       %S |N ' ('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if true then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        if ( ( %C |x ) %==  true ) then
        begin
         ', ' 
        end // if
        if ( ( %3 |N ) %== 'read-only' ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // if
       '));' 
      end // if
      else
      begin
       'f->second.factory->'
       %S |N ' ('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if true then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        if ( ( %C |x ) %==  true ) then
        begin
         ', ' 
        end // if
        if ( ( %3 |N ) %== 'read-only' ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // if
       ');' 
      end // else
     end // else
//	][{%TS!=FactoryMemory}[{%f_is_it_cached(%S)=true}
    end // if
    if ( ( %T |S ) %!= 'FactoryMemory' ) then
    begin
     if ( ( [%f] is_it_cached %( %S )% ) %==  true ) then
     begin
      #13#10

//		GUARD(m_mutex_for_%SN);
      '	GUARD(m_mutex_for_'
      %S |N ');'
//		[{<{}{%CS=cache}{%CC}>!=0}<{}{%CS=cache}%S%f_cache_attr(%C);
      '	'
      if ( 
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C |S ) %== 'cache' ) then
        begin

         ++! l_Counter
        end // if
       end // for C
       l_Counter
       %!= 0 ) then
      begin
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C |S ) %== 'cache' ) then
        begin
         %S %f cache_attr %( %C )% ';'
//		>%U[{_INIT_CUSTOM_CACHE_ARGS}
         '	' 
         ++! l_Counter
        end // if
       end // for C
       %Usersection (
        '_INIT_CUSTOM_CACHE_ARGS' 
       )
       (
        #13#10

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
        '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]
        '	' 
       ) // Usersection
 //		]CachedObjectsFor%f_to_borland(%SN)::iterator f = m_cached_objects_for_%SN.find (ObjectCreationIdFor%f_to_borland(%SN)(<{}{"%CS"!="nokey"}%CN, >key));
       '	' 
      end // if
      'CachedObjectsFor'
      [%f] to_borland %( %S |N )% '::iterator f = m_cached_objects_for_'
      %S |N '.find (ObjectCreationIdFor'
      [%f] to_borland %( %S |N )% '('
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %!= 'nokey' ) then
       begin
        %C |N ', ' 
        ++! l_Counter
       end // if
      end // for C
      'key));'
//		if (f == m_cached_objects_for_%SN.end()[{%S{const_type}=combo|%S{const_type}=read-only} || f-\>second[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.ptr()] == 0]) {
      '	if (f == m_cached_objects_for_'
      %S |N '.end()'
      if ( ( %S get_up ( 'const_type' ) ) %== 'combo' OR 
        ( ( %S get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
      begin
       ' || f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.ptr()' 
       end // if
       ' == 0' 
      end // if
      ') {'
//		[{%S{const_type}=combo&%3N=read-only|%S{const_type}=read-only}{	FactoryMap::iterator f_fct = m_factories_map.find (key);
      '	'
      if ( ( %S get_up ( 'const_type' ) ) %== 'combo' AND 
        ( ( %3 |N ) %== 'read-only'  ) OR 
        ( ( %S get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
      begin
       #13#10

//			f = m_cached_objects_for_%SN.insert (
       '		f = m_cached_objects_for_'
       %S |N '.insert ('
//				CachedObjectsFor%f_to_borland(%SN)::value_type(
       '			CachedObjectsFor'
       [%f] to_borland %( %S |N )% '::value_type('
//					ObjectCreationIdFor%f_to_borland(%SN)(<{}{"%CS"!="nokey"}%CN, >key)
       '				ObjectCreationIdFor'
       [%f] to_borland %( %S |N )% '('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C |S ) %!= 'nokey' ) then
        begin
         %C |N ', ' 
         ++! l_Counter
        end // if
       end // for C
       'key)'
//					, f_fct-\>second.factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]])
       '				, f_fct->second.factory->'
       %S |N ' ('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if true then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        if ( ( %C |x ) %==  true ) then
        begin
         ', ' 
        end // if
        if ( ( %3 |N ) %== 'read-only' ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // if
       ')'

//					,[{%S{const_type}!=read-write}{ f_fct-\>second.factory-\>%SN (<{, }%CN>)} ComboData[{%Ss=synchro}{Var}Ptr] (f_fct-\>second.factory-\>%SN (<{, }%CN>))]
//				)
       '			)'
//			).first;
       '		).first;'
//			m_cached_objects_index_for_%SN.insert (
       '		m_cached_objects_index_for_'
       %S |N '.insert ('
//				CachedObjectsIndexFor%f_to_borland(%SN)::value_type (
       '			CachedObjectsIndexFor'
       [%f] to_borland %( %S |N )% '::value_type ('
//					f-\>second[.%t_cache_postfix(%S,"read-write")][{%f_is_server_type(%{INT})=true}{[{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
       '				f->second'
       if NOT-EMPTY
       begin
        '.'
        [%t] cache_postfix %( %S %, 'read-write' )% 
       end // if
       NOP
       if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
       begin
        '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
       end // if
       else
       begin
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in()' 
        end // if
       end // else
//					, f
       '				, f'
//				)
       '			)'
//			);[{%Ss=synchro}
       '		);'
       if ( ( %S |s ) %== 'synchro' ) then
       begin
        #13#10

//			return f-\>second[.%f_cache_postfix(%S,"%3N")];]
        '		return f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, %3 |N )% 
        end // if
        NOP
        ';' 
       end // if
//		}	if (f == m_cached_objects_for_%SN.end()) {
       '	}	if (f == m_cached_objects_for_'
       %S |N '.end()) {'
//				FactoryMap::iterator f_fct = m_factories_map.find (key);
       '			FactoryMap::iterator f_fct = m_factories_map.find (key);'
//				if (f_fct == m_factories_map.end()) {
       '			if (f_fct == m_factories_map.end()) {'
//					throw Core::Root::UnknownFactoryKey (
       '				throw Core::Root::UnknownFactoryKey ('
//						"%P%P%PN::%P%PN::%PNFactory"
       '					"'
       %P ->P ->P |N   '::'
       %P ->P |N  '::'
       %P |N 'Factory"'
//						, [{%f_need_lexical_cast(%{INT})=true}{key}boost::lexical_cast\<std::string\> (key).c_str ()]
       '					, '
       if ( ( [%f] need_lexical_cast %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
       begin
        'boost::lexical_cast<std::string> (key).c_str ()' 
       end // if
       else
       begin
        'key' 
       end // else
//						);
       '					);'
//				}
       '			}'
//				f = m_cached_objects_for_%SN.insert (
       '			f = m_cached_objects_for_'
       %S |N '.insert ('
//					CachedObjectsFor%f_to_borland(%SN)::value_type(
       '				CachedObjectsFor'
       [%f] to_borland %( %S |N )% '::value_type('
//						ObjectCreationIdFor%f_to_borland(%SN)(<{}{"%CS"!="nokey"}%CN, >key)
       '					ObjectCreationIdFor'
       [%f] to_borland %( %S |N )% '('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C |S ) %!= 'nokey' ) then
        begin
         %C |N ', ' 
         ++! l_Counter
        end // if
       end // for C
       'key)'
//						, ComboData[{%Ss=synchro}{Var}Ptr] (f_fct-\>second.factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]]))
       '					, ComboData'
       if ( ( %S |s ) %== 'synchro' ) then
       begin
        'Ptr' 
       end // if
       else
       begin
        'Var' 
       end // else
       ' (f_fct->second.factory->'
       %S |N ' ('
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if true then
        begin
         if ( l_Counter >0 ) then ( ', ' )
         %C |N 
         ++! l_Counter
        end // if
       end // for C
       if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
       begin
        if ( ( %C |x ) %==  true ) then
        begin
         ', ' 
        end // if
        if ( ( %3 |N ) %== 'read-only' ) then
        begin
          true 
        end // if
        else
        begin
          false 
        end // else
       end // if
       '))'
//					)
       '				)'
//				).first;
       '			).first;'
//				m_cached_objects_index_for_%SN.insert (
       '			m_cached_objects_index_for_'
       %S |N '.insert ('
//					CachedObjectsIndexFor%f_to_borland(%SN)::value_type (
       '				CachedObjectsIndexFor'
       [%f] to_borland %( %S |N )% '::value_type ('
//						f-\>second[.%t_cache_postfix(%S,"read-write")][{%f_is_server_type(%{INT})=true}{[{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]
       '					f->second'
       if NOT-EMPTY
       begin
        '.'
        [%t] cache_postfix %( %S %, 'read-write' )% 
       end // if
       NOP
       if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
       begin
        '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
       end // if
       else
       begin
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in()' 
        end // if
       end // else
//						, f
       '					, f'
//					)
       '				)'
//				);
       '			);'
//				[{%{INT}S=ServerInterface&%S#f_is_exported()=true}{f-\>second[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()]);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()]);
       '			'
       if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' AND 
         ( ( %S %?f is_exported %( )% ) %==  true  ) ) then
       begin
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ');'
//				f-\>second[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();]
        '			f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = wrapper->_this ();' 
       end // if
       else
       begin
        'f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ');' 
       end // else
//				f-\>second.is_ro_first = true;[{%Ss=synchro}
       '			f->second.is_ro_first = true;'
       if ( ( %S |s ) %== 'synchro' ) then
       begin
        #13#10

//				return f-\>second[.%f_cache_postfix(%S,"read-only")];]
        '			return f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ';' 
       end // if
//			} else if (f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr ()] == 0) {
       '		} else if (f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, 'read-only' )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.ptr ()' 
       end // if
       ' == 0) {'
//				[{%{INT}S=ServerInterface&%S#f_is_exported()=true}{f-\>second[.%f_cache_postfix(%S,"read-only")] = new %{INT}NConstWrapper (
       '			'
       if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' AND 
         ( ( %S %?f is_exported %( )% ) %==  true  ) ) then
       begin
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper_var wrapper = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()])
        '				'
        ( get_global_var ( 'INT' ) |N ) '::_duplicate (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ')'
//				);
        '			);'
//				f-\>second[.%f_cache_postfix(%S,"read-only")] = wrapper-\>_this ();][{%Ss=synchro}
        '			f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = wrapper->_this ();' 
       end // if
       else
       begin
        'f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ' = new '
        ( get_global_var ( 'INT' ) |N ) 'ConstWrapper ('
//					%{INT}N::_duplicate (f-\>second[.%t_cache_postfix(%S,"read-write")][{%Ss!=synchro}.in ()])
        '				'
        ( get_global_var ( 'INT' ) |N ) '::_duplicate (f->second'
        if NOT-EMPTY
        begin
         '.'
         [%t] cache_postfix %( %S %, 'read-write' )% 
        end // if
        NOP
        if ( ( %S |s ) %!= 'synchro' ) then
        begin
         '.in ()' 
        end // if
        ')'
//				);}%{INT}NConstWrapper_var wrapper = new %{INT}NConstWrapper (
        '			);' 
       end // else
       if ( ( %S |s ) %== 'synchro' ) then
       begin
        #13#10

//				return f-\>second[.%f_cache_postfix(%S,"read-only")];]
        '			return f->second'
        if NOT-EMPTY
        begin
         '.'
         [%f] cache_postfix %( %S %, 'read-only' )% 
        end // if
        NOP
        ';' 
       end // if
//			}]
       '		}' 
      end // if
      else
      begin
       '	FactoryMap::iterator f_fct = m_factories_map.find (key);'
//			if (f_fct == m_factories_map.end()) {
       '		if (f_fct == m_factories_map.end()) {'
//				throw Core::Root::UnknownFactoryKey (
       '			throw Core::Root::UnknownFactoryKey ('
//					"%P%P%PN::%P%PN::%PNFactory"
       '				"'
       %P ->P ->P |N   '::'
       %P ->P |N  '::'
       %P |N 'Factory"'
//					, [{%f_need_lexical_cast(%{INT})=true}{key}boost::lexical_cast\<std::string\> (key).c_str ()]
       '				, '
       if ( ( [%f] need_lexical_cast %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
       begin
        'boost::lexical_cast<std::string> (key).c_str ()' 
       end // if
       else
       begin
        'key' 
       end // else
//				);
       '			);'
//			}
       '		' 
      end // else
//		}[{%f_is_ro_fctr_exists(%S)=true&%3N=read-write} else if (
      '	}'
      if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true AND 
        ( ( %3 |N ) %== 'read-write'  ) ) then
      begin
       ' else if ('
//			f != m_cached_objects_for_%SN.end()
       '		f != m_cached_objects_for_'
       %S |N '.end()'
//			&& f-\>second[.%f_cache_postfix(%S,"read-only")][{%Ss!=synchro}.ptr ()] != 0
       '		&& f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, 'read-only' )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.ptr ()' 
       end // if
       ' != 0'
//			&& f-\>second.is_ro_first == true
       '		&& f->second.is_ro_first == true'
//		) {
       '	) {'
//			f-\>second[.%f_cache_postfix(%S,"read-only")]-\>upgrade_rw ();
       '		f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, 'read-only' )% 
       end // if
       NOP
       '->upgrade_rw ();'
//			f-\>second.is_ro_first = false;
       '		f->second.is_ro_first = false;'
//		}]
       '	}' 
      end // if
//		GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.in ()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
      '	GDS_ASSERT_MSG (f->second'
      if NOT-EMPTY
      begin
       '.'
       [%f] cache_postfix %( %S %, %3 |N )% 
      end // if
      NOP
      if ( ( %S |s ) %!= 'synchro' ) then
      begin
       '.in ()' 
      end // if
      ' != 0, ("'
      %P ->P ->P |N   '::'
      %P ->P |N  '::'
      %P |N 'Factory impl can''t return zerro"));'
//		return [{[{%{INT}S!=ServerInterface}{[{%S#f_is_exported()=true}{true}false]}true]=true&%Ss!=synchro}{%{INT}N::_duplicate(f-\>second[.%f_cache_postfix(%S,"%1N")][{%Ss!=synchro}.in()])}*f-\>second[.%f_cache_postfix(%S,"%3N")]];
      '	return '
      if ( if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' ) then
       begin
         true 
       end // if
       else
       begin
        if ( ( %S %?f is_exported %( )% ) %==  true ) then
        begin
          false 
        end // if
        else
        begin
          true 
        end // else
       end // else
       %==  true AND 
        ( ( %S |s ) %!= 'synchro'  ) ) then
      begin
       '*f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
      end // if
      else
      begin
       ( get_global_var ( 'INT' ) |N ) '::_duplicate(f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %1 |N )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.in()' 
       end // if
       ')' 
      end // else
      ';'
//	]][{%TS=FactoryMemory}
     end // if
    end // if
    if ( ( %T |S ) %== 'FactoryMemory' ) then
    begin
     #13#10

//	%f_fctr_mng_mem_cpp(%S,"%3N")
     [%f] fctr_mng_mem_cpp %( %S %, %3 |N )% 
//	]}][{%S{transparent multy}=true}\
    end // if
    '}' 
   end // if
   if ( ( %S get_up ( 'transparent multy' ) ) %==  true ) then
   begin

////%S{transparent multy}=true
//	%t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%Ss]") %{INT}NFactoryManager::%SN (%S%f_factory_params("%1N")) [{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{throw (CORBA::SystemException, CoreSrv::NoActiveFactory<, %f_type(%E)>)}/*throw (Core::Root::NoActiveFactory<, %f_type(%E)>)*/] {\
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
      ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
    begin
     %S |s 
    end // if
)%     ' '
    ( get_global_var ( 'INT' ) |N ) 'FactoryManager::'
    %S |N ' ('
    %S %f factory_params %( %1 |N )% ') '
    if ( ( [%f] realize_srv_interface %( %S )% ) %==  false OR 
      ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
    begin
     '/*throw (Core::Root::NoActiveFactory'
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       ', '
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E
     ')*/' 
    end // if
    else
    begin
     'throw (CORBA::SystemException, CoreSrv::NoActiveFactory'
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       ', '
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E
     ')' 
    end // else
    ' {'
//	[{%f_is_it_cached(%S)=false}
    if ( ( [%f] is_it_cached %( %S )% ) %==  false ) then
    begin
     #13#10

//		Core::Var\<%{INT}NAbstractFactory\> factory;
     '	Core::Var<'
     ( get_global_var ( 'INT' ) |N ) 'AbstractFactory> factory;'
//		%U[{_CUSTOM_SELECT_FACTORY}
     '	'
     %Usersection (
      '_CUSTOM_SELECT_FACTORY' 
     )
     (
      #13#10

//		]
      '	' 
     ) // Usersection
 //		if (factory.is_nil () == true) {
     '	if (factory.is_nil () == true) {'
//			throw [{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{CoreSrv::NoActiveFactory ()}Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory")];
     '		throw '
     if ( ( [%f] realize_srv_interface %( %S )% ) %==  false OR 
       ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
     begin
      'Core::Root::NoActiveFactory ("'
      %P ->P ->P |N   '::'
      %P ->P |N  '::'
      %P |N 'Factory")' 
     end // if
     else
     begin
      'CoreSrv::NoActiveFactory ()' 
     end // else
     ';'
//		}
     '	}'
//		
     '	'
//		return factory-\>%SN (<{, }%CN>);
     '	return factory->'
     %S |N ' ('
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |N 
       ++! l_Counter
      end // if
     end // for C
     ');'
//	][{%TS!=FactoryMemory}[{%Ss=cached|%Ss=const,cached}
    end // if
    if ( ( %T |S ) %!= 'FactoryMemory' ) then
    begin
     if ( ( %S |s ) %== 'cached' OR 
       ( ( %S |s ) %== 'const,cached'  ) ) then
     begin
      #13#10

//		GUARD(m_mutex_for_%SN);
      '	GUARD(m_mutex_for_'
      %S |N ');'
//		CachedObjectsFor%f_to_borland(%SN)::iterator f = m_cached_objects_for_%SN.find (ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>));
      '	CachedObjectsFor'
      [%f] to_borland %( %S |N )% '::iterator f = m_cached_objects_for_'
      %S |N '.find (ObjectCreationIdFor'
      [%f] to_borland %( %S |N )% '('
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %!= 'nokey' ) then
       begin
        if ( l_Counter >0 ) then ( ', ' )
        %C |N 
        ++! l_Counter
       end // if
      end // for C
      '));'
//		if (f == m_cached_objects_for_%SN.end()) {
      '	if (f == m_cached_objects_for_'
      %S |N '.end()) {'
//			Core::Var\<%{INT}NAbstractFactory\> factory;
      '		Core::Var<'
      ( get_global_var ( 'INT' ) |N ) 'AbstractFactory> factory;'
//			%U[{_CUSTOM_SELECT_FACTORY}
      '		'
      %Usersection (
       '_CUSTOM_SELECT_FACTORY' 
      )
      (
       #13#10

//			]
       '		' 
      ) // Usersection
 //			if (factory.is_nil () == true) {
      '		if (factory.is_nil () == true) {'
//				throw [{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{CoreSrv::NoActiveFactory ()}Core::Root::NoActiveFactory ("%P%P%PN::%P%PN::%PNFactory")];
      '			throw '
      if ( ( [%f] realize_srv_interface %( %S )% ) %==  false OR 
        ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
      begin
       'Core::Root::NoActiveFactory ("'
       %P ->P ->P |N   '::'
       %P ->P |N  '::'
       %P |N 'Factory")' 
      end // if
      else
      begin
       'CoreSrv::NoActiveFactory ()' 
      end // else
      ';'
//			}
      '		}'
//			f = m_cached_objects_for_%SN.insert (
      '		f = m_cached_objects_for_'
      %S |N '.insert ('
//				CachedObjectsFor%f_to_borland(%SN)::value_type(
      '			CachedObjectsFor'
      [%f] to_borland %( %S |N )% '::value_type('
//					ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
      '				ObjectCreationIdFor'
      [%f] to_borland %( %S |N )% '('
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %!= 'nokey' ) then
       begin
        if ( l_Counter >0 ) then ( ', ' )
        %C |N 
        ++! l_Counter
       end // if
      end // for C
      ')'
//					, factory-\>%SN (<{, }%CN>[{%f_is_ro_fctr_exists(%S)=true}[{%Cx=true}, ][{%3N=read-only}{false}true]])
      '				, factory->'
      %S |N ' ('
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if true then
       begin
        if ( l_Counter >0 ) then ( ', ' )
        %C |N 
        ++! l_Counter
       end // if
      end // for C
      if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
      begin
       if ( ( %C |x ) %==  true ) then
       begin
        ', ' 
       end // if
       if ( ( %3 |N ) %== 'read-only' ) then
       begin
         true 
       end // if
       else
       begin
         false 
       end // else
      end // if
      ')'
//				)
      '			)'
//			).first;
      '		).first;'
//			m_cached_objects_index_for_%SN.insert (
      '		m_cached_objects_index_for_'
      %S |N '.insert ('
//				CachedObjectsIndexFor%f_to_borland(%SN)::value_type (
      '			CachedObjectsIndexFor'
      [%f] to_borland %( %S |N )% '::value_type ('
//					f-\>second[.%f_cache_postfix(%S,"read-write")][{%f_is_server_type(%{INT})=true}{[{%Ss!=synchro}.in()]}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())], f
      '				f->second'
      if NOT-EMPTY
      begin
       '.'
       [%f] cache_postfix %( %S %, 'read-write' )% 
      end // if
      NOP
      if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
      begin
       '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
      end // if
      else
      begin
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.in()' 
       end // if
      end // else
      ', f'
//				)
      '			)'
//			);[{%Ss=synchro}
      '		);'
      if ( ( %S |s ) %== 'synchro' ) then
      begin
       #13#10

//			return f-\>second;]
       '		return f->second;' 
      end // if
//		}
      '	}'
//		GDS_ASSERT_MSG (f-\>second[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.in ()] != 0, ("%P%P%PN::%P%PN::%PNFactory impl can't return zerro"));
      '	GDS_ASSERT_MSG (f->second'
      if NOT-EMPTY
      begin
       '.'
       [%f] cache_postfix %( %S %, %3 |N )% 
      end // if
      NOP
      if ( ( %S |s ) %!= 'synchro' ) then
      begin
       '.in ()' 
      end // if
      ' != 0, ("'
      %P ->P ->P |N   '::'
      %P ->P |N  '::'
      %P |N 'Factory impl can''t return zerro"));'
//		return [{[{%{INT}S!=ServerInterface}{[{%S#f_is_exported()=true}{true}false]}true]=true&%Ss!=synchro}{%{INT}N::_duplicate(f-\>second[.%f_cache_postfix(%S,"%3N")][{%Ss!=synchro}.in()])}*f-\>second[.%f_cache_postfix(%S,"%3N")]];
      '	return '
      if ( if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' ) then
       begin
         true 
       end // if
       else
       begin
        if ( ( %S %?f is_exported %( )% ) %==  true ) then
        begin
          false 
        end // if
        else
        begin
          true 
        end // else
       end // else
       %==  true AND 
        ( ( %S |s ) %!= 'synchro'  ) ) then
      begin
       '*f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
      end // if
      else
      begin
       ( get_global_var ( 'INT' ) |N ) '::_duplicate(f->second'
       if NOT-EMPTY
       begin
        '.'
        [%f] cache_postfix %( %S %, %3 |N )% 
       end // if
       NOP
       if ( ( %S |s ) %!= 'synchro' ) then
       begin
        '.in()' 
       end // if
       ')' 
      end // else
      ';'
//	]][{%TS=FactoryMemory}
     end // if
    end // if
    if ( ( %T |S ) %== 'FactoryMemory' ) then
    begin
     #13#10

//	%f_fctr_mng_mem_cpp(%S,"%3N")
     [%f] fctr_mng_mem_cpp %( %S %, %3 |N )% 
//	]}]]
    end // if
    '}' 
   end // if
  end // if
  NOP

 ) // bind
 
//#UC END# *497870EF0151for47174CE200AB*
; // fctr_mng_m_fctr_cpp_impl


// Используется виртуальное/не виртуальное наследование в зависимости от стереотипа.
//%f _is_virtual_inheritance
: is_virtual_inheritance OBJECT IN %S
//#UC START# *497AD7C30382for47174CE200AB*
//	virtual
 'virtual'
//#UC END# *497AD7C30382for47174CE200AB*
; // is_virtual_inheritance


// выводит имя метода на менеджере фабрик для получения экземпляра менеджера
//%f _fctr_mng_get_instance_name
: fctr_mng_get_instance_name OBJECT IN %S
//#UC START# *4988233B02FDfor47174CE200AB*
//	%t_language_style("get_instance_do_not_call_by_hand")
 [%t] language_style %( 'get_instance_do_not_call_by_hand' )% 
//#UC END# *4988233B02FDfor47174CE200AB*
; // fctr_mng_get_instance_name


// находит атрибут-селектор мульти фабрики и записывает его в переменную с заданным идентификатором
//%f _find_switch
: find_switch OBJECT IN %S
// параметры: var: string = %1
//#UC START# *499274E601E7for47174CE200AB*
//	[{"%1N"=""}%f_error("_find_switch: Не задан идентификатор переменной")]\
 if ( ( %1 |N ) %== '' ) then
 begin
  [%f] error %( '_find_switch: Не задан идентификатор переменной' )% 
 end // if
//	%f_set_var(__SWITCH_ARG__,"%1N")\
 [%f] set_var %( '__SWITCH_ARG__' %, %1 |N )% 
//	%f_set_var(FOUNDED,"false")\
 [%f] set_var %( 'FOUNDED' %, false )% 
//	<{}{%CC=Attribute&%CS=factory switch}%f_set_var(%{__SWITCH_ARG__}N,C)%f_set_var(FOUNDED,"true")>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |C ) %== 'Attribute' AND 
   ( ( %C |S ) %== 'factory switch'  ) ) then
  begin
   [%f] set_var %( ( get_global_var ( '__SWITCH_ARG__' ) |N ) %, 'C' )% [%f] set_var %( 'FOUNDED' %, true )% 
   ++! l_Counter
  end // if
 end // for C
//	[{%{FOUNDED}N=false}<{}{%ga=abstract}\
 if ( ( ( get_global_var ( 'FOUNDED' ) |N ) ) %==  false ) then
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
//	%g<{}{%CC=Attribute&%CS=factory switch}%f_set_var(%{__SWITCH_ARG__}N,C)%f_set_var(FOUNDED,"true")>\
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |C ) %== 'Attribute' AND 
       ( ( %C |S ) %== 'factory switch'  ) ) then
      begin
       [%f] set_var %( ( get_global_var ( '__SWITCH_ARG__' ) |N ) %, 'C' )% [%f] set_var %( 'FOUNDED' %, true )% 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
 //	>]\

    ++! l_Counter
   end // if
  end // for g
 end // if
//	[{%{FOUNDED}N=false&%SS=LocalInterface}<{}{}%R#f_find_switch("%{__SWITCH_ARG__}N")>]
 if ( ( ( get_global_var ( 'FOUNDED' ) |N ) ) %==  false AND 
   ( ( %S |S ) %== 'LocalInterface'  ) ) then
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if true then
   begin
    %R %?f find_switch %( ( get_global_var ( '__SWITCH_ARG__' ) |N ) )% 
    ++! l_Counter
   end // if
  end // for R
 end // if
//#UC END# *499274E601E7for47174CE200AB*
; // find_switch


// Генерация умолчального ремувера для сущности
//%f _additional_remover_declaration
: additional_remover_declaration OBJECT IN %S
//#UC START# *49A643ED0131for47174CE200AB*
//#UC END# *49A643ED0131for47174CE200AB*
; // additional_remover_declaration


// Генерит исключения в декларации фабрики
//%f _dump_exceptions
: dump_exceptions OBJECT IN %S
//#UC START# *49ACD9EC0231for47174CE200AB*
//	[{"%2N"="NEW_LINE"}{ }\n		]/*throw (Core::Root::NoActiveFactory, Core::Root::FactoryManagerWasDestroyed[{%f_need_conversion_exception(%1)=true}, Core::Root::ImpossibleConversion]%1<, %f_type(%E)>)*/[{"%XU"="h"};]
 if ( ( %2 |N ) %== 'NEW_LINE' ) then
 begin
  #13#10'		' 
 end // if
 else
 begin
  ' ' 
 end // else
 '/*throw (Core::Root::NoActiveFactory, Core::Root::FactoryManagerWasDestroyed'
 if ( ( [%f] need_conversion_exception %( %1 )% ) %==  true ) then
 begin
  ', Core::Root::ImpossibleConversion' 
 end // if
 %1
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E

 ) // bind
  ')*/'
 if ( ( %X |U ) %== 'h' ) then
 begin
  ';' 
 end // if
//#UC END# *49ACD9EC0231for47174CE200AB*
; // dump_exceptions


// Дополнительная реализация для менеджера фабрик
//%f _additional_mgr_factory_implementation
: additional_mgr_factory_implementation OBJECT IN %S
//#UC START# *49B11D7A001Cfor47174CE200AB*
//#UC END# *49B11D7A001Cfor47174CE200AB*
; // additional_mgr_factory_implementation


// Генерит реализацию менеджеоа фабрик
//%f _dump_fctr_mng_impl_cpp
: dump_fctr_mng_impl_cpp OBJECT IN %S
//#UC START# *49B6246F03B2for47174CE200AB*
//	%f_set_var(INT,S)[{"%f_has_factory_methods(%S)"="true"}{[{%f_has_self_factory_methods(%S)=true}<{}{%CS=FactoryMemory}%CX>]}
 [%f] set_var %( 'INT' %, 'S' )% if ( ( [%f] has_factory_methods %( %S )% ) %== true ) then
 begin
  #13#10

//	//////////////////////////////////////////////////////////////////////////////////////
  '//////////////////////////////////////////////////////////////////////////////////////'
//	// implementation of factory manager methods for %SN
  '// implementation of factory manager methods for '
  %S |N 
//	bool %SNFactoryManager::s_was_destroyed = false;[{%f_need_const_wrapper(%S)=true}
  'bool '
  %S |N 'FactoryManager::s_was_destroyed = false;'
  if ( ( [%f] need_const_wrapper %( %S )% ) %==  true ) then
  begin
   #13#10

//	[
   if NOT-EMPTY
   begin
    #13#10

//	%f_const_wrapper_operations_cpp(%S)
    [%f] const_wrapper_operations_cpp %( %S )% 
//	%SNConstWrapper::%SNConstWrapper ([{%SS!=ServerInterface}{%f_full_name(%S)}%SN]* impl)
    %S |N 'ConstWrapper::'
    %S |N 'ConstWrapper ('
    if ( ( %S |S ) %!= 'ServerInterface' ) then
    begin
     %S |N 
    end // if
    else
    begin
     [%f] full_name %( %S )% 
    end // else
    '* impl)'
//		: m_impl (impl), is_rw (false)
    '	: m_impl (impl), is_rw (false)'
//	{
    '{'
//	}
    '}'
//	]
   end // if
   NOP
//	%SNFactoryManager::ComboDataVar::ComboDataVar ()
   %S |N 'FactoryManager::ComboDataVar::ComboDataVar ()'
//		: rw_data (0), ro_data (0), is_ro_first (false)
   '	: rw_data (0), ro_data (0), is_ro_first (false)'
//	{
   '{'
//	}
   '}'
//	
   #13#10

//	%SNFactoryManager::ComboDataVar::ComboDataVar (%SN* rw_data_)
   %S |N 'FactoryManager::ComboDataVar::ComboDataVar ('
   %S |N '* rw_data_)'
//		: rw_data (rw_data_), ro_data (0), is_ro_first (false)
   '	: rw_data (rw_data_), ro_data (0), is_ro_first (false)'
//	{
   '{'
//	}
   '}'
//	[{<{}{%f_is_factory(%C)=true&%Cs=synchro}{%CC}>!=0}
   if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( [%f] is_factory %( %C )% ) %==  true AND 
      ( ( %C |s ) %== 'synchro'  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %!= 0 ) then
   begin
    #13#10

//	%SNFactoryManager::ComboDataPtr::ComboDataPtr ()
    %S |N 'FactoryManager::ComboDataPtr::ComboDataPtr ()'
//	: rw_data (0), ro_data (0), is_ro_first (false)
    ': rw_data (0), ro_data (0), is_ro_first (false)'
//	{
    '{'
//	}
    '}'
//	
    #13#10

//	%SNFactoryManager::ComboDataPtr::ComboDataPtr (%SN* rw_data_)
    %S |N 'FactoryManager::ComboDataPtr::ComboDataPtr ('
    %S |N '* rw_data_)'
//	: rw_data (rw_data_), ro_data (0), is_ro_first (false)
    ': rw_data (rw_data_), ro_data (0), is_ro_first (false)'
//	{
    '{'
//	}
    '}'
//	]]
   end // if
  end // if
//	
  #13#10

//	%SNFactoryManager::%SNFactoryManager () /*throw (Core::Root::FactoryManagerWasDestroyed)*/
  %S |N 'FactoryManager::'
  %S |N 'FactoryManager () /*throw (Core::Root::FactoryManagerWasDestroyed)*/'
//		: m_has_registred_factories(false)
  '	: m_has_registred_factories(false)'
//	{
  '{'
//		if (s_was_destroyed == true) {
  '	if (s_was_destroyed == true) {'
//			throw Core::Root::FactoryManagerWasDestroyed ();
  '		throw Core::Root::FactoryManagerWasDestroyed ();'
//		}[
  '	}'
  if NOT-EMPTY
  begin
   #13#10

//		%S%f_additional_fctr_mng_ctor_initialization()]<{}{%f_is_factory(%C)=true&%Cs=synchro&%C%TS!=FactoryMemory}[{%C%Cx=true|%CS=multi factory}{
   '	'
   %S %f additional_fctr_mng_ctor_initialization %( )% 
  end // if
  NOP
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  true AND 
    ( ( %C |s ) %== 'synchro'  ) AND 
    ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
   begin
    if ( ( %C ->C |x  ) %==  true OR 
      ( ( %C |S ) %== 'multi factory'  ) ) then
    begin
    end // if
    else
    begin
     #13#10

//		[{%C{const_type}=combo|%C{const_type}=read-only}{m_cached_object_for_%CN = 0;}m_cached_object_for_%CN.rw_data = 0;
     '	'
     if ( ( %C get_up ( 'const_type' ) ) %== 'combo' OR 
       ( ( %C get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
     begin
      'm_cached_object_for_'
      %C |N '.rw_data = 0;'
//		m_cached_object_for_%CN.ro_data = 0;]}]>
      '	m_cached_object_for_'
      %C |N '.ro_data = 0;' 
     end // if
     else
     begin
      'm_cached_object_for_'
      %C |N ' = 0;' 
     end // else
    end // else

    ++! l_Counter
   end // if
  end // for C
//	}
  '}'
//	
  #13#10

//	%SNFactoryManager::~%SNFactoryManager () {
  %S |N 'FactoryManager::~'
  %S |N 'FactoryManager () {'
//		s_was_destroyed = true;
  '	s_was_destroyed = true;'
//	}
  '}'
//	
  #13#10

//	void %SNFactoryManager::register_factory (
  'void '
  %S |N 'FactoryManager::register_factory ('
//		%SNAbstractFactory* factory, Core::Root::FactoryPriority priority
  '	'
  %S |N 'AbstractFactory* factory, Core::Root::FactoryPriority priority'
//	) /*throw (Core::Root::DuplicatedFactoryKey, Core::Root::FactoryManagerWasDestroyed)*/ {
  ') /*throw (Core::Root::DuplicatedFactoryKey, Core::Root::FactoryManagerWasDestroyed)*/ {'
//		if (s_was_destroyed == true) {
  '	if (s_was_destroyed == true) {'
//			throw Core::Root::FactoryManagerWasDestroyed ();
  '		throw Core::Root::FactoryManagerWasDestroyed ();'
//		}
  '	}'
//		Singleton::instance()-\>register_factory_i (factory, priority);[{%SS=LocalInterface}
  '	Singleton::instance()->register_factory_i (factory, priority);'
  if ( ( %S |S ) %== 'LocalInterface' ) then
  begin
   #13#10

//		<{}{%f_is_interface(%R)=true&%f_has_factory_methods(%R)=true}%f_type(%R)FactoryManager::register_factory (factory, priority);
   '	'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%R
   begin
    OBJECT IN %R
    if ( ( [%f] is_interface %( %R )% ) %==  true AND 
     ( ( [%f] has_factory_methods %( %R )% ) %==  true  ) ) then
    begin
     [%f] type %( %R )% 'FactoryManager::register_factory (factory, priority);'
//		><{}{%ga=abstract}%g<{}{%f_is_interface(%R)=true&%f_has_factory_methods(%R)=true}%f_type(%R)FactoryManager::register_factory (factory, priority);
     '	' 
     ++! l_Counter
    end // if
   end // for R
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%R
      begin
       OBJECT IN %R
       if ( ( [%f] is_interface %( %R )% ) %==  true AND 
        ( ( [%f] has_factory_methods %( %R )% ) %==  true  ) ) then
       begin
        [%f] type %( %R )% 'FactoryManager::register_factory (factory, priority);'
//		>>]
        '	' 
        ++! l_Counter
       end // if
      end // for R

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
//	}[{%S%f_has_multi_factory()=true&%Sa!=abstract}
  '}'
  if ( ( %S %f has_multi_factory %( )% ) %==  true AND 
    ( ( %S |a ) %!= 'abstract'  ) ) then
  begin
   #13#10

//	
   #13#10

//	%S%f_dump_fmng_keys_method()]
   %S %f dump_fmng_keys_method %( )% 
  end // if
//	
  #13#10

//	%S%f_publish_self_cpp()\
  %S %f publish_self_cpp %( )% 
//	void %SNFactoryManager::register_factory_i (
  'void '
  %S |N 'FactoryManager::register_factory_i ('
//		%SNAbstractFactory* factory, Core::Root::FactoryPriority priority
  '	'
  %S |N 'AbstractFactory* factory, Core::Root::FactoryPriority priority'
//	) /*throw (Core::Root::DuplicatedFactoryKey)*/ {
  ') /*throw (Core::Root::DuplicatedFactoryKey)*/ {'
//		m_has_registred_factories = true;
  '	m_has_registred_factories = true;'
//		FactoryMap::iterator f = m_factories_map.find(factory-\>key());
  '	FactoryMap::iterator f = m_factories_map.find(factory->key());'
//		if (f != m_factories_map.end() && f-\>second.priority == priority) {
  '	if (f != m_factories_map.end() && f->second.priority == priority) {'
//			throw Core::Root::DuplicatedFactoryKey (
  '		throw Core::Root::DuplicatedFactoryKey ('
//				"%P%PN::%PN::%SNFactory"
  '			"'
  %P ->P |N  '::'
  %P |N '::'
  %S |N 'Factory"'
//				, [{%f_need_lexical_cast(%{INT})=true}{factory-\>key()[{%{INT}%f_dump_switch_type_name()=a-string}.c_str ()]}boost::lexical_cast\<std::string\> (factory-\>key()).c_str ()]
  '			, '
  if ( ( [%f] need_lexical_cast %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   'boost::lexical_cast<std::string> (factory->key()).c_str ()' 
  end // if
  else
  begin
   'factory->key()'
   if ( ( ( get_global_var ( 'INT' ) %f dump_switch_type_name %( )% ) ) %== 'a-string' ) then
   begin
    '.c_str ()' 
   end // if
  end // else
//			);
  '		);'
//		}
  '	}'
//		if (f == m_factories_map.end() || f-\>second.priority \<= priority) {
  '	if (f == m_factories_map.end() || f->second.priority <= priority) {'
//			m_factories_map\[factory-\>key()\].factory = %SNAbstractFactory::_duplicate(factory);
  '		m_factories_map[factory->key()].factory = '
  %S |N 'AbstractFactory::_duplicate(factory);'
//			m_factories_map\[factory-\>key()\].priority = priority;
  '		m_factories_map[factory->key()].priority = priority;'
//		}
  '	}'
//		
  '	'
//		if (!m_single_active_factory || m_single_active_factory_priority \<= priority) {
  '	if (!m_single_active_factory || m_single_active_factory_priority <= priority) {'
//			m_single_active_factory = %SNAbstractFactory::_duplicate(factory);
  '		m_single_active_factory = '
  %S |N 'AbstractFactory::_duplicate(factory);'
//			m_single_active_factory_priority = priority;
  '		m_single_active_factory_priority = priority;'
//		}
  '	}'
//	}[{%f_has_synchro_factory(%S)=true}
  '}'
  if ( ( [%f] has_synchro_factory %( %S )% ) %==  true ) then
  begin
   #13#10

//	
   #13#10

//	%SNFactoryManager::CacheLocker::CacheLocker () {
   %S |N 'FactoryManager::CacheLocker::CacheLocker () {'
//	%f_clear_list(MUTEX_LIST)<{}{%f_is_factory(%C)&%Cs=synchro}[%f_lock_mutex_for_cache_locker(%C)
   [%f] clear_list %( 'MUTEX_LIST' )% 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( [%f] is_factory %( %C )% ) AND 
     ( ( %C |s ) %== 'synchro'  ) ) then
    begin
     if NOT-EMPTY
     begin
      [%f] lock_mutex_for_cache_locker %( %C )% 
//	]><{}{%ga=abstract}%g<{}{%f_is_factory(%C)&%Cs=synchro}[%f_lock_mutex_for_cache_locker(%C)
     end // if
     NOP

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( [%f] is_factory %( %C )% ) AND 
        ( ( %C |s ) %== 'synchro'  ) ) then
       begin
        if NOT-EMPTY
        begin
         [%f] lock_mutex_for_cache_locker %( %C )% 
//	]>>
        end // if
        NOP

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
//	}
   '}'
//	
   #13#10

//	%SNFactoryManager::CacheLocker::~CacheLocker () {
   %S |N 'FactoryManager::CacheLocker::~CacheLocker () {'
//	%f_clear_list(MUTEX_LIST)<{}{%f_is_factory(%C)&%Cs=synchro}[%f_unlock_mutex_for_cache_locker(%C)
   [%f] clear_list %( 'MUTEX_LIST' )% 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( [%f] is_factory %( %C )% ) AND 
     ( ( %C |s ) %== 'synchro'  ) ) then
    begin
     if NOT-EMPTY
     begin
      [%f] unlock_mutex_for_cache_locker %( %C )% 
//	]><{}{%ga=abstract}%g<{}{%f_is_factory(%C)&%Cs=synchro}[%f_unlock_mutex_for_cache_locker(%C)
     end // if
     NOP

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( [%f] is_factory %( %C )% ) AND 
        ( ( %C |s ) %== 'synchro'  ) ) then
       begin
        if NOT-EMPTY
        begin
         [%f] unlock_mutex_for_cache_locker %( %C )% 
//	]>>
        end // if
        NOP

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
//	}
   '}'
//	
   #13#10

//	void %SNFactoryManager::clean (%t_arg_cpp(%S,"in") obj) {
   'void '
   %S |N 'FactoryManager::clean ('
   [%t] arg_cpp %( %S %, 'in' )% ' obj) {'
//		%SNFactoryManager::Singleton::instance ()-\>clean_i (obj);
   '	'
   %S |N 'FactoryManager::Singleton::instance ()->clean_i (obj);'
//	}
   '}'
//	
   #13#10

//	void %SNFactoryManager::clean_i (%t_arg_cpp(%S,"in") obj) {
   'void '
   %S |N 'FactoryManager::clean_i ('
   [%t] arg_cpp %( %S %, 'in' )% ' obj) {'
//		//удаляем объект из всех синхро фабрик
   '	//удаляем объект из всех синхро фабрик'
//	%f_clear_list(CACHE_LIST)<{}{%f_is_factory(%C)=true&%Cs=synchro}[%f_dump_clean_synchro_cache(%C)
   [%f] clear_list %( 'CACHE_LIST' )% 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( [%f] is_factory %( %C )% ) %==  true AND 
     ( ( %C |s ) %== 'synchro'  ) ) then
    begin
     if NOT-EMPTY
     begin
      [%f] dump_clean_synchro_cache %( %C )% 
//	]><{}{%ga=abstract}%g<{}{%f_is_factory(%C)=true&%Cs=synchro}[%f_dump_clean_synchro_cache(%C)
     end // if
     NOP

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( [%f] is_factory %( %C )% ) %==  true AND 
        ( ( %C |s ) %== 'synchro'  ) ) then
       begin
        if NOT-EMPTY
        begin
         [%f] dump_clean_synchro_cache %( %C )% 
//	]>>
        end // if
        NOP

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
//	}
   '}'
//	]\
  end // if
//	%f_set_var(INT,S)%f_dump_factories_impl_cpp(%S)[
  [%f] set_var %( 'INT' %, 'S' )% [%f] dump_factories_impl_cpp %( %S )% if NOT-EMPTY
  begin
   #13#10

//	
   #13#10

//	%S%f_additional_mgr_factory_methods_impl()
   %S %f additional_mgr_factory_methods_impl %( )% 
//	]<{}{%CS=FactoryMemory}%CX>]%S%f_additional_mgr_factory_implementation()
  end // if
  NOP
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'FactoryMemory' ) then
   begin
    %C |X 
    ++! l_Counter
   end // if
  end // for C
 end // if
 else
 begin
  if ( ( [%f] has_self_factory_methods %( %S )% ) %==  true ) then
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'FactoryMemory' ) then
    begin
     %C |X 
     ++! l_Counter
    end // if
   end // for C
  end // if
 end // else
 %S %f additional_mgr_factory_implementation %( )% 
//	]
 ']'
//#UC END# *49B6246F03B2for47174CE200AB*
; // dump_fctr_mng_impl_cpp


// Генерит определения атрибутов и операций заданных на сущности или интерфейсе.
//%f _dump_methods_decl
: dump_methods_decl OBJECT IN %S
//#UC START# *49B7DFE801D5for47174CE200AB*
//	[#public:<{}{"%f_is_factory(%C)"="false"&%CV=PublicAccess}[
 if NOT-EMPTY
 begin
  out_indent 'public:'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %== false AND 
    ( ( %C |V ) %== 'PublicAccess'  ) ) then
   begin
    if NOT-EMPTY
    begin
     #13#10

//	%CX
     %C |X 
//	]>][#protected:<{}{"%f_is_factory(%C)"="false"&%CV!=PublicAccess}[
    end // if
    NOP

    ++! l_Counter
   end // if
  end // for C
 end // if
 NOP
 if NOT-EMPTY
 begin
  out_indent 'protected:'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %== false AND 
    ( ( %C |V ) %!= 'PublicAccess'  ) ) then
   begin
    if NOT-EMPTY
    begin
     #13#10

//	%CX
     %C |X 
//	]>]
    end // if
    NOP

    ++! l_Counter
   end // if
  end // for C
 end // if
 NOP
//#UC END# *49B7DFE801D5for47174CE200AB*
; // dump_methods_decl


// возвращает true, если интерфейс имеет мульти фабрику (либо наследует её от своих абстрактных
// предков)
//%f _has_multi_factory
: has_multi_factory OBJECT IN %S
//#UC START# *4B715A9D0094for47174CE200AB*
//	[{%S%f_has_self_multi_factory()=false}{true}\
 if ( ( %S %f has_self_multi_factory %( )% ) %==  false ) then
 begin
//	[{<{}{%ga=abstract&%g#f_has_self_multi_factory()=true}{%gC}>=0}{true}\
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' AND 
     ( ( %g %?f has_self_multi_factory %( )% ) %==  true  ) ) then
    begin

     ++! l_Counter
    end // if
   end // for g
   l_Counter
   %== 0 ) then
  begin
//	[{%SS=LocalInterface}{false}[{<{}{%R#f_has_self_multi_factory()=true}{%RC}>=0}{true}false]]]]
   if ( ( %S |S ) %== 'LocalInterface' ) then
   begin
    if ( 
     INTEGER VAR l_Counter l_Counter := 0
     for %S%R
     begin
      OBJECT IN %R
      if ( ( %R %?f has_self_multi_factory %( )% ) %==  true ) then
      begin

       ++! l_Counter
      end // if
     end // for R
     l_Counter
     %== 0 ) then
    begin
      false 
    end // if
    else
    begin
      true 
    end // else
   end // if
   else
   begin
     false 
   end // else
  end // if
  else
  begin
    true 
  end // else
 end // if
 else
 begin
   true 
 end // else

//%f _has_self_multi_factory
; // has_multi_factory

: has_self_multi_factory OBJECT IN %S
//	[{<{}{%f_is_factory(%C)=true&%CS=multi factory}{%CC}>=0}{true}false]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  true AND 
    ( ( %C |S ) %== 'multi factory'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %== 0 ) then
 begin
   false 
 end // if
 else
 begin
   true 
 end // else
//#UC END# *4B715A9D0094for47174CE200AB*
; // has_self_multi_factory


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа C++ Фабрики::MDAGenerator
// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for47174CE200AB*
//	%f_set_var(__OPEN_IFDEF_STR__,"%S%f_open_ifdef()")\
 [%f] set_var %( '__OPEN_IFDEF_STR__' %, %S %f open_ifdef %( )% )% 
//	%f_set_var(IMPL_BODY,"%S%f_dump_fctr_mng_impl_cpp()")\
 [%f] set_var %( 'IMPL_BODY' %, %S %f dump_fctr_mng_impl_cpp %( )% )% 
//	%f_set_var(__CLOSE_IFDEF_STR__,"%S%f_close_ifdef()")\
 [%f] set_var %( '__CLOSE_IFDEF_STR__' %, %S %f close_ifdef %( )% )% 
//	[{"%{IMPL_BODY}N"!=""}[%{__OPEN_IFDEF_STR__}N
 if ( ( ( get_global_var ( 'IMPL_BODY' ) |N ) ) %!= '' ) then
 begin
  if NOT-EMPTY
  begin
   ( get_global_var ( '__OPEN_IFDEF_STR__' ) |N ) 
//	]%{IMPL_BODY}N[
  end // if
  NOP
  ( get_global_var ( 'IMPL_BODY' ) |N ) if NOT-EMPTY
  begin
   #13#10

//	%{__CLOSE_IFDEF_STR__}N
   ( get_global_var ( '__CLOSE_IFDEF_STR__' ) |N ) 
//	]]
  end // if
  NOP
 end // if

//f _dump_factories_impl_cpp
; // fctr.cpp

end. // <<AbstractInterface>>

: dump_factories_impl_cpp OBJECT IN %S
//	<{}{"%CS"="factory"}{%C}
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== 'factory' ) then
  begin
   #13#10

//	
   #13#10

//	%C%f_fctr_mng_fctr_cpp()><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"}{%C}
   %C %f fctr_mng_fctr_cpp %( )% 
   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if ( ( %g |a ) %== 'abstract' ) then
  begin
   %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %== 'factory' ) then
     begin
      #13#10

//	
      #13#10

//	%C%f_fctr_mng_fctr_cpp()>><{}{"%CS"="multi factory"}{%C}
      %C %f fctr_mng_fctr_cpp %( )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for g
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== 'multi factory' ) then
  begin
   #13#10

//	
   #13#10

//	%C%f_fctr_mng_m_fctr_cpp()><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"}{%C}
   %C %f fctr_mng_m_fctr_cpp %( )% 
   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if ( ( %g |a ) %== 'abstract' ) then
  begin
   %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %== 'multi factory' ) then
     begin
      #13#10

//	
      #13#10

//	%C%f_fctr_mng_m_fctr_cpp()>><{}{"%CS"="remover"}{%C}
      %C %f fctr_mng_m_fctr_cpp %( )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for g
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== 'remover' ) then
  begin
   #13#10

//	
   #13#10

//	%f_fctr_mng_rm_cpp(%C)><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"}{%C}
   [%f] fctr_mng_rm_cpp %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if ( ( %g |a ) %== 'abstract' ) then
  begin
   %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %== 'remover' ) then
     begin
      #13#10

//	
      #13#10

//	%f_fctr_mng_rm_cpp(%C)>>
      [%f] fctr_mng_rm_cpp %( %C )% 
      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for g

//f _dump_inherited_factories_cpp
; // dump_factories_impl_cpp

: dump_inherited_factories_cpp OBJECT IN %S
//	[<{}{%f_is_interface(%R)=true}%f_dump_factories_impl_cpp(%R)>]
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( [%f] is_interface %( %R )% ) %==  true ) then
   begin
    [%f] dump_factories_impl_cpp %( %R )% 
    ++! l_Counter
   end // if
  end // for R
 end // if
 NOP

//f _lock_mutex_for_cache_locker
; // dump_inherited_factories_cpp

: lock_mutex_for_cache_locker OBJECT IN %S
//	[{%f_exists_in_list(MUTEX_LIST,"[{%TS!=FactoryMemory}{m_mutex_for_%f_to_omg(%TN)}m_mutex_for_%SN]")=false}\
 if ( ( [%f] exists_in_list %( 'MUTEX_LIST' %, if ( ( %T |S ) %!= 'FactoryMemory' ) then
  begin
   'm_mutex_for_'
   %S |N 
  end // if
  else
  begin
   'm_mutex_for_'
   [%f] to_omg %( %T |N )% 
  end // else
)% )   %==  false ) then
 begin
//	%f_add_to_list(MUTEX_LIST,"[{%TS!=FactoryMemory}{m_mutex_for_%f_to_omg(%TN)}m_mutex_for_%SN]")\
  [%f] add_to_list %( 'MUTEX_LIST' %, if ( ( %T |S ) %!= 'FactoryMemory' ) then
  begin
   'm_mutex_for_'
   %S |N 
  end // if
  else
  begin
   'm_mutex_for_'
   [%f] to_omg %( %T |N )% 
  end // else
)% //		%{INT}NFactoryManager::Singleton::instance ()-\>[{%TS!=FactoryMemory}{m_mutex_for_%f_to_omg(%TN)}m_mutex_for_%SN].acquire ();
  '	'
  ( get_global_var ( 'INT' ) |N ) 'FactoryManager::Singleton::instance ()->'
  if ( ( %T |S ) %!= 'FactoryMemory' ) then
  begin
   'm_mutex_for_'
   %S |N 
  end // if
  else
  begin
   'm_mutex_for_'
   [%f] to_omg %( %T |N )% 
  end // else
  '.acquire ();'
//	]
 end // if

//f _unlock_mutex_for_cache_locker
; // lock_mutex_for_cache_locker

: unlock_mutex_for_cache_locker OBJECT IN %S
//	[{%f_exists_in_list(MUTEX_LIST,"[{%TS!=FactoryMemory}{m_mutex_for_%f_to_omg(%TN)}m_mutex_for_%SN]")=false}\
 if ( ( [%f] exists_in_list %( 'MUTEX_LIST' %, if ( ( %T |S ) %!= 'FactoryMemory' ) then
  begin
   'm_mutex_for_'
   %S |N 
  end // if
  else
  begin
   'm_mutex_for_'
   [%f] to_omg %( %T |N )% 
  end // else
)% )   %==  false ) then
 begin
//	%f_add_to_list(MUTEX_LIST,"[{%TS!=FactoryMemory}{m_mutex_for_%f_to_omg(%TN)}m_mutex_for_%SN]")\
  [%f] add_to_list %( 'MUTEX_LIST' %, if ( ( %T |S ) %!= 'FactoryMemory' ) then
  begin
   'm_mutex_for_'
   %S |N 
  end // if
  else
  begin
   'm_mutex_for_'
   [%f] to_omg %( %T |N )% 
  end // else
)% //		%{INT}NFactoryManager::Singleton::instance ()-\>[{%TS!=FactoryMemory}{m_mutex_for_%f_to_omg(%TN)}m_mutex_for_%SN].release ();
  '	'
  ( get_global_var ( 'INT' ) |N ) 'FactoryManager::Singleton::instance ()->'
  if ( ( %T |S ) %!= 'FactoryMemory' ) then
  begin
   'm_mutex_for_'
   %S |N 
  end // if
  else
  begin
   'm_mutex_for_'
   [%f] to_omg %( %T |N )% 
  end // else
  '.release ();'
//	]
 end // if

//f _dump_clean_synchro_cache
; // unlock_mutex_for_cache_locker

: dump_clean_synchro_cache OBJECT IN %S
//	[{%TS!=FactoryMemory}[{%Cx=true|%SS=multi factory}{\
 if ( ( %T |S ) %!= 'FactoryMemory' ) then
 begin
  if ( ( %C |x ) %==  true OR 
    ( ( %S |S ) %== 'multi factory'  ) ) then
  begin
   #13#10

//		{
   '	{'
//			CachedObjectsIndexFor%f_to_borland(%SN)::iterator it = m_cached_objects_index_for_%SN.find (obj[{%f_is_server_type(%{INT})=true}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]);
   '		CachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% '::iterator it = m_cached_objects_index_for_'
   %S |N '.find (obj'
   if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
   begin
    '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
   end // if
   ');'
//			if (it != m_cached_objects_index_for_%SN.end ()) {
   '		if (it != m_cached_objects_index_for_'
   %S |N '.end ()) {'
//				m_cached_objects_for_%SN.erase (it-\>second);
   '			m_cached_objects_for_'
   %S |N '.erase (it->second);'
//				m_cached_objects_index_for_%SN.erase (it);
   '			m_cached_objects_index_for_'
   %S |N '.erase (it);'
//			}
   '		}'
//		}
   '	}'
//	]][{%TS=FactoryMemory&%f_exists_in_list(CACHE_LIST,"%TN")=false}%f_add_to_list(CACHE_LIST,"%TN")
  end // if
  else
  begin
//		if (m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-write")] && m_cached_object_for_%SN[.%f_cache_postfix(%S,"read-write")][{%f_is_server_type(%{INT})=true}{ == obj}-\>_is_equivalent(obj)]) \{
   '	if (m_cached_object_for_'
   %S |N if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   ' && m_cached_object_for_'
   %S |N if NOT-EMPTY
   begin
    '.'
    [%f] cache_postfix %( %S %, 'read-write' )% 
   end // if
   NOP
   if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
   begin
    '->_is_equivalent(obj)' 
   end // if
   else
   begin
    ' == obj' 
   end // else
   ') {'
//			[{%S{const_type}=combo|%S{const_type}=read-only}{m_cached_object_for_%SN = 0;}m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-write")] = 0;
   '		'
   if ( ( %S get_up ( 'const_type' ) ) %== 'combo' OR 
     ( ( %S get_up ( 'const_type' ) ) %== 'read-only'  ) ) then
   begin
    'm_cached_object_for_'
    %S |N if NOT-EMPTY
    begin
     '.'
     [%t] cache_postfix %( %S %, 'read-write' )% 
    end // if
    NOP
    ' = 0;'
//			m_cached_object_for_%SN[.%t_cache_postfix(%S,"read-only")] = 0;]
    '		m_cached_object_for_'
    %S |N if NOT-EMPTY
    begin
     '.'
     [%t] cache_postfix %( %S %, 'read-only' )% 
    end // if
    NOP
    ' = 0;' 
   end // if
   else
   begin
    'm_cached_object_for_'
    %S |N ' = 0;' 
   end // else
//		\}}
   '	}' 
  end // else
 end // if
 if ( ( %T |S ) %== 'FactoryMemory' AND 
   ( ( [%f] exists_in_list %( 'CACHE_LIST' %, %T |N )% ) %==  false  ) ) then
 begin
  [%f] add_to_list %( 'CACHE_LIST' %, %T |N )% 
//		{
  '	{'
//			%f_to_borland(%TNIndexMap)::iterator it = m_%f_to_omg(%TN)_index.find (obj[{%f_is_server_type(%{INT})=true}-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())]);
  '		'
  [%f] to_borland %( %T |N 'IndexMap' )% '::iterator it = m_'
  [%f] to_omg %( %T |N )% '_index.find (obj'
  if ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  true ) then
  begin
   '->_hash (std::numeric_limits<CORBA::ULong>::max ())' 
  end // if
  ');'
//			if (it != m_%f_to_omg(%TN)_index.end ()) {
  '		if (it != m_'
  [%f] to_omg %( %T |N )% '_index.end ()) {'
//				m_%f_to_omg(%TN).erase (it-\>second);
  '			m_'
  [%f] to_omg %( %T |N )% '.erase (it->second);'
//				m_%f_to_omg(%TN)_index.erase (it);
  '			m_'
  [%f] to_omg %( %T |N )% '_index.erase (it);'
//			}
  '		}'
//		}
  '	}'
//	]
 end // if
//f _clear_fctr_mng_cache
; // dump_clean_synchro_cache

: clear_fctr_mng_cache OBJECT IN %S
//		GUARD(m_mutex_for_%SN);
 '	GUARD(m_mutex_for_'
 %S |N ');'
//	[{%Cx=true}{\
 if ( ( %C |x ) %==  true ) then
 begin
  if ( ( %P |S ) %== 'ServerInterface' AND 
    ( ( [%f] has_cached_factory %( %P )% ) %==  true  ) ) then
  begin
   #13#10

//		CachedObjectDeactivator deactivator;
   '	CachedObjectDeactivator deactivator;'
//		
   '	'
//		CachedObjectsFor%f_to_borland(%SN)::const_iterator it = m_cached_objects_for_%SN.begin ();
   '	CachedObjectsFor'
   [%f] to_borland %( %S |N )% '::const_iterator it = m_cached_objects_for_'
   %S |N '.begin ();'
//		CachedObjectsFor%f_to_borland(%SN)::const_iterator it_end = m_cached_objects_for_%SN.end ();
   '	CachedObjectsFor'
   [%f] to_borland %( %S |N )% '::const_iterator it_end = m_cached_objects_for_'
   %S |N '.end ();'
//		
   '	'
//		for (; it != it_end; ++it) {
   '	for (; it != it_end; ++it) {'
//			deactivator (it-\>second);
   '		deactivator (it->second);'
//		}
   '	}'
//	]	m_cached_objects_for_%SN.clear ();]
  end // if
  '	m_cached_objects_for_'
  %S |N '.clear ();' 
 end // if
 else
 begin
//	[{%PS=ServerInterface&%f_has_cached_factory(%P)=true}\
  if ( ( %P |S ) %== 'ServerInterface' AND 
    ( ( [%f] has_cached_factory %( %P )% ) %==  true  ) ) then
  begin
//		CachedObjectDeactivator deactivator;
   '	CachedObjectDeactivator deactivator;'
//		deactivator (m_cached_object_for_%SN);
   '	deactivator (m_cached_object_for_'
   %S |N ');'
//	]	m_cached_object_for_%SN = 0;\
  end // if
  '	m_cached_object_for_'
  %S |N ' = 0;'
//	}[{%PS=ServerInterface&%f_has_cached_factory(%P)=true}
 end // else
//#UC END# *4705C54B01F4for47174CE200AB*
; // clear_fctr_mng_cache


// реализация абстрактного стереотипа C++ Фабрики::MDAGenerator
// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
implementation @ <<AbstractInterface>>
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for47174CE200AB*
//	%f_set_var(INT,S)[{"%f_has_self_factory_methods(%S)"="true"}%S%f_additional_fctr_mng_declarations()][{"%f_has_factory_methods(%S)"="true"}{[{<{}{%CS=FactoryMemory}{%CC}>!=0}
 [%f] set_var %( 'INT' %, 'S' )% if ( ( [%f] has_self_factory_methods %( %S )% ) %== true ) then
 begin
  %S %f additional_fctr_mng_declarations %( )% 
 end // if
 if ( ( [%f] has_factory_methods %( %S )% ) %== true ) then
 begin
  #13#10

//	[%S%f_open_ifdef()
  if NOT-EMPTY
  begin
   %S %f open_ifdef %( )% 
//	][{%f_need_const_wrapper(%S)=true}////////////////////////////////////////////////////////////////////////////////////
  end // if
  NOP
  if ( ( [%f] need_const_wrapper %( %S )% ) %==  true ) then
  begin
   '////////////////////////////////////////////////////////////////////////////////////'
//	// const wrapper for %SN
   '// const wrapper for '
   %S |N 
//	class %SNConstWrapper: 
   'class '
   %S |N 'ConstWrapper: '
//		virtual public [{%SS!=ServerInterface}{%f_dump_base_poa(%S)}%SN]
   '	virtual public '
   if ( ( %S |S ) %!= 'ServerInterface' ) then
   begin
    %S |N 
   end // if
   else
   begin
    [%f] dump_base_poa %( %S )% 
   end // else
//		, virtual public [{%SS!=ServerInterface}{::CoreSrv::RefCountServantBase}::Core::RefCountObjectBase]
   '	, virtual public '
   if ( ( %S |S ) %!= 'ServerInterface' ) then
   begin
    '::Core::RefCountObjectBase' 
   end // if
   else
   begin
    '::CoreSrv::RefCountServantBase' 
   end // else
//	{
   '{'
//	public:
   'public:'
//		%SNConstWrapper ([{%SS!=ServerInterface}{%f_full_name(%S)}%SN]* impl);
   '	'
   %S |N 'ConstWrapper ('
   if ( ( %S |S ) %!= 'ServerInterface' ) then
   begin
    %S |N 
   end // if
   else
   begin
    [%f] full_name %( %S )% 
   end // else
   '* impl);'
//	
   #13#10

//	[private:
   if NOT-EMPTY
   begin
    'private:'
//	%f_const_wrapper_operations_h(%S)
    [%f] const_wrapper_operations_h %( %S )% 
//	]private:
   end // if
   NOP
   'private:'
//		friend class %SNFactoryManager;
   '	friend class '
   %S |N 'FactoryManager;'
//		%SN_var m_impl;
   '	'
   %S |N '_var m_impl;'
//		bool is_rw;
   '	bool is_rw;'
//	};
   '};'
//	
   #13#10

//	typedef ::Core::Var\<%SNConstWrapper\> %SNConstWrapper_var;
   'typedef ::Core::Var<'
   %S |N 'ConstWrapper> '
   %S |N 'ConstWrapper_var;'
//	
   #13#10

//	]////////////////////////////////////////////////////////////////////////////////////
  end // if
  '////////////////////////////////////////////////////////////////////////////////////'
//	// factories definition for %SN
  '// factories definition for '
  %S |N 
//	
  #13#10

//	class %SNAbstractFactory;
  'class '
  %S |N 'AbstractFactory;'
//	
  #13#10

//	/// factory manager for %SN
  '/// factory manager for '
  %S |N 
//	class %SNFactoryManager%S%f_base_fctr_mng() {
  'class '
  %S |N 'FactoryManager'
  %S %f base_fctr_mng %( )% ' {'
//	public:
  'public:'
//		static void register_factory (%SNAbstractFactory* factory, Core::Root::FactoryPriority priority)
  '	static void register_factory ('
  %S |N 'AbstractFactory* factory, Core::Root::FactoryPriority priority)'
//			/*throw (Core::Root::DuplicatedFactoryKey, Core::Root::FactoryManagerWasDestroyed)*/;[{%S%f_has_multi_factory()=true}
  '		/*throw (Core::Root::DuplicatedFactoryKey, Core::Root::FactoryManagerWasDestroyed)*/;'
  if ( ( %S %f has_multi_factory %( )% ) %==  true ) then
  begin
   #13#10

//		
   '	'
//	%f_shift_intend(1)%S%f_dump_fmng_keys_method()%f_shift_intend(-1)][
   [%f] shift_intend %( 1 )% %S %f dump_fmng_keys_method %( )% [%f] shift_intend %( -1 )% 
  end // if
  if NOT-EMPTY
  begin
   #13#10

//		%S%f_additional_mgr_public_declarations()]
   '	'
   %S %f additional_mgr_public_declarations %( )% 
  end // if
  NOP

//		

//		static void unregister_all_factories () /*throw (Core::Root::FactoryManagerWasDestroyed)*/;
//	[<{}{"%CS"="remover"}{%C}
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'remover' ) then
    begin
     #13#10

//		%f_dump_factory_manager_remover_h(%C,"static")
     '	'
     [%f] dump_factory_manager_remover_h %( %C %, 'static' )% 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"}{%C}

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'remover' ) then
       begin
        #13#10

//		%f_dump_factory_manager_remover_h(%C,"static")
        '	'
        [%f] dump_factory_manager_remover_h %( %C %, 'static' )% 
//	>>]

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
//	%S%f_publish_self_h()\
  %S %f publish_self_h %( )% 
//	protected:
  'protected:'
//		%SNFactoryManager ();
  '	'
  %S |N 'FactoryManager ();'
//		
  '	'
//		~%SNFactoryManager ();
  '	~'
  %S |N 'FactoryManager ();'
//		
  '	'
//		void register_factory_i (%SNAbstractFactory* factory, Core::Root::FactoryPriority priority)
  '	void register_factory_i ('
  %S |N 'AbstractFactory* factory, Core::Root::FactoryPriority priority)'
//			/*throw (Core::Root::DuplicatedFactoryKey)*/;
  '		/*throw (Core::Root::DuplicatedFactoryKey)*/;'
//	
  #13#10


//		void unregister_all_factories_i ();

//	
//	protected:<{}{"%CS"="factory"}{%C}
  'protected:'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' ) then
   begin
    #13#10

//		%C%f_dump_factory_manager_single_factory_h()
    '	'
    %C %f dump_factory_manager_single_factory_h %( )% 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'factory' ) then
      begin
       #13#10

//		%C%f_dump_factory_manager_single_factory_h()
       '	'
       %C %f dump_factory_manager_single_factory_h %( )% 
//	>><{}{"%CS"="multi factory"}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'multi factory' ) then
   begin
    #13#10

//		%C%f_dump_factory_manager_multi_factory_h()
    '	'
    %C %f dump_factory_manager_multi_factory_h %( )% 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'multi factory' ) then
      begin
       #13#10

//		%C%f_dump_factory_manager_multi_factory_h()
       '	'
       %C %f dump_factory_manager_multi_factory_h %( )% 
//	>>[

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  if NOT-EMPTY
  begin
   #13#10

//	%S%f_additional_mgr_factory_mehods()
   %S %f additional_mgr_factory_mehods %( )% 
//	]<{}{"%CS"="remover"}{%C}
  end // if
  NOP
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'remover' ) then
   begin
    #13#10

//		%f_dump_factory_manager_remover_h(%C)
    '	'
    [%f] dump_factory_manager_remover_h %( %C )% 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'remover' ) then
      begin
       #13#10

//		%f_dump_factory_manager_remover_h(%C)
       '	'
       [%f] dump_factory_manager_remover_h %( %C )% 
//	>>

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
//		friend class %SNFactory;
  '	friend class '
  %S |N 'Factory;'
//		typedef ACE_Singleton \<%SNFactoryManager, ACE_SYNCH_RECURSIVE_MUTEX\> Singleton;
  '	typedef ACE_Singleton <'
  %S |N 'FactoryManager, ACE_SYNCH_RECURSIVE_MUTEX> Singleton;'
//		friend class ACE_Singleton \<%SNFactoryManager, ACE_SYNCH_RECURSIVE_MUTEX\>;
  '	friend class ACE_Singleton <'
  %S |N 'FactoryManager, ACE_SYNCH_RECURSIVE_MUTEX>;'
//	
  #13#10

//	private:
  'private:'
//	[{%f_need_const_wrapper(%S)=true}
  if ( ( [%f] need_const_wrapper %( %S )% ) %==  true ) then
  begin
   #13#10

//		struct ComboDataVar {
   '	struct ComboDataVar {'
//			ComboDataVar ();
   '		ComboDataVar ();'
//			ComboDataVar (%SN* rw_data_);
   '		ComboDataVar ('
   %S |N '* rw_data_);'
//			%SN_var rw_data;
   '		'
   %S |N '_var rw_data;'
//			[{%SS!=ServerInterface}{%SN_var}Core::Var\<%SNConstWrapper\>] ro_data;
   '		'
   if ( ( %S |S ) %!= 'ServerInterface' ) then
   begin
    'Core::Var<'
    %S |N 'ConstWrapper>' 
   end // if
   else
   begin
    %S |N '_var' 
   end // else
   ' ro_data;'
//			bool is_ro_first;
   '		bool is_ro_first;'
//		};
   '	};'
//	[{<{}{%f_is_factory(%C)=true&%Cs=synchro}{%CC}>!=0}
   if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( [%f] is_factory %( %C )% ) %==  true AND 
      ( ( %C |s ) %== 'synchro'  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %!= 0 ) then
   begin
    #13#10

//		struct ComboDataPtr {
    '	struct ComboDataPtr {'
//			ComboDataPtr ();
    '		ComboDataPtr ();'
//			ComboDataPtr (%SN* rw_data_);
    '		ComboDataPtr ('
    %S |N '* rw_data_);'
//			%SN* rw_data;
    '		'
    %S |N '* rw_data;'
//			[{%SS!=ServerInterface}{%SN*}%SNConstWrapper*] ro_data;
    '		'
    if ( ( %S |S ) %!= 'ServerInterface' ) then
    begin
     %S |N 'ConstWrapper*' 
    end // if
    else
    begin
     %S |N '*' 
    end // else
    ' ro_data;'
//			bool is_ro_first;
    '		bool is_ro_first;'
//		};
    '	};'
//	]
   end // if
//	]	static bool s_was_destroyed;
  end // if
  '	static bool s_was_destroyed;'
//		
  '	'
//		bool m_has_registred_factories;
  '	bool m_has_registred_factories;'
//		
  '	'
//		struct FactoryData {
  '	struct FactoryData {'
//			Core::Var\<%SNAbstractFactory\> factory;
  '		Core::Var<'
  %S |N 'AbstractFactory> factory;'
//			short priority;
  '		short priority;'
//		};
  '	};'
//		
  '	'
//		%f_set_var(SW_TN,"%S%f_dump_switch_type_name()")typedef std::map \<[{"%{SW_TN}N"!=""&"%{SW_TN}N"!="string"}{std::string}%S%f_dump_switch_type()], FactoryData\> FactoryMap;
  '	'
  [%f] set_var %( 'SW_TN' %, %S %f dump_switch_type_name %( )% )% 'typedef std::map <'
  if ( ( ( get_global_var ( 'SW_TN' ) |N ) ) %!= '' AND 
    ( ( ( get_global_var ( 'SW_TN' ) |N ) ) %!= 'string'  ) ) then
  begin
   %S %f dump_switch_type %( )% 
  end // if
  else
  begin
   'std::string' 
  end // else
  ', FactoryData> FactoryMap;'
//		
  '	'
//		FactoryMap m_factories_map;
  '	FactoryMap m_factories_map;'
//		
  '	'
//		Core::Var\<%SNAbstractFactory\> m_single_active_factory;
  '	Core::Var<'
  %S |N 'AbstractFactory> m_single_active_factory;'
//		
  '	'
//		short m_single_active_factory_priority;
  '	short m_single_active_factory_priority;'
//	[{%f_has_synchro_factory(%S)=true}
  if ( ( [%f] has_synchro_factory %( %S )% ) %==  true ) then
  begin
   #13#10

//	public:
   'public:'
//		class CacheLocker {
   '	class CacheLocker {'
//		public:
   '	public:'
//			CacheLocker ();
   '		CacheLocker ();'
//			
   '		'
//			~CacheLocker ();
   '		~CacheLocker ();'
//		};
   '	};'
//		
   '	'
//		static void clean (%t_arg_cpp(%S,"in") obj);
   '	static void clean ('
   [%t] arg_cpp %( %S %, 'in' )% ' obj);'
//	
   #13#10

//	protected:
   'protected:'
//		void clean_i (%t_arg_cpp(%S,"in") obj);
   '	void clean_i ('
   [%t] arg_cpp %( %S %, 'in' )% ' obj);'
//	]\
  end // if

//	[{%SS=ServerInterface&%f_has_cached_factory(%S)=true}

//	public:

//		struct CachedObjectDeactivator {

//			void operator () (const %SN_var& obj);[{%f_need_const_wrapper(%S)=true}

//			void operator () (const ComboDataVar& obj);[{%f_is_factory(%C)=true&%Cs=synchro}{%CC}>!=0}

//			void operator () (const ComboDataPtr& obj);

//			]]

//		};

//	]\
//	<{}{"%CS"="factory"&"%f_is_it_cached(%C)"="true"&%C%TS!=FactoryMemory}{%C}
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' AND 
    ( ( [%f] is_it_cached %( %C )% ) %== true  ) AND 
    ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
   begin
    #13#10

//	%f_fctr_mng_fctr_h(%C)
    [%f] fctr_mng_fctr_h %( %C )% 
//	><{}{"%CS"="multi factory"&"%f_is_it_cached(%C)"="true"&%C%TS!=FactoryMemory}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'multi factory' AND 
    ( ( [%f] is_it_cached %( %C )% ) %== true  ) AND 
    ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
   begin
    #13#10

//	%f_fctr_mng_m_fctr_h(%C)
    [%f] fctr_mng_m_fctr_h %( %C )% 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%f_is_it_cached(%C)"="true"&%C%TS!=FactoryMemory}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'factory' AND 
       ( ( [%f] is_it_cached %( %C )% ) %== true  ) AND 
       ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
      begin
       #13#10

//	%f_fctr_mng_fctr_h(%C)
       [%f] fctr_mng_fctr_h %( %C )% 
//	>%g<{}{"%CS"="multi factory"&"%f_is_it_cached(%C)"="true"&%C%TS!=FactoryMemory}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
     %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'multi factory' AND 
       ( ( [%f] is_it_cached %( %C )% ) %== true  ) AND 
       ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
      begin
       #13#10

//	%f_fctr_mng_m_fctr_h(%C)
       [%f] fctr_mng_m_fctr_h %( %C )% 
//	>><{}{%ga=abstract}%g<{}{%CS=FactoryMemory}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'FactoryMemory' ) then
      begin
       #13#10

//	%f_dump_common_mem_cache(%C)
       [%f] dump_common_mem_cache %( %C )% 
//	>><{}{%CS=FactoryMemory}%CX>};

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'FactoryMemory' ) then
   begin
    %C |X 
    ++! l_Counter
   end // if
  end // for C
  '};'
//	
  #13#10

//	/// abstract factory for %SN
  '/// abstract factory for '
  %S |N 
//	%f_set_var(DERIVED,"0")\
  [%f] set_var %( 'DERIVED' %, 0 )% 
//	class %SNAbstractFactory : virtual public Core::IObject[{%SS=LocalInterface}[<{}{%f_has_factory_methods(%R)=true}, virtual public %f_type(%R)AbstractFactory%f_set_var(DERIVED,"1")>\
  'class '
  %S |N 'AbstractFactory : virtual public Core::IObject'
  if ( ( %S |S ) %== 'LocalInterface' ) then
  begin
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%R
    begin
     OBJECT IN %R
     if ( ( [%f] has_factory_methods %( %R )% ) %==  true ) then
     begin
      ', virtual public '
      [%f] type %( %R )% 'AbstractFactory'
      [%f] set_var %( 'DERIVED' %, 1 )% 
      ++! l_Counter
     end // if
    end // for R
//	<{}{%ga=abstract}%g<{	, }{%f_has_factory_methods(%R)=true}, virtual public %f_type(%R)AbstractFactory%f_set_var(DERIVED,"1")>>]] {
    INTEGER VAR l_Counter l_Counter := 0
    for %S%g
    begin
     OBJECT IN %g
     if ( ( %g |a ) %== 'abstract' ) then
     begin
      %g
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%R
       begin
        OBJECT IN %R
        if ( ( [%f] has_factory_methods %( %R )% ) %==  true ) then
        begin
         if ( l_Counter >0 ) then ( '	, ' )
         ', virtual public '
         [%f] type %( %R )% 'AbstractFactory'
         [%f] set_var %( 'DERIVED' %, 1 )% 
         ++! l_Counter
        end // if
       end // for R

      ) // bind
 
      ++! l_Counter
     end // if
    end // for g
   end // if
   NOP
  end // if
  ' {'
//		friend class %SNFactoryManager;
  '	friend class '
  %S |N 'FactoryManager;'
//	protected:
  'protected:'
//	[{%{DERIVED}N=0}	virtual const [{}{char*}%S%f_dump_switch_type()] key () const = 0;
  if ( ( ( get_global_var ( 'DERIVED' ) |N ) ) %== 0 ) then
  begin
   '	virtual const '
   if NOT-EMPTY
   begin
    %S %f dump_switch_type %( )% 
   end // if
   NOP
   else
   begin
    'char*' 
   end // else
   ' key () const = 0;'
//	]%f_dump_factories_impl_h(%S)[
  end // if
  [%f] dump_factories_impl_h %( %S )% if NOT-EMPTY
  begin
   #13#10

//	%S%f_additional_abstract_factories()
   %S %f additional_abstract_factories %( )% 
//	]};[
  end // if
  NOP
  '};'
  if NOT-EMPTY
  begin
   #13#10

//	%S%f_close_ifdef()]]
   %S %f close_ifdef %( )% 
  end // if
  NOP
 end // if
 else
 begin
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'FactoryMemory' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
   #13#10

//	class %SNFactoryManager%S%f_base_fctr_mng() \{
   'class '
   %S |N 'FactoryManager'
   %S %f base_fctr_mng %( )% ' {'
//	<{}{%CS=FactoryMemory}%CX>\};]}
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'FactoryMemory' ) then
    begin
     %C |X 
     ++! l_Counter
    end // if
   end // for C
   '};' 
  end // if
 end // else

//f _dump_factories_impl_h
; // fctr.h

end. // <<AbstractInterface>>

: dump_factories_impl_h OBJECT IN %S
//	<{}{"%f_is_factory(%C)"="true"}{%C}
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %== true ) then
  begin
   #13#10

//		%f_dump_abstract_factory_h(%C)
   '	'
   [%f] dump_abstract_factory_h %( %C )% 
//	>%f_set_var(SELF,S)<{}{"%ga"="abstract"}%g<{}{"%f_is_factory(%C)"="true"}{%C}

   ++! l_Counter
  end // if
 end // for C
 [%f] set_var %( 'SELF' %, 'S' )% 
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if ( ( %g |a ) %== 'abstract' ) then
  begin
   %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( [%f] is_factory %( %C )% ) %== true ) then
     begin
      #13#10

//		%f_dump_abstract_factory_h(%C)
      '	'
      [%f] dump_abstract_factory_h %( %C )% 
//	>>

      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for g

//f _dump_inherited_factories_h
; // dump_factories_impl_h

: dump_inherited_factories_h OBJECT IN %S
//	[<{}{%f_is_interface(%R)=true}%f_dump_factories_impl_h(%R)>]
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( [%f] is_interface %( %R )% ) %==  true ) then
   begin
    [%f] dump_factories_impl_h %( %R )% 
    ++! l_Counter
   end // if
  end // for R
 end // if
 NOP
//f _has_synchro_factory
; // dump_inherited_factories_h

: has_synchro_factory OBJECT IN %S
//	[{%f_has_synchro_factory_self(%S)=true|<{}{%ga=abstract&%f_has_synchro_factory_self(%g)=true}{%gC}>!=0}{false}true]
 if ( ( [%f] has_synchro_factory_self %( %S )% ) %==  true OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' AND 
    ( ( [%f] has_synchro_factory_self %( %g )% ) %==  true  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for g
  l_Counter
  %!= 0  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else

//f _has_synchro_factory_self
; // has_synchro_factory

: has_synchro_factory_self OBJECT IN %S
//	[{<{}{%f_is_factory(%C)&%Cs=synchro}{%CC}>!=0}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) AND 
    ( ( %C |s ) %== 'synchro'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4705C5490109for47174CE200AB*
; // has_synchro_factory_self


// реализация абстрактного стереотипа Java::MDAGenerator
// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
implementation @ <<AbstractInterface>>
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor47174CE200AB*
//O [{%f_has_factory_methods(%S)=true|<{}{%CS=FactoryMemory}{%CC}>!=0}%SNFactoryManager.java]
//	%f_output_constraint(%S)\
 [%f] output_constraint %( %S )% 
//	%f_set_var(INT,S)[{%f_has_factory_methods(%S)=true}{[{<{}{%CS=FactoryMemory}{%CC}>!=0}%f_header(%S)
 [%f] set_var %( 'INT' %, 'S' )% if ( ( [%f] has_factory_methods %( %S )% ) %==  true ) then
 begin
  [%f] header %( %S )% 
//	package %f_dump_java_package(%S);
  'package '
  [%f] dump_java_package %( %S )% ';'
//	
  #13#10

//	%f_dump_std_java_imports(%S)
  [%f] dump_std_java_imports %( %S )% 
//	
  #13#10

//	%f_java_core_exceptions(%S)
  [%f] java_core_exceptions %( %S )% 
//	[<{}{%ga=abstract}%g<{}{%CS=FactoryMemory}[import %f_type(%C%P)FactoryManager.%C%f_factory_mem_key_name();
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'FactoryMemory' ) then
       begin
        if NOT-EMPTY
        begin
         'import '
         [%f] type %( %C ->P  )% 'FactoryManager.'
         %C %f factory_mem_key_name %( )% ';'
//	import %f_type(%C%P)FactoryManager.%C%f_factory_mem_key_name()Comparator;
         'import '
         [%f] type %( %C ->P  )% 'FactoryManager.'
         %C %f factory_mem_key_name %( )% 'Comparator;'
//	]>>]
        end // if
        NOP

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
//	import %f_dump_java_package(%P).%P%P%f_name_prefix()LibHomeFactory;
  'import '
  [%f] dump_java_package %( %P )% '.'
  %P ->P %f name_prefix %( )%  'LibHomeFactory;'
//	
  #13#10

//	[{%f_need_const_wrapper(%S)=true}////////////////////////////////////////////////////////////////////////////////////
  if ( ( [%f] need_const_wrapper %( %S )% ) %==  true ) then
  begin
   '////////////////////////////////////////////////////////////////////////////////////'
//	// const wrapper for %SN
   '// const wrapper for '
   %S |N 
//	class %SNConstWrapper[{%SS!=ServerInterface}{ extends %SNPOA} implements %SN%f_interface_postfix(%S)] {
   'class '
   %S |N 'ConstWrapper'
   if ( ( %S |S ) %!= 'ServerInterface' ) then
   begin
    ' implements '
    %S |N [%f] interface_postfix %( %S )% 
   end // if
   else
   begin
    ' extends '
    %S |N 'POA' 
   end // else
   ' {'
//		%SNConstWrapper (%SN impl) {
   '	'
   %S |N 'ConstWrapper ('
   %S |N ' impl) {'
//			impl_ = [{%f_need_private_def(%S)=true&%SS!=ServerInterface}(%SN%f_interface_postfix(%S))]impl;
   '		impl_ = '
   if ( ( [%f] need_private_def %( %S )% ) %==  true AND 
     ( ( %S |S ) %!= 'ServerInterface'  ) ) then
   begin
    '('
    %S |N [%f] interface_postfix %( %S )% ')' 
   end // if
   'impl;'
//		}
   '	}'
//		
   '	'
//		public int hashCode () {
   '	public int hashCode () {'
//			return impl_.hashCode ();
   '		return impl_.hashCode ();'
//		}
   '	}'
//	[%f_const_wrapper_operations_java(%S)
   if NOT-EMPTY
   begin
    [%f] const_wrapper_operations_java %( %S )% 
//	]	private %SN[{%SS!=ServerInterface}%f_interface_postfix(%S)] impl_;
   end // if
   NOP
   '	private '
   %S |N if ( ( %S |S ) %!= 'ServerInterface' ) then
   begin
    [%f] interface_postfix %( %S )% 
   end // if
   ' impl_;'
//		private boolean isRw_ = false;
   '	private boolean isRw_ = false;'
//	};
   '};'
//	
   #13#10

//	]////////////////////////////////////////////////////////////////////////////////////
  end // if
  '////////////////////////////////////////////////////////////////////////////////////'
//	/// factory manager for %SN
  '/// factory manager for '
  %S |N 
//	public class %SNFactoryManager%S%f_base_fctr_mng_java() {
  'public class '
  %S |N 'FactoryManager'
  %S %f base_fctr_mng_java %( )% ' {'
//	<{}{"%CS"="factory"&"%f_is_it_cached(%C)"="true"&%C%TS!=FactoryMemory}{%C}
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' AND 
    ( ( [%f] is_it_cached %( %C )% ) %== true  ) AND 
    ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
   begin
    #13#10

//	%f_fctr_mng_fctr_java(%C)
    [%f] fctr_mng_fctr_java %( %C )% 
//	><{}{"%CS"="multi factory"&"%f_is_it_cached(%C)"="true"&%C%TS!=FactoryMemory}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'multi factory' AND 
    ( ( [%f] is_it_cached %( %C )% ) %== true  ) AND 
    ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
   begin
    #13#10

//	%f_fctr_mng_m_fctr_java(%C)
    [%f] fctr_mng_m_fctr_java %( %C )% 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%f_is_it_cached(%C)"="true"&%C%TS!=FactoryMemory}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'factory' AND 
       ( ( [%f] is_it_cached %( %C )% ) %== true  ) AND 
       ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
      begin
       #13#10

//	%f_fctr_mng_fctr_java(%C)
       [%f] fctr_mng_fctr_java %( %C )% 
//	>%g<{}{"%CS"="multi factory"&"%f_is_it_cached(%C)"="true"&%C%TS!=FactoryMemory}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
     %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'multi factory' AND 
       ( ( [%f] is_it_cached %( %C )% ) %== true  ) AND 
       ( ( %C ->T |S  ) %!= 'FactoryMemory'  ) ) then
      begin
       #13#10

//	%f_fctr_mng_m_fctr_java(%C)
       [%f] fctr_mng_m_fctr_java %( %C )% 
//	>>[{%f_need_const_wrapper(%S)=true}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  if ( ( [%f] need_const_wrapper %( %S )% ) %==  true ) then
  begin
   #13#10

//		public static class ComboDataVar {
   '	public static class ComboDataVar {'

//			ComboDataVar () {

//			}

//			
//			ComboDataVar (%SN rwData) {
   '		ComboDataVar ('
   %S |N ' rwData) {'
//				rwData_ = rwData;
   '			rwData_ = rwData;'
//			}
   '		}'
//			
   '		'
//			%SN rwData_ = null;
   '		'
   %S |N ' rwData_ = null;'
//			[{%SS!=ServerInterface}{%SN}%SNConstWrapper] roData_ = null;
   '		'
   if ( ( %S |S ) %!= 'ServerInterface' ) then
   begin
    %S |N 'ConstWrapper' 
   end // if
   else
   begin
    %S |N 
   end // else
   ' roData_ = null;'
//			boolean isRoFirst = false;
   '		boolean isRoFirst = false;'
//		};
   '	};'
//	[{<{}{%f_is_factory(%C)=true&%Cs=synchro}{%CC}>!=0}
   if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( [%f] is_factory %( %C )% ) %==  true AND 
      ( ( %C |s ) %== 'synchro'  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %!= 0 ) then
   begin
    #13#10

//		public static class ComboDataPtr {
    '	public static class ComboDataPtr {'

//			ComboDataPtr () {

//			}

//			
//			ComboDataPtr (java.lang.ref.WeakReference\<%SN\> rwData) {
    '		ComboDataPtr (java.lang.ref.WeakReference<'
    %S |N '> rwData) {'
//				rwData_ = rwData;
    '			rwData_ = rwData;'
//			}
    '		}'
//			
    '		'
//			java.lang.ref.WeakReference\<%SN\> rwData_ = null;
    '		java.lang.ref.WeakReference<'
    %S |N '> rwData_ = null;'
//			java.lang.ref.WeakReference\<[{%SS!=ServerInterface}{%SN}%SNConstWrapper]\> roData_ = null;
    '		java.lang.ref.WeakReference<'
    if ( ( %S |S ) %!= 'ServerInterface' ) then
    begin
     %S |N 'ConstWrapper' 
    end // if
    else
    begin
     %S |N 
    end // else
    '> roData_ = null;'
//			boolean isRoFirst = false;
    '		boolean isRoFirst = false;'
//		};
    '	};'
//	]
   end // if
//	]
  end // if
//		// abstract factory for %SN
  '	// abstract factory for '
  %S |N 
//	%f_set_var(DERIVED,"0")\
  [%f] set_var %( 'DERIVED' %, 0 )% 
//		public interface %SNAbstractFactory[{%SS=LocalInterface}{ }[{}{ }
  '	public interface '
  %S |N 'AbstractFactory'
  if ( ( %S |S ) %== 'LocalInterface' ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//			extends %f_set_var(COMMA,"0")<{	, }{%f_has_factory_methods(%R)=true}%f_set_var(COMMA,"1")%f_type(%R)FactoryManager.%RNAbstractFactory%f_set_var(DERIVED,"1")
    '		extends '
    [%f] set_var %( 'COMMA' %, 0 )% 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%R
    begin
     OBJECT IN %R
     if ( ( [%f] has_factory_methods %( %R )% ) %==  true ) then
     begin
      if ( l_Counter >0 ) then ( '	, ' )
      [%f] set_var %( 'COMMA' %, 1 )% [%f] type %( %R )% 'FactoryManager.'
      %R |N 'AbstractFactory'
      [%f] set_var %( 'DERIVED' %, 1 )% 
//		><{}{%ga=abstract}%g<{	, }{%f_has_factory_methods(%R)=true}[{%{COMMA}N=1}, %f_set_var(COMMA,"0")]%f_type(%R)FactoryManager.%RNAbstractFactory%f_set_var(DERIVED,"1")
      '	' 
      ++! l_Counter
     end // if
    end // for R
    INTEGER VAR l_Counter l_Counter := 0
    for %S%g
    begin
     OBJECT IN %g
     if ( ( %g |a ) %== 'abstract' ) then
     begin
      %g
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%R
       begin
        OBJECT IN %R
        if ( ( [%f] has_factory_methods %( %R )% ) %==  true ) then
        begin
         if ( l_Counter >0 ) then ( '	, ' )
         if ( ( ( get_global_var ( 'COMMA' ) |N ) ) %== 1 ) then
         begin
          ', '
          [%f] set_var %( 'COMMA' %, 0 )% 
         end // if
         [%f] type %( %R )% 'FactoryManager.'
         %R |N 'AbstractFactory'
         [%f] set_var %( 'DERIVED' %, 1 )% 
//		>>]]{
         '	' 
         ++! l_Counter
        end // if
       end // for R

      ) // bind
 
      ++! l_Counter
     end // if
    end // for g
   end // if
   NOP
   else
   begin
    ' ' 
   end // else
  end // if
  else
  begin
   ' ' 
  end // else
  '{'
//	[{%{DERIVED}N=0}		public [{}{String}%S%f_dump_switch_type()] key ();
  if ( ( ( get_global_var ( 'DERIVED' ) |N ) ) %== 0 ) then
  begin
   '		public '
   if NOT-EMPTY
   begin
    %S %f dump_switch_type %( )% 
   end // if
   NOP
   else
   begin
    'String' 
   end // else
   ' key ();'
//	]<{}{"%f_is_factory(%C)"="true"|%C#f_is_factory()=true}{%C}
  end // if
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %== true OR 
    ( ( %C %?f is_factory %( )% ) %==  true  ) ) then
   begin
    #13#10

//	[{%CS!=remover}%C%f_abstract_factory_operation()
    if ( ( %C |S ) %!= 'remover' ) then
    begin
     %C %f abstract_factory_operation %( )% 
//	]>%f_set_var(SELF,S)<{}{"%ga"="abstract"}%g<{}{"%f_is_factory(%C)"="true"|%C#f_is_factory()=true}{%C}
    end // if

    ++! l_Counter
   end // if
  end // for C
  [%f] set_var %( 'SELF' %, 'S' )% 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( [%f] is_factory %( %C )% ) %== true OR 
       ( ( %C %?f is_factory %( )% ) %==  true  ) ) then
      begin
       #13#10

//	[{%CS!=remover}%C%f_abstract_factory_operation()
       if ( ( %C |S ) %!= 'remover' ) then
       begin
        %C %f abstract_factory_operation %( )% 
//	]>>	} //%SNAbstractFactory
       end // if

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  '	} //'
  %S |N 'AbstractFactory'
//		
  '	'
//		private static class FactoryData {
  '	private static class FactoryData {'
//			public FactoryData (%SNAbstractFactory factory, short priority) {
  '		public FactoryData ('
  %S |N 'AbstractFactory factory, short priority) {'
//				factory_ = factory;
  '			factory_ = factory;'
//				priority_ = priority;
  '			priority_ = priority;'
//			}
  '		}'
//			
  '		'
//			public %SNAbstractFactory factory_;
  '		public '
  %S |N 'AbstractFactory factory_;'
//			public short priority_;
  '		public short priority_;'
//		}
  '	}'
//		private java.util.Map\<[{}{String}%S%f_dump_switch_type()], FactoryData\> factoriesMap_ = new java.util.TreeMap\<[{}{String}%S%f_dump_switch_type()], FactoryData\> ();
  '	private java.util.Map<'
  if NOT-EMPTY
  begin
   %S %f dump_switch_type %( )% 
  end // if
  NOP
  else
  begin
   'String' 
  end // else
  ', FactoryData> factoriesMap_ = new java.util.TreeMap<'
  if NOT-EMPTY
  begin
   %S %f dump_switch_type %( )% 
  end // if
  NOP
  else
  begin
   'String' 
  end // else
  ', FactoryData> ();'
//		private %SNAbstractFactory singleActiveFactory_ = null;
  '	private '
  %S |N 'AbstractFactory singleActiveFactory_ = null;'
//		private short singleActiveFactoryPriority_ = 0;
  '	private short singleActiveFactoryPriority_ = 0;'
//		private static %SNFactoryManager sInstance_ = null;
  '	private static '
  %S |N 'FactoryManager sInstance_ = null;'
//		private boolean hasRegistredFactories_ = false;
  '	private boolean hasRegistredFactories_ = false;'
//	
  #13#10

//		public static %SNFactoryManager %S%f_fctr_mng_get_instance_name() () {
  '	public static '
  %S |N 'FactoryManager '
  %S %f fctr_mng_get_instance_name %( )% ' () {'
//			if (sInstance_ == null) {
  '		if (sInstance_ == null) {'
//				sInstance_ = new %SNFactoryManager ();
  '			sInstance_ = new '
  %S |N 'FactoryManager ();'
//			}
  '		}'
//			return sInstance_;
  '		return sInstance_;'
//		}
  '	}'
//	
  #13#10

//		public static void registerFactory (%SNAbstractFactory factory, short priority) throws DuplicatedFactoryKey {
  '	public static void registerFactory ('
  %S |N 'AbstractFactory factory, short priority) throws DuplicatedFactoryKey {'
//			%SNFactoryManager.%{INT}%f_fctr_mng_get_instance_name()().registerFactoryImpl (factory, priority);[{%SS=LocalInterface}
  '		'
  %S |N 'FactoryManager.'
  ( get_global_var ( 'INT' ) %f fctr_mng_get_instance_name %( )% ) '().registerFactoryImpl (factory, priority);'
  if ( ( %S |S ) %== 'LocalInterface' ) then
  begin
   #13#10

//			<{}{%f_is_interface(%R)=true&%f_has_factory_methods(%R)=true}%f_type(%R)FactoryManager.registerFactory (factory, priority);
   '		'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%R
   begin
    OBJECT IN %R
    if ( ( [%f] is_interface %( %R )% ) %==  true AND 
     ( ( [%f] has_factory_methods %( %R )% ) %==  true  ) ) then
    begin
     [%f] type %( %R )% 'FactoryManager.registerFactory (factory, priority);'
//			><{}{%ga=abstract}%g<{}{%f_is_interface(%R)=true&%f_has_factory_methods(%R)=true}%f_type(%R)FactoryManager.registerFactory (factory, priority);
     '		' 
     ++! l_Counter
    end // if
   end // for R
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%R
      begin
       OBJECT IN %R
       if ( ( [%f] is_interface %( %R )% ) %==  true AND 
        ( ( [%f] has_factory_methods %( %R )% ) %==  true  ) ) then
       begin
        [%f] type %( %R )% 'FactoryManager.registerFactory (factory, priority);'
//			>>]
        '		' 
        ++! l_Counter
       end // if
      end // for R

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
//		}[{%S%f_has_multi_factory()=true}
  '	}'
  if ( ( %S %f has_multi_factory %( )% ) %==  true ) then
  begin
   #13#10

//		
   '	'
//	%f_shift_intend(1)%S%f_dump_fmng_keys_method()%f_shift_intend(-1)]
   [%f] shift_intend %( 1 )% %S %f dump_fmng_keys_method %( )% [%f] shift_intend %( -1 )% 
  end // if
//	
  #13#10

//	[<{}{%CC=Operation&%CS=remover}{%C}
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |C ) %== 'Operation' AND 
     ( ( %C |S ) %== 'remover'  ) ) then
    begin
     #13#10

//	%f_fctr_mng_remover_java(%C)
     [%f] fctr_mng_remover_java %( %C )% 
//	><{}{"%ga"="abstract"}%g<{}{%CC=Operation&%CS=remover}{%C}

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |C ) %== 'Operation' AND 
        ( ( %C |S ) %== 'remover'  ) ) then
       begin
        #13#10

//	%f_fctr_mng_remover_java(%C)
        [%f] fctr_mng_remover_java %( %C )% 
//	>>

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
//	]%S%f_publish_self_java()
  end // if
  NOP
  %S %f publish_self_java %( )% 
//		protected void registerFactoryImpl (%SNAbstractFactory factory, short priority) throws DuplicatedFactoryKey {
  '	protected void registerFactoryImpl ('
  %S |N 'AbstractFactory factory, short priority) throws DuplicatedFactoryKey {'
//			hasRegistredFactories_ = true;
  '		hasRegistredFactories_ = true;'
//			FactoryData factoryData = factoriesMap_.get(factory.key());
  '		FactoryData factoryData = factoriesMap_.get(factory.key());'
//			if (factoryData != null && factoryData.priority_ == priority) {
  '		if (factoryData != null && factoryData.priority_ == priority) {'
//				throw new DuplicatedFactoryKey ("%{INT}%P%PN.%PN.%SNFactory ", factory.key().toString ());
  '			throw new DuplicatedFactoryKey ("'
  ( get_global_var ( 'INT' )  ->P ->P |N  ) '.'
  %P |N '.'
  %S |N 'Factory ", factory.key().toString ());'
//			}
  '		}'
//			if (factoryData == null || factoryData.priority_ \<= priority) {
  '		if (factoryData == null || factoryData.priority_ <= priority) {'
//				factoriesMap_.put(factory.key(), new FactoryData (factory, priority));
  '			factoriesMap_.put(factory.key(), new FactoryData (factory, priority));'
//			}
  '		}'
//			if (singleActiveFactory_ == null || singleActiveFactoryPriority_ \<= priority) {
  '		if (singleActiveFactory_ == null || singleActiveFactoryPriority_ <= priority) {'
//				singleActiveFactory_ = factory;
  '			singleActiveFactory_ = factory;'
//				singleActiveFactoryPriority_ = priority;
  '			singleActiveFactoryPriority_ = priority;'
//			}
  '		}'
//		}
  '	}'
//	
  #13#10

//		private %SNFactoryManager () {
  '	private '
  %S |N 'FactoryManager () {'
//		}
  '	}'
//	[
  if NOT-EMPTY
  begin
   #13#10

//	<{}{%CS=FactoryMemory}%CX>
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'FactoryMemory' ) then
    begin
     %C |X 
     ++! l_Counter
    end // if
   end // for C
//	]%f_fctr_mng_factory_call_tpl(%S,"factory","\%C\%f_fctr_mng_factory_java()")\
  end // if
  NOP
  [%f] fctr_mng_factory_call_tpl %( %S %, 'factory"' %, '%C%f_fctr_mng_factory_java()' )% 
//	%f_fctr_mng_factory_call_tpl(%S,"multi factory","\%C\%f_fctr_mng_factory_java()")\
  [%f] fctr_mng_factory_call_tpl %( %S %, 'multi factory"' %, '%C%f_fctr_mng_factory_java()' )% 
//	%f_fctr_mng_factory_call_tpl(%S,"remover","\%f_dump_factory_manager_remover_java(\%C)")\
  [%f] fctr_mng_factory_call_tpl %( %S %, 'remover"' %, '%f_dump_factory_manager_remover_java(%C)' )% 
//	%f_fctr_mng_factory_call_tpl(%S,"finder","\%C\%f_fctr_mng_factory_java()")\
  [%f] fctr_mng_factory_call_tpl %( %S %, 'finder"' %, '%C%f_fctr_mng_factory_java()' )% 
//	<{}{%ga=abstract}%g<{}{%CS=FactoryMemory}
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'FactoryMemory' ) then
      begin
       #13#10

//	%f_dump_common_mem_cache_java(%C)
       [%f] dump_common_mem_cache_java %( %C )% 
//	>>

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
//	}
  '}'
//	%f_footer(%S)
  [%f] footer %( %S )% 
//	]
 end // if
 else
 begin
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'FactoryMemory' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
   [%f] header %( %S )% 
//	package %f_dump_java_package(%S);
   'package '
   [%f] dump_java_package %( %S )% ';'
//	
   #13#10

//	%f_dump_std_java_imports(%S)
   [%f] dump_std_java_imports %( %S )% 
//	%f_java_core_exceptions(%S)
   [%f] java_core_exceptions %( %S )% 
//	import %f_dump_java_package(%P).%P%P%f_name_prefix()LibHomeFactory;
   'import '
   [%f] dump_java_package %( %P )% '.'
   %P ->P %f name_prefix %( )%  'LibHomeFactory;'
//	
   #13#10

//	public class %SNFactoryManager%S%f_base_fctr_mng_java() \{
   'public class '
   %S |N 'FactoryManager'
   %S %f base_fctr_mng_java %( )% ' {'
//	<{}{%CS=FactoryMemory}%CX>\};]}%f_header(%S)
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'FactoryMemory' ) then
    begin
     %C |X 
     ++! l_Counter
    end // if
   end // for C
   '};' 
  end // if
 end // else

//f _fctr_mng_factory_call_tpl
; // fctr.java

end. // <<AbstractInterface>>

: fctr_mng_factory_call_tpl OBJECT IN %S
//	<{}{"%CS"="%1N"}{%C}
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== ( %1 |N ) ) then
  begin
   #13#10

//	%f_exec(%2N)
   [%f] exec %( %2 |N )% 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="%2N"}{%C}

   ++! l_Counter
  end // if
 end // for C
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if ( ( %g |a ) %== 'abstract' ) then
  begin
   %g
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %== ( %2 |N ) ) then
     begin
      #13#10

//	%f_exec(%3N)
      [%f] exec %( %3 |N )% 
//	>>

      ++! l_Counter
     end // if
    end // for C

   ) // bind
 
   ++! l_Counter
  end // if
 end // for g

//%f _dump_fmng_keys_method
; // fctr_mng_factory_call_tpl

implementation @ <<AbstractInterface>>
: dump_fmng_keys_method OBJECT IN %S
//	[{%XU=fctr.java}#public static java.util.Set\<%S%f_dump_switch_type()\> keys () {
 if ( ( %X |U ) %== 'fctr.java' ) then
 begin
  out_indent 'public static java.util.Set<'
  %S %f dump_switch_type %( )% '> keys () {'
//	#	return %SNFactoryManager.%S%f_fctr_mng_get_instance_name()().factoriesMap_.keySet ();
  out_indent '	return '
  %S |N 'FactoryManager.'
  %S %f fctr_mng_get_instance_name %( )% '().factoriesMap_.keySet ();'
//	#}][{%XU=fctr.h}#static %SNFactory::KeySet* keys ();][{%XU=fctr.cpp}\
  out_indent '}' 
 end // if
 if ( ( %X |U ) %== 'fctr.h' ) then
 begin
  out_indent 'static '
  %S |N 'Factory::KeySet* keys ();' 
 end // if
 if ( ( %X |U ) %== 'fctr.cpp' ) then
 begin
//	%SNFactory::KeySet* %SNFactoryManager::keys () {
  %S |N 'Factory::KeySet* '
  %S |N 'FactoryManager::keys () {'
//		Core::Aptr\<%SNFactory::KeySet\> keys (new %SNFactory::KeySet (Singleton::instance()-\>m_factories_map.size ()));
  '	Core::Aptr<'
  %S |N 'Factory::KeySet> keys (new '
  %S |N 'Factory::KeySet (Singleton::instance()->m_factories_map.size ()));'
//		
  '	'
//		std::transform (
  '	std::transform ('
//			Singleton::instance()-\>m_factories_map.begin ()
  '		Singleton::instance()->m_factories_map.begin ()'
//			, Singleton::instance()-\>m_factories_map.end ()
  '		, Singleton::instance()->m_factories_map.end ()'
//			, std::back_inserter(*keys)
  '		, std::back_inserter(*keys)'
//			, boost::bind (&FactoryMap::value_type::first, _1)
  '		, boost::bind (&FactoryMap::value_type::first, _1)'
//		);
  '	);'
//		
  '	'
//		return keys.forget ();
  '	return keys.forget ();'
//	}]
  '}' 
 end // if

//%f _dump_interface_factory_keys_method
; // dump_fmng_keys_method

: dump_interface_factory_keys_method OBJECT IN %S
//	[{%XU=java}#public static java.util.Set\<%{INT}%f_dump_switch_type()\> keys () {
 if ( ( %X |U ) %== 'java' ) then
 begin
  out_indent 'public static java.util.Set<'
  ( get_global_var ( 'INT' ) %f dump_switch_type %( )% ) '> keys () {'
//	#	return %{INT}NFactoryManager.keys ();
  out_indent '	return '
  ( get_global_var ( 'INT' ) |N ) 'FactoryManager.keys ();'
//	#}][{%XU=h}%f_set_var(SWITCH,"")%S%f_find_switch("SWITCH")\
  out_indent '}' 
 end // if
 if ( ( %X |U ) %== 'h' ) then
 begin
  [%f] set_var %( 'SWITCH' %, '' )% %S %f find_switch %( 'SWITCH' )% 
//	#typedef std::vector\<[{%{SWITCH}%TN!=string}{std::string}%f_type(%{SWITCH}%T)]\> KeySet;
  out_indent 'typedef std::vector<'
  if ( ( ( get_global_var ( 'SWITCH' )  ->T |N ) ) %!= 'string' ) then
  begin
   [%f] type %( ( get_global_var ( 'SWITCH' )  ->T ) )% 
  end // if
  else
  begin
   'std::string' 
  end // else
  '> KeySet;'
//	#
  out_indent 
//	#static KeySet* keys ();][{%XU=cpp}%SNFactory::KeySet* %SNFactory::keys () {
  out_indent 'static KeySet* keys ();' 
 end // if
 if ( ( %X |U ) %== 'cpp' ) then
 begin
  %S |N 'Factory::KeySet* '
  %S |N 'Factory::keys () {'
//		return %SNFactoryManager::keys ();
  '	return '
  %S |N 'FactoryManager::keys ();'
//	}]
  '}' 
 end // if
//#UC END# *470321C1038Afor47174CE200AB*
; // dump_interface_factory_keys_method


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: AbstractInterface::Class::factory::Operation
end. // <<AbstractInterface>>

implementation @ :: <<AbstractInterface>> <<factory>> ;
//? Базовый стереотип фабрики
//= InterfaceGeneratorWithJava::MDAGenerator

// Параметры стереотипа
//e g
// - возможность использовать исключения
//a a
// - тип абстракции
//T 
// - может не иметь "цели" (типа/результата)
//A
// - стереотипы "цели" (типа/результата)

// Пользовательские свойства
//p dll export:b=true ? определяет что данный метод будет экспортироваться наружу компоненты

// Генераторы
// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor497483770297*
//#UC END# *470321C1038Afor497483770297*
; // fctr.java


// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for497483770297*
//#UC END# *4705C5490109for497483770297*
; // fctr.h


// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for497483770297*
//#UC END# *4705C54B01F4for497483770297*
; // fctr.cpp


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor497483770297*
//#UC END# *47022C88029Ffor497483770297*
; // h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for497483770297*
//#UC END# *470321950119for497483770297*
; // java


// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor497483770297*
//#UC END# *47032EC4032Cfor497483770297*
; // dll.h


// С++ TIE-обвязка для DLL (_tie.cpp)
//+ dll.cpp
<<generator>> dll.cpp OBJECT IN %S
//#UC START# *47032ED002DEfor497483770297*
//#UC END# *47032ED002DEfor497483770297*
; // dll.cpp


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{dll export}"!="%S{!dll export}"}%f_up_prefix(%S) *dll export* = *%S{dll export}* - определяет что данный метод будет экспортироваться наружу компоненты
 ?inherited
 if ( ( %S get_up ( 'dll export' ) ) %!= ( %S get_up_def ( 'dll export' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *dll export* = *'
  %S get_up ( 'dll export' ) '* - определяет что данный метод будет экспортироваться наружу компоненты'
//	]
 end // if

// Генерит исключения в декларации фабричных методов менеджера фабрик
//%f _dump_exceptions
; // wiki_up_print

: dump_exceptions OBJECT IN %S
//#UC START# *49AD28F50299for497483770297*
//	[{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{throw (CORBA::SystemException, CoreSrv::NoActiveFactory[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]%S<, %f_type(%E)>)}/*throw (Core::Root::NoActiveFactory[{%f_need_conversion_exception(%S)=true}, Core::Root::ImpossibleConversion]%S<, %f_type(%E)>)*/]
 if ( ( [%f] realize_srv_interface %( %S )% ) %==  false OR 
   ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
 begin
  '/*throw (Core::Root::NoActiveFactory'
  if ( ( [%f] need_conversion_exception %( %S )% ) %==  true ) then
  begin
   ', Core::Root::ImpossibleConversion' 
  end // if
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     ', '
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E

  ) // bind
   ')*/' 
 end // if
 else
 begin
  'throw (CORBA::SystemException, CoreSrv::NoActiveFactory'
  if ( ( [%f] need_conversion_exception %( %S )% ) %==  true ) then
  begin
   ', Core::Root::ImpossibleConversion' 
  end // if
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     ', '
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E

  ) // bind
   ')' 
 end // else
//#UC END# *49AD28F50299for497483770297*
; // dump_exceptions


// Формирует список исключений для статических клиентских фабрик
//%f _dump_exceptions_client_fctr
: dump_exceptions_client_fctr OBJECT IN %S
//#UC START# *49AF75740088for497483770297*
//	[{"%1N"=""}%f_error("Не задан идентифкатор списка")]\
 if ( ( %1 |N ) %== '' ) then
 begin
  [%f] error %( 'Не задан идентифкатор списка' )% 
 end // if
//	%f_clear_list(%1N)\
 [%f] clear_list %( %1 |N )% 
//	[{%S{transparent multy}=true}{[{%S{transparent multy}=false|"%S{transparent multy}"=""}%f_add_to_list(%1N,"Core::Root::UnknownFactoryKey")]}%f_add_to_list(%1N,"Core::Root::NoActiveFactory")]\
 if ( ( %S get_up ( 'transparent multy' ) ) %==  true ) then
 begin
  [%f] add_to_list %( %1 |N %, 'Core::Root::NoActiveFactory' )% 
 end // if
 else
 begin
  if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
    ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
  begin
   [%f] add_to_list %( %1 |N %, 'Core::Root::UnknownFactoryKey' )% 
  end // if
 end // else
//	%f_add_to_list(%1N,"Core::Root::FactoryManagerWasDestroyed")\
 [%f] add_to_list %( %1 |N %, 'Core::Root::FactoryManagerWasDestroyed' )% 
//	[{%f_need_conversion_exception(%S)=true}%f_add_to_list(%1N,"Core::Root::ImpossibleConversion")]\
 if ( ( [%f] need_conversion_exception %( %S )% ) %==  true ) then
 begin
  [%f] add_to_list %( %1 |N %, 'Core::Root::ImpossibleConversion' )% 
 end // if
//	<%f_add_to_list(%1N,"%f_type(%E)")>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   [%f] add_to_list %( %1 |N %, [%f] type %( %E )% )% 
   ++! l_Counter
  end // if
 end // for E
//#UC END# *49AF75740088for497483770297*
; // dump_exceptions_client_fctr


// Список исключений для методов менеджера фабрик
//%f _dump_exceptions_multi_fctr_mngr
: dump_exceptions_multi_fctr_mngr OBJECT IN %S
//#UC START# *49AE8F4C01ABfor497483770297*
//	[{"%1N"=""}%f_error("Не задан идентифкатор списка")]\
 if ( ( %1 |N ) %== '' ) then
 begin
  [%f] error %( 'Не задан идентифкатор списка' )% 
 end // if
//	[{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{%f_add_to_list(%1N,"CORBA::SystemException")}]\
 if ( ( [%f] realize_srv_interface %( %S )% ) %==  false OR 
   ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
 begin
 end // if
 else
 begin
  [%f] add_to_list %( %1 |N %, 'CORBA::SystemException' )% 
 end // else
//	[{%S{transparent multy}=true}{[{%S{transparent multy}=false|"%S{transparent multy}"=""}%f_add_to_list(%1N,"Core::Root::UnknownFactoryKey")]}%f_add_to_list(%1N,"[{%f_realize_srv_interface(%S)=false|%S#f_is_exported()=false}{CoreSrv::NoActiveFactory}Core::Root::NoActiveFactory]")]\
 if ( ( %S get_up ( 'transparent multy' ) ) %==  true ) then
 begin
  [%f] add_to_list %( %1 |N %, if ( ( [%f] realize_srv_interface %( %S )% ) %==  false OR 
    ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
  begin
   'Core::Root::NoActiveFactory' 
  end // if
  else
  begin
   'CoreSrv::NoActiveFactory' 
  end // else
)%  end // if
 else
 begin
  if ( ( %S get_up ( 'transparent multy' ) ) %==  false OR 
    ( ( %S get_up ( 'transparent multy' ) ) %== ''  ) ) then
  begin
   [%f] add_to_list %( %1 |N %, 'Core::Root::UnknownFactoryKey' )% 
  end // if
 end // else
//	[{%f_need_conversion_exception(%S)=true}%f_add_to_list(%1N,"Core::Root::ImpossibleConversion")]\
 if ( ( [%f] need_conversion_exception %( %S )% ) %==  true ) then
 begin
  [%f] add_to_list %( %1 |N %, 'Core::Root::ImpossibleConversion' )% 
 end // if
//	<%f_add_to_list(%1N,"%f_type(%E)")>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   [%f] add_to_list %( %1 |N %, [%f] type %( %E )% )% 
   ++! l_Counter
  end // if
 end // for E
//#UC END# *49AE8F4C01ABfor497483770297*
; // dump_exceptions_multi_fctr_mngr


// генерит объявление мульти фабрики на менеджере фабрик
//%f _dump_factory_manager_multi_factory_h
: dump_factory_manager_multi_factory_h OBJECT IN %S
//#UC START# *4A93BE2103BAfor497483770297*
//	[{%S{const_type}=combo}{%f_dump_factory_manager_multi_factory_h_impl(%S)}%f_dump_factory_manager_multi_factory_h_impl(%S,"read-write")
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] dump_factory_manager_multi_factory_h_impl %( %S %, 'read-write' )% 
//	
  #13#10

//	#%f_dump_factory_manager_multi_factory_h_impl(%S,"read-only","_ro")]
  out_indent [%f] dump_factory_manager_multi_factory_h_impl %( %S %, 'read-only"' %, '_ro' )% 
 end // if
 else
 begin
  [%f] dump_factory_manager_multi_factory_h_impl %( %S )% 
 end // else
//#UC END# *4A93BE2103BAfor497483770297*
; // dump_factory_manager_multi_factory_h


// генерит объявление фабрики на менеджере фабрик
//%f _dump_factory_manager_single_factory_h
: dump_factory_manager_single_factory_h OBJECT IN %S
//#UC START# *4A93BE6D030Afor497483770297*
//	[#%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% 
//	][{%S{const_type}=combo}{%f_dump_factory_manager_single_factory_h_impl(%S)}\
 end // if
 NOP
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
//	%f_dump_factory_manager_single_factory_h_impl(%S,"read-write")
  [%f] dump_factory_manager_single_factory_h_impl %( %S %, 'read-write' )% 
//	
  #13#10

//	#%f_dump_factory_manager_single_factory_h_impl(%S,"read-only","_ro")][
  out_indent [%f] dump_factory_manager_single_factory_h_impl %( %S %, 'read-only"' %, '_ro' )% 
 end // if
 else
 begin
  [%f] dump_factory_manager_single_factory_h_impl %( %S )% 
 end // else
 if NOT-EMPTY
 begin
  #13#10

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4A93BE6D030Afor497483770297*
; // dump_factory_manager_single_factory_h


// Генерация фабрик
//%f _dump_fctr_cpp_factory_impl
: dump_fctr_cpp_factory_impl OBJECT IN %S
//#UC START# *498704DD033Cfor497483770297*
//	[{"%1N"!="servant"}[{"%{SERV}{Factory default impl}"!="true"}[%f_str_split(%SD,// )
 if ( ( %1 |N ) %!= 'servant' ) then
 begin
  if ( ( ( get_global_var ( 'SERV' ) get_up ( 'Factory default impl' ) ) ) %!= true ) then
  begin
   if NOT-EMPTY
   begin
    [%f] str_split %( %S |D %, '// ' )% 
//	]]%f_dump_fctr_header_cpp_i(%S,"%2N") {
   end // if
   NOP
  end // if
  [%f] dump_fctr_header_cpp_i %( %S %, %2 |N )% ' {'
//		[{"%{SERV}{Factory default impl}"="true"}{%f_set_var(CTOR,S)%{CTOR_P}[{true}%U[{%{SERV}U_%{CTOR}U_IMPL}
  '	'
  if ( ( ( get_global_var ( 'SERV' ) get_up ( 'Factory default impl' ) ) ) %== true ) then
  begin
   if ( ( ( get_global_var ( 'SERV' ) get_up ( 'singleton' ) ) ) %== false ) then
   begin
    [%f] var %( ( get_global_var ( 'SERV' ) ) )% ' ret = new '
    ( get_global_var ( 'SERV' ) |N ) ' ('
    %S
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |N 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     if ( ( %T |S ) %== 'FactoryMemory' AND 
      ( 
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %!= 'nokey' ) then
      begin

       ++! l_Counter
      end // if
     end // for C
     l_Counter
     %== 0  ) ) then
    begin
     if ( ( %C |x ) %==  true ) then
     begin
      ', ' 
     end // if
     [%f] set_var %( 'HAS_MEM_KEY' %, 1 )% 'mem_key' 
    end // if
//	[{"%f_equal_ctor(%{SERV},%S)"="true"}[{"%S%Cx"="true"|%S%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}, ]%f_set_var(HAS_FCT_ID,"1")%f_dump_factories_id_parent(%{SERV})FactoriesID::%f_to_borland(%SN)()][{%f_is_ro_fctr_exists(%S)=true}[{%{HAS_MEM_KEY}N=1|%{HAS_FCT_ID}N=1|%S%Cx=true}, ]ro_mode]);
    if ( ( [%f] equal_ctor %( ( get_global_var ( 'SERV' ) ) %, %S )% ) %== true ) then
    begin
     if ( ( %S ->C |x  ) %== true OR 
       ( ( %S ->T |S  ) %== 'FactoryMemory'  ) AND 
       ( 
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %!= 'nokey' ) then
       begin

        ++! l_Counter
       end // if
      end // for C
      l_Counter
      %== 0  ) ) then
     begin
      ', ' 
     end // if
     [%f] set_var %( 'HAS_FCT_ID' %, 1 )% [%f] dump_factories_id_parent %( ( get_global_var ( 'SERV' ) ) )% 'FactoriesID::'
     [%f] to_borland %( %S |N )% '()' 
    end // if
    if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
    begin
     if ( ( ( get_global_var ( 'HAS_MEM_KEY' ) |N ) ) %== 1 OR 
       ( ( ( get_global_var ( 'HAS_FCT_ID' ) |N ) ) %== 1  ) OR 
       ( ( %S ->C |x  ) %==  true  ) ) then
     begin
      ', ' 
     end // if
     'ro_mode' 
    end // if
    ');'
//		%{SERV}%f_activate_and_ret()]]
    '	'
    ( get_global_var ( 'SERV' ) %f activate_and_ret %( )% ) 
   end // if
   else
   begin
    'return Core::IObject::_duplicate ('
    ( get_global_var ( 'SERV' ) |N ) '::Singleton::instance());' 
   end // else
  end // if
  else
  begin
   [%f] set_var %( 'CTOR' %, 'S' )% ( get_global_var ( 'CTOR_P' ) ) 
   bind ( 
    OBJECT VAR %S
    if (  true ) then
    begin
     %Usersection (
      ( get_global_var ( 'SERV' ) |U ) '_'
      ( get_global_var ( 'CTOR' ) |U ) '_IMPL' 
     )
     (
      #13#10

//		]]}[{"%{SERV}{singleton}"="false"}{return Core::IObject::_duplicate (%{SERV}N::Singleton::instance());}%f_var(%{SERV}) ret = new %{SERV}N (%S<{, }%CN>[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}[{%Cx=true}, ]%f_set_var(HAS_MEM_KEY,"1")mem_key]\
      '	' 
     ) // Usersection
     end // if

   ) // bind
  end // else
//	}]\
  '}' 
 end // if
//	[{"%1N"="servant"}%t_ret(%{SERV},"%Ss") %{SERV}NServantFactory::%SN (%S%f_factory_params("%2N","","","servant")[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}[{%Cx=true}, ]%t_arg(%T,"inout") mem_key])[ /*throw (<{, }%f_type(%E)>)*/] {
 if ( ( %1 |N ) %== 'servant' ) then
 begin
  [%t] ret %( ( get_global_var ( 'SERV' ) ) %, %S |s )% ' '
  ( get_global_var ( 'SERV' ) |N ) 'ServantFactory::'
  %S |N ' ('
  %S %f factory_params %( %2 |N %, '' %, '' %, 'servant' )% if ( ( %T |S ) %== 'FactoryMemory' AND 
    ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %== 0  ) ) then
  begin
   if ( ( %C |x ) %==  true ) then
   begin
    ', ' 
   end // if
   [%t] arg %( %T %, 'inout' )% ' mem_key' 
  end // if
  ')'
  if NOT-EMPTY
  begin
   ' /*throw ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E
   ')*/' 
  end // if
  NOP
  ' {'
//	[{%Ss!=cached&%Ss!=const,cached}	if (%{SERV}N_factory::s_instance) {
  if ( ( %S |s ) %!= 'cached' AND 
    ( ( %S |s ) %!= 'const,cached'  ) ) then
  begin
   '	if ('
   ( get_global_var ( 'SERV' ) |N ) '_factory::s_instance) {'
//			return dynamic_cast\<%t_ret(%{SERV})\>(\
   '		return dynamic_cast<'
   [%t] ret %( ( get_global_var ( 'SERV' ) ) )% '>('
//	[{%{INT}S=ServerInterface}LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (]\
   if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
   begin
    'LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (' 
   end // if
//	%{SERV}N_factory::s_instance-\>%SN (<{, }%CN>)[{%{INT}S=ServerInterface})]);
   ( get_global_var ( 'SERV' ) |N ) '_factory::s_instance->'
   %S |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   ')'
   if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
   begin
    ')' 
   end // if
   ');'
//		} else {
   '	} else {'
//			throw Core::Root::NoActiveFactory (%{SERV}["%P%PN::%PN::%SN_factory"]);
   '		throw Core::Root::NoActiveFactory ('
   ( get_global_var ( 'SERV' ) ) 
   bind ( 
    OBJECT VAR %S
    if NOT-EMPTY
    begin
     %P ->P |N  '::'
     %P |N '::'
     %S |N '_factory' 
    end // if
    NOP

   ) // bind
   ');'
//		}
   '	}'
//	]\
  end // if
//	[{%f_is_it_cached(%S)=true}	try {
  if ( ( [%f] is_it_cached %( %S )% ) %==  true ) then
  begin
   '	try {'
//	[{%{INT}S=ServerInterface}{		return dynamic_cast\<%{SERV}N&\> (%f_type(%{INT})Factory::%SN (<{, }%CN>[{%SS=multi factory}[{%S%Cx=true}, ][{}{"%{SERV}N"}%{SERV}#f_key_impl()]]));}\
   if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'ServerInterface' ) then
   begin
//			PortableServer::ServantBase_var serv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (
    '		PortableServer::ServantBase_var serv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant ('
//				&%f_type(%{INT})Factory::%SN (%S<{, }%CN>[{%SS=multi factory}[{%S%Cx=true}, ][{}{"%{SERV}N"}%{SERV}#f_key_impl()]])
    '			&'
    [%f] type %( ( get_global_var ( 'INT' ) ) )% 'Factory::'
    %S |N ' ('
    %S
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |N 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     if ( ( %S |S ) %== 'multi factory' ) then
    begin
     if ( ( %S ->C |x  ) %==  true ) then
     begin
      ', ' 
     end // if
     if NOT-EMPTY
     begin
      ( get_global_var ( 'SERV' ) ) out_indent 'f_key_impl()' 
     end // if
     NOP
     else
     begin
      ( get_global_var ( 'SERV' ) |N ) 
     end // else
    end // if
    ')'
//			);
    '		);'
//			return dynamic_cast\<%{SERV}N&\> (*(serv.in ()));]
    '		return dynamic_cast<'
    ( get_global_var ( 'SERV' ) |N ) '&> (*(serv.in ()));' 
   end // if
   else
   begin
    '		return dynamic_cast<'
    ( get_global_var ( 'SERV' ) |N ) '&> ('
    [%f] type %( ( get_global_var ( 'INT' ) ) )% 'Factory::'
    %S |N ' ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      %C |N 
      ++! l_Counter
     end // if
    end // for C
    if ( ( %S |S ) %== 'multi factory' ) then
    begin
     if ( ( %S ->C |x  ) %==  true ) then
     begin
      ', ' 
     end // if
     if NOT-EMPTY
     begin
      ( get_global_var ( 'SERV' ) ) out_indent 'f_key_impl()' 
     end // if
     NOP
     else
     begin
      ( get_global_var ( 'SERV' ) |N ) 
     end // else
    end // if
    '));' 
   end // else
//		} catch (std::bad_cast& ) {
   '	} catch (std::bad_cast& ) {'
//			throw Core::Root::NoActiveFactory (%{SERV}["%P%PN::%PN::%SN_factory"]);
   '		throw Core::Root::NoActiveFactory ('
   ( get_global_var ( 'SERV' ) ) 
   bind ( 
    OBJECT VAR %S
    if NOT-EMPTY
    begin
     %P ->P |N  '::'
     %P |N '::'
     %S |N '_factory' 
    end // if
    NOP

   ) // bind
   ');'
//		}
   '	}'
//	]}]
  end // if
  '}' 
 end // if
//#UC END# *498704DD033Cfor497483770297*
; // dump_fctr_cpp_factory_impl


// Генерит декларацию конкретных фабрик
//%f _dump_fctr_h_impl
: dump_fctr_h_impl OBJECT IN %S
//#UC START# *49895C3202DFfor497483770297*
//	%f_set_var(HAS_MEM_KEY,"0")\
 [%f] set_var %( 'HAS_MEM_KEY' %, 0 )% 
//	%f_set_var(SRV_FACTORY_OP,"[{"%1N"="servant"}{%t_ret(%{INT})}static %t_ret(%{__SERVANT},"%Ss")] %SN (%S%f_factory_params("%2N","","","servant")[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}[{%Cx=true}, ]%f_set_var(HAS_MEM_KEY,"1")%t_arg(%T,"inout") mem_key][{%f_is_ro_fctr_exists(%S)=true}[{%{HAS_MEM_KEY}N=1|%Cx=true}, ]bool ro_mode])[ /*throw (%S<{, }%f_type(%E)>)*/];")\
 [%f] set_var %( 'SRV_FACTORY_OP' %, if ( ( %1 |N ) %== 'servant' ) then
 begin
  'static '
  [%t] ret %( ( get_global_var ( '__SERVANT' ) ) %, %S |s )% 
 end // if
 else
 begin
  [%t] ret %( ( get_global_var ( 'INT' ) ) )% 
 end // else
 ' '
 %S |N ' ('
 %S %f factory_params %( %2 |N %, '' %, '' %, 'servant' )% if ( ( %T |S ) %== 'FactoryMemory' AND 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %== 0  ) ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
   ', ' 
  end // if
  [%f] set_var %( 'HAS_MEM_KEY' %, 1 )% [%t] arg %( %T %, 'inout' )% ' mem_key' 
 end // if
 if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
 begin
  if ( ( ( get_global_var ( 'HAS_MEM_KEY' ) |N ) ) %== 1 OR 
    ( ( %C |x ) %==  true  ) ) then
  begin
   ', ' 
  end // if
  'bool ro_mode' 
 end // if
 ')'
 if NOT-EMPTY
 begin
  ' /*throw ('
  %S
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] type %( %E )% 
     ++! l_Counter
    end // if
   end // for E

  ) // bind
   ')*/' 
 end // if
 NOP
 ';' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{SRV_FACTORY_OP}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'SRV_FACTORY_OP' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{SRV_FACTORY_OP}N}[{"%1N"="servant"}{%t_ret(%{INT})}static %t_ret(%{__SERVANT},"%Ss")] %SN (%S%f_factory_params("%2N","\n\t\t","","servant")[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}[{%Cx=true}\n\t\t, ]%t_arg(%T,"inout") mem_key][{%f_is_ro_fctr_exists(%S)=true}[{%{HAS_MEM_KEY}N=1|%Cx=true}\n\t\t, ]bool ro_mode]\n\t)[ /*throw (\n\t\t%S<{\n\t\t, }%f_type(%E)>\n\t)*/];]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  if ( ( %1 |N ) %== 'servant' ) then
  begin
   'static '
   [%t] ret %( ( get_global_var ( '__SERVANT' ) ) %, %S |s )% 
  end // if
  else
  begin
   [%t] ret %( ( get_global_var ( 'INT' ) ) )% 
  end // else
  ' '
  %S |N ' ('
  %S %f factory_params %( %2 |N %, #13#10#9#9'"' %, '' %, 'servant' )% if ( ( %T |S ) %== 'FactoryMemory' AND 
    ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %== 0  ) ) then
  begin
   if ( ( %C |x ) %==  true ) then
   begin
    #13#10#9#9', ' 
   end // if
   [%t] arg %( %T %, 'inout' )% ' mem_key' 
  end // if
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
  begin
   if ( ( ( get_global_var ( 'HAS_MEM_KEY' ) |N ) ) %== 1 OR 
     ( ( %C |x ) %==  true  ) ) then
   begin
    #13#10#9#9', ' 
   end // if
   'bool ro_mode' 
  end // if
  #13#10#9')'
  if NOT-EMPTY
  begin
   ' /*throw ('#13#10#9#9
   %S
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%E
    begin
     OBJECT IN %E
     if true then
     begin
      if ( l_Counter >0 ) then ( #13#10#9#9', ' )
      [%f] type %( %E )% 
      ++! l_Counter
     end // if
    end // for E

   ) // bind
    #13#10#9')*/' 
  end // if
  NOP
  ';' 
 end // if
 else
 begin
  ( get_global_var ( 'SRV_FACTORY_OP' ) |N ) 
 end // else
//#UC END# *49895C3202DFfor497483770297*
; // dump_fctr_h_impl


// Генерит форматированный список исключений для клиентских мультифабрик
//%f _dump_formated_exception_client_list
: dump_formated_exception_client_list OBJECT IN %S
//#UC START# *49AF75D50218for497483770297*
//	[{"%1N"=""}%f_error("Не задан идентифкатор списка")]\
 if ( ( %1 |N ) %== '' ) then
 begin
  [%f] error %( 'Не задан идентифкатор списка' )% 
 end // if
//	%f_copy_list(%1N,%1N_COPY)\
 [%f] copy_list %( %1 |N %, %1 |N '_COPY' )% 
//	[{"%3N"="NEW_LINE"&"%XU"="h"}\n#	][{"%3N"!="NEW_LINE"} ]/*throw (<{%2N}{%f_is_empty(%1N_COPY)=false}{W}[%f_pop_first_to_var(%1N_COPY,EX)%{EX}N]>)*/
 if ( ( %3 |N ) %== 'NEW_LINE' AND 
   ( ( %X |U ) %== 'h'  ) ) then
 begin
  #13#10
  out_indent '	' 
 end // if
 if ( ( %3 |N ) %!= 'NEW_LINE' ) then
 begin
  ' ' 
 end // if
 '/*throw ('
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( %1 |N '_COPY' )% ) %==  false ) then
  begin
   if ( l_Counter >0 ) then ( %2 |N )
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( %1 |N '_COPY' %, 'EX' )% ( get_global_var ( 'EX' ) |N ) 
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
 ')*/'
//#UC END# *49AF75D50218for497483770297*
; // dump_formated_exception_client_list


// Генерит форматированный список исключений для реализации клиентских
// фабрик
//%f _dump_formated_exception_client_list_cpp
: dump_formated_exception_client_list_cpp OBJECT IN %S
//#UC START# *49AFC60A02BEfor497483770297*
//	[{"%1N"=""}%f_error("Не задан идентифкатор списка")]\
 if ( ( %1 |N ) %== '' ) then
 begin
  [%f] error %( 'Не задан идентифкатор списка' )% 
 end // if
//	%f_copy_list(%1N,%1N_COPY)\
 [%f] copy_list %( %1 |N %, %1 |N '_COPY' )% 
//	 /*throw (<{%2N}{%f_is_empty(%1N_COPY)=false}{W}[%f_pop_first_to_var(%1N_COPY,EX)%{EX}N]>)*/
 ' /*throw ('
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( %1 |N '_COPY' )% ) %==  false ) then
  begin
   if ( l_Counter >0 ) then ( %2 |N )
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( %1 |N '_COPY' %, 'EX' )% ( get_global_var ( 'EX' ) |N ) 
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
 ')*/'
//#UC END# *49AFC60A02BEfor497483770297*
; // dump_formated_exception_client_list_cpp


// Форматированный вывод списка исключений
//%f _dump_formated_exception_list
: dump_formated_exception_list OBJECT IN %S
//#UC START# *49AE8F900025for497483770297*
//	[{"%1N"=""}%f_error("Не задан идентифкатор списка")]\
 if ( ( %1 |N ) %== '' ) then
 begin
  [%f] error %( 'Не задан идентифкатор списка' )% 
 end // if
//	%f_copy_list(%1N,%1N_COPY)\
 [%f] copy_list %( %1 |N %, %1 |N '_COPY' )% 
//	<{%2N}{%f_is_empty(%1N_COPY)=false}{W}[%f_pop_first_to_var(%1N_COPY,EX)%{EX}N]>
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( %1 |N '_COPY' )% ) %==  false ) then
  begin
   if ( l_Counter >0 ) then ( %2 |N )
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( %1 |N '_COPY' %, 'EX' )% ( get_global_var ( 'EX' ) |N ) 
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//#UC END# *49AE8F900025for497483770297*
; // dump_formated_exception_list


// генерит список праметров фабрики (при это если нужна, выполняется  конвертация спецификаторов
// параметров)
//%f _factory_params
: factory_params OBJECT IN %S
//#UC START# *497963F4033Ffor497483770297*
//	%f_set_var(TYPE,"[{%S{force use const arg}=true&%S{const_type}=combo&%1N=read-only}{read-write}read-only]")\
 [%f] set_var %( 'TYPE' %, if ( ( %S get_up ( 'force use const arg' ) ) %==  true AND 
   ( ( %S get_up ( 'const_type' ) ) %== 'combo'  ) AND 
   ( ( %1 |N ) %== 'read-only'  ) ) then
 begin
  'read-only' 
 end // if
 else
 begin
  'read-write' 
 end // else
)% //	[{"%4N"!="servant"}{%f_set_var(ARGS,"<{%2N, }{}{%C}%t_arg(%C%T,"%t_r_w_param_specificator("%CS","%{TYPE}N")") %t_language_style("%CN")>")}\
 if ( ( %4 |N ) %!= 'servant' ) then
 begin
//	%f_set_var(ARGS,"<{%2N, }{%CS!=cache}{%C}%t_arg(%C%T,"%t_r_w_param_specificator("%CS","%{TYPE}N")") %t_language_style("%CN")>")]\
  [%f] set_var %( 'ARGS' %, 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'cache' ) then
   begin
    if ( l_Counter >0 ) then ( %2 |N ', ' )
    [%t] arg %( %C ->T  %, [%t] r_w_param_specificator %( %C |S %, ( get_global_var ( 'TYPE' ) |N ) )% )% ' '
    [%t] language_style %( %C |N )% 
    ++! l_Counter
   end // if
  end // for C
)%  end // if
 else
 begin
  [%f] set_var %( 'ARGS' %, 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( %2 |N ', ' )
    [%t] arg %( %C ->T  %, [%t] r_w_param_specificator %( %C |S %, ( get_global_var ( 'TYPE' ) |N ) )% )% ' '
    [%t] language_style %( %C |N )% 
    ++! l_Counter
   end // if
  end // for C
)%  end // else
//	[{"%{ARGS}N"!=""}%2N%{ARGS}N%3N]
 if ( ( ( get_global_var ( 'ARGS' ) |N ) ) %!= '' ) then
 begin
  %2 |N ( get_global_var ( 'ARGS' ) |N ) %3 |N 
 end // if

//генерит атрибут для типа кэша
//%f _cache_attr
; // factory_params

: cache_attr OBJECT IN %S
//	[{%f_check_if_type(%1%T,"string")=false&%f_check_if_type(%1%T,"a-string")=false}{std::string %1N}%f_arg_full_decl(%1)]
 if ( ( [%f] check_if_type %( %1 ->T  %, 'string' )% ) %==  false AND 
   ( ( [%f] check_if_type %( %1 ->T  %, 'a-string' )% ) %==  false  ) ) then
 begin
  [%f] arg_full_decl %( %1 )% 
 end // if
 else
 begin
  'std::string '
  %1 |N 
 end // else
//#UC END# *497963F4033Ffor497483770297*
; // cache_attr


// Генерит реализацию конструктора для серванта
//%f _fctr_def_impl_cpp_ctor_impl
: fctr_def_impl_cpp_ctor_impl OBJECT IN %S
//#UC START# *498AEC1101EEfor497483770297*
//	%f_set_var(CTOR,S)\
 [%f] set_var %( 'CTOR' %, 'S' )% 
//	%f_fctr_def_impl_header_cpp_i(%S,"%1N")
 [%f] fctr_def_impl_header_cpp_i %( %S %, %1 |N )% 
//	%{SELF_OP}[{true}%U[{_%{CTOR}U_%{SELF}U_BASE_INIT[{%2N=read-only}_RO]}
 ( get_global_var ( 'SELF_OP' ) ) 
 bind ( 
  OBJECT VAR %S
  if (  true ) then
  begin
   %Usersection (
    '_'
    ( get_global_var ( 'CTOR' ) |U ) '_'
    ( get_global_var ( 'SELF' ) |U ) '_BASE_INIT'
    if ( ( %2 |N ) %== 'read-only' ) then
    begin
     '_RO' 
    end // if

   )
   (
    #13#10

//	]

   ) // Usersection
 //	{%f_start_func_cpp(%{SELF},"%{SELF}N::%{SELF}N")
   '{'
   [%f] start_func_cpp %( ( get_global_var ( 'SELF' ) ) %, ( get_global_var ( 'SELF' ) |N ) '::'
   ( get_global_var ( 'SELF' ) |N ) )% 
//		%U[{_%{CTOR}U_%{SELF}U_BODY[{%2N=read-only}_RO]}
   '	'
   %Usersection (
    '_'
    ( get_global_var ( 'CTOR' ) |U ) '_'
    ( get_global_var ( 'SELF' ) |U ) '_BODY'
    if ( ( %2 |N ) %== 'read-only' ) then
    begin
     '_RO' 
    end // if

   )
   (
    #13#10

//		]
    '	' 
   ) // Usersection
 //	%f_end_func_cpp(%{SELF})}]
   [%f] end_func_cpp %( ( get_global_var ( 'SELF' ) ) )% '}' 
  end // if

 ) // bind
//#UC END# *498AEC1101EEfor497483770297*
; // fctr_def_impl_cpp_ctor_impl


// Генерит декларацию конструктора для серванта
//%f _fctr_def_impl_h_impl
: fctr_def_impl_h_impl OBJECT IN %S
//#UC START# *498AACD601DAfor497483770297*
//	%f_set_var(HAS_MEM_KEY,"0")\
 [%f] set_var %( 'HAS_MEM_KEY' %, 0 )% 
//	%f_set_var(HAS_FCT_ID,"0")\
 [%f] set_var %( 'HAS_FCT_ID' %, 0 )% 
//	%f_set_var(OPERATION_FACTORY,"%{SELF}N (%S%f_factory_params("%1N","","","servant")[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}[{%Cx=true}, ]%f_set_var(HAS_MEM_KEY,"1")%t_arg(%T,"inout") mem_key][{"%f_equal_ctor(%{SELF},%S)"="true"}[{"%S%Cx"="true"|%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}, ]%f_set_var(HAS_FCT_ID,"1")const %f_dump_factories_id_parent(%{SELF})FactoriesID::%f_to_borland(%SN)& factory_id][{%f_is_ro_fctr_exists(%S)=true}[{%{HAS_MEM_KEY}N=1|%{HAS_FCT_ID}N=1|%Cx=true}, ]bool ro_mode]);")\
 [%f] set_var %( 'OPERATION_FACTORY' %, ( get_global_var ( 'SELF' ) |N ) ' ('
 %S %f factory_params %( %1 |N %, '' %, '' %, 'servant' )% if ( ( %T |S ) %== 'FactoryMemory' AND 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'nokey' ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %== 0  ) ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
   ', ' 
  end // if
  [%f] set_var %( 'HAS_MEM_KEY' %, 1 )% [%t] arg %( %T %, 'inout' )% ' mem_key' 
 end // if
 if ( ( [%f] equal_ctor %( ( get_global_var ( 'SELF' ) ) %, %S )% ) %== true ) then
 begin
  if ( ( %S ->C |x  ) %== true OR 
    ( ( %T |S ) %== 'FactoryMemory'  ) AND 
    ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %== 0  ) ) then
  begin
   ', ' 
  end // if
  [%f] set_var %( 'HAS_FCT_ID' %, 1 )% 'const '
  [%f] dump_factories_id_parent %( ( get_global_var ( 'SELF' ) ) )% 'FactoriesID::'
  [%f] to_borland %( %S |N )% '& factory_id' 
 end // if
 if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
 begin
  if ( ( ( get_global_var ( 'HAS_MEM_KEY' ) |N ) ) %== 1 OR 
    ( ( ( get_global_var ( 'HAS_FCT_ID' ) |N ) ) %== 1  ) OR 
    ( ( %C |x ) %==  true  ) ) then
  begin
   ', ' 
  end // if
  'bool ro_mode' 
 end // if
 ');' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{OPERATION_FACTORY}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'OPERATION_FACTORY' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{OPERATION_FACTORY}N}%{SELF}N (%S%f_factory_params("%1N","\n\t\t","","servant")[{%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}[{%Cx=true}, ]%t_arg(%T,"inout") mem_key][{"%f_equal_ctor(%{SELF},%S)"="true"}[{"%S%Cx"="true"|%TS=FactoryMemory&<{}{%CS!=nokey}{%CC}>=0}\n\t\t, ]const %f_dump_factories_id_parent(%{SELF})FactoriesID::%f_to_borland(%SN)& factory_id][{%f_is_ro_fctr_exists(%S)=true}[{%{HAS_MEM_KEY}N=1|%{HAS_FCT_ID}N=1|%Cx=true}, ]bool ro_mode]\n\t);]
 if ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true AND 
   ( ( %C |x ) %==  true  ) ) then
 begin
  ( get_global_var ( 'SELF' ) |N ) ' ('
  %S %f factory_params %( %1 |N %, #13#10#9#9'"' %, '' %, 'servant' )% if ( ( %T |S ) %== 'FactoryMemory' AND 
    ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %== 0  ) ) then
  begin
   if ( ( %C |x ) %==  true ) then
   begin
    ', ' 
   end // if
   [%t] arg %( %T %, 'inout' )% ' mem_key' 
  end // if
  if ( ( [%f] equal_ctor %( ( get_global_var ( 'SELF' ) ) %, %S )% ) %== true ) then
  begin
   if ( ( %S ->C |x  ) %== true OR 
     ( ( %T |S ) %== 'FactoryMemory'  ) AND 
     ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %!= 'nokey' ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %== 0  ) ) then
   begin
    #13#10#9#9', ' 
   end // if
   'const '
   [%f] dump_factories_id_parent %( ( get_global_var ( 'SELF' ) ) )% 'FactoriesID::'
   [%f] to_borland %( %S |N )% '& factory_id' 
  end // if
  if ( ( [%f] is_ro_fctr_exists %( %S )% ) %==  true ) then
  begin
   if ( ( ( get_global_var ( 'HAS_MEM_KEY' ) |N ) ) %== 1 OR 
     ( ( ( get_global_var ( 'HAS_FCT_ID' ) |N ) ) %== 1  ) OR 
     ( ( %C |x ) %==  true  ) ) then
   begin
    ', ' 
   end // if
   'bool ro_mode' 
  end // if
  #13#10#9');' 
 end // if
 else
 begin
  ( get_global_var ( 'OPERATION_FACTORY' ) |N ) 
 end // else
//#UC END# *498AACD601DAfor497483770297*
; // fctr_def_impl_h_impl


// генерит определение менеджера фабрик для интерфейса
//%f _fctr_mng_fctr_cpp
: fctr_mng_fctr_cpp OBJECT IN %S
//#UC START# *4A950A3D028Efor497483770297*
//	[%S%f_open_ifdef()
 if NOT-EMPTY
 begin
  %S %f open_ifdef %( )% 
//	][{%S{const_type}=combo}{%{INT}%f_fctr_mng_fctr_cpp_impl(%S,"%S{const_type}")}%{INT}%f_fctr_mng_fctr_cpp_impl(%S,"read-write")
 end // if
 NOP
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  ( get_global_var ( 'INT' ) %f fctr_mng_fctr_cpp_impl %( %S %, 'read-write' )% ) 
//	
  #13#10

//	%{INT}%f_fctr_mng_fctr_cpp_impl(%S,"read-only","_ro")][
  ( get_global_var ( 'INT' ) %f fctr_mng_fctr_cpp_impl %( %S %, 'read-only"' %, '_ro' )% ) 
 end // if
 else
 begin
  ( get_global_var ( 'INT' ) %f fctr_mng_fctr_cpp_impl %( %S %, %S get_up ( 'const_type' ) )% ) 
 end // else
 if NOT-EMPTY
 begin
  #13#10

//	%S%f_close_ifdef()]
  %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *4A950A3D028Efor497483770297*
; // fctr_mng_fctr_cpp


// генерит релизацию мульти фабрики на менеджере фабрик
//%f _fctr_mng_m_fctr_cpp
: fctr_mng_m_fctr_cpp OBJECT IN %S
//#UC START# *4A950A8402CBfor497483770297*
//	[{%S{const_type}=combo}{%{INT}%f_fctr_mng_m_fctr_cpp_impl(%S,"%S{const_type}")}%{INT}%f_fctr_mng_m_fctr_cpp_impl(%S,"read-write")
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  ( get_global_var ( 'INT' ) %f fctr_mng_m_fctr_cpp_impl %( %S %, 'read-write' )% ) 
//	
  #13#10

//	%{INT}%f_fctr_mng_m_fctr_cpp_impl(%S,"read-only","_ro")]
  ( get_global_var ( 'INT' ) %f fctr_mng_m_fctr_cpp_impl %( %S %, 'read-only"' %, '_ro' )% ) 
 end // if
 else
 begin
  ( get_global_var ( 'INT' ) %f fctr_mng_m_fctr_cpp_impl %( %S %, %S get_up ( 'const_type' ) )% ) 
 end // else
//#UC END# *4A950A8402CBfor497483770297*
; // fctr_mng_m_fctr_cpp


// возвращает true, если RW и RO фабрики имеют различные синатуры
//%f _has_two_different_signatures
: has_two_different_signatures OBJECT IN %S
//#UC START# *4979643901D3for497483770297*
//	[{%S{force use const arg}=true&%S{const_type}=combo&<{}{}{%C}%t_arg(%C%T,"%t_r_w_param_specificator("%CS","read-write")")>!=<{}{}{%C}%t_arg(%C%T,"%t_r_w_param_specificator("%CS","read-only")")>}{false}true]
 if ( ( %S get_up ( 'force use const arg' ) ) %==  true AND 
   ( ( %S get_up ( 'const_type' ) ) %== 'combo'  ) AND 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    [%t] arg %( %C ->T  %, [%t] r_w_param_specificator %( %C |S %, 'read-write' )% )% 
    ++! l_Counter
   end // if
  end // for C
  %!= 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    [%t] arg %( %C ->T  %, [%t] r_w_param_specificator %( %C |S %, 'read-only' )% )% 
    ++! l_Counter
   end // if
  end // for C
 ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4979643901D3for497483770297*
; // has_two_different_signatures


// возвращает true, если фабрика кэшированная (в том числе если это синхро-фабрика), иначе - false
//%f _is_cached
: is_cached OBJECT IN %S
//#UC START# *4A93E7EC0223for497483770297*
//	[{%Ss=cached|%Ss=const,cached|%Ss=synchro}{false}true]
 if ( ( %S |s ) %== 'cached' OR 
   ( ( %S |s ) %== 'const,cached'  ) OR 
   ( ( %S |s ) %== 'synchro'  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4A93E7EC0223for497483770297*
; // is_cached


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for497483770297*
//c                                                             {}
//r {%S%f_is_cached(%S)=false&<{}{%CS=cache}{%CC}>!=0}:         {Стереотип "cache" может использоваться только для параметров кэшированной фабрики}
//r {""=""}:                                                    {}
//#UC END# *4704C0E30186for497483770297*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor497483770297*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor497483770297*
; // wiki_child_kind



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<AbstractInterface>> <<factory>> ;

