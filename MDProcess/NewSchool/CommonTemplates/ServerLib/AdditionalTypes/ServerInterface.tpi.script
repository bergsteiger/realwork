////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/ServerLib/AdditionalTypes/ServerInterface.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::ServerLib::AdditionalTypes::ServerInterface
//
// Серверный интерфейс
// ---
// Определяет интерфейсы в контексте своей компоненты. Для Сервера это серверные интерфейсы, для
// ДЛЛ - объъектный интерфейс экспортируемый ДЛЛ, для библиотеки - интерфейс клсса, для ГУИ набор
// операция пользователя.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: ServerInterface::Class
implementation @ <<ServerInterface>>
//? Серверный интерфейс
//? Определяет интерфейсы в контексте своей компоненты. Для Сервера это серверные интерфейсы, для ДЛЛ - объъектный интерфейс экспортируемый ДЛЛ, для библиотеки - интерфейс клсса, для ГУИ набор операция пользователя.
//< *::Class,*::Category

//= ServerFacet::Class
//= AbstractInterface::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//a raf
// - тип абстракции
//Y code_server_interface.gif
//L code_server_interface
// Параметры визуализации
//$ C 215,215,255
//$ l 10,10,255
//$ f 10,10,255

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p Use AMI:b=false ? генерирует CORBA интерфейс с поддержкой AMI
//p debug log:b=false ? включает генерацию вывода в лог обращений к методам реализующим доступ к данному атрибуту
//p TODO:s ? напоминалка что-то сделать

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S%[ServerFacet::Class]f_wiki_up_print()[{"%S{Use AMI}"!="%S{!Use AMI}"}%f_up_prefix(%S) *Use AMI* = *%S{Use AMI}* - генерирует CORBA интерфейс с поддержкой AMI
 call-inherited:: 'ServerFacet' wiki_up_print %( )%
 if ( ( %S get_up ( 'Use AMI' ) ) %!= ( %S get_up_def ( 'Use AMI' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *Use AMI* = *'
  %S get_up ( 'Use AMI' ) '* - генерирует CORBA интерфейс с поддержкой AMI'
//	][{"%S{debug log}"!="%S{!debug log}"}%f_up_prefix(%S) *debug log* = *%S{debug log}* - включает генерацию вывода в лог обращений к методам реализующим доступ к данному атрибуту
 end // if
 if ( ( %S get_up ( 'debug log' ) ) %!= ( %S get_up_def ( 'debug log' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *debug log* = *'
  %S get_up ( 'debug log' ) '* - включает генерацию вывода в лог обращений к методам реализующим доступ к данному атрибуту'
//	][{"%S{TODO}"!="%S{!TODO}"}%f_up_prefix(%S) *TODO* = *%S{TODO}* - напоминалка что-то сделать
 end // if
 if ( ( %S get_up ( 'TODO' ) ) %!= ( %S get_up_def ( 'TODO' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *TODO* = *'
  %S get_up ( 'TODO' ) '* - напоминалка что-то сделать'
//	]
 end // if

// есть ли не публичные фабрики
//%f _has_private_factory
; // wiki_up_print

: has_private_factory OBJECT IN %S
//#UC START# *470F7242038Afor470F71BF03C8*
//	[{<{}{%CS=factory&%CV!=PublicAccess|%CS=multi factory&%CV!=PublicAccess}{C}>!=0}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' AND 
    ( ( %C |V ) %!= 'PublicAccess'  ) OR 
    ( ( %C |S ) %== 'multi factory'  ) AND 
    ( ( %C |V ) %!= 'PublicAccess'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *470F7242038Afor470F71BF03C8*
; // has_private_factory


// возвращает true, если есть экспортируемые фабрики
//%f _has_exported_factory
: has_exported_factory OBJECT IN %S
//#UC START# *4AE7EC5D017Dfor470F71BF03C8*
//	[{%f_has_exported_factory_impl(%S)=false}{true}[{<{}{%ga=abstract&%f_has_exported_factory_impl(%g)=true}{%gC}>=0}{true}false]]
 if ( ( [%f] has_exported_factory_impl %( %S )% ) %==  false ) then
 begin
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' AND 
     ( ( [%f] has_exported_factory_impl %( %g )% ) %==  true  ) ) then
    begin

     ++! l_Counter
    end // if
   end // for g
   l_Counter
   %== 0 ) then
  begin
    false 
  end // if
  else
  begin
    true 
  end // else
 end // if
 else
 begin
   true 
 end // else

//f _has_exported_factory_impl
; // has_exported_factory

end. // <<ServerInterface>>

: has_exported_factory_impl OBJECT IN %S
//	[{"<{}{%f_kind_of(C,ServerFactoryOperationInternal::Class)=true}{%C}[{%C%f_is_exported()=true}.]>"!=""}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] kind_of %( 'C' %, 'ServerFactoryOperationInternal::Class' )% ) %==  true ) then
   begin
    if ( ( %C %f is_exported %( )% ) %==  true ) then
    begin
     '.' 
    end // if

    ++! l_Counter
   end // if
  end // for C
  %!= '' ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4AE7EC5D017Dfor470F71BF03C8*
; // has_exported_factory_impl


// возвращает true, если есть неэкспортируемые фабрики
//%f _has_non_exported_factory
implementation @ <<ServerInterface>>
: has_non_exported_factory OBJECT IN %S
//#UC START# *4AE7F23B0014for470F71BF03C8*
//	[{%f_has_non_exported_factory(%S)=false}{true}[{<{}{%ga=abstract&%f_has_non_exported_factory(%g)=true}{%gC}>=0}{true}false]]
 if ( ( [%f] has_non_exported_factory %( %S )% ) %==  false ) then
 begin
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' AND 
     ( ( [%f] has_non_exported_factory %( %g )% ) %==  true  ) ) then
    begin

     ++! l_Counter
    end // if
   end // for g
   l_Counter
   %== 0 ) then
  begin
    false 
  end // if
  else
  begin
    true 
  end // else
 end // if
 else
 begin
   true 
 end // else

//f _has_non_exported_factory
; // has_non_exported_factory

end. // <<ServerInterface>>

: has_non_exported_factory OBJECT IN %S
//	[{"<{}{%f_kind_of(C,ServerFactoryOperationInternal::Class)=true}{%C}[{%C%f_is_exported()=false}.]>"!=""}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] kind_of %( 'C' %, 'ServerFactoryOperationInternal::Class' )% ) %==  true ) then
   begin
    if ( ( %C %f is_exported %( )% ) %==  false ) then
    begin
     '.' 
    end // if

    ++! l_Counter
   end // if
  end // for C
  %!= '' ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4AE7F23B0014for470F71BF03C8*
; // has_non_exported_factory


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа AbstractInterface::Class
// генерация дополнительных объявлений для фабрик (C++)
//%f _additional_fctr_def
implementation @ <<ServerInterface>>
: additional_fctr_def OBJECT IN %S
//#UC START# *471F2C3D0232for470F71BF03C8*
//	[{%S%f_has_exported_factory()=true}private:
 if ( ( %S %f has_exported_factory %( )% ) %==  true ) then
 begin
  'private:'
//		typedef ACE_Singleton\<%SNFactoryManagerSrv_var, ACE_SYNCH_RECURSIVE_MUTEX\> FactoryManagerSrvSingleton;
  '	typedef ACE_Singleton<'
  %S |N 'FactoryManagerSrv_var, ACE_SYNCH_RECURSIVE_MUTEX> FactoryManagerSrvSingleton;'
//		static Core::Mutex s_init_mutex;
  '	static Core::Mutex s_init_mutex;'
//		static bool s_renew_mode;
  '	static bool s_renew_mode;'
//	<{}{%f_is_factory(%C)=true&%f_is_it_cached(%C)=true&%C%f_is_exported()=true}{%C}
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  true AND 
    ( ( [%f] is_it_cached %( %C )% ) %==  true  ) AND 
    ( ( %C %f is_exported %( )% ) %==  true  ) ) then
   begin
    #13#10

//	%f_srv_fctr_mng_fctr_h(%C)
    [%f] srv_fctr_mng_fctr_h %( %C )% 
//	>]

    ++! l_Counter
   end // if
  end // for C
 end // if
//#UC END# *471F2C3D0232for470F71BF03C8*
; // additional_fctr_def


// перекрытие базового стереотипа AbstractInterface::Class
// генерация дополнительных объявлений для фабрик (Java)
//%f _additional_fctr_def_java
: additional_fctr_def_java OBJECT IN %S
//#UC START# *471F2C4302FDfor470F71BF03C8*
//	[{%S%f_has_exported_factory()=true}	static boolean sRenewMode = false;
 if ( ( %S %f has_exported_factory %( )% ) %==  true ) then
 begin
  '	static boolean sRenewMode = false;'
//		static class FactoryManagerSrvSingleton {
  '	static class FactoryManagerSrvSingleton {'
//			private static %SNFactoryManagerSrv sInstance_ = null;
  '		private static '
  %S |N 'FactoryManagerSrv sInstance_ = null;'
//	
  #13#10

//			public static %SNFactoryManagerSrv getInstance () {
  '		public static '
  %S |N 'FactoryManagerSrv getInstance () {'
//				return sInstance_;
  '			return sInstance_;'
//			}
  '		}'
//	
  #13#10

//			public static void setInstance (%SNFactoryManagerSrv instance) {
  '		public static void setInstance ('
  %S |N 'FactoryManagerSrv instance) {'
//				sInstance_ = instance;
  '			sInstance_ = instance;'
//			}
  '		}'
//	
  #13#10

//		}
  '	}'
//	<{}{%f_is_factory(%C)=true&%f_is_it_cached(%C)=true&%C%f_is_exported()=true}{%C}
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  true AND 
    ( ( [%f] is_it_cached %( %C )% ) %==  true  ) AND 
    ( ( %C %f is_exported %( )% ) %==  true  ) ) then
   begin
    #13#10

//	%f_srv_fctr_mng_fctr_java(%C)
    [%f] srv_fctr_mng_fctr_java %( %C )% 
//	>]

    ++! l_Counter
   end // if
  end // for C
 end // if
//#UC END# *471F2C4302FDfor470F71BF03C8*
; // additional_fctr_def_java


// перекрытие базового стереотипа AbstractInterface::Class
// возвращает базовый менеджер фабрик (C++)
//%f _base_fctr_mng
: base_fctr_mng OBJECT IN %S
//#UC START# *471F2C4701E4for470F71BF03C8*
//	%f_set_var(NEED_COMMA,"false")\
 [%f] set_var %( 'NEED_COMMA' %, false )% 
//	: [{%S%f_has_exported_factory()=true}%f_set_var(NEED_COMMA,"true")virtual public POA_%f_full_name(%S)FactoryManagerSrv][{%S%f_has_non_exported_factory()=true}[{%{NEED_COMMA}N=true}, ]virtual public %SNFactoryManagerLocal]
 ': '
 if ( ( %S %f has_exported_factory %( )% ) %==  true ) then
 begin
  [%f] set_var %( 'NEED_COMMA' %, true )% 'virtual public POA_'
  [%f] full_name %( %S )% 'FactoryManagerSrv' 
 end // if
 if ( ( %S %f has_non_exported_factory %( )% ) %==  true ) then
 begin
  if ( ( ( get_global_var ( 'NEED_COMMA' ) |N ) ) %==  true ) then
  begin
   ', ' 
  end // if
  'virtual public '
  %S |N 'FactoryManagerLocal' 
 end // if
//#UC END# *471F2C4701E4for470F71BF03C8*
; // base_fctr_mng


// перекрытие базового стереотипа AbstractInterface::Class
// возвращает базовый менеджер фабрик (Java)
//%f _base_fctr_mng_java
: base_fctr_mng_java OBJECT IN %S
//#UC START# *471F2C4B008Cfor470F71BF03C8*
//	%f_set_var(NEED_COMMA,"false")\
 [%f] set_var %( 'NEED_COMMA' %, false )% 
//	 extends [{%S%f_has_exported_factory()=true}%f_set_var(NEED_COMMA,"true")%SNFactoryManagerSrvPOA]\
 ' extends '
 if ( ( %S %f has_exported_factory %( )% ) %==  true ) then
 begin
  [%f] set_var %( 'NEED_COMMA' %, true )% %S |N 'FactoryManagerSrvPOA' 
 end // if
//	[{%S%f_has_non_exported_factory()=true}[{%{NEED_COMMA}N=true} ]%SNFactoryManagerLocal]
 if ( ( %S %f has_non_exported_factory %( )% ) %==  true ) then
 begin
  if ( ( ( get_global_var ( 'NEED_COMMA' ) |N ) ) %==  true ) then
  begin
   ' ' 
  end // if
  %S |N 'FactoryManagerLocal' 
 end // if
//#UC END# *471F2C4B008Cfor470F71BF03C8*
; // base_fctr_mng_java


// перекрытие базового стереотипа AbstractInterface::Class
// что это ??? (C++)
//%f _publish_self_cpp
: publish_self_cpp OBJECT IN %S
//#UC START# *471F2C4F03B9for470F71BF03C8*
//	void %SNFactoryManager::publish_self () {
 'void '
 %S |N 'FactoryManager::publish_self () {'
//	[{%S%f_has_exported_factory()=true}	if (Singleton::instance()-\>m_has_registred_factories) {
 if ( ( %S %f has_exported_factory %( )% ) %==  true ) then
 begin
  '	if (Singleton::instance()->m_has_registred_factories) {'
//			%SNFactoryManagerSrv_var ref = Singleton::instance()-\>_this();
  '		'
  %S |N 'FactoryManagerSrv_var ref = Singleton::instance()->_this();'
//			CoreSrv::bind_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), ref.in(), "%f_full_name(%S)");
  '		CoreSrv::bind_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), ref.in(), "'
  [%f] full_name %( %S )% ');'
//		}
  '	}'
//	]}\n\n
 end // if
 '}'#13#10#13#10
//#UC END# *471F2C4F03B9for470F71BF03C8*
; // publish_self_cpp


// перекрытие базового стереотипа AbstractInterface::Class
// что это?  (C++)
//%f _publish_self_h
: publish_self_h OBJECT IN %S
//#UC START# *471F2C52032Cfor470F71BF03C8*
//	\tstatic void publish_self ();\n\n
 #9'static void publish_self ();'#13#10#13#10
//#UC END# *471F2C52032Cfor470F71BF03C8*
; // publish_self_h


// перекрытие базового стереотипа AbstractInterface::Class
// что это?? (Java)
//%f _publish_self_java
: publish_self_java OBJECT IN %S
//#UC START# *471F2C56032Cfor470F71BF03C8*
//	\tpublic static void publishSelf () {
 #9'public static void publishSelf () {'
//	[{%S%f_has_exported_factory()=true}\t	if (%SNFactoryManager.%S%f_fctr_mng_get_instance_name()().hasRegistredFactories_) {
 if ( ( %S %f has_exported_factory %( )% ) %==  true ) then
 begin
  #9'	if ('
  %S |N 'FactoryManager.'
  %S %f fctr_mng_get_instance_name %( )% '().hasRegistredFactories_) {'
//	\t		try {
  #9'		try {'
//	\t			ru.garant.shared.CoreSrv.cos_naming_op.bindPath (
  #9'			ru.garant.shared.CoreSrv.cos_naming_op.bindPath ('
//	\t				<{}{%PM=Library::Category|%PM=ServerLibrary::Category}%f_dump_java_package(%P).%PN.LibHomeFactory>.get().getOrbFacet().getNsRoot()
  #9'				'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P |M ) %== 'Library::Category' OR 
    ( ( %P |M ) %== 'ServerLibrary::Category'  ) ) then
   begin
    [%f] dump_java_package %( %P )% '.'
    %P |N '.LibHomeFactory' 
    ++! l_Counter
   end // if
  end // for P
  '.get().getOrbFacet().getNsRoot()'
//	\t				, <{}{%PM=Library::Category|%PM=ServerLibrary::Category}%f_dump_java_package(%P).%PN.LibHomeFactory>.get().getOrbFacet().getRootPoa().servant_to_reference(%SNFactoryManager.%S%f_fctr_mng_get_instance_name()())
  #9'				, '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( %P |M ) %== 'Library::Category' OR 
    ( ( %P |M ) %== 'ServerLibrary::Category'  ) ) then
   begin
    [%f] dump_java_package %( %P )% '.'
    %P |N '.LibHomeFactory' 
    ++! l_Counter
   end // if
  end // for P
  '.get().getOrbFacet().getRootPoa().servant_to_reference('
  %S |N 'FactoryManager.'
  %S %f fctr_mng_get_instance_name %( )% '())'
//	\t				, "%f_full_name(%S)"
  #9'				, "'
  [%f] full_name %( %S )% 
//	\t			);
  #9'			);'
//	[<{}{}{%E}\
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%E
   begin
    OBJECT IN %E
    if true then
    begin
//	\t		} catch (%f_type(%E) ex) {
     #9'		} catch ('
     [%f] type %( %E )% ' ex) {'
//	\t			Logs.LOG_SEX(ex);
     #9'			Logs.LOG_SEX(ex);'
//	\t			throw ex;
     #9'			throw ex;'
//	>]\

     ++! l_Counter
    end // if
   end // for E
  end // if
  NOP
//	\t		} catch (Exception ex) {
  #9'		} catch (Exception ex) {'
//	\t			Logs.LOG_SEX(ex);
  #9'			Logs.LOG_SEX(ex);'
//	\t			throw new org.omg.CORBA.portable.UnknownException (ex);
  #9'			throw new org.omg.CORBA.portable.UnknownException (ex);'
//	\t		}
  #9'		}'
//	\t	}
  #9'	}'
//	\t]}\n\n
  #9 
 end // if
 '}'#13#10#13#10
//#UC END# *471F2C56032Cfor470F71BF03C8*
; // publish_self_java


// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for470F71BF03C8*
//c                                                                                                           {}
//r "%f_has_factory_methods(%S)"="false"&"%Sa"!="abstract"&<{}{%LS=LocalInterface}{%LC}>=0:                   {Not abstract %SS must provide at least one factory}
//r {"<{}{%GS!=%SS}{C}>"!="0"}:                                                                               {%SS can inherit only from other %SS}
//r {"<{}{%RS!=ServerFacet}{C}>"!="0"}:                                                                       {%SS can realize only ServerFacet}
//r {<{}{%CC=Operation&%CS=multi factory}{%CC}>!=0&%f_factory_switch_count(%S)=0}:                            {%SS определяющий мульти-фабрику должен определять селектор !%f_factory_switch_count(%S)!}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}:                                        {имя %SS, используемого в качестве серверного типа, не должно совпадать с именем родителя}
//r {<{}{%P{Full MDP}=true}{C}>!=0&<{}{%aS=UseCase}{C}>=0}:                                                   {%SS не используется ни одним прецедентом}
//r {%Sa=abstract&<{}{%SM=%ZM}{C}>=0&<{}{%SM=%LM}{C}>=0}:                                                     {Абстрактный %SS должен иметь наследников}
//#UC END# *4704C0E30186for470F71BF03C8*
; // constraint


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor470F71BF03C8*
//	%f_set_var(SERV,S)\
 [%f] set_var %( 'SERV' %, 'S' )% 
//	[{%f_has_factory_methods(%S)=true}\
 if ( ( [%f] has_factory_methods %( %S )% ) %==  true ) then
 begin
//	[{%S%f_has_exported_factory()=true}\
  if ( ( %S %f has_exported_factory %( )% ) %==  true ) then
  begin
//	Core::Mutex %SNFactory::s_init_mutex;
   'Core::Mutex '
   %S |N 'Factory::s_init_mutex;'
//	bool %SNFactory::s_renew_mode = false;
   'bool '
   %S |N 'Factory::s_renew_mode = false;'
//	[<{}{"%f_is_it_cached(%C)"="true"&[{%CS=factory|%CS=multi factory}{false}true]=true&%C%f_is_exported()=true}{%C}Core::Mutex %SNFactory::s_mutex_for_%CN;[{[{%C<{}{%CS!=cache}{%CC}>!=0}{false}true]=false}
   if NOT-EMPTY
   begin
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( [%f] is_it_cached %( %C )% ) %== true AND 
      ( if ( ( %C |S ) %== 'factory' OR 
       ( ( %C |S ) %== 'multi factory'  ) ) then
     begin
       true 
     end // if
     else
     begin
       false 
     end // else
     %==  true  ) AND 
      ( ( %C %f is_exported %( )% ) %==  true  ) ) then
     begin
      'Core::Mutex '
      %S |N 'Factory::s_mutex_for_'
      %C |N ';'
      if ( if ( ( %C
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%C
         begin
          OBJECT IN %C
          if ( ( %C |S ) %!= 'cache' ) then
          begin

           ++! l_Counter
          end // if
         end // for C
         l_Counter

        ) // bind
 )         %!= 0 ) then
       begin
         true 
       end // if
       else
       begin
         false 
       end // else
       %==  false ) then
      begin
       #13#10

//	CORBA::ULong %SNFactory::s_cached_object_hash_for_%CN = 0;]
       'CORBA::ULong '
       %S |N 'Factory::s_cached_object_hash_for_'
       %C |N ' = 0;' 
      end // if
//	>

      ++! l_Counter
     end // if
    end // for C
//	]][{%S%f_has_multi_factory()=true&%Sa!=abstract}
   end // if
   NOP
  end // if
  if ( ( %S %f has_multi_factory %( )% ) %==  true AND 
    ( ( %S |a ) %!= 'abstract'  ) ) then
  begin
   #13#10

//	%S%f_dump_interface_factory_keys_method()
   %S %f dump_interface_factory_keys_method %( )% 
//	
   #13#10

//	][
  end // if
  if NOT-EMPTY
  begin
   #13#10

//	%f_set_var(INT,S)<{}{"%CS"="factory"}%CX
   [%f] set_var %( 'INT' %, 'S' )% 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'factory' ) then
    begin
     %C |X 
//	
     #13#10

//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"}%CX

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'factory' ) then
       begin
        %C |X 
//	
        #13#10

//	>>][<{}{"%CS"="multi factory"}%CX

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'multi factory' ) then
    begin
     %C |X 
//	
     #13#10

//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"}%CX

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'multi factory' ) then
       begin
        %C |X 
//	
        #13#10

//	>>][

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
  if NOT-EMPTY
  begin
   #13#10

//	%f_set_var(INT,S)<{}{"%CS"="remover"}%CX
   [%f] set_var %( 'INT' %, 'S' )% 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'remover' ) then
    begin
     %C |X 
//	
     #13#10

//	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"}%CX

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'remover' ) then
       begin
        %C |X 
//	
        #13#10

//	>>]]

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
 end // if
//#UC END# *47022CB8034Bfor470F71BF03C8*
; // cpp


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor470F71BF03C8*
//	%f_set_var(SERV,S)\
 [%f] set_var %( 'SERV' %, 'S' )% 
//	%f_dump_factory(%S)[{%S%f_has_non_exported_factory()=true}
 [%f] dump_factory %( %S )% if ( ( %S %f has_non_exported_factory %( )% ) %==  true ) then
 begin
  #13#10

//	
  #13#10

//	// additional interface for private factories implementation
  '// additional interface for private factories implementation'
//	class %SNFactoryManagerLocal {
  'class '
  %S |N 'FactoryManagerLocal {'
//		friend class %SNFactory;
  '	friend class '
  %S |N 'Factory;'
//	private:<{}{"%CS"="factory"&%C%f_is_exported()=false}{%C}
  'private:'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' AND 
    ( ( %C %f is_exported %( )% ) %==  false  ) ) then
   begin
    #13#10

//		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%C#f_is_exported()=false}%Cs]") %CN (%C<{, }%CX>) /*throw (Core::Root::NoActiveFactory%C<, %f_type(%E)>)*/ = 0;
    '	virtual '
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
      ( ( %C %?f is_exported %( )% ) %==  false  ) ) then
    begin
     %C |s 
    end // if
)%     ' '
    %C |N ' ('
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       if ( l_Counter >0 ) then ( ', ' )
       %C |X 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     ') /*throw (Core::Root::NoActiveFactory'
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       ', '
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E

    ) // bind
     ')*/ = 0;'
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&%C#f_is_exported()=false}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'factory' AND 
       ( ( %C %?f is_exported %( )% ) %==  false  ) ) then
      begin
       #13#10

//		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%C#f_is_exported()=false}%Cs]") %CN (%C<{, }%CX>) /*throw (Core::Root::NoActiveFactory%C<, %f_type(%E)>)*/ = 0;
       '	virtual '
       [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
         ( ( %C %?f is_exported %( )% ) %==  false  ) ) then
       begin
        %C |s 
       end // if
)%        ' '
       %C |N ' ('
       %C
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%C
        begin
         OBJECT IN %C
         if true then
         begin
          if ( l_Counter >0 ) then ( ', ' )
          %C |X 
          ++! l_Counter
         end // if
        end // for C

       ) // bind
        ') /*throw (Core::Root::NoActiveFactory'
       %C
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%E
        begin
         OBJECT IN %E
         if true then
         begin
          ', '
          [%f] type %( %E )% 
          ++! l_Counter
         end // if
        end // for E

       ) // bind
        ')*/ = 0;'
//	>><{}{"%CS"="multi factory"&%C%f_is_exported()=false}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'multi factory' AND 
    ( ( %C %f is_exported %( )% ) %==  false  ) ) then
   begin
    #13#10

//		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%C#f_is_exported()=false}%Cs]") %CN (%C<%CX, >const char* key) /*throw (Core::Root::UnknownFactoryKey%C<, %f_type(%E)>)*/ = 0;
    '	virtual '
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
      ( ( %C %?f is_exported %( )% ) %==  false  ) ) then
    begin
     %C |s 
    end // if
)%     ' '
    %C |N ' ('
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       %C |X ', ' 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     'const char* key) /*throw (Core::Root::UnknownFactoryKey'
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       ', '
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E

    ) // bind
     ')*/ = 0;'
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&%C#f_is_exported()=false}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'multi factory' AND 
       ( ( %C %?f is_exported %( )% ) %==  false  ) ) then
      begin
       #13#10

//		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%Cs]") %CN (%C<%CX, >const char* key) /*throw (Core::Root::UnknownFactoryKey%C<, %f_type(%E)>)*/ = 0;
       '	virtual '
       [%t] ret %( ( get_global_var ( 'INT' ) ) %, if ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' OR 
         ( ( %S %?f is_exported %( )% ) %==  false  ) ) then
       begin
        %C |s 
       end // if
)%        ' '
       %C |N ' ('
       %C
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%C
        begin
         OBJECT IN %C
         if true then
         begin
          %C |X ', ' 
          ++! l_Counter
         end // if
        end // for C

       ) // bind
        'const char* key) /*throw (Core::Root::UnknownFactoryKey'
       %C
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%E
        begin
         OBJECT IN %E
         if true then
         begin
          ', '
          [%f] type %( %E )% 
          ++! l_Counter
         end // if
        end // for E

       ) // bind
        ')*/ = 0;'
//	>><{}{"%CS"="remover"&%C%f_is_exported()=false}{%C}

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'remover' AND 
    ( ( %C %f is_exported %( )% ) %==  false  ) ) then
   begin
    #13#10

//		virtual void %CN (%t_arg(%{INT},"in")%C<, %CX>) /*throw (RootSrv::ForeignObject%C<, %f_type(%E)>)*/ = 0;
    '	virtual void '
    %C |N ' ('
    [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if true then
      begin
       ', '
       %C |X 
       ++! l_Counter
      end // if
     end // for C

    ) // bind
     ') /*throw (RootSrv::ForeignObject'
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%E
     begin
      OBJECT IN %E
      if true then
      begin
       ', '
       [%f] type %( %E )% 
       ++! l_Counter
      end // if
     end // for E

    ) // bind
     ')*/ = 0;'
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"&%C#f_is_exported()=false}{%C}

    ++! l_Counter
   end // if
  end // for C
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if ( ( %g |a ) %== 'abstract' ) then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |S ) %== 'remover' AND 
       ( ( %C %?f is_exported %( )% ) %==  false  ) ) then
      begin
       #13#10

//		virtual void %CN (%t_arg(%{INT},"in")%C<, %CX>) /*throw (RootSrv::ForeignObject%C<, %f_type(%E)>)*/ = 0;
       '	virtual void '
       %C |N ' ('
       [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% %C
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%C
        begin
         OBJECT IN %C
         if true then
         begin
          ', '
          %C |X 
          ++! l_Counter
         end // if
        end // for C

       ) // bind
        ') /*throw (RootSrv::ForeignObject'
       %C
       bind ( 
        OBJECT VAR %S
        INTEGER VAR l_Counter l_Counter := 0
        for %S%E
        begin
         OBJECT IN %E
         if true then
         begin
          ', '
          [%f] type %( %E )% 
          ++! l_Counter
         end // if
        end // for E

       ) // bind
        ')*/ = 0;'
//	>>};]

       ++! l_Counter
      end // if
     end // for C

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
  '};' 
 end // if
//#UC END# *47022C88029Ffor470F71BF03C8*
; // h


// перекрытие базового стереотипа C++ Фабрики::MDAGenerator
// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for470F71BF03C8*
//= AbstractInterface::Class;fctr.cpp
%call-other-gen ( 'AbstractInterface' 'fctr.cpp' )
//#UC END# *4705C54B01F4for470F71BF03C8*
; // fctr.cpp


// перекрытие базового стереотипа C++ Фабрики::MDAGenerator
// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for470F71BF03C8*
//= AbstractInterface::Class;fctr.h
%call-other-gen ( 'AbstractInterface' 'fctr.h' )
//#UC END# *4705C5490109for470F71BF03C8*
; // fctr.h


// перекрытие базового стереотипа CORBA IDL::MDAGenerator
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for470F71BF03C8*
//F [{"%Sa"="abstract"}abstract ]interface %SN;
//	<#%FF
 INTEGER VAR l_Counter l_Counter := 0
 for %S%F
 begin
  OBJECT IN %F
  if true then
  begin
   out_indent %F |F 
//	>%f_docs(%S)\

   ++! l_Counter
  end // if
 end // for F
 [%f] docs %( %S )% 
//	#[{"%Sa"="abstract"}abstract ]interface %SN[: <{, }%f_type(%G)>] {<{}{%f_is_factory(%C)=false}[
 out_indent if ( ( %S |a ) %== 'abstract' ) then
 begin
  'abstract ' 
 end // if
 'interface '
 %S |N if NOT-EMPTY
 begin
  ': '
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    [%f] type %( %G )% 
    ++! l_Counter
   end // if
  end // for G
 end // if
 NOP
 ' {'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( [%f] is_factory %( %C )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    #13#10

//	%CX]>[{<{}{%f_is_factory(%C)=true&%C{const_type}=combo}{%CC}>!=0}
    %C |X 
   end // if
   NOP

   ++! l_Counter
  end // if
 end // for C
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] is_factory %( %C )% ) %==  true AND 
    ( ( %C get_up ( 'const_type' ) ) %== 'combo'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
  #13#10

//	#	void upgrade_rw ();]
  out_indent '	void upgrade_rw ();' 
 end // if
//	#};[{%S%f_has_exported_factory(%S)=true}
 out_indent '};'
 if ( ( %S %f has_exported_factory %( %S )% ) %==  true ) then
 begin
  #13#10

//	
  #13#10

//	[{%S%f_has_multi_factory()=true&%Sa!=abstract}%f_set_var(SWITCH,"")%S%f_find_switch("SWITCH")\
  if ( ( %S %f has_multi_factory %( )% ) %==  true AND 
    ( ( %S |a ) %!= 'abstract'  ) ) then
  begin
   [%f] set_var %( 'SWITCH' %, '' )% %S %f find_switch %( 'SWITCH' )% 
//	#typedef sequence\<[{%{SWITCH}%TN!=a-string}{string}%f_type(%{SWITCH}%T)]\> %SNFactoryKeySet;
   out_indent 'typedef sequence<'
   if ( ( ( get_global_var ( 'SWITCH' )  ->T |N ) ) %!= 'a-string' ) then
   begin
    [%f] type %( ( get_global_var ( 'SWITCH' )  ->T ) )% 
   end // if
   else
   begin
    'string' 
   end // else
   '> '
   %S |N 'FactoryKeySet;'
//	
   #13#10

//	]#// factory manager server interface for %SN
  end // if
  out_indent '// factory manager server interface for '
  %S |N 
//	#interface %SNFactoryManagerSrv {
  out_indent 'interface '
  %S |N 'FactoryManagerSrv {'
//	[{%S%f_has_multi_factory()=true&%Sa!=abstract}#	//возвращает список ключей зарегистрированных реализаций интерфейса
  if ( ( %S %f has_multi_factory %( )% ) %==  true AND 
    ( ( %S |a ) %!= 'abstract'  ) ) then
  begin
   out_indent '	//возвращает список ключей зарегистрированных реализаций интерфейса'
//	#	%SNFactoryKeySet keys ();
   out_indent '	'
   %S |N 'FactoryKeySet keys ();'
//	
   #13#10

//	][%f_set_var(INT,S)<{}{%CS=factory&%C#f_is_exported()=true}%CX
  end // if
  if NOT-EMPTY
  begin
   [%f] set_var %( 'INT' %, 'S' )% 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'factory' AND 
     ( ( %C %?f is_exported %( )% ) %==  true  ) ) then
    begin
     %C |X 
//	
     #13#10

//	><{}{%ga=abstract}%g<{}{%CS=factory&%C#f_is_exported()=true}!!%CX

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'factory' AND 
        ( ( %C %?f is_exported %( )% ) %==  true  ) ) then
       begin
        '!!'
        %C |X 
//	
        #13#10

//	>>][<{}{%CS=multi factory&%C#f_is_exported()=true}%CX

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'multi factory' AND 
     ( ( %C %?f is_exported %( )% ) %==  true  ) ) then
    begin
     %C |X 
//	
     #13#10

//	><{}{%ga=abstract}%g<{}{%CS=multi factory&%C#f_is_exported()=true}%CX

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'multi factory' AND 
        ( ( %C %?f is_exported %( )% ) %==  true  ) ) then
       begin
        %C |X 
//	
        #13#10

//	>>]#};]

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
  out_indent '};' 
 end // if
//#UC END# *47022BBE0261for470F71BF03C8*
; // idl


// перекрытие базового стереотипа Java::MDAGenerator
// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor470F71BF03C8*
//= AbstractInterface::Class;fctr.java
%call-other-gen ( 'AbstractInterface' 'fctr.java' )

//%f _dump_fmng_keys_method
; // fctr.java

: dump_fmng_keys_method OBJECT IN %S
//	[{%XU=fctr.java}%f_set_var(SWITCH,"")%S%f_find_switch("SWITCH")\
 if ( ( %X |U ) %== 'fctr.java' ) then
 begin
  [%f] set_var %( 'SWITCH' %, '' )% %S %f find_switch %( 'SWITCH' )% 
//	#public %f_type(%{SWITCH}%T)\[\] keys () {
  out_indent 'public '
  [%f] type %( ( get_global_var ( 'SWITCH' )  ->T ) )% '[] keys () {'
//	#	return factoriesMap_.keySet ().toArray (new %f_type(%{SWITCH}%T)\[0\]);
  out_indent '	return factoriesMap_.keySet ().toArray (new '
  [%f] type %( ( get_global_var ( 'SWITCH' )  ->T ) )% '[0]);'
//	#}][{%XU=fctr.h}#%SNFactoryKeySet* keys ();][{%XU=fctr.cpp}%f_set_var(SWITCH,"")%S%f_find_switch("SWITCH")\
  out_indent '}' 
 end // if
 if ( ( %X |U ) %== 'fctr.h' ) then
 begin
  out_indent %S |N 'FactoryKeySet* keys ();' 
 end // if
 if ( ( %X |U ) %== 'fctr.cpp' ) then
 begin
  [%f] set_var %( 'SWITCH' %, '' )% %S %f find_switch %( 'SWITCH' )% 
//	%SNFactoryKeySet* %SNFactoryManager::keys () {
  %S |N 'FactoryKeySet* '
  %S |N 'FactoryManager::keys () {'
//		%SNFactoryKeySet_var list (new %SNFactoryKeySet (m_factories_map.size ()));
  '	'
  %S |N 'FactoryKeySet_var list (new '
  %S |N 'FactoryKeySet (m_factories_map.size ()));'
//		size_t i = 0;
  '	size_t i = 0;'
//		for (FactoryMap::iterator it = m_factories_map.begin (); it != m_factories_map.end (); ++it) {
  '	for (FactoryMap::iterator it = m_factories_map.begin (); it != m_factories_map.end (); ++it) {'
//			(*list)\[i++\] = it-\>first[{%{SWITCH}%TN=a-string|%{SWITCH}%TN=string}.c_str ()];
  '		(*list)[i++] = it->first'
  if ( ( ( get_global_var ( 'SWITCH' )  ->T |N ) ) %== 'a-string' OR 
    ( ( ( get_global_var ( 'SWITCH' )  ->T |N ) ) %== 'string'  ) ) then
  begin
   '.c_str ()' 
  end // if
  ';'
//		}
  '	}'
//		
  '	'
//		return list._retn ();
  '	return list._retn ();'
//	}]
  '}' 
 end // if
//#UC END# *470321C1038Afor470F71BF03C8*
; // dump_fmng_keys_method


// перекрытие базового стереотипа Java::MDAGenerator
// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for470F71BF03C8*
//O %SNFactory.java
//	%f_output_constraint(%S)\
 [%f] output_constraint %( %S )% 
//	%f_header(%S)
 [%f] header %( %S )% 
//	%f_set_var(INT,S)package %f_dump_java_package(%S);
 [%f] set_var %( 'INT' %, 'S' )% 'package '
 [%f] dump_java_package %( %S )% ';'
//	
//	%f_dump_std_java_imports(%S)
 [%f] dump_std_java_imports %( %S )% 
//	
//	<{}{"%iC"!="Category"}{%i}%f_java_import(%i)
//	><{}{"%f_set_var(ARG,C)%{INT}<{}{%iU=%{ARG}%TU}{C}>"="0"&%CC=Attribute&%C%TM!=UMLPrimitive::Class&%f_can_dump_attr(%C%T)=true}{%C}%f_java_import(%C%T)
//	>
//	[{"%f_has_factory_methods(%S)"="true"}%f_java_core_exceptions(%S)
 if ( ( [%f] has_factory_methods %( %S )% ) %== true ) then
 begin
  [%f] java_core_exceptions %( %S )% 
//	][{%f_is_server_type(%S)=true}
 end // if
 if ( ( [%f] is_server_type %( %S )% ) %==  true ) then
 begin
  #13#10

//	import %f_dump_java_package(%P).%P%P%f_name_prefix()LibHomeFactory;
  'import '
  [%f] dump_java_package %( %P )% '.'
  %P ->P %f name_prefix %( )%  'LibHomeFactory;'
//	]
 end // if
//	%t_visibility(%S,"%XU")class %SNFactory {
 [%t] visibility %( %S %, %X |U )% 'class '
 %S |N 'Factory {'
//	[{"%f_has_factory_methods(%S)"="true"}%f_set_var(FACTORY_PARENT,S)
 if ( ( [%f] has_factory_methods %( %S )% ) %== true ) then
 begin
  [%f] set_var %( 'FACTORY_PARENT' %, 'S' )% 
//	[{%S%f_has_multi_factory()=true}
  if ( ( %S %f has_multi_factory %( )% ) %==  true ) then
  begin
   #13#10

//		
   '	'
//	%f_shift_intend(1)%S%f_dump_interface_factory_keys_method()%f_shift_intend(-1)
   [%f] shift_intend %( 1 )% %S %f dump_interface_factory_keys_method %( )% [%f] shift_intend %( -1 )% 
//	][<{}{%aS=friend&%aC=Dependency}{Sp}%a%P<	friend class %f_type(%L); // friend's servants
  end // if
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%ap
   begin
    OBJECT IN %a
    if ( ( %a |S ) %== 'friend' AND 
     ( ( %a |C ) %== 'Dependency'  ) ) then
    begin
     %a ->P
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%L
      begin
       OBJECT IN %L
       if true then
       begin
        '	friend class '
        [%f] type %( %L )% '; // friend's servants'
//	>><{}{"%ga"="abstract"}%g<{}{"%aM"="Interface::Class::friend::ClassDependency"}{Sp}%a%P<	friend class %f_type(%L); // friend's servants

        ++! l_Counter
       end // if
      end // for L

     ) // bind
  
     ++! l_Counter
    end // if
   end // for a
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%ap
      begin
       OBJECT IN %a
       if ( ( %a |M ) %== 'Interface::Class::friend::ClassDependency' ) then
       begin
        %a ->P
        bind ( 
         OBJECT VAR %S
         INTEGER VAR l_Counter l_Counter := 0
         for %S%L
         begin
          OBJECT IN %L
          if true then
          begin
           '	friend class '
           [%f] type %( %L )% '; // friend's servants'
//	>>>

           ++! l_Counter
          end // if
         end // for L

        ) // bind
  
        ++! l_Counter
       end // if
      end // for a

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
//	][%f_set_var(INT,S)<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}
  end // if
  NOP
  if NOT-EMPTY
  begin
   [%f] set_var %( 'INT' %, 'S' )% 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'factory' AND 
     ( ( %C |V ) %== 'PublicAccess'  ) ) then
    begin
     #13#10

//	%CX
     %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'factory' AND 
        ( ( %C |V ) %== 'PublicAccess'  ) ) then
       begin
        #13#10

//	%CX
        %C |X 
//	>>][<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'factory' AND 
     ( ( %C |V ) %!= 'PublicAccess'  ) ) then
    begin
     #13#10

//	%CX
     %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'factory' AND 
        ( ( %C |V ) %!= 'PublicAccess'  ) ) then
       begin
        #13#10

//	%CX
        %C |X 
//	>>][<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'multi factory' AND 
     ( ( %C |V ) %== 'PublicAccess'  ) ) then
    begin
     #13#10

//	%CX
     %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'multi factory' AND 
        ( ( %C |V ) %== 'PublicAccess'  ) ) then
       begin
        #13#10

//	%CX
        %C |X 
//	>>][<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'multi factory' AND 
     ( ( %C |V ) %!= 'PublicAccess'  ) ) then
    begin
     #13#10

//	%CX
     %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}

     ++! l_Counter
    end // if
   end // for C
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if ( ( %g |a ) %== 'abstract' ) then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |S ) %== 'multi factory' AND 
        ( ( %C |V ) %!= 'PublicAccess'  ) ) then
       begin
        #13#10

//	%CX
        %C |X 
//	>>]%S%f_additional_fctr_def_java()

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
  end // if
  NOP
  %S %f additional_fctr_def_java %( )% 
//	]
 end // if
//	} //interface %SNFactory
 '} //interface '
 %S |N 'Factory'

//%f _dump_interface_factory_keys_method
; // java

: dump_interface_factory_keys_method OBJECT IN %S
//	[{%XU=java}#public static %S%f_dump_switch_type()\[\] keys () throws ru.garant.shared.CoreSrv.ForeignObject {
 if ( ( %X |U ) %== 'java' ) then
 begin
  out_indent 'public static '
  %S %f dump_switch_type %( )% '[] keys () throws ru.garant.shared.CoreSrv.ForeignObject {'
//	#	if (FactoryManagerSrvSingleton.getInstance() == null) {
  out_indent '	if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
  out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			try {
  out_indent '			try {'
//	#				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath (
  out_indent '				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath ('
//	#					LibHomeFactory.get().getOrbFacet().getNsRoot(), "%f_full_name(%S)"
  out_indent '					LibHomeFactory.get().getOrbFacet().getNsRoot(), "'
  [%f] full_name %( %S )% 
//	#				);
  out_indent '				);'
//	#				FactoryManagerSrvSingleton.setInstance(%SNFactoryManagerSrvHelper.narrow (obj));
  out_indent '				FactoryManagerSrvSingleton.setInstance('
  %S |N 'FactoryManagerSrvHelper.narrow (obj));'
//	#			} catch (java.lang.Exception ex) {
  out_indent '			} catch (java.lang.Exception ex) {'
//	#				Logs.LOG_SEX (ex);
  out_indent '				Logs.LOG_SEX (ex);'
//	#			}
  out_indent '			}'
//	#			if (FactoryManagerSrvSingleton.getInstance() == null) {
  out_indent '			if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#				throw new ru.garant.shared.CoreSrv.ForeignObject ();
  out_indent '				throw new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#			}
  out_indent '			}'
//	#		}
  out_indent '		}'
//	#	}
  out_indent '	}'
//	#	try {
  out_indent '	try {'
//	#		return FactoryManagerSrvSingleton.getInstance().keys ();
  out_indent '		return FactoryManagerSrvSingleton.getInstance().keys ();'
//	#	} catch (org.omg.CORBA.TRANSIENT ex) {
  out_indent '	} catch (org.omg.CORBA.TRANSIENT ex) {'
//	#		if (sRenewMode) {
  out_indent '		if (sRenewMode) {'
//	#			sRenewMode = false;
  out_indent '			sRenewMode = false;'
//	#			Logs.LOG_W ("WARNING: %SNFactoryManagerSrv is in invalid (inactive) state");
  out_indent '			Logs.LOG_W ("WARNING: '
  %S |N 'FactoryManagerSrv is in invalid (inactive) state");'
//	#			throw  new ru.garant.shared.CoreSrv.ForeignObject ();
  out_indent '			throw  new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#		}
  out_indent '		}'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
  out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			Logs.LOG_D ("DEBUG: Try to renew %SNFactoryManagerSrv");
  out_indent '			Logs.LOG_D ("DEBUG: Try to renew '
  %S |N 'FactoryManagerSrv");'
//	#			sRenewMode = true;
  out_indent '			sRenewMode = true;'
//	#			FactoryManagerSrvSingleton.setInstance (null);
  out_indent '			FactoryManagerSrvSingleton.setInstance (null);'
//	#			%S%f_dump_switch_type()\[\] ret = keys ();
  out_indent '			'
  %S %f dump_switch_type %( )% '[] ret = keys ();'
//	#			sRenewMode = false;
  out_indent '			sRenewMode = false;'
//	#			return ret;
  out_indent '			return ret;'
//	#		}
  out_indent '		}'
//	#	}
  out_indent '	}'
//	#}][{%XU=h}#%SNFactoryKeySet* keys (); /*throw (CoreSrv::ForeignObject)*/]\
  out_indent '}' 
 end // if
 if ( ( %X |U ) %== 'h' ) then
 begin
  out_indent %S |N 'FactoryKeySet* keys (); /*throw (CoreSrv::ForeignObject)*/' 
 end // if
//	[{%XU=cpp}%SNFactoryKeySet* %SNFactory::keys () /*throw (CoreSrv::ForeignObject)*/ {
 if ( ( %X |U ) %== 'cpp' ) then
 begin
  %S |N 'FactoryKeySet* '
  %S |N 'Factory::keys () /*throw (CoreSrv::ForeignObject)*/ {'
//		if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
  '	if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//			GUARD (s_init_mutex);
  '		GUARD (s_init_mutex);'
//			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
  '		if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//				try {
  '			try {'
//					CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "%f_full_name(%S)");
  '				CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "'
  [%f] full_name %( %S )% ');'
//					*FactoryManagerSrvSingleton::instance() = %SNFactoryManagerSrv::_narrow (obj);
  '				*FactoryManagerSrvSingleton::instance() = '
  %S |N 'FactoryManagerSrv::_narrow (obj);'
//				} CATCH_AND_LOG ("COS Naming can't find FactoryManagerSrv for %SN");
  '			} CATCH_AND_LOG ("COS Naming can''t find FactoryManagerSrv for '
  %S |N ');'
//			}
  '		}'
//			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
  '		if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//				throw CoreSrv::ForeignObject ();
  '			throw CoreSrv::ForeignObject ();'
//			}
  '		}'
//		}
  '	}'


//		try {
  '	try {'
//			return (*FactoryManagerSrvSingleton::instance())-\>keys ();
  '		return (*FactoryManagerSrvSingleton::instance())->keys ();'
//		} catch (CORBA::TRANSIENT& ) {
  '	} catch (CORBA::TRANSIENT& ) {'
//			if (s_renew_mode) {
  '		if (s_renew_mode) {'
//				s_renew_mode = false;
  '			s_renew_mode = false;'
//				LOG_W (("%SNFactoryManagerSrv is in invalid (inactive) state"));
  '			LOG_W (("'
  %S |N 'FactoryManagerSrv is in invalid (inactive) state"));'
//				throw CoreSrv::ForeignObject ();
  '			throw CoreSrv::ForeignObject ();'
//			}
  '		}'
//			GUARD (s_init_mutex);
  '		GUARD (s_init_mutex);'
//			LOG_D (("Try to renew %SNFactoryManagerSrv"));
  '		LOG_D (("Try to renew '
  %S |N 'FactoryManagerSrv"));'
//			
  '		'
//			s_renew_mode = true;
  '		s_renew_mode = true;'
//			(*FactoryManagerSrvSingleton::instance()) = 0;
  '		(*FactoryManagerSrvSingleton::instance()) = 0;'
//			%SNFactoryKeySet* ret = keys ();
  '		'
  %S |N 'FactoryKeySet* ret = keys ();'
//			s_renew_mode = false;
  '		s_renew_mode = false;'
//			
  '		'
//			return ret;
  '		return ret;'
//		} catch (CORBA::OBJECT_NOT_EXIST& ) {
  '	} catch (CORBA::OBJECT_NOT_EXIST& ) {'
//			if (s_renew_mode) {
  '		if (s_renew_mode) {'
//				s_renew_mode = false;
  '			s_renew_mode = false;'
//				LOG_W (("%SNFactoryManagerSrv is in invalid (inactive) state"));
  '			LOG_W (("'
  %S |N 'FactoryManagerSrv is in invalid (inactive) state"));'
//				throw CoreSrv::ForeignObject ();
  '			throw CoreSrv::ForeignObject ();'
//			}
  '		}'
//			GUARD (s_init_mutex);
  '		GUARD (s_init_mutex);'
//			LOG_D (("Try to renew %SNFactoryManagerSrv"));
  '		LOG_D (("Try to renew '
  %S |N 'FactoryManagerSrv"));'
//			
  '		'
//			s_renew_mode = true;
  '		s_renew_mode = true;'
//			(*FactoryManagerSrvSingleton::instance()) = 0;
  '		(*FactoryManagerSrvSingleton::instance()) = 0;'
//			%SNFactoryKeySet* ret = keys ();
  '		'
  %S |N 'FactoryKeySet* ret = keys ();'
//			s_renew_mode = false;
  '		s_renew_mode = false;'
//			
  '		'
//			return ret;
  '		return ret;'
//		}
  '	}'
//	}]
  '}' 
 end // if
//#UC END# *470321950119for470F71BF03C8*
; // dump_interface_factory_keys_method


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: ServerInterface::Class::remover::Operation
end. // <<ServerInterface>>

implementation @ :: <<ServerInterface>> <<remover>> ;
//? Уничтожитель
//? Метод обратный фабричному, т.е. метод приводящий к разрушению (временному или постоянному) созданного фабрикой объекта.
//= ServerFactoryOperationInternal::Class
//= InterfaceGeneratorWithJava::MDAGenerator

// Параметры стереотипа
//e g
// - возможность использовать исключения
//Y code_remover.gif
//L code_remover
//T 
// - может не иметь "цели" (типа/результата)
//m f
// - не может быть реализован/иметь перекрытую реализацию
//A
// - стереотипы "цели" (типа/результата)

// Генераторы
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor471F1823007D*
//#UC END# *47022C88029Ffor471F1823007D*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor471F1823007D*
//#UC END# *47022CB8034Bfor471F1823007D*
; // cpp


// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for471F1823007D*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#void %SN (<{, }%CX>)
 out_indent 'void '
 %S |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |X 
   ++! l_Counter
  end // if
 end // for C
 ')'
//	#	raises (CoreSrv::ForeignObject<, %f_type(%E)>);
 out_indent '	raises (CoreSrv::ForeignObject'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   ', '
   [%f] type %( %E )% 
   ++! l_Counter
  end // if
 end // for E
 ');'
//#UC END# *47022BBE0261for471F1823007D*
; // idl


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for471F1823007D*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#%t_visibility(%S,"%XU")static void %SN (%t_arg(%{INT},"in") obj_<, %f_arg_full_decl(%C)>) throws ru.garant.shared.CoreSrv.ForeignObject<, %f_type(%E)> {
 out_indent [%t] visibility %( %S %, %X |U )% 'static void '
 %S |N ' ('
 [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj_'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 ') throws ru.garant.shared.CoreSrv.ForeignObject'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   ', '
   [%f] type %( %E )% 
   ++! l_Counter
  end // if
 end // for E
 ' {'
//	#	if (FactoryManagerSrvSingleton.getInstance() == null) {
 out_indent '	if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
 out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			try {
 out_indent '			try {'
//	#				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath (
 out_indent '				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath ('
//	#					LibHomeFactory.get().getOrbFacet().getNsRoot(), "%f_full_name(%{INT})"
 out_indent '					LibHomeFactory.get().getOrbFacet().getNsRoot(), "'
 [%f] full_name %( ( get_global_var ( 'INT' ) ) )% '"'
//	#				);
 out_indent '				);'
//	#				FactoryManagerSrvSingleton.setInstance(%{INT}NFactoryManagerSrvHelper.narrow (obj));
 out_indent '				FactoryManagerSrvSingleton.setInstance('
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrvHelper.narrow (obj));'
//	#			} catch (java.lang.Exception ex) {
 out_indent '			} catch (java.lang.Exception ex) {'
//	#				Logs.LOG_SEX (ex);
 out_indent '				Logs.LOG_SEX (ex);'
//	#			}
 out_indent '			}'
//	#			if (FactoryManagerSrvSingleton.getInstance() == null) {
 out_indent '			if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#				throw new ru.garant.shared.CoreSrv.ForeignObject ();
 out_indent '				throw new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#			}
 out_indent '			}'
//	#		}
 out_indent '		}'
//	#	}
 out_indent '	}'
//	[{%SV!=PublicAccess}
 if ( ( %S |V ) %!= 'PublicAccess' ) then
 begin
  #13#10

//	#	%f_type(%{INT})FactoryManagerLocal lsrv = null;
  out_indent '	'
  [%f] type %( ( get_global_var ( 'INT' ) ) )% 'FactoryManagerLocal lsrv = null;'
//	#	try {
  out_indent '	try {'
//	#		org.omg.PortableServer.Servant srv = LibHomeFactory::get().getOrbFacet().getRootPoa().reference_to_servant (FactoryManagerSrvSingleton.getInstance());
  out_indent '		org.omg.PortableServer.Servant srv = LibHomeFactory::get().getOrbFacet().getRootPoa().reference_to_servant (FactoryManagerSrvSingleton.getInstance());'
//	#		lsrv = (%f_type(%{INT})FactoryManagerLocal)srv;
  out_indent '		lsrv = ('
  [%f] type %( ( get_global_var ( 'INT' ) ) )% 'FactoryManagerLocal)srv;'
//	#	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {
  out_indent '	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {'
//	#		Logs.LOG_SEX (ex);
  out_indent '		Logs.LOG_SEX (ex);'
//	#	}
  out_indent '	}'
//	#	if (lsrv == null) {
  out_indent '	if (lsrv == null) {'
//	#		throw new ru.garant.shared.CoreSrv.ForeignObject ();
  out_indent '		throw new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#	}]
  out_indent '	}' 
 end // if
//	#	try {
 out_indent '	try {'
//	#		Integer objHash_ = new Integer ([{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%f_to_java(%SN) (obj_<, %f_to_java(%CN)>));
 out_indent '		Integer objHash_ = new Integer ('
 if ( ( %S |V ) %== 'PublicAccess' ) then
 begin
  'FactoryManagerSrvSingleton.getInstance()' 
 end // if
 else
 begin
  'lsrv' 
 end // else
 '.'
 [%f] to_java %( %S |N )% ' (obj_'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   [%f] to_java %( %C |N )% 
   ++! l_Counter
  end // if
 end // for C
 '));'
//	%P<{}{%CS=factory|%CS=multi factory}[{%Cs=cached|%Cs=const,cached}\
 %P
 bind ( 
  OBJECT VAR %S
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'factory' OR 
    ( ( %C |S ) %== 'multi factory'  ) ) then
   begin
    if ( ( %C |s ) %== 'cached' OR 
      ( ( %C |s ) %== 'const,cached'  ) ) then
    begin
//	#			synchronized ([{%C%Cx=true}{CachedObjectFor%f_to_borland(%CN)}CachedObjectsFor%f_to_borland(%CN)Sngl].class) {
     out_indent '			synchronized ('
     if ( ( %C ->C |x  ) %==  true ) then
     begin
      'CachedObjectsFor'
      [%f] to_borland %( %C |N )% 'Sngl' 
     end // if
     else
     begin
      'CachedObjectFor'
      [%f] to_borland %( %C |N )% 
     end // else
     '.class) {'
//	#				[{%C%Cx=false}if (cachedObjectHashFor%f_to_borland(%CN)_.equals (objHash_)) {
     out_indent '				'
     if ( ( %C ->C |x  ) %==  false ) then
     begin
      'if (cachedObjectHashFor'
      [%f] to_borland %( %C |N )% '_.equals (objHash_)) {'
//	#					CachedObjectFor%f_to_borland(%CN).setInstance(null);
      out_indent '					CachedObjectFor'
      [%f] to_borland %( %C |N )% '.setInstance(null);'
//	#				}][{%C%Cx=true}
      out_indent '				}' 
     end // if
     if ( ( %C ->C |x  ) %==  true ) then
     begin
      #13#10

//	#					ObjectCreationIdFor%f_to_borland(%CN) key = CachedObjectsIndexFor%f_to_borland(%CN)Sngl.instance().get (objHash_);
      out_indent '					ObjectCreationIdFor'
      [%f] to_borland %( %C |N )% ' key = CachedObjectsIndexFor'
      [%f] to_borland %( %C |N )% 'Sngl.instance().get (objHash_);'
//	#					if (key != null) {
      out_indent '					if (key != null) {'
//	#						CachedObjectsFor%f_to_borland(%CN)Sngl.instance().remove (key);
      out_indent '						CachedObjectsFor'
      [%f] to_borland %( %C |N )% 'Sngl.instance().remove (key);'
//	#						CachedObjectsIndexFor%f_to_borland(%CN)Sngl.instance().remove (objHash_);
      out_indent '						CachedObjectsIndexFor'
      [%f] to_borland %( %C |N )% 'Sngl.instance().remove (objHash_);'
//	#					}]
      out_indent '					}' 
     end // if
//	#			}]>
     out_indent '			}' 
    end // if

    ++! l_Counter
   end // if
  end // for C

 ) // bind
 //	#	} catch (org.omg.CORBA.TRANSIENT ex) {
 out_indent '	} catch (org.omg.CORBA.TRANSIENT ex) {'
//	#		if (sRenewMode) {
 out_indent '		if (sRenewMode) {'
//	#			sRenewMode = false;
 out_indent '			sRenewMode = false;'
//	#			Logs.LOG_W ("WARNING: %{INT}NFactoryManagerSrv is in invalid (inactive) state");
 out_indent '			Logs.LOG_W ("WARNING: '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv is in invalid (inactive) state");'
//	#			throw  new ru.garant.shared.CoreSrv.ForeignObject ();
 out_indent '			throw  new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#		}
 out_indent '		}'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
 out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			Logs.LOG_D ("DEBUG: Try to renew %{INT}NFactoryManagerSrv");
 out_indent '			Logs.LOG_D ("DEBUG: Try to renew '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv");'
//	#			sRenewMode = true;
 out_indent '			sRenewMode = true;'
//	#			FactoryManagerSrvSingleton.setInstance (null);
 out_indent '			FactoryManagerSrvSingleton.setInstance (null);'
//	#			%SN (obj_<, %CN>);
 out_indent '			'
 %S |N ' (obj_'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   ', '
   %C |N 
   ++! l_Counter
  end // if
 end // for C
 ');'
//	#			sRenewMode = false;
 out_indent '			sRenewMode = false;'
//	#		}
 out_indent '		}'
//	#	}
 out_indent '	}'
//	#}
 out_indent '}'
//#UC END# *470321950119for471F1823007D*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor471F1823007D*
//#UC END# *470321C1038Afor471F1823007D*
; // fctr.java


// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for471F1823007D*
//#UC END# *4705C5490109for471F1823007D*
; // fctr.h


// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for471F1823007D*
//#UC END# *4705C54B01F4for471F1823007D*
; // fctr.cpp


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию экспортируемой фабрики
//%f _dump_as_exported_cpp
; // st_space_key

: dump_as_exported_cpp OBJECT IN %S
//#UC START# *4AE7F60D03DAfor471F1823007D*
//#UC END# *4AE7F60D03DAfor471F1823007D*
; // dump_as_exported_cpp


// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию неэкспортируемой фабрики
//%f _dump_as_non_exported_cpp
: dump_as_non_exported_cpp OBJECT IN %S
//#UC START# *4AE7F6490336for471F1823007D*
//#UC END# *4AE7F6490336for471F1823007D*
; // dump_as_non_exported_cpp


// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for471F1823007D*
//c                              {}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}
//#UC END# *4704C0E30186for471F1823007D*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor471F1823007D*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor471F1823007D*
; // wiki_child_kind


// Вложенные стереотипы
//: ServerInterface::Class::remover::Operation::Parameter
end. // :: <<ServerInterface>> <<remover>> ;

implementation @ :: <<ServerInterface>> <<remover>> Parameter ;
//? Параметр
//= ServerFacet::Class::Operation::Parameter

// Параметры стереотипа
//Y code_param.gif
//L code_param

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



//: ServerInterface::Class::factory::Operation
; // st_space_key

end. // :: <<ServerInterface>> <<remover>> Parameter ;

implementation @ :: <<ServerInterface>> <<factory>> ;
//? Фабрика (одиночная)
//? Будет создан абстрактный интерфейс фабрики, который будут реализовывать конкретные фабрики (по одной на каждый сервант), создающие соответствующие серванты. Конкретные фабрики мугут инициализироваться своими специфичными параметрами. Созданные конкретные фабрики будут регистрироваться в менеджере фабрик. Последний осуществляет выбор нужной "активной" фабрики при получении запроса на создание экземпляра объекта. Для ОДИНОЧНОЙ фабрики - активной может быть только ОДНА такая фабрика - кто последний зарегистрировался тот и активен.
//= Interface::Class::factory::Operation
//= ServerFactoryOperationInternal::Class

// Параметры стереотипа
//Y code_factory.gif
//L code_factory
//m f
// - не может быть реализован/иметь перекрытую реализацию

// Генераторы
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for471F1E100186*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_idl(%S)}%f_srv_factory_idl(%S)
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] srv_factory_idl %( %S )% 
//	
  #13#10

//	%f_srv_factory_idl(%S,"_ro")]
  [%f] srv_factory_idl %( %S %, '_ro' )% 
 end // if
 else
 begin
  [%f] srv_factory_idl %( %S )% 
 end // else

//f _srv_factory_idl
; // idl

end. // :: <<ServerInterface>> <<factory>> ;

: srv_factory_idl OBJECT IN %S
//	#%t_ret(%{INT},"%Ss") %SN%1N (<{, }{%CS!=cache}%CX>)
 out_indent [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 %S |N %1 |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %!= 'cache' ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |X 
   ++! l_Counter
  end // if
 end // for C
 ')'
//	#	raises (CoreSrv::NoActiveFactory<, %f_type(%E)>);
 out_indent '	raises (CoreSrv::NoActiveFactory'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   ', '
   [%f] type %( %E )% 
   ++! l_Counter
  end // if
 end // for E
 ');'
//#UC END# *47022BBE0261for471F1E100186*
; // srv_factory_idl


// генератор заголовочных файлов C++ (.h)
//+ h
implementation @ :: <<ServerInterface>> <<factory>> ;
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor471F1E100186*
//	[{%S%f_is_exported()=true}{%P%f_dump_factory_operation_h(%S)}%f_docs(%S)\
 if ( ( %S %f is_exported %( )% ) %==  true ) then
 begin
  [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_h(%S)}%f_srv_factory_h(%S)
  if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
  begin
   [%f] srv_factory_h %( %S )% 
//	
   #13#10

//	%f_srv_factory_h(%S,"_ro")][{<{}{%CS=cache}{C}>!=0}
   [%f] srv_factory_h %( %S %, '_ro' )% 
  end // if
  else
  begin
   [%f] srv_factory_h %( %S )% 
  end // else
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'cache' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
   #13#10

//	
   #13#10

//	[{%S{const_type}=combo}{%f_srv_factory_for_server(%S)}%f_srv_factory_for_server(%S)
   if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
   begin
    [%f] srv_factory_for_server %( %S )% 
//	
    #13#10

//	%f_srv_factory_for_server(%S,"_ro")]]]]
    [%f] srv_factory_for_server %( %S %, '_ro' )% 
   end // if
   else
   begin
    [%f] srv_factory_for_server %( %S )% 
   end // else
  end // if
 end // if
 else
 begin
  %P %f dump_factory_operation_h %( %S )% 
 end // else
 ']'

//f _srv_factory_for_server
; // h

end. // :: <<ServerInterface>> <<factory>> ;

: srv_factory_for_server OBJECT IN %S
//	[{%S%f_is_exported()=true}[{%XU=h}#]//Реализация фабрики %SN%1N для использования на стороне сервера
 if ( ( %S %f is_exported %( )% ) %==  true ) then
 begin
  if ( ( %X |U ) %== 'h' ) then
  begin
   out_indent 
  end // if
  '//Реализация фабрики '
  %S |N %1 |N ' для использования на стороне сервера'
//	[{%XU=h}#static ]%t_ret(%{INT}) [{%XU=cpp}%{INT}NFactory::]%SN%1N_srv (<{, }{%CS!=cache}%CX>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]%{INT}%f_dump_switch_arg_type() key])
  if ( ( %X |U ) %== 'h' ) then
  begin
   out_indent 'static ' 
  end // if
  [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' '
  if ( ( %X |U ) %== 'cpp' ) then
  begin
   ( get_global_var ( 'INT' ) |N ) 'Factory::' 
  end // if
  %S |N %1 |N '_srv ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %!= 'cache' ) then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |X 
    ++! l_Counter
   end // if
  end // for C
  if ( ( %S |S ) %== 'multi factory' AND 
    ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
  begin
   if ( ( %C |x ) %==  true ) then
   begin
    ', ' 
   end // if
   ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key' 
  end // if
  ')'
//	[{%XU=h}#]	/*throw (CoreSrv::NoActiveFactory<, %f_type(%E)>)*/[{%XU=cpp}{;}
  if ( ( %X |U ) %== 'h' ) then
  begin
   out_indent 
  end // if
  '	/*throw (CoreSrv::NoActiveFactory'
  INTEGER VAR l_Counter l_Counter := 0
  for %S%E
  begin
   OBJECT IN %E
   if true then
   begin
    ', '
    [%f] type %( %E )% 
    ++! l_Counter
   end // if
  end // for E
  ')*/'
  if ( ( %X |U ) %== 'cpp' ) then
  begin
   #13#10

//	{
   '{'
//		%{INT}NFactoryManagerSrv_var factory_mng;
   '	'
   ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv_var factory_mng;'
//		try {
   '	try {'
//			CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "%f_full_name(%{INT})");
   '		CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "'
   [%f] full_name %( ( get_global_var ( 'INT' ) ) )% ');'
//			factory_mng = %{INT}NFactoryManagerSrv::_narrow (obj);
   '		factory_mng = '
   ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv::_narrow (obj);'
//		} CATCH_AND_LOG ("COS Naming can't find FactoryManagerSrv for %{INT}N");
   '	} CATCH_AND_LOG ("COS Naming can''t find FactoryManagerSrv for '
   ( get_global_var ( 'INT' ) |N ) ');'
//		
   '	'
//		if (CORBA::is_nil (factory_mng)) {
   '	if (CORBA::is_nil (factory_mng)) {'
//			throw CoreSrv::NoActiveFactory ();
   '		throw CoreSrv::NoActiveFactory ();'
//		}
   '	}'
//		
   '	'
//		return factory_mng-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
   '	return factory_mng->'
   %S |N %1 |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'cache' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   if ( ( %S |S ) %== 'multi factory' AND 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
   begin
    if ( ( %C |x ) %==  true ) then
    begin
     ', ' 
    end // if
    'fctr_key' 
   end // if
   ');'
//	}]]
   '}' 
  end // if
  else
  begin
   ';' 
  end // else
 end // if

//f _srv_factory_h
; // srv_factory_for_server

: srv_factory_h OBJECT IN %S
//	#static %t_ret(%{INT},"%Ss") %SN%1N (<{, }{%CS!=cache}%CX>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]%{INT}%f_dump_switch_arg_type() key])
 out_indent 'static '
 [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 %S |N %1 |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %!= 'cache' ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |X 
   ++! l_Counter
  end // if
 end // for C
 if ( ( %S |S ) %== 'multi factory' AND 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
   ', ' 
  end // if
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key' 
 end // if
 ')'
//	#	/*throw ([{%S%f_is_exported()=true}{Core::Root}CoreSrv]::NoActiveFactory<, %f_type(%E)>)*/;
 out_indent '	/*throw ('
 if ( ( %S %f is_exported %( )% ) %==  true ) then
 begin
  'CoreSrv' 
 end // if
 else
 begin
  'Core::Root' 
 end // else
 '::NoActiveFactory'
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   ', '
   [%f] type %( %E )% 
   ++! l_Counter
  end // if
 end // for E
 ')*/;'
//#UC END# *47022C88029Ffor471F1E100186*
; // srv_factory_h


// генератор файлов реализации C++ (.cpp)
//+ cpp
implementation @ :: <<ServerInterface>> <<factory>> ;
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor471F1E100186*
//	[{%S%f_is_exported()=true}{%P%f_dump_factory_operation_cpp(%S)}%f_docs(%S)\
 if ( ( %S %f is_exported %( )% ) %==  true ) then
 begin
  [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_cpp(%S)}%f_srv_factory_cpp(%S)
  if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
  begin
   [%f] srv_factory_cpp %( %S )% 
//	
   #13#10

//	%f_srv_factory_cpp(%S,"_ro")][{<{}{%CS=cache}{C}>!=0}
   [%f] srv_factory_cpp %( %S %, '_ro' )% 
  end // if
  else
  begin
   [%f] srv_factory_cpp %( %S )% 
  end // else
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %== 'cache' ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
   #13#10

//	
   #13#10

//	[{%S{const_type}=combo}{%f_srv_factory_for_server(%S)}%f_srv_factory_for_server(%S)
   if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
   begin
    [%f] srv_factory_for_server %( %S )% 
//	
    #13#10

//	%f_srv_factory_for_server(%S,"_ro")]]]
    [%f] srv_factory_for_server %( %S %, '_ro' )% 
   end // if
   else
   begin
    [%f] srv_factory_for_server %( %S )% 
   end // else
  end // if
 end // if
 else
 begin
  %P %f dump_factory_operation_cpp %( %S )% 
 end // else

//f _srv_factory_cpp
; // cpp

end. // :: <<ServerInterface>> <<factory>> ;

: srv_factory_cpp OBJECT IN %S
//	%t_ret(%{INT},"%Ss") %{INT}NFactory::%SN%1N (<{, }{%CS!=cache}%CX>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]%{INT}%f_dump_switch_arg_type() fctr_key]) /*throw ([{%S%f_is_exported()=true}{Core::Root}CoreSrv]::NoActiveFactory[{%SS=multi factory&%S{transparent multy}=false}, [{%S%f_is_exported()=true}{Core::Root}CoreSrv]::UnknownFactoryKey]<, %f_type(%E)>)*/ {
 [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 ( get_global_var ( 'INT' ) |N ) 'Factory::'
 %S |N %1 |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %!= 'cache' ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |X 
   ++! l_Counter
  end // if
 end // for C
 if ( ( %S |S ) %== 'multi factory' AND 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
   ', ' 
  end // if
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' fctr_key' 
 end // if
 ') /*throw ('
 if ( ( %S %f is_exported %( )% ) %==  true ) then
 begin
  'CoreSrv' 
 end // if
 else
 begin
  'Core::Root' 
 end // else
 '::NoActiveFactory'
 if ( ( %S |S ) %== 'multi factory' AND 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
 begin
  ', '
  if ( ( %S %f is_exported %( )% ) %==  true ) then
  begin
   'CoreSrv' 
  end // if
  else
  begin
   'Core::Root' 
  end // else
  '::UnknownFactoryKey' 
 end // if
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   ', '
   [%f] type %( %E )% 
   ++! l_Counter
  end // if
 end // for E
 ')*/ {'
//		if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
 '	if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//			GUARD (s_init_mutex);
 '		GUARD (s_init_mutex);'
//			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
 '		if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//				try {
 '			try {'
//					CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "%f_full_name(%{INT})");
 '				CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "'
 [%f] full_name %( ( get_global_var ( 'INT' ) ) )% '");'
//					*FactoryManagerSrvSingleton::instance() = %{INT}NFactoryManagerSrv::_narrow (obj);
 '				*FactoryManagerSrvSingleton::instance() = '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv::_narrow (obj);'
//				} CATCH_AND_LOG ("COS Naming can't find FactoryManagerSrv for %{INT}N");
 '			} CATCH_AND_LOG ("COS Naming can''t find FactoryManagerSrv for '
 ( get_global_var ( 'INT' ) |N ) '");'
//			}
 '		}'
//			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
 '		if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//				throw CoreSrv::NoActiveFactory ();
 '			throw CoreSrv::NoActiveFactory ();'
//			}
 '		}'
//		}
 '	}'

//	[{%SV!=PublicAccess}
 if ( ( %S |V ) %!= 'PublicAccess' ) then
 begin
  #13#10

//		%{INT}NFactoryManagerLocal* lsrv = 0;
  '	'
  ( get_global_var ( 'INT' ) |N ) 'FactoryManagerLocal* lsrv = 0;'
//		try {
  '	try {'
//			PortableServer::Servant srv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (*FactoryManagerSrvSingleton::instance());
  '		PortableServer::Servant srv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (*FactoryManagerSrvSingleton::instance());'
//			lsrv = dynamic_cast\<%{INT}NFactoryManagerLocal*\>(srv);
  '		lsrv = dynamic_cast<'
  ( get_global_var ( 'INT' ) |N ) 'FactoryManagerLocal*>(srv);'
//		} catch (PortableServer::POA::WrongAdapter&) {
  '	} catch (PortableServer::POA::WrongAdapter&) {'
//		}
  '	}'
//		if (!lsrv) {
  '	if (!lsrv) {'
//			throw CoreSrv::NoActiveFactory ();
  '		throw CoreSrv::NoActiveFactory ();'
//		}
  '	}'
//	]	try {
 end // if
 '	try {'
//	[{%Ss!=cached&%Ss!=const,cached}		return [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
 if ( ( %S |s ) %!= 'cached' AND 
   ( ( %S |s ) %!= 'const,cached'  ) ) then
 begin
  '		return '
  if ( ( %S |V ) %== 'PublicAccess' ) then
  begin
   '(*FactoryManagerSrvSingleton::instance())' 
  end // if
  else
  begin
   'lsrv' 
  end // else
  '->'
  %S |N %1 |N ' ('
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    if ( l_Counter >0 ) then ( ', ' )
    %C |N 
    ++! l_Counter
   end // if
  end // for C
  if ( ( %S |S ) %== 'multi factory' AND 
    ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
  begin
   if ( ( %C |x ) %==  true ) then
   begin
    ', ' 
   end // if
   'fctr_key' 
  end // if
  ');'
//	][{%Ss=cached|%Ss=const,cached}[{[{<{}{%CS!=cache}{%CC}>!=0}{false}true]=true|[{%SS=multi factory&%S{transparent multy}=false}{false}true]=true}
 end // if
 if ( ( %S |s ) %== 'cached' OR 
   ( ( %S |s ) %== 'const,cached'  ) ) then
 begin
  if ( if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %!= 'cache' ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %!= 0 ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %==  true OR 
    ( if ( ( %S |S ) %== 'multi factory' AND 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %==  true  ) ) then
  begin
   #13#10


//Пока при получении объекта их кэша проверяет влидность этого объекта

//в последствии от этого можно будет избавиться
//			bool created_new = false; //флаг о том, что объект был создан, а не получен из кэша
   '		bool created_new = false; //флаг о том, что объект был создан, а не получен из кэша'
//			GUARD(s_mutex_for_%SN);
   '		GUARD(s_mutex_for_'
   %S |N ');'
//			CachedObjectsFor%f_to_borland(%SN)::iterator f = CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>find (ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>));
   '		CachedObjectsFor'
   [%f] to_borland %( %S |N )% '::iterator f = CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->find (ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   '));'
//			if (f == CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>end()) {
   '		if (f == CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->end()) {'
//				f = CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>insert (
   '			f = CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->insert ('
//					CachedObjectsFor%f_to_borland(%SN)::value_type(
   '				CachedObjectsFor'
   [%f] to_borland %( %S |N )% '::value_type('
//						ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
   '					ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   ')'
//						, [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key])
   '					, '
   if ( ( %S |V ) %== 'PublicAccess' ) then
   begin
    '(*FactoryManagerSrvSingleton::instance())' 
   end // if
   else
   begin
    'lsrv' 
   end // else
   '->'
   %S |N %1 |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'cache' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   if ( ( %S |S ) %== 'multi factory' AND 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
   begin
    if ( ( %C |x ) %==  true ) then
    begin
     ', ' 
    end // if
    'fctr_key' 
   end // if
   ')'
//					)
   '				)'
//				).first;
   '			).first;'
//				(*CachedObjectsIndexFor%f_to_borland(%SN)Sngl::instance())\[f-\>second-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())\] = f;
   '			(*CachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance())[f->second->_hash (std::numeric_limits<CORBA::ULong>::max ())] = f;'
//				created_new = true;
   '			created_new = true;'
//			}
   '		}'
//			if (created_new == false) {
   '		if (created_new == false) {'
//				//если объект получили из кэша - нужно проверить, что он валиден
   '			//если объект получили из кэша - нужно проверить, что он валиден'
//				bool need_recreate = false;
   '			bool need_recreate = false;'
//				try {
   '			try {'
//					need_recreate = f-\>second-\>_non_existent ();
   '				need_recreate = f->second->_non_existent ();'
//				} catch (...) {
   '			} catch (...) {'
//					need_recreate = true;
   '				need_recreate = true;'
//				}
   '			}'
//				if (need_recreate) {
   '			if (need_recreate) {'
//					CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>erase (f);
   '				CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->erase (f);'
//					f = CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>insert (
   '				f = CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->insert ('
//						CachedObjectsFor%f_to_borland(%SN)::value_type(
   '					CachedObjectsFor'
   [%f] to_borland %( %S |N )% '::value_type('
//							ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
   '						ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'nokey' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   ')'
//							, [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key])
   '						, '
   if ( ( %S |V ) %== 'PublicAccess' ) then
   begin
    '(*FactoryManagerSrvSingleton::instance())' 
   end // if
   else
   begin
    'lsrv' 
   end // else
   '->'
   %S |N %1 |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'cache' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   if ( ( %S |S ) %== 'multi factory' AND 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
   begin
    if ( ( %C |x ) %==  true ) then
    begin
     ', ' 
    end // if
    'fctr_key' 
   end // if
   ')'
//						)
   '					)'
//					).first;
   '				).first;'
//					(*CachedObjectsIndexFor%f_to_borland(%SN)Sngl::instance())\[f-\>second-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())\] = f;
   '				(*CachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance())[f->second->_hash (std::numeric_limits<CORBA::ULong>::max ())] = f;'
//				}
   '			}'
//			}
   '		}'
//			return *f-\>second;
   '		return *f->second;'
//	][{[{<{}{%CS!=cache}{%CC}>!=0}{false}true]=false&%SS!=multi factory}
  end // if
  if ( if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %!= 'cache' ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %!= 0 ) then
   begin
     true 
   end // if
   else
   begin
     false 
   end // else
   %==  false AND 
    ( ( %S |S ) %!= 'multi factory'  ) ) then
  begin
   #13#10


//Пока при получении объекта их кэша проверяет влидность этого объекта

//в последствии от этого можно будет избавиться
//			bool created_new = false; //флаг о том, что объект был создан, а не получен из кэша
   '		bool created_new = false; //флаг о том, что объект был создан, а не получен из кэша'
//			if (CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr() == 0) {
   '		if (CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance()->ptr() == 0) {'
//				GUARD(s_mutex_for_%SN);
   '			GUARD(s_mutex_for_'
   %S |N ');'
//				if (CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr() == 0) {
   '			if (CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance()->ptr() == 0) {'
//					*CachedObjectFor%f_to_borland(%SN)::instance() = [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
   '				*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance() = '
   if ( ( %S |V ) %== 'PublicAccess' ) then
   begin
    '(*FactoryManagerSrvSingleton::instance())' 
   end // if
   else
   begin
    'lsrv' 
   end // else
   '->'
   %S |N %1 |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'cache' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   if ( ( %S |S ) %== 'multi factory' AND 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
   begin
    if ( ( %C |x ) %==  true ) then
    begin
     ', ' 
    end // if
    'fctr_key' 
   end // if
   ');'
//					s_cached_object_hash_for_%SN = (*CachedObjectFor%f_to_borland(%SN)::instance())-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ());
   '				s_cached_object_hash_for_'
   %S |N ' = (*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance())->_hash (std::numeric_limits<CORBA::ULong>::max ());'
//					created_new = true;
   '				created_new = true;'
//				}
   '			}'
//			}
   '		}'
//			if (created_new == false) {
   '		if (created_new == false) {'
//				//если объект получили из кэша - нужно проверить, что он валиден
   '			//если объект получили из кэша - нужно проверить, что он валиден'
//				bool need_recreate = false;
   '			bool need_recreate = false;'
//				try {
   '			try {'
//					need_recreate = CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr()-\>_non_existent ();
   '				need_recreate = CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance()->ptr()->_non_existent ();'
//				} catch (...) {
   '			} catch (...) {'
//					need_recreate = true;
   '				need_recreate = true;'
//				}
   '			}'
//				if (need_recreate) {
   '			if (need_recreate) {'
//					GUARD(s_mutex_for_%SN);
   '				GUARD(s_mutex_for_'
   %S |N ');'
//					*CachedObjectFor%f_to_borland(%SN)::instance() = 0;
   '				*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance() = 0;'
//					*CachedObjectFor%f_to_borland(%SN)::instance() = [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
   '				*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance() = '
   if ( ( %S |V ) %== 'PublicAccess' ) then
   begin
    '(*FactoryManagerSrvSingleton::instance())' 
   end // if
   else
   begin
    'lsrv' 
   end // else
   '->'
   %S |N %1 |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |S ) %!= 'cache' ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C
   if ( ( %S |S ) %== 'multi factory' AND 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
   begin
    if ( ( %C |x ) %==  true ) then
    begin
     ', ' 
    end // if
    'fctr_key' 
   end // if
   ');'
//					s_cached_object_hash_for_%SN = (*CachedObjectFor%f_to_borland(%SN)::instance())-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ());
   '				s_cached_object_hash_for_'
   %S |N ' = (*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance())->_hash (std::numeric_limits<CORBA::ULong>::max ());'
//				}
   '			}'
//			}
   '		}'
//			return *CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr();
   '		return *CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance()->ptr();'
//	]]	} catch (CORBA::TRANSIENT& ) {
  end // if
 end // if
 '	} catch (CORBA::TRANSIENT& ) {'
//			if (s_renew_mode) {
 '		if (s_renew_mode) {'
//				s_renew_mode = false;
 '			s_renew_mode = false;'
//				LOG_W (("%{INT}NFactoryManagerSrv is in invalid (inactive) state"));
 '			LOG_W (("'
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv is in invalid (inactive) state"));'
//				throw CoreSrv::NoActiveFactory ();
 '			throw CoreSrv::NoActiveFactory ();'
//			}
 '		}'
//			GUARD (s_init_mutex);
 '		GUARD (s_init_mutex);'
//			LOG_D (("Try to renew %{INT}NFactoryManagerSrv"));
 '		LOG_D (("Try to renew '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv"));'
//			
 '		'
//			s_renew_mode = true;
 '		s_renew_mode = true;'
//			(*FactoryManagerSrvSingleton::instance()) = 0;
 '		(*FactoryManagerSrvSingleton::instance()) = 0;'
//			%{INT}N[{%Ss!=cached&%Ss!=const,cached}{&}_var] ret = %SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
 '		'
 ( get_global_var ( 'INT' ) |N ) if ( ( %S |s ) %!= 'cached' AND 
   ( ( %S |s ) %!= 'const,cached'  ) ) then
 begin
  '_var' 
 end // if
 else
 begin
  '&' 
 end // else
 ' ret = '
 %S |N %1 |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %!= 'cache' ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |N 
   ++! l_Counter
  end // if
 end // for C
 if ( ( %S |S ) %== 'multi factory' AND 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
   ', ' 
  end // if
  'fctr_key' 
 end // if
 ');'
//			s_renew_mode = false;
 '		s_renew_mode = false;'
//			
 '		'
//			return ret[{%Ss!=cached&%Ss!=const,cached}._retn()];				
 '		return ret'
 if ( ( %S |s ) %!= 'cached' AND 
   ( ( %S |s ) %!= 'const,cached'  ) ) then
 begin
  '._retn()' 
 end // if
 ';				'
//		} catch (CORBA::OBJECT_NOT_EXIST& ) {
 '	} catch (CORBA::OBJECT_NOT_EXIST& ) {'
//			if (s_renew_mode) {
 '		if (s_renew_mode) {'
//				s_renew_mode = false;
 '			s_renew_mode = false;'
//				LOG_W (("%{INT}NFactoryManagerSrv is in invalid (inactive) state"));
 '			LOG_W (("'
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv is in invalid (inactive) state"));'
//				throw CoreSrv::NoActiveFactory ();
 '			throw CoreSrv::NoActiveFactory ();'
//			}
 '		}'
//			GUARD (s_init_mutex);
 '		GUARD (s_init_mutex);'
//			LOG_D (("Try to renew %{INT}NFactoryManagerSrv"));
 '		LOG_D (("Try to renew '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv"));'
//			
 '		'
//			s_renew_mode = true;
 '		s_renew_mode = true;'
//			(*FactoryManagerSrvSingleton::instance()) = 0;
 '		(*FactoryManagerSrvSingleton::instance()) = 0;'
//			%{INT}N[{%Ss!=cached&%Ss!=const,cached}{&}_var] ret = %SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
 '		'
 ( get_global_var ( 'INT' ) |N ) if ( ( %S |s ) %!= 'cached' AND 
   ( ( %S |s ) %!= 'const,cached'  ) ) then
 begin
  '_var' 
 end // if
 else
 begin
  '&' 
 end // else
 ' ret = '
 %S |N %1 |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %!= 'cache' ) then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |N 
   ++! l_Counter
  end // if
 end // for C
 if ( ( %S |S ) %== 'multi factory' AND 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
   ', ' 
  end // if
  'fctr_key' 
 end // if
 ');'
//			s_renew_mode = false;
 '		s_renew_mode = false;'
//			
 '		'
//			return ret[{%Ss!=cached&%Ss!=const,cached}._retn()];				
 '		return ret'
 if ( ( %S |s ) %!= 'cached' AND 
   ( ( %S |s ) %!= 'const,cached'  ) ) then
 begin
  '._retn()' 
 end // if
 ';				'
//		}
 '	}'
//	}
 '}'
//#UC END# *47022CB8034Bfor471F1E100186*
; // srv_factory_cpp


// генератор классов, интерфейсов на java (.java)
//+ java
implementation @ :: <<ServerInterface>> <<factory>> ;
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for471F1E100186*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_java(%S)}%f_srv_factory_java(%S)
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] srv_factory_java %( %S )% 
//	
  #13#10

//	%f_srv_factory_java(%S,"_ro")]
  [%f] srv_factory_java %( %S %, '_ro' )% 
 end // if
 else
 begin
  [%f] srv_factory_java %( %S )% 
 end // else

//f _srv_inherited_factory_java
; // java

end. // :: <<ServerInterface>> <<factory>> ;

: srv_inherited_factory_java OBJECT IN %S
//	#	try {
 out_indent '	try {'
//	#		%f_type(%{FACTORY_PARENT}) ret = %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
 out_indent '		'
 [%f] type %( ( get_global_var ( 'FACTORY_PARENT' ) ) )% ' ret = '
 [%f] type %( ( get_global_var ( 'FACTORY_PARENT' ) ) )% 'FactoryManager.'
 ( get_global_var ( 'FACTORY_PARENT' ) %f fctr_mng_get_instance_name %( )% ) ' ().'
 [%f] to_java %( %S |N )% ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] to_java %( %C |N )% 
   ++! l_Counter
  end // if
 end // for C
 if ( ( %S |S ) %== 'multi factory' AND 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
   ', ' 
  end // if
  'fctrKey' 
 end // if
 ');'
//	[{%{INT}S=LocalInterface&%f_use_as_srv_type(%{INT}%R)=true}{#		if (ret instanceof %f_type(%{INT})) \{
 if ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'LocalInterface' AND 
   ( ( [%f] use_as_srv_type %( ( get_global_var ( 'INT' )  ->R ) )% ) %==  true  ) ) then
 begin
  out_indent '		org.omg.PortableServer.Servant srv = '
  ( get_global_var ( 'INT' ) ) 
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%P
   begin
    OBJECT IN %P
    if ( ( %P |M ) %== 'Library::Category' OR 
     ( ( %P |M ) %== 'ServerLibrary::Category'  ) ) then
    begin
     [%f] dump_java_package %( %P )% '.'
     %P |N '.LibHomeFactory' 
     ++! l_Counter
    end // if
   end // for P

  ) // bind
  '.get().getOrbFacet().getRootPoa().reference_to_servant (ret);'
//	#		if (srv instanceof %f_type(%{INT})) {
  out_indent '		if (srv instanceof '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% ') {'
//	#			return (%f_type(%{INT})) srv;]
  out_indent '			return ('
  [%f] type %( ( get_global_var ( 'INT' ) ) )% ') srv;' 
 end // if
 else
 begin
  out_indent '		if (ret instanceof '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% ') {'
//	#			return (%f_type(%{INT})) ret;}#		org.omg.PortableServer.Servant srv = %{INT}<{}{%PM=Library::Category|%PM=ServerLibrary::Category}{%P}%f_dump_java_package(%P).%PN.LibHomeFactory>.get().getOrbFacet().getRootPoa().reference_to_servant (ret);
  out_indent '			return ('
  [%f] type %( ( get_global_var ( 'INT' ) ) )% ') ret;' 
 end // else
//	#		} else {
 out_indent '		} else {'
//	#			throw new NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
 out_indent '			throw new NoActiveFactory ('
 ( get_global_var ( 'INT' ) ) 
 bind ( 
  OBJECT VAR %S
  if NOT-EMPTY
  begin
   %P ->P |N  '::'
   %P |N '::'
   %S |N 'Factory' 
  end // if
  NOP

 ) // bind
 ');'
//	#		}
 out_indent '		}'
//	#	} catch (java.lang.Throwable e) {
 out_indent '	} catch (java.lang.Throwable e) {'
//	#		throw new NoActiveFactory (e);
 out_indent '		throw new NoActiveFactory (e);'
//	#	}
 out_indent '	}'
//	

//f _srv_factory_java
; // srv_inherited_factory_java

: srv_factory_java OBJECT IN %S
//	#%t_visibility(%S,"%XU")static %t_ret(%{INT},"%Ss") %SN%1N (<{, }%f_arg_full_decl(%C)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]%{INT}%f_dump_switch_arg_type() fctrKey]) throws NoActiveFactory[{%SS=multi factory}, UnknownFactoryKey]<, %f_type(%E)> {
 out_indent [%t] visibility %( %S %, %X |U )% 'static '
 [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 %S |N %1 |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   [%f] arg_full_decl %( %C )% 
   ++! l_Counter
  end // if
 end // for C
 if ( ( %S |S ) %== 'multi factory' AND 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
   ', ' 
  end // if
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' fctrKey' 
 end // if
 ') throws NoActiveFactory'
 if ( ( %S |S ) %== 'multi factory' ) then
 begin
  ', UnknownFactoryKey' 
 end // if
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   ', '
   [%f] type %( %E )% 
   ++! l_Counter
  end // if
 end // for E
 ' {'
//	[{%{INT}U=%{FACTORY_PARENT}U}{%f_srv_inherited_factory_java(%S)}#	if (FactoryManagerSrvSingleton.getInstance() == null) {
 if ( ( ( get_global_var ( 'INT' ) |U ) ) %== ( ( get_global_var ( 'FACTORY_PARENT' ) |U ) ) ) then
 begin
  out_indent '	if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
  out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			try {
  out_indent '			try {'
//	#				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath (
  out_indent '				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath ('
//	#					LibHomeFactory.get().getOrbFacet().getNsRoot(), "%f_full_name(%{INT})"
  out_indent '					LibHomeFactory.get().getOrbFacet().getNsRoot(), "'
  [%f] full_name %( ( get_global_var ( 'INT' ) ) )% 
//	#				);
  out_indent '				);'
//	#				FactoryManagerSrvSingleton.setInstance(%{INT}NFactoryManagerSrvHelper.narrow (obj));
  out_indent '				FactoryManagerSrvSingleton.setInstance('
  ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrvHelper.narrow (obj));'
//	#			} catch (java.lang.Exception ex) {
  out_indent '			} catch (java.lang.Exception ex) {'
//	#				Logs.LOG_SEX (ex);
  out_indent '				Logs.LOG_SEX (ex);'
//	#			}
  out_indent '			}'
//	#			if (FactoryManagerSrvSingleton.getInstance() == null) {
  out_indent '			if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#				throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
  out_indent '				throw new ru.garant.shared.CoreSrv.NoActiveFactory ();'
//	#			}
  out_indent '			}'
//	#		}
  out_indent '		}'
//	#	}
  out_indent '	}'
//	[{%SV!=PublicAccess}
  if ( ( %S |V ) %!= 'PublicAccess' ) then
  begin
   #13#10

//	#	%f_type(%{INT})FactoryManagerLocal lsrv = null;
   out_indent '	'
   [%f] type %( ( get_global_var ( 'INT' ) ) )% 'FactoryManagerLocal lsrv = null;'
//	#	try {
   out_indent '	try {'
//	#		org.omg.PortableServer.Servant srv = LibHomeFactory::get().getOrbFacet().getRootPoa().reference_to_servant (FactoryManagerSrvSingleton.getInstance());
   out_indent '		org.omg.PortableServer.Servant srv = LibHomeFactory::get().getOrbFacet().getRootPoa().reference_to_servant (FactoryManagerSrvSingleton.getInstance());'
//	#		lsrv = (%f_type(%{INT})FactoryManagerLocal)srv;
   out_indent '		lsrv = ('
   [%f] type %( ( get_global_var ( 'INT' ) ) )% 'FactoryManagerLocal)srv;'
//	#	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {
   out_indent '	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {'
//	#		Logs.LOG_SEX (ex);
   out_indent '		Logs.LOG_SEX (ex);'
//	#	}
   out_indent '	}'
//	#	if (lsrv == null) {
   out_indent '	if (lsrv == null) {'
//	#		throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
   out_indent '		throw new ru.garant.shared.CoreSrv.NoActiveFactory ();'
//	#	}
   out_indent '	}'
//	][{%Ss!=cached&%Ss!=const,cached}#	return [{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
  end // if
  if ( ( %S |s ) %!= 'cached' AND 
    ( ( %S |s ) %!= 'const,cached'  ) ) then
  begin
   out_indent '	return '
   if ( ( %S |V ) %== 'PublicAccess' ) then
   begin
    'FactoryManagerSrvSingleton.getInstance()' 
   end // if
   else
   begin
    'lsrv' 
   end // else
   '.'
   %S |N %1 |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] to_java %( %C |N )% 
     ++! l_Counter
    end // if
   end // for C
   if ( ( %S |S ) %== 'multi factory' AND 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
   begin
    if ( ( %C |x ) %==  true ) then
    begin
     ', ' 
    end // if
    'fctrKey' 
   end // if
   ');'
//	][{%Ss=cached|%Ss=const,cached}
  end // if
  if ( ( %S |s ) %== 'cached' OR 
    ( ( %S |s ) %== 'const,cached'  ) ) then
  begin
   #13#10

//	#	try {
   out_indent '	try {'
//	[{%Cx=true|%SS=multi factory}\
   if ( ( %C |x ) %==  true OR 
     ( ( %S |S ) %== 'multi factory'  ) ) then
   begin

//Закоментированно, т.к нужно научиться чистить клиентский кэш
//	#		synchronized (CachedObjectsFor%f_to_borland(%SN)Sngl.class) {
    out_indent '		synchronized (CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.class) {'
//	#			boolean createdNew = false;
    out_indent '			boolean createdNew = false;'
//	#			ObjectCreationIdFor%f_to_borland(%SN) key = new ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%f_to_java(%CN)>);
    out_indent '			ObjectCreationIdFor'
    [%f] to_borland %( %S |N )% ' key = new ObjectCreationIdFor'
    [%f] to_borland %( %S |N )% '('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |S ) %!= 'nokey' ) then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C
    ');'
//	#			%t_ret(%{INT},"%Ss") ret = CachedObjectsFor%f_to_borland(%SN)Sngl.instance().get (key);
    out_indent '			'
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' ret = CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().get (key);'
//	#			if (ret == null) {
    out_indent '			if (ret == null) {'
//	#				ret = [{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
    out_indent '				ret = '
    if ( ( %S |V ) %== 'PublicAccess' ) then
    begin
     'FactoryManagerSrvSingleton.getInstance()' 
    end // if
    else
    begin
     'lsrv' 
    end // else
    '.'
    %S |N %1 |N ' ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C
    if ( ( %S |S ) %== 'multi factory' AND 
      ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
    begin
     if ( ( %C |x ) %==  true ) then
     begin
      ', ' 
     end // if
     'fctrKey' 
    end // if
    ');'
//	#				CachedObjectsFor%f_to_borland(%SN)Sngl.instance().put (key, ret);
    out_indent '				CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().put (key, ret);'
//	#				CachedObjectsIndexFor%f_to_borland(%SN)Sngl.instance().put (ret._hash (Integer.MAX_VALUE), key);
    out_indent '				CachedObjectsIndexFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().put (ret._hash (Integer.MAX_VALUE), key);'
//	#				createdNew = true;
    out_indent '				createdNew = true;'
//	#			}
    out_indent '			}'
//	#			if (createdNew == false) {
    out_indent '			if (createdNew == false) {'
//	#				boolean needRecreate = false;
    out_indent '				boolean needRecreate = false;'
//	#				try {
    out_indent '				try {'
//	#					needRecreate = ret._non_existent ();
    out_indent '					needRecreate = ret._non_existent ();'
//	#				} catch (java.lang.Throwable ex) {
    out_indent '				} catch (java.lang.Throwable ex) {'
//	#					needRecreate = true;
    out_indent '					needRecreate = true;'
//	#				}
    out_indent '				}'
//	#				if (needRecreate) {
    out_indent '				if (needRecreate) {'
//	#					CachedObjectsFor%f_to_borland(%SN)Sngl.instance().remove (key);
    out_indent '					CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().remove (key);'
//	#					ret = [{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
    out_indent '					ret = '
    if ( ( %S |V ) %== 'PublicAccess' ) then
    begin
     'FactoryManagerSrvSingleton.getInstance()' 
    end // if
    else
    begin
     'lsrv' 
    end // else
    '.'
    %S |N %1 |N ' ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C
    if ( ( %S |S ) %== 'multi factory' AND 
      ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
    begin
     if ( ( %C |x ) %==  true ) then
     begin
      ', ' 
     end // if
     'fctrKey' 
    end // if
    ');'
//	#					CachedObjectsFor%f_to_borland(%SN)Sngl.instance().put (key, ret);
    out_indent '					CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().put (key, ret);'
//	#					CachedObjectsIndexFor%f_to_borland(%SN)Sngl.instance().put (ret._hash (Integer.MAX_VALUE), key);
    out_indent '					CachedObjectsIndexFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().put (ret._hash (Integer.MAX_VALUE), key);'
//	#				}
    out_indent '				}'
//	#			}
    out_indent '			}'
//	#			return ret;
    out_indent '			return ret;'
//	][{%Cx=false&%SS!=multi factory}
   end // if
   if ( ( %C |x ) %==  false AND 
     ( ( %S |S ) %!= 'multi factory'  ) ) then
   begin
    #13#10


//Закоментированно, т.к нужно научиться чистить клиентский кэш
//	#		synchronized (CachedObjectFor%f_to_borland(%SN).class) {
    out_indent '		synchronized (CachedObjectFor'
    [%f] to_borland %( %S |N )% '.class) {'
//	#			boolean createdNew = false;
    out_indent '			boolean createdNew = false;'
//	#			if (CachedObjectFor%f_to_borland(%SN).instance() == null) {
    out_indent '			if (CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance() == null) {'
//	#				CachedObjectFor%f_to_borland(%SN).setInstance([{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]));
    out_indent '				CachedObjectFor'
    [%f] to_borland %( %S |N )% '.setInstance('
    if ( ( %S |V ) %== 'PublicAccess' ) then
    begin
     'FactoryManagerSrvSingleton.getInstance()' 
    end // if
    else
    begin
     'lsrv' 
    end // else
    '.'
    %S |N %1 |N ' ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C
    if ( ( %S |S ) %== 'multi factory' AND 
      ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
    begin
     if ( ( %C |x ) %==  true ) then
     begin
      ', ' 
     end // if
     'fctrKey' 
    end // if
    '));'
//	#				cachedObjectHashFor%f_to_borland(%SN)_ = new Integer (CachedObjectFor%f_to_borland(%SN).instance()._hash (Integer.MAX_VALUE));
    out_indent '				cachedObjectHashFor'
    [%f] to_borland %( %S |N )% '_ = new Integer (CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance()._hash (Integer.MAX_VALUE));'
//	#				createdNew = true;
    out_indent '				createdNew = true;'
//	#			}
    out_indent '			}'
//	#			if (createdNew == false) {
    out_indent '			if (createdNew == false) {'
//	#				boolean needRecreate = false;
    out_indent '				boolean needRecreate = false;'
//	#				try {
    out_indent '				try {'
//	#					needRecreate = CachedObjectFor%f_to_borland(%SN).instance()._non_existent ();
    out_indent '					needRecreate = CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance()._non_existent ();'
//	#				} catch (java.lang.Throwable ex) {
    out_indent '				} catch (java.lang.Throwable ex) {'
//	#					needRecreate = true;
    out_indent '					needRecreate = true;'
//	#				}
    out_indent '				}'
//	#				if (needRecreate) {
    out_indent '				if (needRecreate) {'
//	#					CachedObjectFor%f_to_borland(%SN).setInstance(null);
    out_indent '					CachedObjectFor'
    [%f] to_borland %( %S |N )% '.setInstance(null);'
//	#					CachedObjectFor%f_to_borland(%SN).setInstance([{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]));
    out_indent '					CachedObjectFor'
    [%f] to_borland %( %S |N )% '.setInstance('
    if ( ( %S |V ) %== 'PublicAccess' ) then
    begin
     'FactoryManagerSrvSingleton.getInstance()' 
    end // if
    else
    begin
     'lsrv' 
    end // else
    '.'
    %S |N %1 |N ' ('
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if ( l_Counter >0 ) then ( ', ' )
      [%f] to_java %( %C |N )% 
      ++! l_Counter
     end // if
    end // for C
    if ( ( %S |S ) %== 'multi factory' AND 
      ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
    begin
     if ( ( %C |x ) %==  true ) then
     begin
      ', ' 
     end // if
     'fctrKey' 
    end // if
    '));'
//	#					cachedObjectHashFor%f_to_borland(%SN)_ = new Integer (CachedObjectFor%f_to_borland(%SN).instance()._hash (Integer.MAX_VALUE));
    out_indent '					cachedObjectHashFor'
    [%f] to_borland %( %S |N )% '_ = new Integer (CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance()._hash (Integer.MAX_VALUE));'
//	#				}
    out_indent '				}'
//	#			}
    out_indent '			}'
//	#			return CachedObjectFor%f_to_borland(%SN).instance();
    out_indent '			return CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance();'
//	]\
   end // if
//	#		}
   out_indent '		}'
//	#	} catch (org.omg.CORBA.SystemException ex) {
   out_indent '	} catch (org.omg.CORBA.SystemException ex) {'
//	#		if (sRenewMode) {
   out_indent '		if (sRenewMode) {'
//	#			sRenewMode = false;
   out_indent '			sRenewMode = false;'
//	#			Logs.LOG_E ("%{INT}NFactoryManagerSrv is in invalid (inactive) state");
   out_indent '			Logs.LOG_E ("'
   ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv is in invalid (inactive) state");'
//	#			throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
   out_indent '			throw new ru.garant.shared.CoreSrv.NoActiveFactory ();'
//	#		}
   out_indent '		}'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
   out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			sRenewMode = true;
   out_indent '			sRenewMode = true;'
//	#			FactoryManagerSrvSingleton.setInstance (null);
   out_indent '			FactoryManagerSrvSingleton.setInstance (null);'
//	#			%t_ret(%{INT},"%Ss") ret = %SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
   out_indent '			'
   [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' ret = '
   %S |N %1 |N ' ('
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] to_java %( %C |N )% 
     ++! l_Counter
    end // if
   end // for C
   if ( ( %S |S ) %== 'multi factory' AND 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) then
   begin
    if ( ( %C |x ) %==  true ) then
    begin
     ', ' 
    end // if
    'fctrKey' 
   end // if
   ');'
//	#			sRenewMode = false;
   out_indent '			sRenewMode = false;'
//	
   #13#10

//	#			return ret;
   out_indent '			return ret;'
//	#		}
   out_indent '		}'
//	#	}
   out_indent '	}'
//	]]#}
  end // if
 end // if
 else
 begin
  [%f] srv_inherited_factory_java %( %S )% 
 end // else
 out_indent '}'
//#UC END# *470321950119for471F1E100186*
; // srv_factory_java


// Функции стереотипа
//%f _st_space_key
implementation @ :: <<ServerInterface>> <<factory>> ;
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию экспортируемой фабрики
//%f _dump_as_exported_cpp
; // st_space_key

: dump_as_exported_cpp OBJECT IN %S
//#UC START# *4AE7F60D03DAfor471F1E100186*
//#UC END# *4AE7F60D03DAfor471F1E100186*
; // dump_as_exported_cpp


// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию неэкспортируемой фабрики
//%f _dump_as_non_exported_cpp
: dump_as_non_exported_cpp OBJECT IN %S
//#UC START# *4AE7F6490336for471F1E100186*
//#UC END# *4AE7F6490336for471F1E100186*
; // dump_as_non_exported_cpp


// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for471F1E100186*
//c                              {}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}
//r {%Ss=synchro}:                                                     {синхро-фабрики не могут быть использованные в серверных интерфейсах}
//#UC END# *4704C0E30186for471F1E100186*
; // constraint


// перекрытие базового стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor471F1E100186*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor471F1E100186*
; // wiki_child_kind


// Вложенные стереотипы
//: ServerInterface::Class::factory::Operation::Parameter
end. // :: <<ServerInterface>> <<factory>> ;

implementation @ :: <<ServerInterface>> <<factory>> Parameter ;
//? Параметр
//= ServerFacet::Class::Operation::Parameter

// Параметры стереотипа
//Y code_param.gif
//L code_param

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



//: ServerInterface::Class::multi factory::Operation
; // st_space_key

end. // :: <<ServerInterface>> <<factory>> Parameter ;

implementation @ :: <<ServerInterface>> <<"multi factory">> ;
//? Фабрика (множественная)
//? Будет создан абстрактный интерфейс фабрики, который будут реализовывать конкретные фабрики (по одной на каждый сервант), создающие соответствующие серванты. Конкретные фабрики мугут инициализироваться своими специфичными параметрами. Созданные конкретные фабрики будут регистрироваться в менеджере фабрик. Последний осуществляет выбор нужной "активной" фабрики при получении запроса на создание экземпляра объекта. Для МНОЖЕСТВЕННОЙ фабрики - активными являются ВСЕ зарегистрированные фабрики, выбор конкретной осущестьвляеться по ключу - дополнительному параметру.
//= Interface::Class::multi factory::Operation
//= ServerFactoryOperationInternal::Class

// Параметры стереотипа
//m f
// - не может быть реализован/иметь перекрытую реализацию

// Генераторы
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for471F1E81034B*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_m_factory_idl(%S)}%f_srv_m_factory_idl(%S)
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] srv_m_factory_idl %( %S )% 
//	
  #13#10

//	%f_srv_m_factory_idl(%S,"_ro")]
  [%f] srv_m_factory_idl %( %S %, '_ro' )% 
 end // if
 else
 begin
  [%f] srv_m_factory_idl %( %S )% 
 end // else

//f _srv_m_factory_idl
; // idl

end. // :: <<ServerInterface>> <<"multi factory">> ;

: srv_m_factory_idl OBJECT IN %S
//	#%t_ret(%{INT},"%Ss") %SN%1N (<{, }{}%CX>[{%S{transparent multy}=false}[{%Cx=true}], %{INT}%f_dump_switch_arg_type() key])
 out_indent [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 %S |N %1 |N ' ('
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   if ( l_Counter >0 ) then ( ', ' )
   %C |X 
   ++! l_Counter
  end // if
 end // for C
 if ( ( %S get_up ( 'transparent multy' ) ) %==  false ) then
 begin
  if ( ( %C |x ) %==  true ) then
  begin
  end // if
  ', '
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key' 
 end // if
 ')'
//	#	raises (CoreSrv::[{%S{transparent multy}=false}{NoActiveFactory}UnknownFactoryKey]<, %f_type(%E)>);
 out_indent '	raises (CoreSrv::'
 if ( ( %S get_up ( 'transparent multy' ) ) %==  false ) then
 begin
  'UnknownFactoryKey' 
 end // if
 else
 begin
  'NoActiveFactory' 
 end // else
 INTEGER VAR l_Counter l_Counter := 0
 for %S%E
 begin
  OBJECT IN %E
  if true then
  begin
   ', '
   [%f] type %( %E )% 
   ++! l_Counter
  end // if
 end // for E
 ');'
//#UC END# *47022BBE0261for471F1E81034B*
; // srv_m_factory_idl


// генератор заголовочных файлов C++ (.h)
//+ h
implementation @ :: <<ServerInterface>> <<"multi factory">> ;
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor471F1E81034B*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S%f_is_exported()=true}{%P%f_dump_multi_factory_operation_h(%S)}[{%S{const_type}=combo}{%f_srv_factory_h(%S)}%f_srv_factory_h(%S)
 if ( ( %S %f is_exported %( )% ) %==  true ) then
 begin
  if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
  begin
   [%f] srv_factory_h %( %S )% 
//	
   #13#10

//	%f_srv_factory_h(%S,"_ro")]]
   [%f] srv_factory_h %( %S %, '_ro' )% 
  end // if
  else
  begin
   [%f] srv_factory_h %( %S )% 
  end // else
 end // if
 else
 begin
  %P %f dump_multi_factory_operation_h %( %S )% 
 end // else
//#UC END# *47022C88029Ffor471F1E81034B*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor471F1E81034B*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S%f_is_exported()=true}{%P%f_dump_multi_factory_operation_cpp(%S)}[{%S{const_type}=combo}{%f_srv_factory_cpp(%S)}%f_srv_factory_cpp(%S)
 if ( ( %S %f is_exported %( )% ) %==  true ) then
 begin
  if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
  begin
   [%f] srv_factory_cpp %( %S )% 
//	
   #13#10

//	%f_srv_factory_cpp(%S,"_ro")]]
   [%f] srv_factory_cpp %( %S %, '_ro' )% 
  end // if
  else
  begin
   [%f] srv_factory_cpp %( %S )% 
  end // else
 end // if
 else
 begin
  %P %f dump_multi_factory_operation_cpp %( %S )% 
 end // else
//#UC END# *47022CB8034Bfor471F1E81034B*
; // cpp


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for471F1E81034B*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_java(%S)}%f_srv_factory_java(%S)
 if ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) then
 begin
  [%f] srv_factory_java %( %S )% 
//	
  #13#10

//	%f_srv_factory_java(%S,"_ro")]
  [%f] srv_factory_java %( %S %, '_ro' )% 
 end // if
 else
 begin
  [%f] srv_factory_java %( %S )% 
 end // else
//#UC END# *470321950119for471F1E81034B*
; // java


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию экспортируемой фабрики
//%f _dump_as_exported_cpp
; // st_space_key

: dump_as_exported_cpp OBJECT IN %S
//#UC START# *4AE7F60D03DAfor471F1E81034B*
//#UC END# *4AE7F60D03DAfor471F1E81034B*
; // dump_as_exported_cpp


// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию неэкспортируемой фабрики
//%f _dump_as_non_exported_cpp
: dump_as_non_exported_cpp OBJECT IN %S
//#UC START# *4AE7F6490336for471F1E81034B*
//#UC END# *4AE7F6490336for471F1E81034B*
; // dump_as_non_exported_cpp


// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for471F1E81034B*
//c                              {}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}
//r {%Ss=synchro}:                                                     {синхро-фабрики не могут быть использованные в серверных интерфейсах}
//#UC END# *4704C0E30186for471F1E81034B*
; // constraint


// перекрытие базового стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor471F1E81034B*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor471F1E81034B*
; // wiki_child_kind


// Вложенные стереотипы
//: ServerInterface::Class::multi factory::Operation::Parameter
end. // :: <<ServerInterface>> <<"multi factory">> ;

implementation @ :: <<ServerInterface>> <<"multi factory">> Parameter ;
//? Параметр
//= ServerFacet::Class::Operation::Parameter

// Параметры стереотипа
//Y code_param.gif
//L code_param

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



//: ServerInterface::Class::factory switch::Attribute
; // st_space_key

end. // :: <<ServerInterface>> <<"multi factory">> Parameter ;

implementation @ :: <<ServerInterface>> <<"factory switch">> ;
//? Селектор мультифабрики
//? Определяет тип селектора и допустимые значения, в качестве селектора могут выступать все простые типы и перечисления (Enum).
//= Interface::Class::factory switch::Attribute

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for47B133E102FA*
//#UC END# *46E6D4BB0339for47B133E102FA*
; // wiki


// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for47B133E102FA*
//#UC END# *47022BBE0261for47B133E102FA*
; // idl


// генератор idl спецификаций для AMI (.idl)
//+ idl_ami
<<generator>> idl_ami OBJECT IN %S
//#UC START# *47022C0F01E4for47B133E102FA*
//#UC END# *47022C0F01E4for47B133E102FA*
; // idl_ami


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor47B133E102FA*
//#UC END# *47022C88029Ffor47B133E102FA*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor47B133E102FA*
//#UC END# *47022CB8034Bfor47B133E102FA*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor47B133E102FA*
//#UC END# *47022CCF00EAfor47B133E102FA*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for47B133E102FA*
//#UC END# *470321950119for47B133E102FA*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor47B133E102FA*
//#UC END# *470321C1038Afor47B133E102FA*
; // fctr.java


// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor47B133E102FA*
//#UC END# *47032EC4032Cfor47B133E102FA*
; // dll.h


// С++ TIE-обвязка для DLL (_tie.cpp)
//+ dll.cpp
<<generator>> dll.cpp OBJECT IN %S
//#UC START# *47032ED002DEfor47B133E102FA*
//#UC END# *47032ED002DEfor47B133E102FA*
; // dll.cpp


// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor47B133E102FA*
//#UC END# *470F152700FAfor47B133E102FA*
; // pas


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor47B133E102FA*
//#UC END# *470F1571031Cfor47B133E102FA*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor47B133E102FA*
//#UC END# *470F15B800CBfor47B133E102FA*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for47B133E102FA*
//#UC END# *477398E501C0for47B133E102FA*
; // intf2.pas


// Ресурсы (.rc)
//+ rc.pas
<<generator>> rc.pas OBJECT IN %S
//R  
//#UC START# *55B8D28B0157for47B133E102FA*
//#UC END# *55B8D28B0157for47B133E102FA*
; // rc.pas


// Скрипты в ресурсах (.rc.script)
//+ rc.script.pas
<<generator>> rc.script.pas OBJECT IN %S
//R  
//#UC START# *55B8D2F80145for47B133E102FA*
//#UC END# *55B8D2F80145for47B133E102FA*
; // rc.script.pas


// Компилятор ресурса (.res.cmd)
//+ res.cmd.pas
<<generator>> res.cmd.pas OBJECT IN %S
//R  
//#UC START# *55B8DD9C0301for47B133E102FA*
//#UC END# *55B8DD9C0301for47B133E102FA*
; // res.cmd.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
; // st_space_key

: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for47B133E102FA*
//#UC END# *470484D50138for47B133E102FA*
; // wiki_up_add_gen



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<ServerInterface>> <<"factory switch">> ;

