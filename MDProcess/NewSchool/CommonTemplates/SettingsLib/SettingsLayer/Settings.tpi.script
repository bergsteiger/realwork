////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/SettingsLib/SettingsLayer/Settings.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::SettingsLib::SettingsLayer::Settings
//
// Настройки
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: Settings::Class
implementation @ <<Settings>>
//? Настройки
//< *::Class,*::Category

//= WikiImplClass::Class
//= C++ интерфейсы и реализация::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//Y code_settings.gif
//L code_settings
// Параметры визуализации
//$ C 175,223,32
//$ L 0,0,0
//$ l 0,147,0
//$ F 0,0,0
//$ f 0,0,0

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Трансформаторы стереотипа

// возвращает true если тип на прямую поддерживается ParamManager-ом
//%t _direct_access
<<transformator>> direct_access OBJECT IN %S
//#UC START# *4929B2E70086for48A27E2101E1*
//c                                                 {}
//r "%1S"="Enum":                                   {false}
//r "%1S"="UMLPrimitive"&"%1N"="boolean":           {false}
//r ""="":                                          {true}
//#UC END# *4929B2E70086for48A27E2101E1*
; // direct_access


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

// Проверяем, что во всем множетсве настроек нет дублирующихся имен параметров
//%f _check_duplicate_attr
; // st_space_key

: check_duplicate_attr OBJECT IN %S
//#UC START# *48B692B502E0for48A27E2101E1*
//	%f_set_var(IS_EXIST_DUPLICATE,"false")\
 [%f] set_var %( 'IS_EXIST_DUPLICATE' %, false )% 
//	<{}{}{%C}%f_add_to_list(CONTROL_LIST,"%f_to_upper("%CN")")>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   [%f] add_to_list %( 'CONTROL_LIST' %, [%f] to_upper %( %C |N )% )% 
   ++! l_Counter
  end // if
 end // for C
//	<{}{"%f_is_empty(CONTROL_LIST)"="false"&"%{IS_EXIST_DUPLICATE}N"="false"}{W}[%f_pop_first_to_var(CONTROL_LIST,EL)[{"%f_exists_in_list(CONTROL_LIST,"%{EL}N")"="true"}%{EL}N%f_set_var(IS_EXIST_DUPLICATE,"true")]]>\
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'CONTROL_LIST' )% ) %== false AND 
   ( ( ( get_global_var ( 'IS_EXIST_DUPLICATE' ) |N ) ) %== false  ) ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( 'CONTROL_LIST' %, 'EL' )% if ( ( [%f] exists_in_list %( 'CONTROL_LIST' %, ( get_global_var ( 'EL' ) |N ) )% ) %== true ) then
    begin
     ( get_global_var ( 'EL' ) |N ) [%f] set_var %( 'IS_EXIST_DUPLICATE' %, true )% 
    end // if
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//	%f_clear_list(CONTROL_LIST)
 [%f] clear_list %( 'CONTROL_LIST' )% 
//#UC END# *48B692B502E0for48A27E2101E1*
; // check_duplicate_attr


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for48A27E2101E1*
//c                                           {}
//r {"%S%f_check_duplicate_attr(%S)"!=""}:    {Duplicate Attribute in Setting container %SN: %S%f_check_duplicate_attr(%S)}
//r {<{}{%CC=Attribute}{C}>=0}:               {%SS не может быть пустым}
//#UC END# *4704C0E30186for48A27E2101E1*
; // constraint


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor48A27E2101E1*
//O [{<{}{%t_target(%P)=true}{C}>=0}<{}{%t_nested_scope_def(%P)=true}{r}%PN_>%SN.cpp]
//	[{<{}{%t_target(%P)=true}{C}>=0}\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( [%t] target %( %P )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for P
  l_Counter
  %== 0 ) then
 begin
//	%f_header(%S)
  [%f] header %( %S )% 
//	%f_std_inc(%S)
  [%f] std_inc %( %S )% 
//	\#include "shared/Core/Params/Params.h"
  '#include "shared/Core/Params/Params.h"'
//	[\#include %f_dump_include_path(%f_with_gen_id(h,%SW),%S)
  if NOT-EMPTY
  begin
   '#include '
   [%f] dump_include_path %( [%f] with_gen_id %( 'h' %, %S |W )% %, %S )% 
//	][
  end // if
  NOP
  if NOT-EMPTY
  begin
   #13#10

//	%S%f_open_ifdef()]\
   %S %f open_ifdef %( )% 
  end // if
  NOP
//	
  #13#10

//	[%SP[{%t_nested_scope_def(%P)=true}\n]\
  if NOT-EMPTY
  begin
   %S |P if ( ( [%t] nested_scope_def %( %P )% ) %==  true ) then
   begin
    #13#10 
   end // if
//	]<{}{%CC=Attribute}{%C}
  end // if
  NOP
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Attribute' ) then
   begin
    #13#10

//	[{"%C%TN"!="string"}{const std::string}%t_ret(%C%T,"const")] %f_function_scope(%S)get_%f_to_omg(%CN) () {
    if ( ( %C ->T |N  ) %!= 'string' ) then
    begin
     [%t] ret %( %C ->T  %, 'const' )% 
    end // if
    else
    begin
     'const std::string' 
    end // else
    ' '
    [%f] function_scope %( %S )% 'get_'
    [%f] to_omg %( %C |N )% ' () {'
//	[{"%CI"=""}	if (false == Core::ParamManagerFactory::get ().is_exist ("-%CN")) {
    if ( ( %C |I ) %== '' ) then
    begin
     '	if (false == Core::ParamManagerFactory::get ().is_exist ("-'
     %C |N ')) {'
//			throw Core::ParameterIsMissing ("-%CN");
     '		throw Core::ParameterIsMissing ("-'
     %C |N ');'
//		}
     '	}'
//	]\
    end // if
//	[{%S%t_direct_access(%C%T)=true}{%C%f_complex_return()}	%C%f_dump_get_impl()
    if ( ( %S %t direct_access %( %C ->T  )% ) %==  true ) then
    begin
     '	'
     %C %f dump_get_impl %( )% 
//	]}
    end // if
    else
    begin
     %C %f complex_return %( )% 
    end // else
    '}'
//	
    #13#10

//	void %f_function_scope(%S)set_%f_to_omg(%CN) ([{"%C%TN"!="string"}{const std::string&}%t_arg(%C%T,"in")] value) {
    'void '
    [%f] function_scope %( %S )% 'set_'
    [%f] to_omg %( %C |N )% ' ('
    if ( ( %C ->T |N  ) %!= 'string' ) then
    begin
     [%t] arg %( %C ->T  %, 'in' )% 
    end // if
    else
    begin
     'const std::string&' 
    end // else
    ' value) {'
//	[{%S%t_direct_access(%C%T)=true}{%C%f_complex_set()}	%C%f_dump_set_impl()
    if ( ( %S %t direct_access %( %C ->T  )% ) %==  true ) then
    begin
     '	'
     %C %f dump_set_impl %( )% 
//	]}
    end // if
    else
    begin
     %C %f complex_set %( )% 
    end // else
    '}'
//	
    #13#10

//	const char* %f_function_scope(%S)%f_to_omg(%CN)_param_name () {
    'const char* '
    [%f] function_scope %( %S )% [%f] to_omg %( %C |N )% '_param_name () {'
//		return "-%CN";
    '	return "-'
    %C |N ';'
//	}
    '}'
//	>

    ++! l_Counter
   end // if
  end // for C
//	]\
 end // if
//	%Sp
 %S |p 
//	%f_footer(%S)]
 [%f] footer %( %S )% ']'
//#UC END# *47022CB8034Bfor48A27E2101E1*
; // cpp


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor48A27E2101E1*
//O [{<{}{%t_target(%P)=true}{C}>=0&%t_nested_scope_def(%P)=false}%SN.h]
//	[{<{}{%t_target(%P)=true}{C}>=0}[{%t_nested_scope_def(%P)=false}\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%P
  begin
   OBJECT IN %P
   if ( ( [%t] target %( %P )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for P
  l_Counter
  %== 0 ) then
 begin
  if ( ( [%t] nested_scope_def %( %P )% ) %==  false ) then
  begin
//	%f_output_constraint(%S)\
   [%f] output_constraint %( %S )% 
//	%f_h_header(%S)
   [%f] h_header %( %S )% 
//	%f_std_inc(%S)
   [%f] std_inc %( %S )% 
//	%f_includes_by_contents(%S)<\#include %f_dump_include_path(%wL,%w)
   [%f] includes_by_contents %( %S )% 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%w
   begin
    OBJECT IN %w
    if true then
    begin
     '#include '
     [%f] dump_include_path %( %w |L %, %w )% 
//	>[

     ++! l_Counter
    end // if
   end // for w
   if NOT-EMPTY
   begin
    #13#10

//	%S%f_open_ifdef()]
    %S %f open_ifdef %( )% 
   end // if
   NOP
//	%SP
   %S |P 
//	]%f_docs(%S)\
  end // if
  [%f] docs %( %S )% 
//	#class %SN {
  out_indent 'class '
  %S |N ' {'
//	[<{}{"%aC"="Dependency"&"%aS"="friend"}{Sp}#friend class %f_type(%a%P); // defined friend
  if NOT-EMPTY
  begin
   INTEGER VAR l_Counter l_Counter := 0
   for %S%ap
   begin
    OBJECT IN %a
    if ( ( %a |C ) %== 'Dependency' AND 
     ( ( %a |S ) %== 'friend'  ) ) then
    begin
     out_indent 'friend class '
     [%f] type %( %a ->P  )% '; // defined friend'
//	>]

     ++! l_Counter
    end // if
   end // for a
  end // if
  NOP
//	#// static member methods and data
  out_indent '// static member methods and data'
//	[#public:<{}{"%CC"="Attribute"&"%CV"="PublicAccess"}{Sn}
  if NOT-EMPTY
  begin
   out_indent 'public:'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Cn
   begin
    OBJECT IN %C
    if ( ( %C |C ) %== 'Attribute' AND 
     ( ( %C |V ) %== 'PublicAccess'  ) ) then
    begin
     #13#10

//	%CX
     %C |X 
//	>

     ++! l_Counter
    end // if
   end // for C
//	]\
  end // if
  NOP
//	[#protected:<{}{"%CC"="Attribute"&"%CV"="ProtectedAccess"}{Sn}
  if NOT-EMPTY
  begin
   out_indent 'protected:'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Cn
   begin
    OBJECT IN %C
    if ( ( %C |C ) %== 'Attribute' AND 
     ( ( %C |V ) %== 'ProtectedAccess'  ) ) then
    begin
     #13#10

//	%CX
     %C |X 
//	>

     ++! l_Counter
    end // if
   end // for C
//	]\
  end // if
  NOP
//	[#private:<{}{"%CC"="Attribute"&"%CV"="PrivateAccess"}{Sn}
  if NOT-EMPTY
  begin
   out_indent 'private:'
   INTEGER VAR l_Counter l_Counter := 0
   for %S%Cn
   begin
    OBJECT IN %C
    if ( ( %C |C ) %== 'Attribute' AND 
     ( ( %C |V ) %== 'PrivateAccess'  ) ) then
    begin
     #13#10

//	%CX
     %C |X 
//	>

     ++! l_Counter
    end // if
   end // for C
//	]\
  end // if
  NOP
//	#}; // class %SN[{%t_nested_scope_def(%P)=false}
  out_indent '}; // class '
  %S |N if ( ( [%t] nested_scope_def %( %P )% ) %==  false ) then
  begin
   #13#10

//	
   #13#10

//	%Sp[
   %S |p if NOT-EMPTY
   begin
    #13#10

//	\#include %f_dump_include_path(%f_with_gen_id(i.h,%SL),%S)]
    '#include '
    [%f] dump_include_path %( [%f] with_gen_id %( 'i.h' %, %S |L )% %, %S )% 
   end // if
   NOP
//	%f_h_footer(%S)
   [%f] h_footer %( %S )% 
//	]]
  end // if
 end // if
//#UC END# *47022C88029Ffor48A27E2101E1*
; // h


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor48A27E2101E1*
//#UC END# *47022CCF00EAfor48A27E2101E1*
; // i.h


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: Settings::Class::Attribute
end. // <<Settings>>

implementation @ :: <<Settings>> <<Attribute>> ;
//? конкретный параметр доступный через настройки
// Параметры стереотипа
//v +
// - типы видимости
//Y code_settings_param.gif
//L code_settings_param

// Пользовательские свойства
//p in config:b=true ? Свойство определяет должен ли параметр попадать в файл настроек
//p is_required:b=false ? Признак обязательного параметра

// Генераторы
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor48A27E7F0092*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#static [{"%S%TN"!="string"}{const std::string}%t_ret(%S%T,"const")] get_%f_to_omg(%SN) () /* throw (Core::ParameterIsMissing) */;
 out_indent 'static '
 if ( ( %S ->T |N  ) %!= 'string' ) then
 begin
  [%t] ret %( %S ->T  %, 'const' )% 
 end // if
 else
 begin
  'const std::string' 
 end // else
 ' get_'
 [%f] to_omg %( %S |N )% ' () /* throw (Core::ParameterIsMissing) */;'
//	#static void set_%f_to_omg(%SN) ([{"%S%TN"!="string"}{const std::string&}%t_arg(%T,"in")] value);
 out_indent 'static void set_'
 [%f] to_omg %( %S |N )% ' ('
 if ( ( %S ->T |N  ) %!= 'string' ) then
 begin
  [%t] arg %( %T %, 'in' )% 
 end // if
 else
 begin
  'const std::string&' 
 end // else
 ' value);'
//	#static const char* %f_to_omg(%SN)_param_name ();
 out_indent 'static const char* '
 [%f] to_omg %( %S |N )% '_param_name ();'
//#UC END# *47022C88029Ffor48A27E7F0092*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor48A27E7F0092*
//#UC END# *47022CB8034Bfor48A27E7F0092*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor48A27E7F0092*
//#UC END# *47022CCF00EAfor48A27E7F0092*
; // i.h


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	[{"%S{is_required}"!="%S{!is_required}"}%f_up_prefix(%S) *is_required* = *%S{is_required}* - Признак обязательного параметра
 if ( ( %S get_up ( 'is_required' ) ) %!= ( %S get_up_def ( 'is_required' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *is_required* = *'
  %S get_up ( 'is_required' ) '* - Признак обязательного параметра'
//	][{"%S{in config}"!="%S{!in config}"}%f_up_prefix(%S) *in config* = *%S{in config}* - Свойство определяет должен ли параметр попадать в файл настроек
 end // if
 if ( ( %S get_up ( 'in config' ) ) %!= ( %S get_up_def ( 'in config' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *in config* = *'
  %S get_up ( 'in config' ) '* - Свойство определяет должен ли параметр попадать в файл настроек'
//	]
 end // if

// генерирует код возврата для типов на прямую не поддержиыаемых ParamМanаger-ом
//%f _complex_return
; // wiki_up_print

: complex_return OBJECT IN %S
//#UC START# *492B824000C5for48A27E7F0092*
//	[{%TS=Enum}	std::string enum_val = Core::ParamManagerFactory::get ().get_string ("-%SN"[{"%SI"!=""}, "%SI"]);
 if ( ( %T |S ) %== 'Enum' ) then
 begin
  '	std::string enum_val = Core::ParamManagerFactory::get ().get_string ("-'
  %S |N if ( ( %S |I ) %!= '' ) then
  begin
   ', "'
   %S |I 
  end // if
  ');'
//		%T<if (enum_val == "%CN") return [%C%P<%NN::>]%CN;
  '	'
  %T
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     'if (enum_val == "'
     %C |N ') return '
     if NOT-EMPTY
     begin
      %C ->P
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       end // if
     NOP
     %C |N ';'
//		>
     '	' 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
 //		throw Core::ParameterIsMissing ("-%SN");
  '	throw Core::ParameterIsMissing ("-'
  %S |N ');'
//	][{%TS=UMLPrimitive&%TN=boolean}[{"%SI"=""}	if (false == Core::ParamManagerFactory::get ().is_exist ("-%SN")) {
 end // if
 if ( ( %T |S ) %== 'UMLPrimitive' AND 
   ( ( %T |N ) %== 'boolean'  ) ) then
 begin
  if ( ( %S |I ) %== '' ) then
  begin
   '	if (false == Core::ParamManagerFactory::get ().is_exist ("-'
   %S |N ')) {'
//			throw Core::ParameterIsMissing ("-%SN");
   '		throw Core::ParameterIsMissing ("-'
   %S |N ');'
//		}
   '	}'
//	]	return Core::ParamManagerFactory::get ().get_ulong ("-%SN"[{"%SI"!=""}, %f_str_replace(%t_init_cpp(%S),\\,\\\\)]) \> 0 ? true : false;
  end // if
  '	return Core::ParamManagerFactory::get ().get_ulong ("-'
  %S |N if ( ( %S |I ) %!= '' ) then
  begin
   ', '
   [%f] str_replace %( [%t] init_cpp %( %S )% %, '\' %, '\\' )% 
  end // if
  ') > 0 ? true : false;'
//	]
 end // if
//#UC END# *492B824000C5for48A27E7F0092*
; // complex_return


// генерирует код установки значения для типов на прямую не поддержиыаемых ParamМanаger-ом
//%f _complex_set
: complex_set OBJECT IN %S
//#UC START# *492B82430369for48A27E7F0092*
//	[{%TS=Enum}	std::string enum_val;
 if ( ( %T |S ) %== 'Enum' ) then
 begin
  '	std::string enum_val;'
//		switch (value) {
  '	switch (value) {'
//	%T<{\n}		case [%C%P<%NN::>]%CN: enum_val = "%CN";
  %T
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( #13#10 )
     '		case '
     if NOT-EMPTY
     begin
      %C ->P
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%N
       begin
        OBJECT IN %N
        if true then
        begin
         %N |N '::' 
         ++! l_Counter
        end // if
       end // for N

      ) // bind
       end // if
     NOP
     %C |N ': enum_val = "'
     %C |N ';'
//				break;>
     '			break;' 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
 //			default: break;
  '		default: break;'
//		}
  '	}'
//		Core::ParamManagerFactory::get ().set_string("-%SN", enum_val.c_str());
  '	Core::ParamManagerFactory::get ().set_string("-'
  %S |N ', enum_val.c_str());'
//	][{%TS=UMLPrimitive&%TN=boolean}	Core::ParamManagerFactory::get ().set_ulong("-%SN", value);
 end // if
 if ( ( %T |S ) %== 'UMLPrimitive' AND 
   ( ( %T |N ) %== 'boolean'  ) ) then
 begin
  '	Core::ParamManagerFactory::get ().set_ulong("-'
  %S |N ', value);'
//	]
 end // if
//#UC END# *492B82430369for48A27E7F0092*
; // complex_set


// генерит приведение типа, если оно необходимо
//%f _dump_cast
: dump_cast OBJECT IN %S
//#UC START# *492B81C90201for48A27E7F0092*
//	[{%TN!=long&%TN!=unsigned long&%f_is_string(%T)=false}static_cast\<%t_ret(%T,"const")\>]
 if ( ( %T |N ) %!= 'long' AND 
   ( ( %T |N ) %!= 'unsigned long'  ) AND 
   ( ( [%f] is_string %( %T )% ) %==  false  ) ) then
 begin
  'static_cast<'
  [%t] ret %( %T %, 'const' )% '>' 
 end // if
//#UC END# *492B81C90201for48A27E7F0092*
; // dump_cast


// генерит реализацию метода get для получения значения параметра
//%f _dump_get_impl
: dump_get_impl OBJECT IN %S
//#UC START# *492B9F400206for48A27E7F0092*
//	%f_set_var(CAST_STR,"%S%f_dump_cast()")\
 [%f] set_var %( 'CAST_STR' %, %S %f dump_cast %( )% )% 
//	return [{"%{CAST_STR}N"!=""}%{CAST_STR}N (]Core::ParamManagerFactory::get ().get_%t_type_to_param_method(%S,%T) ("-%SN"[{"%SI"!=""}, %f_str_replace(%t_init_cpp(%S),\\,\\\\)])[{"%{CAST_STR}N"!=""})];
 'return '
 if ( ( ( get_global_var ( 'CAST_STR' ) |N ) ) %!= '' ) then
 begin
  ( get_global_var ( 'CAST_STR' ) |N ) ' (' 
 end // if
 'Core::ParamManagerFactory::get ().get_'
 [%t] type_to_param_method %( %S %, %T )% ' ("-'
 %S |N '"'
 if ( ( %S |I ) %!= '' ) then
 begin
  ', '
  [%f] str_replace %( [%t] init_cpp %( %S )% %, '\' %, '\\' )% 
 end // if
 ')'
 if ( ( ( get_global_var ( 'CAST_STR' ) |N ) ) %!= '' ) then
 begin
  ')' 
 end // if
 ';'
//#UC END# *492B9F400206for48A27E7F0092*
; // dump_get_impl


// генерит реализациб метода set ля установки значения параметра
//%f _dump_set_impl
: dump_set_impl OBJECT IN %S
//#UC START# *492B9F7001FAfor48A27E7F0092*
//	Core::ParamManagerFactory::get ().set_%t_type_to_param_method(%S,%T) ("-%SN",[{"%TN"!="string"&"%TN"!="a-string"}{ value.c_str()} value]);
 'Core::ParamManagerFactory::get ().set_'
 [%t] type_to_param_method %( %S %, %T )% ' ("-'
 %S |N '",'
 if ( ( %T |N ) %!= 'string' AND 
   ( ( %T |N ) %!= 'a-string'  ) ) then
 begin
  ' value' 
 end // if
 else
 begin
  ' value.c_str()' 
 end // else
 ');'
//#UC END# *492B9F7001FAfor48A27E7F0092*
; // dump_set_impl


// Функция возвращает true, если параметр может попадать в файл настроек, иначе - false
//%f _in_config
: in_config OBJECT IN %S
//#UC START# *493F5C8F02AFfor48A27E7F0092*
//	[{"%SI"!="EMPTY_STR"&%S{in config}=true}{false}true]
 if ( ( %S |I ) %!= 'EMPTY_STR' AND 
   ( ( %S get_up ( 'in config' ) ) %==  true  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *493F5C8F02AFfor48A27E7F0092*
; // in_config


// генерит код для вывода описания параметра в стандартный поток
//%f _print_usage
: print_usage OBJECT IN %S
//#UC START# *492A93F303C8for48A27E7F0092*
//	%f_set_var(PARAM_NAME,"-%SN: ([{%TS=Enum}{%TN}%TN: %T<{, }%CN>])")\
 [%f] set_var %( 'PARAM_NAME' %, '-'
 %S |N ': ('
 if ( ( %T |S ) %== 'Enum' ) then
 begin
  %T |N ': '
  %T
  bind ( 
   OBJECT VAR %S
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if true then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     %C |N 
     ++! l_Counter
    end // if
   end // for C

  ) // bind
  end // if
 else
 begin
  %T |N 
 end // else
 ')' )% 
//	%f_set_var(LEN,"%f_string_length(%{PARAM_NAME}N)")\
 [%f] set_var %( 'LEN' %, [%f] string_length %( ( get_global_var ( 'PARAM_NAME' ) |N ) )% )% 
//	%f_set_var(ADDITION_LEN,"%f_evaluate(25 - %{LEN}N)")\
 [%f] set_var %( 'ADDITION_LEN' %, [%f] evaluate %( 25 ' - '
 ( get_global_var ( 'LEN' ) |N ) )% )% 
//	[{%f_number_cmp("%{ADDITION_LEN}N","0","\>")=0}%f_set_var(CUT_LEN,"%f_evaluate(%{LEN}N - 25)")]\
 if ( ( [%f] number_cmp %( ( get_global_var ( 'ADDITION_LEN' ) |N ) %, 0 %, '>' )% ) %== 0 ) then
 begin
  [%f] set_var %( 'CUT_LEN' %, [%f] evaluate %( ( get_global_var ( 'LEN' ) |N ) ' - 25' )% )% 
 end // if
//	%f_split_to_list(SPLITED,%f_str_split([{%f_number_cmp("%{ADDITION_LEN}N","0","\>")=0}%f_substr_from_end(%{PARAM_NAME}N,%{CUT_LEN}N)][{"%SD"!=""} - %f_str_replace(%f_str_replace(%SD,\\,\\\\),%f_dump_q(%S),%f_dump_escq(%S))],,\\n%f_repeat_str(" ","25"),50),\\n)\
 [%f] split_to_list %( 'SPLITED' %, [%f] str_split %( if ( ( [%f] number_cmp %( ( get_global_var ( 'ADDITION_LEN' ) |N ) %, 0 %, '>' )% ) %== 0 ) then
 begin
  [%f] substr_from_end %( ( get_global_var ( 'PARAM_NAME' ) |N ) %, ( get_global_var ( 'CUT_LEN' ) |N ) )% 
 end // if
 if ( ( %S |D ) %!= '' ) then
 begin
  ' - '
  [%f] str_replace %( [%f] str_replace %( %S |D %, '\' %, '\\' )% %, [%f] dump_q %( %S )% %, [%f] dump_escq %( %S )% )% 
 end // if
%, '' %,  '\n'
 [%f] repeat_str %( ' "' %, 25 )% %, 50 )% %, '\n' )% 
//		std::cout \<\< "[{%f_number_cmp("%{ADDITION_LEN}N","0","\>")=1}{%f_delsubstr_from_end(%{PARAM_NAME}N,%{CUT_LEN}N)}%{PARAM_NAME}N[{"%SD"!=""}%f_repeat_str(" ","%{ADDITION_LEN}N")]][{%f_is_empty(SPLITED)=true&"%SI"=""}\\n";]\
 '	std::cout << "'
 if ( ( [%f] number_cmp %( ( get_global_var ( 'ADDITION_LEN' ) |N ) %, 0 %, '>' )% ) %== 1 ) then
 begin
  ( get_global_var ( 'PARAM_NAME' ) |N ) if ( ( %S |D ) %!= '' ) then
  begin
   [%f] repeat_str %( ' "' %, ( get_global_var ( 'ADDITION_LEN' ) |N ) )% 
  end // if
 end // if
 else
 begin
  [%f] delsubstr_from_end %( ( get_global_var ( 'PARAM_NAME' ) |N ) %, ( get_global_var ( 'CUT_LEN' ) |N ) )% 
 end // else
 if ( ( [%f] is_empty %( 'SPLITED' )% ) %==  true AND 
   ( ( %S |I ) %== ''  ) ) then
 begin
  '\n";' 
 end // if
//	%f_set_var(FIRST_FLAG,"false")%f_set_var(SPLIT_SIZE,"%f_size_list(SPLITED)")\
 [%f] set_var %( 'FIRST_FLAG' %, false )% [%f] set_var %( 'SPLIT_SIZE' %, [%f] size_list %( 'SPLITED' )% )% 
//	<{}{%f_is_empty(SPLITED)=false}{W}[%f_pop_first_to_var(SPLITED,_SPLTD_)[{"%{FIRST_FLAG}N"="false"}{	std::cout \<\< "%{_SPLTD_}N\\n";
 INTEGER VAR l_Counter l_Counter := 0
 while true
 begin
  if ( ( [%f] is_empty %( 'SPLITED' )% ) %==  false ) then
  begin
   if NOT-EMPTY
   begin
    [%f] pop_first_to_var %( 'SPLITED' %, '_SPLTD_' )% if ( ( ( get_global_var ( 'FIRST_FLAG' ) |N ) ) %== false ) then
    begin
     ( get_global_var ( '_SPLTD_' ) |N ) if ( ( [%f] number_cmp %( ( get_global_var ( 'SPLIT_SIZE' ) |N ) %, 1 %, '>' )% ) %== 1 OR 
       ( ( %S |D ) %!= ''  ) ) then
     begin
      '\n";'
//	]%f_set_var(FIRST_FLAG,"true")]]>\
     end // if
     [%f] set_var %( 'FIRST_FLAG' %, true )% 
    end // if
    else
    begin
     '	std::cout << "'
     ( get_global_var ( '_SPLTD_' ) |N ) '\n";'
//	}%{_SPLTD_}N[{%f_number_cmp("%{SPLIT_SIZE}N","1","\>")=1|"%SD"!=""}\\n";
    end // else
   end // if
   NOP

   ++! l_Counter
  end // if
  else
   break
 end // while
//	[{"%SI"!=""}[{%f_number_cmp("%{SPLIT_SIZE}N","1","\>")=1|"%SD"!=""}{= %f_str_replace(%f_str_replace(%SI,\\,\\\\),%f_dump_q(%S),%f_dump_escq(%S))\\n";}\
 if ( ( %S |I ) %!= '' ) then
 begin
  if ( ( [%f] number_cmp %( ( get_global_var ( 'SPLIT_SIZE' ) |N ) %, 1 %, '>' )% ) %== 1 OR 
    ( ( %S |D ) %!= ''  ) ) then
  begin
//	%f_str_split( = %f_str_replace(%f_str_replace(%SI,\\,\\\\),%f_dump_q(%S),%f_dump_escq(%S))\\n%f_dump_q(%S);,	std::cout \<\< %f_dump_q(%S)%f_repeat_str(" ","25"),\\n%f_dump_q(%S);\n,90)]]
   [%f] str_split %( ' = '
   [%f] str_replace %( [%f] str_replace %( %S |I %, '\' %, '\\' )% %, [%f] dump_q %( %S )% %, [%f] dump_escq %( %S )% )% '\n'
   [%f] dump_q %( %S )% ';' %, '	std::cout << '
   [%f] dump_q %( %S )% [%f] repeat_str %( ' "' %, 25 )% %, '\n'
   [%f] dump_q %( %S )% ';'#13#10 %, 90 )% 
  end // if
  else
  begin
   '= '
   [%f] str_replace %( [%f] str_replace %( %S |I %, '\' %, '\\' )% %, [%f] dump_q %( %S )% %, [%f] dump_escq %( %S )% )% '\n";' 
  end // else
 end // if
//#UC END# *492A93F303C8for48A27E7F0092*
; // print_usage



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<Settings>> <<Attribute>> ;

