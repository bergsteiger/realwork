////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/DelphiSpecific/DelphiLang/Interface/StaticObject.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$ForDelphi::DelphiSpecific::DelphiLang::Interface::StaticObject
//
// Статический объект
// ---
// Определяет элемент реализации (пока может находится в интерфейсных пакетах, потом должен быть
// перенёс только в пакеты реализации), экземпляры которого можно создавать на стеке. Аналог
// Struct, но с методами и наследованием.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: StaticObject::Class
implementation @ <<StaticObject>>
//? Статический объект
//? Определяет элемент реализации (пока может находится в интерфейсных пакетах, потом должен быть перенёс только в пакеты реализации), экземпляры которого можно создавать на стеке. Аналог Struct, но с методами и наследованием.
//> method::Class
//> Constructor::Class

//= UsesContainer::Class
//= InterfaceTypesInclude::Class
//= StaticObjectPrim::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//Y code_struct.gif
//L code_struct
//D
// - запрещена форвард-декларация
// Параметры визуализации
//$ C 240,230,210
//$ l 100,75,35
//$ f 100,75,35
//d 1
// - может иметь унаследованную реализацию

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p packed:b=false ? определяет упакованность структуры
//p IsAutoHelper:b=false ? Определяет, что объект является автоматическим helper'ом для интерфейса
//p not treat as record for XE4:tribool=undefined ? 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{packed}"!="%S{!packed}"}%f_up_prefix(%S) *packed* = *%S{packed}* - определяет упакованность структуры
 ?inherited
 if ( ( %S get_up ( 'packed' ) ) %!= ( %S get_up_def ( 'packed' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *packed* = *'
  %S get_up ( 'packed' ) '* - определяет упакованность структуры'
//	][{"%S{IsAutoHelper}"!="%S{!IsAutoHelper}"}%f_up_prefix(%S) *IsAutoHelper* = *%S{IsAutoHelper}* - Определяет, что объект является автоматическим helper'ом для интерфейса
 end // if
 if ( ( %S get_up ( 'IsAutoHelper' ) ) %!= ( %S get_up_def ( 'IsAutoHelper' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *IsAutoHelper* = *'
  %S get_up ( 'IsAutoHelper' ) '* - Определяет, что объект является автоматическим helper'ом для интерфейса'
//	][{"%S{not treat as record for XE4}"!="%S{!not treat as record for XE4}"}%f_up_prefix(%S) *not treat as record for XE4* = *%S{not treat as record for XE4}*
 end // if
 if ( ( %S get_up ( 'not treat as record for XE4' ) ) %!= ( %S get_up_def ( 'not treat as record for XE4' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *not treat as record for XE4* = *'
  %S get_up ( 'not treat as record for XE4' ) '*'
//	]
 end // if

//%f _IsConstructorsHolder
; // wiki_up_print

: IsConstructorsHolder OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4E0B58C0032Ffor4739862802BF*
//@ %SU
//	[{%Gx=true&<{}{%C#f_IsConstructor()!=true}{C}>=0}{\
 if ( ( %G |x ) %==  true AND 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f IsConstructor %( )% ) %!=  true ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %== 0  ) ) then
 begin
//	true\
   true 
//	]
 end // if
 else
 begin
//	false\
   false 
//	}\
 end // else
// - избегаем ситуации с кривой финализацией наследуемых статических объектов
//#UC END# *4E0B58C0032Ffor4739862802BF*
; // IsConstructorsHolder


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет, что метод должен быть реализован публично
//%f _IsPublicRealizedMethod
: IsPublicRealizedMethod OBJECT IN %S
// параметры: aMethod: void = %1
//#UC START# *4A42517502CEfor4739862802BF*
//	true
 true
//#UC END# *4A42517502CEfor4739862802BF*
; // IsPublicRealizedMethod


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _IsStaticObject
: IsStaticObject OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4B6C3C5C01FCfor4739862802BF*
//	true
 true
//#UC END# *4B6C3C5C01FCfor4739862802BF*
; // IsStaticObject


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Добавляет файлы необходимые элементу с точки зрения метамодели
//%f _pas_ImplUses
: pas_ImplUses OBJECT IN %S
//#UC START# *4948EB2601FAfor4739862802BF*
//	%S%[inherited]\
 inherited
//	<{}{%aC=Dependency&%aS=injects}{Sg}\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%ag
 begin
  OBJECT IN %a
  if ( ( %a |C ) %== 'Dependency' AND 
   ( ( %a |S ) %== 'injects'  ) ) then
  begin
//	%f_pas_PutToUses(%a%P)\
   [%f] pas_PutToUses %( %a ->P  )% 
//	>

   ++! l_Counter
  end // if
 end // for a
//#UC END# *4948EB2601FAfor4739862802BF*
; // pas_ImplUses


// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for4739862802BF*
//c	{}
//r {""=""}: {}
//#UC END# *4704C0E30186for4739862802BF*
; // constraint


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor4739862802BF*
//R  
//	%f_pas_OutClassImplementation(%S)\
 [%f] pas_OutClassImplementation %( %S )% 

//	[{%S{IsAutoHelper}=true|<{}{%C#f_IsProp()=true&%C{reads field}!=true}{C}>!=0}\
 if ( ( %S get_up ( 'IsAutoHelper' ) ) %==  true OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f IsProp %( )% ) %==  true AND 
    ( ( %C get_up ( 'reads field' ) ) %!=  true  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0  ) ) then
 begin
//	%f_pas_OpenMethodImplementation("Fake",%S)\
  [%f] pas_OpenMethodImplementation %( 'Fake"' %, %S )% 
//	\{$IfNDef XE4\}
  '{$IfNDef XE4}'
//	procedure %f_pas_TypeName(%S).Fake;
  'procedure '
  [%f] pas_TypeName %( %S )% '.Fake;'
//	begin
  'begin'
//	 Assert(false);
  ' Assert(false);'
//	end;
  'end;'
//	\{$EndIf XE4\}\
  '{$EndIf XE4}'


//	%f_pas_OpenMethodImplementation("Init",%S)\
  [%f] pas_OpenMethodImplementation %( 'Init"' %, %S )% 
//	constructor %f_pas_TypeName(%S).Init[{%S{IsAutoHelper}=true}(const anIntf: %f_pas_TypeName(%R))];
  'constructor '
  [%f] pas_TypeName %( %S )% '.Init'
  if ( ( %S get_up ( 'IsAutoHelper' ) ) %==  true ) then
  begin
   '(const anIntf: '
   [%f] pas_TypeName %( %R )% ')' 
  end // if
  ';'
//	begin
  'begin'
//	[{%S{IsAutoHelper}=true}{\
  if ( ( %S get_up ( 'IsAutoHelper' ) ) %==  true ) then
  begin
//	 f_%RN := anIntf;
   ' f_'
   %R |N ' := anIntf;'
//	]\
  end // if
  else
  begin
//	%f_with_gen_id(intf.pas,\
   [%f] with_gen_id %( 'intf.pas' %, 
//	%U[{Init}
   %Usersection (
    'Init' 
   )
   (
    #13#10

//	 !!! Needs to be implemented !!!
    ' !!! Needs to be implemented !!!'
//	]

   ) // Usersection
 //	)\
)% //	}\
  end // else
//	end;\
  'end;'
//	]\
 end // if

//	[{%S{IsAutoHelper}=true}\
 if ( ( %S get_up ( 'IsAutoHelper' ) ) %==  true ) then
 begin
//	%f_pas_OpenMethodImplementation("IsValid",%S)\
  [%f] pas_OpenMethodImplementation %( 'IsValid"' %, %S )% 
//	function %f_pas_TypeName(%S).IsValid: Boolean;
  'function '
  [%f] pas_TypeName %( %S )% '.IsValid: Boolean;'
//	begin
  'begin'
//	 Result := (f_%RN \<\> nil);
  ' Result := (f_'
  %R |N ' <> nil);'
//	end;\
  'end;'
//	%f_pas_OpenMethodImplementation("Free",%S)\
  [%f] pas_OpenMethodImplementation %( 'Free"' %, %S )% 
//	procedure %f_pas_TypeName(%S).Free;
  'procedure '
  [%f] pas_TypeName %( %S )% '.Free;'
//	begin
  'begin'
//	 f_%RN := nil;
  ' f_'
  %R |N ' := nil;'
//	 inherited;
  ' inherited;'
//	end;\
  'end;'
//	]
 end // if
//#UC END# *470F15B800CBfor4739862802BF*
; // impl.pas


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor4739862802BF*
//	[{%f_exists_in_list(GENERATED_INTF,"%f_pas_TypeName(%S)")!=true}\
 if ( ( [%f] exists_in_list %( 'GENERATED_INTF' %, [%f] pas_TypeName %( %S )% )% ) %!=  true ) then
 begin
//	%f_add_to_list(GENERATED_INTF,"%f_pas_TypeName(%S)")\
  [%f] add_to_list %( 'GENERATED_INTF' %, [%f] pas_TypeName %( %S )% )% 
//	%f_shift_intend(-1)\
  [%f] shift_intend %( -1 )% 
//	<{}{%CV!=PrivateAccess&%C%f_IsClassInner()!=true&"%CO"=""}[{%CS!=Typedef|%C%GU!=%SU|%C{isClassRef}=true}[%CX\n]]>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |V ) %!= 'PrivateAccess' AND 
    ( ( %C %f IsClassInner %( )% ) %!=  true  ) AND 
    ( ( %C |O ) %== ''  ) ) then
   begin
    if ( ( %C |S ) %!= 'Typedef' OR 
      ( ( %C ->G |U  ) %!= ( %S |U )  ) OR 
      ( ( %C get_up ( 'isClassRef' ) ) %==  true  ) ) then
    begin
     if NOT-EMPTY
     begin
      %C |X #13#10 
     end // if
     NOP
    end // if

    ++! l_Counter
   end // if
  end // for C
//	%f_shift_intend(+1)\
  [%f] shift_intend %( 1 )% 

//	[{%S#f_IsConstructorsHolder()!=true}\
  if ( ( %S %?f IsConstructorsHolder %( )% ) %!=  true ) then
  begin
//	%f_pas_OpenType(%S)\
   [%f] pas_OpenType %( %S )% 
//	[{%S{need UC}=true}%U[{ci}\n]\n]\
   if ( ( %S get_up ( 'need UC' ) ) %==  true ) then
   begin
    %Usersection (
     'ci' 
    )
    (
     #13#10 
    ) // Usersection
     #13#10 
   end // if


//	#%f_pas_TypeName(%S) = [{%S{packed}=true}packed ]\
   out_indent [%f] pas_TypeName %( %S )% ' = '
   if ( ( %S get_up ( 'packed' ) ) %==  true ) then
   begin
    'packed ' 
   end // if


//	[{%S{not treat as record for XE4}!=true}\
   if ( ( %S get_up ( 'not treat as record for XE4' ) ) %!=  true ) then
   begin
//	\{$IfDef XE4\}\
    '{$IfDef XE4}'
//	record\
    'record'
//	\{$Else\}\
    '{$Else}'
//	]\
   end // if


//	object[(%GN)]\
   'object'
   if NOT-EMPTY
   begin
    '('
    %G |N ')' 
   end // if
   NOP


//	[{%S{not treat as record for XE4}!=true}\
   if ( ( %S get_up ( 'not treat as record for XE4' ) ) %!=  true ) then
   begin
//	\{$EndIf\}\
    '{$EndIf}'
//	]\
   end // if


//	[\n# \{* %f_Doc(%S) \}]
   if NOT-EMPTY
   begin
    #13#10
    out_indent ' {* '
    [%f] Doc %( %S )% ' }' 
   end // if
   NOP


//	[{%S{not treat as record for XE4}!=true}\
   if ( ( %S get_up ( 'not treat as record for XE4' ) ) %!=  true ) then
   begin
//	[{%Gx=true}\
    if ( ( %G |x ) %==  true ) then
    begin
//	#\{$IfDef XE4\}
     out_indent '{$IfDef XE4}'
//	#public\n#\
     out_indent 'public'#13#10
     out_indent 
//	 r%f_pas_TypeName(%G) : %f_pas_TypeName(%G);\n\
     ' r'
     [%f] pas_TypeName %( %G )% ' : '
     [%f] pas_TypeName %( %G )% ';'#13#10
//	#\{$EndIf XE4\}\n\
     out_indent '{$EndIf XE4}'#13#10
//	]\
    end // if
//	]\
   end // if


//	[{%S{IsAutoHelper}=true}#private\n#\
   if ( ( %S get_up ( 'IsAutoHelper' ) ) %==  true ) then
   begin
    out_indent 'private'#13#10
    out_indent 
//	 f_%RN : %f_pas_TypeName(%R);\n\
    ' f_'
    %R |N ' : '
    [%f] pas_TypeName %( %R )% ';'#13#10
//	]\
   end // if



//	[#private

//	#// property fields

//	%f_with_gen_id(intf3.pas,<{}{%C#f_IsStaticObject()!=true&%C#f_IsStruct()!=true}[%CX\n]>)]\


//	[#private\n#\
   if NOT-EMPTY
   begin
    out_indent 'private'#13#10
    out_indent 
//	<{\n#}{%CV=PrivateAccess&%C#f_IsConstructor()!=true&%C%f_IsClassInner()=true&%C#f_IsAttribute()=true}%CX>\n]\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |V ) %== 'PrivateAccess' AND 
      ( ( %C %?f IsConstructor %( )% ) %!=  true  ) AND 
      ( ( %C %f IsClassInner %( )% ) %==  true  ) AND 
      ( ( %C %?f IsAttribute %( )% ) %==  true  ) ) then
     begin
      if ( l_Counter >0 ) then ( #13#10
      out_indent )
      %C |X 
      ++! l_Counter
     end // if
    end // for C
    #13#10 
   end // if
   NOP


//	[#protected\n#\
   if NOT-EMPTY
   begin
    out_indent 'protected'#13#10
    out_indent 
//	<{\n#}{%CV=ProtectedAccess&%C#f_IsConstructor()!=true&%C%f_IsClassInner()=true&%C#f_IsAttribute()=true}%CX>\n]\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |V ) %== 'ProtectedAccess' AND 
      ( ( %C %?f IsConstructor %( )% ) %!=  true  ) AND 
      ( ( %C %f IsClassInner %( )% ) %==  true  ) AND 
      ( ( %C %?f IsAttribute %( )% ) %==  true  ) ) then
     begin
      if ( l_Counter >0 ) then ( #13#10
      out_indent )
      %C |X 
      ++! l_Counter
     end // if
    end // for C
    #13#10 
   end // if
   NOP


//	[#private\n#\
   if NOT-EMPTY
   begin
    out_indent 'private'#13#10
    out_indent 
//	<{\n#}{%CV=PrivateAccess&%C#f_IsConstructor()!=true&%C%f_IsClassInner()=true&%C#f_IsAttribute()!=true}%CX>\n]\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |V ) %== 'PrivateAccess' AND 
      ( ( %C %?f IsConstructor %( )% ) %!=  true  ) AND 
      ( ( %C %f IsClassInner %( )% ) %==  true  ) AND 
      ( ( %C %?f IsAttribute %( )% ) %!=  true  ) ) then
     begin
      if ( l_Counter >0 ) then ( #13#10
      out_indent )
      %C |X 
      ++! l_Counter
     end // if
    end // for C
    #13#10 
   end // if
   NOP


//	[#protected\n#\
   if NOT-EMPTY
   begin
    out_indent 'protected'#13#10
    out_indent 
//	<{\n#}{%CV=ProtectedAccess&%C#f_IsConstructor()!=true&%C%f_IsClassInner()=true&%C#f_IsAttribute()!=true}%CX>\n]\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |V ) %== 'ProtectedAccess' AND 
      ( ( %C %?f IsConstructor %( )% ) %!=  true  ) AND 
      ( ( %C %f IsClassInner %( )% ) %==  true  ) AND 
      ( ( %C %?f IsAttribute %( )% ) %!=  true  ) ) then
     begin
      if ( l_Counter >0 ) then ( #13#10
      out_indent )
      %C |X 
      ++! l_Counter
     end // if
    end // for C
    #13#10 
   end // if
   NOP


//	[#protected
   if NOT-EMPTY
   begin
    out_indent 'protected'
//	#// property methods
    out_indent '// property methods'
//	<{}{%C#f_IsProp()=true}[%CX\n]>]\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C %?f IsProp %( )% ) %==  true ) then
     begin
      if NOT-EMPTY
      begin
       %C |X #13#10 
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP


//	[{%S{not treat as record for XE4}!=true}{\
   if ( ( %S get_up ( 'not treat as record for XE4' ) ) %!=  true ) then
   begin


//	[#\
    if NOT-EMPTY
    begin
     out_indent 
//	\{$IfDef XE4\}\
     '{$IfDef XE4}'
//	private\
     'private'
//	\{$Else\}\
     '{$Else}'
//	protected\
     'protected'
//	\{$EndIf\}\
     '{$EndIf}'
//	\n#\
     #13#10
     out_indent 

//	// realized methods
     '// realized methods'
//	<{\n}{%oS!=inline}\
     INTEGER VAR l_Counter l_Counter := 0
     for %S%o
     begin
      OBJECT IN %o
      if ( ( %o |S ) %!= 'inline' ) then
      begin
       if ( l_Counter >0 ) then ( #13#10 )
//	[{%o#f_IsAttribute()=true|%S%f_IsPublicRealizedMethod(%o)!=true}\
       if ( ( %o %?f IsAttribute %( )% ) %==  true OR 
         ( ( %S %f IsPublicRealizedMethod %( %o )% ) %!=  true  ) ) then
       begin
//	%o%f_pas_MethodInterface(%S,"r")\
        %o %f pas_MethodInterface %( %S %, 'r' )% 
//	]>\
       end // if

       ++! l_Counter
      end // if
     end // for o
//	\n\
     #13#10
//	]\
    end // if
    NOP


//	]\
   end // if
   else
   begin


//	[#\
    if NOT-EMPTY
    begin
     out_indent 
//	protected\
     'protected'
//	\n#\
     #13#10
     out_indent 

//	// realized methods
     '// realized methods'
//	<{\n}{%oS!=inline}\
     INTEGER VAR l_Counter l_Counter := 0
     for %S%o
     begin
      OBJECT IN %o
      if ( ( %o |S ) %!= 'inline' ) then
      begin
       if ( l_Counter >0 ) then ( #13#10 )
//	[{%o#f_IsAttribute()=true|%S%f_IsPublicRealizedMethod(%o)!=true}\
       if ( ( %o %?f IsAttribute %( )% ) %==  true OR 
         ( ( %S %f IsPublicRealizedMethod %( %o )% ) %!=  true  ) ) then
       begin
//	%o%f_pas_MethodInterface(%S,"r")\
        %o %f pas_MethodInterface %( %S %, 'r' )% 
//	]>\
       end // if

       ++! l_Counter
      end // if
     end // for o
//	\n\
     #13#10
//	]\
    end // if
    NOP


//	}\
   end // else


//	[#public\n#\
   if NOT-EMPTY
   begin
    out_indent 'public'#13#10
    out_indent 
//	// realized methods
    '// realized methods'
//	<{\n}{%oS!=inline}\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%o
    begin
     OBJECT IN %o
     if ( ( %o |S ) %!= 'inline' ) then
     begin
      if ( l_Counter >0 ) then ( #13#10 )
//	[{%o#f_IsAttribute()!=true&%S%f_IsPublicRealizedMethod(%o)=true}\
      if ( ( %o %?f IsAttribute %( )% ) %!=  true AND 
        ( ( %S %f IsPublicRealizedMethod %( %o )% ) %==  true  ) ) then
      begin
//	%o%f_pas_MethodInterface(%S,"r")\
       %o %f pas_MethodInterface %( %S %, 'r' )% 
//	]>\n]\
      end // if

      ++! l_Counter
     end // if
    end // for o
    #13#10 
   end // if
   NOP


//	[#public\n#\
   if NOT-EMPTY
   begin
    out_indent 'public'#13#10
    out_indent 
//	\
//	<{\n#}{%C#f_IsProp()!=true&%CV=PublicAccess&%C#f_IsConstructor()!=true&%C%f_IsClassInner()=true&%C#f_IsAttribute()=true}\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C %?f IsProp %( )% ) %!=  true AND 
      ( ( %C |V ) %== 'PublicAccess'  ) AND 
      ( ( %C %?f IsConstructor %( )% ) %!=  true  ) AND 
      ( ( %C %f IsClassInner %( )% ) %==  true  ) AND 
      ( ( %C %?f IsAttribute %( )% ) %==  true  ) ) then
     begin
      if ( l_Counter >0 ) then ( #13#10
      out_indent )
//	%CX\
      %C |X 
//	>\n\

      ++! l_Counter
     end // if
    end // for C
    #13#10
//	]\
   end // if
   NOP


//	[#public\n#\
   if NOT-EMPTY
   begin
    out_indent 'public'#13#10
    out_indent 
//	\
//	<{\n#}{%CV=PublicAccess&%C#f_IsConstructor()!=true&%C%f_IsClassInner()=true&%C#f_IsAttribute()!=true}\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |V ) %== 'PublicAccess' AND 
      ( ( %C %?f IsConstructor %( )% ) %!=  true  ) AND 
      ( ( %C %f IsClassInner %( )% ) %==  true  ) AND 
      ( ( %C %?f IsAttribute %( )% ) %!=  true  ) ) then
     begin
      if ( l_Counter >0 ) then ( #13#10
      out_indent )
//	%CX\
      %C |X 
//	>\n\

      ++! l_Counter
     end // if
    end // for C
    #13#10
//	]\
   end // if
   NOP


//	%f_with_gen_id(intf2.pas,\
   [%f] with_gen_id %( 'intf2.pas' %, 
//	%f_shift_intend(-2)\
   [%f] shift_intend %( '-2' )% 
//	[#public\n<[%CX\n]>]\
   if NOT-EMPTY
   begin
    out_indent 'public'#13#10
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if true then
     begin
      if NOT-EMPTY
      begin
       %C |X #13#10 
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for C
   end // if
   NOP
//	%f_shift_intend(+2)\
   [%f] shift_intend %( '+2' )% 
//	)\
)% 

//	%f_with_gen_id(intf2.pas,\
   [%f] with_gen_id %( 'intf2.pas' %, 
//	%f_shift_intend(-2)\
   [%f] shift_intend %( '-2' )% 
//	[#public\n\
   if NOT-EMPTY
   begin
    out_indent 'public'#13#10
//	%f_shift_intend(-1)\
    [%f] shift_intend %( -1 )% 
//	<{\n}%oX>\n\
    INTEGER VAR l_Counter l_Counter := 0
    for %S%o
    begin
     OBJECT IN %o
     if true then
     begin
      if ( l_Counter >0 ) then ( #13#10 )
      %o |X 
      ++! l_Counter
     end // if
    end // for o
    #13#10
//	]\
   end // if
   NOP
//	%f_shift_intend(+3)\
   [%f] shift_intend %( '+3' )% 
//	)\
)% 

//	[{%S{IsAutoHelper}=true|<{}{%C#f_IsProp()=true&%C{reads field}!=true}{C}>!=0}\
   if ( ( %S get_up ( 'IsAutoHelper' ) ) %==  true OR 
     ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C %?f IsProp %( )% ) %==  true AND 
      ( ( %C get_up ( 'reads field' ) ) %!=  true  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %!= 0  ) ) then
   begin
//	#\{$IfNDef XE4\}
    out_indent '{$IfNDef XE4}'
//	#private
    out_indent 'private'
//	#  procedure Fake; virtual; // - это нужно чтобы правильно генерировались вызовы методов доступа к свойствам\n\
    out_indent '  procedure Fake; virtual; // - это нужно чтобы правильно генерировались вызовы методов доступа к свойствам'#13#10
//	#\{$EndIf XE4\}
    out_indent '{$EndIf XE4}'
//	#public
    out_indent 'public'
//	#  constructor Init[{%S{IsAutoHelper}=true}(const anIntf: %f_pas_TypeName(%R))];
    out_indent '  constructor Init'
    if ( ( %S get_up ( 'IsAutoHelper' ) ) %==  true ) then
    begin
     '(const anIntf: '
     [%f] pas_TypeName %( %R )% ')' 
    end // if
    ';'
//	]\
   end // if


//	[{%S{IsAutoHelper}=true}\
   if ( ( %S get_up ( 'IsAutoHelper' ) ) %==  true ) then
   begin
//	#public
    out_indent 'public'
//	#  function IsValid: Boolean;
    out_indent '  function IsValid: Boolean;'
//	#  procedure Free;
    out_indent '  procedure Free;'
//	#  property As_%RN: %f_pas_TypeName(%R) read f_%RN;
    out_indent '  property As_'
    %R |N ': '
    [%f] pas_TypeName %( %R )% ' read f_'
    %R |N ';'
//	]\
   end // if
//	[{%S{need UC}=true}%U[{publ}\n]\n]\
   if ( ( %S get_up ( 'need UC' ) ) %==  true ) then
   begin
    %Usersection (
     'publ' 
    )
    (
     #13#10 
    ) // Usersection
     #13#10 
   end // if
//	#end;//%f_pas_TypeName(%S)\
   out_indent 'end;//'
   [%f] pas_TypeName %( %S )% 
//	]\
  end // if


//	%f_shift_intend(-1)\
  [%f] shift_intend %( -1 )% 
//	<{}{%CV!=PrivateAccess&%C%f_IsClassInner()!=true&"%CO"=""}[{%CS=Typedef&%C%GU=%SU&%C{isClassRef}!=true}[%CX\n]]>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |V ) %!= 'PrivateAccess' AND 
    ( ( %C %f IsClassInner %( )% ) %!=  true  ) AND 
    ( ( %C |O ) %== ''  ) ) then
   begin
    if ( ( %C |S ) %== 'Typedef' AND 
      ( ( %C ->G |U  ) %== ( %S |U )  ) AND 
      ( ( %C get_up ( 'isClassRef' ) ) %!=  true  ) ) then
    begin
     if NOT-EMPTY
     begin
      %C |X #13#10 
     end // if
     NOP
    end // if

    ++! l_Counter
   end // if
  end // for C
//	%f_shift_intend(+1)\
  [%f] shift_intend %( 1 )% 
//	]
 end // if
//#UC END# *470F1571031Cfor4739862802BF*
; // intf.pas


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for4739862802BF*
//	%f_with_gen_id(intf.pas,[\n<{\n}{%C#f_IsConstructor()=true}%CX>])
 [%f] with_gen_id %( 'intf.pas' %, if NOT-EMPTY
 begin
  #13#10
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f IsConstructor %( )% ) %==  true ) then
   begin
    if ( l_Counter >0 ) then ( #13#10 )
    %C |X 
    ++! l_Counter
   end // if
  end // for C
 end // if
 NOP
)% //#UC END# *4774D2A20372for4739862802BF*
; // intf3.pas


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: StaticObject::Class::Attribute
end. // <<StaticObject>>

implementation @ :: <<StaticObject>> <<Attribute>> ;
//? Атрибут.
//= Delphi интерфейсы и реализация::MDAGenerator

// Параметры стереотипа
//v +#-
// - типы видимости
//a fr
// - тип абстракции
//Y code_attr.gif
//L code_attr

// Генераторы
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor47398BF3004E*
//R  
//	[#%S%f_open_ifdef()\n ]\
 if NOT-EMPTY
 begin
  out_indent %S %f open_ifdef %( )% #13#10' ' 
 end // if
 NOP
//	#%SN : %f_pas_TypeName(%S%T);[ // %f_Doc(%S)]\
 out_indent %S |N ' : '
 [%f] pas_TypeName %( %S ->T  )% ';'
 if NOT-EMPTY
 begin
  ' // '
  [%f] Doc %( %S )% 
 end // if
 NOP
//	[\n #%S%f_close_ifdef()]
 if NOT-EMPTY
 begin
  #13#10' '
  out_indent %S %f close_ifdef %( )% 
 end // if
 NOP
//#UC END# *470F1571031Cfor47398BF3004E*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor47398BF3004E*
//#UC END# *470F15B800CBfor47398BF3004E*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for47398BF3004E*
//R  
//	%f_pas_PropsFromUnion(%S)
 [%f] pas_PropsFromUnion %( %S )% 
//#UC END# *477398E501C0for47398BF3004E*
; // intf2.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
; // st_space_key

: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor47398BF3004E*
//	attr
 'attr'
//#UC END# *4705CBD6003Efor47398BF3004E*
; // wiki_child_kind


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет, что стереотип является атрибутом
//%f _IsAttribute
: IsAttribute OBJECT IN %S
//#UC START# *4A37B6A9016Ffor47398BF3004E*
//	true
 true
//#UC END# *4A37B6A9016Ffor47398BF3004E*
; // IsAttribute


//: StaticObject::Class::Operation
end. // :: <<StaticObject>> <<Attribute>> ;

implementation @ :: <<StaticObject>> <<Operation>> ;
//? Метод.
//= Delphi интерфейсы и реализация::MDAGenerator

// Параметры стереотипа
//v +#-
// - типы видимости
//a fr
// - тип абстракции
//Y code_method.gif
//L code_method
//T 
// - может не иметь "цели" (типа/результата)

// Генераторы
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor47398C2B001F*
//R  
//	%S%f_pas_MethodInterface()
 %S %f pas_MethodInterface %( )% 
//#UC END# *470F1571031Cfor47398C2B001F*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor47398C2B001F*
//R  
//	%S%f_pas_MethodImplementation()
 %S %f pas_MethodImplementation %( )% 
//#UC END# *470F15B800CBfor47398C2B001F*
; // impl.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
; // st_space_key

: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor47398C2B001F*
//	method
 'method'
//#UC END# *4705CBD6003Efor47398C2B001F*
; // wiki_child_kind


//: StaticObject::Class::ctor::Operation
end. // :: <<StaticObject>> <<Operation>> ;

implementation @ :: <<StaticObject>> <<ctor>> ;
//? Конструктор.
//= StaticObject::Class::Operation

// Параметры стереотипа
//v +
// - типы видимости
//a f
// - тип абстракции
//Y code_ctor.gif
//L code_ctor
//T 
// - может не иметь "цели" (типа/результата)

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for47E0E4970192*
//#UC END# *46E6D4BB0339for47E0E4970192*
; // wiki


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for47E0E4970192*
//#UC END# *477398E501C0for47E0E4970192*
; // intf2.pas


// Ресурсы (.rc)
//+ rc.pas
<<generator>> rc.pas OBJECT IN %S
//R  
//#UC START# *55B8D28B0157for47E0E4970192*
//#UC END# *55B8D28B0157for47E0E4970192*
; // rc.pas


// Скрипты в ресурсах (.rc.script)
//+ rc.script.pas
<<generator>> rc.script.pas OBJECT IN %S
//R  
//#UC START# *55B8D2F80145for47E0E4970192*
//#UC END# *55B8D2F80145for47E0E4970192*
; // rc.script.pas


// Компилятор ресурса (.res.cmd)
//+ res.cmd.pas
<<generator>> res.cmd.pas OBJECT IN %S
//R  
//#UC START# *55B8DD9C0301for47E0E4970192*
//#UC END# *55B8DD9C0301for47E0E4970192*
; // res.cmd.pas


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor47E0E4970192*
//R  
//	%f_pas_OutStaticCtorInterface(%S)
 [%f] pas_OutStaticCtorInterface %( %S )% 
//#UC END# *470F1571031Cfor47E0E4970192*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor47E0E4970192*
//R  
//	\n%f_pas_OutStaticCtorImplementation(%S)
 #13#10
 [%f] pas_OutStaticCtorImplementation %( %S )% 
//#UC END# *470F15B800CBfor47E0E4970192*
; // impl.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
; // st_space_key

<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for47E0E4970192*
//c	{}
//r {""=""}: {}
//#UC END# *4704C0E30186for47E0E4970192*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for47E0E4970192*
//#UC END# *470484D50138for47E0E4970192*
; // wiki_up_add_gen


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _IsConstructor
: IsConstructor OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4AE025440082for47E0E4970192*
//	true
 true
//#UC END# *4AE025440082for47E0E4970192*
; // IsConstructor


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _pas_BeforeMethodBodyImplementation
: pas_BeforeMethodBodyImplementation OBJECT IN %S
// параметры: Implementator: void = %1, Modification: void = %2
// возвращаемый результат: a-string
//#UC START# *4B6C4DE70271for47E0E4970192*
//	%S%[inherited]\
 inherited
//	%S%f_pas_StaticCtorBeforeMethodBodyImplementation(%1,%2)
 %S %f pas_StaticCtorBeforeMethodBodyImplementation %( %1 %, %2 )% 
//#UC END# *4B6C4DE70271for47E0E4970192*
; // pas_BeforeMethodBodyImplementation


// перекрытие базового стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor47E0E4970192*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor47E0E4970192*
; // wiki_child_kind


//: StaticObject::Class::readonly::Attribute
end. // :: <<StaticObject>> <<ctor>> ;

implementation @ :: <<StaticObject>> <<readonly>> ;
//= ClassBase::Class::readonly::Attribute

// Параметры стереотипа
//a f
// - тип абстракции

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; // st_space_key

end. // :: <<StaticObject>> <<readonly>> ;

