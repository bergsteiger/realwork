////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/VCMTemplates/VCMViewImplementationLayer/FormsPack/VCMFormsPack.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$ForDelphi::VCMTemplates::VCMViewImplementationLayer::FormsPack::VCMFormsPack
//
// Пачка форм
// ---
// Аналог TvcmModule. По историческим причинам VCMModule стал папкой. Может содержать только
// финальные формы
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: VCMFormsPack::Class
implementation @ <<VCMFormsPack>>
//? Пачка форм
//? Аналог TvcmModule. По историческим причинам VCMModule стал папкой. Может содержать только финальные формы
//> VCMFinalForm::Class
//> FormSetFactory::Class
//> FormFactory::Class
//> FactoryMethod::Class
//> VCMFormSetFactory::Class
//> ModuleMethod::Class
//> VCMFinalContainer::Class
//> ScriptKeyword::Class
//> ScriptKeywordsPack::Class

//= SimpleClass::Class
//= ModuleOpRecall::Class
//= OperationsPublisher::Class
//= FormSetFactoryPublisher::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//Y code_vcm_formspack.gif
//L code_vcm_formspack
// Параметры визуализации
//$ C 116,245,162
//$ l 29,177,58
//$ f 29,177,58

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'

//%f _IsVCMFormsPack
; // st_space_key

: IsVCMFormsPack OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4A951A2C003Ffor498AFF8101F5*
//	true
 true
//#UC END# *4A951A2C003Ffor498AFF8101F5*
; // IsVCMFormsPack


//%f _IsFinalVCMFormsPack
: IsFinalVCMFormsPack OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4A951A3402A8for498AFF8101F5*
//	[{%Sa=final}{false}true]
 if ( ( %S |a ) %== 'final' ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4A951A3402A8for498AFF8101F5*
; // IsFinalVCMFormsPack


//%f _PublishModule
: PublishModule OBJECT IN %S
//#UC START# *4A96413C02FAfor498AFF8101F5*
//	[{%f_exists_in_list(PUBLISHED_MODULES_LIST,S)!=true}\
 if ( ( [%f] exists_in_list %( 'PUBLISHED_MODULES_LIST' %, 'S' )% ) %!=  true ) then
 begin
//	%f_add_to_list(PUBLISHED_MODULES_LIST,S)\
  [%f] add_to_list %( 'PUBLISHED_MODULES_LIST' %, 'S' )% 
//	[%S%f_open_ifdef()\n ]\
  if NOT-EMPTY
  begin
   %S %f open_ifdef %( )% #13#10' ' 
  end // if
  NOP
//	PublishModule(%f_pas_TypeName(%S), '%SD');\
  'PublishModule('
  [%f] pas_TypeName %( %S )% ', '''
  %S |D ''');'
//	[\n %S%f_close_ifdef()]\
  if NOT-EMPTY
  begin
   #13#10' '
   %S %f close_ifdef %( )% 
  end // if
  NOP
//	]
 end // if
//#UC END# *4A96413C02FAfor498AFF8101F5*
; // PublishModule


// Имя финального модуля
//%f _FinalName
: FinalName OBJECT IN %S
// возвращаемый результат: a-string
//#UC START# *4AAA1A7601C9for498AFF8101F5*
//@ %SU
//	[{%S%f_IsFinalVCMFormsPack()=true}{<%Z#f_FinalName()>}%f_N(%S)]
 if ( ( %S %f IsFinalVCMFormsPack %( )% ) %==  true ) then
 begin
  [%f] N %( %S )% 
 end // if
 else
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%Z
  begin
   OBJECT IN %Z
   if true then
   begin
    %Z %?f FinalName %( )% 
    ++! l_Counter
   end // if
  end // for Z
 end // else

//%f _FinalDoc
; // FinalName

: FinalDoc OBJECT IN %S
//@ %SU
//	[{%S%f_IsFinalVCMFormsPack()=true}{<%Z#f_FinalDoc()>}%SD]
 if ( ( %S %f IsFinalVCMFormsPack %( )% ) %==  true ) then
 begin
  %S |D 
 end // if
 else
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%Z
  begin
   OBJECT IN %Z
   if true then
   begin
    %Z %?f FinalDoc %( )% 
    ++! l_Counter
   end // if
  end // for Z
 end // else
//#UC END# *4AAA1A7601C9for498AFF8101F5*
; // FinalDoc


// Имя ТИПА финального модуля
//%f _FinalTypeName
: FinalTypeName OBJECT IN %S
// возвращаемый результат: a-string
//#UC START# *4AAA1ACC022Ffor498AFF8101F5*
//@ %SU
//	[{%S%f_IsFinalVCMFormsPack()=true}{<%Z#f_FinalTypeName()>}%f_pas_TypeName(%S)]
 if ( ( %S %f IsFinalVCMFormsPack %( )% ) %==  true ) then
 begin
  [%f] pas_TypeName %( %S )% 
 end // if
 else
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%Z
  begin
   OBJECT IN %Z
   if true then
   begin
    %Z %?f FinalTypeName %( )% 
    ++! l_Counter
   end // if
  end // for Z
 end // else
//#UC END# *4AAA1ACC022Ffor498AFF8101F5*
; // FinalTypeName


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа FormSetFactoryPublisher::Class
//%f _FormSetFactoryToUses
: FormSetFactoryToUses OBJECT IN %S
//#UC START# *4A94F30303DDfor498AFF8101F5*
//	<%C#f_FormSetFactoryToUses()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f FormSetFactoryToUses %( )% 
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_FormSetFactoryToUses()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f FormSetFactoryToUses %( )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A94F30303DDfor498AFF8101F5*
; // FormSetFactoryToUses


// реализация абстрактного стереотипа FormSetFactoryPublisher::Class
//%f _PublishFormSetFactory
: PublishFormSetFactory OBJECT IN %S
//#UC START# *4A94F31902FDfor498AFF8101F5*
//	<%C#f_PublishFormSetFactory()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f PublishFormSetFactory %( )% 
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_PublishFormSetFactory()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f PublishFormSetFactory %( )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A94F31902FDfor498AFF8101F5*
; // PublishFormSetFactory


// реализация абстрактного стереотипа ModuleOpRecall::Class
// Выводит реализацию метода перенаправления операции
//%f _OutRecallImpl
: OutRecallImpl OBJECT IN %S
// параметры: aCaller: MDAClass = %1
//#UC START# *4A76CC1D010Dfor498AFF8101F5*
//	[{%f_exists_in_list(RECALL_LIST,S)!=true}\
 if ( ( [%f] exists_in_list %( 'RECALL_LIST' %, 'S' )% ) %!=  true ) then
 begin
//	%f_add_to_list(RECALL_LIST,S)\
  [%f] add_to_list %( 'RECALL_LIST' %, 'S' )% 
//	<%C#f_OutRecallImpl(%1)>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    %C %?f OutRecallImpl %( %1 )% 
    ++! l_Counter
   end // if
  end // for C
//	<%G#f_OutRecallImpl(%1)>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if true then
   begin
    %G %?f OutRecallImpl %( %1 )% 
    ++! l_Counter
   end // if
  end // for G
//	<%R#f_OutRecallImpl(%1)>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if true then
   begin
    %R %?f OutRecallImpl %( %1 )% 
    ++! l_Counter
   end // if
  end // for R
//	<{}{%CS=uses&%C%T#f_IsUseCase()=true}%C%T<%L#f_OutRecallImpl(%2)>>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'uses' AND 
    ( ( %C ->T %?f IsUseCase %( )%  ) %==  true  ) ) then
   begin
    %C ->T
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%L
     begin
      OBJECT IN %L
      if true then
      begin
       %L %?f OutRecallImpl %( %2 )% 
       ++! l_Counter
      end // if
     end // for L

    ) // bind
  
    ++! l_Counter
   end // if
  end // for C
//	]
 end // if
//#UC END# *4A76CC1D010Dfor498AFF8101F5*
; // OutRecallImpl


// реализация абстрактного стереотипа ModuleOpRecall::Class
// Выводит интерфейс метода перенаправления операции
//%f _OutRecallIntf
: OutRecallIntf OBJECT IN %S
// параметры: aCaller: MDAClass = %1
//#UC START# *4A76CC1902FEfor498AFF8101F5*
//	[{%f_exists_in_list(RECALL_LIST,S)!=true}\
 if ( ( [%f] exists_in_list %( 'RECALL_LIST' %, 'S' )% ) %!=  true ) then
 begin
//	%f_add_to_list(RECALL_LIST,S)\
  [%f] add_to_list %( 'RECALL_LIST' %, 'S' )% 
//	<%C#f_OutRecallIntf(%1)>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    %C %?f OutRecallIntf %( %1 )% 
    ++! l_Counter
   end // if
  end // for C
//	<%G#f_OutRecallIntf(%1)>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if true then
   begin
    %G %?f OutRecallIntf %( %1 )% 
    ++! l_Counter
   end // if
  end // for G
//	<%R#f_OutRecallIntf(%1)>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if true then
   begin
    %R %?f OutRecallIntf %( %1 )% 
    ++! l_Counter
   end // if
  end // for R
//	<{}{%CS=uses&%C%T#f_IsUseCase()=true}%C%T<%L#f_OutRecallIntf(%2)>>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'uses' AND 
    ( ( %C ->T %?f IsUseCase %( )%  ) %==  true  ) ) then
   begin
    %C ->T
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%L
     begin
      OBJECT IN %L
      if true then
      begin
       %L %?f OutRecallIntf %( %2 )% 
       ++! l_Counter
      end // if
     end // for L

    ) // bind
  
    ++! l_Counter
   end // if
  end // for C
//	]
 end // if
//#UC END# *4A76CC1902FEfor498AFF8101F5*
; // OutRecallIntf


// реализация абстрактного стереотипа ModuleOpRecall::Class
//%f _RecallToImplUses
: RecallToImplUses OBJECT IN %S
//#UC START# *4A9CF8A30296for498AFF8101F5*
//	[{%f_exists_in_list(RECALL_LIST,S)!=true}\
 if ( ( [%f] exists_in_list %( 'RECALL_LIST' %, 'S' )% ) %!=  true ) then
 begin
//	%f_add_to_list(RECALL_LIST,S)\
  [%f] add_to_list %( 'RECALL_LIST' %, 'S' )% 
//	<%C#f_RecallToImplUses()>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    %C %?f RecallToImplUses %( )% 
    ++! l_Counter
   end // if
  end // for C
//	<%G#f_RecallToImplUses()>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if true then
   begin
    %G %?f RecallToImplUses %( )% 
    ++! l_Counter
   end // if
  end // for G
//	<%R#f_RecallToImplUses()>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if true then
   begin
    %R %?f RecallToImplUses %( )% 
    ++! l_Counter
   end // if
  end // for R
//	%f_pas_PutToUses(%S)\
  [%f] pas_PutToUses %( %S )% 
//	<{}{%CS=uses&%C%T#f_IsUseCase()=true}%C%T<%L#f_RecallToImplUses()>>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'uses' AND 
    ( ( %C ->T %?f IsUseCase %( )%  ) %==  true  ) ) then
   begin
    %C ->T
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%L
     begin
      OBJECT IN %L
      if true then
      begin
       %L %?f RecallToImplUses %( )% 
       ++! l_Counter
      end // if
     end // for L

    ) // bind
  
    ++! l_Counter
   end // if
  end // for C
//	]
 end // if
//#UC END# *4A9CF8A30296for498AFF8101F5*
; // RecallToImplUses


// реализация абстрактного стереотипа ModuleOpRecall::Class
//%f _RecallToIntfUses
: RecallToIntfUses OBJECT IN %S
//#UC START# *4A9CF892039Afor498AFF8101F5*
//	[{%f_exists_in_list(RECALL_LIST,S)!=true}\
 if ( ( [%f] exists_in_list %( 'RECALL_LIST' %, 'S' )% ) %!=  true ) then
 begin
//	%f_add_to_list(RECALL_LIST,S)\
  [%f] add_to_list %( 'RECALL_LIST' %, 'S' )% 
//	<%C#f_RecallToIntfUses()>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    %C %?f RecallToIntfUses %( )% 
    ++! l_Counter
   end // if
  end // for C
//	<%C<{}{%w#f_IsVCMForm()!=true}%f_pas_PutToUses(%w)>>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if true then
   begin
    %C
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%w
     begin
      OBJECT IN %w
      if ( ( %w %?f IsVCMForm %( )% ) %!=  true ) then
      begin
       [%f] pas_PutToUses %( %w )% 
       ++! l_Counter
      end // if
     end // for w

    ) // bind
 
    ++! l_Counter
   end // if
  end // for C
//	<%G#f_RecallToIntfUses()>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%G
  begin
   OBJECT IN %G
   if true then
   begin
    %G %?f RecallToIntfUses %( )% 
    ++! l_Counter
   end // if
  end // for G
//	<%R#f_RecallToIntfUses()>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if true then
   begin
    %R %?f RecallToIntfUses %( )% 
    ++! l_Counter
   end // if
  end // for R
//	<{}{%w#f_IsVCMForm()!=true&%w#f_IsVCMFormsPack()!=true}%f_pas_PutToUses(%w)>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%w
  begin
   OBJECT IN %w
   if ( ( %w %?f IsVCMForm %( )% ) %!=  true AND 
    ( ( %w %?f IsVCMFormsPack %( )% ) %!=  true  ) ) then
   begin
    [%f] pas_PutToUses %( %w )% 
    ++! l_Counter
   end // if
  end // for w
//	<%g<{}{%w#f_IsVCMForm()!=true&%w#f_IsVCMFormsPack()!=true}%f_pas_PutToUses(%w)>>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%g
  begin
   OBJECT IN %g
   if true then
   begin
    %g
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%w
     begin
      OBJECT IN %w
      if ( ( %w %?f IsVCMForm %( )% ) %!=  true AND 
       ( ( %w %?f IsVCMFormsPack %( )% ) %!=  true  ) ) then
      begin
       [%f] pas_PutToUses %( %w )% 
       ++! l_Counter
      end // if
     end // for w

    ) // bind
 
    ++! l_Counter
   end // if
  end // for g
//	<{}{%CS=uses&%C%T#f_IsUseCase()=true}%C%T<%L#f_RecallToIntfUses()>>\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'uses' AND 
    ( ( %C ->T %?f IsUseCase %( )%  ) %==  true  ) ) then
   begin
    %C ->T
    bind ( 
     OBJECT VAR %S
     INTEGER VAR l_Counter l_Counter := 0
     for %S%L
     begin
      OBJECT IN %L
      if true then
      begin
       %L %?f RecallToIntfUses %( )% 
       ++! l_Counter
      end // if
     end // for L

    ) // bind
  
    ++! l_Counter
   end // if
  end // for C
//	]
 end // if
//#UC END# *4A9CF892039Afor498AFF8101F5*
; // RecallToIntfUses


// реализация абстрактного стереотипа OperationsPublisher::Class
//%f _OperationsToFuncImpl
: OperationsToFuncImpl OBJECT IN %S
// параметры: aCaller: MDAClass = %1
//#UC START# *4A8E9F9502BBfor498AFF8101F5*
//	<%C#f_OperationsToFuncImpl(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f OperationsToFuncImpl %( %1 )% 
   ++! l_Counter
  end // if
 end // for C
//	<{}{%C%TU!=%SU}%C%T#f_OperationsToFuncImpl(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C ->T |U  ) %!= ( %S |U ) ) then
  begin
   %C ->T %?f OperationsToFuncImpl %( %1 )%  
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_OperationsToFuncImpl(%1)>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f OperationsToFuncImpl %( %1 )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A8E9F9502BBfor498AFF8101F5*
; // OperationsToFuncImpl


// реализация абстрактного стереотипа OperationsPublisher::Class
// Операции в функции
//%f _OperationsToFuncIntf
: OperationsToFuncIntf OBJECT IN %S
// параметры: aCaller: MDAClass = %1
//#UC START# *4A8E9D5E0038for498AFF8101F5*
//	<%C#f_OperationsToFuncIntf(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f OperationsToFuncIntf %( %1 )% 
   ++! l_Counter
  end // if
 end // for C
//	<{}{%C%TU!=%SU}%C%T#f_OperationsToFuncIntf(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C ->T |U  ) %!= ( %S |U ) ) then
  begin
   %C ->T %?f OperationsToFuncIntf %( %1 )%  
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_OperationsToFuncIntf(%1)>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f OperationsToFuncIntf %( %1 )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A8E9D5E0038for498AFF8101F5*
; // OperationsToFuncIntf


// реализация абстрактного стереотипа OperationsPublisher::Class
// Определяет необходимые uses для операций
//%f _OperationsToUses
: OperationsToUses OBJECT IN %S
//#UC START# *4A82DDA6016Afor498AFF8101F5*
//	%f_pas_PutToUses(%S)\
 [%f] pas_PutToUses %( %S )% 
//	<%f_pas_PutToUses(%g)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%g
 begin
  OBJECT IN %g
  if true then
  begin
   [%f] pas_PutToUses %( %g )% 
   ++! l_Counter
  end // if
 end // for g
//	<%C#f_OperationsToUses()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f OperationsToUses %( )% 
   ++! l_Counter
  end // if
 end // for C
//	<{}{%C%TU!=%SU}%C%T#f_OperationsToUses()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C ->T |U  ) %!= ( %S |U ) ) then
  begin
   %C ->T %?f OperationsToUses %( )%  
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_OperationsToUses()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f OperationsToUses %( )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A82DDA6016Afor498AFF8101F5*
; // OperationsToUses


// реализация абстрактного стереотипа OperationsPublisher::Class
// Операции в секцию Var
//%f _OperationsToVar
: OperationsToVar OBJECT IN %S
//#UC START# *4A8E9D3A01FEfor498AFF8101F5*
//	<%C#f_OperationsToVar()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f OperationsToVar %( )% 
   ++! l_Counter
  end // if
 end // for C
//	<{}{%C%TU!=%SU}%C%T#f_OperationsToVar()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C ->T |U  ) %!= ( %S |U ) ) then
  begin
   %C ->T %?f OperationsToVar %( )%  
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_OperationsToVar()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f OperationsToVar %( )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A8E9D3A01FEfor498AFF8101F5*
; // OperationsToVar


// реализация абстрактного стереотипа OperationsPublisher::Class
// Публикует операции
//%f _PublishOperations
: PublishOperations OBJECT IN %S
//#UC START# *4A770F770199for498AFF8101F5*
//	<%C#f_PublishOperations()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f PublishOperations %( )% 
   ++! l_Counter
  end // if
 end // for C
//	<{}{%C%TU!=%SU}%C%T#f_PublishOperations()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C ->T |U  ) %!= ( %S |U ) ) then
  begin
   %C ->T %?f PublishOperations %( )%  
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_PublishOperations()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f PublishOperations %( )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A770F770199for498AFF8101F5*
; // PublishOperations


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// нет документации
//%f _pas_DefaultAncestor
: pas_DefaultAncestor OBJECT IN %S
//#UC START# *4948E5B60391for498AFF8101F5*
//	TvcmModule
 'TvcmModule'
//#UC END# *4948E5B60391for498AFF8101F5*
; // pas_DefaultAncestor


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Добавляет файлы необходимые элементу с точки зрения метамодели
//%f _pas_ImplUses
: pas_ImplUses OBJECT IN %S
//#UC START# *4948EB2601FAfor498AFF8101F5*
//	%S%[inherited]\
 inherited
//	[{%Sa!=final}\
 if ( ( %S |a ) %!= 'final' ) then
 begin
//	%f_pas_PutToUses("vcmFormSetFactory")\
  [%f] pas_PutToUses %( 'vcmFormSetFactory' )% 
//	%f_pas_PutToUses("StdRes")\
  [%f] pas_PutToUses %( 'StdRes' )% 
//	]\
 end // if
//	[{%Sa!=final}\
 if ( ( %S |a ) %!= 'final' ) then
 begin
//	[{<{}{%C#f_IsModuleOperation()=true}{C}>!=0}\
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C %?f IsModuleOperation %( )% ) %==  true ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
//	%f_pas_PutToUses("vcmModuleDef")\
   [%f] pas_PutToUses %( 'vcmModuleDef' )% 
//	]\
  end // if
//	]
 end // if
//#UC END# *4948EB2601FAfor498AFF8101F5*
; // pas_ImplUses


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит дополнительные модули необходимые элементу в интерфейсной секции
//%f _pas_IntfUses
: pas_IntfUses OBJECT IN %S
//#UC START# *4948F2EE0334for498AFF8101F5*
//	%S%[inherited]\
 inherited
//	[{%Sa!=final}\
 if ( ( %S |a ) %!= 'final' ) then
 begin
//	%f_pas_PutToUses("vcmExternalInterfaces")\
  [%f] pas_PutToUses %( 'vcmExternalInterfaces' )% 
//	%f_pas_PutToUses("vcmInterfaces")\
  [%f] pas_PutToUses %( 'vcmInterfaces' )% 
//	%f_pas_PutToUses("vcmModule")\
  [%f] pas_PutToUses %( 'vcmModule' )% 
//	[{<{}{%C#f_IsVCMFinalForm()=true}{C}>!=0}\
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C %?f IsVCMFinalForm %( )% ) %==  true ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
//	%f_pas_PutToUses("vcmBase")\
   [%f] pas_PutToUses %( 'vcmBase' )% 
//	]\
  end // if
//	]\
 end // if
//	[{%Sa=final}\
//	%f_pas_PutToUses("Classes")\
//	%f_pas_PutToUses("l3InterfacedComponent")\
//	%f_pas_PutToUses("vcmComponent")\
//	%f_pas_PutToUses("vcmOperations")\
//	%f_pas_PutToUses("vcmModuleDef")\
//	]\
//	
//#UC END# *4948F2EE0334for498AFF8101F5*
; // pas_IntfUses


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит код после секции implementation
//%f _pas_OutAfterUnitImplementation
: pas_OutAfterUnitImplementation OBJECT IN %S
//#UC START# *498B059101B3for498AFF8101F5*
//	%S%[inherited]
 inherited
//#UC END# *498B059101B3for498AFF8101F5*
; // pas_OutAfterUnitImplementation


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит родительский класс
//%f _pas_OutAncestor
: pas_OutAncestor OBJECT IN %S
//#UC START# *4989EB520196for498AFF8101F5*
//	%S%[inherited]
 inherited
//#UC END# *4989EB520196for498AFF8101F5*
; // pas_OutAncestor


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит код перед поляпи класса. Для переопределения в потомках
//%f _pas_OutBeforeFields
: pas_OutBeforeFields OBJECT IN %S
//#UC START# *498B054F03A1for498AFF8101F5*
//	%S%[inherited]
 inherited
//#UC END# *498B054F03A1for498AFF8101F5*
; // pas_OutBeforeFields


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит объявление класса
//%f _pas_OutClassInterface
: pas_OutClassInterface OBJECT IN %S
//#UC START# *494B7197025Afor498AFF8101F5*
//	%S%[inherited]
 inherited
//#UC END# *494B7197025Afor498AFF8101F5*
; // pas_OutClassInterface


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит спец-метку класса
//%f _pas_OutClassMark
: pas_OutClassMark OBJECT IN %S
//#UC START# *494B74D7016Bfor498AFF8101F5*
//	formspack
 'formspack'
//#UC END# *494B74D7016Bfor498AFF8101F5*
; // pas_OutClassMark


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит реализацию переопределённых методов
//%f _pas_OutOverridesImpl
: pas_OutOverridesImpl OBJECT IN %S
//#UC START# *494B86B5014Bfor498AFF8101F5*
//	%S%[inherited]\
 inherited

//	[{<{}{%C#f_IsModuleOperation()=true}{C}>!=0}\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f IsModuleOperation %( )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
//	%f_pas_OpenMethodImplementation("Loaded",%S)\
  [%f] pas_OpenMethodImplementation %( 'Loaded"' %, %S )% 
//	procedure %f_pas_TypeName(%S).Loaded;
  'procedure '
  [%f] pas_TypeName %( %S )% '.Loaded;'
//	begin
  'begin'
//	 inherited;\
  ' inherited;'
//	[\
  if NOT-EMPTY
  begin
//	<{}{%C#f_IsModuleOperation()=true}\
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C %?f IsModuleOperation %( )% ) %==  true ) then
    begin
//	[\n %C#f_open_ifdef()]\
     if NOT-EMPTY
     begin
      #13#10' '
      %C %?f open_ifdef %( )% 
     end // if
     NOP
//	\n PublishOp('[{%C{no prefix}!=true}op]%f_N(%C)', \
     #13#10' PublishOp('''
     if ( ( %C get_up ( 'no prefix' ) ) %!=  true ) then
     begin
      'op' 
     end // if
     [%f] N %( %C )% ''', '
//	%C%f_pas_MethodName("exec"), \
     %C %f pas_MethodName %( 'exec' )% ', '
//	[{%C{no test}!=true}{nil}%C%f_pas_MethodName("test")]\
     if ( ( %C get_up ( 'no test' ) ) %!=  true ) then
     begin
      %C %f pas_MethodName %( 'test' )% 
     end // if
     else
     begin
      'nil' 
     end // else
//	);\
     ');'


//	[{"%C{ShowInToolbar}"!=""&%C{ShowInToolbar}!=undefined}\
     if ( ( %C get_up ( 'ShowInToolbar' ) ) %!= '' AND 
       ( ( %C get_up ( 'ShowInToolbar' ) ) %!= 'undefined'  ) ) then
     begin
//	\n ShowInToolbar('[{%C{no prefix}!=true}op]%f_N(%C)', %C{ShowInToolbar});\
      #13#10' ShowInToolbar('''
      if ( ( %C get_up ( 'no prefix' ) ) %!=  true ) then
      begin
       'op' 
      end // if
      [%f] N %( %C )% ''', '
      %C get_up ( 'ShowInToolbar' ) ');'
//	]\
     end // if

// %C{ShowInToolbar}!=undefined


//	[{"%C{ShortCut}"!=""}\
     if ( ( %C get_up ( 'ShortCut' ) ) %!= '' ) then
     begin
//	\n SetShortCut('[{%C{no prefix}!=true}op]%f_N(%C)', '%C{ShortCut}');\
      #13#10' SetShortCut('''
      if ( ( %C get_up ( 'no prefix' ) ) %!=  true ) then
      begin
       'op' 
      end // if
      [%f] N %( %C )% ''', '''
      %C get_up ( 'ShortCut' ) ''');'
//	]\
     end // if

// %C{ShortCut}!=""


//	[\n %C#f_close_ifdef()]\
     if NOT-EMPTY
     begin
      #13#10' '
      %C %?f close_ifdef %( )% 
     end // if
     NOP
//	>\

     ++! l_Counter
    end // if
   end // for C
//	]
  end // if
  NOP
//	end;\
  'end;'
//	]\
 end // if

//	[{<{}{%C#f_IsVCMFinalForm()=true}{C}>!=0}\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f IsVCMFinalForm %( )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
//	%f_pas_OpenMethodImplementation("GetEntityForms",%S)\
  [%f] pas_OpenMethodImplementation %( 'GetEntityForms"' %, %S )% 
//	class procedure %f_pas_TypeName(%S).GetEntityForms(aList : TvcmClassList);
  'class procedure '
  [%f] pas_TypeName %( %S )% '.GetEntityForms(aList : TvcmClassList);'
//	begin
  'begin'
//	 inherited;\
  ' inherited;'
//	[\n <{\n }{%C#f_IsVCMFinalForm()=true}aList.Add(%f_pas_TypeName(%C));>]
  if NOT-EMPTY
  begin
   #13#10' '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C %?f IsVCMFinalForm %( )% ) %==  true ) then
    begin
     if ( l_Counter >0 ) then ( #13#10' ' )
     'aList.Add('
     [%f] pas_TypeName %( %C )% ');' 
     ++! l_Counter
    end // if
   end // for C
  end // if
  NOP
//	end;\
  'end;'
//	]
 end // if
//#UC END# *494B86B5014Bfor498AFF8101F5*
; // pas_OutOverridesImpl


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит интерфейс переопределённых методов
//%f _pas_OutOverridesIntf
: pas_OutOverridesIntf OBJECT IN %S
//#UC START# *494B856502ECfor498AFF8101F5*
//	%S%[inherited]\
 inherited
//	[{<{}{%C#f_IsModuleOperation()=true}{C}>!=0}\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f IsModuleOperation %( )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
//	# procedure Loaded; override;
  out_indent ' procedure Loaded; override;'
//	]\
 end // if
//	[{<{}{%C#f_IsVCMFinalForm()=true}{C}>!=0}\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f IsVCMFinalForm %( )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
//	# class procedure GetEntityForms(aList : TvcmClassList); override;
  out_indent ' class procedure GetEntityForms(aList : TvcmClassList); override;'
//	]
 end // if
//#UC END# *494B856502ECfor498AFF8101F5*
; // pas_OutOverridesIntf


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Имя типа
//%f _pas_TypeName
: pas_TypeName OBJECT IN %S
//#UC START# *4947F8AD02A1for498AFF8101F5*
//	[{%S%f_IsMixIn()=true}{[{%Sa=final}{T%f_N(%S)Module}Tmo_%f_N(%S)]}%S%[inherited]]
 if ( ( %S %f IsMixIn %( )% ) %==  true ) then
 begin
  inherited
 end // if
 else
 begin
  if ( ( %S |a ) %== 'final' ) then
  begin
   'Tmo_'
   [%f] N %( %S )% 
  end // if
  else
  begin
   'T'
   [%f] N %( %S )% 'Module' 
  end // else
 end // else
//#UC END# *4947F8AD02A1for498AFF8101F5*
; // pas_TypeName


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Имя модуля в котором содержится элемент
//%f _pas_UnitName
: pas_UnitName OBJECT IN %S
//#UC START# *4948065C01DFfor498AFF8101F5*
//	[{%S%f_IsMixIn()=true}{[{%Sa=final}{%f_N(%S)_Module}mo%f_N(%S)]}%S%[inherited]]
 if ( ( %S %f IsMixIn %( )% ) %==  true ) then
 begin
  inherited
 end // if
 else
 begin
  if ( ( %S |a ) %== 'final' ) then
  begin
   'mo'
   [%f] N %( %S )% 
  end // if
  else
  begin
   [%f] N %( %S )% '_Module' 
  end // else
 end // else
//#UC END# *4948065C01DFfor498AFF8101F5*
; // pas_UnitName


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Путь к модулю
//%f _pas_UnitPath
: pas_UnitPath OBJECT IN %S
//#UC START# *4948C3290020for498AFF8101F5*
//	[{%P#f_IsVCMSubsystem()=true}/View]%S%[inherited]
 if ( ( %P %?f IsVCMSubsystem %( )% ) %==  true ) then
 begin
  '/View' 
 end // if
 inherited
//#UC END# *4948C3290020for498AFF8101F5*
; // pas_UnitPath


// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for498AFF8101F5*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for498AFF8101F5*
; // constraint


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor498AFF8101F5*
//O [{%Sa=final}[{%S{finished}!=true}NOT_FINISHED_]%S%f_pas_UnitName().dfm]
//C %S%f_pas_UnitPath()
//	[{"%SO"!=""}\
 if ( ( %S |O ) %!= '' ) then
 begin
//	object %f_cut_prefix(%S%f_pas_TypeName(),T): %S%f_pas_TypeName()
  'object '
  [%f] cut_prefix %( %S %f pas_TypeName %( )% %, 'T' )% ': '
  %S %f pas_TypeName %( )% 
//	  OldCreateOrder = True
  '  OldCreateOrder = True'
//	  Left = 100
  '  Left = 100'
//	  Top = 132
  '  Top = 132'
//	  Height = 177
  '  Height = 177'
//	  Width = 255
  '  Width = 255'
//	  object ModuleDef: TvcmModuleDef
  '  object ModuleDef: TvcmModuleDef'
//	    Caption = '%SD'
  '    Caption = '''
  %S |D '''
//	[    Operations = \<\
  if NOT-EMPTY
  begin
   '    Operations = <'
//	<{}{"%CO"=""}[\n%CX]>\
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |O ) %== '' ) then
    begin
     if NOT-EMPTY
     begin
      #13#10
      %C |X 
     end // if
     NOP

     ++! l_Counter
    end // if
   end // for C
//	<%g<{}{"%CO"=""}[\n%CX]>>\
   INTEGER VAR l_Counter l_Counter := 0
   for %S%g
   begin
    OBJECT IN %g
    if true then
    begin
     %g
     bind ( 
      OBJECT VAR %S
      INTEGER VAR l_Counter l_Counter := 0
      for %S%C
      begin
       OBJECT IN %C
       if ( ( %C |O ) %== '' ) then
       begin
        if NOT-EMPTY
        begin
         #13#10
         %C |X 
        end // if
        NOP

        ++! l_Counter
       end // if
      end // for C

     ) // bind
 
     ++! l_Counter
    end // if
   end // for g
//	\>\n]\
   '>'#13#10 
  end // if
  NOP
//	    Left = 72
  '    Left = 72'
//	    Top = 64
  '    Top = 64'
//	  end
  '  end'
//	end\
  'end'
//	]\
 end // if
//	<{}{"%CO"!=""}%CX>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |O ) %!= '' ) then
  begin
   %C |X 
   ++! l_Counter
  end // if
 end // for C
//#UC END# *49F5795900ECfor498AFF8101F5*
; // dfm


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: VCMFormsPack::Class::ModuleOperation::Operation
end. // <<VCMFormsPack>>

implementation @ :: <<VCMFormsPack>> <<ModuleOperation>> ;
//? Операция модуля
//= ClassBase::Class::Operation
//= ModuleOperationPrim::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Основная ветка наследования
//! ModuleOperationPrim::Class

// Параметры стереотипа
//v #
// - типы видимости
//a f
// - тип абстракции

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for49F6F6E60362*
//#UC END# *46E6D4BB0339for49F6F6E60362*
; // wiki


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor49F6F6E60362*
//#UC END# *470321C1038Afor49F6F6E60362*
; // fctr.java


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S%[ClassBase::Class::Operation]f_wiki_up_print()[{"%S{no test}"!="%S{!no test}"}%f_up_prefix(%S) *no test* = *%S{no test}* - Отключает OnTest
 call-inherited:: 'ClassBase::Operation' wiki_up_print %( )%
 if ( ( %S get_up ( 'no test' ) ) %!= ( %S get_up_def ( 'no test' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *no test* = *'
  %S get_up ( 'no test' ) '* - Отключает OnTest'
//	][{"%S{no prefix}"!="%S{!no prefix}"}%f_up_prefix(%S) *no prefix* = *%S{no prefix}* - Нет префикса у имени. Костыль для \[$133891300\]
 end // if
 if ( ( %S get_up ( 'no prefix' ) ) %!= ( %S get_up_def ( 'no prefix' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *no prefix* = *'
  %S get_up ( 'no prefix' ) '* - Нет префикса у имени. Костыль для [$133891300]'
//	][{"%S{ShowInToolbar}"!="%S{!ShowInToolbar}"}%f_up_prefix(%S) *ShowInToolbar* = *%S{ShowInToolbar}*
 end // if
 if ( ( %S get_up ( 'ShowInToolbar' ) ) %!= ( %S get_up_def ( 'ShowInToolbar' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *ShowInToolbar* = *'
  %S get_up ( 'ShowInToolbar' ) '*'
//	][{"%S{ShortCut}"!="%S{!ShortCut}"}%f_up_prefix(%S) *ShortCut* = *%S{ShortCut}*
 end // if
 if ( ( %S get_up ( 'ShortCut' ) ) %!= ( %S get_up_def ( 'ShortCut' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *ShortCut* = *'
  %S get_up ( 'ShortCut' ) '*'
//	]
 end // if


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
; // wiki_up_print

: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for49F6F6E60362*
//#UC END# *470484D50138for49F6F6E60362*
; // wiki_up_add_gen


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _DoSpell
: DoSpell OBJECT IN %S
//#UC START# *4B2A19E3038Bfor49F6F6E60362*
//	%S%[inherited]\
 inherited
//	%S%f_SpellWordForModuleOperation()
 %S %f SpellWordForModuleOperation %( )% 
//#UC END# *4B2A19E3038Bfor49F6F6E60362*
; // DoSpell



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<VCMFormsPack>> <<ModuleOperation>> ;

