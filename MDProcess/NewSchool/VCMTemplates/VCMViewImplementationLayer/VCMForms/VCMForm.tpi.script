////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/VCMTemplates/VCMViewImplementationLayer/VCMForms/VCMForm.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$ForDelphi::VCMTemplates::VCMViewImplementationLayer::VCMForms::VCMForm
//
// Форма VCM
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: VCMForm::Class
implementation @ <<VCMForm>>
//? Форма VCM
//> UserType::Class
//> Control::Class
//> ControlOverride::Class
//> ExcludeUserTypes::Class
//> IncludeUserTypes::Class
//> VCMFormDefinition::Class
//> ScriptKeyword::Class

//= VCMCustomForm::Class
//= OperationsPublisher::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p ZoneType=Any|Parent|Child|Main|Navigator|Modal|SimpleFloat|ManualModal|Floating ? Тип зоны
//p restrict form def:tribool=undefined ? 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{ZoneType}"!="%S{!ZoneType}"}%f_up_prefix(%S) *ZoneType* = *%S{ZoneType}* - Тип зоны
 ?inherited
 if ( ( %S get_up ( 'ZoneType' ) ) %!= ( %S get_up_def ( 'ZoneType' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *ZoneType* = *'
  %S get_up ( 'ZoneType' ) '* - Тип зоны'
//	][{"%S{restrict form def}"!="%S{!restrict form def}"}%f_up_prefix(%S) *restrict form def* = *%S{restrict form def}*
 end // if
 if ( ( %S get_up ( 'restrict form def' ) ) %!= ( %S get_up_def ( 'restrict form def' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *restrict form def* = *'
  %S get_up ( 'restrict form def' ) '*'
//	]
 end // if

// Есть ли UserType'ы
//%f _HasUserType
; // wiki_up_print

: HasUserType OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4B5DE4800324for4B5DA84A00DD*
//@ %SU
//	[{<{}{%C#f_IsUserType()=true}{C}>!=0}{false}true]
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C %?f IsUserType %( )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0 ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4B5DE4800324for4B5DA84A00DD*
; // HasUserType


// Есть ли UserType'ы (рекурсивно)
//%f _HasUserTypeRec
: HasUserTypeRec OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4B5DE48F01D4for4B5DA84A00DD*
//@ %SU
//	[{%S%f_HasUserType()=true}{\
 if ( ( %S %f HasUserType %( )% ) %==  true ) then
 begin
//	true]
   true 
 end // if
 else
 begin
//	[{<{}{%G#f_HasUserTypeRec()=true}{C}>!=0}{\
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%G
   begin
    OBJECT IN %G
    if ( ( %G %?f HasUserTypeRec %( )% ) %==  true ) then
    begin

     ++! l_Counter
    end // if
   end // for G
   l_Counter
   %!= 0 ) then
  begin
//	true\
    true 
//	]\
  end // if
  else
  begin
//	[{<{}{%R#f_HasUserTypeRec()=true}{C}>!=0}{\
   if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%R
    begin
     OBJECT IN %R
     if ( ( %R %?f HasUserTypeRec %( )% ) %==  true ) then
     begin

      ++! l_Counter
     end // if
    end // for R
    l_Counter
    %!= 0 ) then
   begin
//	true\
     true 
//	]\
   end // if
   else
   begin
//	false\
     false 
//	}\
   end // else
//	}\
  end // else
//	}\
 end // else
//#UC END# *4B5DE48F01D4for4B5DA84A00DD*
; // HasUserTypeRec


//%f _IsVCMFinalForm
: IsVCMFinalForm OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4B5F28CD00A9for4B5DA84A00DD*
//	false
 false
//#UC END# *4B5F28CD00A9for4B5DA84A00DD*
; // IsVCMFinalForm


// Надо ли выводить перекрытие процедуры InitEntities
//%f _NeedsInitEntities
: NeedsInitEntities OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4BDB046402D7for4B5DA84A00DD*
//@ %SU
//	[{%S%f_ImplementsSomeVCMOperation()=true|<{}{%CS=ExcludeUserTypes|%CS=IncludeUserTypes}{C}>!=0}{false}true]
 if ( ( %S %f ImplementsSomeVCMOperation %( )% ) %==  true OR 
   ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |S ) %== 'ExcludeUserTypes' OR 
    ( ( %C |S ) %== 'IncludeUserTypes'  ) ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %!= 0  ) ) then
 begin
   true 
 end // if
 else
 begin
   false 
 end // else
//#UC END# *4BDB046402D7for4B5DA84A00DD*
; // NeedsInitEntities


// Реализует ли хоть одну операцию VCM
//%f _ImplementsSomeVCMOperation
: ImplementsSomeVCMOperation OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4BDB047F02CDfor4B5DA84A00DD*
//@ %SU
//	[{<{}{%R#f_IsVCMOperations()=true}{C}>!=0}{\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%R
  begin
   OBJECT IN %R
   if ( ( %R %?f IsVCMOperations %( )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for R
  l_Counter
  %!= 0 ) then
 begin
//	true\
   true 
//	]
 end // if
 else
 begin
//	%f_set_var(RESULT,"false")\
  [%f] set_var %( 'RESULT' %, false )% 
//	<{}{%O#f_IsVCMOperation()=true}\
  INTEGER VAR l_Counter l_Counter := 0
  for %S%O
  begin
   OBJECT IN %O
   if ( ( %O %?f IsVCMOperation %( )% ) %==  true ) then
   begin
//	[{"%O{ShowInContextMenu}"!=""|%O{ShowInContextMenu}!=undefined|"%O{ContextMenuWeight}"!=""|"%O{ShowInToolbar}"!=""|%O{ShowInToolbar}!=undefined}\
    if ( ( %O get_up ( 'ShowInContextMenu' ) ) %!= '' OR 
      ( ( %O get_up ( 'ShowInContextMenu' ) ) %!= 'undefined'  ) OR 
      ( ( %O get_up ( 'ContextMenuWeight' ) ) %!= ''  ) OR 
      ( ( %O get_up ( 'ShowInToolbar' ) ) %!= ''  ) OR 
      ( ( %O get_up ( 'ShowInToolbar' ) ) %!= 'undefined'  ) ) then
    begin
//	%f_set_var(RESULT,"true")\
     [%f] set_var %( 'RESULT' %, true )% 
//	%f_cycle_break(%S)\
     [%f] cycle_break %( %S )% 
//	]\
    end // if
//	>\

    ++! l_Counter
   end // if
  end // for O
//	[{%{RESULT}N!=true}\
  if ( ( ( get_global_var ( 'RESULT' ) |N ) ) %!=  true ) then
  begin
//	<{}{%C#f_IsControl()=true}{%C}\
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C %?f IsControl %( )% ) %==  true ) then
    begin
//	[{%C<{}{%R#f_IsVCMOperations()=true}{C}>!=0}\
     if ( ( %C
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%R
       begin
        OBJECT IN %R
        if ( ( %R %?f IsVCMOperations %( )% ) %==  true ) then
        begin

         ++! l_Counter
        end // if
       end // for R
       l_Counter

      ) // bind
 )       %!= 0 ) then
     begin
//	%f_set_var(RESULT,"true")\
      [%f] set_var %( 'RESULT' %, true )% 
//	%f_cycle_break(%S)\
      [%f] cycle_break %( %S )% 
//	]\
     end // if
//	>\

     ++! l_Counter
    end // if
   end // for C
//	]\
  end // if
//	%{RESULT}N\
  ( get_global_var ( 'RESULT' ) |N ) 
//	}\
 end // else
//#UC END# *4BDB047F02CDfor4B5DA84A00DD*
; // ImplementsSomeVCMOperation


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа OperationsPublisher::Class
//%f _OperationsToFuncImpl
: OperationsToFuncImpl OBJECT IN %S
// параметры: aCaller: MDAClass = %1
//#UC START# *4A8E9F9502BBfor4B5DA84A00DD*
//	<%R#f_OperationsToFuncImpl(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%R
 begin
  OBJECT IN %R
  if true then
  begin
   %R %?f OperationsToFuncImpl %( %1 )% 
   ++! l_Counter
  end // if
 end // for R
//	<{}{%G#f_IsVCMMainForm()!=true}%G#f_OperationsToFuncImpl(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if ( ( %G %?f IsVCMMainForm %( )% ) %!=  true ) then
  begin
   %G %?f OperationsToFuncImpl %( %1 )% 
   ++! l_Counter
  end // if
 end // for G
//	<{}{%o#f_IsVCMOperation()=true}\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( %o %?f IsVCMOperation %( )% ) %==  true ) then
  begin
//	%o#f_OperationsToFuncImpl(%1)\
   %o %?f OperationsToFuncImpl %( %1 )% 
//	>\

   ++! l_Counter
  end // if
 end // for o
//	<%C%T#f_OperationsToFuncImpl(%1)>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C ->T %?f OperationsToFuncImpl %( %1 )%  
   ++! l_Counter
  end // if
 end // for C
//#UC END# *4A8E9F9502BBfor4B5DA84A00DD*
; // OperationsToFuncImpl


// реализация абстрактного стереотипа OperationsPublisher::Class
// Операции в функции
//%f _OperationsToFuncIntf
: OperationsToFuncIntf OBJECT IN %S
// параметры: aCaller: MDAClass = %1
//#UC START# *4A8E9D5E0038for4B5DA84A00DD*
//	<%R#f_OperationsToFuncIntf(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%R
 begin
  OBJECT IN %R
  if true then
  begin
   %R %?f OperationsToFuncIntf %( %1 )% 
   ++! l_Counter
  end // if
 end // for R
//	<{}{%G#f_IsVCMMainForm()!=true}%G#f_OperationsToFuncIntf(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if ( ( %G %?f IsVCMMainForm %( )% ) %!=  true ) then
  begin
   %G %?f OperationsToFuncIntf %( %1 )% 
   ++! l_Counter
  end // if
 end // for G
//	<{}{%o#f_IsVCMOperation()=true}\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( %o %?f IsVCMOperation %( )% ) %==  true ) then
  begin
//	%o#f_OperationsToFuncIntf(%1)>\
   %o %?f OperationsToFuncIntf %( %1 )% 
   ++! l_Counter
  end // if
 end // for o
//	>\
 '>'
//	<%C%T#f_OperationsToFuncIntf(%1)>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C ->T %?f OperationsToFuncIntf %( %1 )%  
   ++! l_Counter
  end // if
 end // for C
//#UC END# *4A8E9D5E0038for4B5DA84A00DD*
; // OperationsToFuncIntf


// реализация абстрактного стереотипа OperationsPublisher::Class
// Определяет необходимые uses для операций
//%f _OperationsToUses
: OperationsToUses OBJECT IN %S
//#UC START# *4A82DDA6016Afor4B5DA84A00DD*
//	<%R#f_OperationsToUses()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%R
 begin
  OBJECT IN %R
  if true then
  begin
   %R %?f OperationsToUses %( )% 
   ++! l_Counter
  end // if
 end // for R
//	<{}{%G#f_IsVCMMainForm()!=true}%G#f_OperationsToUses()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if ( ( %G %?f IsVCMMainForm %( )% ) %!=  true ) then
  begin
   %G %?f OperationsToUses %( )% 
   ++! l_Counter
  end // if
 end // for G
//	<{}{%o#f_IsVCMOperation()=true}\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( %o %?f IsVCMOperation %( )% ) %==  true ) then
  begin
//	%o#f_OperationsToUses()\
   %o %?f OperationsToUses %( )% 
//	>\

   ++! l_Counter
  end // if
 end // for o
//	<%C%T#f_OperationsToUses()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C ->T %?f OperationsToUses %( )%  
   ++! l_Counter
  end // if
 end // for C
//#UC END# *4A82DDA6016Afor4B5DA84A00DD*
; // OperationsToUses


// реализация абстрактного стереотипа OperationsPublisher::Class
// Операции в секцию Var
//%f _OperationsToVar
: OperationsToVar OBJECT IN %S
//#UC START# *4A8E9D3A01FEfor4B5DA84A00DD*
//	<%R#f_OperationsToVar()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%R
 begin
  OBJECT IN %R
  if true then
  begin
   %R %?f OperationsToVar %( )% 
   ++! l_Counter
  end // if
 end // for R
//	<{}{%G#f_IsVCMMainForm()!=true}%G#f_OperationsToVar()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if ( ( %G %?f IsVCMMainForm %( )% ) %!=  true ) then
  begin
   %G %?f OperationsToVar %( )% 
   ++! l_Counter
  end // if
 end // for G
//	<{}{%o#f_IsVCMOperation()=true}\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( %o %?f IsVCMOperation %( )% ) %==  true ) then
  begin
//	%o#f_OperationsToVar()\
   %o %?f OperationsToVar %( )% 
//	>\

   ++! l_Counter
  end // if
 end // for o
//	<%C%T#f_OperationsToVar()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C ->T %?f OperationsToVar %( )%  
   ++! l_Counter
  end // if
 end // for C
//#UC END# *4A8E9D3A01FEfor4B5DA84A00DD*
; // OperationsToVar


// реализация абстрактного стереотипа OperationsPublisher::Class
// Публикует операции
//%f _PublishOperations
: PublishOperations OBJECT IN %S
//#UC START# *4A770F770199for4B5DA84A00DD*
//	<%R#f_PublishOperations()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%R
 begin
  OBJECT IN %R
  if true then
  begin
   %R %?f PublishOperations %( )% 
   ++! l_Counter
  end // if
 end // for R
//	<{}{%G#f_IsVCMMainForm()!=true}%G#f_PublishOperations()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if ( ( %G %?f IsVCMMainForm %( )% ) %!=  true ) then
  begin
   %G %?f PublishOperations %( )% 
   ++! l_Counter
  end // if
 end // for G
//	<{}{%o#f_IsVCMOperation()=true}\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%o
 begin
  OBJECT IN %o
  if ( ( %o %?f IsVCMOperation %( )% ) %==  true ) then
  begin
//	%o#f_PublishOperations()\
   %o %?f PublishOperations %( )% 
//	>\

   ++! l_Counter
  end // if
 end // for o
//	<%C%T#f_PublishOperations()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C ->T %?f PublishOperations %( )%  
   ++! l_Counter
  end // if
 end // for C
//#UC END# *4A770F770199for4B5DA84A00DD*
; // PublishOperations


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _DoSpell
: DoSpell OBJECT IN %S
//#UC START# *4B2A19E3038Bfor4B5DA84A00DD*
//	%S%[inherited]\
 inherited

//	[{%Sa=final}\
 if ( ( %S |a ) %== 'final' ) then
 begin


//	[{%S%f_HasUserTypeRec()!=true}\
  if ( ( %S %f HasUserTypeRec %( )% ) %!=  true ) then
  begin
//	%S%f_add_class(%SU_UserType,UserType,ut_%SN,Form_Def)\
   %S %f add_class %( %S |U '_UserType' %, 'UserType' %, 'ut_'
   %S |N %, 'Form_Def' )% 
//	%{Form_Def}%f_set_documentation([{}{%SN}%SD])\
   ( get_global_var ( 'Form_Def' ) %f set_documentation %( if NOT-EMPTY
   begin
    %S |D 
   end // if
   NOP
   else
   begin
    %S |N 
   end // else
)% ) //	%{Form_Def}%f_set_up(VisibleToUser,false)\
   ( get_global_var ( 'Form_Def' ) %f set_up %( 'VisibleToUser' %, false )% ) 
//	]\
  end // if


//	[{%S{restrict form def}!=true}\
  if ( ( %S get_up ( 'restrict form def' ) ) %!=  true ) then
  begin
//	[{<{}{%RS=VCMFormDefinition}{C}>=0}\
   if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%R
    begin
     OBJECT IN %R
     if ( ( %R |S ) %== 'VCMFormDefinition' ) then
     begin

      ++! l_Counter
     end // if
    end // for R
    l_Counter
    %== 0 ) then
   begin
//	[{%S{finished}=true}\
    if ( ( %S get_up ( 'finished' ) ) %==  true ) then
    begin
//	%S%f_add_class(%SU_Def,VCMFormDefinition,%SN$Def,Form_Def)\
     %S %f add_class %( %S |U '_Def' %, 'VCMFormDefinition' %, %S |N '$Def' %, 'Form_Def' )% 
//	%{Form_Def}%f_set_documentation(Идентификатор формы %SN)\
     ( get_global_var ( 'Form_Def' ) %f set_documentation %( 'Идентификатор формы '
     %S |N )% ) 
//	%f_addR(%S,%{Form_Def})\
     [%f] addR %( %S %, ( get_global_var ( 'Form_Def' ) ) )% 
//	]\
    end // if
//	]\
   end // if
//	]\
  end // if
//	]\
 end // if

//	<{}{%RS=VCMFormDefinition}\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%R
 begin
  OBJECT IN %R
  if ( ( %R |S ) %== 'VCMFormDefinition' ) then
  begin
//	[{%f_HasFactory(%S)!=true}\
   if ( ( [%f] HasFactory %( %S )% ) %!=  true ) then
   begin
//	[{%S{finished}=true}{\
    if ( ( %S get_up ( 'finished' ) ) %==  true ) then
    begin
//	%S%f_add_operation(%SU_Ini,ini,Ini_FormFactory_%RN (),Op_Instance)\
     %S %f add_operation %( %S |U '_Ini' %, 'ini' %, 'Ini_FormFactory_'
     %R |N ' ()' %, 'Op_Instance' )% 
//	]\
    end // if
    else
    begin
//	%P%f_add_operation(%SU_Ini,ini,Ini_FormFactory_%SN_%RN (),Op_Instance)\
     %P %f add_operation %( %S |U '_Ini' %, 'ini' %, 'Ini_FormFactory_'
     %S |N '_'
     %R |N ' ()' %, 'Op_Instance' )% 
//	}\
    end // else
//	%{Op_Instance}%f_set_documentation(Регистрация фабрики формы %SN)\
    ( get_global_var ( 'Op_Instance' ) %f set_documentation %( 'Регистрация фабрики формы '
    %S |N )% ) 
//	%{Op_Instance}%f_set_abstraction_type(final)\
    ( get_global_var ( 'Op_Instance' ) %f set_abstraction_type %( 'final' )% ) 
//	%{Op_Instance}%f_set_visibility_type(PrivateAccess)\
    ( get_global_var ( 'Op_Instance' ) %f set_visibility_type %( 'PrivateAccess' )% ) 
//	%{Op_Instance}%f_set_var(SpelledFor,S)\
    ( get_global_var ( 'Op_Instance' ) %f set_var %( 'SpelledFor' %, 'S' )% ) 
//	[{%S{finished}!=true|%f_UseNewGenRecG(%S)!=true}\
    if ( ( %S get_up ( 'finished' ) ) %!=  true OR 
      ( ( [%f] UseNewGenRecG %( %S )% ) %!=  true  ) ) then
    begin
//	%{Op_Instance}%f_set_uc_content(intf.pas,,\
     ( get_global_var ( 'Op_Instance' ) %f set_uc_content %( 'intf.pas' %, '' %, 
//	 fm_%f_cut_prefix(%f_pas_TypeName(%S),T).SetFactory(%f_pas_TypeName(%S).Make);\
     ' fm_'
     [%f] cut_prefix %( [%f] pas_TypeName %( %S )% %, 'T' )% '.SetFactory('
     [%f] pas_TypeName %( %S )% '.Make);'
//	)\
)% ) //	]\
    end // if
//	]\
   end // if
//	>\

   ++! l_Counter
  end // if
 end // for R

//	[{%Sa=final}\
 if ( ( %S |a ) %== 'final' ) then
 begin
//	%S%f_set_visibility_type(PublicAccess)\
  %S %f set_visibility_type %( 'PublicAccess' )% 
//	]
 end // if

//f _IsFormFactory
; // DoSpell

end. // <<VCMForm>>

: IsFormFactory OBJECT IN %S
//	[{%SN=Make}{false}[{%SS=factory|%SS=Factory}{false}true]]
 if ( ( %S |N ) %== 'Make' ) then
 begin
  if ( ( %S |S ) %== 'factory' OR 
    ( ( %S |S ) %== 'Factory'  ) ) then
  begin
    true 
  end // if
  else
  begin
    false 
  end // else
 end // if
 else
 begin
   false 
 end // else

//f _HasFactory
; // IsFormFactory

: HasFactory OBJECT IN %S
//@ %SU
//	[{<{}{%f_IsFormFactory(%C)=true}{C}>=0}{\
 if ( 
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( [%f] IsFormFactory %( %C )% ) %==  true ) then
   begin

    ++! l_Counter
   end // if
  end // for C
  l_Counter
  %== 0 ) then
 begin
//	[{<{}{%GS!=SimpleClass&%f_HasFactory(%G)=true}{C}>=0}{\
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%G
   begin
    OBJECT IN %G
    if ( ( %G |S ) %!= 'SimpleClass' AND 
     ( ( [%f] HasFactory %( %G )% ) %==  true  ) ) then
    begin

     ++! l_Counter
    end // if
   end // for G
   l_Counter
   %== 0 ) then
  begin
//	false\
    false 
//	]\
  end // if
  else
  begin
//	true\
    true 
//	}\
  end // else
//	]
 end // if
 else
 begin
//	true\
   true 
//	}\
 end // else
//#UC END# *4B2A19E3038Bfor4B5DA84A00DD*
; // HasFactory


// перекрытие базового стереотипа Ifdef::MDAGenerator
//%f _UseNewGenRec
implementation @ <<VCMForm>>
: UseNewGenRec OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *56BCA5310152for4B5DA84A00DD*
//	%f_UseNewGenRecG(%S)
 [%f] UseNewGenRecG %( %S )% 
//#UC END# *56BCA5310152for4B5DA84A00DD*
; // UseNewGenRec


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: VCMForm::Class::ViewArea::Attribute
end. // <<VCMForm>>

implementation @ :: <<VCMForm>> <<ViewArea>> ;
//? Контроллер области вывода
//= VCMController::Class

// Параметры стереотипа
//v #-
// - типы видимости
//a f
// - тип абстракции
//l l
// - возможные типы связи атрибута

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет, что элемент является контролелром области вывода
//%f _IsViewAreaController
; // st_space_key

: IsViewAreaController OBJECT IN %S
//#UC START# *497DF8C8028Efor494B848E003E*
//	true
 true
//#UC END# *497DF8C8028Efor494B848E003E*
; // IsViewAreaController


//: VCMForm::Class::UseCase::Attribute
end. // :: <<VCMForm>> <<ViewArea>> ;

implementation @ :: <<VCMForm>> <<UseCase>> ;
//? Контроллер прецедента
//= VCMController::Class

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет является ли элемент контроллером прецедента
//%f _IsUseCaseController
; // st_space_key

: IsUseCaseController OBJECT IN %S
//#UC START# *494B7E8B02B1for496A21CE0209*
//	true
 true
//#UC END# *494B7E8B02B1for496A21CE0209*
; // IsUseCaseController


//: VCMForm::Class::GroupItemsInContextMenu::ClassDependency
end. // :: <<VCMForm>> <<UseCase>> ;

implementation @ :: <<VCMForm>> <<GroupItemsInContextMenu>> ;
//? Группировать операции сущности в контекстном меню
//= ClassBaseGenerator::MDAGenerator

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for502128C500BE*
//#UC END# *46E6D4BB0339for502128C500BE*
; // wiki


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor502128C500BE*
//#UC END# *47022C88029Ffor502128C500BE*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor502128C500BE*
//#UC END# *47022CB8034Bfor502128C500BE*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor502128C500BE*
//#UC END# *47022CCF00EAfor502128C500BE*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for502128C500BE*
//#UC END# *470321950119for502128C500BE*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor502128C500BE*
//#UC END# *470321C1038Afor502128C500BE*
; // fctr.java


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor502128C500BE*
//#UC END# *470F1571031Cfor502128C500BE*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor502128C500BE*
//#UC END# *470F15B800CBfor502128C500BE*
; // impl.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'

//%f _NeedGroupItemsInContextMenu
; // st_space_key

: NeedGroupItemsInContextMenu OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *502129440035for502128C500BE*
//	true
 true
//#UC END# *502129440035for502128C500BE*
; // NeedGroupItemsInContextMenu


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for502128C500BE*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for502128C500BE*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor502128C500BE*
//	dep
 'dep'
//#UC END# *4705CBD6003Efor502128C500BE*
; // wiki_child_kind


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for502128C500BE*
//#UC END# *470484D50138for502128C500BE*
; // wiki_up_add_gen


//: VCMForm::Class::ToolbarAtBottom::ClassDependency
end. // :: <<VCMForm>> <<GroupItemsInContextMenu>> ;

implementation @ :: <<VCMForm>> <<ToolbarAtBottom>> ;
//= ClassBaseGenerator::MDAGenerator

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for502149B8006C*
//#UC END# *46E6D4BB0339for502149B8006C*
; // wiki


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor502149B8006C*
//#UC END# *47022C88029Ffor502149B8006C*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor502149B8006C*
//#UC END# *47022CB8034Bfor502149B8006C*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor502149B8006C*
//#UC END# *47022CCF00EAfor502149B8006C*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for502149B8006C*
//#UC END# *470321950119for502149B8006C*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor502149B8006C*
//#UC END# *470321C1038Afor502149B8006C*
; // fctr.java


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor502149B8006C*
//#UC END# *470F1571031Cfor502149B8006C*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor502149B8006C*
//#UC END# *470F15B800CBfor502149B8006C*
; // impl.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'

//%f _ToolbarAtBottom
; // st_space_key

: ToolbarAtBottom OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *502149CA00B1for502149B8006C*
//	true
 true
//#UC END# *502149CA00B1for502149B8006C*
; // ToolbarAtBottom


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for502149B8006C*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for502149B8006C*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor502149B8006C*
//	dep
 'dep'
//#UC END# *4705CBD6003Efor502149B8006C*
; // wiki_child_kind


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for502149B8006C*
//#UC END# *470484D50138for502149B8006C*
; // wiki_up_add_gen


//: VCMForm::Class::ContextMenuWeight::ClassDependency
end. // :: <<VCMForm>> <<ToolbarAtBottom>> ;

implementation @ :: <<VCMForm>> <<ContextMenuWeight>> ;
//= ClassBaseGenerator::MDAGenerator

// Пользовательские свойства
//p Value:s ? 

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for51CE86080034*
//#UC END# *46E6D4BB0339for51CE86080034*
; // wiki


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor51CE86080034*
//#UC END# *47022C88029Ffor51CE86080034*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor51CE86080034*
//#UC END# *47022CB8034Bfor51CE86080034*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor51CE86080034*
//#UC END# *47022CCF00EAfor51CE86080034*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for51CE86080034*
//#UC END# *470321950119for51CE86080034*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor51CE86080034*
//#UC END# *470321C1038Afor51CE86080034*
; // fctr.java


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor51CE86080034*
//#UC END# *470F1571031Cfor51CE86080034*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor51CE86080034*
//#UC END# *470F15B800CBfor51CE86080034*
; // impl.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{Value}"!="%S{!Value}"}%f_up_prefix(%S) *Value* = *%S{Value}*
 ?inherited
 if ( ( %S get_up ( 'Value' ) ) %!= ( %S get_up_def ( 'Value' ) ) ) then
 begin
  [%f] up_prefix %( %S )% ' *Value* = *'
  %S get_up ( 'Value' ) '*'
//	]
 end // if

//%f _ContextMenuWeight
; // wiki_up_print

: ContextMenuWeight OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *51CE863501D2for51CE86080034*
//	true
 true
//#UC END# *51CE863501D2for51CE86080034*
; // ContextMenuWeight


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for51CE86080034*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for51CE86080034*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor51CE86080034*
//#UC END# *4705CBD6003Efor51CE86080034*
; // wiki_child_kind


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for51CE86080034*
//#UC END# *470484D50138for51CE86080034*
; // wiki_up_add_gen



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<VCMForm>> <<ContextMenuWeight>> ;

