////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/VCMTemplates/VCMViewInterfacesLayer/FormOperations/VCMOperations.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$ForDelphi::VCMTemplates::VCMViewInterfacesLayer::FormOperations::VCMOperations
//
// Набор операций
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: VCMOperations::Class
implementation @ <<VCMOperations>>
//? Набор операций
//> VCMOperation::Class

//= WikiImplClass::Class
//= Delphi интерфейсы и реализация::MDAGenerator
//= OperationsPublisher::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//Y code_vcm_operations.gif
//L code_vcm_operations
// Параметры визуализации
//$ C 192,255,255
//$ l 0,128,255
//$ f 0,128,255

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'

// нет документации
//%f _IsVCMOperations
; // st_space_key

: IsVCMOperations OBJECT IN %S
//#UC START# *494FCCEC019Ffor494F808C01DB*
//	true
 true
//#UC END# *494FCCEC019Ffor494F808C01DB*
; // IsVCMOperations


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа OperationsPublisher::Class
//%f _OperationsToFuncImpl
: OperationsToFuncImpl OBJECT IN %S
// параметры: aCaller: MDAClass = %1
//#UC START# *4A8E9F9502BBfor494F808C01DB*
//	<%C#f_OperationsToFuncImpl(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f OperationsToFuncImpl %( %1 )% 
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_OperationsToFuncImpl(%1)>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f OperationsToFuncImpl %( %1 )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A8E9F9502BBfor494F808C01DB*
; // OperationsToFuncImpl


// реализация абстрактного стереотипа OperationsPublisher::Class
// Операции в функции
//%f _OperationsToFuncIntf
: OperationsToFuncIntf OBJECT IN %S
// параметры: aCaller: MDAClass = %1
//#UC START# *4A8E9D5E0038for494F808C01DB*
//	<%C#f_OperationsToFuncIntf(%1)>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f OperationsToFuncIntf %( %1 )% 
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_OperationsToFuncIntf(%1)>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f OperationsToFuncIntf %( %1 )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A8E9D5E0038for494F808C01DB*
; // OperationsToFuncIntf


// реализация абстрактного стереотипа OperationsPublisher::Class
// Определяет необходимые uses для операций
//%f _OperationsToUses
: OperationsToUses OBJECT IN %S
//#UC START# *4A82DDA6016Afor494F808C01DB*
//	<%C#f_OperationsToUses()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f OperationsToUses %( )% 
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_OperationsToUses()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f OperationsToUses %( )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A82DDA6016Afor494F808C01DB*
; // OperationsToUses


// реализация абстрактного стереотипа OperationsPublisher::Class
// Операции в секцию Var
//%f _OperationsToVar
: OperationsToVar OBJECT IN %S
//#UC START# *4A8E9D3A01FEfor494F808C01DB*
//	<%C#f_OperationsToVar()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f OperationsToVar %( )% 
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_OperationsToVar()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f OperationsToVar %( )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A8E9D3A01FEfor494F808C01DB*
; // OperationsToVar


// реализация абстрактного стереотипа OperationsPublisher::Class
// Публикует операции
//%f _PublishOperations
: PublishOperations OBJECT IN %S
//#UC START# *4A770F770199for494F808C01DB*
//	<%C#f_PublishOperations()>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C %?f PublishOperations %( )% 
   ++! l_Counter
  end // if
 end // for C
//	<%G#f_PublishOperations()>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%G
 begin
  OBJECT IN %G
  if true then
  begin
   %G %?f PublishOperations %( )% 
   ++! l_Counter
  end // if
 end // for G
//#UC END# *4A770F770199for494F808C01DB*
; // PublishOperations


// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for494F808C01DB*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for494F808C01DB*
; // constraint


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет, что элемент может реализовываться классом
//%f _ClassImplementable
: ClassImplementable OBJECT IN %S
//#UC START# *49551CA202CFfor494F808C01DB*
//	false
 false
//#UC END# *49551CA202CFfor494F808C01DB*
; // ClassImplementable


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor494F808C01DB*
//#UC END# *470F15B800CBfor494F808C01DB*
; // impl.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor494F808C01DB*
//R  
//F %f_pas_OutInterfaceForward(%S)
//	[\{$IfDef %S{ifdef}\}\n]\
 if NOT-EMPTY
 begin
  '{$IfDef '
  %S get_up ( 'ifdef' ) '}'#13#10 
 end // if
 NOP
//	[<{}{%CC=Class&%C#f_IsVCMOperation()!=true}%CX>\n]
 if NOT-EMPTY
 begin
  INTEGER VAR l_Counter l_Counter := 0
  for %S%C
  begin
   OBJECT IN %C
   if ( ( %C |C ) %== 'Class' AND 
    ( ( %C %?f IsVCMOperation %( )% ) %!=  true  ) ) then
   begin
    %C |X 
    ++! l_Counter
   end // if
  end // for C
  #13#10 
 end // if
 NOP
//	%f_pas_OpenType(%S)\
//	[{%t_impl_class(%P)=true|%P#f_IsInterface()=true}[{<{}{%CC=Attribute&%C%TU=%PU}{C}>!=0}{\
 if ( ( [%t] impl_class %( %P )% ) %==  true OR 
   ( ( %P %?f IsInterface %( )% ) %==  true  ) ) then
 begin
  if ( 
   INTEGER VAR l_Counter l_Counter := 0
   for %S%C
   begin
    OBJECT IN %C
    if ( ( %C |C ) %== 'Attribute' AND 
     ( ( %C ->T |U  ) %== ( %P |U )  ) ) then
    begin

     ++! l_Counter
    end // if
   end // for C
   l_Counter
   %!= 0 ) then
  begin
//	%PF]]\
   %P |F 
  end // if
  else
  begin
//	[{<{}{%CC=Operation&%C%TU=%PU}{C}>!=0}{\
   if ( 
    INTEGER VAR l_Counter l_Counter := 0
    for %S%C
    begin
     OBJECT IN %C
     if ( ( %C |C ) %== 'Operation' AND 
      ( ( %C ->T |U  ) %== ( %P |U )  ) ) then
     begin

      ++! l_Counter
     end // if
    end // for C
    l_Counter
    %!= 0 ) then
   begin
    %P |F 
   end // if
   else
   begin
//	[{<{}{%CC=Operation&%C<{}{%C%TU=%1%PU}{C}>!=0}{C}>!=0}%PF]\
    if ( 
     INTEGER VAR l_Counter l_Counter := 0
     for %S%C
     begin
      OBJECT IN %C
      if ( ( %C |C ) %== 'Operation' AND 
       ( ( %C
      bind ( 
       OBJECT VAR %S
       INTEGER VAR l_Counter l_Counter := 0
       for %S%C
       begin
        OBJECT IN %C
        if ( ( %C ->T |U  ) %== ( %1 ->P |U  ) ) then
        begin

         ++! l_Counter
        end // if
       end // for C
       l_Counter

      ) // bind
 )       %!= 0  ) ) then
      begin

       ++! l_Counter
      end // if
     end // for C
     l_Counter
     %!= 0 ) then
    begin
     %P |F 
    end // if
//	}%PF]\
   end // else
//	}\
  end // else
 end // if
//	<{}{%CS=impurity value}%f_set_var(%CN,"%f_pas_TypeName(%C%T)")>\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== 'impurity value' ) then
  begin
   [%f] set_var %( %C |N %, [%f] pas_TypeName %( %C ->T  )% )% 
   ++! l_Counter
  end // if
 end // for C
//	(* %f_pas_TypeName(%S) = operations[(%f_pas_InterfaceAncestor(%S)[\{, <{, }{%R#f_IsPureMixIn()!=true}%f_pas_TypeName(%R)>\}])]\
 '(* '
 [%f] pas_TypeName %( %S )% ' = operations'
 if NOT-EMPTY
 begin
  '('
  [%f] pas_InterfaceAncestor %( %S )% if NOT-EMPTY
  begin
   '{, '
   INTEGER VAR l_Counter l_Counter := 0
   for %S%R
   begin
    OBJECT IN %R
    if ( ( %R %?f IsPureMixIn %( )% ) %!=  true ) then
    begin
     if ( l_Counter >0 ) then ( ', ' )
     [%f] pas_TypeName %( %R )% 
     ++! l_Counter
    end // if
   end // for R
   '}' 
  end // if
  NOP
  ')' 
 end // if
 NOP
//	[\n  \{* %SD \}]
 if NOT-EMPTY
 begin
  #13#10'  {* '
  %S |D ' }' 
 end // if
 NOP
//	   \['{%SG}'\]
 '   [''{'
 %S |G '}'']'
//	%f_pas_OutFacetBody(%S)\
 [%f] pas_OutFacetBody %( %S )% 
//	<{}{%R#f_IsPureMixIn()=true}[  // %RN\n\
 INTEGER VAR l_Counter l_Counter := 0
 for %S%R
 begin
  OBJECT IN %R
  if ( ( %R %?f IsPureMixIn %( )% ) %==  true ) then
  begin
   if NOT-EMPTY
   begin
    '  // '
    %R |N #13#10
//	%f_pas_OutFacetBody(%R)]\
    [%f] pas_OutFacetBody %( %R )% 
   end // if
   NOP
//	%R<{}{%g#f_IsPureMixIn()=true}[  // %gN\n\
   %R
   bind ( 
    OBJECT VAR %S
    INTEGER VAR l_Counter l_Counter := 0
    for %S%g
    begin
     OBJECT IN %g
     if ( ( %g %?f IsPureMixIn %( )% ) %==  true ) then
     begin
      if NOT-EMPTY
      begin
       '  // '
       %g |N #13#10
//	%f_pas_OutFacetBody(%g)]>\
       [%f] pas_OutFacetBody %( %g )% 
      end // if
      NOP

      ++! l_Counter
     end // if
    end // for g

   ) // bind
 //	>\

   ++! l_Counter
  end // if
 end // for R
//	 end;//%f_pas_TypeName(%S)*)\
 ' end;//'
 [%f] pas_TypeName %( %S )% '*)'
//	[\n\{$EndIf %S{ifdef}\}\n]\
 if NOT-EMPTY
 begin
  #13#10'{$EndIf '
  %S get_up ( 'ifdef' ) '}'#13#10 
 end // if
 NOP
//	<{}{%CS=impurity value}%f_set_var(%CN,"")>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if ( ( %C |S ) %== 'impurity value' ) then
  begin
   [%f] set_var %( %C |N %, '' )% 
   ++! l_Counter
  end // if
 end // for C
//#UC END# *470F1571031Cfor494F808C01DB*
; // intf.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for494F808C01DB*
//#UC END# *477398E501C0for494F808C01DB*
; // intf2.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Ресурсы (.rc)
//+ rc.pas
<<generator>> rc.pas OBJECT IN %S
//R  
//#UC START# *55B8D28B0157for494F808C01DB*
//#UC END# *55B8D28B0157for494F808C01DB*
; // rc.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Скрипты в ресурсах (.rc.script)
//+ rc.script.pas
<<generator>> rc.script.pas OBJECT IN %S
//R  
//#UC START# *55B8D2F80145for494F808C01DB*
//#UC END# *55B8D2F80145for494F808C01DB*
; // rc.script.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Компилятор ресурса (.res.cmd)
//+ res.cmd.pas
<<generator>> res.cmd.pas OBJECT IN %S
//R  
//#UC START# *55B8DD9C0301for494F808C01DB*
//#UC END# *55B8DD9C0301for494F808C01DB*
; // res.cmd.pas


// перекрытие базового стереотипа ModelBuilding::MDAGenerator
// генератор построения виртуальных элементов модели - запускается до генерации конкретных
// артефактов
//+ spell
<<generator>> spell OBJECT IN %S
//#UC START# *4A41A13D03D5for494F808C01DB*
//	<%CX>
 INTEGER VAR l_Counter l_Counter := 0
 for %S%C
 begin
  OBJECT IN %C
  if true then
  begin
   %C |X 
   ++! l_Counter
  end // if
 end // for C
//#UC END# *4A41A13D03D5for494F808C01DB*
; // spell


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: VCMOperations::Class::Operation
end. // <<VCMOperations>>

implementation @ :: <<VCMOperations>> <<Operation>> ;
//? Операция
//= VCMOperationBase::Class

// Параметры стереотипа
//T 
// - может не иметь "цели" (типа/результата)

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	SHD
 'SHD'



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; // st_space_key

end. // :: <<VCMOperations>> <<Operation>> ;

