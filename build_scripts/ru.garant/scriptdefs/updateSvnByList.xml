<?xml encoding = "ISO-8859-1"?>

<!--
	uses:
		ru.garant.extensions.properties.svnUpdateMaxCyclesCount

		ru.garant.extensions.scriptdefs.cleanupSvnByPath
-->

<scriptdef
	name = "ru.garant.extensions.scriptdefs.updateSvnByList"
	language = "javascript"
>
	<attribute name = "svn.dirset.list"/>
	<attribute name = "svn.root.dir"/>

	<![CDATA[
		{
			importClass (
				Packages.java.io.File
			);

			importPackage (
				Packages.org.apache.tools.ant
			);

			importPackage (
				Packages.org.apache.tools.ant.types
			);
		} {
			var a_svnDirsetList = (
				attributes.get ("svn.dirset.list")
			);

			var a_svnRootDir = (
				attributes.get ("svn.root.dir")
			);

			if (a_svnRootDir != null) {
				var l_svnRootDirFile = new File (a_svnRootDir);
				var l_svnRootDirPath = l_svnRootDirFile.getPath ();

				a_svnRootDir = l_svnRootDirPath;
			}

			var l_svnDirset = project.createDataType ("dirset"); {
				l_svnDirset.setDir (new File (a_svnRootDir));
				l_svnDirset.setIncludes (a_svnDirsetList);
			}

			var l_svnDirsetDirectoryScaner = l_svnDirset.getDirectoryScanner (project);
			var l_svnDirsetIncludedDirectories = l_svnDirsetDirectoryScaner.getIncludedDirectories ();

			var l_svnUpdateMaxCyclesCount = project.getProperty ("ru.garant.extensions.properties.svnUpdateMaxCyclesCount");

			var l_svnBreakCycle = false;

			for (
				var l_svnUpdateCycleIndex = 0
				; (!l_svnBreakCycle)
				; ++l_svnUpdateCycleIndex
			) {
				if (l_svnUpdateCycleIndex >= l_svnUpdateMaxCyclesCount) {
					var l_failTask = project.createTask ("fail"); {
						l_failTask.setMessage ("Too many svn update operation cycles (count = "+ l_svnUpdateCycleIndex+ ")");

						l_failTask.reconfigure ();
					}

					l_failTask.execute ();
				} else {
					if (l_svnUpdateCycleIndex != 0) {
						project.log (
							(
								"\t"
								+ "Update is not stable and will be repeated again"
							)
							, project.MSG_WARN
						);
					}
				}

				l_svnBreakCycle = true;

				for (
					var l_svnDirsetIncludedDirectoriesIndex = 0
					; (l_svnDirsetIncludedDirectoriesIndex < l_svnDirsetIncludedDirectories.length)
					; ++l_svnDirsetIncludedDirectoriesIndex
				) {
					var l_svnDirsetItem = l_svnDirsetIncludedDirectories [l_svnDirsetIncludedDirectoriesIndex];
					var l_svnDirectory = l_svnDirsetDirectoryScaner.getBasedir ()+ l_svnDirsetItem;

					project.log (
						(
							"\t"
							+ "Update svn catalog `"+ l_svnDirectory+ "`"
						)
						, project.MSG_INFO
					);

					{
						if (l_svnUpdateCycleIndex == 0) {
							var l_cleanupSvnByPath = project.createTask ("ru.garant.extensions.scriptdefs.cleanupSvnByPath"); {
								var l_runtimeConfigurableWrapper = l_cleanupSvnByPath.getRuntimeConfigurableWrapper (); {
									l_runtimeConfigurableWrapper.setAttribute ("svn.dir", l_svnDirectory);
								}

								l_cleanupSvnByPath.reconfigure ();
							}

							l_cleanupSvnByPath.execute ();
						}
					} {
						var l_svnOutputFile = File.createTempFile ("svn", ".log"); {
							l_svnOutputFile.deleteOnExit ();
						}

						var l_execTask = project.createTask ("exec"); {
							l_execTask.setDir (new File (l_svnDirectory));
							l_execTask.setExecutable ("svn.exe");
							l_execTask.setFailIfExecutionFails (true);
							l_execTask.setFailonerror (true);
							l_execTask.setLogError (true);
							l_execTask.setOutput (l_svnOutputFile);

							var l_execTaskArg = l_execTask.createArg (); {
								l_execTaskArg.setLine (
									"update"
									+ " --non-interactive"
									+ " --quiet"
									+ " ."
								);
							}

							l_execTask.reconfigure ();
						}

						l_execTask.execute ();

						if (l_svnOutputFile.length () != 0) {
							l_svnBreakCycle = false;
						}
					}
				}
			}
		}
	]]>
</scriptdef>
