//#UC START# *4677FBA70343_ext:FileName
w:\common\components\rtl\Garant\L3\l3Interfaces.pas
//#UC END# *4677FBA70343_ext:FileName
//#UC START# *46A480790259ci*
//#UC END# *46A480790259ci*
//#UC START# *46A480790259impl*
// start object Tl3_Point

procedure Tl3_Point.Init(aX, aY: Tl3Inch);
  {-инициализирует точку}
begin
 P.X := aX;
 P.Y := aY;
end;

function Tl3_Point.IsNull: Boolean;
  {-}
begin
 Result := (P.X = 0) AND (P.Y = 0);
end;

function Tl3_Point.Add(const Pt: Tl3_Point): Tl3_Point;
  {-складывает Self с P}
begin
 Result.P.X := P.X + Pt.P.X;
 Result.P.Y := P.Y + Pt.P.Y;
end;

function Tl3_Point.Sub(const Pt: Tl3_Point): Tl3_Point;
  {-вычитает P из Self и возвращает полученное значение}
begin
 Result.P.X := P.X - Pt.P.X;
 Result.P.Y := P.Y - Pt.P.Y;
end;

function Tl3_Point.Mul(const Pt: Tl3_Point): Tl3_Point;
  {-умножает Self на P и возвращает полученное значение}
begin
 Result.Init(P.X * Pt.P.X, P.Y * Pt.P.Y);
end;

function Tl3_Point.Divide(const Pt: Tl3_Point): Tl3_Point;
begin
 Result.Init(P.X div Pt.P.X, P.Y div Pt.P.Y);
end;

function Tl3_Point.EQ(const Pt: Tl3_Point): Boolean;
  {-проверяет равенство двух точек}
begin
 Result := (P.X = Pt.P.X) AND (P.Y = Pt.P.Y);
end;

function Tl3_Point.Neg: Tl3_Point;
  {-возвращает точку отраженную через начало координат}
begin
 Result.Init(-P.X, -P.Y);
end;

function Tl3_Point.e(aVert: Boolean): Tl3_Point;
  {-}
begin
 Result.P.bPt[aVert] := P.bPt[aVert];
 Result.P.bPt[not aVert] := 0;
end;
  
function Tl3_Point.eX: Tl3_Point;
  {-возвращает вектор параллельный оси X "длиной" Self.X}
begin
 Result.Init(P.X, 0);
end;

function Tl3_Point.e_X: Tl3_Point;
  {-возвращает вектор параллельный оси X "длиной" -Self.X}
begin
 Result.Init(-P.X, 0);
end;

function Tl3_Point.eY: Tl3_Point;
  {-возвращает вектор параллельный оси X "длиной" Self.Y}
begin
 Result.Init(0, P.Y);
end;

function Tl3_Point.e_Y: Tl3_Point;
  {-возвращает вектор параллельный оси X "длиной" -Self.Y}
begin
 Result.Init(0, -P.Y);
end;

function evZoom(Zoom: Integer; Value: Integer): Integer;
begin
 if (Zoom <> 100) then
  Result := l3MulDiv(Value, Zoom, 100)
 else
  Result := Value;
end;

function evDezoom(Zoom: Integer; Value: Integer): Integer;
begin
 if (Zoom <> 100) AND (Zoom > 0) then
  Result := l3MulDiv(Value, 100, Zoom)
 else
  Result := Value;
end;

function Tl3_Point.Zoom(Z: Integer): Tl3_Point;
  {-увеличивает координаты вектора на Z % и возвращает Result}
begin
 Result.Init(evZoom(Z, P.X), evZoom(Z, P.Y));
end;

function Tl3_Point.Dezoom(Z: Integer): Tl3_Point;
  {-уменьшает координаты вектора на Z % и возвращает Result}
begin
 Result.Init(evDezoom(Z, P.X), evDezoom(Z, P.Y));
end;

procedure Tl3_Point.MakeZoom(Z: Integer);
  {-увеличивает координаты вектора на Z %}
begin
 P.X := evZoom(Z, P.X);
 P.Y := evZoom(Z, P.Y);
end;
//#UC END# *46A480790259impl*
//#UC START# *46A480790259publ*
    public
    // public methods
      procedure Init(aX, aY: Tl3Inch);
        {* - инициализирует точку. }
      function  IsNull: Boolean;
        {-}
      function Add(const Pt: Tl3_Point): Tl3_Point;
        {* - складывает Self с P и возвращает полученное значение. }
      function Sub(const Pt: Tl3_Point): Tl3_Point;
        {* - вычитает P из Self и возвращает полученное значение. }
      function Mul(const Pt: Tl3_Point): Tl3_Point;
        {* - умножает Self на P и возвращает полученное значение. }
      function Divide(const Pt: Tl3_Point): Tl3_Point;
      function EQ(const Pt: Tl3_Point): Boolean;
        {* - проверяет равенство двух точек. }
      function Neg: Tl3_Point;
        {* - возвращает точку отраженную через начало координат. }
      function e(aVert: Boolean): Tl3_Point;
        {-}
      function eX: Tl3_Point;
        {* - возвращает вектор параллельный оси X "длиной" Self.X. }
      function e_X: Tl3_Point;
        {* - возвращает вектор параллельный оси X "длиной" -Self.X. }
      function eY: Tl3_Point;
        {* - возвращает вектор параллельный оси Y "длиной" Self.Y. }
      function e_Y: Tl3_Point;
        {* - возвращает вектор параллельный оси Y "длиной" -Self.Y. }
      function Zoom(Z: Integer): Tl3_Point;
        {* - увеличивает координаты вектора на Z % и возвращает Result. }
      function Dezoom(Z: Integer): Tl3_Point;
        {* - уменьшает координаты вектора на Z % и возвращает Result. }
      procedure MakeZoom(Z: Integer);
        {* - увеличивает координаты вектора на Z %. }
//#UC END# *46A480790259publ*
//#UC START# *46A498630097ci*
//#UC END# *46A498630097ci*
//#UC START# *46A498630097impl*
// start object Tl3_Rect

procedure Tl3_Rect.Inflate(const Pt: Tl3_Point);
  {overload;}
  {-увеличивает размеры прямоугольника на P}
begin
 TopLeft := Tl3_Point(R.TopLeft).Sub(Pt);
 BottomRight := Tl3_Point(R.BottomRight).Add(Pt);
end;

procedure Tl3_Rect.Inflate(X, Y: Tl3Inch);
  {overload;}
  {-увеличивает размеры прямоугольника на (X, Y)}
begin
 Dec(R.Left, X);
 Inc(R.Right, X);
 Dec(R.Top, Y);
 Inc(R.Bottom, Y);
end;

procedure Tl3_Rect.OffsetPt(const Pt: Tl3_Point);
  {-сдвинуть прямоугольник на Pt}
begin
 TopLeft := Tl3_Point(R.TopLeft).Add(Pt);
 BottomRight := Tl3_Point(R.BottomRight).Add(Pt);
end;

procedure Tl3_Rect.Offset(aX, aY: Tl3Inch);
  {-сдвинуть прямоугольник на (X, Y)}
begin
 Inc(R.Top, aY);
 Inc(R.Bottom, aY);
 Inc(R.Left, aX);
 Inc(R.Right, aX);
end;

function Tl3_Rect.ContainsPt(const Pt: Tl3_Point): Boolean;
  {-содержит ли прямоугольник точку Pt}
begin
 with Pt do
  Result := ((P.X >= R.Left) AND (P.Y >= R.Top)) AND ((P.X < R.Right) AND (P.Y < R.Bottom));
end;

function Tl3_Rect.EQ(const Rt: Tl3_Rect): Boolean;
  {-проверяет равенство двух прямоугольников}
begin
 Result := Tl3_Point(R.TopLeft).EQ(Rt.R.TopLeft) AND Tl3_Point(R.BottomRight).EQ(Rt.R.BottomRight);
end;

function Tl3_Rect.AddPt(const Pt: Tl3_Point): Tl3_Rect;
  {-сдвинуть прямоугольник на Pt и вернуть Result}
begin
 Result.R.Left := R.Left + Pt.P.X;
 Result.R.Right := R.Right + Pt.P.X;
 Result.R.Top := R.Top + Pt.P.Y;
 if R.Bottom = High(MaxInt) then
  Result.R.Bottom := High(Integer)
 else 
  Result.R.Bottom := R.Bottom + Pt.P.Y;
end;

function Tl3_Rect.SubPt(const Pt: Tl3_Point): Tl3_Rect;
  {-сдвинуть прямоугольник на -Pt и вернуть Result}
begin
 Result.R.Left := R.Left - Pt.P.X;
 Result.R.Right := R.Right - Pt.P.X;
 Result.R.Top := R.Top - Pt.P.Y;
 Result.R.Bottom := R.Bottom - Pt.P.Y;
end;

function evIntersectRect(var DR: Tl3Rect; const SR1, SR2: Tl3Rect): Boolean;
begin
 with DR do
 begin
  R.Top := Max(SR1.R.Top, SR2.R.Top);
  R.Bottom := Min(SR1.R.Bottom, SR2.R.Bottom);
  Result := (R.Top < R.Bottom);
  if Result then
  begin
   R.Left := Max(SR1.R.Left, SR2.R.Left);
   R.Right := Min(SR1.R.Right, SR2.R.Right);
   Result := (R.Left < R.Right);
  end;//Result
  if not Result then
   FillChar(DR, SizeOf(DR), 0);
 end;//with DR
end;

function Tl3_Rect.IntersectsWith(const Rt: Tl3_Rect): Boolean;
  {-проверяет пересечение Self с Rt}
var
 OutR : Tl3_Rect;
begin
 Result := evIntersectRect(OutR, Self, Tl3_Rect(Rt));
end;

(*function Tl3_Rect.pm_GetTopLeft: Tl3_Point;
  {-}
begin
 Result := Tl3_Point(R.TopLeft);
end;

procedure Tl3_Rect.pm_SetTopLeft(const aValue: Tl3_Point);
  {-}
begin
 R.TopLeft := aValue;
end;

function Tl3_Rect.pm_GetBottomRight: Tl3_Point;
  {-}
begin
 Result := Tl3_Point(R.BottomRight);
end;

procedure Tl3_Rect.pm_SetBottomRight(const aValue: Tl3_Point);
  {-}
begin
 R.BottomRight := aValue;
end;*)

procedure Tl3_Rect.MakeZoom(Z: Integer);
begin
 Top := evZoom(Z, Top);
 Left := evZoom(Z, Left);
 Right := evZoom(Z, Right);
 Bottom := evZoom(Z, Bottom);
end;
//#UC END# *46A498630097impl*
//#UC START# *46A498630097publ*
(*    protected
    // property methods
      function  pm_GetTopLeft: Tl3_Point;
      procedure pm_SetTopLeft(const aValue: Tl3_Point);
        {-}
      function  pm_GetBottomRight: Tl3_Point;
      procedure pm_SetBottomRight(const aValue: Tl3_Point);
        {-}*)
    public
    // public methods
      procedure Inflate(const Pt: Tl3_Point);
        overload;
        {* - увеличивает размеры прямоугольника на P. }
      procedure Inflate(X, Y: Tl3Inch);
        overload;
        {* - увеличивает размеры прямоугольника на (X, Y). }
      procedure OffsetPt(const Pt: Tl3_Point);
        {* - сдвинуть прямоугольник на Pt. }
      procedure Offset(aX, aY: Tl3Inch);
        {* - сдвинуть прямоугольник на (X, Y). }
      function  ContainsPt(const Pt: Tl3_Point): Boolean;
        {* - содержит ли прямоугольник точку Pt? }
      function  EQ(const Rt: Tl3_Rect): Boolean;
        {* - проверяет равенство двух прямоугольников. }
      function  AddPt(const Pt: Tl3_Point): Tl3_Rect;
        {* - сдвинуть прямоугольник на Pt и вернуть Result. }
      function  SubPt(const Pt: Tl3_Point): Tl3_Rect;
        {* - сдвинуть прямоугольник на -Pt и вернуть Result. }
      function  IntersectsWith(const Rt: Tl3_Rect): Boolean;
        {* - проверяет пересечение Self с Rt. }
      procedure MakeZoom(Z: Integer);
        {* - увеличивает координаты вектора на Z %. }
(*    public
    // public properties
      property TopLeft: Tl3_Point
        read pm_GetTopLeft
        write pm_SetTopLeft;
        {-}
      property BottomRight: Tl3_Point
        read pm_GetBottomRight
        write pm_SetBottomRight;
        {-}*)
//#UC END# *46A498630097publ*
//#UC START# *46A4988D03E1ci*
  Tl3ConvertPointProc = function (const Pt: TPoint): TPoint of object;
    {* Тип процедур для конвертации точек. }

//#UC END# *46A4988D03E1ci*
//#UC START# *46A4988D03E1impl*
// start object Tl3_SPoint

procedure Tl3_SPoint.Init(aX, aY: Integer);
  {-инициализирует точку}
begin
 P.X := aX;
 P.Y := aY;
end;

procedure Tl3_SPoint.Inc(const Pt: Tl3_SPoint);
  {-прибавляет Pt к Self}
begin
 System.Inc(P.X, Pt.P.X);
 System.Inc(P.Y, Pt.P.Y);
end;

procedure Tl3_SPoint.Dec(const Pt: Tl3_SPoint);
  {-отнимает Pt от Self}
begin
 System.Dec(P.X, Pt.P.X);
 System.Dec(P.Y, Pt.P.Y);
end;

function Tl3_SPoint.Add(const Pt: Tl3_SPoint): Tl3_SPoint;
  {-складывает Self с P и возвращает полученное значение}
begin
 if (P.X = High(P.X)) then
  Result.P.X := P.X
 else
  Result.P.X := P.X + Pt.P.X;
 if (P.Y = High(P.Y)) then
  Result.P.Y := P.Y
 else
  Result.P.Y := P.Y + Pt.P.Y;
end;

function Tl3_SPoint.Sub(const Pt: Tl3_SPoint): Tl3_SPoint;
  {-вычитает P из Self и возвращает полученное значение}
begin
 Result.P.X := P.X - Pt.P.X;
 Result.P.Y := P.Y - Pt.P.Y;
end;

function Tl3_SPoint.EQ(const Pt: Tl3_SPoint): Boolean;
  {-проверяет равенство двух точек}
begin
 Result := (P.X = Pt.P.X) AND (P.Y = Pt.P.Y);
end;

function Tl3_SPoint.Neg: Tl3_SPoint;
  {-возвращает точку отраженную через начало координат}
begin
 Result.P.X := -P.X;
 Result.P.Y := -P.Y;
end;

function Tl3_SPoint.GetCursorPos: Boolean;
  {-инициализирует точку значением начала координат курсора мыши}
var
 WP : TPoint;
begin
 Windows.GetCursorPos(WP);
 Self := Tl3_SPoint_C(WP.X, WP.Y);
 Result := true;
end;

function Tl3_SPoint.Zoom(Z: Integer): Tl3_SPoint;
  {-увеличивает координаты вектора на Z % и возвращает Result}
begin
 Result.Init(evZoom(Z, P.X), evZoom(Z, P.Y));
end;

function Tl3_SPoint.Dezoom(Z: Integer): Tl3_SPoint;
  {-уменьшает координаты вектора на Z % и возвращает Result}
begin
 Result.Init(evDezoom(Z, P.X), evDezoom(Z, P.Y));
end;

procedure Tl3_SPoint.MakeZoom(Z: Integer);
  {-увеличивает координаты вектора на Z %}
begin
 P.X := evZoom(Z, P.X);
 P.Y := evZoom(Z, P.Y);
end;

procedure Tl3_SPoint.MakeDezoom(Z: Integer);
  {-уменьшает координаты вектора на Z %}
begin
 P.X := evDezoom(Z, P.X);
 P.Y := evDezoom(Z, P.Y);
end;

function Tl3_SPoint.Convert(CP: Tl3ConvertPointProc): Tl3_SPoint;
  {-конвертирует точку процедурой CP}
begin
 with CP(TPoint(Self)) do
  Self := Tl3_SPoint_C(X, Y);
 Result := Self;
end;
//#UC END# *46A4988D03E1impl*
//#UC START# *46A4988D03E1publ*
    public
    // public methods
      procedure Init(aX, aY: Integer);
        {* - инициализирует точку. }
      procedure Inc(const Pt: Tl3_SPoint);
        {* - прибавляет Pt к Self. }
      procedure Dec(const Pt: Tl3_SPoint);
        {* - отнимает Pt от Self. }
      function  Add(const Pt: Tl3_SPoint): Tl3_SPoint;
        {* - складывает Self с P и возвращает полученное значение. }
      function  Sub(const Pt: Tl3_SPoint): Tl3_SPoint;
        {* - вычитает P из Self и возвращает полученное значение. }
      function EQ(const Pt: Tl3_SPoint): Boolean;
        {* - проверяет равенство двух точек. }
      function  Neg: Tl3_SPoint;
        {* - возвращает точку отраженную через начало координат. }
      function  GetCursorPos: Boolean;
        {* - инициализирует точку значением начала координат курсора мыши. }
      function  Zoom(Z: Integer): Tl3_SPoint;
        {* - увеличивает координаты вектора на Z % и возвращает Result. }
      function  Dezoom(Z: Integer): Tl3_SPoint;
        {* - уменьшает координаты вектора на Z % и возвращает Result. }
      procedure MakeZoom(Z: Integer);
        {* - увеличивает координаты вектора на Z %. }
      procedure MakeDezoom(Z: Integer);
        {* - уменьшает координаты вектора на Z %. }
      function  Convert(CP: Tl3ConvertPointProc): Tl3_SPoint;
        {* - конвертирует точку процедурой CP. }
//#UC END# *46A4988D03E1publ*
//#UC START# *47E0FA3E03CA_46A480790259_impl*
 Result.X := aX;
 Result.Y := aY;
//#UC END# *47E0FA3E03CA_46A480790259_impl*
//#UC START# *47E0FA3E03CA_46A480790259_var*
//#UC END# *47E0FA3E03CA_46A480790259_var*
//#UC START# *537B842903A3_46A4988D03E1_impl*
 Result.X := anX;
 Result.Y := anY;
//#UC END# *537B842903A3_46A4988D03E1_impl*
//#UC START# *537B842903A3_46A4988D03E1_var*
//#UC END# *537B842903A3_46A4988D03E1_var*
