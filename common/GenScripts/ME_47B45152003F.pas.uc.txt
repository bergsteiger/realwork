//#UC START# *47B486CB037A_47B45152003F_impl*
 CheckIndex(Index);
 DoDelete(Index);
//#UC END# *47B486CB037A_47B45152003F_impl*
//#UC START# *47B486CB037A_47B45152003F_var*
//#UC END# *47B486CB037A_47B45152003F_var*
//#UC START# *47B4895F01BE_47B45152003F_impl*
 {$IfNDef l3Items_NoChanging}
 Changing;
 try
 {$EndIf l3Items_NoChanging}
  l_P := ItemSlot(Index);
  Dec(f_Count);
  FreeSlot(l_P^);
  if (Index <> f_Count) then
   MoveItems(Index, Succ(Index), f_Count-Index, Self);
  {$If not defined(l3Items_IsAtomic)}
   l3FillChar(Pointer(ItemSlot(f_Count))^,
              {$If Declared(cItemSize)}
              cItemSize
              {$Else}
              _Instance_R_(Self).ItemSize
              {$IfEnd}
              );
   // - это для того, чтобы не оказалось лишней ссылки на строки и/или интерфейсы
  {$IfEnd}
 {$IfNDef l3Items_NoChanging}
 finally
  Changed;
 end;//try..finally
 {$EndIf  l3Items_NoChanging}
//#UC END# *47B4895F01BE_47B45152003F_impl*
//#UC START# *47B4895F01BE_47B45152003F_var*
var
 l_P : PItemType;
//#UC END# *47B4895F01BE_47B45152003F_var*
//#UC START# *47B49B1D033E_47B45152003F_impl*
 {$IfNDef l3Items_NoChanging}
 Changing;
 {$EndIf  l3Items_NoChanging}
 FillItem(aPlace, anItem{$IfDef l3Items_FillItem_NeedsList}, Self{$EndIf});
 {$IfNDef l3Items_NoChanging}
 Changed;
 {$EndIf  l3Items_NoChanging}
//#UC END# *47B49B1D033E_47B45152003F_impl*
//#UC START# *47B49B1D033E_47B45152003F_var*
//#UC END# *47B49B1D033E_47B45152003F_var*
//#UC START# *47B49EC50034_47B45152003F_impl*
 {$IfNDef l3Items_NoChanging}
 Changing;
 try
 {$EndIf  l3Items_NoChanging}
  l_Count := f_Count;
  l_Cap := GetCapacity(Self);
  if (l_Count >= l_Cap) then
   ReAllocList(ExpandSize(l_Cap + 1), Self);
  { Make room for the inserted item. }
  Dec(l_Count, anIndex);
  if (l_Count > 0) then
  begin
   MoveItems(anIndex + 1, anIndex + 0, l_Count, Self);
   {$If not defined(l3Items_IsAtomic)}
   l3FillChar(Pointer(ItemSlot(anIndex))^,
              {$If Declared(cItemSize)}
              cItemSize
              {$Else}
              _Instance_R_(Self).ItemSize
              {$IfEnd}
              );
   // - это для того, чтобы не оказалось лишней ссылки на строки и/или интерфейсы
   {$IfEnd}
  end;//l_Count > 0
  FillItem(ItemSlot(anIndex)^, aData{$IfDef l3Items_FillItem_NeedsList}, Self{$EndIf});
  Inc(f_Count);
  {$IfDef l3Items_IsAtomic}
  Assert(ItemSlot(anIndex)^ = aData);
  {$Else  l3Items_IsAtomic}
  {$If (SizeOf(_ItemType_) <= 4) AND not Defined(l3Items_Uncomparable)}
  Assert(ItemSlot(anIndex)^ = aData);
  {$IfEnd}
  {$EndIf l3Items_IsAtomic}
 {$IfNDef l3Items_NoChanging}
 finally
  Changed;
 end;//try..finally
 {$EndIf  l3Items_NoChanging}
//#UC END# *47B49EC50034_47B45152003F_impl*
//#UC START# *47B49EC50034_47B45152003F_var*
var
 l_Cap   : Integer;
 l_Count : Integer;
//#UC END# *47B49EC50034_47B45152003F_var*
//#UC START# *47B49FF70034_47B45152003F_impl*
 CheckIndex(anIndex);
//#UC END# *47B49FF70034_47B45152003F_impl*
//#UC START# *47B49FF70034_47B45152003F_var*
//#UC END# *47B49FF70034_47B45152003F_var*
//#UC START# *47B5982200F8_47B45152003Fget_impl*
 Result := GetCapacity(Self);
//#UC END# *47B5982200F8_47B45152003Fget_impl*
//#UC START# *47B5982200F8_47B45152003Fget_var*
//#UC END# *47B5982200F8_47B45152003Fget_var*
//#UC START# *47B5982200F8_47B45152003Fset_impl*
 if (aValue < 0) then
  SayBadCap(aValue);
 if (GetCapacity(Self) <> aValue) then
 begin
  { If the list is shrinking, then update _Count for the smaller size. }
  if (aValue < f_Count) then
   Count := aValue;
  ReAllocList(aValue, Self);
 end;//GetCapacity(Self) <> aValue
//#UC END# *47B5982200F8_47B45152003Fset_impl*
//#UC START# *47B5982200F8_47B45152003Fset_var*

 procedure SayBadCap(NewCapacity: LongInt);
 begin
  raise EListError.CreateFmt(sListIndexError, [NewCapacity]);
 end;

//#UC END# *47B5982200F8_47B45152003Fset_var*
//#UC START# *47B5A5B00230_47B45152003F_impl*
 {$If not defined(l3Items_NoSort)}
 Sorted := false;
 {$IfEnd} //not l3Items_NoSort
 Count := 0;
 if (f_Data.GetSize > 4 * 1024) then
  f_Data.SetSize(0);
  // - это видимо, чтобы в кеш не попадали большие куски памяти
 inherited;
//#UC END# *47B5A5B00230_47B45152003F_impl*
//#UC START# *47B5A5B00230_47B45152003F_var*
//#UC END# *47B5A5B00230_47B45152003F_var*
//#UC START# *47B5A5BF00D1_47B45152003F_impl*
 Count := 0;
 f_Data.SetSize(0);
 inherited;
//#UC END# *47B5A5BF00D1_47B45152003F_impl*
//#UC START# *47B5A5BF00D1_47B45152003F_var*
//#UC END# *47B5A5BF00D1_47B45152003F_var*
//#UC START# *47B5B5F1038E_47B45152003F_impl*
 {$IfDef l3Items_CompareItemsRec_NeedsRList}
 Assert(aList Is _l3Items_);
 {$EndIf l3Items_CompareItemsRec_NeedsRList}
 l_CI.rA := @A;
 l_CI.rB := @B;
 {$IfDef l3Items_HasCustomSort}
 l_CI.rSortIndex := aSortIndex;
 {$EndIf l3Items_HasCustomSort}
 {$IfDef l3Items_CompareItemsRec_NeedsRList}
 l_CI.rList := aList;
 {$EndIf l3Items_CompareItemsRec_NeedsRList}
 Result := CompareExistingItems(l_CI);
//#UC END# *47B5B5F1038E_47B45152003F_impl*
//#UC START# *47B5B5F1038E_47B45152003F_var*
var
 l_CI : CompareItemsRec;
//#UC END# *47B5B5F1038E_47B45152003F_var*
//#UC START# *47B5B7B6011A_47B45152003F_impl*
 if (Index < 0) or (Index >= f_Count) then
  _Error;
//#UC END# *47B5B7B6011A_47B45152003F_impl*
//#UC START# *47B5B7B6011A_47B45152003F_var*

 procedure _Error;
 begin
  raise EListError.CreateFmt(SListIndexError + ' from (%d)', [Index, f_Count])
 end;

//#UC END# *47B5B7B6011A_47B45152003F_var*
//#UC START# *47B5B88203A7_47B45152003F_impl*
 if (@I1 = @I2) then
  Exit;
 {$IfNDef l3Items_NoChanging}
 Changing;
 try
 {$EndIf  l3Items_NoChanging}
  DoExchange(I1, I2{$IfDef l3Items_FillItem_NeedsList}, Self{$EndIf});
 {$IfNDef l3Items_NoChanging}
 finally
  Changed;
 end;//try..finally
 {$EndIf l3Items_NoChanging}
//#UC END# *47B5B88203A7_47B45152003F_impl*
//#UC START# *47B5B88203A7_47B45152003F_var*
//#UC END# *47B5B88203A7_47B45152003F_var*
//#UC START# *47B5BDCD035D_47B45152003F_impl*
 Result := GetItemSlot(anIndex, Self);
//#UC END# *47B5BDCD035D_47B45152003F_impl*
//#UC START# *47B5BDCD035D_47B45152003F_var*
//#UC END# *47B5BDCD035D_47B45152003F_var*
//#UC START# *47B947FD009A_47B45152003F_impl*
 {$IfDef l3Items_NeedsBeforeFreeItem}
 BeforeFreeItem(aPlace);
 {$EndIf l3Items_NeedsBeforeFreeItem}
 FreeItem(aPlace{$IfDef l3Items_FreeItem_NeedsList}, Self{$EndIf});
//#UC END# *47B947FD009A_47B45152003F_impl*
//#UC START# *47B947FD009A_47B45152003F_var*
//#UC END# *47B947FD009A_47B45152003F_var*
//#UC START# *47B975AF02ED_47B45152003F_impl*
 Assert(aTargetSize > 0);

 Result := aTargetSize;
 if Result > cMaxForTwice then
 // большие массивы не удваиваем а подравниваем под 64мб
  Result := (aTargetSize div cMaxForTwice + 1) * cMaxForTwice
 else
 for I := 0 to High(cIncrArray) do
  if (aTargetSize > cIncrArray[I]) then
  begin
   Result := (aTargetSize div cIncrArray[I]) * cIncrArray[I] * 2;
   Break;
  end;//aTargetSize > cIncrArray[I]
//#UC END# *47B975AF02ED_47B45152003F_impl*
//#UC START# *47B975AF02ED_47B45152003F_var*
const
 cIncrArray : array [0..3] of Integer = (64 * 1024, 1024, 128, 4);
 cMaxForTwice : Integer = 1 * 1024 * 1024;
var
 I : Integer;
//#UC END# *47B975AF02ED_47B45152003F_var*
//#UC START# *47B97B0A0268_47B45152003F_impl*
 Result := (Count <= 0);
//#UC END# *47B97B0A0268_47B45152003F_impl*
//#UC START# *47B97B0A0268_47B45152003F_var*
//#UC END# *47B97B0A0268_47B45152003F_var*
//#UC START# *47B97BE20318_47B45152003Fget_impl*
 Result := 0;
//#UC END# *47B97BE20318_47B45152003Fget_impl*
//#UC START# *47B97BE20318_47B45152003Fget_var*
//#UC END# *47B97BE20318_47B45152003Fget_var*
//#UC START# *47B9BAFD01F4_47B45152003F_impl*
 Assert(aList Is _l3Items_);
 l_CI.rA := @anItem;
 l_CI.rB := @aData;
 {$IfDef l3Items_HasCustomSort}
 l_CI.rSortIndex := aSortIndex;
 {$EndIf l3Items_HasCustomSort}
 {$IfDef l3Items_CompareItemsRec_NeedsRList}
 l_CI.rList := aList;
 {$EndIf l3Items_CompareItemsRec_NeedsRList}
 Result := CompareExistingItems(l_CI);
//#UC END# *47B9BAFD01F4_47B45152003F_impl*
//#UC START# *47B9BAFD01F4_47B45152003F_var*
var
 l_CI : CompareItemsRec;
//#UC END# *47B9BAFD01F4_47B45152003F_var*
//#UC START# *47BB01F000D3_47B45152003F_impl*
 CheckIndex(I1);
 CheckIndex(I2);
 Swap(ItemSlot(I1)^, ItemSlot(I2)^);
//#UC END# *47BB01F000D3_47B45152003F_impl*
//#UC START# *47BB01F000D3_47B45152003F_var*
//#UC END# *47BB01F000D3_47B45152003F_var*
//#UC START# *47BEED100067_47B45152003F_impl*
 try
  Result := _Instance_R_{_l3Items_R_}(Self).Iterate(I1, I2, Action);
 finally
  l3FreeIA(Action);
 end;//try..finally
//#UC END# *47BEED100067_47B45152003F_impl*
//#UC START# *47BEED100067_47B45152003F_var*
//#UC END# *47BEED100067_47B45152003F_var*
//#UC START# *47BEED3D038B_47B45152003F_impl*
 try
  Result := _Instance_R_{_l3Items_R_}(Self).IterateAll(Action);
 finally
  l3FreeIA(Action);
 end;//try..finally
//#UC END# *47BEED3D038B_47B45152003F_impl*
//#UC START# *47BEED3D038B_47B45152003F_var*
//#UC END# *47BEED3D038B_47B45152003F_var*
//#UC START# *4B87FCF8038B_47B45152003F_impl*
 // - ничего не делаем
//#UC END# *4B87FCF8038B_47B45152003F_impl*
//#UC START# *4B87FCF8038B_47B45152003F_var*
//#UC END# *4B87FCF8038B_47B45152003F_var*
