//#UC START# *48078DCF011F_48078D230277_impl*
  Assert(rootNode <> nil, 'rootNode <> nil');
  currNode := rootNode;
  if (count > 0) then
    while (true) do
    begin
      if (@NodeCallBack <> nil) then
        NodeCallBack(currNode);
      Dec(count);
      if (count = 0) then break;
      //
      if (level > 0 ) AND (currNode.HasChildren) then
      begin
        currNode.GetFirstChild(firstChild);
        if (firstChild <> nil) then // firstChild = nil это штатная ситуация (см. K: 106989170)
          LoadNodesPriv(firstChild, level-1, count, NodeCallBack);
      end;
      //
      if currNode.IsLast then break;
      //
      currNode.GetNext(tempNode);
      currNode := tempNode;
      tempNode := nil;
    end;
//#UC END# *48078DCF011F_48078D230277_impl*
//#UC START# *48078DCF011F_48078D230277_var*
    var
      currNode, tempNode, firstChild : INodeBase;
//#UC END# *48078DCF011F_48078D230277_var*
//#UC START# *48078DFD028F_48078D230277_impl*
    Result := false;
    assert(rootNode <> nil, 'rootNode <> nil');
    isLoadAll := (nodesCount = -1);
    //
    rootNode.IterateAllNodes(nodeFlag, nodeIter);
    assert(nodeIter <> nil, 'nodeIter <> nil');
    //
    node := rootNode;
    i := 1;
    while isLoadAll OR (i < nodesCount) do
    begin
      if (node = nil) then
      begin
        Result := isLoadAll;
        break;
      end;
      if (@NodeCallBack <> nil) then
        NodeCallBack(node);
      // берем следующую
      nodeIter.GetNext(node);
      //
      Inc(i);
    end;
//#UC END# *48078DFD028F_48078D230277_impl*
//#UC START# *48078DFD028F_48078D230277_var*
    const
      FUNCTION_NAME = 'TatNodeHelper.LoadNodes';
    var
      node : INodeBase;
      nodeIter : INodeIterator;
      isLoadAll : boolean;
      i : integer;
//#UC END# *48078DFD028F_48078D230277_var*
//#UC START# *4840189501ED_48078D230277_impl*
  Assert(aNode <> nil, 'aNode <> nil');
  aNode.GetCaption(l_String);
  Result := l_String.GetData
//#UC END# *4840189501ED_48078D230277_impl*
//#UC START# *4840189501ED_48078D230277_var*
  var
    l_String : IString;
//#UC END# *4840189501ED_48078D230277_var*
//#UC START# *4A4DE37502ED_48078D230277_impl*
  LoadNodesPriv(rootNode, level, count, nodeCallBack);
//#UC END# *4A4DE37502ED_48078D230277_impl*
//#UC START# *4A4DE37502ED_48078D230277_var*
//#UC END# *4A4DE37502ED_48078D230277_var*
//#UC START# *4A4DEF3101A3_4A4DEF1D0195_impl*
  node.GetCaption(str);
  if str <> nil then str.GetData;
//#UC END# *4A4DEF3101A3_4A4DEF1D0195_impl*
//#UC START# *4A4DEF3101A3_4A4DEF1D0195_var*
  var
    str : IString;
//#UC END# *4A4DEF3101A3_4A4DEF1D0195_var*
//#UC START# *4B90F22700A3_4B90F1F501DD_impl*
  Assert(VarType(aCaption) = varString, 'VarType(aCaption) = varString');
  aNode.GetCaption(l_String);
  Result := Assigned(l_String) AND (String(l_String.GetData) = VarToStr(aCaption));
//#UC END# *4B90F22700A3_4B90F1F501DD_impl*
//#UC START# *4B90F22700A3_4B90F1F501DD_var*
  var
    l_String : IString;
//#UC END# *4B90F22700A3_4B90F1F501DD_var*
//#UC START# *4B90F261015F_48078D230277_impl*
  Result := nil;
  l_CurrNode := aRoot;
  i := Low(aPath);
  if isExcludeRoot then
    GoToNextLevel;
  // проходим по дереву
  while (Result = nil) AND (l_CurrNode <> nil) do //AND (l_CurrNode.HasChildren)) do
  begin
    // ищем на текущем уровне удовлетворяющую ноду
    while (l_CurrNode <> nil) AND (NOT aMatchFunc(l_CurrNode, aPath[i])) do
    begin
      l_CurrNode.GetNext(l_TmpNode);
      l_CurrNode := l_TmpNode;
      l_TmpNode := nil;
    end;
    // если нода найдена
    if (l_CurrNode <> nil) then
      if (i = High(aPath)) then // и путь исчерпан, то значит нашли то что искали
        Result := l_CurrNode
      else
      begin
        // переходим к следующему элементу пути
        Inc(i);
        // переходим к следующему уровню
        GoToNextLevel;
      end;
  end;
//#UC END# *4B90F261015F_48078D230277_impl*
//#UC START# *4B90F261015F_48078D230277_var*
  var
    l_CurrNode, l_TmpNode : INodeBase;
    i : Integer;

  procedure GoToNextLevel;
  begin
    l_CurrNode.GetFirstChild(l_TmpNode);
    l_CurrNode := l_TmpNode;
    l_TmpNode := nil;
  end;
//#UC END# *4B90F261015F_48078D230277_var*
//#UC START# *4B90F2D60278_48078D230277_impl*
    assert(rootNode <> nil, 'rootNode <> nil');
    //
    Result := 1;
    // тупо итерируемся до конца
    rootNode.IterateAllNodes(FM_SHARED_NONE, nodeIter);
    if (nodeIter <> nil) then
      while true do
      begin
        nodeIter.GetNext(currNode);
        if (currNode <> nil) then
          Inc(Result)
        else
          break;
      end;

  {  currNode := rootNode;
    //
    if (NOT rootNode.HasChildren) then
    begin
      parentNode.GetParent(parentNode);
      if (parentNode <> nil) then
        rootNode.GetBySibblingIndex(parentNode.GetChildCount-1, currNode);
    end
    else // позиционируемся на самого последнего ребенка
      while currNode.HasChildren do
      begin
        currNode.GetFirstChild(firstChild);
        currNodeChildCount := currNode.GetChildCount;
        firstChild.GetBySibblingIndex(currNodeChildCount-1, currNode);
      end;
    // получаем количество нод как разницу абсолютных индексов
    Result := currNode.GetAbsIndex - rootNode.GetAbsIndex + 1; }
//#UC END# *4B90F2D60278_48078D230277_impl*
//#UC START# *4B90F2D60278_48078D230277_var*
    var
      parentNode, currNode, firstChild : INodeBase;
      currNodeChildCount : integer;
      nodeIter : INodeIterator;
//#UC END# *4B90F2D60278_48078D230277_var*
//#UC START# *4BAB7D76024F_48078D230277_impl*
  Result := nil;
  l_CurrNode := aNode;
  //
  while (Result = nil) AND (l_CurrNode <> nil) do
    if aMatchFunc(l_CurrNode, aValue) then
      Result := l_CurrNode
    else
    begin
      if l_CurrNode.HasChildren then // если есть дети, то начинаем искать среди них
        l_CurrNode.GetFirstChild(l_NextNode)
      else // берем следующую ноду
      begin
        l_CurrNode.GetNext(l_NextNode);
        // если она пустая, значит пробуем найти выше
        while (l_NextNode = nil) AND (l_CurrNode <> nil) do
        begin
          l_CurrNode.GetParent(l_NextNode);
          l_CurrNode := l_NextNode;
          l_NextNode := nil;
          //
          if (l_CurrNode <> nil) then
            l_CurrNode.GetNext(l_NextNode);
        end;
      end;
      //
      l_CurrNode := l_NextNode;
      l_NextNode := nil;
   end;
//#UC END# *4BAB7D76024F_48078D230277_impl*
//#UC START# *4BAB7D76024F_48078D230277_var*
  var
    l_CurrNode, l_NextNode : INodeBase;
//#UC END# *4BAB7D76024F_48078D230277_var*
//#UC START# *4BACB88F0360_48078D230277_impl*
  Assert(aNode <> nil, 'aNode <> nil');
  aNode.GetCaption(l_String);
  Result := l_String.GetData
//#UC END# *4BACB88F0360_48078D230277_impl*
//#UC START# *4BACB88F0360_48078D230277_var*
  var
    l_String : IString;
//#UC END# *4BACB88F0360_48078D230277_var*
//#UC START# *4FDB88BF0068_48078D230277_impl*
  Assert(aNode <> nil, 'aNode <> nil');
  aNode.GetCaption(l_String);
  Result := l_String.GetData
//#UC END# *4FDB88BF0068_48078D230277_impl*
//#UC START# *4FDB88BF0068_48078D230277_var*
  var
    l_String : IString;
//#UC END# *4FDB88BF0068_48078D230277_var*
//#UC START# *500466E70257_48078D230277_impl*
  // разбиваем путь на массив элементов
  l_Strings := TStringList.Create;
  try
    ExtractStrings([aPathDelimiter], [], PAnsiChar(aPath), l_Strings);
    SetLength(l_Path, l_Strings.Count);
    for i := 0 to l_Strings.Count-1 do
      l_Path[i] := l_Strings.Strings[i];
  finally
    FreeAndNil(l_Strings);
  end;

  if isCaseInsensitive then
    l_MatchFunc := TatNodeMatchFuncs.MatchByCaptionCI
  else
    l_MatchFunc := TatNodeMatchFuncs.MatchByCaption;

  Result := TatNodeHelper.FindNodeByPath(aRoot, l_Path, l_MatchFunc, isExcludeRoot);
//#UC END# *500466E70257_48078D230277_impl*
//#UC START# *500466E70257_48078D230277_var*
  var
    l_Path : array of Variant;
    i : Integer;
    l_MatchFunc : TatNodeMatchFuncOfObj;
    l_Strings : TStringList;
//#UC END# *500466E70257_48078D230277_var*
//#UC START# *50046733037B_4B90F1F501DD_impl*
  Assert(VarType(aCaption) = varString, 'VarType(aCaption) = varString');
  aNode.GetCaption(l_String);
  Result := Assigned(l_String) AND AnsiSameText(l_String.GetData, VarToStr(aCaption));
//#UC END# *50046733037B_4B90F1F501DD_impl*
//#UC START# *50046733037B_4B90F1F501DD_var*
  var
    l_String : IString;
//#UC END# *50046733037B_4B90F1F501DD_var*
//#UC START# *50056589021B_48078D230277_impl*
  Result := '';
  l_CurrentNode := aNode;
  while true do
  begin
    l_CurrentNode.GetCaption(l_Caption);
    if NOT Assigned(l_Caption) then
      Raise Exception.Create('Нельзя получить путь потому что найден пустой caption!');
    //
    l_CurrentNode.GetParent(l_ParentNode);
    l_CurrentNode := l_ParentNode;
    //
    if (l_CurrentNode <> nil) OR (NOT isExcludeRoot) then
      Result := String(l_Caption.GetData) + aPathDelimiter + Result;
    if l_CurrentNode = nil then break;
  end;
  if Length(Result) > 0 then
    SetLength(Result, Length(Result) - Length(aPathDelimiter));
//#UC END# *50056589021B_48078D230277_impl*
//#UC START# *50056589021B_48078D230277_var*
  var
    l_CurrentNode, l_ParentNode : INodeBase;
    l_Caption : IString;
//#UC END# *50056589021B_48078D230277_var*
//#UC START# *503E3A040395_503F7E3800E2_impl*
  InitConvertMap(CONVERT_MAP);
//#UC END# *503E3A040395_503F7E3800E2_impl*
//#UC START# *503E3A040395_503F7E3800E2_var*
  const
    CONVERT_MAP : array [0..44] of Synonyms = (
   (First : AT_ANNO_INTEREST; Second : 'Сфера интересов'),
   (First : AT_ANNO_KIND; Second : 'Вид информации'),
   (First : AT_ANNO_ORG; Second : 'Специфика Вашей организации'),
   (First : AT_ANNO_TAX; Second : 'Налоги и налогообложение'),
   (First : AT_ANNO_USER; Second : 'Ваша профессия'),
   (First : AT_BASES; Second : 'Информационный блок'),
   (First : AT_CLASS; Second : 'Раздел/Тема'),
   (First : AT_EDITION; Second : 'Искать в недействующих редакциях'),
   (First : AT_KW; Second : 'Ситуации'),
   (First : AT_NORM; Second : 'Значимость'),
   (First : AT_PREFIX; Second : 'Вид правовой информации'),
   (First : AT_PUBLISH_SOURCE; Second : 'Источник опубликования'),
   (First : AT_REG_IN_MU_NUM; Second : 'Регистрационный номер'),
   (First : AT_REG_IN_MU; Second : 'Статус регистрации'),
   (First : AT_REG_NUM; Second : 'Номер'),
   (First : AT_SOURCE; Second : 'Орган/Источник'),
   (First : AT_STATUS; Second : 'Статус'),
   (First : AT_TERRITORY; Second : 'Территория регулирования'),
   (First : AT_TYPE; Second : 'Тип'),
   (First : AT_UC; Second : 'Мои комментарии'),
   (First : AT_PHARM_INTERNATIONAL_NAME; Second : 'Международное наименование'),
   (First : AT_PHARM_TRADE_NAME; Second : 'Торговое наименование'),
   (First : AT_PHARM_CHAPTER; Second : 'Раздел справочника'),
   (First : AT_PHARM_COUNTRY; Second : 'Страна'),
   (First : AT_PHARM_FIRM; Second : 'Фирма'),
   (First : AT_PHARM_REG_STATUS; Second : 'Статус регистрации'),
   (First : AT_PHARM_MEDICINAL_FORM; Second : 'Лекарственная форма'),
   (First : AT_PHARM_ATC; Second : 'Код АТХ'),
   (First : AT_PHARM_MKB; Second : 'Класс МКБ'),
   (First : AT_PHARM_GROUP; Second : 'Фармгруппа'),
   (First : AT_PHARM_EFFECT; Second : 'Фармакологическое действие'),
   (First : AT_PHARM_NARCOTIC; Second : 'Сильнодействующие средства'),
   (First : AT_PHARM_IMPORTANT; Second : 'ЖНВЛП'),
   (First : AT_PHARM_COUNTRY_FOR_FILTER; Second : 'Страна'),
   (First : AT_PREFIX_REVIEW; Second : 'Вид правовой информации'),
   (First : AT_PUBLISH_SOURCE_FINANCE; Second : 'СМИ по налогам и бухучету'),
   (First : AT_PUBLISH_SOURCE_LEGAL; Second : 'СМИ для юриста'),
   (First : AT_PUBLISH_SOURCE_HR; Second : 'СМИ по кадровым вопросам'),
   (First : AT_PUBLISH_SOURCE_BUDGET_ORGS; Second : 'СМИ для государственного сектора'),
   (First : AT_BASE_SEARCH_PANES; Second : 'Вкладки Базового поиска'),
   (First : AT_CLASS_REVIEW; Second : 'Раздел/Тема'),
   (First : AT_SOURCE_REVIEW; Second : 'Орган/Источник'),
    (First : 'ExplanatoryDiction'; Second : 'Толковый словарь'),
      (First : 'MainMenu'; Second : 'Тематика'),
   (First : 'MedExplanatoryDiction'; Second : 'Словарь медицинских терминов')
    );
//#UC END# *503E3A040395_503F7E3800E2_var*
//#UC START# *505216EC02EC_48078D230277_impl*
  aNode.GetNext(Result);
//#UC END# *505216EC02EC_48078D230277_impl*
//#UC START# *505216EC02EC_48078D230277_var*
//#UC END# *505216EC02EC_48078D230277_var*
