//#UC START# *479731C50290_484D485A0275_impl*
  inherited;
  FreeAndNil(f_RegExp);
//#UC END# *479731C50290_484D485A0275_impl*
//#UC START# *479731C50290_484D485A0275_var*
//#UC END# *479731C50290_484D485A0275_var*
//#UC START# *47A042E100E2_484D485A0275_impl*
  f_MatchMethod := MM_ALL;
  f_Name := '';
//#UC END# *47A042E100E2_484D485A0275_impl*
//#UC START# *47A042E100E2_484D485A0275_var*
//#UC END# *47A042E100E2_484D485A0275_var*
//#UC START# *4808645502A6_480864400141_impl*
  if (folders = nil) then
    TatGblAdapterWorker.Instance.Folders.GetRoot(root)
  else
    folders.GetRoot(root);
  root.GetChild(0, Result);
  Assert(Result <> nil, 'Result <> nil');
//#UC END# *4808645502A6_480864400141_impl*
//#UC START# *4808645502A6_480864400141_var*
  var
    root : INode;
//#UC END# *4808645502A6_480864400141_var*
//#UC START# *4843BEA80357_4843BEFE0153_impl*
  f_FoldersNode := aFoldersNode;
  Result := CheckIsMatch;
//#UC END# *4843BEA80357_4843BEFE0153_impl*
//#UC START# *4843BEA80357_4843BEFE0153_var*
//#UC END# *4843BEA80357_4843BEFE0153_var*
//#UC START# *4843BF1B0059_4843C0AE03D4_impl*
  Result :=
    ( TFoldersItemType( FoldersNode.GetObjectType ) = FIT_BOOKMARK )
    AND ( inherited CheckIsMatch );
//#UC END# *4843BF1B0059_4843C0AE03D4_impl*
//#UC START# *4843BF1B0059_4843C0AE03D4_var*
//#UC END# *4843BF1B0059_4843C0AE03D4_var*
//#UC START# *4843BF1B0059_4843C7450355_impl*
  Result := true;
//#UC END# *4843BF1B0059_4843C7450355_impl*
//#UC START# *4843BF1B0059_4843C7450355_var*
//#UC END# *4843BF1B0059_4843C7450355_var*
//#UC START# *4843BF1B0059_484D2643016E_impl*
  Result :=
    ( TFoldersItemType( FoldersNode.GetObjectType ) = FIT_FOLDER )
    AND ( inherited CheckIsMatch );
//#UC END# *4843BF1B0059_484D2643016E_impl*
//#UC START# *4843BF1B0059_484D2643016E_var*
//#UC END# *4843BF1B0059_484D2643016E_var*
//#UC START# *4843BF1B0059_484D485A0275_impl*
  Result := false;
  if NOT (inherited CheckIsMatch) then
    Exit;
  // нам подходят любые ноды...
  if (f_MatchMethod = MM_ALL) then
  begin
    Result := true;
    Exit;
  end;
  // получаем имя объекта
  l_ObjectCaption := ObjectCaption;
  // и сравниваем с заданным
  case f_MatchMethod of
    MM_COMPARE  : Result := (l_ObjectCaption.GetData = f_Name);
    MM_REGEXP   : Result := f_RegExp.SearchInString(
      l_ObjectCaption.GetData, 0, l_ObjectCaption.GetLength, l_Pos, l_ObjectCaption.GetCodePage );
  end;
//#UC END# *4843BF1B0059_484D485A0275_impl*
//#UC START# *4843BF1B0059_484D485A0275_var*
  var
    l_ObjectCaption : IString;
    l_Pos : Tl3MatchPosition;
//#UC END# *4843BF1B0059_484D485A0275_var*
//#UC START# *4843BF1B0059_484FE8AF001E_impl*
  Result :=
    ( TFoldersItemType( FoldersNode.GetObjectType ) = FIT_LIST )
    AND ( inherited CheckIsMatch );
//#UC END# *4843BF1B0059_484FE8AF001E_impl*
//#UC START# *4843BF1B0059_484FE8AF001E_var*
//#UC END# *4843BF1B0059_484FE8AF001E_var*
//#UC START# *4843BF1B0059_4FD2376601E4_impl*
  Result :=
    ( TFoldersItemType( FoldersNode.GetObjectType ) = FIT_QUERY )
    AND ( inherited CheckIsMatch );
//#UC END# *4843BF1B0059_4FD2376601E4_impl*
//#UC START# *4843BF1B0059_4FD2376601E4_var*
//#UC END# *4843BF1B0059_4FD2376601E4_var*
//#UC START# *4843C7000113_480864400141_impl*
  Result := 0;
  Assert(aRootNode <> nil, 'aRootNode <> nil');
  //
  for i := aRootNode.GetChildCount-1 downto 0 do
  begin
    aRootNode.GetChild(i, l_CurrNode);
    Assert(l_CurrNode <> nil, 'l_CurrNode <> nil');
    if (aMatcher = nil) OR aMatcher.IsMatch(l_CurrNode) then
    begin
      aFoldersNodeCallback.OnFoldersNode(l_CurrNode);
      Inc(Result);
    end
    else if isRecursive AND (TFoldersItemType(l_CurrNode.GetObjectType) = FIT_FOLDER) then
      Result := Result + IterateAllChildFoldersNode(l_CurrNode, aFoldersNodeCallback, aMatcher, isRecursive)
  end; // for
//#UC END# *4843C7000113_480864400141_impl*
//#UC START# *4843C7000113_480864400141_var*
  var
    l_CurrNode : IFoldersNode;
    i : Integer;
//#UC END# *4843C7000113_480864400141_var*
//#UC START# *4843E40A01DE_480864400141_impl*
  Assert(anEntity <> nil, 'anEntity <> nil');
  l_MyDocs := GetMyDocuments;
  AddToFolder(l_MyDocs, anEntity, theAddedNode);
  Assert(theAddedNode <> nil, 'theAddedNode <> nil');
//#UC END# *4843E40A01DE_480864400141_impl*
//#UC START# *4843E40A01DE_480864400141_var*
  var
    l_MyDocs : IFoldersNode;
//#UC END# *4843E40A01DE_480864400141_var*
//#UC START# *48468B1302AF_480864400141_impl*
  Assert(aRootNode <> nil, 'aRootNode <> nil');
  Assert(aName <> '', 'aName <> ''''');
  // проверяем, что родительская нода является папкой
  l_ItemType := TFoldersItemType(aRootNode.GetObjectType);
  if (l_ItemType <> FIT_FOLDER) then
    Raise Exception.CreateFmt('Только папка может содержать дочерние папки! А нам передали объект типа %s.', [FIT2Str(l_ItemType)]);
  // создаем папку
  TatGblAdapterWorker.Instance.Folders.CreateFolder(l_Folder);
  Assert(l_Folder <> nil, 'l_Folder <> nil');
  // устанавливаем ее свойства
  l_Folder.SetName( TatStringHelper.DStr2AStr(aName) );
  l_Folder.SetComment( TatStringHelper.DStr2AStr(aComment) );
  // создаем ноду с папкой
  aRootNode.AddChildNode(l_Folder, theAddedNode);
  Assert(theAddedNode <> nil, 'theAddedNode <> nil');
//#UC END# *48468B1302AF_480864400141_impl*
//#UC START# *48468B1302AF_480864400141_var*
  var
    l_Folder : IFolder;
    l_ItemType : TFoldersItemType;

  function FIT2Str(aItemType : TFoldersItemType) : String;
  begin
    case aItemType of
      FIT_BOOKMARK        : Result := 'FIT_BOOKMARK';
      FIT_LIST            : Result := 'FIT_LIST';
      FIT_QUERY           : Result := 'FIT_QUERY';
      FIT_FOLDER          : Result := 'FIT_FOLDER';
      FIT_CONSULTATION    : Result := 'FIT_CONSULTATION';
      FIT_PHARM_LIST      : Result := 'FIT_PHARM_LIST';
      FIT_PHARM_BOOKMARK  : Result := 'FIT_PHARM_BOOKMARK';
    else
      Raise Exception.CreateFmt('Неизвестное значение aItemType (%d)!', [Ord(aItemType)]);
    end;
  end;
//#UC END# *48468B1302AF_480864400141_var*
//#UC START# *484D48AE03DD_484D485A0275get_impl*
  Result := f_MatchMethod;
//#UC END# *484D48AE03DD_484D485A0275get_impl*
//#UC START# *484D48AE03DD_484D485A0275get_var*
//#UC END# *484D48AE03DD_484D485A0275get_var*
//#UC START# *484D48AE03DD_484D485A0275set_impl*
  f_MatchMethod := aValue;
  if (f_MatchMethod = MM_REGEXP) AND (NOT Assigned(f_RegExp)) then
  begin
    f_RegExp := Tl3RegularSearch.Create;
    Assert(f_RegExp <> nil, 'f_RegExp <> nil');
    // переустанавливаем имя закладки
    Set_Name(f_Name);
  end;
//#UC END# *484D48AE03DD_484D485A0275set_impl*
//#UC START# *484D48AE03DD_484D485A0275set_var*
//#UC END# *484D48AE03DD_484D485A0275set_var*
//#UC START# *484D490C02C3_484D485A0275get_impl*
  Result := f_Name;
//#UC END# *484D490C02C3_484D485A0275get_impl*
//#UC START# *484D490C02C3_484D485A0275get_var*
//#UC END# *484D490C02C3_484D485A0275get_var*
//#UC START# *484D490C02C3_484D485A0275set_impl*
  f_Name := aValue;
  if (f_MatchMethod = MM_REGEXP) then
    f_RegExp.SearchPattern := f_Name;
//#UC END# *484D490C02C3_484D485A0275set_impl*
//#UC START# *484D490C02C3_484D485A0275set_var*
//#UC END# *484D490C02C3_484D485A0275set_var*
//#UC START# *484D51CF004B_4843BEFE0153get_impl*
 Result := f_FoldersNode;
//#UC END# *484D51CF004B_4843BEFE0153get_impl*
//#UC START# *484D51CF004B_4843BEFE0153get_var*
//#UC END# *484D51CF004B_4843BEFE0153get_var*
//#UC START# *484D51FE0183_4843C0AE03D4get_impl*
  FoldersNode.Open(l_Object);
  if (l_Object <> nil) then
    (l_Object as IBookmark).GetName(Result)
  else
    Raise Exception.Create('Не могу получить закладку из ноды!');
//#UC END# *484D51FE0183_4843C0AE03D4get_impl*
//#UC START# *484D51FE0183_4843C0AE03D4get_var*
  var
    l_Object : IUnknown;
//#UC END# *484D51FE0183_4843C0AE03D4get_var*
//#UC START# *484D51FE0183_484D2643016Eget_impl*
  FoldersNode.Open(l_Object);
  if (l_Object <> nil) then
    (l_Object as IFolder).GetName(Result)
  else
    Raise Exception.Create('Не могу получить папку из ноды!');
//#UC END# *484D51FE0183_484D2643016Eget_impl*
//#UC START# *484D51FE0183_484D2643016Eget_var*
  var
    l_Object : IUnknown;
//#UC END# *484D51FE0183_484D2643016Eget_var*
//#UC START# *484D51FE0183_484FE8AF001Eget_impl*
  FoldersNode.Open(l_Object);
  if (l_Object <> nil) then
    (l_Object as IDynList).GetName(Result)
  else
    Raise Exception.Create('Не могу получить список из ноды!');
//#UC END# *484D51FE0183_484FE8AF001Eget_impl*
//#UC START# *484D51FE0183_484FE8AF001Eget_var*
  var
    l_Object : IUnknown;
//#UC END# *484D51FE0183_484FE8AF001Eget_var*
//#UC START# *484D51FE0183_4FD2376601E4get_impl*
  FoldersNode.Open(l_Object);
  if (l_Object <> nil) then
    (l_Object as IDynList).GetName(Result)
  else
    Raise Exception.Create('Не могу получить запрос из ноды!');
//#UC END# *484D51FE0183_4FD2376601E4get_impl*
//#UC START# *484D51FE0183_4FD2376601E4get_var*
  var
    l_Object : IUnknown;
//#UC END# *484D51FE0183_4FD2376601E4get_var*
//#UC START# *48562215003C_480864400141_impl*
  Assert(aFolder <> nil, 'aFolder <> nil');
  Assert(anEntity <> nil, 'anEntity <> nil');
  //
  aFolder.AddChildNode(anEntity, theAddedNode);
  Assert(theAddedNode <> nil, 'theAddedNode <> nil');
//#UC END# *48562215003C_480864400141_impl*
//#UC START# *48562215003C_480864400141_var*
//#UC END# *48562215003C_480864400141_var*
