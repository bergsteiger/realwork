//#UC START# *479731C50290_48CA5CB001A3_impl*
 l3Free(f_Values);
 f_PrevIndex := -1;
 inherited; 
//#UC END# *479731C50290_48CA5CB001A3_impl*
//#UC START# *479731C50290_48CA5CB001A3_var*
//#UC END# *479731C50290_48CA5CB001A3_var*
//#UC START# *48CA5CB001A3_ext:FileName
w:\common\components\rtl\Garant\L3\l3CoordinateMap.pas
//#UC END# *48CA5CB001A3_ext:FileName
//#UC START# *48CA5CB001A3impl_uses*
//#UC END# *48CA5CB001A3impl_uses*
//#UC START# *48CA5D1F037A_48CA5CB001A3_impl*
 inherited Create;
 f_IsVertical := anOrientation;
 f_Values := Tl3FrameLineList.Make;
 f_PrevIndex := -1; 
//#UC END# *48CA5D1F037A_48CA5CB001A3_impl*
//#UC START# *48CA5D1F037A_48CA5CB001A3_var*
//#UC END# *48CA5D1F037A_48CA5CB001A3_var*
//#UC START# *48CA5D5101AE_48CA5CB001A3_impl*
 f_Values.IterateAllF(l3L2IA(@DrawElement));
//#UC END# *48CA5D5101AE_48CA5CB001A3_impl*
//#UC START# *48CA5D5101AE_48CA5CB001A3_var*

 function DrawElement(Data: PObject; Index: Integer): Boolean; 
 begin
  Result := True;
  Tl3FrameLine(Data^).DrawLine(aCanvas, aColorArray, f_IsVertical, aWidth);
 end;

//#UC END# *48CA5D5101AE_48CA5CB001A3_var*
//#UC START# *48CA5D78038C_48CA5CB001A3_impl*
 l_FoundIndex := -1;
 if aMapValue <> cWaitAlignMean then
 begin
  if (f_PrevIndex > -1) and not aToBuffer and f_IsVertical then
   l_FoundIndex := f_PrevIndex
  else
  for l_Index := f_Values.Count - 1 downto 0 do
  begin
   if (Abs(aMapValue - f_Values[l_Index].LineCoordinate) <= L3FrameLinesDelta) then
   begin
    l_FoundIndex := l_Index; 
    Break;
   end; // Abs(aMapValue - f_Values[l_Index].LineCoordinate) <= L3FrameLinesDelta 
  end; // for l_Index := f_Values.Count - 1 downto 0 do
 end; // if aMapValue <> cWaitAlignMean then
 if l_FoundIndex = -1 then 
 // Если не нашли ни одной подходящей линии, то пытаемся создать новую.
 begin
  l_FrameLine := Tl3FrameLine.Create(aMapValue);
  try
   l_FoundIndex := f_Values.Add(l_FrameLine);
   Result := l_FrameLine;
  finally
   l3Free(l_FrameLine);
  end;//try..finally
 end//if l_FoundIndex = -1 then 
 else
 begin
  Result := f_Values[l_FoundIndex];
  if f_VBuffer = l_FoundIndex then
  begin
   Result.LineCoordinate := aMapValue;
   f_VBuffer := -1;
  end; // if f_VBuffer = l_FoundIndex then
 end;
 if aLine <> nil then 
  Result.AssignData(aLine); 
 if aToBuffer and f_IsVertical then
  f_PrevIndex := l_FoundIndex
 else
  f_PrevIndex := -1;
//#UC END# *48CA5D78038C_48CA5CB001A3_impl*
//#UC START# *48CA5D78038C_48CA5CB001A3_var*
var
 l_Index      : Integer;
 l_FrameLine  : Tl3FrameLine;
 l_FoundIndex : Integer;
//#UC END# *48CA5D78038C_48CA5CB001A3_var*
//#UC START# *48CA5D9D008E_48CA5CB001A3_impl*
 l_Last := f_Values.Count - 1; 
 for l_Index := l_Last downto 0 do
 begin
  l_Line := f_Values[l_Index];
  if (l_Line.LineCoordinate <> cWaitAlignMean) then
   if (l_Line.LineCoordinate = cAlingByBoundary) or
     ((aStart - L3FrameLinesDelta) <= l_Line.LineCoordinate) and
     (l_Line.LineCoordinate <= (aFinish + L3FrameLinesDelta)) then
   begin
    aDestList.AddLine(aFinish, l_Line, False);
    l_Line := nil;
    f_Values.Delete(l_Index);
   end;//if ((aStart - L3FrameLinesDelta) <= f_Values[l_Index].LineCoordinate) and
 end;//for l_Index := l_Last downto 0 do
//#UC END# *48CA5D9D008E_48CA5CB001A3_impl*
//#UC START# *48CA5D9D008E_48CA5CB001A3_var*
var
 l_Last  : Integer; 
 l_Index : Integer;
 l_Line  : Tl3FrameLine;
//#UC END# *48CA5D9D008E_48CA5CB001A3_var*
//#UC START# *491448230196_48CA5CB001A3_impl*
 l_Last := f_Values.Count - 1;
 for l_Index := l_Last downto 0 do
 begin
  if (f_Values[l_Index].LineCoordinate = cWaitAlignMean) then
  begin
   l_Line := f_Values[l_Index];
   aDestList.AddLine(aValue, l_Line, False);
   l_Line := nil;
   f_Values.Delete(l_Index);
  end;//if ((aStart - L3FrameLinesDelta) <= f_Values[l_Index].LineCoordinate) and
 end;//for l_Index := l_Last downto 0 do
//#UC END# *491448230196_48CA5CB001A3_impl*
//#UC START# *491448230196_48CA5CB001A3_var*
var
 l_Last  : Integer;
 l_Index : Integer;
 l_Line  : Tl3FrameLine;
//#UC END# *491448230196_48CA5CB001A3_var*
//#UC START# *49BE609800C6_48CA5CB001A3_impl*
 f_Values.IterateAllF(l3L2IA(@CheckElement));
//#UC END# *49BE609800C6_48CA5CB001A3_impl*
//#UC START# *49BE609800C6_48CA5CB001A3_var*
 function CheckElement(Data: PObject; Index: Integer): Boolean;
 begin
  if (Tl3FrameLine(Data^).LineCoordinate = cWaitAlignMean) then
   Tl3FrameLine(Data^).CheckCoordinate(aMinBound, aMaxBound);
  Result := True;
 end;
//#UC END# *49BE609800C6_48CA5CB001A3_var*
//#UC START# *4AB1D0CF01E7_48CA5CB001A3_impl*
 f_PrevIndex := -1;
 if aClearAll then
  f_VBuffer := -1;
//#UC END# *4AB1D0CF01E7_48CA5CB001A3_impl*
//#UC START# *4AB1D0CF01E7_48CA5CB001A3_var*
//#UC END# *4AB1D0CF01E7_48CA5CB001A3_var*
//#UC START# *4AB8773101B3_48CA5CB001A3_impl*
 l_IL := Tl3InterfacedIntegerList.Create;
 try
  l_IL.Count := f_Values.Count;
  for i := 0 to f_Values.Count - 1 do
   l_IL[i] := f_Values[i].LineCoordinate;
  Result := l_IL; 
 finally
  FreeAndNil(l_IL);
 end;//try..finally
//#UC END# *4AB8773101B3_48CA5CB001A3_impl*
//#UC START# *4AB8773101B3_48CA5CB001A3_var*
var
 i: Integer;
 l_IL : Tl3InterfacedIntegerList;
//#UC END# *4AB8773101B3_48CA5CB001A3_var*
//#UC START# *4AB8775E017C_48CA5CB001A3_impl*
 for i := 0 to aData.Count - 1 do
  AddLine(aData[i], nil, False);
//#UC END# *4AB8775E017C_48CA5CB001A3_impl*
//#UC START# *4AB8775E017C_48CA5CB001A3_var*
var
 i       : Integer;
 l_Count : Integer;
//#UC END# *4AB8775E017C_48CA5CB001A3_var*
//#UC START# *4C18991501FE_48CA5CB001A3_impl*
 f_VBuffer := f_PrevIndex;
//#UC END# *4C18991501FE_48CA5CB001A3_impl*
//#UC START# *4C18991501FE_48CA5CB001A3_var*
//#UC END# *4C18991501FE_48CA5CB001A3_var*
//#UC START# *4C651ED702E4_48CA5CB001A3_impl*
 ClearPrev(True);
 f_Values.Clear;
//#UC END# *4C651ED702E4_48CA5CB001A3_impl*
//#UC START# *4C651ED702E4_48CA5CB001A3_var*
//#UC END# *4C651ED702E4_48CA5CB001A3_var*
//#UC START# *4D00BD46021B_48CA5CB001A3_impl*
 Result := f_Values;
//#UC END# *4D00BD46021B_48CA5CB001A3_impl*
//#UC START# *4D00BD46021B_48CA5CB001A3_var*
//#UC END# *4D00BD46021B_48CA5CB001A3_var*
