//#UC START# *47C7F168011D_48CE2103031C_impl*
 l_UpRight := aStart + aWidth;
 l_OffsetX := 0;
 Result := 0;
 IterateChildrenF(L2Mk2ChildrenIterateChildrenFAction(@SumWidth));
//#UC END# *47C7F168011D_48CE2103031C_impl*
//#UC START# *47C7F168011D_48CE2103031C_var*
var
 l_OffsetX : Integer;
 l_UpRight : Integer;

 function SumWidth(aTag: Tl3Variant; anIndex: Integer): Boolean;
 var
  l_Found      : Boolean;
  l_RightBound : Integer;
 begin
  l_RightBound := l_OffsetX + aTag.IntA[k2_tiWidth];
  if aWidth = 0 then
  begin
   Result := l_RightBound < aStart;
   if Result and aRight then
    Result := (l_RightBound - aStart) < -evEpsilon;
   if (evEqualOffset(l_RightBound, aStart) or not Result) and (anIndex > 0) then
    FindCell := anIndex;
  end // if aWidth = 0 then
  else
  begin
   Result := True;
   if aRight then
    l_Found := (evMoreOrEqualOffset(aStart, l_OffsetX) and evMoreOrEqualOffset(l_RightBound, l_UpRight)) or (evMoreOrEqualOffset(aStart, l_OffsetX) and evMoreOrEqualOffset(l_UpRight, l_RightBound))
   else
    l_Found := evMoreOrEqualOffset(l_OffsetX, aStart) and evMoreOrEqualOffset(l_UpRight, l_RightBound);
   if l_Found then
    FindCell := anIndex;
  end;
  l_OffsetX := l_RightBound;
 end;

//#UC END# *47C7F168011D_48CE2103031C_var*
//#UC START# *48CE2103031C_ext:FileName
w:\common\components\gui\Garant\Everest\new\nevTableRow.pas
//#UC END# *48CE2103031C_ext:FileName
//#UC START# *48CE2103031Cimpl_uses*
//#UC END# *48CE2103031Cimpl_uses*
//#UC START# *4C8DE3B00073_48CE2103031C_impl*
 l_Neighbour := TagInst.Child[aPID];
 if TevMergeStatus(l_Neighbour.IntA[k2_tiMergeStatus]) = ev_msHead then
 begin
  l_Neighbour.QT(InevTableCell, l_Cell);
  l_Cell := l_Cell.GetContinueCell(True, fc_Down);
  while l_Cell <> nil do
  begin
   l_NewCell := evCloneCell(anOp, aPara);
   l_PrevCell := l_Cell; // http://mdp.garant.ru/pages/viewpage.action?pageId=597332678. “олько одну строчку правильно исправл€ем. “.к. после вставки будут другие смещени€ у €чеек.
   l_Cell := l_Cell.GetContinueCell(True, fc_Down);
   l_PrevCell.AsObject.Owner.InsertChildTag(l_PrevCell.PID, l_NewCell.AsObject, anOp);
  end; // while l_Cell <> nil do
 end; // if TevMergeStatus(l_Neighbour.IntA[k2_tiMergeStatus]) = ev_msHead then
//#UC END# *4C8DE3B00073_48CE2103031C_impl*
//#UC START# *4C8DE3B00073_48CE2103031C_var*
var
 l_Cell      : InevTableCell;
 l_NewCell   : Il3TagRef;
 l_PrevCell  : InevTableCell;
 l_Neighbour : Tl3Variant;
//#UC END# *4C8DE3B00073_48CE2103031C_var*
//#UC START# *52B29B2E013C_48CE2103031C_impl*
 Result := inherited DoGetBackColor;
 if (Result = nevDefaultColor) then
 begin
  with OwnerPara.AsObject.Attr[k2_tiStyle].Attr[k2_tiFont] do
  begin
   if HasSubAtom(k2_tiBackColor) then
   begin
    l_HasMerged := False;
    Self.IterateChildrenF(L2Mk2ChildrenIterateChildrenFAction(@lp_CheckCell));
    if l_HasMerged then
     Result := GetPrev.BackColor
    else
     if not Odd(GetPID) then
     begin
      Result := IntA[k2_tiBackColor];
      if (Result = k2_TransparentValue) then
       Result := nevDefaultColor;
     end;//if not Odd(GetPID) then
   end;//HasSubAtom(k2_tiBackColor)
  end;//Attr[k2_tiStyle].Attr[k2_tiFont]
 end;//Result = nevDefaultColor  
//#UC END# *52B29B2E013C_48CE2103031C_impl*
//#UC START# *52B29B2E013C_48CE2103031C_var*
var
 l_HasMerged: Boolean;

 function lp_CheckCell(aCell: Tl3Variant; Index: LongInt): Boolean;
 begin
  Result := TevMergeStatus(aCell.IntA[k2_tiMergeStatus]) <> ev_msContinue;
  if not Result then
   l_HasMerged := True;
 end;

//#UC END# *52B29B2E013C_48CE2103031C_var*
