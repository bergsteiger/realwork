//#UC START# *48FD97BC0335_48FDC52D0006_impl*
 f_GetByVisibleIndexCounter := 0;
 f_OneLevel := False;
 inherited;
 RootNode := nil;
//#UC END# *48FD97BC0335_48FDC52D0006_impl*
//#UC START# *48FD97BC0335_48FDC52D0006_var*
//#UC END# *48FD97BC0335_48FDC52D0006_var*
//#UC START# *48FDA0CB01AD_48FDC52D0006_impl*
 Result := (f_GetByVisibleIndexCounter > 0);
//#UC END# *48FDA0CB01AD_48FDC52D0006_impl*
//#UC START# *48FDA0CB01AD_48FDC52D0006_var*
//#UC END# *48FDA0CB01AD_48FDC52D0006_var*
//#UC START# *48FDA0F500F9_48FDC52D0006_impl*
 if (RootNode <> nil) then
 begin
  if (not GetShowRoot)
  // http://mdp.garant.ru/pages/viewpage.action?pageId=316114353
  // http://mdp.garant.ru/pages/viewpage.action?pageId=316114353&focusedCommentId=328863929#comment-328863929
  and (aNodeIndex > 0)
  //
  then
   Result := aNodeIndex - 1
  else
   Result := aNodeIndex;
  if Assigned(f_CurrentNode) and
     (Result < f_CurrentNodeIndex) then
   //  орректируем индекс текущего элемента, если изменени€ дерева произошли "выше" него
   if (aDelta < 0) and
      (f_CurrentNodeIndex + aDelta <= Result) then
   begin
    f_CurrentNode := nil;
    f_CurrentNodeIndex := -1;
   end//aDelta < 0..
   else
    Inc(f_CurrentNodeIndex, aDelta);
 end//aNodeIndex = -1
 else
  Result := inherited DoChangeChildrenCount(aNodeIndex, aDelta);
//#UC END# *48FDA0F500F9_48FDC52D0006_impl*
//#UC START# *48FDA0F500F9_48FDC52D0006_var*
//#UC END# *48FDA0F500F9_48FDC52D0006_var*
//#UC START# *48FDA1F20208_48FDC52D0006_impl*
 inherited;
 f_CurrentNode := nil;
 f_CurrentNodeIndex := -1;
//#UC END# *48FDA1F20208_48FDC52D0006_impl*
//#UC START# *48FDA1F20208_48FDC52D0006_var*
//#UC END# *48FDA1F20208_48FDC52D0006_var*
//#UC START# *48FDC58F0218_48FDC52D0006_impl*
 Result := nil;
 GetByVisibleIndexStarted;
 try
  l_TmpCountViewChanged := CountViewChanged;
  try
   if (CurrentNode = nil) then
   begin
    l_Index := anIndex;
    if not GetShowRoot then
     Inc(l_Index);
    if (RootNode <> nil) then
    begin
     RootNode.GetByVisibleIndex(l_Index, Result);
     f_CurrentNode := Result;
     f_CurrentNodeIndex := anIndex;
    end;//RootNode <> nil
   end//CurrentNode = nil
   else
   begin

    if f_OneLevel then  // http://mdp.garant.ru/pages/viewpage.action?pageId=585938594
      CurrentNode.GetBySibblingIndex(anIndex - f_CurrentNodeIndex, Result)
    else
      CurrentNode.GetByVisibleIndex(anIndex - f_CurrentNodeIndex, Result);
    if not CountViewChanged then
    // ≈сли не измен€лось количество видимых элементов во врем€ получени€ текущего - то присваиваем Current
    begin
     f_CurrentNodeIndex := anIndex;
     f_CurrentNode := Result;
    end;//not CountViewChanged
    f_CountViewChanged := False;
   end;//CurrentNode = nil
  finally
   f_CountViewChanged := l_TmpCountViewChanged;
  end;//try..finally
 finally
  GetByVisibleIndexFinished;
 end;//try..finally
//#UC END# *48FDC58F0218_48FDC52D0006_impl*
//#UC START# *48FDC58F0218_48FDC52D0006_var*
var
 l_Index: Integer;
 l_TmpCountViewChanged: Boolean;
//#UC END# *48FDC58F0218_48FDC52D0006_var*
//#UC START# *48FDC5BC0004_48FDC52D0006get_impl*
 if (f_CurrentNode = nil) then
 begin
  if GetShowRoot then
   f_CurrentNode := RootNode
  else
  if (RootNode <> nil) then
   RootNode.GetFirstChild(f_CurrentNode);
  f_CurrentNodeIndex := 0;
 end;//f_CurrentNode = nil
 Result := f_CurrentNode;
//#UC END# *48FDC5BC0004_48FDC52D0006get_impl*
//#UC START# *48FDC5BC0004_48FDC52D0006get_var*
//#UC END# *48FDC5BC0004_48FDC52D0006get_var*
//#UC START# *48FDC5DE02CF_48FDC52D0006_impl*
 Inc(f_GetByVisibleIndexCounter);
//#UC END# *48FDC5DE02CF_48FDC52D0006_impl*
//#UC START# *48FDC5DE02CF_48FDC52D0006_var*
//#UC END# *48FDC5DE02CF_48FDC52D0006_var*
//#UC START# *48FDC5EE026F_48FDC52D0006_impl*
 if f_GetByVisibleIndexCounter > 0 then
  Dec(f_GetByVisibleIndexCounter)
 else
  Assert(f_GetByVisibleIndexCounter > 0, 'Ќепарный вызов GetByVisibleIndexStarted/Finished');
//#UC END# *48FDC5EE026F_48FDC52D0006_impl*
//#UC START# *48FDC5EE026F_48FDC52D0006_var*
//#UC END# *48FDC5EE026F_48FDC52D0006_var*
//#UC START# *48FDC60C0328_48FDC52D0006_impl*
 Result := -1;
 try
  if (CurrentNode = nil) then
  begin
   if (RootNode <> nil) then
   begin
    Result := RootNode.GetVisibleDelta(aNode);
    if not GetShowRoot then
     Dec(Result);
   end;
  end//CurrentNode = nil
  else
  begin
   l_CurrentNodeIndex := CurrentNodeIndex;
   l_Index := CurrentNode.GetVisibleDelta(aNode);
   Result := l_Index + l_CurrentNodeIndex;
   // - CurrentNodeIndex использовать нельз€, потому что
   //   CurrentNode.GetVisibleDelta(aNode) может вызвать перерисовку
   //   NodeNotifier.Invalidate и CurrentNodeIndex будет равен последнему
   //   отрисованному;
  end;//CurrentNode = nil
 except
  on ENotFound do ; // Ќоду не нашли (скорее всего она не видима€), вернем -1
 end;//try..except
//#UC END# *48FDC60C0328_48FDC52D0006_impl*
//#UC START# *48FDC60C0328_48FDC52D0006_var*
var
 l_Index            : Integer;
 l_CurrentNodeIndex : Integer;
//#UC END# *48FDC60C0328_48FDC52D0006_var*
//#UC START# *48FDC628027A_48FDC52D0006_impl*
 if (CurrentNode <> nil) and
    (CurrentNodeIndex = anIndex) then
 begin
  // - возвращаем то, что было запомнено
  Result := CurrentNode;
  Exit;
 end;//CurrentNode <> nil
 if (RootNode = nil) then
  Result := nil
 else
 begin
  if GetShowRoot and (anIndex = 0) then
   Result := RootNode;

  if (Result = nil) then
   Result := GetByVisibleIndex(anIndex);
 end;//RootNode = nil
// SetNewCurrentNode(Result, anIndex);
//#UC END# *48FDC628027A_48FDC52D0006_impl*
//#UC START# *48FDC628027A_48FDC52D0006_var*
//#UC END# *48FDC628027A_48FDC52D0006_var*
//#UC START# *48FDC63903E2_48FDC52D0006_impl*
 if (RootNode <> nil) then
 begin
  f_CurrentNode := nil;
  f_CurrentNodeIndex := 0;
 end//RootNode <> nil
 else
  DropCurrent;
//#UC END# *48FDC63903E2_48FDC52D0006_impl*
//#UC START# *48FDC63903E2_48FDC52D0006_var*
//#UC END# *48FDC63903E2_48FDC52D0006_var*
