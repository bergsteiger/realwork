//#UC START# *4912DBE30091_ext:FileName
w:\garant6x\implementation\Garant\GbaNemesis\Data\Tree\nsTreeUtils.pas
//#UC END# *4912DBE30091_ext:FileName
//#UC START# *4912DBE30091impl_uses*
//#UC END# *4912DBE30091impl_uses*
//#UC START# *4912DC1303B0_4912DBE30091_impl*
 Result := nil;
 if Supports(aTree.RootNode, INodeBase, l_Root) then
 try
  try
   l_NodeIndex := l_Root.GetVisibleDelta(aNode);
   if not aTree.ShowRoot then
    dec(l_NodeIndex);
  except
   on ENotFound do
    l_NodeIndex := -1; // Ничего не нашли, вернем -1
  end;{try..except}
  if l_NodeIndex >= 0 then
   Result := aTree.Nodes[l_NodeIndex] as INodeBase;
 finally
  l_Root := nil;
 end;{try..finally}
//#UC END# *4912DC1303B0_4912DBE30091_impl*
//#UC START# *4912DC1303B0_4912DBE30091_var*
var
 l_Root      : INodeBase;
 l_NodeIndex : Integer;
//#UC END# *4912DC1303B0_4912DBE30091_var*
//#UC START# *4912DC4002C5_4912DBE30091_impl*
 Result := False;
//
 l_eeNode := eeTreeView.CurrentNode;
 if (l_eeNode = nil) then
  Exit;
 if (not l_eeNode.HasChild) then
  Exit;
//
 l_Flags := eeTreeView.NodeFlags[l_eeNode];
 if ((l_Flags and nfExpanded) = 0) then
  l_Flags := (l_Flags or nfExpanded)
 else
  l_Flags := (l_Flags and not(nfExpanded));
 eeTreeView.NodeFlags[l_eeNode] := l_Flags;
//
 Result := True;
//#UC END# *4912DC4002C5_4912DBE30091_impl*
//#UC START# *4912DC4002C5_4912DBE30091_var*
var
 l_eeNode : IeeNode;
 l_Flags : Integer;
//#UC END# *4912DC4002C5_4912DBE30091_var*
//#UC START# *4912DC5203B4_4912DBE30091_impl*
 Result := aTree.IterateF(eeL2NA(@FindNode), imCheckResult);
//#UC END# *4912DC5203B4_4912DBE30091_impl*
//#UC START# *4912DC5203B4_4912DBE30091_var*

 function FindNode(const anIntf: IeeNode) : Boolean;
 var
  l_IterNode : INode;
 begin
  Result := Supports(anIntf, INode, l_IterNode) and
            aAdapterNode.IsSameNode(l_IterNode);
  l_IterNode := nil;
 end;

//#UC END# *4912DC5203B4_4912DBE30091_var*
//#UC START# *4912DC6803CB_4912DBE30091_impl*
  Result := aRoot.IterateF(eeL2NA(@FindNode), imCheckResult or imParentNeed);
//#UC END# *4912DC6803CB_4912DBE30091_impl*
//#UC START# *4912DC6803CB_4912DBE30091_var*

 function FindNode(const anIntf: IeeNode) : Boolean;
 var
  l_IterNode : INode;
 begin
  Result := Supports(anIntf, INode, l_IterNode) and
            aAdapterNode.IsSameNode(l_IterNode);
  l_IterNode := nil;
 end;

//#UC END# *4912DC6803CB_4912DBE30091_var*
//#UC START# *4912DC8500F0_4912DBE30091_impl*
 Result := aRoot.IterateF(l3L2NA(@FindNode), imCheckResult or imParentNeed);
//#UC END# *4912DC8500F0_4912DBE30091_impl*
//#UC START# *4912DC8500F0_4912DBE30091_var*

 function FindNode(const anIntf: Il3Node) : Boolean;
 var
  l_IterNode : INode;
 begin
  Result := Supports(anIntf, INode, l_IterNode) and
            aAdapterNode.IsSameNode(l_IterNode);
  l_IterNode := nil;
 end;

//#UC END# *4912DC8500F0_4912DBE30091_var*
//#UC START# *4912DC9B037B_4912DBE30091_impl*
 Result := aRoot.IterateF(l3L2NA(@FindNode), imCheckResult);
//#UC END# *4912DC9B037B_4912DBE30091_impl*
//#UC START# *4912DC9B037B_4912DBE30091_var*

 function FindNode(const anIntf: Il3Node) : Boolean;
 var
  l_Controllable : IControllable;
 begin
  if Supports(anIntf, IControllable, l_Controllable) then
   try
    Result := aControllable.IsSameControllable(l_Controllable);
   finally
    l_Controllable := nil;
   end//try..finally
  else
   Result := false;
 end;

//#UC END# *4912DC9B037B_4912DBE30091_var*
//#UC START# *4912DCC60049_4912DBE30091_impl*
 aTree.ClearSelected;
//#UC END# *4912DCC60049_4912DBE30091_impl*
//#UC START# *4912DCC60049_4912DBE30091_var*
//#UC END# *4912DCC60049_4912DBE30091_var*
//#UC START# *4CB2FE6701DB_4912DBE30091_impl*
 Result := aRoot.IterateF(eeL2NA(@FindNode), imCheckResult or imParentNeed);
//#UC END# *4CB2FE6701DB_4912DBE30091_impl*
//#UC START# *4CB2FE6701DB_4912DBE30091_var*
 function FindNode(const anIntf: IeeNode) : Boolean;
 var
  l_Filter : IFilterFromQuery;
 begin
  if Supports(anIntf, IFilterFromQuery, l_Filter) then
   try
    Result := aFilter.IsSame(l_Filter);
   finally
    l_Filter := nil;
   end//try..finally
  else
   Result := false;
 end;
//#UC END# *4CB2FE6701DB_4912DBE30091_var*
//#UC START# *4F991AC20207_4912DBE30091_impl*
 Result := aRoot.IterateF(l3L2NA(@FindNode), imCheckResult or imParentNeed);
//#UC END# *4F991AC20207_4912DBE30091_impl*
//#UC START# *4F991AC20207_4912DBE30091_var*
 function FindNode(const anIntf: Il3Node) : Boolean;
 var
  l_Filter : IFilterFromQuery;
 begin
  if Supports(anIntf, IFilterFromQuery, l_Filter) then
   try
    Result := aFilter.IsSame(l_Filter);
   finally
    l_Filter := nil;
   end//try..finally
  else
   Result := false;
 end;
//#UC END# *4F991AC20207_4912DBE30091_var*
