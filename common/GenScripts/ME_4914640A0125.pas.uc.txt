//#UC START# *49145C5D0015_4914640A0125_impl*
 if HasListNode then
 begin
  Result := nil;
  l_Current := DocInfo.ListNode;
  while lp_CanMove do
  begin
   if aPrev then
    l_Current.GetPrev(l_Node)
   else
    l_Current.GetNext(l_Node);
   try
    with DocInfo do
     Result := bsDocInfoMake(l_Node,
                             List,
                             Language,
                             ListRoot,
                             True,
                             CloneSearchInfo(List));
    // ѕрервем цикл документ дл€ узла получен:
    if Result <> nil then
     Break
    // ƒокумента нет, бывает когда документ открыт на экране, базу обновили и
    // следующий в списке уже отсутствует в базе (K<104434416>):
    else
     l_Current := l_Node;
   finally
    l_Node := nil;
   end;{try..finally}
  end;//while not DocInfo.ListNode.IsLast do
  if Result <> nil then
   TdmStdRes.OpenDocument(Result, nil);
 end//if HasListNode then
 else
   Result := nil;
//#UC END# *49145C5D0015_4914640A0125_impl*
//#UC START# *49145C5D0015_4914640A0125_var*
var
 l_Node    : INodeBase;
 l_Current : INodeBase;

 function lp_CanMove: Boolean;
 begin
  Result := (aPrev and not l_Current.IsFirst) or
            (not aPrev and not l_Current.IsLast);
 end;

//#UC END# *49145C5D0015_4914640A0125_var*
//#UC START# *49145C6E00F8_4914640A0125_impl*
 with DocInfo do
  if List <> nil then
  begin
   l_List := bsListClone(List);
   if l_List <> nil then
   try
    l_List.GetRoot(l_RootNode);
    try
     l_RootNode.SetAllFlag(FM_SELECTION, False);
     l_RootNode.SetAllFlag(FM_OPEN, False);
     DoReturnToList(l_List, lp_MakeNewNode);
    finally
     l_RootNode := nil;
    end;//try..finally
   finally
    l_List := nil;
   end;//try..finally
  end//if HasListNode then
//#UC END# *49145C6E00F8_4914640A0125_impl*
//#UC START# *49145C6E00F8_4914640A0125_var*
var
 l_List     : IDynList;
 l_RootNode : INodeBase;

 function lp_MakeNewNode: Il3SimpleNode;
 var
  l_NewNode: INodeBase;
 begin
  with DocInfo do
   if ListNode <> nil then
   begin
    l_RootNode.FindNode(ListNode, l_NewNode);
    Result := TnsINodeWrap.Make(l_NewNode);
   end//if ListNode <> nil then
   else
    Result := nil;
 end;//lp_MakeNewNode

//#UC END# *49145C6E00F8_4914640A0125_var*
//#UC START# *49145C7C0021_4914640A0125get_impl*
 Result := HasListNode and not DocInfo.ListNode.IsFirst;
//#UC END# *49145C7C0021_4914640A0125get_impl*
//#UC START# *49145C7C0021_4914640A0125get_var*
//#UC END# *49145C7C0021_4914640A0125get_var*
//#UC START# *49145C86028D_4914640A0125get_impl*
 Result := HasListNode and not DocInfo.ListNode.IsLast;
//#UC END# *49145C86028D_4914640A0125get_impl*
//#UC START# *49145C86028D_4914640A0125get_var*
//#UC END# *49145C86028D_4914640A0125get_var*
//#UC START# *49145C940250_4914640A0125get_impl*
 Result := DocInfo.List <> nil;
//#UC END# *49145C940250_4914640A0125get_impl*
//#UC START# *49145C940250_4914640A0125get_var*
//#UC END# *49145C940250_4914640A0125get_var*
//#UC START# *4914640A0125_ext:FileName
w:\garant6x\implementation\Garant\GbaNemesis\Business\Document\dsDocumentFromList.imp.pas
//#UC END# *4914640A0125_ext:FileName
//#UC START# *491466040150_4914640A0125get_impl*
 Result := Assigned(DocInfo) and Assigned(DocInfo.ListNode);
//#UC END# *491466040150_4914640A0125get_impl*
//#UC START# *491466040150_4914640A0125get_var*
//#UC END# *491466040150_4914640A0125get_var*
//#UC START# *4914664B019A_4914640A0125_impl*
 if Assigned(DocInfo.SearchInfo) then
  with DocInfo.SearchInfo do
   Result := TdeSearchInfo.Make(aList, NeedApplyPermanentFilters)
 else
  Result := TdeSearchInfo.Make(aList, False);
//#UC END# *4914664B019A_4914640A0125_impl*
//#UC START# *4914664B019A_4914640A0125_var*
//#UC END# *4914664B019A_4914640A0125_var*
