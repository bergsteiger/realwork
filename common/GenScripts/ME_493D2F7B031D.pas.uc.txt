//#UC START# *01DBA41F4474_493D2F7B031Dget_impl*
 Result := False;
 if pm_GetHasDocument and not l3BoolCheck(SetData.HasTranslation, Result) then
 begin
  Result := l3BoolSet(pm_GetDocInfo.Doc.HasTranslation, l_Temp);
  SetData.HasTranslation := l_Temp;
 end;
//#UC END# *01DBA41F4474_493D2F7B031Dget_impl*
//#UC START# *01DBA41F4474_493D2F7B031Dget_var*
var
 l_Temp: Tl3Bool;
//#UC END# *01DBA41F4474_493D2F7B031Dget_var*
//#UC START# *10E3D328A415_493D2F7B031Dget_impl*
 Result := TruthHasSimilarDocuments;
//#UC END# *10E3D328A415_493D2F7B031Dget_impl*
//#UC START# *10E3D328A415_493D2F7B031Dget_var*
//#UC END# *10E3D328A415_493D2F7B031Dget_var*
//#UC START# *3690DB82E835_493D2F7B031Dget_impl*
 Result := TruthHasRelatedDoc;
//#UC END# *3690DB82E835_493D2F7B031Dget_impl*
//#UC START# *3690DB82E835_493D2F7B031Dget_var*
//#UC END# *3690DB82E835_493D2F7B031Dget_var*
//#UC START# *479731C50290_493D2F7B031D_impl*
 ResetCachedObject(false);
 SetData.ResetBooleans;
 inherited;
//#UC END# *479731C50290_493D2F7B031D_impl*
//#UC START# *479731C50290_493D2F7B031D_var*
//#UC END# *479731C50290_493D2F7B031D_var*
//#UC START# *47A042E100E2_493D2F7B031D_impl*
 inherited;
 SetData.ResetBooleans;
 SetData.CorrType := TbsCRTypeFrozen.Make;
 SetData.RespType := TbsCRTypeFrozen.Make;
//#UC END# *47A042E100E2_493D2F7B031D_impl*
//#UC START# *47A042E100E2_493D2F7B031D_var*
//#UC END# *47A042E100E2_493D2F7B031D_var*
//#UC START# *47EA4E9002C6_493D2F7B031D_impl*
 inherited;
 ResetCacheAfterUpdate; // http://mdp.garant.ru/pages/viewpage.action?pageId=323060346 
 if pm_GetDocInfo <> nil then
  pm_GetDocInfo.ClearListNode;
  // - отключаем переход по предыдущему\сдедующему (K<104434416>).
  //
  //   В самом TdeDocInfo подписываться на уведомления о переключении базы и
  //   обнулять ListNode нельзя, т.к. когда уведомление получит БОС то
  //   произойдет Refresh, в котором клонируют TdeDocInfo (передадут ListNode),
  //   а старый освободят и до уведомления TdeDocInfo дело не дойдет.
  //
  //   Можно было дописать логику уведомления об обновлении, если подписывается
  //   новый слушатель и при этом идет процесс уведомления, то уведомлять
  //   слушателя, но я не уверен, что правильно посылать такое сообщение вновь
  //   созданным объектам.
  //
  //   Морозов. М.А.
  ////////////////////////////////////////////////////////////////////////////// 
//#UC END# *47EA4E9002C6_493D2F7B031D_impl*
//#UC START# *47EA4E9002C6_493D2F7B031D_var*
//#UC END# *47EA4E9002C6_493D2F7B031D_var*
//#UC START# *47EA8B9601FE_493D2F7B031D_impl*
 inherited;
 ConfigurationChanged;
//#UC END# *47EA8B9601FE_493D2F7B031D_impl*
//#UC START# *47EA8B9601FE_493D2F7B031D_var*
//#UC END# *47EA8B9601FE_493D2F7B031D_var*
//#UC START# *4925B7F00156_493D2F7B031D_impl*
 inherited;
 with SetData do
 begin
  dsRespondentsRef.Referred := nil;
  dsCorrespondentsRef.Referred := nil;
  dsRelatedDocRef.Referred := nil;
  dsAnnotationRef.Referred := nil;
  dsSimilarDocumentsRef.Referred := nil;
  dsDocumentWithFlashRef.Referred := nil;

  pm_GetdsTranslationRef.Referred := nil;
  pm_GetdsUserCR1Ref.Referred := nil;
  pm_GetdsUserCR2Ref.Referred := nil;
 end;
//#UC END# *4925B7F00156_493D2F7B031D_impl*
//#UC START# *4925B7F00156_493D2F7B031D_var*
//#UC END# *4925B7F00156_493D2F7B031D_var*
//#UC START# *4925B9370022_493D2F7B031D_impl*
 if not (pm_GetDocInfo <> nil) or not Assigned(aDoc) or
   (not aDoc.Doc.IsSameView(pm_GetDocInfo.Doc) or
   not aDoc.Pos.EQ(pm_GetDocInfo.Pos)) then
 begin
  SetData.DocInfo := aDoc;
  ResetCachedObject(false);
  SetData.ResetBooleans;
  Result := True;
 end
 else
  Result := False;
 FillState;
//#UC END# *4925B9370022_493D2F7B031D_impl*
//#UC START# *4925B9370022_493D2F7B031D_var*
//#UC END# *4925B9370022_493D2F7B031D_var*
//#UC START# *4937C4D90220_493D2F7B031D_impl*
 if SetData.dsCorrespondentsRef.IsEmpty then
 begin
  SetData.dsCorrespondentsRef.NeedMake := vcm_nmForce;
  Refresh;
 end;//if SetData.refCorrespondents.IsEmpty then
//#UC END# *4937C4D90220_493D2F7B031D_impl*
//#UC START# *4937C4D90220_493D2F7B031D_var*
//#UC END# *4937C4D90220_493D2F7B031D_var*
//#UC START# *4937C4E701F3_493D2F7B031D_impl*
 if SetData.dsRespondentsRef.IsEmpty then
 begin
  SetData.dsRespondentsRef.NeedMake := vcm_nmForce;
  Refresh;
 end;//if SetData.refRespondents.IsEmpty then
//#UC END# *4937C4E701F3_493D2F7B031D_impl*
//#UC START# *4937C4E701F3_493D2F7B031D_var*
//#UC END# *4937C4E701F3_493D2F7B031D_var*
//#UC START# *4937C4F5038B_493D2F7B031D_impl*
 Result := DoChangeCRType(aNode, aType, IsCRToPart);
//#UC END# *4937C4F5038B_493D2F7B031D_impl*
//#UC START# *4937C4F5038B_493D2F7B031D_var*
//#UC END# *4937C4F5038B_493D2F7B031D_var*
//#UC START# *4937C5250138_493D2F7B031D_impl*
 if (pm_GetDocInfo <> nil) then
 begin
  TvcmModulesFactories.AddDocumentToControl(pm_GetDocInfo.Doc);
  SetData.IsUnderControl := l3_bUnknown;
 end;
//#UC END# *4937C5250138_493D2F7B031D_impl*
//#UC START# *4937C5250138_493D2F7B031D_var*
//#UC END# *4937C5250138_493D2F7B031D_var*
//#UC START# *4937C55101B2_493D2F7B031D_impl*
 if (pm_GetDocInfo <> nil) then
 begin
  TvcmModulesFactories.DeleteDocumentFromControl(pm_GetDocInfo.Doc);
  SetData.IsUnderControl := l3_bUnknown;
 end;
//#UC END# *4937C55101B2_493D2F7B031D_impl*
//#UC START# *4937C55101B2_493D2F7B031D_var*
//#UC END# *4937C55101B2_493D2F7B031D_var*
//#UC START# *4937C56002B6_493D2F7B031D_impl*
 SetData.ResetBooleans;
 ResetCachedObject(True);
//#UC END# *4937C56002B6_493D2F7B031D_impl*
//#UC START# *4937C56002B6_493D2F7B031D_var*
//#UC END# *4937C56002B6_493D2F7B031D_var*
//#UC START# *4937C58D008D_493D2F7B031D_impl*
 with SetData.UserCRListInfo[aSheetNumber] do
  Result := (ListType <> crtNone) and bsIsCRNodeAreNotAllDocuments(Node);
//#UC END# *4937C58D008D_493D2F7B031D_impl*
//#UC START# *4937C58D008D_493D2F7B031D_var*
//#UC END# *4937C58D008D_493D2F7B031D_var*
//#UC START# *4937C5A5024F_493D2F7B031D_impl*
 Result := false;
 with SetData.UserCRListInfo[aSheetNumber] do
  if pm_GetHasDocument and (Node <> nil) then
   case ListType of
    crtRespondents:
     Result := pm_GetDocInfo.Doc.HasRespondents(Node.Value);
    crtCorrespondents:
     Result := pm_GetDocInfo.Doc.HasCorrespondents(Node.Value);
   end;//case SetData.UserCRSheetTypes[aSheetNumber] of
//#UC END# *4937C5A5024F_493D2F7B031D_impl*
//#UC START# *4937C5A5024F_493D2F7B031D_var*
//#UC END# *4937C5A5024F_493D2F7B031D_var*
//#UC START# *4937C61C0270_493D2F7B031Dget_impl*
 Result := False;
 if (pm_GetDocInfo <> nil) and
    not l3BoolCheck(SetData.IsUnderControl, Result) then
 begin
  Result := l3BoolSet(TvcmModulesFactories.IsUnderControl(pm_GetDocInfo.Doc), l_Temp);
  SetData.IsUnderControl := l_Temp;
 end;
//#UC END# *4937C61C0270_493D2F7B031Dget_impl*
//#UC START# *4937C61C0270_493D2F7B031Dget_var*
var
 l_Temp: Tl3Bool;
//#UC END# *4937C61C0270_493D2F7B031Dget_var*
//#UC START# *4937D0FF0303_493D2F7B031Dget_impl*
 Result := SetData.UserCRListInfo[aId];
//#UC END# *4937D0FF0303_493D2F7B031Dget_impl*
//#UC START# *4937D0FF0303_493D2F7B031Dget_var*
//#UC END# *4937D0FF0303_493D2F7B031Dget_var*
//#UC START# *4939534D01FB_493D2F7B031Dget_impl*
 if SetData.FlashData = nil then
 begin
  if pm_GetHasDocument then
  begin
   try
    pm_GetDocInfo.Doc.GetFlash(Result);
    SetData.FlashData := Result;
   except
    on ECanNotFindData do
     ;
   end;
  end
  else
   Result := nil;
 end
 else
  Result := SetData.FlashData;
//#UC END# *4939534D01FB_493D2F7B031Dget_impl*
//#UC START# *4939534D01FB_493D2F7B031Dget_var*
//#UC END# *4939534D01FB_493D2F7B031Dget_var*
//#UC START# *493D51B00058_493D2F7B031D_impl*
 Result := SetData.UserCRListInfo[ulFirst].Has;
//#UC END# *493D51B00058_493D2F7B031D_impl*
//#UC START# *493D51B00058_493D2F7B031D_var*
//#UC END# *493D51B00058_493D2F7B031D_var*
//#UC START# *493D51BE03DC_493D2F7B031D_impl*
 Result := SetData.UserCRListInfo[ulSecond].Has;
//#UC END# *493D51BE03DC_493D2F7B031D_impl*
//#UC START# *493D51BE03DC_493D2F7B031D_var*
//#UC END# *493D51BE03DC_493D2F7B031D_var*
//#UC START# *493D51D0039B_493D2F7B031D_impl*
 Result := pm_GetHasCorrespondents;
//#UC END# *493D51D0039B_493D2F7B031D_impl*
//#UC START# *493D51D0039B_493D2F7B031D_var*
//#UC END# *493D51D0039B_493D2F7B031D_var*
//#UC START# *493D51DF022F_493D2F7B031D_impl*
 Result := pm_GetHasRespondents;
//#UC END# *493D51DF022F_493D2F7B031D_impl*
//#UC START# *493D51DF022F_493D2F7B031D_var*
//#UC END# *493D51DF022F_493D2F7B031D_var*
//#UC START# *493D51ED0329_493D2F7B031D_impl*
 inherited;
 if not afw.Settings.LoadBoolean(pi_Document_Sheets_Translation,
   dv_Document_Sheets_Translation) then
  SetData.dsTranslationRef.Clear;
 // Первый пользовательский список КР:
 lp_InitUserCRList(ulFirst);
 // Второй список КР:
 lp_InitUserCRList(ulSecond);
 // Если в качестве пользовательского СР выбраны "Все документы", то открывается
 // обычный СКР, который можно типизировать:
 lpCRNeedMake(pm_GetDsRespondentsRef, crtRespondents);
 lpCRNeedMake(pm_GetDsCorrespondentsRef, crtCorrespondents);
//#UC END# *493D51ED0329_493D2F7B031D_impl*
//#UC START# *493D51ED0329_493D2F7B031D_var*

  procedure lpCRNeedMake(const aDSRef : IvcmFormDataSourceRef;
                         const aType  : TlstCRType);
  var
   l_List             : TnsUserCRListId;
   l_IsFullCRSelected : Boolean;
  begin
   with aDSRef do
   begin
    l_IsFullCRSelected := IsOrdinalCRSelected(aType, l_List);
    // Отметим, что вместо пользовательской вкладки показывается полный СКР:
    if l_IsFullCRSelected then
     SetData.UserCRListInfo[l_List].wKindOfList := bs_ulFullCR;
    // Откроем нормальную СКР вместо пользовательской
    if (NeedMake = vcm_nmNo) and l_IsFullCRSelected then
    begin
     NeedMake := StateIfNeedShowFullCRList;
     // Закроем пользовательскую вкладку
     case l_List of
      ulFirst:
       SetData.dsUserCR1Ref.Referred := nil;
      ulSecond:
       SetData.dsUserCR2Ref.Referred := nil;
     end;//case l_List of
    end//if (NeedMake = vcm_nmNo) ...
    else
     // Закроем форму СКР потому, что она была открыта по причине установки
     // пользовательской вкладки в настройках с типом "Все документы", а теперь
     // пользователь установил другой тип
     if (NeedMake = StateIfNeedShowFullCRList) and not l_IsFullCRSelected then
      aDSRef.Clear;
   end;//with aDSRef do
  end;//lpCRNeedMake

  procedure lp_InitUserCRList(const aValue: TnsUserCRListId);
  var
   l_Temp: IbsUserCRListInfoModify;

   function lp_IsUserCRListChanged: Boolean;
   begin
    l_Temp.Assign(SetData.UserCRListInfo[aValue]);
     // - скопируем, чтобы позднее сравнить изменились ли параметры
     //   пользовательской вкладки:
    with SetData.UserCRListInfo[aValue] do
    begin
     wListType := bsUserCRList(aValue);
     wNode := bsUserCRNode(aValue);
     wHas := IsTypedCRSelected(aValue) and (ListType <> crtNone) and
      HasTypedCRinBigBase(aValue);
     wKindOfList := bs_ulUserCR;
    end;//with SetData.UserCRListInfo[ulSecond] do
    Result := not l_Temp.IsSame(SetData.UserCRListInfo[aValue]);
     // - проверим изменились ли данные;
   end;//lp_ReadSettings

   procedure lp_UpdateDSUserCRList;
   begin
    // Инициируем переполучение бизнес объекта для вкладки:
    with SetData do
     case aValue of
      ulFirst:
       dsUserCR1Ref.Clear;
      ulSecond:
       dsUserCR2Ref.Clear;
      else
       Assert(False);
     end;//case aValue of
   end;//lp_UpdateDSUserCRList

  begin
   l_Temp := TbsUserCRListInfo.Make;
   try
    // Проверим изменились ли параметры:
    if lp_IsUserCRListChanged then
     // Инициируем переполучение бизнес объктов:
     lp_UpdateDSUserCRList;
   finally
    l_Temp := nil;
   end;//try..finally
  end;//lp_InitUserCRList

//#UC END# *493D51ED0329_493D2F7B031D_var*
//#UC START# *493D521E0135_493D2F7B031D_impl*
 Result := vcm_nmYes;
//#UC END# *493D521E0135_493D2F7B031D_impl*
//#UC START# *493D521E0135_493D2F7B031D_var*
//#UC END# *493D521E0135_493D2F7B031D_var*
//#UC START# *493D524802C9_493D2F7B031D_impl*
 Result := False;
 if not SetData.CorrType.HasNode or not SetData.CorrType.Value.IsSameNode(aValue) then
 begin
  SetData.CorrType.Value := aValue;
  SetData.HasCorrespondents := l3_bUnknown;
  SetData.CorrList := nil;
  SetData.dsCorrespondentsRef.Referred := nil;
  Result := True;
 end
 else//if not Assigned(SetData.CorrType)
  Result := SetData.CorrList = nil;
//#UC END# *493D524802C9_493D2F7B031D_impl*
//#UC START# *493D524802C9_493D2F7B031D_var*
//#UC END# *493D524802C9_493D2F7B031D_var*
//#UC START# *493D525B007D_493D2F7B031D_impl*
 Result := False;
 if not SetData.RespType.HasNode or not SetData.RespType.Value.IsSameNode(aValue) then
 begin
  SetData.RespType.Value := aValue;
  SetData.HasRespondents := l3_bUnknown;
  SetData.RespList := nil;
  SetData.dsRespondentsRef.Referred := nil;
  Result := True;
 end
 else//if not Assigned(SetData.RespType)
  Result := SetData.RespList = nil;
//#UC END# *493D525B007D_493D2F7B031D_impl*
//#UC START# *493D525B007D_493D2F7B031D_var*
//#UC END# *493D525B007D_493D2F7B031D_var*
//#UC START# *493D5BB40051_493D2F7B031D_impl*
 for I := Low(TnsUserCRListId) to High(TnsUserCRListId) do
 begin
  with SetData.UserCRListInfo[I] do
   Result := (ListType = aCRType) and not bsIsCRNodeAreNotAllDocuments(Node);
  if Result then
  begin
   aId := I;
   Break;
  end;//if Result then
 end;//for I := Low(TnsUserCRListId) to
//#UC END# *493D5BB40051_493D2F7B031D_impl*
//#UC START# *493D5BB40051_493D2F7B031D_var*
var
 I: TnsUserCRListId;
//#UC END# *493D5BB40051_493D2F7B031D_var*
//#UC START# *493D5E9700AE_493D2F7B031D_impl*
 with SetData do
 begin
  if not aWithoutCRTypes then
  begin
   if (CorrType <> nil) then
    CorrType.Value := nil;
   if (RespType <> nil) then
    RespType.Value := nil;
  end;
  CorrList := nil;
  RespList := nil;
  //RelatedDoc := nil;
  //Annotation := nil;
  FlashData := nil;
 end;//with SetData do
//#UC END# *493D5E9700AE_493D2F7B031D_impl*
//#UC START# *493D5E9700AE_493D2F7B031D_var*
//#UC END# *493D5E9700AE_493D2F7B031D_var*
//#UC START# *493D5FA703E6_493D2F7B031D_impl*
 Result := False;
 if pm_GetHasDocument and
  not l3BoolCheck(SetData.HasSimilarDocuments, Result) then
 begin
  Result := l3BoolSet(pm_GetDocInfo.Doc.HasSameDocuments, l_Temp);
  SetData.HasSimilarDocuments := l_Temp;
 end;
//#UC END# *493D5FA703E6_493D2F7B031D_impl*
//#UC START# *493D5FA703E6_493D2F7B031D_var*
var
 l_Temp: Tl3Bool;
//#UC END# *493D5FA703E6_493D2F7B031D_var*
//#UC START# *493D5FC202B1_493D2F7B031D_impl*
 Result := False;
 if pm_GetHasDocument and not l3BoolCheck(SetData.HasRelatedDoc, Result) then
 begin
  Result := l3BoolSet(pm_GetDocInfo.Doc.HasRelatedDoc, l_Temp);
  SetData.HasRelatedDoc := l_Temp;
 end;//if pm_GetHasDocument..
//#UC END# *493D5FC202B1_493D2F7B031D_impl*
//#UC START# *493D5FC202B1_493D2F7B031D_var*
var
 l_Temp: Tl3Bool;
//#UC END# *493D5FC202B1_493D2F7B031D_var*
//#UC START# *493D5FD70278_493D2F7B031D_impl*
 Result := False;
 if pm_GetHasDocument and not l3BoolCheck(SetData.HasAnnotation, Result) then
 begin
  Result := l3BoolSet(pm_GetDocInfo.Doc.HasAnnotation, l_Temp);
  SetData.HasAnnotation := l_Temp;
 end;
//#UC END# *493D5FD70278_493D2F7B031D_impl*
//#UC START# *493D5FD70278_493D2F7B031D_var*
var
 l_Temp: Tl3Bool;
//#UC END# *493D5FD70278_493D2F7B031D_var*
//#UC START# *493D60320164_493D2F7B031D_impl*
 Result := nil;
 try
  with SetData.UserCRListInfo[aId] do
   if pm_GetHasDocument and Assigned(Node) then
    case ListType of
     crtRespondents:
      pm_GetDocInfo.Doc.GetRespondents(Node.Value, l_Catalog);
     crtCorrespondents:
      pm_GetDocInfo.Doc.GetCorrespondents(Node.Value, l_Catalog);
    end;//case ListType of
 except
  on ECanNotFindData do
   l_Catalog := nil;
 end;//try..except
 Supports(l_Catalog, IDynList, l_List);
 with SetData.UserCRListInfo[aId] do
  Result := TdeDocumentListCR.Make(l_List, Node.Value, ListType);
//#UC END# *493D60320164_493D2F7B031D_impl*
//#UC START# *493D60320164_493D2F7B031D_var*
var
 l_List    : IDynList;
 l_Catalog : ICatalogBase;
//#UC END# *493D60320164_493D2F7B031D_var*
//#UC START# *493D606D0189_493D2F7B031D_impl*
 FillState;
 Refresh;
//#UC END# *493D606D0189_493D2F7B031D_impl*
//#UC START# *493D606D0189_493D2F7B031D_var*
//#UC END# *493D606D0189_493D2F7B031D_var*
//#UC START# *493D62FF02AF_493D2F7B031D_impl*
 Result := pm_GetHasDocument and (pm_GetDocInfo.Doc.GetDocType = DT_FLASH);
//#UC END# *493D62FF02AF_493D2F7B031D_impl*
//#UC START# *493D62FF02AF_493D2F7B031D_var*
//#UC END# *493D62FF02AF_493D2F7B031D_var*
//#UC START# *493D6B5B02DE_493D2F7B031D_impl*
 Result := False;
 if not IsCRToPart then
  case aType of
   crtCorrespondents:
    Result := ChangeCorrType(aNode);
   crtRespondents:
    Result := ChangeRespType(aNode);
  end
 else
  Assert(not IsCRToPart, caRespCorrestUnsupported);
//#UC END# *493D6B5B02DE_493D2F7B031D_impl*
//#UC START# *493D6B5B02DE_493D2F7B031D_var*
//#UC END# *493D6B5B02DE_493D2F7B031D_var*
//#UC START# *493D6E7E0282_493D2F7B031D_impl*
 Result := pm_GetHasRelatedDoc;
//#UC END# *493D6E7E0282_493D2F7B031D_impl*
//#UC START# *493D6E7E0282_493D2F7B031D_var*
//#UC END# *493D6E7E0282_493D2F7B031D_var*
//#UC START# *493D6EAB0019_493D2F7B031D_impl*
 Result := pm_GetHasAnnotation;
//#UC END# *493D6EAB0019_493D2F7B031D_impl*
//#UC START# *493D6EAB0019_493D2F7B031D_var*
//#UC END# *493D6EAB0019_493D2F7B031D_var*
//#UC START# *493D6EC40228_493D2F7B031D_impl*
 Result := pm_GetHasSimilarDocuments;
//#UC END# *493D6EC40228_493D2F7B031D_impl*
//#UC START# *493D6EC40228_493D2F7B031D_var*
//#UC END# *493D6EC40228_493D2F7B031D_var*
//#UC START# *4946533D0039_493D2F7B031D_impl*
 if (pm_GetDocInfo <> nil) and not Assigned(SetData.RespList) then
  try
   pm_GetDocInfo.Doc.GetRespondents(SetData.RespType.Value, l_Catalog);
   if Supports(l_Catalog, IDynList, l_Temp) then
   SetData.RespList := l_Temp;
  except
   on ECanNotFindData do
    SetData.RespList := nil;
  end;
 Result := SetData.RespList;
//#UC END# *4946533D0039_493D2F7B031D_impl*
//#UC START# *4946533D0039_493D2F7B031D_var*
var
 l_Temp: IDynList;
 l_Catalog: ICatalogBase;
//#UC END# *4946533D0039_493D2F7B031D_var*
//#UC START# *4946539A0021_493D2F7B031D_impl*
 if (pm_GetDocInfo <> nil) and not Assigned(SetData.CorrList) then
  try
   pm_GetDocInfo.Doc.GetCorrespondents(SetData.CorrType.Value, l_Catalog);
   if Supports(l_Catalog, IDynList, l_Temp) then
    SetData.CorrList := l_Temp;
  except
   on ECanNotFindData do
    SetData.CorrList := nil;
  end;
 Result := SetData.CorrList;
//#UC END# *4946539A0021_493D2F7B031D_impl*
//#UC START# *4946539A0021_493D2F7B031D_var*
var
 l_Temp: IDynList;
 l_Catalog: ICatalogBase;
//#UC END# *4946539A0021_493D2F7B031D_var*
//#UC START# *4958BE910345_493D2F7B031D_impl*
 inherited;
 ConfigurationChanged;
//#UC END# *4958BE910345_493D2F7B031D_impl*
//#UC START# *4958BE910345_493D2F7B031D_var*
//#UC END# *4958BE910345_493D2F7B031D_var*
//#UC START# *5009A673037A_493D2F7B031Darea_impl*
 if Supports(SetData.DocInfo, IbsDocumentContainer, l_Container) then
  try
   Result := TdsRelatedDoc.Make(Self, TdeDocInfo.Make(
    TbsNestedDocumentContainer.Make(l_Container, ndtRelatedDoc, TruthHasRelatedDoc)));
  finally
   l_Container := nil;
  end//try..finally
 else
  Result := nil;
//#UC END# *5009A673037A_493D2F7B031Darea_impl*
//#UC START# *5009A673037A_493D2F7B031Darea_var*
var
 l_Container : IbsDocumentContainer;
//#UC END# *5009A673037A_493D2F7B031Darea_var*
//#UC START# *5009A673037A_493D2F7B031Dget_need*
     and (NeedMake <> vcm_nmNo)
     and NeedMakeRelatedDoc
   // - условие создания ViewArea
//#UC END# *5009A673037A_493D2F7B031Dget_need*
//#UC START# *5009A673037A_493D2F7B031Dget_var*
//#UC END# *5009A673037A_493D2F7B031Dget_var*
//#UC START# *5009A699023D_493D2F7B031Darea_impl*
 Result := TdsDocumentListCR.Make(Self, TdeDocumentListCR.Make(GetOrMakeRespList,
  SetData.RespType.Value, crtRespondents));
//#UC END# *5009A699023D_493D2F7B031Darea_impl*
//#UC START# *5009A699023D_493D2F7B031Darea_var*
//#UC END# *5009A699023D_493D2F7B031Darea_var*
//#UC START# *5009A699023D_493D2F7B031Dget_need*
     AND (NeedMake <> vcm_nmNo)
     AND NeedMakeDSRespondents
     AND CheckList   
   // - условие создания ViewArea
//#UC END# *5009A699023D_493D2F7B031Dget_need*
//#UC START# *5009A699023D_493D2F7B031Dget_var*

 function CheckList: Boolean;
  // Обнулим, потому, что пользователь мог удалить из списка документы,
  // потом закрыть вкладку, потом открыть вновь, то мы должны показать ему
  // полный список
 begin
  Result := true;
  if bsIsListChanged(GetOrMakeRespList) then
   SetData.RespList := nil;
 end;

//#UC END# *5009A699023D_493D2F7B031Dget_var*
//#UC START# *5009A6BE01DD_493D2F7B031Darea_impl*
 Result := TdsDocumentListCR.Make(Self, TdeDocumentListCR.Make(GetOrMakeCorrList,
  SetData.CorrType.Value, crtCorrespondents));
//#UC END# *5009A6BE01DD_493D2F7B031Darea_impl*
//#UC START# *5009A6BE01DD_493D2F7B031Darea_var*
//#UC END# *5009A6BE01DD_493D2F7B031Darea_var*
//#UC START# *5009A6BE01DD_493D2F7B031Dget_need*
     AND (NeedMake <> vcm_nmNo)
     AND NeedMakeDSCorrespondents
     AND CheckList   
   // - условие создания ViewArea
//#UC END# *5009A6BE01DD_493D2F7B031Dget_need*
//#UC START# *5009A6BE01DD_493D2F7B031Dget_var*

 function CheckList: Boolean;
  // Обнулим, потому, что пользователь мог удалить из списка документы,
  // потом закрыть вкладку, потом открыть вновь, то мы должны показать ему
  // полный список
 begin
  Result := true;
  if bsIsListChanged(GetOrMakeCorrList) then
   SetData.CorrList := nil;
 end;

//#UC END# *5009A6BE01DD_493D2F7B031Dget_var*
//#UC START# *5009A6EF0016_493D2F7B031Darea_impl*
 Result := TdsDocumentListCR.Make(Self, GetTypedCR(ulFirst)); 
//#UC END# *5009A6EF0016_493D2F7B031Darea_impl*
//#UC START# *5009A6EF0016_493D2F7B031Darea_var*
//#UC END# *5009A6EF0016_493D2F7B031Darea_var*
//#UC START# *5009A6EF0016_493D2F7B031Dget_need*
     AND NeedMakeDSUserCRList1   
   // - условие создания ViewArea
//#UC END# *5009A6EF0016_493D2F7B031Dget_need*
//#UC START# *5009A6EF0016_493D2F7B031Dget_var*
//#UC END# *5009A6EF0016_493D2F7B031Dget_var*
//#UC START# *5009A72B01A5_493D2F7B031Darea_impl*
 Result := TdsDocumentListCR.Make(Self, GetTypedCR(ulSecond));
//#UC END# *5009A72B01A5_493D2F7B031Darea_impl*
//#UC START# *5009A72B01A5_493D2F7B031Darea_var*
//#UC END# *5009A72B01A5_493D2F7B031Darea_var*
//#UC START# *5009A72B01A5_493D2F7B031Dget_need*
     AND NeedMakeDSUserCRList2   
   // - условие создания ViewArea
//#UC END# *5009A72B01A5_493D2F7B031Dget_need*
//#UC START# *5009A72B01A5_493D2F7B031Dget_var*
//#UC END# *5009A72B01A5_493D2F7B031Dget_var*
//#UC START# *5009ADAC0080_493D2F7B031Darea_impl*
 Result := TdsDocumentWithFlash.Make(Self, pm_GetDocInfo.Clone);
//#UC END# *5009ADAC0080_493D2F7B031Darea_impl*
//#UC START# *5009ADAC0080_493D2F7B031Darea_var*
//#UC END# *5009ADAC0080_493D2F7B031Darea_var*
//#UC START# *5009ADAC0080_493D2F7B031Dget_need*
     AND NeedMakeDocumentWithFlash   
   // - условие создания ViewArea
//#UC END# *5009ADAC0080_493D2F7B031Dget_need*
//#UC START# *5009ADAC0080_493D2F7B031Dget_var*
//#UC END# *5009ADAC0080_493D2F7B031Dget_var*
//#UC START# *500CEDF00141_493D2F7B031Darea_impl*
 if Supports(SetData.DocInfo, IbsDocumentContainer, l_Container) then
  try
   Result := TdsAnnotation.Make(Self, TdeDocInfo.Make(
    TbsNestedDocumentContainer.Make(l_Container, ndtAnnotation, TruthHasAnnotation)));
  finally
   l_Container := nil;
  end//try..finally
 else
  Result := nil;
//#UC END# *500CEDF00141_493D2F7B031Darea_impl*
//#UC START# *500CEDF00141_493D2F7B031Darea_var*
var
 l_Container: IbsDocumentContainer;
//#UC END# *500CEDF00141_493D2F7B031Darea_var*
//#UC START# *500CEDF00141_493D2F7B031Dget_need*
     AND NeedMakeAnnotation   
   // - условие создания ViewArea
//#UC END# *500CEDF00141_493D2F7B031Dget_need*
//#UC START# *500CEDF00141_493D2F7B031Dget_var*
//#UC END# *500CEDF00141_493D2F7B031Dget_var*
//#UC START# *500CEE0F0071_493D2F7B031Darea_impl*
 if Supports(SetData.DocInfo, IbsDocumentContainer, l_Container) then
  try
   Result := TdsTranslation.Make(Self, TdeDocInfo.Make(
    TbsNestedDocumentContainer.Make(l_Container, ndtTranslation, pm_GetHasTranslation)));
  finally
   l_Container := nil;
  end{try..finally}
 else
  Result := nil; 
//#UC END# *500CEE0F0071_493D2F7B031Darea_impl*
//#UC START# *500CEE0F0071_493D2F7B031Darea_var*
var
 l_Container: IbsDocumentContainer;
//#UC END# *500CEE0F0071_493D2F7B031Darea_var*
//#UC START# *500CEE0F0071_493D2F7B031Dget_need*
     AND pm_GetHasTranslation
     AND afw.Settings.LoadBoolean(pi_Document_Sheets_Translation, dv_Document_Sheets_Translation)
   // - условие создания ViewArea
//#UC END# *500CEE0F0071_493D2F7B031Dget_need*
//#UC START# *500CEE0F0071_493D2F7B031Dget_var*
//#UC END# *500CEE0F0071_493D2F7B031Dget_var*
//#UC START# *500CEE5200DF_493D2F7B031Darea_impl*
 Result := TdsDocumentList.Make(Self, TdeDocumentList.Make(lp_SimilarDocsList));
//#UC END# *500CEE5200DF_493D2F7B031Darea_impl*
//#UC START# *500CEE5200DF_493D2F7B031Darea_var*
  function lp_SimilarDocsList: IDynList;
  var
   l_CB: ICatalogBase;
  begin
   if TruthHasSimilarDocuments then
   begin
    pm_GetDocInfo.Doc.GetSameDocuments(l_CB);
    try
     Supports(l_CB, IDynList, Result);
    finally
     l_CB := nil;
    end;{try..finally}
   end//TruthHasSimilarDocuments
   else
    Result := nil;
  end;//lp_SimilarDocsList
//#UC END# *500CEE5200DF_493D2F7B031Darea_var*
//#UC START# *500CEE5200DF_493D2F7B031Dget_need*
     and (NeedMake <> vcm_nmNo)
     and NeedMakeSimilarDocuments
   // - условие создания ViewArea
//#UC END# *500CEE5200DF_493D2F7B031Dget_need*
//#UC START# *500CEE5200DF_493D2F7B031Dget_var*
//#UC END# *500CEE5200DF_493D2F7B031Dget_var*
//#UC START# *53BFD3A70050_493D2F7B031Darea_impl*
 if Supports(SetData.DocInfo, IbsDocumentContainer, l_Container) then
  try
   Result := TdsChronology.Make(Self,
     TdeDocInfo.Make(TbsNestedDocumentContainer.Make(l_Container, ndtChronology, TruthHasChronology))
   );
  finally
   l_Container := nil;
  end//try..finally
 else
  Result := nil;
//#UC END# *53BFD3A70050_493D2F7B031Darea_impl*
//#UC START# *53BFD3A70050_493D2F7B031Darea_var*
var
 l_Container: IbsDocumentContainer;
//#UC END# *53BFD3A70050_493D2F7B031Darea_var*
//#UC START# *53BFD3A70050_493D2F7B031Dget_need*
   and NeedMakeChronology
//#UC END# *53BFD3A70050_493D2F7B031Dget_need*
//#UC START# *53BFD3A70050_493D2F7B031Dget_var*
//#UC END# *53BFD3A70050_493D2F7B031Dget_var*
//#UC START# *53BFE45F039B_493D2F7B031D_impl*
 Result := False;
 if pm_GetHasDocument and not l3BoolCheck(SetData.HasChronology, Result) then
 begin
  Result := l3BoolSet(pm_GetDocInfo.Doc.HasChronology, l_Temp);
  SetData.HasChronology := l_Temp;
 end;
//#UC END# *53BFE45F039B_493D2F7B031D_impl*
//#UC START# *53BFE45F039B_493D2F7B031D_var*
var
 l_Temp: Tl3Bool;
//#UC END# *53BFE45F039B_493D2F7B031D_var*
//#UC START# *53BFE4C1035E_493D2F7B031D_impl*
 Result := pm_GetHasChronology;
//#UC END# *53BFE4C1035E_493D2F7B031D_impl*
//#UC START# *53BFE4C1035E_493D2F7B031D_var*
//#UC END# *53BFE4C1035E_493D2F7B031D_var*
//#UC START# *558928CF0335_493D2F7B031D_impl*
 if pm_GetHasDocument then
 begin
  pm_GetDocInfo.Doc.GetTextProvider(False, l_Provider);
  Result := l_Provider.HasSame(anId);
 end else
  Result := False;
//#UC END# *558928CF0335_493D2F7B031D_impl*
//#UC START# *558928CF0335_493D2F7B031D_var*
var
 l_Provider: IDocumentTextProvider;
//#UC END# *558928CF0335_493D2F7B031D_var*
//#UC START# *5594F2C102D7_493D2F7B031Darea_impl*
 Result := TdsDocumentList.Make(Self, TdeDocumentList.Make(lp_SimilarDocsList));
 SetData.SimilarDocumentsBlockId := 0;
//#UC END# *5594F2C102D7_493D2F7B031Darea_impl*
//#UC START# *5594F2C102D7_493D2F7B031Darea_var*
  function lp_SimilarDocsList: IDynList;
  var
   l_CB: ICatalogBase;
  begin
   if SetData.SimilarDocumentsBlockId > 0 then
   begin
    pm_GetDocInfo.Doc.GetSameToPoint(SetData.SimilarDocumentsBlockId, l_CB);
    try
     Supports(l_CB, IDynList, Result);
    finally
     l_CB := nil;
    end;{try..finally}
   end else
    Result := nil;
  end;//lp_SimilarDocsList
//#UC END# *5594F2C102D7_493D2F7B031Darea_var*
//#UC START# *5594F2C102D7_493D2F7B031Dget_need*
    and (SetData.SimilarDocumentsBlockId > 0)
//#UC END# *5594F2C102D7_493D2F7B031Dget_need*
//#UC START# *5594F2C102D7_493D2F7B031Dget_var*
//#UC END# *5594F2C102D7_493D2F7B031Dget_var*
//#UC START# *5BAF4D39E661_493D2F7B031Dget_impl*
 Result := TruthHasChronology; 
//#UC END# *5BAF4D39E661_493D2F7B031Dget_impl*
//#UC START# *5BAF4D39E661_493D2F7B031Dget_var*
//#UC END# *5BAF4D39E661_493D2F7B031Dget_var*
//#UC START# *8A0096569944_493D2F7B031Dget_impl*
 Result := TruthHasAnnotation;
//#UC END# *8A0096569944_493D2F7B031Dget_impl*
//#UC START# *8A0096569944_493D2F7B031Dget_var*
//#UC END# *8A0096569944_493D2F7B031Dget_var*
//#UC START# *A0814C441725_493D2F7B031Dget_impl*
 Result := False;
 if pm_GetHasDocument and not l3BoolCheck(SetData.HasCorrespondents, Result) then
 begin
  Result := l3BoolSet(pm_GetDocInfo.Doc.
   HasCorrespondents(SetData.CorrType.Value), l_Temp);
  SetData.HasCorrespondents := l_Temp;
 end;
//#UC END# *A0814C441725_493D2F7B031Dget_impl*
//#UC START# *A0814C441725_493D2F7B031Dget_var*
var
 l_Temp: Tl3Bool;
//#UC END# *A0814C441725_493D2F7B031Dget_var*
//#UC START# *E562F23618B1_493D2F7B031Dget_impl*
 Result := False;
 if pm_GetHasDocument and not l3BoolCheck(SetData.HasRespondents, Result) then
 begin
  Result := l3BoolSet(pm_GetDocInfo.Doc.HasRespondents(SetData.RespType.Value),
   l_Temp);
  SetData.HasRespondents := l_Temp;
 end;
//#UC END# *E562F23618B1_493D2F7B031Dget_impl*
//#UC START# *E562F23618B1_493D2F7B031Dget_var*
var
 l_Temp: Tl3Bool;
//#UC END# *E562F23618B1_493D2F7B031Dget_var*
