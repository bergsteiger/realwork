//#UC START# *479731C50290_499D24A503A6_impl*
 f_Thread.WaitFor;
 FreeAndNil(f_Thread);
 Set_Waiter(nil);
 if f_Valid then
  ReleaseMutex(f_Guard);
 f_Valid := False;
 if f_Header <> nil then
  UnmapViewOfFile(f_Header);
 f_Header := nil;
 CloseHandle(f_Guard);
 CloseHandle(f_CanCloseEvent);
 CloseHandle(f_MemFile);
 DeleteCriticalSection(f_WaiterGuard);
 inherited Cleanup;
//#UC END# *479731C50290_499D24A503A6_impl*
//#UC START# *479731C50290_499D24A503A6_var*
//#UC END# *479731C50290_499D24A503A6_var*
//#UC START# *499D074100CF_499D24A503A6get_impl*
 Result := InsSplashWaiter(f_Waiter);
//#UC END# *499D074100CF_499D24A503A6get_impl*
//#UC START# *499D074100CF_499D24A503A6get_var*
//#UC END# *499D074100CF_499D24A503A6get_var*
//#UC START# *499D074100CF_499D24A503A6set_impl*
 EnterCriticalSection(f_WaiterGuard);
 try
  f_Waiter := Pointer(aValue);
  if Assigned(aValue) and f_CanClose then
   aValue.CanCloseSplash;
 finally
  LeaveCriticalSection(f_WaiterGuard);
 end;
//#UC END# *499D074100CF_499D24A503A6set_impl*
//#UC START# *499D074100CF_499D24A503A6set_var*
//#UC END# *499D074100CF_499D24A503A6set_var*
//#UC START# *499D076503E0_499D24A503A6_impl*
 if Get_IsValid and (f_Header^.ParentWnd <> 0) then
 begin
  if (GetWindowThreadProcessId(GetForegroundWindow, nil) = GetCurrentThreadID) then
   SetForegroundWindow(f_Header^.ParentWnd);
 end;
//#UC END# *499D076503E0_499D24A503A6_impl*
//#UC START# *499D076503E0_499D24A503A6_var*
//#UC END# *499D076503E0_499D24A503A6_var*
//#UC START# *499D121F01A1_499D24A503A6get_impl*
 Result := f_Valid;
//#UC END# *499D121F01A1_499D24A503A6get_impl*
//#UC START# *499D121F01A1_499D24A503A6get_var*
//#UC END# *499D121F01A1_499D24A503A6get_var*
//#UC START# *499D12390040_499D24A503A6get_impl*
 if Get_IsValid then
  Result := f_Header^.MinimalShowTime
 else
  Result := 0;
//#UC END# *499D12390040_499D24A503A6get_impl*
//#UC START# *499D12390040_499D24A503A6get_var*
//#UC END# *499D12390040_499D24A503A6get_var*
//#UC START# *499D12670256_499D24A503A6get_impl*
 if Get_IsValid then
  Result := l3CStr(l3PCharLen(PAnsiChar(WarningPointer), (f_Header^.WarningSize - 2) div 2, CP_Unicode))
 else
  Result := nil;
//#UC END# *499D12670256_499D24A503A6get_impl*
//#UC START# *499D12670256_499D24A503A6get_var*
//#UC END# *499D12670256_499D24A503A6get_var*
//#UC START# *499D128B028A_499D24A503A6get_impl*
 if Get_IsValid then
  Result := l3CStr(l3PCharLen(PAnsiChar(UserInfoPointer), (f_Header^.UserInfoSize - 2) div 2, CP_Unicode))
 else
  Result := nil;
//#UC END# *499D128B028A_499D24A503A6get_impl*
//#UC START# *499D128B028A_499D24A503A6get_var*
//#UC END# *499D128B028A_499D24A503A6get_var*
//#UC START# *499D1298014D_499D24A503A6get_impl*
 Result := PAnsiChar(ApplicationTitlePointer);
//#UC END# *499D1298014D_499D24A503A6get_impl*
//#UC START# *499D1298014D_499D24A503A6get_var*
//#UC END# *499D1298014D_499D24A503A6get_var*
//#UC START# *499D24A503A6_ext:FileName
w:\garant6x\implementation\Garant\GbaNemesis\Splash\nsSplashInfo.pas
//#UC END# *499D24A503A6_ext:FileName
//#UC START# *499D24A503A6impl_uses*
//#UC END# *499D24A503A6impl_uses*
//#UC START# *499D25B501C4_499D24A503A6_impl*
 inherited Create;
 InitializeCriticalSection(f_WaiterGuard);
 f_Valid := False;
 f_Guard := OpenMutex(MUTEX_MODIFY_STATE or SYNCHRONIZE, true, cGuardName);
 if (f_Guard = 0) then
  Exit;
 f_CanCloseEvent := OpenEvent(SYNCHRONIZE, True, cFinishEventName);
 if (f_CanCloseEvent = 0) then
  Exit;
 WaitForSingleObject(f_Guard, Infinite);
 try
  f_MemFile := OpenFileMapping(FILE_MAP_READ, true, cMemFileName);
  f_Header := MapViewOfFile(f_MemFile, FILE_MAP_READ, 0, 0, SizeOf(f_Header^));
  try
   if f_Header^.Version <> cSplashVersion then
    exit;
   if f_Header^.ProcessID <> GetCurrentProcessID then
    exit;
   l_Size := f_Header^.Size;
   f_Thread := TnsWaitThread.Create(Self);
  finally
   UnmapViewOfFile(f_Header);
  end;
  f_Header := MapViewOfFile(f_MemFile, FILE_MAP_READ, 0, 0, l_Size);
  f_Valid := True;
  f_Thread.Resume;
 finally
  if not f_Valid then
  begin
   if Assigned(f_Header) then
    UnmapViewOfFile(f_Header);
   ReleaseMutex(f_Guard);
  end;
 end;
//#UC END# *499D25B501C4_499D24A503A6_impl*
//#UC START# *499D25B501C4_499D24A503A6_var*
var
 l_Size: Cardinal;
//#UC END# *499D25B501C4_499D24A503A6_var*
//#UC START# *499D3344000F_499D24A503A6_impl*
 if Get_IsValid then
  Result := Pointer(Cardinal(f_Header) + f_Header^.SplashDataOffset)
 else
  Result := nil;
//#UC END# *499D3344000F_499D24A503A6_impl*
//#UC START# *499D3344000F_499D24A503A6_var*
//#UC END# *499D3344000F_499D24A503A6_var*
//#UC START# *499D37120197_499D24A503A6_impl*
 if Get_IsValid then
  Result := Pointer(Cardinal(f_Header) + f_Header^.UserInfoOffset)
 else
  Result := nil;
//#UC END# *499D37120197_499D24A503A6_impl*
//#UC START# *499D37120197_499D24A503A6_var*
//#UC END# *499D37120197_499D24A503A6_var*
//#UC START# *499D372A02A8_499D24A503A6_impl*
 if Get_IsValid then
  Result := Pointer(Cardinal(f_Header) + f_Header^.WarningOffset)
 else
  Result := nil;
//#UC END# *499D372A02A8_499D24A503A6_impl*
//#UC START# *499D372A02A8_499D24A503A6_var*
//#UC END# *499D372A02A8_499D24A503A6_var*
//#UC START# *499D374D0203_499D24A503A6_impl*
 if Get_IsValid then
  Result := Pointer(Cardinal(f_Header) + f_Header^.ApplicationTitleOffset)
 else
  Result := nil;
//#UC END# *499D374D0203_499D24A503A6_impl*
//#UC START# *499D374D0203_499D24A503A6_var*
//#UC END# *499D374D0203_499D24A503A6_var*
//#UC START# *499D3BA602BC_499D3B52019D_impl*
 Assert(Assigned(aInfo));
 inherited Create(True);
 f_Info := aInfo;
//#UC END# *499D3BA602BC_499D3B52019D_impl*
//#UC START# *499D3BA602BC_499D3B52019D_var*
//#UC END# *499D3BA602BC_499D3B52019D_var*
//#UC START# *499D3BE0004D_499D3B52019D_impl*
 WaitForSingleObject(f_Info.f_CanCloseEvent, INFINITE);
 Synchronize(DoDone);
//#UC END# *499D3BE0004D_499D3B52019D_impl*
//#UC START# *499D3BE0004D_499D3B52019D_var*
//#UC END# *499D3BE0004D_499D3B52019D_var*
//#UC START# *499D3C000104_499D3B52019D_impl*
 f_Info.SignalCanClose;
//#UC END# *499D3C000104_499D3B52019D_impl*
//#UC START# *499D3C000104_499D3B52019D_var*
//#UC END# *499D3C000104_499D3B52019D_var*
//#UC START# *499D3E8A0270_499D24A503A6_impl*
 if Get_IsValid then
 begin
  l_Instance := Tl3ConstMemoryStream.Create(SplashDataPointer, f_Header^.SplashDataSize);
  try
   Result := l_Instance
  finally
   FreeAndNil(l_Instance);
  end;
 end
 else
  Result := nil;
//#UC END# *499D3E8A0270_499D24A503A6_impl*
//#UC START# *499D3E8A0270_499D24A503A6_var*
var
 l_Instance: Tl3ConstMemoryStream;
//#UC END# *499D3E8A0270_499D24A503A6_var*
//#UC START# *499D40ED018C_499D24A503A6_impl*
 f_CanClose := True;
 EnterCriticalSection(f_WaiterGuard);
 try
  if Get_Waiter <> nil then
   Get_Waiter.CanCloseSplash;
 finally
  LeaveCriticalSection(f_WaiterGuard);
 end;
//#UC END# *499D40ED018C_499D24A503A6_impl*
//#UC START# *499D40ED018C_499D24A503A6_var*
//#UC END# *499D40ED018C_499D24A503A6_var*
//#UC START# *499E5EA40035_499D24A503A6_impl*
 if Get_IsValid then
 begin
  l_Instance := Tl3ConstMemoryStream.Create(LogoPointer, f_Header^.LogoSize);
  try
   Result := l_Instance
  finally
   FreeAndNil(l_Instance);
  end;
 end
 else
  Result := nil;
//#UC END# *499E5EA40035_499D24A503A6_impl*
//#UC START# *499E5EA40035_499D24A503A6_var*
var
 l_Instance: Tl3ConstMemoryStream;
//#UC END# *499E5EA40035_499D24A503A6_var*
//#UC START# *499E5F9102A0_499D24A503A6_impl*
 if Get_IsValid then
  Result := Pointer(Cardinal(f_Header) + f_Header^.LogoOffset)
 else
  Result := nil;
//#UC END# *499E5F9102A0_499D24A503A6_impl*
//#UC START# *499E5F9102A0_499D24A503A6_var*
//#UC END# *499E5F9102A0_499D24A503A6_var*
