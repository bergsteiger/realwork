//#UC START# *479731C50290_4A5D7B82016A_impl*
 f_BaseLine := nil;
 inherited;
//#UC END# *479731C50290_4A5D7B82016A_impl*
//#UC START# *479731C50290_4A5D7B82016A_var*
//#UC END# *479731C50290_4A5D7B82016A_var*
//#UC START# *4A3B707700C9_4A5D7B82016A_impl*
 if (f_BaseLine <> nil) then
  Result := f_BaseLine.AtStart
 else
  Result := inherited GetAtStart;
//#UC END# *4A3B707700C9_4A5D7B82016A_impl*
//#UC START# *4A3B707700C9_4A5D7B82016A_var*
//#UC END# *4A3B707700C9_4A5D7B82016A_var*
//#UC START# *4A3B708900C4_4A5D7B82016A_impl*
 if (f_BaseLine <> nil) then
  Result := f_BaseLine.AtEnd(aView)
 else
  Result := inherited GetAtEnd(aView);
//#UC END# *4A3B708900C4_4A5D7B82016A_impl*
//#UC START# *4A3B708900C4_4A5D7B82016A_var*
//#UC END# *4A3B708900C4_4A5D7B82016A_var*
//#UC START# *4A3B7F2E01CE_4A5D7B82016A_impl*
 if (f_BaseLine <> nil) then
  Result := f_BaseLine.VertPosition(aView, aMap)
 else
  Result := inherited GetVertPosition(aView, aMap);
//#UC END# *4A3B7F2E01CE_4A5D7B82016A_impl*
//#UC START# *4A3B7F2E01CE_4A5D7B82016A_var*
//#UC END# *4A3B7F2E01CE_4A5D7B82016A_var*
//#UC START# *4A3B826402B8_4A5D7B82016A_impl*
 if (f_BaseLine = nil) then
  Result := inherited GetInner
 else
  Result := f_BaseLine.Inner;
//#UC END# *4A3B826402B8_4A5D7B82016A_impl*
//#UC START# *4A3B826402B8_4A5D7B82016A_var*
//#UC END# *4A3B826402B8_4A5D7B82016A_var*
//#UC START# *4A3B82710255_4A5D7B82016A_impl*
 inherited;
 Assert(False);
//#UC END# *4A3B82710255_4A5D7B82016A_impl*
//#UC START# *4A3B82710255_4A5D7B82016A_var*
//#UC END# *4A3B82710255_4A5D7B82016A_var*
//#UC START# *4A3B848302A5_4A5D7B82016A_impl*
 if f_BaseLine <> nil then
  Result := f_BaseLine.InnerFor(aChild, aRealTop)
 else
  Result := inherited GetInnerFor(aChild, aRealTop);
//#UC END# *4A3B848302A5_4A5D7B82016A_impl*
//#UC START# *4A3B848302A5_4A5D7B82016A_var*
//#UC END# *4A3B848302A5_4A5D7B82016A_var*
//#UC START# *4A58BA550111_4A5D7B82016Aget_impl*
 Result := (f_BaseLine = nil);
 if Result then
  Result := inherited pm_GetHasInner;
//#UC END# *4A58BA550111_4A5D7B82016Aget_impl*
//#UC START# *4A58BA550111_4A5D7B82016Aget_var*
//#UC END# *4A58BA550111_4A5D7B82016Aget_var*
//#UC START# *4A5D7B82016A_ext:FileName
w:\common\components\gui\Garant\Everest\new\nevTableRowAnchor.pas
//#UC END# *4A5D7B82016A_ext:FileName
//#UC START# *4A5D7B82016Aimpl_uses*
//#UC END# *4A5D7B82016Aimpl_uses*
//#UC START# *4A5D7BF302EB_4A5D7B82016A_impl*
 if f_BaseLine = nil then
 begin
  l_RowFI := aView.FormatInfoByPoint(Self);     
  if l_RowFI = nil then Exit; // Нечего инициализировать базовую линию, если форматирование строки недоступно - огребем кучу AV!
  f_BaseLine := ParaX.BaseLine4Anchor;
  ParaX.AsList.IterateParaF(nevL2PIA(@CheckChildren));
 end; // if f_BaseLine = nil then
//#UC END# *4A5D7BF302EB_4A5D7B82016A_impl*
//#UC START# *4A5D7BF302EB_4A5D7B82016A_var*
var
 l_RowFI : TnevFormatInfoPrim;

 function CheckChildren(const anItem: InevPara; anIndex: Integer): Boolean;
 var
  l_Point: InevBasePoint;
 begin
  Result := true;
  f_BaseLine.InitBaseLineInner(aView, anItem); 
 end;

//#UC END# *4A5D7BF302EB_4A5D7B82016A_var*
//#UC START# *4AA777B603B6_4A5D7B82016A_impl*
 Result := (f_BaseLine <> nil);
//#UC END# *4AA777B603B6_4A5D7B82016A_impl*
//#UC START# *4AA777B603B6_4A5D7B82016A_var*
//#UC END# *4AA777B603B6_4A5D7B82016A_var*
//#UC START# *4AA7797701F5_4A5D7B82016A_impl*
 if (aForDrawing = nev_itNeedInit) and (f_BaseLine = nil) then
 begin
  l_BaseLine := ParaX.BaseLine4Anchor;
  Result := l_BaseLine.InnerForChildThatNotAfterEnd(aFI, aForDrawing);
 end // if (aForDrawing = nev_itNeedInit) and (f_BaseLine = nil) then
 else
  Result := f_BaseLine.InnerForChildThatNotAfterEnd(aFI, aForDrawing);
//#UC END# *4AA7797701F5_4A5D7B82016A_impl*
//#UC START# *4AA7797701F5_4A5D7B82016A_var*
var
 l_BaseLine : InevBaseLine4Anchor;
//#UC END# *4AA7797701F5_4A5D7B82016A_var*
//#UC START# *4AA785540310_4A5D7B82016A_impl*
 Result := inherited DoDiff(aView, aPoint, aMap);
 if (Result = 0) then
  if HasBaseLine and aPoint.HasBaseLine then
  begin
   Result := nev_PlusDiff;
   l_Line := aPoint;
   if (l_Line <> nil) then
   begin
    l_List := ParaX.AsList;
    for i := 0 to l_List.AsObject.ChildrenCount - 1 do
    begin
     l_Child := l_List.Para[i];
     l_PointInner := l_Line.InnerFor(l_Child, l_PointReal);
     l_Inner := InnerFor(l_Child, l_Real);
     if l_PointInner = nil then
      if l_Inner = nil then
       Result := 0
      else
       Result := nev_PlusDiff
     else
     if l_PointInner.AfterEnd then
      if l_Inner = nil then
       Result := nev_PlusDiff
      else
       if l_Inner.AfterEnd then
       begin
        if aMap.GreatestObjPID = i then
         if (l_PointReal = nil) or l_PointReal.AfterEnd then
          if (l_Real = nil) or l_Real.AfterEnd then
           Result := 0
          else
           Result := nev_PlusDiff
         else
          if (l_Real = nil) or l_Real.AfterEnd then
           Result := nev_MinusDiff
          else
           Result := l_Real.Diff(aView, l_PointReal, aView.FormatInfoByPoint(l_Real))
        else
         Result := 0;
      end // if l_Inner.AfterEnd then
      else
       Result := nev_PlusDiff
     else
      if l_Inner = nil then
       Result := nev_PlusDiff
      else
      if l_Inner.AfterEnd then
       Result := nev_MinusDiff
      else
       if l_Inner.BeforeStart then
        Result := nev_PlusDiff
       else
        Result := l_Inner.Diff(aView, l_PointInner, aMap.InfoForChild(l_Child));
     if Result <> 0 then Break;
    end; // for i := 0 to f_Children.Count - 1 do
   end;//l_Line <> nil
  end//if Result = 0 then
  else
   begin
    if HasBaseLine then
     l_Inner := InnerFor(ParaX.ToList.Obj[0], l_Real)
    else
     l_Inner := pm_GetInner;
    if aPoint.HasBaseLine then
     l_PointInner := aPoint.InnerFor(aPoint.Obj^.ToList.Obj[0], l_Real)
    else
     l_PointInner := pm_GetInner;
    if (l_Inner = nil) or (l_PointInner = nil) then
    begin
     if l_Inner <> nil then
      Result := nev_PlusDiff;
     if l_PointInner <> nil then
      Result := nev_MinusDiff;
    end
    else
     Result := l_Inner.Diff(aView, l_PointInner, aMap.InfoForChild(l_Inner.Obj^));
   end;
//#UC END# *4AA785540310_4A5D7B82016A_impl*
//#UC START# *4AA785540310_4A5D7B82016A_var*
var
 i            : Integer;
 l_PointInner : InevBasePoint;
 l_Inner      : InevBasePoint;
 l_Line       : InevBasePoint;
 l_List       : InevParaList;
 l_Child      : InevPara;
 l_PointReal  : InevBasePoint;
 l_Real       : InevBasePoint;
//#UC END# *4AA785540310_4A5D7B82016A_var*
//#UC START# *4AEC34960358_4A5D7B82016A_impl*
 Result := inherited GetInnerTop(aChild);
 if f_BaseLine <> nil then
  Result := f_BaseLine.InnerTop(aChild);
//#UC END# *4AEC34960358_4A5D7B82016A_impl*
//#UC START# *4AEC34960358_4A5D7B82016A_var*
//#UC END# *4AEC34960358_4A5D7B82016A_var*
//#UC START# *4B1CFD7B0332_4A5D7B82016A_impl*
 LockScroll;
 try
  CheckBaseLine(aView);
  if f_BaseLine <> nil then
   f_BaseLine.Bottom(aView);
 finally
  UnlockScroll;
 end;//try..finally
//#UC END# *4B1CFD7B0332_4A5D7B82016A_impl*
//#UC START# *4B1CFD7B0332_4A5D7B82016A_var*
//#UC END# *4B1CFD7B0332_4A5D7B82016A_var*
//#UC START# *4B1D0220010E_4A5D7B82016A_impl*
 inherited DoAssignPoint(aView, aPoint);
 if aPoint.HasBaseLine then
 begin
  if f_BaseLine = nil then
   f_BaseLine := ParaX.BaseLine4Anchor;
  f_BaseLine.AssignPoint(aView, aPoint);
 end // if aPoint.HasBaseLine then
 else
  if aPoint.HasInner then
   InitByCursor(aView, aPoint.Inner);
//#UC END# *4B1D0220010E_4A5D7B82016A_impl*
//#UC START# *4B1D0220010E_4A5D7B82016A_var*
//#UC END# *4B1D0220010E_4A5D7B82016A_var*
//#UC START# *4B1D18650208_4A5D7B82016A_impl*
 CheckBaseLine(aView);
 if f_BaseLine <> nil then
  Result := f_BaseLine.IncLine(aView, theLine, aSmall)
 else
  Result := 0;
//#UC END# *4B1D18650208_4A5D7B82016A_impl*
//#UC START# *4B1D18650208_4A5D7B82016A_var*
//#UC END# *4B1D18650208_4A5D7B82016A_var*
//#UC START# *4B90DBFE00EF_4A5D7B82016A_impl*
 CheckBaseLine(aView);
 if f_BaseLine <> nil then
  f_BaseLine.AddInner(aView, anInner, anIndex, aFirst, aMode);
//#UC END# *4B90DBFE00EF_4A5D7B82016A_impl*
//#UC START# *4B90DBFE00EF_4A5D7B82016A_var*
//#UC END# *4B90DBFE00EF_4A5D7B82016A_var*
//#UC START# *4B9625260325_4A5D7B82016A_impl*
 CheckBaseLine(aView);
 if f_BaseLine <> nil then
  f_BaseLine.CompareWithOtherInner(aView, anMaxID);
//#UC END# *4B9625260325_4A5D7B82016A_impl*
//#UC START# *4B9625260325_4A5D7B82016A_var*
//#UC END# *4B9625260325_4A5D7B82016A_var*
//#UC START# *4C7361850250_4A5D7B82016A_impl*
 CheckBaseLine(aView);
 if f_BaseLine <> nil then
  f_BaseLine.InitByCursor(aView, anInnerPoint);
//#UC END# *4C7361850250_4A5D7B82016A_impl*
//#UC START# *4C7361850250_4A5D7B82016A_var*
//#UC END# *4C7361850250_4A5D7B82016A_var*
