//#UC START# *4A9CE5F2036F_ext:FileName
w:\garant6x\implementation\Garant\GbaNemesis\View\Diction\Diction_Module.pas
//#UC END# *4A9CE5F2036F_ext:FileName
//#UC START# *4A9CE5F2036Fimpl_uses*
 , CommonDictionInterfaces
 , DictionInterfaces
 , StdRes
//#UC END# *4A9CE5F2036Fimpl_uses*
//#UC START# *4A9CEF360326_4A9CE5F2036F_impl*
 l_Str := l3Trim(aContext, cc_AllChars - cc_ANSILetter);
 l_DictTree := TnsDictionTree.Make(ns_dkDiction, aLanguage, l_Str, True);

 Supports(l_DictTree, Il3FilterableTree, l_FilterTree);

 if not l3IsNil(aContext) and
    (l3IsNil(l_Str) or l3IsNil(l_FilterTree.CloneFilters.Context)) then
 begin
  vcmSay(inf_NothingWasFound);
  Exit;
 end;

 Supports(l_DictTree.RootNode.Child, INodeBase, l_Child);
 Assert(Assigned(l_FilterTree));

 if l_Child <> nil then
 try
  l_Child.GetEntity(l_Entity);
  try
   if Supports(l_Entity, IDocument, l_Doc) then
   try
    l_Map := TnsLangToContextMap.Make(nil);
    try
     l_Map.ByLang[aLanguage] := TnscContextFilterState.Make(True, l_Str, MaxInt);
     OpenDictionary(TdeDiction.Make(l_Doc, aLanguage, l_Map), DefaultContainer);
    finally
     l_Map := nil;
    end;
   finally
    l_Doc := nil;
   end;//try..finally
  finally
   l_Entity := nil;
  end;//try..finally
 finally
  l_Child := nil;
 end;//try..finally
//#UC END# *4A9CEF360326_4A9CE5F2036F_impl*
//#UC START# *4A9CEF360326_4A9CE5F2036F_var*
var
 l_Map: InsLangToContextMap;
//#UC END# *4A9CEF360326_4A9CE5F2036F_var*
//#UC START# *4A9D1FD20092_4A9CE5F2036F_impl*
 TnsOpenDictionaryEvent.Log;
 Tfs_Diction.Make(TsdsDiction.Make(aDocInfo), aContainer);
//#UC END# *4A9D1FD20092_4A9CE5F2036F_impl*
//#UC START# *4A9D1FD20092_4A9CE5F2036F_var*
//#UC END# *4A9D1FD20092_4A9CE5F2036F_var*
//#UC START# *4A9D55E901D6_4A9CE5F2036Fexec_impl*
 l_CurOpIndex := aParams.ItemIndex;

 l_Cont := (aParams As IvcmExecuteParams).Container;
 if (l_Cont <> nil) and
  l_Cont.HasForm(fm_TextForm.rFormID, vcm_ztParent, true, @l_Form) and
  (((l_CurOpIndex = 1) or (l_CurOpIndex = 0))) then
 begin
  // Найти толкование
  if not op_Document_FindExplanation.Call(l_Form) then
  begin
   if (l_CurOpIndex = 1) or
      (l_Form.UserType = dftDictEntry) then
   begin
    vcmSay(war_ExplanationSearchNotEnabled);
    Exit;
   end;//l_CurOpIndex = 1
  end//not op_Document_FindExplanation.Call(l_Form)
  else
   Exit;
 end;//l_Cont <> nil
 if not lp_HasDictionForm then
  OpenDictionary(nil, l_Cont);
//#UC END# *4A9D55E901D6_4A9CE5F2036Fexec_impl*
//#UC START# *4A9D55E901D6_4A9CE5F2036Fexec_var*

var
 l_Cont : IvcmContainer;

 function lp_HasDictionForm: Boolean;
 begin//lp_ShowDictionForm
  Result := (l_Cont <> nil) and
            l_Cont.HasForm(fm_enDiction.rFormID, vcm_ztNavigator, True);
 end;//lp_ShowDictionForm

var
 l_CurOpIndex : Integer;
//#UC END# *4A9D55E901D6_4A9CE5F2036Fexec_var*
//#UC START# *4A9D55E901D6_4A9CE5F2036Ftest_impl*
 with (aParams As IvcmTestParams) do
 begin
  Op.Flag[vcm_ofEnabled] := defDataAdapter.IsExplanatoryExists;
  if Op.Flag[vcm_ofEnabled] then
  begin
   if (Container <> nil) and
      Container.HasForm(fm_TextForm.rFormID, vcm_ztParent, true, @l_Form) then
   begin
    with Op.SubItems do
     if (l_Form.UserType = dftDictEntry) then
     begin
      if (Count <> 0) then
       Clear;
     end//l_Form.UserType = dftDictEntry
     else
     if (Count < 2) then
     begin
      Clear;
      Add(vcmCStr(str_SearchInDiction));
      Add(vcmCStr(str_OpenDiction));
     end;//Count < 2
   end//Container <> nil
   else
    with Op.SubItems do
     if (Count <> 0) then
      Clear;
  end;//Op.Flag[vcm_ofEnabled]
  Op.Flag[vcm_ofVisible] := Op.Flag[vcm_ofEnabled];
 end;//with aParams
//#UC END# *4A9D55E901D6_4A9CE5F2036Ftest_impl*
//#UC START# *4A9D55E901D6_4A9CE5F2036Ftest_var*
//#UC END# *4A9D55E901D6_4A9CE5F2036Ftest_var*
//#UC START# *4B14CE0A001F_4B14CDEA039C_impl*
 GetLogger.AddEvent(LE_OPEN_DICTIONARY, MakeParamsList);
//#UC END# *4B14CE0A001F_4B14CDEA039C_impl*
//#UC START# *4B14CE0A001F_4B14CDEA039C_var*
//#UC END# *4B14CE0A001F_4B14CDEA039C_var*
