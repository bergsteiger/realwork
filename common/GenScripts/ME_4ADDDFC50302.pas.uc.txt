//#UC START# *46A44F6B035E_4ADDDFC50302_impl*
 if f_NotifiedObjList = nil then
  f_NotifiedObjList := Tl3LongintList.MakeSorted;
 f_NotifiedObjList.Add(Integer(aRecipient));
//#UC END# *46A44F6B035E_4ADDDFC50302_impl*
//#UC START# *46A44F6B035E_4ADDDFC50302_var*
//#UC END# *46A44F6B035E_4ADDDFC50302_var*
//#UC START# *46A44FFE0143_4ADDDFC50302_impl*
 if f_NotifiedObjList <> nil then
  f_NotifiedObjList.Remove(Integer(aRecipient));
//#UC END# *46A44FFE0143_4ADDDFC50302_impl*
//#UC START# *46A44FFE0143_4ADDDFC50302_var*
//#UC END# *46A44FFE0143_4ADDDFC50302_var*
//#UC START# *479731C50290_4ADDDFC50302_impl*
 l3Free(f_NotifiedObjList);
 ReleaseChilds;
 inherited;
//#UC END# *479731C50290_4ADDDFC50302_impl*
//#UC START# *479731C50290_4ADDDFC50302_var*
//#UC END# *479731C50290_4ADDDFC50302_var*
//#UC START# *4ADDDFC50302_ext:ParentFileName
w:\common\components\rtl\Garant\L3\l3NodesModelPart.pas
//#UC END# *4ADDDFC50302_ext:ParentFileName
//#UC START# *54C78A1E033E_4ADDDFC50302_impl*
 Result := GetNumInParent(True);
//#UC END# *54C78A1E033E_4ADDDFC50302_impl*
//#UC START# *54C78A1E033E_4ADDDFC50302_var*
//#UC END# *54C78A1E033E_4ADDDFC50302_var*
//#UC START# *54C78E1002BE_4ADDDFC50302_impl*
 Result := Parent;
//#UC END# *54C78E1002BE_4ADDDFC50302_impl*
//#UC START# *54C78E1002BE_4ADDDFC50302_var*
//#UC END# *54C78E1002BE_4ADDDFC50302_var*
//#UC START# *54C78E2702B3_4ADDDFC50302_impl*
 Result := Child;
//#UC END# *54C78E2702B3_4ADDDFC50302_impl*
//#UC START# *54C78E2702B3_4ADDDFC50302_var*
//#UC END# *54C78E2702B3_4ADDDFC50302_var*
//#UC START# *54C78E370213_4ADDDFC50302_impl*
 Result := Next;
//#UC END# *54C78E370213_4ADDDFC50302_impl*
//#UC START# *54C78E370213_4ADDDFC50302_var*
//#UC END# *54C78E370213_4ADDDFC50302_var*
//#UC START# *54C78E440118_4ADDDFC50302_impl*
 Result := Prev;
//#UC END# *54C78E440118_4ADDDFC50302_impl*
//#UC START# *54C78E440118_4ADDDFC50302_var*
//#UC END# *54C78E440118_4ADDDFC50302_var*
//#UC START# *54C78EA30198_4ADDDFC50302_impl*
 Result := 0;
 lCNode := Self;
 while (lCNode <> nil) and not lCNode.IsSame(aNode) do
 begin
  Inc(Result);
  lCNode := lCNode.Parent;
 end;//while (lCNode <> nil)
 if (lCNode = nil) then
  Result := -1;
//#UC END# *54C78EA30198_4ADDDFC50302_impl*
//#UC START# *54C78EA30198_4ADDDFC50302_var*
var
 lCNode : Il3SimpleNode;
//#UC END# *54C78EA30198_4ADDDFC50302_var*
//#UC START# *54C791DB001D_4ADDDFC50302_impl*
 if Parent = nil then
  exit;
 Changing;
 try
  Flags := Flags or nfWasDisappear;
  Notify(ntDelete, Self);
  try
   if IsFirst then
    if IsLast then
     Parent.Child := nil
    else
     Parent.Child := Next;

   if Parent.Child <> nil then
   begin
    Next.Prev := Prev;
    Prev.Next := Next;
   end;

   if Next = Self then
   begin
    Next := nil;
    Prev := nil;
   end;
   Parent.IncAllChildrenCount( -Succ(AllChildrenCount));
   //Parent := nil; Changed send to Parent!!!
  finally
   Notify(ntDeleteDone, Self);
  end;
 finally
  Changed;
 end;
 Parent := nil;
 Free;
//#UC END# *54C791DB001D_4ADDDFC50302_impl*
//#UC START# *54C791DB001D_4ADDDFC50302_var*
//#UC END# *54C791DB001D_4ADDDFC50302_var*
//#UC START# *54C8DFF102DD_4ADDDFC50302_impl*
 Result := nil;
 if not HasChild then
  Exit;
 if (aFromNode = nil) then
  lCurNode := ChildNode
 else
 begin
  if not IsSame(aFromNode.ParentNode) then
   Exit;
  lCurNode := aFromNode;
 end;

 repeat
  if lCurNode.IsLast then
   lNextNode := nil
  else lNextNode := lCurNode.NextNode;

  Result := lCurNode.Iterate(Action, IterMode);
  // ## Result := (lCurNode as Il3NodeWrap).GetSelf.Iterate(Action, IterMode);

  if (Result <> nil) or (lNextNode = nil) then
   Exit;

  lCurNode := lNextNode;
 until False;
//#UC END# *54C8DFF102DD_4ADDDFC50302_impl*
//#UC START# *54C8DFF102DD_4ADDDFC50302_var*
var
 lCurNode : Il3Node;
 lNextNode : Il3Node;
//#UC END# *54C8DFF102DD_4ADDDFC50302_var*
//#UC START# *54C8E0850062_4ADDDFC50302_impl*
 if not HasChild then
  Exit;
 if aChild <> nil then
 begin
  if not IsSame(aChild.ParentNode) then
   Exit;
  if Child.IsLast then
   Exit;
  lNextNode := Child;
  lChild := (aChild as Il3NodeWrap).GetSelf as Tl3Node;

  lMakeFirst := False;

  while True do
  begin
   if (lChild <> lNextNode) then
   begin
    if CompareChild(aChild, lNextNode) < 0 then
    begin
     lMakeFirst := Child = lNextNode;
     Break;
    end;
   end;

   lNextNode := lNextNode.Next;

   if lNextNode.IsFirst then {конец списка}
   begin
    lNextNode := Child;
    Break;
   end;
  end;
  Changing;
  try
   lpMoveNode(lChild, lNextNode, lMakeFirst);
  finally
   Changed;
  end;
 end
 else
 begin
  if Child.IsLast then
   Exit;
  lChild := Child.Next;
  lEndList := lChild.IsLast;
  Changing;
  try
   while True do
   begin
    lNextNode := Child;
    //lMakeFirst := False;

    while True do
    begin
     if (lChild <> lNextNode) then
     begin
      if CompareChild(lChild, lNextNode) < 0 then
      begin
       lMakeFirst := Child = lNextNode;
       lNextOfChild := lChild.Next;
       lpMoveNode(lChild, lNextNode, lMakeFirst);
       lChild := lNextOfChild;
       Break;
      end
     end
     else
     begin
      lChild := lChild.Next;
      Break;
     end;
     lNextNode := lNextNode.Next;
    end;

    if lEndList then
     Break; {конец списка}
    lEndList := lChild.IsLast;
   end;
  finally
   Changed;
  end;
 end;
//#UC END# *54C8E0850062_4ADDDFC50302_impl*
//#UC START# *54C8E0850062_4ADDDFC50302_var*
var
 lChild : Tl3Node;
 lNextNode : Tl3Node;
 lNextOfChild : Tl3Node;
 lEndList : Boolean;

 lMakeFirst : Boolean;
 lUserParam : Pointer;

 procedure lpMoveNode(const aMoveNode, aNextNode: Tl3Node; aMakeFirst: Boolean);
 begin
  if (aMoveNode.Next = aNextNode) and
   ( not aMakeFirst or (Child = aMoveNode)) then
   Exit;

  Notify(ntMoveBegin, aMoveNode);
  try
   lUserParam := nil;
   aMoveNode.BeginMove(lUserParam);

   try
    if aMakeFirst then
     Child := aMoveNode
    else
     if Child = aMoveNode then
      Child := aMoveNode.Next;

    if (aMoveNode <> aNextNode) and
       (aMoveNode.Next <> aNextNode) then
    begin
     with aMoveNode do
     begin
      Next.Prev := Prev;
      Prev.Next := Next;
     end;

     aMoveNode.Prev := lNextNode.Prev;
     aMoveNode.Next := aNextNode;
     aMoveNode.Prev.Next := aMoveNode;
     aNextNode.Prev := aMoveNode;
    end;

   finally
    aMoveNode.EndMove(lUserParam);
   end;
  finally
   Notify(ntMoveEnd, aMoveNode);
  end;
 end;
//#UC END# *54C8E0850062_4ADDDFC50302_var*
//#UC START# *54C8E1F30128_4ADDDFC50302_impl*
 Result := 0;
 lNode := Self;
 while not lNode.IsFirst do
 begin
  lNode := lNode.Prev;
  Inc(Result);
  if not aOnlyOneLevel then
   Inc(Result, lNode.AllChildrenCount);
 end;
//#UC END# *54C8E1F30128_4ADDDFC50302_impl*
//#UC START# *54C8E1F30128_4ADDDFC50302_var*
var
 lNode : Tl3Node;
//#UC END# *54C8E1F30128_4ADDDFC50302_var*
//#UC START# *54C8E22F0223_4ADDDFC50302_impl*
 if Child = nil then
  Exit;

 Changing;
 try
  Notify(ntChildClear, Self);
  AllChildrenCount := 0;
  ReleaseChildsPrim;
 finally
  Changed;
 end;
//#UC END# *54C8E22F0223_4ADDDFC50302_impl*
//#UC START# *54C8E22F0223_4ADDDFC50302_var*
//#UC END# *54C8E22F0223_4ADDDFC50302_var*
//#UC START# *54C8E23B01AB_4ADDDFC50302_impl*
 if Child = nil then
  Exit;

 lCurNode := Child.Prev; // Last
 repeat
  lLast := lCurNode = Child;
  lNextNode := lCurNode.Prev;
  lCurNode.Parent := nil;
  lCurNode.Free;
  lCurNode := lNextNode;
 until lLast;
 Child := nil;
//#UC END# *54C8E23B01AB_4ADDDFC50302_impl*
//#UC START# *54C8E23B01AB_4ADDDFC50302_var*
var
 lCurNode : Tl3Node;
 lNextNode : Tl3Node;
 lLast : Boolean;
//#UC END# *54C8E23B01AB_4ADDDFC50302_var*
//#UC START# *54C8E45103D9_4ADDDFC50302_impl*
 Result := False;
 if Parent = Nil then
  Exit;
 if Parent.ChildSorted then
  Exit;

 Notify(ntMoveBegin, Self);
 try
  lUserParam := nil;
  BeginMove(lUserParam);
  try
   case aDirection of
    dUp:
     if not IsFirst then
     begin
      Changing;
      try
       Prev.Next := Next;
       Next.Prev := Prev;

       if Parent.Child = Prev then
        Parent.Child := Self;
       Next := Prev;
       Prev := Prev.Prev;
       Next.Prev := Self;
       Prev.Next := Self;
       Result := True;
      finally
       Changed;
      end;
     end;

    dUpMax:
     if not IsFirst then
     begin
      Changing;
      try
       Prev.Next := Next;
       Next.Prev := Prev;

       Next := Parent.Child;
       Prev := Parent.Child.Prev;
       Next.Prev := Self;
       Prev.Next := Self;
       Parent.Child := Self;
       Result := True;
      finally
       Changed;
      end;
     end;

    dDown:
     if not IsLast then
     begin
      Changing;
      try
       Prev.Next := Next;
       Next.Prev := Prev;

       if IsFirst then
        Parent.Child := Next;

       Prev := Next;
       Next := Next.Next;
       Next.Prev := Self;
       Prev.Next := Self;
       Result := True;
      finally
       Changed;
      end;
     end;
    (*
    dLeft:
     if Assigned(Parent) and Assigned(Parent.Parent) then
     begin
      ltParentNode := ParentNode;
      ltNextNode := NextNode;
      if ltParentNode.ParentNode.IsAcceptChild(Self) then
      begin
       Changing;
       try
        Remove;
        try
         ltParentNode.ParentNode.InsertChildBefore(ltParentNode, Self);
         Result := True;
        except
         ltParentNode.InsertChildBefore(ltNextNode, Self);
        end;
       finally
        Changed;
       end;
      end;
     end;

    dRight:
     if not IsLast then
     begin
      ltNextNode := NextNode;
      if ltNextNode.IsAcceptChild(Self) then
      begin
       Changing;
       try
        //ltNextNode := Next;
        Remove;
        try
         ltNextNode.InsertChildBefore(ltNextNode.ChildNode, Self);
         Result := True;
        except
         ltNextNode.ParentNode.InsertChildBefore(ltNextNode, Self);
        end;
       finally
        Changed;
       end;
      end;
     end;

     *)
    dLeft:
     if Assigned(Parent) and Assigned(Parent.Parent) then
     begin
      ltParentNode := ParentNode;
      ltNextNode := NextNode;
      if ltNextNode.IsFirst then
       ltNextNode := nil;

      ltParentParentNode := ltParentNode.ParentNode;
      if ltParentParentNode.IsAcceptChild(Self) then
      begin
       Changing;
       try
        Remove;
        try
         if ltParentNode.IsLast then
          ltParentNode := nil
         else
          ltParentNode := ltParentNode.NextNode;
         ltParentParentNode.InsertChildBefore(ltParentNode, Self);
         Result := True;

         While ltNextNode <> nil do
         begin
          ltNextNextNode := ltNextNode.NextNode;
          if ltNextNextNode.IsFirst then
           ltNextNextNode := nil;
          ltNextNode.Remove;
          InsertChild(ltNextNode);

          ltNextNode := ltNextNextNode;
         end;

        except
         // это работать не будет ltParentNode.InsertChildBefore(ltNextNode, Self);
         on E: Exception do
          l3System.Exception2Log(E);
        end;

       finally
        Changed;
       end;
      end;
     end;

    dRight:
     if not IsFirst then
     begin
      ltParentNode := PrevNode;

      if ltParentNode.IsAcceptChild(Self) then
      begin
       Changing;
       try
        //ltNextNode := Next;
        Remove;
        try
         ltParentNode.InsertChild(Self);
         Result := True;
        except
         on E: Exception do
         begin
          l3System.Exception2Log(E);
          if ltParentNode.IsLast then
           ltNextNode := nil
          else
           ltNextNode := ltParentNode.NextNode;
          ltParentNode.ParentNode.InsertChildBefore(ltNextNode, Self);
         end;
        end;
       finally
        Changed;
       end;
      end;
     end;
   end;
  finally
   EndMove(lUserParam);
  end;
 finally
  Notify(ntMoveEnd, Self);
 end;
//#UC END# *54C8E45103D9_4ADDDFC50302_impl*
//#UC START# *54C8E45103D9_4ADDDFC50302_var*
var
 ltParentNode       : Il3Node;
 ltParentParentNode : Il3Node;
 ltNextNode         : Il3Node;
 ltNextNextNode     : Il3Node;
 lUserParam         : Pointer;
//#UC END# *54C8E45103D9_4ADDDFC50302_var*
//#UC START# *54C8E4FA0325_4ADDDFC50302_impl*
 inherited DoNotify(aOperation, aNode);
 if (f_NotifiedObjList <> nil) then
  for l_Index := 0 to f_NotifiedObjList.Hi do
  begin
   try // - зачем ??!!
    l_Item := IUnknown(f_NotifiedObjList[l_Index]);
    if Supports(l_Item, Il3NodeNotifyRecipient, l_NotifyRecipient) AND
       (l_Item = l_NotifyRecipient) then
     try
      l_NotifyRecipient.Notify(aOperation, aNode);
     finally
      l_NotifyRecipient := nil;
     end;//try..finally
   except
    on E: Exception do
     l3System.Exception2Log(E);
   end;
  end;
//#UC END# *54C8E4FA0325_4ADDDFC50302_impl*
//#UC START# *54C8E4FA0325_4ADDDFC50302_var*
var
 l_Index : Integer;
 l_NotifyRecipient : Il3NodeNotifyRecipient;
 l_Item  : IUnknown;
//#UC END# *54C8E4FA0325_4ADDDFC50302_var*
//#UC START# *54C8E5660144_4ADDDFC50302_impl*
 Result := ChildNode;
 while (Result <> nil) do
 begin
  if aNum = 0 then
   Break
  else
  if aNum <= Result.AllChildrenCount then
  begin
   Result := Result.GetNodeByNumber(aNum);
   Break;
  end
  else Dec(aNum, Succ(Result.AllChildrenCount));
  Result := Result.NextNode;
 end;
//#UC END# *54C8E5660144_4ADDDFC50302_impl*
//#UC START# *54C8E5660144_4ADDDFC50302_var*
//#UC END# *54C8E5660144_4ADDDFC50302_var*
//#UC START# *54C8E5AF00F8_4ADDDFC50302_impl*
 lFromNode := aFromNode;
 if IsSame(lFromNode) then
  lFromNode := nil
 else
  lFromNode := aFromNode;

 if (IterMode and imNoSubRoot > 0) and (lFromNode <> nil) then
 begin
  Result := IterateNoParent(Action, IterMode, lFromNode);
  Exit;
 end;

 Result := nil;
 lParentNeed := l3TestMask(IterMode, imParentNeed);
 IterMode := IterMode or imParentNeed;

 if (IterMode and imChildsBefore > 0) and (IterMode and imNoChilds = 0) and HasChild then
 begin
  if (IterMode and imOneLevel > 0) then
   l3SetMask(IterMode, imNoChilds);
  Result := IterateChild(Action, IterMode, lFromNode);
 end;

 if (Result = nil) and lParentNeed then
 begin
  lCurNode := Self;
{$IfDef SkipIterByExcept}
  try
   if (IterMode and imLeavesOnly > 0) then
   begin
    if (not lCurNode.HasChild) then
     ActionResult := Action(lCurNode)
    else
     ActionResult := False;
   end
   else
    ActionResult := Action(lCurNode);
  except
   on E: ESkipIterateChilds do
   begin
    ActionResult := False;
    l3SetMask(IterMode, imNoChilds);
   end;
   else raise;
  end;
{$Else}
  if (IterMode and imLeavesOnly > 0) then
  begin
   if (not lCurNode.HasChild) then
    ActionResult := Action(lCurNode)
   else
    ActionResult := False;
  end
  else
   ActionResult := Action(lCurNode);

  if Byte(ActionResult) = 2 then
  begin
   ActionResult := False;
   if l3TestMask(IterMode, imCheckResult) then
    l3SetMask(IterMode, imNoChilds);
  end;
{$EndIf}

  if (IterMode and imCheckResult > 0) and ActionResult then
  begin
   Result := lCurNode;
   Exit;
  end;
 end;

 if (IterMode and imChildsBefore = 0) and (IterMode and imNoChilds = 0) and HasChild then
 begin
  if (IterMode and imOneLevel > 0) then
   l3SetMask(IterMode, imNoChilds);
  Result := IterateChild(Action, IterMode, lFromNode);
 end;
//#UC END# *54C8E5AF00F8_4ADDDFC50302_impl*
//#UC START# *54C8E5AF00F8_4ADDDFC50302_var*
var
 lCurNode : Il3Node;
 ActionResult : Boolean;
 lParentNeed : Boolean;
 lFromNode : Il3Node;
//#UC END# *54C8E5AF00F8_4ADDDFC50302_var*
//#UC START# *54C8E60703B6_4ADDDFC50302_impl*
 Changing;
 try
  Result := aChild;
  lNewChild := (aChild as Il3NodeWrap).GetSelf as Tl3Node;
  lNewChild.Parent := Self;
  lNewChild.Use;
  lNewChild.Flags := lNewChild.Flags and not nfWasDisappear;

  if not HasChild then
  begin
   Child := lNewChild;
   //Flags := Flags or nfHasChild;
   lNewChild.Prev := lNewChild;
   lNewChild.Next := lNewChild;
  end
  else
  begin
   if ChildSorted then
   begin
    lNextNode := Child;
    while True do
    begin
     if CompareChild(aChild, lNextNode) < 0 then
     begin
      if Child = lNextNode then
       Child := lNewChild;
      Break;
     end;

     lNextNode := lNextNode.Next;

     if lNextNode.IsFirst then
     begin
      lNextNode := Child;
      Break;
     end;
    end;
   end
   else if aNextChild = nil then
    lNextNode := Child
   else
   begin
    lNextNode := (aNextChild as Il3NodeWrap).GetSelf as Tl3Node;
    if Child = lNextNode then
     Child := lNewChild;
   end;

   //lNextNode := lPrevNode.Next;

   lPrevNode := lNextNode.Prev;
   lPrevNode.Next := lNewChild;
   lNextNode.Prev := lNewChild;
   lNewChild.Next := lNextNode;
   lNewChild.Prev := lPrevNode;
  end;

  {Increment AllChildrenCount}
  IncAllChildrenCount(Succ(aChild.AllChildrenCount));
  Notify(ntInsert, aChild);
 finally
  Changed;
 end;
//#UC END# *54C8E60703B6_4ADDDFC50302_impl*
//#UC START# *54C8E60703B6_4ADDDFC50302_var*
var
 lNewChild : Tl3Node;
 lPrevNode : Tl3Node;
 lNextNode : Tl3Node;
//#UC END# *54C8E60703B6_4ADDDFC50302_var*
//#UC START# *54C8E65102F8_4ADDDFC50302_impl*
 Result := (aChild as Il3NodeWrap).GetSelf is Tl3Node;
//#UC END# *54C8E65102F8_4ADDDFC50302_impl*
//#UC START# *54C8E65102F8_4ADDDFC50302_var*
//#UC END# *54C8E65102F8_4ADDDFC50302_var*
//#UC START# *54CA26F7039B_4ADDDFC50302_impl*
 Result := nil;
 lNext := nil;
 IterMode := IterMode and not imNoSubRoot and not imParentNeed;

 lCNode := aFromNode;
 repeat
  Result := lCNode.Iterate(Action, IterMode, lNext);
  if (Result <> nil) or IsSame(lCNode) then
   Exit;

  while lCNode.IsLast do
  begin
   lCNode := lCNode.ParentNode;
   if IsSame(lCNode) then
    Exit;
  end;

  lNext := lCNode.NextNode;
  lCNode := lCNode.ParentNode;
 until false;
//#UC END# *54CA26F7039B_4ADDDFC50302_impl*
//#UC START# *54CA26F7039B_4ADDDFC50302_var*
var
 lNext: Il3Node;
 lCNode: Il3Node;
//#UC END# *54CA26F7039B_4ADDDFC50302_var*
//#UC START# *54D9E08D0212_4ADDDFC50302_impl*
 inherited;
 if (f_NotifiedObjList <> nil) then
  for l_Index := 0 to f_NotifiedObjList.Hi do
  begin
   try // - зачем ??!!
    l_Item := IUnknown(f_NotifiedObjList[l_Index]);
    if Supports(l_Item, Il3ChangeRecipient, l_Intf) AND
       (l_Item = l_Intf) then
     try
      l_Intf.Changed;
     finally
      l_Intf := nil;
     end;//try..finally
   except
    on E: Exception do
     l3System.Exception2Log(E);
   end;
  end;
//#UC END# *54D9E08D0212_4ADDDFC50302_impl*
//#UC START# *54D9E08D0212_4ADDDFC50302_var*
var
 l_Index : Integer;
 l_Intf  : Il3ChangeRecipient;
 l_Item  : IUnknown;
//#UC END# *54D9E08D0212_4ADDDFC50302_var*
//#UC START# *54D9E09D018D_4ADDDFC50302_impl*
 inherited;
 if (f_NotifiedObjList <> nil) then
  for l_Index := 0 to f_NotifiedObjList.Hi do
  begin
   try // - зачем ??!!
    l_Item := IUnknown(f_NotifiedObjList[l_Index]);
    if Supports(l_Item, Il3ChangeRecipient, l_Intf) AND
       (l_Item = l_Intf) then
     try
      l_Intf.Changing;
     finally
      l_Intf := nil;
     end;//try..finally
   except
    on E: Exception do
     l3System.Exception2Log(E);
   end;
  end;
//#UC END# *54D9E09D018D_4ADDDFC50302_impl*
//#UC START# *54D9E09D018D_4ADDDFC50302_var*
var
 l_Index : Integer;
 l_Intf  : Il3ChangeRecipient;
 l_Item  : IUnknown;
//#UC END# *54D9E09D018D_4ADDDFC50302_var*
