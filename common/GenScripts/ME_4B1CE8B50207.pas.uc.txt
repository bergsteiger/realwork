//#UC START# *479731C50290_4B1CE8B50207_impl*
 f_Handle := -1;
 f_CheckType := Low(f_CheckType);
 FreeAndNil(f_Presentation);
 inherited;
//#UC END# *479731C50290_4B1CE8B50207_impl*
//#UC START# *479731C50290_4B1CE8B50207_var*
//#UC END# *479731C50290_4B1CE8B50207_var*
//#UC START# *47A869D10074_4B1CE8B50207_impl*
 l3Set(f_Caption, Value);
//#UC END# *47A869D10074_4B1CE8B50207_impl*
//#UC START# *47A869D10074_4B1CE8B50207_var*
//#UC END# *47A869D10074_4B1CE8B50207_var*
//#UC START# *4A60B23E00C3_4B1CE8B50207_impl*
 if IID.EQ(Il3NodePainter) then
 begin
  l_P := Presentation;
  if (l_P = nil) OR not l_P.IsValid then
   Result.SetNoInterface
  else
  begin
   Result.SetOk;
   Il3NodePainter(Obj) := TevNodePainter.Make(l_P.AsObject);
  end;//l_P = nil.. 
 end//IID.EQ(Il3NodePainter)
 else
 if IID.EQ(Il3TagRef) then
 begin
  l_P := Presentation;
  if (l_P = nil) OR not l_P.IsValid then
   Result.SetNoInterface
  else
  begin
   Result.SetOk;
   Il3TagRef(Obj) := l_P.AsRef;
  end;//l_P = nil.. 
 end//Il3TagRef
 else
  Result := inherited COMQueryInterface(IID, Obj);
//#UC END# *4A60B23E00C3_4B1CE8B50207_impl*
//#UC START# *4A60B23E00C3_4B1CE8B50207_var*
var
 l_P : Tl3Tag;
//#UC END# *4A60B23E00C3_4B1CE8B50207_var*
//#UC START# *4B1CE85D0167_4B1CE8B50207_impl*
 Result := f_Handle = aID;
//#UC END# *4B1CE85D0167_4B1CE8B50207_impl*
//#UC START# *4B1CE85D0167_4B1CE8B50207_var*
//#UC END# *4B1CE85D0167_4B1CE8B50207_var*
//#UC START# *4B1CE87602C2_4B1CE8B50207get_impl*
 Result := f_Handle;
//#UC END# *4B1CE87602C2_4B1CE8B50207get_impl*
//#UC START# *4B1CE87602C2_4B1CE8B50207get_var*
//#UC END# *4B1CE87602C2_4B1CE8B50207get_var*
//#UC START# *4B1CE8A00198_4B1CE8B50207get_impl*
 Result := f_EType;
//#UC END# *4B1CE8A00198_4B1CE8B50207get_impl*
//#UC START# *4B1CE8A00198_4B1CE8B50207get_var*
//#UC END# *4B1CE8A00198_4B1CE8B50207get_var*
//#UC START# *4B1CE8B50207_ext:ParentFileName
w:\garant6x\implementation\Garant\GbaNemesis\Common\nsEditionNodes.pas
//#UC END# *4B1CE8B50207_ext:ParentFileName
//#UC START# *4B1CE99E0212_4B1CE8B50207_impl*
 inherited Create(nil, -1, -1);
 f_Handle := aHandle;
 f_EType := aEType;
//#UC END# *4B1CE99E0212_4B1CE8B50207_impl*
//#UC START# *4B1CE99E0212_4B1CE8B50207_var*
//#UC END# *4B1CE99E0212_4B1CE8B50207_var*
//#UC START# *4EC25E6B006A_4B1CE8B50207_impl*
 if (f_Presentation = nil) then
 begin
  l_GroupBeginType := Get_GroupBeginType;
  k2_typTextPara.MakeTag.AsObject.SetRef(f_Presentation);
  l_N := ev_psFixLen(IntToStr(EditionNumber), 3, ' ') + ' ';
  l_T := Self.AsPCharLen;
  l_T := CutPrefix('с ', l_T);
  l_CT := l3Trim(l3CStr(l_T));
  l_CT := l3StringReplace(l_CT, l3PCharLen(' по '), l3PCharLen(' - '), []{[rfReplaceAll]});
  l_BracketStr := l3PCharLen(l_CT);
  l_Rest := l3FindChar('(', l_BracketStr);
  f_Presentation.PCharLenA[k2_tiText] := l3PCharLen(l3Cat(l_N, l_CT));
  f_Presentation.IntA[k2_tiStyle] := f1_saEdition;
  l_Segs := f_Presentation.cAtomEx([k2_tiSegments,
                                    k2_tiChildren, k2_tiHandle, Ord(ev_slView)],
                                    nil);
  l_S := k2_typTextSegment.MakeTag.AsObject;
  l_S.IntA[k2_tiStyle] := f1_saEditionNumber;
  l_S.IntA[k2_tiStart] := 1;
  l_S.IntA[k2_tiFinish] := l_S.IntA[k2_tiStart] + Length(l_N) - 1;
  l_Segs.AddChild(l_S.AsObject);
  if not l3IsNil(l_BracketStr) then
  begin
   l_S := k2_typTextSegment.MakeTag.AsObject;
   l_S.IntA[k2_tiStyle] := f1_saEditionInterval;
   l_S.IntA[k2_tiStart] := Length(l_N) + 1;
   if l3IsNil(l_Rest) then
    l_S.IntA[k2_tiFinish] := l_S.IntA[k2_tiStart] + l_BracketStr.SLen - 1
   else
    l_S.IntA[k2_tiFinish] := l_S.IntA[k2_tiStart] + l_BracketStr.SLen - 2;
   l_Segs.AddChild(l_S.AsObject);
  end;//not l3IsNil(l_BracketStr)
  if (l_GroupBeginType <> ns_gbtNone) then
  // - здесь формируем группу
  begin
   l_Block := k2_typNodeGroup.MakeTag.AsObject;
   try
    l_Block.AddChild(f_Presentation);
    Case l_GroupBeginType of
     ns_gbtNew:
      l_Block.PCharLenA[k2_tiShortName] := str_engcNew.AsWStr;
     ns_gbtActual:
      l_Block.PCharLenA[k2_tiShortName] := str_engcActual.AsWStr;
     ns_gbtOld:
      l_Block.PCharLenA[k2_tiShortName] := str_engcOld.AsWStr;
     else
      Assert(false);
    end;//Case l_GroupBeginType
    l_Block.SetRef(f_Presentation);
   finally
    l_Block := nil;
   end;//try..finally
  end;//l_GroupBeginType <> ns_gbtNone
(*  f_Presentation.IntA[k2_tiFirstIndent] := 0;
  f_Presentation.IntA[k2_tiLeftIndent] := 0;
  f_Presentation.IntA[k2_tiJustification] := Ord(ev_itLeft);*)
 end;//f_Presentation = nil
 Result := f_Presentation; 
//#UC END# *4EC25E6B006A_4B1CE8B50207_impl*
//#UC START# *4EC25E6B006A_4B1CE8B50207_var*

 function CutPrefix(const aPref : String; const aStr : Tl3PCharLen): Tl3PCharLen;
 var
  l_Len : Integer;
 begin//CutPrefix
  if l3Starts(aPref, aStr) then
  begin
   l_Len := Length(aPref);
   Result.S := aStr.S + l_Len;
   Result.SLen := aStr.SLen - l_Len;
   Result.SCodePage := aStr.SCodePage;
  end//l3Starts(aPref, aStr)
  else
   Result := aStr;
 end;//CutPrefix

var
 l_CT : Il3CString;
 l_T : Tl3PCharLen;
 l_N : AnsiString;
 l_S : Tl3Variant;
 l_Segs : Tl3Variant;
 l_BracketStr : Tl3PCharLen;
 l_Rest : Tl3PCharLen;
 l_GroupBeginType : TnsEditionNodeGroupBeginType;
 l_Block : Tl3Variant;
//#UC END# *4EC25E6B006A_4B1CE8B50207_var*
//#UC START# *4EC28EB6019F_4B1CE8B50207_impl*
 Result := (ParentNode.ThisChildrenCount - Self.pm_GetIndexInParent){ + 1};
//#UC END# *4EC28EB6019F_4B1CE8B50207_impl*
//#UC START# *4EC28EB6019F_4B1CE8B50207_var*
//#UC END# *4EC28EB6019F_4B1CE8B50207_var*
//#UC START# *4EC3AD4E008E_4B1CE8B50207get_impl*
 Result := f_CheckType;
//#UC END# *4EC3AD4E008E_4B1CE8B50207get_impl*
//#UC START# *4EC3AD4E008E_4B1CE8B50207get_var*
//#UC END# *4EC3AD4E008E_4B1CE8B50207get_var*
//#UC START# *4EC3AD4E008E_4B1CE8B50207set_impl*
 f_CheckType := aValue;
//#UC END# *4EC3AD4E008E_4B1CE8B50207set_impl*
//#UC START# *4EC3AD4E008E_4B1CE8B50207set_var*
//#UC END# *4EC3AD4E008E_4B1CE8B50207set_var*
//#UC START# *4EC3B6EC02BB_4B1CE8B50207_impl*
 // - тут надо проверить хитрую логику с "Ведущей" и "Дополнительной"
 aTree.Changing;
 try
  if (f_CheckType = ns_enctUnchecked) then
  begin
   if not Supports(Self.Get_Parent, IDocument, l_D) then
    Assert(false);
   l_D.GetCurrentState(l_State);
   if l_State.CanCompareWithAnyOtherRedaction then
   // http://mdp.garant.ru/pages/viewpage.action?pageId=318374263
   begin
    if not HasMainChecked(aTree) then
     f_CheckType := ns_enctMain
    else
    begin
     UncheckAllAdditional(aTree);
     f_CheckType := ns_enctAdditional;
    end;//not HasMainChecked(aTree)
   end;//l_State.CanCompareWithAnyOtherRedaction
  end//f_CheckType = ns_enctUnchecked
  else
  if (f_CheckType = ns_enctMain) then
   f_CheckType := ns_enctUnchecked
  else
   f_CheckType := ns_enctUnchecked;
 finally
  aTree.Changed;
 end;//try..finally
//#UC END# *4EC3B6EC02BB_4B1CE8B50207_impl*
//#UC START# *4EC3B6EC02BB_4B1CE8B50207_var*
var
 l_D : IDocument;
 l_State : IDocumentState;
//#UC END# *4EC3B6EC02BB_4B1CE8B50207_var*
//#UC START# *4EC3C9D20140_4B1CE8B50207_impl*
 if (f_CheckType <> ns_enctMain) then
 begin
  if not Supports(Self.Get_Parent, IDocument, l_D) then
   Assert(false);
  l_D.GetCurrentState(l_State);
  if l_State.CanCompareWithAnyOtherRedaction then
  // http://mdp.garant.ru/pages/viewpage.action?pageId=318374263
   if not HasMainChecked(aTree) then
   begin
    aTree.Changing;
    try
     Assert(f_CheckType <> ns_enctAdditional);
     // - если вдруг сломается, то надо думать над UncheckAllAdditional(aTree) что ли
     f_CheckType := ns_enctMain;
    finally
     aTree.Changed;
    end;//try..finally
   end;//not HasMainChecked(aTree)
 end;//f_CheckType <> ns_enctMain
//#UC END# *4EC3C9D20140_4B1CE8B50207_impl*
//#UC START# *4EC3C9D20140_4B1CE8B50207_var*
var
 l_D : IDocument;
 l_State : IDocumentState;
//#UC END# *4EC3C9D20140_4B1CE8B50207_var*
//#UC START# *4EC3CA120205_4B1CE8B50207_impl*
 Result := false;
 aTree.SimpleIterateF(l3L2SNA(@DoFind), imCheckResult);
//#UC END# *4EC3CA120205_4B1CE8B50207_impl*
//#UC START# *4EC3CA120205_4B1CE8B50207_var*

 function DoFind(const anIntf: Il3SimpleNode) : Boolean;
 var
  l_Node : InsEditionNode;
 begin//DoFind
  Result := false;
  if Supports(anIntf, InsEditionNode, l_Node) then
   try
    if (l_Node.CheckType = ns_enctMain) then
    begin
     Result := true;
     HasMainChecked := true;
    end;//l_Node.CheckType = ns_enctMain
   finally
    l_Node := nil;
   end;//try..finally
 end;//DoFind

//#UC END# *4EC3CA120205_4B1CE8B50207_var*
//#UC START# *4EC3D2720139_4B1CE8B50207_impl*
 aTree.SimpleIterateF(l3L2SNA(@DoUncheck), 0{imCheckResult});
//#UC END# *4EC3D2720139_4B1CE8B50207_impl*
//#UC START# *4EC3D2720139_4B1CE8B50207_var*

 procedure DoUncheck(const anIntf: Il3SimpleNode);
 var
  l_Node : InsEditionNode;
 begin//DoUncheck
  if Supports(anIntf, InsEditionNode, l_Node) then
   try
    if (l_Node.CheckType = ns_enctAdditional) then
     l_Node.CheckType := ns_enctUnchecked;
   finally
    l_Node := nil;
   end;//try..finally
 end;//DoUncheck

//#UC END# *4EC3D2720139_4B1CE8B50207_var*
//#UC START# *4EC3D5F002E1_4B1CE8B50207_impl*
 Result := HasMainChecked(aTree) AND HasAdditionalChecked(aTree);
//#UC END# *4EC3D5F002E1_4B1CE8B50207_impl*
//#UC START# *4EC3D5F002E1_4B1CE8B50207_var*
//#UC END# *4EC3D5F002E1_4B1CE8B50207_var*
//#UC START# *4EC3D6300158_4B1CE8B50207_impl*
 Result := false;
 aTree.SimpleIterateF(l3L2SNA(@DoFind), imCheckResult);
//#UC END# *4EC3D6300158_4B1CE8B50207_impl*
//#UC START# *4EC3D6300158_4B1CE8B50207_var*

 function DoFind(const anIntf: Il3SimpleNode) : Boolean;
 var
  l_Node : InsEditionNode;
 begin//DoFind
  Result := false;
  if Supports(anIntf, InsEditionNode, l_Node) then
   try
    if (l_Node.CheckType = ns_enctAdditional) then
    begin
     Result := true;
     HasAdditionalChecked := true;
    end;//l_Node.CheckType = ns_enctMain
   finally
    l_Node := nil;
   end;//try..finally
 end;//DoFind

//#UC END# *4EC3D6300158_4B1CE8B50207_var*
//#UC START# *4EC4E7BF029B_4B1CE8B50207_impl*
 l_Main := nil;
 l_Additional := nil;
 l_MainE := nil;
 l_AdditionalE := nil;
 aTree.SimpleIterateF(l3L2SNA(@DoFind), imCheckResult);
 if (l_MainE <> nil) AND (l_AdditionalE <> nil) then
 begin
  if (l_Main.IndexInParent > l_Additional.IndexInParent) then
  begin
   l3Swap(Pointer(l_Main), Pointer(l_Additional));
   l3Swap(Pointer(l_MainE), Pointer(l_AdditionalE));
  end;//l_Main.IndexInParent > l_Additional.IndexInParent
  if not Supports(l_Main.Parent, IDocument, l_D) then
   Assert(false);
  l_D.GetCurrentState(l_State);
  l_State.Clone(l_LeftState);
  l_State.Clone(l_RightState);
  l_LeftState.SetRedactionOnId(l_AdditionalE.EditionID);
  l_RightState.SetRedactionOnId(l_MainE.EditionID);
  l_D.CreateView(l_LeftState, aLeft);
  if (aLeft = nil) then
   aLeft := l_D;
  l_D.CreateView(l_RightState, aRight);
  if (aRight = nil) then
   aRight := l_D;
 end;//l_MainE <> nil
//#UC END# *4EC4E7BF029B_4B1CE8B50207_impl*
//#UC START# *4EC4E7BF029B_4B1CE8B50207_var*
var
 l_Main : Il3SimpleNode;
 l_Additional : Il3SimpleNode;
 l_MainE : InsEditionNode;
 l_AdditionalE : InsEditionNode;

 function DoFind(const anIntf: Il3SimpleNode) : Boolean;
 var
  l_Node : InsEditionNode;
 begin//DoFind
  Result := false;
  if Supports(anIntf, InsEditionNode, l_Node) then
   try
    if (l_Node.CheckType = ns_enctMain) then
    begin
     l_Main := anIntf;
     l_MainE := l_Node;
    end//l_Node.CheckType = ns_enctMain
    else
    if (l_Node.CheckType = ns_enctAdditional) then
    begin
     l_Additional := anIntf;
     l_AdditionalE := l_Node;
    end//l_Node.CheckType = ns_enctAdditional
    else
     Exit;
    Result := (l_MainE <> nil) AND (l_AdditionalE <> nil);
   finally
    l_Node := nil;
   end;//try..finally
 end;//DoFind

var
 l_D : IDocument;
 l_State : IDocumentState;
 l_LeftState : IDocumentState;
 l_RightState : IDocumentState;
//#UC END# *4EC4E7BF029B_4B1CE8B50207_var*
//#UC START# *4ED4B9680283_4B1CE8B50207get_impl*
 Result := ns_gbtNone;
 if Self.IsFirst then
 // - т.к. ноды у Вована - закольцованы
  l_Prev := nil
 else
  l_Prev := Self.PrevNode;
 Case f_EType of
  RT_ACTUAL,
  RT_ACTUAL_ABOLISHED,
  RT_ACTUAL_PREACTIVE:
   if (l_Prev = nil) OR (PrevGroupBeginType <> ns_gbtActual) then
    Result := ns_gbtActual;
  RT_OLD:
   if (l_Prev = nil) OR (PrevGroupBeginType <> ns_gbtOld) then
    Result := ns_gbtOld;
  RT_NEW,
  RT_NEW_ABOLISHED,
  RT_NEW_PREACTIVE:
   if (l_Prev = nil) OR (PrevGroupBeginType <> ns_gbtNew) then
    Result := ns_gbtNew;
  else
   Assert(false);
 end;//f_EType
//#UC END# *4ED4B9680283_4B1CE8B50207get_impl*
//#UC START# *4ED4B9680283_4B1CE8B50207get_var*
var
 l_Prev : Il3Node;

 function PrevGroupBeginType: TnsEditionNodeGroupBeginType;
 var
  l_Node : InsEditionNode;
 begin//PrevGroupBeginType
  if not Supports(l_Prev, InsEditionNode, l_Node) then
   Assert(false)
  else
   try
(*    Result := l_Node.GroupBeginType;*)
    Case l_Node.EditionType of
     RT_ACTUAL,
     RT_ACTUAL_ABOLISHED,
     RT_ACTUAL_PREACTIVE:
      Result := ns_gbtActual;
     RT_OLD:
      Result := ns_gbtOld;
     RT_NEW,
     RT_NEW_ABOLISHED,
     RT_NEW_PREACTIVE:
      Result := ns_gbtNew;
     else
     begin
      Assert(false);
      Result := ns_gbtNone;
     end;//else
    end;//Case l_Node.EditionType
   finally
    l_Node := nil;
   end;//try..finally
 end;//PrevGroupBeginType

//#UC END# *4ED4B9680283_4B1CE8B50207get_var*
//#UC START# *54C78D9201B9_4B1CE8B50207_impl*
 Result := inherited GetIsSame(aNode);
 if not Result then begin
  if Supports(aNode, InsEditionNode, l_EditionNode) then
   try
    Result := l_EditionNode.IsSameID(f_Handle);
   finally
    l_EditionNode := nil;
   end;//try..finally
 end;//not Result
//#UC END# *54C78D9201B9_4B1CE8B50207_impl*
//#UC START# *54C78D9201B9_4B1CE8B50207_var*
var
 l_EditionNode: InsEditionNode;
//#UC END# *54C78D9201B9_4B1CE8B50207_var*
