//#UC START# *4836D4650177_4C56D4E002D2_impl*
 if (TypeID = k2_typBlock) and (SkipLevel = 2) then
 begin
  f_NeedToReport := True;
  StopBufferingAndFlush(False, TopObject[0], False);
 end;
 inherited StartChild(TypeID);
//#UC END# *4836D4650177_4C56D4E002D2_impl*
//#UC START# *4836D4650177_4C56D4E002D2_var*
//#UC END# *4836D4650177_4C56D4E002D2_var*
//#UC START# *4836D4C20059_4C56D4E002D2_impl*
 if CurrentType.IsKindOf(k2_typLeafPara) and (SkipLevel = 3) then
 begin
  l_Para := f_Buffer.Tags.Top^.Box;
  if l3IsNil(l_Para.PCharLenA[k2_tiText]) then
  begin
   if not f_NeedToReport then
   begin
    // "выносим" пустой параграф за буфер, то есть "наверх"
    Generator.StartChild(l_Para.TagType);
    try
     l_Para.WriteTag(Generator);
    finally
     Generator.Finish;
    end;
    // удаляем параграф
    inherited;
    with f_Buffer.Tags.Top^.Box do
     DeleteChild(Pred(ChildrenCount));
   end
   else
   begin
    // параграф пустой, но его нельзя вытащить
    inherited;
    l_ID := f_Buffer.Tags.Top^.Box.IntA[k2_tiHandle];
    l3System.Msg2Log('Невозможно поднять пустой параграф в блоке %d', [l_ID]);
   end;
  end
  else
   inherited;
  // прекращаем буферизацию
  StopBufferingAndFlush(NeedUndo, TopObject[SkipLevel-2], False);
  f_NeedToReport := False;
 end
 else
  inherited;
//#UC END# *4836D4C20059_4C56D4E002D2_impl*
//#UC START# *4836D4C20059_4C56D4E002D2_var*
var
 l_Para: Tl3Variant;
 l_ID: Integer;
//#UC END# *4836D4C20059_4C56D4E002D2_var*
//#UC START# *4C56D54B002A_4C56D4E002D2_impl*
 Result := (aID < 0) and (aID = -k2_idBlock);//TypeTable.TypeByHandle[-aID].IsKindOf(k2_typBlock);
//#UC END# *4C56D54B002A_4C56D4E002D2_impl*
//#UC START# *4C56D54B002A_4C56D4E002D2_var*
//#UC END# *4C56D54B002A_4C56D4E002D2_var*
