//#UC START# *46A4504B03C4_4C7E651B0179_impl*
 case TbsNotification(aOperation) of
  nConsultation:
   case TbsConsultationOperation(aIndex) of
    coUnreadChanged:
     FoldersTree.Invalidate;
   end;//case TbsConsultationOperation(aIndex) of
 end;//case TbsNotification(aOperation) of
//#UC END# *46A4504B03C4_4C7E651B0179_impl*
//#UC START# *46A4504B03C4_4C7E651B0179_var*
//#UC END# *46A4504B03C4_4C7E651B0179_var*
//#UC START# *49803F5503AA_4C7E651B0179_impl*
 inherited;
 f_FilterMap := nsIntegerMapManager.Map[imap_FolderFilters];
//#UC END# *49803F5503AA_4C7E651B0179_impl*
//#UC START# *49803F5503AA_4C7E651B0179_var*
//#UC END# *49803F5503AA_4C7E651B0179_var*
//#UC START# *49901C9600DD_4C7E651B0179_impl*
 op_UsersRights_UpdateRights.Call(Aggregate, aNode As IeeNode);
 op_FolderElement_SetContent.Call(Aggregate, FoldersTree.TreeView.CurrentNode);
//#UC END# *49901C9600DD_4C7E651B0179_impl*
//#UC START# *49901C9600DD_4C7E651B0179_var*
//#UC END# *49901C9600DD_4C7E651B0179_var*
//#UC START# *4AC3803A03CD_4C7E651B0179_impl*
 Windows.SetFocus(FoldersTree.Handle);
//#UC END# *4AC3803A03CD_4C7E651B0179_impl*
//#UC START# *4AC3803A03CD_4C7E651B0179_var*
//#UC END# *4AC3803A03CD_4C7E651B0179_var*
//#UC START# *4AE718F90254_4C7E651B0179_impl*
 Result := True;
 if (Aggregate <> nil) then
 begin
  if IsInSaveLoadState then
  begin
   //Assert(False, 'http://mdp.garant.ru/pages/viewpage.action?pageId=452373109&focusedCommentId=492624070#comment-492624070');
   //Нашлось:    http://mdp.garant.ru/pages/viewpage.action?pageId=506710748
   l_Coord  := FoldersTree.GetDrawTextRect(FoldersTree.TreeView.GoToNode(aNode));
   with l_Coord do
   begin
    TopLeft := FoldersTree.ClientToScreen(TopLeft);
    BottomRight := FoldersTree.ClientToScreen(BottomRight);
   end;
   Result := (TFoldersService.Instance.EditInfoOpen(IsNewFolder, aNode, TnsFormCoordinates.Make(l_Coord)) = mrOk);
  end//IsInSaveLoadState
  else
  begin
   FoldersTree.Changing;
   try
    if IsNewFolder then
     Op_FolderElement_SetState.Call(Aggregate, fiNewFolder)
    else
     Op_FolderElement_SetState.Call(Aggregate, fiEdit);
    Op_FolderElement_SetContent.Call(Aggregate, aNode, IsNewFolder);
    Op_AdditionInfo_Show.Call(Aggregate);
    if WithPositioning then
     FoldersTree.TreeView.GoToNode(aNode);
   finally
    FoldersTree.Changed;
   end;//try..finally
  end;//IsInSaveLoadState
 end;//Aggregate <> nil
//#UC END# *4AE718F90254_4C7E651B0179_impl*
//#UC START# *4AE718F90254_4C7E651B0179_var*
var
 l_Coord  : TRect;
//#UC END# *4AE718F90254_4C7E651B0179_var*
//#UC START# *4AE7192B023C_4C7E651B0179_impl*
 if Aggregate <> nil then
 begin
  op_FolderElement_SetContent.Call(Aggregate, aNode);
  Aggregate.Operation(opcode_AdditionInfo_Hide);
 end;//Aggregate <> nil
//#UC END# *4AE7192B023C_4C7E651B0179_impl*
//#UC START# *4AE7192B023C_4C7E651B0179_var*
//#UC END# *4AE7192B023C_4C7E651B0179_var*
//#UC START# *4AE71F530142_4C7E651B0179_impl*
 Result := drCancel;
 if (dsFoldersTree <> nil) and
  dsFoldersTree.IsConsultation(aNode As Il3SimpleNode) then
 begin
  if Ask(qr_ObjectDelete, [aNode.Text]) then
  begin
   try
    dsFoldersTree.DeleteConsultation(aNode As Il3SimpleNode);
    Result := drOk;
   except
    on ECanNotFindData do
     Ask(inf_ConsultationAlreadyDelete);
   end;
  end;
 end//dsFoldersTree <> nil 
 else
  if CheckFolderElementRights(aNode, faDelete) then
   with FoldersTree.TreeView do
   begin
    Result := drCancel;
    if (aNode.NextNode <> nil) and
        not l3IEQ(aNode, aNode.NextNode) and
        not l3IEQ(aNode.ParentNode.ChildNode, aNode.NextNode) then
     l_newCurrentNode := aNode.NextNode
    else
     if (aNode.PrevNode <> nil) and
        not l3IEQ(aNode, aNode.PrevNode) then
      l_newCurrentNode := aNode.PrevNode
     else
      l_newCurrentNode := aNode.ParentNode;

    if aAskConfirmation then
    begin
     Supports(aNode, INode, l_AdapterNode);
     try
      if aNode.HasChild then
      begin
       {if (l_AdapterNode <> nil) and
          DefDataAdapter.Folders.IsLastUnderControl(l_AdapterNode as IFoldersNode) then
        l_Desision := Ask(qr_DeleteControlledFolder)
       else
       begin !STUB!  Это не нужно, т.к. теперь на контроле не связаны с папками}
        l_AdapterNode.GetCaption(l_String);
        try
         l_Desision := Ask(qr_ObjectDelete, [nsCStr(l_String)]);
        finally
         l_String := nil;
        end;//try..finally
       {end;}
      end//aNode.HasChild
      else
      if (l_AdapterNode <> nil) and
         (TFoldersItemType(l_AdapterNode.GetObjectType) <> FIT_FOLDER) then
      begin
       {if DefDataAdapter.Folders.IsLastUnderControl(l_AdapterNode as IFoldersNode) then
        l_Desision := Ask(qr_DeleteControlledObject, [l3CStr(aNode)])
       else !STUB!  Это не нужно, т.к. теперь на контроле не связаны с папками}
        l_Desision := Ask(qr_ObjectDelete, [aNode.Text]);
      end//l_AdapterNode <> nil..
      else
       l_Desision := Ask(qr_FolderEmptyQuery, [aNode.Text]);
     finally
      l_AdapterNode := nil;
     end;
    end
    else
     l_Desision := True;

    if l_Desision then
    begin
     aNode.Delete;
     Result := drOk;
    end;

    if (Result = drOk) and
       (l_newCurrentNode <> nil) then
    begin
     l_OldCurrent := Current;
     GoToNode(l_newCurrentNode);
     DoFoldersTreeCurrentChanged(self, Current, l_OldCurrent);
    end;
   end
  else
   Result := drDenied;
//#UC END# *4AE71F530142_4C7E651B0179_impl*
//#UC START# *4AE71F530142_4C7E651B0179_var*
var
 l_OldCurrent     : Integer;
 l_newCurrentNode : IeeNode;
 l_AdapterNode    : INode;
 l_Desision       : Boolean;
 l_String         : IString;
//#UC END# *4AE71F530142_4C7E651B0179_var*
//#UC START# *4AF2F5E50289_4C7E651B0179_impl*
 Result := FoldersInfo;
//#UC END# *4AF2F5E50289_4C7E651B0179_impl*
//#UC START# *4AF2F5E50289_4C7E651B0179_var*
//#UC END# *4AF2F5E50289_4C7E651B0179_var*
//#UC START# *4BDAF7880236_4C7E651B0179exec_impl*
 FoldersTree.TreeView.Tree.Changing;
 try
  aParams.CallControl;
 finally
  FoldersTree.TreeView.Tree.Changed;
 end;
//#UC END# *4BDAF7880236_4C7E651B0179exec_impl*
//#UC START# *4BDAF7880236_4C7E651B0179exec_var*
//#UC END# *4BDAF7880236_4C7E651B0179exec_var*
//#UC START# *4BDAF7880236_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := FoldersTree.TreeView.Current >= 0;
//#UC END# *4BDAF7880236_4C7E651B0179test_impl*
//#UC START# *4BDAF7880236_4C7E651B0179test_var*
//#UC END# *4BDAF7880236_4C7E651B0179test_var*
//#UC START# *4BDAF7A2005C_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := FoldersTree.TreeView.Current >= 0;
//#UC END# *4BDAF7A2005C_4C7E651B0179test_impl*
//#UC START# *4BDAF7A2005C_4C7E651B0179test_var*
//#UC END# *4BDAF7A2005C_4C7E651B0179test_var*
//#UC START# *4C3F3421036A_4C7E651B0179exec_impl*
 with FoldersTree.TreeView do
 begin
  l_eeNode := CurrentNode;
  try
   if Supports(l_eeNode, INode, l_AdapterNode) then
    try
     try
      l_AdapterNode.Open(l_BaseEntity);
     except
      on ECanNotFindData do
       exit; //TODO: нода "пропала" что делать?
     end;
     try
      OpenQuery(l_BaseEntity);
     finally
      l_BaseEntity := nil;
     end;
    finally
     l_AdapterNode := nil;
    end;
  finally
   l_eeNode := nil;
  end;
 end;
//#UC END# *4C3F3421036A_4C7E651B0179exec_impl*
//#UC START# *4C3F3421036A_4C7E651B0179exec_var*
var
 l_eeNode      : IeeNode;
 l_AdapterNode : INode;
 l_BaseEntity  : IUnknown;
//#UC END# *4C3F3421036A_4C7E651B0179exec_var*
//#UC START# *4C3F3421036A_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := not IsInSaveLoadState and
  Supports(FoldersTree.TreeView.CurrentNode, INode, l_Node) and
  (TFoldersItemType(l_Node.GetObjectType) = FIT_QUERY) and
  (l_Node.GetFlags and NF_IN_COMMENTS = 0);
//#UC END# *4C3F3421036A_4C7E651B0179test_impl*
//#UC START# *4C3F3421036A_4C7E651B0179test_var*
var
 l_Node: INode;
//#UC END# *4C3F3421036A_4C7E651B0179test_var*
//#UC START# *4C3F342E02AF_4C7E651B0179exec_impl*
 with FoldersTree.TreeView do
 begin
  l_eeNode := CurrentNode;
  try
   if Supports(l_eeNode, INode, l_AdapterNode) then
    try
     try
      l_AdapterNode.Open(l_BaseEntity);
     except
      on ECanNotFindData do
       Exit; //TODO: нода "пропала" что делать?
     end;
     Assert(l_BaseEntity <> nil);
     try
      l_Query := l_BaseEntity As IQuery;
      try
       if l_Query.GetType = QT_BASE_SEARCH then
        OpenQuery(l_Query);
       nsSearch(l_Query, nil, nil, NativeMainForm);
      finally
       l_Query := nil;
      end;
     finally
      l_BaseEntity := nil;
     end;//try..finally
    finally
     l_AdapterNode := nil;
    end;//try..finally
  finally
   l_eeNode := nil;
  end;//try..finally
 end;//with FoldersTree.TreeView
//#UC END# *4C3F342E02AF_4C7E651B0179exec_impl*
//#UC START# *4C3F342E02AF_4C7E651B0179exec_var*
var
 l_eeNode : IeeNode;
 l_AdapterNode : INode;
 l_BaseEntity : IUnknown;
 l_Query: IQuery;
//#UC END# *4C3F342E02AF_4C7E651B0179exec_var*
//#UC START# *4C3F342E02AF_4C7E651B0179test_impl*
 SavedQuery_OpenQuery_Test(aParams);
//#UC END# *4C3F342E02AF_4C7E651B0179test_impl*
//#UC START# *4C3F342E02AF_4C7E651B0179test_var*
//#UC END# *4C3F342E02AF_4C7E651B0179test_var*
//#UC START# *4C7D0CC90052_4C7E651B0179exec_impl*
 FolderElement_InternalDelete_Execute(nil);
//#UC END# *4C7D0CC90052_4C7E651B0179exec_impl*
//#UC START# *4C7D0CC90052_4C7E651B0179exec_var*
//#UC END# *4C7D0CC90052_4C7E651B0179exec_var*
//#UC START# *4C7D0CC90052_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := (dsFoldersTree <> nil) and dsFoldersTree.CanDelete(FoldersTree.GetCurrentNode);
//#UC END# *4C7D0CC90052_4C7E651B0179test_impl*
//#UC START# *4C7D0CC90052_4C7E651B0179test_var*
//#UC END# *4C7D0CC90052_4C7E651B0179test_var*
//#UC START# *4C7E651B0179_ext:FileName
w:\garant6x\implementation\Garant\GbaNemesis\View\Folders\Forms\PrimFoldersTreeOptions_Form.pas
//#UC END# *4C7E651B0179_ext:FileName
//#UC START# *4C7E651B0179impl_uses*
 , Base_Operations_F1Services_Contracts
//#UC END# *4C7E651B0179impl_uses*
//#UC START# *4C7E65DF016E_4C7E651B0179exec_impl*
 l_FoldersInfo := FoldersInfo;
 if (l_FoldersInfo <> nil) then
  try
   l_Index := aParams.ItemIndex;
   if (l_Index >= 0) then
   begin
    l_FoldersInfo.CantChangeFilter := False;
    if (f_OldFilter = -1) then
     f_OldFilter := Byte(l_FoldersInfo.FilterInfo.FilterType);
    l_FoldersInfo.FilterInfo.FilterType := TnsFolderFilter(l_Index);
   end//l_Index >= 0
   else
    l_FoldersInfo.FilterInfo.FilterType := TnsFolderFilter(f_FilterMap.
     DisplayNameToValue(aParams.SelectedString));
   if (FoldersTree.TreeView.Current < 0) then
   // - если отфильтровалось все - то сбрасываем текущий у формы со свойствами.
    op_FolderElement_SetContent.Call(Aggregate, nil);
  finally
   l_FoldersInfo := nil;
  end;//try..finally
//#UC END# *4C7E65DF016E_4C7E651B0179exec_impl*
//#UC START# *4C7E65DF016E_4C7E651B0179exec_var*
var
 l_FoldersInfo : InsFoldersInfo;
 l_Index       : Integer;
//#UC END# *4C7E65DF016E_4C7E651B0179exec_var*
//#UC START# *4C7E65DF016E_4C7E651B0179test_impl*
 l_FoldersInfo := FoldersInfo;
 if l_FoldersInfo <> nil then
  try
   aParams.Op.Flag[vcm_ofEnabled] := not l_FoldersInfo.CantChangeFilter;
   if l_FoldersInfo.CantChangeFilter then
    aParams.Op.Font.ForeColor := clLtGray
   else
    aParams.Op.Font.ForeColor := clBlack;

   l_Strings := aParams.Op.SubItems;
   if (l_Strings <> nil) then
   begin
    aParams.Op.SelectedString := f_FilterMap.
     ValueToDisplayName(ord(l_FoldersInfo.FilterInfo.FilterType));
    if l_Strings.Count = 0 then
     if Supports(f_FilterMap, InsStringsSource, l_StringSource) then
      l_StringSource.FillStrings(l_Strings);
   end;
  finally
   l_FoldersInfo := nil;
  end
 else
  aParams.Op.Flag[vcm_ofEnabled] := False;
//#UC END# *4C7E65DF016E_4C7E651B0179test_impl*
//#UC START# *4C7E65DF016E_4C7E651B0179test_var*
var
 l_Strings     : IvcmStrings;
 l_FoldersInfo : InsFoldersInfo;
 l_StringSource: InsStringsSource;
//#UC END# *4C7E65DF016E_4C7E651B0179test_var*
//#UC START# *4C7E66850144_4C7E651B0179exec_impl*
 with FoldersTree.TreeView do
 begin
  l_CurRoot := GetCurrentFolder(CurrentNode);
  if l_CurRoot = nil then
   l_CurRoot := Tree.Root;
  try
   l_CurFolder := UserFoldersTree.CreateFolder(CreateUniqName(l_CurRoot),
                                               l_CurRoot as Il3Node,
                                               nil,
                                               nsFindInsertPosition(l_CurRoot as Il3Node,
                                                                    nil,
                                                                    True)) as IeeNode;

   if l_CurFolder <> nil then
    try
     if not BeginEdit(l_CurFolder, True, True) then
      DeleteNode(l_CurFolder, False);
    finally
     l_CurFolder := nil;
    end;
  finally
   l_CurRoot := nil;
  end;
 end;
//#UC END# *4C7E66850144_4C7E651B0179exec_impl*
//#UC START# *4C7E66850144_4C7E651B0179exec_var*
var
 l_CurFolder,
 l_CurRoot: IeeNode;
//#UC END# *4C7E66850144_4C7E651B0179exec_var*
//#UC START# *4C7E66850144_4C7E651B0179test_impl*
 if Aggregate <> nil then
 begin
  if (Op_FolderElement_GetState.Call(Aggregate) in [fiLoad, fiSelect]) then
   aParams.Op.Flag[vcm_ofEnabled] := False
  else
   with FoldersTree.TreeView do
   begin
    l_eeNode := GetCurrentFolder(CurrentNode);
    try
     if (l_eeNode <> nil) and (l_eeNode.GetLevelForParent(Tree.Root) < cMaxFoldersDepth) then
      aParams.Op.Flag[vcm_ofEnabled] := CheckFolderElementRights(l_eeNode, faAddChild)
     else
      aParams.Op.Flag[vcm_ofEnabled] := False;
    finally
     l_eeNode := nil;
    end;
   end;
 end
 else
  aParams.Op.Flag[vcm_ofEnabled] := True;
//#UC END# *4C7E66850144_4C7E651B0179test_impl*
//#UC START# *4C7E66850144_4C7E651B0179test_var*
var
 l_eeNode : IeeNode;
//#UC END# *4C7E66850144_4C7E651B0179test_var*
//#UC START# *4C7E66990246_4C7E651B0179exec_impl*
 if Ask(qr_SetControlStatus) then
  FoldersTree.TreeView.CurrentNode.IterateF(eeL2NA(@SetControlStatus));
//#UC END# *4C7E66990246_4C7E651B0179exec_impl*
//#UC START# *4C7E66990246_4C7E651B0179exec_var*

 function SetControlStatus(const anIntf: IeeNode) : Boolean;
 var
  l_FoldersNode : InsFoldersNode;
 begin
  if Supports(anIntf, InsFoldersNode, l_FoldersNode) then
   try
    l_FoldersNode.SetUnderControlStatus(True);
   finally
    l_FoldersNode := nil;
   end;

  Result := False;
 end;

//#UC END# *4C7E66990246_4C7E651B0179exec_var*
//#UC START# *4C7E66990246_4C7E651B0179test_impl*
 with FoldersTree.TreeView do
  aParams.Op.Flag[vcm_ofEnabled] := (Current < 0) and
   Assigned(Aggregate) and not IsInSaveLoadState and
   Supports(CurrentNode, INode, l_Node) and
   (TFoldersItemType(l_Node.GetObjectType) = FIT_FOLDER) and
   not nsHasNodeAnyFlag(CurrentNode, [affExternal, affInComment]);
//#UC END# *4C7E66990246_4C7E651B0179test_impl*
//#UC START# *4C7E66990246_4C7E651B0179test_var*
var
 l_Node: INode;
//#UC END# *4C7E66990246_4C7E651B0179test_var*
//#UC START# *4C7E66B102FB_4C7E651B0179exec_impl*
 if Ask(qr_DelControlStatus) then
  FoldersTree.TreeView.CurrentNode.IterateF(eeL2NA(@SetControlStatus));
//#UC END# *4C7E66B102FB_4C7E651B0179exec_impl*
//#UC START# *4C7E66B102FB_4C7E651B0179exec_var*

 function SetControlStatus(const anIntf: IeeNode) : Boolean;
 var
  l_FoldersNode : InsFoldersNode;
 begin
  if Supports(anIntf, InsFoldersNode, l_FoldersNode) then
   try
    l_FoldersNode.SetUnderControlStatus(False);
   finally
    l_FoldersNode := nil;
   end;

  Result := False;
 end;

//#UC END# *4C7E66B102FB_4C7E651B0179exec_var*
//#UC START# *4C7E66B102FB_4C7E651B0179test_impl*
 Folder_AddToControl_Test(aParams);
//#UC END# *4C7E66B102FB_4C7E651B0179test_impl*
//#UC START# *4C7E66B102FB_4C7E651B0179test_var*
//#UC END# *4C7E66B102FB_4C7E651B0179test_var*
//#UC START# *4C7E66C70264_4C7E651B0179exec_impl*
 FoldersTree.Changing;
 try
  DoSetShare(FoldersTree.TreeView.CurrentNode);
  if Supports(FoldersTree.TreeView.CurrentNode, INode, l_Node) then
  try
   UserFoldersTree.DropUserRightsCache(l_Node);
  finally
   l_Node := nil;
  end;
 finally
  FoldersTree.Changed;
 end;
//#UC END# *4C7E66C70264_4C7E651B0179exec_impl*
//#UC START# *4C7E66C70264_4C7E651B0179exec_var*
var
 l_Node : INode;
//#UC END# *4C7E66C70264_4C7E651B0179exec_var*
//#UC START# *4C7E66C70264_4C7E651B0179test_impl*
 // Enabled
 with FoldersTree.TreeView do
  aParams.Op.Flag[vcm_ofEnabled] := not IsInSaveLoadState and
   Supports(CurrentNode, INode, l_Node) and
   CheckFolderElementRights(CurrentNode, faChangeRights) and
   not (l_Node.GetFlags and NF_IN_SHARED = NF_IN_SHARED);
 // Checked
 if aParams.Op.Flag[vcm_ofEnabled] then
   aParams.Op.Flag[vcm_ofChecked] := (l_Node.GetFlags and NF_SHARED = NF_SHARED);
//#UC END# *4C7E66C70264_4C7E651B0179test_impl*
//#UC START# *4C7E66C70264_4C7E651B0179test_var*
var
 l_Node: INode;
//#UC END# *4C7E66C70264_4C7E651B0179test_var*
//#UC START# *4C7E66DC00F5_4C7E651B0179exec_impl*
 if (dsFoldersTree <> nil) then
 begin
  l_FO := TvtSaveDialog.Create(Self);
  try
   with l_FO do
   begin
    Options := Options + [ofOverwritePrompt, ofPathMustExist];
    Filter := vcmConstString(str_FolderFilter);
    Title := vcmConstString(str_ExportFolderTitle);
    DefaultExt := vcmConstString(str_XMLFileExtension);
    FilterIndex := 1;
    FileName := l3PStr(nsPrepareFileName(vcmFmt(vcmCStr(str_FolderFileNamePattern),[l3CStr(FoldersTree.GetCurrentNode)])));
   end;
   if l_FO.Execute then
   try
    dsFoldersTree.ExportToXML(FoldersTree.GetCurrentNode, l3PCharLen(l_FO.FileName));
   except
    on EAccessDenied do
     Say(err_ExportFolderError, [FoldersTree.GetCurrentNode]);
    on EInvalidEntityType do
     Say(err_ExportFolderError, [FoldersTree.GetCurrentNode]);
   end;//try..except
  finally
   FreeAndNil(l_FO);
  end;//try..except
 end;//dsFoldersTree <> nil
//#UC END# *4C7E66DC00F5_4C7E651B0179exec_impl*
//#UC START# *4C7E66DC00F5_4C7E651B0179exec_var*
var
 l_FO : TOpenDialog;
//#UC END# *4C7E66DC00F5_4C7E651B0179exec_var*
//#UC START# *4C7E66DC00F5_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := (dsFoldersTree <> nil) and
  dsFoldersTree.CanExportToXML(FoldersTree.GetCurrentNode);
//#UC END# *4C7E66DC00F5_4C7E651B0179test_impl*
//#UC START# *4C7E66DC00F5_4C7E651B0179test_var*
//#UC END# *4C7E66DC00F5_4C7E651B0179test_var*
//#UC START# *4C7E66F60347_4C7E651B0179exec_impl*
 if (dsFoldersTree <> nil) then
 begin
  l_FO := TOpenDialog.Create(Self);
  try
   with l_FO do
   begin
    Filter := vcmConstString(str_FolderFilter);
    Title := vcmConstString(str_ImportFolderTitle);
    DefaultExt := vcmConstString(str_XMLFileExtension);
    FilterIndex := 1;
    FileName := '';
   end;
   if l_FO.Execute then
   try
    dsFoldersTree.ImportFromXML(FoldersTree.GetCurrentNode, l3PCharLen(l_FO.FileName));
   except
    on EAccessDenied do
     Say(err_ExportFolderError, [FoldersTree.GetCurrentNode]);
    on EInvalidEntityType do
     Say(err_ExportFolderError, [FoldersTree.GetCurrentNode]);
   end;//try..except
  finally
   FreeAndNil(l_FO);
  end;//try..except
 end;//dsFoldersTree <> nil
//#UC END# *4C7E66F60347_4C7E651B0179exec_impl*
//#UC START# *4C7E66F60347_4C7E651B0179exec_var*
var
 l_FO : TOpenDialog;
//#UC END# *4C7E66F60347_4C7E651B0179exec_var*
//#UC START# *4C7E66F60347_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := (dsFoldersTree <> nil) and
  dsFoldersTree.CanImportFromXML(FoldersTree.GetCurrentNode);
//#UC END# *4C7E66F60347_4C7E651B0179test_impl*
//#UC START# *4C7E66F60347_4C7E651B0179test_var*
//#UC END# *4C7E66F60347_4C7E651B0179test_var*
//#UC START# *4C7E679702DA_4C7E651B0179exec_impl*
 FolderElement_InternalEdit_Execute(FoldersTree.TreeView.CurrentNode, false);
//#UC END# *4C7E679702DA_4C7E651B0179exec_impl*
//#UC START# *4C7E679702DA_4C7E651B0179exec_var*
//#UC END# *4C7E679702DA_4C7E651B0179exec_var*
//#UC START# *4C7E679702DA_4C7E651B0179test_impl*
 if (FoldersTree.TreeView.Current < 0) then
  aParams.Op.Flag[vcm_ofEnabled] := False
 else
 if (Aggregate <> nil) then
 begin
  case Op_FolderElement_GetState.Call(Aggregate) of
   fiNone      : aParams.Op.Flag[vcm_ofChecked] := False;
   fiNewFolder : aParams.Op.Flag[vcm_ofEnabled] := False;
   fiEdit      : aParams.Op.Flag[vcm_ofChecked] := True;
   else
    aParams.Op.Flag[vcm_ofEnabled] := False;
  end//case Op_FolderElement_GetState.Call(Aggregate)
 end//Aggregate <> nil
 else
  aParams.Op.Flag[vcm_ofEnabled] := False;
//#UC END# *4C7E679702DA_4C7E651B0179test_impl*
//#UC START# *4C7E679702DA_4C7E651B0179test_var*
//#UC END# *4C7E679702DA_4C7E651B0179test_var*
//#UC START# *4C7E67B301FD_4C7E651B0179exec_impl*
 FolderElement_InternalEdit_Execute(FoldersTree.TreeView.CurrentNode, true);
//#UC END# *4C7E67B301FD_4C7E651B0179exec_impl*
//#UC START# *4C7E67B301FD_4C7E651B0179exec_var*
//#UC END# *4C7E67B301FD_4C7E651B0179exec_var*
//#UC START# *4C7E67B301FD_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := not (FoldersTree.TreeView.Current < 0);
//#UC END# *4C7E67B301FD_4C7E651B0179test_impl*
//#UC START# *4C7E67B301FD_4C7E651B0179test_var*
//#UC END# *4C7E67B301FD_4C7E651B0179test_var*
//#UC START# *4C7E67CE01CB_4C7E651B0179exec_impl*
 OpenFolderElement(self.as_IvcmEntityForm, FoldersTree.GetCurrentNode, vcm_okInCurrentTab);
//#UC END# *4C7E67CE01CB_4C7E651B0179exec_impl*
//#UC START# *4C7E67CE01CB_4C7E651B0179exec_var*
//#UC END# *4C7E67CE01CB_4C7E651B0179exec_var*
//#UC START# *4C7E67CE01CB_4C7E651B0179test_impl*
 with FoldersTree.TreeView do
  aParams.Op.Flag[vcm_ofEnabled] := (Current < 0) and
   not IsInSaveLoadState and Supports(CurrentNode, INode, l_Node) and
   not (TFoldersItemType(l_Node.GetObjectType) in [FIT_FOLDER]);
//#UC END# *4C7E67CE01CB_4C7E651B0179test_impl*
//#UC START# *4C7E67CE01CB_4C7E651B0179test_var*
var
 l_Node: INode;
//#UC END# *4C7E67CE01CB_4C7E651B0179test_var*
//#UC START# *4C7E685801E5_4C7E651B0179exec_impl*
 OpenFolderElement(self.as_IvcmEntityForm, FoldersTree.GetCurrentNode, vcm_okInNewWindow);
//#UC END# *4C7E685801E5_4C7E651B0179exec_impl*
//#UC START# *4C7E685801E5_4C7E651B0179exec_var*
//#UC END# *4C7E685801E5_4C7E651B0179exec_var*
//#UC START# *4C7E685801E5_4C7E651B0179test_impl*
 with FoldersTree.TreeView do
  aParams.Op.Flag[vcm_ofEnabled] := (Current < 0) and
   not IsInSaveLoadState and Supports(CurrentNode, INode, l_Node) and
   not (TFoldersItemType(l_Node.GetObjectType) in [FIT_FOLDER, FIT_OLD_HISTORY]);
//#UC END# *4C7E685801E5_4C7E651B0179test_impl*
//#UC START# *4C7E685801E5_4C7E651B0179test_var*
var
 l_Node: INode;
//#UC END# *4C7E685801E5_4C7E651B0179test_var*
//#UC START# *4C7E68D602DB_4C7E651B0179exec_impl*
 with FoldersTree.TreeView do
 begin
  l_eeNode := CurrentNode;
  try
   if Supports(l_eeNode, InsFoldersNode, l_FoldersNode) then
    try
     l_FoldersNode.ChangeUnderControlStatus;
    finally
     l_FoldersNode := nil;
    end;//try..finally
  finally
   l_eeNode := nil;
  end;//try..finally
 end;//with FoldersTree.TreeView
//#UC END# *4C7E68D602DB_4C7E651B0179exec_impl*
//#UC START# *4C7E68D602DB_4C7E651B0179exec_var*
var
 l_eeNode      : IeeNode;
 l_FoldersNode : InsFoldersNode;
//#UC END# *4C7E68D602DB_4C7E651B0179exec_var*
//#UC START# *4C7E68D602DB_4C7E651B0179test_impl*
 // Enabled
 aParams.Op.Flag[vcm_ofEnabled] := not IsInSaveLoadState;

 try
  if aParams.Op.Flag[vcm_ofEnabled] then
  begin
   if Supports(FoldersTree.TreeView.CurrentNode, INode, l_Node) then
   begin
    // Пока на контроль можно поставить только Закладки
    aParams.Op.Flag[vcm_ofEnabled] :=
     (TFoldersItemType(l_Node.GetObjectType) in
      [FIT_BOOKMARK, FIT_PHARM_BOOKMARK]) and
     not nsHasNodeAnyFlag(l_Node, [affInExternal]);

    if aParams.Op.Flag[vcm_ofEnabled] then
    begin
     // begin http://mdp.garant.ru/pages/viewpage.action?pageId=268346048
     if Supports(l_Node, IControllable, l_Controllable) then
      try
       Assert(l_Controllable <> nil);
       aParams.Op.Flag[vcm_ofEnabled] := (l_Controllable <> nil) AND
                                         l_Controllable.GetCanSetToControl;
      finally
       l_Controllable := nil;
      end//try..finally
     else
      aParams.Op.Flag[vcm_ofEnabled] := false;
     // end http://mdp.garant.ru/pages/viewpage.action?pageId=268346048
    end;//aParams.Op.Flag[vcm_ofEnabled]
   end//Supports(FoldersTree.TreeView.CurrentNode, INode, l_Node)
   else
    aParams.Op.Flag[vcm_ofEnabled] := false;
  end;//aParams.Op.Flag[vcm_ofEnabled]

  // Checked
  if aParams.Op.Flag[vcm_ofEnabled] then
   aParams.Op.Flag[vcm_ofChecked] :=
    (l_Node <> nil) AND
    ((l_Node.GetFlags and NF_CONTROLLED) = NF_CONTROLLED);
 finally
  l_Node := nil;
 end//try..finally
//#UC END# *4C7E68D602DB_4C7E651B0179test_impl*
//#UC START# *4C7E68D602DB_4C7E651B0179test_var*
var
 l_Node: INode;
 l_Controllable : IControllable;
//#UC END# *4C7E68D602DB_4C7E651B0179test_var*
//#UC START# *4C7E68E900DC_4C7E651B0179exec_impl*
 if (dsFoldersTree <> nil) then
 try
  dsFoldersTree.ExportForIntegration(FoldersTree.GetCurrentNode);
 except
  on EInvalidEntityType do
   Say(err_CanNotExport);
 end;//try..except
//#UC END# *4C7E68E900DC_4C7E651B0179exec_impl*
//#UC START# *4C7E68E900DC_4C7E651B0179exec_var*
//#UC END# *4C7E68E900DC_4C7E651B0179exec_var*
//#UC START# *4C7E68E900DC_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := defDataAdapter.IntergationExportEnabled and
  (dsFoldersTree <> nil) and
  dsFoldersTree.CanExportForIntegration(FoldersTree.GetCurrentNode);
//#UC END# *4C7E68E900DC_4C7E651B0179test_impl*
//#UC START# *4C7E68E900DC_4C7E651B0179test_var*
//#UC END# *4C7E68E900DC_4C7E651B0179test_var*
//#UC START# *4C7E6AE10291_4C7E651B0179exec_impl*
 OpenFolderElement(self.as_IvcmEntityForm, FoldersTree.GetCurrentNode, vcm_okInCurrentTab);
//#UC END# *4C7E6AE10291_4C7E651B0179exec_impl*
//#UC START# *4C7E6AE10291_4C7E651B0179exec_var*
//#UC END# *4C7E6AE10291_4C7E651B0179exec_var*
//#UC START# *4C7E6AE10291_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := (dsFoldersTree <> nil) and
  dsFoldersTree.CanBeOpenAsConsultation(FoldersTree.GetCurrentNode);
//#UC END# *4C7E6AE10291_4C7E651B0179test_impl*
//#UC START# *4C7E6AE10291_4C7E651B0179test_var*
//#UC END# *4C7E6AE10291_4C7E651B0179test_var*
//#UC START# *4C7E6AF2031C_4C7E651B0179exec_impl*
 if (dsFoldersTree <> nil) then
 begin
  if dsFoldersTree.CanGiveMarkOnConsultation(FoldersTree.GetCurrentNode) then
   TConsultationService.Instance.GiveMarkOnConsultation(FoldersTree.GetCurrentNode);
 end;//dsFoldersTree <> nil
//#UC END# *4C7E6AF2031C_4C7E651B0179exec_impl*
//#UC START# *4C7E6AF2031C_4C7E651B0179exec_var*
//#UC END# *4C7E6AF2031C_4C7E651B0179exec_var*
//#UC START# *4C7E6AF2031C_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := (dsFoldersTree <> nil) and
  dsFoldersTree.CanGiveMarkOnConsultation(FoldersTree.GetCurrentNode);
//#UC END# *4C7E6AF2031C_4C7E651B0179test_impl*
//#UC START# *4C7E6AF2031C_4C7E651B0179test_var*
//#UC END# *4C7E6AF2031C_4C7E651B0179test_var*
//#UC START# *4C7E6B1A019D_4C7E651B0179exec_impl*
 nsWriteLetterAboutConsultation(FoldersTree.GetCurrentNode);
//#UC END# *4C7E6B1A019D_4C7E651B0179exec_impl*
//#UC START# *4C7E6B1A019D_4C7E651B0179exec_var*
//#UC END# *4C7E6B1A019D_4C7E651B0179exec_var*
//#UC START# *4C7E6B1A019D_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofVisible] := False;
  // - эта операция от которой нужен только ShortCut, показывать;
//#UC END# *4C7E6B1A019D_4C7E651B0179test_impl*
//#UC START# *4C7E6B1A019D_4C7E651B0179test_var*
//#UC END# *4C7E6B1A019D_4C7E651B0179test_var*
//#UC START# *4C7E6B310055_4C7E651B0179exec_impl*
 if (dsFoldersTree <> nil) then
 begin
  l_FO := TOpenDialog.Create(Self);
  try
   with l_FO do
   begin
    Filter := vcmConstString(str_ConsultationFilter);
    Title := vcmConstString(str_ImportConsultationCaption);
    DefaultExt := vcmConstString(str_XMLFileExtension);
    FilterIndex := 1;
   end;
   if l_FO.Execute then
   try
    dsFoldersTree.ImportConsultation(l3PCharLen(l_FO.FileName));
   except
    on EAccessDenied do
     Say(err_FileReadErrorF, [l_FO.FileName]);
    on EInvalidXMLType do
     Say(err_InvalidFileFormat);
   end;
  finally
   FreeAndNil(l_FO);
  end;
 end;//dsFoldersTree <> nil
//#UC END# *4C7E6B310055_4C7E651B0179exec_impl*
//#UC START# *4C7E6B310055_4C7E651B0179exec_var*
var
 l_FO : TOpenDialog;
//#UC END# *4C7E6B310055_4C7E651B0179exec_var*
//#UC START# *4C7E6B310055_4C7E651B0179test_impl*
 aParams.Op.Flag[vcm_ofEnabled] := (dsFoldersTree <> nil)
  and dsFoldersTree.CanImportConsultation(FoldersTree.GetCurrentNode);
//#UC END# *4C7E6B310055_4C7E651B0179test_impl*
//#UC START# *4C7E6B310055_4C7E651B0179test_var*
//#UC END# *4C7E6B310055_4C7E651B0179test_var*
//#UC START# *4C7E73BD019F_4C7E651B0179_impl*
 Result := (Op_FolderElement_GetState.Call(Aggregate) in [fiLoad, fiSelect, fiSave]);
//#UC END# *4C7E73BD019F_4C7E651B0179_impl*
//#UC START# *4C7E73BD019F_4C7E651B0179_var*
//#UC END# *4C7E73BD019F_4C7E651B0179_var*
//#UC START# *4C7E772A036F_4C7E651B0179_impl*
 Result := nil;
 if Supports(aNode, INode, l_AdapterNode) then
  if TFoldersItemType(l_AdapterNode.GetObjectType) = FIT_FOLDER then
   Result := aNode
  else
   Result := aNode.ParentNode;
//#UC END# *4C7E772A036F_4C7E651B0179_impl*
//#UC START# *4C7E772A036F_4C7E651B0179_var*
var
 l_AdapterNode: INode;
//#UC END# *4C7E772A036F_4C7E651B0179_var*
//#UC START# *4C7E77D901C5_4C7E651B0179_impl*
 I := 1;
 repeat
  l_Name := vcmFmt(str_NewFolderDefaultName, [I]);
  l_Node := aNode.IterateF(eeL2NA(@FindNode), imOneLevel or imCheckResult);
  Inc(I);
 until l_Node = nil;
 Result := l_Name;
//#UC END# *4C7E77D901C5_4C7E651B0179_impl*
//#UC START# *4C7E77D901C5_4C7E651B0179_var*
var
 l_Name : Il3CString;

 function FindNode(const anIntf: IeeNode) : Boolean;
 begin//FindNode
  Result := l3Same(l_Name, anIntf.Text);
 end;//FindNode

var
 l_Node : IeeNode;
 I  : Integer;
//#UC END# *4C7E77D901C5_4C7E651B0179_var*
//#UC START# *4C7E7A8000F8_4C7E651B0179_impl*
 lFolder := GetIFolderFromIeeNode(aNode);
 if Assigned(lFolder) then
 try
  // установим доступ по умному, см. описание SharedFolder
  SharedFolder(aNode, not lFolder.GetShared);
  // проинформируем об изменениях
  op_UsersRights_FolderShareChanged.Call(Aggregate);
 finally
  lFolder := nil;
 end;
//#UC END# *4C7E7A8000F8_4C7E651B0179_impl*
//#UC START# *4C7E7A8000F8_4C7E651B0179_var*
var
 lFolder : IFolder;
//#UC END# *4C7E7A8000F8_4C7E651B0179_var*
//#UC START# *4C7E808A035E_4C7E651B0179_impl*
 if (Aggregate <> nil) and (NewCurrent <> -1) then
  with FoldersTree.TreeView do
  begin
   l_eeNode := GetNode(NewCurrent);
   try
    op_FolderElement_SetContent.Call(Aggregate, l_eeNode);
   finally
    l_eeNode := nil;
   end;//try..finally
  end;//with FoldersTree.TreeView
//#UC END# *4C7E808A035E_4C7E651B0179_impl*
//#UC START# *4C7E808A035E_4C7E651B0179_var*
var
 l_eeNode : IeeNode;
//#UC END# *4C7E808A035E_4C7E651B0179_var*
//#UC START# *4CB5802D00CB_4C7E651B0179exec_impl*
 with FoldersTree.TreeView do
 begin
  l_eeNode := CurrentNode;
  try
   if Supports(l_eeNode, INode, l_AdapterNode) then
    try
     try
      l_AdapterNode.Open(l_BaseEntity);
     except
      on ECanNotFindData do
       exit; //TODO: нода "пропала" что делать?
     end;//try..except
     try
      Supports(l_BaseEntity, IQuery, l_Query);
      Assert(Assigned(l_Query));
      TFiltersService.Instance.CreateFilter(l_Query);
     finally
      l_BaseEntity := nil;
     end;//try..finally
    finally
     l_AdapterNode := nil;
    end;//try..finally
  finally
   l_eeNode := nil;
  end;//try..finally
 end;//with FoldersTree.TreeView
//#UC END# *4CB5802D00CB_4C7E651B0179exec_impl*
//#UC START# *4CB5802D00CB_4C7E651B0179exec_var*
var
 l_eeNode      : IeeNode;
 l_AdapterNode : INode;
 l_BaseEntity  : IUnknown;
 l_Query: IQuery;
//#UC END# *4CB5802D00CB_4C7E651B0179exec_var*
//#UC START# *4CB5802D00CB_4C7E651B0179test_impl*
 SavedQuery_OpenQuery_Test(aParams);
//#UC END# *4CB5802D00CB_4C7E651B0179test_impl*
//#UC START# *4CB5802D00CB_4C7E651B0179test_var*
//#UC END# *4CB5802D00CB_4C7E651B0179test_var*
