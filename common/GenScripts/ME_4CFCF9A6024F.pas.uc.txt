//#UC START# *4CFCF9A6024F_ext:ParentFileName
w:\quality\test\garant6x\AdapterTest\AdapterHelpers\atDocumentHelper.pas
//#UC END# *4CFCF9A6024F_ext:ParentFileName
//#UC START# *4CFD01EF02C5_4CFCF9A6024F_impl*
  // смотрим, есть ли у текущей дети
  CurrLayer.Curr.ChildLayerID := f_DTP.GetChildLayerId(CurrLayer.Curr.EP);
  CurrLayer.Curr.ChildrenCount := f_DTP.ChildrenCount(CurrLayer.Curr.ChildLayerID);
  Result := CurrLayer.Curr.ChildrenCount > 0;

  // если нет, то проверяем что не дошли до конца
  i := f_CurrLayerIdx;
  while (NOT Result) AND (i >= 0) do
  begin
    Result := f_LayerStack[i].Curr.EP.rChild < f_LayerStack[i].MaxChild;
    Dec(i);
  end;
//#UC END# *4CFD01EF02C5_4CFCF9A6024F_impl*
//#UC START# *4CFD01EF02C5_4CFCF9A6024F_var*
  var
    i : Integer;
//#UC END# *4CFD01EF02C5_4CFCF9A6024F_var*
//#UC START# *4CFD01FD00DB_4CFCF9A6024F_impl*
  // если у текущей есть дети, то делаем первого ребенка текущим
  if CurrLayer.Curr.ChildrenCount > 0 then
  begin
    l_NewLayer.Curr.EP.rLayer := CurrLayer.Curr.ChildLayerID;
    l_NewLayer.Curr.EP.rChild := ROOT_CHILD;
    l_NewLayer.MaxChild := CurrLayer.Curr.ChildrenCount-1;
    PushLayer(l_NewLayer);
  end
  else
  begin
    // если необходимо, поднимаемся вверх до незакончившегося слоя
    while CurrLayer.Curr.EP.rChild = CurrLayer.MaxChild do PopLayer;
    // и переходим к следующему элементу в слое
    Inc(CurrLayer.Curr.EP.rChild);
  end;
  
  Result := CurrLayer.Curr.EP;
//#UC END# *4CFD01FD00DB_4CFCF9A6024F_impl*
//#UC START# *4CFD01FD00DB_4CFCF9A6024F_var*
  var
    l_NewLayer : TatLayerContext;
//#UC END# *4CFD01FD00DB_4CFCF9A6024F_var*
//#UC START# *4CFE2AFB01CC_4CFCF9A6024F_impl*
  Inc(f_CurrLayerIdx);
  if f_CurrLayerIdx+1 > Length(f_LayerStack) then
    SetLength(f_LayerStack, f_CurrLayerIdx+1);
  f_LayerStack[f_CurrLayerIdx] := aLayer;
  f_CurrLayer := @(f_LayerStack[f_CurrLayerIdx]);
//#UC END# *4CFE2AFB01CC_4CFCF9A6024F_impl*
//#UC START# *4CFE2AFB01CC_4CFCF9A6024F_var*
//#UC END# *4CFE2AFB01CC_4CFCF9A6024F_var*
//#UC START# *4CFE2B140080_4CFCF9A6024F_impl*
  Assert(f_CurrLayerIdx > 0, 'f_CurrLayerIdx > 0');
  Dec(f_CurrLayerIdx);
  f_CurrLayer := @(f_LayerStack[f_CurrLayerIdx]);
//#UC END# *4CFE2B140080_4CFCF9A6024F_impl*
//#UC START# *4CFE2B140080_4CFCF9A6024F_var*
//#UC END# *4CFE2B140080_4CFCF9A6024F_var*
//#UC START# *4CFE69960335_4CFCF9A6024F_impl*
  inherited Create();
  f_DTP := aDTP;
  Reset();
//#UC END# *4CFE69960335_4CFCF9A6024F_impl*
//#UC START# *4CFE69960335_4CFCF9A6024F_var*
//#UC END# *4CFE69960335_4CFCF9A6024F_var*
//#UC START# *4DD3A0CC019F_4CFCF9A6024F_impl*
  l_NewLayer.Curr.EP.rLayer := ROOT_LAYER;
  l_NewLayer.Curr.EP.rChild := ROOT_CHILD;
  l_NewLayer.MaxChild := ROOT_CHILD;
  l_NewLayer.Curr.ChildrenCount := 1;
  //
  f_CurrLayerIdx := -1;
  PushLayer(l_NewLayer);
//#UC END# *4DD3A0CC019F_4CFCF9A6024F_impl*
//#UC START# *4DD3A0CC019F_4CFCF9A6024F_var*
  var
    l_NewLayer : TatLayerContext;
//#UC END# *4DD3A0CC019F_4CFCF9A6024F_var*
//#UC START# *4DD3A0D902D1_4CFCF9A6024F_impl*
  Assert(aNIP <> nil, 'aNIP <> nil');
  //
  Reset();
  CurrLayer.Curr.ChildLayerID := f_DTP.GetChildLayerId(CurrLayer.Curr.EP);
  //
  for i := 0 to aNIP.Count-1 do
  begin
    l_NewLayer.Curr.EP.rChild := aNIP.Items[i];
    if (i = aNIP.Count-1) then
      if l_NewLayer.Curr.EP.rChild = ROOT_CHILD then
        break
      else
        Dec(l_NewLayer.Curr.EP.rChild);
    //
    l_NewLayer.Curr.EP.rLayer := CurrLayer.Curr.ChildLayerID;
    l_NewLayer.Curr.ChildLayerID := f_DTP.GetChildLayerId(l_NewLayer.Curr.EP);
    l_NewLayer.Curr.ChildrenCount := f_DTP.ChildrenCount(l_NewLayer.Curr.ChildLayerID);
    //
    l_NewLayer.MaxChild := CurrLayer.Curr.ChildrenCount-1;
    //
    PushLayer(l_NewLayer);
  end;
//#UC END# *4DD3A0D902D1_4CFCF9A6024F_impl*
//#UC START# *4DD3A0D902D1_4CFCF9A6024F_var*
  var
    i : Integer;
    l_NewLayer : TatLayerContext;
//#UC END# *4DD3A0D902D1_4CFCF9A6024F_var*
//#UC START# *4DD3A0F10121_4CFCF9A6024F_impl*
  Reset();
  f_DTP.GetChildLayerId(CurrLayer.Curr.EP); // без этой строки FindPara внизу выкидывает ECanNotFindData там где не должен, почему так, я не знаю
  //
  try
    f_DTP.FindPara(aParaID, l_NIP);
  except
    on ex : ECanNotFindData do
    begin
      Logger.Info('Не можем найти параграф %d', [aParaID]);
      Raise;
    end;
  end;
  InitLayerStackByNIP(l_NIP);
//#UC END# *4DD3A0F10121_4CFCF9A6024F_impl*
//#UC START# *4DD3A0F10121_4CFCF9A6024F_var*
  var
    l_NIP : INodeIndexPath;
//#UC END# *4DD3A0F10121_4CFCF9A6024F_var*
//#UC START# *4DD3A10C0050_4CFCF9A6024F_impl*
  try
    f_DTP.FindBlockOrSub(aSubID, l_NIP);
  except
    on ex : ECanNotFindData do
    begin
      Logger.Info('Не можем найти саб %d', [aSubId]);
      Raise;
    end;
  end;
  InitLayerStackByNIP(l_NIP);
//#UC END# *4DD3A10C0050_4CFCF9A6024F_impl*
//#UC START# *4DD3A10C0050_4CFCF9A6024F_var*
  var
    l_NIP : INodeIndexPath;
//#UC END# *4DD3A10C0050_4CFCF9A6024F_var*
