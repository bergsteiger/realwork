//#UC START# *4DB00A510300_ext:ParentFileName
w:\common\components\rtl\Garant\ScriptEngine\tfwTypeInfo.pas
//#UC END# *4DB00A510300_ext:ParentFileName
//#UC START# *4DB0137B0192_4DB00A510300_impl*
 CheckTypeIs(tfw_vtBool);
 Result := (rInteger <> 0);
//#UC END# *4DB0137B0192_4DB00A510300_impl*
//#UC START# *4DB0137B0192_4DB00A510300_var*
//#UC END# *4DB0137B0192_4DB00A510300_var*
//#UC START# *4DB04AE10159_4DB00A510300_impl*
 CheckTypeIs(tfw_vtStr);
 Result := rString;
//#UC END# *4DB04AE10159_4DB00A510300_impl*
//#UC START# *4DB04AE10159_4DB00A510300_var*
//#UC END# *4DB04AE10159_4DB00A510300_var*
//#UC START# *4DBAF96002B5_4DB00A510300_impl*
 if (rType = tfw_vtNil) then
  Result := nil
 else
 begin
  CheckTypeIs(tfw_vtObj);
  Result := TObject(rInteger);
 end;//rType = tfw_svtNil
//#UC END# *4DBAF96002B5_4DB00A510300_impl*
//#UC START# *4DBAF96002B5_4DB00A510300_var*
//#UC END# *4DBAF96002B5_4DB00A510300_var*
//#UC START# *4E4CE1D0000E_4DB00A510300_impl*
 CheckTypeIs(tfw_vtInt);
 Result := rInteger;
//#UC END# *4E4CE1D0000E_4DB00A510300_impl*
//#UC START# *4E4CE1D0000E_4DB00A510300_var*
//#UC END# *4E4CE1D0000E_4DB00A510300_var*
//#UC START# *4EB2750D010D_4DB00A510300_impl*
 if (rType = tfw_vtObj) then
 begin
  l_O := Self.AsObject;
  if (l_O <> nil) then
  begin
   if l_O.GetInterface(aGUID, Result) then
    Exit
(*   else
   if Supports(Self.AsObject, aGUID, Result) then
    Exit*)
   // - наверное не стоит ходить за интерфейсом "окольными путями"
   //   если объект его не поддерживает
   //   Ну типа как в Delphi. 
   ;
  end;//l_O <> nil
 end//rType = tfw_svtObj
 else
 if (rType = tfw_vtIntf) then
 begin
  if Supports(Self.AsIntf, aGUID, Result) then
   Exit;
 end;//rType = tfw_svtIntf
 EtfwCheck.Fail(l3Str(AsPrintable) + ': Не поддерживается интерфес ' + GUIDToString(aGUID));
//#UC END# *4EB2750D010D_4DB00A510300_impl*
//#UC START# *4EB2750D010D_4DB00A510300_var*
var
 l_O : TObject;
//#UC END# *4EB2750D010D_4DB00A510300_var*
//#UC START# *4EB275290323_4DB00A510300_impl*
 if (rType = tfw_vtNil) then
  Result := nil
 else
 begin
  if not ((rType = tfw_vtIntf) OR
          (rType = tfw_vtList) OR
          (rType = tfw_vtFile)) then
   EtfwCheck.Fail('Тип значения ' +
          GetEnumName(TypeInfo(TtfwValueType), Ord(rType)) +
          ' несовместим с интерфейсом'
         );
  Result := IUnknown(rString);
 end;//rType = tfw_svtNil
//#UC END# *4EB275290323_4DB00A510300_impl*
//#UC START# *4EB275290323_4DB00A510300_var*
//#UC END# *4EB275290323_4DB00A510300_var*
//#UC START# *4F47BE7100B4_4DB00A510300_impl*
 if (rType <> aTypeNeeded) then
  EtfwCheck.Fail(
         'Тип значения ' +
         GetEnumName(TypeInfo(TtfwValueType), Ord(rType)) +
         ' несовместим с ' +
         GetEnumName(TypeInfo(TtfwValueType), Ord(aTypeNeeded))
        );
//#UC END# *4F47BE7100B4_4DB00A510300_impl*
//#UC START# *4F47BE7100B4_4DB00A510300_var*
//#UC END# *4F47BE7100B4_4DB00A510300_var*
//#UC START# *4F4FDCBE01B5_4DB00A510300_impl*
 CheckTypeIs(tfw_vtChar);
 Result := AnsiChar(rInteger);
//#UC END# *4F4FDCBE01B5_4DB00A510300_impl*
//#UC START# *4F4FDCBE01B5_4DB00A510300_var*
//#UC END# *4F4FDCBE01B5_4DB00A510300_var*
//#UC START# *4F4FEB3C01D1_4DB00A510300_impl*
 Case rType of
  tfw_vtStr:
   Result := AsString;
  tfw_vtInt:
   Result := TtfwCStringFactory.C(IntToStr(rInteger));
  tfw_vtBool:
   Result := TtfwCStringFactory.C(BoolToStr(AsBoolean, true));
  tfw_vtVoid:
   Result := TtfwCStringFactory.C('<void>');
  tfw_vtObj:
  begin
   l_Obj := AsObject;
   if (l_Obj Is TComponent) then
    Result := TtfwCStringFactory.C(TComponent(l_Obj).Name + ' : ' + l_Obj.ClassName)
   else
   if (l_Obj <> nil) then
    Result := TtfwCStringFactory.C(l_Obj.ClassName)
   else
    Result := TtfwCStringFactory.C('<nil>'); 
  end;//tfw_svtObj
  tfw_vtIntf:
   Result := TtfwCStringFactory.C(Format('<interface %p>', [Pointer(rString)]));
  tfw_vtList:
   Result := TtfwCStringFactory.C(Format('<array %p>', [Pointer(rString)]));
(*  tfw_vtWStr:
   Result := TtfwCStringFactory.C(AsWString);*)
  tfw_vtChar:
   Result := TtfwCStringFactory.C(AsChar);
(*  tfw_vtBracket:
   Result := TtfwCStringFactory.C('<bracket>');*)
  tfw_vtNil:
   Result := TtfwCStringFactory.C('<nil>');
  tfw_vtClass:
    Result := TtfwCStringFactory.C(AsClass.ClassName);
  else
  begin
   Result := nil;
   EtfwCheck.Fail('Неизвестный тип для приведения к печатному виду');
  end;//else
 end;//Case rType  
//#UC END# *4F4FEB3C01D1_4DB00A510300_impl*
//#UC START# *4F4FEB3C01D1_4DB00A510300_var*
var
 l_Obj : TObject;
//#UC END# *4F4FEB3C01D1_4DB00A510300_var*
//#UC START# *5085301700BE_4DB00A510300_impl*
 if (rType = tfw_vtNil) then
  Result := nil
 else
 begin
  CheckTypeIs(tfw_vtClass);
  Result := TClass(rInteger);
 end;//rType = tfw_svtNil
//#UC END# *5085301700BE_4DB00A510300_impl*
//#UC START# *5085301700BE_4DB00A510300_var*
//#UC END# *5085301700BE_4DB00A510300_var*
//#UC START# *558D1A20035B_4DB00A510300_impl*
 rString := nil;
//#UC END# *558D1A20035B_4DB00A510300_impl*
//#UC START# *558D1A20035B_4DB00A510300_var*
//#UC END# *558D1A20035B_4DB00A510300_var*
//#UC START# *55C8C3D00092_4DB00A510300_impl*
 l_O := AsObject;
 if (l_O = nil) then
 begin
  if aClass.InheritsFrom(TtfwWord) OR aAllowNil then
  begin
   Result := nil;
   Exit;
  end;//aClass.IhneritsFrom(TtfwWord)
  EtfwCheck.Fail('Передан nil, вместо: ' + aClass.ClassName);
 end;//l_O = nil
 if not (l_O Is aClass) then
  EtfwCheck.Fail('Класс: ' + l_O.ClassName + ' не совместим с: ' + aClass.ClassName);
 Result := Pointer(l_O);
//#UC END# *55C8C3D00092_4DB00A510300_impl*
//#UC START# *55C8C3D00092_4DB00A510300_var*
var
 l_O : TObject;
//#UC END# *55C8C3D00092_4DB00A510300_var*
//#UC START# *55CB0A17007A_4DB00A510300_impl*
 Result := l3Str(Self.AsString);
//#UC END# *55CB0A17007A_4DB00A510300_impl*
//#UC START# *55CB0A17007A_4DB00A510300_var*
//#UC END# *55CB0A17007A_4DB00A510300_var*
//#UC START# *55CB29290229_4DB00A510300_impl*
 l_C := AsClass;
 if (l_C = nil) then
 begin
(*  if aClass.InheritsFrom(TtfwWord) then
  begin
   Result := nil;
   Exit;
  end;//aClass.IhneritsFrom(TtfwWord)*)
  EtfwCheck.Fail('Передан nil, вместо: ' + aClass.ClassName);
 end;//l_C = nil
 if not l_C.InheritsFrom(aClass) then
  EtfwCheck.Fail('Класс: ' + l_C.ClassName + ' не совместим с: ' + aClass.ClassName);
 Result := Pointer(l_C);
//#UC END# *55CB29290229_4DB00A510300_impl*
//#UC START# *55CB29290229_4DB00A510300_var*
var
 l_C : TClass;
//#UC END# *55CB29290229_4DB00A510300_var*
