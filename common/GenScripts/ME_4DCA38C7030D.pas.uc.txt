//#UC START# *4DCA38C7030D_ext:ParentFileName
w:\common\components\rtl\Garant\dd\ddTextToTableConverters.pas
//#UC END# *4DCA38C7030D_ext:ParentFileName
//#UC START# *4FACDFA2002E_4DCA38C7030D_impl*
 // - Вначале заводим табличку 
 f_Row := TddTableRow.Create(nil);
 try
  f_LineParser := Tl3CustomParser.Create{(nil)};
  try
   f_Text := Tl3String.Create;
   try
    f_Text.CodePage := cp_OEM;
    f_LogicalTable := False;
    for l_Line := 0 to f_Lines.Hi do
    begin
     f_CurLine := l_Line;
     f_Text.Assign(Tl3String(f_Lines.Items[l_Line]));
     if not f_Text.Empty then
      if not CheckRowEnd then
       ScanForCols;
     f_Text.Clear;
    end; { for l_Line}
   finally
    l3Free(f_Text);
   end;
  finally
   l3Free(f_LineParser);
  end;
 finally
  if f_Row.CellCount > 0 then
   f_RowList.Add(f_Row);
  l3Free(f_Row);
 end;
 l_MaxCellCount := 0;
 for i := 0 to f_RowList.Count - 1 do
  l_MaxCellCount := Max(l_MaxCellCount, TddTableRow(f_RowList.Items[i]).CellCount);
 f_CellCount := l_MaxCellCount;
 f_RowCount := f_RowList.Count;
//#UC END# *4FACDFA2002E_4DCA38C7030D_impl*
//#UC START# *4FACDFA2002E_4DCA38C7030D_var*
var
 i              : Integer;
 l_Line         : Integer;
 l_MaxCellCount : Integer;
//#UC END# *4FACDFA2002E_4DCA38C7030D_var*
//#UC START# *4FACDFDE03BB_4DCA38C7030D_impl*
 f_CellCount:= 0;
 f_RowCount:= 0;
//#UC END# *4FACDFDE03BB_4DCA38C7030D_impl*
//#UC START# *4FACDFDE03BB_4DCA38C7030D_var*
//#UC END# *4FACDFDE03BB_4DCA38C7030D_var*
//#UC START# *4FACEB5D0335_4DCA38C7030D_impl*
 if not OnlyGraphic(f_Text) then
 begin
  Result := True;
 // Кроме псевдографики есть еще и другие символы
 // Дополнительная проверка на случай объед. верт. ячеек     
  if l3CharSetPresent(l3CStr(f_Text), CellStopChars) then
   CheckMixed
  else
   if OnlyGraphicAndSpace(f_Text) then
    CheckGraphicAndSpace
    //CheckMixed(True)
   else
    Result := False;
 end // if not OnlyGraphic(f_Text) then
 else
 begin
  if l3CharSetPresent(l3CStr(f_Text), CellCloseTable) and f_LogicalTable then
   CheckGraphicAndSpace(True)
  else
   CheckOnlyGraphic;
  Result := True;
 end;
//#UC END# *4FACEB5D0335_4DCA38C7030D_impl*
//#UC START# *4FACEB5D0335_4DCA38C7030D_var*
//#UC END# *4FACEB5D0335_4DCA38C7030D_var*
//#UC START# *4FACEBB6021F_4DCA38C7030D_impl*
 // Нужно вычленить оставшиеся ячейки и вылить их, закрыв строку
 //  и перерассчитав количество ячеек.
 l_LineStream := Tl3StringStream.Create(f_Text);
 try
  with f_LineParser do
  begin
   CheckFiler.Stream := l_LineStream;
   try
    f_LineParser.WhiteSpace := CellWhiteSpace;
    f_LineParser.WordChars := [#0 .. #255] - cc_Frames;
    // - Концом ключевого слова является псевдографика
    f_LineParser.CheckInt := False;
    while not f_LineParser.Filer.EOF do
    begin
     f_LineParser.NextTokenSp;
     l_PrevStr := l3CStr(f_LineParser.TokenLongString);
     l_PrevFPos := f_LineParser.Filer.Pos;
     f_LineParser.NextTokenPrim(l3NextTokenAllFlags - [l3_ntfCheckString]);
     l_TokenStr := f_LineParser.TokenLongString;
     //!!! НЕ ПИСАТЬ l3CStr(TokenLongString) - грохнете строку !!!
     if (l_TokenStr.Len > 0)
        and not l3CharSetPresent(l3CStr(l_TokenStr), cc_Frames) then
     try
      // - Прежде чем вносить текст, нужно найти ячейку
      l_FilterPos := f_LineParser.Filer.Pos;
      l_Cell := GetPrevVMergeCell(l_FilterPos, False);
      if (l_Cell = nil) or l_Cell.Props.Border.Frames[bpBottom].Enable then
      begin
       l_OldCell := l_Cell;
       l_Cell := f_Row.CellByPos[l_FilterPos];
       if (l_OldCell <> nil) and ((l_Cell = nil) or l_Cell.Props.VMerged) then
        l_Cell := l_OldCell;
      end;//if l_Cell.Props.Border.Frames[bpBottom].Enable then
      if l_Cell <> nil then
      begin
       l_Cell.Props.VMergeFirst := True;
       if l_TokenStr.RTrimLen <> 0 then
        AddParagraph(l_TokenStr, l_Cell);
      end; // if l_Cell <> nil then
     except
      on E: Exception do
      begin
       l3System.Msg2Log('Ошибка разбора строки ' + f_Text.AsString);
       l3System.Exception2Log(E);
       {$IFDEF nsTest}
         raise E;
       {$ENDIF nsTest}
      end; // on E
     end // try..except
     else
      if (l3Len(l_PrevStr) > 0)
         and not l3CharSetPresent(l_PrevStr, cc_Frames) then
       try
        l_Cell := GetPrevVMergeCell(l_PrevFPos, False);
        if (l_Cell = nil) or l_Cell.Props.Border.Frames[bpBottom].Enable then
        begin
         l_OldCell := l_Cell;
         l_Cell := f_Row.CellByPos[l_PrevFPos];
         if (l_Cell = nil) or l_Cell.Props.VMerged then
          l_Cell := l_OldCell;
        end;//if l_Cell.Props.Border.Frames[bpBottom].Enable then
        if l_Cell <> nil then
         l_Cell.Props.VMergeFirst := True;
        if l3Len(l3Trim(l_PrevStr)) > 0 then
        begin
         l_TokenStr1 := Tl3String.Make(l_PrevStr.AsWStr);
         try
          AddParagraph(l_TokenStr1, l_Cell);
         finally
          l3Free(l_TokenStr1);
         end;
        end;//if l3Len(l3Trim(l_PrevStr)) > 0 then
       except
        on E: Exception do
        begin
         l3System.Msg2Log('Ошибка разбора строки ' + f_Text.AsString);
         l3System.Exception2Log(E);
       {$IFDEF nsTest}
         raise E;
       {$ENDIF nsTest}
        end; // on E
       end;//if l_NeedCheck then
    end; { while not EOF}
    WriteRow;
   finally
    f_LineParser.Filer.Stream := nil;
   end;{try..finally}
  end;{with l_LineParser}
 finally
  l3Free(l_LineStream);
 end;{try..finally}
 l_AddCell := False;
 for i := 1 to f_Text.Len - 1 do
 begin
  if f_Text.Ch[i] in (CellAdvStartChars + [cc_VLine]) then
  begin
   f_Row.AddCellAndPara;
   f_Row.LastCell.Props := f_Row.LastCell.Props;
   with f_Row.LastCell.Props do
   begin
    CellOffset := i;
    IsBorder := True;
   end; // f_Row.LastCell.Props
   if f_Text.Ch[i] in [cc_VLine, cc_LeftCross] then
    with f_Row.LastCell.Props do
    begin
     Border.Frames[bpTop].Enable := False;
     VMerged := True;
    end; // f_Text.Ch[i] in [cc_VLine, cc_LeftCross]
  end // f_Text.Ch[i] in (CellAdvStartChars + [cc_VLine])
 end; // for i
//#UC END# *4FACEBB6021F_4DCA38C7030D_impl*
//#UC START# *4FACEBB6021F_4DCA38C7030D_var*
var
 l_Cell       : TddTableCell;
 i, j         : Integer;
 l_Length     : Integer;
 l_ColText    : Tl3String;
 l_LineStream : TStream;
 l_AddCell    : Boolean;
 l_TokenStr   : Tl3String;
 l_TokenStr1  : Tl3String;
 l_PrevStr    : Il3CString;
 l_FilterPos  : Integer;
 l_PrevFPos   : Integer;
 l_OldCell    : TddTableCell;
//#UC END# *4FACEBB6021F_4DCA38C7030D_var*
//#UC START# *4FACEBD701C8_4DCA38C7030D_impl*
 if not f_LogicalTable then
 begin
  // Проверить предыдущую строку на количесто ячеек, если есть ячейки "сверху".
  if (f_RowList.Count > 0) then
  begin
   // Здесь ищем ячейки которые не были объедены по вертикали и устанавливаем им нижнюю границу
   l_Row := TddTableRow(f_RowList.Last);
   for i := 0 to l_Row.CellCount - 1 do
   begin
    if l_Row.Cells[i].Props.VMerged then
    begin
     //Если такущая ячейка относится к объединенной, то пытаемся найти ячейку до объединенной и выставить ей границу снизу
     j := f_RowList.Hi;
     while (j >= 0) and (i < TddTableRow(f_RowList.Items[j]).CellCount) do
     begin
      if TddTableRow(f_RowList.Items[j]).Cells[i].Props.VMergeFirst then
      begin
       TddTableRow(f_RowList.Items[j]).Cells[i].Props.Border.Frames[bpBottom].Enable := True;
       Break;
      end // TddTableRow(f_RowList.Items[j]).TAP.CellsProps[i].VMergeFirst
      else
       Dec(j);
     end; // while J >= 0
    end // l_Row.TAP.CellsProps[i].VMerged
    else
     l_Row.Cells[i].Props.Border.Frames[bpBottom].Enable := True;
   end; // for i
  end; // l_Row.CellCount = 1) and l3CharSetPresent(f_Text.St, f_Text.Len, CellOverChars)
 end;//if not f_LogicalTable then

 for i := 0 to f_Row.CellCount - 1 do
  f_Row.Cells[i].Props.Border.Frames[bpBottom].Enable := True;

 if (f_Row.CellCount > 0) then
  WriteRow;

  // Искать ли здесь колонки? Видимо, да.
 if l3CharSetPresent(f_Text.St, f_Text.Len, CellStartChars) then
 begin
  f_LogicalTable := False;
  l_Len := 1;
  for i := 1 to f_Text.Len - 1 do
  begin
   if f_Text.Ch[i] in CellStartChars then
   begin
    f_Row.AddCellAndPara;
    f_Row.LastCell.Props := f_Row.LastCell.Props;
    with f_Row.LastCell.Props do
     if f_Row.CellCount > 1 then
      CellOffset := f_Row.Cells[f_Row.CellCount - 2].Props.CellOffset + l_Len
     else
      CellOffset := l_Len;
    f_Row.LastCell.Props.IsBorder := f_Text.Ch[i] <> cc_RightCross;
    l_Len := 1;
   end // if f_Text.Ch[i] in CellStartChars then
   else
    Inc(l_Len);
  end; // i:= 1
 end // l3CharSetPresent(f_Text, f_Text.Len, CellStartChars)
 else
  if f_LogicalTable and ConvertCellToRow(True) then
   WriteRow;
//#UC END# *4FACEBD701C8_4DCA38C7030D_impl*
//#UC START# *4FACEBD701C8_4DCA38C7030D_var*
var
 i, j   : Integer;
 l_Len  : Integer;
 l_Row  : TddTableRow;
 l_Text : Tl3String;
 l_CP   : TddCellProperty;
//#UC END# *4FACEBD701C8_4DCA38C7030D_var*
//#UC START# *4FACEC1B0129_4DCA38C7030D_impl*
 if ConvertCellToRow(CloseTable) then
 begin
  WriteRow;
  if f_Row.CellCount > 0 then
  begin
   // Синхронизируем количество ячеек
   l_EtalonRow := TddTableRow(f_RowList.Last);
   f_Row.TAP.AssignFrom(l_EtalonRow.TAP);
   for i := 0 to l_EtalonRow.CellCount - 1 do
   begin
    f_Row.AddCellAndPara(True);
    with f_Row.LastCell do
    begin
     Props := f_Row.Cells[i].Props;
     Props.IsBorder := False;
    end; // with f_Row.LastCell do
   end; // for i
  end; // if f_Row.CellCount > 0 then
 end;
//#UC END# *4FACEC1B0129_4DCA38C7030D_impl*
//#UC START# *4FACEC1B0129_4DCA38C7030D_var*
var
 i           : Integer;
 l_EtalonRow : TddTableRow;
//#UC END# *4FACEC1B0129_4DCA38C7030D_var*
//#UC START# *4FACEC3C023E_4DCA38C7030D_impl*
 if f_Row.CellCount > 0 then
 begin
  CorrectRow;
  f_RowList.Add(f_Row);
  l3Free(f_Row);
  f_Row := TddTableRow.Create(nil);
 end; // f_Row.CellCount > 0
//#UC END# *4FACEC3C023E_4DCA38C7030D_impl*
//#UC START# *4FACEC3C023E_4DCA38C7030D_var*
//#UC END# *4FACEC3C023E_4DCA38C7030D_var*
//#UC START# *4FACEC5A00BB_4DCA38C7030D_impl*
 if f_Row.CellCount = 0 then
 begin
  f_Row.AddCellAndPara;
  f_Row.LastCell.Props.CellOffset := f_Text.Len - 1;
 end; // Row.CellCount = 0
 l_LineStream := Tl3StringStream.Create(f_Text);
 try
  with f_LineParser do
  begin
   CheckFiler.Stream := l_LineStream;
   try
    f_LineParser.WhiteSpace := [];
    f_LineParser.WordChars := [#0 .. #255] - cc_Frames;
    // - Концом ключевого слова является псевдографика
    // В следующем куске считаем число ячеек 
    f_LineParser.CheckInt := False;
    l_CellCount := 0;
    while not Filer.EOF do
    begin
     NextTokenSp;
     while (TokenType <> l3_ttSingleChar) and not Filer.EOF do
      NextTokenSp;
     if (TokenLongString.Len > 0) and not Filer.EOF then
      Inc(l_CellCount);
    end; // while not Filer.EOF
    if l_CellCount <> 0 then
    begin
     // Количество, насчитанных ячеек больше, чем в предыдущей строке...
     if l_CellCount > f_Row.CellCount then
     begin
      f_LogicalTable := True;
      l_TextList := TddDocumentAtomList.Make;
      try
       //Сохраняем текст ячеек
       for i := 0 to f_Row.Cells[0].Hi do
        l_TextList.Add(f_Row.Cells[0].Items[i]);

       // И начинаем анализировать поток заново 
       f_Row.Clear;
       Filer.Seek(0, soBeginning);
       while not Filer.EOF do
       begin
         NextTokenSp;
         if TokenType <> l3_ttSymbol then
          NextTokenSp;
         if TokenLongString.Len > 0 then
         begin
          f_Row.AddCellAndPara;
          if f_Row.CellCount > 1 then
           f_Row.LastCell.Props.CellOffset := TokenLongString.Len + 1 +
                                   f_Row.Cells[f_Row.CellCount - 2].Props.CellOffset
          else
          begin
           f_Row.LastCell.Props.CellOffset := TokenLongString.Len;
           if f_Text.First in cc_Frames then
            f_Row.LastCell.Props.CellOffset := f_Row.LastCell.Props.CellOffset + 1;

           for i := 0 to l_TextList.Hi do
           begin
            if f_Row.LastCell.LastTextPara.Empty then
             f_Row.LastCell.LastTextPara.Assign(l_TextList.Items[i])
            else
             f_Row.LastCell.Add(l_TextList.Items[i]);
           end; // for i
          end; //f_Row.CellCount > 1
          if f_Row.CellCount = 1 then
           f_Row.LastCell.Props.Border.Frames[bpLeft].Enable := f_Text.First in cc_Frames
          else
           f_Row.LastCell.Props.Border.Frames[bpLeft].Enable := True;
          f_Row.LastCell.Props.Border.Frames[bpRight].Enable := True;
         end; //TokenLongString.Len > 0
       end; // while not Filer.EOF
      finally
       l3Free(l_TextList);
      end;
     end; // if l_CellCount > f_Row.CellCount

     k := 0;
     Filer.Seek(0, soBeginning);
     // Проверяем еще раз поток...
     while not Filer.EOF do
     begin
       NextTokenSp;
       if TokenType <> l3_ttSymbol then
        NextTokenSp;
       if (TokenLongString.Len > 0) and not OnlyGraphic(TokenLongString) then { DONE -oДмитрий Дудко -cРазвитие : Добавить проверку на символ псевдографики }
       begin
        if (k = 0) and not (f_Text.First in cc_Frames) then
         Dec(k);
        Inc(k, Succ(TokenLongString.Len));
        l_Cell := f_Row.CellByPos[k];
        if l_Cell <> nil then
        begin
         l_CellProp := l_Cell.Props;
         if l_CellProp <> nil then
         begin
         // Здесь пытаемся рамку накалякать...
          if l_Cell.anIndex = 0 then
           l_CellProp.Border.Frames[bpLeft].Enable := f_Text.First in cc_Frames
          else
           l_CellProp.Border.Frames[bpLeft].Enable := True;
          if l_Cell.anIndex = Pred(f_Row.CellCount) then
           l_CellProp.Border.Frames[bpRight].Enable := f_Text.Last in cc_Frames
          else
           l_CellProp.Border.Frames[bpRight].Enable := True;
          // Здесь находим ячейку, объединенную по вертикали
          if l_CellProp.VMerged then
           l_Cell := GetPrevVMergeCell(k, False);
         end; //if l_CellProp <> nil then
        end; // l_Cell <> nil
        // Добавляем текст к ячейке (если нашли для объединения).
        if l_Cell <> nil then
        begin
         if not l_Cell.LastTextPara.Empty then //В каждой ячейке много абзацев
          AddParagraph(TokenLongString, l_Cell)
         else
          AddText(l_Cell, TokenLongString);
        end; // l_Cell <> nil
      end; // if (TokenLongString.Len > 0) and not OnlyGraphic(TokenLongString) then
     end; { while not}
    end; // l_CellCount <> 0
   finally
    Filer.Stream := nil;
   end;{try..finally}
  end;{with l_LineParser}
 finally
  l3Free(l_LineStream);
 end;{try..finally}
//#UC END# *4FACEC5A00BB_4DCA38C7030D_impl*
//#UC START# *4FACEC5A00BB_4DCA38C7030D_var*
var
 k, i         : Integer;
 l_LineStream : TStream;
 l_Cell       : TddTableCell;
 l_CellProp   : TddCellProperty;
 l_TextList   : TddDocumentAtomList;
 l_CellCount  : Integer;
//#UC END# *4FACEC5A00BB_4DCA38C7030D_var*
//#UC START# *4FACEC7801A0_4DCA38C7030D_impl*
 for i := 0 to Pred(f_Row.CellCount) do
 begin
  l_Cell := f_Row.Cells[i];
  j := l_Cell.Hi;
  while (j > 0) and GlueLines do
  begin
   if TddTextParagraph(l_Cell.Items[j]).Empty and TddTextParagraph(l_Cell.Items[j - 1]).Empty then
    l_Cell.Delete(j);
   Dec(j);
  end; // while J > 0
 end; //for i:= 0

 if f_Row.CellCount > 0 then
 begin
  i := 0;
  while (i <= Pred(f_Row.CellCount)) and (f_Row.CellCount > 1) do
  begin
   l_Cell := f_Row.Cells[i];
   if (l_Cell.Count = 1) and l_Cell.LastTextPara.Empty and f_LogicalTable and
      not (l_Cell.Props.VMerged or l_Cell.Props.VMergeFirst) then
    f_Row.DeleteCell(i)
   else
    Inc(i);
  end; // while i:= 0

  if f_RowList.Count > 0 then
  begin
   l_Row := TddTableRow(f_RowList.Last);
   for i := 0 to f_Row.CellCount - 1 do
   begin
    l_Cell := f_Row.Cells[i];
    if l_Row <> nil then
     for j := 0 to l_Row.CellCount - 1 do
     begin
      l_UpCell := l_Row.Cells[j];
      if (l_UpCell.Props.CellOffset = l_Cell.Props.CellOffset) then
      begin
       if l_UpCell.Props.VMerged and not l_Cell.Props.VMerged then
        l_Cell.Props.Border.Frames[bpTop].Enable := True;
       if not l_UpCell.Props.VMergeFirst and l_Cell.Props.VMerged then
       begin
        l_Cell.Props.Border.Frames[bpTop].Enable := False;
        l_UpCell.Props.Border.Frames[bpBottom].Enable := False;
       end;
      end; //if (l_UpCell..Width = l_Cell..Width) then
     end; //for j := 0 to l_Row.CellCount - 1 do
    l_Cell.Props.Border.Frames[bpBottom].Enable := True;
   end; //for i := 0 to f_Row.CellCount - 1 do
  end; //if f_RowList.Count > 0 then
 end; //if f_Row.CellCount > 0 then
//#UC END# *4FACEC7801A0_4DCA38C7030D_impl*
//#UC START# *4FACEC7801A0_4DCA38C7030D_var*
var
 i, j     : Integer;
 l_Cell   : TddTableCell;
 l_UpCell : TddTableCell;
 l_Row    : TddTableRow;
//#UC END# *4FACEC7801A0_4DCA38C7030D_var*
//#UC START# *4FACEC8D03A8_4DCA38C7030D_impl*
 i := f_Text.FindChar(1, cc_VLine);
 if (i > 0) and (i <= (f_Text.Len - 1)) then
 begin
  // Проверить на совпадение cc_VLine на соответствие границам ячейки
  if f_RowList.Count > 0 then
  begin
   l_EtalonRow := TddTableRow(f_RowList.First);
   for j := 0 to l_EtalonRow.CellCount - 1 do
   begin
    Result := f_Text.Ch[l_EtalonRow.Cells[j].Props.CellOffset] = cc_VLine;
    if Result then
     Break;
   end; // for j := 0 to l_EtalonRow.CellCount - 1 do
   if Result then
    //Здесь сбрасываем рамку у объединенных ячеек и "синхронизируем" правые границы.
    for j := 0 to f_Row.CellCount - 1 do
    begin
     if not f_Row.Cells[j].Props.VMergeFirst then
      f_Row.Cells[j].Props.Border.Frames[bpBottom].Enable := False;
     if (j < l_EtalonRow.CellCount) and (f_Row.Cells[j].Props.CellOffset = l_EtalonRow.Cells[j].Props.CellOffset) then
      f_Row.Cells[j].Props.Border.Frames[bpRight].Enable := l_EtalonRow.Cells[j].Props.Border.Frames[bpRight].Enable;
    end; // for j := 0 to f_Row.CellCount - 1 do
    if (f_Row.CellCount > l_EtalonRow.CellCount) and (l_EtalonRow.LastCellProperty.CellOffset = f_Row.LastCellProperty.CellOffset) then
     f_Row.LastCellProperty.Border.Frames[bpRight].Enable := l_EtalonRow.LastCellProperty.Border.Frames[bpRight].Enable;
   Result := False or f_LogicalTable;
  end  // if f_RowList.Count > 0 then
  else
   Result := False or f_LogicalTable;
  Exit;
 end;

 if (f_Row.CellCount > 0) and (f_RowList.Count > 0) then
 begin
  if aBottomBorder and (f_Row.CellCount > 1) then
   for i := 0 to f_Row.CellCount - 1 do
   begin
    f_Row.Cells[i].Props.Border.Frames[bpBottom].Enable := True;
   end // for i := 0 to f_Row.CellCount - 1 do
  else
  begin
   f_LogicalTable := True;
   l_TextList := Tl3StringList.Make;
   try
    // Cохраняем текст по строкам первой ячейки
    { TODO -oNarry -cРазвитие : Нужно сохранять не только текст, но и его оформление }
    for i := 0 to f_Row.Cells[0].Hi do
    begin
     l_Text := Tl3String.Create;
     try
      l_Text.Assign(TddTextParagraph(f_Row.Cells[0].Items[i]).Text);
      l_TextList.Add(l_Text);
     finally
      l3Free(l_Text);
     end; // l_Text
    end; // for i
    f_Row.Clear;
    // Cинхронизируем количество ячеек
    l_EtalonRow := TddTableRow(f_RowList.Items[0]);
    f_Row.TAP.AssignFrom(l_EtalonRow.TAP);
    for i := 0 to l_EtalonRow.CellCount - 1 do
    begin
     f_Row.AddCellAndPara(True);
     f_Row.LastCell.Props := f_Row.Cells[i].Props;
     with f_Row.LastCell.Props do
     begin
      IsBorder := False;
      if (i = 0) then
       Border.Frames[bpLeft].Enable := True
      else
      if (i = l_EtalonRow.CellCount - 1) then
       Border.Frames[bpRight].Enable := True;
      if aBottomBorder then
       Border.Frames[bpBottom].Enable := True;
     end; // with f_Row.LastCell.Props do
    end; // for i

    // распихиваем сохраненный текст
    { TODO -oNarry -cРазвитие : Нужно распихивать не только текст, но и его оформление }
    for j := 0 to l_TextList.Hi do
    begin
     l_Length := 1;
     l_Text := Tl3String(l_TextList.Items[j]);
     for i := 0 to f_Row.CellCount-1 do
     begin 
      if i > 0 then
       l_Delta := f_Row.Cells[i].Props.CellOffset - f_Row.Cells[i - 1].Props.CellOffset
      else
       l_Delta := f_Row.Cells[i].Props.CellOffset;
      l_TextStr := Copy(l_Text.AsString, l_Length, l_Delta);
      if (l_Text.Ch[l_Length + l_Delta - 2] <> ' ') and (i <> f_Row.CellCount - 1) then
       AddText(f_Row.Cells[i + 1], l_Text, l_Length, l_Delta)
      else
       AddText(f_Row.Cells[i], l_Text, l_Length, l_Delta);
      Inc(l_Length, l_Delta);
     end; // for i
    end; // for j                              
   finally
    l3Free(l_TextList);
   end; // l_TextList
  end;
 end; // f_Row.CellCount > 0
 Result := True;
//#UC END# *4FACEC8D03A8_4DCA38C7030D_impl*
//#UC START# *4FACEC8D03A8_4DCA38C7030D_var*
var
 l_TextList  : Tl3StringList;
 l_EtalonRow : TddTableRow;
 l_Text      : Tl3String;
 l_CellText  : Tl3String;
 i, j        : Integer;
 l_Length    : Integer;
 l_Delta     : Integer;
 l_TextStr   : AnsiString;
//#UC END# *4FACEC8D03A8_4DCA38C7030D_var*
//#UC START# *4FACECAA0043_4DCA38C7030D_impl*
 Result := nil;
 for i := f_RowList.Hi downto 0 do
 begin
  Result := TddTableRow(f_RowList.Items[i]).CellByPos[aPos];
  if (Result <> nil) then
  begin
   if not Result.Props.VMerged then
   begin
    if aNeedCheckVMerge and not Result.Props.VMergeFirst then
     Result.Props.VMergeFirst := True;
    Break;
   end; // if not Result.Props.VMerged then
  end // if (Result <> nil) then
  else
   Break;
 end; // while i >= 0
//#UC END# *4FACECAA0043_4DCA38C7030D_impl*
//#UC START# *4FACECAA0043_4DCA38C7030D_var*
var
 i : Integer;
//#UC END# *4FACECAA0043_4DCA38C7030D_var*
