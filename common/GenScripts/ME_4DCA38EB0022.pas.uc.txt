//#UC START# *4DCA38EB0022_ext:ParentFileName
w:\common\components\rtl\Garant\dd\ddTextToTableConverters.pas
//#UC END# *4DCA38EB0022_ext:ParentFileName
//#UC START# *4FACDFA2002E_4DCA38EB0022_impl*
 l_Map := Tl3String.Create;
 try
  // 1. Построение карты столбцов
  l_SepS := TL3String.Create;
  try
   l_Seps.AsString := cc_HardSpace;
   l_Seps.MakeBMTable(l_BT);
   l_Found := False;
   l_Text := nil;
   for l_Line := 0 to f_Lines.Count - 1 do
   begin
    l_Text := Tl3String(f_Lines.Items[l_Line]);
    if OnlyGraphicAndSpace(l_Text) then Continue;
    l_SpaceAbsent := False;
    l_Found := l_SepS.BMSearchUC(l_Text, l_BT, l_Pos2);
    if not l_Found then // Если есть текст, но без пробела, то это одна ячейка. // http://mdp.garant.ru/pages/viewpage.action?pageId=585429117
     if l_Text.Empty then
      Exit
     else
     begin
      l_Found := True;
      l_SpaceAbsent := True;
     end;
    if l_Found then
    begin
     if l_Map.Len < l_Text.Len then
      l_Map.Append(cc_HardSpace, l_Text.Len - l_Map.Len);
      for i := 0 to l_Text.Len - 1 do
       if l_Text.Ch[i] <> cc_HardSpace then
        l_Map.Ch[i] := cc_CellChar;
      if l_SpaceAbsent then
       l_Map.Ch[l_Text.Len] := cc_BreakChar;
    end; // l_Found
   end; // for l_Line
   (* Нужно преобразовать последовательности Х_____ХХХ
                                          в Х_ХХХХХХХ   *)
   l_Seps.AsString:= cc_HardSpace + cc_CellChar;
   l_Seps.MakeBMTable(l_BT);
   l_Pos2 := 0;
   repeat
    l_Found := l_SepS.BMSearchUC(l_Map, l_BT, l_Pos2);
    if l_Found then
    begin
     if (l_Pos2 = 0) or (l_Map.Ch[l_Pos2 - 1] = cc_HardSpace) then
      l_Map.Ch[l_Pos2] := cc_CellChar
     else
      l_Map.Ch[l_Pos2] := cc_BreakChar;
    end; // l_Found
   until not l_Found;
  finally
   l3Free(l_Seps);
  end; // l_Seps
  // 2. Создание таблицы
  Map2Row(l_Map);
  f_CellCount := f_Row.CellCount;
  l_WasEmpty := True;
  for l_Line := 0 to f_Lines.Count - 1 do
  begin
   f_CurLine := l_Line;
   l_Text := Tl3String(f_Lines.Items[l_Line]);
   if OnlyGraphicAndSpace(l_Text) and (l_Line < Pred(f_Lines.Count)) then
   begin
    if not l_WasEmpty then _StartNewRow;
    l_WasEmpty := True;
   end
   else
   begin
    l_WasEmpty := False;
    if l_Map[1] = cc_BreakChar then
     l_PrevPos := 1
    else
     l_PrevPos := 0;
    repeat
     l_Pos := l_Map.FindChar(l_PrevPos, cc_BreakChar);
     if l_Pos = -1 then
     begin
      l_Cell := f_Row.LastCell;
      AddText(l_Cell, l_Text, l_PrevPos, l_Text.Len - l_PrevPos + 1);
     end // if l_Pos = -1 then
     else
     begin
      l_Cell := f_Row.CellByPos[l_Pos];
      if l_Cell <> nil then
       AddText(l_Cell, l_Text, l_PrevPos, l_Pos - l_PrevPos + 1);
     end;
     if (l_Cell <> nil) and l_Cell.LastTextPara.Empty then
      l_Cell.LastTextPara.AddText(cc_SoftSpace, CP_ANSI);

     l_PrevPos := l_Pos + 1;
    until (l_Pos = -1) or (l_Pos > l_Text.Len); // repeat..until
    if l_Pos <> -1 then
     for i := f_Row.CellByPos[l_Pos].anIndex + 1 to f_Row.CellCount - 1 do
     begin
      with f_Row.Cells[i] do
      begin
       AddParagraph;
       LastTextPara.AddText(cc_SoftSpace, CP_ANSI);
      end; // with f_Row.Cells[i] do
     end; // for i := f_Row.CellByPos[l_Pos].anIndex + 1 to f_Row.CellCount - 1 do
   end; // l_Text.Empty
  end; // for l_Line
  f_RowList.Add(f_Row);
  l3Free(f_Row);
 finally
  l3Free(l_Map);
 end; // l_Map
//#UC END# *4FACDFA2002E_4DCA38EB0022_impl*
//#UC START# *4FACDFA2002E_4DCA38EB0022_var*
var
 i, j      : Integer;
 l_Line    : Integer;
 l_Found   : Boolean;
 l_Map     : Tl3String;
 l_SepS    : Tl3String;
 l_Text    : Tl3String;
 l_Pos     : Integer;
 l_PrevPos : Integer;
 l_Pos2    : Cardinal;
 l_BT      : Tl3BMTable;
 l_Cell    : TddTableCell;
 l_WasEmpty: Boolean;

 procedure _StartNewRow;
 begin
  f_RowList.Add(f_Row);
  l3Free(f_Row);                             
  Map2Row(l_Map);
 end;

var
 l_SpaceAbsent: Boolean;
//#UC END# *4FACDFA2002E_4DCA38EB0022_var*
//#UC START# *4FACED7B0253_4DCA38EB0022_impl*
 f_Row := TddTableRow.Create(nil);
 l_Pos := aMap.FindChar(1, cc_BreakChar);
 while l_Pos <> -1 do
 begin
  f_Row.AddCellAndPara;
  with f_Row.LastCell do
   Props.CellOffset := l_Pos + 1;
  l_Pos := aMap.FindChar(l_Pos + 1, cc_BreakChar);
 end; // while l_Pos <> -1 do
 f_Row.AddCellAndPara;
 with f_Row.LastCell do
  Props.CellOffset := aMap.Len;
//#UC END# *4FACED7B0253_4DCA38EB0022_impl*
//#UC START# *4FACED7B0253_4DCA38EB0022_var*
var
 l_Pos: Integer;
//#UC END# *4FACED7B0253_4DCA38EB0022_var*
