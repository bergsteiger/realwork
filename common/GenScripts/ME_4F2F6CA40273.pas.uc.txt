//#UC START# *479731C50290_4F2F6CA40273_impl*
 if f_Offsets <> nil then
  f_Offsets.Clear;
 FreeAndNil(f_Offsets);
 if f_Widths <> nil then
  f_Widths.Clear;
 FreeAndNil(f_Widths);
 f_UsingCount := 0;
 inherited;
//#UC END# *479731C50290_4F2F6CA40273_impl*
//#UC START# *479731C50290_4F2F6CA40273_var*
//#UC END# *479731C50290_4F2F6CA40273_var*
//#UC START# *4F2F6CA40273_ext:FileName
w:\common\components\gui\Garant\Everest\evCellsCharOffsets.pas
//#UC END# *4F2F6CA40273_ext:FileName
//#UC START# *4F2F6CA40273impl_uses*
//#UC END# *4F2F6CA40273impl_uses*
//#UC START# *4F2F6D94002E_4F2F6CA40273_impl*
 CheckList;
 f_Offsets.Add(f_Offset);
 f_Widths.Add(f_Width);
 Inc(f_Offset, f_Width);
//#UC END# *4F2F6D94002E_4F2F6CA40273_impl*
//#UC START# *4F2F6D94002E_4F2F6CA40273_var*
//#UC END# *4F2F6D94002E_4F2F6CA40273_var*
//#UC START# *4F2F6DAB0114_4F2F6CA40273_impl*
 if (f_Offsets <> nil) then
 begin
  f_Offsets.Clear;
  f_Widths.Clear;
  f_Offset := 0;
  f_Width := 0;
  f_Index := 0;
  f_UsingCount := 0;
 end; // if (f_Offsets <> nil) then
//#UC END# *4F2F6DAB0114_4F2F6CA40273_impl*
//#UC START# *4F2F6DAB0114_4F2F6CA40273_var*
//#UC END# *4F2F6DAB0114_4F2F6CA40273_var*
//#UC START# *4F2F6DC40150_4F2F6CA40273_impl*
 Result := f_Offsets <> nil;
 if Result then
 begin
  Result := f_Offsets.FindData(aOffsetList.f_Offset, anIndex);
  if Result then
  begin
   f_Width := f_Widths[anIndex];
   f_Offset := f_Offsets[anIndex];
  end; // if Result then
 end; // if Result then
//#UC END# *4F2F6DC40150_4F2F6CA40273_impl*
//#UC START# *4F2F6DC40150_4F2F6CA40273_var*
//#UC END# *4F2F6DC40150_4F2F6CA40273_var*
//#UC START# *4F2F6DEE0354_4F2F6CA40273_impl*
 Result := f_Offsets <> nil;
 if Result then
 begin
  Result := f_Offsets.FindData(anOffset, anIndex);
  if Result then
  begin
   f_Width := f_Widths[anIndex];
   f_Offset := f_Offsets[anIndex];
  end; // if Result then
 end; // if Result then
//#UC END# *4F2F6DEE0354_4F2F6CA40273_impl*
//#UC START# *4F2F6DEE0354_4F2F6CA40273_var*
//#UC END# *4F2F6DEE0354_4F2F6CA40273_var*
//#UC START# *4F2F6E25013C_4F2F6CA40273_impl*
 f_Index := f_Widths.Count;
 Result := PrevWidth;
//#UC END# *4F2F6E25013C_4F2F6CA40273_impl*
//#UC START# *4F2F6E25013C_4F2F6CA40273_var*
//#UC END# *4F2F6E25013C_4F2F6CA40273_var*
//#UC START# *4F2F6E47025D_4F2F6CA40273_impl*
 Dec(f_Index);
 if f_Index >= 0 then
  Result := f_Widths[f_Index]
 else
  Result := 0;
//#UC END# *4F2F6E47025D_4F2F6CA40273_impl*
//#UC START# *4F2F6E47025D_4F2F6CA40273_var*
//#UC END# *4F2F6E47025D_4F2F6CA40273_var*
//#UC START# *4F2F6E6301E4_4F2F6CA40273_impl*
 Result := f_Offset + f_Width;
//#UC END# *4F2F6E6301E4_4F2F6CA40273_impl*
//#UC START# *4F2F6E6301E4_4F2F6CA40273_var*
//#UC END# *4F2F6E6301E4_4F2F6CA40273_var*
//#UC START# *4F2F6E8500D5_4F2F6CA40273_impl*
 f_Width := f_Widths[anIndex];
 f_Offset := f_Offsets[anIndex];
//#UC END# *4F2F6E8500D5_4F2F6CA40273_impl*
//#UC START# *4F2F6E8500D5_4F2F6CA40273_var*
//#UC END# *4F2F6E8500D5_4F2F6CA40273_var*
//#UC START# *4F2F6EAB0342_4F2F6CA40273_impl*
 Result := f_Offset;
//#UC END# *4F2F6EAB0342_4F2F6CA40273_impl*
//#UC START# *4F2F6EAB0342_4F2F6CA40273_var*
//#UC END# *4F2F6EAB0342_4F2F6CA40273_var*
//#UC START# *4F2F6EC7021E_4F2F6CA40273_impl*
 f_Width := aWidth;
//#UC END# *4F2F6EC7021E_4F2F6CA40273_impl*
//#UC START# *4F2F6EC7021E_4F2F6CA40273_var*
//#UC END# *4F2F6EC7021E_4F2F6CA40273_var*
//#UC START# *4F2F6EE10292_4F2F6CA40273_impl*
 Result := f_Width;
//#UC END# *4F2F6EE10292_4F2F6CA40273_impl*
//#UC START# *4F2F6EE10292_4F2F6CA40273_var*
//#UC END# *4F2F6EE10292_4F2F6CA40273_var*
//#UC START# *4F2F6EFA02E7_4F2F6CA40273_impl*
 if anIndex = -1 then
 begin
  f_Offset := f_Offset + aDelta;
  f_Widths.Last := f_Widths.Last + aDelta;
 end // if anIndex = -1 then
 else
  f_Widths[anIndex] := f_Widths[anIndex] + aDelta;
//#UC END# *4F2F6EFA02E7_4F2F6CA40273_impl*
//#UC START# *4F2F6EFA02E7_4F2F6CA40273_var*
//#UC END# *4F2F6EFA02E7_4F2F6CA40273_var*
//#UC START# *4F2FC2F502F6_4F2F6CA40273_impl*
 Result := False;
 Assert(f_Widths <> nil);
 l_Result := anIterator.CellsCount = f_Widths.Count;
 if l_Result then
 begin
  l_Cell := anIterator.First(False);
  l_Delta := 4 * evCellWidthEpsilon;
  for i := 0 to f_Widths.Count - 1 do
  begin
   l_Result := Abs(l_Cell.Width - f_Widths[i]) <= l_Delta;
   if not l_Result then
    l_Result := ((l_Cell.Width < evCellWidthEpsilon) or (l_Cell.Width > cnTooBigCellWidth)) and not l_Cell.IsEmptyCell;
   if not l_Result then Break;
   l_Cell := anIterator.Next;
  end; // for i := 0 to f_Widths.Count - 1 do
  if l_Result then
   Result := True;
 end; // if not l_Result then
//#UC END# *4F2FC2F502F6_4F2F6CA40273_impl*
//#UC START# *4F2FC2F502F6_4F2F6CA40273_var*
const
 cnTooBigCellWidth = 1000000;
var
 i        : Integer;
 l_Cell   : IedCell;
 l_Delta  : Integer;
 l_Result : Boolean;
//#UC END# *4F2FC2F502F6_4F2F6CA40273_var*
//#UC START# *4F2FCECA004D_4F2F6CA40273_impl*
 CheckList;
 if anIterator = nil then
 begin
  f_Widths.Assign(aData.f_Widths);
  f_Offsets.Assign(aData.f_Offsets);
 end // if anIterator = nil then
 else
 begin
  f_Widths.Capacity := anIterator.CellsCount;
  f_Offsets.Capacity := anIterator.CellsCount;
  l_Cell := anIterator.First(False);
  l_Offset := 0;
  while l_Cell <> nil do
  begin
   f_Widths.Add(l_Cell.Width);
   f_Offsets.Add(l_Offset);
   Inc(l_Offset, l_Cell.Width);
   l_Cell := anIterator.Next;
  end; // while l_Cell <> nil do
 end; // if anIterator = nil then
//#UC END# *4F2FCECA004D_4F2F6CA40273_impl*
//#UC START# *4F2FCECA004D_4F2F6CA40273_var*
var
 l_Cell   : IedCell;
 l_Offset : Integer;
//#UC END# *4F2FCECA004D_4F2F6CA40273_var*
//#UC START# *4F2FD1E202A4_4F2F6CA40273_impl*
 if (f_Offsets = nil) then
  f_Offsets := TevOneCharLongIntList.Make;
 if (f_Widths = nil) then
  f_Widths := TevOneCharLongIntList.Make;
//#UC END# *4F2FD1E202A4_4F2F6CA40273_impl*
//#UC START# *4F2FD1E202A4_4F2F6CA40273_var*
//#UC END# *4F2FD1E202A4_4F2F6CA40273_var*
//#UC START# *4FAB832701E6_4F2F6CA40273_impl*
 Result := 0;
 l_Count := f_Widths.Count - 1;
 for i := 0 to l_Count do
 begin
  //if (i = l_Count) and (f_Widths[i] = evCellWidthEpsilon) then Break; // http://mdp.garant.ru/pages/viewpage.action?pageId=206078013
  Inc(Result, f_Widths[i]);
 end; // for i := 0 to l_Count do
//#UC END# *4FAB832701E6_4F2F6CA40273_impl*
//#UC START# *4FAB832701E6_4F2F6CA40273_var*
var
 i       : Integer;
 l_Count : Integer;
//#UC END# *4FAB832701E6_4F2F6CA40273_var*
//#UC START# *4FC773170099_4F2F6CA40273_impl*
 l_Index := f_Widths.Count - 1;
 l_PrevIndex := aData.f_Widths.Count - 1;
 if l_Index <= l_PrevIndex then
 begin
  l_RowWidth := aData.GetRowWidth;
  while l_Index > 0 do
  begin
   f_Widths[l_Index] := aData.f_Widths[l_PrevIndex];
   Dec(l_RowWidth, f_Widths[l_Index]);
   Dec(l_Index);
   Dec(l_PrevIndex);
  end; // while l_Index > 0 do
  f_Widths[l_Index] := l_RowWidth;
 end; // if l_Index < aData.f_Widths.Count then
//#UC END# *4FC773170099_4F2F6CA40273_impl*
//#UC START# *4FC773170099_4F2F6CA40273_var*
var
 l_Index       : Integer;
 l_PrevIndex   : Integer;
 l_RowWidth    : Integer;
 l_RightIndent : Integer;
//#UC END# *4FC773170099_4F2F6CA40273_var*
//#UC START# *50937BBB01BF_4F2F6CA40273_impl*
 Result := False;
 l_Count := f_Widths.Count;
 l_Result := anIterator.CellsCount <> l_Count;
 if not l_Result then
 begin
  l_Cell := anIterator.First(False);
  l_Equal := 0;
  for i := 0 to l_Count - 1 do
  begin
   if (Abs(l_Cell.Width - f_Widths[i]) < l_Cell.Width div 2) then
    Inc(l_Equal);
   l_Cell := anIterator.Next;
  end; // for i := 0 to l_List.Count - 1 do
  l_Result := l_Equal >= l_Count div 2;
  if not aForTempate and not l_Result then
   l_Result := f_UsingCount > 1;
  if l_Result then
   Result := True;
 end; // if not l_Result then
//#UC END# *50937BBB01BF_4F2F6CA40273_impl*
//#UC START# *50937BBB01BF_4F2F6CA40273_var*
var
 i        : Integer;
 l_Cell   : IedCell;
 l_Count  : Integer;
 l_Equal  : Integer;
 l_Result : Boolean;
//#UC END# *50937BBB01BF_4F2F6CA40273_var*
//#UC START# *509383B202C4_4F2F6CA40273_impl*
 Inc(f_UsingCount);
//#UC END# *509383B202C4_4F2F6CA40273_impl*
//#UC START# *509383B202C4_4F2F6CA40273_var*
//#UC END# *509383B202C4_4F2F6CA40273_var*
//#UC START# *52F1EC8D0285_4F2F6CA40273_impl*
  Result := f_Widths[anIndex];
//#UC END# *52F1EC8D0285_4F2F6CA40273_impl*
//#UC START# *52F1EC8D0285_4F2F6CA40273_var*
//#UC END# *52F1EC8D0285_4F2F6CA40273_var*
//#UC START# *52F1ECC0021F_4F2F6CA40273_impl*
 Result := f_Offsets[anIndex];
//#UC END# *52F1ECC0021F_4F2F6CA40273_impl*
//#UC START# *52F1ECC0021F_4F2F6CA40273_var*
//#UC END# *52F1ECC0021F_4F2F6CA40273_var*
//#UC START# *52F1ECE3002C_4F2F6CA40273_impl*
 Result := f_Offsets.Count;
//#UC END# *52F1ECE3002C_4F2F6CA40273_impl*
//#UC START# *52F1ECE3002C_4F2F6CA40273_var*
//#UC END# *52F1ECE3002C_4F2F6CA40273_var*
//#UC START# *52F1ED3803C8_4F2F6CA40273_impl*
 l_Delta := f_Offsets[anIndex] - anOffset;
 for i := anIndex - 1 downto 0 do
  if aCellTypeList[i] = ed_ctEmptyAndNotFramed then
  begin
   f_Widths[i] := f_Widths[i] - l_Delta;
   f_Offsets[i + 1] := f_Offsets[i] + f_Widths[i];
   Break;
  end; // if aCellTypeList[i] = ed_EmptyAndNotFramed then
//#UC END# *52F1ED3803C8_4F2F6CA40273_impl*
//#UC START# *52F1ED3803C8_4F2F6CA40273_var*
var
 i      : Integer;
 l_Delta: Integer;
//#UC END# *52F1ED3803C8_4F2F6CA40273_var*
