//#UC START# *479731C50290_502518C60255_impl*
 if f_ImgDLL <> 0 then
  FreeLibrary(f_ImgDLL);
 g_AlphaBlendFunc := nil;
//#UC END# *479731C50290_502518C60255_impl*
//#UC START# *479731C50290_502518C60255_var*
//#UC END# *479731C50290_502518C60255_var*
//#UC START# *47A042E100E2_502518C60255_impl*
 if Win32Platform = VER_PLATFORM_WIN32_NT then
 begin
  f_ImgDLL := SafeLoadLibrary(msimg32);
  if f_ImgDLL <> 0 then
   g_AlphaBlendFunc := TAlphaBlendFunc(GetProcAddress(f_ImgDLL, 'AlphaBlend'));
  if @g_AlphaBlendFunc = nil then
   FreeLibrary(f_ImgDLL);
 end;
//#UC END# *47A042E100E2_502518C60255_impl*
//#UC START# *47A042E100E2_502518C60255_var*
//#UC END# *47A042E100E2_502518C60255_var*
//#UC START# *4FD1F66B03D5_4FD1F6B00129_impl*
 aDest.Width := aSource.Width;
 aDest.Height := aSource.Height*2;
 aDest.PixelFormat := pf32Bit;
 for l_LineIdx := 0 to aSource.Height-1 do
 begin
  l_DestColor := aDest.Scanline[l_LineIdx];
  l_DestGray := aDest.Scanline[l_LineIdx+aSource.Height];
  l_Source := aSource.Scanline[l_LineIdx];
  l_Alpha := aSource.AlphaChannel.Scanline[l_LineIdx];
  for l_PixelIdx:=0 to aSource.Width-1 do
  begin
   with l_DestColor^ do
   begin
    r := l_Source^.r * l_Alpha^ div cFullAlpha;
    g := l_Source^.g * l_Alpha^ div cFullAlpha;
    b := l_Source^.b * l_Alpha^ div cFullAlpha;
    a := l_Alpha^;
   end;
   l_DisabledAlpha := l_Alpha^ * cDisabledAlpha div cFullAlpha;
   l_Gray := max(max(l_Source^.r, l_Source^.g),l_Source^.b) * l_DisabledAlpha div cFullAlpha;
   with l_DestGray^ do
   begin
    r := l_Gray;
    g := l_Gray;
    b := l_Gray;
    a := l_DisabledAlpha;
   end;
   inc(l_Source);
   inc(l_DestColor);
   inc(l_DestGray);
   inc(l_Alpha);
  end;
 end;
 aDest.Dormant;
//#UC END# *4FD1F66B03D5_4FD1F6B00129_impl*
//#UC START# *4FD1F66B03D5_4FD1F6B00129_var*
var
 l_LineIdx, l_PixelIdx: integer;
 l_DestColor: pRGBA;
 l_DestGray: pRGBA;
 l_Source: PRGB;
 l_Alpha: PByte;
 l_DisabledAlpha: Byte;
 l_Gray: Byte;
//#UC END# *4FD1F66B03D5_4FD1F6B00129_var*
//#UC START# *4FD1F6FB00AF_4FD1F6B00129_impl*
 if Assigned(g_AlphaBlendFunc) then
  Result := g_AlphaBlendFunc(DestDC, X, Y, Width, Height, SrcDC, XSrc,
  YSrc, SrcWidth, SrcHeight, BlendFunc)
 else
 begin
  SetLastError(ERROR_INVALID_FUNCTION);
  Result := false;
 end;
//#UC END# *4FD1F6FB00AF_4FD1F6B00129_impl*
//#UC START# *4FD1F6FB00AF_4FD1F6B00129_var*
//#UC END# *4FD1F6FB00AF_4FD1F6B00129_var*
//#UC START# *4FD1F75F023A_4FD1F6B00129_impl*
 if HalfTransparent
  then Result := aTransparensy div 2
  else Result := aTransparensy;
//#UC END# *4FD1F75F023A_4FD1F6B00129_impl*
//#UC START# *4FD1F75F023A_4FD1F6B00129_var*
//#UC END# *4FD1F75F023A_4FD1F6B00129_var*
//#UC START# *4FD1F77B0267_4FD1F6B00129_impl*
 if TvtilCreators.IsAssigned then
  TvtilCreators.Instance.IterateAllF(l3L2IA(@DoItem));
 try
  if (g_PILList <> nil) then
   g_PILList.IterateAll(anAction);
 finally
  l3FreeIA(anAction);
 end;//try..finally  
//#UC END# *4FD1F77B0267_4FD1F6B00129_impl*
//#UC START# *4FD1F77B0267_4FD1F6B00129_var*
 function DoItem(P: PPointer; Index: Long): Bool;
 begin//DoItem
  if (P^ <> nil) then
   TvtImageListCreatorProc(P^);
  P^ := nil;
  Result := true;
 end;//DoItem
//#UC END# *4FD1F77B0267_4FD1F6B00129_var*
//#UC START# *4FD1F81F02CF_4FD1F6B00129_impl*
 AddImageListCreatorPrim(TvtImageListCreatorProc(aCreator));
//#UC END# *4FD1F81F02CF_4FD1F6B00129_impl*
//#UC START# *4FD1F81F02CF_4FD1F6B00129_var*
//#UC END# *4FD1F81F02CF_4FD1F6B00129_var*
//#UC START# *4FD1F900009A_4FD1F6B00129_impl*
 TvtilCreators.Instance.Add(TProcedure(aCreator));
//#UC END# *4FD1F900009A_4FD1F6B00129_impl*
//#UC START# *4FD1F900009A_4FD1F6B00129_var*
//#UC END# *4FD1F900009A_4FD1F6B00129_var*
//#UC START# *4FD1F96300AF_4FD1F6B00129_impl*
 if aSize = ps16x16
  then Result := ps24x24
  else Result := ps16x16;
//#UC END# *4FD1F96300AF_4FD1F6B00129_impl*
//#UC START# *4FD1F96300AF_4FD1F6B00129_var*
//#UC END# *4FD1F96300AF_4FD1F6B00129_var*
//#UC START# *4FD1F98902AB_4FD1F6B00129_impl*
 case aBpp of
  bpp24: Result := bpp8;
  bpp8: Result := bpp4;
 else
  Result := bpp24;
 end;
//#UC END# *4FD1F98902AB_4FD1F6B00129_impl*
//#UC START# *4FD1F98902AB_4FD1F6B00129_var*
//#UC END# *4FD1F98902AB_4FD1F6B00129_var*
//#UC START# *4FD1F9AA00E5_4FD1F6B00129_impl*
 DC := GetDC(0);
 try
  Result := GetDeviceCaps(DC, BITSPIXEL);
 finally
  ReleaseDC(0, DC);
 end;
//#UC END# *4FD1F9AA00E5_4FD1F6B00129_impl*
//#UC START# *4FD1F9AA00E5_4FD1F6B00129_var*
var
 DC: HDC;
//#UC END# *4FD1F9AA00E5_4FD1F6B00129_var*
//#UC START# *4FD1F9CB0196_4FD1F6B00129_impl*
 case GetScreenCOlorDepth of
  1..4: Result := bpp4;
  8: Result := bpp8;
  16,24,32: Result := bpp24;
 else
  raise Exception.Create('Не удалось определить глубину цвета экрана');
 end;
//#UC END# *4FD1F9CB0196_4FD1F6B00129_impl*
//#UC START# *4FD1F9CB0196_4FD1F6B00129_var*
//#UC END# *4FD1F9CB0196_4FD1F6B00129_var*
//#UC START# *4FD1F9E601E9_4FD1F6B00129_impl*
 I := GetScreenCOlorDepth;
 l_NeedReset := I <> g_ScreenColorDepth;
 g_ScreenColorDepth := I;
 if g_PILList <> nil then
 begin
  for I := 0 to Pred(g_PILList.Count) do
  begin
   if g_PILList[I] is TvtPngImageList then
   begin
    if l_NeedReset then
     TvtPngImageList(g_PILList[I]).ClearCache;
    TvtPngImageList(g_PILList[I]).CurBpp := aBpp;
   end;
   if g_PILList[I] is TvtNonFixedPngImageList then
   begin
    if l_NeedReset then
     TvtNonFixedPngImageList(g_PILList[I]).ClearCache;
    TvtNonFixedPngImageList(g_PILList[I]).CurBpp := aBpp;
   end;
  end;
 end;
//#UC END# *4FD1F9E601E9_4FD1F6B00129_impl*
//#UC START# *4FD1F9E601E9_4FD1F6B00129_var*
var
 I: Integer;
 l_NeedReset: Boolean;
//#UC END# *4FD1F9E601E9_4FD1F6B00129_var*
//#UC START# *4FD318100335_4FD31272000C_impl*
 Result := Assigned(g_TvtilCreators);
//#UC END# *4FD318100335_4FD31272000C_impl*
//#UC START# *4FD318100335_4FD31272000C_var*
//#UC END# *4FD318100335_4FD31272000C_var*
