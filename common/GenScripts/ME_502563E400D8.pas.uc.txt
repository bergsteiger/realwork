//#UC START# *48077504027E_502563E400D8_impl*
  Size := 0;
  inherited;
//#UC END# *48077504027E_502563E400D8_impl*
//#UC START# *48077504027E_502563E400D8_var*
//#UC END# *48077504027E_502563E400D8_var*
//#UC START# *5025646900CB_502563E400D8set_impl*
  if aValue <> Size then
  begin
    l_NewMemSize := GetBufSize(aValue);
    l_OldMemSize := GetBufSize(Size);
    if l_NewMemSize <> l_OldMemSize then
    begin
      l_NewMem := nil;
      if l_NewMemSize <> 0 then
      begin
        GetMem(l_NewMem, l_NewMemSize);
        FillChar(l_NewMem^, l_NewMemSize, 0);
      end;
      if l_OldMemSize <> 0 then
      begin
        if l_NewMem <> nil then
          Move(f_Bits^, l_NewMem^, Min(l_OldMemSize, l_NewMemSize));
        FreeMem(f_Bits, l_OldMemSize);
      end;
      f_Bits := l_NewMem;
    end;
    f_Size := aValue;
  end;
//#UC END# *5025646900CB_502563E400D8set_impl*
//#UC START# *5025646900CB_502563E400D8set_var*
  var
    l_NewMem: Pointer;
    l_NewMemSize, l_OldMemSize: Integer;

  function Min(X, Y: Integer): Integer;
  begin
    Result := X;
    if X > Y then Result := Y;
  end;
//#UC END# *5025646900CB_502563E400D8set_var*
//#UC START# *502565320313_502563E400D8get_impl*
  asm
    MOV EAX, [Self]
    MOV EAX, [EAX].f_Bits
    MOV ECX, anIndex
    BT  [EAX], ECX
    SBB EAX, EAX
    AND EAX, 1
    MOV Result, AL
  end;
//#UC END# *502565320313_502563E400D8get_impl*
//#UC START# *502565320313_502563E400D8get_var*
//#UC END# *502565320313_502563E400D8get_var*
//#UC START# *502565320313_502563E400D8set_impl*
  asm
    MOV ECX, anIndex
    MOV EDX, [Self]
    MOV EDX, [EDX].f_Bits
    MOV AL, aValue
    OR AL, AL
    JZ  @@2
    BTS [EDX], ECX
    JMP @@quit

  @@2:
    BTR [EDX], ECX

  @@quit:
  end;
//#UC END# *502565320313_502563E400D8set_impl*
//#UC START# *502565320313_502563E400D8set_var*
//#UC END# *502565320313_502563E400D8set_var*
//#UC START# *5025659F0300_502563E400D8_impl*
  Result := -1;

  l_Start := Pointer(Integer(f_Bits) + GetBufSize(aStartIndex+1) - SizeOf(Integer));
  Assert(Integer(l_Start) mod SizeOf(Integer) = 0, 'Integer(l_Start) mod SizeOf(Integer) = 0'); // указатель должен быть кратен SizeOf(Int)
  l_LastOfBits := Pointer(Integer(f_Bits) + GetBufSize(Size) - SizeOf(Integer));

  if aSetBit then
    l_InvertMask := 0
  else
    l_InvertMask := $FFFFFFFF;

  l_LastBlockMask := ($FFFFFFFF shr (GetBufSize(Size) * BITS_PER_INT - Size));

  if aForward then
    l_FirstBlockMask := $FFFFFFFF shl (aStartIndex AND $1F)
  else
    l_FirstBlockMask := ($FFFFFFFF shl ((aStartIndex AND $1F)+1)) XOR $FFFFFFFF;

  asm
    MOV EAX, [l_Start]  // EAX содержит адрес с которого ищем
    MOV EDX, [EAX]
    XOR EDX, l_InvertMask // инвертируем для поиска сброшенных битов
    AND EDX, l_FirstBlockMask // из первого блока вырезаем биты младше стартового индекса

    MOV CL, aForward
    CMP CL, 0
    JE @@backward_search

  // ищем нужный бит по увеличению индекса
  @@forward_search:
    MOV ECX, [l_LastOfBits] // ECX содержит границу буфера - конец
    CMP EAX, ECX
    JE @@forward_last_block
    //
  @@forward_cycle:
    BSF EDX, EDX
    JNE @@found
    CMP ECX, 0
    JE @@quit
    ADD EAX, $04 // передвигаем указатель на 4 байта дальше
    MOV EDX, [EAX]
    XOR EDX, l_InvertMask // инвертируем для поиска сброшенных битов
    CMP EAX, ECX // достигли начала буфера?
    JNE @@forward_cycle
  @@forward_last_block:
    AND EDX, l_LastBlockMask // из последнего блока вырезаем биты старше чем размер
    MOV ECX, 0 // следующая проверка станет последней
    JMP @@forward_cycle

  // ищем нужный бит по уменьшению индекса
  @@backward_search:
    MOV ECX, [Self]
    MOV ECX, [ECX].f_Bits // ECX содержит границу - начало буфера
    CMP EAX, ECX
    JNE @@backward_cycle
    AND EDX, l_LastBlockMask
    //
  @@backward_cycle:
    BSR EDX, EDX
    JNE @@found
    CMP EAX, ECX
    JE @@quit
    SUB EAX, $04 // передвигаем указатель на 4 байта ближе
    MOV EDX, [EAX]
    XOR EDX, l_InvertMask
    JMP @@backward_cycle

  @@found:
    MOV ECX, [Self]
    MOV ECX, [ECX].f_Bits
    SUB EAX, ECX // разница между указателями в байтах
    IMUL EAX, $8 // 8 битов в байте
    ADD EDX, EAX // EDX содержит номер последнего установленного бита от начала буфера
    MOV Result, EDX
  @@quit:
  end;
//#UC END# *5025659F0300_502563E400D8_impl*
//#UC START# *5025659F0300_502563E400D8_var*
  var
    l_Start, l_LastOfBits : Pointer;
    l_InvertMask, l_LastBlockMask, l_FirstBlockMask : Longword;
//#UC END# *5025659F0300_502563E400D8_var*
//#UC START# *502565EE034B_502563E400D8_impl*
  Result := ((aBitsCount + BITS_PER_INT - 1) div BITS_PER_INT) * SizeOf(Integer);
//#UC END# *502565EE034B_502563E400D8_impl*
//#UC START# *502565EE034B_502563E400D8_var*
//#UC END# *502565EE034B_502563E400D8_var*
//#UC START# *5025661502E8_502563E400D8_impl*
  Result := GetBitFrom(Size-1, false, true);
//#UC END# *5025661502E8_502563E400D8_impl*
//#UC START# *5025661502E8_502563E400D8_var*
//#UC END# *5025661502E8_502563E400D8_var*
//#UC START# *5025662B0086_502563E400D8_impl*
  l_StartIndex := Random(Size);
  l_Direction := Random > 0.5;
  Result := GetBitFrom(l_StartIndex, l_Direction, false);
  if Result = -1 then
    Result := GetBitFrom(l_StartIndex, NOT l_Direction, false);
//#UC END# *5025662B0086_502563E400D8_impl*
//#UC START# *5025662B0086_502563E400D8_var*
  var
    l_StartIndex : Integer;
    l_Direction : Boolean;
//#UC END# *5025662B0086_502563E400D8_var*
//#UC START# *5025664301E6_502563E400D8_impl*
  l_Size := Size;
  Size := 0;
  Size := l_Size;
//#UC END# *5025664301E6_502563E400D8_impl*
//#UC START# *5025664301E6_502563E400D8_var*
  var
    l_Size : Integer;
//#UC END# *5025664301E6_502563E400D8_var*
//#UC START# *5025664D00CC_502563E400D8_impl*
  l_Handle := CreateFile(PAnsiChar(aFileName), GENERIC_WRITE, FILE_SHARE_READ, nil, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
  if l_Handle = INVALID_HANDLE_VALUE then
    Raise Exception.Create( SysErrorMessage(GetLastError) );

  try
    FileSeek(l_Handle, 0, 0);
    FileWrite(l_Handle, f_Size, SizeOf(f_Size));
    FileWrite(l_Handle, f_Bits^, GetBufSize(f_Size));
  finally
    CloseHandle(l_Handle);
  end;
//#UC END# *5025664D00CC_502563E400D8_impl*
//#UC START# *5025664D00CC_502563E400D8_var*
  var
    l_Handle : Windows.THandle;
//#UC END# *5025664D00CC_502563E400D8_var*
//#UC START# *50256663004A_502563E400D8_impl*
  l_Handle := CreateFile(PAnsiChar(aFileName), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  if l_Handle = INVALID_HANDLE_VALUE then
    Raise Exception.Create( SysErrorMessage(GetLastError) );

  try
    FileSeek(l_Handle, 0, 0);
    FileRead(l_Handle, l_Size, SizeOf(l_Size));
    Size := l_Size;
    FileRead(l_Handle, f_Bits^, GetBufSize(Size));
  finally
    CloseHandle(l_Handle);
  end;
//#UC END# *50256663004A_502563E400D8_impl*
//#UC START# *50256663004A_502563E400D8_var*
  var
    l_Handle : Windows.THandle;
    l_Size : Integer;
//#UC END# *50256663004A_502563E400D8_var*
