//#UC START# *467D2CB10135_508EBA08009F_impl*
 // Применим изменения таблицы стилей, нужно чтобы до процесса размещения у
 // компонентов установились новые размеры:
 if f_Grid <> nil then
 begin
  for l_Index := 0 to Pred(ComponentCount) do
   if Supports(Components[l_Index], IafwStyleTableSpy, l_Spy) then
   try
    l_Spy.StyleTableChanged;
   finally
    l_Spy := nil;
   end;//try..finally
 end;//if f_Grid <> nil then
 // Разместим:
 ArrangeGrid(True);
//#UC END# *467D2CB10135_508EBA08009F_impl*
//#UC START# *467D2CB10135_508EBA08009F_var*
var
 l_Index: Integer;
 l_Spy: IafwStyleTableSpy;
//#UC END# *467D2CB10135_508EBA08009F_var*
//#UC START# *46A4504B03C4_508EBA08009F_impl*
 case TvcmTaskPanelOperation(aOperation) of
  cvcm_tpBeforeUpdate: LockView;
  cvcm_tpAfterUpdate: UnLockView;
 end;//case aOperation of
//#UC END# *46A4504B03C4_508EBA08009F_impl*
//#UC START# *46A4504B03C4_508EBA08009F_var*
//#UC END# *46A4504B03C4_508EBA08009F_var*
//#UC START# *46A450C703AE_508EBA08009F_impl*
 if (aOperation = cvcm_tpGroupAdded) and
  Supports(aInterface, IvcmCustOpsGroup, l_Group) then
 try
  AddGroup(l_Group);
  if not SortGroups then
   ArrangeGrid;
 finally
  l_Group := nil;
 end;//try..finally
//#UC END# *46A450C703AE_508EBA08009F_impl*
//#UC START# *46A450C703AE_508EBA08009F_var*
var
 l_Group: IvcmCustOpsGroup;
//#UC END# *46A450C703AE_508EBA08009F_var*
//#UC START# *479731C50290_508EBA08009F_impl*
 {$If not defined(DesignTimeLibrary)}
 evDelStyleTableSpy(Self);
 {$IfEnd}
 if (TasksPanel <> nil) then
  TasksPanel.As_Il3ChangeNotifier.Unsubscribe(Il3ItemNotifyRecipient(Self));
 if (TasksPanel <> nil) then
  TasksPanel.As_Il3ChangeNotifier.Unsubscribe(IvcmTaskPanelNotifyRecipient(Self));
 f_TasksPanel := nil;
 f_Grid := nil;
 f_TabTable := nil;
 inherited;
//#UC END# *479731C50290_508EBA08009F_impl*
//#UC START# *479731C50290_508EBA08009F_var*
//#UC END# *479731C50290_508EBA08009F_var*
//#UC START# *47D1602000C6_508EBA08009F_impl*
 inherited;
 ParentColor := False;
 f_CollapseGroupImage := -1;
 f_ExpandGroupImage := -1;
 f_GroupColor := clNavy;
 {$IfNDef DesignTimeLibrary}
 evAddStyleTableSpy(Self);
 {$EndIf DesignTimeLibrary}
 f_UpdateRequests := 0;
//#UC END# *47D1602000C6_508EBA08009F_impl*
//#UC START# *47D1602000C6_508EBA08009F_var*
//#UC END# *47D1602000C6_508EBA08009F_var*
//#UC START# *48C6C044025E_508EBA08009F_impl*
 inherited;
 {$IfDef DesignTimeLibrary}
 with CN, Canvas do
 begin
  Pen.Color := clBlack;
  Pen.Width := 2;
  Brush.Color := Self.Color;
  l_Rect := Rect(0, 0, Width, Height);
  InflateRect(l_Rect, -2, -2);
  Rectangle(l_Rect);
  InflateRect(l_Rect, -4, -4);
  DrawText(l3PCharLen('TasksPanelView is RunTime control. It don`t allow ' +
   'edit anything in DesignTime.'), l_Rect, DT_CENTER or DT_VCENTER or
   DT_WORDBREAK);
 end;//with CN.Canvas do
 {$Else DesignTimeLibrary}
 // Таблица не пустая, нужно залить подложку без
 // дочерних компонентов (K<104435077>):
 if not Grid.IsEmpty then
 begin
  l_Rgn := Tl3Region.Make;
  try
   l_SRect.InitRect(ClientRect);
   l_Rgn.Rect := l_SRect;
   with Grid do
    l_SRect.InitRect(Rect(Left, Top, LastColumn.Right, LastRow.Bottom));
   if l_Rgn.CombineRect(l_SRect, RGN_DIFF) <> NULLREGION then
    with CN, Canvas do
    begin
     Brush.Color := Self.Color;
     FillRgn(l_Rgn);
    end;//with CN do
  finally
   l_Rgn := nil;
  end;
 end
 else
 begin
  l_SRect.InitRect(Self.ClientRect);
  CN.FillRect(l_SRect);
 end;//if not Grid.IsEmpty then
 {$EndIf DesignTimeLibrary}
//#UC END# *48C6C044025E_508EBA08009F_impl*
//#UC START# *48C6C044025E_508EBA08009F_var*
var
{$IfDef DesignTimeLibrary}
 l_Rect: TRect;
{$Else DesignTimeLibrary}
 l_Rgn   : Il3Region;
 l_SRect : Tl3SRect;
{$EndIf DesignTimeLibrary}
//#UC END# *48C6C044025E_508EBA08009F_var*
//#UC START# *4CC8417A0288_508EBA08009F_impl*
 inherited;
 ArrangeGrid;
//#UC END# *4CC8417A0288_508EBA08009F_impl*
//#UC START# *4CC8417A0288_508EBA08009F_var*
//#UC END# *4CC8417A0288_508EBA08009F_var*
//#UC START# *508EB28F03DA_508EBA08009Fset_impl*
 if (f_TasksPanel <> aValue) then
 begin
  if (f_TasksPanel <> nil) then
  begin
//   MakeTasksPanel;
   f_TasksPanel.As_Il3ChangeNotifier.UnSubscribe(IvcmTaskPanelNotifyRecipient(Self));
   f_TasksPanel.As_Il3ChangeNotifier.UnSubscribe(Il3ItemNotifyRecipient(Self));
  end;//f_TasksPanel <> nil
  f_TasksPanel := aValue;
  if (f_TasksPanel <> nil) then
  begin
   f_TasksPanel.As_Il3ChangeNotifier.Subscribe(IvcmTaskPanelNotifyRecipient(Self));
   f_TasksPanel.As_Il3ChangeNotifier.Subscribe(Il3ItemNotifyRecipient(Self));
   MakeTasksPanel;
  end;//f_TasksPanel <> nil
 end;//f_TasksPanel <> aValue
//#UC END# *508EB28F03DA_508EBA08009Fset_impl*
//#UC START# *508EB28F03DA_508EBA08009Fset_var*
//#UC END# *508EB28F03DA_508EBA08009Fset_var*
//#UC START# *508EB30E0238_508EBA08009Fset_impl*
 f_GroupImages := aValue;
//#UC END# *508EB30E0238_508EBA08009Fset_impl*
//#UC START# *508EB30E0238_508EBA08009Fset_var*
//#UC END# *508EB30E0238_508EBA08009Fset_var*
//#UC START# *508EBA08009F_ext:ParentFileName
w:\common\components\gui\Garant\Nemesis\nscTasksPanelView.pas
//#UC END# *508EBA08009F_ext:ParentFileName
//#UC START# *508EBAB102AA_508EBA08009F_impl*
 aMessage.Result := 1;
//#UC END# *508EBAB102AA_508EBA08009F_impl*
//#UC START# *508EBAB102AA_508EBA08009F_var*
//#UC END# *508EBAB102AA_508EBA08009F_var*
//#UC START# *508EBB16008E_508EBA08009F_impl*
 if aGroup.IsLinkToExistingControl then
 begin
  l_Control := aGroup.Control;
  Assert(l_Control <> nil);
  l_TreeView := nil;
 end//aGroup.IsLinkToExistingControl
 else
 begin
  l_TreeView := TnscTasksPanelTreeView.Create(Self, aGroup);
  l_TreeView.Name := Self.Name + '_' +  IntToStr(aGroup.Position) + '_' + IntToStr(aGroup.RepGroup.ID);
  l_Control := l_TreeView;
 end;//aGroup.IsLinkToExistingControl

  // компонент может не быть удален из-за взведенного счетчика ссылок
  // http://mdp.garant.ru/pages/viewpage.action?pageId=522786290
 l_TmpComponent := Self.FindComponent('field_' + l_Control.Name);
 if Assigned(l_TmpComponent) then
 begin
  l_TmpComponent.Name := '';
 end;

 l_HideField := TnscTasksPanelHideField.Create(Self, aGroup);
 l_HideField.Name := 'field_' + l_Control.Name;
 with l_HideField do
 begin
  Parent := Self;
  ClientControl := l_Control;
  Font.Style := [fsBold];
  Options := [hfoCanHide];
  LeftHeaderIndent := 5;
  TopHeaderIndent := 5;
  ButtonImageList := GroupImages;
  {$IfDef HideFieldVgSceneStyle}
  { Для DFM-a не подходит $IfDef, и подгружаемые из TasksPanel_Form.dfm индексы картинок
    затирают значения, установленные в TPrimContentsForm.InitLists. Поэтому выставляем их явно. }
  CollapseGroupImage := 2;
  ExpandGroupImage := 3;
  {$EndIf HideFieldVgSceneStyle}
  ButtonOpenImage := ExpandGroupImage;
  ButtonCloseImage := CollapseGroupImage;
  HeaderColor := GroupColor;
  TabStop := True;
//  l_HideField.Perform(CM_FONTCHANGED, 0, 0);
 {$IfDef HideFieldVgSceneStyle}
  SetBitmapButton;
 {$EndIf HideFieldVgSceneStyle}
 end;//with l_HideField do
 if (l_TreeView = nil) then
 begin
//  l_Control.Parent := l_HideField;
 end//l_TreeView = nil
 else
  l_TreeView.Images := ImageList;
 // Сетка контролов:
 with Grid do
 begin
  AddRow;
  Cell[Pred(RowCount), 0] := TnscHideFieldCell.Make(l_HideField, false{(l_TreeView = nil)});
 end;//with f_Grid do
 // Сетка перехода фокуса:
 with TabTable do
 begin
  if ColumnCount = 0 then
   AddColumn;
  if (l_TreeView = nil) then
  begin
   if (l_Control is TeeTreeView) then
    Column[0].AddItem(TnscTreeViewTabCell.Make(TeeTreeView(l_Control)))
   else
    Column[0].AddItem(TnscTabCell.Make(l_Control));
  end//l_TreeView = nil
  else
   Column[0].AddItem(TnscTreeViewTabCell.Make(l_TreeView));
 end;//with TabTable do
//#UC END# *508EBB16008E_508EBA08009F_impl*
//#UC START# *508EBB16008E_508EBA08009F_var*
var
 l_HideField: TnscTasksPanelHideField;
 l_TreeView: TnscTasksPanelTreeView;
 l_Control: TWinControl;
 l_TmpComponent: TComponent;
//#UC END# *508EBB16008E_508EBA08009F_var*
//#UC START# *508EBB35000D_508EBA08009F_impl*
 ArrangeGrid;
//#UC END# *508EBB35000D_508EBA08009F_impl*
//#UC START# *508EBB35000D_508EBA08009F_var*
//#UC END# *508EBB35000D_508EBA08009F_var*
//#UC START# *508EBB4E0337_508EBA08009F_impl*
 if not IsViewLocked then
  Grid.BeginUpdate;
 Inc(f_UpdateRequests);
//#UC END# *508EBB4E0337_508EBA08009F_impl*
//#UC START# *508EBB4E0337_508EBA08009F_var*
//#UC END# *508EBB4E0337_508EBA08009F_var*
//#UC START# *508EBB5B038C_508EBA08009F_impl*
 Dec(f_UpdateRequests);
 if not IsViewLocked then
 begin
  Grid.EndUpdate;
  // http://mdp.garant.ru/pages/viewpage.action?pageId=505415962
  if HandleAllocated then
   ArrangeGrid(True);
 end;//if not IsViewLocked then
//#UC END# *508EBB5B038C_508EBA08009F_impl*
//#UC START# *508EBB5B038C_508EBA08009F_var*
//#UC END# *508EBB5B038C_508EBA08009F_var*
//#UC START# *508EBB6A02D9_508EBA08009F_impl*
 if Assigned(f_OnOperationExecute) then
  f_OnOperationExecute(Self);
//#UC END# *508EBB6A02D9_508EBA08009F_impl*
//#UC START# *508EBB6A02D9_508EBA08009F_var*
//#UC END# *508EBB6A02D9_508EBA08009F_var*
//#UC START# *508EBB7A001F_508EBA08009F_impl*
 if (TasksPanel <> nil) then
 begin
  f_Grid := nil;
  TabTable.Clear;
  for I := ControlCount - 1 downto 0 do
   if (Controls[I].Owner = Self) then
   begin
    if (Controls[I] is TWinControl) then
    begin
     l_WC := TWinControl(Controls[I]);
     for J := l_WC.ControlCount - 1 downto 0 do
      if (l_WC.Controls[J] is TWinControl) then
      begin
       if (l_WC.Controls[J].Owner = Self) then
       begin
        with l_WC.Controls[J] do
        begin
         Parent := nil;
         Free;
        end;
       end
       else
        TWinControl(l_WC.Controls[J]).Parent := Self.Parent;
      end//l_WC.Controls[0] is TWinControl
      else
       Assert(false);
    end;//Controls[0] is TWinControl
    with Controls[I] do
    begin
     Parent := nil;
     Free;
    end;
   end//Controls[0].Owner = Self
   else
    Assert(false);
  l_Iterator := TasksPanel.Groups;
  try
   l_Group := l_Iterator.Next;
   while l_Group <> nil do
   begin
    AddGroup(l_Group);
    l_Group := l_Iterator.Next;
   end;//while l_Group <> nil do
  finally
   l_Iterator := nil;
  end;//try..finally
  if not SortGroups then
   ArrangeGrid;
 end;//if TasksPanel <> nil then
//#UC END# *508EBB7A001F_508EBA08009F_impl*
//#UC START# *508EBB7A001F_508EBA08009F_var*
var
 l_Iterator: IvcmCustOpsGroupsIterator;
 l_Group: IvcmCustOpsGroup;
 l_WC: TWinControl;

 I, J: Integer;
//#UC END# *508EBB7A001F_508EBA08009F_var*
//#UC START# *508EBB87010C_508EBA08009F_impl*
 TabTable.Clear;
 if Grid.ColumnCount > 0 then
  with Grid.Column[0] do
   for l_Index := 0 to Pred(CellCount) do
    if Supports(Cell[l_Index], IagControlCell, l_Cell) then
    try
     if TabTable.ColumnCount = 0 then
      TabTable.AddColumn;
     with TabTable.Column[0] do
     begin
      // HideField
      AddItem(TnscHideFieldTabCell.Make(TvtHideField(l_Cell.Control)));
      // TreeView
      AddItem(TnscTreeViewTabCell.Make(TnscTasksPanelTreeView(
       TvtHideField(l_Cell.Control).ClientControl)));
     end;//with TabTable.Column[0] do
    finally
     l_Cell := nil;
    end;//try..finally
//#UC END# *508EBB87010C_508EBA08009F_impl*
//#UC START# *508EBB87010C_508EBA08009F_var*
var
 l_Index: Integer;
 l_Cell: IagControlCell;
//#UC END# *508EBB87010C_508EBA08009F_var*
//#UC START# *508EBB960031_508EBA08009F_impl*
 if (f_Grid <> nil) and not IsViewLocked then
 begin
  if aRecalc then
   f_Grid.Recalc;
  agArrangeGrid(f_Grid, afw.GetParentForm(Self), Self, 0);
 end;//if f_Grid <> nil then
//#UC END# *508EBB960031_508EBA08009F_impl*
//#UC START# *508EBB960031_508EBA08009F_var*
//#UC END# *508EBB960031_508EBA08009F_var*
//#UC START# *508EBBB1038A_508EBA08009F_impl*
 for l_Index := 0 to Pred(Grid.RowCount) do
  if Supports(Grid.Cell[l_Index, 0], IagControlCell, l_Cell) then
  try
   if l_Cell.Control = aHideField then
   begin
    l_Cell.Control := nil;
    Grid.Row[l_Index].Delete;
    aHideField.Free;
    ArrangeGrid(True);
    MakeTabTable;
    Break;
   end;//if l_Cell.Control = TControl(AComponent) then
  finally
   l_Cell := nil;
  end;//try..finally
//#UC END# *508EBBB1038A_508EBA08009F_impl*
//#UC START# *508EBBB1038A_508EBA08009F_var*
var
 l_Index: Integer;
 l_Cell: IagControlCell;
//#UC END# *508EBBB1038A_508EBA08009F_var*
//#UC START# *508EBBC80102_508EBA08009F_impl*
 Result := False;
 with Grid do
  if ColumnCount > 0 then
   for l_J := 0 to Pred(Column[0].CellCount) do
   begin
    l_Done := True;
    for l_Index := Pred(Column[0].CellCount) downto Succ(l_J) do
    begin
     if Supports(Column[0].Cell[l_Index], IagControlCell, l_Group2) and
      Supports(Column[0].Cell[l_Index - 1], IagControlCell, l_Group1) and
      (lp_Pos(l_Group1) > lp_Pos(l_Group2)) then
     begin
      Result := True;
      l_Done := False;
      l_Control1 := lp_ClearGroupControl(l_Group1);
      l_Control2 := lp_ClearGroupControl(l_Group2);
      l_Group1.Control := l_Control2;
      TWinControl(l_Control2).TabOrder := l_Index - 1;
      l_Group2.Control := l_Control1;
      TWinControl(l_Control1).TabOrder := l_Index;
     end;//if Supports(Column[0].Cell[l_Index]
    end;//for l_Index := 0 to Pred(Column[0].CellCount) do
    // Во время последнего цикла не было сделано ни одной перестановки, группы
    // отсортированы, выходим:
    if l_Done then
     Break;
   end;//for l_J := 0 to Pred(Column[0].CellCount) do
 if Result then
 begin
  ArrangeGrid(True);
  MakeTabTable;
 end;//if Result then
//#UC END# *508EBBC80102_508EBA08009F_impl*
//#UC START# *508EBBC80102_508EBA08009F_var*
 function lp_Pos(const aGroup: IagControlCell): Integer;
 begin
  Result := TnscTasksPanelHideField(aGroup.Control).Group.Position;
 end;//lp_Pos

 function lp_ClearGroupControl(const aGroup: IagControlCell): TControl;
 begin
  Result := aGroup.Control;
   // - запомним компонент;
  aGroup.Control := nil;
   // - отпустим обработчики перекрываемые ячейкой у компонента, иначе может
   //   получиться зацикливание;
 end;//lp_ClearGroupControl

var
 l_J: Integer;
 l_Index: Integer;
 l_Group1: IagControlCell;
 l_Group2: IagControlCell;
 l_Control1: TControl;
 l_Control2: TControl;
 l_Done: Boolean;
//#UC END# *508EBBC80102_508EBA08009F_var*
//#UC START# *508EBC200154_508EBA08009Fget_impl*
 if f_TabTable = nil then
  f_TabTable := TnscTabTable.Make;
 Result := f_TabTable;
//#UC END# *508EBC200154_508EBA08009Fget_impl*
//#UC START# *508EBC200154_508EBA08009Fget_var*
//#UC END# *508EBC200154_508EBA08009Fget_var*
//#UC START# *508EBC4B00B3_508EBA08009Fget_impl*
 Result := f_UpdateRequests > 0;
//#UC END# *508EBC4B00B3_508EBA08009Fget_impl*
//#UC START# *508EBC4B00B3_508EBA08009Fget_var*
//#UC END# *508EBC4B00B3_508EBA08009Fget_var*
//#UC START# *508EBC8B0298_508EBA08009F_impl*
 with Grid do
  if (Grid.ColumnCount > 0) and
     (Grid.Column[0].CellCount > 0) and
     Supports(Column[0].Cell[0], IagControlCell, l_Cell) and
     TWinControl(l_Cell.Control).CanFocus then
   TWinControl(l_Cell.Control).SetFocus;
//#UC END# *508EBC8B0298_508EBA08009F_impl*
//#UC START# *508EBC8B0298_508EBA08009F_var*
var
 l_Cell: IagControlCell;
//#UC END# *508EBC8B0298_508EBA08009F_var*
//#UC START# *510261DC001C_508EBA08009Fget_impl*
 if Supports(Grid.Column[0].Cell[anIndex], IagControlCell, l_Group) then
  Result := l_Group.Control as TnscTasksPanelHideField;
//#UC END# *510261DC001C_508EBA08009Fget_impl*
//#UC START# *510261DC001C_508EBA08009Fget_var*
var
 l_Group: IagControlCell;
//#UC END# *510261DC001C_508EBA08009Fget_var*
//#UC START# *510261F0028D_508EBA08009Fget_impl*
 if Grid.ColumnCount > 0
  then Result := Grid.Column[0].CellCount
  else Result := 0;
//#UC END# *510261F0028D_508EBA08009Fget_impl*
//#UC START# *510261F0028D_508EBA08009Fget_var*
//#UC END# *510261F0028D_508EBA08009Fget_var*
//#UC START# *510288E102AC_508EBA08009Fget_impl*
 if f_Grid = nil then
 begin
  f_Grid := TnscArrangeGrid.Make(False, True);
  f_Grid.OnSizeChanged := GrideSizeChanged;
 end;//if f_Grid = nil then
 Result := f_Grid;
//#UC END# *510288E102AC_508EBA08009Fget_impl*
//#UC START# *510288E102AC_508EBA08009Fget_var*
//#UC END# *510288E102AC_508EBA08009Fget_var*
