//#UC START# *478CF34E02CE_51D547F700AB_impl*
 if Source is TddAppConfigNode then
 begin
  inherited;
  f_Objects.Clear;
  for I := 0 to Pred(l_AC.Count) do
  begin
   l_Item := l_AC.Items[I].Clone;
   try
    f_Objects.Add(l_Item);
   finally
    FreeAndNil(l_Item);
   end;
  end
 end
 else
  inherited;
//#UC END# *478CF34E02CE_51D547F700AB_impl*
//#UC START# *478CF34E02CE_51D547F700AB_var*
var
 l_AC: TddAppConfigNode absolute Source;
 I: Integer;
 l_Item: TddBaseConfigItem;
//#UC END# *478CF34E02CE_51D547F700AB_var*
//#UC START# *479731C50290_51D547F700AB_impl*
 FreeAndNil(f_Objects);
 inherited;
//#UC END# *479731C50290_51D547F700AB_impl*
//#UC START# *479731C50290_51D547F700AB_var*
//#UC END# *479731C50290_51D547F700AB_var*
//#UC START# *51D547F700AB_ext:ParentFileName
w:\common\components\rtl\Garant\dd\ddAppConfigTypes.pas
//#UC END# *51D547F700AB_ext:ParentFileName
//#UC START# *5217205002F2_51D547F700ABget_impl*
 Result := inherited pm_GetChanged;
 if not Result then
  for I := 0 to Pred(Count) do
   if Items[I].Changed then
   begin
    Result := true;
    break
   end;
//#UC END# *5217205002F2_51D547F700ABget_impl*
//#UC START# *5217205002F2_51D547F700ABget_var*
var
 I: Integer;
//#UC END# *5217205002F2_51D547F700ABget_var*
//#UC START# *5217205002F2_51D547F700ABset_impl*
 inherited;
 for I := 0 to Pred(Count) do
  Items[I].Changed := aValue;
 if not aValue then 
  for I := 0 to Pred(ChildrenCount) do
   Children[I].Changed := aValue;
//#UC END# *5217205002F2_51D547F700ABset_impl*
//#UC START# *5217205002F2_51D547F700ABset_var*
var
 I: Integer;
//#UC END# *5217205002F2_51D547F700ABset_var*
//#UC START# *52172A7700CB_51D547F700AB_impl*
 Result := AnsiCompareStr(Alias, anAlias) = 0;
 if Result then
  theItem := Self
 else
 begin
  for I := 0 to Pred(Count) do
  begin
   Result := Items[I].HasValue(anAlias, theItem);
   if Result then
    break;
  end;
  if not Result then
   for I := 0 to Pred(ChildrenCount) do
   begin
    Result := Children[I].HasValue(anAlias, theItem);
    if Result then
     break;
   end;
 end;
//#UC END# *52172A7700CB_51D547F700AB_impl*
//#UC START# *52172A7700CB_51D547F700AB_var*
var
 I: Integer;
//#UC END# *52172A7700CB_51D547F700AB_var*
//#UC START# *52172B72014C_51D547F700AB_impl*
 for I := 0 to Pred(Count) do
 begin
  aStorage.Section := Alias;
  Items[I].Load(aStorage);
 end; // for I
 for I := 0 to Pred(ChildrenCount) do
  Children[I].Load(aStorage);
//#UC END# *52172B72014C_51D547F700AB_impl*
//#UC START# *52172B72014C_51D547F700AB_var*
var
 I: Integer;
//#UC END# *52172B72014C_51D547F700AB_var*
//#UC START# *52172CA801E3_51D547F700AB_impl*
 for I := 0 to Pred(f_Objects.Count) do
 begin
   aStorage.Section := Alias;
   Items[I].Save(aStorage);
 end; // for I
 for I := 0 to Pred(ChildrenCount) do
   Children[I].Save(aStorage);
//#UC END# *52172CA801E3_51D547F700AB_impl*
//#UC START# *52172CA801E3_51D547F700AB_var*
var
 I: Integer;
//#UC END# *52172CA801E3_51D547F700AB_var*
//#UC START# *521B251D0001_51D547F700AB_impl*
 Result := False;
 aMessage := '';
 for I := 0 to Pred(Count) do
 begin
  if Items[I].IsRequired then
  begin
   Result := True;
   aMessage := aMessage + Items[I].Caption;
  end;
 end;
//#UC END# *521B251D0001_51D547F700AB_impl*
//#UC START# *521B251D0001_51D547F700AB_var*
var
 I: Integer;
//#UC END# *521B251D0001_51D547F700AB_var*
//#UC START# *521B285C035B_51D547F700AB_impl*
  for I := 0 to Pred(Count) do
   Items[I].ClearControl;
  for I := 0 to Pred(ChildrenCount) do
   IddConfigNode(Children[I]).ClearControls;
//#UC END# *521B285C035B_51D547F700AB_impl*
//#UC START# *521B285C035B_51D547F700AB_var*
var
  I: Integer;
//#UC END# *521B285C035B_51D547F700AB_var*
//#UC START# *521B28760177_51D547F700AB_impl*
 Result := TFrame.Create(aOwner);
 Result.Name := Alias;
 Result.Parent := aOwner as TWinControl;
 Result.Align := alClient;
 Result.Tag := aTag;
 Result.HelpContext := HelpContext;

//  l_P := TvtPanel.Create(aOwner);
//  Result.InsertControl(l_P);
//  l_P.Align := alClient;
//  l_P.BorderStyle := bsNone;
//  l_P.BevelOuter := bvNone;
//  l_P.BevelInner := bvNone;
//  {$IfDef Nemesis}
//  l_P.Color := cGarant2011BackColor;
//  {$EndIf};
 l_ScrollBox := TScrollBox.Create(aOwner);
 Result.InsertControl(l_ScrollBox);
 with l_ScrollBox do
 begin
  Align := alClient;
  BorderStyle := bsNone;
  {$IfDef Nemesis}
  Color := cGarant2011BackColor;
  {$EndIf};
 end;

 l_ButtonLeft := Result.ClientWidth;
 l_ButtonHeight := 0;
 l_MaxLeft := RequiredSignWidth(Result);
 l_LJCount := 0;
 for J := 0 to Pred(Count) do
 begin
  l_CI := Items[J];
  if l_CI is TddGroupConfigItem then
   l_MaxLeft := Max(l_MaxLeft, TddGroupConfigItem(l_CI).ItemsLabelWidth(Result, l_LJCount))
  else
  if l_CI.Labeled and not l_CI.LabelTop then
  begin
   l_MaxLeft := Max(l_MaxLeft, l_CI.LabelWidth(Result));
   if not l_CI.LabelTop then
    Inc(l_LJCount);
  end;
 end;
 { TODO -oДмитрий Дудко -cОшибка :
 Выравнивать элементы по ширине метки нужно только в том случае,
 если есть несколько элементов с горизонтальным расположением элемента }
   if l_LJCount < 2 then
    l_MaxLeft := 0
   else
    Inc(l_MaxLeft, c_ConfigItemLeft);

 // Здесь добавляем контролы
 l_FirstButton := True;
 l_Top := c_ConfigItemTop;
 l_PrevControl := nil;
 for J := 0 to Pred(Count) do
 begin
  l_CI := Items[J];
  l_Left := c_ConfigItemLeft;
  l_I := l_CI.MasterItem;
  while l_I <> nil do
  begin
   Inc(l_Left, c_ConfigItemLeft);
   l_I := l_I.MasterItem;
  end;
  if l_CI.Visible then // Правильнее засунуть это внутрь CreateControl
   l_Control := l_CI.CreateControl(l_Left, l_MaxLeft, l_Top, l_ScrollBox{l_P}{Result})
  else
   l_Control := nil;
  if l_Control <> nil then
  begin
   if l_Control.HelpContext = 0 then
    l_Control.HelpContext := HelpContext;
   // кнопка в правом нижнем
   if (l_CI is TddButtonConfigItem) then       
   begin
    if (TddButtonConfigItem(l_CI).ButtonPlace = dd_bpBottomRight) then
    begin
     l_Control.Top := Result.ClientHeight - l_Control.Height - c_ConfigItemTop;
     if (l_Control.Parent is TScrollBox) and l_FirstButton
      then l_Control.Left := l_ButtonLeft - l_Control.Width - 2 * c_ConfigItemTop - c_ScrollBarWidth
      else l_Control.Left := l_ButtonLeft - l_Control.Width - 2 * c_ConfigItemTop;
     {$ifdef nemesis}
     l_Control.Anchors := l_Control.Anchors + [akRight] - [akLeft];
     {$endif}
     l_FirstButton := False;
     l_ButtonLeft := l_Control.Left;
     l_ButtonHeight := l_Control.Height + c_ConfigItemTop;
    end
    else
    begin
     if (l_PrevControl <> nil) and (l_PrevControl is TvtButton) then
     begin
      l_Control.Top := l_PrevControl.Top;
      l_Control.Left := l_PrevControl.Left + l_PrevControl.Width + c_ConfigItemTop;
      l_Top := l_Control.Height + l_Control.Top;
      Inc(l_Top, c_ConfigItemTop);
     end;
    end;
   end
   else // остальные компоненты
   begin
    l_Top := l_CI.ControlHeight(l_ScrollBox{l_P}) + l_Control.Top;
    Inc(l_Top, c_ConfigItemTop);
   end;
   l_PrevControl := l_Control;
  end;
  //CheckHeight(l_ButtonHeight + l_Top);
 end; // for J

 for J := 0 to Pred(Count) do
 begin
  l_CI := Items[J];
  l_Control := l_CI.Control;

  if l_Control <> nil then
   if (l_CI is TddButtonConfigItem) then
    if (TddButtonConfigItem(l_CI).ButtonPlace = dd_bpBottomRight) then
     l_Control.Top := Max(l_Control.Top, l_Top + c_ConfigItemTop);
 end;
//#UC END# *521B28760177_51D547F700AB_impl*
//#UC START# *521B28760177_51D547F700AB_var*
var
  l_MaxLeft: Integer;
  l_Top: Integer;
  l_Left: Integer;
  J, l_LJCount: Integer;
  l_CI: TddVisualConfigItem;
  l_Control, l_PrevControl: TControl;
  l_ButtonLeft: Integer;
  l_ButtonHeight: Integer;
  l_I: TddBaseConfigItem;
  //l_P: TvtPanel;
  l_ScrollBox: TScrollBox;
  l_FirstButton: Boolean;
//  procedure CheckHeight(aHeight : Integer);
//  begin
//   if not IsVerticalScrollBar and (aHeight > Result.ClientHeight) then
//    ScrollBars := ssVertical;
//    raise EddConfigError.CreateFmt('??????? "%s" (%s) ??????? ?? ??????? ?????',
//     [l_CI.Alias, l_CI.Caption]);
//  end;

//#UC END# *521B28760177_51D547F700AB_var*
//#UC START# *521B28930009_51D547F700AB_impl*
 l_ButtonHeight := 0;
 l_ButtonWidth := 0;
 aHeight := 0;
 aWidth := 0;

 for I := 0 to Pred(Count) do
 begin
  // учитываем кнопки в правом нижнем
  if (Items[I] is TddButtonConfigItem) and
   (TddButtonConfigItem(Items[I]).ButtonPlace = dd_bpBottomRight) then
  begin
   // учитываем только первую, потому что кнопки размещаются на одной линии
   if (l_ButtonHeight = 0) then
   begin
    l_ButtonHeight := Items[I].ControlHeight(aParent) + c_ConfigItemTop;
    Inc(aHeight, l_ButtonHeight);
   end;
   // ширина вытянутых в линию кнопок
   Inc(l_ButtonWidth, Items[I].MinWidth(aParent) + c_ConfigItemLeft);
  end
  // все остальные
  else
  begin
   _ItemSize(Items[I], aHeight, aWidth);
   Inc(aHeight, c_ConfigItemTop);
  end;
 end; // for I
 aHeight := aHeight + 2 * c_ConfigItemTop;
 aWidth := Max(aWidth, l_ButtonWidth);
//#UC END# *521B28930009_51D547F700AB_impl*
//#UC START# *521B28930009_51D547F700AB_var*
var
  I: Integer;
  l_ButtonHeight: Integer;
  l_ButtonWidth: Integer;
  procedure _ItemSize(aCI: TddVisualConfigItem; out aH, aW: Integer);
  var
   l_LW, l_CW: Integer;
   l_Delta: Integer;
   l_I: TddBaseConfigItem;
  begin
   l_Delta := 0;
   l_I := aCI.MasterItem;
   while l_I <> nil do // Вычисляем сдвиг относительно Хозяина
   begin
    Inc(l_Delta, c_ConfigItemLeft);
    l_I := l_I.MasterItem;
   end; // while l_I <> nil

    l_LW := IfThen(aCI.Labeled, aCI.LabelWidth(aParent), 0); // метка

    l_CW := aCI.MinWidth(aParent) + RequiredSignWidth(aParent); // контрол

   if aCI.Labeled and (not aCI.LabelTop) then
    Inc(l_CW, l_LW + c_ConfigItemLeft);

   aW := Max(aW, l_CW);

   Inc(aW, l_Delta);
   Inc(aH, aCI.FullControlHeight[aParent]);
  end;
//#UC END# *521B28930009_51D547F700AB_var*
//#UC START# *521B28BE015D_51D547F700AB_impl*
 for I := 0 to Pred(Count) do
 begin
  with Items[I]do
  begin
   if Visible then
   begin
    Lock;
    GetValueFromControl;
    UnLock;
   end
  end
 end; // for I
 for I := 0 to Pred(ChildrenCount) do
  IddConfigNode(Children[I]).GetControlValues;
//#UC END# *521B28BE015D_51D547F700AB_impl*
//#UC START# *521B28BE015D_51D547F700AB_var*
var
 I: Integer;
 l_Item: TddVisualConfigItem;
//#UC END# *521B28BE015D_51D547F700AB_var*
//#UC START# *521B28D60001_51D547F700AB_impl*
 Result := False;
 for lIndex := 0 to Pred(Count) do
  if Items[lIndex].IsSame(aItem) then
  begin
   Result := True;
   Break;
  end;
//#UC END# *521B28D60001_51D547F700AB_impl*
//#UC START# *521B28D60001_51D547F700AB_var*
var
 lIndex : Integer;
//#UC END# *521B28D60001_51D547F700AB_var*
//#UC START# *521B28F40355_51D547F700AB_impl*
 LoadValue(aStorage)
//#UC END# *521B28F40355_51D547F700AB_impl*
//#UC START# *521B28F40355_51D547F700AB_var*
//#UC END# *521B28F40355_51D547F700AB_var*
//#UC START# *521B293B0012_51D547F700AB_impl*
 for I := 0 to Pred(f_Objects.Count) do
  TddVisualConfigItem(f_Objects.Items[I]).ResetToDefault;
 for I := 0 to Pred(ChildrenCount) do
  IddConfigNode(Children[I]).ResetToDefault;
//#UC END# *521B293B0012_51D547F700AB_impl*
//#UC START# *521B293B0012_51D547F700AB_var*
var
 I: Integer;
//#UC END# *521B293B0012_51D547F700AB_var*
//#UC START# *521B295A024F_51D547F700AB_impl*
 SaveValue(aStorage);
//#UC END# *521B295A024F_51D547F700AB_impl*
//#UC START# *521B295A024F_51D547F700AB_var*
//#UC END# *521B295A024F_51D547F700AB_var*
//#UC START# *521B298800F7_51D547F700AB_impl*
 for I := 0 to Pred(Count) do
 begin
  l_Item := Items[I];
  if l_Item.Control <> nil then
  begin
   l_Item.Lock;
   l_Item.SetValueToControl(aDefault);
   l_Item.UnLock;
  end; // l_Item.Control <> nil
 end;
 for I := 0 to Pred(ChildrenCount) do
  IddConfigNode(Children[I]).SetControlValues(aDefault);
//#UC END# *521B298800F7_51D547F700AB_impl*
//#UC START# *521B298800F7_51D547F700AB_var*
var
  I: Integer;
  l_Item: TddVisualConfigItem;
//#UC END# *521B298800F7_51D547F700AB_var*
//#UC START# *5225B8100090_51D547F700ABset_impl*
 f_Objects.Assign(aValue);
//#UC END# *5225B8100090_51D547F700ABset_impl*
//#UC START# *5225B8100090_51D547F700ABset_var*
//#UC END# *5225B8100090_51D547F700ABset_var*
//#UC START# *5225B88A031F_51D547F700ABset_impl*
 if f_LabelTop <> aValue then
 begin
  f_LabelTop := aValue;
  for I := 0 to Pred(Count) do
   Items[I].LabelTop := f_LabelTop;
 end; // f_LabelTop <> aValue
//#UC END# *5225B88A031F_51D547F700ABset_impl*
//#UC START# *5225B88A031F_51D547F700ABset_var*
var
 I: Integer;
//#UC END# *5225B88A031F_51D547F700ABset_var*
//#UC START# *5225B97C02D3_51D547F700ABget_impl*
 Result := TddVisualConfigItem(f_Objects.Items[anIndex]);
//#UC END# *5225B97C02D3_51D547F700ABget_impl*
//#UC START# *5225B97C02D3_51D547F700ABget_var*
//#UC END# *5225B97C02D3_51D547F700ABget_var*
//#UC START# *5225B9B00383_51D547F700ABget_impl*
 Result := nil;
 for I := 0 to Pred(f_Objects.Count) do
 begin
  l_Item := TddVisualConfigItem(f_Objects.Items[I]);
  if l_Item.AbsoluteIndex = anIndex then
  begin
   Result := l_Item;
   Break;
  end;
 end;
//#UC END# *5225B9B00383_51D547F700ABget_impl*
//#UC START# *5225B9B00383_51D547F700ABget_var*
var
  I: Integer;
  l_Item: TddVisualConfigItem;
//#UC END# *5225B9B00383_51D547F700ABget_var*
//#UC START# *5225BA060217_51D547F700ABget_impl*
 Result := ItemByAlias[anAlias].Value.AsBoolean;
//#UC END# *5225BA060217_51D547F700ABget_impl*
//#UC START# *5225BA060217_51D547F700ABget_var*
//#UC END# *5225BA060217_51D547F700ABget_var*
//#UC START# *5225BA060217_51D547F700ABset_impl*
 l_Item := ItemByAlias[anAlias];
 l_Value := l_Item.Value;
 if l_Value.Kind = dd_vkBoolean then
 begin
  l_Value.AsBoolean := aValue;
  l_Item.Value := l_Value;
 end
 else
  EddConfigError.CreateFmt(str_DifferentType.AsStr, [anAlias]);
//#UC END# *5225BA060217_51D547F700ABset_impl*
//#UC START# *5225BA060217_51D547F700ABset_var*
var
 l_Value: TddConfigValue;
 l_Item: TddBaseConfigItem;
//#UC END# *5225BA060217_51D547F700ABset_var*
//#UC START# *5225BAF902D3_51D547F700ABget_impl*
 Result := ItemByAlias[anAlias].Value.AsDateTime;
//#UC END# *5225BAF902D3_51D547F700ABget_impl*
//#UC START# *5225BAF902D3_51D547F700ABget_var*
//#UC END# *5225BAF902D3_51D547F700ABget_var*
//#UC START# *5225BAF902D3_51D547F700ABset_impl*
 l_Item := ItemByAlias[anAlias];
 l_Value := l_Item.Value;
 if l_Value.Kind = dd_vkDateTime then
 begin
  l_Value.AsDateTime := aValue;
  l_Item.Value := l_Value;
 end
 else
  EddConfigError.CreateFmt(str_DifferentType.AsStr, [anAlias]);
//#UC END# *5225BAF902D3_51D547F700ABset_impl*
//#UC START# *5225BAF902D3_51D547F700ABset_var*
var
 l_Value: TddConfigValue;
 l_Item: TddBaseConfigItem;
//#UC END# *5225BAF902D3_51D547F700ABset_var*
//#UC START# *5225BB4B0246_51D547F700ABget_impl*
 Result := ItemByAlias[anAlias].Value.AsInteger;
//#UC END# *5225BB4B0246_51D547F700ABget_impl*
//#UC START# *5225BB4B0246_51D547F700ABget_var*
//#UC END# *5225BB4B0246_51D547F700ABget_var*
//#UC START# *5225BB4B0246_51D547F700ABset_impl*
 l_Item := ItemByAlias[anAlias];
 l_Value := l_Item.Value;
 if l_Value.Kind = dd_vkInteger then
 begin
  l_Value.AsInteger := aValue;
  l_Item.Value := l_Value;
 end
 else
  EddConfigError.CreateFmt(str_DifferentType.AsStr, [anAlias]);
//#UC END# *5225BB4B0246_51D547F700ABset_impl*
//#UC START# *5225BB4B0246_51D547F700ABset_var*
var
 l_Value: TddConfigValue;
 l_Item: TddBaseConfigItem;
//#UC END# *5225BB4B0246_51D547F700ABset_var*
//#UC START# *5225BB59010E_51D547F700ABget_impl*
 Result := ItemByAlias[anAlias].Value.AsObject;
//#UC END# *5225BB59010E_51D547F700ABget_impl*
//#UC START# *5225BB59010E_51D547F700ABget_var*
//#UC END# *5225BB59010E_51D547F700ABget_var*
//#UC START# *5225BB59010E_51D547F700ABset_impl*
 l_Item := ItemByAlias[anAlias];
 l_Value := l_Item.Value;
 if l_Value.Kind = dd_vkObject then
 begin
  l_Value.AsObject := aValue;
  l_Item.Value := l_Value;
 end
 else
  EddConfigError.CreateFmt(str_DifferentType.AsStr, [anAlias]);
//#UC END# *5225BB59010E_51D547F700ABset_impl*
//#UC START# *5225BB59010E_51D547F700ABset_var*
var
 l_Value: TddConfigValue;
 l_Item: TddBaseConfigItem;
//#UC END# *5225BB59010E_51D547F700ABset_var*
//#UC START# *5225BB630324_51D547F700ABget_impl*
 Result := ItemByAlias[anAlias].Value.AsString;
//#UC END# *5225BB630324_51D547F700ABget_impl*
//#UC START# *5225BB630324_51D547F700ABget_var*
//#UC END# *5225BB630324_51D547F700ABget_var*
//#UC START# *5225BB630324_51D547F700ABset_impl*
 l_Item := ItemByAlias[anAlias];
 l_Value := l_Item.Value;
 if l_Value.Kind = dd_vkString then
 begin
  l_Value.AsString := aValue;
  l_Item.Value := l_Value;
 end
 else
  EddConfigError.CreateFmt(str_DifferentType.AsStr, [anAlias]);
//#UC END# *5225BB630324_51D547F700ABset_impl*
//#UC START# *5225BB630324_51D547F700ABset_var*
var
 l_Value: TddConfigValue;
 l_Item: TddBaseConfigItem;
//#UC END# *5225BB630324_51D547F700ABset_var*
//#UC START# *5225BBD2035C_51D547F700ABget_impl*
  Assert(f_Objects <> nil);
  Result := f_Objects.Count
//#UC END# *5225BBD2035C_51D547F700ABget_impl*
//#UC START# *5225BBD2035C_51D547F700ABget_var*
//#UC END# *5225BBD2035C_51D547F700ABget_var*
//#UC START# *5225BC4B01A6_51D547F700AB_impl*
 inherited;
 f_Objects := Tl3ProtoPersistentRefList.Create;
 f_LabelTop := True;
//#UC END# *5225BC4B01A6_51D547F700AB_impl*
//#UC START# *5225BC4B01A6_51D547F700AB_var*
//#UC END# *5225BC4B01A6_51D547F700AB_var*
//#UC START# *5225BCAE02EE_51D547F700AB_impl*
 Result := aItem;
 aItem.ReadOnly := ReadOnly;
 Result.OnChange := ItemChanged;
 if (Result is TddVisualConfigItem) then
  TddVisualConfigItem(Result).LabelTop := LabelTop;
 f_Objects.Add(Result);
 FreeAndNil(aItem);
//#UC END# *5225BCAE02EE_51D547F700AB_impl*
//#UC START# *5225BCAE02EE_51D547F700AB_var*
//#UC END# *5225BCAE02EE_51D547F700AB_var*
//#UC START# *5225C9B80025_51D547F700ABget_impl*
 if HasValue(anAlias, l_Obj) then
  Result := l_Obj
 else
  raise EddConfigError.CreateFmt(str_PropertyAbsent.AsStr, [anAlias]);;
//#UC END# *5225C9B80025_51D547F700ABget_impl*
//#UC START# *5225C9B80025_51D547F700ABget_var*
var
 l_Obj: TddBaseConfigItem;
//#UC END# *5225C9B80025_51D547F700ABget_var*
//#UC START# *5301EC7500FF_51D547F700AB_impl*
 Result := TddAppConfigNode.Create(Alias, Caption);
 TddAppConfigNode(Result).Assign(Self);
//#UC END# *5301EC7500FF_51D547F700AB_impl*
//#UC START# *5301EC7500FF_51D547F700AB_var*
//#UC END# *5301EC7500FF_51D547F700AB_var*
//#UC START# *552BA9B9039B_51D547F700AB_impl*
 inherited;
 for l_IDX := 0 to Count - 1 do
  Items[l_IDX].ReadOnly := ReadOnly;
//#UC END# *552BA9B9039B_51D547F700AB_impl*
//#UC START# *552BA9B9039B_51D547F700AB_var*
var
 l_IDX: Integer;
//#UC END# *552BA9B9039B_51D547F700AB_var*
