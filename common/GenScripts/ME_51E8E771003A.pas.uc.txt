//#UC START# *51D27A48038E_51E8E771003A_impl*
 inherited;
 Picture.Clear;
//#UC END# *51D27A48038E_51E8E771003A_impl*
//#UC START# *51D27A48038E_51E8E771003A_var*
//#UC END# *51D27A48038E_51E8E771003A_var*
//#UC START# *51D27C3302EC_51E8E771003A_impl*
 Picture.AddText(aText);
//#UC END# *51D27C3302EC_51E8E771003A_impl*
//#UC START# *51D27C3302EC_51E8E771003A_var*
//#UC END# *51D27C3302EC_51E8E771003A_var*
//#UC START# *51D27EC50388_51E8E771003A_impl*
 if propType = propPict then
  ApplyToPicture(What, Value)
 else
  inherited;
//#UC END# *51D27EC50388_51E8E771003A_impl*
//#UC START# *51D27EC50388_51E8E771003A_var*
//#UC END# *51D27EC50388_51E8E771003A_var*
//#UC START# *51E7C9DB0213_51E8E771003A_impl*
 inherited Create(aRTFReader);
 l_Picture := TddPicture.Create(Self);
 try
  AddParagraph(l_Picture);
 finally
  FreeAndNil(l_Picture);
 end;
//#UC END# *51E7C9DB0213_51E8E771003A_impl*
//#UC START# *51E7C9DB0213_51E8E771003A_var*
var
 l_Picture: TddPicture;
//#UC END# *51E7C9DB0213_51E8E771003A_var*
//#UC START# *51E8E7DC003B_51E8E771003Aget_impl*
 Result := TddPicture(LastAtom);
//#UC END# *51E8E7DC003B_51E8E771003Aget_impl*
//#UC START# *51E8E7DC003B_51E8E771003Aget_var*
//#UC END# *51E8E7DC003B_51E8E771003Aget_var*
//#UC START# *51E8E82F0299_51E8E771003A_impl*
 case aWhat of
  ipropHeight  : Picture.Height:= aValue;
  ipropWidth   : Picture.Width:= aValue;
  ipropScaleX  : Picture.ScaleX:= aValue;
  ipropScaleY  : Picture.ScaleY:= aValue;
  ipropPicCropL: Picture.CropL:= aValue;
  ipropPicCropR: Picture.CropR:= aValue;
  ipropPicCropT: Picture.CropT:= aValue;
  ipropPicCropB: Picture.CropB:= aValue;
  ipropPicEMF: Picture.Format := pictEMF;
  ipropPicJPEG: Picture.Format := pictJPG;
  ipropPicPNG: Picture.Format := pictPNG;
  ipropPicWMF: Picture.Format := pictWMF;
  ipropBin: Picture.Try2ReadBinaryData(f_CustomRTFReader.Parser.Filer, aValue);
  iproppicw: Picture.WidthInPixels := aValue;
  iproppich: Picture.HeightInPixels := aValue;
 end;
//#UC END# *51E8E82F0299_51E8E771003A_impl*
//#UC START# *51E8E82F0299_51E8E771003A_var*
//#UC END# *51E8E82F0299_51E8E771003A_var*
//#UC START# *534658E901B6_51E8E771003A_impl*
 Result := Picture.Try2ReadKnownPicture(aFiler);
//#UC END# *534658E901B6_51E8E771003A_impl*
//#UC START# *534658E901B6_51E8E771003A_var*
//#UC END# *534658E901B6_51E8E771003A_var*
//#UC START# *5461BEC2017D_51E8E771003A_impl*
 l_NeedSkip := f_CustomRTFReader.NeedSkip(Picture);
 if (l_NeedSkip <> rtf_psYes) and (aNewDest is TdestNorm) then
  TdestNorm(aNewDest).AddPicture(Picture, aState, l_NeedSkip = rtf_psWMF);
 Clear;
 f_CustomRTFReader.SkipPicture := False;
//#UC END# *5461BEC2017D_51E8E771003A_impl*
//#UC START# *5461BEC2017D_51E8E771003A_var*
var
 l_NeedSkip: TRTFPictureSkip;
//#UC END# *5461BEC2017D_51E8E771003A_var*
//#UC START# *54E1F08400F9_51E8E771003A_impl*
 Assert(False, 'Добавление картники из необычного места');
//#UC END# *54E1F08400F9_51E8E771003A_impl*
//#UC START# *54E1F08400F9_51E8E771003A_var*
//#UC END# *54E1F08400F9_51E8E771003A_var*
//#UC START# *54E46D5F0045_51E8E771003A_impl*
 if not TextBuffer.Empty then
 begin
  aParser.Filer.UngetChars(TextBuffer.Len);
  TextBuffer.Clear;
 end; // if not Text.Empty then
 with Picture do
  if not Text.Empty then
  begin
   aParser.Filer.UngetChars(Text.Len);
   Text.Clear;
  end; // if not Text.Empty then
//#UC END# *54E46D5F0045_51E8E771003A_impl*
//#UC START# *54E46D5F0045_51E8E771003A_var*
//#UC END# *54E46D5F0045_51E8E771003A_var*
//#UC START# *54E46DAF037C_51E8E771003A_impl*
 Picture.AddHexData(aHexStream);
//#UC END# *54E46DAF037C_51E8E771003A_impl*
//#UC START# *54E46DAF037C_51E8E771003A_var*
//#UC END# *54E46DAF037C_51E8E771003A_var*
//#UC START# *550913790257_51E8E771003A_impl*
 Result := inherited ReadData;
 with f_CustomRTFReader.Parser.Filer do
 begin
  TryToClearText(f_CustomRTFReader.Parser);
  UngetC; // И текущий символ тоже нужно прочитать...
  l_KnonwData := Try2ReadKnownPicture(f_CustomRTFReader.Parser.Filer); // А попробуем-ка считать побыстрому...
  try
   if lp_CheckEOF then Exit;
   l_Str := ReadHexLn(cc_HexDigitalCharSetWithEnters, cc_RTFFinishLineChar); // Дочитываем хвост или читаем целиком...
   if lp_CheckEOF then Exit;
   if not f_CustomRTFReader.SkipHexData then // Надо бы "запилить" Filer для такого случая...
   begin
    if l_Str.SLen > 0 then
     if l_KnonwData = nil then
      l_KnonwData := Tl3String.Make(l_Str)
     else
      l_KnonwData.Append(l_Str);
    AddHexData(l_KnonwData);
   end; // if not l_WrongData and not f_CustomRTFReader.SkipHexData then
  finally
   l3Free(l_KnonwData);
  end;
  lp_FinalAction;
 end; // with Parser.Filer do
//#UC END# *550913790257_51E8E771003A_impl*
//#UC START# *550913790257_51E8E771003A_var*

 procedure lp_FinalAction;
 begin
  Result := True;
  f_CustomRTFReader.Parser.NextTokenSp;
 end;

 function lp_CheckEOF: Boolean;
 begin
  Result := f_CustomRTFReader.Parser.Filer.EOF;
  if Result then
  begin
   f_CustomRTFReader.Status := ecInvalidPicture;
   lp_FinalAction;
  end; // if Result then
 end;

var
 l_Str      : Tl3WString;
 l_KnonwData: Tl3String;
//#UC END# *550913790257_51E8E771003A_var*
//#UC START# *559516AA0098_51E8E771003A_impl*
 Result := False;
//#UC END# *559516AA0098_51E8E771003A_impl*
//#UC START# *559516AA0098_51E8E771003A_var*
//#UC END# *559516AA0098_51E8E771003A_var*
