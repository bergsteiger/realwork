//#UC START# *479731C50290_52B9AF0A027C_impl*
 l3Free(f_Link);
 inherited;
//#UC END# *479731C50290_52B9AF0A027C_impl*
//#UC START# *479731C50290_52B9AF0A027C_var*
//#UC END# *479731C50290_52B9AF0A027C_var*
//#UC START# *47D1602000C6_52B9AF0A027C_impl*
 inherited;
 f_Container := TnpContainerSurface.Make(Self);
 //f_Panel := TvtPanel.Create(Self);
 //f_Panel.Parent := Self;
 //f_Panel.Align := alClient;
 f_Splitter := TnpSplitter.Create(Self{, f_Panel});
 with f_Splitter do
 begin
  Parent := Self;
  Align := alRight;
  Width := cspSize;
  f_Surface := Self;
 end;
 f_Link := TnpChangeLink.Create;
 f_Link.OnStateChanged := OnStateChanged;
//#UC END# *47D1602000C6_52B9AF0A027C_impl*
//#UC START# *47D1602000C6_52B9AF0A027C_var*
//#UC END# *47D1602000C6_52B9AF0A027C_var*
//#UC START# *5028A60300AD_52B9AF0A027C_impl*
 if (csDesigning in ComponentState) then
 begin
  l_R := ClientRect;
  with Canvas do
  begin
   with Pen do
   begin
    Color := clBlack;
    Width := 1;
   end;//with Pen
   Rectangle(l_R);
  end;//with Canvas
  InflateRect(l_R, -1, -1);
  npDrawGradient(l_R, clRed, clMaroon);
 end//csDesigning in ComponentState
 else
 begin
  (* Заливаем только когда на подложке никого нет, иначе у компонентов слетает
     то, что нарисовали в WMNCPaint *)
  if Assigned(f_Navigator) and Assigned(f_Navigator.PageControl) and
   (f_Navigator.PageControl.PageCount = 0) then
  with Canvas do
  begin
   Brush.Color := clWhite{clBtnFace};
   FillRect(ClientRect);
  end;//with Canvas
 end;//csDesigning in ComponentState
//#UC END# *5028A60300AD_52B9AF0A027C_impl*
//#UC START# *5028A60300AD_52B9AF0A027C_var*
 procedure npDrawGradient(aRect       : TRect;
                          aBeginColor : TColor = clBtnHighlight;
                          aEndColor   : TColor = clBtnShadow);
 var
  lI         : Integer;
  lStartRGB  : array[0..2] of Byte;
  lEndRGB    : array[0..2] of Byte;
  lStartC    : TColor;
  lEndC      : TColor;
  lColors    : Word;
  lRDist, lGDist, lBDist : Integer;
  lRTmp, lGTmp, lBTmp : Integer;
 begin//npDrawGradient
  // цвета
  lStartC := ColorToRGB(aBeginColor);
  lEndC := ColorToRGB(aEndColor);
  // массив с исходными цветами (lStartC)
  lStartRGB[0] := GetRValue(lStartC);
  lStartRGB[1] := GetGValue(lStartC);
  lStartRGB[2] := GetBValue(lStartC);
  // массив с конечными цветами (lEndC)
  lEndRGB[0] := GetRValue(lEndC);
  lEndRGB[1] := GetGValue(lEndC);
  lEndRGB[2] := GetBValue(lEndC);
  // расстояние между каждым цветом
  lRDist := Abs(lEndRGB[0] - lStartRGB[0]);
  lGDist := Abs(lEndRGB[1] - lStartRGB[1]);
  lBDist := Abs(lEndRGB[2] - lStartRGB[2]);
  // количество цветов которые будут нарисованы
  lColors := aRect.Right - aRect.Left;
  for lI := 0 to Pred(lColors) do
    with Canvas do
    begin
     // красный
     lRTmp := MulDiv(lI, lRDist, Pred(lColors));
     if lStartRGB[0] > lEndRGB[0] then
      lRTmp := - lRTmp;
     // зеленый
     lGTmp := MulDiv(lI, lGDist, Pred(lColors));
     if lStartRGB[1] > lEndRGB[1] then
      lGTmp := - lGTmp;
     // синий
     lBTmp := MulDiv(lI, lBDist, Pred(lColors));
     if lStartRGB[2] > lEndRGB[2] then
      lBTmp := - lBTmp;
     // установим цвет и нарисуем
     Pen.Color :=  RGB(
      (lStartRGB[0] + lRTmp),
      (lStartRGB[1] + lGTmp),
      (lStartRGB[2] + lBTmp));
     MoveTo(aRect.Left + lI, aRect.Top);
     LineTo(aRect.Left + lI, aRect.Bottom);
    end;//with Canvas
 end;//npDrawGradient
var
 l_R : TRect;
//#UC END# *5028A60300AD_52B9AF0A027C_var*
//#UC START# *52B9AF0A027C_ext:ParentFileName
w:\common\components\gui\Garant\VT\vtNavigator.pas
//#UC END# *52B9AF0A027C_ext:ParentFileName
//#UC START# *52BABD9C03B7_52B9AF0A027Cset_impl*
 if (f_PageControl <> aValue) then
 begin
  f_PageControl := aValue;
  if (f_PageControl <> nil) then
  begin
   f_PageControl.Parent := f_Container;
   f_PageControl.Align := alClient;
  end;//f_PageControl <> nil
 end;//f_PageControl <> Value
//#UC END# *52BABD9C03B7_52B9AF0A027Cset_impl*
//#UC START# *52BABD9C03B7_52B9AF0A027Cset_var*
//#UC END# *52BABD9C03B7_52B9AF0A027Cset_var*
//#UC START# *52BABDB6021C_52B9AF0A027Cset_impl*
 if (f_Header <> aValue) then
 begin
  f_Header := aValue;
  if (f_Header <> nil) then
  begin
   f_Header.Parent := f_Container.Parent;
   f_Header.Align := alTop;
  end;//f_Header <> nil
 end;//f_Header <> Value
//#UC END# *52BABDB6021C_52B9AF0A027Cset_impl*
//#UC START# *52BABDB6021C_52B9AF0A027Cset_var*
//#UC END# *52BABDB6021C_52B9AF0A027Cset_var*
//#UC START# *52BAC0430151_52B9AF0A027Cget_impl*
 case f_Navigator.Align of
  alBottom, alTop: Result := Height;
  alLeft, alRight: Result := Width;
 else
  Result := Width;
 end;//case f_Navigator.Align
//#UC END# *52BAC0430151_52B9AF0A027Cget_impl*
//#UC START# *52BAC0430151_52B9AF0A027Cget_var*
//#UC END# *52BAC0430151_52B9AF0A027Cget_var*
//#UC START# *52BAC0A1016B_52B9AF0A027C_impl*
 Message.Result := 1;
//#UC END# *52BAC0A1016B_52B9AF0A027C_impl*
//#UC START# *52BAC0A1016B_52B9AF0A027C_var*
//#UC END# *52BAC0A1016B_52B9AF0A027C_var*
//#UC START# *52BAC11201BE_52B9AF0A027C_impl*
 if (f_Navigator.State = nsAutoHide) then
 case f_Navigator.Align of
  alRight: Left := f_Navigator.Parent.ClientWidth - Self.Width;
  alBottom: Top := f_Navigator.Parent.ClientHeight - Self.Height;
 end;//case f_Navigator.Align
//#UC END# *52BAC11201BE_52B9AF0A027C_impl*
//#UC START# *52BAC11201BE_52B9AF0A027C_var*
//#UC END# *52BAC11201BE_52B9AF0A027C_var*
//#UC START# *52BAC1220315_52B9AF0A027C_impl*
 f_Splitter.Visible := (*(f_Navigator.State <> nsMinimized) and*)
                      not f_Navigator.Float and
                      (f_Navigator.PageControl.PageCount > 0);
//#UC END# *52BAC1220315_52B9AF0A027C_impl*
//#UC START# *52BAC1220315_52B9AF0A027C_var*
//#UC END# *52BAC1220315_52B9AF0A027C_var*
//#UC START# *52BAC1450146_52B9AF0A027C_impl*
 case f_Navigator.Align of
  alBottom, alTop: Height := f_Navigator.SizeMini;
  alLeft, alRight: Width := f_Navigator.SizeMini;
 end;//case f_Navigator.Align
//#UC END# *52BAC1450146_52B9AF0A027C_impl*
//#UC START# *52BAC1450146_52B9AF0A027C_var*
//#UC END# *52BAC1450146_52B9AF0A027C_var*
//#UC START# *52BAC14E0369_52B9AF0A027C_impl*
 case f_Navigator.Align of
  alTop: f_Splitter.Align := alBottom;
  alLeft: f_Splitter.Align := alRight;
  alRight: f_Splitter.Align := alLeft;
  alBottom: f_Splitter.Align := alTop;
 end;//case f_Navigator.Align
//#UC END# *52BAC14E0369_52B9AF0A027C_impl*
//#UC START# *52BAC14E0369_52B9AF0A027C_var*
//#UC END# *52BAC14E0369_52B9AF0A027C_var*
//#UC START# *52BC48CC01E9_52B9AF0A027Cset_impl*
 if f_Navigator <> nil then
  f_Navigator.UnRegisterStateChanged(f_Link);

 f_Navigator := aValue;

 if f_Navigator <> nil then
  f_Navigator.RegisterStateChanged(f_Link);
//#UC END# *52BC48CC01E9_52B9AF0A027Cset_impl*
//#UC START# *52BC48CC01E9_52B9AF0A027Cset_var*
//#UC END# *52BC48CC01E9_52B9AF0A027Cset_var*
