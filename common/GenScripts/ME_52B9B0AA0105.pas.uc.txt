//#UC START# *479731C50290_52B9B0AA0105_impl*
 splHideHint;
 FreeAndNil(f_HideButtonHint);
 inherited;
//#UC END# *479731C50290_52B9B0AA0105_impl*
//#UC START# *479731C50290_52B9B0AA0105_var*
//#UC END# *479731C50290_52B9B0AA0105_var*
//#UC START# *47D1602000C6_52B9B0AA0105_impl*
 inherited;
 // Видимость изменится при добавлении первой закладки
 ControlStyle := ControlStyle + [csNoDesignVisible];
 Visible := False;
 Cursor := crHSplit;
 f_IsHideButtonDown := False;
 IsMouseDown := False;
//#UC END# *47D1602000C6_52B9B0AA0105_impl*
//#UC START# *47D1602000C6_52B9B0AA0105_var*
//#UC END# *47D1602000C6_52B9B0AA0105_var*
//#UC START# *48E22B250241_52B9B0AA0105_impl*
 l_CurPt := Point(X, Y);
 l_WasRealMoving := (Abs(f_LastMovingPoint.X - X) > cRealMovingThreshold) or
  (Abs(f_LastMovingPoint.Y - Y) > cRealMovingThreshold);
 // http://mdp.garant.ru/pages/viewpage.action?pageId=622830711
 l_TME.cbSize := SizeOf(TTrackMouseEvent);
 l_TME.dwFlags := TME_LEAVE;
 l_TME.hwndTrack := Handle;
 TrackMouseEvent(l_TME);
 try
  // Курсор вышел за пределы сплиттера, освободим захват курсора:
  if not PtInRect(ClientRect, l_CurPt) then
  begin
   // Если перетаскивают, то ничего делать не нужно:
   if not IsMouseDown and (GetCapture = Handle) then
     ReleaseCapture;
   // Мы перетаскиваем поэтому подсказку надо спрятать:
   splHideHint;
  end;//if not PtInRect(ClientRect, Point(X, Y)) then
  if not (ssLeft in Shift) then
  begin
   if (not GetParentForm(Self).Active) and (not f_Surface.Navigator.IsMinimized) then
    Exit;
   l_Button := PtInRect(GetButtonRect, l_CurPt);
   // Установим курсор:
   UpdateCursor(l_Button);
   // Покажем подсказку:
   if l_Button then
    splShowHint(X, Y)
   else
    splHideHint;
  end//not (ssLeft in Shift)
  else
  // Сплиттер перетаскивают:
  if IsMouseDown and l_WasRealMoving then
  // http://mdp.garant.ru/pages/viewpage.action?pageId=622830711
  begin
   l_Types := [dstErase, dstPaint];
   if IsHideButtonDown then
   begin
    // Отожмем кнопку:
    IsHideButtonDown := False;
    // изменим курсор
    UpdateCursor(False);
    // Первая отрисовка, очищать не надо:
    l_Types := [dstPaint];
   end;//IsHideButtonDown
   // Нарисуем сплиттер:
   with Mouse.CursorPos do
    f_Surface.Navigator.PaintSpliter(X, Y, l_Types);
  end;//if IsMouseDown then
 finally
  f_LastMovingPoint := l_CurPt;
 end;
//#UC END# *48E22B250241_52B9B0AA0105_impl*
//#UC START# *48E22B250241_52B9B0AA0105_var*
const
 cRealMovingThreshold: Integer = 4;
var
 l_CurPt: TPoint;
 l_WasRealMoving: Boolean;
 l_Types  : TnpDrawSplitterTypes;
 l_Button : Boolean;
 l_TME: TTrackMouseEvent;
//#UC END# *48E22B250241_52B9B0AA0105_var*
//#UC START# *4E7896270076_52B9B0AA0105_impl*
 splHideHint;
 IsMouseDown := False;
 if not (Button = mbLeft) then
  Exit;
 with f_Surface.Navigator do
 begin
  // Изменение размеров навигатора:
  if not IsHideButtonDown then
  begin
   // Удалим нарисованный сплиттер:
   PaintSpliter(Mouse.CursorPos.X, Mouse.CursorPos.Y, [dstErase]);
   Perform(CM_npDoActionWithFormControls, Ord(acRedraw), 0);
   // Изменим размеры навигатора:
   if not PointsEqual(f_MouseDownPoint, Mouse.CursorPos) then
   begin
    DoSplit;
    AutoHideUpdate;
   end;//if not PointsEqual(f_MouseDownPoint, Mouse.CursorPos) then
  end//if not IsHideButtonDown then
  // развернём/свернём навигатор
  else
  begin
   IsHideButtonDown := False;
   State := TNavigatorState(IfThen(State = nsMinimized, Ord(nsNormal), Ord(nsMinimized)));
  end;//if not PointsEqual(f_MouseDownPoint, Mouse.CursorPos) then
 end;//with f_Surface.Navigator do
//#UC END# *4E7896270076_52B9B0AA0105_impl*
//#UC START# *4E7896270076_52B9B0AA0105_var*
//#UC END# *4E7896270076_52B9B0AA0105_var*
//#UC START# *4F88473B03CD_52B9B0AA0105_impl*
 if (Button = mbLeft) then
 begin
  IsMouseDown := True;
  // запомним, чтобы определить в MouseUp, что пользователь двигал мыш
  f_MouseDownPoint := Mouse.CursorPos;
  // кнопка нажата
  if PtInRect(GetButtonRect, Point(X, Y)) then
   IsHideButtonDown := True
  else
  begin
   // нарисуем сплиттер
   with Mouse.CursorPos do
    f_Surface.Navigator.PaintSpliter(X, Y, [dstPaint]);
  end;//PtInRect(GetButtonRect, Point(X, Y))
 end;//Button = mbLeft
//#UC END# *4F88473B03CD_52B9B0AA0105_impl*
//#UC START# *4F88473B03CD_52B9B0AA0105_var*
//#UC END# *4F88473B03CD_52B9B0AA0105_var*
//#UC START# *5028A60300AD_52B9B0AA0105_impl*
 l_R := ClientRect;
 with Canvas do
 begin
  // заливаем
  Brush.Color := cGarant2011BackColor{clBtnFace};
  FillRect(l_R);
  // рисуем справа, слева линии clShadow
  Pen.Color := clBtnShadow;
  if (f_Surface.Navigator.Align <> alLeft) then
  begin
   MoveTo(l_R.Left, l_R.Top);
   LineTo(l_R.Left, l_R.Bottom);
  end;//Surface.Navigator.Align <> alLeft
  if (f_Surface.Navigator.Align <> alRight) then
  begin
   MoveTo(Pred(l_R.Right), l_R.Top);
   LineTo(Pred(l_R.Right), l_R.Bottom);
  end;//Surface.Navigator.Align <> alRight
 end;//with Canvas
 // рисуем кнопку сплиттера
 DrawButton;
//#UC END# *5028A60300AD_52B9B0AA0105_impl*
//#UC START# *5028A60300AD_52B9B0AA0105_var*
var
 l_R : TRect;
//#UC END# *5028A60300AD_52B9B0AA0105_var*
//#UC START# *52B9B0AA0105_ext:ParentFileName
w:\common\components\gui\Garant\VT\vtNavigator.pas
//#UC END# *52B9B0AA0105_ext:ParentFileName
//#UC START# *52BAB00903A4_52B9B0AA0105set_impl*
 if (f_IsHideButtonDown <> aValue) then
 begin
  f_IsHideButtonDown := aValue;
  DrawButton;
 end;//f_IsHideButtonDown <> Value
//#UC END# *52BAB00903A4_52B9B0AA0105set_impl*
//#UC START# *52BAB00903A4_52B9B0AA0105set_var*
//#UC END# *52BAB00903A4_52B9B0AA0105set_var*
//#UC START# *52BAB80A032F_52B9B0AA0105_impl*
 if not IsHandledShortcut(Msg) then
  inherited;
//#UC END# *52BAB80A032F_52B9B0AA0105_impl*
//#UC START# *52BAB80A032F_52B9B0AA0105_var*
//#UC END# *52BAB80A032F_52B9B0AA0105_var*
//#UC START# *52BAB8250200_52B9B0AA0105_impl*
 if not IsHandledShortcut(Msg) then
  inherited;
//#UC END# *52BAB8250200_52B9B0AA0105_impl*
//#UC START# *52BAB8250200_52B9B0AA0105_var*
//#UC END# *52BAB8250200_52B9B0AA0105_var*
//#UC START# *52BAB838013D_52B9B0AA0105_impl*
 if not IsHandledShortcut(Msg) then
  inherited;
//#UC END# *52BAB838013D_52B9B0AA0105_impl*
//#UC START# *52BAB838013D_52B9B0AA0105_var*
//#UC END# *52BAB838013D_52B9B0AA0105_var*
//#UC START# *52BAB8530216_52B9B0AA0105_impl*
 if not IsHandledShortcut(Msg) then
  inherited;
//#UC END# *52BAB8530216_52B9B0AA0105_impl*
//#UC START# *52BAB8530216_52B9B0AA0105_var*
//#UC END# *52BAB8530216_52B9B0AA0105_var*
//#UC START# *52BABB100388_52B9B0AA0105_impl*
 // Опустим будущее окно под курсор
 Inc(X, 16);
 // Окно
 l_Window := CreateButtonHint;
 // Hint
 l_Hint := f_Surface.Navigator.MinBtnHint;
 // Размещение окна
 l_Monitor := Screen.MonitorFromPoint(Mouse.CursorPos);
 if not Assigned(l_Monitor) then
  Exit;
 l_Temp.TopLeft := ClientToScreen(Point(X, Y));
 // Посчитаем размер прямоугольника учитывая ограничения текущим монитором
 l_HintRect := l_Window.CalcHintRect(l_Monitor.WorkareaRect.Right - l_Temp.Left,
  l_Hint, nil);
 l_Temp.Right := l_Temp.Left + l_HintRect.Right;
 l_Temp.Bottom := l_Temp.Top + l_HintRect.Bottom;
 // Покажем
 l_Window.ActivateHint(l_Temp, l_Hint);
//#UC END# *52BABB100388_52B9B0AA0105_impl*
//#UC START# *52BABB100388_52B9B0AA0105_var*
var
 l_HintRect : TRect;
 l_Hint     : String;
 l_Temp     : TRect;
 l_Window   : THintWindow;
 l_Monitor  : TMonitor;
//#UC END# *52BABB100388_52B9B0AA0105_var*
//#UC START# *52BABB57018D_52B9B0AA0105_impl*
 if HideButtonHint <> nil then
  HideButtonHint.ReleaseHandle;
//#UC END# *52BABB57018D_52B9B0AA0105_impl*
//#UC START# *52BABB57018D_52B9B0AA0105_var*
//#UC END# *52BABB57018D_52B9B0AA0105_var*
//#UC START# *52BABB61000E_52B9B0AA0105_impl*
 if HideButtonHint = nil then
 begin
  HideButtonHint := THintWindow.Create(Self);
  with HideButtonHint do
  begin
   Color:= GetSysColor(COLOR_INFOBK);
   Canvas.Brush.Color:= GetSysColor(COLOR_INFOBK);
   Canvas.Font:= Self.Font;
   Canvas.Font.Color:= GetSysColor(COLOR_INFOTEXT);
   Canvas.Pen.Color:= clBlack;
  end;//with HideButtonHint
 end;//HideButtonHint = nil
 Result := HideButtonHint;
//#UC END# *52BABB61000E_52B9B0AA0105_impl*
//#UC START# *52BABB61000E_52B9B0AA0105_var*
//#UC END# *52BABB61000E_52B9B0AA0105_var*
//#UC START# *52BABB7902B0_52B9B0AA0105_impl*
 if aButton then
  Cursor := crHandPoint
 else
  SetSizeCursor;
 // это нужно, чтобы при смене курсора компонента поменялся курсор на экране
 Windows.SetCursor(Screen.Cursors[Cursor]);
//#UC END# *52BABB7902B0_52B9B0AA0105_impl*
//#UC START# *52BABB7902B0_52B9B0AA0105_var*
//#UC END# *52BABB7902B0_52B9B0AA0105_var*
//#UC START# *52BABB8900D4_52B9B0AA0105_impl*
 if not Assigned(aCanvas) then
  aCanvas := Canvas;
 // область расположения
 l_Rect := GetButtonRect;
 // кнопка
 DrawFrameControl(aCanvas.Handle,
                  l_Rect,
                  DFC_BUTTON, DFCS_BUTTONPUSH or cButtonState[IsHideButtonDown]);
 // нужно доделать если появится такое выравнивание
 //Assert((Align <> alTop) and (Align <> alBottom));
 // точка стрелочки
 l_Center := (l_Rect.Top + l_Rect.Bottom) div 2;
 // рисуем
 InflateRect(l_Rect, -1, -1);
 DrawArrow(l_Center, clBlue);
//#UC END# *52BABB8900D4_52B9B0AA0105_impl*
//#UC START# *52BABB8900D4_52B9B0AA0105_var*
const
 cButtonState : array [Boolean] of Integer = (0, DFCS_PUSHED);
var
 l_Rect    : TRect;
 l_Center  : Integer;

 procedure DrawArrow(aY     : Integer;
                     aColor : TColor);
 var
  l_Delta   : Integer;
  l_Left    : Boolean;
    {* - стрелка указывает влево. }
  l_Index   : Integer;
 begin//DrawArrow
  // куда указывает стрелка
  l_Left := (Align = alRight);
  if f_Surface.Navigator.IsMinimized then
   l_Left := not l_Left;
  // инициализируем дельту
  if l_Left then
   l_Delta := 0
  else
   l_Delta := Pred(l_Rect.Right) - l_Rect.Left;
  // первая точка
  for l_Index := l_Rect.Left to Pred(l_Rect.Right) do
  begin
   with aCanvas do
   begin
    Pixels[l_Index, aY - l_Delta] := aColor;
    Pixels[l_Index, aY + l_Delta] := aColor;
   end;//with aCanvas
   if l_Left then
    Inc(l_Delta)
   else
    Dec(l_Delta);
  end;//for l_Index
 end;//DrawArrow
//#UC END# *52BABB8900D4_52B9B0AA0105_var*
//#UC START# *52BABB9A02AB_52B9B0AA0105_impl*
 SetRectEmpty(Result);
 // горизонтальный сплиттер
 if (Width > Height) then
 begin
  l_Size := lDefineSize(ClientWidth);
  Result.Left := (ClientWidth - l_Size) div 2;
  Result.Right := Result.Left + l_Size;
  Result.Top := 0;
  Result.Bottom := ClientHeight;
 end//Width > Height
 // вертикальный сплиттер
 else
 begin
  l_Size := lDefineSize(ClientHeight);
  Result.Top := (ClientHeight - l_Size) div 2;
  Result.Bottom := Result.Top + l_Size;
  Result.Left := 0;
  Result.Right := ClientWidth;
 end;//Width > Height
 Inc(Result.Left);
//#UC END# *52BABB9A02AB_52B9B0AA0105_impl*
//#UC START# *52BABB9A02AB_52B9B0AA0105_var*
 function lDefineSize(const aSize : Integer) : Integer;
 begin//lDefineSize
  if (cspButtonSize > aSize) then
   Result := aSize div 3
  else
   Result := cspButtonSize;
 end;//lDefineSize

var
 l_Size : Integer;
//#UC END# *52BABB9A02AB_52B9B0AA0105_var*
//#UC START# *52BABBD102EC_52B9B0AA0105_impl*
 case f_Surface.Navigator.Align of
  alLeft, alRight: Cursor := crHSplit;
  alTop, alBottom: Cursor := crVSplit;
 end;//case f_Surface.Navigator.Align of
//#UC END# *52BABBD102EC_52B9B0AA0105_impl*
//#UC START# *52BABBD102EC_52B9B0AA0105_var*
//#UC END# *52BABBD102EC_52B9B0AA0105_var*
//#UC START# *52BABBE6027E_52B9B0AA0105_impl*
 Result := False;
 l_Controller := GetDefController;
 if Assigned(l_Controller) then
  with l_Controller.EntryCommands do
   if TranslateUsing([], TMessage(Msg), GetTickCount) = ccShortCut then
   begin
    Msg.Result := 0;  {indicate that this message was processed}
    Result := True;
   end;//TranslateUsing([], TMessage(Msg), GetTickCount) = ccShortCut
//#UC END# *52BABBE6027E_52B9B0AA0105_impl*
//#UC START# *52BABBE6027E_52B9B0AA0105_var*
var
 l_Controller : TOvcController;
//#UC END# *52BABBE6027E_52B9B0AA0105_var*
//#UC START# *5374D62902DC_52B9B0AA0105_impl*
 splHideHint;
 inherited;
//#UC END# *5374D62902DC_52B9B0AA0105_impl*
//#UC START# *5374D62902DC_52B9B0AA0105_var*
//#UC END# *5374D62902DC_52B9B0AA0105_var*
