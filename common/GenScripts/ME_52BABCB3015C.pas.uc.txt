//#UC START# *479731C50290_52BABCB3015C_impl*
 if (f_Navigator <> nil) then
  f_Navigator.UnRegisterStateChanged(f_Link);
 f_Navigator := nil;

 FreeAndNil(f_Canvas);
 FreeAndNil(f_CloseButton);
 FreeAndNil(f_AutoHideButton);
 FreeAndNil(f_HideButton);
 FreeAndNil(f_Link);
 inherited;
//#UC END# *479731C50290_52BABCB3015C_impl*
//#UC START# *479731C50290_52BABCB3015C_var*
//#UC END# *479731C50290_52BABCB3015C_var*
//#UC START# *47D1602000C6_52BABCB3015C_impl*
 inherited Create(AOwner);
 ControlStyle := ControlStyle + [csNoDesignVisible];
 Cursor := crSizeAll;
 f_Canvas := Tl3CustomControlCanvas.Create(Self);
 f_AutoHideOnImage := 0;
 f_AutoHideOffImage := 1;
 f_HideLeftImage := 2;
 f_HideRightImage := 3;
 f_CloseImage := 6;
 f_HideUpImage := 4;
 f_HideDownImage := 5;
 Size := cHeaderSize;
 f_Link := TnpChangeLink.Create;
 f_Link.OnStateChanged := OnStateChanged;
 SetBtn(f_AutoHideButton, nbtAutoHide, cBmpAutoHideOff);
 with AutoHideButton do
 begin
  AllowAllUp := True;
  GroupIndex := 1;
  Down := True;
 end;
 SetBtn(f_HideButton, nbtMinimize, cBmpHideLeft);
 SetBtn(f_CloseButton, nbtClose,    cBmpClose);
 UpdatePositions;
//#UC END# *47D1602000C6_52BABCB3015C_impl*
//#UC START# *47D1602000C6_52BABCB3015C_var*
  procedure SetBtn(var aBtn : TnpButton;
                   aBtnType : TnpButtonType;
                   const aGlyphID : String);
  begin//SetBtn
   aBtn := TnpButton.Create(Self, TvtNavigator(aOwner), aBtnType);
   with aBtn do
   begin
    Name := aGlyphID;
    Parent := Self;
    Height := cButtonSize;
    Width := cButtonSize;
    Left := cIntervalButtonLine;
    Top := cIntervalButtonLine;
    Flat := True;
    Glyph.LoadFromResourceName(HInstance, aGlyphID);
   end;//with aBtn do
   if csDesigning in Self.ComponentState  then
     aBtn.Visible := False;
  end;//SetBtn
//#UC END# *47D1602000C6_52BABCB3015C_var*
//#UC START# *4F88473B03CD_52BABCB3015C_impl*
 if Button = mbLeft then
 begin
  if not Assigned(f_Navigator.f_PageControl.ActivePage) then
   Exit
  else
  if f_Navigator.f_PageControl.ActivePage.ControlCount = 0 then
   Exit;
  l_Control := f_Navigator.f_PageControl.ActivePage.Controls[0];
  f_Navigator.InitDrag(l_Control);
  f_IsDragBegining := True;
  f_Navigator.f_ActiveControl := l_Control;
  l_Control.BeginDrag(False);
 end;
 inherited MouseDown(Button, Shift, X, Y);
//#UC END# *4F88473B03CD_52BABCB3015C_impl*
//#UC START# *4F88473B03CD_52BABCB3015C_var*
var
 l_Control : TControl;
//#UC END# *4F88473B03CD_52BABCB3015C_var*
//#UC START# *5028A60300AD_52BABCB3015C_impl*
 inherited;
 lRect := ClientRect;
 with Canvas do
 begin
  Brush.Color := cGarant2011ToolbarsColor{clBtnFace};
  FillRect(lRect);
  if f_Navigator.State = nsMinimized then
   Exit;
  (* навигатор находится в режиме автоскрытия и сейчас должна быть видна только
     кнопка AutoHideButton *)
  HideButton.Visible := not ((f_Navigator.State = nsAutoHide) and
   (f_Navigator.f_Surface.Size <= f_Navigator.SizeMini));
  CloseButtonVisible(HideButton.Visible);
  (* выводим иконку и название закладки *)
  if f_Navigator.ShowActivePageInHeader then
  begin
   if HideButton.Visible then
    lp_DrawActivePage;
  end//f_Navigator.ShowActivePageInHeader
  (* рисуем полосы *)
  else
  begin
   (* видна только кнопка AutoHideButton *)
   if not HideButton.Visible then
    Exit;
   if (f_Navigator.State <> nsMinimized) and
    (f_Navigator.f_HideDirect <> hdHide) then
   begin
    if f_Navigator.f_Float then
     InflateRect(lRect, -1, -1);
    lp_DrawFrame(lRect);
    { Первая линия }
    lp_PaintLine(0);
    { Подадим смещения для второй линии }
    lp_PaintLine(cOffsetSecondLine);
   end;//f_Navigator.State <> nsMinimized..
  end;//f_Navigator.ShowActivePageInHeader
 end;//with Canvas
//#UC END# *5028A60300AD_52BABCB3015C_impl*
//#UC START# *5028A60300AD_52BABCB3015C_var*
  procedure lp_DrawFrame(aRect : TRect);
  begin//lp_DrawFrame
   Frame3D(Canvas, aRect, clBtnHighlight, clBtnShadow, 1);
   //Frame3D(Canvas, aRect, clBtnShadow, clBtnShadow, 1);
  end;//lp_DrawFrame

  procedure lp_PaintLine(ABelow: Integer);
  var
   lRect: TRect;
  begin//lp_PaintLine
   lRect := GetRectLines;
   { горизонталь }
   if (Self.Width > Self.Height) then
   begin
    lRect.Top := lRect.Top + ABelow;
    lRect.Bottom := lRect.Top + cBorderWidth;
   { вертикаль }
   end//Self.Width > Self.Height
   else
   begin
    lRect.Left := lRect.Left + ABelow;
    lRect.Right := lRect.Left + cBorderWidth;
   end;//Self.Width > Self.Height

   if Self.Width > Self.Height then
    Inc(lRect.Bottom)
   else
    Inc(lRect.Right);

   Frame3D(Self.Canvas, lRect, clBtnHighlight, clBtnShadow, 1);
  end;//lp_PaintLine

  procedure lp_DrawActivePage;
  var
   lRect    : TRect;
   lCaption : String;
  begin//lp_DrawActivePage
   if Assigned(f_Navigator.PageControl.ActivePage) then
   begin
    with Canvas do
    begin
     if f_Navigator.State = nsMinimized then
      Exit;
     (* рамка *)
     lp_DrawFrame(ClientRect);
     (* выводимая область *)
     lRect := GetRectLines;
     lRect.Top := 0;
     lRect.Bottom := ClientHeight;
     (* иконка *)
     with f_Navigator.f_PageControl do
      if Assigned(Images) and (ActivePage.ImageIndex <> -1) and
       (ActivePage.ImageIndex < Images.Count) then
      begin
       with Images do
        Draw(Self.Canvas, lRect.Left, (Self.Height - Height) div 2,
         ActivePage.ImageIndex, True);
       lRect.Left := lRect.Left + Images.Width + 2;
      end;//Assigned(Images) and (ActivePage.ImageIndex <> -1)..
     (* текст *)
     InflateRect(lRect, -1, -1);
     lCaption := f_Navigator.PageControl.ActivePage.Caption;
     f_Canvas.Font.AssignFont(Font);
     f_Canvas.BeginPaint;
     try
      f_Canvas.DrawText(l3PCharLen(lCaption),
                       lRect,
                       DT_VCENTER      or
                       DT_END_ELLIPSIS or
                       DT_SINGLELINE);
     finally
      f_Canvas.EndPaint;
     end;//try..finally
    end;//with Canvas
   end;//Assigned(f_Navigator.PageControl.ActivePage)
  end;//lp_DrawActivePage

var
  lRect: TRect;
//#UC END# *5028A60300AD_52BABCB3015C_var*
//#UC START# *508F957E0283_52BABCB3015C_impl*
 inherited;
 InflateRect(Rect, - cIntervalHeaderButton, - cIntervalHeaderButton);
//#UC END# *508F957E0283_52BABCB3015C_impl*
//#UC START# *508F957E0283_52BABCB3015C_var*
//#UC END# *508F957E0283_52BABCB3015C_var*
//#UC START# *52BABCB3015C_ext:ParentFileName
w:\common\components\gui\Garant\VT\vtNavigator.pas
//#UC END# *52BABCB3015C_ext:ParentFileName
//#UC START# *52BAC39100F8_52BABCB3015C_impl*
 Message.Result := 1;
//#UC END# *52BAC39100F8_52BABCB3015C_impl*
//#UC START# *52BAC39100F8_52BABCB3015C_var*
//#UC END# *52BAC39100F8_52BABCB3015C_var*
//#UC START# *52BAC726019F_52BABCB3015Cget_impl*
 Result := inherited Align;
//#UC END# *52BAC726019F_52BABCB3015Cget_impl*
//#UC START# *52BAC726019F_52BABCB3015Cget_var*
//#UC END# *52BAC726019F_52BABCB3015Cget_var*
//#UC START# *52BAC726019F_52BABCB3015Cset_impl*
 inherited Align := aValue;
 UpdatePositions;
//#UC END# *52BAC726019F_52BABCB3015Cset_impl*
//#UC START# *52BAC726019F_52BABCB3015Cset_var*
//#UC END# *52BAC726019F_52BABCB3015Cset_var*
//#UC START# *52BAC77E0213_52BABCB3015Cset_impl*
 if (f_CloseImage <> aValue) then
 begin
  f_CloseImage := aValue;
  UpdateCloseImage;
  UpdateHideImage;
 end;//f_CloseImage <> Value
//#UC END# *52BAC77E0213_52BABCB3015Cset_impl*
//#UC START# *52BAC77E0213_52BABCB3015Cset_var*
//#UC END# *52BAC77E0213_52BABCB3015Cset_var*
//#UC START# *52BAC83B035F_52BABCB3015Cset_impl*
 if (f_AutoHideOnImage <> aValue) then
 begin
  f_AutoHideOnImage := aValue;
  UpdateAutoHideImage;
 end;//f_AutoHideOnImage <> Value
//#UC END# *52BAC83B035F_52BABCB3015Cset_impl*
//#UC START# *52BAC83B035F_52BABCB3015Cset_var*
//#UC END# *52BAC83B035F_52BABCB3015Cset_var*
//#UC START# *52BAC84C0124_52BABCB3015Cset_impl*
 if (f_AutoHideOffImage <> aValue) then
 begin
  f_AutoHideOffImage := aValue;
  UpdateAutoHideImage;
 end;//f_AutoHideOffImage <> Value
//#UC END# *52BAC84C0124_52BABCB3015Cset_impl*
//#UC START# *52BAC84C0124_52BABCB3015Cset_var*
//#UC END# *52BAC84C0124_52BABCB3015Cset_var*
//#UC START# *52BAC8920025_52BABCB3015Cset_impl*
 if (f_HideLeftImage <> aValue) then
 begin
  f_HideLeftImage := aValue;
  DoStateChanged;
 end;//f_HideLeftImage <> Value
//#UC END# *52BAC8920025_52BABCB3015Cset_impl*
//#UC START# *52BAC8920025_52BABCB3015Cset_var*
//#UC END# *52BAC8920025_52BABCB3015Cset_var*
//#UC START# *52BAC89D020A_52BABCB3015Cset_impl*
 if (f_HideRightImage <> aValue) then
 begin
  f_HideRightImage := aValue;
  DoStateChanged;
 end;//f_HideRightImage <> Value
//#UC END# *52BAC89D020A_52BABCB3015Cset_impl*
//#UC START# *52BAC89D020A_52BABCB3015Cset_var*
//#UC END# *52BAC89D020A_52BABCB3015Cset_var*
//#UC START# *52BAC8A7004C_52BABCB3015Cset_impl*
 if (f_HideUpImage <> aValue) then
 begin
  f_HideUpImage := aValue;
  UpdateHideImage;
 end;//f_HideUpImage <> Value
//#UC END# *52BAC8A7004C_52BABCB3015Cset_impl*
//#UC START# *52BAC8A7004C_52BABCB3015Cset_var*
//#UC END# *52BAC8A7004C_52BABCB3015Cset_var*
//#UC START# *52BAC8AF036E_52BABCB3015Cset_impl*
 if (f_HideDownImage <> aValue) then
 begin
  f_HideDownImage := aValue;
  UpdateHideImage;
 end;//f_HideDownImage <> Value
//#UC END# *52BAC8AF036E_52BABCB3015Cset_impl*
//#UC START# *52BAC8AF036E_52BABCB3015Cset_var*
//#UC END# *52BAC8AF036E_52BABCB3015Cset_var*
//#UC START# *52BAC8FB0112_52BABCB3015Cget_impl*
 Result := f_Size;
//#UC END# *52BAC8FB0112_52BABCB3015Cget_impl*
//#UC START# *52BAC8FB0112_52BABCB3015Cget_var*
//#UC END# *52BAC8FB0112_52BABCB3015Cget_var*
//#UC START# *52BAC8FB0112_52BABCB3015Cset_impl*
 if (f_Size <> aValue) then
 begin
  f_Size := aValue;
  UpdateSize;
 end;//f_Size <> Value
//#UC END# *52BAC8FB0112_52BABCB3015Cset_impl*
//#UC START# *52BAC8FB0112_52BABCB3015Cset_var*
//#UC END# *52BAC8FB0112_52BABCB3015Cset_var*
//#UC START# *52BAC9740089_52BABCB3015Cget_impl*
 Result := HideButton.OnClick;
//#UC END# *52BAC9740089_52BABCB3015Cget_impl*
//#UC START# *52BAC9740089_52BABCB3015Cget_var*
//#UC END# *52BAC9740089_52BABCB3015Cget_var*
//#UC START# *52BAC9740089_52BABCB3015Cset_impl*
 HideButton.OnClick := aValue;
//#UC END# *52BAC9740089_52BABCB3015Cset_impl*
//#UC START# *52BAC9740089_52BABCB3015Cset_var*
//#UC END# *52BAC9740089_52BABCB3015Cset_var*
//#UC START# *52BAC993024A_52BABCB3015Cget_impl*
 Result := AutoHideButton.OnClick;
//#UC END# *52BAC993024A_52BABCB3015Cget_impl*
//#UC START# *52BAC993024A_52BABCB3015Cget_var*
//#UC END# *52BAC993024A_52BABCB3015Cget_var*
//#UC START# *52BAC993024A_52BABCB3015Cset_impl*
 AutoHideButton.OnClick := aValue;
//#UC END# *52BAC993024A_52BABCB3015Cset_impl*
//#UC START# *52BAC993024A_52BABCB3015Cset_var*
//#UC END# *52BAC993024A_52BABCB3015Cset_var*
//#UC START# *52BACA3F0292_52BABCB3015Cset_impl*
 if f_ButtonsImageList <> aValue then
 begin
//  {$IfDef NavigatorPanelNeedsTb97}
  AutoHideButton.Images := aValue;
  HideButton.Images := aValue;
  CloseButton.Images := aValue;
//  {$EndIf NavigatorPanelNeedsTb97}
  f_ButtonsImageList := aValue;
 end;
//#UC END# *52BACA3F0292_52BABCB3015Cset_impl*
//#UC START# *52BACA3F0292_52BABCB3015Cset_var*
//#UC END# *52BACA3F0292_52BABCB3015Cset_var*
//#UC START# *52BACD510230_52BABCB3015C_impl*
 if (CloseButton <> nil) then
  with CloseButton do
  begin
   OnClick := nil;
   CloseButtonVisible(False);
  end;//with CloseButton
//#UC END# *52BACD510230_52BABCB3015C_impl*
//#UC START# *52BACD510230_52BABCB3015C_var*
//#UC END# *52BACD510230_52BABCB3015C_var*
//#UC START# *52BACD6D0047_52BABCB3015C_impl*
 if Assigned(aHandler.Handler) AND
    aHandler.CanHaveCloseButtonInNavigator then
 begin
  if (f_CloseButton <> nil) then
   with CloseButton do
   begin
    OnClick := aHandler.Handler;
    Hint := l3Str(aHandler.Hint);
    CloseButtonVisible(True);
   end//with CloseButton do
 end//Assigned(aHandler.Handler)
 else
  HideCloseButton;
//#UC END# *52BACD6D0047_52BABCB3015C_impl*
//#UC START# *52BACD6D0047_52BABCB3015C_var*
//#UC END# *52BACD6D0047_52BABCB3015C_var*
//#UC START# *52BACD9A0283_52BABCB3015C_impl*
 if Assigned(CloseButton.OnClick) then
  CloseButton.Visible := aValue
 else
 if not aValue then
  CloseButton.Hide;
//#UC END# *52BACD9A0283_52BABCB3015C_impl*
//#UC START# *52BACD9A0283_52BABCB3015C_var*
//#UC END# *52BACD9A0283_52BABCB3015C_var*
//#UC START# *52BACDF902D8_52BABCB3015C_impl*
 UpdateAutoHideImage;
 UpdateHideImage;
 UpdateCloseImage;
//#UC END# *52BACDF902D8_52BABCB3015C_impl*
//#UC START# *52BACDF902D8_52BABCB3015C_var*
//#UC END# *52BACDF902D8_52BABCB3015C_var*
//#UC START# *52BACE0703DA_52BABCB3015C_impl*
 case Align of
  alLeft, alRight: Width := f_Size;
  alTop, alBottom: Height := f_Size;
 else
  Height := f_Size;
 end;//case Align
//#UC END# *52BACE0703DA_52BABCB3015C_impl*
//#UC START# *52BACE0703DA_52BABCB3015C_var*
//#UC END# *52BACE0703DA_52BABCB3015C_var*
//#UC START# *52BACE0F03BF_52BABCB3015C_impl*
 AutoHideButton.Align := alNone;
 CloseButton.Align := alNone;
 HideButton.Align := alNone;
 if Navigator = nil then
  Exit;
 if Navigator.Float then
  lp_Left
 else
 case Navigator.Align of
  alLeft: lp_Left;
  alRight: lp_Right;
  alTop: lp_Top;
  alBottom: lp_Bottom;
 end;//case Align of
//#UC END# *52BACE0F03BF_52BABCB3015C_impl*
//#UC START# *52BACE0F03BF_52BABCB3015C_var*
  procedure lp_Left;
  begin//lp_Left
   AutoHideButton.Align := alLeft;
   HideButton.Align := alRight;
   CloseButton.Align := alRight;
   // Поставим кнопку закрыть перед кнопкой скрыть:
   if HideButton.Visible and CloseButton.Visible then
    CloseButton.Left := HideButton.Left - 1;
  end;//lp_Left

  procedure lp_Right;
  begin//lp_Right
   AutoHideButton.Align := alRight;
   HideButton.Align := alLeft;
   CloseButton.Align := alLeft;
   // Поставим кнопку закрыть перед кнопкой скрыть:
   if HideButton.Visible and CloseButton.Visible then
    CloseButton.Left := HideButton.BoundsRect.Right + 1;
  end;//lp_Right

  procedure lp_Top;
  begin//lp_Top
   AutoHideButton.Align := alTop;
   HideButton.Align := alBottom;
   CloseButton.Align := alBottom;
   // Поставим кнопку закрыть перед кнопкой скрыть:
   if HideButton.Visible and CloseButton.Visible then
    CloseButton.Top := HideButton.Top - 1;
  end;//lp_Top

  procedure lp_Bottom;
  begin//lp_Bottom
   AutoHideButton.Align := alBottom;
   HideButton.Align := alTop;
   CloseButton.Align := alTop;
   // Поставим кнопку закрыть перед кнопкой скрыть:
   if HideButton.Visible and CloseButton.Visible then
    CloseButton.Top := HideButton.BoundsRect.Bottom + 1;
  end;//lp_Bottom
//#UC END# *52BACE0F03BF_52BABCB3015C_var*
//#UC START# *52BACE1A006B_52BABCB3015C_impl*
 if not f_Navigator.f_Float then
 begin
  if f_Navigator.State <> nsMinimized then
   case f_Navigator.Align of
    alRight:
     begin
//      {$IfDef NavigatorPanelNeedsTb97}
      HideButton.ImageIndex := f_HideRightImage;
//      {$Else}
//      HideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideRight);
//      {$EndIf NavigatorPanelNeedsTb97}
     end;//alRight
    alLeft:
     begin
//      {$IfDef NavigatorPanelNeedsTb97}
      HideButton.ImageIndex := f_HideLeftImage;
//      {$Else}
//      HideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideLeft);
//      {$EndIf NavigatorPanelNeedsTb97}
     end;//alLeft
   end//f_Navigator.Align
  else
   case f_Navigator.Align of
    alRight:
     begin
//      {$IfDef NavigatorPanelNeedsTb97}
      HideButton.ImageIndex := f_HideLeftImage;
//      {$Else}
//      HideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideLeft);
//      {$EndIf NavigatorPanelNeedsTb97}
     end;//alRight
    alLeft:
     begin
//      {$IfDef NavigatorPanelNeedsTb97}
      HideButton.ImageIndex := f_HideRightImage;
//      {$Else}
//      HideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideRight);
//      {$EndIf NavigatorPanelNeedsTb97}
     end;//alLeft
   end;//case f_Navigator.Align
 end//not f_Navigator.f_Float
 else
//  {$IfDef NavigatorPanelNeedsTb97}
  HideButton.ImageIndex := f_AutoHideOnImage;
//  {$EndIf NavigatorPanelNeedsTb97}
//#UC END# *52BACE1A006B_52BABCB3015C_impl*
//#UC START# *52BACE1A006B_52BABCB3015C_var*
//#UC END# *52BACE1A006B_52BABCB3015C_var*
//#UC START# *52BACE520121_52BABCB3015C_impl*
// {$IfDef NavigatorPanelNeedsTB97}
 CloseButton.ImageIndex := f_CloseImage;
// {$Else}
// CloseButton.Glyph.LoadFromResourceName(HInstance, cBmpClose);
// {$EndIf NavigatorPanelNeedsTB97}
//#UC END# *52BACE520121_52BABCB3015C_impl*
//#UC START# *52BACE520121_52BABCB3015C_var*
//#UC END# *52BACE520121_52BABCB3015C_var*
//#UC START# *52BACE6303BA_52BABCB3015C_impl*
 if not f_Navigator.f_Float then
 begin
  case f_Navigator.State of
   nsAutoHide:
//    {$IfDef NavigatorPanelNeedsTB97}
    AutoHideButton.ImageIndex := f_AutoHideOffImage;
//    {$Else}
//    AutoHideButton.Glyph.LoadFromResourceName(HInstance, cBmpAutoHideOn);
//    {$EndIf NavigatorPanelNeedsTB97}
   else
//    {$IfDef NavigatorPanelNeedsTB97}
    AutoHideButton.ImageIndex := f_AutoHideOnImage;
//    {$Else}
//    AutoHideButton.Glyph.LoadFromResourceName(HInstance, cBmpAutoHideOff);
//    {$EndIf NavigatorPanelNeedsTB97}
  end;//case f_Navigator.Stat
 end//not f_Navigator.f_Float
 else
 begin
  if f_Navigator.f_FloatNavigator.State = fwsMinimized then
//   {$IfDef NavigatorPanelNeedsTB97}
   AutoHideButton.ImageIndex := f_HideDownImage
//   {$Else}
//   AutoHideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideBottom)
//   {$EndIf NavigatorPanelNeedsTB97}
  else
//   {$IfDef NavigatorPanelNeedsTB97}
   AutoHideButton.ImageIndex := f_HideUpImage;
//   {$Else}
//   AutoHideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideTop);
//   {$EndIf NavigatorPanelNeedsTB97}
 end;//not f_Navigator.f_Float
//#UC END# *52BACE6303BA_52BABCB3015C_impl*
//#UC START# *52BACE6303BA_52BABCB3015C_var*
//#UC END# *52BACE6303BA_52BABCB3015C_var*
//#UC START# *52BACE6F03E3_52BABCB3015C_impl*
 Result := lp_FreeRect;
  // - свободная область для вывода линий;
 with Result do
  case Align of
   alLeft, alRight: Windows.InflateRect(Result, - ((Width - cLinesHeight) div 2), 0);
     // - расположим линии по середине навигатора;
   alTop, alBottom: Windows.InflateRect(Result, 0, - ((Height - cLinesHeight) div 2));
     // - расположим линии по середине навигатора;
  end;//case Navigator.Align of
//#UC END# *52BACE6F03E3_52BABCB3015C_impl*
//#UC START# *52BACE6F03E3_52BABCB3015C_var*
 function lp_FreeRect: TRect;
 var
  l_Index: Integer;
 begin
  Result := BoundsRect;
  for l_Index := 0 to Pred(ControlCount) do
   if Controls[l_Index].Visible then
    case Align of
     alLeft, alRight:
      case Controls[l_Index].Align of
       alTop: Result.Top := Max(Result.Top, Controls[l_Index].BoundsRect.Bottom);
       alBottom: Result.Bottom := Min(Result.Bottom, Controls[l_Index].BoundsRect.Top);
      else
       Assert(False);
      end;//case Controls[l_Index] of
     alTop, alBottom:
      case Controls[l_Index].Align of
       alLeft: Result.Left := Max(Result.Left, Controls[l_Index].BoundsRect.Right);
       alRight: Result.Right := Min(Result.Right, Controls[l_Index].BoundsRect.Left);
      else
       Assert(False);
      end;//case Controls[l_Index] of
    end;//case Navigator.Align of
 end;//lp_FreeRect
//#UC END# *52BACE6F03E3_52BABCB3015C_var*
//#UC START# *52BACE8501F5_52BABCB3015C_impl*
 with f_Navigator do
 begin
  UpdateHideImage;
  UpdateAutoHideImage;
  if f_Navigator.Float then
   with AutoHideButton do
   begin
    GroupIndex := 0;
    Down := False;
   end//with AutoHideButton
  else
   case State of
    nsMinimized:
     begin
      HideButton.Visible := True;
      AutoHideButton.Visible := False;
      CloseButtonVisible(False);
     end;//nsMinimized
    nsNormal:
     begin
      HideButton.Visible := True;
      AutoHideButton.Down := True;
      AutoHideButton.Visible := True;
      CloseButtonVisible(True);
     end;//nsNormal
    nsAutoHide:
     begin
      with AutoHideButton do
      begin
       Down := False;
       Visible := True;
      end;//AutoHideButton
      HideButton.Visible := f_Navigator.f_HideDirect = hdShow;
      CloseButtonVisible(HideButton.Visible);
     end;//nsAutoHide
   end;//case State
 end;//with f_Navigator
//#UC END# *52BACE8501F5_52BABCB3015C_impl*
//#UC START# *52BACE8501F5_52BABCB3015C_var*
//#UC END# *52BACE8501F5_52BABCB3015C_var*
//#UC START# *52BACE8C01C7_52BABCB3015C_impl*
 DoStateChanged;
//#UC END# *52BACE8C01C7_52BABCB3015C_impl*
//#UC START# *52BACE8C01C7_52BABCB3015C_var*
//#UC END# *52BACE8C01C7_52BABCB3015C_var*
//#UC START# *52BC48D00331_52BABCB3015Cset_impl*
 if (f_Navigator <> aValue) then
 begin
  if f_Navigator <> nil then
   f_Navigator.UnRegisterStateChanged(f_Link);

  f_Navigator := aValue;

  if f_Navigator <> nil then
   f_Navigator.RegisterStateChanged(f_Link);
 end;//f_Navigator <> Value
//#UC END# *52BC48D00331_52BABCB3015Cset_impl*
//#UC START# *52BC48D00331_52BABCB3015Cset_var*
//#UC END# *52BC48D00331_52BABCB3015Cset_var*
