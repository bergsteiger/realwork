//#UC START# *4683E75B01D8_52BAD1C40174_impl*
{$ifdef Nemesis}
 Result := f_PageControl.SaveState(theState, aStateType);
{$endif Nemesis}
//#UC END# *4683E75B01D8_52BAD1C40174_impl*
//#UC START# *4683E75B01D8_52BAD1C40174_var*
//#UC END# *4683E75B01D8_52BAD1C40174_var*
//#UC START# *4683E79D0331_52BAD1C40174_impl*
{$ifdef Nemesis}
 Result := f_PageControl.LoadState(theState, aStateType);
{$endif Nemesis}
//#UC END# *4683E79D0331_52BAD1C40174_impl*
//#UC START# *4683E79D0331_52BAD1C40174_var*
//#UC END# *4683E79D0331_52BAD1C40174_var*
//#UC START# *473DB05D033A_52BAD1C40174_impl*
 {$If defined(Nemesis) AND not defined(NoVCM)}
 f_PageDeactivated := True;
 {$IfEnd}
 DoActivate(False);
//#UC END# *473DB05D033A_52BAD1C40174_impl*
//#UC START# *473DB05D033A_52BAD1C40174_var*
//#UC END# *473DB05D033A_52BAD1C40174_var*
//#UC START# *473DB06A01A8_52BAD1C40174_impl*
 {$If defined(Nemesis) AND not defined(NoVCM)}
 f_PageDeactivated := False;
 {$IfEnd}
 DoActivate(True);
//#UC END# *473DB06A01A8_52BAD1C40174_impl*
//#UC START# *473DB06A01A8_52BAD1C40174_var*
//#UC END# *473DB06A01A8_52BAD1C40174_var*
//#UC START# *473DB083030D_52BAD1C40174get_impl*
 Result := 0;
//#UC END# *473DB083030D_52BAD1C40174get_impl*
//#UC START# *473DB083030D_52BAD1C40174get_var*
//#UC END# *473DB083030D_52BAD1C40174get_var*
//#UC START# *476965D302A1_52BAD1C40174_impl*
 if Assigned(f_Header) then
  f_Header.Size := aValue;
//#UC END# *476965D302A1_52BAD1C40174_impl*
//#UC START# *476965D302A1_52BAD1C40174_var*
//#UC END# *476965D302A1_52BAD1C40174_var*
//#UC START# *478CF34E02CE_52BAD1C40174_impl*
 if (Source is TvtNavigator) then
  AssignNav(TvtNavigatorPrim(Source))
 else
  inherited;
//#UC END# *478CF34E02CE_52BAD1C40174_impl*
//#UC START# *478CF34E02CE_52BAD1C40174_var*
//#UC END# *478CF34E02CE_52BAD1C40174_var*
//#UC START# *479731C50290_52BAD1C40174_impl*
 TnpNavigatorList.Instance.UnReg(Self);
 DoSaveSize;

 if f_Float then
 begin
  f_FloatNavigator.f_Navigator := nil;
  PostMessage(f_ParentNavigatorHandle, CM_npDeleteFromList,
   Integer(Pointer(f_FloatNavigator)), 0);
 end;//f_Float
 l3Free(f_NavigatorList);
 FreeAndNil(f_TimerDelay);
 FreeAndNil(f_TimerFloat);

 if (f_Header <> nil) then
 begin
  if (f_Header.Navigator <> nil) then
  begin
   Assert(f_Header.Navigator = Self);
   Self.UnRegisterStateChanged(f_Header.f_Link);
   f_Header.Navigator := nil;
  end;//f_Header.Navigator <> nil
 end;//f_Header <> nil
 FreeAndNil(f_Header);

 inherited;
//#UC END# *479731C50290_52BAD1C40174_impl*
//#UC START# *479731C50290_52BAD1C40174_var*
//#UC END# *479731C50290_52BAD1C40174_var*
//#UC START# *47CFAAC70224_52BAD1C40174_impl*
 l_Class := TvtNavigatorForm.Create(aCloseHandler);
 try
  TvtNavigatorFormList.Instance.Add(l_Class);
  aCloseHandler.Form.FreeNotification(Self);
 finally
  FreeAndNil(l_Class);
 end;//try..finally
 UpdateCloseButton;
//#UC END# *47CFAAC70224_52BAD1C40174_impl*
//#UC START# *47CFAAC70224_52BAD1C40174_var*
var
 l_Class: TvtNavigatorForm;
//#UC END# *47CFAAC70224_52BAD1C40174_var*
//#UC START# *47D1602000C6_52BAD1C40174_impl*
 inherited Create(AOwner);
 f_NavigatorList := Tl3ObjectList.Create;
 (* «арегистрируемс€ *)
 TnpNavigatorList.Instance.Reg(Self);
 (* √лавна€ форма, которой принадлежит навигатор *)
 InitMainForm(AOwner);
 (* interited *)
 Width := cInitSize;
 if not (csDesigning in ComponentState) then
  BevelOuter := bvNone;
 DockSite := True;
 (* self *)
 f_SizeMini := -1;
 f_CountUndock := 0;
 f_HideDirect := hdNone;
 f_ChangeLinks := Tl3ObjectList.Create;
 f_State := nsNormal;
 f_IsFloatingOnShow := False;
 f_IsInitDockDrop := False;
 f_ShowActivePageInHeader := True;
 f_UnDockFromFloat := True;
 f_SingleFloatNavigator := True;
 f_SetCursorResize := False;
 f_SizeEmpty := cInitSize;
 f_SizeNormal := cDefaultNormalSize;
 f_Swim := True;
 f_IsDelay := False;
 f_DoDelay := False;
 f_DelayIntervalOnShow := 0;
 f_DelayIntervalOnHide := 1000;
 f_DelayOnAutoHide := False;
 f_TimerDelay := TTimer.Create(Self);
 f_TimerDelay.Enabled := False;
 f_TimerDelay.OnTimer := OnTimerDelay;
 f_AutoHideFloat := False;
 f_TimerFloat := TTimer.Create(Self);
 f_TimerFloat.Enabled := False;
 f_TimerFloat.Interval := 1;
 f_TimerFloat.OnTimer := OnTimerFloat;
 (* TnpSurface *)
 CreateSurface;
 (* TnpHeader *)
 CreateHeader;
 (* TnpPageControl *)
 CreatePageControl;
 (* Ќеобходимо устанавливать здесь, потому, что в SetAlign используютс€
    TnpHeader, TnpPageControl *)
 Align := alLeft;
 f_CloseHint := str_vtBtnCloseHint.AsStr;
 f_AutoHideOffHint := str_vtAutoHideOffHint.AsStr;
 f_AutoHideOnHint := str_vtAutoHideOnHint.AsStr;
 f_MinimizedOffHint := str_vtMinimizedOffHint.AsStr;
 f_MinimizedOnHint := str_vtMinimizedOnHint.AsStr;
 f_FormWasMinimized := False;
//#UC END# *47D1602000C6_52BAD1C40174_impl*
//#UC START# *47D1602000C6_52BAD1C40174_var*
//#UC END# *47D1602000C6_52BAD1C40174_var*
//#UC START# *4CC8417A0288_52BAD1C40174_impl*
 inherited Resize;
 if not f_Float then
  PlaceSurface
 else
  f_SizeNormal := f_FloatNavigator.Width;
//#UC END# *4CC8417A0288_52BAD1C40174_impl*
//#UC START# *4CC8417A0288_52BAD1C40174_var*
//#UC END# *4CC8417A0288_52BAD1C40174_var*
//#UC START# *4F2A599E0283_52BAD1C40174_impl*
 {$IfDef DesignTimeLibrary}
 if Align = alNone then
  inherited
 else
 begin
  case Align of
   alLeft, alRight: AWidth := 20;
   alTop, alBottom: AHeight := 20;
  end;
  inherited;
 end;//case Align
 {$Else DesignTimeLibrary}
 (* Ќельз€ устанавливать навигатору без закладок ширину (высоту) больше
    f_SizeEmpty. Ёто может происходить в результате чтени€ размеров компонента из
    настроек *)
 if not Assigned(f_PageControl) or (f_PageControl.PageCount = 0) then
 begin
  case Align of
   alBottom, alTop:
    begin
     if (AHeight <= f_SizeEmpty) or (AHeight = SizeMini) then
      inherited
     else
      inherited SetBounds(ALeft, ATop, AWidth, Height);
    end;//alBottom, alTop
   alLeft, alRight:
    begin
     if (AWidth <= f_SizeEmpty) or (AWidth = SizeMini) then
      inherited
     else
      inherited SetBounds(ALeft, ATop, Width, AHeight);
    end;//alLeft, alRight
   else
    inherited;
  end;//case Align
  Exit;
 end;//not Assigned(f_PageControl) or (f_PageControl.PageCount = 0)
 inherited;
 {$EndIf DesignTimeLibrary}
//#UC END# *4F2A599E0283_52BAD1C40174_impl*
//#UC START# *4F2A599E0283_52BAD1C40174_var*
//#UC END# *4F2A599E0283_52BAD1C40174_var*
//#UC START# *4F71E1460089_52BAD1C40174_impl*
 inherited;
 DoNotifyControls(Self, CM_npTabPositionChanged, 0, 0);
//#UC END# *4F71E1460089_52BAD1C40174_impl*
//#UC START# *4F71E1460089_52BAD1C40174_var*
//#UC END# *4F71E1460089_52BAD1C40174_var*
//#UC START# *4F884378016A_52BAD1C40174_impl*
 inherited Notification(aComponent, Operation);
 if (Operation = opRemove) then
 begin
  if TvtNavigatorFormList.Instance.FindData(TvtFormHandlerID_C(aComponent), l_Item) then
  begin
   AComponent.RemoveFreeNotification(Self);
   TvtNavigatorFormList.Instance.Delete(l_Item);
   UpdateCloseButton;
  end;//if TvtNavigatorFormList.Instance.FindData(l_Form, l_Item) then
 end;//if (Operation = opRemove) then
//#UC END# *4F884378016A_52BAD1C40174_impl*
//#UC START# *4F884378016A_52BAD1C40174_var*
var
 l_Item : Integer;
//#UC END# *4F884378016A_52BAD1C40174_var*
//#UC START# *4F8851380274_52BAD1C40174_impl*
 lImageIndex := -1;
 lIsEmpty := f_PageControl.PageCount = 0;
 f_IsInitDockDrop := False;
 if ((f_ImportNavigator <> nil) and (f_ImportNavigator <> Self)) or
  (f_ImportNavigator = nil) and CheckControl(Source.Control) then
 begin
  if Source.Control.Parent is TElTabSheet then
   lImageIndex := TElTabSheet(Source.Control.Parent).ImageIndex;
  if (f_PageControl.PageCount = 0) then
   f_SizeNormal := GetNavigatorSizeNormal(Source.Control);
  //f_PageControl.DockDrop(Source, X, Y);
  inherited DockDrop(Source, X, Y);
  MovePagesToNavigator(f_ImportNavigator, Source.Control);
  if Source.Control.Parent is TElTabSheet then
   TElTabSheet(Source.Control.Parent).ImageIndex := lImageIndex;
  if Source.Control.Visible then
   InitDockDrop;
 end;//((f_ImportNavigator <> nil) and (f_ImportNavigator <> Self))
 (* сбрасываем значени€ f_SizeNormal, которые были установлены навигатору до
    по€влени€ закладок в SetBounds, чтобы при нормализации он не был
    равен свернутому состо€нию *)
 if (f_PageControl.PageCount = 1) and (f_State = nsMinimized) and (not f_SizeNormalLoaded) then
  f_SizeNormal := cDefaultNormalSize;
 // http://mdp.garant.ru/pages/viewpage.action?pageId=622830691
 UpdateState;
 {$IfDef Nemesis}
 if f_Float then
  f_FloatNavigator.UpdateFloatWindowsBounds;
 {$EndIf Nemesis}
 (* ќбработчик отстыковки *)
 if lIsEmpty and not Assigned(f_PageControl.OnUnDock) then
  f_PageControl.OnUnDock := OnPageControlUnDock;
 (* не заслон€ем компоненты, которые лежат в этом же месте *)
 if lIsEmpty and (f_PageControl.PageCount > 0) then
  PostMessage(Handle, CM_npDoActionWithFormControls, Ord(acUpInZOrder), 0);
//#UC END# *4F8851380274_52BAD1C40174_impl*
//#UC START# *4F8851380274_52BAD1C40174_var*
var
 lImageIndex : Integer;
 lIsEmpty    : Boolean;
//#UC END# *4F8851380274_52BAD1C40174_var*
//#UC START# *50FD32F103CA_52BAD1C40174_impl*
 inherited DockOver(Source, X, Y, State, Accept);
 Accept := f_Activate;
 if Accept then
 begin
  SetDockRect(Source);
  Accept := True;
 end;//Accept
//#UC END# *50FD32F103CA_52BAD1C40174_impl*
//#UC START# *50FD32F103CA_52BAD1C40174_var*
 procedure pm_SetSizeNormal;
 var
  lParent: TWinControl;
  lNavigator: TvtNavigator;
 begin//pm_SetSizeNormal
  lNavigator := nil;

  if f_PageControl.PageCount = 0 then
  begin
   lParent := Source.Control.Parent;
   while (lNavigator = nil) and (lParent <> nil) do
    if lParent is TvtNavigator then
      lNavigator := lParent as TvtNavigator
    else
      lParent := lParent.Parent;
  end;

  if lNavigator <> nil then
   f_SizeNormal := lNavigator.SizeNormal;
 end;//pm_SetSizeNormal
//#UC END# *50FD32F103CA_52BAD1C40174_var*
//#UC START# *52B9A6A80336_52BAD1C40174_impl*
 CanDock := f_Activate;
 if CanDock then
 begin
  inherited GetSiteInfo(Client, InfluenceRect, MousePos, CanDock);
  if (f_PageControl.PageCount = 0) and CanDock then
   InfluenceRect := GetDockRect;
 end;//CanDock
//#UC END# *52B9A6A80336_52BAD1C40174_impl*
//#UC START# *52B9A6A80336_52BAD1C40174_var*
//#UC END# *52B9A6A80336_52BAD1C40174_var*
//#UC START# *52BAD1C40174_ext:ParentFileName
w:\common\components\gui\Garant\VT\vtNavigator.pas
//#UC END# *52BAD1C40174_ext:ParentFileName
//#UC START# *52BAD30B01CD_52BAD1C40174_impl*
 l_Activate := Boolean(Message.WParam);
 if l_Activate then
 begin
  if {$If defined(Nemesis) AND not defined(NoVCM)} f_PageDeactivated or {$IfEnd}
    ((f_FloatNavigator <> nil) AND f_FloatNavigator.f_ReactivateDisabled) then
   Exit;
 end;
 Activate := l_Activate;
//#UC END# *52BAD30B01CD_52BAD1C40174_impl*
//#UC START# *52BAD30B01CD_52BAD1C40174_var*
var
 l_Activate : Boolean;
//#UC END# *52BAD30B01CD_52BAD1C40174_var*
//#UC START# *52BAD3540031_52BAD1C40174_impl*
 ModeStateUpdate;
//#UC END# *52BAD3540031_52BAD1C40174_impl*
//#UC START# *52BAD3540031_52BAD1C40174_var*
//#UC END# *52BAD3540031_52BAD1C40174_var*
//#UC START# *52BAD36C00B4_52BAD1C40174_impl*
 DelNavigator(Pointer(Message.wParam));
//#UC END# *52BAD36C00B4_52BAD1C40174_impl*
//#UC START# *52BAD36C00B4_52BAD1C40174_var*
//#UC END# *52BAD36C00B4_52BAD1C40174_var*
//#UC START# *52BAD37C031A_52BAD1C40174_impl*
 for l_Index := Pred(Parent.ControlCount) downto 0 do
 begin
  l_Control := Parent.Controls[l_Index];
  if not (l_Control is TvtNavigator)and not (l_Control is TnpSurface) and
   (l_Control.Align = alNone) then
   case TnpDoActionWithFormControl(Message.WParam) of
    acRedraw:
     if l_Control is TWinControl then
      Windows.RedrawWindow(TWinControl(l_Control).Handle, nil, 0,
       RDW_FRAME or RDW_INVALIDATE or RDW_INTERNALPAINT);
    acUpInZOrder:
     l_Control.BringToFront;
   end;//case TnpDoActionWithFormControl(Message.WParam) of
 end;//for l_Index := Pred(Parent.ControlCount) downto 0 do
//#UC END# *52BAD37C031A_52BAD1C40174_impl*
//#UC START# *52BAD37C031A_52BAD1C40174_var*
var
 l_Index   : Integer;
 l_Control : TControl;
//#UC END# *52BAD37C031A_52BAD1C40174_var*
//#UC START# *52BAD3E80090_52BAD1C40174_impl*
 if (Message.WParam > 0) and (not (csDestroying in ComponentState)) then
 begin
  l_Control := TControl(Message.WParam);
  l_Float := DockToFloatNavigator(l_Control);
  // ни к кому не пристыковали, такого не может быть
  Assert(Assigned(l_Float));
  {$IfDef Nemesis}
  // если форму пристыковали к уже существующему навигатору, то нужно обновить
  // FloatWindowBounds
  if (l_Control is TvcmForm) then
   TvcmForm(l_Control).FloatWindowBounds := l_Float.BoundsRect;
  {$EndIf Nemesis}
 end;//(Message.WParam > 0) and (not (csDestroying in ComponentState))
//#UC END# *52BAD3E80090_52BAD1C40174_impl*
//#UC START# *52BAD3E80090_52BAD1C40174_var*
var
 l_Control : TControl;
 l_Float   : TnpFloatingWindow;
//#UC END# *52BAD3E80090_52BAD1C40174_var*
//#UC START# *52BAD43803E3_52BAD1C40174_impl*
 Message.Result := 1;
//#UC END# *52BAD43803E3_52BAD1C40174_impl*
//#UC START# *52BAD43803E3_52BAD1C40174_var*
//#UC END# *52BAD43803E3_52BAD1C40174_var*
//#UC START# *52BC212F023F_52BAD1C40174_impl*
 inherited SetName(aValue);
 if Assigned(f_PageControl) then
  f_PageControl.Name := aValue;
//#UC END# *52BC212F023F_52BAD1C40174_impl*
//#UC START# *52BC212F023F_52BAD1C40174_var*
//#UC END# *52BC212F023F_52BAD1C40174_var*
//#UC START# *52BC260803B0_52BAD1C40174_impl*
 if (f_PageControl.PageCount = 0) or (State = nsAutoHide) then
 begin
  l_Rect := GetDockRect;
  if PtInRect(l_Rect, DragDockObject.DragPos) then
  begin
   SetDockRect(DragDockObject);
   Exit;
  end;//PtInRect(l_Rect, DragDockObject.DragPos)
 end;//(f_PageControl.PageCount = 0) or (State = nsAutoHide)
 inherited PositionDockRect(DragDockObject);
//#UC END# *52BC260803B0_52BAD1C40174_impl*
//#UC START# *52BC260803B0_52BAD1C40174_var*
var
 l_Rect : TRect;
//#UC END# *52BC260803B0_52BAD1C40174_var*
//#UC START# *52BC2B9401F3_52BAD1C40174_impl*
 (* f_ChangeLinks удал€ем после всех, потому, что в Inherited-е компоненты
    описываетс€ от нотификации *)
 l3Free(f_ChangeLinks);
 inherited;
//#UC END# *52BC2B9401F3_52BAD1C40174_impl*
//#UC START# *52BC2B9401F3_52BAD1C40174_var*
//#UC END# *52BC2B9401F3_52BAD1C40174_var*
//#UC START# *52BC2DA80151_52BAD1C40174get_impl*
 if not Assigned(f_RelativeNavigator) then
  f_RelativeNavigator := FindRelative(RelativeAlign);
 Result := f_RelativeNavigator;
//#UC END# *52BC2DA80151_52BAD1C40174get_impl*
//#UC START# *52BC2DA80151_52BAD1C40174get_var*
//#UC END# *52BC2DA80151_52BAD1C40174get_var*
//#UC START# *52BC2DE7032A_52BAD1C40174get_impl*
 Result := nil;
 if Assigned(Parent) then
  for l_Index := 0 to Pred(Parent.ControlCount) do
   if Parent.Controls[l_Index] is TWinControl then
    with TWinControl(Parent.Controls[l_Index]) do
     if (Align = alClient) then
     begin
      Result := TWinControl(Parent.Controls[l_Index]);
      Break;
     end;//if (Align = alClient) then
//#UC END# *52BC2DE7032A_52BAD1C40174get_impl*
//#UC START# *52BC2DE7032A_52BAD1C40174get_var*
var
 l_Index: Integer;
//#UC END# *52BC2DE7032A_52BAD1C40174get_var*
//#UC START# *52BC2E2D011E_52BAD1C40174get_impl*
 Result := 0;
 if (f_SizeMini > -1) and (f_PageControl.PageCount > 0) then
 begin
  Result := f_SizeMini;
  Exit;
 end;
 with TnpPageControl(f_PageControl) do
 begin
  if (PageCount > 0) then
  begin
   // иначе не посчитаетс€ область закладок в CalcTabAreaSize, потому что ни
   // одна закладка не видима
   if (PageCount = 1) and not Pages[0].TabVisible then
    Pages[0].TabVisible := True;
   lSize := f_PageControl.MaxTabHeight + 20;
   // клиентска€ область, формы
   lRect := Rect(0, 0, lSize, lSize);
   AdjustClientRect(lRect);
   // область закладок
   case TabPosition of
    etpTop: Result := lRect.Top;
    etpBottom: Result := lSize - lRect.Bottom;
    etpLeft: Result := lRect.Left;
    etpRight: Result := lSize - lRect.Right;
   end;//case TabPosition
   // добавим ширину сплиттера, у плавающего навигатора сплиттер отсутствует,
   // его не учитываем
   if not f_Navigator.Float then
    Inc(Result, cspSize);
   // кешируем результат
   f_SizeMini := Result;
  end;//PageCount > 0
 end;//with TnpPageControl(f_PageControl)
//#UC END# *52BC2E2D011E_52BAD1C40174get_impl*
//#UC START# *52BC2E2D011E_52BAD1C40174get_var*
var
 lRect : TRect;
 lSize : Integer;
//#UC END# *52BC2E2D011E_52BAD1C40174get_var*
//#UC START# *52BC2E6203D8_52BAD1C40174set_impl*
 f_Swim := aValue;
 DoStateChanged;
//#UC END# *52BC2E6203D8_52BAD1C40174set_impl*
//#UC START# *52BC2E6203D8_52BAD1C40174set_var*
//#UC END# *52BC2E6203D8_52BAD1C40174set_var*
//#UC START# *52BC2E81013F_52BAD1C40174set_impl*
 if f_Activate <> aValue then
 begin
  // Ќе показываем навигатор, если окно минизированно
  if aValue and npIsWindowMinimized(f_MainForm) then
   Exit;
  f_Activate := aValue;
  if f_Float then
  begin
   case aValue of
    True:
     SetWindowPos(f_FloatNavigator.Handle, HWND_TOPMOST, 0, 0, 0, 0,
      SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or SWP_SHOWWINDOW);
    False:
     SetWindowPos(f_FloatNavigator.Handle, 0, 0, 0, 0, 0,
      SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or SWP_HIDEWINDOW);
   end;
   f_FloatNavigator.Visible := aValue;
   // - иначе огребаем рассинхронизацию
//   {$IfDef vtNavUseDebugLog}
//   l3System.Msg2Log(Format('NAV NavigatorActivate = %d', [Integer(Value)]));
//   {$EndIf vtNavUseDebugLog}
  end
  else
  if not f_Activate then
   f_Surface.f_Splitter.splHideHint;
 end;
//#UC END# *52BC2E81013F_52BAD1C40174set_impl*
//#UC START# *52BC2E81013F_52BAD1C40174set_var*
//#UC END# *52BC2E81013F_52BAD1C40174set_var*
//#UC START# *52BC2F7A018F_52BAD1C40174get_impl*
 Result := f_State = nsMinimized;
//#UC END# *52BC2F7A018F_52BAD1C40174get_impl*
//#UC START# *52BC2F7A018F_52BAD1C40174get_var*
//#UC END# *52BC2F7A018F_52BAD1C40174get_var*
//#UC START# *52BC2FAA0390_52BAD1C40174get_impl*
 Result := f_PageControl.Pages[anIndex];
//#UC END# *52BC2FAA0390_52BAD1C40174get_impl*
//#UC START# *52BC2FAA0390_52BAD1C40174get_var*
//#UC END# *52BC2FAA0390_52BAD1C40174get_var*
//#UC START# *52BC2FFB0208_52BAD1C40174get_impl*
 Result := f_PageControl.ActivePageIndex;
//#UC END# *52BC2FFB0208_52BAD1C40174get_impl*
//#UC START# *52BC2FFB0208_52BAD1C40174get_var*
//#UC END# *52BC2FFB0208_52BAD1C40174get_var*
//#UC START# *52BC2FFB0208_52BAD1C40174set_impl*
 f_PageControl.ActivePageIndex := aValue;
//#UC END# *52BC2FFB0208_52BAD1C40174set_impl*
//#UC START# *52BC2FFB0208_52BAD1C40174set_var*
//#UC END# *52BC2FFB0208_52BAD1C40174set_var*
//#UC START# *52BC303702E2_52BAD1C40174get_impl*
 Result := f_PageControl.PageCount;
//#UC END# *52BC303702E2_52BAD1C40174get_impl*
//#UC START# *52BC303702E2_52BAD1C40174get_var*
//#UC END# *52BC303702E2_52BAD1C40174get_var*
//#UC START# *52BC3164027D_52BAD1C40174set_impl*
 f_Float := aValue;
 DoStateChanged;
//#UC END# *52BC3164027D_52BAD1C40174set_impl*
//#UC START# *52BC3164027D_52BAD1C40174set_var*
//#UC END# *52BC3164027D_52BAD1C40174set_var*
//#UC START# *52BC31BA023D_52BAD1C40174get_impl*
 Result := f_State;
//#UC END# *52BC31BA023D_52BAD1C40174get_impl*
//#UC START# *52BC31BA023D_52BAD1C40174get_var*
//#UC END# *52BC31BA023D_52BAD1C40174get_var*
//#UC START# *52BC31BA023D_52BAD1C40174set_impl*
 if (aValue <> f_State) then
 begin
  if (f_State = nsAutoHide) then
  begin
   f_TimerFloat.Enabled := False;
   f_TimerDelay.Enabled := False;
  end;//f_State = nsAutoHide
  f_State := aValue;
  // ѕри открытии приложени€ изначально панели должны быть скрыты в авторежиме:
  if f_State = nsAutoHide then
   f_TimerFloat.Enabled := True;
  UpdateState;
  DoStateChanged(True);
 end;//Value <> f_State
//#UC END# *52BC31BA023D_52BAD1C40174set_impl*
//#UC START# *52BC31BA023D_52BAD1C40174set_var*
//#UC END# *52BC31BA023D_52BAD1C40174set_var*
//#UC START# *52BC320E037B_52BAD1C40174set_impl*
 f_ShowActivePageInHeader := aValue;
 f_Header.Invalidate;
//#UC END# *52BC320E037B_52BAD1C40174set_impl*
//#UC START# *52BC320E037B_52BAD1C40174set_var*
//#UC END# *52BC320E037B_52BAD1C40174set_var*
//#UC START# *52BC32F601CAStored_52BAD1C40174_impl*
 Result := f_AutoHideOffHint <> str_cAutoHideOffHint.AsStr;
//#UC END# *52BC32F601CAStored_52BAD1C40174_impl*
//#UC START# *52BC32F601CAStored_52BAD1C40174_var*
//#UC END# *52BC32F601CAStored_52BAD1C40174_var*
//#UC START# *52BC334A00D3Stored_52BAD1C40174_impl*
 Result := f_AutoHideOnHint <> str_cAutoHideOnHint.AsStr;
//#UC END# *52BC334A00D3Stored_52BAD1C40174_impl*
//#UC START# *52BC334A00D3Stored_52BAD1C40174_var*
//#UC END# *52BC334A00D3Stored_52BAD1C40174_var*
//#UC START# *52BC33AF0000Stored_52BAD1C40174_impl*
 Result := f_MinimizedOnHint <> str_cMinimizedOnHint.AsStr;
//#UC END# *52BC33AF0000Stored_52BAD1C40174_impl*
//#UC START# *52BC33AF0000Stored_52BAD1C40174_var*
//#UC END# *52BC33AF0000Stored_52BAD1C40174_var*
//#UC START# *52BC33C5025EStored_52BAD1C40174_impl*
 Result := f_MinimizedOffHint <> str_cMinimizedOffHint.AsStr;
//#UC END# *52BC33C5025EStored_52BAD1C40174_impl*
//#UC START# *52BC33C5025EStored_52BAD1C40174_var*
//#UC END# *52BC33C5025EStored_52BAD1C40174_var*
//#UC START# *52BC33F802B6Stored_52BAD1C40174_impl*
 Result := f_CloseHint <> str_cCloseHint.AsStr;
//#UC END# *52BC33F802B6Stored_52BAD1C40174_impl*
//#UC START# *52BC33F802B6Stored_52BAD1C40174_var*
//#UC END# *52BC33F802B6Stored_52BAD1C40174_var*
//#UC START# *52BC350C00A3_52BAD1C40174get_impl*
 Result := f_PageControl.Images;
//#UC END# *52BC350C00A3_52BAD1C40174get_impl*
//#UC START# *52BC350C00A3_52BAD1C40174get_var*
//#UC END# *52BC350C00A3_52BAD1C40174get_var*
//#UC START# *52BC350C00A3_52BAD1C40174set_impl*
 f_PageControl.Images := aValue;
//#UC END# *52BC350C00A3_52BAD1C40174set_impl*
//#UC START# *52BC350C00A3_52BAD1C40174set_var*
//#UC END# *52BC350C00A3_52BAD1C40174set_var*
//#UC START# *52BC35CD014E_52BAD1C40174set_impl*
 if not aValue then
  f_TimerDelay.Enabled := False;
 f_DelayOnAutoHide := aValue;
 f_DoDelay := aValue;
//#UC END# *52BC35CD014E_52BAD1C40174set_impl*
//#UC START# *52BC35CD014E_52BAD1C40174set_var*
//#UC END# *52BC35CD014E_52BAD1C40174set_var*
//#UC START# *52BC360D034F_52BAD1C40174set_impl*
 f_SingleFloatNavigator := aValue;
//#UC END# *52BC360D034F_52BAD1C40174set_impl*
//#UC START# *52BC360D034F_52BAD1C40174set_var*
//#UC END# *52BC360D034F_52BAD1C40174set_var*
//#UC START# *52BC365D0137_52BAD1C40174get_impl*
 Result := inherited Align;
//#UC END# *52BC365D0137_52BAD1C40174get_impl*
//#UC START# *52BC365D0137_52BAD1C40174get_var*
//#UC END# *52BC365D0137_52BAD1C40174get_var*
//#UC START# *52BC365D0137_52BAD1C40174set_impl*
 if aValue <> Align then
 begin
  case aValue of
   alTop:
   begin
    inherited Align := aValue;
    f_Header.Align := alLeft;
    f_PageControl.TabPosition := etpTop;
   end;
   alLeft:
   begin
    inherited Align := aValue;
    f_Header.Align := alTop;
    f_PageControl.TabPosition := etpLeft;
   end;
   alRight:
   begin
    inherited Align := aValue;
    f_Header.Align := alTop;
    f_PageControl.TabPosition := etpRight;
   end;
   alBottom:
    begin
     inherited Align := aValue;
     f_Header.Align := alLeft;
     f_PageControl.TabPosition := etpBottom;
    end;
   else
    begin
     if not f_Float then
     begin
      inherited Align := alTop;
      f_Header.Align := alLeft;
     end
     else
     begin
      inherited Align := aValue;
      f_Header.Align := alTop;
     end;
     f_PageControl.TabPosition := etpTop;
    end;
  end;
  f_Surface.DefineSplitterAlign;
  f_Header.UpdateImages;
  ModeStateUpdate;
 end;//Value <> Align
//#UC END# *52BC365D0137_52BAD1C40174set_impl*
//#UC START# *52BC365D0137_52BAD1C40174set_var*
//#UC END# *52BC365D0137_52BAD1C40174set_var*
//#UC START# *52BC36B202C9_52BAD1C40174set_impl*
 f_SizeEmpty := aValue;
 AttachSurface;
 SetSize(aValue);
//#UC END# *52BC36B202C9_52BAD1C40174set_impl*
//#UC START# *52BC36B202C9_52BAD1C40174set_var*
//#UC END# *52BC36B202C9_52BAD1C40174set_var*
//#UC START# *52BC36FC016D_52BAD1C40174set_impl*
 f_SizeNormalLoaded := False;
 f_SizeNormal := aValue;
 (* Ќе закладок не нужно и размер устанавливать *)
 if not Assigned(f_PageControl) or (f_PageControl.PageCount = 0) then
  Exit;
 f_SizeNormal := CorrectSize(f_SizeNormal);
 //CheckSize(f_SizeNormal);
 (* AutoHide *)
 case f_State of
  nsAutoHide:
   lp_SetSize(f_Surface);
  nsNormal:
   lp_SetSize(Self);
 end;//case f_State of
 if (f_State = nsAutoHide) and (Align = alRight) then
  f_Surface.Left := Parent.ClientWidth - f_Surface.Width;
//#UC END# *52BC36FC016D_52BAD1C40174set_impl*
//#UC START# *52BC36FC016D_52BAD1C40174set_var*
 procedure lp_SetSize(aControl : TControl);
 begin
  case Self.Align of
   alTop, alBottom: aControl.Height := f_SizeNormal;
   alLeft, alRight: aControl.Width := f_SizeNormal;
  end;//case Self.Align of
 end;//lp_SetSize
//#UC END# *52BC36FC016D_52BAD1C40174set_var*
//#UC START# *52BC37B80233_52BAD1C40174get_impl*
 Result := f_Header.ButtonsImageList;
//#UC END# *52BC37B80233_52BAD1C40174get_impl*
//#UC START# *52BC37B80233_52BAD1C40174get_var*
//#UC END# *52BC37B80233_52BAD1C40174get_var*
//#UC START# *52BC37B80233_52BAD1C40174set_impl*
 f_Header.ButtonsImageList := aValue;
//#UC END# *52BC37B80233_52BAD1C40174set_impl*
//#UC START# *52BC37B80233_52BAD1C40174set_var*
//#UC END# *52BC37B80233_52BAD1C40174set_var*
//#UC START# *52BC38190127_52BAD1C40174get_impl*
 Result := f_Header.CloseImage;
//#UC END# *52BC38190127_52BAD1C40174get_impl*
//#UC START# *52BC38190127_52BAD1C40174get_var*
//#UC END# *52BC38190127_52BAD1C40174get_var*
//#UC START# *52BC38190127_52BAD1C40174set_impl*
 f_Header.CloseImage := aValue;
//#UC END# *52BC38190127_52BAD1C40174set_impl*
//#UC START# *52BC38190127_52BAD1C40174set_var*
//#UC END# *52BC38190127_52BAD1C40174set_var*
//#UC START# *52BC38290235_52BAD1C40174get_impl*
 Result := f_Header.AutoHideOnImage;
//#UC END# *52BC38290235_52BAD1C40174get_impl*
//#UC START# *52BC38290235_52BAD1C40174get_var*
//#UC END# *52BC38290235_52BAD1C40174get_var*
//#UC START# *52BC38290235_52BAD1C40174set_impl*
 f_Header.AutoHideOnImage := aValue;
//#UC END# *52BC38290235_52BAD1C40174set_impl*
//#UC START# *52BC38290235_52BAD1C40174set_var*
//#UC END# *52BC38290235_52BAD1C40174set_var*
//#UC START# *52BC38560093_52BAD1C40174get_impl*
 Result := f_Header.AutoHideOffImage;
//#UC END# *52BC38560093_52BAD1C40174get_impl*
//#UC START# *52BC38560093_52BAD1C40174get_var*
//#UC END# *52BC38560093_52BAD1C40174get_var*
//#UC START# *52BC38560093_52BAD1C40174set_impl*
 f_Header.AutoHideOffImage := aValue;
//#UC END# *52BC38560093_52BAD1C40174set_impl*
//#UC START# *52BC38560093_52BAD1C40174set_var*
//#UC END# *52BC38560093_52BAD1C40174set_var*
//#UC START# *52BC386603CA_52BAD1C40174get_impl*
 Result := f_Header.HideLeftImage;
//#UC END# *52BC386603CA_52BAD1C40174get_impl*
//#UC START# *52BC386603CA_52BAD1C40174get_var*
//#UC END# *52BC386603CA_52BAD1C40174get_var*
//#UC START# *52BC386603CA_52BAD1C40174set_impl*
 f_Header.HideLeftImage := aValue;
//#UC END# *52BC386603CA_52BAD1C40174set_impl*
//#UC START# *52BC386603CA_52BAD1C40174set_var*
//#UC END# *52BC386603CA_52BAD1C40174set_var*
//#UC START# *52BC38770142_52BAD1C40174get_impl*
 Result := f_Header.HideRightImage;
//#UC END# *52BC38770142_52BAD1C40174get_impl*
//#UC START# *52BC38770142_52BAD1C40174get_var*
//#UC END# *52BC38770142_52BAD1C40174get_var*
//#UC START# *52BC38770142_52BAD1C40174set_impl*
 f_Header.HideRightImage := aValue;
//#UC END# *52BC38770142_52BAD1C40174set_impl*
//#UC START# *52BC38770142_52BAD1C40174set_var*
//#UC END# *52BC38770142_52BAD1C40174set_var*
//#UC START# *52BC38840249_52BAD1C40174get_impl*
 Result := f_Header.HideUpImage;
//#UC END# *52BC38840249_52BAD1C40174get_impl*
//#UC START# *52BC38840249_52BAD1C40174get_var*
//#UC END# *52BC38840249_52BAD1C40174get_var*
//#UC START# *52BC38840249_52BAD1C40174set_impl*
 f_Header.HideUpImage := aValue;
//#UC END# *52BC38840249_52BAD1C40174set_impl*
//#UC START# *52BC38840249_52BAD1C40174set_var*
//#UC END# *52BC38840249_52BAD1C40174set_var*
//#UC START# *52BC38920251_52BAD1C40174get_impl*
 Result := f_Header.HideDownImage;
//#UC END# *52BC38920251_52BAD1C40174get_impl*
//#UC START# *52BC38920251_52BAD1C40174get_var*
//#UC END# *52BC38920251_52BAD1C40174get_var*
//#UC START# *52BC38920251_52BAD1C40174set_impl*
 f_Header.HideDownImage := aValue;
//#UC END# *52BC38920251_52BAD1C40174set_impl*
//#UC START# *52BC38920251_52BAD1C40174set_var*
//#UC END# *52BC38920251_52BAD1C40174set_var*
//#UC START# *52BD5F51022B_52BAD1C40174_impl*
 Result := aSizeNormal;
 with CorrectBounds(CalcBounds(aSizeNormal)) do
  case Self.Align of
   alLeft, alRight: Result := Right - Left;
   alTop, alBottom: Result := Bottom - Top;
  end;//case Self.Align
//#UC END# *52BD5F51022B_52BAD1C40174_impl*
//#UC START# *52BD5F51022B_52BAD1C40174_var*
//#UC END# *52BD5F51022B_52BAD1C40174_var*
//#UC START# *52BD5F720354_52BAD1C40174_impl*
 Result := alNone;
 case Self.Align of
  alLeft: Result := alRight;
  alRight: Result := alLeft;
  alTop: Result := alBottom;
  alBottom: Result := alTop;
 end;//case Self.Align of
//#UC END# *52BD5F720354_52BAD1C40174_impl*
//#UC START# *52BD5F720354_52BAD1C40174_var*
//#UC END# *52BD5F720354_52BAD1C40174_var*
//#UC START# *52BD5F9E0274_52BAD1C40174_impl*
 Result := nil;
 if Assigned(Parent) then
  with Parent do
   for l_Index := 0 to Pred(ControlCount) do
    if (Controls[l_Index] is TvtNavigator) and
     (Controls[l_Index].Align = aAlign) then
    begin
     Result := TvtNavigator(Controls[l_Index]); 
     Break;
    end;//if (Controls[l_Index] is TvtNavigator) and
//#UC END# *52BD5F9E0274_52BAD1C40174_impl*
//#UC START# *52BD5F9E0274_52BAD1C40174_var*
var
 l_Index: Integer;
//#UC END# *52BD5F9E0274_52BAD1C40174_var*
//#UC START# *52BD5FCF0121_52BAD1C40174_impl*
 Result := BoundsRect;
 case Align of
  alLeft: Result.Right := Result.Left + aSizeNormal;
  alRight: Result.Left := Result.Right - aSizeNormal;
  alTop: Result.Bottom := Result.Top + aSizeNormal;
  alBottom: Result.Top := Result.Bottom - aSizeNormal;
 end;//case Align of
//#UC END# *52BD5FCF0121_52BAD1C40174_impl*
//#UC START# *52BD5FCF0121_52BAD1C40174_var*
//#UC END# *52BD5FCF0121_52BAD1C40174_var*
//#UC START# *52BD5FEF0063_52BAD1C40174_impl*
 Result := 0;
 with aBounds do
  case Align of
   alLeft, alRight: Result := Right - Left;
   alTop, alBottom: Result := Bottom - Top;
  end;//case Align of
//#UC END# *52BD5FEF0063_52BAD1C40174_impl*
//#UC START# *52BD5FEF0063_52BAD1C40174_var*
//#UC END# *52BD5FEF0063_52BAD1C40174_var*
//#UC START# *52BD60180199_52BAD1C40174_impl*
 Result := aBounds;
 if Assigned(ClientControl) then
 begin
  l_CurrentSize := CalcSize(BoundsRect);
  l_NewSize := CalcSize(aBounds);
  if l_NewSize >= l_CurrentSize then
  begin
   lp_CorrectBounds;
   // ≈сли при изменении размеров формы мы достигли минимального размера
   // навигатора, более уже ничего сделать нельз€
   if not ((l_NewSize = l_CurrentSize) and (f_SizeNormal = cMinNormalSize)) then
   begin
    lp_MinSize;
    lp_ConflictWithBusyRect;
   end;//if not ((l_NewSize = l_CurrentSize)
  end;//if l_NewSize >= l_CurrentSize then
 end;//if Assigned(l_Control) then
//#UC END# *52BD60180199_52BAD1C40174_impl*
//#UC START# *52BD60180199_52BAD1C40174_var*
 procedure lp_MinSize;
 {* - сожмем навигатор, зан€той области он не оставил даже минимального
      пространства (cMinNormalSize + cMinClientControlSize).}
 var
  l_Rect   : TRect;
  l_Client : TRect;
  l_Size   : Integer;
 begin
  if Assigned(RelativeNavigator) then
  begin
   l_Size := cMinNormalSize + cMinClientControlSize;
   l_Rect := BoundsRect;
   l_Client := Parent.ClientRect;
   case Align of
    alLeft:
     begin
      if (l_Rect.Right > l_Client.Right - l_Size) and
       (Width > cMinNormalSize) then
      begin
       Width := l_Client.Right - l_Size - l_Rect.Left;
       Result.Right := l_Client.Right - l_Size;
      end;//if (l_Rect.Right > l_Client.Right - l_Size) and
     end;//alLeft
    alRight:
     begin
      if (l_Rect.Left < l_Client.Left + l_Size) and
       (Width > cMinNormalSize) then
      begin
       Width := l_Rect.Right - (l_Client.Left + l_Size);
       Result.Left := l_Client.Left + l_Size;
      end;//if (l_Rect.Left < l_Client.Left + l_Size) and
     end;//alRight
   end;//case Align of
  end;//if Assigned(RelativeNavigator) then
 end;//lp_CorrectAfterRestore

 procedure lp_ConflictWithBusyRect;
 {* - установим размер навигатора в зависимости от уже зан€той области. }

  function BusyRectOnParent: TRect;
    {* - область зан€та€ клиентским компонентом и навигатором. }
  var
   l_Control  : TWinControl;
   l_TempSize : Integer;
   l_Size     : Integer;
   l_Rect     : TRect;
  begin
   SetRectEmpty(Result);
   l_Control := ClientControl;
   if Assigned(l_Control) then
   begin
    Result := l_Control.BoundsRect;
    if Assigned(RelativeNavigator) then
    begin
     l_Size := cMinClientControlSize;
     l_Rect := RelativeNavigator.BoundsRect;
     l_TempSize := CalcSize(l_Rect);
     if l_TempSize < cMinNormalSize then
      l_TempSize := cMinNormalSize;
     Inc(l_Size, l_TempSize);
     case RelativeNavigator.Align of
      alLeft:
       begin
        Result.Left := l_Rect.Left;
        Result.Right := l_Rect.Left + l_Size;
       end;
      alRight:
       begin
        Result.Right := l_Rect.Right;
        Result.Left := l_Rect.Right - l_Size
       end;
      alTop:
       begin
        Result.Top := l_Rect.Top;
        Result.Bottom := l_Rect.Top - l_Size;
       end;
      alBottom:
       begin
        Result.Bottom := l_Rect.Bottom;
        Result.Top := l_Rect.Bottom - l_Size;
       end;
     end;//case RelativeNavigator of
    end//if Assigned(RelativeNavigator) then
    else
     case Self.Align of
      alLeft: Result.Left := Result.Right;
     else
      Assert(False);
     end;//Case Self.Align
   end;//if Assigned(l_Control) then
  end;//BusyRectOnParent

 var
  l_Rect: TRect;
 begin
  l_Rect := BusyRectOnParent;
  case Self.Align of
   alLeft:
    if Result.Right > l_Rect.Left then
     if Result.Left + cMinNormalSize > l_Rect.Left then
      Result.Right := Result.Left + cMinNormalSize
     else
      Result.Right := l_Rect.Left;
   alRight:
    if Result.Left < l_Rect.Right then
     if Result.Right - cMinNormalSize < l_Rect.Right then
      Result.Left := Result.Right - cMinNormalSize
     else
     Result.Left := l_Rect.Right;
   alTop:
    if Result.Bottom > l_Rect.Top then
     if Result.Top + cMinNormalSize > l_Rect.Top then
      Result.Bottom := Result.Top + cMinNormalSize
     else
      Result.Bottom := l_Rect.Top;
   alBottom:
    if Result.Top > l_Rect.Bottom then
     if Result.Bottom - cMinNormalSize > l_Rect.Bottom then
      Result.Top := Result.Bottom - cMinNormalSize
     else
     Result.Top := l_Rect.Bottom;
  end;//case Self.Align of
 end;//lp_ConflictWithBusyRect

 procedure lp_CorrectBounds;
 {* - если навигатор выходит за пределы то откорректируем. }
 var
  l_Rect   : TRect;
  l_Client : TRect;
 begin//lp_CorrectBounds
  l_Rect := BoundsRect;
  l_Client := Parent.ClientRect;
  case Align of
   alLeft:
    if l_Rect.Left < l_Client.Left then
    begin
     Windows.OffsetRect(l_Rect, l_Client.Left - l_Rect.Left, 0);
     BoundsRect := l_Rect;
    end;//if l_Rect.Left < l_Client.Left then
   alRight:
    if l_Rect.Right > l_Client.Right then
    begin
     Windows.OffsetRect(l_Rect, l_Client.Right - l_Rect.Right, 0);
     BoundsRect := l_Rect;
    end;//if l_Rect.Right > l_Client.Right then
   alTop:
    if l_Rect.Top < l_Client.Top then
    begin
     Windows.OffsetRect(l_Rect, 0, l_Client.Top - l_Rect.Top);
     BoundsRect := l_Rect;
    end;//if l_Rect.Top < l_Client.Top then
   alBottom:
    if l_Rect.Bottom > l_Client.Bottom then
    begin
     Windows.OffsetRect(l_Rect, 0, l_Client.Bottom - l_Rect.Bottom);
     BoundsRect := l_Rect;
    end;//if l_Rect.Top < l_Client.Top then
  end;//case RelativeNavigator.Align of
 end;//lp_CorrectBounds

var
 l_CurrentSize : Integer;
 l_NewSize     : Integer;
//#UC END# *52BD60180199_52BAD1C40174_var*
//#UC START# *52BD604900EC_52BAD1C40174_impl*
 if f_State = nsAutoHide then
  AutoUpdateSize
 else
  NormalUpdateSize;
//#UC END# *52BD604900EC_52BAD1C40174_impl*
//#UC START# *52BD604900EC_52BAD1C40174_var*
//#UC END# *52BD604900EC_52BAD1C40174_var*
//#UC START# *52BD60530301_52BAD1C40174_impl*
 // –азмер
 if f_HideDirect = hdHide then
  lDelta := SizeMini
 else
  lDelta := SizeNormal;
 if Swim then
 begin
  // “екущий размер
  lBounds := f_Surface.BoundsRect;
  // Ќовый размер
  with lBounds do
   case Self.Align of
    alLeft: Right := Left + lDelta;
    alRight: Left := Right - lDelta;
    alTop: Bottom := Top + lDelta;
    alBottom: Top := Bottom - lDelta;
   end;//case Self.Align
  // ѕрименим
  f_Surface.BoundsRect := lBounds;
 end//Swim
 else
  SetSelfSize(lDelta);
//#UC END# *52BD60530301_52BAD1C40174_impl*
//#UC START# *52BD60530301_52BAD1C40174_var*
var
 lDelta: Integer;
 lBounds: TRect;
//#UC END# *52BD60530301_52BAD1C40174_var*
//#UC START# *52BD60960071_52BAD1C40174_impl*
 f_Header.f_IsDragBegining := False;
 f_ClickOnTab := False;
//#UC END# *52BD60960071_52BAD1C40174_impl*
//#UC START# *52BD60960071_52BAD1C40174_var*
//#UC END# *52BD60960071_52BAD1C40174_var*
//#UC START# *52BD60BF0233_52BAD1C40174_impl*
 Assert(f_Header <> nil);
 Result := f_Header.f_IsDragBegining or (f_ClickOnTab and not f_DblClickUnDock);
//#UC END# *52BD60BF0233_52BAD1C40174_impl*
//#UC START# *52BD60BF0233_52BAD1C40174_var*
//#UC END# *52BD60BF0233_52BAD1C40174_var*
//#UC START# *52BD615702DB_52BAD1C40174_impl*
 f_DblClickUnDock := True;
 if f_Float then
 begin
  CanUnDock := False;
  TnpControlsList.Instance.DockOnForm(aControl);
  f_DblClickUnDock := False;
 end;//f_Float
//#UC END# *52BD615702DB_52BAD1C40174_impl*
//#UC START# *52BD615702DB_52BAD1C40174_var*
//#UC END# *52BD615702DB_52BAD1C40174_var*
//#UC START# *52BD619100C0_52BAD1C40174_impl*
 f_Surface := TnpSurface.Create(Self);
 with f_Surface do
 begin
  Navigator := Self;
  Parent := Self;
  Align := alClient;
 end;//with f_Surface
//#UC END# *52BD619100C0_52BAD1C40174_impl*
//#UC START# *52BD619100C0_52BAD1C40174_var*
//#UC END# *52BD619100C0_52BAD1C40174_var*
//#UC START# *52BD619A032E_52BAD1C40174_impl*
 f_Header := TnpHeader.Create(Self);
 f_Surface.Header := f_Header;
 f_Header.Navigator := Self;
 f_Header.Width := f_Header.Size;
 f_Header.OnUnDock := OnPageControlUnDock;
 f_Header.OnHide := OnHide;
 f_Header.OnAutoHide := OnAutoHide;
//#UC END# *52BD619A032E_52BAD1C40174_impl*
//#UC START# *52BD619A032E_52BAD1C40174_var*
//#UC END# *52BD619A032E_52BAD1C40174_var*
//#UC START# *52BD61A40323_52BAD1C40174_impl*
 f_PageControl := GetPageControlClass.Create(Self);
 f_Surface.PageControl := f_PageControl;
 with f_PageControl do
 begin
  Name := Self.Name;
  f_Navigator := Self;
  DockSite := True;
  Flat := True;
  OnUnDock := Self.OnPageControlUnDock;
  OnTabSheetClick := Self.OnTabSheetClick;
  OnChange := Self.OnPageControlChange;
  OnResize := Self.OnPageControlResize;
  DragPageControl := True;
  OnStartDragControl := Self.OnStartDragControl;
  OnDblClickUndock := Self.OnDblClickUndock;
 end;//with f_PageControl
//#UC END# *52BD61A40323_52BAD1C40174_impl*
//#UC START# *52BD61A40323_52BAD1C40174_var*
//#UC END# *52BD61A40323_52BAD1C40174_var*
//#UC START# *52BD61C202D9_52BAD1C40174_impl*
 lOwner := aOwner;
 while Assigned(lOwner) do
 begin
  if (lOwner.Owner = Application) and (lOwner is TCustomForm) then
  begin
   if (TCustomForm(lOwner).Parent = nil) then
   begin
    f_MainForm := TCustomForm(lOwner);
    Break;
   end
   else
   begin
    f_MainForm := lp_GetParentForm(TCustomForm(lOwner));
    {$If defined(Nemesis) AND not defined(NoVCM)}
    if Supports(f_MainForm, IafwMainFormContainer, l_ContainerForm) then
    try
     f_ParentMainForm := l_ContainerForm.CurrentMainForm;
    finally
     l_ContainerForm := nil;
    end
    else
     f_ParentMainForm := f_MainForm;
    {$IfEnd}
    // - http://mdp.garant.ru/pages/viewpage.action?pageId=596174840
    Break;
   end;
  end;//(lOwner.Owner = Application) and (lOwner is TCustomForm)
  lOwner := lOwner.Owner;
 end;//while Assigned(lOwner)
//#UC END# *52BD61C202D9_52BAD1C40174_impl*
//#UC START# *52BD61C202D9_52BAD1C40174_var*

 function lp_GetParentForm(aForm: TCustomForm): TCustomForm;
 var
  l_Control: TControl;
 begin
  Result := nil;
  l_Control := aForm;
  while (l_Control.Parent <> nil) do
  begin
   l_Control := l_Control.Parent;
   if (l_Control is TCustomForm) and (l_Control.Parent = nil) then
   begin
    Result := TCustomForm(l_Control);
    Break;
   end;
  end;
 end;

var
 lOwner : TComponent;
 l_ContainerForm: IafwMainFormContainer;
//#UC END# *52BD61C202D9_52BAD1C40174_var*
//#UC START# *52BD61E101FF_52BAD1C40174_impl*
 lWinPosInfo := BeginDeferWindowPos(1);
 try
  with f_Surface do
   DeferWindowPos(lWinPosInfo, Handle, 0, 0, 0, Width, Height, SWP_FRAMECHANGED);
 finally
  EndDeferWindowPos(lWinPosInfo);
 end;//try..finally
//#UC END# *52BD61E101FF_52BAD1C40174_impl*
//#UC START# *52BD61E101FF_52BAD1C40174_var*
var
 lWinPosInfo : Cardinal;
//#UC END# *52BD61E101FF_52BAD1C40174_var*
//#UC START# *52BD61F501E5_52BAD1C40174_impl*
 if not Assigned(aControl) then
  aControl := Self; 
 case Self.Align of
  alLeft, alRight: aControl.Width := aValue;
  alTop, alBottom: aControl.Height := aValue;
 end;//case Self.Align
//#UC END# *52BD61F501E5_52BAD1C40174_impl*
//#UC START# *52BD61F501E5_52BAD1C40174_var*
//#UC END# *52BD61F501E5_52BAD1C40174_var*
//#UC START# *52BD625A0013_52BAD1C40174_impl*
 with f_PageControl do
 begin
  f_Header.Visible := PageCount > 0;
  Visible := PageCount > 0;
 end;
 case f_State of
  nsAutoHide: DoAutoHide;
  nsMinimized:
   begin
    AttachSurface;
    Minimized;
   end;//Minimized
  nsNormal:
   begin
    AttachSurface;
    pm_SetSizeNormal(f_SizeNormal);
   end;//nsNormal
 end;//case f_State
 (* ѕересчитаем размер клиентской области *)
 if f_State <> nsAutoHide then
  RecalcSize;
 UpdateCloseButton; 
//#UC END# *52BD625A0013_52BAD1C40174_impl*
//#UC START# *52BD625A0013_52BAD1C40174_var*
//#UC END# *52BD625A0013_52BAD1C40174_var*
//#UC START# *52BD627B0350_52BAD1C40174_impl*
 if State <> nsAutoHide then
  Exit;
 case Align of
  alBottom, alTop:
   begin
    f_Surface.Width := Width;
    if Align = alBottom then
     f_Surface.Top := Self.Parent.ClientHeight - f_Surface.Height
    else
     f_Surface.Top := Self.Top;
   end;//alBottom, alTop:
  alLeft, alRight:
   begin
    f_Surface.Top := Top;
    f_Surface.Height := Height;
    if Align = alRight then
     f_Surface.Left := Self.Parent.ClientWidth - f_Surface.Width;
   end;//alLeft, alRight:
 end;//case Align of
//#UC END# *52BD627B0350_52BAD1C40174_impl*
//#UC START# *52BD627B0350_52BAD1C40174_var*
var
 l_Left, l_Top, l_Width, l_Height: Integer;
//#UC END# *52BD627B0350_52BAD1C40174_var*
//#UC START# *52BD628801D8_52BAD1C40174_impl*
 with f_Surface do
 begin
  Parent := Self;
  Align := alClient;
 end;//with f_Surface do
//#UC END# *52BD628801D8_52BAD1C40174_impl*
//#UC START# *52BD628801D8_52BAD1C40174_var*
//#UC END# *52BD628801D8_52BAD1C40174_var*
//#UC START# *52BD62920263_52BAD1C40174_impl*
 with f_Surface do
 begin
  Align := alNone;
  Parent := Self.Parent;
  PlaceSurface;
 end;//with f_Surface do
 Perform(CM_npDoActionWithFormControls, Ord(acUpInZOrder), 0);
//#UC END# *52BD62920263_52BAD1C40174_impl*
//#UC START# *52BD62920263_52BAD1C40174_var*
//#UC END# *52BD62920263_52BAD1C40174_var*
//#UC START# *52BD629A02DA_52BAD1C40174_impl*
 SetSize(SizeMini);
//#UC END# *52BD629A02DA_52BAD1C40174_impl*
//#UC START# *52BD629A02DA_52BAD1C40174_var*
//#UC END# *52BD629A02DA_52BAD1C40174_var*
//#UC START# *52BD62A70122_52BAD1C40174_impl*
 if (f_PageControl.PageCount = 0) then
  Exit;
 f_TimerDelay.Enabled := True;
 f_HideDirect := hdHide;
 DetachSurface;
 with f_Surface do
 begin
  SetSizeMini;
  InitAutoHidePosition;
 end;//with f_Surface
 SetSizeMini;
//#UC END# *52BD62A70122_52BAD1C40174_impl*
//#UC START# *52BD62A70122_52BAD1C40174_var*
//#UC END# *52BD62A70122_52BAD1C40174_var*
//#UC START# *52BD62C20057_52BAD1C40174_impl*
 l_Height := 0;
 l_Width := 0;
 l_Cursor := Mouse.CursorPos;
 if IsUndockByUser then
 begin
  l_Left := l_Cursor.X - f_ClickPoint.X;
  l_Top := l_Cursor.Y - f_ClickPoint.Y;
 end//IsUndockByUser
 else
 begin
  Windows.GetWindowRect(Handle, l_Rect);
  l_Left := l_Rect.Left;
  l_Top := l_Rect.Top;
 end;//IsUndockByUser
 (* —местим плавающий навигатор относительно навигатора на форме *)
 if f_DblClickUnDock or not IsUndockByUser then
 begin
  Inc(f_CountUndock);
  if f_CountUndock > 10 then
   f_CountUndock := 1;
  l_Dist := f_CountUndock * cMultiplier;
  l_Monitor := Screen.MonitorFromPoint(l_Cursor).BoundsRect;
  (* —местим вверх или вниз *)
  if l_Top + l_Dist < l_Monitor.Bottom then
   Inc(l_Top, l_Dist)
  else
   Dec(l_Top, l_Dist);
  (* ƒл€ навигаторов справа, внизу сдвигаем рамку плавающего навигатора вверх,
     влево *)
  if Align in [alRight, alBottom] then
   l_Dist := -l_Dist;
  (* —местим вправо или влево *)
  if l_Left + l_Dist < l_Monitor.Right then
   Inc(l_Left, l_Dist)
  else
   Dec(l_Left, l_Dist);
  f_DblClickUnDock := False;
 end;
 (* –азмеры нового навигатора *)
 if f_Float then
  with f_FloatNavigator do
  begin
   l_Height := Height;
   l_Width := Width;
  end//with f_FloatNavigator
 else
 begin
  // “ак нужно делать потому, что в режиме автоскрыти€ размеры мен€ютс€, а
  // размер рамки должен быть как у прикрепленного навигатора
  case Align of
   alLeft, alRight:
    begin
     l_Height := Height;
     l_Width := f_SizeNormal;
    end;//alLeft, alRight
   alTop, alBottom:
    begin
     l_Width := Width;
     l_Height := f_SizeNormal;
    end;//alTop, alBottom
  end;//case Align
 end;//f_Float
 (* ѕоложение плавающего навигатора *)
 Result := Rect(l_Left, l_Top, l_Left + l_Width, l_Top  + l_Height);
//#UC END# *52BD62C20057_52BAD1C40174_impl*
//#UC START# *52BD62C20057_52BAD1C40174_var*
const
 cMultiplier = 20;
var
 l_Left    : Integer;
 l_Top     : Integer;
 l_Height  : Integer;
 l_Width   : Integer;
 l_Monitor : TRect;
 l_Cursor  : TPoint;
 l_Dist    : Integer;
 l_Rect    : TRect;
//#UC END# *52BD62C20057_52BAD1C40174_var*
//#UC START# *52BD62DB03DF_52BAD1C40174_impl*
 if (State = nsAutoHide) and (f_PageControl.PageCount > 0) then
  DragDockObject.DockRect := GetDockRect(f_SizeNormal)
 else
 if f_PageControl.PageCount = 0 then
  DragDockObject.DockRect := GetDockRect(GetNavigatorSizeNormal(DragDockObject.Control));
//#UC END# *52BD62DB03DF_52BAD1C40174_impl*
//#UC START# *52BD62DB03DF_52BAD1C40174_var*
//#UC END# *52BD62DB03DF_52BAD1C40174_var*
//#UC START# *52BD6318023E_52BAD1C40174_impl*
 { ѕолучим размеры будущей формы }
 if f_Float then
  f_DockRect := f_FloatNavigator.BoundsRect
 else
  f_DockRect := GetDockRect(f_SizeNormal);

 { Ќавигатор может быть плавающим и его видимые размеры (размеры PageControl-а)
   больше чем сам TvtNavigator в св€зи с этим рассчитаем положение мышы,
   чтобы не зависеть от размеров TvtNavigator }
 f_ClickPoint.X := f_DockRect.Left - Mouse.CursorPos.X;
 f_ClickPoint.X := Abs(f_ClickPoint.X);
 f_ClickPoint.Y := f_DockRect.Top - Mouse.CursorPos.Y;
 f_ClickPoint.Y := Abs(f_ClickPoint.Y);
 { –азмеры навигатора были получены в экранных координатах, пересчитаем }
 OffsetRect(f_DockRect, -f_DockRect.Left, -f_DockRect.Top);

 { ƒл€ отрисовки тени }
 {$IfDef Nemesis}
 if aControl is TvcmForm then
  TvcmForm(aControl).OnPositionDockRect := OnFormPositionDockRect;
 {$EndIf Nemesis}
//#UC END# *52BD6318023E_52BAD1C40174_impl*
//#UC START# *52BD6318023E_52BAD1C40174_var*
//#UC END# *52BD6318023E_52BAD1C40174_var*
//#UC START# *52BD634A02F3_52BAD1C40174_impl*
 l_Index := 0;
 Result := True;
 while Result and (l_Index <= Pred(f_PageControl.PageCount)) do
 begin
  if (f_PageControl.Pages[l_Index].ControlCount > 0) then
   Result := not (f_PageControl.Pages[l_Index].Controls[0] = aControl)
  else
   Result := True; 
  (* такой компонент уже есть, проверим его позицию *)
  if not Result then
   aControl.Align := alClient;
  Inc(l_Index);
 end;//while Result and (l_Index <= Pred(f_PageControl.PageCount))
//#UC END# *52BD634A02F3_52BAD1C40174_impl*
//#UC START# *52BD634A02F3_52BAD1C40174_var*
var
 l_Index: Integer;
//#UC END# *52BD634A02F3_52BAD1C40174_var*
//#UC START# *52BD63660252_52BAD1C40174_impl*
 Result := -1;
 if Assigned(f_OnLoadSize) then
 begin
  f_OnLoadSize(Self, Result);
  f_SizeNormalLoaded := True;
 end;
//#UC END# *52BD63660252_52BAD1C40174_impl*
//#UC START# *52BD63660252_52BAD1C40174_var*
//#UC END# *52BD63660252_52BAD1C40174_var*
//#UC START# *52BD637E01DC_52BAD1C40174_impl*
 Result := nil;
 Index := 0;
 while (Index <= Application.ComponentCount - 1) and (Result = nil) do
 begin
  if Application.Components[Index] is TnpFloatingWindow then
    Result := Application.Components[Index] as TnpFloatingWindow;
  Inc(Index);
 end;
//#UC END# *52BD637E01DC_52BAD1C40174_impl*
//#UC START# *52BD637E01DC_52BAD1C40174_var*
var
 Index: Integer;
//#UC END# *52BD637E01DC_52BAD1C40174_var*
//#UC START# *52BD640D0313_52BAD1C40174_impl*
 if (f_Header <> nil) then
 begin
  if (f_State <> nsMinimized) then
  begin
   with PageControl do
    if (ActivePage <> nil) and
       (ActivePage.ControlCount > 0) then
    begin
     if TvtNavigatorFormList.Instance.FindData(TvtFormHandlerID_C(ActivePage.Controls[0]), l_Index) then
      f_Header.ShowCloseButton(TvtNavigatorFormList.Instance.Items[l_Index].CloseHandler)
     else
      f_Header.HideCloseButton;
    end//if PageControl.ActivePage <> nil then
    else
     f_Header.HideCloseButton;
  end
  else
   f_Header.HideCloseButton;
  // - http://mdp.garant.ru/pages/viewpage.action?pageId=602933962 
 end;
//#UC END# *52BD640D0313_52BAD1C40174_impl*
//#UC START# *52BD640D0313_52BAD1C40174_var*
var
 l_Index : Integer;
//#UC END# *52BD640D0313_52BAD1C40174_var*
//#UC START# *52BD64230135_52BAD1C40174_impl*
 Result := BoundsRect;
 case Align of
  alLeft: Result.Right := X;
  alRight:
   begin
    Result.Left := X;
    (* ѕосле перетаскивани€ оставл€ем курсор в области сплиттера *)
    Dec(Result.Left, cspSize);
   end;
  alTop: Result.Bottom := Y;
  alBottom: Result.Top := Y;
 end;//case Align of
//#UC END# *52BD64230135_52BAD1C40174_impl*
//#UC START# *52BD64230135_52BAD1C40174_var*
//#UC END# *52BD64230135_52BAD1C40174_var*
//#UC START# *52BD644A002B_52BAD1C40174_impl*
 if (f_NavigatorList.IndexOf(P) = -1) then
  f_NavigatorList.Add(P);
//#UC END# *52BD644A002B_52BAD1C40174_impl*
//#UC START# *52BD644A002B_52BAD1C40174_var*
//#UC END# *52BD644A002B_52BAD1C40174_var*
//#UC START# *52BD645E0355_52BAD1C40174_impl*
 if f_State <> nsAutoHide then
  Exit;
 if (not f_Surface.f_Splitter.IsHideButtonDown or f_TimerFloat.Enabled) and
    (Self.Parent.Handle <> GetCapture) and
    (f_State <> nsMinimized) and
    not f_MouseDown and
    (f_PageControl.PageCount > 0) then
 begin
  if not f_IsDelay then
  begin
   if f_DoDelay and not ((f_HideDirect = hdHide) and (f_DelayIntervalOnShow = 0)) then
    OpenDelay
   else
   begin
    lSaveDirect := f_HideDirect;
    Windows.GetWindowRect(f_Surface.Handle, lRect);
    lIsNavigator := PtInRect(lRect, Mouse.CursorPos);
    if (f_HideDirect = hdShow) and not lIsNavigator then
     f_HideDirect := hdHide
    else
    if (f_HideDirect = hdHide) and lIsNavigator then
     f_HideDirect := hdShow;

    if lSaveDirect <> f_HideDirect then
     if f_AutoHideFloat then
     begin
      if f_HideDirect = hdShow then
       f_IsFloatingOnShow := True;
      f_TimerFloat.Enabled := True;
     end//f_AutoHideFloat
     else
      ModeAutoUpdate;
   end;//f_DoDelay and not ((f_HideDirect = hdHide) and (f_DelayIntervalOnShow = 0))
  end;//not f_IsDelay
 end//(not Surface.Splitter.IsHideButtonDown or f_TimerFloat.Enabled)
 else
 if f_AutoHideFloat then
  if not f_IsFloatingOnShow then
   f_TimerFloat.Enabled := False;
//#UC END# *52BD645E0355_52BAD1C40174_impl*
//#UC START# *52BD645E0355_52BAD1C40174_var*
const
  SizeSensitive = 6;
var
 lSaveDirect  : TnpHideDirect;
 lIsNavigator : Boolean;
 lRect        : TRect;
//#UC END# *52BD645E0355_52BAD1C40174_var*
//#UC START# *52BD64760236_52BAD1C40174_impl*
 f_TimerDelay.Enabled := False;
 f_IsDelay := False;
 f_DoDelay := False;
 AutoHideUpdate;
 f_DoDelay := True;
//#UC END# *52BD64760236_52BAD1C40174_impl*
//#UC START# *52BD64760236_52BAD1C40174_var*
//#UC END# *52BD64760236_52BAD1C40174_var*
//#UC START# *52BD64810357_52BAD1C40174_impl*
 Index := f_NavigatorList.IndexOf(P);
 if (Index <> -1) then
  f_NavigatorList.Delete(Index);
//#UC END# *52BD64810357_52BAD1C40174_impl*
//#UC START# *52BD64810357_52BAD1C40174_var*
var
 Index: Integer;
//#UC END# *52BD64810357_52BAD1C40174_var*
//#UC START# *52BD64B202A8_52BAD1C40174_impl*
 Result := nil;
 lIsCreate := False;
 if (aControl <> nil) then
 begin
  {  омпонент был вытащен из плавающего навигатора и ни к кому не пристыкован }
  if f_DockInSelf then
    aControl.ManualDock(f_PageControl)
  { Ќовый плавающий }
  else
  begin
   { ќдин плавающий на всех }
   if f_SingleFloatNavigator then
     Result := FindFloatNavigator
   else
   { ѕристыковываем к навигатору по идентификатору }
// !! временно задействовал
// !! проблема: при переключении конфигураций, если в обеих есть плавающие навигаторы
// !! в DockToExistsFloat форма дочитс€ к _старому_(!) плавающему навигатору, который умрЄт,
// !! когда до него долетит CM_RELEASE (он и не умер-то до сих пор потому, что сообщение
// !! в очереди
//
// !! выключил - зацикливание в каком-то специфическом случае. ¬идимо, проблему пристыковки
// !! надо как-то по-другому решать.
//   afw.ProcessMessages;
   if not IsUndockByUser and DockToExistsFloat(Result) then
    Exit;
   if (Result = nil) then
   begin
    Result := CreateNavigator;
    lIsCreate := True;
   end;//Result = nil
   f_ClickOnTab := False;
   if f_Header.f_IsDragBegining then
   begin
    f_Header.f_IsDragBegining := False;
    Result.f_Navigator.MovePagesToNavigator(Self, aControl);
   end//f_Header.f_IsDragBegining
   else
   begin
    aControl.ManualDock(Result.Navigator.PageControl);
    {$IfDef Nemesis}
    if (aControl Is TvcmEntityForm) then
     TvcmEntityForm(aControl).CheckFloatingVisibility;
    {$EndIf Nemesis}
   end;//f_Header.f_IsDragBegining
   { Ќовый навигатор }
   if lIsCreate then
   begin
    with Result do
    begin
     Constraints.MinHeight := f_Navigator.pm_GetSizeMini + f_Navigator.f_Header.Height;
     Constraints.MinWidth := Constraints.MinHeight * 2;
     with f_Navigator.f_PageControl.Pages[0].Controls[0] do
     begin
      UndockWidth := Result.Width;
      UndockHeight := Result.Height;
     end;//with f_Navigator.f_PageControl.Pages[0].Controls[0]
    end;//with Result
   end;//lIsCreate
  end;//f_DockInSelf
 end;//aControl <> nil
//#UC END# *52BD64B202A8_52BAD1C40174_impl*
//#UC START# *52BD64B202A8_52BAD1C40174_var*
var
  lIsCreate: Boolean;

  procedure SetFloatingSize(aNavigator : TnpFloatingWindow;
                            aControl   : TControl);
  var
   l_Parent : TControl;
  begin//SetFloatingSize
   aNavigator.Width := aControl.Width;
   aNavigator.Height := aControl.Height;
   l_Parent := aControl.Parent;
   while True do
   begin
    if not Assigned(l_Parent) then
     Break;
    if (l_Parent is TnpFloatingWindow) then
    begin
     aNavigator.Width := l_Parent.Width;
     aNavigator.Height := l_Parent.Height;
     Break;
    end;//l_Parent is TnpFloatingWindow
    l_Parent := l_Parent.Parent;
   end;//while True
  end;//SetFloatingSize

  function CreateNavigator : TnpFloatingWindow;
  var
   l_Owner : TComponent;
   l_Rect  : TRect;
   {$IfDef Nemesis}
   l_ParentForm: TCustomForm;
   {$EndIf Nemesis}
  begin//CreateNavigator
   SetRectEmpty(l_Rect);
   if f_Float then
    l_Owner := f_FloatNavigator.Owner
   else
    l_Owner := Self;
   Result := GetFloatingWindowClass.CreateNew(l_Owner);
   Result.Navigator.AssignNav(Self);
   SetFloatingSize(Result, aControl);
   with Result.f_Navigator do
   begin
    f_SingleFloatNavigator := Self.f_SingleFloatNavigator;
    f_UnDockFromFloat := Self.f_UnDockFromFloat;
    f_Header.Size := Self.f_Header.Size;
   end;//with Result.f_Navigator
   { «арегистрируем плаващий навигатор }
   if f_Float then
   begin
    f_NavigatorOnForm.AddNavigator(Result);
    Result.f_Navigator.NavigatorOnForm := f_NavigatorOnForm;
   end//f_Float
   else
   begin
    AddNavigator(Result);
    Result.f_Navigator.NavigatorOnForm := Self;
   end;//f_Float
   {$IfDef Nemesis}
   if (aControl is TvcmForm) then
   begin
    { ќпределим идентификатор навигатора }
    if (TvcmForm(aControl).FloatID > 0) and not f_Float then
     Result.FloatID := TvcmForm(aControl).FloatID
    else
     Result.FloatID := RandomRange(1, 1000);
    // если закладку отстыковали не перетаскиванием, а по DblClick-у или
    // программно, то восстанавливаем размер плавающей формы
    if not IsUndockByUser then
     l_Rect := TvcmForm(aControl).FloatWindowBounds;
   end;
   {$EndIf Nemesis}
   { ѕоложение нового навигатора }
   if IsRectEmpty(l_Rect) then
    l_Rect := CalcNewFloatBounds;

   // ѕровер€ем не вылазием ли мы за границы видимой рабочей области экрана
   // http://mdp.garant.ru/pages/viewpage.action?pageId=331187752
   l_Rect := vcmUtils.vcmCheckWindowBounds(l_Rect);

   Result.BoundsRect := l_Rect;
   { Ќе показываем если пристыковали невидимый объект (см. CMDockNotification) }
   {$IfDef Nemesis}
   l_ParentForm := GetParentForm(Self);
   if (aControl Is TvcmEntityForm) then
    Result.Visible := aControl.Visible and
                      TvcmEntityForm(aControl).FloatingVisible and
                      (l_ParentForm <> nil) and
                      l_ParentForm.Visible
    // - http://mdp.garant.ru/pages/viewpage.action?pageId=587161831
   else
   {$EndIf Nemesis}
    Result.Visible := aControl.Visible;
   (* устанавливаем здесь, потому, что vcl умничает и в процедуре SetVisible
    устанавливает окно там, где находитс€ главное окно приложени€, а мы хотим
    там где отпустил пользователь *)
   Result.BoundsRect := l_Rect;
   {$IfDef Nemesis}
    { —осто€ние навигатора }
    if not IsUndockByUser and ((TvcmForm(aControl).FloatWindowState and
      cFloatMinimized) = cFloatMinimized) then
     Result.State := fwsMinimized;
   {$EndIf Nemesis}
  end;//CreateNavigator

  function DockToExistsFloat(var aFindingWindow : TnpFloatingWindow) : Boolean;
  {$IfDef Nemesis}
  var
   l_Index : Integer;
   lFloat : TnpFloatingWindow;
  {$EndIf Nemesis}
  begin//DockToExistsFloat
   Result := False;
   {$IfDef Nemesis}
   if (aControl is TvcmForm) and (TvcmForm(aControl).FloatID > 0) then
   begin
    for l_Index := 0 to Pred(TnpNavigatorList.Instance.Count) do
    begin
     if TvtNavigator(TnpNavigatorList.Instance[l_Index]).Float then
     begin
      lFloat := TvtNavigator(TnpNavigatorList.Instance[l_Index]).f_FloatNavigator;
      if (lFloat.FloatID  = TvcmForm(aControl).FloatID) and
       // “.к. регистрируютс€ навигаторы дл€ всех главных окон выбираем только
       // те, которые принадлежат форме, от которой отстыковываем
       (lFloat.Navigator.f_MainForm = f_ParentMainForm) then
      begin
       Result := True;
       aFindingWindow := lFloat;
       aControl.ManualDock(lFloat.Navigator.PageControl);
       Break;
      end;//lFloat.FloatID  = TvcmForm(aControl).FloatID..
     end;//TvtNavigator(TnpNavigatorList.Instance[l_Index]).Float
    end;//for l_Index
   end;//(aControl is TvcmForm) and (TvcmForm(aControl).FloatID > 0)
   {$EndIf Nemesis}
  end;//DockToExistsFloat
//#UC END# *52BD64B202A8_52BAD1C40174_var*
//#UC START# *52BD64EC0294_52BAD1C40174_impl*
 if not f_Float then
 begin
  f_HideDirect := hdNone;
  if f_State = nsMinimized then
   ModeHide
  else
   ModeNormalUpdate;
 end;//not f_Float
//#UC END# *52BD64EC0294_52BAD1C40174_impl*
//#UC START# *52BD64EC0294_52BAD1C40174_var*
//#UC END# *52BD64EC0294_52BAD1C40174_var*
//#UC START# *52BD64F60307_52BAD1C40174_impl*
 if Assigned(f_OnSaveSize) then
  f_OnSaveSize(Self, f_SizeNormal);
//#UC END# *52BD64F60307_52BAD1C40174_impl*
//#UC START# *52BD64F60307_52BAD1C40174_var*
//#UC END# *52BD64F60307_52BAD1C40174_var*
//#UC START# *52BD65070210_52BAD1C40174_impl*
 l_DesktopHandle := GetDesktopWindow;
 l_DC := GetDCEx(l_DesktopHandle, 0, DCX_CACHE or DCX_LOCKWINDOWUPDATE);
 try
  l_Brush := TBrush.Create;
  try
   l_Brush.Bitmap := AllocPatternBitmap(clBlack, clWhite);
   l_OldBrush := SelectObject(l_DC, l_Brush.Handle);
   try
    with f_SplitterRect do
     PatBlt(l_DC, Left, Top, Right - Left, Bottom - Top, PATINVERT);
   finally
    SelectObject(l_DC, l_OldBrush);
   end;{try..finally}
  finally
   FreeAndNil(l_Brush);
  end;{try..finally}
 finally
  ReleaseDC(l_DesktopHandle, l_DC);
 end;{try..finally}
//#UC END# *52BD65070210_52BAD1C40174_impl*
//#UC START# *52BD65070210_52BAD1C40174_var*
var
 l_DC            : HDC;
 l_OldBrush      : HBrush;
 l_DesktopHandle : HWND;
 l_Brush         : TBrush;
//#UC END# *52BD65070210_52BAD1C40174_var*
//#UC START# *52BD653001BE_52BAD1C40174_impl*
 if not f_IsInitDockDrop then
 begin
  f_Header.Visible := True;
  if not f_Float then
   ModeStateUpdate;
  f_IsInitDockDrop := True;
 end;
//#UC END# *52BD653001BE_52BAD1C40174_impl*
//#UC START# *52BD653001BE_52BAD1C40174_var*
//#UC END# *52BD653001BE_52BAD1C40174_var*
//#UC START# *52BD656B01FB_52BAD1C40174_impl*
 if (f_State = nsAutoHide) then
 begin
  if (f_PageControl.DockClientCount = 0) then
  begin
   SetSizeMini;
   f_PageControl.Visible := False;
   f_Header.Visible := False;
  end//f_PageControl.DockClientCount = 0
  else
  if f_HideDirect = hdShow then
   ModeShow
  else
   ModeHide;
 end;//f_State = nsAutoHide
//#UC END# *52BD656B01FB_52BAD1C40174_impl*
//#UC START# *52BD656B01FB_52BAD1C40174_var*
//#UC END# *52BD656B01FB_52BAD1C40174_var*
//#UC START# *52BD6597029C_52BAD1C40174_impl*
 UpdateSize;
//#UC END# *52BD6597029C_52BAD1C40174_impl*
//#UC START# *52BD6597029C_52BAD1C40174_var*
//#UC END# *52BD6597029C_52BAD1C40174_var*
//#UC START# *52BD65A40367_52BAD1C40174_impl*
 if (f_PageControl.PageCount > 0) then
 begin
  if f_State = nsNormal then
  begin
   SetSelfSize(f_SizeNormal);
   f_PageControl.Visible := True;
   f_Header.Visible := True;
  end;
 end//f_PageControl.PageCount > 0
 else
 begin
  f_PageControl.Visible := False;
  f_Header.Visible := False;
  case Self.Align of
   alTop, alBottom:
    Self.Height := f_SizeEmpty;
   alLeft, alRight:
    Self.Width := f_SizeEmpty;
  end;//case Self.Align
 end;//f_PageControl.PageCount > 0
//#UC END# *52BD65A40367_52BAD1C40174_impl*
//#UC START# *52BD65A40367_52BAD1C40174_var*
//#UC END# *52BD65A40367_52BAD1C40174_var*
//#UC START# *52BD65DF01E3_52BAD1C40174_impl*
 case f_State of
  nsAutoHide:
   ModeAutoUpdate;
 else
  ModeNormalUpdate;
 end;//case f_State
//#UC END# *52BD65DF01E3_52BAD1C40174_impl*
//#UC START# *52BD65DF01E3_52BAD1C40174_var*
//#UC END# *52BD65DF01E3_52BAD1C40174_var*
//#UC START# *52BD661D0125_52BAD1C40174_impl*
 PostMessage(Handle, CM_npAfterUndock, 0, 0);
//#UC END# *52BD661D0125_52BAD1C40174_impl*
//#UC START# *52BD661D0125_52BAD1C40174_var*
//#UC END# *52BD661D0125_52BAD1C40174_var*
//#UC START# *52BD665B0244_52BAD1C40174_impl*
 if (Value <> nil) then
 begin
  Value.f_PageControl.OnUnDock := nil;
  try
   { ”становим TElCustomPageControl.Images }
   if f_PageControl.Images <> nil then
     Value.Images := f_PageControl.Images;
   { ѕереместим в "TElCustomPageControl приемник" DockControl который пользователь тащит.
     Ёто не делаетс€ в цикле потому что в этот момент закладки на которой он
     был расположен уже нет }
   DoDockControl;
   { »дем по закладкам из одного PageControl в другой }
   Index := Pred(Value.f_PageControl.PageCount);
   while (Index >= 0) do
   begin
    if (Value.f_PageControl.Pages[0].ControlCount > 0) then
     l_DockControl := Value.f_PageControl.Pages[0].Controls[0]
    else
     l_DockControl := nil;
    if (l_DockControl = nil) then
     Value.f_PageControl.RemovePage(Value.f_PageControl.Pages[0])
    else
    begin
     { «апомним ImageIndex }
     l_ImageIndex := Value.f_PageControl.Pages[0].ImageIndex;
     if l_DockControl is TForm then
       TForm(l_DockControl).OnEndDock := nil;
     l_DockControl.ManualDock(f_PageControl);
     { ”становим ImageIndex }
     if l_DockControl.Parent is TElTabSheet then
      TElTabSheet(l_DockControl.Parent).ImageIndex := l_ImageIndex;
    end;//l_DockControl <> nil
    Dec(Index);
   end;//Index >= 0
   Value.SetUndockSize;
   { ”становим активную закладку }
   if Value.f_ActiveControl <> nil then
    if Value.f_ActiveControl = DockControl then
     f_PageControl.ActivePage := TElTabSheet(DockControl.Parent)
    else
     for Index := 0 to Pred(f_PageControl.PageCount) do
      if f_PageControl.Pages[Index].Controls[0] = Value.f_ActiveControl then
      begin
       f_PageControl.ActivePage := f_PageControl.Pages[Index];
       Exit;
      end;
  finally
   Value.f_PageControl.OnUnDock := Value.OnPageControlUnDock;
   with Value do
   begin
    ModeStateUpdateAfter;
    Value.f_Header.Visible := False;
   end;
   f_Header.Visible := True;
   Value := nil;
  end;
 end//Value <> nil
 else
  DoDockControl;
 ModeNormalUpdate;
 {$IfDef Nemesis}
 if f_Float and
   (f_FloatNavigator <> nil) then
  f_FloatNavigator.Visible := True;
 {$EndIf Nemesis} 
//#UC END# *52BD665B0244_52BAD1C40174_impl*
//#UC START# *52BD665B0244_52BAD1C40174_var*
 procedure DoDockControl;
 begin//DoDockControl
  if DockControl <> nil then
  begin
   if DockControl is TForm then
     TForm(DockControl).OnEndDock := nil;
   DockControl.ManualDock(f_PageControl);
   SetUndockSize;
  end;//DockControl <> nil
 end;//DoDockControl

var
 Index, l_ImageIndex: Integer;
 l_DockControl: TControl;
//#UC END# *52BD665B0244_52BAD1C40174_var*
//#UC START# *52BD669D02AB_52BAD1C40174_impl*
 f_IsDelay := True;
 if f_HideDirect = hdHide then
  f_TimerDelay.Interval := f_DelayIntervalOnShow
 else
  f_TimerDelay.Interval := f_DelayIntervalOnHide;
 f_TimerDelay.Enabled := True;
//#UC END# *52BD669D02AB_52BAD1C40174_impl*
//#UC START# *52BD669D02AB_52BAD1C40174_var*
//#UC END# *52BD669D02AB_52BAD1C40174_var*
//#UC START# *52BD66F600F4_52BAD1C40174_impl*
 { ѕересчитаем координаты навигатора в координаты родительского окна }
 l_Point := Parent.ScreenToClient(Point(X, Y));
 l_Rect := Parent.ClientRect;
 { ќграничени€ на изменение размера }
 if not (aDrawSplitterType = [dstErase]) then
  l_Rect := CorrectBounds(l_Rect);
 lp_MinusPageSize;
 if PtInRect(l_Rect, l_Point) then
 begin
  { —тарый сплиттер }
  if dstErase in aDrawSplitterType then
   DrawSplit(f_SplitterRect);
  { Ќовый сплиттер }
  if dstPaint in aDrawSplitterType then
  begin
   l_Rect := lp_CalcSplitRect;
   l_Point.X := l_Rect.Left;
   l_Point.Y := l_Rect.Top;
   l_Point := Self.ClientToScreen(l_Point);
   f_SplitterRect := l_Rect;
   with f_SplitterRect do
   begin
    Right := l_Point.X + (Left - Right);
    Bottom := l_Point.Y + (Bottom - Top);
    Left := l_Point.X;
    Top := l_Point.Y;
   end;//with f_SplitterRect do
   DrawSplit(f_SplitterRect);
  end;//if dstPaint in aDrawSplitterType then
 end;//if PtInRect(l_Rect, l_Point) then
//#UC END# *52BD66F600F4_52BAD1C40174_impl*
//#UC START# *52BD66F600F4_52BAD1C40174_var*
var
 l_Rect  : TRect;
 l_Point : TPoint;

  function lp_CalcSplitRect: TRect;
  var
   lPoint : TPoint;
  begin
   lPoint := ScreenToClient(Point(X, Y));
   if dstPaint in aDrawSplitterType then
    case Self.Align of
     alTop, alBottom:
      begin
       Result.Left := 0;
       Result.Right := Self.Width;
       Result.Top := lPoint.Y + cspSize div 2;
       Result.Bottom := Result.Top + cspSize;
      end;
     alLeft, alRight:
      begin
       Result.Left := lPoint.X + cspSize div 2;
       Result.Right := Result.Left + cspSize;
       Result.Top := 0;
       Result.Bottom := Self.Height;
      end;
    end;
  end;

 procedure lp_MinusPageSize;
 var
  l_Limit: Integer;
 begin
  { ”становим ограничени€ }
  l_Limit := pm_GetSizeMini - cspSize;
  case Self.Align of
   alLeft: l_Rect.Left := l_Rect.Left + l_Limit;
   alRight: l_Rect.Right := l_Rect.Right - l_Limit;
   alTop: l_Rect.Top := l_Rect.Top + l_Limit;
   alBottom: l_Rect.Bottom := l_Rect.Bottom - l_Limit;
  end;//case Self.Align of
 end;//lp_CheckPageSize
//#UC END# *52BD66F600F4_52BAD1C40174_var*
//#UC START# *52BD6A4C0348_52BAD1C40174_impl*
 if (f_ExportPageControl <> nil) then
 begin
  f_PageControl.OnUnDock := nil;
  for Index := Pred(f_PageControl.PageCount) downto 0 do
  begin
   l_Control := f_PageControl.Pages[Index].Controls[0];
   if l_Control is TForm then
    TForm(l_Control).OnEndDock := nil;
   l_Control.ManualDock(f_ExportPageControl);
  end;//for Index
  f_ExportPageControl := nil;
 end//f_ExportPageControl <> nil
 else
 if (f_Header.f_IsDragBegining) or
    (f_Float and (f_PageControl.PageCount = 1)) then
 begin
  with f_FloatNavigator do
  begin
   // ”становим новую позицию окна
   BoundsRect := CalcNewFloatBounds;
   {$IfDef Nemesis}
   // ќбновим информацию о положении окна у TvcmForm`s
   UpdateFloatWindowsBounds;
   {$EndIf Nemesis}
  end;//with f_FloatNavigator
  f_Header.f_IsDragBegining := False;
 end;//(f_Header.f_IsDragBegining) or (f_Float and (f_PageControl.PageCount = 1))
 TForm(f_EndDockClient).OnEndDock := nil;
//#UC END# *52BD6A4C0348_52BAD1C40174_impl*
//#UC START# *52BD6A4C0348_52BAD1C40174_var*
var
 Index: Integer;
 l_Control : TControl;
//#UC END# *52BD6A4C0348_52BAD1C40174_var*
//#UC START# *52BD6A7F0011_52BAD1C40174_impl*
 f_ClickOnTab := True;
 f_Header.f_IsDragBegining := False;
 if f_State = nsMinimized then
  State := nsNormal;
 if (Page.ControlCount > 0) then
 begin
  InitDrag(Page.Controls[0]);
  if not Mouse.IsDragging then
   Page.Controls[0].BeginDrag(False);
 end;//Page.ControlCount > 0
//#UC END# *52BD6A7F0011_52BAD1C40174_impl*
//#UC START# *52BD6A7F0011_52BAD1C40174_var*
//#UC END# *52BD6A7F0011_52BAD1C40174_var*
//#UC START# *52BD6A960020_52BAD1C40174_impl*
 if State = nsMinimized then
  State := nsNormal
 else
  State := nsMinimized;
//#UC END# *52BD6A960020_52BAD1C40174_impl*
//#UC START# *52BD6A960020_52BAD1C40174_var*
//#UC END# *52BD6A960020_52BAD1C40174_var*
//#UC START# *52BD6AC300B2_52BAD1C40174_impl*
 if State = nsAutoHide then
  State := nsNormal
 else
  State := nsAutoHide;
//#UC END# *52BD6AC300B2_52BAD1C40174_impl*
//#UC START# *52BD6AC300B2_52BAD1C40174_var*
//#UC END# *52BD6AC300B2_52BAD1C40174_var*
//#UC START# *52BD6B500014_52BAD1C40174_impl*
 SetUndockSize;
//#UC END# *52BD6B500014_52BAD1C40174_impl*
//#UC START# *52BD6B500014_52BAD1C40174_var*
//#UC END# *52BD6B500014_52BAD1C40174_var*
//#UC START# *52BD6B6801D6_52BAD1C40174_impl*
 if (f_PageControl.PageCount = 0) then
 begin
  f_PageControl.Visible := False; // костыль дл€ http://mdp.garant.ru/pages/viewpage.action?pageId=324009991
                                  // http://mdp.garant.ru/pages/viewpage.action?pageId=324009991&focusedCommentId=330141913
  if f_Float then
   f_FloatNavigator.Close
  else
  begin
   (* запомним текущий нормальный размер *)
   l_Size := f_Surface.Size;
   // ”станавливаем только дл€ нормального размера
   if f_State = nsNormal then
    f_SizeNormal := l_Size;
   (* сохраним размер *)
   DoSaveSize;
   pm_SetSizeEmpty(f_SizeEmpty);
  end;//f_Float
 end//f_PageControl.PageCount = 0
 else
  f_Header.Invalidate;
 UpdateCloseButton;
 DoStateChanged;
//#UC END# *52BD6B6801D6_52BAD1C40174_impl*
//#UC START# *52BD6B6801D6_52BAD1C40174_var*
var
 l_Size : Integer;
//#UC END# *52BD6B6801D6_52BAD1C40174_var*
//#UC START# *52BD6B710302_52BAD1C40174_impl*
 lIsExit := False;
 // ќпределим приращение
 if (f_HideDirect = hdHide) then
 begin
  lDelta := -clDelta;
  lDist := -clDelta;
  lLimit := SizeMini;
 end//f_HideDirect = hdHide
 else
 begin
  lDelta := clDelta;
  lDist := clDelta;
  lLimit := f_SizeNormal;
 end;//f_HideDirect = hdHide
 // “екущие размеры
 lBounds := f_Surface.BoundsRect;
 // ќпредим не достигли ли мы пределного сворачивани€/разворачивани€
 case Align of
  alLeft, alRight:
   if f_HideDirect = hdHide then
    lIsExit := (f_Surface.Width + lDist <= lLimit) or
     (f_Surface.Width + lDelta < lLimit)
   else
    lIsExit := (f_Surface.Width + lDist >= lLimit) or
     (f_Surface.Width + lDelta > lLimit);
  alTop, alBottom:
   if f_HideDirect = hdHide then
    lIsExit := (f_Surface.Height + lDist <= lLimit)  or
     (f_Surface.Height + lDelta < lLimit)
   else
    lIsExit := (f_Surface.Height + lDist >= lLimit)  or
     (f_Surface.Height + lDelta > lLimit);
 end;//case Align
 // ”стновим новый размер
 case Align of
  alLeft:
   with lBounds do
   begin
    if lIsExit then
     Right := Left + lLimit
    else
     Inc(Right, lDelta);
   end;
  alRight:
   with lBounds do
    if lIsExit then
     Left := Right - lLimit
    else
     Dec(Left, lDelta);
  alTop:
   with lBounds do
    if lIsExit then
     Bottom := Top + lLimit
    else
     Inc(Bottom, lDelta);
  alBottom:
   with lBounds do
    if lIsExit then
     Top := Bottom - lLimit
    else
     Inc(Top, lDelta);
 end;//case Align
 // ”стновим новые размеры
 Windows.SetWindowPos(f_Surface.Handle, 0, lBounds.Left, lBounds.Top,
  lBounds.Right - lBounds.Left, lBounds.Bottom - lBounds.Top, SWP_NOACTIVATE or
   SWP_NOZORDER);
//#UC END# *52BD6B710302_52BAD1C40174_impl*
//#UC START# *52BD6B710302_52BAD1C40174_var*
const
 clDelta = 30;
var
 lDelta  : Integer;
 lDist   : Integer;
 lLimit  : Integer;
 lIsExit : Boolean;
 lBounds : TRect;
//#UC END# *52BD6B710302_52BAD1C40174_var*
//#UC START# *52BD6B7E0075_52BAD1C40174_impl*
 CloseDelay;
//#UC END# *52BD6B7E0075_52BAD1C40174_impl*
//#UC START# *52BD6B7E0075_52BAD1C40174_var*
//#UC END# *52BD6B7E0075_52BAD1C40174_var*
//#UC START# *52BD6BDB0195_52BAD1C40174_impl*
 SetUndockSize;
 if (NewTarget <> Self) then
 begin
  { »мпортируем в PageControl }
  if Allow and (NewTarget <> nil) and f_Header.f_IsDragBegining and
   (NewTarget is TnpPageControl) then
  begin
   f_ExportPageControl := NewTarget as TnpPageControl;
   SetEndDockProcedure;
   ResetDragInfo;
   Allow := False;
  end;//Allow and (NewTarget <> nil) and f_Header.f_IsDragBegining
  if Allow then
  begin
   if f_Float then
    Allow := (NewTarget <> nil) or ((f_PageControl.PageCount > 1) and
     f_UnDockFromFloat and
     not f_SingleFloatNavigator and not f_Header.f_IsDragBegining);
   if Allow then
   begin
    if not f_Float then
     ModeStateUpdateAfter;
    f_DockInSelf := False;
    if (f_PageControl.PageCount = 1) then
    begin
     if f_Float then
     begin
      if NewTarget <> nil then
       f_FloatNavigator.Close
      else
       if not f_UnDockFromFloat then
        f_DockInSelf := True;
     end;//f_Float
    end//f_PageControl.PageCount = 1
    { NewTarget - использу€ f_ImportNavigator  примет все закладки текущего навигатора }
    else
    if (NewTarget <> nil) and (NewTarget is TvtNavigator) and
      f_Header.f_IsDragBegining then
     TvtNavigator(NewTarget).f_ImportNavigator := Self;
    {  лиент ни к кому не пристыкован }
    if NewTarget = nil then
     if Client is TForm then
     begin
      Allow := False;
      PostMessage(Handle, CM_npDockToFloatWindow, Integer(Client), 0);
     end;//if Client is TForm then
   end;//if Allow then
  end;
  if not Allow then
   if f_Float then
    if Client is TForm then
     SetEndDockProcedure;
 end//NewTarget <> Self
 else
  Allow := False;
 if Allow then
  ResetDragInfo;
//#UC END# *52BD6BDB0195_52BAD1C40174_impl*
//#UC START# *52BD6BDB0195_52BAD1C40174_var*
 procedure SetEndDockProcedure;
 begin//SetEndDockProcedure
  if (Client is TForm) then
  begin
   TForm(Client).OnEndDock := OnEndDockControl;
   f_EndDockClient := Client;
  end;//Client is TForm
 end;//SetEndDockProcedure
//#UC END# *52BD6BDB0195_52BAD1C40174_var*
//#UC START# *52BD6C000396_52BAD1C40174_impl*
 if (aDragControl is TForm) then
 begin
  TForm(aDragControl).OnEndDock := OnEndDockControl;
  f_EndDockClient := aDragControl;
 end;//aDragControl is TForm
//#UC END# *52BD6C000396_52BAD1C40174_impl*
//#UC START# *52BD6C000396_52BAD1C40174_var*
//#UC END# *52BD6C000396_52BAD1C40174_var*
//#UC START# *52BD6C1F0372_52BAD1C40174_impl*
 if (DragDockObject.DragTarget = nil) then
  DragDockObject.DockRect := CalcNewFloatBounds;
//#UC END# *52BD6C1F0372_52BAD1C40174_impl*
//#UC START# *52BD6C1F0372_52BAD1C40174_var*
//#UC END# *52BD6C1F0372_52BAD1C40174_var*
//#UC START# *52BD6DC7031F_52BAD1C40174_impl*
 case Self.Align of
  alTop, alBottom: Self.Height := aSize;
  alLeft, alRight: Self.Width := aSize;
 end;
//#UC END# *52BD6DC7031F_52BAD1C40174_impl*
//#UC START# *52BD6DC7031F_52BAD1C40174_var*
//#UC END# *52BD6DC7031F_52BAD1C40174_var*
//#UC START# *52BD6DE601F7_52BAD1C40174_impl*
  // 1 - определим точку отпускани€;
  // 2 - расчитаем новый размер;
  // 3 - применим новые размеры;
 lp_ApplyNewSize(lp_CalcSize(lp_CalcPoint));
//#UC END# *52BD6DE601F7_52BAD1C40174_impl*
//#UC START# *52BD6DE601F7_52BAD1C40174_var*
 function lp_CalcPoint: TPoint;

  procedure lp_OffsetPoint(var aPoint: TPoint);
  var
   l_AddSize: Integer;
  begin
   // –азмер сплиттера:
   case Align of
    alLeft, alRight: l_AddSize := f_Surface.f_Splitter.Width;
    alTop, alBottom: l_AddSize := f_Surface.f_Splitter.Height;
   else
    l_AddSize := 0;
   end;//case Align of
   // ”величим размер:
   if l_AddSize > 0 then
   begin
    l_AddSize := l_AddSize div 2;
    case Align of
     alLeft, alRight: Inc(aPoint.X, l_AddSize);
     alTop, alBottom: Inc(aPoint.Y, l_AddSize);
    end;//case Align of
   end;//if l_AddSize > 0 then
  end;//lp_OffsetPoint

  procedure lp_CorrentPoint(var aPoint: TPoint);
  var
   l_SizeMini   : Integer;
   l_ParentRect : TRect;
  begin
   l_SizeMini := pm_GetSizeMini + 4;
   l_ParentRect := Parent.ClientRect;
   // ѕраво
   if aPoint.X > (l_ParentRect.Right - l_SizeMini) then
    aPoint.X := l_ParentRect.Right - l_SizeMini
   else
    // Ћево
    if aPoint.X < l_ParentRect.Left + l_SizeMini then
     aPoint.X := l_ParentRect.Left + l_SizeMini;
   // ¬ерх
   if aPoint.Y < l_ParentRect.Top + l_SizeMini then
    aPoint.Y := l_ParentRect.Top + l_SizeMini
   else
    // Ќиз
    if aPoint.Y > (l_ParentRect.Bottom - l_SizeMini) then
     aPoint.Y := l_ParentRect.Bottom - l_SizeMini;
  end;//lp_CorrentPoint

 begin
  // ѕолучим точку отпускани€:
  Result := Parent.ScreenToClient(Mouse.CursorPos);
  // ќткорретируем, чтобы она не была меньше минимальных размеров:
  lp_CorrentPoint(Result);
  // ќпределим размер навигатора таким образом, чтобы после применени€ новых
  // размеров курсор мыши располагалс€ по середине сплиттера:
  lp_OffsetPoint(Result);
 end;//lp_CalcPoint

 function lp_CalcSize(const aPoint: TPoint): Integer;
 var
  l_NewBounds: TRect;
 begin
  Result := 0;
  l_NewBounds := CorrectBounds(GetNewBoundsFromPoint(aPoint.X, aPoint.Y));
  with l_NewBounds do
   case Align of
    alLeft, alRight:
     Result := Right - Left;
    alTop, alBottom:
     Result := Bottom - Top;
   end;//case Self.Align of
 end;//lp_CalcSize

 procedure lp_ApplyNewSize(const aSize: Integer);
 begin
  // ћинимизируем навигатор, если ширину установили меньше допустимой:
  if aSize < cMinNormalSize then
   State := nsMinimized
  else
  // ”становим новый размер:
  begin
   f_SizeNormal := aSize;
   if IsMinimized then
    State := nsNormal
   else
    if f_State <> nsMinimized then
     pm_SetSizeNormal(f_SizeNormal);
  end;//if l_NewSize < cMinNormalSize then
 end;//lp_ApplyNewSize
//#UC END# *52BD6DE601F7_52BAD1C40174_var*
//#UC START# *52BD6E0B0379_52BAD1C40174_impl*
 for l_Index := 0 to f_PageControl.PageCount - 1 do
 begin
  with f_PageControl.Pages[l_Index] do
  begin
   if (ControlCount > 0) then
    if f_Float then
    begin
     Controls[0].UndockHeight := Self.Height;
     Controls[0].UndockWidth := Self.Width;
    end//f_Float
    else
    begin
     Controls[0].UndockHeight := f_PageControl.Height;
     Controls[0].UndockWidth := f_PageControl.Width;
    end;//f_Float
  end;//with f_PageControl.Pages[l_Index]
 end;//for l_Index
//#UC END# *52BD6E0B0379_52BAD1C40174_impl*
//#UC START# *52BD6E0B0379_52BAD1C40174_var*
var
 l_Index: Integer;
//#UC END# *52BD6E0B0379_52BAD1C40174_var*
//#UC START# *52BD6E53030E_52BAD1C40174_impl*
 if (f_PageControl.PageCount <> 0) then
  Result := f_SizeNormal
 else
 begin
  l_SizeNormal := DoLoadSize;
  if l_SizeNormal > 0 then
   Result := l_SizeNormal
  else
   Result := aControl.Width;
  l_Parent := aControl.Parent;
  while True do
  begin
   if not Assigned(l_Parent) then
    Break;
   if l_Parent is TElCustomPageControl then
   begin
    l_Navigator := TvtNavigator(l_Parent.Owner);
    Result := l_Navigator.SizeNormal;
    Break;
   end;
   l_Parent := l_Parent.Parent;
  end;
 end;
//#UC END# *52BD6E53030E_52BAD1C40174_impl*
//#UC START# *52BD6E53030E_52BAD1C40174_var*
var
 l_Parent     : TWinControl;
 l_Navigator  : TvtNavigator;
 l_SizeNormal : Integer;
//#UC END# *52BD6E53030E_52BAD1C40174_var*
//#UC START# *52BD6E7A02BA_52BAD1C40174_impl*
 if aDockSize = -1 then
  aDockSize := cDockSize;
 GetWindowRect(Self.Handle, Result);
 { ќбласть докинга }
 case Self.Align of
  alBottom:
   with Result do
    Top := Bottom - aDockSize;
  alTop:
   with Result do
    Bottom := Top + aDockSize;
  alLeft:
   with Result do
    Right := Left + aDockSize;
  alRight:
   with Result do
    Left := Right - aDockSize;
 end;//case Self.Align
//#UC END# *52BD6E7A02BA_52BAD1C40174_impl*
//#UC START# *52BD6E7A02BA_52BAD1C40174_var*
const
 cDockSize = 50;
//#UC END# *52BD6E7A02BA_52BAD1C40174_var*
//#UC START# *52BD6EAC0226_52BAD1C40174_impl*
 (* ChangeLinks  *)
 for l_Index := 0 to Pred(f_ChangeLinks.Count) do
  with TnpChangeLink(f_ChangeLinks[l_Index]) do
   if Assigned(OnStateChanged) then
    OnStateChanged(Self);
 if aNavigatorState and Assigned(f_OnStateChange) then
  f_OnStateChange(Self);
//#UC END# *52BD6EAC0226_52BAD1C40174_impl*
//#UC START# *52BD6EAC0226_52BAD1C40174_var*
var
 l_Index : Integer;
//#UC END# *52BD6EAC0226_52BAD1C40174_var*
//#UC START# *52BD6ECD0365_52BAD1C40174_impl*
 Result := TnpPageControl;
//#UC END# *52BD6ECD0365_52BAD1C40174_impl*
//#UC START# *52BD6ECD0365_52BAD1C40174_var*
//#UC END# *52BD6ECD0365_52BAD1C40174_var*
//#UC START# *52BD6EE2010C_52BAD1C40174_impl*
 Result := TnpFloatingWindow;
//#UC END# *52BD6EE2010C_52BAD1C40174_impl*
//#UC START# *52BD6EE2010C_52BAD1C40174_var*
//#UC END# *52BD6EE2010C_52BAD1C40174_var*
//#UC START# *52BD6F1D0237_52BAD1C40174_impl*
 if (f_ChangeLinks = nil) then 
  Exit;
 if f_ChangeLinks.IndexOf(aLink) = -1 then
  f_ChangeLinks.Add(aLink);
//#UC END# *52BD6F1D0237_52BAD1C40174_impl*
//#UC START# *52BD6F1D0237_52BAD1C40174_var*
//#UC END# *52BD6F1D0237_52BAD1C40174_var*
//#UC START# *52BD6F4901D6_52BAD1C40174_impl*
 if (f_ChangeLinks = nil) then
  Exit;
 l_Index := f_ChangeLinks.IndexOf(aLink);
 if l_Index <> -1 then
  f_ChangeLinks.Delete(l_Index);
//#UC END# *52BD6F4901D6_52BAD1C40174_impl*
//#UC START# *52BD6F4901D6_52BAD1C40174_var*
var
 l_Index : Integer;
//#UC END# *52BD6F4901D6_52BAD1C40174_var*
//#UC START# *52BD6F8E02BA_52BAD1C40174_impl*
 Result := False;
 if Assigned(f_PageControl) then
  Result := f_PageControl.IsActiveControl(aControl);
//#UC END# *52BD6F8E02BA_52BAD1C40174_impl*
//#UC START# *52BD6F8E02BA_52BAD1C40174_var*
//#UC END# *52BD6F8E02BA_52BAD1C40174_var*
//#UC START# *52BD6FBC0045_52BAD1C40174_impl*
 Result := f_Header.HideButton.MakeHint;
//#UC END# *52BD6FBC0045_52BAD1C40174_impl*
//#UC START# *52BD6FBC0045_52BAD1C40174_var*
//#UC END# *52BD6FBC0045_52BAD1C40174_var*
//#UC START# *52BD70000390_52BAD1C40174_impl*
 ButtonsImageList := aDest.ButtonsImageList;
 AutoHideOffImage := aDest.AutoHideOffImage;
 AutoHideOnImage := aDest.AutoHideOnImage;
 CloseImage := aDest.CloseImage;
 HideDownImage := aDest.HideDownImage;
 HideLeftImage := aDest.HideLeftImage;
 HideRightImage := aDest.HideRightImage;
 HideUpImage := aDest.HideUpImage;
 CloseHint := aDest.CloseHint;
 AutoHideOffHint := aDest.AutoHideOffHint;
 AutoHideOnHint := aDest.AutoHideOnHint;
 MinimizedOffHint := aDest.MinimizedOffHint;
 MinimizedOnHint := aDest.MinimizedOnHint;
//#UC END# *52BD70000390_52BAD1C40174_impl*
//#UC START# *52BD70000390_52BAD1C40174_var*
//#UC END# *52BD70000390_52BAD1C40174_var*
//#UC START# *52BD705202C5_52BAD1C40174_impl*
 case Code of
  HCBT_MINMAX:
   if Assigned(f_MainForm) and f_MainForm.HandleAllocated then
    if (THandle(WParam) = f_MainForm.Handle) then
     // „тобы у двух окон при минимизации не оставались плавающие навигаторы
     if ((LoWord(LParam) and SW_MINIMIZE) = SW_MINIMIZE) then
     begin
      Activate := False;
      f_FormWasMinimized := True;
     end
     else
      if ((LoWord(LParam) and SW_RESTORE) = SW_RESTORE) then
       f_ParentRestore := True;
 end;//case Code of
//#UC END# *52BD705202C5_52BAD1C40174_impl*
//#UC START# *52BD705202C5_52BAD1C40174_var*
//#UC END# *52BD705202C5_52BAD1C40174_var*
//#UC START# *52BD70850139_52BAD1C40174_impl*
 if csDestroying in ComponentState then
  Exit;
 case aMessage.message of
  WM_MOUSEMOVE:
   if (f_State = nsAutoHide) and CheckWindowUnderCursor then
    AutoHideUpdate;
  WM_SIZE:
  begin
   (* »зменилс€ размер родительского окна, изменим размер плавающего навигатора *)
   if Assigned(Parent) and Parent.HandleAllocated and
    (aMessage.hwnd = Parent.Handle) then
   begin
    if (f_State = nsAutoHide) then
     Resize;
    // ≈сли форму минимизировали, то ничего не делаем
    if ((not f_Float) and (not f_FormWasMinimized))
     {$IfDef Nemesis}
      and ((LoWord(aMessage^.LParam) <> Parent.ClientWidth) or
       (HiWord(aMessage^.LParam) <> Parent.Clientheight))
     {$EndIf Nemesis} then
      // - http://mdp.garant.ru/pages/viewpage.action?pageId=564993305
    begin
     if f_ParentRestore then
      f_ParentRestore := False;
     lp_CorrectSize;
    end;
    // ‘орму разворачивают после минимизации
    if f_FormWasMinimized and f_ParentRestore then
    begin
     f_FormWasMinimized := False;
     f_ParentRestore := False;
    end;//if f_FormWasMinimized and f_ParentRestore then
   end;//if Assigned(Parent)
  end;//WM_SIZE
  WM_ACTIVATE:
  begin
   (* ћинимизировать главное окно *)
   if {$IfDef Nemesis}(not f_MainForm.HandleAllocated) or{$EndIf Nemesis}
   // - http://mdp.garant.ru/pages/viewpage.action?pageId=573672384
     ((f_MainForm.Handle = THandle(aMessage.hwnd)) and
     Boolean(HiWord(aMessage.wParam))) then
    Activate := False
   (*  акое-то окно получило фокус, если окно, которое принадлежит главной
      форме, то активируем, в противном случае деактивируем *)
   else
   begin
    lIsAct := LoWord(aMessage.WParam) <> WA_INACTIVE;
    if lIsAct then
    begin
     lActWnd := aMessage.hwnd;
     if lpIsDropDown(lActWnd) then
      Exit;
     (* ѕоказали модальную форму, пр€чем навигатор и выходим *)
     if npIsModalForm(lActWnd) then
     begin
      DoActivate(False);
      Exit;
     end;
     (* јктивировали плавающую форму *)
     if not npIsInFloatNavigator(lActWnd) and npIsFloatingForm(lActWnd) then
     begin
      DoActivate(True);
      Exit;
     end;
    end
    else
    begin
    (* ќкну aMessage.hwnd пришло сообщение о деактивации, handle активированного
       окна содержитс€ в THandle(aMessage.lParam). ≈сли окно принадлежит
       главному окну навигатора ничего не делаем или активируем, в противном
       случае спр€чем *)
     lActWnd := THandle(aMessage.lParam);
     (* »нформацию о деактивации нет смысла обрабатывать если фокус не ушел на
        рабочий стол, потому что когда придет, через HOOK сообщение об активации
        окна, то мы спр€чем навигаторы если активировалось окно другой главной
        формы, или совсем чужое окно *)
     if  lActWnd <> HWND_DESKTOP then
      Exit;
    end;
    (* »зменим состо€ние *)
    l_Activate := npGetActivationValue(Self, f_MainForm, lActWnd);
    // - http://mdp.garant.ru/pages/viewpage.action?pageId=570120392
    DoActivate(l_Activate);
   end;
  end;
 end;
//#UC END# *52BD70850139_52BAD1C40174_impl*
//#UC START# *52BD70850139_52BAD1C40174_var*

 function lpIsDropDown(aWnd : THandle) : Boolean;
 var
  lControl    : TWinControl;
  lDropWindow : IafwDropDownWindow;
 begin
  Result := False;
  lControl := FindControl(aWnd);
  if Assigned(lControl) then
   if Supports(lControl, IafwDropDownWindow, lDropWindow) then
   try
    Result := True;
   finally
    lDropWindow := nil;
   end
   else
    Result := not Assigned(lControl.Parent) and not Assigned(lControl.Owner);
 end;

 procedure lp_CorrectSize;
 begin
  // ѕри восстановлении формы, откорректируем размер навигаторов
  with CorrectBounds(CalcBounds(SizeNormal)) do
   case Self.Align of
    alLeft, alRight:
     if Right - Left <> f_SizeNormal then
      SizeNormal := Right - Left;
    alBottom, alTop:
     if Bottom - Top <> f_SizeNormal then
      SizeNormal := Bottom - Top;
   end;//case Self.Align of
 end;//lp_CorrectSize

 function CheckWindowUnderCursor: Boolean;
 var
  l_CurPos: TPoint;
  l_Window: THandle;
  l_Class: string;
  l_ClassLen: Integer;
 begin // http://mdp.garant.ru/pages/viewpage.action?pageId=296095220
  if GetCursorPos(l_CurPos) then
  begin
   l_Window := WindowFromPoint(l_CurPos);
   Result := (not Tl3PopupControlService.Instance.IsPopupControlWindow(l_Window));
  end //GetCursorPos
  else
   Result := False;
 end; //CheckWindowUnderCursor

var
 lIsAct   : Boolean;
 lActWnd  : THandle;
 l_Activate: Boolean;
//#UC END# *52BD70850139_52BAD1C40174_var*
//#UC START# *52CECF5600E7_52BAD1C40174_impl*
 case f_State of
  nsMinimized: SetSelfSize(SizeMini);
  nsNormal: SetSelfSize(SizeNormal);
 end;//case f_State
//#UC END# *52CECF5600E7_52BAD1C40174_impl*
//#UC START# *52CECF5600E7_52BAD1C40174_var*
//#UC END# *52CECF5600E7_52BAD1C40174_var*
//#UC START# *52CED0F20285_52BAD1C40174set_impl*
 f_NavigatorOnForm := aValue;
 if (aValue <> nil) then
  f_ParentNavigatorHandle := aValue.Handle
 else
  f_ParentNavigatorHandle := 0;
//#UC END# *52CED0F20285_52BAD1C40174set_impl*
//#UC START# *52CED0F20285_52BAD1C40174set_var*
//#UC END# *52CED0F20285_52BAD1C40174set_var*
//#UC START# *52CFCE2D03DE_52BAD1C40174_impl*
 UpdateSize;
//#UC END# *52CFCE2D03DE_52BAD1C40174_impl*
//#UC START# *52CFCE2D03DE_52BAD1C40174_var*
//#UC END# *52CFCE2D03DE_52BAD1C40174_var*
//#UC START# *54102F6E00A4_52BAD1C40174_impl*
 f_MainForm := aNewMainForm;
 // - http://mdp.garant.ru/pages/viewpage.action?pageId=564993305
//#UC END# *54102F6E00A4_52BAD1C40174_impl*
//#UC START# *54102F6E00A4_52BAD1C40174_var*
//#UC END# *54102F6E00A4_52BAD1C40174_var*
//#UC START# *5448CCD000FF_52BAD1C40174_impl*
 (* »наче при активизации приложени€ по заголовку окна окно навигатора могло
    находитс€ под главным, кроме того наблюдались мерцани€ (показывали,
    скрывали, показывали) *)
 PostMessage(Handle, CM_npChangeActivate, Integer(aActive), 0);
//#UC END# *5448CCD000FF_52BAD1C40174_impl*
//#UC START# *5448CCD000FF_52BAD1C40174_var*
//#UC END# *5448CCD000FF_52BAD1C40174_var*
//#UC START# *54868B67034A_52BAD1C40174_impl*
 PageActive;
//#UC END# *54868B67034A_52BAD1C40174_impl*
//#UC START# *54868B67034A_52BAD1C40174_var*
//#UC END# *54868B67034A_52BAD1C40174_var*
//#UC START# *54868B84029F_52BAD1C40174_impl*
 PageInactive;
//#UC END# *54868B84029F_52BAD1C40174_impl*
//#UC START# *54868B84029F_52BAD1C40174_var*
//#UC END# *54868B84029F_52BAD1C40174_var*
