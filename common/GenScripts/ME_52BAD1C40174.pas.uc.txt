//#UC START# *4683E75B01D8_52BAD1C40174_impl*
{$ifdef Nemesis}
 Result := f_PageControl.SaveState(theState, aStateType);
{$endif Nemesis}
//#UC END# *4683E75B01D8_52BAD1C40174_impl*
//#UC START# *4683E75B01D8_52BAD1C40174_var*
//#UC END# *4683E75B01D8_52BAD1C40174_var*
//#UC START# *4683E79D0331_52BAD1C40174_impl*
{$ifdef Nemesis}
 Result := f_PageControl.LoadState(theState, aStateType);
{$endif Nemesis}
//#UC END# *4683E79D0331_52BAD1C40174_impl*
//#UC START# *4683E79D0331_52BAD1C40174_var*
//#UC END# *4683E79D0331_52BAD1C40174_var*
//#UC START# *473DB05D033A_52BAD1C40174_impl*
 {$If defined(Nemesis) AND not defined(NoVCM)}
 f_PageDeactivated := True;
 {$IfEnd}
 DoActivate(False);
//#UC END# *473DB05D033A_52BAD1C40174_impl*
//#UC START# *473DB05D033A_52BAD1C40174_var*
//#UC END# *473DB05D033A_52BAD1C40174_var*
//#UC START# *473DB06A01A8_52BAD1C40174_impl*
 {$If defined(Nemesis) AND not defined(NoVCM)}
 f_PageDeactivated := False;
 {$IfEnd}
 DoActivate(True);
//#UC END# *473DB06A01A8_52BAD1C40174_impl*
//#UC START# *473DB06A01A8_52BAD1C40174_var*
//#UC END# *473DB06A01A8_52BAD1C40174_var*
//#UC START# *473DB083030D_52BAD1C40174get_impl*
 Result := 0;
//#UC END# *473DB083030D_52BAD1C40174get_impl*
//#UC START# *473DB083030D_52BAD1C40174get_var*
//#UC END# *473DB083030D_52BAD1C40174get_var*
//#UC START# *476965D302A1_52BAD1C40174_impl*
 if Assigned(f_Header) then
  f_Header.Size := aValue;
//#UC END# *476965D302A1_52BAD1C40174_impl*
//#UC START# *476965D302A1_52BAD1C40174_var*
//#UC END# *476965D302A1_52BAD1C40174_var*
//#UC START# *478CF34E02CE_52BAD1C40174_impl*
 if (Source is TvtNavigator) then
  AssignNav(TvtNavigatorPrim(Source))
 else
  inherited;
//#UC END# *478CF34E02CE_52BAD1C40174_impl*
//#UC START# *478CF34E02CE_52BAD1C40174_var*
//#UC END# *478CF34E02CE_52BAD1C40174_var*
//#UC START# *479731C50290_52BAD1C40174_impl*
 TnpNavigatorList.Instance.UnReg(Self);
 DoSaveSize;

 if f_Float then
 begin
  f_FloatNavigator.f_Navigator := nil;
  PostMessage(f_ParentNavigatorHandle, CM_npDeleteFromList,
   Integer(Pointer(f_FloatNavigator)), 0);
 end;//f_Float
 l3Free(f_NavigatorList);
 FreeAndNil(f_TimerDelay);
 FreeAndNil(f_TimerFloat);

 if (f_Header <> nil) then
 begin
  if (f_Header.Navigator <> nil) then
  begin
   Assert(f_Header.Navigator = Self);
   Self.UnRegisterStateChanged(f_Header.f_Link);
   f_Header.Navigator := nil;
  end;//f_Header.Navigator <> nil
 end;//f_Header <> nil
 FreeAndNil(f_Header);

 inherited;
//#UC END# *479731C50290_52BAD1C40174_impl*
//#UC START# *479731C50290_52BAD1C40174_var*
//#UC END# *479731C50290_52BAD1C40174_var*
//#UC START# *47CFAAC70224_52BAD1C40174_impl*
 l_Class := TvtNavigatorForm.Create(aCloseHandler);
 try
  TvtNavigatorFormList.Instance.Add(l_Class);
  aCloseHandler.Form.FreeNotification(Self);
 finally
  FreeAndNil(l_Class);
 end;//try..finally
 UpdateCloseButton;
//#UC END# *47CFAAC70224_52BAD1C40174_impl*
//#UC START# *47CFAAC70224_52BAD1C40174_var*
var
 l_Class: TvtNavigatorForm;
//#UC END# *47CFAAC70224_52BAD1C40174_var*
//#UC START# *47D1602000C6_52BAD1C40174_impl*
 inherited Create(AOwner);
 f_NavigatorList := Tl3ObjectList.Create;
 (* Зарегистрируемся *)
 TnpNavigatorList.Instance.Reg(Self);
 (* Главная форма, которой принадлежит навигатор *)
 InitMainForm(AOwner);
 (* interited *)
 Width := cInitSize;
 if not (csDesigning in ComponentState) then
  BevelOuter := bvNone;
 DockSite := True;
 (* self *)
 f_SizeMini := -1;
 f_CountUndock := 0;
 f_HideDirect := hdNone;
 f_ChangeLinks := Tl3ObjectList.Create;
 f_State := nsNormal;
 f_IsFloatingOnShow := False;
 f_IsInitDockDrop := False;
 f_ShowActivePageInHeader := True;
 f_UnDockFromFloat := True;
 f_SingleFloatNavigator := True;
 f_SetCursorResize := False;
 f_SizeEmpty := cInitSize;
 f_SizeNormal := cDefaultNormalSize;
 f_Swim := True;
 f_IsDelay := False;
 f_DoDelay := False;
 f_DelayIntervalOnShow := 0;
 f_DelayIntervalOnHide := 1000;
 f_DelayOnAutoHide := False;
 f_TimerDelay := TTimer.Create(Self);
 f_TimerDelay.Enabled := False;
 f_TimerDelay.OnTimer := OnTimerDelay;
 f_AutoHideFloat := False;
 f_TimerFloat := TTimer.Create(Self);
 f_TimerFloat.Enabled := False;
 f_TimerFloat.Interval := 1;
 f_TimerFloat.OnTimer := OnTimerFloat;
 (* TnpSurface *)
 CreateSurface;
 (* TnpHeader *)
 CreateHeader;
 (* TnpPageControl *)
 CreatePageControl;
 (* Необходимо устанавливать здесь, потому, что в SetAlign используются
    TnpHeader, TnpPageControl *)
 Align := alLeft;
 f_CloseHint := str_vtBtnCloseHint.AsStr;
 f_AutoHideOffHint := str_vtAutoHideOffHint.AsStr;
 f_AutoHideOnHint := str_vtAutoHideOnHint.AsStr;
 f_MinimizedOffHint := str_vtMinimizedOffHint.AsStr;
 f_MinimizedOnHint := str_vtMinimizedOnHint.AsStr;
 f_FormWasMinimized := False;
//#UC END# *47D1602000C6_52BAD1C40174_impl*
//#UC START# *47D1602000C6_52BAD1C40174_var*
//#UC END# *47D1602000C6_52BAD1C40174_var*
//#UC START# *4CC8417A0288_52BAD1C40174_impl*
 inherited Resize;
 if not f_Float then
  PlaceSurface
 else
  f_SizeNormal := f_FloatNavigator.Width;
//#UC END# *4CC8417A0288_52BAD1C40174_impl*
//#UC START# *4CC8417A0288_52BAD1C40174_var*
//#UC END# *4CC8417A0288_52BAD1C40174_var*
//#UC START# *4F2A599E0283_52BAD1C40174_impl*
 {$IfDef DesignTimeLibrary}
 if Align = alNone then
  inherited
 else
 begin
  case Align of
   alLeft, alRight: AWidth := 20;
   alTop, alBottom: AHeight := 20;
  end;
  inherited;
 end;//case Align
 {$Else DesignTimeLibrary}
 (* Нельзя устанавливать навигатору без закладок ширину (высоту) больше
    f_SizeEmpty. Это может происходить в результате чтения размеров компонента из
    настроек *)
 if not Assigned(f_PageControl) or (f_PageControl.PageCount = 0) then
 begin
  case Align of
   alBottom, alTop:
    begin
     if (AHeight <= f_SizeEmpty) or (AHeight = SizeMini) then
      inherited
     else
      inherited SetBounds(ALeft, ATop, AWidth, Height);
    end;//alBottom, alTop
   alLeft, alRight:
    begin
     if (AWidth <= f_SizeEmpty) or (AWidth = SizeMini) then
      inherited
     else
      inherited SetBounds(ALeft, ATop, Width, AHeight);
    end;//alLeft, alRight
   else
    inherited;
  end;//case Align
  Exit;
 end;//not Assigned(f_PageControl) or (f_PageControl.PageCount = 0)
 inherited;
 {$EndIf DesignTimeLibrary}
//#UC END# *4F2A599E0283_52BAD1C40174_impl*
//#UC START# *4F2A599E0283_52BAD1C40174_var*
//#UC END# *4F2A599E0283_52BAD1C40174_var*
//#UC START# *4F71E1460089_52BAD1C40174_impl*
 inherited;
 DoNotifyControls(Self, CM_npTabPositionChanged, 0, 0);
//#UC END# *4F71E1460089_52BAD1C40174_impl*
//#UC START# *4F71E1460089_52BAD1C40174_var*
//#UC END# *4F71E1460089_52BAD1C40174_var*
//#UC START# *4F884378016A_52BAD1C40174_impl*
 inherited Notification(aComponent, Operation);
 if (Operation = opRemove) then
 begin
  if TvtNavigatorFormList.Instance.FindData(TvtFormHandlerID_C(aComponent), l_Item) then
  begin
   AComponent.RemoveFreeNotification(Self);
   TvtNavigatorFormList.Instance.Delete(l_Item);
   UpdateCloseButton;
  end;//if TvtNavigatorFormList.Instance.FindData(l_Form, l_Item) then
 end;//if (Operation = opRemove) then
//#UC END# *4F884378016A_52BAD1C40174_impl*
//#UC START# *4F884378016A_52BAD1C40174_var*
var
 l_Item : Integer;
//#UC END# *4F884378016A_52BAD1C40174_var*
//#UC START# *4F8851380274_52BAD1C40174_impl*
 lImageIndex := -1;
 lIsEmpty := f_PageControl.PageCount = 0;
 f_IsInitDockDrop := False;
 if ((f_ImportNavigator <> nil) and (f_ImportNavigator <> Self)) or
  (f_ImportNavigator = nil) and CheckControl(Source.Control) then
 begin
  if Source.Control.Parent is TElTabSheet then
   lImageIndex := TElTabSheet(Source.Control.Parent).ImageIndex;
  if (f_PageControl.PageCount = 0) then
   f_SizeNormal := GetNavigatorSizeNormal(Source.Control);
  //f_PageControl.DockDrop(Source, X, Y);
  inherited DockDrop(Source, X, Y);
  MovePagesToNavigator(f_ImportNavigator, Source.Control);
  if Source.Control.Parent is TElTabSheet then
   TElTabSheet(Source.Control.Parent).ImageIndex := lImageIndex;
  if Source.Control.Visible then
   InitDockDrop;
 end;//((f_ImportNavigator <> nil) and (f_ImportNavigator <> Self))
 (* сбрасываем значения f_SizeNormal, которые были установлены навигатору до
    появления закладок в SetBounds, чтобы при нормализации он не был
    равен свернутому состоянию *)
 if (f_PageControl.PageCount = 1) and (f_State = nsMinimized) and (not f_SizeNormalLoaded) then
  f_SizeNormal := cDefaultNormalSize;
 // http://mdp.garant.ru/pages/viewpage.action?pageId=622830691
 UpdateState;
 {$IfDef Nemesis}
 if f_Float then
  f_FloatNavigator.UpdateFloatWindowsBounds;
 {$EndIf Nemesis}
 (* Обработчик отстыковки *)
 if lIsEmpty and not Assigned(f_PageControl.OnUnDock) then
  f_PageControl.OnUnDock := OnPageControlUnDock;
 (* не заслоняем компоненты, которые лежат в этом же месте *)
 if lIsEmpty and (f_PageControl.PageCount > 0) then
  PostMessage(Handle, CM_npDoActionWithFormControls, Ord(acUpInZOrder), 0);
//#UC END# *4F8851380274_52BAD1C40174_impl*
//#UC START# *4F8851380274_52BAD1C40174_var*
var
 lImageIndex : Integer;
 lIsEmpty    : Boolean;
//#UC END# *4F8851380274_52BAD1C40174_var*
//#UC START# *50FD32F103CA_52BAD1C40174_impl*
 inherited DockOver(Source, X, Y, State, Accept);
 Accept := f_Activate;
 if Accept then
 begin
  SetDockRect(Source);
  Accept := True;
 end;//Accept
//#UC END# *50FD32F103CA_52BAD1C40174_impl*
//#UC START# *50FD32F103CA_52BAD1C40174_var*
 procedure pm_SetSizeNormal;
 var
  lParent: TWinControl;
  lNavigator: TvtNavigator;
 begin//pm_SetSizeNormal
  lNavigator := nil;

  if f_PageControl.PageCount = 0 then
  begin
   lParent := Source.Control.Parent;
   while (lNavigator = nil) and (lParent <> nil) do
    if lParent is TvtNavigator then
      lNavigator := lParent as TvtNavigator
    else
      lParent := lParent.Parent;
  end;

  if lNavigator <> nil then
   f_SizeNormal := lNavigator.SizeNormal;
 end;//pm_SetSizeNormal
//#UC END# *50FD32F103CA_52BAD1C40174_var*
//#UC START# *52B9A6A80336_52BAD1C40174_impl*
 CanDock := f_Activate;
 if CanDock then
 begin
  inherited GetSiteInfo(Client, InfluenceRect, MousePos, CanDock);
  if (f_PageControl.PageCount = 0) and CanDock then
   InfluenceRect := GetDockRect;
 end;//CanDock
//#UC END# *52B9A6A80336_52BAD1C40174_impl*
//#UC START# *52B9A6A80336_52BAD1C40174_var*
//#UC END# *52B9A6A80336_52BAD1C40174_var*
//#UC START# *52BAD1C40174_ext:ParentFileName
w:\common\components\gui\Garant\VT\vtNavigator.pas
//#UC END# *52BAD1C40174_ext:ParentFileName
//#UC START# *52BAD30B01CD_52BAD1C40174_impl*
 l_Activate := Boolean(Message.WParam);
 if l_Activate then
 begin
  if {$If defined(Nemesis) AND not defined(NoVCM)} f_PageDeactivated or {$IfEnd}
    ((f_FloatNavigator <> nil) AND f_FloatNavigator.f_ReactivateDisabled) then
   Exit;
 end;
 Activate := l_Activate;
//#UC END# *52BAD30B01CD_52BAD1C40174_impl*
//#UC START# *52BAD30B01CD_52BAD1C40174_var*
var
 l_Activate : Boolean;
//#UC END# *52BAD30B01CD_52BAD1C40174_var*
//#UC START# *52BAD3540031_52BAD1C40174_impl*
 ModeStateUpdate;
//#UC END# *52BAD3540031_52BAD1C40174_impl*
//#UC START# *52BAD3540031_52BAD1C40174_var*
//#UC END# *52BAD3540031_52BAD1C40174_var*
//#UC START# *52BAD36C00B4_52BAD1C40174_impl*
 DelNavigator(Pointer(Message.wParam));
//#UC END# *52BAD36C00B4_52BAD1C40174_impl*
//#UC START# *52BAD36C00B4_52BAD1C40174_var*
//#UC END# *52BAD36C00B4_52BAD1C40174_var*
//#UC START# *52BAD37C031A_52BAD1C40174_impl*
 for l_Index := Pred(Parent.ControlCount) downto 0 do
 begin
  l_Control := Parent.Controls[l_Index];
  if not (l_Control is TvtNavigator)and not (l_Control is TnpSurface) and
   (l_Control.Align = alNone) then
   case TnpDoActionWithFormControl(Message.WParam) of
    acRedraw:
     if l_Control is TWinControl then
      Windows.RedrawWindow(TWinControl(l_Control).Handle, nil, 0,
       RDW_FRAME or RDW_INVALIDATE or RDW_INTERNALPAINT);
    acUpInZOrder:
     l_Control.BringToFront;
   end;//case TnpDoActionWithFormControl(Message.WParam) of
 end;//for l_Index := Pred(Parent.ControlCount) downto 0 do
//#UC END# *52BAD37C031A_52BAD1C40174_impl*
//#UC START# *52BAD37C031A_52BAD1C40174_var*
var
 l_Index   : Integer;
 l_Control : TControl;
//#UC END# *52BAD37C031A_52BAD1C40174_var*
//#UC START# *52BAD3E80090_52BAD1C40174_impl*
 if (Message.WParam > 0) and (not (csDestroying in ComponentState)) then
 begin
  l_Control := TControl(Message.WParam);
  l_Float := DockToFloatNavigator(l_Control);
  // ни к кому не пристыковали, такого не может быть
  Assert(Assigned(l_Float));
  {$IfDef Nemesis}
  // если форму пристыковали к уже существующему навигатору, то нужно обновить
  // FloatWindowBounds
  if (l_Control is TvcmForm) then
   TvcmForm(l_Control).FloatWindowBounds := l_Float.BoundsRect;
  {$EndIf Nemesis}
 end;//(Message.WParam > 0) and (not (csDestroying in ComponentState))
//#UC END# *52BAD3E80090_52BAD1C40174_impl*
//#UC START# *52BAD3E80090_52BAD1C40174_var*
var
 l_Control : TControl;
 l_Float   : TnpFloatingWindow;
//#UC END# *52BAD3E80090_52BAD1C40174_var*
//#UC START# *52BAD43803E3_52BAD1C40174_impl*
 Message.Result := 1;
//#UC END# *52BAD43803E3_52BAD1C40174_impl*
//#UC START# *52BAD43803E3_52BAD1C40174_var*
//#UC END# *52BAD43803E3_52BAD1C40174_var*
//#UC START# *52BC212F023F_52BAD1C40174_impl*
 inherited SetName(aValue);
 if Assigned(f_PageControl) then
  f_PageControl.Name := aValue;
//#UC END# *52BC212F023F_52BAD1C40174_impl*
//#UC START# *52BC212F023F_52BAD1C40174_var*
//#UC END# *52BC212F023F_52BAD1C40174_var*
//#UC START# *52BC260803B0_52BAD1C40174_impl*
 if (f_PageControl.PageCount = 0) or (State = nsAutoHide) then
 begin
  l_Rect := GetDockRect;
  if PtInRect(l_Rect, DragDockObject.DragPos) then
  begin
   SetDockRect(DragDockObject);
   Exit;
  end;//PtInRect(l_Rect, DragDockObject.DragPos)
 end;//(f_PageControl.PageCount = 0) or (State = nsAutoHide)
 inherited PositionDockRect(DragDockObject);
//#UC END# *52BC260803B0_52BAD1C40174_impl*
//#UC START# *52BC260803B0_52BAD1C40174_var*
var
 l_Rect : TRect;
//#UC END# *52BC260803B0_52BAD1C40174_var*
//#UC START# *52BC2B9401F3_52BAD1C40174_impl*
 (* f_ChangeLinks удаляем после всех, потому, что в Inherited-е компоненты
    описывается от нотификации *)
 l3Free(f_ChangeLinks);
 inherited;
//#UC END# *52BC2B9401F3_52BAD1C40174_impl*
//#UC START# *52BC2B9401F3_52BAD1C40174_var*
//#UC END# *52BC2B9401F3_52BAD1C40174_var*
//#UC START# *52BC2DA80151_52BAD1C40174get_impl*
 if not Assigned(f_RelativeNavigator) then
  f_RelativeNavigator := FindRelative(RelativeAlign);
 Result := f_RelativeNavigator;
//#UC END# *52BC2DA80151_52BAD1C40174get_impl*
//#UC START# *52BC2DA80151_52BAD1C40174get_var*
//#UC END# *52BC2DA80151_52BAD1C40174get_var*
//#UC START# *52BC2DE7032A_52BAD1C40174get_impl*
 Result := nil;
 if Assigned(Parent) then
  for l_Index := 0 to Pred(Parent.ControlCount) do
   if Parent.Controls[l_Index] is TWinControl then
    with TWinControl(Parent.Controls[l_Index]) do
     if (Align = alClient) then
     begin
      Result := TWinControl(Parent.Controls[l_Index]);
      Break;
     end;//if (Align = alClient) then
//#UC END# *52BC2DE7032A_52BAD1C40174get_impl*
//#UC START# *52BC2DE7032A_52BAD1C40174get_var*
var
 l_Index: Integer;
//#UC END# *52BC2DE7032A_52BAD1C40174get_var*
//#UC START# *52BC2E2D011E_52BAD1C40174get_impl*
 Result := 0;
 if (f_SizeMini > -1) and (f_PageControl.PageCount > 0) then
 begin
  Result := f_SizeMini;
  Exit;
 end;
 with TnpPageControl(f_PageControl) do
 begin
  if (PageCount > 0) then
  begin
   // иначе не посчитается область закладок в CalcTabAreaSize, потому что ни
   // одна закладка не видима
   if (PageCount = 1) and not Pages[0].TabVisible then
    Pages[0].TabVisible := True;
   lSize := f_PageControl.MaxTabHeight + 20;
   // клиентская область, формы
   lRect := Rect(0, 0, lSize, lSize);
   AdjustClientRect(lRect);
   // область закладок
   case TabPosition of
    etpTop: Result := lRect.Top;
    etpBottom: Result := lSize - lRect.Bottom;
    etpLeft: Result := lRect.Left;
    etpRight: Result := lSize - lRect.Right;
   end;//case TabPosition
   // добавим ширину сплиттера, у плавающего навигатора сплиттер отсутствует,
   // его не учитываем
   if not f_Navigator.Float then
    Inc(Result, cspSize);
   // кешируем результат
   f_SizeMini := Result;
  end;//PageCount > 0
 end;//with TnpPageControl(f_PageControl)
//#UC END# *52BC2E2D011E_52BAD1C40174get_impl*
//#UC START# *52BC2E2D011E_52BAD1C40174get_var*
var
 lRect : TRect;
 lSize : Integer;
//#UC END# *52BC2E2D011E_52BAD1C40174get_var*
//#UC START# *52BC2E6203D8_52BAD1C40174set_impl*
 f_Swim := aValue;
 DoStateChanged;
//#UC END# *52BC2E6203D8_52BAD1C40174set_impl*
//#UC START# *52BC2E6203D8_52BAD1C40174set_var*
//#UC END# *52BC2E6203D8_52BAD1C40174set_var*
//#UC START# *52BC2E81013F_52BAD1C40174set_impl*
 if f_Activate <> aValue then
 begin
  // Не показываем навигатор, если окно минизированно
  if aValue and npIsWindowMinimized(f_MainForm) then
   Exit;
  f_Activate := aValue;
  if f_Float then
  begin
   case aValue of
    True:
     SetWindowPos(f_FloatNavigator.Handle, HWND_TOPMOST, 0, 0, 0, 0,
      SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or SWP_SHOWWINDOW);
    False:
     SetWindowPos(f_FloatNavigator.Handle, 0, 0, 0, 0, 0,
      SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or SWP_HIDEWINDOW);
   end;
   f_FloatNavigator.Visible := aValue;
   // - иначе огребаем рассинхронизацию
//   {$IfDef vtNavUseDebugLog}
//   l3System.Msg2Log(Format('NAV NavigatorActivate = %d', [Integer(Value)]));
//   {$EndIf vtNavUseDebugLog}
  end
  else
  if not f_Activate then
   f_Surface.f_Splitter.splHideHint;
 end;
//#UC END# *52BC2E81013F_52BAD1C40174set_impl*
//#UC START# *52BC2E81013F_52BAD1C40174set_var*
//#UC END# *52BC2E81013F_52BAD1C40174set_var*
//#UC START# *52BC2F7A018F_52BAD1C40174get_impl*
 Result := f_State = nsMinimized;
//#UC END# *52BC2F7A018F_52BAD1C40174get_impl*
//#UC START# *52BC2F7A018F_52BAD1C40174get_var*
//#UC END# *52BC2F7A018F_52BAD1C40174get_var*
//#UC START# *52BC2FAA0390_52BAD1C40174get_impl*
 Result := f_PageControl.Pages[anIndex];
//#UC END# *52BC2FAA0390_52BAD1C40174get_impl*
//#UC START# *52BC2FAA0390_52BAD1C40174get_var*
//#UC END# *52BC2FAA0390_52BAD1C40174get_var*
//#UC START# *52BC2FFB0208_52BAD1C40174get_impl*
 Result := f_PageControl.ActivePageIndex;
//#UC END# *52BC2FFB0208_52BAD1C40174get_impl*
//#UC START# *52BC2FFB0208_52BAD1C40174get_var*
//#UC END# *52BC2FFB0208_52BAD1C40174get_var*
//#UC START# *52BC2FFB0208_52BAD1C40174set_impl*
 f_PageControl.ActivePageIndex := aValue;
//#UC END# *52BC2FFB0208_52BAD1C40174set_impl*
//#UC START# *52BC2FFB0208_52BAD1C40174set_var*
//#UC END# *52BC2FFB0208_52BAD1C40174set_var*
//#UC START# *52BC303702E2_52BAD1C40174get_impl*
 Result := f_PageControl.PageCount;
//#UC END# *52BC303702E2_52BAD1C40174get_impl*
//#UC START# *52BC303702E2_52BAD1C40174get_var*
//#UC END# *52BC303702E2_52BAD1C40174get_var*
//#UC START# *52BC3164027D_52BAD1C40174set_impl*
 f_Float := aValue;
 DoStateChanged;
//#UC END# *52BC3164027D_52BAD1C40174set_impl*
//#UC START# *52BC3164027D_52BAD1C40174set_var*
//#UC END# *52BC3164027D_52BAD1C40174set_var*
//#UC START# *52BC31BA023D_52BAD1C40174get_impl*
 Result := f_State;
//#UC END# *52BC31BA023D_52BAD1C40174get_impl*
//#UC START# *52BC31BA023D_52BAD1C40174get_var*
//#UC END# *52BC31BA023D_52BAD1C40174get_var*
//#UC START# *52BC31BA023D_52BAD1C40174set_impl*
 if (aValue <> f_State) then
 begin
  if (f_State = nsAutoHide) then
  begin
   f_TimerFloat.Enabled := False;
   f_TimerDelay.Enabled := False;
  end;//f_State = nsAutoHide
  f_State := aValue;
  // При открытии приложения изначально панели должны быть скрыты в авторежиме:
  if f_State = nsAutoHide then
   f_TimerFloat.Enabled := True;
  UpdateState;
  DoStateChanged(True);
 end;//Value <> f_State
//#UC END# *52BC31BA023D_52BAD1C40174set_impl*
//#UC START# *52BC31BA023D_52BAD1C40174set_var*
//#UC END# *52BC31BA023D_52BAD1C40174set_var*
//#UC START# *52BC320E037B_52BAD1C40174set_impl*
 f_ShowActivePageInHeader := aValue;
 f_Header.Invalidate;
//#UC END# *52BC320E037B_52BAD1C40174set_impl*
//#UC START# *52BC320E037B_52BAD1C40174set_var*
//#UC END# *52BC320E037B_52BAD1C40174set_var*
//#UC START# *52BC32F601CAStored_52BAD1C40174_impl*
 Result := f_AutoHideOffHint <> str_cAutoHideOffHint.AsStr;
//#UC END# *52BC32F601CAStored_52BAD1C40174_impl*
//#UC START# *52BC32F601CAStored_52BAD1C40174_var*
//#UC END# *52BC32F601CAStored_52BAD1C40174_var*
//#UC START# *52BC334A00D3Stored_52BAD1C40174_impl*
 Result := f_AutoHideOnHint <> str_cAutoHideOnHint.AsStr;
//#UC END# *52BC334A00D3Stored_52BAD1C40174_impl*
//#UC START# *52BC334A00D3Stored_52BAD1C40174_var*
//#UC END# *52BC334A00D3Stored_52BAD1C40174_var*
//#UC START# *52BC33AF0000Stored_52BAD1C40174_impl*
 Result := f_MinimizedOnHint <> str_cMinimizedOnHint.AsStr;
//#UC END# *52BC33AF0000Stored_52BAD1C40174_impl*
//#UC START# *52BC33AF0000Stored_52BAD1C40174_var*
//#UC END# *52BC33AF0000Stored_52BAD1C40174_var*
//#UC START# *52BC33C5025EStored_52BAD1C40174_impl*
 Result := f_MinimizedOffHint <> str_cMinimizedOffHint.AsStr;
//#UC END# *52BC33C5025EStored_52BAD1C40174_impl*
//#UC START# *52BC33C5025EStored_52BAD1C40174_var*
//#UC END# *52BC33C5025EStored_52BAD1C40174_var*
//#UC START# *52BC33F802B6Stored_52BAD1C40174_impl*
 Result := f_CloseHint <> str_cCloseHint.AsStr;
//#UC END# *52BC33F802B6Stored_52BAD1C40174_impl*
//#UC START# *52BC33F802B6Stored_52BAD1C40174_var*
//#UC END# *52BC33F802B6Stored_52BAD1C40174_var*
//#UC START# *52BC350C00A3_52BAD1C40174get_impl*
 Result := f_PageControl.Images;
//#UC END# *52BC350C00A3_52BAD1C40174get_impl*
//#UC START# *52BC350C00A3_52BAD1C40174get_var*
//#UC END# *52BC350C00A3_52BAD1C40174get_var*
//#UC START# *52BC350C00A3_52BAD1C40174set_impl*
 f_PageControl.Images := aValue;
//#UC END# *52BC350C00A3_52BAD1C40174set_impl*
//#UC START# *52BC350C00A3_52BAD1C40174set_var*
//#UC END# *52BC350C00A3_52BAD1C40174set_var*
//#UC START# *52BC35CD014E_52BAD1C40174set_impl*
 if not aValue then
  f_TimerDelay.Enabled := False;
 f_DelayOnAutoHide := aValue;
 f_DoDelay := aValue;
//#UC END# *52BC35CD014E_52BAD1C40174set_impl*
//#UC START# *52BC35CD014E_52BAD1C40174set_var*
//#UC END# *52BC35CD014E_52BAD1C40174set_var*
//#UC START# *52BC360D034F_52BAD1C40174set_impl*
 f_SingleFloatNavigator := aValue;
//#UC END# *52BC360D034F_52BAD1C40174set_impl*
//#UC START# *52BC360D034F_52BAD1C40174set_var*
//#UC END# *52BC360D034F_52BAD1C40174set_var*
//#UC START# *52BC365D0137_52BAD1C40174get_impl*
 Result := inherited Align;
//#UC END# *52BC365D0137_52BAD1C40174get_impl*
//#UC START# *52BC365D0137_52BAD1C40174get_var*
//#UC END# *52BC365D0137_52BAD1C40174get_var*
//#UC START# *52BC365D0137_52BAD1C40174set_impl*
 if aValue <> Align then
 begin
  case aValue of
   alTop:
   begin
    inherited Align := aValue;
    f_Header.Align := alLeft;
    f_PageControl.TabPosition := etpTop;
   end;
   alLeft:
   begin
    inherited Align := aValue;
    f_Header.Align := alTop;
    f_PageControl.TabPosition := etpLeft;
   end;
   alRight:
   begin
    inherited Align := aValue;
    f_Header.Align := alTop;
    f_PageControl.TabPosition := etpRight;
   end;
   alBottom:
    begin
     inherited Align := aValue;
     f_Header.Align := alLeft;
     f_PageControl.TabPosition := etpBottom;
    end;
   else
    begin
     if not f_Float then
     begin
      inherited Align := alTop;
      f_Header.Align := alLeft;
     end
     else
     begin
      inherited Align := aValue;
      f_Header.Align := alTop;
     end;
     f_PageControl.TabPosition := etpTop;
    end;
  end;
  f_Surface.DefineSplitterAlign;
  f_Header.UpdateImages;
  ModeStateUpdate;
 end;//Value <> Align
//#UC END# *52BC365D0137_52BAD1C40174set_impl*
//#UC START# *52BC365D0137_52BAD1C40174set_var*
//#UC END# *52BC365D0137_52BAD1C40174set_var*
//#UC START# *52BC36B202C9_52BAD1C40174set_impl*
 f_SizeEmpty := aValue;
 AttachSurface;
 SetSize(aValue);
//#UC END# *52BC36B202C9_52BAD1C40174set_impl*
//#UC START# *52BC36B202C9_52BAD1C40174set_var*
//#UC END# *52BC36B202C9_52BAD1C40174set_var*
//#UC START# *52BC36FC016D_52BAD1C40174set_impl*
 f_SizeNormalLoaded := False;
 f_SizeNormal := aValue;
 (* Не закладок не нужно и размер устанавливать *)
 if not Assigned(f_PageControl) or (f_PageControl.PageCount = 0) then
  Exit;
 f_SizeNormal := CorrectSize(f_SizeNormal);
 //CheckSize(f_SizeNormal);
 (* AutoHide *)
 case f_State of
  nsAutoHide:
   lp_SetSize(f_Surface);
  nsNormal:
   lp_SetSize(Self);
 end;//case f_State of
 if (f_State = nsAutoHide) and (Align = alRight) then
  f_Surface.Left := Parent.ClientWidth - f_Surface.Width;
//#UC END# *52BC36FC016D_52BAD1C40174set_impl*
//#UC START# *52BC36FC016D_52BAD1C40174set_var*
 procedure lp_SetSize(aControl : TControl);
 begin
  case Self.Align of
   alTop, alBottom: aControl.Height := f_SizeNormal;
   alLeft, alRight: aControl.Width := f_SizeNormal;
  end;//case Self.Align of
 end;//lp_SetSize
//#UC END# *52BC36FC016D_52BAD1C40174set_var*
//#UC START# *52BC37B80233_52BAD1C40174get_impl*
 Result := f_Header.ButtonsImageList;
//#UC END# *52BC37B80233_52BAD1C40174get_impl*
//#UC START# *52BC37B80233_52BAD1C40174get_var*
//#UC END# *52BC37B80233_52BAD1C40174get_var*
//#UC START# *52BC37B80233_52BAD1C40174set_impl*
 f_Header.ButtonsImageList := aValue;
//#UC END# *52BC37B80233_52BAD1C40174set_impl*
//#UC START# *52BC37B80233_52BAD1C40174set_var*
//#UC END# *52BC37B80233_52BAD1C40174set_var*
//#UC START# *52BC38190127_52BAD1C40174get_impl*
 Result := f_Header.CloseImage;
//#UC END# *52BC38190127_52BAD1C40174get_impl*
//#UC START# *52BC38190127_52BAD1C40174get_var*
//#UC END# *52BC38190127_52BAD1C40174get_var*
//#UC START# *52BC38190127_52BAD1C40174set_impl*
 f_Header.CloseImage := aValue;
//#UC END# *52BC38190127_52BAD1C40174set_impl*
//#UC START# *52BC38190127_52BAD1C40174set_var*
//#UC END# *52BC38190127_52BAD1C40174set_var*
//#UC START# *52BC38290235_52BAD1C40174get_impl*
 Result := f_Header.AutoHideOnImage;
//#UC END# *52BC38290235_52BAD1C40174get_impl*
//#UC START# *52BC38290235_52BAD1C40174get_var*
//#UC END# *52BC38290235_52BAD1C40174get_var*
//#UC START# *52BC38290235_52BAD1C40174set_impl*
 f_Header.AutoHideOnImage := aValue;
//#UC END# *52BC38290235_52BAD1C40174set_impl*
//#UC START# *52BC38290235_52BAD1C40174set_var*
//#UC END# *52BC38290235_52BAD1C40174set_var*
//#UC START# *52BC38560093_52BAD1C40174get_impl*
 Result := f_Header.AutoHideOffImage;
//#UC END# *52BC38560093_52BAD1C40174get_impl*
//#UC START# *52BC38560093_52BAD1C40174get_var*
//#UC END# *52BC38560093_52BAD1C40174get_var*
//#UC START# *52BC38560093_52BAD1C40174set_impl*
 f_Header.AutoHideOffImage := aValue;
//#UC END# *52BC38560093_52BAD1C40174set_impl*
//#UC START# *52BC38560093_52BAD1C40174set_var*
//#UC END# *52BC38560093_52BAD1C40174set_var*
//#UC START# *52BC386603CA_52BAD1C40174get_impl*
 Result := f_Header.HideLeftImage;
//#UC END# *52BC386603CA_52BAD1C40174get_impl*
//#UC START# *52BC386603CA_52BAD1C40174get_var*
//#UC END# *52BC386603CA_52BAD1C40174get_var*
//#UC START# *52BC386603CA_52BAD1C40174set_impl*
 f_Header.HideLeftImage := aValue;
//#UC END# *52BC386603CA_52BAD1C40174set_impl*
//#UC START# *52BC386603CA_52BAD1C40174set_var*
//#UC END# *52BC386603CA_52BAD1C40174set_var*
//#UC START# *52BC38770142_52BAD1C40174get_impl*
 Result := f_Header.HideRightImage;
//#UC END# *52BC38770142_52BAD1C40174get_impl*
//#UC START# *52BC38770142_52BAD1C40174get_var*
//#UC END# *52BC38770142_52BAD1C40174get_var*
//#UC START# *52BC38770142_52BAD1C40174set_impl*
 f_Header.HideRightImage := aValue;
//#UC END# *52BC38770142_52BAD1C40174set_impl*
//#UC START# *52BC38770142_52BAD1C40174set_var*
//#UC END# *52BC38770142_52BAD1C40174set_var*
//#UC START# *52BC38840249_52BAD1C40174get_impl*
 Result := f_Header.HideUpImage;
//#UC END# *52BC38840249_52BAD1C40174get_impl*
//#UC START# *52BC38840249_52BAD1C40174get_var*
//#UC END# *52BC38840249_52BAD1C40174get_var*
//#UC START# *52BC38840249_52BAD1C40174set_impl*
 f_Header.HideUpImage := aValue;
//#UC END# *52BC38840249_52BAD1C40174set_impl*
//#UC START# *52BC38840249_52BAD1C40174set_var*
//#UC END# *52BC38840249_52BAD1C40174set_var*
//#UC START# *52BC38920251_52BAD1C40174get_impl*
 Result := f_Header.HideDownImage;
//#UC END# *52BC38920251_52BAD1C40174get_impl*
//#UC START# *52BC38920251_52BAD1C40174get_var*
//#UC END# *52BC38920251_52BAD1C40174get_var*
//#UC START# *52BC38920251_52BAD1C40174set_impl*
 f_Header.HideDownImage := aValue;
//#UC END# *52BC38920251_52BAD1C40174set_impl*
//#UC START# *52BC38920251_52BAD1C40174set_var*
//#UC END# *52BC38920251_52BAD1C40174set_var*
//#UC START# *52BD5F51022B_52BAD1C40174_impl*
 Result := aSizeNormal;
 with CorrectBounds(CalcBounds(aSizeNormal)) do
  case Self.Align of
   alLeft, alRight: Result := Right - Left;
   alTop, alBottom: Result := Bottom - Top;
  end;//case Self.Align
//#UC END# *52BD5F51022B_52BAD1C40174_impl*
//#UC START# *52BD5F51022B_52BAD1C40174_var*
//#UC END# *52BD5F51022B_52BAD1C40174_var*
//#UC START# *52BD5F720354_52BAD1C40174_impl*
 Result := alNone;
 case Self.Align of
  alLeft: Result := alRight;
  alRight: Result := alLeft;
  alTop: Result := alBottom;
  alBottom: Result := alTop;
 end;//case Self.Align of
//#UC END# *52BD5F720354_52BAD1C40174_impl*
//#UC START# *52BD5F720354_52BAD1C40174_var*
//#UC END# *52BD5F720354_52BAD1C40174_var*
//#UC START# *52BD5F9E0274_52BAD1C40174_impl*
 Result := nil;
 if Assigned(Parent) then
  with Parent do
   for l_Index := 0 to Pred(ControlCount) do
    if (Controls[l_Index] is TvtNavigator) and
     (Controls[l_Index].Align = aAlign) then
    begin
     Result := TvtNavigator(Controls[l_Index]); 
     Break;
    end;//if (Controls[l_Index] is TvtNavigator) and
//#UC END# *52BD5F9E0274_52BAD1C40174_impl*
//#UC START# *52BD5F9E0274_52BAD1C40174_var*
var
 l_Index: Integer;
//#UC END# *52BD5F9E0274_52BAD1C40174_var*
//#UC START# *52BD5FCF0121_52BAD1C40174_impl*
 Result := BoundsRect;
 case Align of
  alLeft: Result.Right := Result.Left + aSizeNormal;
  alRight: Result.Left := Result.Right - aSizeNormal;
  alTop: Result.Bottom := Result.Top + aSizeNormal;
  alBottom: Result.Top := Result.Bottom - aSizeNormal;
 end;//case Align of
//#UC END# *52BD5FCF0121_52BAD1C40174_impl*
//#UC START# *52BD5FCF0121_52BAD1C40174_var*
//#UC END# *52BD5FCF0121_52BAD1C40174_var*
//#UC START# *52BD5FEF0063_52BAD1C40174_impl*
 Result := 0;
 with aBounds do
  case Align of
   alLeft, alRight: Result := Right - Left;
   alTop, alBottom: Result := Bottom - Top;
  end;//case Align of
//#UC END# *52BD5FEF0063_52BAD1C40174_impl*
//#UC START# *52BD5FEF0063_52BAD1C40174_var*
//#UC END# *52BD5FEF0063_52BAD1C40174_var*
//#UC START# *52BD60180199_52BAD1C40174_impl*
 Result := aBounds;
 if Assigned(ClientControl) then
 begin
  l_CurrentSize := CalcSize(BoundsRect);
  l_NewSize := CalcSize(aBounds);
  if l_NewSize >= l_CurrentSize then
  begin
   lp_CorrectBounds;
   // Если при изменении размеров формы мы достигли минимального размера
   // навигатора, более уже ничего сделать нельзя
   if not ((l_NewSize = l_CurrentSize) and (f_SizeNormal = cMinNormalSize)) then
   begin
    lp_MinSize;
    lp_ConflictWithBusyRect;
   end;//if not ((l_NewSize = l_CurrentSize)
  end;//if l_NewSize >= l_CurrentSize then
 end;//if Assigned(l_Control) then
//#UC END# *52BD60180199_52BAD1C40174_impl*
//#UC START# *52BD60180199_52BAD1C40174_var*
 procedure lp_MinSize;
 {* - сожмем навигатор, занятой области он не оставил даже минимального
      пространства (cMinNormalSize + cMinClientControlSize).}
 var
  l_Rect   : TRect;
  l_Client : TRect;
  l_Size   : Integer;
 begin
  if Assigned(RelativeNavigator) then
  begin
   l_Size := cMinNormalSize + cMinClientControlSize;
   l_Rect := BoundsRect;
   l_Client := Parent.ClientRect;
   case Align of
    alLeft:
     begin
      if (l_Rect.Right > l_Client.Right - l_Size) and
       (Width > cMinNormalSize) then
      begin
       Width := l_Client.Right - l_Size - l_Rect.Left;
       Result.Right := l_Client.Right - l_Size;
      end;//if (l_Rect.Right > l_Client.Right - l_Size) and
     end;//alLeft
    alRight:
     begin
      if (l_Rect.Left < l_Client.Left + l_Size) and
       (Width > cMinNormalSize) then
      begin
       Width := l_Rect.Right - (l_Client.Left + l_Size);
       Result.Left := l_Client.Left + l_Size;
      end;//if (l_Rect.Left < l_Client.Left + l_Size) and
     end;//alRight
   end;//case Align of
  end;//if Assigned(RelativeNavigator) then
 end;//lp_CorrectAfterRestore

 procedure lp_ConflictWithBusyRect;
 {* - установим размер навигатора в зависимости от уже занятой области. }

  function BusyRectOnParent: TRect;
    {* - область занятая клиентским компонентом и навигатором. }
  var
   l_Control  : TWinControl;
   l_TempSize : Integer;
   l_Size     : Integer;
   l_Rect     : TRect;
  begin
   SetRectEmpty(Result);
   l_Control := ClientControl;
   if Assigned(l_Control) then
   begin
    Result := l_Control.BoundsRect;
    if Assigned(RelativeNavigator) then
    begin
     l_Size := cMinClientControlSize;
     l_Rect := RelativeNavigator.BoundsRect;
     l_TempSize := CalcSize(l_Rect);
     if l_TempSize < cMinNormalSize then
      l_TempSize := cMinNormalSize;
     Inc(l_Size, l_TempSize);
     case RelativeNavigator.Align of
      alLeft:
       begin
        Result.Left := l_Rect.Left;
        Result.Right := l_Rect.Left + l_Size;
       end;
      alRight:
       begin
        Result.Right := l_Rect.Right;
        Result.Left := l_Rect.Right - l_Size
       end;
      alTop:
       begin
        Result.Top := l_Rect.Top;
        Result.Bottom := l_Rect.Top - l_Size;
       end;
      alBottom:
       begin
        Result.Bottom := l_Rect.Bottom;
        Result.Top := l_Rect.Bottom - l_Size;
       end;
     end;//case RelativeNavigator of
    end//if Assigned(RelativeNavigator) then
    else
     case Self.Align of
      alLeft: Result.Left := Result.Right;
     else
      Assert(False);
     end;//Case Self.Align
   end;//if Assigned(l_Control) then
  end;//BusyRectOnParent

 var
  l_Rect: TRect;
 begin
  l_Rect := BusyRectOnParent;
  case Self.Align of
   alLeft:
    if Result.Right > l_Rect.Left then
     if Result.Left + cMinNormalSize > l_Rect.Left then
      Result.Right := Result.Left + cMinNormalSize
     else
      Result.Right := l_Rect.Left;
   alRight:
    if Result.Left < l_Rect.Right then
     if Result.Right - cMinNormalSize < l_Rect.Right then
      Result.Left := Result.Right - cMinNormalSize
     else
     Result.Left := l_Rect.Right;
   alTop:
    if Result.Bottom > l_Rect.Top then
     if Result.Top + cMinNormalSize > l_Rect.Top then
      Result.Bottom := Result.Top + cMinNormalSize
     else
      Result.Bottom := l_Rect.Top;
   alBottom:
    if Result.Top > l_Rect.Bottom then
     if Result.Bottom - cMinNormalSize > l_Rect.Bottom then
      Result.Top := Result.Bottom - cMinNormalSize
     else
     Result.Top := l_Rect.Bottom;
  end;//case Self.Align of
 end;//lp_ConflictWithBusyRect

 procedure lp_CorrectBounds;
 {* - если навигатор выходит за пределы то откорректируем. }
 var
  l_Rect   : TRect;
  l_Client : TRect;
 begin//lp_CorrectBounds
  l_Rect := BoundsRect;
  l_Client := Parent.ClientRect;
  case Align of
   alLeft:
    if l_Rect.Left < l_Client.Left then
    begin
     Windows.OffsetRect(l_Rect, l_Client.Left - l_Rect.Left, 0);
     BoundsRect := l_Rect;
    end;//if l_Rect.Left < l_Client.Left then
   alRight:
    if l_Rect.Right > l_Client.Right then
    begin
     Windows.OffsetRect(l_Rect, l_Client.Right - l_Rect.Right, 0);
     BoundsRect := l_Rect;
    end;//if l_Rect.Right > l_Client.Right then
   alTop:
    if l_Rect.Top < l_Client.Top then
    begin
     Windows.OffsetRect(l_Rect, 0, l_Client.Top - l_Rect.Top);
     BoundsRect := l_Rect;
    end;//if l_Rect.Top < l_Client.Top then
   alBottom:
    if l_Rect.Bottom > l_Client.Bottom then
    begin
     Windows.OffsetRect(l_Rect, 0, l_Client.Bottom - l_Rect.Bottom);
     BoundsRect := l_Rect;
    end;//if l_Rect.Top < l_Client.Top then
  end;//case RelativeNavigator.Align of
 end;//lp_CorrectBounds

var
 l_CurrentSize : Integer;
 l_NewSize     : Integer;
//#UC END# *52BD60180199_52BAD1C40174_var*
//#UC START# *52BD604900EC_52BAD1C40174_impl*
 if f_State = nsAutoHide then
  AutoUpdateSize
 else
  NormalUpdateSize;
//#UC END# *52BD604900EC_52BAD1C40174_impl*
//#UC START# *52BD604900EC_52BAD1C40174_var*
//#UC END# *52BD604900EC_52BAD1C40174_var*
//#UC START# *52BD60530301_52BAD1C40174_impl*
 // Размер
 if f_HideDirect = hdHide then
  lDelta := SizeMini
 else
  lDelta := SizeNormal;
 if Swim then
 begin
  // Текущий размер
  lBounds := f_Surface.BoundsRect;
  // Новый размер
  with lBounds do
   case Self.Align of
    alLeft: Right := Left + lDelta;
    alRight: Left := Right - lDelta;
    alTop: Bottom := Top + lDelta;
    alBottom: Top := Bottom - lDelta;
   end;//case Self.Align
  // Применим
  f_Surface.BoundsRect := lBounds;
 end//Swim
 else
  SetSelfSize(lDelta);
//#UC END# *52BD60530301_52BAD1C40174_impl*
//#UC START# *52BD60530301_52BAD1C40174_var*
var
 lDelta: Integer;
 lBounds: TRect;
//#UC END# *52BD60530301_52BAD1C40174_var*
//#UC START# *52BD60960071_52BAD1C40174_impl*
 f_Header.f_IsDragBegining := False;
 f_ClickOnTab := False;
//#UC END# *52BD60960071_52BAD1C40174_impl*
//#UC START# *52BD60960071_52BAD1C40174_var*
//#UC END# *52BD60960071_52BAD1C40174_var*
//#UC START# *52BD60BF0233_52BAD1C40174_impl*
 Assert(f_Header <> nil);
 Result := f_Header.f_IsDragBegining or (f_ClickOnTab and not f_DblClickUnDock);
//#UC END# *52BD60BF0233_52BAD1C40174_impl*
//#UC START# *52BD60BF0233_52BAD1C40174_var*
//#UC END# *52BD60BF0233_52BAD1C40174_var*
//#UC START# *52BD615702DB_52BAD1C40174_impl*
 f_DblClickUnDock := True;
 if f_Float then
 begin
  CanUnDock := False;
  TnpControlsList.Instance.DockOnForm(aControl);
  f_DblClickUnDock := False;
 end;//f_Float
//#UC END# *52BD615702DB_52BAD1C40174_impl*
//#UC START# *52BD615702DB_52BAD1C40174_var*
//#UC END# *52BD615702DB_52BAD1C40174_var*
//#UC START# *52BD619100C0_52BAD1C40174_impl*
 f_Surface := TnpSurface.Create(Self);
 with f_Surface do
 begin
  Navigator := Self;
  Parent := Self;
  Align := alClient;
 end;//with f_Surface
//#UC END# *52BD619100C0_52BAD1C40174_impl*
//#UC START# *52BD619100C0_52BAD1C40174_var*
//#UC END# *52BD619100C0_52BAD1C40174_var*
//#UC START# *52BD619A032E_52BAD1C40174_impl*
 f_Header := TnpHeader.Create(Self);
 f_Surface.Header := f_Header;
 f_Header.Navigator := Self;
 f_Header.Width := f_Header.Size;
 f_Header.OnUnDock := OnPageControlUnDock;
 f_Header.OnHide := OnHide;
 f_Header.OnAutoHide := OnAutoHide;
//#UC END# *52BD619A032E_52BAD1C40174_impl*
//#UC START# *52BD619A032E_52BAD1C40174_var*
//#UC END# *52BD619A032E_52BAD1C40174_var*
//#UC START# *52BD61A40323_52BAD1C40174_impl*
 f_PageControl := GetPageControlClass.Create(Self);
 f_Surface.PageControl := f_PageControl;
 with f_PageControl do
 begin
  Name := Self.Name;
  f_Navigator := Self;
  DockSite := True;
  Flat := True;
  OnUnDock := Self.OnPageControlUnDock;
  OnTabSheetClick := Self.OnTabSheetClick;
  OnChange := Self.OnPageControlChange;
  OnResize := Self.OnPageControlResize;
  DragPageControl := True;
  OnStartDragControl := Self.OnStartDragControl;
  OnDblClickUndock := Self.OnDblClickUndock;
 end;//with f_PageControl
//#UC END# *52BD61A40323_52BAD1C40174_impl*
//#UC START# *52BD61A40323_52BAD1C40174_var*
//#UC END# *52BD61A40323_52BAD1C40174_var*
//#UC START# *52BD61C202D9_52BAD1C40174_impl*
 lOwner := aOwner;
 while Assigned(lOwner) do
 begin
  if (lOwner.Owner = Application) and (lOwner is TCustomForm) then
  begin
   if (TCustomForm(lOwner).Parent = nil) then
   begin
    f_MainForm := TCustomForm(lOwner);
    Break;
   end
   else
   begin
    f_MainForm := lp_GetParentForm(TCustomForm(lOwner));
    {$If defined(Nemesis) AND not defined(NoVCM)}
    if Supports(f_MainForm, IafwMainFormContainer, l_ContainerForm) then
    try
     f_ParentMainForm := l_ContainerForm.CurrentMainForm;
    finally
     l_ContainerForm := nil;
    end
    else
     f_ParentMainForm := f_MainForm;
    {$IfEnd}
    // - http://mdp.garant.ru/pages/viewpage.action?pageId=596174840
    Break;
   end;
  end;//(lOwner.Owner = Application) and (lOwner is TCustomForm)
  lOwner := lOwner.Owner;
 end;//while Assigned(lOwner)
//#UC END# *52BD61C202D9_52BAD1C40174_impl*
//#UC START# *52BD61C202D9_52BAD1C40174_var*

 function lp_GetParentForm(aForm: TCustomForm): TCustomForm;
 var
  l_Control: TControl;
 begin
  Result := nil;
  l_Control := aForm;
  while (l_Control.Parent <> nil) do
  begin
   l_Control := l_Control.Parent;
   if (l_Control is TCustomForm) and (l_Control.Parent = nil) then
   begin
    Result := TCustomForm(l_Control);
    Break;
   end;
  end;
 end;

var
 lOwner : TComponent;
 l_ContainerForm: IafwMainFormContainer;
//#UC END# *52BD61C202D9_52BAD1C40174_var*
//#UC START# *52BD61E101FF_52BAD1C40174_impl*
 lWinPosInfo := BeginDeferWindowPos(1);
 try
  with f_Surface do
   DeferWindowPos(lWinPosInfo, Handle, 0, 0, 0, Width, Height, SWP_FRAMECHANGED);
 finally
  EndDeferWindowPos(lWinPosInfo);
 end;//try..finally
//#UC END# *52BD61E101FF_52BAD1C40174_impl*
//#UC START# *52BD61E101FF_52BAD1C40174_var*
var
 lWinPosInfo : Cardinal;
//#UC END# *52BD61E101FF_52BAD1C40174_var*
//#UC START# *52BD61F501E5_52BAD1C40174_impl*
 if not Assigned(aControl) then
  aControl := Self; 
 case Self.Align of
  alLeft, alRight: aControl.Width := aValue;
  alTop, alBottom: aControl.Height := aValue;
 end;//case Self.Align
//#UC END# *52BD61F501E5_52BAD1C40174_impl*
//#UC START# *52BD61F501E5_52BAD1C40174_var*
//#UC END# *52BD61F501E5_52BAD1C40174_var*
//#UC START# *52BD625A0013_52BAD1C40174_impl*
 with f_PageControl do
 begin
  f_Header.Visible := PageCount > 0;
  Visible := PageCount > 0;
 end;
 case f_State of
  nsAutoHide: DoAutoHide;
  nsMinimized:
   begin
    AttachSurface;
    Minimized;
   end;//Minimized
  nsNormal:
   begin
    AttachSurface;
    pm_SetSizeNormal(f_SizeNormal);
   end;//nsNormal
 end;//case f_State
 (* Пересчитаем размер клиентской области *)
 if f_State <> nsAutoHide then
  RecalcSize;
 UpdateCloseButton; 
//#UC END# *52BD625A0013_52BAD1C40174_impl*
//#UC START# *52BD625A0013_52BAD1C40174_var*
//#UC END# *52BD625A0013_52BAD1C40174_var*
//#UC START# *52BD627B0350_52BAD1C40174_impl*
 if State <> nsAutoHide then
  Exit;
 case Align of
  alBottom, alTop:
   begin
    f_Surface.Width := Width;
    if Align = alBottom then
     f_Surface.Top := Self.Parent.ClientHeight - f_Surface.Height
    else
     f_Surface.Top := Self.Top;
   end;//alBottom, alTop:
  alLeft, alRight:
   begin
    f_Surface.Top := Top;
    f_Surface.Height := Height;
    if Align = alRight then
     f_Surface.Left := Self.Parent.ClientWidth - f_Surface.Width;
   end;//alLeft, alRight:
 end;//case Align of
//#UC END# *52BD627B0350_52BAD1C40174_impl*
//#UC START# *52BD627B0350_52BAD1C40174_var*
var
 l_Left, l_Top, l_Width, l_Height: Integer;
//#UC END# *52BD627B0350_52BAD1C40174_var*
//#UC START# *52BD628801D8_52BAD1C40174_impl*
 with f_Surface do
 begin
  Parent := Self;
  Align := alClient;
 end;//with f_Surface do
//#UC END# *52BD628801D8_52BAD1C40174_impl*
//#UC START# *52BD628801D8_52BAD1C40174_var*
//#UC END# *52BD628801D8_52BAD1C40174_var*
//#UC START# *52BD62920263_52BAD1C40174_impl*
 with f_Surface do
 begin
  Align := alNone;
  Parent := Self.Parent;
  PlaceSurface;
 end;//with f_Surface do
 Perform(CM_npDoActionWithFormControls, Ord(acUpInZOrder), 0);
//#UC END# *52BD62920263_52BAD1C40174_impl*
//#UC START# *52BD62920263_52BAD1C40174_var*
//#UC END# *52BD62920263_52BAD1C40174_var*
//#UC START# *52BD629A02DA_52BAD1C40174_impl*
 SetSize(SizeMini);
//#UC END# *52BD629A02DA_52BAD1C40174_impl*
//#UC START# *52BD629A02DA_52BAD1C40174_var*
//#UC END# *52BD629A02DA_52BAD1C40174_var*
//#UC START# *52BD62A70122_52BAD1C40174_impl*
 if (f_PageControl.PageCount = 0) then
  Exit;
 f_TimerDelay.Enabled := True;
 f_HideDirect := hdHide;
 DetachSurface;
 with f_Surface do
 begin
  SetSizeMini;
  InitAutoHidePosition;
 end;//with f_Surface
 SetSizeMini;
//#UC END# *52BD62A70122_52BAD1C40174_impl*
//#UC START# *52BD62A70122_52BAD1C40174_var*
//#UC END# *52BD62A70122_52BAD1C40174_var*
//#UC START# *52BD62C20057_52BAD1C40174_impl*
 l_Height := 0;
 l_Width := 0;
 l_Cursor := Mouse.CursorPos;
 if IsUndockByUser then
 begin
  l_Left := l_Cursor.X - f_ClickPoint.X;
  l_Top := l_Cursor.Y - f_ClickPoint.Y;
 end//IsUndockByUser
 else
 begin
  Windows.GetWindowRect(Handle, l_Rect);
  l_Left := l_Rect.Left;
  l_Top := l_Rect.Top;
 end;//IsUndockByUser
 (* Сместим плавающий навигатор относительно навигатора на форме *)
 if f_DblClickUnDock or not IsUndockByUser then
 begin
  Inc(f_CountUndock);
  if f_CountUndock > 10 then
   f_CountUndock := 1;
  l_Dist := f_CountUndock * cMultiplier;
  l_Monitor := Screen.MonitorFromPoint(l_Cursor).BoundsRect;
  (* Сместим вверх или вниз *)
  if l_Top + l_Dist < l_Monitor.Bottom then
   Inc(l_Top, l_Dist)
  else
   Dec(l_Top, l_Dist);
  (* Для навигаторов справа, внизу сдвигаем рамку плавающего навигатора вверх,
     влево *)
  if Align in [alRight, alBottom] then
   l_Dist := -l_Dist;
  (* Сместим вправо или влево *)
  if l_Left + l_Dist < l_Monitor.Right then
   Inc(l_Left, l_Dist)
  else
   Dec(l_Left, l_Dist);
  f_DblClickUnDock := False;
 end;
 (* Размеры нового навигатора *)
 if f_Float then
  with f_FloatNavigator do
  begin
   l_Height := Height;
   l_Width := Width;
  end//with f_FloatNavigator
 else
 begin
  // Так нужно делать потому, что в режиме автоскрытия размеры меняются, а
  // размер рамки должен быть как у прикрепленного навигатора
  case Align of
   alLeft, alRight:
    begin
     l_Height := Height;
     l_Width := f_SizeNormal;
    end;//alLeft, alRight
   alTop, alBottom:
    begin
     l_Width := Width;
     l_Height := f_SizeNormal;
    end;//alTop, alBottom
  end;//case Align
 end;//f_Float
 (* Положение плавающего навигатора *)
 Result := Rect(l_Left, l_Top, l_Left + l_Width, l_Top  + l_Height);
//#UC END# *52BD62C20057_52BAD1C40174_impl*
//#UC START# *52BD62C20057_52BAD1C40174_var*
const
 cMultiplier = 20;
var
 l_Left    : Integer;
 l_Top     : Integer;
 l_Height  : Integer;
 l_Width   : Integer;
 l_Monitor : TRect;
 l_Cursor  : TPoint;
 l_Dist    : Integer;
 l_Rect    : TRect;
//#UC END# *52BD62C20057_52BAD1C40174_var*
//#UC START# *52BD62DB03DF_52BAD1C40174_impl*
 if (State = nsAutoHide) and (f_PageControl.PageCount > 0) then
  DragDockObject.DockRect := GetDockRect(f_SizeNormal)
 else
 if f_PageControl.PageCount = 0 then
  DragDockObject.DockRect := GetDockRect(GetNavigatorSizeNormal(DragDockObject.Control));
//#UC END# *52BD62DB03DF_52BAD1C40174_impl*
//#UC START# *52BD62DB03DF_52BAD1C40174_var*
//#UC END# *52BD62DB03DF_52BAD1C40174_var*
//#UC START# *52BD6318023E_52BAD1C40174_impl*
 { Получим размеры будущей формы }
 if f_Float then
  f_DockRect := f_FloatNavigator.BoundsRect
 else
  f_DockRect := GetDockRect(f_SizeNormal);

 { Навигатор может быть плавающим и его видимые размеры (размеры PageControl-а)
   больше чем сам TvtNavigator в связи с этим рассчитаем положение мышы,
   чтобы не зависеть от размеров TvtNavigator }
 f_ClickPoint.X := f_DockRect.Left - Mouse.CursorPos.X;
 f_ClickPoint.X := Abs(f_ClickPoint.X);
 f_ClickPoint.Y := f_DockRect.Top - Mouse.CursorPos.Y;
 f_ClickPoint.Y := Abs(f_ClickPoint.Y);
 { Размеры навигатора были получены в экранных координатах, пересчитаем }
 OffsetRect(f_DockRect, -f_DockRect.Left, -f_DockRect.Top);

 { Для отрисовки тени }
 {$IfDef Nemesis}
 if aControl is TvcmForm then
  TvcmForm(aControl).OnPositionDockRect := OnFormPositionDockRect;
 {$EndIf Nemesis}
//#UC END# *52BD6318023E_52BAD1C40174_impl*
//#UC START# *52BD6318023E_52BAD1C40174_var*
//#UC END# *52BD6318023E_52BAD1C40174_var*
//#UC START# *52BD634A02F3_52BAD1C40174_impl*
 l_Index := 0;
 Result := True;
 while Result and (l_Index <= Pred(f_PageControl.PageCount)) do
 begin
  if (f_PageControl.Pages[l_Index].ControlCount > 0) then
   Result := not (f_PageControl.Pages[l_Index].Controls[0] = aControl)
  else
   Result := True; 
  (* такой компонент уже есть, проверим его позицию *)
  if not Result then
   aControl.Align := alClient;
  Inc(l_Index);
 end;//while Result and (l_Index <= Pred(f_PageControl.PageCount))
//#UC END# *52BD634A02F3_52BAD1C40174_impl*
//#UC START# *52BD634A02F3_52BAD1C40174_var*
var
 l_Index: Integer;
//#UC END# *52BD634A02F3_52BAD1C40174_var*
//#UC START# *52BD63660252_52BAD1C40174_impl*
 Result := -1;
 if Assigned(f_OnLoadSize) then
 begin
  f_OnLoadSize(Self, Result);
  f_SizeNormalLoaded := True;
 end;
//#UC END# *52BD63660252_52BAD1C40174_impl*
//#UC START# *52BD63660252_52BAD1C40174_var*
//#UC END# *52BD63660252_52BAD1C40174_var*
//#UC START# *52BD637E01DC_52BAD1C40174_impl*
 Result := nil;
 Index := 0;
 while (Index <= Application.ComponentCount - 1) and (Result = nil) do
 begin
  if Application.Components[Index] is TnpFloatingWindow then
    Result := Application.Components[Index] as TnpFloatingWindow;
  Inc(Index);
 end;
//#UC END# *52BD637E01DC_52BAD1C40174_impl*
//#UC START# *52BD637E01DC_52BAD1C40174_var*
var
 Index: Integer;
//#UC END# *52BD637E01DC_52BAD1C40174_var*
//#UC START# *52BD640D0313_52BAD1C40174_impl*
 if (f_Header <> nil) then
 begin
  if (f_State <> nsMinimized) then
  begin
   with PageControl do
    if (ActivePage <> nil) and
       (ActivePage.ControlCount > 0) then
    begin
     if TvtNavigatorFormList.Instance.FindData(TvtFormHandlerID_C(ActivePage.Controls[0]), l_Index) then
      f_Header.ShowCloseButton(TvtNavigatorFormList.Instance.Items[l_Index].CloseHandler)
     else
      f_Header.HideCloseButton;
    end//if PageControl.ActivePage <> nil then
    else
     f_Header.HideCloseButton;
  end
  else
   f_Header.HideCloseButton;
  // - http://mdp.garant.ru/pages/viewpage.action?pageId=602933962 
 end;
//#UC END# *52BD640D0313_52BAD1C40174_impl*
//#UC START# *52BD640D0313_52BAD1C40174_var*
var
 l_Index : Integer;
//#UC END# *52BD640D0313_52BAD1C40174_var*
//#UC START# *52BD64230135_52BAD1C40174_impl*
 Result := BoundsRect;
 case Align of
  alLeft: Result.Right := X;
  alRight:
   begin
    Result.Left := X;
    (* После перетаскивания оставляем курсор в области сплиттера *)
    Dec(Result.Left, cspSize);
   end;
  alTop: Result.Bottom := Y;
  alBottom: Result.Top := Y;
 end;//case Align of
//#UC END# *52BD64230135_52BAD1C40174_impl*
//#UC START# *52BD64230135_52BAD1C40174_var*
//#UC END# *52BD64230135_52BAD1C40174_var*
//#UC START# *52BD644A002B_52BAD1C40174_impl*
 if (f_NavigatorList.IndexOf(P) = -1) then
  f_NavigatorList.Add(P);
//#UC END# *52BD644A002B_52BAD1C40174_impl*
//#UC START# *52BD644A002B_52BAD1C40174_var*
//#UC END# *52BD644A002B_52BAD1C40174_var*
//#UC START# *52BD645E0355_52BAD1C40174_impl*
 if f_State <> nsAutoHide then
  Exit;
 if (not f_Surface.f_Splitter.IsHideButtonDown or f_TimerFloat.Enabled) and
    (Self.Parent.Handle <> GetCapture) and
    (f_State <> nsMinimized) and
    not f_MouseDown and
    (f_PageControl.PageCount > 0) then
 begin
  if not f_IsDelay then
  begin
   if f_DoDelay and not ((f_HideDirect = hdHide) and (f_DelayIntervalOnShow = 0)) then
    OpenDelay
   else
   begin
    lSaveDirect := f_HideDirect;
    Windows.GetWindowRect(f_Surface.Handle, lRect);
    lIsNavigator := PtInRect(lRect, Mouse.CursorPos);
    if (f_HideDirect = hdShow) and not lIsNavigator then
     f_HideDirect := hdHide
    else
    if (f_HideDirect = hdHide) and lIsNavigator then
     f_HideDirect := hdShow;

    if lSaveDirect <> f_HideDirect then
     if f_AutoHideFloat then
     begin
      if f_HideDirect = hdShow then
       f_IsFloatingOnShow := True;
      f_TimerFloat.Enabled := True;
     end//f_AutoHideFloat
     else
      ModeAutoUpdate;
   end;//f_DoDelay and not ((f_HideDirect = hdHide) and (f_DelayIntervalOnShow = 0))
  end;//not f_IsDelay
 end//(not Surface.Splitter.IsHideButtonDown or f_TimerFloat.Enabled)
 else
 if f_AutoHideFloat then
  if not f_IsFloatingOnShow then
   f_TimerFloat.Enabled := False;
//#UC END# *52BD645E0355_52BAD1C40174_impl*
//#UC START# *52BD645E0355_52BAD1C40174_var*
const
  SizeSensitive = 6;
var
 lSaveDirect  : TnpHideDirect;
 lIsNavigator : Boolean;
 lRect        : TRect;
//#UC END# *52BD645E0355_52BAD1C40174_var*
//#UC START# *52BD64760236_52BAD1C40174_impl*
 f_TimerDelay.Enabled := False;
 f_IsDelay := False;
 f_DoDelay := False;
 AutoHideUpdate;
 f_DoDelay := True;
//#UC END# *52BD64760236_52BAD1C40174_impl*
//#UC START# *52BD64760236_52BAD1C40174_var*
//#UC END# *52BD64760236_52BAD1C40174_var*
//#UC START# *52BD64810357_52BAD1C40174_impl*
 Index := f_NavigatorList.IndexOf(P);
 if (Index <> -1) then
  f_NavigatorList.Delete(Index);
//#UC END# *52BD64810357_52BAD1C40174_impl*
//#UC START# *52BD64810357_52BAD1C40174_var*
var
 Index: Integer;
//#UC END# *52BD64810357_52BAD1C40174_var*
//#UC START# *52BD64B202A8_52BAD1C40174_impl*
 Result := nil;
 lIsCreate := False;
 if (aControl <> nil) then
 begin
  { Компонент был вытащен из плавающего навигатора и ни к кому не пристыкован }
  if f_DockInSelf then
    aControl.ManualDock(f_PageControl)
  { Новый плавающий }
  else
  begin
   { Один плавающий на всех }
   if f_SingleFloatNavigator then
     Result := FindFloatNavigator
   else
   { Пристыковываем к навигатору по идентификатору }
// !! временно задействовал
// !! проблема: при переключении конфигураций, если в обеих есть плавающие навигаторы
// !! в DockToExistsFloat форма дочится к _старому_(!) плавающему навигатору, который умрёт,
// !! когда до него долетит CM_RELEASE (он и не умер-то до сих пор потому, что сообщение
// !! в очереди
//
// !! выключил - зацикливание в каком-то специфическом случае. Видимо, проблему пристыковки
// !! надо как-то по-другому решать.
//   afw.ProcessMessages;
   if not IsUndockByUser and DockToExistsFloat(Result) then
    Exit;
   if (Result = nil) then
   begin
    Result := CreateNavigator;
    lIsCreate := True;
   end;//Result = nil
   f_ClickOnTab := False;
   if f_Header.f_IsDragBegining then
   begin
    f_Header.f_IsDragBegining := False;
    Result.f_Navigator.MovePagesToNavigator(Self, aControl);
   end//f_Header.f_IsDragBegining
   else
   begin
    aControl.ManualDock(Result.Navigator.PageControl);
    {$IfDef Nemesis}
    if (aControl Is TvcmEntityForm) then
     TvcmEntityForm(aControl).CheckFloatingVisibility;
    {$EndIf Nemesis}
   end;//f_Header.f_IsDragBegining
   { Новый навигатор }
   if lIsCreate then
   begin
    with Result do
    begin
     Constraints.MinHeight := f_Navigator.pm_GetSizeMini + f_Navigator.f_Header.Height;
     Constraints.MinWidth := Constraints.MinHeight * 2;
     with f_Navigator.f_PageControl.Pages[0].Controls[0] do
     begin
      UndockWidth := Result.Width;
      UndockHeight := Result.Height;
     end;//with f_Navigator.f_PageControl.Pages[0].Controls[0]
    end;//with Result
   end;//lIsCreate
  end;//f_DockInSelf
 end;//aControl <> nil
//#UC END# *52BD64B202A8_52BAD1C40174_impl*
//#UC START# *52BD64B202A8_52BAD1C40174_var*
var
  lIsCreate: Boolean;

  procedure SetFloatingSize(aNavigator : TnpFloatingWindow;
                            aControl   : TControl);
  var
   l_Parent : TControl;
  begin//SetFloatingSize
   aNavigator.Width := aControl.Width;
   aNavigator.Height := aControl.Height;
   l_Parent := aControl.Parent;
   while True do
   begin
    if not Assigned(l_Parent) then
     Break;
    if (l_Parent is TnpFloatingWindow) then
    begin
     aNavigator.Width := l_Parent.Width;
     aNavigator.Height := l_Parent.Height;
     Break;
    end;//l_Parent is TnpFloatingWindow
    l_Parent := l_Parent.Parent;
   end;//while True
  end;//SetFloatingSize

  function CreateNavigator : TnpFloatingWindow;
  var
   l_Owner : TComponent;
   l_Rect  : TRect;
   {$IfDef Nemesis}
   l_ParentForm: TCustomForm;
   {$EndIf Nemesis}
  begin//CreateNavigator
   SetRectEmpty(l_Rect);
   if f_Float then
    l_Owner := f_FloatNavigator.Owner
   else
    l_Owner := Self;
   Result := GetFloatingWindowClass.CreateNew(l_Owner);
   Result.Navigator.AssignNav(Self);
   SetFloatingSize(Result, aControl);
   with Result.f_Navigator do
   begin
    f_SingleFloatNavigator := Self.f_SingleFloatNavigator;
    f_UnDockFromFloat := Self.f_UnDockFromFloat;
    f_Header.Size := Self.f_Header.Size;
   end;//with Result.f_Navigator
   { Зарегистрируем плаващий навигатор }
   if f_Float then
   begin
    f_NavigatorOnForm.AddNavigator(Result);
    Result.f_Navigator.NavigatorOnForm := f_NavigatorOnForm;
   end//f_Float
   else
   begin
    AddNavigator(Result);
    Result.f_Navigator.NavigatorOnForm := Self;
   end;//f_Float
   {$IfDef Nemesis}
   if (aControl is TvcmForm) then
   begin
    { Определим идентификатор навигатора }
    if (TvcmForm(aControl).FloatID > 0) and not f_Float then
     Result.FloatID := TvcmForm(aControl).FloatID
    else
     Result.FloatID := RandomRange(1, 1000);
    // если закладку отстыковали не перетаскиванием, а по DblClick-у или
    // программно, то восстанавливаем размер плавающей формы
    if not IsUndockByUser then
     l_Rect := TvcmForm(aControl).FloatWindowBounds;
   end;
   {$EndIf Nemesis}
   { Положение нового навигатора }
   if IsRectEmpty(l_Rect) then
    l_Rect := CalcNewFloatBounds;

   // Проверяем не вылазием ли мы за границы видимой рабочей области экрана
   // http://mdp.garant.ru/pages/viewpage.action?pageId=331187752
   l_Rect := vcmUtils.vcmCheckWindowBounds(l_Rect);

   Result.BoundsRect := l_Rect;
   { Не показываем если пристыковали невидимый объект (см. CMDockNotification) }
   {$IfDef Nemesis}
   l_ParentForm := GetParentForm(Self);
   if (aControl Is TvcmEntityForm) then
    Result.Visible := aControl.Visible and
                      TvcmEntityForm(aControl).FloatingVisible and
                      (l_ParentForm <> nil) and
                      l_ParentForm.Visible
    // - http://mdp.garant.ru/pages/viewpage.action?pageId=587161831
   else
   {$EndIf Nemesis}
    Result.Visible := aControl.Visible;
   (* устанавливаем здесь, потому, что vcl умничает и в процедуре SetVisible
    устанавливает окно там, где находится главное окно приложения, а мы хотим
    там где отпустил пользователь *)
   Result.BoundsRect := l_Rect;
   {$IfDef Nemesis}
    { Состояние навигатора }
    if not IsUndockByUser and ((TvcmForm(aControl).FloatWindowState and
      cFloatMinimized) = cFloatMinimized) then
     Result.State := fwsMinimized;
   {$EndIf Nemesis}
  end;//CreateNavigator

  function DockToExistsFloat(var aFindingWindow : TnpFloatingWindow) : Boolean;
  {$IfDef Nemesis}
  var
   l_Index : Integer;
   lFloat : TnpFloatingWindow;
  {$EndIf Nemesis}
  begin//DockToExistsFloat
   Result := False;
   {$IfDef Nemesis}
   if (aControl is TvcmForm) and (TvcmForm(aControl).FloatID > 0) then
   begin
    for l_Index := 0 to Pred(TnpNavigatorList.Instance.Count) do
    begin
     if TvtNavigator(TnpNavigatorList.Instance[l_Index]).Float then
     begin
      lFloat := TvtNavigator(TnpNavigatorList.Instance[l_Index]).f_FloatNavigator;
      if (lFloat.FloatID  = TvcmForm(aControl).FloatID) and
       // Т.к. регистрируются навигаторы для всех главных окон выбираем только
       // те, которые принадлежат форме, от которой отстыковываем
       (lFloat.Navigator.f_MainForm = f_ParentMainForm) then
      begin
       Result := True;
       aFindingWindow := lFloat;
       aControl.ManualDock(lFloat.Navigator.PageControl);
       Break;
      end;//lFloat.FloatID  = TvcmForm(aControl).FloatID..
     end;//TvtNavigator(TnpNavigatorList.Instance[l_Index]).Float
    end;//for l_Index
   end;//(aControl is TvcmForm) and (TvcmForm(aControl).FloatID > 0)
   {$EndIf Nemesis}
  end;//DockToExistsFloat
//#UC END# *52BD64B202A8_52BAD1C40174_var*
//#UC START# *52BD64EC0294_52BAD1C40174_impl*
 if not f_Float then
 begin
  f_HideDirect := hdNone;
  if f_State = nsMinimized then
   ModeHide
  else
   ModeNormalUpdate;
 end;//not f_Float
//#UC END# *52BD64EC0294_52BAD1C40174_impl*
//#UC START# *52BD64EC0294_52BAD1C40174_var*
//#UC END# *52BD64EC0294_52BAD1C40174_var*
//#UC START# *52BD64F60307_52BAD1C40174_impl*
 if Assigned(f_OnSaveSize) then
  f_OnSaveSize(Self, f_SizeNormal);
//#UC END# *52BD64F60307_52BAD1C40174_impl*
//#UC START# *52BD64F60307_52BAD1C40174_var*
//#UC END# *52BD64F60307_52BAD1C40174_var*
//#UC START# *52BD65070210_52BAD1C40174_impl*
 l_DesktopHandle := GetDesktopWindow;
 l_DC := GetDCEx(l_DesktopHandle, 0, DCX_CACHE or DCX_LOCKWINDOWUPDATE);
 try
  l_Brush := TBrush.Create;
  try
   l_Brush.Bitmap := AllocPatternBitmap(clBlack, clWhite);
   l_OldBrush := SelectObject(l_DC, l_Brush.Handle);
   try
    with f_SplitterRect do
     PatBlt(l_DC, Left, Top, Right - Left, Bottom - Top, PATINVERT);
   finally
    SelectObject(l_DC, l_OldBrush);
   end;{try..finally}
  finally
   FreeAndNil(l_Brush);
  end;{try..finally}
 finally
  ReleaseDC(l_DesktopHandle, l_DC);
 end;{try..finally}
//#UC END# *52BD65070210_52BAD1C40174_impl*
//#UC START# *52BD65070210_52BAD1C40174_var*
var
 l_DC            : HDC;
 l_OldBrush      : HBrush;
 l_DesktopHandle : HWND;
 l_Brush         : TBrush;
//#UC END# *52BD65070210_52BAD1C40174_var*
//#UC START# *52BD653001BE_52BAD1C40174_impl*
 if not f_IsInitDockDrop then
 begin
  f_Header.Visible := True;
  if not f_Float then
   ModeStateUpdate;
  f_IsInitDockDrop := True;
 end;
//#UC END# *52BD653001BE_52BAD1C40174_impl*
//#UC START# *52BD653001BE_52BAD1C40174_var*
//#UC END# *52BD653001BE_52BAD1C40174_var*
//#UC START# *52BD656B01FB_52BAD1C40174_impl*
 if (f_State = nsAutoHide) then
 begin
  if (f_PageControl.DockClientCount = 0) then
  begin
   SetSizeMini;
   f_PageControl.Visible := False;
   f_Header.Visible := False;
  end//f_PageControl.DockClientCount = 0
  else
  if f_HideDirect = hdShow then
   ModeShow
  else
   ModeHide;
 end;//f_State = nsAutoHide
//#UC END# *52BD656B01FB_52BAD1C40174_impl*
//#UC START# *52BD656B01FB_52BAD1C40174_var*
//#UC END# *52BD656B01FB_52BAD1C40174_var*
//#UC START# *52BD6597029C_52BAD1C40174_impl*
 UpdateSize;
//#UC END# *52BD6597029C_52BAD1C40174_impl*
//#UC START# *52BD6597029C_52BAD1C40174_var*
//#UC END# *52BD6597029C_52BAD1C40174_var*
//#UC START# *52BD65A40367_52BAD1C40174_impl*
 if (f_PageControl.PageCount > 0) then
 begin
  if f_State = nsNormal then
  begin
   SetSelfSize(f_SizeNormal);
   f_PageControl.Visible := True;
   f_Header.Visible := True;
  end;
 end//f_PageControl.PageCount > 0
 else
 begin
  f_PageControl.Visible := False;
  f_Header.Visible := False;
  case Self.Align of
   alTop, alBottom:
    Self.Height := f_SizeEmpty;
   alLeft, alRight:
    Self.Width := f_SizeEmpty;
  end;//case Self.Align
 end;//f_PageControl.PageCount > 0
//#UC END# *52BD65A40367_52BAD1C40174_impl*
//#UC START# *52BD65A40367_52BAD1C40174_var*
//#UC END# *52BD65A40367_52BAD1C40174_var*
//#UC START# *52BD65DF01E3_52BAD1C40174_impl*
 case f_State of
  nsAutoHide:
   ModeAutoUpdate;
 else
  ModeNormalUpdate;
 end;//case f_State
//#UC END# *52BD65DF01E3_52BAD1C40174_impl*
//#UC START# *52BD65DF01E3_52BAD1C40174_var*
//#UC END# *52BD65DF01E3_52BAD1C40174_var*
//#UC START# *52BD661D0125_52BAD1C40174_impl*
 PostMessage(Handle, CM_npAfterUndock, 0, 0);
//#UC END# *52BD661D0125_52BAD1C40174_impl*
//#UC START# *52BD661D0125_52BAD1C40174_var*
//#UC END# *52BD661D0125_52BAD1C40174_var*
//#UC START# *52BD665B0244_52BAD1C40174_impl*
 if (Value <> nil) then
 begin
  Value.f_PageControl.OnUnDock := nil;
  try
   { Установим TElCustomPageControl.Images }
   if f_PageControl.Images <> nil then
     Value.Images := f_PageControl.Images;
   { Переместим в "TElCustomPageControl приемник" DockControl который пользователь тащит.
     Это не делается в цикле потому что в этот момент закладки на которой он
     был расположен уже нет }
   DoDockControl;
   { Идем по закладкам из одного PageControl в другой }
   Index := Pred(Value.f_PageControl.PageCount);
   while (Index >= 0) do
   begin
    if (Value.f_PageControl.Pages[0].ControlCount > 0) then
     l_DockControl := Value.f_PageControl.Pages[0].Controls[0]
    else
     l_DockControl := nil;
    if (l_DockControl = nil) then
     Value.f_PageControl.RemovePage(Value.f_PageControl.Pages[0])
    else
    begin
     { Запомним ImageIndex }
     l_ImageIndex := Value.f_PageControl.Pages[0].ImageIndex;
     if l_DockControl is TForm then
       TForm(l_DockControl).OnEndDock := nil;
     l_DockControl.ManualDock(f_PageControl);
     { Установим ImageIndex }
     if l_DockControl.Parent is TElTabSheet then
      TElTabSheet(l_DockControl.Parent).ImageIndex := l_ImageIndex;
    end;//l_DockControl <> nil
    Dec(Index);
   end;//Index >= 0
   Value.SetUndockSize;
   { Установим активную закладку }
   if Value.f_ActiveControl <> nil then
    if Value.f_ActiveControl = DockControl then
     f_PageControl.ActivePage := TElTabSheet(DockControl.Parent)
    else
     for Index := 0 to Pred(f_PageControl.PageCount) do
      if f_PageControl.Pages[Index].Controls[0] = Value.f_ActiveControl then
      begin
       f_PageControl.ActivePage := f_PageControl.Pages[Index];
       Exit;
      end;
  finally
   Value.f_PageControl.OnUnDock := Value.OnPageControlUnDock;
   with Value do
   begin
    ModeStateUpdateAfter;
    Value.f_Header.Visible := False;
   end;
   f_Header.Visible := True;
   Value := nil;
  end;
 end//Value <> nil
 else
  DoDockControl;
 ModeNormalUpdate;
 {$IfDef Nemesis}
 if f_Float and
   (f_FloatNavigator <> nil) then
  f_FloatNavigator.Visible := True;
 {$EndIf Nemesis} 
//#UC END# *52BD665B0244_52BAD1C40174_impl*
//#UC START# *52BD665B0244_52BAD1C40174_var*
 procedure DoDockControl;
 begin//DoDockControl
  if DockControl <> nil then
  begin
   if DockControl is TForm then
     TForm(DockControl).OnEndDock := nil;
   DockControl.ManualDock(f_PageControl);
   SetUndockSize;
  end;//DockControl <> nil
 end;//DoDockControl

var
 Index, l_ImageIndex: Integer;
 l_DockControl: TControl;
//#UC END# *52BD665B0244_52BAD1C40174_var*
//#UC START# *52BD669D02AB_52BAD1C40174_impl*
 f_IsDelay := True;
 if f_HideDirect = hdHide then
  f_TimerDelay.Interval := f_DelayIntervalOnShow
 else
  f_TimerDelay.Interval := f_DelayIntervalOnHide;
 f_TimerDelay.Enabled := True;
//#UC END# *52BD669D02AB_52BAD1C40174_impl*
//#UC START# *52BD669D02AB_52BAD1C40174_var*
//#UC END# *52BD669D02AB_52BAD1C40174_var*
//#UC START# *52BD66F600F4_52BAD1C40174_impl*
 { Пересчитаем координаты навигатора в координаты родительского окна }
 l_Point := Parent.ScreenToClient(Point(X, Y));
 l_Rect := Parent.ClientRect;
 { Ограничения на изменение размера }
 if not (aDrawSplitterType = [dstErase]) then
  l_Rect := CorrectBounds(l_Rect);
 lp_MinusPageSize;
 if PtInRect(l_Rect, l_Point) then
 begin
  { Старый сплиттер }
  if dstErase in aDrawSplitterType then
   DrawSplit(f_SplitterRect);
  { Новый сплиттер }
  if dstPaint in aDrawSplitterType then
  begin
   l_Rect := lp_CalcSplitRect;
   l_Point.X := l_Rect.Left;
   l_Point.Y := l_Rect.Top;
   l_Point := Self.ClientToScreen(l_Point);
   f_SplitterRect := l_Rect;
   with f_SplitterRect do
   begin
    Right := l_Point.X + (Left - Right);
    Bottom := l_Point.Y + (Bottom - Top);
    Left := l_Point.X;
    Top := l_Point.Y;
   end;//with f_SplitterRect do
   DrawSplit(f_SplitterRect);
  end;//if dstPaint in aDrawSplitterType then
 end;//if PtInRect(l_Rect, l_Point) then
//#UC END# *52BD66F600F4_52BAD1C40174_impl*
//#UC START# *52BD66F600F4_52BAD1C40174_var*
var
 l_Rect  : TRect;
 l_Point : TPoint;

  function lp_CalcSplitRect: TRect;
  var
   lPoint : TPoint;
  begin
   lPoint := ScreenToClient(Point(X, Y));
   if dstPaint in aDrawSplitterType then
    case Self.Align of
     alTop, alBottom:
      begin
       Result.Left := 0;
       Result.Right := Self.Width;
       Result.Top := lPoint.Y + cspSize div 2;
       Result.Bottom := Result.Top + cspSize;
      end;
     alLeft, alRight:
      begin
       Result.Left := lPoint.X + cspSize div 2;
       Result.Right := Result.Left + cspSize;
       Result.Top := 0;
       Result.Bottom := Self.Height;
      end;
    end;
  end;

 procedure lp_MinusPageSize;
 var
  l_Limit: Integer;
 begin
  { Установим ограничения }
  l_Limit := pm_GetSizeMini - cspSize;
  case Self.Align of
   alLeft: l_Rect.Left := l_Rect.Left + l_Limit;
   alRight: l_Rect.Right := l_Rect.Right - l_Limit;
   alTop: l_Rect.Top := l_Rect.Top + l_Limit;
   alBottom: l_Rect.Bottom := l_Rect.Bottom - l_Limit;
  end;//case Self.Align of
 end;//lp_CheckPageSize
//#UC END# *52BD66F600F4_52BAD1C40174_var*
//#UC START# *52BD6A4C0348_52BAD1C40174_impl*
 if (f_ExportPageControl <> nil) then
 begin
  f_PageControl.OnUnDock := nil;
  for Index := Pred(f_PageControl.PageCount) downto 0 do
  begin
   l_Control := f_PageControl.Pages[Index].Controls[0];
   if l_Control is TForm then
    TForm(l_Control).OnEndDock := nil;
   l_Control.ManualDock(f_ExportPageControl);
  end;//for Index
  f_ExportPageControl := nil;
 end//f_ExportPageControl <> nil
 else
 if (f_Header.f_IsDragBegining) or
    (f_Float and (f_PageControl.PageCount = 1)) then
 begin
  with f_FloatNavigator do
  begin
   // Установим новую позицию окна
   BoundsRect := CalcNewFloatBounds;
   {$IfDef Nemesis}
   // Обновим информацию о положении окна у TvcmForm`s
   UpdateFloatWindowsBounds;
   {$EndIf Nemesis}
  end;//with f_FloatNavigator
  f_Header.f_IsDragBegining := False;
 end;//(f_Header.f_IsDragBegining) or (f_Float and (f_PageControl.PageCount = 1))
 TForm(f_EndDockClient).OnEndDock := nil;
//#UC END# *52BD6A4C0348_52BAD1C40174_impl*
//#UC START# *52BD6A4C0348_52BAD1C40174_var*
var
 Index: Integer;
 l_Control : TControl;
//#UC END# *52BD6A4C0348_52BAD1C40174_var*
//#UC START# *52BD6A7F0011_52BAD1C40174_impl*
 f_ClickOnTab := True;
 f_Header.f_IsDragBegining := False;
 if f_State = nsMinimized then
  State := nsNormal;
 if (Page.ControlCount > 0) then
 begin
  InitDrag(Page.Controls[0]);
  if not Mouse.IsDragging then
   Page.Controls[0].BeginDrag(False);
 end;//Page.ControlCount > 0
//#UC END# *52BD6A7F0011_52BAD1C40174_impl*
//#UC START# *52BD6A7F0011_52BAD1C40174_var*
//#UC END# *52BD6A7F0011_52BAD1C40174_var*
//#UC START# *52BD6A960020_52BAD1C40174_impl*
 if State = nsMinimized then
  State := nsNormal
 else
  State := nsMinimized;
//#UC END# *52BD6A960020_52BAD1C40174_impl*
//#UC START# *52BD6A960020_52BAD1C40174_var*
//#UC END# *52BD6A960020_52BAD1C40174_var*
//#UC START# *52BD6AC300B2_52BAD1C40174_impl*
 if State = nsAutoHide then
  State := nsNormal
 else
  State := nsAutoHide;
//#UC END# *52BD6AC300B2_52BAD1C40174_impl*
//#UC START# *52BD6AC300B2_52BAD1C40174_var*
//#UC END# *52BD6AC300B2_52BAD1C40174_var*
//#UC START# *52BD6B500014_52BAD1C40174_impl*
 SetUndockSize;
//#UC END# *52BD6B500014_52BAD1C40174_impl*
//#UC START# *52BD6B500014_52BAD1C40174_var*
//#UC END# *52BD6B500014_52BAD1C40174_var*
//#UC START# *52BD6B6801D6_52BAD1C40174_impl*
 if (f_PageControl.PageCount = 0) then
 begin
  f_PageControl.Visible := False; // костыль для http://mdp.garant.ru/pages/viewpage.action?pageId=324009991
                                  // http://mdp.garant.ru/pages/viewpage.action?pageId=324009991&focusedCommentId=330141913
  if f_Float then
   f_FloatNavigator.Close
  else
  begin
   (* запомним текущий нормальный размер *)
   l_Size := f_Surface.Size;
   // Устанавливаем только для нормального размера
   if f_State = nsNormal then
    f_SizeNormal := l_Size;
   (* сохраним размер *)
   DoSaveSize;
   pm_SetSizeEmpty(f_SizeEmpty);
  end;//f_Float
 end//f_PageControl.PageCount = 0
 else
  f_Header.Invalidate;
 UpdateCloseButton;
 DoStateChanged;
//#UC END# *52BD6B6801D6_52BAD1C40174_impl*
//#UC START# *52BD6B6801D6_52BAD1C40174_var*
var
 l_Size : Integer;
//#UC END# *52BD6B6801D6_52BAD1C40174_var*
//#UC START# *52BD6B710302_52BAD1C40174_impl*
 lIsExit := False;
 // Определим приращение
 if (f_HideDirect = hdHide) then
 begin
  lDelta := -clDelta;
  lDist := -clDelta;
  lLimit := SizeMini;
 end//f_HideDirect = hdHide
 else
 begin
  lDelta := clDelta;
  lDist := clDelta;
  lLimit := f_SizeNormal;
 end;//f_HideDirect = hdHide
 // Текущие размеры
 lBounds := f_Surface.BoundsRect;
 // Опредим не достигли ли мы пределного сворачивания/разворачивания
 case Align of
  alLeft, alRight:
   if f_HideDirect = hdHide then
    lIsExit := (f_Surface.Width + lDist <= lLimit) or
     (f_Surface.Width + lDelta < lLimit)
   else
    lIsExit := (f_Surface.Width + lDist >= lLimit) or
     (f_Surface.Width + lDelta > lLimit);
  alTop, alBottom:
   if f_HideDirect = hdHide then
    lIsExit := (f_Surface.Height + lDist <= lLimit)  or
     (f_Surface.Height + lDelta < lLimit)
   else
    lIsExit := (f_Surface.Height + lDist >= lLimit)  or
     (f_Surface.Height + lDelta > lLimit);
 end;//case Align
 // Устновим новый размер
 case Align of
  alLeft:
   with lBounds do
   begin
    if lIsExit then
     Right := Left + lLimit
    else
     Inc(Right, lDelta);
   end;
  alRight:
   with lBounds do
    if lIsExit then
     Left := Right - lLimit
    else
     Dec(Left, lDelta);
  alTop:
   with lBounds do
    if lIsExit then
     Bottom := Top + lLimit
    else
     Inc(Bottom, lDelta);
  alBottom:
   with lBounds do
    if lIsExit then
     Top := Bottom - lLimit
    else
     Inc(Top, lDelta);
 end;//case Align
 // Устновим новые размеры
 Windows.SetWindowPos(f_Surface.Handle, 0, lBounds.Left, lBounds.Top,
  lBounds.Right - lBounds.Left, lBounds.Bottom - lBounds.Top, SWP_NOACTIVATE or
   SWP_NOZORDER);
//#UC END# *52BD6B710302_52BAD1C40174_impl*
//#UC START# *52BD6B710302_52BAD1C40174_var*
const
 clDelta = 30;
var
 lDelta  : Integer;
 lDist   : Integer;
 lLimit  : Integer;
 lIsExit : Boolean;
 lBounds : TRect;
//#UC END# *52BD6B710302_52BAD1C40174_var*
//#UC START# *52BD6B7E0075_52BAD1C40174_impl*
 CloseDelay;
//#UC END# *52BD6B7E0075_52BAD1C40174_impl*
//#UC START# *52BD6B7E0075_52BAD1C40174_var*
//#UC END# *52BD6B7E0075_52BAD1C40174_var*
//#UC START# *52BD6BDB0195_52BAD1C40174_impl*
 SetUndockSize;
 if (NewTarget <> Self) then
 begin
  { Импортируем в PageControl }
  if Allow and (NewTarget <> nil) and f_Header.f_IsDragBegining and
   (NewTarget is TnpPageControl) then
  begin
   f_ExportPageControl := NewTarget as TnpPageControl;
   SetEndDockProcedure;
   ResetDragInfo;
   Allow := False;
  end;//Allow and (NewTarget <> nil) and f_Header.f_IsDragBegining
  if Allow then
  begin
   if f_Float then
    Allow := (NewTarget <> nil) or ((f_PageControl.PageCount > 1) and
     f_UnDockFromFloat and
     not f_SingleFloatNavigator and not f_Header.f_IsDragBegining);
   if Allow then
   begin
    if not f_Float then
     ModeStateUpdateAfter;
    f_DockInSelf := False;
    if (f_PageControl.PageCount = 1) then
    begin
     if f_Float then
     begin
      if NewTarget <> nil then
       f_FloatNavigator.Close
      else
       if not f_UnDockFromFloat then
        f_DockInSelf := True;
     end;//f_Float
    end//f_PageControl.PageCount = 1
    { NewTarget - используя f_ImportNavigator  примет все закладки текущего навигатора }
    else
    if (NewTarget <> nil) and (NewTarget is TvtNavigator) and
      f_Header.f_IsDragBegining then
     TvtNavigator(NewTarget).f_ImportNavigator := Self;
    { Клиент ни к кому не пристыкован }
    if NewTarget = nil then
     if Client is TForm then
     begin
      Allow := False;
      PostMessage(Handle, CM_npDockToFloatWindow, Integer(Client), 0);
     end;//if Client is TForm then
   end;//if Allow then
  end;
  if not Allow then
   if f_Float then
    if Client is TForm then
     SetEndDockProcedure;
 end//NewTarget <> Self
 else
  Allow := False;
 if Allow then
  ResetDragInfo;
//#UC END# *52BD6BDB0195_52BAD1C40174_impl*
//#UC START# *52BD6BDB0195_52BAD1C40174_var*
 procedure SetEndDockProcedure;
 begin//SetEndDockProcedure
  if (Client is TForm) then
  begin
   TForm(Client).OnEndDock := OnEndDockControl;
   f_EndDockClient := Client;
  end;//Client is TForm
 end;//SetEndDockProcedure
//#UC END# *52BD6BDB0195_52BAD1C40174_var*
//#UC START# *52BD6C000396_52BAD1C40174_impl*
 if (aDragControl is TForm) then
 begin
  TForm(aDragControl).OnEndDock := OnEndDockControl;
  f_EndDockClient := aDragControl;
 end;//aDragControl is TForm
//#UC END# *52BD6C000396_52BAD1C40174_impl*
//#UC START# *52BD6C000396_52BAD1C40174_var*
//#UC END# *52BD6C000396_52BAD1C40174_var*
//#UC START# *52BD6C1F0372_52BAD1C40174_impl*
 if (DragDockObject.DragTarget = nil) then
  DragDockObject.DockRect := CalcNewFloatBounds;
//#UC END# *52BD6C1F0372_52BAD1C40174_impl*
//#UC START# *52BD6C1F0372_52BAD1C40174_var*
//#UC END# *52BD6C1F0372_52BAD1C40174_var*
//#UC START# *52BD6DC7031F_52BAD1C40174_impl*
 case Self.Align of
  alTop, alBottom: Self.Height := aSize;
  alLeft, alRight: Self.Width := aSize;
 end;
//#UC END# *52BD6DC7031F_52BAD1C40174_impl*
//#UC START# *52BD6DC7031F_52BAD1C40174_var*
//#UC END# *52BD6DC7031F_52BAD1C40174_var*
//#UC START# *52BD6DE601F7_52BAD1C40174_impl*
  // 1 - определим точку отпускания;
  // 2 - расчитаем новый размер;
  // 3 - применим новые размеры;
 lp_ApplyNewSize(lp_CalcSize(lp_CalcPoint));
//#UC END# *52BD6DE601F7_52BAD1C40174_impl*
//#UC START# *52BD6DE601F7_52BAD1C40174_var*
 function lp_CalcPoint: TPoint;

  procedure lp_OffsetPoint(var aPoint: TPoint);
  var
   l_AddSize: Integer;
  begin
   // Размер сплиттера:
   case Align of
    alLeft, alRight: l_AddSize := f_Surface.f_Splitter.Width;
    alTop, alBottom: l_AddSize := f_Surface.f_Splitter.Height;
   else
    l_AddSize := 0;
   end;//case Align of
   // Увеличим размер:
   if l_AddSize > 0 then
   begin
    l_AddSize := l_AddSize div 2;
    case Align of
     alLeft, alRight: Inc(aPoint.X, l_AddSize);
     alTop, alBottom: Inc(aPoint.Y, l_AddSize);
    end;//case Align of
   end;//if l_AddSize > 0 then
  end;//lp_OffsetPoint

  procedure lp_CorrentPoint(var aPoint: TPoint);
  var
   l_SizeMini   : Integer;
   l_ParentRect : TRect;
  begin
   l_SizeMini := pm_GetSizeMini + 4;
   l_ParentRect := Parent.ClientRect;
   // Право
   if aPoint.X > (l_ParentRect.Right - l_SizeMini) then
    aPoint.X := l_ParentRect.Right - l_SizeMini
   else
    // Лево
    if aPoint.X < l_ParentRect.Left + l_SizeMini then
     aPoint.X := l_ParentRect.Left + l_SizeMini;
   // Верх
   if aPoint.Y < l_ParentRect.Top + l_SizeMini then
    aPoint.Y := l_ParentRect.Top + l_SizeMini
   else
    // Низ
    if aPoint.Y > (l_ParentRect.Bottom - l_SizeMini) then
     aPoint.Y := l_ParentRect.Bottom - l_SizeMini;
  end;//lp_CorrentPoint

 begin
  // Получим точку отпускания:
  Result := Parent.ScreenToClient(Mouse.CursorPos);
  // Откорретируем, чтобы она не была меньше минимальных размеров:
  lp_CorrentPoint(Result);
  // Определим размер навигатора таким образом, чтобы после применения новых
  // размеров курсор мыши располагался по середине сплиттера:
  lp_OffsetPoint(Result);
 end;//lp_CalcPoint

 function lp_CalcSize(const aPoint: TPoint): Integer;
 var
  l_NewBounds: TRect;
 begin
  Result := 0;
  l_NewBounds := CorrectBounds(GetNewBoundsFromPoint(aPoint.X, aPoint.Y));
  with l_NewBounds do
   case Align of
    alLeft, alRight:
     Result := Right - Left;
    alTop, alBottom:
     Result := Bottom - Top;
   end;//case Self.Align of
 end;//lp_CalcSize

 procedure lp_ApplyNewSize(const aSize: Integer);
 begin
  // Минимизируем навигатор, если ширину установили меньше допустимой:
  if aSize < cMinNormalSize then
   State := nsMinimized
  else
  // Установим новый размер:
  begin
   f_SizeNormal := aSize;
   if IsMinimized then
    State := nsNormal
   else
    if f_State <> nsMinimized then
     pm_SetSizeNormal(f_SizeNormal);
  end;//if l_NewSize < cMinNormalSize then
 end;//lp_ApplyNewSize
//#UC END# *52BD6DE601F7_52BAD1C40174_var*
//#UC START# *52BD6E0B0379_52BAD1C40174_impl*
 for l_Index := 0 to f_PageControl.PageCount - 1 do
 begin
  with f_PageControl.Pages[l_Index] do
  begin
   if (ControlCount > 0) then
    if f_Float then
    begin
     Controls[0].UndockHeight := Self.Height;
     Controls[0].UndockWidth := Self.Width;
    end//f_Float
    else
    begin
     Controls[0].UndockHeight := f_PageControl.Height;
     Controls[0].UndockWidth := f_PageControl.Width;
    end;//f_Float
  end;//with f_PageControl.Pages[l_Index]
 end;//for l_Index
//#UC END# *52BD6E0B0379_52BAD1C40174_impl*
//#UC START# *52BD6E0B0379_52BAD1C40174_var*
var
 l_Index: Integer;
//#UC END# *52BD6E0B0379_52BAD1C40174_var*
//#UC START# *52BD6E53030E_52BAD1C40174_impl*
 if (f_PageControl.PageCount <> 0) then
  Result := f_SizeNormal
 else
 begin
  l_SizeNormal := DoLoadSize;
  if l_SizeNormal > 0 then
   Result := l_SizeNormal
  else
   Result := aControl.Width;
  l_Parent := aControl.Parent;
  while True do
  begin
   if not Assigned(l_Parent) then
    Break;
   if l_Parent is TElCustomPageControl then
   begin
    l_Navigator := TvtNavigator(l_Parent.Owner);
    Result := l_Navigator.SizeNormal;
    Break;
   end;
   l_Parent := l_Parent.Parent;
  end;
 end;
//#UC END# *52BD6E53030E_52BAD1C40174_impl*
//#UC START# *52BD6E53030E_52BAD1C40174_var*
var
 l_Parent     : TWinControl;
 l_Navigator  : TvtNavigator;
 l_SizeNormal : Integer;
//#UC END# *52BD6E53030E_52BAD1C40174_var*
//#UC START# *52BD6E7A02BA_52BAD1C40174_impl*
 if aDockSize = -1 then
  aDockSize := cDockSize;
 GetWindowRect(Self.Handle, Result);
 { Область докинга }
 case Self.Align of
  alBottom:
   with Result do
    Top := Bottom - aDockSize;
  alTop:
   with Result do
    Bottom := Top + aDockSize;
  alLeft:
   with Result do
    Right := Left + aDockSize;
  alRight:
   with Result do
    Left := Right - aDockSize;
 end;//case Self.Align
//#UC END# *52BD6E7A02BA_52BAD1C40174_impl*
//#UC START# *52BD6E7A02BA_52BAD1C40174_var*
const
 cDockSize = 50;
//#UC END# *52BD6E7A02BA_52BAD1C40174_var*
//#UC START# *52BD6EAC0226_52BAD1C40174_impl*
 (* ChangeLinks  *)
 for l_Index := 0 to Pred(f_ChangeLinks.Count) do
  with TnpChangeLink(f_ChangeLinks[l_Index]) do
   if Assigned(OnStateChanged) then
    OnStateChanged(Self);
 if aNavigatorState and Assigned(f_OnStateChange) then
  f_OnStateChange(Self);
//#UC END# *52BD6EAC0226_52BAD1C40174_impl*
//#UC START# *52BD6EAC0226_52BAD1C40174_var*
var
 l_Index : Integer;
//#UC END# *52BD6EAC0226_52BAD1C40174_var*
//#UC START# *52BD6ECD0365_52BAD1C40174_impl*
 Result := TnpPageControl;
//#UC END# *52BD6ECD0365_52BAD1C40174_impl*
//#UC START# *52BD6ECD0365_52BAD1C40174_var*
//#UC END# *52BD6ECD0365_52BAD1C40174_var*
//#UC START# *52BD6EE2010C_52BAD1C40174_impl*
 Result := TnpFloatingWindow;
//#UC END# *52BD6EE2010C_52BAD1C40174_impl*
//#UC START# *52BD6EE2010C_52BAD1C40174_var*
//#UC END# *52BD6EE2010C_52BAD1C40174_var*
//#UC START# *52BD6F1D0237_52BAD1C40174_impl*
 if (f_ChangeLinks = nil) then 
  Exit;
 if f_ChangeLinks.IndexOf(aLink) = -1 then
  f_ChangeLinks.Add(aLink);
//#UC END# *52BD6F1D0237_52BAD1C40174_impl*
//#UC START# *52BD6F1D0237_52BAD1C40174_var*
//#UC END# *52BD6F1D0237_52BAD1C40174_var*
//#UC START# *52BD6F4901D6_52BAD1C40174_impl*
 if (f_ChangeLinks = nil) then
  Exit;
 l_Index := f_ChangeLinks.IndexOf(aLink);
 if l_Index <> -1 then
  f_ChangeLinks.Delete(l_Index);
//#UC END# *52BD6F4901D6_52BAD1C40174_impl*
//#UC START# *52BD6F4901D6_52BAD1C40174_var*
var
 l_Index : Integer;
//#UC END# *52BD6F4901D6_52BAD1C40174_var*
//#UC START# *52BD6F8E02BA_52BAD1C40174_impl*
 Result := False;
 if Assigned(f_PageControl) then
  Result := f_PageControl.IsActiveControl(aControl);
//#UC END# *52BD6F8E02BA_52BAD1C40174_impl*
//#UC START# *52BD6F8E02BA_52BAD1C40174_var*
//#UC END# *52BD6F8E02BA_52BAD1C40174_var*
//#UC START# *52BD6FBC0045_52BAD1C40174_impl*
 Result := f_Header.HideButton.MakeHint;
//#UC END# *52BD6FBC0045_52BAD1C40174_impl*
//#UC START# *52BD6FBC0045_52BAD1C40174_var*
//#UC END# *52BD6FBC0045_52BAD1C40174_var*
//#UC START# *52BD70000390_52BAD1C40174_impl*
 ButtonsImageList := aDest.ButtonsImageList;
 AutoHideOffImage := aDest.AutoHideOffImage;
 AutoHideOnImage := aDest.AutoHideOnImage;
 CloseImage := aDest.CloseImage;
 HideDownImage := aDest.HideDownImage;
 HideLeftImage := aDest.HideLeftImage;
 HideRightImage := aDest.HideRightImage;
 HideUpImage := aDest.HideUpImage;
 CloseHint := aDest.CloseHint;
 AutoHideOffHint := aDest.AutoHideOffHint;
 AutoHideOnHint := aDest.AutoHideOnHint;
 MinimizedOffHint := aDest.MinimizedOffHint;
 MinimizedOnHint := aDest.MinimizedOnHint;
//#UC END# *52BD70000390_52BAD1C40174_impl*
//#UC START# *52BD70000390_52BAD1C40174_var*
//#UC END# *52BD70000390_52BAD1C40174_var*
//#UC START# *52BD705202C5_52BAD1C40174_impl*
 case Code of
  HCBT_MINMAX:
   if Assigned(f_MainForm) and f_MainForm.HandleAllocated then
    if (THandle(WParam) = f_MainForm.Handle) then
     // Чтобы у двух окон при минимизации не оставались плавающие навигаторы
     if ((LoWord(LParam) and SW_MINIMIZE) = SW_MINIMIZE) then
     begin
      Activate := False;
      f_FormWasMinimized := True;
     end
     else
      if ((LoWord(LParam) and SW_RESTORE) = SW_RESTORE) then
       f_ParentRestore := True;
 end;//case Code of
//#UC END# *52BD705202C5_52BAD1C40174_impl*
//#UC START# *52BD705202C5_52BAD1C40174_var*
//#UC END# *52BD705202C5_52BAD1C40174_var*
//#UC START# *52BD70850139_52BAD1C40174_impl*
 if csDestroying in ComponentState then
  Exit;
 case aMessage.message of
  WM_MOUSEMOVE:
   if (f_State = nsAutoHide) and CheckWindowUnderCursor then
    AutoHideUpdate;
  WM_SIZE:
  begin
   (* Изменился размер родительского окна, изменим размер плавающего навигатора *)
   if Assigned(Parent) and Parent.HandleAllocated and
    (aMessage.hwnd = Parent.Handle) then
   begin
    if (f_State = nsAutoHide) then
     Resize;
    // Если форму минимизировали, то ничего не делаем
    if ((not f_Float) and (not f_FormWasMinimized))
     {$IfDef Nemesis}
      and ((LoWord(aMessage^.LParam) <> Parent.ClientWidth) or
       (HiWord(aMessage^.LParam) <> Parent.Clientheight))
     {$EndIf Nemesis} then
      // - http://mdp.garant.ru/pages/viewpage.action?pageId=564993305
    begin
     if f_ParentRestore then
      f_ParentRestore := False;
     lp_CorrectSize;
    end;
    // Форму разворачивают после минимизации
    if f_FormWasMinimized and f_ParentRestore then
    begin
     f_FormWasMinimized := False;
     f_ParentRestore := False;
    end;//if f_FormWasMinimized and f_ParentRestore then
   end;//if Assigned(Parent)
  end;//WM_SIZE
  WM_ACTIVATE:
  begin
   (* Минимизировать главное окно *)
   if {$IfDef Nemesis}(not f_MainForm.HandleAllocated) or{$EndIf Nemesis}
   // - http://mdp.garant.ru/pages/viewpage.action?pageId=573672384
     ((f_MainForm.Handle = THandle(aMessage.hwnd)) and
     Boolean(HiWord(aMessage.wParam))) then
    Activate := False
   (* Какое-то окно получило фокус, если окно, которое принадлежит главной
      форме, то активируем, в противном случае деактивируем *)
   else
   begin
    lIsAct := LoWord(aMessage.WParam) <> WA_INACTIVE;
    if lIsAct then
    begin
     lActWnd := aMessage.hwnd;
     if lpIsDropDown(lActWnd) then
      Exit;
     (* Показали модальную форму, прячем навигатор и выходим *)
     if npIsModalForm(lActWnd) then
     begin
      DoActivate(False);
      Exit;
     end;
     (* Активировали плавающую форму *)
     if not npIsInFloatNavigator(lActWnd) and npIsFloatingForm(lActWnd) then
     begin
      DoActivate(True);
      Exit;
     end;
    end
    else
    begin
    (* Окну aMessage.hwnd пришло сообщение о деактивации, handle активированного
       окна содержится в THandle(aMessage.lParam). Если окно принадлежит
       главному окну навигатора ничего не делаем или активируем, в противном
       случае спрячем *)
     lActWnd := THandle(aMessage.lParam);
     (* Информацию о деактивации нет смысла обрабатывать если фокус не ушел на
        рабочий стол, потому что когда придет, через HOOK сообщение об активации
        окна, то мы спрячем навигаторы если активировалось окно другой главной
        формы, или совсем чужое окно *)
     if  lActWnd <> HWND_DESKTOP then
      Exit;
    end;
    (* Изменим состояние *)
    l_Activate := npGetActivationValue(Self, f_MainForm, lActWnd);
    // - http://mdp.garant.ru/pages/viewpage.action?pageId=570120392
    DoActivate(l_Activate);
   end;
  end;
 end;
//#UC END# *52BD70850139_52BAD1C40174_impl*
//#UC START# *52BD70850139_52BAD1C40174_var*

 function lpIsDropDown(aWnd : THandle) : Boolean;
 var
  lControl    : TWinControl;
  lDropWindow : IafwDropDownWindow;
 begin
  Result := False;
  lControl := FindControl(aWnd);
  if Assigned(lControl) then
   if Supports(lControl, IafwDropDownWindow, lDropWindow) then
   try
    Result := True;
   finally
    lDropWindow := nil;
   end
   else
    Result := not Assigned(lControl.Parent) and not Assigned(lControl.Owner);
 end;

 procedure lp_CorrectSize;
 begin
  // При восстановлении формы, откорректируем размер навигаторов
  with CorrectBounds(CalcBounds(SizeNormal)) do
   case Self.Align of
    alLeft, alRight:
     if Right - Left <> f_SizeNormal then
      SizeNormal := Right - Left;
    alBottom, alTop:
     if Bottom - Top <> f_SizeNormal then
      SizeNormal := Bottom - Top;
   end;//case Self.Align of
 end;//lp_CorrectSize

 function CheckWindowUnderCursor: Boolean;
 var
  l_CurPos: TPoint;
  l_Window: THandle;
  l_Class: string;
  l_ClassLen: Integer;
 begin // http://mdp.garant.ru/pages/viewpage.action?pageId=296095220
  if GetCursorPos(l_CurPos) then
  begin
   l_Window := WindowFromPoint(l_CurPos);
   Result := (not Tl3PopupControlService.Instance.IsPopupControlWindow(l_Window));
  end //GetCursorPos
  else
   Result := False;
 end; //CheckWindowUnderCursor

var
 lIsAct   : Boolean;
 lActWnd  : THandle;
 l_Activate: Boolean;
//#UC END# *52BD70850139_52BAD1C40174_var*
//#UC START# *52CECF5600E7_52BAD1C40174_impl*
 case f_State of
  nsMinimized: SetSelfSize(SizeMini);
  nsNormal: SetSelfSize(SizeNormal);
 end;//case f_State
//#UC END# *52CECF5600E7_52BAD1C40174_impl*
//#UC START# *52CECF5600E7_52BAD1C40174_var*
//#UC END# *52CECF5600E7_52BAD1C40174_var*
//#UC START# *52CED0F20285_52BAD1C40174set_impl*
 f_NavigatorOnForm := aValue;
 if (aValue <> nil) then
  f_ParentNavigatorHandle := aValue.Handle
 else
  f_ParentNavigatorHandle := 0;
//#UC END# *52CED0F20285_52BAD1C40174set_impl*
//#UC START# *52CED0F20285_52BAD1C40174set_var*
//#UC END# *52CED0F20285_52BAD1C40174set_var*
//#UC START# *52CFCE2D03DE_52BAD1C40174_impl*
 UpdateSize;
//#UC END# *52CFCE2D03DE_52BAD1C40174_impl*
//#UC START# *52CFCE2D03DE_52BAD1C40174_var*
//#UC END# *52CFCE2D03DE_52BAD1C40174_var*
//#UC START# *54102F6E00A4_52BAD1C40174_impl*
 f_MainForm := aNewMainForm;
 // - http://mdp.garant.ru/pages/viewpage.action?pageId=564993305
//#UC END# *54102F6E00A4_52BAD1C40174_impl*
//#UC START# *54102F6E00A4_52BAD1C40174_var*
//#UC END# *54102F6E00A4_52BAD1C40174_var*
//#UC START# *5448CCD000FF_52BAD1C40174_impl*
 (* Иначе при активизации приложения по заголовку окна окно навигатора могло
    находится под главным, кроме того наблюдались мерцания (показывали,
    скрывали, показывали) *)
 PostMessage(Handle, CM_npChangeActivate, Integer(aActive), 0);
//#UC END# *5448CCD000FF_52BAD1C40174_impl*
//#UC START# *5448CCD000FF_52BAD1C40174_var*
//#UC END# *5448CCD000FF_52BAD1C40174_var*
//#UC START# *54868B67034A_52BAD1C40174_impl*
 PageActive;
//#UC END# *54868B67034A_52BAD1C40174_impl*
//#UC START# *54868B67034A_52BAD1C40174_var*
//#UC END# *54868B67034A_52BAD1C40174_var*
//#UC START# *54868B84029F_52BAD1C40174_impl*
 PageInactive;
//#UC END# *54868B84029F_52BAD1C40174_impl*
//#UC START# *54868B84029F_52BAD1C40174_var*
//#UC END# *54868B84029F_52BAD1C40174_var*
