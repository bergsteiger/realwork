//#UC START# *537F62DD009F_ext:FileName
w:\common\components\rtl\Garant\cs\CsDataPipe.pas
//#UC END# *537F62DD009F_ext:FileName
//#UC START# *538DE0DC02BD_537F62DD009F_impl*
 l_ZeroSize := False;
 l_MismatchSize :=False;

 if aToPath <> '' then
  Result:= ForceDirectories(aToPath);

 WriteBufferFlush;
  while True{IOHandler.Connected} do
  begin
   l_FileName := IOHandler.ReadLn;
   if l_FileName = c_NoMoreFiles then
    Break;
   l_FullFileName := ConcatDirName(aToPath, l_FileName);
   l_Dir := ExtractFilePath(l_FullFileName);
   if Result and not DirExists(l_Dir) then
    try
     MakeDir(l_Dir);
    except
     // нужно прочитать данные из трубы, иначе все сбивается
     on E: Exception do
     begin
      l3System.Msg2Log('Из-за %s содержимое файла %s потеряно', [E.Message, l_FullFileName]);
      Result:= False;
     end;
    end;

   if not Result then
   begin
    l3System.Msg2Log('Содержимое файла %s потеряно', [l_FullFileName]);
    l_FileSize := IOHandler.ReadInt64;

    if l_FileSize = 0 then
     begin
       l3System.Msg2Log('!!! Нулевая длина файла %s', [l_FullFileName]);
       l_MismatchSize := True;
     end;

    l_FileStream := Tl3TempMemoryStream.Create;
    try
     IOHandler.ReadStream(l_FileStream, l_FileSize);

     l_FileStream.Seek(0, soEnd);
     if l_FileStream.Position <> l_FileSize then
     begin
       l3System.Msg2Log('!!! Для файла %s считано %d вместо %d', [l_FullFileName, l_FileStream.Position, l_FileSize]);
       l_MismatchSize := True;
     end;

    finally
     l3Free(l_FileStream);
    end;
   end
   else
   begin
    if FileExists(l_FullFileName) then
     RenametoBack(l_FullFileName);
    l_FileSize := IOHandler.ReadInt64;

    if l_FileSize = 0 then
     begin
       l3System.Msg2Log('!!! Нулевая длина файла %s', [l_FullFileName]);
       l_MismatchSize := True;
     end;

    l_FileStream := Tl3FileStream.Create(l_FullFileName, l3_fmCreateReadWrite);
    try
     IOHandler.ReadStream(l_FileStream, l_FileSize);

     l_FileStream.Seek(0, soEnd);
     if l_FileStream.Position <> l_FileSize then
     begin
       l3System.Msg2Log('!!! Для файла %s считано %d вместо %d', [l_FullFileName, l_FileStream.Position, l_FileSize]);
       l_MismatchSize := True;
     end;

    finally
     l3Free(l_FileStream);
    end;
   end;
  end; // while
  Result := Result and not l_MismatchSize and not l_ZeroSize;
//#UC END# *538DE0DC02BD_537F62DD009F_impl*
//#UC START# *538DE0DC02BD_537F62DD009F_var*
var
 l_FileName: string;
 l_FileSize: Int64;
 l_FileStream: Tl3Stream;
 l_FullFileName: string;
 l_Dir: string;
 l_ZeroSize: Boolean;
 l_MismatchSize: Boolean;
//#UC END# *538DE0DC02BD_537F62DD009F_var*
//#UC START# *538DE100010F_537F62DD009F_impl*
 if DirExists(aFolderName) then
 begin
  IOHandler.WriteBufferOpen(GSendBufferSizeDefault);
  try
   SendAllFiles(aFolderName);
   IOHandler.WriteLn(c_NoMoreFiles); // ставим точку
   IOHandler.WriteBufferClose;
  except
   IOHandler.WriteBufferClear;
   raise;
  end;
 end
 else
  IOHandler.WriteLn(c_NoMoreFiles); // только точка
//#UC END# *538DE100010F_537F62DD009F_impl*
//#UC START# *538DE100010F_537F62DD009F_var*

 function SendFile(const aFileName: string): Boolean;
 var
  l_FileSize: Int64;
  l_RelPath: string;
  l_DelimPos: Integer;
 begin
  Result := IOHandler.Connected;
  if Result and FileExists(aFileName) then
  begin
   l_RelPath := ExtractRelativePath(aFolderName, aFileName);
   // отрезаем первую папку (она лишняя)
   l_DelimPos := Pos(PathDelim, l_RelPath);
   IOHandler.WriteLn(Copy(l_RelPath, l_DelimPos + 1, Length(l_RelPath)));
   l_FileSize := SizeOfFile(aFileName);
   IOHandler.WriteInt64(l_FileSize); // размер файла
   IOHandler.WriteFile(aFileName{, False}); // сам файл
  end;
 end;

 procedure SendAllFiles(const aDir: TFileName);
 var
  l_SearchRec: TSearchRec;
  l_FileFound: Boolean;
  l_Name: TFileName;
 begin
  l_FileFound := FindFirst(ConcatDirName(aDir, '*.*'), faAnyFile, l_SearchRec) = 0;
  try
   while l_FileFound do
   begin
    if l_SearchRec.Name[1] <> '.' then
    begin
     l_Name := ConcatDirName(aDir, l_SearchRec.Name);
     if (l_SearchRec.Attr and faDirectory) <> 0 then // директория ==> запуск рекурсии
      SendAllFiles(l_Name)
     else if (l_SearchRec.Attr and (faReadOnly or faHidden or faSysFile or faArchive)) <> 0 then // файл
      if not SendFile(l_Name) then
       Break;
    end;
    l_FileFound := FindNext(l_SearchRec) = 0;
   end; // while
  finally
   FindClose(l_SearchRec);
  end;
 end;

//#UC END# *538DE100010F_537F62DD009F_var*
