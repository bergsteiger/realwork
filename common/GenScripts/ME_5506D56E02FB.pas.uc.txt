//#UC START# *479731C50290_5506D56E02FB_impl*
 f_ContainerItem := nil;
 f_MainForm := nil;
 f_Current := 0;
 FreeAndNil(f_History);
 FreeAndNil(f_Forms);
 inherited;
//#UC END# *479731C50290_5506D56E02FB_impl*
//#UC START# *479731C50290_5506D56E02FB_var*
//#UC END# *479731C50290_5506D56E02FB_var*
//#UC START# *499559BF038A_5506D56E02FB_impl*
 // Только для форм без сборки (сборка сама занимается сохранением)
 if not Assigned(aForm.FormSet) then
  InternalSaveState(aForm, vcm_stContent, True)
 else
 if aForm.IsMainInFormSet then
  if (g_LockBeforeFormDestroy = 0) then
   with aForm.FormSet do
   begin
    PopToHistory;
    SaveHistory;
   end;//if aForm.IsMainInFormSet then
//#UC END# *499559BF038A_5506D56E02FB_impl*
//#UC START# *499559BF038A_5506D56E02FB_var*
//#UC END# *499559BF038A_5506D56E02FB_var*
//#UC START# *499559C900EE_5506D56E02FB_impl*
 Result := InternalSaveState(aForm, aStateType, False, True);
//#UC END# *499559C900EE_5506D56E02FB_impl*
//#UC START# *499559C900EE_5506D56E02FB_var*
//#UC END# *499559C900EE_5506D56E02FB_var*
//#UC START# *499559DD00D6_5506D56E02FB_impl*
 Result := InternalSaveState(aForm, aStateType, False);
//#UC END# *499559DD00D6_5506D56E02FB_impl*
//#UC START# *499559DD00D6_5506D56E02FB_var*
//#UC END# *499559DD00D6_5506D56E02FB_var*
//#UC START# *499559EC0143_5506D56E02FB_impl*
 if CheckAnother(aForm, l_History) then
  (l_History as IvcmInternalHistory).SaveClose(aForm, aFormId, aUserType, aZoneType, aSubUserType)
 else
  Add(TvcmHistoryItemPrim.Make(aForm, vcm_stContent, aFormId, aUserType, aZoneType, vcm_hitClose, aSubUserType, False));
//#UC END# *499559EC0143_5506D56E02FB_impl*
//#UC START# *499559EC0143_5506D56E02FB_var*
var
 l_History: IvcmHistory;
//#UC END# *499559EC0143_5506D56E02FB_var*
//#UC START# *49955A0E01FD_5506D56E02FB_impl*
 l_Check := True;
 while (f_Current > 0) do
 begin
  if Supports(f_History[f_Current - 1], IvcmContainerHistoryItem, l_ContItem) then
  begin
   l_Check := False;
   for l_Index := 0 to l_ContItem.ItemsCount - 1 do
    if Check(l_ContItem.GetItem(l_Index)) then
    begin
     l_Check := True;
     Break;
    end;//Check(l_ContItem.GetItem(l_Index))
  end//Supports(f_History[f_Current - 1], IvcmContainerHistoryItem, l_ContItem)
  else
   l_Check := Check(f_History[f_Current - 1]);
  Back;
  if not l_Check then
   Break;
 end;//while (f_Current > 0)
 Result := not l_Check;
//#UC END# *49955A0E01FD_5506D56E02FB_impl*
//#UC START# *49955A0E01FD_5506D56E02FB_var*
 function Check(const aItem: IvcmHistoryItem): Boolean;
 var
  l_FormItem: IvcmFormHistoryItem;
 begin//Check
  Result := Supports(aItem, IvcmFormHistoryItem,
   l_FormItem) and not l_FormItem.FormClass.EQ(aFormClass) and
   ((aUserType = vcm_utAny) or (l_FormItem.UserType = aUserType));
 end;//Check

var
 l_ContItem: IvcmContainerHistoryItem;
 l_Check: Boolean;
 l_Index: Integer;
//#UC END# *49955A0E01FD_5506D56E02FB_var*
//#UC START# *49955A280277_5506D56E02FB_impl*
 l_Accept := True;
 Result := CanBack;
 if not f_Multi then
  f_Last := True;
 if Result then
 begin
  if not f_History[f_Current - 1].IsAcceptable then
  begin
   DeleteBackItem;
   Result := Back(aTruncate);
   Exit;
  end;
  g_Dispatcher.FormDispatcher.Lock;
  try
   g_Dispatcher.StoreFocus;
   try
    g_Dispatcher.BeginOp;
    try
     Dec(f_Current);
     l_Current := f_Current;
     f_InBF := True;
     try
      f_InBack := True;
      l_Item := f_History[l_Current];
      l_Accept := l_Item.Activate(MainForm);
      //
      if aTruncate and (l_Current >= 0) then
       f_History.Count := l_Current;
     finally
      f_InBF := False;
     end;//try..finally
     f_Current := l_Current;
    finally
     g_Dispatcher.EndOp;
    end;//try..finally
   finally
    g_Dispatcher.RestoreFocus;
   end;//try..finally
  finally
   g_Dispatcher.FormDispatcher.Unlock;
  end;//try..finally
  if not l_Accept then
  begin
   Result := Back(True);
  end;
 end;//f_Current > 0
//#UC END# *49955A280277_5506D56E02FB_impl*
//#UC START# *49955A280277_5506D56E02FB_var*
var
 l_Current: Integer;
 l_Item: IvcmHistoryItem;
 l_Accept: Boolean;
//#UC END# *49955A280277_5506D56E02FB_var*
//#UC START# *49955A3202E4_5506D56E02FB_impl*
 l_Accept := True;
 Result := CanForward;
 if not f_Multi then
  f_Last := True;
 if Result then
 begin
  if not f_History[f_Current].IsAcceptable then
  begin
   DeleteForwardItem;
   Result := Forward;
   Exit;
  end;
  g_Dispatcher.FormDispatcher.Lock;
  try
   g_Dispatcher.StoreFocus;
   try
    g_Dispatcher.BeginOp;
    try
     l_Current := f_Current;
     f_InBF := True;
     try
      f_InBack := False;
      l_Item := f_History[l_Current];
      l_Accept := l_Item.Activate(MainForm);
     finally
      f_InBF := False;
     end;//try..finally
     f_Current := Succ(l_Current);
    finally
     g_Dispatcher.EndOp;
    end;//try..finally
   finally
    g_Dispatcher.RestoreFocus;
   end;//try..finally
  finally
   g_Dispatcher.FormDispatcher.Unlock;
  end;//try..finally
  if not l_Accept then
   if CanForward then
    Result := Forward
   else
    Back(True);
 end;//f_Current >= 0
//#UC END# *49955A3202E4_5506D56E02FB_impl*
//#UC START# *49955A3202E4_5506D56E02FB_var*
var
 l_Current: Integer;
 l_Item: IvcmHistoryItem;
 l_Accept: Boolean;
//#UC END# *49955A3202E4_5506D56E02FB_var*
//#UC START# *49955A4401E0_5506D56E02FB_impl*
 l_To := aParams.ItemIndex;
 if (l_To <= 0) then
  l_To := 1;
 f_Multi := True;
 try
  f_Last := l_To = 1;
  while (l_To > 0) and Back(aTruncate) do
  begin
   Dec(l_To);
   f_Last := l_To = 1;
  end;
 finally
  f_Multi := False;
  f_Last := True;
 end;
//#UC END# *49955A4401E0_5506D56E02FB_impl*
//#UC START# *49955A4401E0_5506D56E02FB_var*
var
 l_To: Integer;
//#UC END# *49955A4401E0_5506D56E02FB_var*
//#UC START# *49955A4F00AB_5506D56E02FB_impl*
 l_To := aParams.ItemIndex;
 if (l_To <= 0) then
  l_To := 1;
 f_Multi := True;
 f_Last := l_To = 1;
 try
  while (l_To > 0) and Forward do
  begin
   Dec(l_To);
   f_Last := l_To = 1;
  end;
 finally
  f_Multi := False;
  f_Last := True; 
 end; 
//#UC END# *49955A4F00AB_5506D56E02FB_impl*
//#UC START# *49955A4F00AB_5506D56E02FB_var*
var
 l_To: Integer;
//#UC END# *49955A4F00AB_5506D56E02FB_var*
//#UC START# *49955A5B00B1_5506D56E02FB_impl*
 Result := (f_History <> nil) and (f_Current > 0) and (f_Current <= f_History.Count);
//#UC END# *49955A5B00B1_5506D56E02FB_impl*
//#UC START# *49955A5B00B1_5506D56E02FB_var*
//#UC END# *49955A5B00B1_5506D56E02FB_var*
//#UC START# *49955A6701A1_5506D56E02FB_impl*
 Result := (f_History <> nil) and (f_Current >= 0) and (f_Current < f_History.Count);
//#UC END# *49955A6701A1_5506D56E02FB_impl*
//#UC START# *49955A6701A1_5506D56E02FB_var*
//#UC END# *49955A6701A1_5506D56E02FB_var*
//#UC START# *49955A71029F_5506D56E02FB_impl*
 with aParams.Op.SubItems do
 begin
  Clear;
  if (f_History <> nil) then
   for l_Index := Pred(f_Current) downto Max(f_Current - cMaxCount, 0) do
    Add(GetCaption(l_Index));
 end;//with aParams.Op.SubItems
//#UC END# *49955A71029F_5506D56E02FB_impl*
//#UC START# *49955A71029F_5506D56E02FB_var*
var
 l_Index: Integer;
//#UC END# *49955A71029F_5506D56E02FB_var*
//#UC START# *49955A7B015F_5506D56E02FB_impl*
 with aParams.Op.SubItems do
 begin
  Clear;
  if (f_History <> nil) then
   for l_Index := f_Current to Pred(Min(f_Current + cMaxCount, f_History.Count)) do
    Add(GetCaption(l_Index));
 end;//with aParams.Op.SubItems
//#UC END# *49955A7B015F_5506D56E02FB_impl*
//#UC START# *49955A7B015F_5506D56E02FB_var*
var
 l_Index: Integer;
//#UC END# *49955A7B015F_5506D56E02FB_var*
//#UC START# *49955A870211_5506D56E02FB_impl*
 if CheckAnother(aSender, l_History) then
  l_History.Start(aSender)
 else
 begin
  if (f_Starts = 0) then
  begin
   // Пока закомментировал в связи с
   // http://mdp.garant.ru/pages/viewpage.action?pageId=424393579
   // Assert(aCaption = nil);
   // - проверяем необходимомсть параметра
   if not aFormSet then
    f_ContainerItem := TvcmContainerHistoryItem.Make(aCaption)
   else
    f_ContainerItem := TvcmContainerFormSetHistoryItem.Make(aCaption);
  end;//f_Starts = 0
  Inc(f_Starts);
  if (f_Starts = 1) then
  begin
   f_Delta := 0;
   if (f_Forms <> nil) then
   begin
    f_ForceSave := True;
    try
     l_Delta := 0;
     with f_Forms do
     begin
      l_Index := 0;
      while (l_Index < Count) do
      begin
       l_Form := Items[l_Index];
       if l_Form.InClose then
       begin
        if SaveState(l_Form, vcm_stContent) then
         Inc(l_Delta);
       end//l_Form.InClose
       else
       begin
        if SaveState(l_Form, vcm_stPosition) then
         Inc(l_Delta);
       end;//l_Form.InClose
       Inc(l_Index);
      end;//while (l_Index < Count)
     end;//with f_Forms
     f_Delta := l_Delta;
    finally
     f_ForceSave := False;
    end;//try..finally
   end;//f_Forms <> nil
  end;//f_Starts = 1
 end;//CheckAnother(aForm, l_History)
//#UC END# *49955A870211_5506D56E02FB_impl*
//#UC START# *49955A870211_5506D56E02FB_var*
var
 l_Index: Integer;
 l_Delta: Integer;
 l_History: IvcmHistory;
 l_Form: IvcmEntityForm;
//#UC END# *49955A870211_5506D56E02FB_var*
//#UC START# *49955AA6028E_5506D56E02FB_impl*
 if CheckAnother(aSender, l_History) then
  l_History.Finish(aSender)
 else
 begin
  Dec(f_Starts);
  if (f_Starts = 0) then
  begin
   l_Container := f_ContainerItem;
   f_ContainerItem := nil;
   if (l_Container <> nil) and
      not l_Container.IsEmpty and
      (l_Container.ItemsCount > f_Delta) then
   begin
    if (l_Container.ItemsCount > 1) then
     Add(l_Container)
    else
     Add(l_Container.GetItem(0));
   end;//not l_Container.IsEmpty
  end;//f_Starts = 0
 end;//CheckAnother(aSender, l_History)
//#UC END# *49955AA6028E_5506D56E02FB_impl*
//#UC START# *49955AA6028E_5506D56E02FB_var*
var
 l_Container: IvcmContainerHistoryItem;
 l_History: IvcmHistory;
//#UC END# *49955AA6028E_5506D56E02FB_var*
//#UC START# *49955AB102DB_5506D56E02FB_impl*
 if CheckAnother(aForm, l_History) then
  l_History.AddForm(aForm)
 else
 begin
  if (f_Forms = nil) then
   f_Forms := TvcmIEntityFormPtrList.MakeSorted;
  f_Forms.Add(aForm);
 end;//CheckAnother(aForm, l_History)
//#UC END# *49955AB102DB_5506D56E02FB_impl*
//#UC START# *49955AB102DB_5506D56E02FB_var*
var
 l_History: IvcmHistory;
//#UC END# *49955AB102DB_5506D56E02FB_var*
//#UC START# *49955ABC00AD_5506D56E02FB_impl*
 if CheckAnother(aForm, l_History) then
 begin
  if (l_History <> nil) then // здесь эта проверка нужна !!!
   l_History.RemoveForm(aForm)
 end
 else
 begin
  if (f_Forms <> nil) then
   f_Forms.Remove(aForm);
 end;//CheckAnother(aForm, l_History)
//#UC END# *49955ABC00AD_5506D56E02FB_impl*
//#UC START# *49955ABC00AD_5506D56E02FB_var*
var
 l_History: IvcmHistory;
//#UC END# *49955ABC00AD_5506D56E02FB_var*
//#UC START# *49955AC80055_5506D56E02FB_impl*
 if (f_ContainerItem <> nil) then
 begin
  Result := f_ContainerItem.Add(anItem, f_Delta);
 end//f_ContainerItem <> nil
 else
 begin
  if (f_History = nil) then
   f_History := TvcmHistoryItemList.Create;
  if (f_Current >= f_History.Count) then
   Result := (f_History.Add(anItem) >= 0)
  else
  begin
   Result := True;
   f_History[f_Current] := anItem;
   if not f_InBF then
    f_History.Count := Succ(f_Current);
  end;
  if not f_InBF then
  begin
   l_Index := 0;
   while (f_History.Count - l_Index > g_vcmHistoryLimit) do
   begin
    if f_History[l_Index].Drop then
     // - удалось выместить на диск
     Inc(l_Index)
    else
    begin
     f_History.Delete(l_Index);
     Dec(f_Current);
    end;//f_History[l_Index].Drop
   end;//f_History.Count > g_vcmHistoryLimit
  end;//not f_InBF
  Inc(f_Current);
 end;//f_ContainerItem <> nil
//#UC END# *49955AC80055_5506D56E02FB_impl*
//#UC START# *49955AC80055_5506D56E02FB_var*
var
 l_Index: Integer;  
//#UC END# *49955AC80055_5506D56E02FB_var*
//#UC START# *49955AD6022E_5506D56E02FB_impl*
 Result := f_Last;
//#UC END# *49955AD6022E_5506D56E02FB_impl*
//#UC START# *49955AD6022E_5506D56E02FB_var*
//#UC END# *49955AD6022E_5506D56E02FB_var*
//#UC START# *49955AE20023_5506D56E02FBget_impl*
 Result := f_InBF;
//#UC END# *49955AE20023_5506D56E02FBget_impl*
//#UC START# *49955AE20023_5506D56E02FBget_var*
//#UC END# *49955AE20023_5506D56E02FBget_var*
//#UC START# *49955AF40024_5506D56E02FBget_impl*
 Result := (f_Starts <> 0);
//#UC END# *49955AF40024_5506D56E02FBget_impl*
//#UC START# *49955AF40024_5506D56E02FBget_var*
//#UC END# *49955AF40024_5506D56E02FBget_var*
//#UC START# *49EDA518032B_5506D56E02FB_impl*
 Result := f_InBack;
//#UC END# *49EDA518032B_5506D56E02FB_impl*
//#UC START# *49EDA518032B_5506D56E02FB_var*
//#UC END# *49EDA518032B_5506D56E02FB_var*
//#UC START# *4DB0239600EC_5506D56E02FB_impl*
 Assert(not f_InBF);
 Assert({$IfDef nsTest}not aHeedCheckCurrent or {$EndIf}(f_Starts <= 0));
 f_Starts := 0;
 f_Current := 0;
 if (f_History <> nil) then
  f_History.Clear;
//#UC END# *4DB0239600EC_5506D56E02FB_impl*
//#UC START# *4DB0239600EC_5506D56E02FB_var*
//#UC END# *4DB0239600EC_5506D56E02FB_var*
//#UC START# *4E82C9D3005D_5506D56E02FB_impl*
 Assert(not f_InBF);
 Assert(f_Starts <= 0);
 Assert(f_Current > 0);
 Assert(f_Current <= f_History.Count);
 Dec(f_Current);
 f_History.Delete(f_Current);
//#UC END# *4E82C9D3005D_5506D56E02FB_impl*
//#UC START# *4E82C9D3005D_5506D56E02FB_var*
//#UC END# *4E82C9D3005D_5506D56E02FB_var*
//#UC START# *4FC4CF3F01DC_5506D56E02FB_impl*
 Result := Max(f_Current, 0);
//#UC END# *4FC4CF3F01DC_5506D56E02FB_impl*
//#UC START# *4FC4CF3F01DC_5506D56E02FB_var*
//#UC END# *4FC4CF3F01DC_5506D56E02FB_var*
//#UC START# *4FC4CF570044_5506D56E02FB_impl*
 Result := Max(f_History.Count - f_Current, 0);
//#UC END# *4FC4CF570044_5506D56E02FB_impl*
//#UC START# *4FC4CF570044_5506D56E02FB_var*
//#UC END# *4FC4CF570044_5506D56E02FB_var*
//#UC START# *4FC4CF6B0145_5506D56E02FB_impl*
 Result := GetCaption(GetBackCount - anIndex - 1);
//#UC END# *4FC4CF6B0145_5506D56E02FB_impl*
//#UC START# *4FC4CF6B0145_5506D56E02FB_var*
//#UC END# *4FC4CF6B0145_5506D56E02FB_var*
//#UC START# *4FC4CF840110_5506D56E02FB_impl*
 Result := GetCaption(GetBackCount + anIndex);
//#UC END# *4FC4CF840110_5506D56E02FB_impl*
//#UC START# *4FC4CF840110_5506D56E02FB_var*
//#UC END# *4FC4CF840110_5506D56E02FB_var*
//#UC START# *53DE68ED020E_5506D56E02FB_impl*
 Assert(not f_InBF);
 Assert(f_Starts <= 0);
 Assert(f_Current >= 0);
 Assert(f_Current < f_History.Count);
 f_History.Delete(f_Current);
//#UC END# *53DE68ED020E_5506D56E02FB_impl*
//#UC START# *53DE68ED020E_5506D56E02FB_var*
//#UC END# *53DE68ED020E_5506D56E02FB_var*
//#UC START# *5506D54601F8_5506D56E02FB_impl*
 if (g_LockHistory > 0) then
  Result := False
 else
 if CheckAnother(aForm, l_History) then
  Result := (l_History as IvcmInternalHistory).InternalSaveState(aForm, aStateType, InDestroy)
 else
 begin
  if aForceSave or NeedSaveForm(aForm, InDestroy) then
  begin
   if InDestroy then
    Start(aForm);
   try
    Result := Add(TvcmHistoryItem.Make(aForm, aStateType, InDestroy, False));
   finally
    if InDestroy then
     Finish(aForm);
   end;//try..finally
  end//NeedSaveForm
  else
   Result := False;
 end;//CheckAnother(aForm, l_History)
//#UC END# *5506D54601F8_5506D56E02FB_impl*
//#UC START# *5506D54601F8_5506D56E02FB_var*
var
 l_History: IvcmHistory;
//#UC END# *5506D54601F8_5506D56E02FB_var*
//#UC START# *5506D56E02FB_ext:ParentFileName
w:\common\components\gui\Garant\VCM\implementation\vcmHistory.pas
//#UC END# *5506D56E02FB_ext:ParentFileName
//#UC START# *5506D8CD0392_5506D56E02FBget_impl*
 Result := IvcmEntityForm(f_MainForm);
//#UC END# *5506D8CD0392_5506D56E02FBget_impl*
//#UC START# *5506D8CD0392_5506D56E02FBget_var*
//#UC END# *5506D8CD0392_5506D56E02FBget_var*
//#UC START# *5506D91401EE_5506D56E02FB_impl*
 Result := False;
 if (aForm = nil) then
  Exit;
 if f_ForceSave and not InDestroy then
 begin
  Result := True;
  Exit;
 end;//f_ForceSave..
 l_Main := MainForm;
 if (l_Main = nil) then
  Exit;
 try
  l_VMain := l_Main.VCLWinControl;
  l_Form := aForm;
  l_Container := aForm.Container;
  while True do
  begin
   if (l_Container = nil) or l_Container.IsNULL then
    Exit;
   if (l_Container.AsForm.VCLWinControl = l_VMain) then
    if (l_Form.ZoneType in g_MenuManager.HistoryZones) then
     Break
    else
     Exit;
   l_Form := l_Container.AsForm;
   l_Container := l_Container.AsForm.Container;
  end;//while True
  Result := True;
 finally
  // - если форма находится в списке добавленных и руками дернули ее сохранение
  if not Result and (f_Forms <> nil) then
   Result := (f_Forms.IndexOf(aForm) >= 0);
 end;//try..finally
//#UC END# *5506D91401EE_5506D56E02FB_impl*
//#UC START# *5506D91401EE_5506D56E02FB_var*
var
 l_Main: IvcmEntityForm;
 l_VMain: TWinControl;
 l_Container: IvcmContainer;
 l_Form: IvcmEntityForm;
//#UC END# *5506D91401EE_5506D56E02FB_var*
//#UC START# *5506D937025E_5506D56E02FB_impl*
 Result := False;
 if (aForm <> nil) then
 begin
  l_Form := (aForm.VCLWinControl as TCustomForm);
  while (l_Form <> nil) do
  begin
   if Supports(l_Form, IvcmMainForm, l_MainForm) then
   try
    l_History := l_MainForm.History;
    if not vcmIEQ(Self, l_History) then
    begin
     Result := True;
     theHistory := l_History;
    end;//not vcmIEQ(Self, l_History)
    Break;
   finally
    l_MainForm := nil;
   end;//try..finally
   l_Form := afw.GetAnotherParentForm(l_Form);
  end;//while True
 end;//aForm = nil
//#UC END# *5506D937025E_5506D56E02FB_impl*
//#UC START# *5506D937025E_5506D56E02FB_var*
var
 l_Form: TCustomForm;
 l_MainForm: IvcmMainForm;
 l_History: IvcmHistory;
//#UC END# *5506D937025E_5506D56E02FB_var*
//#UC START# *5506D97302DF_5506D56E02FB_impl*
 if (f_History = nil) or (anIndex < 0) or (anIndex >= f_History.Count) then
  Result := str_vcmWrongHistoryElement.AsCStr
 else
 begin
  Result := f_History[anIndex].Caption;
  if vcmIsNil(Result) then
   Result := vcmCStr(IntToStr(Succ(anIndex)));
 end;//f_History = nil..
 if (vcmLen(Result) > cLen) then
 begin
  l_Res := vcmStr(Result);
  SetLength(l_Res, cLen - Length(cCont));
  Result := vcmCStr(l_Res + cCont);
 end;//Length(Result)
//#UC END# *5506D97302DF_5506D56E02FB_impl*
//#UC START# *5506D97302DF_5506D56E02FB_var*
const
 cCont = '...';
 cLen = 73;
var
 l_Res: AnsiString; 
//#UC END# *5506D97302DF_5506D56E02FB_var*
//#UC START# *5506D99500B7_5506D56E02FB_impl*
 inherited Create;
 f_MainForm := Pointer(aMainForm);
 f_Last := True;
//#UC END# *5506D99500B7_5506D56E02FB_impl*
//#UC START# *5506D99500B7_5506D56E02FB_var*
//#UC END# *5506D99500B7_5506D56E02FB_var*
//#UC START# *5583A8D20275_5506D56E02FB_impl*
 for l_Index := 0 to Pred(f_History.Count) do
 begin
  if Supports(f_History[l_Index], IvcmFormHistoryItem, l_FormItem) then
  try
   l_FormItem.ResetContainer;
  finally
   l_FormItem := nil;
  end;
 end;
//#UC END# *5583A8D20275_5506D56E02FB_impl*
//#UC START# *5583A8D20275_5506D56E02FB_var*
var
 l_Index: Integer;
 l_FormItem: IvcmFormHistoryItem;
//#UC END# *5583A8D20275_5506D56E02FB_var*
//#UC START# *558A5FAC01CC_5506D56E02FB_impl*
 Result := TvcmHistoryState.Make(f_History, f_Current, f_ContainerItem);
//#UC END# *558A5FAC01CC_5506D56E02FB_impl*
//#UC START# *558A5FAC01CC_5506D56E02FB_var*
//#UC END# *558A5FAC01CC_5506D56E02FB_var*
//#UC START# *558A5FD70198_5506D56E02FB_impl*
 if (aState.Items <> nil) then
 begin
  if (f_History = nil) then
   f_History := TvcmHistoryItemList.Create;
  f_History.Assign(aState.Items);
 end;
 f_Current := aState.Current;
 f_ContainerItem := aState.ContainerItem;
//#UC END# *558A5FD70198_5506D56E02FB_impl*
//#UC START# *558A5FD70198_5506D56E02FB_var*
//#UC END# *558A5FD70198_5506D56E02FB_var*
//#UC START# *559F70D00030_5506D56E02FB_impl*
 f_SavingClone := True;
 try
  if not Assigned(aForm.FormSet) then
   InternalSaveState(aForm, vcm_stContent, True)
  else
  if aForm.IsMainInFormSet then
   if (g_LockBeforeFormDestroy = 0) then
    with aForm.FormSet do
    begin
     PopToHistory;
     SaveHistory;
    end;//if aForm.IsMainInFormSet then
 finally
  f_SavingClone := False;
 end;
//#UC END# *559F70D00030_5506D56E02FB_impl*
//#UC START# *559F70D00030_5506D56E02FB_var*
//#UC END# *559F70D00030_5506D56E02FB_var*
