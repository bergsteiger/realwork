//#UC START# *5506DD5502B6_ext:ParentFileName
w:\common\components\gui\Garant\VCM\implementation\vcmHistory.pas
//#UC END# *5506DD5502B6_ext:ParentFileName
//#UC START# *550828F60179_5506DD5502B6_impl*
 Result := True;
 l_SaveSelf := Self;
 try
  if not IsEmpty then
  begin
   l_NeedLock := False;
   if aMainForm.AsContainer.HasForm(vcm_ztMainObjectForm, True, @l_MainObjectForm) then
   begin
    if not l_MainObjectForm.IsMainInFormSet then
     l_MainObjectForm := l_MainObjectForm.Container.AsForm;
    if (l_MainObjectForm <> nil) then
     if (l_MainObjectForm.IsMainInFormSet) then
     begin
      l_NeedLock := True;
      g_Dispatcher.History.BeforeFormDestroy(l_MainObjectForm);
     end;//l_MainObjectForm.IsMainInFormSet
   end;//aMainForm.AsContainer.HasForm(vcm_ztMainObjectForm
   if l_NeedLock then
    Inc(g_LockBeforeFormDestroy);
   try
    l_List := TvcmHistoryItemList.Create;
    try
     // Нам нужно получить FormSet до того как мы начнем активировать элементы,
     // т.к. в процессе активации данные элементов будут замененны:
     l_FormSet := nil;
     if (Hi >= 0) then
      Supports(Items[0], IvcmFormSet, l_FormSet);

     l_FormSet.Container := aMainForm.AsContainer;


     // Формы которые должны быть закрыты. Сохраняем сначала, поэтому что была
     // ситуация, когда в текущем и предыдущем шаге разные формы находились в
     // одном контейнере, при создании Формы1 существующая Форма2 удалялась и
     // когда доходили до элемента истории связанного с Формой2 он не заполнялся,
     // поскольку Формы2 уже не было (cq 00018103). Поэтому сначала сохраняются
     // формы, которые должны быть закрыты, потом создаются новые, или
     // перегружаются существующие.
     //
     for l_Index := Hi downto Lo do
      // for l_Index := Hi downto Lo do
      //   - потому, что формы из сборки записываются рекурсивным обходом дерева
      //     сборки и нам нужно сначала закрыть детей потом родителей, в которые
      //     они вложены.
      if Supports(Items[l_Index], IvcmFormHistoryItem, l_FormItem) then
      begin
       with l_FormItem do
        if ItemType = vcm_hitClose then
         Activate(aMainForm)
        else
         // l_List.Insert(0, Items[l_Index]) -
         //   - с точностью до наоборот, создаем родителей, потом детей.
         l_List.Insert(0, Items[l_Index]);
      end//Supports(Items[l_Index], IvcmFormHistoryItem, l_FormItem)
 (*     else
      if Supports(Items[l_Index], IvcmObjectWithDataHistoryItem) then
       IvcmHistoryItem(Items[l_Index]).Activate(aMainForm)*)
   // Это всё попытки залечить http://mdp.garant.ru/pages/viewpage.action?pageId=267324195
   // но дело оказалось не в этом
      ;
     // Формы которые должны быть созданы
     for l_Index := l_List.Lo to l_List.Hi do
      with l_List[l_Index] do
       Activate(aMainForm);
     // Сообщим, что можно обновлять представление сборки:
     if l_FormSet <> nil then
      l_FormSet.PushFromHistory;
    finally
     FreeAndNil(l_List);
    end;//try..finally
   finally
    if l_NeedLock then
     Dec(g_LockBeforeFormDestroy);
   end;//try..finally
  end;//if not IsEmpty then
 finally
  l_SaveSelf := nil;
 end;//try..finally
//#UC END# *550828F60179_5506DD5502B6_impl*
//#UC START# *550828F60179_5506DD5502B6_var*
var
 l_SaveSelf: IUnknown;
 l_Index: Integer;
 l_List: TvcmHistoryItemList;
 l_FormItem: IvcmFormHistoryItem;
 l_FormSet: IvcmFormSet;
 l_MainObjectForm: IvcmEntityForm;
 l_NeedLock: Boolean;
//#UC END# *550828F60179_5506DD5502B6_var*
