//#UC START# *479731C50290_560A5BC502D5_impl*
 if Assigned(f_Filer) then
 begin
  try
   f_Filer.Flush;
   if f_Filer.Size = 0 then // если в файл ничего не записано, то файл надо удалить
   begin
    while f_Filer.Opened do
     f_Filer.Close;
    DeleteFile(f_Filer.FileName);
   end;
  finally
   FreeAndNil(f_Filer);
  end; // try...finally
 end;
 inherited;
//#UC END# *479731C50290_560A5BC502D5_impl*
//#UC START# *479731C50290_560A5BC502D5_var*
//#UC END# *479731C50290_560A5BC502D5_var*
//#UC START# *5603F0260334_560A5BC502D5get_impl*
 if (f_Filer = nil) or ((f_PartSize > 0) and (f_Filer.Size > f_PartSize)) then
 begin
  FreeAndNil(f_Filer);
  if f_PartSize > 0 then
  begin
   Inc(f_PartNum);
   l_FileName := l3Str(l3StringReplace(f_FileMask, cExportFileMaskPatterns[eptPartNum], l3PCharLen(IntToStr(f_PartNum)), [rfReplaceAll, rfIgnoreCase]));
  end
  else
   l_FileName := l3Str(f_FileMask);
  try
   if f_UpdateFiles and FileExists(l_FileName) then
    f_Filer := Tl3DOSFiler.Make(l_Filename, l3_fmAppend)
   else
    f_Filer := Tl3DOSFiler.Make(l_Filename, l3_fmWrite);
   // Файлер открываем два раза. Потому что неизвестно, будет ли этот файлер последним в выливке. А если будет - то труба
   // его закроет. И тогда не сработает логика удаления пустого файла в Cleanup.
   f_Filer.Open;
   f_Filer.Open;
   f_Filer.CodePage := f_CodePage;
  except
   on E: Exception do
    l3System.Msg2Log(cFilerOpenErrorMsg, [E.Message, l_FileName]);
  end;
 end;
 f_RollBackPos := f_Filer.Stream.Position;
 Result := f_Filer;
//#UC END# *5603F0260334_560A5BC502D5get_impl*
//#UC START# *5603F0260334_560A5BC502D5get_var*
var
 l_FileName: AnsiString;
//#UC END# *5603F0260334_560A5BC502D5get_var*
//#UC START# *560A5BC502D5_ext:FileName
w:\common\components\rtl\Garant\dd\PipeOut\ddExportFilerDispatcherElem.pas
//#UC END# *560A5BC502D5_ext:FileName
//#UC START# *560A5BC502D5impl_uses*
//#UC END# *560A5BC502D5impl_uses*
//#UC START# *560A5C2D0282_560A5BC502D5_impl*
  inherited Create;
  f_FileMask := aFileMask;
  f_PartSize := aPartSize;
  f_CodePage := aCodePage;
  f_UpdateFiles := aUpdateFiles;
//#UC END# *560A5C2D0282_560A5BC502D5_impl*
//#UC START# *560A5C2D0282_560A5BC502D5_var*
//#UC END# *560A5C2D0282_560A5BC502D5_var*
//#UC START# *5616668C01A8_560A5BC502D5_impl*
 if Assigned(f_Filer) then
 begin
  f_Filer.Stream.Position := f_RollBackPos;
  f_Filer.Seek(0, soEnd);
 end;
//#UC END# *5616668C01A8_560A5BC502D5_impl*
//#UC START# *5616668C01A8_560A5BC502D5_var*
//#UC END# *5616668C01A8_560A5BC502D5_var*
