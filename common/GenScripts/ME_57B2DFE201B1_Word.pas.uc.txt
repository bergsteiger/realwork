//#UC START# *57B2DFE201B1_57B2DFE201B1_Word_impl*
 Case aCacheWhere.rType of
  tfw_vtIntf:
   l_Word := (aCacheWhere.AsIntf As ItfwWordBox).Boxed As TtfwWord;
  tfw_vtObj:
   l_Word := aCacheWhere.AsObject As TtfwWord;
  else
  begin
   aLambda.DoIt(aCtx);
   Exit;
  end;//else
 end;//Case aCacheWhere.rType

 if (l_Word = nil) OR (l_Word.GetRefForCompare = nil) then
 begin
  aLambda.DoIt(aCtx);
  //aCtx.rEngine.Push(aDefault);
  //- вообще-то тут надо звать aLambda.DoIt(aCtx); по-аналогии с DoCache
  Exit;
 end;//(l_Word = nil) OR (l_Word.GetRefForCompare)

 l_V := TmsmModelElementMethodValue_C(l_Word, aKey);
 with TmsmModelElementMethodValueCache.Instance do
 begin
  Lock;
  try
   if FindData(l_V, l_Index) then
   begin
    aCtx.rEngine.Push(ItemSlot(l_Index)^.rValue);
    //aCtx.rEngine.Push(Items[l_Index].rValue);
    Exit;
   end;//FindData(l_V, l_Index)
  finally
   Unlock;
  end;//try..finally
  aLambda.DoIt(aCtx);
  // - а вот это надо бы обернуть в try..except и использовать aDefault, по-аналогии с DoCache
  // - при трансформации элементов внутри надо звать Ctx:EnterCS/Ctx:LeaveCS
  l_V.rValue := aCtx.rEngine.Top^;
  {$IfDef MSM}
(*  if (l_V.rValue.rType = tfw_vtList) then
   if (l_V.rValue.AsIntf <> nil) then
    if ItfwValueList(l_V.rValue.AsIntf).IsView then
     Assert(false);*)
  {$EndIf MSM}
  Add(l_V);
 end;//with TmsmModelElementMethodValueCache.Instance
//#UC END# *57B2DFE201B1_57B2DFE201B1_Word_impl*
//#UC START# *57B2DFE201B1_57B2DFE201B1_Word_var*
var
 l_Word : TtfwWord;
 l_V : TmsmModelElementMethodValue;
 l_Index : Integer;
//#UC END# *57B2DFE201B1_57B2DFE201B1_Word_var*
//#UC START# *57B2DFE201B1_Word_ext:ParentFileName
w:\common\components\gui\Garant\msm\msmWordsCachePack.pas
//#UC END# *57B2DFE201B1_Word_ext:ParentFileName
