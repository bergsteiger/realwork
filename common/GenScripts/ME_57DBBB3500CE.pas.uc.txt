//#UC START# *479731C50290_57DBBB3500CE_impl*
 FreeAndNil(f_Message);
 FreeAndNil(f_Generator);
 FreeAndNil(f_Filer);
 inherited;
//#UC END# *479731C50290_57DBBB3500CE_impl*
//#UC START# *479731C50290_57DBBB3500CE_var*
//#UC END# *479731C50290_57DBBB3500CE_var*
//#UC START# *57DBBB3500CE_ext:FileName
w:\archi\source\projects\Common\Utils\arDirectMultiModifyDocsHelper.pas
//#UC END# *57DBBB3500CE_ext:FileName
//#UC START# *57DBBB3500CEimpl_uses*
//#UC END# *57DBBB3500CEimpl_uses*
//#UC START# *57DBBB72033C_57DBBB3500CEget_impl*
 Result := f_Generator;
//#UC END# *57DBBB72033C_57DBBB3500CEget_impl*
//#UC START# *57DBBB72033C_57DBBB3500CEget_var*
//#UC END# *57DBBB72033C_57DBBB3500CEget_var*
//#UC START# *57DBBB9202CC_57DBBB3500CE_impl*
 if f_DirectAccessMode then
 begin
  TGroupOpFilter(f_Generator).DoneCachingData;
  if f_WasException then
   Exit;
  ProcessForAnoncedList(TGroupOpFilter(f_Generator).DocIDList_forAnonced);
  ProcessForIZMList(TGroupOpFilter(f_Generator).DocIDList_forIZM);
 end
 else
 begin
  Assert(False);
//!! !!! Needs to be implemented !!!
 end;
//#UC END# *57DBBB9202CC_57DBBB3500CE_impl*
//#UC START# *57DBBB9202CC_57DBBB3500CE_var*

 procedure ProcessForAnoncedList(const aDocIDList : Il3IDList);
 var
  lSab : ISab;
  lTypeSab : ISab;
  lTypeSabCursor : ISabCursor;
  I : TUserType;
 begin
  if (aDocIDList = nil) or aDocIDList.Empty then Exit;
  lSab := MakeValueSet(DocumentServer(f_FamilyID).FileTbl, fId_Fld, aDocIDList);
  lSab.RecordsByKey;

  lTypeSab := MakeEmptyValueSab(lSab, fUserType_Fld);
  lTypeSabCursor := lTypeSab.MakeSabCursor([fUserType_Fld]);
  for I := low(TUserType) to high(TUserType) do
   if I in utFullFeatureDocTypes then
    lTypeSabCursor.AddItem(@I);
  lTypeSabCursor := nil;
  lTypeSab.InvertSab;
  lTypeSab.RecordsByKey;
  lSab.SubtractSab(lTypeSab);

  lSab.ValuesOfKey(fId_Fld);

  FilterbyVAnouncedAccGroupsBlackList(lSab);

  LinkServer(f_FamilyID).LogBook.PutLogRecToDocs(lSab, acAnonced, 0, DateTimeToStDate(f_AnouncedDate));
 end;

 procedure ProcessForIZMList(Const aDocIDList : Il3IDList);
 var
  lSab : ISab;
 begin
  if  (aDocIDList = nil) or aDocIDList.Empty then Exit;
  lSab := MakeValueSet(DocumentServer(f_FamilyID).FileTbl, fId_Fld, aDocIDList);
  GetIZMChecker.CheckoutForIZM(lSab);
 end;

//#UC END# *57DBBB9202CC_57DBBB3500CE_var*
//#UC START# *57DF8D6100EC_57DBBB3500CE_impl*
 inherited Create;
 f_DirectAccessMode := aDirectAccess;
 f_WasException := False;
 f_FamilyID := aFamily;
 f_AnouncedDate := anAnouncedDate;
 f_Generator := nil;
 if f_DirectAccessMode then
 begin
  f_Generator := TGroupOpFilter.Create(nil);
  with TGroupOpFilter(f_Generator) do
  begin
   Family := aFamily;
   //CurDocID := DocInfo.DocID;
   InternalFormat := True;
   //ExcludeAttr := []; //CctAllAttributes - [ctHLink, ctSub];
   ExcludeMainRec := false; //True;
   case OperType of
    atAdd    : SaveMode := smAttrAdd;
    atDelete : SaveMode := smAttrDel;
   end;

   lDocIDList := dtMakeSortedIDListBySab(aDocIdList);
   SetDocIDList(lDocIDList);

   ExcludeAttr := []; //CctAllAttributes - [ctHLink, ctSub];

   //NeedEventforEraseAttrRec := [ctKW];
   //OnEraseAttrRecords := evntOnEraseAttrRecords;
  end; 
  TGroupOpFilter(f_Generator).StartCachingData;
 end
 else
 begin
  f_Message := TcsMultiModifyDocs.Create;
  TevdNativeWriter.SetTo(f_Generator);
  f_Filer := MakeFilerForMessage(f_Message.Data);
  TevdNativeWriter(f_Generator).Filer := f_Filer;
 end;
//#UC END# *57DF8D6100EC_57DBBB3500CE_impl*
//#UC START# *57DF8D6100EC_57DBBB3500CE_var*
var
 lDocIDList : Il3IDList;
//#UC END# *57DF8D6100EC_57DBBB3500CE_var*
//#UC START# *57DFBB0803B7_57DBBB3500CE_impl*
 f_WasException := True;
//#UC END# *57DFBB0803B7_57DBBB3500CE_impl*
//#UC START# *57DFBB0803B7_57DBBB3500CE_var*
//#UC END# *57DFBB0803B7_57DBBB3500CE_var*
//#UC START# *57E1086001DB_57DBBB3500CE_impl*
 if f_DirectAccessMode then
  Result := TGroupOpFilter(f_Generator).RejectedDocsID.Count > 0
 else
 begin
  Assert(False);
//!! !!! Needs to be implemented !!!
 end;
//#UC END# *57E1086001DB_57DBBB3500CE_impl*
//#UC START# *57E1086001DB_57DBBB3500CE_var*
//#UC END# *57E1086001DB_57DBBB3500CE_var*
//#UC START# *57E108850183_57DBBB3500CE_impl*
 if f_DirectAccessMode then
  for l_IDX := 0 to Pred(TGroupOpFilter(f_Generator).RejectedDocsID.Count) do
   AddToDenyList(f_FamilyID, TGroupOpFilter(f_Generator).RejectedDocsID[l_IDX], aList, True)
 else
 begin
  Assert(False);
//!! !!! Needs to be implemented !!!
 end;
//#UC END# *57E108850183_57DBBB3500CE_impl*
//#UC START# *57E108850183_57DBBB3500CE_var*
var
 l_IDX: Integer;
//#UC END# *57E108850183_57DBBB3500CE_var*
