unit evCustomEditorWindow;
{* Реализация базового оконного элемента для отображения содержимого документа. }

{ Библиотека "Эверест"    }
{ Автор: Люлин А.В. ©     }
{ Модуль: evEditorWindow - оконный элемент для отображения содержимого документа}
{ Начат: 17.03.1997 19:20 }
{ $Id: evCustomEditorWindow.pas,v 1.150 2016/08/23 11:46:40 kostitsin Exp $ }

// $Log: evCustomEditorWindow.pas,v $
// Revision 1.150  2016/08/23 11:46:40  kostitsin
// {requestlink: 624862173 }
//
// Revision 1.149  2016/03/09 15:18:26  lulin
// - перегенерация.
//
// Revision 1.148  2016/02/07 15:24:57  kostitsin
// - чиню сборку
//
// Revision 1.147  2015/10/28 07:44:13  dinishev
// {Requestlink:610313141}
//
// Revision 1.146  2015/10/08 13:32:43  lulin
// - типизируем интерфейсы.
//
// Revision 1.145  2015/09/28 11:52:30  morozov
// {RequestLink: 604485227}
//
// Revision 1.144  2015/09/28 07:01:21  morozov
// {RequestLink: 604485227}
//
// Revision 1.143  2015/09/25 13:26:13  morozov
// {RequestLink: 604485227}
//
// Revision 1.142  2015/09/22 11:16:34  dinishev
// {Requestlink:606818367}
//
// Revision 1.141  2015/09/15 11:12:05  dinishev
// {Requestlink:606818367}
//
// Revision 1.140  2015/08/19 14:26:04  dinishev
// {Requestlink:396788520}
//
// Revision 1.139  2015/06/03 14:53:30  lulin
// - пытаемся разрулить зависимости.
//
// Revision 1.138  2015/06/03 13:55:17  lulin
// - пытаемся разрулить зависимости.
//
// Revision 1.137  2015/06/03 12:43:15  lulin
// - пытаемся разрулить зависимости.
//
// Revision 1.136  2015/04/24 14:25:31  kostitsin
// no message
//
// Revision 1.135  2015/04/20 12:43:02  dinishev
// {Requestlink:596845383}
//
// Revision 1.134  2015/03/12 15:32:44  lulin
// - перетряхиваем слова.
//
// Revision 1.133  2015/03/02 14:46:01  lulin
// - перетряхиваем слова.
//
// Revision 1.132  2015/02/26 09:28:58  kostitsin
// List*ner -> Listener
//
// Revision 1.131  2015/02/25 13:53:17  kostitsin
// List*ner -> Listener
//
// Revision 1.130  2015/02/25 13:11:43  lulin
// - перегенерация.
//
// Revision 1.129  2015/01/22 19:10:07  kostitsin
// рисуем TeeEditorExport
//
// Revision 1.128  2015/01/19 18:36:35  lulin
// {RequestLink:580710025}
//
// Revision 1.127  2014/12/10 13:30:21  kostitsin
// {requestlink: 533559686 }
//
// Revision 1.126  2014/12/10 13:06:35  kostitsin
// {requestlink: 533559686 }
//
// Revision 1.125  2014/11/27 08:22:48  dinishev
// Bug fix: из-за непонятных костылей для Немезиса падал Арчи.
//
// Revision 1.124  2014/11/26 19:23:36  kostitsin
// {requestlink: 533559686 }
//
// Revision 1.123  2014/10/31 14:20:45  kostitsin
// {requestlink: 533559686 } - открутил обратно. Не помогло.
//
// Revision 1.122  2014/10/24 16:04:40  kostitsin
// {requestlink: 533559686 }
//
// Revision 1.121  2014/04/30 11:23:52  lulin
// - выпрямляем зависимости.
//
// Revision 1.120  2014/04/29 12:03:45  lulin
// - вычищаем ненужный метод.
//
// Revision 1.119  2014/04/25 12:59:20  lulin
// {RequestLink:532613367}
//
// Revision 1.118  2014/04/24 12:26:07  lulin
// [$531960334]
//
// Revision 1.117  2014/04/21 16:54:36  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.116  2014/04/21 15:41:52  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.115  2014/04/21 12:56:50  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.114  2014/04/11 15:52:36  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.113  2014/04/11 15:46:21  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.112  2014/04/11 15:30:29  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.111  2014/04/11 10:54:08  lulin
// {RequestLink:528448870}
//
// Revision 1.110  2014/04/10 15:08:57  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.109  2014/04/10 13:09:44  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.108  2014/04/09 14:35:01  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.107  2014/04/09 10:34:47  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.106  2014/04/07 17:56:59  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.105  2014/04/07 11:19:51  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.104  2014/04/04 17:53:34  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.103  2014/04/03 17:10:25  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.102  2014/03/25 11:53:27  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.101  2014/03/24 16:28:20  lulin
// - чистим код.
//
// Revision 1.100  2014/03/24 15:52:49  lulin
// - выпрямляем наследование.
//
// Revision 1.99  2014/03/24 12:02:14  lulin
// {RequestLink:522793127}
//
// Revision 1.98  2014/03/18 09:59:10  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.97  2014/03/11 16:56:59  lulin
// - причёсываем код.
//
// Revision 1.96  2014/03/04 13:08:19  lulin
// - переводим идентификаторы Sub'ов и сегментов на нормальные Enum'ы.
//
// Revision 1.95  2014/02/24 16:04:39  lulin
// - чистим код.
//
// Revision 1.94  2014/02/21 17:34:41  lulin
// - избавляемся от обёрток над тегами.
//
// Revision 1.93  2014/02/20 10:49:43  lulin
// - переводим словари на теги.
//
// Revision 1.92  2014/02/18 12:08:45  lulin
// - избавляемся от ощибочной бесконечной рекурсии.
//
// Revision 1.91  2014/02/13 15:27:18  lulin
// - рефакторим безликие списки.
//
// Revision 1.90  2014/02/13 15:15:55  lulin
// - рефакторим безликие списки.
//
// Revision 1.89  2013/12/26 12:49:12  lulin
// {RequestLink:509706011}
//
// Revision 1.88  2013/11/08 10:42:56  morozov
// {RequestLink: 488604061}
//
// Revision 1.87  2013/11/06 12:41:04  lulin
// - атомарные типы теперь тоже не имеют постоянного идентификатора для сохранения в поток.
//
// Revision 1.86  2013/10/23 12:25:49  lulin
// - автоматически определяемые типы тоже генерируем с модели.
//
// Revision 1.85  2013/10/21 17:30:59  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.84  2013/10/21 15:42:58  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.83  2013/10/21 10:30:41  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.82  2013/10/16 14:36:24  morozov
// {RequestLink: 425282245}
//
// Revision 1.81  2013/10/09 07:29:56  morozov
// {RequestLink: 488604061}
//
// Revision 1.80  2013/09/08 12:20:56  dinishev
// Bug fix: недокоммител.
//
// Revision 1.79  2013/09/08 08:34:48  dinishev
// {Requestlink:481428636}
//
// Revision 1.78  2013/08/06 14:32:55  dinishev
// New function
//
// Revision 1.77  2013/07/01 05:31:17  lulin
// - чистим код.
//
// Revision 1.76  2013/06/26 12:36:35  kostitsin
// no message
//
// Revision 1.75  2013/06/25 16:23:10  kostitsin
// [$453155865] - FoldersTree
//
// Revision 1.74  2013/05/31 04:58:21  lulin
// - портируем под XE4.
//
// Revision 1.73  2013/05/14 13:36:30  lulin
// {RequestLink:453166247}.
//
// Revision 1.72  2013/04/24 09:35:36  lulin
// - портируем.
//
// Revision 1.71  2013/04/17 14:19:38  lulin
// - портируем.
//
// Revision 1.70  2013/04/04 11:18:51  lulin
// - портируем.
//
// Revision 1.69  2013/03/29 11:36:53  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.68  2013/02/05 10:31:53  dinishev
// Bug fix: AV в логе.
//
// Revision 1.67  2013/01/16 11:53:54  dinishev
// Борьба с AV
//
// Revision 1.66  2012/10/26 14:54:54  lulin
// {RequestLink:406489593}
//
// Revision 1.65  2012/10/26 14:08:43  lulin
// {RequestLink:406489593}
//
// Revision 1.64  2012/10/01 13:14:47  dinishev
// {Requestlink:380622157}
//
// Revision 1.63  2012/09/29 15:24:35  lulin
// {RequestLink:397301416}
//
// Revision 1.62  2012/09/28 09:23:42  dinishev
// {Requestlink:397289578}
//
// Revision 1.61  2012/09/27 11:49:39  dinishev
// {Requestlink:397289578}
//
// Revision 1.60  2012/09/24 09:55:39  dinishev
// {Requestlink:396790773}
//
// Revision 1.59  2012/09/12 13:23:04  dinishev
// {Requestlink:390578250}
//
// Revision 1.58  2012/09/11 06:35:48  fireton
// - если ищем в выделении, выделения нет, но есть выделение от предыдущего поиска, то используем его (K 265418319)
//
// Revision 1.57  2012/09/05 08:25:52  dinishev
// {Requestlink:390577849}
//
// Revision 1.56  2012/08/24 16:05:22  dinishev
// {Requestlink:385483591}
//
// Revision 1.55  2012/08/08 13:07:44  dinishev
// {Requestlink:380623516}
//
// Revision 1.54  2012/08/08 11:06:01  dinishev
// {Requestlink:380623516}
//
// Revision 1.53  2012/08/08 10:20:38  kostitsin
// [$381879735]
//
// Revision 1.52  2012/08/06 13:50:38  dinishev
// {Requestlink:380623516}
//
// Revision 1.51  2012/08/06 11:57:02  kostitsin
// [$381879723]
//
// Revision 1.50  2012/08/01 13:09:17  kostitsin
// [$379249992]
//
// Revision 1.49  2012/07/11 13:00:13  dinishev
// {Requestlink:342859301}. В CheckView уже проверяли на корректность пришедшего TopAnchor, только результатами не пользовались.
//
// Revision 1.48  2012/05/22 06:43:25  dinishev
// Ловушка для EIntOverflow. Не там ловил. :-(
//
// Revision 1.47  2012/05/16 07:11:27  dinishev
// Ловушка для EIntOverflow.
//
// Revision 1.46  2012/04/20 14:56:33  lulin
// {RequestLink:283610570}
//
// Revision 1.45  2012/04/12 06:48:52  dinishev
// {Requestlink:356061447}
//
// Revision 1.44  2012/03/29 15:34:19  lulin
// {RequestLink:352452629}
//
// Revision 1.43  2012/03/27 14:41:39  lulin
// - выделяем общую часть.
//
// Revision 1.42  2012/02/17 10:15:44  dinishev
// Bug fix: отъехало движение меток по сабпанели.
//
// Revision 1.41  2012/02/16 14:26:34  dinishev
// {Requestlink:338003907}
//
// Revision 1.40  2012/02/16 11:45:46  dinishev
// {Requestlink:338003907}
//
// Revision 1.39  2012/02/07 12:48:09  lulin
// - генерируем документацию с словам скриптовой машины.
//
// Revision 1.38  2012/02/07 11:34:49  kostitsin
// [$329646239]
//
// Revision 1.37  2012/02/07 11:12:04  dinishev
// Прячем под дефайны запилы от Немезиса. В Арчи пока никто не заказывал.
//
// Revision 1.36  2012/02/06 13:43:55  dinishev
// {Requestlink:335578573}. Перестарался.
//
// Revision 1.35  2012/02/06 12:41:55  kostitsin
// Костыль для [$329646239]
//                                                                 
// Revision 1.34  2012/02/06 09:14:14  dinishev
// {Requestlink:335578573}
//
// Revision 1.33  2012/02/03 17:09:11  lulin
// {RequestLink:333548940}
// - рисуем изменения Жени на модели.
//
// Revision 1.32  2012/02/03 11:45:43  lulin
// - делаем инфраструктуру для Михаила.
//
// Revision 1.31  2012/01/17 11:58:01  lulin
// {RequestLink:265391594}
// - теперь генерируем предупреждения только когда их надо реально нарисовать.
//
// Revision 1.30  2012/01/10 18:34:51  vkuprovich
// {RequestLink:297713171}
// Откат изменений по просьбе migel
//
// Revision 1.29  2012/01/10 15:42:12  vkuprovich
// {RequestLink:268341731}
// - fix: изменение текста в режиме ReadOnly
//
// Revision 1.28  2011/12/16 14:38:47  lulin
// - убираем борьбу с дублирующимся кодом и пишем комментарии - почему так надо.
//
// Revision 1.27  2011/12/16 14:14:08  kostitsin
// чистка кода
//
// Revision 1.26  2011/12/01 14:44:41  gensnet
// http://mdp.garant.ru/pages/viewpage.action?pageId=280857854
//
// Revision 1.25  2011/11/29 14:05:50  dinishev
// {Requestlink:109904163}
//
// Revision 1.24  2011/11/23 11:58:50  gensnet
// http://mdp.garant.ru/pages/viewpage.action?pageId=297714497
//
// Revision 1.23  2011/10/28 13:13:16  lulin
// {RequestLink:296096620}
//
// Revision 1.22  2011/10/28 10:41:03  lulin
// {RequestLink:227478574}
//
// Revision 1.21  2011/10/26 16:55:57  lulin
// {RequestLink:278135821}.
//
// Revision 1.20  2011/10/13 15:36:29  lulin
// {RequestLink:292913360}.
//
// Revision 1.19  2011/10/06 14:26:44  lulin
// {RequestLink:290264293}.
//
// Revision 1.18  2011/10/03 14:00:56  lulin
// {RequestLink:274465892}.
//
// Revision 1.17  2011/09/22 15:45:41  lulin
// {RequestLink:278836572}.
//
// Revision 1.16  2011/09/20 15:01:38  lulin
// {RequestLink:272663344}.
//
// Revision 1.15  2011/09/15 18:32:06  lulin
// {RequestLink:278824896}.
//
// Revision 1.14  2011/09/14 07:51:44  lulin
// {RequestLink:278824896}.
//
// Revision 1.13  2011/09/08 15:56:02  lulin
// {RequestLink:281532686}.
//
// Revision 1.12  2011/08/05 10:42:55  dinishev
// [$278135327]
//
// Revision 1.11  2011/08/04 11:47:10  lulin
// {RequestLink:278136191}.
//
// Revision 1.10  2011/07/08 10:14:36  lulin
// {RequestLink:273587124}.
//
// Revision 1.9  2011/07/06 11:05:51  lulin
// {RequestLink:254944102}.
//
// Revision 1.8  2011/06/26 11:42:29  lulin
// {RequestLink:270663704}.
//
// Revision 1.7  2011/06/26 09:16:01  lulin
// {RequestLink:271193435}.
//
// Revision 1.6  2011/06/22 10:48:28  lulin
// - приближаем исходники к модели.
//
// Revision 1.696  2011/06/22 10:11:24  lulin
// {RequestLink:270664206}.
//
// Revision 1.695  2011/06/21 10:48:07  lulin
// {RequestLink:265393897}.
//
// Revision 1.694  2011/06/20 19:59:40  lulin
// - чистим мусор.
//
// Revision 1.693  2011/06/14 15:26:56  lulin
// {RequestLink:269064902}.
//
// Revision 1.692  2011/06/08 16:06:32  lulin
// {RequestLink:267326476}.
//
// Revision 1.691  2011/05/13 18:34:25  lulin
// {RequestLink:220202968}.
//
// Revision 1.690  2011/04/19 14:05:20  lulin
// {RequestLink:228688732}.
// - запрещаем колесо, если автоподгоняемся под высоту текста.
//
// Revision 1.689  2011/04/15 09:00:56  lulin
// {RequestLink:263293085}.
//
// Revision 1.688  2011/04/14 16:19:20  lulin
// {RequestLink:257822128}.
//
// Revision 1.687  2011/04/04 14:57:09  lulin
// {RequestLink:255980313}.
//
// Revision 1.686  2011/03/31 13:37:47  lulin
// {RequestLink:255980970}.
//
// Revision 1.685  2011/03/30 14:22:40  lulin
// {RequestLink:255982818}.
//
// Revision 1.684  2011/03/25 16:12:42  lulin
// {RequestLink:259168102}.
//
// Revision 1.683  2011/03/23 12:43:23  lulin
// {RequestLink:255982818}.
//
// Revision 1.682  2011/03/23 09:53:48  lulin
// - недоделки про правую кнопку мыши в подсказке БП.
//
// Revision 1.681  2011/03/04 15:32:36  lulin
// {RequestLink:255960842}.
//
// Revision 1.680  2011/03/03 14:05:01  lulin
// {RequestLink:254353230}.
//
// Revision 1.679  2011/03/01 10:59:47  lulin
// {RequestLink:253664017}.
//
// Revision 1.678  2011/02/25 18:41:16  lulin
// {RequestLink:254944075}.
//
// Revision 1.677  2011/02/15 14:32:51  lulin
// {RequestLink:231670346}.]
// - я ох..ю от собственно крутости, сделал всё как хотел Шер.
//
// Revision 1.676  2011/02/15 11:24:48  lulin
// {RequestLink:231670346}.
//
// Revision 1.675  2011/02/14 18:09:49  lulin
// {RequestLink:231670346}.
// - при всякого рода навигациях по тексту учитываем, что параграфы могут быть схлопнутыми.
//
// Revision 1.674  2011/01/25 10:59:00  lulin
// - вытащил ReplaceCount на интерфейс, для Антоши.
//
// Revision 1.673  2011/01/21 15:36:23  dinishev
// [$185830965]
//
// Revision 1.672  2011/01/14 15:52:28  lulin
// {RequestLink:248195582}.
// - вычищаем устаревшие интерфейсы.
//
// Revision 1.671  2010/12/01 14:56:11  lulin
// {RequestLink:244195072}.
//
// Revision 1.670  2010/11/30 11:47:02  lulin
// {RequestLink:228688602}.
// - борьба с предупреждениями.
//
// Revision 1.669  2010/11/08 13:48:20  dinishev
// [$239372528]
//
// Revision 1.668  2010/08/13 09:55:12  dinishev
// [$210436700]
//
// Revision 1.667  2010/06/30 05:06:53  lulin
// {RequestLink:221250102}.
//
// Revision 1.666  2010/06/09 08:10:09  oman
// - new: {RequestLink:217679043}
//
// Revision 1.665  2010/06/07 10:37:03  oman
// - new: {RequestLink:217679031}
//
// Revision 1.664  2010/05/07 11:09:54  oman
// - new: {RequestLink:210043512}
//
// Revision 1.663  2010/05/04 13:56:31  lulin
// {RequestLink:207004464}.
// - ещё один запил. Чтобы скроллирование не мазало.
//
// Revision 1.662  2010/05/04 12:24:14  lulin
// {RequestLink:207004464}.
// - неправильно сдвигали правый край области отсечения.
//
// Revision 1.661  2010/05/04 11:55:04  lulin
// {RequestLink:207004464}.
//
// Revision 1.660  2010/04/23 05:27:13  dinishev
// Bug fix: откатываем изменения [$205357705]. Появились проблемы с перемещением курсора.
//
// Revision 1.659  2010/04/22 09:44:10  dinishev
// [$205357705]
//
// Revision 1.658  2010/04/19 11:07:30  lulin
// {RequestLink:204113269}.
//
// Revision 1.657  2010/04/09 16:02:37  lulin
// {RequestLink:201493388}.
//
// Revision 1.656  2010/04/07 17:35:50  lulin
// {RequestLink:201491473}.
//
// Revision 1.655  2010/04/06 13:53:51  fireton
// - редактируем размер шрифта при печати
//
// Revision 1.654  2010/04/01 11:46:38  lulin
// {RequestLink:200085315}.
//
// Revision 1.653  2010/03/26 11:55:19  dinishev
// [$200081714]
//
// Revision 1.652  2010/02/10 19:15:28  lulin
// {RequestLink:186352297}.
//
// Revision 1.651  2010/02/04 13:35:43  oman
// - fix: Грязно хачим для W2k {RequestLink:185831125}
//
// Revision 1.650  2010/02/02 16:55:42  lulin
// {RequestLink:185828256}. Попытка анализа ситуации.
//
// Revision 1.649  2010/01/29 10:27:40  oman
// - fix: {RequestLink:183796183}
//
// Revision 1.648  2010/01/26 13:26:08  lulin
// {RequestLink:183337289}.
//
// Revision 1.647  2010/01/22 17:39:37  lulin
// - делаем тест для "бубны".
//
// Revision 1.646  2009/12/16 13:41:35  lulin
// {RequestLink:174293583}.
//
// Revision 1.645  2009/12/16 13:19:00  lulin
// {RequestLink:174293583}.
//
// Revision 1.644  2009/12/15 12:53:58  lulin
// - пул памяти наследуем от более простого контейнера.
//
// Revision 1.643  2009/12/02 17:42:05  lulin
// {RequestLink:172985919}.
//
// Revision 1.642  2009/11/20 13:56:25  lulin
// - при хождении по истории сбрасываем флажок.
//
// Revision 1.641  2009/11/20 12:09:30  lulin
// {RequestLink:159360589}.
//
// Revision 1.640  2009/10/30 14:01:05  dinishev
// [$168951859]
//
// Revision 1.639  2009/10/19 17:55:55  lulin
// {RequestLink:164599478}.
//
// Revision 1.638  2009/09/18 11:13:56  oman
// - fix: {RequestLink:163061899}
//
// Revision 1.637  2009/08/25 17:09:54  lulin
// {RequestLink:159360578}. №12.
//
// Revision 1.636  2009/08/19 18:07:09  lulin
// {RequestLink:158795592}. Вставленный фрагмент из документа гаранта (вложенный k2_idDocument) сделать read-only, чтобы его можно было удалить только целиком.
//
// Revision 1.635  2009/08/14 16:04:55  lulin
// - вставляем Assert.
//
// Revision 1.634  2009/08/14 15:55:10  lulin
// - не сохраняем комбо в историю, т.к. всё равно ничего хорошего не получается - он очищается, да и дерево не сохраняется и Current.
//
// Revision 1.633  2009/08/11 17:03:03  lulin
// - прикручиваем обработку ссылок к Сравнению редакций.
//
// Revision 1.632  2009/08/11 11:07:31  dinishev
// http://mdp.garant.ru/pages/viewpage.action?pageId=156371297&focusedCommentId=159352189#comment-159352189
//
// Revision 1.631  2009/08/11 07:39:06  dinishev
// [$156371297]
//
// Revision 1.630  2009/08/06 16:08:09  lulin
// {RequestLink:159352843}.
//
// Revision 1.629  2009/08/06 10:36:51  lulin
// {RequestLink:129240934}. №24.
//
// Revision 1.628  2009/08/05 17:22:37  lulin
// {RequestLink:129240934}. №22a.
//
// Revision 1.627  2009/08/05 16:42:46  lulin
// {RequestLink:129240934}. №22.
//
// Revision 1.626  2009/08/04 11:50:44  dinishev
// [$156371297]. Вычищаем.
//
// Revision 1.625  2009/07/23 13:42:10  lulin
// - переносим процессор операций туда куда надо.
//
// Revision 1.624  2009/07/23 08:14:38  lulin
// - вычищаем ненужное использование процессора операций.
//
// Revision 1.623  2009/07/14 14:56:26  lulin
// {RequestLink:141264340}. №25.
//
// Revision 1.622  2009/07/13 12:31:36  lulin
// {RequestLink:141264340}. №23ac.
//
// Revision 1.621  2009/07/13 08:20:55  lulin
// {RequestLink:141264340}. №23b.
//
// Revision 1.620  2009/07/13 08:05:21  lulin
// {RequestLink:141264340}. №24bc.
//
// Revision 1.619  2009/07/11 15:55:09  lulin
// {RequestLink:141264340}. №22.
//
// Revision 1.618  2009/07/11 12:46:22  lulin
// {RequestLink:141264340}. №14.
//
// Revision 1.617  2009/07/11 10:43:37  lulin
// - не вычисляем курсор для низа отрисовки, там где он не нужен.
//
// Revision 1.616  2009/07/11 09:24:41  lulin
// - избавляемся от лишнего дёрганья счётчиков ссылок.
//
// Revision 1.615  2009/07/10 16:15:41  lulin
// - избавляемся от лишнего дёрганья счётчиков ссылок.
//
// Revision 1.614  2009/07/10 13:55:57  lulin
// - избавляемся от лишнего виртуального метода.
//
// Revision 1.613  2009/07/10 12:49:10  lulin
// - чистка контекста.
//
// Revision 1.612  2009/07/09 19:11:15  lulin
// {RequestLink:141264340}. №10.
//
// Revision 1.611  2009/07/07 14:07:43  lulin
// {RequestLink:155030165}.
//
// Revision 1.610  2009/07/03 16:24:02  lulin
// - шаг к переходу от интерфейсов к объектам.
//
// Revision 1.609  2009/07/01 16:47:52  lulin
// - в отладке позволяем сразу скроллировать.
//
// Revision 1.608  2009/06/26 16:04:35  lulin
// По мотивам [$153682462]. Не моргаем, когда сдвигаемая область слишком большая.
//
// Revision 1.607  2009/06/26 14:07:14  lulin
// - откатываем предыдущие изменения, т.к. не всё так просто в этой жизни.
//
// Revision 1.606  2009/06/26 13:42:03  lulin
// По мотивам [$153682462]. Не скроллируем содержимое окна, если оно залочено.
//
// Revision 1.605  2009/06/17 12:40:09  lulin
// {RequestLink:144575132}.
//
// Revision 1.604  2009/06/15 12:08:39  lulin
// [$146376785].
//
// Revision 1.603  2009/06/10 12:26:46  lulin
// - цепляем фильтр имён блоков к экспорту.
// - восстанавливаем код пропавший (точнее пролюбленный) при переносе на модель.
// - фильтруем полностью выделенные блоки.
//
// Revision 1.602  2009/06/02 17:23:15  lulin
// - удалены ненужные интерфейсы и переопределения типов.
//
// Revision 1.601  2009/06/01 11:13:28  lulin
// [$148572848].
//
// Revision 1.600  2009/05/29 17:18:25  lulin
// [$142610853].
//
// Revision 1.599  2009/05/07 10:20:09  oman
// - new: Погдняли высоту невовремя - [$146903337]
// Committed on the Free edition of March Hare Software CVSNT Server.
// Upgrade to CVS Suite for more features and support:
// http://march-hare.com/cvsnt/
//
// Revision 1.598  2009/05/04 12:34:41  dinishev
// <K> : 144572957
//
// Revision 1.597  2009/04/23 06:14:41  dinishev
// <K> : 142613601
//
// Revision 1.596  2009/04/17 07:48:54  oman
// - fix: Перерисовывамеся только после реального убиения каретки
//
// Revision 1.595  2009/04/16 15:55:28  lulin
// [$143396720]. №5. Убираем доступ к ненужному свойству.
//
// Revision 1.594  2009/04/16 14:46:31  lulin
// [$143396720]. №8.
//
// Revision 1.593  2009/04/15 07:48:35  lulin
// [$143396720]. Убраны ненужные параметры в фабричных методах.
//
// Revision 1.592  2009/04/13 14:19:55  lulin
// [$142613919]. Выделяем виртуальный метод обработки сообщений.
//
// Revision 1.591  2009/04/09 14:12:36  lulin
// [$140837386]. №15.
//
// Revision 1.590  2009/04/08 12:56:37  lulin
// [$142610892]. Вычищаем ненужные контексты.
//
// Revision 1.589  2009/04/08 11:18:29  oman
// - new: В _JumpTo подаем не состояние мыши а желаемое поведение - [$140287160]
//
// Revision 1.588  2009/04/07 16:09:41  lulin
// [$140837386]. №13.
//
// Revision 1.587  2009/04/07 13:39:12  oman
// - new: Прикручиваем клик по колесу мыши - [$140287160]
//
// Revision 1.586  2009/04/06 08:54:11  lulin
// [$140837386]. Чистка кода.
//
// Revision 1.585  2009/03/31 12:04:36  lulin
// [$140286997].
//
// Revision 1.584  2009/03/25 14:24:07  lulin
// - делаем возможность включения/выключения версионных комментариев.
//
// Revision 1.583  2009/03/19 09:54:30  oman
// - fix: Рисуем правильней (К-137463980)
//
// Revision 1.582  2009/03/05 19:17:17  lulin
// - убираем ненужное использование интерфейса.
//
// Revision 1.581  2009/03/05 16:46:31  lulin
// - <K>: 137470629. Убран ненужный интерфейс.
//
// Revision 1.580  2009/03/05 13:09:35  lulin
// - <K>: 137470629. Используем ссылки на типы.
//
// Revision 1.579  2009/03/05 09:44:35  lulin
// - <K>: 137470629. Генерируем ссылки на типы.
// - bg fix: перегенерировал, т.к. были ссылки на несуществующие модули.
//
// Revision 1.578  2009/03/04 18:14:14  lulin
// - <K>: 137470629. Удалён ненужный интерфейс.
//
// Revision 1.577  2009/03/04 13:32:46  lulin
// - <K>: 137470629. Генерируем идентификаторы типов с модели и убираем их из общей помойки.
//
// Revision 1.576  2009/03/03 17:27:22  lulin
// - <K>: 137470629. Переносим константу запрещённоо типа.
//
// Revision 1.575  2009/03/03 13:35:50  oman
// - fix: Сносили Selection внутри его вызова (К-137469208)
//
// Revision 1.574  2009/01/22 11:48:00  lulin
// - <K>: 128288557. Чистим код.
//
// Revision 1.573  2009/01/16 17:16:33  lulin
// - <K>: 135597645.
//
// Revision 1.572  2009/01/16 14:14:21  lulin
// - <K>: 121158769.
//
// Revision 1.571  2009/01/15 09:23:29  lulin
// - <K>: 121163874.
//
// Revision 1.570  2009/01/15 08:26:30  lulin
// - правильнее обрабатываем условие.
//
// Revision 1.569  2008/12/29 12:22:45  oman
// - fix: Не подаем HAFPainter снаружи (К-122675365)
//
// Revision 1.568  2008/12/26 13:59:12  oman
// - fix: подключаем MacroReplacer (К-122675365)
//
// Revision 1.567  2008/12/23 07:53:52  oman
// - new: Выставляем зону для превью (К-122675365)
//
// Revision 1.566  2008/12/22 15:04:44  oman
// - new: В кэше превью различаем из какой зоны было оно вызвано (К-122675365)
//
// Revision 1.565  2008/12/15 16:06:17  lulin
// - <K>: 131137753.
//
// Revision 1.564  2008/12/12 19:19:14  lulin
// - <K>: 129762414.
//
// Revision 1.563  2008/12/11 06:40:07  oman
// - fix: Отказываемся принимать данные в RO редактор по D&D (К-128288881)
//
// Revision 1.562  2008/12/10 06:50:54  dinishev
// <K> : 127764966 - более корректное обновление линейки.
//
// Revision 1.561  2008/12/05 12:40:12  dinishev
// <K> : 127764966
//
// Revision 1.560  2008/11/10 17:53:54  lulin
// - <K>: 114459503. bug fix: не учитывали разрывы разделов при печати.
//
// Revision 1.559  2008/11/05 10:54:37  lulin
// - <K>: 121831634.
//
// Revision 1.558  2008/10/15 13:03:23  lulin
// - <K>: 121149970.
//
// Revision 1.557  2008/10/10 14:19:41  lulin
// - <K>: 121146878.
//
// Revision 1.556  2008/10/09 13:37:33  lulin
// - <K>: 121145547.
//
// Revision 1.555  2008/10/01 17:31:01  lulin
// - <K>: 120720356.
//
// Revision 1.554  2008/10/01 16:24:02  lulin
// - <K>: 120719934.
//
// Revision 1.553  2008/10/01 13:29:06  lulin
// - <K>: 120719470.
//
// Revision 1.552  2008/10/01 12:29:39  lulin
// - в рамках <K>: 120719470 вычищаем работы с обработчиком сообщений.
//
// Revision 1.551  2008/10/01 10:49:49  lulin
// - <K>: 120718563.
//
// Revision 1.550  2008/09/30 14:44:05  lulin
// - bug fix: не собирался Архивариус.
//
// Revision 1.549  2008/09/30 11:21:31  lulin
// - перегенерация.
//
// Revision 1.548  2008/09/30 11:08:01  lulin
// - переносим на модель.
//
// Revision 1.547  2008/09/30 10:55:33  lulin
// - переносим на модель.
//
// Revision 1.546  2008/09/29 14:11:57  lulin
// - чистка кода.
//
// Revision 1.545  2008/09/29 13:05:37  lulin
// - используем более правильную канву.
//
// Revision 1.544  2008/09/29 07:04:25  oman
// Не собиралась библиотека
//
// Revision 1.543  2008/09/26 10:10:47  dinishev
// <K>: 77235630 для Head'а
//
// Revision 1.542  2008/09/12 11:48:15  oman
// - fix: Дружим мемо с историей (К-114459128)
//
// Revision 1.541  2008/09/10 16:41:26  lulin
// - <K>: 98828579.
//
// Revision 1.540  2008/09/10 12:07:32  lulin
// - <K>: 88080895.
//
// Revision 1.539  2008/09/10 10:07:43  lulin
// - <K>: 88080895.
//
// Revision 1.538  2008/09/09 21:02:09  lulin
// - чистка кода.
//
// Revision 1.537  2008/09/09 20:50:47  lulin
// - чистка кода.
//
// Revision 1.536  2008/09/09 20:29:38  lulin
// - методы переехали в более подходящий класс.
//
// Revision 1.535  2008/09/09 17:29:47  lulin
// - избавдяемся от лишних вычислений.
//
// Revision 1.534  2008/09/09 16:43:18  lulin
// - bug fix: не учитываем один и тот же отступ дважды..
//
// Revision 1.533  2008/09/09 15:40:08  lulin
// - удалены ненужные свойства.
//
// Revision 1.532  2008/09/04 11:56:42  lulin
// - <K>: 88080895.
//
// Revision 1.531  2008/09/04 11:16:13  lulin
// - <K>: 88080895.
//
// Revision 1.530  2008/09/02 12:38:07  lulin
// - <K>: 88080895.
//
// Revision 1.529  2008/08/28 06:59:53  lulin
// - bug fix: могли не инициализировать цвета.
//
// Revision 1.528  2008/08/27 14:49:32  lulin
// - <K>: 110986777.
//
// Revision 1.527  2008/08/15 13:13:53  lulin
// - <K>: 108626698.
//
// Revision 1.526  2008/08/13 08:28:09  lulin
// - <K>: 108233400.
//
// Revision 1.525  2008/08/12 13:49:16  lulin
// - щедро рассыпаем Assert'ы в рамках <K>: 108233438.
//
// Revision 1.524  2008/08/11 14:06:08  lulin
// - <K>: 108232735.
//
// Revision 1.523  2008/08/08 15:40:08  lulin
// - вернул наложение области отсечения.
//
// Revision 1.522  2008/08/08 15:36:46  lulin
// - bug fix: некорректно перерисовывалось начало параграфа.
//
// Revision 1.521  2008/08/08 12:46:49  lulin
// - <K>: 103942807.
//
// Revision 1.520  2008/08/05 12:51:59  lulin
// - cleanup.
//
// Revision 1.519  2008/08/05 12:39:37  lulin
// http://mdp.garant.ru/pages/viewpage.action?pageId=96484670&focusedCommentId=106037862#comment-106037862
//
// Revision 1.518  2008/08/05 12:32:20  lulin
// - <K>: 96484670.
//
// Revision 1.517  2008/07/15 14:37:44  lulin
// - <K>: 98828459.
//
// Revision 1.516  2008/07/10 12:28:32  lulin
// - <K>: 100958718.
//
// Revision 1.515  2008/07/03 20:12:36  lulin
// - восстановил давно утерянную функциональность - подгонку картинки по высоте окна вывода.
//
// Revision 1.514  2008/07/03 13:23:20  lulin
// - <K>: 87589015.
//
// Revision 1.513  2008/07/03 05:52:22  oman
// - fix: Реагируем в КЗ на "вставку из клипборда" - сохраняем выделение (К-96474339)
//
// Revision 1.512  2008/07/02 12:32:21  lulin
// - <K>: 91848911.
//
// Revision 1.511  2008/06/24 12:09:50  dinishev
// New proc: Validate (Поддержка преобразования к верхнему регистру в TevEdit при вставке из буфера)
//
// Revision 1.510  2008/06/20 14:48:50  lulin
// - используем префиксы элементов.
//
// Revision 1.509  2008/06/17 20:44:42  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.508  2008/06/05 10:48:14  lulin
// - cleanup.
//
// Revision 1.507  2008/06/05 08:54:22  lulin
// - <K>: 93261783.
//
// Revision 1.506  2008/06/03 11:42:50  lulin
// - переносим на модель.
//
// Revision 1.505  2008/06/02 14:28:32  lulin
// - <K>: 93259930.
//
// Revision 1.504  2008/06/02 13:18:00  lulin
// - <K>: 89096952.
//
// Revision 1.503  2008/06/02 11:55:19  lulin
// - <K>: 93259698.
//
// Revision 1.502  2008/05/30 07:06:11  lulin
// - <K>: 92766396.
//
// Revision 1.501  2008/05/28 15:11:10  lulin
// - <K>: 91851229.
//
// Revision 1.500  2008/05/28 13:55:38  lulin
// - выделена функция получения полной высоты документа, <K>: 91851229.
//
// Revision 1.499  2008/05/27 08:48:50  lulin
// - <CQ>: 29061.
//
// Revision 1.498  2008/05/22 12:59:51  lulin
// - <K>: 90450972.
//
// Revision 1.497  2008/05/22 12:07:47  lulin
// - <K>: 90450950.
//
// Revision 1.496  2008/05/22 11:56:14  lulin
// - ставим курсор, а не выделение.
//
// Revision 1.495  2008/05/20 12:03:55  lulin
// - <K>: 90448469.
//
// Revision 1.494  2008/05/16 15:20:35  lulin
// - переносим на модель.
//
// Revision 1.493  2008/05/15 18:03:27  lulin
// - <K>: 90447231.
//
// Revision 1.492  2008/05/15 17:31:37  lulin
// - чистка использования модулей.
// - убираем неочевидную логику скроллирования.
//
// Revision 1.491  2008/05/15 13:25:34  lulin
// - <K>: 90446803.
//
// Revision 1.490  2008/05/15 11:28:28  lulin
// - <K>: 90446071.
//
// Revision 1.489  2008/05/14 19:05:06  lulin
// - <K>: 90446006.
//
// Revision 1.488  2008/05/13 18:15:06  lulin
// - рисуем различные редакторы.
//
// Revision 1.487  2008/05/12 08:39:37  lulin
// - bug fix: AV при определении невидимости параграфа.
//
// Revision 1.486  2008/05/08 16:10:54  lulin
// - изменения в рамках <K>: 90442475.
//
// Revision 1.485  2008/05/08 13:48:45  lulin
// http://mdp.garant.ru/pages/viewpage.action?pageId=86479273&focusedCommentId=90442637#comment-90442637
//
// Revision 1.484  2008/05/08 08:40:33  lulin
// - <K>: 90442149.
//
// Revision 1.483  2008/05/07 18:29:48  lulin
// - изменения в рамках <K>: 90441963.
//
// Revision 1.482  2008/05/07 13:49:57  lulin
// - <K>: 90441635.
//
// Revision 1.481  2008/05/07 13:04:22  lulin
// - изменения в рамках <K>: 90441635.
//
// Revision 1.480  2008/04/29 17:24:27  lulin
// - работы по <K>: 89106312.
//
// Revision 1.479  2008/04/24 18:52:04  lulin
// - подготавливаемся к хранению форматированияв пуле, в рамках <K>: 89106312.
//
// Revision 1.478  2008/04/24 15:22:11  lulin
// - изменения в рамках <K>: 89106312.
//
// Revision 1.477  2008/04/23 09:52:50  lulin
// - <K>: 89105866.
//
// Revision 1.476  2008/04/22 10:49:23  lulin
// - <K>: 88637809.
//
// Revision 1.475  2008/04/16 10:17:07  lulin
// - <CQ>: 28882.
//
// Revision 1.474  2008/04/15 16:39:03  lulin
// - передаём вью в качестве параметра.
//
// Revision 1.473  2008/04/15 08:23:45  lulin
// - передаём вью в качестве параметра.
//
// Revision 1.472  2008/04/14 15:42:50  lulin
// - cleanup.
//
// Revision 1.471  2008/04/14 13:46:35  lulin
// - <K>: 89096854.
//
// Revision 1.470  2008/04/11 14:26:16  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.469  2008/04/11 13:54:04  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.468  2008/04/11 13:03:52  lulin
// - <K>: 89096854.
//
// Revision 1.467  2008/04/11 12:38:59  lulin
// - <K>: 89100748.
//
// Revision 1.466  2008/04/11 12:26:08  lulin
// - <K>: 89100752.
//
// Revision 1.465  2008/04/10 17:34:24  lulin
// - <K>: 89097983.
//
// Revision 1.464  2008/04/10 12:45:56  lulin
// - <K>: 89099092.
//
// Revision 1.463  2008/04/09 18:09:58  lulin
// - <K>: 89099025.
//
// Revision 1.462  2008/04/09 17:57:07  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.461  2008/04/09 11:20:21  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.460  2008/04/09 07:34:58  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.459  2008/04/08 16:41:20  lulin
// - передаём View в AssignPoint. <K>: 89096854.
//
// Revision 1.458  2008/04/07 13:34:06  lulin
// - изменения в рамках <K>: 89096854.
//
// Revision 1.457  2008/04/07 06:18:36  lulin
// - cleanup.
//
// Revision 1.456  2008/04/02 14:22:01  lulin
// - cleanup.
//
// Revision 1.455  2008/03/28 11:07:15  dinishev
// Bug fix: при скроллировании линейка "забывалась"
//
// Revision 1.454  2008/03/27 11:42:50  dinishev
// Борьба с медленным скроллингом длинной таблицы
//
// Revision 1.453  2008/03/26 17:17:46  lulin
// - cleanup.
//
// Revision 1.452  2008/03/26 17:09:35  lulin
// - <K>: 88081573.
//
// Revision 1.451  2008/03/19 14:23:33  lulin
// - cleanup.
//
// Revision 1.450  2008/03/14 13:43:29  lulin
// - <K>: 86479821.
//
// Revision 1.449  2008/03/12 06:37:30  lulin
// - добавлена информация о заплатке.
//
// Revision 1.448  2008/03/11 16:13:05  dinishev
// Bug fix: реанимируем заплатку на установку _FoundBlock для Арчи - вываливался с Assert при поиске/замене
//
// Revision 1.447  2008/03/11 08:51:20  lulin
// - <K>: 85721144.
//
// Revision 1.446  2008/03/04 08:27:55  lulin
// - <K>: 85721148.
//
// Revision 1.445  2008/03/03 20:05:45  lulin
// - <K>: 85721135.
//
// Revision 1.444  2008/03/03 15:49:17  lulin
// - типизируем список маркеров параграфа.
//                                                                                 
// Revision 1.443  2008/03/03 13:20:27  lulin
// - nevTools перенесён на модель. Теперь всё компилируется.
//
// Revision 1.442  2008/02/27 17:24:57  lulin
// - подгоняем код под модель.
//
// Revision 1.441  2008/02/26 11:46:32  lulin
// - <CQ>: 20626.
//
// Revision 1.440  2008/02/14 17:08:54  lulin
// - cleanup.
//
// Revision 1.439  2008/02/07 08:01:09  oman
// - new: Поддержка технических комментариев (cq28378)
//
// Revision 1.438  2008/02/04 08:51:23  lulin
// - класс _Tl3InterfaceList выделен в отдельный модуль.
//
// Revision 1.437  2008/01/31 18:53:26  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.436  2008/01/21 13:14:07  oman
// - fix: Мог залипать старый документ во View._TopAnchor (cq27928)
//
// Revision 1.435  2008/01/11 09:50:32  oman
// - fix: Мог залипать старый документ в каретке (cq27928)
//
// Revision 1.434  2007/12/28 08:44:51  dinishev
// _CleanUp
//
// Revision 1.433  2007/12/24 22:38:43  lulin
// - удален ненужный модуль.
//
// Revision 1.432  2007/12/05 18:15:06  lulin
// - удален ненужный код.
//
// Revision 1.431  2007/12/04 12:47:01  lulin
// - перекладываем ветку в HEAD.
//
// Revision 1.387.2.475  2007/12/04 12:08:34  lulin
// - cleanup.
//
// Revision 1.387.2.474  2007/12/03 15:51:39  lulin
// - cleanup.
//
// Revision 1.387.2.473  2007/11/28 15:25:55  dinishev
// Совместимость с Арчи
//
// Revision 1.387.2.472  2007/10/31 12:35:25  oman
// - new: Событие OnShowDocumentPartsChanged (cq27244)
//
// Revision 1.387.2.471  2007/10/10 16:39:20  lulin
// - теперь при вычислении шрифта передаем ссылку на карту форматирования.
//
// Revision 1.387.2.470  2007/10/04 17:00:39  lulin
// - bug fix: падали когда не могли создать окно.
//
// Revision 1.387.2.469  2007/09/20 16:17:27  lulin
// - cleanup.
//
// Revision 1.387.2.468  2007/09/17 06:05:39  lulin
// - cleanup.
//
// Revision 1.387.2.467  2007/09/14 13:26:05  lulin
// - объединил с веткой B_Tag_Clean.
//
// Revision 1.387.2.466.2.1  2007/09/12 15:23:00  lulin
// - избавляемся от метода, дублирующего функциональность получения атрибута.
//
// Revision 1.387.2.466  2007/08/28 17:07:05  lulin
// - оптимизируем загрузку строк.
//
// Revision 1.387.2.465  2007/08/23 11:36:49  mmorozov
// - bugfix: при загрузке данных из истории занимались получением данных (CQ: OIT5-26463);
//
// Revision 1.387.2.464  2007/08/21 08:38:52  oman
// - fix: Если редактор не принимает фокус не пытаемся его
//  фокусировать (cq26293)
//
// Revision 1.387.2.463  2007/08/17 15:43:54  lulin
// - не скроллируемся при переносе фокуса (CQ OIT5-25866).
//
// Revision 1.387.2.462  2007/08/17 14:26:14  lulin
// - убрал заточку из CQ 25188. Вроде ничего сейчас не падает.
//
// Revision 1.387.2.461  2007/08/14 19:31:29  lulin
// - оптимизируем очистку памяти.
//
// Revision 1.387.2.460  2007/08/14 15:19:22  lulin
// - оптимизируем перемещение блоков памяти.
//
// Revision 1.387.2.459  2007/08/10 14:44:42  lulin
// - cleanup.
//
// Revision 1.387.2.458  2007/08/09 11:19:12  lulin
// - cleanup.
//
// Revision 1.387.2.457  2007/07/18 15:07:18  lulin
// - выпрямляем зависимости. Схема документа, теперь не зависит от Эвереста.
//
// Revision 1.387.2.456  2007/06/26 10:42:43  lulin
// - cleanup.
//
// Revision 1.387.2.455  2007/06/25 10:31:50  mmorozov
// - new behaviour: избавляемся от получения контейнера документа при сохранении в историю (в рамках работы над CQ: OIT5-25280, по сценарию изменений K<7438844>);
//
// Revision 1.387.2.454  2007/06/22 20:18:31  lulin
// - cleanup.
//
// Revision 1.387.2.453  2007/06/22 19:18:57  lulin
// - cleanup.
//
// Revision 1.387.2.452  2007/06/22 19:02:30  lulin
// - cleanup.
//
// Revision 1.387.2.451  2007/06/22 18:59:53  lulin
// - cleanup.
//
// Revision 1.387.2.450  2007/05/31 08:51:01  oman
// - fix: Новый обработчик об изменении видимости комментариев
//  (cq25181)
//
// Revision 1.387.2.449  2007/04/27 09:07:05  oman
// - fix: Залечили падение по Assert - при установке _FoundBlock делаем
//   пока полное переформатирование (cq25188)
//
// Revision 1.387.2.448  2007/04/25 08:49:03  oman
// - fix: Редактор с автовысотой реагирует на изменение текста -
//   не дочистил предыдущий вариант (cq25132)
//
// Revision 1.387.2.447  2007/04/25 08:28:50  oman
// - fix: Редактор с автовысотой реагирует на изменение текста -
//   более кошерный вариант (cq25132)
//
// Revision 1.387.2.446  2007/04/25 08:13:47  oman
// - new: Редактор с автовысотой реагирует на изменение текста
//  (cq25132)
//
// Revision 1.387.2.445  2007/04/18 12:15:02  oman
// - new: При установке Selection._FoundBlock нотифицируется редактор,
//  который в ответ на эту нотификацию реагирует перерисовкой,
//  обновлением каретки и пр. (cq22752)
// - new: _Find учитывает последний _FoundBlock вместо целикового
//  выделения при поиске (cq22752)
//
// Revision 1.387.2.444  2007/04/17 10:11:33  oman
// - fix: Если ничего не найдено - сохраним предыдущий _FoundBlock
//   (cq22752)
//
// Revision 1.387.2.443  2007/04/10 12:05:12  lulin
// - cleanup.
//
// Revision 1.387.2.442  2007/03/22 06:26:17  lulin
// - cleanup.
//
// Revision 1.387.2.441  2007/03/16 14:47:17  lulin
// - cleanup.
//
// Revision 1.387.2.440  2007/02/28 10:42:35  oman
// - fix: После очистки коллекции отрисованных всегда вызываем
//  _Invalidate (cq24528)
//
// Revision 1.387.2.439  2007/02/12 17:15:58  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.387.2.438  2007/01/31 17:19:38  lulin
// - получаем объект буфера обмена в один прием.
//
// Revision 1.387.2.437  2007/01/31 12:01:11  lulin
// - сделана возможность показа меню по клику на метке.
//
// Revision 1.387.2.436  2007/01/31 10:00:30  lulin
// - выделен метод для показа контекстного меню.
//
// Revision 1.387.2.435  2007/01/30 10:04:53  lulin
// - добавлен метод получения базовой точки.
//
// Revision 1.387.2.434  2007/01/30 09:49:26  lulin
// - передаем полную информацию о курсоре.
//
// Revision 1.387.2.433  2007/01/23 15:14:11  lulin
// - не очищаем коллекцию отрисованных при скроллировании и в режиме показа блоков, т.к. надобность в очистке вроде пропала.
//
// Revision 1.387.2.432  2007/01/23 15:08:39  lulin
// - bug fix: при переключении режима показа блоков не корректировали коллекцию отрисованных.
//
// Revision 1.387.2.431  2007/01/09 14:00:15  oman
// - fix: При загрузке из истории привязываем _TopAnchor к View по
//   всей цепочке - иначе AV (cq23966)
//
// Revision 1.387.2.430  2007/01/05 14:37:18  lulin
// - cleanup.
//
// Revision 1.387.2.429  2006/12/27 14:39:15  lulin
// - упрощена работа со списками форматов.
//
// Revision 1.387.2.428  2006/12/27 13:08:26  lulin
// - копирование выделенного атрибута переведено на использование объектов данных.
//
// Revision 1.387.2.427  2006/12/21 14:27:58  lulin
// - картинку копируем в буфер обмена теперь тоже посредством объекта данных.
//
// Revision 1.387.2.426  2006/12/21 09:47:00  lulin
// - cleanup.
//
// Revision 1.387.2.425  2006/12/21 09:39:36  oman
// - fix: Переименовал nevSelection._SelectPoint(TPoint) в SelectPt, чтобы
//  лучше отражал сущность
//
// Revision 1.387.2.424  2006/12/19 12:24:21  lulin
// - избавляемся от запоминания объкта данных на контроле.
//
// Revision 1.387.2.423  2006/12/18 09:57:21  lulin
// - выделен метод установки данных буферу обмена.
//
// Revision 1.387.2.422  2006/12/18 09:40:24  lulin
// - cleanup.
//
// Revision 1.387.2.421  2006/12/15 13:52:27  lulin
// - cleanup.
//
// Revision 1.387.2.420  2006/12/15 13:48:46  lulin
// - cleanup.
//
// Revision 1.387.2.419  2006/12/15 13:12:30  lulin
// - cleanup.
//
// Revision 1.387.2.418  2006/12/15 13:11:01  lulin
// - cleanup.
//
// Revision 1.387.2.417  2006/12/14 13:08:16  lulin
// - по-честному получаем ноду из объекта данных.
//
// Revision 1.387.2.416  2006/12/13 17:34:26  lulin
// - теперь базовый контрол поддерживает иконку от перетаскиваемого в него объекта.
//
// Revision 1.387.2.415  2006/12/13 15:50:41  oman
// - fix: Неверно формировали превью для выделения
//
// Revision 1.387.2.414  2006/12/13 15:41:37  lulin
// - метод вставки данных из буфера обмена переехал на базовый контрол.
//
// Revision 1.387.2.413  2006/12/13 15:29:13  lulin
// - метод вставки данных в указанном формате переехал на базовый контрол.
//
// Revision 1.387.2.412  2006/12/13 15:13:08  lulin
// - cleanup.
//
// Revision 1.387.2.411  2006/12/13 10:10:46  lulin
// - cleanup.
//
// Revision 1.387.2.410  2006/12/13 08:02:42  lulin
// - вычишен ненужный на интерфейсе метод.
//
// Revision 1.387.2.409  2006/12/12 10:46:50  lulin
// - не используем лишний раз филтры.
//
// Revision 1.387.2.408  2006/12/12 10:25:44  lulin
// - cleanup.
//
// Revision 1.387.2.407  2006/12/12 09:54:17  oman
// - fix: Перенос HiddenStyles c DocumentContainer на редактор.
//   Поддержка экспорта/клипборда/d'n'd (cq12564)
//
// Revision 1.387.2.406  2006/12/12 09:26:28  lulin
// - cleanup.
//
// Revision 1.387.2.405  2006/12/12 06:50:28  lulin
// - cleanup.
//
// Revision 1.387.2.404  2006/12/11 09:55:25  oman
// - new: HiddenStyles перенесены с DocumentContainer на редактор (cq12564)
// - new: Изменена схема кэширования превью на DocumentContainer
//
// Revision 1.387.2.403  2006/12/08 10:08:17  lulin
// - bug fix: был потенциальный AV для тех параграфов, которые еще не отрисованы.
//
// Revision 1.387.2.402  2006/12/05 13:49:41  lulin
// - контрол переехал в визуальную библиотеку.
//
// Revision 1.387.2.401  2006/12/01 14:56:10  lulin
// - cleanup.
//
// Revision 1.387.2.400  2006/11/30 14:51:43  lulin
// - cleanup.
//
// Revision 1.387.2.399  2006/11/30 14:47:24  lulin
// - cleanup.
//
// Revision 1.387.2.398  2006/11/24 12:02:05  oman
// - fix: После перевода на состояние мыши отъехал Shift+Ckick.
//  Для поддержки этого в afwMouseEffects добавлено
//  соответствующее поле (cq23104)
//
// Revision 1.387.2.397  2006/11/23 15:18:49  lulin
// - bug fix: иногда при подравнивании окна по найденному или по курсору окно редактора перерисовывалось нецеликом.
//
// Revision 1.387.2.396  2006/11/23 14:27:44  lulin
// - bug fix: при возврате по истории подравнивались по курсору, а не по верхнему обрезу текста.
//
// Revision 1.387.2.395  2006/11/20 17:40:14  lulin
// - не даем модифицировать якорь не в рамках вью.
//
// Revision 1.387.2.394  2006/11/10 15:59:30  oman
// Merge from B_NEMESIS_6_4
//
// Revision 1.387.2.393  2006/11/03 12:23:00  lulin
// - удален ненужный метод.
//
// Revision 1.387.2.392  2006/11/03 12:21:07  lulin
// - удалены ненужные методы.
//
// Revision 1.387.2.391  2006/11/03 11:00:04  lulin
// - объединил с веткой 6.4.
//
// Revision 1.387.2.390.2.23.2.2  2006/11/10 13:18:12  lulin
// - третий клик выделяет параграф только если попали в выделение.
//
// Revision 1.387.2.390.2.23.2.1  2006/11/09 09:18:26  oman
// - fix: Восстанавливаем карту форматирования, если она убилась на
//   _ReadOnly тексте (cq23448)
// - fix: Не переставлась каретка при схлопывании параграфов (cq23406)
//
// Revision 1.387.2.390.2.23  2006/11/03 07:50:55  lulin
// - cleanup.
//
// Revision 1.387.2.390.2.22  2006/11/02 19:48:24  lulin
// - cleanup.
//
// Revision 1.387.2.390.2.21  2006/11/02 14:56:56  lulin
// - cleanup.
//
// Revision 1.387.2.390.2.20  2006/11/01 14:59:04  lulin
// - убираем использование неправильного метода.
//
// Revision 1.387.2.390.2.19  2006/10/31 09:21:18  lulin
// - при поиске горячей точки подаем уже вычисленную карту форматирования.
//
// Revision 1.387.2.390.2.18  2006/10/26 07:03:09  lulin
// - удалено ненужное свойство.
//
// Revision 1.387.2.390.2.17  2006/10/25 09:44:59  lulin
// - операция клонирования спущена на базовую точку.
//
// Revision 1.387.2.390.2.16  2006/10/24 10:00:01  lulin
// - убран ненужный метод.
//
// Revision 1.387.2.390.2.15  2006/10/23 14:20:51  lulin
// - не делаем лишнюю копию курсора.
//
// Revision 1.387.2.390.2.14  2006/10/23 08:58:08  lulin
// - теперь при определении "горячей точки" передаем базовый курсор.
//
// Revision 1.387.2.390.2.13  2006/10/23 05:50:54  lulin
// - переход по ссылке переделан с обработки мыши на специально для этого выделенное событие.
//
// Revision 1.387.2.390.2.12  2006/10/20 10:54:01  lulin
// - более правильно делаем курсор для картинки.
//
// Revision 1.387.2.390.2.11  2006/10/19 13:33:17  lulin
// - переводим курсоры и подсказки на новые рельсы.
//
// Revision 1.387.2.390.2.10  2006/10/18 13:37:58  lulin
// - наследование заменяем агрегацией.
//
// Revision 1.387.2.390.2.9  2006/10/18 13:17:02  lulin
// - cleanup.
//
// Revision 1.387.2.390.2.8  2006/10/18 13:06:34  lulin
// - вычищены ненужные данные.
//
// Revision 1.387.2.390.2.7  2006/10/18 12:33:14  lulin
// - типы для обработки мыши переехали в более общую библиотеку.
//
// Revision 1.387.2.390.2.6  2006/10/18 10:14:26  lulin
// - раскомментрировал, казалось бы безобидный, код, отсутствие которого напрочь ломало отрисовку. Почему он так влияет - надо со временем разобраться. CQ OIT5-23087.
//
// Revision 1.387.2.390.2.5  2006/10/16 13:25:39  lulin
// - cleanup.
//
// Revision 1.387.2.390.2.4  2006/10/16 11:33:07  lulin
// - прячем-таки горизонтальный скролер при включенной XP теме.
//
// Revision 1.387.2.390.2.3  2006/10/13 12:10:11  oman
// Реация на смену параграфа в КЗ перенесена в более правильное место
// cleanup
//
// Revision 1.387.2.390.2.2  2006/10/13 11:38:07  lulin
// - теперь при горизонтальном скроллировании двигаем уже нарисованное изображение.
//
// Revision 1.387.2.390.2.1  2006/10/12 17:45:20  lulin
// - вычищаем все, что связано с дозагрузкой документа.
//
// Revision 1.387.2.390  2006/10/10 18:19:23  lulin
// - убран ненужный параметр.
//
// Revision 1.387.2.389  2006/10/10 12:06:13  lulin
// - cleanup.
//
// Revision 1.387.2.388  2006/10/10 10:44:16  lulin
// - убрано значение по-умолчанию, т.к. его использование вело к AV.
//
// Revision 1.387.2.387  2006/10/10 10:29:49  lulin
// - bug fix: был AV при превышении лимита параграфов (CQ OIT5-22815).
//
// Revision 1.387.2.386  2006/10/10 10:05:17  lulin
// - cleanup.
//
// Revision 1.387.2.385  2006/10/09 13:33:25  lulin
// - убран ненужный метод.
//
// Revision 1.387.2.384  2006/10/09 13:29:36  lulin
// - cleanup.
//
// Revision 1.387.2.383  2006/10/09 13:15:32  lulin
// - спрятан ненужный метод.
//
// Revision 1.387.2.382  2006/10/09 12:40:12  lulin
// - cleanup.
//
// Revision 1.387.2.381  2006/10/09 10:34:04  lulin
// - cleanup.
//
// Revision 1.387.2.380  2006/10/09 10:09:14  lulin
// - cleanup.
//
// Revision 1.387.2.379  2006/10/09 09:52:54  lulin
// - убрана ненужная поддержка интерфейсов.
//
// Revision 1.387.2.378  2006/10/08 13:24:35  lulin
// - убираем ненужный запрос интерфейса от курсора.
//
// Revision 1.387.2.377  2006/10/06 15:26:44  lulin
// - теперь возможность автоматического выделения получается из структуры, описывающей поведение горячей точки.
//
// Revision 1.387.2.376  2006/10/06 14:45:30  lulin
// - cleanup.
//
// Revision 1.387.2.375  2006/10/06 14:20:47  lulin
// - cleanup.
//
// Revision 1.387.2.374  2006/10/06 13:50:09  lulin
// - cleanup.
//
// Revision 1.387.2.373  2006/10/06 13:40:03  lulin
// - cleanup.
//
// Revision 1.387.2.372  2006/10/06 13:25:38  lulin
// - теперь вид строба получается из структуры, описывающей поведение горячей точки.
//
// Revision 1.387.2.371  2006/10/06 08:19:41  lulin
// - выкидываем ненужный параметр - класс горячей точки.
//
// Revision 1.387.2.370  2006/10/06 08:10:46  oman
// - fix: Очередной перепил ЦК22879, 22864
//
// Revision 1.387.2.369  2006/10/05 12:09:11  oman
// - fix: В мемо для КЗ не срабатывал первый Enter (cq22879)
// - refix: При смене текста документа на лету было AV (cq22864)
//
// Revision 1.387.2.368  2006/10/04 11:23:02  lulin
// - при получении горячей точки передаем "состояние" курсора.
//
// Revision 1.387.2.367  2006/10/04 08:32:05  lulin
// - теперь умолчательное поведение при действиях мышью описывается структурой - чтобы проще было расширять интерфейс.
//
// Revision 1.387.2.366  2006/10/04 06:47:36  lulin
// - начальную точку мыши упаковываем в состояние мыши.
//
// Revision 1.387.2.365  2006/10/04 06:23:44  lulin
// - точку мыши упаковываем в состояние мыши.
//
// Revision 1.387.2.364  2006/10/04 04:33:50  lulin
// - избавляемся от возвращаемого результа в стиле OLE.
//
// Revision 1.387.2.363  2006/10/03 13:56:23  lulin
// - выделяем альтернативный интерфейс получения "горячей точки".
//
// Revision 1.387.2.362  2006/10/03 13:15:40  lulin
// - используем более базовый интерфейс.
//
// Revision 1.387.2.361  2006/10/03 12:35:16  lulin
// - спрятан интерфейс, ненужный в F1 - чтобы не мешал выпрямлять кривизну.
//
// Revision 1.387.2.360  2006/10/02 11:38:34  lulin
// - объединяем с веткой в которой размеры параграфов подсчитываются методами канвы.
//
// Revision 1.387.2.359  2006/09/28 12:15:27  oman
// - fix: Двигать точку контекстного меню при вызове от клавиатуры
//  вправо больше не надо (cq22483)
//
// Revision 1.387.2.358  2006/09/26 14:43:51  oman
// - fix: При поиске гиперссылок.
//   1. Если было выделении могли замерзнуть на гиперссылке в
//       выделении (cq22726)
//   2. Гасилась каретка (cq22724)
//   3. Если было выедление, могли перескакивать через ссылку
//       (зависит от напровления выделения и поиска)
//
// Revision 1.387.2.357  2006/09/20 11:38:37  lulin
// - cleanup.
//
// Revision 1.387.2.356  2006/09/20 11:27:19  lulin
// - bug fix: не попадали в гиперссылку при открытии контекстного меню с клавиатуры (CQ OIT5-22440).
//
// Revision 1.387.2.355  2006/09/15 07:57:21  lulin
// - теперь по координатам курсора возвращаем более базовую точку.
//
// Revision 1.387.2.354  2006/08/31 14:29:23  oman
// - fix: Пры вызове контекстного меню от клавиатуры, чуть сдвигаем
//  точку выпадения вправо (cq22433)
//
// Revision 1.387.2.353  2006/08/29 12:36:59  lulin
// - bug fix: при переходе в конец документа не сбрасывальсь выделение (CQ OIT5-21768).
//
// Revision 1.387.2.352  2006/08/29 11:51:29  oman
// - fix: При смене документа не обновлялся мышиный курсор (cq22083)
//
// Revision 1.387.2.351  2006/08/28 13:47:02  lulin
// - bug fix: AV при получении "горячей точки" при переходных процессах смены текста (CQ OIT5-22362).
//
// Revision 1.387.2.350  2006/08/02 10:51:52  lulin
// - объединил с веткой в которой боролся со скроллингом.
//
// Revision 1.387.2.349  2006/08/02 09:16:08  mmorozov
// - bugfix: процессору, после создания, не устанавливали флаг _ReadOnly (CQ: OIT500022099);
//
// Revision 1.387.2.348  2006/07/21 11:43:31  lulin
// - имя метода убрано из комментариев - чтобы не находилось контекстным поиском.
//
// Revision 1.387.2.347  2006/07/21 11:35:24  lulin
// - имя метода убрано из комментариев - чтобы не находилось контекстным поиском.
//
// Revision 1.387.2.346  2006/07/20 18:36:55  lulin
// - имя метода убрано из комментариев - чтобы не находилось контекстным поиском.
//
// Revision 1.387.2.345  2006/07/20 18:28:05  lulin
// - убран лишний параметр.
//
// Revision 1.387.2.344  2006/07/20 18:10:44  lulin
// - избавляемся от получения горячей точки, через запрос интерфейса.
//
// Revision 1.387.2.343  2006/07/20 17:35:57  lulin
// - убраны параметры по умолчанию.
// - имя метода убрано из комментариев.
// - bug fix: в КЗ - рисовался "палец", теперь он правда рисуется в другом месте.
//
// Revision 1.387.2.342  2006/07/19 17:55:07  mmorozov
// - new: событие первой отрисовки текста, для производства замеров;
//
// Revision 1.387.2.341  2006/07/19 15:50:23  lulin
// - переименован метод - в соответствии с его параметрами.
//
// Revision 1.387.2.340  2006/07/19 14:33:27  lulin
// - теперь для обновления прямоугольника вывода работаем с исходным объектом, а не с формой.
//
// Revision 1.387.2.339  2006/07/19 14:24:13  lulin
// - теперь для определения прямоугольника вывода работаем с исходным объектом, а не с формой.
//
// Revision 1.387.2.338  2006/07/18 08:44:15  lulin
// - вставлена строчка для включения синхронного скроллирования.
//
// Revision 1.387.2.337  2006/07/14 14:40:56  lulin
// - bug fix: сбрасываем флаг о том, что было скроллирование при отрисовке документа.
//
// Revision 1.387.2.336  2006/07/14 13:46:59  lulin
// - гораздо реже дергаем непосредственное обновление окна.
//
// Revision 1.387.2.335  2006/07/12 14:00:10  oman
// - new: Метод MakePreviewRangeAsDocument
//
// Revision 1.387.2.334  2006/07/10 15:13:05  lulin
// - cleanup.
//
// Revision 1.387.2.333  2006/07/10 11:49:43  oman
// - new: Новые методы PreviewRange и CopyRange (cq21631).
//
// Revision 1.387.2.332  2006/07/10 08:44:50  lulin
// - cleanup: не запоминаем TextSource, т.к. смена редакций и полного/неполного текста давно уже делается сменой контейнера, а не TextSource.
//
// Revision 1.387.2.331  2006/07/10 08:31:31  lulin
// - cleanup: не запоминаем спрятанные стили, т.к. они не относятся к состоянию редактора и их восстанавливать не нужно.
//
// Revision 1.387.2.330  2006/07/10 08:21:36  lulin
// - bug fix: при переходе по гиперссылкам в историю не запоминалось положение курсора и соответственно, не восстанавливалось (CQ OIT5-21610).
//
// Revision 1.387.2.328  2006/07/10 07:13:27  lulin
// - исправлены имена интерфейсов.
//
// Revision 1.387.2.327  2006/07/10 06:53:54  lulin
// - исправлены имена классов.
//
// Revision 1.387.2.326  2006/07/07 08:57:36  mmorozov
// - bugfix: AV;
//
// Revision 1.387.2.325  2006/07/04 11:54:08  lulin
// - убрано значение параметра по-умолчанию.
//
// Revision 1.387.2.324  2006/07/03 15:45:52  lulin
// - разгребаем множественность методов добавления части выделения, которые в свое время наплодил Никитин.
//
// Revision 1.387.2.323  2006/07/03 14:43:08  lulin
// - cleanup.
//
// Revision 1.387.2.322  2006/07/03 14:10:31  lulin
// - вычищено внутреннее поле HotSpot'а о том, что было движение мыши - как устаревшее, теперь эти знания передаются в состоянии мыши.
//
// Revision 1.387.2.321  2006/07/03 12:35:18  lulin
// - new behavior: по тройному клику выделяем абзац целиком (CQ OIT5-21547).
//
// Revision 1.387.2.320  2006/07/03 11:58:52  lulin
// - передаем не множество клавиш, а "состояние мыши".
//
// Revision 1.387.2.319  2006/07/03 09:59:23  lulin
// - подготовительная работа к выделению параграфа третьим щелчком мыши.
//
// Revision 1.387.2.318  2006/07/03 09:15:37  lulin
// - new behavior: если выделили слово двойным щелчком мыши, то при последующем движении курсора выделение начинается с этого слова.
//
// Revision 1.387.2.317  2006/06/30 13:15:19  lulin
// - bug fix: неправильно выделялся текст при быстром движении мыши (CQ OIT5-17914).
//
// Revision 1.387.2.316  2006/06/30 08:49:39  lulin
// - cleanup.
//
// Revision 1.387.2.315  2006/06/30 08:43:05  lulin
// - cleanup.
//
// Revision 1.387.2.314  2006/06/27 11:35:46  lulin
// - bug fix: после подравнивания без движения мышью не обновлялось окно редактора.
//
// Revision 1.387.2.313  2006/06/27 11:15:59  lulin
// - bug fix: не работал переход к картинке, которая не уместилась целиком (CQ OIT5-21461).
// - bug fix: паразитное выделение, при кликаньи на последнюю строку текста (CQ OIT5-21473).
//
// Revision 1.387.2.312  2006/06/21 11:51:43  lulin
// - bug fix: со включенными темами не перерисовывался горизонтальный скроллбар (CQ OIT5-20311).
//
// Revision 1.387.2.311  2006/06/19 12:32:11  dinishev
// Bug fix: борьба с лишним скроллером при вкюченных темах.
//
// Revision 1.387.2.310  2006/06/09 11:35:23  lulin
// - bug fix: не всегда вставлялась картинка из буфера обмена (CQ OIT5-19060).
//
// Revision 1.387.2.309  2006/06/08 13:37:49  lulin
// - подготавливаем контролы к обработке числа повторений нажатия клавиши.
//
// Revision 1.387.2.308  2006/06/05 11:42:29  lulin
// - new behavior: для Немезиса не синхронизируем текст со скроллером, если скроллер  не отпустили (CQ OIT5-21221).
//
// Revision 1.387.2.307  2006/06/05 08:42:53  lulin
// - заплатка для борьбы с рудиментапи при скроллировании, при включенных блоках (CQ OIT5-21050).
//
// Revision 1.387.2.306  2006/06/02 12:45:53  lulin
// - cleanup.
//
// Revision 1.387.2.305  2006/05/31 08:27:08  lulin
// - bug fix: вставил глупую проверку для борьбы с AV при потере фокуса во время смены документа (CQ OIT5-21148).
//
// Revision 1.387.2.304  2006/04/24 09:28:07  oman
// - new beh: при печати для определения текущая страница ищем ближайший
//  листьевой параграф (cq20376)
//
// Revision 1.387.2.303  2006/04/18 10:49:37  mmorozov
// - bugfix: при работе с memo были проблемы;
//
// Revision 1.387.2.302  2006/04/12 13:10:12  oman
// - fix: неправильно определялась текущая страница для печати (cq20376)
//
// Revision 1.387.2.301  2006/03/10 14:53:42  lulin
// - bug fix: AV при фильтрации СКР (CQ OIT5-19972).
//
// Revision 1.387.2.300  2006/03/08 14:09:44  lulin
// - bug fix: не обновлялось содержимое мемо-поля (CQ OIT5-19912).
//
// Revision 1.387.2.299  2006/03/08 13:38:02  lulin
// - bug fix: AV при переходе по ссылке (CQ OIT5-19919).
//
// Revision 1.387.2.298  2006/03/08 13:22:41  lulin
// - bug fix: AV при переключении в действующую редакцию документа по ссылке.
//
// Revision 1.387.2.297  2006/03/06 12:16:01  lulin
// - cleanup.
//
// Revision 1.387.2.296  2006/03/06 11:39:48  lulin
// - bug fix: не обновлялся синхронный просмотр.
//
// Revision 1.387.2.295  2006/03/06 10:57:23  lulin
// - bug fix: не всегда вставлялись комментарии.
//
// Revision 1.387.2.294  2006/03/02 13:39:46  lulin
// - присваиваем _Owner'а каретке напрямую, а не через Selection.
//
// Revision 1.387.2.293  2006/03/02 13:25:02  lulin
// - теперь View не хранит ссылку на Shape, а получает его у контрола.
//
// Revision 1.387.2.292  2006/03/02 11:18:04  lulin
// - cleanup: View теперь не владеет курсором, а запрашивает его у контрола.
//
// Revision 1.387.2.291  2006/03/02 10:06:16  lulin
// - bug fix: AV при back при закрытом синхронном просмотре (CQ OIT5-19842).
//
// Revision 1.387.2.290  2006/03/02 08:12:18  lulin
// - модуль с выделением переехал в общий каталог.
//
// Revision 1.387.2.289  2006/03/02 07:07:24  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.387.2.288  2006/03/01 12:27:20  lulin
// - cleanup: избавляемся от обращения к нетипизированному _Owner'у.
//
// Revision 1.387.2.287  2006/03/01 11:28:34  lulin
// - cleanup: избавляемся от устаревшего интерфейса.
//
// Revision 1.387.2.286  2006/03/01 10:48:46  lulin
// - cleanup.
//
// Revision 1.387.2.285  2006/03/01 10:27:12  lulin
// - bug fix: при движении с Shift-ом не всегда изменялось выделение.
//
// Revision 1.387.2.284  2006/02/26 10:00:58  lulin
// - избавляемся от косвенного получения каретки у контрола - теперь канва владеет кареткой.
//
// Revision 1.387.2.283  2006/02/20 17:29:31  dinishev
// Корретная работа Tab (c выходом за пределы редактора)
//
// Revision 1.387.2.282  2006/02/17 19:10:18  lulin
// - cleanup.
//
// Revision 1.387.2.281  2006/02/17 08:48:10  lulin
// - bug fix: при скроллировании была рассинхронизация строк параграфов.
//
// Revision 1.387.2.280  2006/02/17 07:32:39  lulin
// - bug fix: был перепутан знак дельты.
//
// Revision 1.387.2.279  2006/02/17 06:25:13  lulin
// - очищаем коллекцию отрисованных параграфов при вставке/удалении параграфов.
//
// Revision 1.387.2.278  2006/02/15 18:57:59  lulin
// - cleanup.
//
// Revision 1.387.2.277  2006/02/15 18:25:25  lulin
// - прикрутил скроллирование окна на основе коллекции отрисованных параграфов. Пока немного глючит.
//
// Revision 1.387.2.276  2006/02/08 15:10:13  lulin
// - заставил работать Everest в ветке.
//
// Revision 1.387.2.275  2006/02/07 09:25:47  lulin
// - bug fix: неправильно рассчитывалась максимальная ширина горизонтального скроллера (CQ OIT5-19466).
//
// Revision 1.387.2.274  2006/02/06 15:36:46  lulin
// - bug fix: падали при вставке комментария в толковый словарь - при наличии выделения (CQ OIT5-19409).
//
// Revision 1.387.2.273  2006/02/03 14:55:57  lulin
// - bug fix: избавился от неадекватного поведения скроллера в КЗ (CQ OIT5-19361).
//
// Revision 1.387.2.272  2006/02/02 10:53:12  lulin
// - cleanup.
//
// Revision 1.387.2.271  2006/01/30 08:18:17  lulin
// - cleanup.
//
// Revision 1.387.2.270  2006/01/30 08:03:58  lulin
// - cleanup.
//
// Revision 1.387.2.269  2006/01/26 15:12:01  lulin
// - bug fix: прячем выделение не при нажатии кнопки, а при изменении выделенного блока (CQ OIT5-16215).
//
// Revision 1.387.2.268  2006/01/25 12:09:39  lulin
// - bug fix: при изменении выделения не всегда целиком перерисовывалось окно редактора (CQ OIT5-18981).
//
// Revision 1.387.2.267  2006/01/24 12:54:07  lulin
// - cleanup.
//
// Revision 1.387.2.266  2006/01/24 12:09:46  lulin
// - cleanup.
//
// Revision 1.387.2.265  2006/01/23 12:54:44  lulin
// - убрна заточка про горизонтальный скроллер.
//
// Revision 1.387.2.264  2006/01/23 12:40:42  lulin
// - bug fix: не всегда появлялся и не всегда исчезал горизонтальный скроллер.
//
// Revision 1.387.2.263  2006/01/20 14:55:46  lulin
// - bug fix: при появлении горизонтального скроллера оставляем курсор видимым на экране (CQ OIT5-19183).
//
// Revision 1.387.2.262  2006/01/20 14:24:07  lulin
// - cleanup.
//
// Revision 1.387.2.261  2006/01/20 14:07:34  lulin
// - в ветку кода, куда не должны попадать вставлен assert.
//
// Revision 1.387.2.260  2006/01/19 13:16:42  lulin
// - bug fix: при контекстном поиске редактор неправильно скроллировался по горизонтали - найденного фрагмента не было видно (CQ OIT5-19183).
//
// Revision 1.387.2.259  2006/01/16 09:18:38  lulin
// - new behavior: если параграф не сформатирован, а просят его i-ю строку, то форматируем его.
//
// Revision 1.387.2.258  2006/01/10 13:48:04  lulin
// - bug fix: был AV при быстром переключении редакций (CQ OIT5-18961).
//
// Revision 1.387.2.257  2005/12/28 13:55:46  lulin
// - падало при зажатой клавише Esc (CQ OIT5-18883).
//
// Revision 1.387.2.256  2005/12/23 11:13:07  lulin
// - bug fix: не пересчитывались параметры шрифта.
//
// Revision 1.387.2.255  2005/12/22 17:43:09  dinishev
// Bug fix: глюки с горизонтальным скроллером
//
// Revision 1.387.2.254  2005/12/21 15:54:54  lulin
// - bug fix: при переключении полный текст/извлечения - не сохранялись комментарии, сохранялись только при выходе из оболочки.
//
// Revision 1.387.2.252  2005/12/21 14:27:01  lulin
// - new behavior: сделана синхронизация редактирования комментариев в различных копиях текста.
//
// Revision 1.387.2.251  2005/12/15 13:30:14  lulin
// - cleanup: убрано смешение знаковых и беззнаковых типов.
//
// Revision 1.387.2.250  2005/12/13 12:46:51  lulin
// - bug fix: был AV при быстрой смене документов (CQ OIT5-18584).
//
// Revision 1.387.2.249  2005/12/09 12:13:44  lulin
// - bug fix: был AV при переключении в полный текст.
//
// Revision 1.387.2.248  2005/12/08 18:44:38  lulin
// - cleanup.
//
// Revision 1.387.2.247  2005/12/08 17:40:29  lulin
// - bug fix: в 3-й раз починил циклические ссылки между объектами.
// - bug fix: висло при Back по истории - т.к. циклически создавался контейнер документа.
//
// Revision 1.387.2.246  2005/12/08 14:47:59  lulin
// - cleanup.
//
// Revision 1.387.2.245  2005/12/08 13:48:42  lulin
// - cleanup.
//
// Revision 1.387.2.244  2005/12/07 16:08:43  lulin
// - cleanup.
//
// Revision 1.387.2.243  2005/12/05 11:15:39  lulin
// - bug fix: все падало при подгрузке документа из потока - из за того, что пытались рекурсивно войти в процедуру отрисовки.
//
// Revision 1.387.2.242  2005/12/05 09:06:15  lulin
// - валидация генерации документа полностью переехала с TextSource на DocumentContainer.
//
// Revision 1.387.2.241  2005/12/05 06:21:39  lulin
// - реализация владельца утилиты перенесена на базовый контрол.
//
// Revision 1.387.2.240  2005/12/05 06:04:52  lulin
// - реализация инструментов перенесена в базовую библиотеку.
//
// Revision 1.387.2.239  2005/12/05 05:48:56  lulin
// - интерфейс инструментов перенесен в базовую библиотеку.
//
// Revision 1.387.2.238  2005/12/05 05:29:30  lulin
// - HotSpot редактора выделен в отдельный модуль.
//
// Revision 1.387.2.237  2005/12/05 04:18:16  lulin
// - cleanup.
//
// Revision 1.387.2.236  2005/12/03 19:43:57  lulin
// - удален старый механизм перехода на метки. Теперь все делается через Waiter'ов.
//
// Revision 1.387.2.235  2005/12/03 14:46:52  lulin
// - избавляемся от хитросплетений методов TextSource и контейнера документа.
//
// Revision 1.387.2.234  2005/12/02 22:56:23  lulin
// - запрещаем присваивать документ контейнеру.
//
// Revision 1.387.2.233  2005/12/02 18:23:27  lulin
// - обрабока нотфификации об удалении/добавлении параграфа практически полностью перенесена на процессор.
//
// Revision 1.387.2.232  2005/12/01 13:07:27  lulin
// - bug fix: бы AV при хождении по истории.
//
// Revision 1.387.2.231  2005/12/01 12:10:39  lulin
// - восстановлена задержка перехода на конец документа, если документ еще грузится.
//
// Revision 1.387.2.230  2005/12/01 10:06:11  lulin
// - удалены методы, связанные со старым алгоритмом форматирования.
//
// Revision 1.387.2.229  2005/12/01 08:22:59  lulin
// - cleanup.
//
// Revision 1.387.2.228  2005/12/01 08:02:34  lulin
// - cleanup: хитрая обработка добавляемых тегов (в частности формирование оглавления) перенесена с TextSource на DocumentContainer.
//
// Revision 1.387.2.227  2005/12/01 06:20:33  lulin
// - реализация _preview перенесена в более общую библиотеку.
//
// Revision 1.387.2.226  2005/12/01 06:10:33  lulin
// - интерфейс _preview перенесен в более общую библиотеку.
//
// Revision 1.387.2.225  2005/11/30 14:22:22  lulin
// - cleanup.
//
// Revision 1.387.2.224  2005/11/25 14:59:20  lulin
// - bug fix: не выполняем лишние действия.
//
// Revision 1.387.2.223  2005/11/25 14:54:16  lulin
// - bug fix: при смене документа не отвязывали себя от View - в итоге были всякие разные проблемы с провисшими ссылками.
//
// Revision 1.387.2.222  2005/11/25 13:37:30  lulin
// - bug fix: было зависание при возврате по истории.
//
// Revision 1.387.2.221  2005/11/25 13:13:40  lulin
// - bug fix: не очищали коллекцию отрисованных параграфов при очистске курсора. В результате опять провисали ссылки. В результате опять все зависало.
//
// Revision 1.387.2.220  2005/11/25 12:45:22  lulin
// - bug fix: не очищали коллекцию отрисованных параграфов при очистске курсора. В результате опять провисали ссылки. В результате опять все зависало.
//
// Revision 1.387.2.219  2005/11/23 11:05:14  lulin
// - спрятан ненужный метод.
//
// Revision 1.387.2.218  2005/11/23 08:57:34  dinishev
// Подправлена реакция кнопок на движение мыши
//
// Revision 1.387.2.217  2005/11/22 11:41:55  lulin
// - сделал сохранение комментариев при потере фокуса.
//
// Revision 1.387.2.216  2005/11/22 11:31:46  lulin
// - для курсора сделал рекурсивное сохранение тегов.
//
// Revision 1.387.2.215  2005/11/22 11:20:16  lulin
// - bug fix: при переходе по истории позиционировались на Sub.
//
// Revision 1.387.2.214  2005/11/21 11:02:48  lulin
// - bug fix: при уходе документа в историю не сохранялись комментарии.
//
// Revision 1.387.2.213  2005/11/18 15:13:33  lulin
// - доделано сохранение комментариев.
//
// Revision 1.387.2.212  2005/11/18 13:44:37  oman
// - fix: _TevCustomEditorWindow.pm_SetModified никогда не срабатывал
// - fix: _TevCustomEditorWindow._CursorChanged вставил условную компиляцию DesignTimeLibrary при обращении к _TextPara
//
// Revision 1.387.2.211  2005/11/15 13:50:01  lulin
// - cleanup: используем только Reader тегов - не подкладывая под него Pool. Связывание теперь осуществляется раньше.
//
// Revision 1.387.2.210  2005/11/15 11:32:34  lulin
// - типизируем интерфейс потока.
//
// Revision 1.387.2.209  2005/11/14 18:36:56  lulin
// - теперь при заборе в буфер обмена в него кладется контейнер документа, а не TextSource - должно починить ошибку CQ OIT5-17870.
//
// Revision 1.387.2.208  2005/11/14 13:53:05  lulin
// - bug fix: при выделении не вставлялись комментарии (CQ OIT5-18019).
//
// Revision 1.387.2.207  2005/11/14 10:53:04  dinishev
// Пропадал курсор в ППР после перехода в КЗ после создания нового фильтра. (CQ 16984)
//
// Revision 1.387.2.206  2005/11/11 22:31:40  lulin
// - избавляемся от управления свойством модифицированности документа путем посылки сообщений.
//
// Revision 1.387.2.205  2005/11/11 22:23:14  lulin
// - избавляемся от управления свойством модифицированности документа путем посылки сообщений.
//
// Revision 1.387.2.204  2005/11/11 20:31:40  dinishev
// Вызовы обработчиков для дерева перенесены на QueryCardEditor
//
// Revision 1.387.2.203  2005/11/11 17:01:31  lulin
// - bug fix: зависала оболочка при переключении документа с пустого на непустой (CQ OIT5-17961).
//
// Revision 1.387.2.202  2005/11/11 16:39:40  fireton
// - bug fix: не сохраняем выделение при поиске во всем тексте
//
// Revision 1.387.2.201  2005/11/10 18:55:39  lulin
// - new behavior: не скроллируем контрол, если якорь реалтно не изменился.
//
// Revision 1.387.2.200  2005/11/09 17:55:28  lulin
// - bug fix: не перерисовывалось окно редактора поле снятия выделения (CQ OIT5-17899).
//
// Revision 1.387.2.199  2005/11/09 16:14:28  lulin
// - bug fix: с Shift'ом была возможность выделить всю группу контролов.
//
// Revision 1.387.2.198  2005/11/09 15:28:23  lulin
// - базовые интерфейсы перенесены в правильный модуль.
//
// Revision 1.387.2.197  2005/11/08 17:50:52  lulin
// - bug fix: мерцание панели Sub'ов при попытке скроллирования колесом выше начала документа (CQ OIT5-17172).
//
// Revision 1.387.2.196  2005/11/08 15:31:29  lulin
// - bug fix: при клике мышью не снималось выделение (CQ OIT5-17734).
//
// Revision 1.387.2.195  2005/11/08 15:06:27  lulin
// - new behavior: запрещаем скроллировать горизонтальным скроллером за пределами документа.
//
// Revision 1.387.2.194  2005/11/08 13:22:51  lulin
// - не изменяем позицию скроллера - если она и так уже такая.
//
// Revision 1.387.2.193  2005/11/08 11:42:08  lulin
// - bug fix: при движении курсора не снималось выделение (CQ OIT5-17691).
//
// Revision 1.387.2.192  2005/11/08 10:56:25  lulin
// - bug fix: не закрывлись скобки обновления шрифта и стиля блока - в результате повисали при закрытии.
//
// Revision 1.387.2.191  2005/11/05 09:03:13  lulin
// - выделяем у якоря и у курсора общую функциональность.
//
// Revision 1.387.2.190  2005/11/05 08:12:27  lulin
// - выделяем у якоря и у курсора общую функциональность.
//
// Revision 1.387.2.189  2005/11/04 16:47:57  lulin
// - базовый объект теперь поддерживает свое удаление.
//
// Revision 1.387.2.188  2005/11/04 16:46:06  dinishev
// Обработка нажатия Shift+Enter в качестве добавления полей
//
// Revision 1.387.2.187  2005/11/03 09:15:48  fireton
// - bug fix: не собиралась библиотека
//
// Revision 1.387.2.186  2005/11/03 07:15:51  lulin
// - оптимизируем скроллирование документа с клавиатуры (CQ OIT5-17499).
//
// Revision 1.387.2.185  2005/11/02 13:19:04  lulin
// - не пересчитываем шрифт при смене выделения, будем потом пересчитывать его on-demand (CQ OIT5-17495).
//
// Revision 1.387.2.184  2005/11/02 11:54:26  lulin
// - bug fix: иногда не показывалась справка к документу (CQ OIT5-17125).
//
// Revision 1.387.2.183  2005/11/01 14:05:20  lulin
// - bug fix: не печаталась текущая страница.
//
// Revision 1.387.2.182  2005/11/01 07:11:46  lulin
// - bug fix: теперь в карточке запросов невозможно выделить более одного поля (CQ OIT5-16201).
//
// Revision 1.387.2.181  2005/10/27 16:21:49  lulin
// - упрощаем получение размера страницы горизонтального скроллера.
//
// Revision 1.387.2.180  2005/10/25 11:05:44  lulin
// - не получаем напрямую информационную канву экрана, а получаем ее через фасад.
//
// Revision 1.387.2.179  2005/10/18 12:11:13  dinishev
// Bug fix: отъехала прокрутка с помощью колеса мыши в редакторе.
//
// Revision 1.387.2.178  2005/10/13 17:27:20  dinishev
// Попытка отвязать модель от редактора и привязать её к DocumentContainer
//
// Revision 1.387.2.177  2005/10/13 06:00:23  lulin
// - cleanup.
//
// Revision 1.387.2.176  2005/10/11 14:21:14  lulin
// - bug fix: не возвращался курсор на верхний край документа.
//
// Revision 1.387.2.175  2005/10/11 14:15:19  lulin
// - bug fix: был AV при попытке вставить комментарий за конец документа.
//
// Revision 1.387.2.174  2005/10/10 11:43:15  lulin
// - cleanup: используем интерфейсы из правильной библиотеки.
//
// Revision 1.387.2.173  2005/10/07 14:50:15  dinishev
// Событие о движение мыши теперь попадает в BlockHotSpot
//
// Revision 1.387.2.172  2005/10/07 09:22:13  lulin
// - bug fix: при рисовании документа совершенно бесцельно дергался поиск параграфа с Sub'ом.
//
// Revision 1.387.2.171  2005/10/06 08:30:20  dinishev
// Bug fix: AV с переполнением целого при вызове контекстного меню на параграфе с/без рамки (каретка ввода не видна).
//
// Revision 1.387.2.170  2005/10/06 08:25:10  lulin
// - убран устаревший класс.
//
// Revision 1.387.2.169  2005/10/06 08:15:51  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.387.2.168  2005/10/06 08:02:44  lulin
// - cleanup.
//
// Revision 1.387.2.167  2005/10/05 17:33:51  dinishev
// Контекстные меню
//
// Revision 1.387.2.166  2005/10/05 11:35:19  lulin
// - потихоньку откручиваем представление от TextSource.
//
// Revision 1.387.2.165  2005/10/05 08:28:49  lulin
// - bug fix: из оглавления от документа в виде дерева, не переходили на встроенные объекты.
//
// Revision 1.387.2.164  2005/10/04 12:48:00  lulin
// - убрано устаревшее свойство - размеры документа.
//
// Revision 1.387.2.163  2005/10/03 07:02:32  lulin
// - cleanup.
//
// Revision 1.387.2.162  2005/09/23 16:03:54  lulin
// - выделен модуль с общими интерфейсами.
//
// Revision 1.387.2.161  2005/09/23 12:27:38  lulin
// - вытаскиваем общие интерфейсы в общий каталог.
//
// Revision 1.387.2.160  2005/09/22 12:37:18  lulin
// - bug fix: после back не работали переходы по ссылкам.
//
// Revision 1.387.2.159  2005/09/22 08:33:41  lulin
// - bug fix: был AV при хитрых переходах по истории.
//
// Revision 1.387.2.158  2005/09/21 09:40:42  lulin
// - теперь при по форматировании текса по ширине окна справа добавлен отступ в два символа.
//
// Revision 1.387.2.157  2005/09/15 10:34:14  lulin
// - bug fix: при нажатии на Enter при наличии неудаляемого выделения сообщение об ошибке выводилось пользователю (CQ OIT5-16399).
//
// Revision 1.387.2.156  2005/09/12 10:41:41  lulin
// - bug fix: неправильно заливали поля редактора.
//
// Revision 1.387.2.155  2005/09/12 10:26:10  lulin
// - new behavior: чтобы черточка внизу документа не мерцала при сроллировании - рисуем правый и левый отступ в самый последний момент.
//
// Revision 1.387.2.154  2005/09/12 10:09:48  lulin
// - восстановлено рисование черточки внизу документа.
//
// Revision 1.387.2.153  2005/09/12 09:37:54  lulin
// - bug fix: неправильно рисовалась каретка после скроллирования окна редактора.
//
// Revision 1.387.2.152  2005/09/12 08:40:40  lulin
// - bug fix: при смене размеров окна не всегда перерисовывалась каретка окна.
//
// Revision 1.387.2.151  2005/09/12 07:47:42  lulin
// - cleanup.
//
// Revision 1.387.2.150  2005/09/12 06:21:01  lulin
// - клавиши перемещения курсора теперь работают через View.
//
// Revision 1.387.2.149  2005/09/09 15:47:21  lulin
// - при редактировании текста не перерисовываем все окно - если высота параграфа не изменилась - сильно помогло с вводом в КЗ.
//
// Revision 1.387.2.148  2005/09/07 11:56:15  lulin
// - bug fix: при возврате по истории теперь восстанавливается точка верхнего края редактора.
//
// Revision 1.387.2.147  2005/09/07 09:05:11  dinishev
// Remove interface InevInputListener
//
// Revision 1.387.2.146  2005/09/06 16:58:31  lulin
// - выделен метод _CheckView.
//
// Revision 1.387.2.145  2005/09/06 16:54:15  lulin
// - cleanup.
//
// Revision 1.387.2.144  2005/09/06 16:40:43  lulin
// - cleanup.
//
// Revision 1.387.2.143  2005/09/06 16:26:33  lulin
// - cleanup: убрано ненужное свойство.
//
// Revision 1.387.2.142  2005/09/01 11:29:42  lulin
// - список спрятанных стилей теперь известен View.
//
// Revision 1.387.2.141  2005/09/01 10:27:09  lulin
// - из-за проблем с курсором убрана двойная буферизация.
//
// Revision 1.387.2.140  2005/08/31 17:49:04  dinishev
// Корректно обрабатываем клавишу ESC для дерева (должно закрыться, если было открыто)
//
// Revision 1.387.2.139  2005/08/31 15:22:05  lulin
// - для КЗ включена двойная буферизация.
//
// Revision 1.387.2.138  2005/08/30 13:08:38  lulin
// - new behavior: при DnD редактор возвращает правильное действие (copy).
//
// Revision 1.387.2.137  2005/08/29 11:52:43  lulin
// - свойство _PlainText переехало на базовый редактор.
//
// Revision 1.387.2.136  2005/08/29 11:22:57  lulin
// - bug fix: не всегда рисовался документ при смене контейнера.
//
// Revision 1.387.2.135  2005/08/26 14:18:16  lulin
// - bug fix: иногда не отрисовывался курсо при первой инициализации КЗ.
//
// Revision 1.387.2.134  2005/08/26 13:34:13  lulin
// - bug fix: не всегда перерисовывались курсор и фокусная рамка.
//
// Revision 1.387.2.133  2005/08/26 12:15:17  mmorozov
// - warning fix;
//
// Revision 1.387.2.132  2005/08/17 11:23:41  dinishev
// Bug fix: выпадающее дерево в КЗ и календарь оставались поверх редактора, если была прокрутка текста.
//
// Revision 1.387.2.131  2005/07/28 10:14:17  lulin
// - переходим на более конкретные интерфейсы параграфов.
//
// Revision 1.387.2.130  2005/07/27 19:25:36  lulin
// - избавился от глобальных объектов для КЗ - теперь с каждым редактором связана своя обвязка для карточки запроса.
//
// Revision 1.387.2.129  2005/07/27 16:07:03  lulin
// - переупорядочил наименование и расположение интерфейсов для КЗ.
//
// Revision 1.387.2.128  2005/07/27 09:31:02  lulin
// - поддержка истории спущена на базовый редактор.
//
// Revision 1.387.2.127  2005/07/26 14:11:18  lulin
// - убраны лишние параметры в методе трансляции сообщений.
//
// Revision 1.387.2.126  2005/07/26 12:42:36  lulin
// - контрол теперь отдает процессор Shotcut'ов.
//
// Revision 1.387.2.125  2005/07/25 18:09:15  lulin
// - теперь TextSource не знает про реализацию контейнера документа, а только про его интерфейс.
//
// Revision 1.387.2.124  2005/07/25 12:13:14  lulin
// - TextSource теперь знает про базовый контейнер документа, а не про специализированный.
//
// Revision 1.387.2.123  2005/07/22 16:00:39  dinishev
// Убраны ссылки на скрипты
//
// Revision 1.387.2.122  2005/07/22 15:03:30  dinishev
// Новая версия
//
// Revision 1.387.2.121  2005/07/21 17:34:21  lulin
// - bug fix: была ошибка в определении размеров контрола - в итоге никогда не очищался список нарисованных параграфов.
//
// Revision 1.387.2.120  2005/07/21 07:54:31  lulin
// - убран промежуточный интерфейс и упрощено использование функции поиска/замены.
//
// Revision 1.387.2.119  2005/07/21 06:46:11  lulin
// - модификация состояния курсора и его связей с другими курсорами разнесены на два разных интерфейса.
//
// Revision 1.387.2.118  2005/07/21 05:27:42  lulin
// - обеспечена возможность повторного входа в процедуру отрисовки, без потери ресурсов.
//
// Revision 1.387.2.117  2005/07/21 05:05:03  lulin
// - распилил модуль с TextSource на несколько.
//
// Revision 1.387.2.116  2005/07/20 18:49:26  lulin
// - редактор теперь умеет работать с базовым TextSource, а не со специализированным.
//
// Revision 1.387.2.115  2005/07/20 18:21:13  lulin
// - убран переходный интерфейс.
//
// Revision 1.387.2.114  2005/07/20 17:31:43  lulin
// - спрятаны методы, которые не стоит использовать напрямую.
//
// Revision 1.387.2.113  2005/07/20 15:13:18  lulin
// - убрано косвенное получение инструментов для чтения/записи тега.
//
// Revision 1.387.2.112  2005/07/20 12:56:48  lulin
// - bug fix: залечил остающиеся объекты, появлявшиеся при повторном входе в процедуру отрисовки.
//
// Revision 1.387.2.111  2005/07/19 17:23:46  lulin
// - убран косвенный доступ к списку Sub'ов документа - теперь он получается непосредственно от параграфа.
//
// Revision 1.387.2.110  2005/07/19 16:47:04  lulin
// - убран косвенный запрос подтверждения замены. Теперь соответствующий интерфейс подается непосредственно в Replacer.
//
// Revision 1.387.2.109  2005/07/19 15:32:23  lulin
// - убрана часть обращений к интересующим интерфейсам через цепочку Parent'ов диапазонов и курсоров.
//
// Revision 1.387.2.108  2005/07/19 12:03:19  lulin
// - cleanup: удалены ненужные модули и методы.
//
// Revision 1.387.2.107  2005/07/19 09:37:48  lulin
// - избавился от посылки сообщений.
//
// Revision 1.387.2.106  2005/07/19 08:25:03  lulin
// - избавился от посылки сообщений для конвертации текста параграфа - перевел конвертацию на общий механизм Search/_Replace.
//
// Revision 1.387.2.105  2005/07/18 17:37:42  lulin
// - упорядочена интерфейсная модель редактора - для удобства чтения и эффективности использования, а также для избавления от посылки сообщений.
//
// Revision 1.387.2.104  2005/07/18 15:10:26  lulin
// - избавляемся от косвенного приведения одного интерфейса к другому.
//
// Revision 1.387.2.103  2005/07/18 11:22:36  lulin
// - методу, возвращаещему выделение на параграфе дано более подходящее название.
//
// Revision 1.387.2.102  2005/07/18 10:26:12  lulin
// - удален ненужный интерфейс окна.
//
// Revision 1.387.2.101  2005/07/15 15:45:30  lulin
// - new behavior: перерисовываем строки параграфов, через _InevSimpleView.
//
// Revision 1.387.2.100  2005/07/15 13:56:04  lulin
// - new behavior: перерисовываем параграфы, через _InevSimpleView.
//
// Revision 1.387.2.99  2005/07/15 13:17:53  lulin
// - поддерживаем новый интерфейс области вывода.
//
// Revision 1.387.2.98  2005/07/15 10:14:03  lulin
// - избавляемся от использования самостийной функции преобразования интерфейсов.
//
// Revision 1.387.2.97  2005/07/14 14:17:35  lulin
// - new behavior: теперь один документ может быть привязан к нескольким TextSource - т.е. одна и та же копия документа может быть показана в разных окнах редакторов, расположенных на разных формах.
//
// Revision 1.387.2.96  2005/07/14 10:24:25  lulin
// - реализация интерфейса IevSubList спущена с TextSource, на DocumentContainer.
//
// Revision 1.387.2.95  2005/07/14 09:07:45  lulin
// - new interface: InevTextSource.
// - new behavior: DocumentContainer теперь не знает напрямую о TextSource, а только через интерфейс InevTextSource - это задел на показ одного документа в нескольких окнах.
//
// Revision 1.387.2.94  2005/07/13 15:36:29  lulin
// - new unit: evEditorWindowTextSource.
//
// Revision 1.387.2.93  2005/07/13 12:55:36  lulin
// - new behavior: при трансляции клавиш передаем View в операцию трансляции.
//
// Revision 1.387.2.92  2005/07/11 14:23:33  mmorozov
// new: использование директивы компиляции "_evMakeTableOfContents";
//
// Revision 1.387.2.91  2005/07/11 06:07:05  lulin
// - упорядочены названия интерфейсов.
//
// Revision 1.387.2.90  2005/07/08 12:50:10  lulin
// - bug fix: при скроллировании окна по курсору съезжала координата X.
//
// Revision 1.387.2.89  2005/07/07 17:46:58  lulin
// - new behavior: транслируем экранные координаты в координаты параграфа, используя информацию от View.
//
// Revision 1.387.2.88  2005/07/07 17:21:47  lulin
// - убран устаревший интерфейс.
//
// Revision 1.387.2.87  2005/07/07 17:15:46  lulin
// - InevAnchor и InevViewPoint теперь наследуются от InevLocation.
//
// Revision 1.387.2.86  2005/07/07 16:54:01  lulin
// - cleanup.
//
// Revision 1.387.2.85  2005/07/07 15:38:04  lulin
// - InevViewPoint теперь не наследуется от InevAnchor.
//
// Revision 1.387.2.84  2005/07/07 15:10:38  lulin
// - new behavior: теперь HotSpot запоминает точку в которой находился курсор.
//
// Revision 1.387.2.83  2005/07/07 13:58:20  lulin
// - спрятана возможность получения от View координат якоря в точках.
//
// Revision 1.387.2.82  2005/07/07 13:30:30  lulin
// - спрятана возможность прямой модификации _TopAnchor.
//
// Revision 1.387.2.81  2005/07/07 13:09:27  lulin
// - упорядочены названия интерфейсов.
//
// Revision 1.387.2.80  2005/07/07 11:41:17  lulin
// - передаем в _GetAdvancedHotSpot специальный интерфейс InevViewPoint.
//
// Revision 1.387.2.79  2005/07/04 06:51:15  lulin
// - bug fix: в документе, полученном как дерево, не рисовались Sub'ы.
//
// Revision 1.387.2.78  2005/07/01 14:09:59  lulin
// - bug fix: защищаемся от AV при отсутствии информации о отрисованных параграфах.
//
// Revision 1.387.2.77  2005/07/01 13:29:01  lulin
// - для определения HotSpot'ов пользуемся коллекцией отрисованных параграфов.
//
// Revision 1.387.2.76  2005/07/01 12:50:17  lulin
// - для определения курсора пользуемся коллекцией отрисованных параграфов.
//
// Revision 1.387.2.75  2005/06/29 11:38:29  lulin
// - cleanup.
//
// Revision 1.387.2.74  2005/06/29 11:19:30  lulin
// - cleanup.
//
// Revision 1.387.2.73  2005/06/29 10:51:18  lulin
// - bug fix: не забываем взводить флаг о том, что был скроллинг.
//
// Revision 1.387.2.72  2005/06/29 10:30:16  lulin
// - введен собственный тип для множества скроллбар'ов - чтобы не такскать везде это виндовое уродство.
//
// Revision 1.387.2.71  2005/06/28 11:05:40  lulin
// - new behavior: при переходе на Sub синхронизируем позицию скроллера.
//
// Revision 1.387.2.70  2005/06/28 10:29:11  lulin
// - new behavior: теперь контрол инициализирует свой скроллер исходя из параметров соответствующего скроллера от View.
//
// Revision 1.387.2.69  2005/06/27 14:16:46  lulin
// - new behavior: для вертикального скроллера используем AllChildrenCount.
//
// Revision 1.387.2.68  2005/06/25 14:24:59  lulin
// - new behavior: View теперь умеет контроллировать изменение размеров скроллера и сообщать об этом контролу.
//
// Revision 1.387.2.67  2005/06/24 16:02:29  lulin
// - bug fix: не создавался курсор, если документ получался не путем парсинга, а из дерева.
//
// Revision 1.387.2.66  2005/06/22 17:53:03  lulin
// - типы переименованы в соответствии с названием библиотеки.
//
// Revision 1.387.2.65  2005/06/22 17:34:09  lulin
// - генератор документа в памяти перенесен в "правильную" библиотеку.
//
// Revision 1.387.2.64  2005/06/22 10:21:42  lulin
// - bug fix: при скроллировании теперь временно очищаем панель Sub'ов, т.к. нету возможности по другому ее корректно перерисовать.
//
// Revision 1.387.2.63  2005/06/20 15:42:09  lulin
// - cleanup: избавляемся от абсолютных координат.
//
// Revision 1.387.2.62  2005/06/17 11:40:47  lulin
// - bug fix: при смене контейнера у TextSource не изманялся отображаемый документ (CQ OIT5-15717).
//
// Revision 1.387.2.61  2005/06/16 16:04:44  lulin
// - cleanup: подготавливаемся к расширению интерфейса InevTextPara.
//
// Revision 1.387.2.60  2005/06/16 14:59:13  lulin
// - cleanup: удалены ненужные зависимости.
//
// Revision 1.387.2.59  2005/06/16 14:11:29  lulin
// - cleanup: отдельно стоящие процедуры перенесены на интерфейсы.
//
// Revision 1.387.2.58  2005/06/16 11:24:11  lulin
// - убрана косвенная типизация параграфов (при помощи _QI и QT).
//
// Revision 1.387.2.57  2005/06/15 17:23:51  lulin
// - remove proc: _evMoveCursor.
//
// Revision 1.387.2.56  2005/06/15 13:05:59  lulin
// - убрана инициализация блоков выделения в явном виде.
//
// Revision 1.387.2.55  2005/06/15 11:04:09  lulin
// - убрана инициализация курсоров в явном виде.
//
// Revision 1.387.2.54  2005/06/14 14:51:51  lulin
// - new interface: _InevSelection.
// - remove interface: IevSelection.
//
// Revision 1.387.2.53  2005/06/14 12:38:58  lulin
// - избавился от передачи безликого интерфейса (теперь передается View).
//
// Revision 1.387.2.52  2005/06/14 10:01:30  lulin
// - избавился от передачи безликого интерфейса (теперь передается View).
//
// Revision 1.387.2.51  2005/06/11 14:38:23  lulin
// - корректнее и дешевле получаем верхний параграф.
//
// Revision 1.387.2.50  2005/06/11 12:24:55  lulin
// - свойство View теперь сделано доступным всем.
//
// Revision 1.387.2.49  2005/06/11 11:56:47  lulin
// - уменьшаем количество получения необходимых интерфейсов косвенно (через _QI).
//
// Revision 1.387.2.48  2005/06/11 08:55:38  lulin
// - в какой-то мере восстановлена работоспособность HotSpot'ов.
//
// Revision 1.387.2.47  2005/06/10 16:43:53  lulin
// - new behavior: сразу прячем каретку, если курсор не на экране.
//
// Revision 1.387.2.46  2005/06/10 16:27:53  lulin
// - bug fix: правильнее скроллируем окно по курсору.
//
// Revision 1.387.2.45  2005/06/10 14:30:11  lulin
// - bug fix: не всегда окно скроллировалось, при выделении текста мышью.
//
// Revision 1.387.2.44  2005/06/10 12:54:31  lulin
// - cleanup: у редактора убрано знание про верхнюю позицию скроллирования.
//
// Revision 1.387.2.43  2005/06/09 13:22:27  lulin
// - восстановлена возможность позиционирования курсора мышью.
//
// Revision 1.387.2.42  2005/06/09 12:05:09  lulin
// - удалено знание курсора о верхней точке окна.
//
// Revision 1.387.2.41  2005/06/09 11:27:40  lulin
// - временно отключен код, подгоняющий курсор по экрану.
//
// Revision 1.387.2.40  2005/06/09 09:57:53  lulin
// - от абсолютных координат переходим к относительным.
//
// Revision 1.387.2.39  2005/06/08 15:07:22  lulin
// - new behavior: начал переводить обработку "тыканья" мышью с абсолютных координат на относительные.
//
// Revision 1.387.2.38  2005/06/08 14:28:04  lulin
// - new behavior: при вычисленнии координат мышиного курсора не учитываем Top от редактора.
//
// Revision 1.387.2.37  2005/06/08 14:03:55  lulin
// - cleanup.
//
// Revision 1.387.2.36  2005/06/08 10:41:58  lulin
// - вместо флага используем счетчик.
//
// Revision 1.387.2.35  2005/06/08 09:56:34  mmorozov
// - change: позиция курсора теперь определяется и устанавливается в процессе отрисовке;
//
// Revision 1.387.2.34  2005/06/07 13:43:47  lulin
// - удален ненужный модуль.
//
// Revision 1.387.2.33  2005/06/07 12:46:30  lulin
// - заключительный аккорд перехода с объектов на интерфейсы (при работе с курсорами).
//
// Revision 1.387.2.32  2005/06/07 11:48:48  lulin
// - bug fix: был AV в Design-time при создании Memo-поля.
//
// Revision 1.387.2.31  2005/06/03 16:00:49  lulin
// - cleanup.
//
// Revision 1.387.2.30  2005/06/03 14:23:32  lulin
// - еще один шаг от объектов к интерфейсам.
//
// Revision 1.387.2.29  2005/06/03 12:18:18  lulin
// - убран Assert при поиске.
//
// Revision 1.387.2.28  2005/06/03 12:08:18  lulin
// - cleanup: убраны ненужные зависимости.
//
// Revision 1.387.2.27  2005/06/02 14:44:23  lulin
// - bug fix: восстановлена работа множественного выделения, отъехавшая в связи с переходом на интерфейсы.
//
// Revision 1.387.2.26  2005/06/02 12:33:07  lulin
// - вчерне заменил прямое создание блока выделения на его получение от фабрики.
//
// Revision 1.387.2.25  2005/06/01 14:34:41  lulin
// - new unit: evLocation.
//
// Revision 1.387.2.24  2005/06/01 14:02:17  lulin
// - new unit: evCursor.
//
// Revision 1.387.2.23  2005/05/31 12:13:06  lulin
// - cleanup: при работе с курсорами используем интерфейсы, а не объекты.
//
// Revision 1.387.2.22  2005/05/31 12:06:30  lulin
// - cleanup: при работе с курсорами используем интерфейсы, а не объекты.
//
// Revision 1.387.2.21  2005/05/30 16:51:27  lulin
// - cleanup.
//
// Revision 1.387.2.20  2005/05/30 13:37:21  fireton
// - bug fix: при превью фрагмента не передавалось полное имя документа
//
// Revision 1.387.2.19  2005/05/27 14:42:21  lulin
// - базовый контрол переехал в быблиотеку L3.
//
// Revision 1.387.2.18  2005/05/27 12:05:56  lulin
// - убраны лишние зависимости.
//
// Revision 1.387.2.17  2005/05/26 16:29:54  lulin
// - директивы, настраивающие канву вывода перемещены в библиотеку L3.
//
// Revision 1.387.2.16  2005/05/26 16:09:32  lulin
// - избавил базовую канву вывода от знания об интерфейсах Эвереста.
//
// Revision 1.387.2.15  2005/05/26 13:19:28  lulin
// - new unit: _l3ScreenIC.
//
// Revision 1.387.2.14  2005/05/24 12:48:14  lulin
// - для канвы используем интерфейс, а не объект.
//
// Revision 1.387.2.13  2005/05/23 14:16:43  lulin
// - new method: TevStyleInterface._MakeList.
//
// Revision 1.387.2.12  2005/05/23 14:04:02  lulin
// - cleanup.
//
// Revision 1.387.2.11  2005/05/23 13:33:20  lulin
// - cleanup.
//
// Revision 1.387.2.10  2005/05/23 12:23:55  lulin
// - bug fix: были AV при получении шрифта.
//
// Revision 1.387.2.9  2005/05/20 16:33:26  lulin
// - bug fix: был AV.
//
// Revision 1.387.2.8  2005/05/20 16:30:14  lulin
// - развязал интерфейс и реализацию шрифта выделения.
//
// Revision 1.387.2.7  2005/05/20 14:58:38  lulin
// - new unit: evStyleInterface.
//
// Revision 1.387.2.6  2005/05/20 14:53:10  dinishev
// Bug fix: Selection.WasAssigned могла влиять как на Y, так и на X
//
// Revision 1.387.2.5  2005/05/20 11:27:35  lulin
// - класс TevBlock вынесен в отдельный модуль.
//
// Revision 1.387.2.4  2005/05/19 15:49:25  lulin
// - класс _TevCustomFont выделен в отдельный модуль.
//
// Revision 1.387.2.3  2005/05/19 12:31:10  lulin
// - получение шрифта у блока и у курсора приведено к единому знаменателю.
//
// Revision 1.387.2.2  2005/05/18 13:26:06  lulin
// - bug fix: был Range Check при открытии документа.
//
// Revision 1.387.2.1  2005/05/18 12:42:46  lulin
// - отвел новую ветку.
//
// Revision 1.346.2.46  2005/05/18 12:32:08  lulin
// - очередной раз объединил ветку с HEAD.
//
// Revision 1.346.2.45  2005/04/28 09:18:28  lulin
// - объединил с веткой B_Tag_Box.
//
// Revision 1.346.2.44  2005/04/19 12:23:01  lulin
// - cleanup: спрятаны ненужные методы.
//
// Revision 1.346.2.43  2005/04/19 07:24:22  lulin
// - небольшая оптимизация.
//
// Revision 1.346.2.42  2005/04/14 17:30:46  lulin
// - cleanup.
//
// Revision 1.346.2.41  2005/04/14 16:15:39  lulin
// - вычищен код, связанный с отрисовкой по абсолютным координатам.
//
// Revision 1.346.2.40  2005/04/14 15:14:30  lulin
// - сделана специальная процедура мещения якоря "по строкам".
//
// Revision 1.346.2.39  2005/04/14 10:30:12  lulin
// - сделана возможность привязывать каретку к View.
//
// Revision 1.346.2.38  2005/04/14 10:13:47  lulin
// - new interfaces: InevSelectionView, InevInputView.
//
// Revision 1.346.2.37  2005/04/14 08:40:21  lulin
// - new define: evMapBottomRightToView.
//
// Revision 1.346.2.36  2005/04/14 08:36:10  lulin
// - new define: evMapKeysToView (пока в целях отладки отключен).
//
// Revision 1.346.2.35  2005/04/14 08:22:24  lulin
// - new behavior: теперь методы VScrollPrim и HScrollPrim работают через View.
//
// Revision 1.346.2.34  2005/04/13 11:40:05  lulin
// - ненужные методы убраны под Define.
//
// Revision 1.346.2.33  2005/04/13 10:30:01  lulin
// - new behavior: используем Top от View.
//
// Revision 1.346.2.32  2005/04/13 07:57:12  lulin
// - cleanup.
//
// Revision 1.346.2.31  2005/04/13 07:33:32  lulin
// - cleanup.
//
// Revision 1.346.2.30  2005/04/12 15:45:36  lulin
// - мусор связанный с удержанием Top окна при переформатировании, спрятан под Define.
//
// Revision 1.346.2.29  2005/04/12 13:47:27  lulin
// - убрано использование хитрой точки для рисования.
//
// Revision 1.346.2.28  2005/04/12 08:23:00  lulin
// - горизонтальный скроллер также переключен на View.
//
// Revision 1.346.2.27  2005/04/12 07:58:08  lulin
// - new behavior: созвращена возможность таскать скроллер (на больших документах пока выглядит ужасно).
//
// Revision 1.346.2.26  2005/04/12 06:29:00  lulin
// - убрана догрузка документа при смене Top (пердполагается перенести ее уже на отрисовку недогруженных параграфов).
//
// Revision 1.346.2.25  2005/04/11 18:57:04  lulin
// - cleanup: используем свойство, а не поле объекта.
//
// Revision 1.346.2.24  2005/04/11 18:53:45  lulin
// - new interface: InevCaret.
//
// Revision 1.346.2.23  2005/04/11 17:53:22  lulin
// - new behavior: поддержка колеса мыши и синхронизация со скроллером собственно окна.
//
// Revision 1.346.2.22  2005/04/11 17:37:13  lulin
// - примитивная реализация скроллера, стоящего отдельно от собственно окна редактирования.
//
// Revision 1.346.2.21  2005/04/11 16:52:28  lulin
// - new interface: InevScroller.
//
// Revision 1.346.2.20  2005/04/11 16:31:34  lulin
// - new methods: IevScrollView.LinkShape, UnlinkShape.
//
// Revision 1.346.2.19  2005/04/11 16:06:15  lulin
// - new type: TnevFrame.
//
// Revision 1.346.2.18  2005/04/11 15:25:45  lulin
// - new interface: IevScrollView.
//
// Revision 1.346.2.17  2005/04/11 14:51:16  lulin
// - удален устаревший интерфейс.
//
// Revision 1.346.2.16  2005/04/11 14:04:04  lulin
// - слил с HEAD.
//
// Revision 1.346.2.15  2005/04/11 13:53:13  lulin
// - new prop: InevViewMetrics.ShowDocumentParts.
//
// Revision 1.346.2.14  2005/04/11 13:00:16  lulin
// - используем другой тип для определения начала координат.
//
// Revision 1.346.2.13  2005/04/11 11:24:49  lulin
// - new interface: InevViewMetrics.
//
// Revision 1.346.2.12  2005/04/11 10:08:47  lulin
// - спрятан мусор, связанный с тем, что TextSource хранил максимальную ширину форматирования.
//
// Revision 1.346.2.11  2005/04/10 15:20:03  lulin
// - new unit: nevDocument.
//
// Revision 1.346.2.10  2005/04/10 14:49:40  lulin
// - если не _WebStyle, то берем для скроллера ширину документа, а не View.
//
// Revision 1.346.2.9  2005/04/10 14:45:05  lulin
// - new behavior: берем размеры для скроллера непосредственно у документа, а не у TextSource.
//
// Revision 1.346.2.8  2005/04/10 10:58:00  lulin
// - bug fix: посли слияния с HEAD не компилировалось.
//
// Revision 1.346.2.7  2005/04/10 10:39:42  lulin
// - слил с HEAD.
//
// Revision 1.346.2.6  2005/04/09 14:20:32  lulin
// - new interfaces: InevView, InevControl, _InevLinkedShape.
//
// Revision 1.346.2.5  2005/04/09 10:34:30  lulin
// - убраны лишние зависимости между модулями различных слоев.
//
// Revision 1.346.2.4  2005/04/08 18:10:36  lulin
// - первый эксперимент с отключением форматирования всего документа. Не впечатляет, но определенные успехи есть.
//
// Revision 1.346.2.3  2005/04/08 13:35:04  lulin
// - _Processor стал обязательным параметром.
//
// Revision 1.346.2.2  2005/04/08 07:50:40  lulin
// - bug fix: с клавиатуры не вставлялся разрыв страницы.
//
// Revision 1.346.2.1  2005/04/08 07:29:14  lulin
// - для рисования документа напрямую используем InevParaList от курсора редактора.
//
// Revision 1.348  2005/04/09 15:06:55  dinishev
// if Locked {or not Showing} then закомменировал, т.е. вернул все как было, но с возможностью возврата (нужно удалить and Showing), т.к. разници никакой.
//
// Revision 1.347  2005/04/09 13:37:19  dinishev
// Резирвируем справа поле, равное ширине сплиттера, чтобы не было повторных переформатирований.
//
// Revision 1.349  2005/04/11 13:46:28  dinishev
// Bug fix: нельзя было увидеть компонент в Delphi, происходило AV
// Revision 1.361.2.12  2005/04/27 13:58:40  lulin
// - new behavior: в Архивариусе фильтруем вложенные документы при вставке из буфера обмена.
//
// Revision 1.361.2.11  2005/04/27 13:18:48  lulin
// - new behavior: разрешена дозагрузка текста ВНУТРИ основной загрузки текста (убрал проверку).
//
// Revision 1.361.2.10  2005/04/27 12:22:49  lulin
// - bug fix: автореферат не переформатировался по целой ширине окна (CQ OIT5-13485).
//
// Revision 1.361.2.9  2005/04/27 10:22:23  lulin
// - удалена заплатка с дозагрузкой параграфов на которые сместились.
//
// Revision 1.361.2.8  2005/04/27 09:53:40  lulin
// - new behavior: догружаем недогруженные параграфы в процессе их отрисовки.
//
// Revision 1.361.2.7  2005/04/27 09:13:54  fireton
// - merge с HEAD
//
// Revision 1.361.2.6  2005/04/27 08:32:04  mmorozov
// bugfix: при установке TestSource в случае если компонент находится в состоянии разрушения, то присваиваем значение полю f_TextSource и выходим, иначе в некоторых случаях имели AV (стек вызовов отсутствовал);
//
// Revision 1.361.2.5  2005/04/26 08:41:37  lulin
// - bug fix: не изменялось выравнивание текста.
//
// Revision 1.361.2.4  2005/04/25 13:54:25  dinishev
// Bug fix: пропадание выделения
//
// Revision 1.361.2.3  2005/04/25 09:03:33  lulin
// - объединил с HEAD.
//
// Revision 1.361.2.2  2005/04/23 16:07:24  lulin
// - удален временный интерфейс Ik2TagBox.
//
// Revision 1.361.2.1  2005/04/21 14:46:54  lulin
// - избавляемся от обертки над тегами - теперь объекты посредством шаблонов сами реализуют интерфейс _Ik2Tag.
//
// Revision 1.361  2005/04/20 14:19:44  lulin
// - убираем прямое обращение к тегу.
//
// Revision 1.360  2005/04/19 15:41:27  lulin
// - переходим на "правильный" ProcessMessages.
//
// Revision 1.359  2005/04/19 09:16:23  lulin
// - убран лишний запрос интерфейса.
//
// Revision 1.358  2005/04/19 07:53:40  lulin
// - небольшая оптимизация.
//
// Revision 1.357  2005/04/18 14:22:27  demon
// - new behavior: Добавлены ProcessMessages при форматировании
//
// Revision 1.356  2005/04/18 09:49:29  lulin
// - для Немезиса не крутим ProcessMessages между фреймами форматирования.
//
// Revision 1.355  2005/04/15 11:10:39  lulin
// - не пытаемся запускать процесс форматирования, если параграф на который переходим сформатирован.
//
// Revision 1.354  2005/04/14 11:19:43  demon
// - fix: Добавлена проверка (f_Cursor.Cursor <> nil) для ситуации, когда в историю попал не прогруженный документ
//
// Revision 1.353  2005/04/12 12:40:26  fireton
// - add: добавляем возможность выводить в колонитулах полное название документа
//
// Revision 1.352  2005/04/12 10:41:35  voba
// - bug fix заплатка : В мемо поле висло когда текст чуть-чуть выходил за границы экрана.
//
// Revision 1.351  2005/04/12 09:28:33  dinishev
// Исправление ошибки с зависанием оболочки при появлении в полях-насделниках скроллера
//
// Revision 1.350  2005/04/11 14:25:04  demon
// - fix: заплатка : после обновления, если на экране был автореферат, в _DoDrawSub получался Sub = nil
//
// Revision 1.349  2005/04/11 13:46:28  dinishev
// Bug fix: нельзя было увидеть компонент в Delphi, происходило AV
//
// Revision 1.348  2005/04/09 15:06:55  dinishev
// if Locked {or not Showing} then закомменировал, т.е. вернул все как было, но с возможностью возврата (нужно удалить and Showing), т.к. разници никакой.
//
// Revision 1.347  2005/04/09 13:37:19  dinishev
// Резирвируем справа поле, равное ширине сплиттера, чтобы не было повторных переформатирований.
//
// Revision 1.387  2005/05/17 14:17:34  lulin
// - уменьшен правый отступ.
//
// Revision 1.386  2005/05/17 11:46:20  lulin
// - убран "лишний" метод.
//
// Revision 1.385  2005/05/17 11:19:24  lulin
// - cleanup: возвращаем более общий интерфейс.
//
// Revision 1.384  2005/05/17 09:55:42  lulin
// - cleanup.
//
// Revision 1.383  2005/05/17 09:27:33  lulin
// - new unit: _evResultFont.
//
// Revision 1.382  2005/05/16 16:26:36  lulin
// - реструктурированы интерфейсы.
//
// Revision 1.381  2005/05/16 15:31:11  lulin
// - cleanup: прямое использование объекта заменено на использование интерфейса.
//
// Revision 1.380  2005/05/16 11:42:09  lulin
// - cleanup: прямое использование объекта заменено на использование интерфейса.
//
// Revision 1.379  2005/05/13 17:29:47  lulin
// - new behavior: теперь стиль вычисляется на основе мультивыделения.
//
// Revision 1.378  2005/05/13 17:15:21  lulin
// - new behavior: теперь шрифт вычисляется на основе мультивыделения - должно помочь с проблемой долгого выделения (CQ OIT5-13320).
//
// Revision 1.377  2005/05/13 15:29:18  lulin
// - cleanup.
//
// Revision 1.376  2005/05/13 15:22:10  lulin
// - cleanup.
//
// Revision 1.375  2005/05/13 15:13:12  lulin
// - bug fix: лишний раз удаляли курсор - из-за этого был AV (CQ OIT5-13796).
//
// Revision 1.374  2005/05/13 14:03:45  lulin
// - cleanup.
//
// Revision 1.373  2005/05/13 13:56:54  lulin
// - new behavior: не "умничаем" с флагом _WebStyle.
//
// Revision 1.372  2005/05/13 13:49:57  lulin
// - new behavior: форматируем неформатированные параграфы при отрисовке - в результате этого починилась отрисовка после поиска (CQ OIT5-13427).
//
// Revision 1.371  2005/05/12 17:06:33  lulin
// - удален ненужный модуль.
//
// Revision 1.370  2005/05/12 13:45:16  lulin
// - удалено ненужное свойство RecalcMode.
//
// Revision 1.369  2005/05/12 12:22:50  lulin
// - bug fix: неправильно выливались отступы документа в RTF.
//
// Revision 1.368  2005/05/12 11:22:36  lulin
// - уменьшено количество телодвижений при вычислении максимальной ширины параграфа.
// - Memo наконец переведено на стандартный механизм форматирования по ширине.
//
// Revision 1.367  2005/05/12 09:30:32  fireton
// - bug fix: если курсор находится на экране, то определяем текущую страницу по нему, а не по верхней границе текста
//
// Revision 1.366  2005/05/03 09:48:26  demon
// - fix: AV при открытии TextForm в design-time
//
// Revision 1.365  2005/04/28 15:03:37  lulin
// - переложил ветку B_Tag_Box в HEAD.
//
// Revision 1.364  2005/04/27 08:56:43  fireton
// - bug fix: вызывалась ненужная прокрутка текста в документе
//
// Revision 1.363  2005/04/26 06:55:56  dinishev
// Merge с веткой
//
// Revision 1.362  2005/04/22 13:27:36  dinishev
// new event: f_OnHistory
//
// Revision 1.361.2.13  2005/04/28 10:27:17  lulin
// - bug fix: AV при переходе по ссылке из комментария.
//
// Revision 1.361.2.12  2005/04/27 13:58:40  lulin
// - new behavior: в Архивариусе фильтруем вложенные документы при вставке из буфера обмена.
//
// Revision 1.361.2.11  2005/04/27 13:18:48  lulin
// - new behavior: разрешена дозагрузка текста ВНУТРИ основной загрузки текста (убрал проверку).
//
// Revision 1.361.2.10  2005/04/27 12:22:49  lulin
// - bug fix: автореферат не переформатировался по целой ширине окна (CQ OIT5-13485).
//
// Revision 1.361.2.9  2005/04/27 10:22:23  lulin
// - удалена заплатка с дозагрузкой параграфов на которые сместились.
//
// Revision 1.361.2.8  2005/04/27 09:53:40  lulin
// - new behavior: догружаем недогруженные параграфы в процессе их отрисовки.
//
// Revision 1.361.2.7  2005/04/27 09:13:54  fireton
// - merge с HEAD
//
// Revision 1.361.2.6  2005/04/27 08:32:04  mmorozov
// bugfix: при установке TestSource в случае если компонент находится в состоянии разрушения, то присваиваем значение полю f_TextSource и выходим, иначе в некоторых случаях имели AV (стек вызовов отсутствовал);
//
// Revision 1.361.2.5  2005/04/26 08:41:37  lulin
// - bug fix: не изменялось выравнивание текста.
//
// Revision 1.361.2.4  2005/04/25 13:54:25  dinishev
// Bug fix: пропадание выделения
//
// Revision 1.361.2.3  2005/04/25 09:03:33  lulin
// - объединил с HEAD.
//
// Revision 1.361.2.2  2005/04/23 16:07:24  lulin
// - удален временный интерфейс Ik2TagBox.
//
// Revision 1.361.2.1  2005/04/21 14:46:54  lulin
// - избавляемся от обертки над тегами - теперь объекты посредством шаблонов сами реализуют интерфейс _Ik2Tag.
//
// Revision 1.361  2005/04/20 14:19:44  lulin
// - убираем прямое обращение к тегу.
//
// Revision 1.360  2005/04/19 15:41:27  lulin
// - переходим на "правильный" ProcessMessages.
//
// Revision 1.359  2005/04/19 09:16:23  lulin
// - убран лишний запрос интерфейса.
//
// Revision 1.358  2005/04/19 07:53:40  lulin
// - небольшая оптимизация.
//
// Revision 1.357  2005/04/18 14:22:27  demon
// - new behavior: Добавлены ProcessMessages при форматировании
//
// Revision 1.356  2005/04/18 09:49:29  lulin
// - для Немезиса не крутим ProcessMessages между фреймами форматирования.
//
// Revision 1.355  2005/04/15 11:10:39  lulin
// - не пытаемся запускать процесс форматирования, если параграф на который переходим сформатирован.
//
// Revision 1.354  2005/04/14 11:19:43  demon
// - fix: Добавлена проверка (f_Cursor.Cursor <> nil) для ситуации, когда в историю попал не прогруженный документ
//
// Revision 1.353  2005/04/12 12:40:26  fireton
// - add: добавляем возможность выводить в колонитулах полное название документа
//
// Revision 1.352  2005/04/12 10:41:35  voba
// - bug fix заплатка : В мемо поле висло когда текст чуть-чуть выходил за границы экрана.
//
// Revision 1.351  2005/04/12 09:28:33  dinishev
// Исправление ошибки с зависанием оболочки при появлении в полях-насделниках скроллера
//
// Revision 1.350  2005/04/11 14:25:04  demon
// - fix: заплатка : после обновления, если на экране был автореферат, в _DoDrawSub получался Sub = nil
//
// Revision 1.349  2005/04/11 13:46:28  dinishev
// Bug fix: нельзя было увидеть компонент в Delphi, происходило AV
//
// Revision 1.348  2005/04/09 15:06:55  dinishev
// if Locked {or not Showing} then закомменировал, т.е. вернул все как было, но с возможностью возврата (нужно удалить and Showing), т.к. разници никакой.
//
// Revision 1.347  2005/04/09 13:37:19  dinishev
// Резирвируем справа поле, равное ширине сплиттера, чтобы не было повторных переформатирований.
//
// Revision 1.346  2005/04/07 10:27:45  lulin
// - убрана неправильная проверка на необходимость перерисовки редактора при смене фокуса.
//
// Revision 1.345  2005/04/05 09:55:26  lulin
// - используем IevShape.
//
// Revision 1.344  2005/04/04 06:43:57  lulin
// - в связи с появлением механизма событий и фасада библиотеки K-2, удалены глобальные "заплатки" связанные с созданием/уничтожением таблицы тегов.
//
// Revision 1.343  2005/03/30 16:50:08  lulin
// - в процедуре печати/отрисовки убран ненужный параметр (aBottomCursor).
//
// Revision 1.342  2005/03/30 16:44:50  lulin
// - TextSource теперь не отвечает за рисование документа - как это и должно быть.
//
// Revision 1.341  2005/03/30 16:38:07  lulin
// - убран ненужный параметр.
//
// Revision 1.340  2005/03/30 10:35:35  lulin
// - bug fix: текст документа показывался не с Sub'а, а с начала (CQ OIT5-13062).
//
// Revision 1.339  2005/03/29 17:36:25  lulin
// - new behavior: не грузим документ при первой прорисовке.
//
// Revision 1.338  2005/03/28 11:32:07  lulin
// - интерфейсы переехали в "правильный" модуль.
//
// Revision 1.337  2005/03/25 17:09:01  lulin
// - избавляемся от метода Tk2AtomW.sLong.
//
// Revision 1.336  2005/03/25 12:12:14  lulin
// - используем _Ik2Type вместо Tk2Type.
//
// Revision 1.335  2005/03/24 12:08:12  lulin
// - remove method: Ik2TagBox._Tag.
// - new method: Ik2TagBox._Target.
//
// Revision 1.334  2005/03/23 17:38:21  lulin
// - исправлен тип.
//
// Revision 1.333  2005/03/23 17:28:00  lulin
// - свойство _TevSelection.Document стало _Ik2Tag.
//
// Revision 1.332  2005/03/23 16:34:07  lulin
// - свойство TextSource.Document стало _Ik2Tag.
//
// Revision 1.331  2005/03/23 11:16:29  lulin
// - удалено ненужное исключение.
//
// Revision 1.330  2005/03/22 17:03:04  lulin
// - спрятаны ненужные методы. Чуть подоптимизирована загрузка - ГК в Эвересте на 1 сек меньше.
//
// Revision 1.329  2005/03/22 14:30:09  lulin
// - new method: _Ik2TypeTable._IUnknownToTag.
//
// Revision 1.328  2005/03/22 12:42:16  lulin
// - bug fix: установка стиля убивала гиперссылки.
//
// Revision 1.327  2005/03/21 13:42:58  lulin
// - убраны ненужные методы.
//
// Revision 1.326  2005/03/21 10:04:49  lulin
// - new interface: _Ik2Type.
//
// Revision 1.325  2005/03/19 16:39:51  lulin
// - спрятаны ненужные методы.
//
// Revision 1.324  2005/03/17 17:57:02  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.323  2005/03/17 16:44:32  lulin
// - при вставке из буфера обмена разрешаем вставку вложенных документов.
//
// Revision 1.322  2005/03/16 19:21:53  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.321  2005/03/16 17:04:21  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.320  2005/03/16 13:40:00  fireton
// - bug fix: не сохраняем выделение пользователя, если ищем не в блоке
//
// Revision 1.319  2005/03/16 12:16:52  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.318  2005/03/16 10:20:24  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.317  2005/03/15 11:18:18  lulin
// - cleanup.
//
// Revision 1.316  2005/03/14 15:08:51  lulin
// - new behavior: не сбрасываем результат поиска по ShortCut'у.
//
// Revision 1.315  2005/03/11 17:28:08  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.314  2005/03/10 14:58:38  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.313  2005/03/09 18:40:19  lulin
// - remove method: Tk2AtomR.DeleteChild.
// - new method: _Ik2Tag.DeleteChild.
//
// Revision 1.312  2005/03/04 10:10:53  lulin
// - bug fix: при возврате по истории попадали в начало документа, а не в то место с которого уходили (CQ OIT5-12496).
//
// Revision 1.311  2005/03/02 10:10:26  lulin
// - bug fix: при скроллировании "внутри" отрисовки бывали случаи, когда окно не перерисовывалось с актуальным Top.
//
// Revision 1.310  2005/02/25 07:10:10  dinishev
// no message
//
// Revision 1.309  2005/02/24 13:04:52  lulin
// - переходим от объектов к интерфейсам.
//
// Revision 1.308  2005/02/22 12:27:39  lulin
// - рефакторинг работы с Tl3Point и Tl3Rect.
//
// Revision 1.307  2005/02/21 14:02:22  lulin
// - bug fix: не прогружался текст Конституции при смещении вниз (CQ OIT5-12430).
//
// Revision 1.306  2005/02/17 12:56:56  lulin
// - проверка рекурсии перенесена в более правильное место - т.е. даем догружать документ, если место закгрузки ниже текущего края экрана.
//
// Revision 1.305  2005/02/17 12:18:11  lulin
// - bug fix: в случае позиционирования на закладку при прогрузке документа, которая возникала рекурсивно в итоге закрадка оказывалась в середине экрана (в частности OIT5-12250).
//
// Revision 1.304  2005/02/16 15:54:55  lulin
// - bug fix: при догрузке документа и переходе на закладку - закладка теперь хоть попадает на экран. Завтра надо добить, чтобы она всегда показывалась сверху экрана.
//
// Revision 1.303  2005/02/16 15:31:34  lulin
// - поборолся с пустым экраном документа 10035750 (CQ OIT5-12250). Осталось добить, чтобы позиционировалось правильно на закладку.
//
// Revision 1.302  2005/02/16 12:25:18  lulin
// - bug fix: при догрузке документа не всегда правильно позиционировались на метки/закладки (CQ OIT5-12365).
//
// Revision 1.301  2005/02/14 17:32:03  lulin
// - bug fix: сообщаем линейкам и панели Sub'ов о скроллировании редактора в более правильном месте.
//
// Revision 1.300  2005/02/14 16:59:45  lulin
// - new behavior: для Эвереста и Архивариуса не умничаем с горизонтальным скроллером.
//
// Revision 1.299  2005/02/14 16:47:03  lulin
// - new behavior: контроллируем, чтобы скроллирование по горизонтали не выходило в отрицательную область (если размер документа меньше размера окна).
//
// Revision 1.298  2005/02/04 14:33:43  lulin
// - new behavior: закладкам пользователя ставим флаг 3.
// - из Drag'n'drop возвращаем Effect.
//
// Revision 1.297  2005/02/03 16:52:45  lulin
// - new behavior: получше отрисовываем документ в процессе загрузки форматирования из кеша.
//
// Revision 1.296  2005/02/03 11:37:26  lulin
// - new behavior: при загрузке форматирования из кеша крутим ProcessMessages - чтобы документ побыстрее отрисовывался.
//
// Revision 1.295  2005/02/03 10:46:26  lulin
// - убрал отложенную прогрузку документа - чтобы снять проблемы с непрогрузкой и большим правым полем.
//
// Revision 1.294  2005/02/02 18:36:29  lulin
// - bug fix: после поиска восстанавливаем ТОЛЬКО блок, но не курсор.
//
// Revision 1.293  2005/02/02 14:47:03  lulin
// - new behavior: сохраняем/восстанавливаем выделение при поиске.
//
// Revision 1.292  2005/02/02 12:28:13  lulin
// - bug fix: в синхронном просмотре опять не всегда зачитывались документы - при быстром и бездумном хождении по списку.
//
// Revision 1.291  2005/01/31 15:18:45  lulin
// - bug fix: из буфера обмена не вставлялся пользовательский комментарий если курсор стоял на параграфе без ID.
//
// Revision 1.290  2005/01/31 11:47:45  lulin
// - убран ненужный код.
//
// Revision 1.289  2005/01/28 15:34:59  lulin
// - bug fix: был нарушен баланс между временем жизни HotSpot'а и редактора - соответственно не убивалась мертвая ссылка на редактор и был AV.
//
// Revision 1.288  2005/01/28 12:35:21  lulin
// - bug fix: не всегда включался и не всегда выключался горизонтальный скроллер (в частности CQ OIT5-10927).
//
// Revision 1.287  2005/01/27 16:45:27  lulin
// - optimization: меньше переформатируем документ за счет более поздней прогрузки текста.
//
// Revision 1.286  2005/01/27 09:39:00  lulin
// - new behavior: не даем скроллировать по горизонтали дальше текста документа.
//
// Revision 1.285  2005/01/25 09:50:57  lulin
// - bug fix: "двоила" клавиша Ins.
//
// Revision 1.284  2005/01/24 16:11:22  lulin
// - bug fix: не скроллировались на Sub при загрузке документа, если Sub был на экране.
//
// Revision 1.283  2005/01/19 13:45:22  lulin
// - bug fix: в закрытом синхронном просмотре прогружались документы.
//
// Revision 1.282  2005/01/19 12:57:42  dinishev
// В TevEditorWindowHotSpot._TranslatePt  значение ClickCursor могло быть равно nil (OIT500011533)
//
// Revision 1.281  2005/01/19 12:34:13  lulin
// - new behavior: для _ReadOnly-редакторов не публикуем операции редактирования.
//
// Revision 1.280  2005/01/19 12:10:06  lulin
// - bug fix: не присваивалось IsStaticText в отсутствии TextSource.
//
// Revision 1.279  2005/01/19 11:41:31  lulin
// - bug fix: не присваивалось IsStaticText в отсутствии TextSource.
//
// Revision 1.278  2005/01/17 14:40:04  lulin
// - new behavior: теперь _preview показывает ту страницу, которую видел пользователь (CQ OIT5-10919).
//
// Revision 1.277  2005/01/14 17:24:14  lulin
// - в _ProcessCommand добавлен параметр aForce - сигнализирующий, что такого ShortCut'а нету в VCM и что не надо умничать с обработкой комманды.
//
// Revision 1.276  2005/01/14 13:44:44  lulin
// - вернул возможность не печатать отключенные комментарии.
//
// Revision 1.275  2005/01/13 16:23:42  voba
// - add defAutoHideSelection
//
// Revision 1.274  2005/01/12 14:01:11  lulin
// - new methods: _Tafw.BeginOp/EndOp.
//
// Revision 1.273  2005/01/11 16:39:01  dinishev
// Обработка движения мыши над контролом.
//
// Revision 1.272  2005/01/11 09:29:26  lulin
// - bug fix: в Архивариусе при печати были неправильные колонтитулы.
//
// Revision 1.271  2004/12/30 11:46:24  lulin
// - интерфейсы относящиеся к _Preview переехали в библиотеку AFW.
//
// Revision 1.270  2004/12/29 16:36:12  lulin
// - remove prop: TevCustomEditor.HAFPainter.
//
// Revision 1.269  2004/12/29 14:44:04  lulin
// - с TextSource убрана печать.
//
// Revision 1.268  2004/12/29 14:04:29  lulin
// - evGraph и _Preview полностью переведены с класса TPrinter на интерфейс _Il3Printer.
//                                          
// Revision 1.267  2004/12/29 11:51:20  lulin
// - построение _Preview практически полность перенесено из _Nemesis'а в Everest.
//
// Revision 1.266  2004/12/29 11:22:36  dinishev
// Обработка события перетаскивания окон и изменения их разамера - раньше выпадающие дерево и календарь
// не прятались.
//
// Revision 1.265  2004/12/28 16:42:37  lulin
// - TevEditorWindowTextSourceDocumentContainer теперь умеет создавать _Preview.
//
// Revision 1.264  2004/12/28 15:51:59  dinishev
// рисование иконок переведено на TCustomImageList, чтобы можно было использовать и TPngImageList из vt,
// исправление - если контрол находился в таблице, то не выпадающий список нельзя было спрятать с помощью мыши,
//
// Revision 1.263  2004/12/27 16:42:16  dinishev
// Более безопасный вызов выпадающих деревьев и календарей
//
// Revision 1.262  2004/12/27 11:24:10  lulin
// - bug fix: защитил от AV в обработчике нажатия клавиш (CQ OIT5-11339).
//
// Revision 1.261  2004/12/22 14:25:37  lulin
// - bug fix: AV и Cannot convert Null to Long при Double Click в списке с синхронным просмотром.
//
// Revision 1.260  2004/12/22 13:36:21  lulin
// - вычищены ненужные параметры и ненужный интерфейс.
//
// Revision 1.259  2004/12/17 15:35:37  lulin
// - bug fix: при множественном выделении не работал Drag'n'drop.
//
// Revision 1.258  2004/12/17 14:27:29  demon
// - new behavior: метод _DoDrop получил новый параметр var dwEffect: Longint, теперь его может поменять приемник (TargetObject)
//
// Revision 1.257  2004/12/15 16:28:18  dinishev
// подправлена функция пересчета координат
//
// Revision 1.256  2004/12/11 14:40:22  lulin
// - в нулевом приближении прикрутил свой Print-_preview взамен Никитинского.
//
// Revision 1.255  2004/12/10 18:52:56  lulin
// - дозагрузка документа переехала с TextSource на DocumentContainer.
//
// Revision 1.254  2004/12/10 17:28:53  dinishev
// исправление ошибок при выпадении: неправильные координаты в таблице, AV при щелчке правой кнопкой мыши, обработка прокрутки.
//
// Revision 1.253  2004/12/08 15:26:49  dinishev
// убран AV при закрытии редактора после вызова календаря,
// доделана реакция календаря на клавиатуру,
// передача данных из/в календарь,
// устранены ряд ошибок в выпадающем дереве,
// связанных с объединением логики с календарем (некорректное закрытие по ESC, появление дублирующего окна при открытии)
//
// Revision 1.252  2004/12/08 13:20:10  lulin
// - указываем число повторов символа.
//
// Revision 1.251  2004/12/07 14:41:46  dinishev
// новый компонент ev_ctCalEdit - ComboBox с выпадающим календарем.
// доделано объединение выпадающих деревьев.
// новые интерфейсы IDropBase - базовый интерфейс для выпадающих
// компонент и IDropCalendar - интерфейс для календаря.
//
// Revision 1.250  2004/12/02 15:55:31  lulin
// - bug fix: терялись события мыши.
//
// Revision 1.249  2004/12/02 15:04:15  lulin
// - не скроллируем текст.
//
// Revision 1.248  2004/12/02 12:57:58  lulin
// - new behavior: для Немезиса комментарии сворачиваются/разворачивабтся и выделяются по одинарному щелчку, а не по двойному.
//
// Revision 1.247  2004/12/01 14:50:33  dinishev
// Реакция на изменение параграфа, подправлено изменение состояния кнопки ComboBox'а.
//
// Revision 1.246  2004/11/30 17:51:35  dinishev
// Реализация выпадающего дерева для CombobBox'а. Некоторые исправления отображения.
//
// Revision 1.245  2004/11/30 16:48:15  lulin
// - bug fix: AV при смене контента редактора (CQ OIT5-11025).
//
// Revision 1.244  2004/11/30 16:33:29  lulin
// - bug fix: не появлялся скроллер при увеличении шрифта (CQ OIT5-11025).
//
// Revision 1.243  2004/11/30 11:31:59  lulin
// - bug fix: не отрисовывалось начало документа - т.к. не скроллировались на заказанный параграф (CQ OIT5-10982).
//
// Revision 1.242  2004/11/29 15:28:26  lulin
// - bug fix: не обрабатывали значение Default у ForeColor.
//
// Revision 1.241  2004/11/25 13:22:01  lulin
// - используем в TeeEditorExport._GetHotspotOnPoint вызов _TevCustomEditorWindow._GetHotspotOnPoint.
//
// Revision 1.240  2004/11/25 12:44:56  lulin
// - new method: _TevCustomEditorWindow._GetHotspotOnPoint.
// - избавился от дублирования кода.
//
// Revision 1.239  2004/11/24 16:51:31  lulin
// - bug fix: не всегда картинки правильно забирались в буфер обмена.
//
// Revision 1.238  2004/11/19 16:33:00  lulin
// - bug fix: съедались двухбуквенные ShortCut'ы.
//
// Revision 1.237  2004/11/19 13:54:40  lulin
// - bug fix: не всегда работал переход по ссылке - когда в переходных процессах высота окна была нулевая.
//
// Revision 1.236  2004/11/18 08:47:30  lulin
// - new interface: IevWindowEx.
//
// Revision 1.235  2004/11/17 10:42:21  lulin
// - new prop: _TevCustomEditorWindow.OnCheckFocusedInPaint.
//
// Revision 1.234  2004/11/16 14:12:50  lulin
// - bug fix: _Hint портил выделение мышью.
//
// Revision 1.233  2004/11/16 12:15:52  lulin
// - new method version: Tl3Control.ActivateHint.
//
// Revision 1.232  2004/11/16 12:11:37  lulin
// - new behavior: обновляем _Hint'ы если изменилось их содержимое.
//
// Revision 1.231  2004/11/13 13:49:27  lulin
// - new behavior: рисуем рамку вокруг текущей кнопки.
//
// Revision 1.230  2004/11/12 17:55:48  lulin
// - поправлена отрисовка параграфов с контролами.
//
// Revision 1.229  2004/11/10 12:44:22  lulin
// - new interface: IevTagShape.
// - remove interface: IevVisualShapedTag.
//
// Revision 1.228  2004/11/10 11:06:07  lulin
// - new interface: IevTagShape.
// - remove interface: IevVisualShapedTag.
//
// Revision 1.227  2004/11/05 17:18:26  lulin
// - bug fix: не падаем, если обрабатываем Message от уже убитого окна (CQ OIT5-10421).
//
// Revision 1.226  2004/11/05 16:51:18  lulin
// - new behavior: при пропадании скроллера, если текст умещается в окно, то показываем текст с начала (CQ OIT5-9150).
//
// Revision 1.225  2004/11/04 15:17:52  am
// откатил изменения с WM_SYSKEYDOWN -> CN_SYSKEYDOWN
//
// Revision 1.224  2004/11/04 10:14:53  am
// bugfix: переводя обработку клавиатурных сообщений с WM_KEYDOWN на CN_KEYDOWN забыли о WM_SYSKEYDOWN.
//
// Revision 1.223  2004/11/03 09:55:12  lulin
// - new behavior: копирование параграфа в буфер обмена в формате CF_Bitmap теперь не завязано на тип параграфа, а использует интерфейс Il3Bitmap - в результате, кроме параграфов idBitmap в буфер обмена стали попадать все парагравы у которых атрибут tiObject поддерживает интерфейс Il3Bitmap, например idFormula.
//
// Revision 1.222  2004/11/02 16:39:17  lulin
// - bug fix: для параграфа с картинкой используем правильный контейнер.
//
// Revision 1.221  2004/10/28 13:54:26  lulin
// - remove type: TevParam.
//
// Revision 1.220  2004/10/21 17:24:16  lulin
// - bug fix: в списке редакций в очередной раз не показывался текст.
//
// Revision 1.219  2004/10/21 11:38:16  lulin
// - метод _UnformatAll "переехал" на TevDocumentContainer.
//
// Revision 1.218  2004/10/19 13:56:46  lulin
// - bug fix: _TevCustomEditorWindow.SkipMessage не учитывал, что Handle окна в цикле может пропасть.
//
// Revision 1.217  2004/10/19 12:00:31  lulin
// - new prop: _TevCustomTextSource.OnChangeHiddenStyles (CQ OIT5-10339).
//
// Revision 1.216  2004/10/19 09:59:56  lulin
// - bug fix: AV при уничтожении окна редактора, когда был успешный контекстный поиск (CQ OIT5-10398).
//
// Revision 1.215  2004/10/15 10:56:40  demon
// - bug fix: из-за ошибки округления во время нажатия на ссылку редактор отматывалтекст к началу.
//
// Revision 1.214  2004/10/14 13:56:45  lulin
// - интерфейс Ik2ChildSpy спущен на TevDocumentContainer - в итоге поправилась ошибка CQ OIT5-10138.
//
// Revision 1.213  2004/10/13 14:02:29  lulin
// - неудачная попытка включить DoubleBuffered - сразу же отключил, т.к. курсор "мажет". Разбираться буду потом.
//
// Revision 1.212  2004/10/12 17:39:33  lulin
// - new param: в метод _TevDocumentsCache.NotifyUserCommentDeleted теперь подается контейнер.
//
// Revision 1.211  2004/10/08 13:40:24  lulin
// - bug fix: при лимите количества параграфов - Enter ломал строку параграфа.
//
// Revision 1.210  2004/10/05 10:14:11  lulin
// - bug fix: после скроллирования текста пропадал курсор (CQ OIT5-9713).
//
// Revision 1.209  2004/10/05 09:22:11  lulin
// - bug fix: был AV при удалении комментария. Да и параграфа вообще. Т.к. курсор жил в кеше, а редактор уже умер, но курсор продолжал "знать" про редактор (CQ OIT5-10066).
//
// Revision 1.208  2004/10/04 15:27:27  lulin
// - откат предыдущего коммита.
//
// Revision 1.206  2004/10/04 10:33:01  lulin
// - bug fix: после поиска контекста окно скроллировалось чуть вверх, скрывая то, что было найдено в последний раз (CQ OIT5-9999).
//
// Revision 1.205  2004/10/01 11:37:15  lulin
// - bug fix: при догрузке документа не всегда правильно работал Back по истории (CQ OIT5-9601).
//
// Revision 1.204  2004/09/29 12:07:34  lulin
// - new behavior: если невозможно напрямую использовать документ из истории, то копируем его содержимое в новый DocumentContainer (не обращаясь к серверу).
//
// Revision 1.203  2004/09/28 15:38:16  lulin
// - свойство _Processor перенесено с _TevCustomTextSource на _TevDocumentContainerWithProcessor (это для возможности кеширования DocumentContainer'ов).
//
// Revision 1.202  2004/09/24 12:33:28  lulin
// - bug fix: не очищался _Owner.
//
// Revision 1.201  2004/09/24 07:53:59  lulin
// - не очищался HotSpot перед положением в кеш.
//
// Revision 1.200  2004/09/22 12:11:14  mmorozov
// bugfix: беззнаковому nPage могли установить значение <0 (SetHScrollRange);
//
// Revision 1.199  2004/09/21 09:59:41  lulin
// - bug fix: не снималось выделение - в результате того, что не очищался объект HotSpot (CQ OIT5-9744).
//
// Revision 1.198  2004/09/20 12:42:49  lulin
// - оптимизация - путем перемещения части объектов в пул, время загрузки ГК (до показа оглавления) уменьшено с 3.5 сек до 2.6 сек.
//
// Revision 1.197  2004/09/16 12:20:49  lulin
// - удалено большинство нечитабельных include'ов.
//
// Revision 1.196  2004/09/16 11:30:50  lulin
// - навел подобие порядка с регистрацией компонент библиотеки.
//
// Revision 1.195  2004/09/16 09:24:59  lulin
// - bug fix: наследники от evCtrl убивались в DesignTime произвольным образом.
//
// Revision 1.194  2004/09/15 16:44:56  lulin
// - в зависимости от DesignTimeLibrary перекрываем Destroy или Cleanup.
//
// Revision 1.193  2004/09/15 16:20:37  lulin
// - bug fix: AllEverestComponents7 не собирался из-за Str_Man'а.
// - bug fix: AllEverestComponents7 не загружался из-за шаблонов.
//
// Revision 1.192  2004/09/10 10:35:17  lulin
// - убрал пока совершенно никому ненужного скроллера.
//
// Revision 1.191  2004/09/09 12:55:13  voba
// - грубо запилил инициализацию LargeChange, которая бывает что вылазит за границы диапазона
//
// Revision 1.190  2004/09/08 09:28:27  lulin
// - bug fix: Esc затирал выделенный текст в редакторе.
//
// Revision 1.189  2004/09/02 13:05:48  law
// - все dynamic методы заменил на _virtual.
//
// Revision 1.188  2004/09/02 08:56:44  law
// - cleanup.
//
// Revision 1.187  2004/09/01 12:27:58  law
// - new behavior: для редактора, для рисования выделения при включенной директиве l3RealPaint используем системные цвета.
//
// Revision 1.186  2004/09/01 11:57:49  law
// - new behavior: редактор по правой кнопке мыши принимает на себя фокус ( CQ OIT5-8707).
//
// Revision 1.185  2004/09/01 10:12:06  law
// - bug fix: конец текста показывали посередине экрана, хотя есть возможность прижать его вниз (CQ OIT5-8954).
//
// Revision 1.184  2004/08/16 15:33:58  law
// - bug fix: не скроллируем окно после его полной перерисовки.
//
// Revision 1.183  2004/08/16 11:36:02  law
// - bug fix: обрана хитрая обработка области отсечения - приводившая к рудиментам отрисовки.
//
// Revision 1.182  2004/08/13 14:27:42  law
// - bug fix: "мусор" при скроллинге вверх и догрузке кусочка (CQ OIT5-8085).
//
// Revision 1.181  2004/08/10 18:01:55  law
// - bug fix: не умничаем со скроллингом при загрузке документа.
//
// Revision 1.180  2004/08/10 15:49:10  law
// - bug fix: при дочитке "начала" экрана, не учитывали, что двигаемся снизу вверх.
//
// Revision 1.179  2004/08/06 11:00:54  law
// - ужесточил проверку на то что пытаемся скроллироваться в несформатированную область ("пустые строки").
//
// Revision 1.178  2004/08/05 12:21:37  law
// - new behavior: если параграф или метка не "приехали", то сбрасываем песочные часы и догружаем первый видимый экран (CQ OIT5-8169).
//
// Revision 1.177  2004/08/05 09:08:41  law
// - change: почему-то _TevCustomEditorWindow.Select - нельзя было попросить выделить один символ.
//
// Revision 1.176  2004/08/04 11:53:02  law
// - bug fix: вычисление позиции курсора не учитывало режима отображения спецсимволов.
//
// Revision 1.175  2004/08/04 10:41:04  law
// - добавлен комментарий.
//
// Revision 1.174  2004/08/04 06:39:32  law
// - new behavior: не фильтруем оглавление если его Root не поменялся.
//
// Revision 1.173  2004/08/03 13:55:47  law
// - bug fix: при позиционировании курсора не учитывали масштаб.
//
// Revision 1.172  2004/07/31 11:27:20  law
// - bug fix: не изменялись размеры курсора при переходе от одного параграфа к другому.
//
// Revision 1.171  2004/07/30 16:54:03  law
// - new behavior: не переходим на начало документа, если ожидается переход на Sub.
//
// Revision 1.170  2004/07/30 16:12:11  law
// - bug fix: не дергаем догрузку начального экрана при ожидании перехода на Sub.
//
// Revision 1.169  2004/07/30 15:22:39  law
// - bug: не показывался текст выше закладки на которую перешли (CQ OIT5-8455.
//
// Revision 1.168  2004/07/30 14:42:45  law
// - new method: _TevCustomEditorWindow.CheckTopUploaded.
//
// Revision 1.167  2004/07/30 13:01:28  demon
// - fix: был AV при быстром переключении редакций
//
// Revision 1.166  2004/07/29 13:50:02  voba
// - bug fix: и с третьего раза не получилось.
//
// Revision 1.165  2004/07/29 13:30:43  voba
// - bug fix: и со второго раза не получилось.
//
// Revision 1.164  2004/07/29 13:18:12  law
// - bug fix: предыдущие исправления были сделаны некорректно.
//
// Revision 1.163  2004/07/29 13:11:18  law
// - new behavior: при НЕ Persistent-выделении когда ищем не в выделении, то ищем не с курсора, а с КОНЦА выделениия.
//
// Revision 1.162  2004/07/29 12:30:09  law
// - optimization: при изменении только ПОЗИЦИИ КУРСОРА не перерисовываем все содержимое окно редактора.
//
// Revision 1.161  2004/07/28 13:12:58  law
// - bug fix: падало при закрытии окна во время форматирования.
//
// Revision 1.160  2004/07/28 12:09:50  law
// - new behavior: если уперлись в начало документа, то догружаем с 0-го Sub'а.
//
// Revision 1.159  2004/07/27 14:53:18  voba
// - bug fix.
//
// Revision 1.158  2004/07/27 14:29:14  law
// - new param: aCheckSub.
//
// Revision 1.157  2004/07/27 13:27:01  law
// - new method version: _TevCustomEditorWindow._GotoTag.
//
// Revision 1.156  2004/07/27 07:58:52  law
// - bug fix: повисание приложения внутри форматирования, когда вдруг пришло сообщение WM_Paint (CQ OIT5-8387).
//
// Revision 1.155  2004/07/26 15:58:45  law
// - bug fix: неправильно позиционировались при включении/выключении комментариев (CQ OIT5-8382).
//
// Revision 1.154  2004/07/21 16:25:59  law
// - Tl3Control.GetCommands теперь стала функцией.
//
// Revision 1.153  2004/07/21 11:58:31  law
// - bug fix: после удаления комментария выделение перемещалось на следующий параграф (CQ OIT5-7190).
//
// Revision 1.152  2004/07/21 11:00:51  law
// - bug fix: переход по ссылке срабатывал даже после выделения текста.
//
// Revision 1.151  2004/07/21 09:46:35  law
// - bug fix: AV при Enter когда документа еще нету (CQ OIT5-7417).
//
// Revision 1.150  2004/07/19 13:37:27  law
// - new behavior: снимаем выделение после вставки текста (CQ OIT5-7748).
//
// Revision 1.149  2004/07/16 15:58:17  law
// - new behavior: сбалансированы скобки ожидания перехода на метку.
//
// Revision 1.148  2004/07/16 12:36:41  law
// - bug fix: неправильно обрабатывали PgUp/PgDn когда курсора не было видно.
//
// Revision 1.147  2004/07/15 16:29:08  law
// - механизм ожидания доступности метки перенесен с генератора на TextSource.
// - к этому же механизму приделано ожидание доступности конца документа.
//
// Revision 1.146  2004/07/15 14:58:18  law
// - new behavior: не разрешаем смещаться в конец документа, который еще не догрузился.
//
// Revision 1.145  2004/07/15 14:14:02  law
// - optimization: быстрее догружаем параграфы при движении снизу вверх.
// - избегаем коллизий между догрузкой, скроллированием, форматированием и отрисовкой.
//
// Revision 1.144  2004/07/14 08:37:34  voba
// - bug fix
//
// Revision 1.143  2004/07/13 16:56:17  law
// - безуспешные попытки исправить пропадание курсора в редакторе.
//
// Revision 1.142  2004/07/13 13:28:05  law
// - bug fix: пустой текст документа (CQ IOT5-6743).
//
// Revision 1.141  2004/07/13 11:43:30  law
// - bug fix: те случаи когда редактор рисовался, там дернул GetDocument отуда приехал AllowGotoSub, оттуда VScrollPrim, а он не отработал - т.к. находимся в режиме рисования, в итоге для кусочной закрузки документов получался пустой текст документа, который приезжал, только когда дернули скроллер (CQ OIT5-8101).
//
// Revision 1.140  2004/07/12 17:21:39  law
// - bug fix: были несбалансированы скобки, что приводило к отсутствию текста документа (и иногда к незакрытию окна) (CQ OIT5-8169).
//
// Revision 1.139  2004/07/08 16:16:09  law
// - bug fix: AV при быстром закрытии документа.
//
// Revision 1.138  2004/07/08 15:46:07  law
// - ускорена вставка/удаление параграфов в длинных документах.
//
// Revision 1.137  2004/07/06 12:46:21  law
// - new behavior: для Немезиса выключена директива evNeedMarkers.
//
// Revision 1.136  2004/07/06 12:08:02  law
// - new behavior: для Немезиса открутил сбор информации о стиле и шрифте.
//
// Revision 1.135  2004/07/01 12:04:54  law
// - bug fix: скроллировались на начало документа после перехода на параграф.
//
// Revision 1.134  2004/06/25 15:32:39  law
// - bug fix: при маленьких документах можно было скроллировать документ за экран.
//
// Revision 1.133  2004/06/25 15:17:23  law
// - bug fix: при Back/Forward по истории неправильно восстанавливалось текущее место документа.
//
// Revision 1.132  2004/06/25 14:52:35  law
// - bug fix: при навигации по ссылкам короткие документы показывались за обрезом экрана.
//
// Revision 1.131  2004/06/25 12:48:38  law
// - new behavior: запрещаем ксроллировать документ ниже его конца.
//
// Revision 1.130  2004/06/23 15:04:12  law
// - придаем окошку с _Hint'ом фиксированную позицию.
//
// Revision 1.129  2004/06/23 14:27:13  law
// - new behavior: при скроллировании выводим _Hint о текущем положении.
//
// Revision 1.128  2004/06/22 15:46:23  law
// - new behavior: догружаем параграфы, при попытке печати, заборе в буфер обмена и т.п.
//
// Revision 1.127  2004/06/22 12:43:49  law
// - new behavior: поиск теперь использует IevTagSelection, а не TevBlock.
//
// Revision 1.126  2004/06/18 13:53:11  law
// - bug fix: "проталкиваем" форматтер при скроллировании после догрузки куска документа.
//
// Revision 1.125  2004/06/18 13:37:53  law
// - не пытаемся скролироваться во время догрузки документа.
//
// Revision 1.124  2004/06/16 17:38:31  law
// - new behavior: при догрузке документа форматируем его не с самого начала, а с начала догруженного куска.
//
// Revision 1.123  2004/06/16 17:04:58  law
// - new behavior: не сообщаем об обновлениях урсоров, не привязанных к окну.
// - класс _TevParaListCursor тепреь поддерживает интерфейс IevTagIndex.
//
// Revision 1.122  2004/06/16 15:17:50  law
// - new behavior: корректнее обновляем параметры скроллера (не внутри WM_Scroll).
// - VScrollPrim - теперь функция - возвращает результат успеха скроллирования.
// - bug fix: если при листании по страницам не удалось соскроллироваться к курсору, то показываем курсор.
// - bug fix: при скроллировании вверх неправильно определяли начало дочитываемого куска.
// - bug fix: обносляем скроллер после отрисовки, а не там где было - непонятно где.
// - если форматируем или дочитываем, то не даем сразу показывать результат скроллирования.
//
// Revision 1.121  2004/06/16 12:34:46  law
// - не скроллируем окно во время переформатирования - все равно ничего хорошего не выходит.
//
// Revision 1.120  2004/06/16 12:06:24  law
// - не скроллируем окно во время отрисовки - все равно ничего хорошего не получается.
//
// Revision 1.119  2004/06/16 10:40:27  law
// - new behavior: не вызываем форматирование внутри форматирования.
//
// Revision 1.118  2004/06/16 10:00:19  law
// - new behavior: фрагмент для догрузки теперь вычисляет TextSource.
//
// Revision 1.117  2004/06/15 17:08:56  law
// - оптимизирована догрузка документа при движении от ео конца вверх.
//
// Revision 1.116  2004/06/15 14:40:55  law
// - new behavior: не обновляем вертикальный скроллер при перерисовки и внутри процесса скроллирования - так как ничего хорошего из этого все равно не выходит.
//
// Revision 1.115  2004/06/15 12:51:22  law
// - optimization: используем более "дешевые" операции для навигации по документу для определения параметров догрузки кусками.
//
// Revision 1.114  2004/06/11 15:33:36  law
// - продолжаем оптимизировать загрузку документа кусками.
//
// Revision 1.113  2004/06/09 15:30:14  law
// - дотачиваем догрузку документа.
//
// Revision 1.112  2004/06/09 14:21:40  law
// - bug fix: неправильно работала догрузка документа.
//
// Revision 1.111  2004/06/08 14:55:59  law
// - new behavior: догружаем параграфы не только с обреза экрана, а с любого видимого на экране.
//
// Revision 1.110  2004/06/08 13:38:19  law
// - new interface: IevDocumentInfo.
//
// Revision 1.109  2004/06/08 13:17:52  law
// - new behavior: сделан подсчет недогруженных параграфов.
//
// Revision 1.108  2004/06/08 12:13:45  law
// - сделана догрузка документа кусками, учитывая знания об адаптере.
//
// Revision 1.107  2004/06/08 09:33:39  law
// - new unit: evUploadGenerator.
//
// Revision 1.106  2004/06/02 10:20:32  law
// - удален конструктор Tl3VList.MakeIUnknown - пользуйтесь _Tl3InterfaceList.Make.
//
// Revision 1.105  2004/05/27 11:21:13  fireton
// - change: _DeleteFoundRgn и Update теперь public
//
// Revision 1.104  2004/05/26 10:07:09  law
// - bug fix: при смене документа Top не сбрасывался в 0 (CQ OIT5-7276).
//
// Revision 1.103  2004/05/24 15:05:29  law
// - добавлен комметарий и проверка на то, что у нас сейчас _WebStyle.
//
// Revision 1.102  2004/05/24 14:56:13  law
// - bug fix: при хождении по истории документ не переформатировался по текущим размерам окна (CQ OIT5-7110).
//
// Revision 1.101  2004/05/21 17:37:30  law
// - bug fix: был клинч между событиями _ev_msgWasWMSize и _vcm_msgCloseForm (CQ OIT5-7253). Теперь появилось мерцание скроллбаров, которое надо полечить в понедельник.
//
// Revision 1.100  2004/05/20 14:33:52  law
// - bug fix: "Ошибка при переходе к следующему/ппредыдущему документа списка" - успевали грохнуть курсор во время получения документа для присвоения курсору (CQ OIT5-7274).
//
// Revision 1.99  2004/05/20 12:28:07  law
// - new method: _TevCustomTextSource._AsIDataObject.
//
// Revision 1.98  2004/05/19 08:16:12  nikitin75
// освобождаем неосвобожденное
//
// Revision 1.97  2004/05/19 07:54:49  nikitin75
// закомментарил лишнее освобождение объектов
//
// Revision 1.96  2004/05/19 07:38:05  nikitin75
// + _TevCustomEditorWindow.FindA - первая реализация поиска с поддержкой мультивыделения
//
// Revision 1.95  2004/05/14 15:16:52  law
// - remove unit: evTypesE.
//
// Revision 1.94  2004/05/11 17:48:53  law
// - new method: _TevCustomEditorWindow.TextCodePage.
//
// Revision 1.93  2004/05/11 17:36:24  law
// - change: метод _Find перенесен с TevCustomEditor на _TevCustomEditorWindow.
//
// Revision 1.92  2004/05/11 17:29:52  law
// - change: поддержка интерфейса IevReplacer перенесена с TevCustomEditor на _TevCustomEditorWindow.
//
// Revision 1.91  2004/05/11 17:21:35  law
// - cleanup.
//
// Revision 1.90  2004/05/11 16:39:39  law
// - new behavior: теперь Memo тоже забирает в буфер обмена cf_Unicode.
//
// Revision 1.89  2004/05/11 16:17:06  law
// - избавляемся от дублирования кода.
//
// Revision 1.88  2004/05/11 15:54:39  law
// - избавляемся от дублирования кода при определении наиболее вероятного формата для вставки из буфера обмена.
//
// Revision 1.87  2004/05/11 15:37:43  law
// - bug fix: более правильно забираем/вставляем cf_UnicodeText.
//
// Revision 1.86  2004/05/05 14:10:59  law
// - new method: _TevCustomEditorWindow.WantTab.
//
// Revision 1.85  2004/05/01 11:28:36  law
// - bug fix: слетала фильтрация оглавления при путешествии по истории (CQ OIT5-7252).
//
// Revision 1.84  2004/04/30 13:25:14  law
// - bug fix.
//
// Revision 1.83  2004/04/21 09:32:58  law
// - new behavior: при Web-стиле отображения, при изменнении размеров окна подравниваемся на ближайший блок (если выставлена директива _evNeedScrollToBlockFrame).
//
// Revision 1.82  2004/04/20 11:44:30  fireton
// - change: приведение evControl к божескому виду (с нормальными рамочками и отступами)
//
// Revision 1.81  2004/04/15 06:45:47  law
// - change: убрана хитрая трансляция клавиш, оказавшаяся ненужной на системах где не "подхачено" _1252 = 1251.
//
// Revision 1.80  2004/04/14 14:34:39  law
// - new behavior: даем возможность вводить символы немецкого и других европейских языков.
//
// Revision 1.79  2004/04/14 08:51:50  law
// - rename method: Tl3System.PeekStringEx -> PeekString.
//
// Revision 1.78  2004/04/08 13:16:43  law
// - bug fix: AV при освобождении TextSource раньше редактора.
//
// Revision 1.77  2004/04/07 13:01:00  law
// - new method: _TevCustomEditorWindow.MakeTextSource.
// - new event: TevCustomEditor.OnMakeTextSource.
//
// Revision 1.76  2004/04/06 09:25:39  law
// - bug fix: "Отображается комментарии при отжатой кнопке показа комменариев пользователя" (CQ OIT5-6924).
//
// Revision 1.75  2004/04/05 12:11:42  law
// - bug fix; "ошибка при переходе по редакциям документа через закладку "редакции" (CQ OIT5-6951).
//
// Revision 1.74  2004/04/02 13:12:42  law
// - bug fix: не присваивался контейнер из истории, когда в истории не было курсора.
//
// Revision 1.73  2004/04/02 11:44:44  law
// - bug fix: AV в _TevCustomEditorWindow.MoveLeafCursor при отсутствии курсора, например при прерывании загрузки.
//
// Revision 1.72  2004/04/02 07:23:30  law
// - bug fix: AV - при скроллинге в отсутвтвии документа.
//
// Revision 1.71  2004/03/30 16:02:22  law
// - new method: _TevCustomEditorWindow.ReScrollCaret.
// - bug fix: текст показывался обрезанным слева, хотя была возможность показать его целиком, сохранив видимость курсора (CQ OIT5-6717).
//
// Revision 1.70  2004/03/29 11:17:36  law
// - bug fix: текст показывался обрезанным слева, хотя была возможность показать его целиком, сохранив видимость курсора (CQ OIT5-6717).
//
// Revision 1.69  2004/03/26 09:40:31  law
// - bug fix: AV при обработке клавиатуры в момент смены документа.
//
// Revision 1.68  2004/03/19 17:29:00  law
// - bug fix: AV при обработке клавиатуры, когда перегружыется документ (CQ OIT5-5993).
//
// Revision 1.67  2004/03/19 16:54:39  law
// - bug fix: не обновлялись скроллеры при хождении по истории (CQ OIT5-6130).
//
// Revision 1.66  2004/03/15 12:25:05  law
// - bug fix: перечитывался сброшенный документ при обнулении Explorer'а.
//
// Revision 1.65  2004/03/03 18:03:53  law
// - rename unit: l3Tree2 -> l3Tree.
//
// Revision 1.64  2004/03/03 15:12:32  law
// - new method version: Tl3Control._ProcessCommand.
// - new methods: Tl3Control.GetCommands, SetCommands,
//
// Revision 1.63  2004/03/03 13:57:17  law
// - chage: метод _ProcessCommand спущен в класс Tl3Control.
//
// Revision 1.62  2004/03/03 11:01:36  voba
// - bug fix: ошибка обработки Web-стиля в Архивариусе.
//
// Revision 1.61  2004/02/27 19:22:12  law
// - bug fix: поправлена обработка ShortCut'ов для операций модулей.
// - bug fix: поправдена ДВОЙНАЯ обработка ShortCut'ов в случае редактора.
//
// Revision 1.60  2004/02/26 12:42:52  law
// - bug fix: при присвоении TextSource сбрасывался флаг _WebStyle.
//
// Revision 1.59  2004/02/24 07:44:56  nikitin75
// fix: снимаем _fl_WasAsyncLoop ПОСЛЕ aHotSpot.LButtonUp;
//
// Revision 1.58  2004/02/06 15:44:48  nikitin75
// fix: разъезжалась обработка событий при мультивыделении (с Ctrl);
//
// Revision 1.57  2004/01/21 16:16:52  law
// - new method: TevEditorWindowHotSpot.DoExtendBlock.
//
// Revision 1.56  2004/01/21 16:06:13  law
// - cleanup.
//
// Revision 1.55  2004/01/21 15:59:29  law
// - cleanup.
//
// Revision 1.54  2004/01/21 15:49:11  law
// - comments: закомментированы классы TevEditorWindowHotSpot, TevMultiSelectEditorWindowHotSpot.
//
// Revision 1.53  2004/01/21 15:29:09  law
// - cleanup.
//
// Revision 1.52  2004/01/21 15:22:12  law
// - cleanup.
//
// Revision 1.51  2004/01/21 15:20:18  law
// - change: задел на будущее "интеллектуальное" множественное выделение.
//
// Revision 1.50  2004/01/21 14:55:18  law
// - new behavior: в крайне нулевом приближении сделал множественное выделение при помощи "таскания" мышью.
//
// Revision 1.49  2004/01/21 13:34:40  law
// - new _virtual method: TevEditorWindowHotSpot.DoLButtonUp.
//
// Revision 1.48  2004/01/21 13:07:44  law
// - new _virtual method: TevEditorWindowHotSpot.DoMouseMove.
//
// Revision 1.47  2004/01/20 17:20:37  law
// - new method version: TevBlockCursor.GetBlock(out theBlock: _InevDataObject).
//
// Revision 1.46  2004/01/20 16:13:08  law
// - change: перекрываем LButtonDown, а не _DoLButtonDown - чтобы с Ctl можно было выделять ЛЮБОЙ параграф (раньше со ссылками не работало).
//
// Revision 1.45  2004/01/19 18:25:14  law
// - new method: TevMultiSelection.ChangeParaSelection - пока ничего не делает, но реализация методе TevMultiSelectEditorWindowHotSpot._DoLButtonDown его использует.
//
// Revision 1.44  2004/01/19 17:33:09  law
// - new method: TevEditorWindowHotSpot._TranslatePt.
//
// Revision 1.43  2004/01/19 17:25:58  law
// - new _virtual method: TevEditorWindowHotSpot._DoLButtonDown.
//
// Revision 1.42  2004/01/19 15:25:26  law
// - new unit: evMultiSelectEditorWindowHotSpot.
// - new class: TevMultiSelectEditorWindowHotSpot.
//
// Revision 1.41  2004/01/19 15:09:43  law
// - new method: _TevCustomEditorWindow.HotSpotClass.
//
// Revision 1.40  2004/01/19 15:02:23  law
// - new method: TevEditorWindowHotSpot.Make.
//
// Revision 1.39  2004/01/19 14:47:10  law
// - change: класс TevEditorWindowHotSpot переехал в интерфейсную секцию модуля evEditorWindow.
//
// Revision 1.38  2004/01/15 16:56:42  law
// - cleanup: убил свойство TevBlockCursor.BlockRgn для директивы l3RealPaint.
//
// Revision 1.37  2004/01/15 16:33:59  law
// - change: вместо TevBlock используем IevTagSelection.
//
// Revision 1.36  2004/01/15 16:22:34  law
// - cleanup: правильно поименовал локальные переменные.
//
// Revision 1.35  2004/01/15 15:59:10  law
// - new define: l3RealPaint. Включил его для _Nemesis. Должно полечить ошибку CQ OIT5-5860, но может подтормаживать выделение текста в документе (у меня не подтормаживает).
//
// Revision 1.34  2004/01/10 14:49:47  law
// - new unit: evMultiSelectionEditorWindow - загготовка для множественного выделения в редакторе.
//
// Revision 1.33  2004/01/10 13:26:11  law
// - bug fix: Скроллируется документ при вызове контекстного меню (CQ OIT5-5160).
//
// Revision 1.32  2004/01/10 10:48:02  law
// - new behavior: если было выделение и нажали Enter, то выделение снимается и добавляется пользовательский комментарий (CQ OIT5-4993).
//
// Revision 1.31  2004/01/09 16:15:31  law
// - bug fix:  CQ OIT5-4786:
// demon (23.09.2003): Порядок действий:
// 1. Открываем документ 10003372 (база New).
// 2. Переходим по первой ссылке "См. текст Закона в предыдущей редакции"
// 3. Видим ошибку "Невозможно получить процессор операций. (W:\common\components\rtl\Garant\l3\l3BaseIntf.pas, line 241)".
//
// Revision 1.30  2004/01/06 15:43:44  law
// - new prop: _TevCustomEditorWindow.OnTextSourceChanged.
//
// Revision 1.29  2003/12/27 14:36:54  law
// - bug fix: циклическое переформатирование текста при показе/убирании скроллера (CQ IOT5-5681).
//
// Revision 1.28  2003/12/26 11:50:24  law
// - bug fix: AV при обработке клавиш в процессе загрузки документа (CQ OIT5-5674).
//
// Revision 1.27  2003/12/24 14:22:52  law
// - bug fix: падало при закрытии 2-го окна (CQ IOT5-5568).
//
// Revision 1.26  2003/12/24 11:39:24  law
// - bug fix: обрабатываем ситуацию, когда Handle окна не создан - а раз не создан, значит и сообщений не должно быть.
//
// Revision 1.25  2003/12/18 17:19:47  law
// - борьба с мерцанием.
//
// Revision 1.24  2003/12/10 15:13:34  demon
// - bug fix: очищаем Explorer при смене документа.
//
// Revision 1.23  2003/12/10 11:57:25  law
// - bug fix: AV при back из документа.
//
// Revision 1.22  2003/12/10 11:48:14  law
// - bug fix: рекурсивное обращение к Explorer, приводящее к зависанию приложения.
//
// Revision 1.21  2003/12/10 11:00:22  law
// - new behavior: создаем Exlporer, ecли его не было.
//
// Revision 1.20  2003/12/09 17:36:01  law
// - new behavior: сделан показ оглавления на определенный уровень.
//
// Revision 1.19  2003/12/04 14:50:34  law
// - bug fix: Selection.Persistent переехало в _ViewParams.PersistentSelection (CQ OIT5-5457).
//
// Revision 1.18  2003/11/26 13:49:32  law
// - new interface: IedEditableObject.
//
// Revision 1.17  2003/11/24 13:27:22  voba
// - bug fix: неправильно показывалась справка к документу.
//
// Revision 1.16  2003/11/21 16:38:54  law
// - bug fix: не отрисовывались "короткие" документы.
//
// Revision 1.15  2003/11/13 12:36:23  law
// - new behavior: рисунки теперь вписываются не только по ширине, но и по высоте.
//
// Revision 1.14  2003/11/13 11:54:21  law
// - change: _MaxWidth -> Limits.
//
// Revision 1.13  2003/11/11 12:35:20  law
// - new behavior: защитил редактор/TextSource от "переходных" процессов.
//
// Revision 1.12  2003/11/05 17:45:20  law
// - new method: _TevCustomEditorWindow._GotoTag.
//
// Revision 1.11  2003/10/30 15:46:30  law
// - new behavior: защищаем MouseDown при помощи evStartOp/evEndOp.
//
// Revision 1.10  2003/10/29 15:37:57  law
// - cnange: добавлены модификаторы const.
//
// Revision 1.9  2003/10/29 12:29:41  law
// - new behavior: сделана отладочная печать отфильтрованных message.
//
// Revision 1.8  2003/10/22 15:23:53  law
// - new behavior: очищаем очередь событий при уничтожении Handle, в частности ev_msgDoFormat.
// - new behavior: вызываем evStartOp/evEndOp при обработке ev_msgDoFormat (проблема с отложенным удалением форм).
//
// Revision 1.7  2003/10/22 14:08:21  nikitin75
// + в TextSource.Print передаем Cursor для получения смещения на текущую страницу;
//
// Revision 1.6  2003/10/21 05:25:47  nikitin75
// + методу Print добавлен пораметр по-умолчанию aPagesArray - массив (номеров) листов для печати;
//
// Revision 1.5  2003/10/20 11:49:32  nikitin75
// + методу Print добавлен пораметр по-умолчанию aPagesArray - массив (номеров) листов для печати;
//
// Revision 1.4  2003/10/14 16:35:42  law
// - rename unit: evTxtSrc -> evTextSource.
//
// Revision 1.3  2003/10/14 12:09:40  law
// - change: _TevCustomEditorWindow._GetPtCursor, _GetTopCursor теперь public.
//
// Revision 1.2  2003/10/14 09:37:29  law
// - слили с веткой BPRINT_PREVIEW.
//
// Revision 1.1  2003/10/13 15:04:14  law
// - rename unit: evEdWnd -> evEditorWindow.
//
// Revision 1.361  2003/10/11 09:32:44  law
// - bug fix: исправил то, что разломал в результате вчерашней оптимизации.
//
// Revision 1.360  2003/10/10 18:47:25  law
// - new behavior: избавился от переформатирования внутри WM_Size.
// - change: задел на отрисовку окна во время переформатирования (см. комментарии _TevCustomEditorWindow._Paint - f_ScrollTagWrap). А то сейчас некрасиво выглядит при Maximize при _WebStyle.
//
// Revision 1.359  2003/10/10 15:22:41  law
// - new behavior: скрытие/показ комментариев заметно убыстрены.
// - доточена процедура фоновоо форматирования.
// - change: в консольном режиме вставлен отладочный вывод, для тестирования фонового форматирования.
//
// Revision 1.358  2003/10/09 17:57:37  law
// - bug fix: при изменении размера скроллера не изменялась его позиция.
//
// Revision 1.357  2003/10/06 16:34:14  law
// - bug fix: перепозиционирование текста при скрытии/показе комментариев (ошибка №4).
//
// Revision 1.356  2003/10/06 12:49:53  law
// - new methods: _TevCustomEditorWindow._ScrollToCursor, _TevCustomEditorWindow.ScrollToTag.
//
// Revision 1.355  2003/10/03 15:15:20  law
// - bug fix: для режима _WebStyle откорректировано выставление максимума горизонтального скроллера.
//
// Revision 1.354  2003/10/02 16:33:23  law
// - rename unit: evBseCur -> evBaseCursor.
//
// Revision 1.353  2003/10/02 12:50:39  law
// - new methods: _GetPtCursor, _GetTopCursor.
//
// Revision 1.352  2003/09/23 14:16:53  law
// - bug fix: не пересчитывался скроллер при смене TextSource (OIT5-4591).
//
// Revision 1.351  2003/09/23 08:37:56  law
// - new prop: IevHyperlink._Hint.
// - rename proc: ev_plAssignNil -> l3AssignNil.
//
// Revision 1.350  2003/09/22 16:01:53  law
// - change: класс _TevCustomEditorWindow самоинкапсулирован относительно поля f_Top.
//
// Revision 1.349  2003/09/22 12:30:54  law
// - bug fix: ни разу не показываевшемуся редактору не воостанавливался контейнер из истории.
//
// Revision 1.348  2003/09/12 16:35:48  law
// - bug fix: AV при освобождении SubPanel'и.
//
// Revision 1.347  2003/09/12 13:24:19  demon
// - bug fix: попытка починить AV.
//
// Revision 1.346  2003/09/10 10:14:15  law
// - cleanup: упрощено создание процессора операций.
//
// Revision 1.345  2003/09/09 15:19:23  demon
// - bug fix: при загрузке документа не всегда осуществляся корректный переход на метку.
//
// Revision 1.344  2003/09/08 17:05:40  law
// - bug fix: при включенном фоновом форматировании не работал переход на Sub в конец длинного документа, а также на параграф в конце длинного документа.
//
// Revision 1.343  2003/08/29 12:17:20  law
// - bug fix: не вызывался inherited Notification.
// - bug fix: были циклические зависимости между TeeDocumentTool и редактором.
// - bug fix: после вставки inherited было зависание (бесконечная рекурсия).
// - bug fix: в итоге поправлена ошибка от Опоссума.
//
// Revision 1.342  2003/08/27 15:45:38  law
// - bug fix: не закрывалось окно редактора при переходе по ссылке с помощью мыши (соответственно не работала истори при переходе в "Золотой сертификат").
//
// Revision 1.341  2003/08/27 08:44:39  migel
// - bug fix: падение при переходе на картинку.
//
// Revision 1.340  2003/08/26 12:59:19  law
// - change: не изменяем параметры скроллеров, когда документ не загружен (пока закомментровано - до исправления ошибки с возвратом в синхронный просмотр).
//
// Revision 1.339  2003/07/22 12:21:17  law
// - bug fix: AV при получении фокуса окном редактора, при переходных процессах (загрузка, форматирование).
// - new behavior: избавились от мерцания при переходе от списка к рубрикатору и обратно.
//
// Revision 1.338  2003/07/15 09:31:26  law
// - bug fix: обрабатываем сообщение WM_Paint раньше, чем перепосылаем ev_msgDoFormat.
//
// Revision 1.337  2003/07/11 18:55:51  law
// - bug fix: доделаны операции Back/Forward для редактора, при смене контента.
//
// Revision 1.336  2003/07/10 19:01:42  law
// - change: f_TextSource теперь protected, а pm_SetTextSource - _virtual.
//
// Revision 1.335  2003/07/10 16:49:14  law
// - bug fix: не очищался _Owner курсора.
//
// Revision 1.334  2003/07/10 14:43:30  law
// - new prop: TevEditorWindow.AutoHideSelection.
// - new prop: TevCustomEditor.OnSelectionChange.
// - new prop: TeeEditor.OnCursorInSelectionChange.
//
// Revision 1.333  2003/07/09 13:10:27  law
// - new behavior: в событие _OnMouseAction теперь передается параметр aWasSelection.
//
// Revision 1.332  2003/07/08 19:33:14  law
// - bug fix: не перезапускался процесс переформатирования.
// - bug fix: при закрытии редактора во время форматирования все падало.
//
// Revision 1.331  2003/07/08 15:20:23  law
// - cleanup: убрано использование LastIndex, теперь его использует только форматер.
//
// Revision 1.330  2003/07/08 15:06:56  law
// - new behavior: доделано форматирование в фоновом режиме (для _ReadOnly системы все должно работать).
//
// Revision 1.329  2003/07/08 11:23:40  law
// - new behavior: избавился от конфликта скроллера и фонового форматирования.
//
// Revision 1.328  2003/07/07 18:26:09  law
// - change: форматирование в фоновом режиме теперь работает корректно, осталось только доделать, чтобы оно не раздражало пользователя.
//
// Revision 1.327  2003/07/07 15:19:08  demon
// - bug fix: не вызывалось контекстное меню на втором мониторе, расположенном слева от основного.
//
// Revision 1.326  2003/07/04 19:39:45  law
// - оптимизация переформатирования текста в фоновом режиме (до конца не доделано, но светлые мысли есть).
//
// Revision 1.325  2003/07/04 17:07:42  demon
// - bug fix: попытка выставить позицию на Sub у незагруженного документа
//
// Revision 1.324  2003/07/03 17:39:53  law
// - new behavior: попытка оптимизировать переформатирование в _WebStyle режиме (пока что-то не сильно заметно).
//
// Revision 1.323  2003/07/03 12:26:55  law
// - bug fix: отъезжало переформатирование по ширине окна.
//
// Revision 1.322  2003/07/01 13:05:07  law
// - new method: _IeeEditor._GetHotspotOnPoint.
//
// Revision 1.321  2003/06/27 19:07:24  law
// - new behavior: TeeEditorExport теперь поддерживает сохранение состояния.
//
// Revision 1.320  2003/06/06 09:10:42  law
// - bug fix: был AV при освобождании Explorer'а (вчера, как оказалось, до конца дочинено не было).
//
// Revision 1.319  2003/06/05 14:11:29  law
// - bug fix: был AV при изменении корневого узла, если у Explorer'а не было дерева (вчера, как оказалось, до конца дочинено не было).
//
// Revision 1.318  2003/06/05 12:37:41  law
// - bug fix: был AV при изменении корневого узла, если у Explorer'а не было дерева.
//
// Revision 1.317  2003/06/04 11:22:37  law
// - bug fix: при попадании TextSource в Clipboard не освобождалось дерево, которое уже убито.
//
// Revision 1.316  2003/05/29 13:31:06  law
// - new behavior: TeeEditorExport теперь создает TextSource, если его не было.
//
// Revision 1.315  2003/05/28 16:15:52  law
// - chage: развязал модули evEdWnd и evRuler.
//
// Revision 1.314  2003/05/28 13:13:35  law
// - change: развязал модули evEdWnd и evSubPanel, так что чисто теоретически можно использовать другую панель Sub'ов.
//
// Revision 1.313  2003/05/26 16:38:35  law
// - new method: IevToolWindow._Invalidate.
//
// Revision 1.312  2003/05/23 17:38:14  law
// - new unit: evVisualInterfaces - задел на развязку окна редактора с реализацией линейки и панели Sub'ов.
//
// Revision 1.311  2003/05/23 17:29:23  law
// - change type: _TevEditorWindowTextSource.Explorer: TComponent -> Il3TreeSource.
//
// Revision 1.310  2003/05/23 16:33:44  law
// - cleanup: используем IevMarker вместо TevMarker.
//
// Revision 1.309  2003/05/22 13:10:09  law
// - cleanup.
//
// Revision 1.308  2003/05/20 11:35:13  law
// - rename class: TevCustomTextSourceFiler -> TevCustomTextSourceDocumentContainer.
// - rename prop: _TevCustomTextSource.Filer -> _TevCustomTextSource.DocumentContainer.
//
// Revision 1.307  2003/05/19 17:23:37  law
// - bug fix: пытаемся исправить _Preview-режим.
//
// Revision 1.306  2003/05/13 09:34:28  law
// - new behavior: запрещен горизонтальный скроллинг в отрицательную сторону.
//
// Revision 1.305  2003/05/10 13:17:08  law
// - cleanup: используем IevMarker вместо TevMarker.
//
// Revision 1.304  2003/05/10 13:13:16  law
// - new prop: IedParagraphFormatting.LeftIndent.
//
// Revision 1.303  2003/05/10 13:06:43  law
// - cleanup: подготавливаемся к поддержке не только свойства FirstIndent, но и других.
//
// Revision 1.302  2003/05/10 12:28:11  law
// - new behavior: сделана возможность изменять выравнивание по вертикали сразу группе ячеек.
//
// Revision 1.301  2003/03/19 10:47:33  law
// - new directives: evForEE, _evNeedDisp, _evNotNeedDisp.
//
// Revision 1.300  2003/02/18 15:19:41  law
// - new behavior: Если курсор установлен на первый символ (строку?) первого абзаца блока надо показывать рамку блока (№101).
//
// Revision 1.299  2003/02/18 14:31:40  law
// - new methods: IeeNode.Remove, IeeNode.RemoveChildren (для коллег из Гаранта 6 сделать удаление узлов из дерева №123).
//
// Revision 1.298  2003/02/18 13:04:53  law
// - new behavior: при переходе на метку ровняем курсор по верхней границе окна, по заказу коллег из Гарант 6 (задача №2871).
//
// Revision 1.297  2003/02/17 16:13:20  law
// - remove prop: TevBlockCursor.HasSelection.
// - new prop: TevBlockCursor.Collapsed.
//
// Revision 1.296  2003/02/13 18:17:20  law
// - change: у _Il3Lock переделать параметр методов Lock/Unlock с Integer на IUnknown (№113).
//
// Revision 1.295  2003/02/13 12:50:53  law
// - cleanup: l3IQueryInterface, l3IBQueryInterface переименованы в l3QueryInterface, Supports.
//
// Revision 1.294  2003/02/13 12:27:31  law
// - cleanup: IevFont переименован в _TevCustomFont, чтобы не путать его с интерфейсом.
//
// Revision 1.293  2003/02/06 14:42:58  law
// - cleanup: переходим от сообщений (message)  к виртуальным функциям.
//
// Revision 1.292  2003/02/06 10:13:24  law
// - change: добавлено значение кода операции по умолчанию.
//
// Revision 1.291  2003/02/05 14:21:41  law
// - bug fix: попытка исправить ошибку, когда не обновляются кнопки (Action) при выставлении параметров шрифта выделению, но это не помогло, так как надо пересматривать TevTextCursorPair.GetFontPrim, логика которого сломалась при починки учета прозрачности гиперссылок.
//
// Revision 1.290  2003/02/05 13:53:10  law
// - cleanup: переходим от сообщений (message)  к виртуальным функциям.
//
// Revision 1.289  2003/02/04 10:59:46  law
// - cleanup: переходим к IUnknown вместо TObject.
//
// Revision 1.288  2003/02/04 10:30:45  law
// - cleanup: переходим к IUnknown вместо TObject.
//
// Revision 1.287  2003/01/23 17:00:56  law
// - bug fix: при включении режима отображения блоков была ошибка конвертации NULL в _Bool.
//
// Revision 1.286  2003/01/21 12:49:46  law
// - new behavior: сделана возможность редактирование списков.
//
// Revision 1.285  2003/01/17 17:27:49  law
// - cleanup: избавляемся от прямого использования ev_msgMove.
//
// Revision 1.284  2003/01/13 17:35:49  law
// - new behavior: расширена возможность выделения строк при DoubleClick внутри ячейки.
//
// Revision 1.283  2002/12/24 13:02:01  law
// - change: объединил Int64_Seek c основной веткой.
//
// Revision 1.282.2.1  2002/12/23 15:51:26  law
// - bug fix: не работали с хранилищем > 2Гб.
//
// Revision 1.282  2002/12/17 12:20:43  law
// - new unit: k2Unknown.
//
// Revision 1.281  2002/12/17 10:32:58  law
// - cleanup.
//
// Revision 1.280  2002/12/16 16:10:37  law
// - new unit: evParaCursor.
//
// Revision 1.279  2002/11/13 15:22:45  law
// - new class: TeeSubPanel.
//
// Revision 1.278  2002/11/12 13:14:09  law
// - bug fix: AV при загрузке документа.
//
// Revision 1.277  2002/11/12 10:17:29  law
// - bug fix: при переходе по ссылке в режиме Web неправильно отображалась текущая позиция курсора.
//
// Revision 1.276  2002/10/28 13:40:11  law
// - cleanup & comments.
//
// Revision 1.275  2002/10/28 13:00:07  law
// - bug fix: ошибка при прикручивании новой логики обработки ScrollBar'ов.
//
// Revision 1.274  2002/10/28 12:09:59  law
// - bug fix: изменение позиции курсора не синхронизировалось со ScrollBar'ами.
//
// Revision 1.273  2002/10/28 10:10:24  law
// - new behavior: синхронизация редактора со скроллерами.
//
// Revision 1.272  2002/10/28 09:10:31  law
// - new prop: TeeCustomEditor.HScrollBar, TeeCustomEditor.VScrollBar.
//
// Revision 1.271  2002/10/25 15:30:19  law
// - new behavior: при вызове контекстного меню с клавиатуры привязываемся к позиции каретки.
//
// Revision 1.270  2002/10/10 16:03:26  law
// no message
//
// Revision 1.269  2002/10/10 13:21:15  law
// - bug fix: не убирался отступ.
//
// Revision 1.268  2002/10/10 11:31:59  law
// - new property: LeftIndentDelta.
//
// Revision 1.267  2002/10/10 11:21:10  law
// - new property: LeftIndentDelta.
//
// Revision 1.266  2002/10/09 10:45:34  voba
// - bug fix: неправильно взаимодействовали режимы _Preview и Web-style.
//
// Revision 1.265  2002/10/01 11:00:39  law
// - new behavior: при отработке нажатия на ссылку проверяем и k2_tiInternalHandle.
//
// Revision 1.264  2002/09/27 09:18:07  law
// - bug fix: не перерисовывался горизонтальный скроллер.
// - new behavior: теперь можно вызвать WM_Size с параметрами  (0, -1) для принудительного обновления скроллеров и _WebStyle.
//
// Revision 1.263  2002/09/26 14:30:05  law
// - cleanup.
//
// Revision 1.262  2002/09/26 08:26:00  law
// - new behavior: сделан переход по локальным ссылкам.
//
// Revision 1.261  2002/09/18 14:31:36  law
// - change: начата работа по поддержке нотификации об изменении стилей.
// - new unit: evStyleTableTools.
//
// Revision 1.260  2002/09/17 13:03:03  law
// - new standard action: ev_ccWebStyle.
//
// Revision 1.259  2002/09/16 14:04:08  law
// - new property: _TevCustomEditorWindow._WebStyle.
//
// Revision 1.258  2002/09/16 12:16:12  law
// - new behavior: сделана возможность форматирования документа по ширине окна.
//
// Revision 1.257  2002/08/29 08:49:09  law
// - new param: Sender.
//
// Revision 1.256  2002/08/29 08:45:07  law
// - new behavior: сделана возможность настройки параметров HotSpot'а.
//
// Revision 1.255  2002/08/26 14:43:31  law
// - new behavior: пытаемся изменить алгорим обработки PgUp и PgDown.
//
// Revision 1.254  2002/08/02 08:32:13  law
// no message
//
// Revision 1.253  2002/08/01 11:44:40  law
// - bug fix: не вызывалось контекстное меню.
//
// Revision 1.252  2002/07/31 14:22:51  law
// - bug fix: AV при загрузке документа.
//
// Revision 1.251  2002/07/31 12:29:03  law
// - new behavior: после включения/выключения режима показа блоков позиционируем текущий параграф, чтобы он был виден на экране.
//
// Revision 1.250  2002/07/29 12:01:51  law
// - new param: aOpProc.
//
// Revision 1.249  2002/07/29 10:45:32  law
// - new behavior: трансляция клавиатурных сообщений параграфам.
//
// Revision 1.248  2002/07/17 12:12:20  law
// - bug fix: двоило контекстное меню.
//
// Revision 1.247  2002/07/15 13:51:41  law
// - new behavior: возможность отказаться от цикла выделения при обработке нажатия левой кнопки мыши.
//
// Revision 1.246  2002/07/12 17:44:11  law
// - new behavior: предварительно сделано синее выделение в дереве.
//
// Revision 1.245  2002/07/12 14:14:36  law
// - bug fix: неправильно отрабатывалось Popup-Menu.
//
// Revision 1.244  2002/07/11 12:03:14  law
// - rename proc: _evPoint -> l3Point, evRect -> l3Rect.
//
// Revision 1.243  2002/07/09 13:57:38  law
// - new unit: evMsgCode.
//
// Revision 1.242  2002/07/09 12:02:19  law
// - rename unit: evUnits -> l3Units.
//
// Revision 1.241  2002/07/03 11:11:12  law
// - new behavior: Ctrl-Del как в Word'е (как Вован и юристы хотели).
//
// Revision 1.240  2002/06/03 13:19:38  law
// - new behavior: сделана вставка в "резиновые" псевдотаблицы в режиме рисования линий.
//
// Revision 1.239  2002/05/17 10:41:07  law
// - new _commands: ev_ocDeleteWordLeft, ev_ocDeleteWordRight.
//
// Revision 1.238  2002/05/16 08:26:50  law
// - new operation: удаление слова слева по Ctrl-Backspace.
//
// Revision 1.237  2002/05/16 06:49:11  law
// - new behavior: удаление слова по Ctrl-Del.
//
// Revision 1.236  2002/04/08 12:33:51  law
// - bug fix: AV иногда при изменении стиля.
//
// Revision 1.235  2002/04/06 10:43:55  law
// - bug fix: съедался Ctrl-Enter.
//
// Revision 1.234  2002/04/06 10:39:37  law
// - bug fix: неправильно отрабатывался Enter в многострочном Memo.
//
// Revision 1.233  2002/04/06 10:30:33  law
// - bug fix: неправильно отрабатывалось контекстное меню для HotSpot'ов.
//
// Revision 1.232  2002/04/05 15:47:43  law
// - bug fix.
//
// Revision 1.231  2002/02/18 12:28:39  law
// - bug fix: не активизировалось мышью.
//
// Revision 1.230  2002/02/15 14:36:12  law
// - new prop: _IedRange.Document.
//
// Revision 1.229  2002/02/13 15:55:15  law
// - cleanup.
//
// Revision 1.228  2002/02/13 15:41:03  law
// - new behavior: немного изменена обработка кнопок мыши.
//
// Revision 1.227  2002/02/07 16:12:15  law
// - cleanup: убраны ненужные ссылки на evTxtPar.
//
// Revision 1.226  2002/02/07 15:22:29  law
// - rename class: IevBlock -> TevBlock, для того чтобы не путать его с интерфейсом.
//
// Revision 1.225  2002/02/07 15:05:24  law
// - rename class: IevCursor -> _TevCursor, для того чтобы не путать его с интерфейсом.
//
// Revision 1.224  2002/02/07 14:42:47  law
// - rename class: InevLocation -> _TevLocation, для того чтобы не путать его с интерфейсом.
//
// Revision 1.223  2002/02/07 13:43:20  voba
// - bug fix: AV при закрытии формы с окном редактора.
//
// Revision 1.222  2002/02/06 14:47:29  voba
// - bug fix: bad translation of Ctrl-V keyboard sequence (Paste + 'v').
//
// Revision 1.221  2002/02/01 15:27:49  law
// - bug fix: ^K^B.
//
// Revision 1.220  2002/01/29 16:46:25  law
// - new behavior:  повышаем точность рисования строба.
//
// Revision 1.219  2001/11/27 14:59:01  law
// - change behavior: вместо TevMarker используем IevMarker.
//
// Revision 1.218  2001/11/26 14:31:04  law
// - change type: Keys: Long -> Keys: TShiftState.
//
// Revision 1.217  2001/11/23 10:23:23  law
// - cleanup: убрал ненужную ссылку на TevCanvas.
//
// Revision 1.216  2001/11/23 08:24:33  law
// - cleanup: немного упрощена логика evSubPn (теперь используем IevSub и Il3Canvas).
//
// Revision 1.215  2001/11/22 15:10:11  law
// - bug fix: мерцание при скроллинге.
//
// Revision 1.214  2001/11/19 15:08:45  law
// - rename class: Il3HAFPainter -> Tl3HAFPainter.
// - new interface: Il3HAFPainter.
//
// Revision 1.213  2001/11/19 14:31:49  law
// - cleanup: убраны ненужные зависимости между модулями.
//
// Revision 1.212  2001/11/19 13:15:33  law
// - bug fix: странности со скроллингом (см. задачу №1359, _TestSet\Scroll\1.evd).
//
// Revision 1.211  2001/11/19 10:25:53  law
// - bug fix: несогласованность масштаба редактора и линеек (см. задачу 1343).
//
// Revision 1.210  2001/11/09 12:10:24  law
// - new interface: IevOpTranslator.
//
// Revision 1.209  2001/11/09 09:25:26  law
// - change method: MoveLeafCursor переехал в _TevCustomEditorWindow и приобрел параметр по умолчанию ApplyToPara.
//
// Revision 1.208  2001/11/05 16:21:10  voba
// -new behavior :  игнорирует команды для листов и таблиц
//
// Revision 1.207  2001/10/17 16:09:30  law
// - bug fix: AV при закрытии большого документа сразу же после выделения всего текста.
//
// Revision 1.206  2001/10/16 14:01:12  law
// - bug fix & new behavior: добавление в буфер обмена когда там ничего не было или не было IDataObject.
//
// Revision 1.205  2001/10/16 11:59:24  law
// - new behavior: добавление фрагментов текста в буфер обмена на основе _OleSetClipboard.
//
// Revision 1.204  2001/10/15 14:58:49  law
// - cleanup: уменьшен список форматов.
//
// Revision 1.203  2001/10/12 17:51:59  law
// - new behavior: работа с буфером обмена через _OleSetClipboard.
//
// Revision 1.202  2001/10/05 11:37:55  law
// - bug fix: зависание при скроллинге.
//
// Revision 1.201  2001/10/02 12:24:06  law
// - bug fix: ошибки при выставлении параметров горизонтального скроллера.
//
// Revision 1.200  2001/09/25 12:51:56  law
// - new behavior: курсор гасится во время скроллинга.
//
// Revision 1.199  2001/09/25 12:31:00  law
// - bug fix: курсор при скроллинге иногда пачкал.
//
// Revision 1.198  2001/09/25 10:49:25  law
// - bug fix: странное поведение каретки при скроллинге.
//
// Revision 1.197  2001/09/25 08:27:38  law
// - new behavior: обрабатываются сообщения горизонтального скроллбара scTop и scBottom.
//
// Revision 1.196  2001/09/25 08:09:26  law
// - cleanup.
//
// Revision 1.195  2001/09/25 08:04:29  law
// - new behavior: пропорциональный горизонтальный скроллер.
//
// Revision 1.194  2001/09/25 07:18:59  law
// - new behavior: удалена проверка диапазона скроллера.
//
// Revision 1.193  2001/09/24 15:46:00  law
// - new behavior: вертикальный скроллбар сделан на основе 32-битных функций.
//
// Revision 1.192  2001/09/24 15:32:51  law
// - cleanup.
//
// Revision 1.191  2001/09/24 15:23:06  law
// - new behavior: методу SetVScrollRange можно указать нужен но ли переустанавливать позицию скроллера.
//
// Revision 1.190  2001/09/24 14:41:41  law
// - cleanup.
//
// Revision 1.189  2001/09/24 14:12:47  law
// - new behavior: пропорциональный вертикальный скроллбар.
//
// Revision 1.188  2001/09/24 13:49:41  law
// - cleanup.
//
// Revision 1.187  2001/09/24 13:16:22  law
// - bug fix: повисание при вызове SetScrollRange.
//
// Revision 1.186  2001/09/24 11:18:06  law
// - bug fix: не обновлялись максимальные размеры вертикального скроллера.
//
// Revision 1.185  2001/09/21 16:47:07  law
// - bug fix: иногда окно редактора не перерисовывалось при изменении текста.
//
// Revision 1.184  2001/09/07 08:53:01  law
// - rename procedures: evPointX -> l3PointX, evPointY -> l3PointY.
//
// Revision 1.183  2001/09/07 08:13:58  law
// - cleanup.
//
// Revision 1.182  2001/09/05 09:31:27  law
// - new method: TevBitmapHandleReader.Make.
//
// Revision 1.181  2001/08/29 07:01:07  law
// - split unit: l3Intf -> l3BaseStream, l3BaseDraw, l3InterfacedComponent.
//
// Revision 1.180  2001/08/28 12:55:12  law
// - rename unit: evUtils -> l3Utils.
//
// Revision 1.179  2001/07/24 08:01:30  law
// - new behavior: выделение удаляется при опции not Persistent при вставке текста.
//
// Revision 1.178  2001/07/20 12:55:38  voba
// - bug fix: TextSource -> aTextSource.
//
// Revision 1.177  2001/07/20 10:47:36  voba
// - new method: InsertFrom.
//
// Revision 1.176  2001/07/10 11:51:25  law
// - nothing special: исследования насчет задачи №461 (см. _TestSet\PseudoTable\1.evd).
//
// Revision 1.175  2001/06/25 09:59:35  law
// - bug fix: AV при drag n drop внутрь выделения (запретили drop внутрь выделения).
//
// Revision 1.174  2001/06/21 08:17:35  law
// - bug fix: подавлена ошибка при получении свойства Visible у параграфа, для которого это свойство не определено.
//
// Revision 1.173  2001/06/19 08:19:40  law
// - new behavior: вставлена проверка ошибок при работе с буфером обмена.
//
// Revision 1.172  2001/06/18 14:32:49  law
// - cleanup.
//
// Revision 1.171  2001/06/15 14:38:58  law
// no message
//
// Revision 1.170  2001/06/14 14:22:46  law
// - new logic: вместо сообщения ev_msgUpdateScrollRange используем метод IevWindow._UpdateScrollRange.
//
// Revision 1.169  2001/06/09 13:39:49  law
// - new behavior: обработка _EevLimitReached.
//
// Revision 1.168  2001/06/09 13:12:21  law
// - new behavior: обработка EevReadOnly в IevHotSpot.
//
// Revision 1.167  2001/06/05 13:42:34  law
// - comments: еще комментарии для xHelpGen.
//
// Revision 1.166  2001/06/01 12:45:52  law
// - new behavior: убрано использование WM_Clear на верхнем уровне для удаления выделения.
//
// Revision 1.165  2001/06/01 08:11:07  law
// - cleanup: убрана работа с ненужными сообщениями, а также ненужные зависимости между модулями.
//
// Revision 1.164  2001/05/31 11:16:51  law
// - cleanup: убрана работа с сообщениями em_* за ненадобностью.
//
// Revision 1.163  2001/05/25 11:55:15  law
// - bug fix: AV при получении типа текущего стиля не для текстового параграфа.
//
// Revision 1.162  2001/05/15 12:22:32  law
// - cleanup: немного подчищены ненужные типы и перекрестные ссылки между модулями.
// - comments: добавлены комментарии для xHelpGen.
//
// Revision 1.161  2001/05/14 12:35:47  law
// - cleanup: убран класс TevCustomStandardTextSource.
//
// Revision 1.160  2001/05/11 10:58:35  law
// - bug fix: обработка корректности значения _TextPara.Style.ID внутри операторных скобок (referer: Гарри, сборка оглавления).
//
// Revision 1.159  2001/05/10 14:28:43  law
// - delete prop: удалено свойство _TevSelection._VisualFormatting.
//
// Revision 1.158  2001/05/07 08:54:00  law
// - new behavior: _Tl3Tree ->Il3RootNode.
//
// Revision 1.157  2001/05/07 06:56:11  law
// - bug fix: дизбаланс скобок нотификации дерева при загрузке документа.
//
// Revision 1.156  2001/05/04 13:22:12  law
// - cleanup: изменена логика TevDocumentFiler - от _TevBaseParaList к Ik2TagWrap, а также переходим от деревьев к листьям.
//
// Revision 1.155  2001/05/04 11:55:04  law
// - cleanup: убраны ненужные методы и классы.
//
// Revision 1.154  2001/04/25 09:14:28  law
// - cleanup & comments.
//
// Revision 1.153  2001/04/25 07:32:29  law
// - new behavior: флаги ev_uf* и ev_uwf* объединены в ev_uwf*.
//
// Revision 1.152  2001/04/25 06:48:30  law
// - new behavior: свойства BorderStyle и ScrollStyle переехали в TevCustomControl.
// - bug fix: переход на метку после загрузки документа.
//
// Revision 1.151  2001/04/24 15:16:57  law
// - change field: поле fl_ShowCursor заменено на флаг ev_uwfScrollCaret.
//
// Revision 1.150  2001/04/24 12:40:43  law
// - new behavior:
//  1. Немного поправлена линейка - иногда не перерисовывались засечки.
//  2. Немного изменен алгоритм вычисления шрифта выделения - теперь выделение на больших файлах появляется без задержки.
//
// Revision 1.149  2001/04/12 16:35:26  law
// - new behavior: сделаны стробы при операциях с мышью.
//
// Revision 1.148  2001/04/12 13:23:34  law
// - new behavior: сделана обработка формата _cf_hDrop.
//
// Revision 1.147  2001/04/10 12:30:16  law
// - new behavior: сделано запрещение перетаскивания выделения в самого себя.
//
// Revision 1.146  2001/04/09 15:18:28  law
// - new behavior: на горизонтальной линейке 0 перенесен на конец левого поля документа.
//
// Revision 1.145  2001/04/09 13:51:14  law
// - new behavior: сделан перенос начала координат на линейке, относительно текущего параграфа.
//
// Revision 1.144  2001/04/06 13:58:41  law
// - new behavior: в первом приближении сделан Drag из окна редактора.
//
// Revision 1.143  2001/04/05 17:03:40  law
// - new behavior: в первом приближении сделан Drop данных в окно редактора.
//
// Revision 1.142  2001/04/05 08:21:45  law
// - new behavior: поддрежка Drag'n'Drop переехала в evCtrl.
//
// Revision 1.141  2001/04/04 17:03:05  law
// - new behavior: начата работа над поддержкой окном редактора интерфейса IDropTarget.
//
// Revision 1.140  2001/04/02 11:29:55  law
// - операции над текстовым параграфом вынесены в модуль evTextParaOp.
//
// Revision 1.139  2001/03/30 11:54:34  law
// - курсор для текстовых параграфов вынесен в модуль evTextParaCursor.
//
// Revision 1.138  2001/03/29 15:22:41  law
// - new: добавлен интерфейс IedLeafParagraph и метод _IedRange.IterateLeafParagraphs.
//
// Revision 1.137  2001/03/27 08:44:01  law
// - убраны ненужные forward описания классов.
//
// Revision 1.136  2001/03/27 08:01:57  law
// - TevPoint -> Tl3Point, TevRect -> Tl3Rect.
//
// Revision 1.135  2001/03/26 13:50:23  law
// - убран класс Wk2Handle.
//
// Revision 1.134  2001/03/23 17:48:09  law
// - сделана обработка операции ev_ocToggleInsMode и переделана вставка строки через IevOpInsertString.
//
// Revision 1.133  2001/03/23 14:38:22  voba
// Bug fix% Обработка <enter> в memo
//
// Revision 1.132  2001/03/21 15:03:16  law
// - сделана отмена перемещения при отпускании клавиши Control.
//
// Revision 1.131  2001/03/21 14:10:46  law
// - добавлен интерфейс IevSelection.
//
// Revision 1.130  2001/03/21 13:15:40  law
// - сделано перетаскивание блоков мышью.
//
// Revision 1.129  2001/03/15 17:21:44  law
// - немного поправлена обработка сообщений для меню.
//
// Revision 1.128  2001/03/15 14:52:22  law
// - cleaning & coments.
//
// Revision 1.127  2001/03/14 13:24:54  law
// - some cleaup and tuning.
//
// Revision 1.126  2001/03/13 18:44:33  law
// - some cleaning, tuning & comments.
//
// Revision 1.125  2001/03/13 13:20:39  law
// - some tuning & comments.
//
// Revision 1.124  2001/03/12 14:04:34  law
// - у интерфейса IedTextParagraph добавлен метод для присваивания свойства Font.
//
// Revision 1.123  2001/03/02 16:25:34  law
// - сделана отработка команд ^KB и ^KK.
//
// Revision 1.122  2001/02/27 17:11:34  law
// - дописаны комментарии.
//
// Revision 1.121  2001/02/27 15:36:34  law
// - дописаны комментарии.
//
// Revision 1.120  2001/02/21 13:54:55  law
// - убраны ненужные директивы l3OldVersion.
//
// Revision 1.119  2001/02/20 10:23:51  law
// - some tuning
//
// Revision 1.118  2001/01/31 10:37:30  law
// - оптимизировано использование QueryInterface.
//
// Revision 1.117  2001/01/25 13:54:52  law
// - к интерфейсу IedParagraphFormatting добавлено свойство FirstIndent.
//
// Revision 1.116  2001/01/19 15:55:21  law
// - попытка заставить курсор не "пачкать" при перемещении.
//
// Revision 1.115  2001/01/15 17:43:16  law
// - bug fix: не посылалось сообщение StyleChange при смене стиля.
//
// Revision 1.114  2001/01/04 14:58:51  voba
// - bug fix: установка стиля по умолчанию.
//
// Revision 1.113  2000/12/20 14:59:21  law
// - немного переделана функция копирования в буфер обмена.
//
// Revision 1.111  2000/12/19 14:41:36  law
// - подчищены ненужные свойства и восстановлена функциональность нужных.
//
// Revision 1.110  2000/12/19 11:42:52  law
// - переделан механизм отрисовки найденного фрагмента.
//
// Revision 1.109  2000/12/15 14:57:01  law
// - вставлены директивы Log.
//

{$Include evDefine.inc }

 {$Define evMapKeysToView}
 {$Define evMapBottomRightToView}

interface

uses
  Windows,
  Classes,
  Controls,
  Messages,
  StdCtrls,
  RichEdit,
  Graphics,
  SysUtils,
  Forms,    {- используем для ссылки на Application & TBorderStyle}
  Dialogs,
  ExtCtrls,

  l3Interfaces,
  l3Variant,
  l3MinMax,
  l3Types,
  l3Const,
  l3IID,
  l3Msg,
  l3Base,
  l3InternalInterfaces,
  l3Tree_TLB,
  l3Tree,
  l3Units,  {- работа с различными единицами измерения}
  l3PrinterInterfaces,

  afwInterfaces,
  afwTypes,
  afwControl,
  afwNavigation,

  k2Const,
  k2Tags,
  k2Base,
  k2Interfaces,
  k2InternalInterfaces,
  k2DocumentGenerator,
  k2BaseIntf,

  evdInterfaces,

  evExcept,
  evInternalInterfaces,
  evVisualInterfaces,
  evConst,
  evTypes,
  evDef,
  evOp,     {- описание операций редактирования }
  evMsgCode,
  evCustomTextSource,
  {$IfDef evNeedDisp}
  evDisp,
  {$EndIf evNeedDisp}
  evEditorInterfaces,
  evdStyles,
  evEditorWindowHotSpot,

  {$IfNDef NoVCM}
  vcmExternalInterfaces,
  {$EndIf  NoVCM}

  evdTypes,
  
  nevBase,
  nevTools,
  nevInterfaces,
  nevSelection,
  nevControl,
  nevGUIInterfaces,
  nevNavigation,
  
  evCustomEditorWindowPrim,
  vtScrollBar
  ;

const
 defAutoHideSelection = false;

const
  SB_WheelUp   = SB_EndScroll + 1;
  SB_WheelDown = SB_WheelUp + 1;
  //SB_Delta     = SB_WheelUp + 2;

type
  TevFocusedEvent = procedure(aSender      : TObject;
                              var aFocused : Boolean) of object;
   {-}
  TevCursorEvent = function(Sender         : TObject;
                            const aHotSpot : IevHotSpot): Boolean of object;
   {* - событие для изменения формы курсора. }
  TevJumpToEvent = function(Sender          : TObject;
                            anEffects : TafwJumpToEffects;
                            const aMoniker  : IevMoniker): Boolean of object;
   {* - событие для перехода по адресу aMoniker. }
  TevGetMonikerSinkEvent = function(Sender             : TObject;
                                    out theMonikerSink : IevMonikerSink): Boolean of object;
   {* - событие для получения объекта для перехода по адресу. }

  TevParaChangeEvent = procedure(Sender: TObject; const aTextPara: IedTextParagraph) of object;
   {* - нотификация об изменении текущего параграфа. }
  TevFontChangeEvent = procedure(Sender: TObject; const Font: Il3Font) of object;
   {* - нотификация об изменении текущего шрифта. }
  TevStyleChangeEvent = procedure(Sender: TObject; const Style: IedStyle) of object;
   {* - нотификация об изменении текущего стиля. }
  TevMouseActionEvent = function (const aHotSpot    : IevHotSpot;
                                  aButton           : TevMouseButton;
                                  anAction          : TevMouseAction;
                                  Keys              : TShiftState;
                                  var NeedAsyncLoop : Boolean): Boolean of object;
   {* - событие для реакции на операцию мышью. }
  TevGetHotspotInfo = procedure(Sender         : TObject;
                                const aHotSpot : IevHotSpot;
                                const aKeys    : TafwCursorState;
                                var theInfo    : TafwCursorInfo) of object;
   {* - событие для получения информации о HotSpot'е. }

  TevHistoryEvent = procedure (Sender  : TObject;
                               var IsLast: Boolean) of object;

  TevMakeHAFMacroReplacer = procedure (Sender: TObject; var aReplacer: IafwHAFMacroReplacer) of object;

  RevSelection = class of TnevSelection;     

  TevAfterAdjustHeightEvent = procedure (Sender: TObject; anOldHeight : Integer; aNewHeight : Integer) of object;

  {$IfDef Nemesis}
  TevOnZOrderChangingEvent = procedure (Sender: TObject; var aAllowChangeZOrder: Boolean) of object;
  {$EndIf Nemesis}

  RevEditorWindowHotSpot = class of TevEditorWindowHotSpot;

  TevCustomEditorWindow = class(TevCustomEditorWindowPrim,
                                Il3ObjectWrap,
                                // - это надо ТОЛЬКО для поддержки "старых" HotSpot'ов 
                                Il3Lock,
                                {$IfDef evNeedDisp}
                                Il3ActionControl,
                                {$EndIf evNeedDisp}
                                IevMonikerSink,
                                IevMarkerSpy,
                                Il3CaretOwner,
                                IevCursorSource,
                                IevHotSpotSink,
                                IevObjectFrame,
                                IevReplacer,
                                InevConfirm,
                                InevViewArea,
                                InevCommentSwitcher
                                {$IfNDef NoVCM}
                                ,
                                IvcmState,
                                IvcmCloneableState
                                {$EndIf  NoVCM}
                                )
   {* Реализует базовый оконный элемент для отображения и редактирования содержимого документа. }
    protected
    // internal fields
      fl_Capture         : Boolean;     {-if True, we have the capture}
      fl_WasAsyncLoop    : Boolean;
      f_WasMouseUp       : Boolean;
      f_CursorFromHistory: Boolean;
    private
    // internal fields
      fl_HScroll         : Boolean;     {-есть ли горизонтальный ScrollBar}
      {$IfDef evNeedGetBlockFont}
      fl_BlockFontCalls  : Long;
      {$EndIf evNeedGetBlockFont}
      {$IfDef evNeedGetBlockStyle}
      fl_BlockStyleCalls : Long;
      {$EndIf evNeedGetBlockStyle}
      fl_VScroll         : Boolean;     {-есть ли вертикальный ScrollBar}
      fl_UpdateFlags     : TevUpdateWindowFlags; {-элементы требующие обновления}
      f_ReadOnly         : Boolean;
    protected
    // property fields
      f_TextSource       : TevCustomTextSource;
      //Redirect           : _Ik2Tag;
      //f_CheckedBookmarks : Boolean;
    private
    // property fields
      f_Document         : InevParaList;
      f_LMargin          : TevPixel;         {-отступ слева}
      f_HRuler           : IevRuler;         {-горизонтальная линейка}
      f_VRuler           : IevRuler;         {-вертикальная линейка}
      f_HScrollBar       : TvtScrollBar;
      f_VSubPanel        : Pointer;
      f_Cursor           : TnevSelection;
      f_CursorInSelection: Boolean;
      { текущие значения параметров }
      f_CurFont          : array [Boolean] of InevFontPrim;
      f_CurStyle         : array [Boolean] of Il3TagRef;
      f_InScroll         : Boolean;
      f_WebStyle         : Boolean;
      f_LeftIndentDelta  : Long;
      f_AutoHideSelection: Boolean;
      f_InHScrollRange   : Boolean;
      f_InVScrollRange   : Boolean;
      f_NeedUpdateRange  : Boolean;
      f_NeedInvalidate      : Boolean;
      f_NeedSetVScrollRange : Boolean;
      f_UnicodeChar         : WideString;
      f_NeedDocCalled       : Integer;
      f_View                : InevInputView;
      f_WasScroll           : Boolean;
      // - флаг сигнализирующий, что был скроллинг во время обработки движения мыши
      f_Pt                  : Tl3Point;
      f_sPt                 : Tl3SPoint;
      f_DoubleClickMoment   : TDateTime;
      f_AdjustingHeight     : Boolean;
      f_AutoHeightByText    : Boolean;
      f_DisableDragAndDropSupport: Boolean;
   private
    // event fields
      f_OnCursorChange      : TNotifyEvent;
      f_OnHistory           : TevHistoryEvent;
      f_OnParaChange        : TevParaChangeEvent;
      f_OnFontChange        : TevFontChangeEvent;
      f_OnSetCursor         : TevCursorEvent;
      f_OnStyleChange       : TevStyleChangeEvent;
      f_OnJumpTo            : TevJumpToEvent;
      f_OnGetMonikerSink    : TevGetMonikerSinkEvent;
      f_OnCursorInSelectionChange : TNotifyEvent;
      f_OnMouseAction             : TevMouseActionEvent;
      f_OnGetHotSpotInfo          : TevGetHotspotInfo;
      f_OnTextSourceChanged       : TNotifyEvent;
      f_OnCheckFocusedInPaint     : TevFocusedEvent;
      f_OnAfterFirstPaint         : TNotifyEvent;
      f_WasFirstPaint             : Boolean;
      f_OnCommentsVisibleChanged  : TNotifyEvent;
      f_OnShowDocumentPartsChanged : TNotifyEvent;
      f_SearchOptions              : TevSearchOptionSet;
      f_MakingTextSourceCounter: Integer;
      f_PreviewCaleeArea: TafwPreviewCaleeArea;
      f_OnMakeMacroReplacer: TevMakeHAFMacroReplacer;
      f_AfterAdjustHeight : TevAfterAdjustHeightEvent;
      f_OnFocusChanged : TNotifyEvent;
      {$IfDef Nemesis}
      f_OnZOrderChanging : TevOnZOrderChangingEvent;
      {$EndIf Nemesis}
    protected
    // interface methods
      {$IfNDef NoVCM}
      // IvcmState
      function  IvcmState_SaveState(out aState : IUnknown;
                                    aStateType : TvcmStateType): Boolean;
        virtual;
      function  IvcmState_LoadState(const aState : IUnknown;
                                    aStateType   : TvcmStateType;
                                    aClone: Boolean): Boolean;
        virtual;
        {-}
      function  IvcmState.SaveState = IvcmState_SaveState;
      function  IvcmState.LoadState = IvcmState_LoadState;
        {-}
      // IvcmCloneableState
      function  IvcmCloneableState_SaveState(out aState : IUnknown;
                                    aStateType : TvcmStateType): Boolean;
        virtual;
      function  IvcmCloneableState_LoadState(const aState : IUnknown;
                                    aStateType   : TvcmStateType): Boolean;
        virtual;
        {-}
      function  IvcmCloneableState.SaveStateForClone = IvcmCloneableState_SaveState;
      function  IvcmCloneableState.LoadCloneState = IvcmCloneableState_LoadState;
        {-}
      {$EndIf  NoVCM}  
      {$IfDef evNeedDisp}
      { Il3ActionControl }
      function  Get_ActionData(Action: Long): Long;
      procedure Set_ActionData(Action: Long; Value: Long);
        {-}
      {$EndIf evNeedDisp}
      // InevMetrics
      function  GetLimitWidth: Integer;
        override;
        {-}
      // InevViewArea
      procedure InvalidateShape(const aShape      : InevObject;
                                aParts : TnevShapeParts);
        {-}
      procedure Changed(aPlace: TnevChangePlace);
        {-}
      procedure DoChanged(aPlace: TnevChangePlace);
        override;
        {-}
      procedure pm_SetShowDocumentParts(Value: Boolean);
        {-}
      // InevControl
      function GetInClose: Boolean; override;
        {-}
      function  GetViewArea: InevViewArea;
        override;
        {-}
      function  GetData: InevObject;
        override;
        {-}
      function  GetProcessor: InevProcessor;
        override;
        {-}
      function  GetSelection: InevSelection;
        override;
        {-}
      // IevMarkerSpy
      procedure IevMarkerSpy.NotifyMarkerChange = DoMarkerChange;
        {-}
      procedure DoSetFlag(aFlag: TevUpdateWindowFlag);
        override;
        {-}
      // Il3CaretOwner
      procedure RedrawCaret;
        {-}
      procedure WasScroll;
        {-}
      function  DataCodePage: Integer;
        override;
        {-}
      procedure pm_SetAutoHeightByText(const Value: Boolean);
        {-}
      procedure pm_SetPreviewCaleeArea(const aValue: TafwPreviewCaleeArea);
        {-}
    protected
      // IevCursorSource
      function  GetCaret: Il3Caret;
        override;
        {-}
      function  GetHorzDelta: Integer;
        virtual;
        {- зазор, после которого начинается скроллирование вправо. }  
      procedure MakeView;
        {-}
      procedure MakeCursor;
        virtual;
        {-}
      procedure InitAACLikeCursor;
        {-}
      procedure DoMakeCursorHolder;
        {-}
      // IevHotSpotSink
      function MouseAction(const aHotSpot : IevHotSpot;
                           aButton        : TevMouseButton;
                           anAction       : TevMouseAction;
                           const Keys     : TevMouseState;
                           var Effect     : TevMouseEffect): Boolean;
        {-}
      // IevReplacer
      function  IevReplacer_pm_GetText: AnsiString;
        {-}
      function  IevReplacer_pm_GetOptions: TevSearchOptionSet;
      procedure IevReplacer_pm_SetOptions(Value: TevSearchOptionSet);
        {-}
      procedure IevReplacer_Start;
        {* - начало поиска. }
      procedure IevReplacer_Finish(aCancel: Boolean; const aBlock: InevRange);
        {* - конец поиска. }
      function  IevReplacer_Get_Searcher: IevSearcher;
      procedure IevReplacer_Set_Searcher(const aValue: IevSearcher);
        {-}
     function Get_ReplaceCount: Integer;
        {-}
      function  FakeReplace(const Container : InevOp;
                            const aBlock    : InevRange;
                            const aConfirm  : InevConfirm): Boolean;
        {-}
      function  IevReplacer_NeedProgress: Boolean;
        {-}
      function  IevReplacer.pm_GetText = IevReplacer_pm_GetText;
        {-}
      function  IevReplacer.pm_GetOptions = IevReplacer_pm_GetOptions;
      procedure IevReplacer.pm_SetOptions = IevReplacer_pm_SetOptions;
        {-}
      procedure IevReplacer.Start = IevReplacer_Start;
        {* - начало поиска. }
      procedure IevReplacer.Finish = IevReplacer_Finish;
        {* - конец поиска. }
      function  IevReplacer.Get_Searcher = IevReplacer_Get_Searcher;
      procedure IevReplacer.Set_Searcher = IevReplacer_Set_Searcher;
        {-}
      function  IevReplacer.Replace = FakeReplace;
        {-}
      function  IevReplacer.NeedProgress = IevReplacer_NeedProgress;
        {-}
      // InevConfirm
      function  ReplaceConfirm(const aBlock        : InevRange;
                               AlienReplaceConfirm : TevReplaceConfirmEvent): ShortInt;
        virtual;
        {-}
      function CheckAACMode(aCommand: Long; aForce: Boolean; aCount: Integer): Boolean;
        virtual;
        {-}
      property WasFirstPaint: Boolean
        read f_WasFirstPaint;
    public
     procedure AdjustHeightByText;
      {-}
     function  DeleteFoundRgn: Boolean;
      {-}
   {$IF not Defined(Archi) and not Defined(EverestLite)}
    // начался костыль для http://mdp.garant.ru/pages/viewpage.action?pageId=329646239
    private
      FInvalidateTimerK329646239: TTimer;
      procedure OnIvalidateTimerK329646239(ASender: TObject);
      procedure InvalidateByTimerK329646239;
    public
      procedure Invalidate; override;
    // закончился костыль для http://mdp.garant.ru/pages/viewpage.action?pageId=329646239
    {$IFEND}
    private
    // message handlers
      procedure WMEraseBkGnd(var Msg : TWMEraseBkGnd);
        message WM_ERASEBKGND;
        {-}
      procedure WMPaint(var Msg : TWMPaint);
        message WM_Paint;
        {-}
      procedure WMGetDlgCode(var Msg : TWMGetDlgCode);
        message WM_GETDLGCODE;
        {-}
      procedure WMChar(var Msg : TWMChar);
        message WM_CHAR;
        {-}
      procedure WMKeyDown(var Msg : TWMKeyDown);
        message CN_KEYDOWN;
        {-}
      procedure WMHScroll(var Msg: TWMHScroll);
        message WM_HSCROLL;
        {-}
      procedure WMVScroll(var Msg: TWMVScroll);
        message WM_VSCROLL;
        {-}
      procedure WMSetFocus(var Msg : TWMSetFocus);
        message WM_SETFOCUS;
        {-}
      procedure WMKillFocus(var Msg : TWMKillFocus);
        message WM_KILLFOCUS;
        {-}
      procedure WMSysKeyDown(var Msg : TWMSysKeyDown);
        message WM_SYSKEYDOWN;
        {-}
      procedure WMSetCursor(var Msg : TWMSetCursor);
        message WM_SETCURSOR;
        {-}
      procedure WMLButtonDown(var Msg : TWMLButtonDown);
        message WM_LBUTTONDOWN;
        {-}
      procedure WMLButtonDblClk(var Msg : TWMLButtonDblClk);
        message WM_LBUTTONDBLCLK;
        {-}
      procedure WMSize(var Msg: TWMSize);
        message WM_SIZE;
        {-}
      procedure evmsgNeedDoc(var Msg: TMessage);
        message ev_msgNeedDoc;
        {-}
      procedure WMMove(var Msg: TWMMove);
        message WM_Move;
        {-}
      procedure WMCut(var Msg: TMessage);
        message WM_Cut;
        {-}
      procedure WMCopy(var Msg: TMessage);
        message WM_Copy;
        {-}
      procedure WMPaste(var Msg: TMessage);
        message WM_Paste;
        {-}
      procedure WMClear(var Msg: TMessage);
        message WM_Clear;
        {-}
      procedure WMUndo(var Msg: TMessage);
        message WM_Undo;
        {-}
      procedure EMUndo(var Msg: TMessage);
        message EM_Undo;
        {-}
      procedure EMRedo(var Msg: TMessage);
        message EM_Redo;
        {-}
      procedure EMGetModify(var Msg: MemGetModify);
        message EM_GetModify;
        {-}
      procedure EMSetModify(var Msg: MemSetModify);
        message EM_SetModify;
        {-}
      procedure EMCanPaste(var Msg: TMessage);
        message EM_CanPaste;
        {-}
      procedure EMPasteSpecial(var Msg: TMessage);
        message EM_PasteSpecial;
        {-}
      procedure EMScrollCaret(var Msg: TMessage);
        message EM_ScrollCaret;
        {-}
      procedure EMSetReadOnly(var Msg: TEMSetReadOnly);
        message EM_SetReadOnly;
        {-}
     {$IfDef Nemesis}
      // http://mdp.garant.ru/pages/viewpage.action?pageId=488604061
      procedure WMWindowPosChanging(var Msg: TWMWindowPosChanging);
        message WM_WINDOWPOSCHANGING;
        {-}
     {$EndIf Nemesis}
    protected
    // event handlers
      procedure SetEditRect;
        virtual;
        {-}
      procedure DoScrollEvent;
        virtual;
        {-}
      procedure HScrollEvent(aSender          : TObject;
                             aScrollCode      : TScrollCode;
                             var theScrollPos : Integer);
        {* - событие для горизонтального скроллинга. }
      procedure VScrollEvent(aSender          : TObject;
                             aScrollCode      : TScrollCode;
                             var theScrollPos : Integer);
        {* - событие для вертикального  скроллинга. }
      procedure TextChange;
        virtual;
        {* - вызывается при смене текста. }  
      procedure ParaChange;
        virtual;
        {* - текущий параграф изменился. }
      procedure DoCursorChanged;
        override;
        {* - позиция курсора изменилась. }
      procedure DoMarkerChange;
        {-}
      procedure BlockChange;
        virtual;
        {* - изменилось выделение. }
      procedure DoDrawSub(aSubTarget : TObject;
                          const Canvas     : Il3Canvas;
                          const R          : Tl3Rect;
                          SubType          : Tl3Handle;
                          aSub       : TObject);
        override;
        {-}
      procedure DoHRulerSetMarker(Sender       : TObject;
                                  const Marker : IevMarker;
                                  Value        : Long);
        {-}
    protected
    // property methods
      procedure DoAfterSetZoom;
        override;
        {-}
      function  ProcessHotSpots: Boolean;
        virtual;
        {-}
      function  IsReadOnly: Boolean;
        virtual;
        {-}
      procedure SetSelectionFromHistory(aSelection       : TnevSelection;
                                        const aContainer : InevDocumentContainer);
        {-}
      procedure MouseDown(Button : TMouseButton;
                          Shift  : TShiftState;
                          X, Y   : Integer);
        override;
        {-}
      procedure MouseUp(Button : TMouseButton;
                        Shift  : TShiftState;
                        aX, aY : Integer);
        override;
        {-}
      procedure DoSignalScroll(aDeltaY   : Integer;
                               aNeedVert : Boolean);
        override;                       
        {-}
      function  GetLMargin: Long;
        override;
      procedure pm_SetLMargin(Value: TevPixel);
        {-}
      procedure pm_SetLeftIndentDelta(aValue: Long);
        {-}
      function  pm_GetModified: Boolean;
      procedure pm_SetModified(aValue: Boolean);
        {-}
      procedure pm_SetHiddenStyles(aValue: TevStandardStyles);
        {-}
      function  pm_GetShowComments: Boolean;
      procedure pm_SetShowComments(aValue: Boolean);
        {-}
      function  pm_GetShowVersionComments: Boolean;
      procedure pm_SetShowVersionComments(aValue: Boolean);
        {-}
      function  pm_GetShowUserComments: Boolean;
      procedure pm_SetShowUserComments(aValue: Boolean);
        {-}
      function pm_GetShowTechComments: Boolean;
      procedure pm_SetShowTechComments(aValue: Boolean);
        {-}
      procedure pm_SetHRuler(const aValue: IevRuler);
        {* - Устанавливает горизонтальную линейку. }
      procedure pm_SetVRuler(const aValue: IevRuler);
        {* - Устанавливает вертикальную линейку. }
      function  pm_GetDocument: InevParaList;
        {-}
      {$IfNDef DesignTimeLibrary}
      function  pm_GetTextPara: IedTextParagraph;
        {-}
      {$EndIf  DesignTimeLibrary}
      function  pm_GetHasSelection: Boolean;
        {-}
      function  pm_GetTextSource: TevCustomTextSource;
        virtual;
        
      procedure pm_SetTextSource(Value: TevCustomTextSource);
        virtual;
        {-}
      procedure pm_SetHScrollBar(Value: TvtScrollBar);
        {-}
      function  pm_GetVSubPanel: IevSubPanel;
      procedure pm_SetVSubPanel(const aValue: IevSubPanel);
        {-}
      function  pm_GetProcessor: InevProcessor;
        {-}
      function  pm_GetCurPara: Tl3Variant;
        {-}
      function  pm_GetLocked: Boolean;
        {-}
      function  pm_GetRange: IedRange;
        {-}
      function  pm_GetCurText: Tl3PCharLen;
        {* - Возвращает указатель на текст текущего параграфа. }
      function  pm_GetInsertMode: Boolean;
      procedure pm_SetInsertMode(Value: Boolean);
        {-}
      procedure pm_SetScrollStyle(Value: TScrollStyle);
        override;
        {* - Устанавливает какие ScrollBar'ы нужны. }
      procedure pm_SetExcludeSuper(const aValue: TevNormalSegLayerHandleSet);
      function Get_View: InevView;
      function  GetView: InevInputView;
        override;
        {-}
      function  pm_GetPlainText: Boolean;
        virtual;
      procedure pm_SetPlainText(aValue: Boolean);
        virtual;
        {-}
      function  LMarginStored: Boolean;
        {-}
    protected
    // internal methods
      procedure DoInitAACLikeCursor;
        virtual;
        {-}
      procedure DoAfterFirstPaint;
        {* - событие после первой отрисовки. }
      procedure DoCommentsVisibleChanged;
        {-}
      procedure CheckView(const anAnchor: InevBasePoint);
        {-}
      procedure MakeTextSource(out theTextSource: TevCustomTextSource);
        virtual;
        {-}
      procedure SetTextColor(const aCanvas: Il3Canvas);
        virtual;
        {-}
      procedure Paint(const aCanvas: Il3Canvas);
        override;
        {* - Отрисовка документа. }
      function DoDrawDocument(const aCanvas: Il3Canvas; out aMap: InevMap): Boolean;
        virtual;
        {* - Отрисовка документа. }
      procedure Resize;
       override;
        {-}
      function AllowDrawDocumentEdge: Boolean;
        virtual;
        {-}
      procedure Notification(AComponent: TComponent; Operation: TOperation);
        override;
        {-}
      procedure AfterOperation;
        virtual;
        {-}
      procedure DrawCaret(weNeedCheckPaint : Boolean);
        {-}
      function IsLastHistoryStep: Boolean;
        {* - проверки из истории. }
      function IsVScrollBarVisible: Boolean;
        {* - проверяет видимость вертикального скроллбара. }
    public
      function  DocumentFullHeight: Integer;
        {* - возвращает полную высоту документа. ОСТОРОЖНО: для вычисления используется виртуальная отрисовка, которая может быть достаточно медленной. }
      function HasTextSource: Boolean;
       {-}
    protected
      procedure DoAdjustHeightByText;
        {-}
      function  GetTopMargin: Integer;
        virtual;
        {-}
      function Get_AutoHideSelection: Boolean;
       {-}
      procedure ScrollInfoChange(aVert             : Boolean;
                                 const aScrollInfo : TScrollInfo;
                                 aPosChanged       : Boolean);
        virtual;
        {-}
      procedure SetVScrollRange;
        {* - устанавливает параметры вертикального ScrollBar'а. }
      procedure SetHScrollRange;
        {* - устанавливает параметры горизонтального ScrollBar'а. }
      function  SetVScrollPos(aPos: Integer): Boolean;
        {* - устанавливает позицию вертикального ScrollBar'а. }
      function  SetHScrollPos: Boolean;
        {* - устанавливает позицию горизонтального ScrollBar'а. }
      {Методы для работы с текстовм курсором}
      function  GetPaintSelection: InevRange;
        virtual;
        {-}
      function  ProcessCommandEx(Cmd     : Long;
                                 aForce  : Boolean;
                                 aSubCmd : Cardinal;
                                 aCount  : Integer): Boolean;
        virtual;
        {-process the specified command, return true if processed}
      function ProcessBottomRigth(aCommand: Long;
                                  aForce  : Boolean;
                                  aCount  : Integer): Boolean;
        {-}
      function  GetCommands: TafwCommands;
        override;
        {-}
      function  DoProcessCommand(Cmd    : Tl3OperationCode;
                                 aForce : Boolean;
                                 aCount : Integer): Boolean;
        override;
        {-}
    protected
    // event methods
      procedure DoCursorInSelectionChange;
        virtual;
        {* - изменилось свойство CursorInSelection. }
      procedure DoFontChange(const Font: Il3Font);
        virtual;
        {-}
      function  SetCursorToScreen(aCursor : TCursor): Boolean;
        {-}
      function  DoSetCursor(const aPt      : Tl3Point;
                            const aHotSpot : IevHotSpot): Boolean;
        virtual;
        {-}
      procedure DoStyleChange(const aStyle: IedStyle);
        virtual;
        {-}
      procedure StyleChangeEvent(const aStyle: IedStyle);
        {-}
      procedure DoLButtonDown(const aHotSpot : IevHotSpot;
                              const Keys     : TevMouseState;
                              aWasSelect     : Boolean);
        {-}
      function  SelectWhenUnfocused: Boolean;
        virtual;
        {-}
      procedure DoBeforeRMouseClick;
        virtual;
        {-}
      function  WrapLimit: Integer;
        {-}
      function  RightIndentMul: Integer;
        virtual;
        {-}
      function VScrollWidth(const anIC: Il3InfoCanvas): Integer; virtual; 
    private
    // private methods
      function  CheckBlockFont(aNow: Boolean): Boolean;
        {-}
      {$IfDef evNeedGetBlockFont}
      function  CheckBlockFontPrim(aNow: Boolean): Boolean;
        {-}
      {$EndIf evNeedGetBlockFont}
      function  CheckBlockStyle(aNow: Boolean): Boolean;
        {-}
      {$IfDef evNeedGetBlockStyle}
      function  CheckBlockStylePrim(aNow: Boolean): Boolean;
        {-}
      {$EndIf evNeedGetBlockStyle}
      function MakePreviewKey: TevPreviewCacheKey;
        {-}
    protected
    // internal methods
      function UpdateCursorFromHotSpotEx(anX, anY : Integer): Boolean;
      function UpdateCursorFromHotSpot: Boolean;
        {*- Обновить Курсор от Hotspot'а. Возвращает признак успешного обновления}
      procedure CheckCurStyle;
        {-}
      procedure CheckCurFont;
        {-}
      function  CheckCursorInSelection: Boolean;
        {-}
      procedure CreateWnd;
        override;
        {-}
      procedure WndProc(var Message: TMessage);
        override;
        {-}
      procedure ConvertInputChar(const aStr: Tl3PCharLen);
        {* - преобразует введенный символ. }
      function COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
      function  WantEnter: Boolean;
        virtual;
        {-}
      function  WantTab(aKeyPressed: Boolean = False): Boolean;
        virtual;
        {-}
      function DoGetAcceptableFormats: Tl3ClipboardFormats;
        override;
        {-}
      function  DoKeys2Effect(aKeys: Long): Long;
        override;
        {-}
      function DoDoDrop(aFormat       : Tl3ClipboardFormat;
                      const aMedium : Tl3StoragePlace;
                      var dwEffect  : Longint): Boolean;
        override;
        {-}
      function DoDoDragOver(const aData  : IDataObject;
                            const aPoint : TPoint): Boolean;
        override;
        {-}
      procedure FreeView;
        {-}
      procedure FreeCursor;
        {-}
      function  DoBreakPara(aDrawLines : Boolean; const anOp : InevOp): Boolean;
        virtual;
        {-}
      function  SelectionClass: RevSelection;
        virtual;
        {-}
      procedure DoUnselectAfterInsertData;
        virtual;
        {-}
      function GetMacroReplacer(const aTransit: IafwHAFMacroReplacer): IafwHAFMacroReplacer;
        {-}
      function GetDocumentPartByPoint(const aPoint: InevBasePoint): IevDocumentPart;
        override;
        {-}
    protected
    // interface methods
      // InevConfirm
      function Get_Progress: InevProgress;
        {-}
      // Il3ObjectWrap
      function  GetObject: TObject;
        {-}
      { Il3Lock }
      procedure Lock(const aLocker: IUnknown);
        {* - запретить отрисовку. }
      procedure Unlock(const aLocker: IUnknown);
        {* - разрешить отрисовку. }
      { IevMonikerSink }
      function JumpTo(anEffects : TafwJumpToEffects;
                      const aMoniker  : IevMoniker): Boolean;
        {* - перейти по адресу aMoniker. }
      function ObjectXOffset: Long;
        {-}
      // IevWindow
      procedure DoUpdateScrollRange(WhatUpdate: TafwScrollBars);
        override;
        {-}
      procedure CreateWindowHandle(const Params: TCreateParams);
        override;
        {-}
      function  HandledReadOnly(E: EevReadOnly): Boolean;
        virtual;
        {-}
      procedure DoContextPopup(aMousePos: TPoint; var Handled: Boolean);
        override;
        {-}
      {$IfNDef DesignTimeLibrary}
      procedure DoStyleTableChanged;
        override;
        {-}
      {$EndIf}
      procedure WebStyleChanged;
        override;
        {-}
      procedure Cleanup;
        override;
        {-}
    protected
    // protected properties
      property Processor: InevProcessor
        read pm_GetProcessor;
        {* - процессор команд редактора и Undo-буффераю }
    public
    // public methods
      constructor Create(AOwner: TComponent);
        override;
        {-}
      function  ScrollToCursor(const aCursor: InevBasePoint): Boolean;
        {-}
      function  CheckMouseUp(const aHotSpot : IevHotSpot;
                             const aState   : TevMouseState): Boolean;
        virtual;
        {-}
      procedure DoUpdateBlock;
        {-}
      procedure DoParaChange;
        override;
        {-}
      function  GetAvaliableFormats(out theFormats: Tl3ClipboardFormats): Boolean;
        {-}
      function  SetFoundBlock(const aBlock : InevRange;
                              aRC          : TevReplaceConfirmEvent = nil): ShortInt;
        {-}
      function  Preview(const aMacroReplacer: IafwHAFMacroReplacer = nil): IafwComplexDocumentPreview;
        {-}
      function  PreviewRange(const aRange: InevRange; const aMacroReplacer: IafwHAFMacroReplacer): IafwComplexDocumentPreview;
        {* - Делает штатное превью документа и в качестве выделения делает aRange }
      function  MakePreviewRangeAsDocument(const aRange: InevRange;
       const aMacroReplacer: IafwHAFMacroReplacer): IafwComplexDocumentPreview;
        {* - Делает превью aRange как документа }
      function  HotSpotClass: RevEditorWindowHotSpot;
        virtual;
        {-}
      function  TextCodePage(aCheckBlock: Boolean = false): Long;
        {-}
      function  InPara(ID                : Tk2Type;
                       out theParaCursor : InevBasePoint;
                       anExcludeType     : Tk2Type = nil): Boolean;
        overload;
        {* - курсор в параграфе который наследуется от типа ID? }
      function  InPara(ID            : Tk2Type;
                       anExcludeType : Tk2Type = nil): Boolean;
        overload;
        {* - курсор в параграфе который наследуется от типа ID?
           |* Пример использования метода InPara.
            !function TevCustomEditor.InTable: Boolean;
            !begin
            ! Result := InPara(k2_idTable);
            !end;
           |*
        }
      function  Find(const aSearcher : IevSearcher;
                     const aReplacer : IevReplacer;
                     anOptions       : TevSearchOptionSetEx): Boolean;
        {* - произвести поиск/замену. }
      procedure GotoTop;
        {* - перейти к началу текста. }
      function  GotoBottom: Boolean;
        {* - перейти к концу текста. }
      function  GotoPara(anID: Integer): Boolean;
        {-}
      function  ScrollToPara(anID: Integer): Boolean;
        {-}
      procedure GotoTag(const aTag: InevObject);
        {-}
      procedure Print(const aPrinter    : Il3Printer = nil;
                      aPrintSelection   : Boolean = false;
                      const aMacroReplacer: IafwHAFMacroReplacer = nil);
        {* - печать документа или его выделенного фрагмента. }
      procedure Cut;
        {* - удалить выделение с копированием его в буфер обмена. }
      procedure Copy;
        {* - скопировать выделение в буфер обмена. }
      procedure CopyRange(const aRange: InevRange);
        {-}
      function  CopyToClipboardEx(aFormat: Tl3ClipboardFormat; NeedAdd: Boolean = false): Boolean;
        {* - сохранить выделенный блок в буфер обмена в формате aFormat. }
      function  PasteFromClipboard(aFormat     : Tl3ClipboardFormat;
                                   const aData : IDataObject): Boolean;
        override;
        {* - вставить текст из буфера обмена в формате aFormat. }
      function  InsertData(aFormat : Tl3ClipboardFormat;
                           aData   : THandle): Boolean;
        {* - вставить данные из памяти в формате aFormat. }
      procedure InsertFrom(const aTextSource: InevTagReader);
        {* - вставить данные из другого источника текста. }
      procedure Select(aTarget: TevSelectTarget);
        {* - выделить текущее слово, строку, параграф etc. }
      function  ColumnLeft: Boolean;
        {* - переместиться на колонку влево. }
      function  ColumnRight: Boolean;
        {* - переместиться на колонку вправо. }
      function  Tabulate: Boolean;
        virtual;
        {* - эквивалетно нажатию Tab. }
      function  Untabulate: Boolean;
        virtual;
        {* - эквивалетно нажатию Shift-Tab. }
      function  StartOp(Op     : Long = 0;
                        DoLock : Boolean = true): InevOp;
        {* - начать операцию с кодом Op. }
      function  ScrollWindow(const aDelta: TafwSPoint): Boolean;
        overload;
        {-}
      function  ScrollWindow(const aDelta: TafwPoint): Boolean;
        overload;
        {* - скроллирует окно на aDelta. }
      function  Block2DataObject(const aBlock  : IevdDataObject;
                                 anInternal    : Boolean = false): IDataObject;
        {-}
      function  Data2DataObject(aData : THandle): IDataObject;
        {-}
      function  DoCloseQuery: Boolean;
        override;
        {-}
      function  MoveLeafCursor(anOp          : Long;
                               ApplyToParent : Boolean = false): Boolean;
        {* - переместить листьевой курсор. (см. evOp: ev_ocCharLeft, ev_ocCharRight etc.) }
      function  GetPtPoint(const aPt      : TafwPoint;
                            out theCursor : InevBasePoint): Boolean;
        {-}
      function  GetTopCursor(out theCursor: InevBasePoint): Boolean;
        {-}
      procedure Update;
        override;
        {-}
      function  HasDocument: Boolean;
        {-}
      function  GetHotspotOnPoint(const aPt      : TPoint;
                                  out theHotSpot : IevHotSpot;
                                  NeedStorePoint : Boolean): Boolean;
        {-}
      procedure DoHitTest(const aHotSpot : IevHotSpot;
                          const aState   : TafwCursorState;
                          var theInfo    : TafwCursorInfo);
        virtual;
        {-}
      function MakeExportFilters(aSelection: Boolean; aForExport : Boolean): Ik2TagGenerator;
        virtual;
        {-}
      function IsEmpty: Boolean;
        {-}
      function Paste: Boolean; override;
        {* - вставить из буфера обмена. }
    public
    // public properties
      property DisableDragAndDropSupport: Boolean
        read f_DisableDragAndDropSupport
        write f_DisableDragAndDropSupport
        default false;
      {-}
      property AutoHeightByText: Boolean
        read f_AutoHeightByText
        write pm_SetAutoHeightByText
        default false;
        {-}
      property Selection: TnevSelection
        read f_Cursor;
        {* - текущий курсор и выделение. }
      property PlainText: Boolean
        read pm_GetPlainText
        write pm_SetPlainText
        default false;
        {-}
      property Document: InevParaList
        read pm_GetDocument;
        {* - отображаемый документ. }
      property LMargin: TevPixel
        read pm_GetLMargin
        write pm_SetLMargin
        stored LMarginStored
        default def_LMargin;
        {* - левый отступ от окна до текста. }
      property LeftIndentDelta: TevPixel
        read f_LeftIndentDelta
        write pm_SetLeftIndentDelta
        default 0;
        {-}
      property HRuler: IevRuler
        read f_HRuler
        write pm_SetHRuler;
        {* - горизонтальная линейка. }
      property VRuler: IevRuler
        read f_VRuler
        write pm_SetVRuler;
        {* - вертикальная линейка. }
      {$IfNDef DesignTimeLibrary}
      property TextPara: IedTextParagraph
        read pm_GetTextPara;
        {* - текущий "текстовый" параграф. }
      {$EndIf  DesignTimeLibrary}
      property TextSource: TevCustomTextSource
        read pm_GetTextSource
        write pm_SetTextSource;
        {* - источник документа. }
      property HasSelection: Boolean
        read pm_GetHasSelection;
        {* - есть ли выделение? }
      property CursorInSelection: Boolean
        read f_CursorInSelection;
        {* - курсор в выделении? }
      property HScrollBar: TvtScrollBar
        read f_HScrollBar
        write pm_SetHScrollBar;
        {* - горизонтальный скроллбар. }
      property VSubPanel: IevSubPanel
        read pm_GetVSubPanel
        write pm_SetVSubPanel;
        {* - вертикальная панель для Sub'ов. }
      property CurPara: Tl3Variant
        read pm_GetCurPara;
        {* - текущий самый внутренний параграф. }
      property MousePos: TnevPoint
        read pm_GetMousePos;
        {-}
      property Locked: Boolean
        read pm_GetLocked;
        {* - запрещена ли перерисовка? }
      property Range: IedRange
        read pm_GetRange;
        {* - интерфейсный объект "выделение". }
      property CurText: Tl3PCharLen
        read pm_GetCurText;
        {* - текст текущего параграфа (см. CurPara). }
      property InsertMode: Boolean
        read pm_GetInsertMode
        write pm_SetInsertMode
        default true;
        {* - режим вставки? }
      property ScrollStyle
        default ssBoth;
        {* - какие ScrollBar'ы нужны. }
      property AutoHideSelection: Boolean
        read Get_AutoHideSelection
        write f_AutoHideSelection
        default defAutoHideSelection;
        {-}
      property View: InevInputView
        read pm_GetView;
        {-}
      property ShowDocumentParts: Boolean
        read pm_GetShowDocumentParts
        write pm_SetShowDocumentParts;
        {* - показывать ли блочную структуру документа. }
      property Modified: Boolean
        read pm_GetModified
        write pm_SetModified
        default false;
        {* - признак модификации документа после загрузки или сохранения. }
      property UpdateFlags: TevUpdateWindowFlags
        read fl_UpdateFlags;
        {-}
      property HiddenStyles: TevStandardStyles
        read f_HiddenStyles
        write pm_SetHiddenStyles;
        {-}
      property ExcludeSuper: TevNormalSegLayerHandleSet
        read f_ExcludeSuper
        write pm_SetExcludeSuper;
        {-}
      property ShowComments: Boolean
        read pm_GetShowComments
        write pm_SetShowComments;
        {-}
      property ShowVersionComments: Boolean
        read pm_GetShowVersionComments
        write pm_SetShowVersionComments;
        {-}
      property ShowUserComments: Boolean
        read pm_GetShowUserComments
        write pm_SetShowUserComments;
        {-}
      property ShowTechComments: Boolean
        read pm_GetShowTechComments
        write pm_SetShowTechComments;
        {-}
      property PreviewCaleeArea: TafwPreviewCaleeArea
        read f_PreviewCaleeArea
        write pm_SetPreviewCaleeArea;
        {-}
    public
    // public events
      property OnAfterFirstPaint: TNotifyEvent
        read f_OnAfterFirstPaint
        write f_OnAfterFirstPaint;
        {* - вызывается после первой отрисовки. }
      property OnCommentsVisibleChanged: TNotifyEvent
        read f_OnCommentsVisibleChanged
        write f_OnCommentsVisibleChanged;
        {* - Изменилась видимость комментариев (пользовательских или юридических). }
      property OnShowDocumentPartsChanged: TNotifyEvent
        read f_OnShowDocumentPartsChanged
        write f_OnShowDocumentPartsChanged;
        {* - Изменилась видимость границ блоков }
      property OnHistory: TevHistoryEvent
        read f_OnHistory
        write f_OnHistory;
        {* - получение свойств истории. }
      property OnParaChange: TevParaChangeEvent
        read f_OnParaChange
        write f_OnParaChange;
        {* - нотификация смены текущего параграфа. }
      property OnCursorChange: TNotifyEvent
        read f_OnCursorChange
        write f_OnCursorChange;
        {* - нотификация изменения положения курсора. }
      property OnFontChange: TevFontChangeEvent
        read f_OnFontChange
        write f_OnFontChange;
        {* - нотификация изменения текущего шрифта. }
      property OnSetCursor: TevCursorEvent
        read f_OnSetCursor
        write f_OnSetCursor;
        {* - событие для изменения формы курсора. }
      property OnStyleChange: TevStyleChangeEvent
        read f_OnStyleChange
        write f_OnStyleChange;
        {* - нотификация изменения текущего стиля. }
      property OnJumpTo: TevJumpToEvent
        read f_OnJumpTo
        write f_OnJumpTo;
        {* - событие для перехода по адресу. }
      property OnGetMonikerSink: TevGetMonikerSinkEvent
        read f_OnGetMonikerSink
        write f_OnGetMonikerSink;
        {* - событие для получения объекта для перехода по адресу. }
      property OnMouseAction: TevMouseActionEvent
        read f_OnMouseAction
        write f_OnMouseAction;
        {* - событие для обработки действий мышью. }
      property OnGetHotSpotInfo: TevGetHotspotInfo
        read f_OnGetHotSpotInfo
        write f_OnGetHotSpotInfo;
        {* - событие для получения информации о HotSpot'е. }
      property OnCursorInSelectionChange: TNotifyEvent
        read f_OnCursorInSelectionChange
        write f_OnCursorInSelectionChange;
        {* - изменение свойства - курсор в блоке или нет. }
      property OnTextSourceChanged: TNotifyEvent
        read f_OnTextSourceChanged
        write f_OnTextSourceChanged;
        {-}
      property OnCheckFocusedInPaint: TevFocusedEvent
        read f_OnCheckFocusedInPaint
        write f_OnCheckFocusedInPaint;
        {-}
      property OnMakeMacroReplacer: TevMakeHAFMacroReplacer
        read f_OnMakeMacroReplacer
        write f_OnMakeMacroReplacer;
      property AfterAdjustHeight: TevAfterAdjustHeightEvent
        read f_AfterAdjustHeight
        write f_AfterAdjustHeight;
      property OnFocusChanged: TNotifyEvent
        read f_OnFocusChanged
        write f_OnFocusChanged;
      {$IfDef Nemesis}
      property OnZOrderChanging: TevOnZOrderChangingEvent
        read f_OnZOrderChanging
        write f_OnZOrderChanging;
      {$EndIf Nemesis}
    published
    // published properties
      property Cursor
        default def_EditorCursor;
        {-}
  end;//TevCustomEditorWindow
  {* Базовый класс окон для отображения и редактирования содержимого документа из TextSource.
     Рекомендуется как предок для пользовательских окон редактирования со специфической
     функциональностью. }

implementation

uses
 l3ProcessMessagesManager,
  DateUtils,
  ActiveX,
  ComObj,
//  ExtCtrls,
  {$IFDEF Delphi7}
  Themes,
  UxTheme,
  {$ENDIF Delphi7}
  ovcCmd,

  l3Chars,
  l3Bits,
  l3Memory,
  //l3Wheel,
  l3Stream,
  l3Clipboard,
  l3String,
  l3InterfacesMisc,
  l3Math,
  l3BitmapDataObject,
  l3InterfaceList,
  l3CacheableBase,
  l3VirtualCanvas,
  l3StringEx,

  afwFacade,
  afwComplexDocumentPreview,

  k2Facade,
  k2Types,
  k2Except,
  k2Unknown,
  k2IUnknown_Const,
  k2NullTagImpl,

  {$IfDef evNeedDisp}
  evStandardActions,
  {$EndIf evNeedDisp}
  evBitmapReader,

  evRange,
  evDefaultContext,
  evHotSpotMisc,
  evCursorShapeMisc,
  evCursorTools,
  evStyleInterface,
  evCodePageAnalyzer,
  evParaTools,
  evParaDrawTools,
  evCustomFont,
  evLocation,
  evCursor,
  evEditorWindowTextSource,
  evSubWaiter,
  evHiddenFilter,
  evMarkersList,
  evTextParaTools,
  evAlignBySeparatorUtils,

  nevFacade,
  nevView,
  nevVirtualDrawView,
  nevRealTools,

  evFormats,

  TextPara_Const,
  Block_Const,
  Document_Const,
  Para_Const,
  LeafPara_Const,
  
  evSubImplementation
  ;

const
 cFormatFrameMul = 4;
 cCommentStyles = [-ev_saTxtComment, -ev_saContents];
 cVersionCommentStyles = [-ev_saVersionInfo];

{$IfNDef DesignTimeLibrary}

// class IevEditorWindow

type
  IevEditorWindow = class(Ik2Unknown)
    private
    {internal fields}
      f_EditorWindow : TevCustomEditorWindow;
    protected
    // property methods
      function Get_Processor: InevProcessor;
        {-}
    protected
    // internal methods
      procedure SetParam(Index: Long; Source: Tl3Variant);
        override;
        {-}
      function COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
    public
      constructor Create(anEditor : TevCustomEditorWindow);
        {-}
  end;//IevEditorWindow

// class IevEditorWindowFont

  IevEditorWindowFont = class(TevCustomFont)
    private
    // internal fields
      f_EditorWindow : IevEditorWindow;
    protected
    // property methods
      function  pm_GetpFont: InevFontPrim;
        {-}
    protected
    // internal methods
      procedure GetParam(Index: Long; TK: Tk2TypeKind; var Dest);
        override;
        {-}
      procedure SetParam(Index: Long; Source: Tl3Variant);
        override;
        {-}
      procedure Cleanup;
        override;
        {-}  
    public
    // public methods
      constructor Create(anOwner : IevEditorWindow);
        {-}
      class function Make(anOwner : IevEditorWindow): Il3Font;
        {-}
      procedure Assign2Font(const aFont: Il3Font);
        override;
        {-}
    public
    // public properties
      property pFont: InevFontPrim
        read pm_GetpFont;
        {-}
  end;//IevEditorWindowFont

  IevEditorWindowStylePrim = class(IevEditorWindow)
    protected
    // internal methods
      function  GetTagType: Tk2Type;
        override;
        {-}
  end;//IevEditorWindowStylePrim

  IevEditorWindowStyle = class(IevEditorWindowStylePrim, IedStyle)
    protected
    // internal methods
      function  pm_GetStyles: Il3Strings;
        {-}
      function GetStylesForBlock: Il3Strings;
       {-}       
      function  pm_GetID: Long;
      procedure pm_SetID(Value: Long);
        {-}
      function  pm_GetName: AnsiString;
        reintroduce;
      procedure pm_SetName(const Value: AnsiString);
        {-}
      procedure GetParam(Index: Long; TK: Tk2TypeKind; var Dest);
        override;
        {-}
      procedure SetParam(Index: Long; Source: Tl3Variant);
        override;
        {-}
    public
    // public methods
      class function Make(anOwner : TevCustomEditorWindow): IedStyle;
        {-}
  end;//IevEditorWindowStyle

  IevEditorWindowTextPara = class(IevEditorWindow, IedParagraphFormatting, IedTextParagraph)
    private
    // property fields
      {$IfDef evNeedMarkers}
      f_FirstIndentMarker : IevMarker;
      f_LeftIndentMarker  : IevMarker;
      {$EndIf evNeedMarkers}
    protected
    // property methods
      function  pm_GetVisible: Boolean;
      procedure pm_SetVisible(Value: Boolean);
        {-}
      function  pm_GetFormatting: IedParagraphFormatting;
        {-}
      function  pm_GetFont: Il3Font;
      procedure pm_SetFont(const Value: Il3Font);
        {-}
      function  pm_GetStyle: IedStyle;
        {-}
      {$IfDef evNeedMarkers}
      function  pm_GetFirstIndent: Long;
        {* - метод для чтения свойства FirstIndent. }
      procedure pm_SetFirstIndent(aValue: Long);
        {* - метод для записи свойства FirstIndent. }
      function  pm_GetLeftIndent: Long;
      procedure pm_SetLeftIndent(aValue: Long);
        {-}
      {$EndIf evNeedMarkers}
      function  pm_GetBullet: Long;
      procedure pm_SetBullet(aValue: Long);
        {-}
      function  pm_GetPrintFontSize: Integer;
      procedure pm_SetPrintFontSize(aValue: Integer);
        {-}
      function  Get_Frame: IedFrame;
      procedure Set_Frame(const Value: IedFrame);
        {-}
    protected
    // internal methods
      function  GetTagType: Tk2Type;
        override;
        {-}
      function COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
      function  pm_GetHorizontalAligment: TedHorizontalAligment;
      procedure pm_SetHorizontalAligment(Value: TedHorizontalAligment);
        {-}
      function pm_GetHasDecimalAligment: Boolean;
        {-}
      procedure GetParam(Index: Long; TK: Tk2TypeKind; var Dest);
        override;
        {-}
      procedure Cleanup;
        override;
        {-}
      {$IfDef evNeedMarkers}
      function  CheckMarker(aStyle        : TevParaMarkerStyle;
                            var theMarker : IevMarker): IevMarker;
        {-}
      function  GetMarkerValue(aStyle        : TevParaMarkerStyle;
                               var theMarker : IevMarker): Long;
      procedure SetMarkerValue(aStyle        : TevParaMarkerStyle;
                               var theMarker : IevMarker;
                               aValue        : Long);
        {-}
      {$EndIf evNeedMarkers}
    public
    // public methods
      class function Make(anOwner : TevCustomEditorWindow): IedTextParagraph;
        {-}
    public
    // public properties
      property Font: Il3Font
        read pm_GetFont
        write pm_SetFont;
        {* - шрифт параграфа. }
  end;//IevEditorWindowTextPara

// start class IevEditorWindow 

constructor IevEditorWindow.Create(anEditor : TevCustomEditorWindow);
  {-}
begin
 inherited Create;
 f_EditorWindow := anEditor;
end;

function IevEditorWindow.Get_Processor: InevProcessor;
  {-}
begin
 if (f_EditorWindow = nil) then
  Result := nil
 else
  Result := f_EditorWindow.Processor; 
end;
  
function IevEditorWindow.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  {override;}
  {-}
begin
 Result.SetOk;
 if IID.EQ(IedTextParagraph) then
  IedTextParagraph(Obj) := IevEditorWindowTextPara.Make(Self.f_EditorWindow)
 else
  Result := inherited COMQueryInterface(IID, Obj);
end;
  
procedure IevEditorWindow.SetParam(Index: Long; Source: Tl3Variant);
  {override;}
  {-}
begin
  f_EditorWindow.Selection.SetAtom(Index, Source);
end;

// start class IevEditorWindowFont 

procedure IevEditorWindowFont.Cleanup;
  //override;
  {-}
begin
 FreeAndNil(f_EditorWindow);
 inherited;
end;

constructor IevEditorWindowFont.Create(anOwner : IevEditorWindow);
  {-}
begin
 inherited Create;
 anOwner.SetRefTo(f_EditorWindow);
end;

class function IevEditorWindowFont.Make(anOwner : IevEditorWindow): Il3Font;
  {-}
var
 l_F : IevEditorWindowFont;  
begin
 l_F := Create(anOwner);
 try
  Result := l_F;
 finally
  l3Free(l_F);
 end;//try..finally
end;

procedure IevEditorWindowFont.GetParam(Index: Long; TK: Tk2TypeKind; var Dest);
  {override;}
  {-}
var
 L      : Long;
 l_Font : InevFontPrim;
begin
 l_Font := pFont;
 if (l_Font = nil) then
  NoParam(Index)
 else
 begin
  L := l_Font.GetParam(Index);
  if (L = k2_TransparentValue) then
   NoParam(Index);
  case TK of
   k2_tkInteger:
    Long(Dest) := L;
   k2_tkBool:
    Boolean(Dest) := Boolean(L);
   k2_tkObject:
    TObject(Dest) := TObject(L);
   else
    inherited GetParam(Index, TK, Dest);
  end;//case TK
 end;//l_Font = nil
end;

procedure IevEditorWindowFont.SetParam(Index: Long; Source: Tl3Variant);
  {override;}
  {-}
begin
 f_EditorWindow.SetParam(Index, Source);
 if f_EditorWindow.f_EditorWindow.CursorInSelection then
 begin
  if not f_EditorWindow.f_EditorWindow.CheckBlockFont(false) then
   Exit;
 end//CursorInSelection
 else
  f_EditorWindow.f_EditorWindow.CheckCurFont;
 f_EditorWindow.f_EditorWindow.DoFontChange(Self);
end;

function IevEditorWindowFont.pm_GetpFont: InevFontPrim;
  {-}
var
 l_InSel : Boolean;
begin
 l_InSel := f_EditorWindow.f_EditorWindow.CursorInSelection;
 if l_InSel AND (f_EditorWindow.f_EditorWindow.f_CurFont[l_InSel] = nil) then
  f_EditorWindow.f_EditorWindow.CheckBlockFont(true);
 Result := f_EditorWindow.f_EditorWindow.f_CurFont[l_InSel];
end;

procedure IevEditorWindowFont.Assign2Font(const aFont: Il3Font);
  {override;}
  {-}
var
 l_Font : InevFontPrim;
begin
 l_Font := pFont;
 if (l_Font <> nil) then
 begin
  Lock;
  try
   l_Font.Set2Font(aFont, false);
  finally
   Unlock;
  end;//try..finally
 end;//l_Font <> nil
end;

// start class IevEditorWindowStylePrim 

function IevEditorWindowStylePrim.GetTagType: Tk2Type;
  {override;}
  {-}
var
 l_Prop : Tk2CustomPropertyPrim;
begin
 Result := nil;
 if (f_EditorWindow.CurPara.TagType <> nil) then
  with Tk2Type(f_EditorWindow.CurPara.TagType) do
  begin
   l_Prop := Prop[k2_tiStyle];
   if (l_Prop = nil) then
    l_Prop := k2_typTextPara.Prop[k2_tiStyle];
   Result := Tk2Type(l_Prop.AtomType);
  end;//with f_EditorWindow.CurPara.TagType
end;

// start class IevEditorWindowStyle

class function IevEditorWindowStyle.Make(anOwner : TevCustomEditorWindow): IedStyle;
  {-}
var
 l_S : IevEditorWindowStyle;
begin
 l_S := Create(anOwner);
 try
  Result := l_S;
 finally
  l3Free(l_S);
 end;//try..finally
end;

function IevEditorWindowStyle.pm_GetStyles: Il3Strings;
  {-}
begin
 Result := TevStyleInterface.MakeList(GetTagType);
end;

function IevEditorWindowStyle.pm_GetID: Long;
  {-}
begin
 Result := GetLongParam(k2_tiHandle);
end;

procedure IevEditorWindowStyle.pm_SetID(Value: Long);
  {-}
begin
 SetParam(k2_tiStyle, Tk2Type(GetTagType).ValueTable.DRbyID[Value]);
end;

function IevEditorWindowStyle.pm_GetName: AnsiString;
  {-}
begin
 Result := GetStringParam(k2_tiName);
end;

procedure IevEditorWindowStyle.pm_SetName(const Value: AnsiString);
  {-}
begin
 SetParam(k2_tiStyle, Tk2Type(GetTagType).ValueTable.DRbyName[Value]);
end;

procedure IevEditorWindowStyle.GetParam(Index: Long; TK: Tk2TypeKind; var Dest);
  {override;}
  {-}
var
 l_St : Il3TagRef;
begin
 if (Index = k2_tiName) AND (TK = k2_tkObject) then
 begin
  l_St := f_EditorWindow.f_CurStyle[f_EditorWindow.CursorInSelection];
  if (l_St = nil) then
  begin
   l_St := Tl3NullTag.Instance;
   f_EditorWindow.f_CurStyle[f_EditorWindow.CursorInSelection] := l_St;
  end;//l_St = nil
  TObject(Dest) := l_St.AsObject
 end//Index = k2_tiName
 else
 if (Index = k2_tiHandle) AND (TK = k2_tkInteger) then
 begin
  with f_EditorWindow do
  begin
   if Locked AND (ev_uwfPara in fl_UpdateFlags) then
    CheckCurStyle;
   Long(Dest) := f_CurStyle[CursorInSelection].AsObject.IntA[k2_tiHandle];
  end;//with f_EditorWindow
 end//Index = k2_tiHandle..
 else
  NoParam(Index);
end;

procedure IevEditorWindowStyle.SetParam(Index: Long; Source: Tl3Variant);
  {override;}
  {-}
var
 TT   : Tk2Type;
 l_Op : InevOp;
begin
 if (Index = k2_tiStyle) then
 begin
  with f_EditorWindow do
  begin
   TT := GetTagType;
   if (TT = nil) then
    Exit;
   try
     f_CurStyle[CursorInSelection] := Source.AsRef;
   except
    on Ek2ConversionError do Exit;
   end;//try..except
   if f_CurStyle[CursorInSelection].AsObject.IsNull then
   begin
    Assert(false);
    f_CurStyle[CursorInSelection] := TT.ValueTable.Default.AsRef;
   end;//f_CurStyle[CursorInSelection].IsNull
    //f_CurStyle[CursorInSelection] := k2Tag(TT.ValueTable.Default);
   l_Op := StartOp;
   try
    if l_Op.DeleteMapped then
     Selection.SetAtom(k2_tiStyle, f_CurStyle[CursorInSelection].AsObject)
    else
    begin
     // - это напильник поменьше:
     //   http://mdp.garant.ru/pages/viewpage.action?pageId=90442149
     //   http://mdp.garant.ru/pages/viewpage.action?pageId=90440848
     l_Op.DeleteMapped := true;
     try
      Selection.SetAtom(k2_tiStyle, f_CurStyle[CursorInSelection].AsObject)
     finally
      l_Op.DeleteMapped := false;
     end;//try..finally
    end;//l_Op.DeleteMapped
   finally
    l_Op := nil;
   end;//try..finally
   DoStyleChange(Self);
  end;//with f_EditorWindow
 end//Index = k2_tiStyle..
 else
  NoParam(Index);
end;

// start class IevEditorWindowTextPara

class function IevEditorWindowTextPara.Make(anOwner : TevCustomEditorWindow): IedTextParagraph;
  {-}
var
 l_P : IevEditorWindowTextPara;
begin
 l_P := Create(anOwner);
 try
  Result := l_P;
 finally
  l3Free(l_P);
 end;//try..finally
end;

procedure IevEditorWindowTextPara.Cleanup;
  //override;
  {-}
begin
 {$IfDef evNeedMarkers}
 f_FirstIndentMarker := nil;
 f_LeftIndentMarker := nil;
 {$EndIf evNeedMarkers}
 inherited;
end;

function IevEditorWindowTextPara.pm_GetVisible: Boolean;
  {-}
begin
 try
  Result := GetBoolParam(k2_tiVisible);
 except
  on Ek2ParamNotDefined do Result := true;
 end;
end;

procedure IevEditorWindowTextPara.pm_SetVisible(Value: Boolean);
  {-}
begin
 SetBoolParam(k2_tiVisible, Value);
end;

function IevEditorWindowTextPara.pm_GetFormatting: IedParagraphFormatting;
  {-}
begin
 Result := Self;
end;

function IevEditorWindowTextPara.pm_GetFont: Il3Font;
  {-}
begin
 QueryInterface(Il3Font, Result);
end;

procedure IevEditorWindowTextPara.pm_SetFont(const Value: Il3Font);
  {-}
begin
 if (Value = nil) then
  SetParam(k2_tiFont, Tk2NullTagImpl.Instance)
 else
  Value.Assign2Font(Font);
end;

function IevEditorWindowTextPara.pm_GetStyle: IedStyle;
  {-}
begin
 QueryInterface(IedStyle, Result);
end;

{$IfDef evNeedMarkers}
function IevEditorWindowTextPara.CheckMarker(aStyle        : TevParaMarkerStyle;
                                             var theMarker : IevMarker): IevMarker;
  {-}

 function _CheckMarker(aMarker: PIUnknown; anIndex: Long): Boolean; 
 var
  l_Marker : IevMarker;
 begin//_CheckMarker
  l_Marker := aMarker^ As IevMarker;
  if (l_Marker.Style = aStyle) then
  begin
   theMarker := l_Marker;
   Result := false;
  end//l_Marker.Style = aStyle
  else
   Result := true;
 end;//_CheckMarker

var
 l_List : TevMarkersList;
begin
 if (theMarker = nil) then
 begin
  l_List := TevMarkersList.Make;
  try
   with f_EditorWindow do
    if (Selection <> nil) then
     with Selection do
      if (Cursor <> nil) then
       Cursor.MarkersSource.GetMarkers(View, l_List);
   l_List.IterateAllF(l3L2IA(@_CheckMarker));
  finally
   l3Free(l_List);
  end;//try..finally
 end;//theMarker = nil
 Result := theMarker;
end;

function IevEditorWindowTextPara.GetMarkerValue(aStyle        : TevParaMarkerStyle;
                                                var theMarker : IevMarker): Long;
  {-}
var
 l_Marker : IevMarker;
begin
 l_Marker := CheckMarker(aStyle, theMarker);
 if (l_Marker <> nil) then
  Result := l_Marker.ClientValue
 else
  Result := 0;
end;

procedure IevEditorWindowTextPara.SetMarkerValue(aStyle        : TevParaMarkerStyle;
                                                 var theMarker : IevMarker;
                                                 aValue        : Long);
  {-}
var
 l_Value  : Long;
 l_Marker : IevMarker;
begin
 l_Marker := CheckMarker(aStyle, theMarker);
 if (l_Marker <> nil) then
 begin
  with l_Marker do
   l_Value := Value + (Max(0, aValue) - ClientValue);
  f_EditorWindow.DoHRulerSetMarker(Self, l_Marker, l_Value);
 end;//l_Marker <> nil
end;
{$EndIf evNeedMarkers}

{$IfDef evNeedMarkers}
function IevEditorWindowTextPara.pm_GetFirstIndent: Long;
  {* - метод для чтения свойства FirstIndent. }
begin
 Result := GetMarkerValue(ev_pmsFirstIndent, f_FirstIndentMarker);
end;

procedure IevEditorWindowTextPara.pm_SetFirstIndent(aValue: Long);
  {* - метод для записи свойства FirstIndent. }
begin
 SetMarkerValue(ev_pmsFirstIndent, f_FirstIndentMarker, aValue);
end;

function IevEditorWindowTextPara.pm_GetLeftIndent: Long;
  {-}
begin
 Result := GetMarkerValue(ev_pmsLeftIndent, f_LeftIndentMarker);
end;

procedure IevEditorWindowTextPara.pm_SetLeftIndent(aValue: Long);
  {-}
begin
 SetMarkerValue(ev_pmsLeftIndent, f_LeftIndentMarker, aValue);
end;
{$EndIf evNeedMarkers}

function IevEditorWindowTextPara.pm_GetBullet: Long;
  {-}
begin
 Result := GetLongParam(k2_tiBullet);
end;

procedure IevEditorWindowTextPara.pm_SetBullet(aValue: Long);
  {-}
begin
 SetLongParam(k2_tiBullet, aValue);
end;

function IevEditorWindowTextPara.Get_Frame: IedFrame;
  {-}
begin
 Result := f_EditorWindow.Range.Paragraph.Frame;
end;

procedure IevEditorWindowTextPara.Set_Frame(const Value: IedFrame);
  {-}
begin
 Assert(false);
 //f_EditorWindow.Range.Paragraph.Frame := Value;
end;

function IevEditorWindowTextPara.GetTagType: Tk2Type;
  //override;
  {-}
begin
 Result := k2_typTextPara;
end;

function IevEditorWindowTextPara.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  {override;}
  {-}
begin
 Result.SetOk;
 if IID.EQ(IedStyle) then
  IedStyle(Obj) := IevEditorWindowStyle.Make(Self.f_EditorWindow)
 else
 if IID.EQ(Il3Font) then
  Il3Font(Obj) := IevEditorWindowFont.Make(Self)
 else
  Result := inherited COMQueryInterface(IID, Obj);
end;

function IevEditorWindowTextPara.pm_GetHorizontalAligment: TedHorizontalAligment;
  {-}
var
 IT : TevIndentType;
begin
 try
  IT := TevIndentType(GetLongParam(k2_tiJustification));
 except
  on Ek2ParamNotDefined do
   IT := ev_itNone;
 end;//try..except
 if (IT = ev_itNone) then
  Result := ed_halUndefined
 else
  Result := TedHorizontalAligment(Succ(Ord(IT)));
end;

procedure IevEditorWindowTextPara.pm_SetHorizontalAligment(Value: TedHorizontalAligment);
  {-}
begin
 if (Value <> ed_halUndefined) then
  SetLongParam(k2_tiJustification, Pred(Ord(Value)));
end;


function IevEditorWindowTextPara.pm_GetHasDecimalAligment: Boolean;
begin
 Result := evHasDecimalTabIndent(f_EditorWindow.CurPara);
end;

procedure IevEditorWindowTextPara.GetParam(Index: Long; TK: Tk2TypeKind; var Dest);
  {override;}
  {-}
var
 CP : Tl3Variant;
 A  : Tl3Variant;
begin
 CP := f_EditorWindow.CurPara;
 if not CP.IsValid then
  inherited GetParam(Index, TK, Dest)
 else
 begin
  A := CP.Attr[Index];
  if not A.IsNull then
  begin
   Case TK of
    k2_tkInteger:
     Long(Dest) := A.AsLong;
    k2_tkBool:
     Boolean(Dest) := A.AsBool;
    k2_tkObject:
     TObject(Dest) := A.AsObject;
    else
     inherited GetParam(Index, TK, Dest);
   end;//Case TK
  end//not A.IsNull
  else
   inherited GetParam(Index, TK, Dest);
 end;//not CP.IsValid
end;

function IevEditorWindowTextPara.pm_GetPrintFontSize: Integer;
begin
 Result := GetLongParam(k2_tiPrintFontSize );
end;

procedure IevEditorWindowTextPara.pm_SetPrintFontSize(aValue: Integer);
begin
 SetLongParam(k2_tiPrintFontSize, aValue);
end;

{$EndIf DesignTimeLibrary}

// class TevCustomEditorWindow 

constructor TevCustomEditorWindow.Create(AOwner: TComponent);
begin
 inherited;
 //DoubleBuffered := true;
 // - выключил т.к. курсор при скроллинге мажет
 Width := 185;
 Height := 89;
 ControlStyle := ControlStyle + [{csFramed,} csOpaque, csDoubleClicks];
 ControlStyle := ControlStyle - [csCaptureMouse];
 ScrollStyle := ssBoth;
 TabStop := def_TabStop;
 DoMakeCursorHolder;
 Cursor := def_EditorCursor;
 f_CursorFromHistory := False;
 AutoHideSelection := defAutoHideSelection;
 {$IfDef evNeedDisp}
 with evOperationDispatcher do
 begin
  IncludeOperations([ev_ccZoom]);
  AddControl(ev_ccZoom, Self);
 end;//with evOperationDispatcher
 {$endIf evNeedDisp}
end;

function TevCustomEditorWindow.SetFoundBlock(const aBlock : InevRange;
                                             aRC          : TevReplaceConfirmEvent = nil): ShortInt;
  {-}

 procedure DoConfirm;
 begin//DoConfirm
  if Assigned(Selection) then
  begin
   Selection.Show;
   Selection.FoundBlock := aBlock;
   if Assigned(aRC) then
    Result := aRC(Self, aBlock);
  end;//Assigned(Selection)
 end;//DoConfirm

begin
 DeleteFoundRgn;
 if not Assigned(aRC) then
  Result := mrYes
 else
  Result := mrNo;
 if Locked then
 begin
  if ForceRepaint then
   DoConfirm
  else
  begin
   try
    ForceRepaint := true;
    DoConfirm;
   finally
    ForceRepaint := false;
   end;{try..finally}
  end;//ForceRepaint
 end//Locked
 else
  DoConfirm;
end;

function TevCustomEditorWindow.MakePreviewRangeAsDocument(const aRange: InevRange;
 const aMacroReplacer: IafwHAFMacroReplacer): IafwComplexDocumentPreview;
begin
 if HasDocument then
 begin
  if (TextSource.DocumentContainer <> nil) then
   with TextSource, DocumentContainer do
   begin
    Result := Preview(MakePreviewKey, GetMacroReplacer(aMacroReplacer), aRange, False);
    if (Result <> nil) then
     Result.Document.SetCurrentPage(nil);
   end;
 end//HasDocument
 else
  Result := nil;
end;

function TevCustomEditorWindow.PreviewRange(const aRange: InevRange; const aMacroReplacer: IafwHAFMacroReplacer): IafwComplexDocumentPreview;
var
 l_Cursor : InevBasePoint;
begin
 if HasDocument then
 begin
  if (TextSource.DocumentContainer <> nil) then
   with TextSource, DocumentContainer do
   begin
    Result := Preview(MakePreviewKey, GetMacroReplacer(aMacroReplacer), aRange, true);
    if (Result <> nil) then
    begin
     if (Selection = nil) then
      l_Cursor := nil
     else //Selection = nil
     begin
      // если курсор на экране, то текущую страницу будем определять по нему,
      // а не по верхнему обрезу
      l_Cursor := Selection.Cursor;
      if (l_Cursor <> nil) then
      begin
       if (View = nil) OR not View.IsCaretVisible then
        l_Cursor := nil;
      end;//l_Cursor <> nil
     end;//Selection = nil

     if (Result.Document <> nil) then
     begin
      if l_Cursor = nil then
       GetTopCursor(l_Cursor);
      if l_Cursor <> nil then
       Result.Document.SetCurrentPage(evFindNumberedPara(l_Cursor.MostInner.Obj.AsPara));
     end;//Result.Document <> nil
    end;//Result <> nil
   end//with TextSource.DocumentContainer
  else
   Result := nil;
 end//HasDocument
 else
  Result := nil;
end;

function TevCustomEditorWindow.Preview(const aMacroReplacer: IafwHAFMacroReplacer = nil): IafwComplexDocumentPreview;
  {-}
var
 l_Range: InevRange;
 l_SSel: InevRange;
begin
 if (Selection <> nil) and not Selection.Collapsed then
 begin
  l_Range := InevSelection(Selection).GetBlock;
  if Supports(l_Range.Data, InevRange, l_SSel) and l_SSel.Solid(View) then
   l_Range := nil;
 end//Selection <> nil
 else
  l_Range := nil;
 Result := PreviewRange(l_Range, GetMacroReplacer(aMacroReplacer));
end;

function TevCustomEditorWindow.HotSpotClass: RevEditorWindowHotSpot;
  //virtual;
  {-}
begin
 Result := TevEditorWindowHotSpot;
end;

function TevCustomEditorWindow.SelectionClass: RevSelection;
  //virtual;
  {-}
begin
 Result := TnevSelection;
end;

procedure TevCustomEditorWindow.DoMakeCursorHolder;
  {-}
begin
 MakeView;
 Assert(f_InPaint <= 0);
 FreeCanvas;
 f_Cursor := SelectionClass.Create(f_View, Self);
 if Focused then
  f_Cursor.SetFocus;
end;
  
procedure TevCustomEditorWindow.Cleanup;
  {-}
begin
 FreeView;
 DeleteFoundRgn;
 {$IfDef evNeedDisp}
 evOperationDispatcher.RemoveControl(ev_ccZoom, Self);
 {$EndIf evNeedDisp}
 f_CurStyle[True] := nil;
 f_CurStyle[False] := nil;
 f_CurFont[True] := nil;
 f_CurFont[False] := nil;
 f_CursorFromHistory := False;
 FreeCursor;
 //Redirect := nil;
 f_Document := nil;
 TextSource := nil;
 {$IF not Defined(Archi) and not Defined(EverestLite)}
 FreeAndNil(FInvalidateTimerK329646239);
 {$IFEND}
 inherited;
end;

procedure TevCustomEditorWindow.FreeView;
  {-}
begin
 if (f_View <> nil) then
  f_View.UnlinkControl(Self);
 f_View := nil;
 f_Document := nil;
 //Redirect := nil;
end;
  
procedure TevCustomEditorWindow.FreeCursor;
  {-}
var
 l_Exit : Boolean;
 l_HasCursor: Boolean;
begin
 l_Exit := false;
 if (f_Cursor <> nil) then
 begin
  {$IfNDef DesignTimeLibrary}
  Use;
  // - это чтобы не потерять последнюю ссылку - т.к. f_Cursor.Owner := nil может
  //   ее отпустить.
  {$EndIf DesignTimeLibrary}
  try
   f_Cursor.Caret.Owner := nil;
  finally
   {$IfNDef DesignTimeLibrary}
   l_Exit := (Free = nil);
   // - нас убили - ничего дальше делать нельзя.
   {$EndIf  DesignTimeLibrary}
  end;//try..finally
 end;//f_Cursor <> nil
 if not l_Exit then
 begin
  Assert(f_InPaint <= 0);
  FreeCanvas;
  l_HasCursor := Assigned(f_Cursor);
  if (f_Cursor <> nil) then
   f_Cursor.ForceStore;
  l3Free(f_Cursor);
  FreeView;
  if l_HasCursor then
   Invalidate;
  // - чтобы перерисовать пустое окно
 end;//not l_Exit
end;

function TevCustomEditorWindow.GetPtPoint(const aPt      : TafwPoint;
                                          out theCursor : InevBasePoint): Boolean;
  {-}
begin
 if (View <> nil) then
  theCursor := View.PointByPt(aPt)
 else
  theCursor := nil;
 Result := (theCursor <> nil);
end;

function TevCustomEditorWindow.GetTopCursor(out theCursor: InevBasePoint): Boolean;
  {-}
begin
 Result := false;
 if Document.AsObject.IsValid AND (View <> nil) then
 begin
(*  theCursor := View.TopAnchor.ClonePoint(View);
  Result := (theCursor <> nil);*)
  // - так к сожалению нельзя, т.к. TeeEditorExport.GetNearestBlockByCursor не будет работать,
  //   т.к. у якоря метод Move - фиктивный
  theCursor := Document.MakePoint;
  if (theCursor <> nil) then
  begin
   theCursor.AssignPoint(View, View.TopAnchor);
   Result := true;
  end;//theCursor <> nil
 end;//Document.IsValid
end;

{$IfNDef DesignTimeLibrary}
function  TevCustomEditorWindow.pm_GetTextPara: IedTextParagraph;
  {-}
var
 l_Factory : IevEditorWindow;
begin
 l_Factory := IevEditorWindow.Create(Self);
 try
  l_Factory.QueryInterface(IedTextParagraph, Result);
 finally
  l3Free(l_Factory);
 end;{try..finally}
end;
{$EndIf  DesignTimeLibrary}

function TevCustomEditorWindow.pm_GetHasSelection: Boolean;
  {-}
begin
 if (f_Cursor <> nil) then
  Result := not f_Cursor.Collapsed
 else
  Result := false;
end;

procedure TevCustomEditorWindow.MakeTextSource(out theTextSource: TevCustomTextSource);
  //virtual;
  {-}
begin
 theTextSource := nil;
end;

function  TevCustomEditorWindow.pm_GetTextSource: TevCustomTextSource;
  //virtual;
  {-}
begin
 Result := f_TextSource;
 if (Result = nil) AND
    not (csDestroying in ComponentState) then
 begin
  inc(f_MakingTextSourceCounter);
  try
   MakeTextSource(Result);
  finally
   Dec(f_MakingTextSourceCounter)
  end;
  TextSource := Result;
 end;//Result = nil
end;

procedure TevCustomEditorWindow.pm_SetTextSource(Value: TevCustomTextSource);
  {-}
begin
 if (f_TextSource <> Value) then
 begin
  f_WasFirstPaint := False;
  f_NeedDocCalled := 0;
  if (f_TextSource <> nil) then
   f_TextSource.UnlinkEditor(Self);
  f_TextSource := Value;
  //////////////////////////////////////////////////////////////////////////////
  // Когда в Cleanup выполняют код TextSource := nil, то действия ниже        //
  // являются лишними                                                         //
  //////////////////////////////////////////////////////////////////////////////
  if csDestroying in ComponentState then
   Exit;
  //////////////////////////////////////////////////////////////////////////////
  if (f_TextSource <> nil) then
   f_TextSource.LinkEditor(Self);
  if Assigned(f_OnTextSourceChanged) then
   f_OnTextSourceChanged(Self);
  UpdateScrollRange(afw_sbBoth);
  MakeCursor;
  Invalidate;
 end;//f_TextSource <> Value
end;

function TevCustomEditorWindow.Get_Progress: InevProgress;
  {-}
begin
 Result := TextSource;
end;
  
function TevCustomEditorWindow.GetObject: TObject;
  {-}
begin
 Result := Self;
end;

procedure TevCustomEditorWindow.Lock(const aLocker: IUnknown);
  {-}
begin
 if (f_Cursor <> nil) then
  f_Cursor.Lock;
 if not l3IEQ(aLocker, TextSource) then
  TextSource.Lock(aLocker);
end;

procedure TevCustomEditorWindow.Unlock(const aLocker: IUnknown);
  {-}
var
 l_NeedUpdateBlock : Boolean;
 l_ClearCursor     : Boolean;
begin
 if not l3IEQ(aLocker, TextSource) then
  TextSource.Unlock(aLocker);
 if (f_Cursor <> nil) then
  f_Cursor.Unlock;
 if not Locked then
 begin
  if (ev_uwfText in fl_UpdateFlags) then
  begin
   Exclude(fl_UpdateFlags, ev_uwfText);
   if f_MakingTextSourceCounter = 0 then
    TextChange;
  end;//ev_uwfText in fl_UpdateFlags
  if (f_View <> nil) AND not f_View.InMakeCaretVisible then
  begin
   if f_NeedInvalidate then
   begin
    f_NeedInvalidate := false;
    Invalidate;
   end;//f_NeedInvalidate
   l_NeedUpdateBlock := (ev_uwfBlock in fl_UpdateFlags);
   l_ClearCursor := (ev_uwfCursor in fl_UpdateFlags);
   if not l_ClearCursor then
    l_ClearCursor := (Selection <> nil) AND (Selection.Cursor <> nil) AND
                     not Selection.Cursor.MostInner.NeedWindowsCaret;
   Update;
   l_ClearCursor := l_ClearCursor AND not (ev_uwfCursor in fl_UpdateFlags);
   if (ev_uwfPara in fl_UpdateFlags) then
    DoParaChange;
   if (ev_uwfRuler in fl_UpdateFlags) then
    DoMarkerChange;
   if l_NeedUpdateBlock then
    DoUpdateBlock;
   if l_ClearCursor then
    Exclude(fl_UpdateFlags, ev_uwfCursor);
    // - очищаем флаг перерисовки курсора, т.к. он уже перерисовался
  end;//(f_View <> nil) AND not f_View.InMakeCaretVisible
 end;//not Locked
end;

function TevCustomEditorWindow.JumpTo(anEffects : TafwJumpToEffects;
                                      const aMoniker  : IevMoniker): Boolean;
  {-}

 procedure _GotoSub(anID: Long);
 begin//_GotoSub
  TextSource.DocumentContainer.SubList.Sub[anID].Select(Selection);
  Result := true;
 end;//_GotoSub

var
 l_MonikerSink    : IevMonikerSink;
 l_AddressMoniker : IevAddressMoniker;
begin
 Result := false;
 if Assigned(f_OnGetMonikerSink) AND OnGetMonikerSink(Self, l_MonikerSink) then
  try
   Result := l_MonikerSink.JumpTo(anEffects, aMoniker);
  finally
   l_MonikerSink := nil;
  end;{try..finally}
 if not Result and Assigned(f_OnJumpTo) then
  Result := f_OnJumpTo(Self, anEffects, aMoniker);
 if not Result then
 begin
  if Supports(aMoniker, IevAddressMoniker, l_AddressMoniker) then
   try
    with l_AddressMoniker.Address{$IfDef XE4}.rTafwAddress{$EndIf} do
    begin
     if (DocID = 0) then
      _GotoSub(SubID)
     else
     with Document do
     begin
      with AsObject.Attr[k2_tiExternalHandle] do
       if IsValid then
       begin
        if (AsLong = DocID) then
         _GotoSub(SubID)
        else
         Exit;
       end;//IsValid
      with AsObject.Attr[k2_tiInternalHandle] do
       if IsValid then
       begin
        if (AsLong = DocID) then
         _GotoSub(SubID);
       end;//IsValid
     end;//with Document
    end;//with l_AddressMoniker
   finally
    l_AddressMoniker := nil;
   end;//try..finally
 end;//not Result
end;

function TevCustomEditorWindow.ObjectXOffset: Long;
  {-}
begin
 Result := - Document.AsObject.IntA[k2_tiLeftIndent];
end;

procedure TevCustomEditorWindow.DoUpdateScrollRange(WhatUpdate: TafwScrollBars);
  //override;
  {-}
begin
 if Locked OR not HandleAllocated then
  f_NeedUpdateRange := true
 else
 begin
  if GetInClose then Exit;
  if (afw_sbHorz in WhatUpdate) then
   SetHScrollRange;
  if (afw_sbVert in WhatUpdate) then
   SetVScrollRange;
  f_NeedUpdateRange := false;
 end;//HandleAllocated
 if (afw_sbVert in WhatUpdate) then
  AdjustHeightByText;
end;

function TevCustomEditorWindow.ScrollToCursor(const aCursor: InevBasePoint): Boolean;
  {-}
begin
 Result := false;
 if (aCursor <> nil) then
  if (View <> nil) then
  begin
   Result := true;
   View.TopAnchor.AssignPoint(View, aCursor);
  end;//View <> nil
end;

function TevCustomEditorWindow.TextCodePage(aCheckBlock: Boolean = false): Long;
  {-}
var
 l_CPA : TevCodePageAnalyzer;
begin
 if HasDocument AND (Selection <> nil) AND (Selection.Cursor <> nil) then
 begin
  l_CPA := TevCodePageAnalyzer.Create;
  try
   try
    if aCheckBlock then
     Find(l_CPA, nil, [ev_soGlobal, ev_soSelText, ev_soUseInternalCursor, ev_soNoProgress])
    else
     Find(l_CPA, nil, [ev_soGlobal, ev_soUseInternalCursor, ev_soNoProgress]);
   except
    on EevSearchFailed do ;
   end;//try..except
   case l_CPA.CodePage of
    CP_DefaultValue :
     Result := CP_ANSI;
    CP_Unicode :
     Result := CP_Unicode;
    else
     Result := l_CPA.CodePage;
   end;//case l_CPA.CodePage
  finally
   l3Free(l_CPA);
  end;//try..finally
 end//HasDocument
 else
  Result := CP_ANSI;
end;

function TevCustomEditorWindow.InPara(ID                : Tk2Type;
                                      out theParaCursor : InevBasePoint;
                                      anExcludeType     : Tk2Type = nil): Boolean;
  //overload;
  {* - курсор в параграфе который наследуется от типа ID? }
begin
 if (Selection = nil) then
 begin
  Result := false;
  theParaCursor := nil;
 end
 else
  Result := evInPara(Selection.Cursor, ID, theParaCursor, anExcludeType);
end;

function TevCustomEditorWindow.InPara(ID            : Tk2Type;
                                      anExcludeType : Tk2Type = nil): Boolean;
  //overload;
  {-}
begin
 if (Selection = nil) then
  Result := false
 else
  Result := evInPara(Selection.Cursor, ID, anExcludeType);
end;

function TevCustomEditorWindow.Find(const aSearcher : IevSearcher;
                                     const aReplacer : IevReplacer;
                                     anOptions       : TevSearchOptionSetEx): Boolean;
  {-}
var
 l_Block          : InevRange;
 l_Pack           : InevOp;
 l_Cancel         : Boolean;
 l_Cursor         : InevBasePoint;
 l_Start          : InevBasePoint;
 l_Finish         : InevBasePoint;
 l_Replacer       : IevReplacer;
 l_Global         : Boolean;
 l_PrevAnchor     : InevBasePoint;
 l_PrevSearcher   : IevSearcher;
// l_SaveBlock      : InevLocation;
 l_PrevFoundBlock : InevRange;
begin
 Result := false;
 Assert(Selection <> nil);
 Assert(Selection.Cursor <> nil);
 if Assigned(Selection.FoundBlock) then
  l_PrevFoundBlock := Selection.FoundBlock.CloneSel(View)
 else
  l_PrevFoundBlock := nil;
 Selection.DeleteFoundBlockBeforeSearch;
 if (aSearcher <> nil) AND Document.AsObject.IsValid AND (Selection <> nil) then
 begin
  {
  if Selection.Persistent then
   l_SaveBlock := nil
  else
   l_SaveBlock := Selection.SaveBlock;
  if Assigned(l_PrevFoundBlock) then
   Selection.AssignSel(l_PrevFoundBlock);
  }
  try
   f_SearchOptions := anOptions;
   aSearcher.Options := anOptions;
   if (aReplacer <> nil) then
   begin
    aReplacer.Options := anOptions;
    l_PrevSearcher := aReplacer.Searcher;
   end//aReplacer <> nil
   else
    l_PrevSearcher := nil;
   if (aReplacer <> nil) AND ([ev_soReplace, ev_soReplaceAll] * anOptions <> []) then
    l_Replacer := aReplacer
   else
    l_Replacer := Self;
   try
    if (aReplacer <> nil) then
     aReplacer.Searcher := aSearcher;
    l_Cancel := false;
    l_Pack := StartOp(ev_msgSearch);
    try
     try
      l_Global := (ev_soGlobal in anOptions);
      if (ev_soDocumentPart in anOptions) AND
         InPara(k2_typBlock, l_Cursor, k2_typDocument) then
       l_Block := l_Cursor.Obj.SubRange(View, 0, High(Long))
      else
      if (ev_soSelText in anOptions) and (HasSelection or (l_PrevFoundBlock <> nil)) then
      begin
       if HasSelection then
       begin
        l_Block := InevSelection(Selection).GetBlock;
        l_Cursor := Selection.Cursor;
       end
       else
       begin
        l_Block := l_PrevFoundBlock.CloneSel(View);
        l_Block.GetBorderPoints(l_Start, l_Finish);
        l_Cursor := Selection.Cursor;
        l_Cursor.AssignPoint(View, l_Finish);
       end;
      end//ev_soSelText in anOptions
      else
      begin
       if l_Global then
       begin
        if not (ev_soUseInternalCursor in anOptions) then
        begin
         if (ev_soBackward in anOptions) then
          GotoBottom
         else
          GotoTop;
        end;//not (ev_soUseInternalCursor in anOptions)
        l_Global := false;
       end;//l_Global
       l_Block := Document.Range;
       with Selection do
       begin
        if (ev_soUseInternalCursor in anOptions) then
         l_Cursor := Cursor.Obj.MakePoint
        else
         if ([ev_soInPageUp, ev_soInPageDown] * anOptions) <> [] then
          l_Cursor := Cursor.ClonePoint(View)
         else
          l_Cursor := Cursor;
        // Если ищем от курсора и курсор в последнем найденном блоке,
        // то подправим курсор от последнего найденного блока
        if not (ev_soGlobal in anOptions) and Assigned(l_PrevFoundBlock) AND
           not l_PrevFoundBlock.Collapsed(View) AND l_PrevFoundBlock.Contains(View, l_Cursor) then
        begin
         if (l_Pack <> nil) then
          (l_Pack As IevCursorContext).RecordCursor(l_Cursor);
         l_PrevFoundBlock.GetBorderPoints(l_Start, l_Finish);
         if (ev_soBackward in anOptions) then
          l_Cursor.AssignPoint(View, l_Start)
         else
          l_Cursor.AssignPoint(View, l_Finish);
        end;//not Persistent..
       end;//with Selection
      end;//(ev_soSelText in anOptions) AND HasSelection
      try
       if l_Global then
       begin
        l_Block.GetBorderPoints(l_Start, l_Finish);
        if (ev_soBackward in anOptions) then
         l_Cursor.AssignPoint(View, l_Finish)
        else
         l_Cursor.AssignPoint(View, l_Start);
       end;//l_Global
       aSearcher.Start;
       try
        l_Replacer.Start;
        try
         l_Cancel := l_Block.SearchReplace(aSearcher,
                                           l_Replacer,
                                           Self,
                                           l_Cursor,
                                           l_Pack,
                                           not (ev_soNoProgress in anOptions));
         if l_Cancel then
         begin
          if (ev_soInPageDown in anOptions) then
          begin
           l_PrevAnchor := View.TopAnchor;
           Result := l_PrevAnchor.Diff(View, l_Cursor, View.FormatInfoByPoint(l_PrevAnchor)) <= 0;
           if Result then
            Selection.Cursor.AssignPoint(View, l_Cursor);
          end // if (ev_soInPageDown in anOptions) then
          else
          if (ev_soInPageUp in anOptions) then
          begin
           l_PrevAnchor := View.BottomAnchor(True);
           if l_PrevAnchor = nil then
            Result := True
           else
            Result := l_PrevAnchor.Diff(View, l_Cursor, View.FormatInfoByPoint(l_PrevAnchor)) >= 0;
           if Result then
            Selection.Cursor.AssignPoint(View, l_Cursor);
          end // if (ev_soInPageUp in anOptions) then
          else
           Result := true;
         end; // if l_Cancel then
        finally
         l_Replacer.Finish(l_Cancel, l_Block);
        end;//try..finally
       finally
        aSearcher.Finish(l_Cancel, l_Block);
       end;//try..finally
      finally
       l_Block := nil;
      end;//try..finally
     except
      on EevSearchFailed do
      begin
       if (ev_soGlobal in anOptions) AND not (ev_soUseInternalCursor in anOptions) then
        l_Pack.Undo(Processor);
       Selection.FoundBlock := l_PrevFoundBlock;
       Result := false;
       raise;
      end;//on EevSearchFailed
     end;//try..except
    finally
     l_Pack := nil;
    end;//try..finally
   finally
    if (aReplacer <> nil) then
     aReplacer.Searcher := l_PrevSearcher;
   end;//try..finally
  finally
   {
   try
    if (l_SaveBlock <> nil) AND (l_SaveBlock.Range <> nil) then
     Selection.AssignSel(l_SaveBlock.Range);
   finally
    l_SaveBlock := nil;
   end;//try..finally
   }
  end;//try..finally
 end;//aSearcher <> nil..
end;

procedure TevCustomEditorWindow.GotoTop;
  {-перейти к началу текста}
begin
 ProcessCommand(ev_ocTopLeft, true, 1);
end;

function TevCustomEditorWindow.GotoBottom: Boolean;
  {-перейти к концу текста}
begin
 if (f_TextSource <> nil) AND f_TextSource.HasDocument then
  Result := f_TextSource.DocumentContainer.LinkWaiter(TevSubWaiter.Make(Self, Ord(ev_dpEnd), ev_sbtDocumentPlace))
 else
  Result := false;
end;

function TevCustomEditorWindow.GotoPara(anID: Integer): Boolean;
  {-}
var
 l_Para : InevObject;
begin
 Result := false;
 if (Selection <> nil) then
  if TextSource.DocumentContainer.FindObjByID(anID, l_Para) then
   Result := InevSelection(Selection).SelectPoint(l_Para.MakePoint, True);
end;

function TevCustomEditorWindow.ScrollToPara(anID: Integer): Boolean;
  {-}
var
 l_Para : InevObject;
begin
 Result := false;
 if (Selection <> nil) then
  if TextSource.DocumentContainer.FindObjByID(anID, l_Para) then
   Result := ScrollToCursor(l_Para.MakePoint.PointToParentByLevel(MaxInt));
end;

procedure TevCustomEditorWindow.GotoTag(const aTag: InevObject);
  //overload;
  {-}
begin
 if (Selection <> nil) AND (aTag <> nil) AND aTag.AsObject.IsKindOf(k2_typPara) then
  if not InevSelection(Selection).SelectPoint(aTag.MakePoint, True) then
  begin
   if aTag.AsObject.IsKindOf(k2_typLeafPara) then
    GotoPara(aTag.AsObject.IntA[k2_tiHandle]);
  end;//not Selection.SelectPoint(aTag.MakePoint)
end;

procedure TevCustomEditorWindow.Cut;
  {-удалить в буфер обмена}
begin
 Copy;
 if not IsReadOnly then
  Range.Delete;
end;

function TevCustomEditorWindow.Block2DataObject(const aBlock  : IevdDataObject;
                                                anInternal    : Boolean = false): IDataObject;
  {-}
var
 l_Formats : Tl3ClipboardFormats;
begin
 if GetAvaliableFormats(l_Formats) then
  try
   Result := TextSource.Block2DataObject(aBlock, l_Formats, MakeExportFilters(false, false), anInternal);
  finally
   l_Formats := nil;
  end//try..finally
 else
  Result := nil;
end;

function TevCustomEditorWindow.Data2DataObject(aData : THandle): IDataObject;
  {-}
var
 l_Formats : Tl3ClipboardFormats;
begin
 if GetAvaliableFormats(l_Formats) then
  try
   Result := TextSource.Data2DataObject(aData, l_Formats);
  finally
   l_Formats := nil;
  end//try..finally
 else
  Result := nil;
end;

function TevCustomEditorWindow.DoCloseQuery: Boolean;
  //override;
  {-}
begin
 Result := true;
 {$IfDef evNeedGetBlockFont}
 if (fl_BlockFontCalls > 0) AND (fl_BlockFontCalls <> l3NilLong) then
 begin
  fl_BlockFontCalls := l3NilLong;
  Result := false;
 end;//fl_BlockFontCalls > 0
 {$EndIf evNeedGetBlockFont}
 {$IfDef evNeedGetBlockStyle}
 if (fl_BlockStyleCalls > 0) AND (fl_BlockStyleCalls <> l3NilLong) then
 begin
  fl_BlockStyleCalls := l3NilLong;
  Result := false;
 end;//fl_BlockStyleCalls > 0
 {$EndIf evNeedGetBlockStyle}
end;

function TevCustomEditorWindow.MoveLeafCursor(anOp          : Long;
                                              ApplyToParent : Boolean = false): Boolean;
  {-}
var
 l_TopCursor : InevBasePoint;
 l_Cursor    : InevBasePoint;
begin
 if (Selection = nil) then
  Result := false
 else
 begin
  l_TopCursor := Selection.Cursor;
  if (l_TopCursor = nil) then
   Result := false
  else
  begin
   l_Cursor := l_TopCursor.MostInner;
   if ApplyToParent then
    l_Cursor := l_Cursor.ParentPoint;
   if (l_Cursor = nil) then
    Result := false
   else
    Result := l_Cursor.Move(View, anOp, StartOp(ev_msgMove));
  end;//l_Cursor = nil
 end;//Selection = nil
end;

procedure TevCustomEditorWindow.Copy;
  {virtual;}
  {-вставить в буфер обмена}
var
 l_Para   : Tl3Tag;
 l_Bitmap : Il3Bitmap;
begin
 with Selection do
 begin
  if Collapsed then
  begin
   l_Para := Selection.Cursor.MostInner.Obj^.AsObject;
   if l_Para.Attr[k2_tiObject].QI(Il3Bitmap, l_Bitmap) then
    try
     if l3System.SetClipboardData(Tl3BitmapDataObject.Make(l_Bitmap)) then
      Exit;
    finally
     l_Bitmap := nil;
    end;//try..finally
  end;//Collapsed
  if HasSelection then
   CopyRange(InevSelection(Self.Selection).GetBlock);
 end;//with Selection
end;

procedure TevCustomEditorWindow.CopyRange(const aRange: InevRange);
  {-}
begin
 l3System.SetClipboardData(Block2DataObject(aRange.Data));
end;

function TevCustomEditorWindow.GetCommands: TafwCommands;
  //override;
  {-}
begin
 SetCommands(ovcTextEditorCommands, Result);
end;

function TevCustomEditorWindow.DoProcessCommand(Cmd    : Tl3OperationCode;
                                                aForce : Boolean;
                                                aCount : Integer): Boolean;
  //override;
  {-process the specified command, return true if processed}
begin
 Result := ProcessCommandEx(Cmd, aForce, 0, aCount);
end;

function TevCustomEditorWindow.ReplaceConfirm(const aBlock        : InevRange;
                                              AlienReplaceConfirm : TevReplaceConfirmEvent): ShortInt;
  //virtual;
  {-}
begin
 Result := SetFoundBlock(aBlock, AlienReplaceConfirm);
end;
  
function TevCustomEditorWindow.DeleteFoundRgn: Boolean;
  {-}
begin
 Result := Assigned(Selection) and Assigned(Selection.FoundBlock);
 if Result then
  Selection.FoundBlock := nil;
end;

function TevCustomEditorWindow.ProcessBottomRigth(aCommand: Long;
                                                  aForce  : Boolean;
                                                  aCount  : Integer): Boolean;
begin
 {$IfNDef Nemesis}
  {$If Defined(evMapKeysToView) OR Defined(evMapBottomRightToView)}
  if (View <> nil) then
  begin
   View.Caret.Bottom;
   Result := true;
  end//View <> nil
  else
   Result := False;
  {$Else}
  Result := GotoBottom;
  {$IfEnd}
 {$Else  Nemesis}
  Result := ProcessCommandEx(ev_msgMove, aForce, aCommand, aCount);
 {$EndIf Nemesis}
 if Result then
  CheckAACMode(ev_ocBottomRight, aForce, aCount);
end;

function TevCustomEditorWindow.ProcessCommandEx(Cmd     : Long;
                                                aForce  : Boolean;
                                                aSubCmd : Cardinal;
                                                aCount  : Integer): Boolean;
  {virtual;}
  {-process the specified command, return true if processed}

  procedure lp_ProcessWithCheckAACMode;
  begin
   Result := CheckAACMode(Cmd, aForce, aCount);
   if not Result then
    Result := ProcessCommandEx(ev_msgMove, aForce, Cmd, aCount);
  end;

var
 l_Pack : InevOp;
begin
 Result := False;
 if (Cmd = ev_ocShortCut) then
  Result := true
 else
 begin
//  DeleteFoundRgn;
  if (Selection = nil) OR (Selection.Cursor = nil) then
   Result := false
  else
  begin
    Case Cmd of
     ev_ocActionItem,
     ev_ocAcceptChar,
     ev_ocTab :
      Result := false;

     ev_ocPageUp,
     ev_ocPageDown,
     ev_ocExtPageUp,
     ev_ocExtPageDown:
      lp_ProcessWithCheckAACMode;

     ev_ocBottomRight: Result := ProcessBottomRigth(Cmd, aForce, aCount);

     ev_ocTopLeft,
     ev_ocLineUp,
     ev_ocLineDown,
     ev_ocWordLeft,    ev_ocWordRight,
     ev_ocWordStart,   ev_ocWordFinish,
     ev_ocCharLeft,    ev_ocCharRight,
     ev_ocLineHome,    ev_ocLineEnd,
     ev_ocParaHome,    ev_ocParaEnd,
     ev_ocParaUp,      ev_ocParaDown,
     ev_ocParaLeft,    ev_ocParaRight,
     ev_ocListHome,    ev_ocListEnd,
     ev_ocPageTop,     ev_ocPageBottom,

     ev_ocExtTop,      ev_ocExtBottom,
     ev_ocExtWordLeft, ev_ocExtWordRight,
     ev_ocExtCharLeft, ev_ocExtCharRight,
     ev_ocExtLineUp,   ev_ocExtLineDown,
     ev_ocExtLineHome, ev_ocExtLineEnd,
     ev_ocExtParaHome, ev_ocExtParaEnd,
     ev_ocExtParaUp,   ev_ocExtParaDown,
     ev_ocExtParaLeft, ev_ocExtParaRight,
     ev_ocExtPageTop,  ev_ocExtPageBottom: lp_ProcessWithCheckAACMode;

     ev_ocUndo:
     begin
      Processor.Undo;
      Result := true;
     end;//ev_ocUndo

     ev_ocRedo:
     begin
      Processor.Redo;
      Result := true;
     end;//ev_ocRedo

     ev_ocDeleteWordLeft:
      if IsReadOnly then
       Result := false
      else
       with Range do
        if Collapsed then
         Result := Part[ed_rpToLeftWord].Delete
        else
         Result := Delete;

     ev_ocDeleteWordRight:
      if IsReadOnly then
       Result := false
      else
       with Range do
        if Collapsed then
         Result := Part[ed_rpWholeWordRight].Delete
        else
         Result := Delete;

     ev_ocStartSelection:
     begin
      with Selection do
       if Persistent then
        InevSelection(Self.Selection).AddBlock(Cursor, Finish)
       else
        //StartMark.AssignPoint(View, Cursor);
        StartMarkForCtrlKBCtrlKK.AssignPoint(View, Cursor);
        // http://mdp.garant.ru/pages/viewpage.action?pageId=227478574
        // http://mdp.garant.ru/pages/viewpage.action?pageId=227478574&focusedCommentId=296097324#comment-296097324
      Result := true;
     end;//ev_ocStartSelection

     ev_ocFinishSelection:
     begin
      with Selection do
       if Persistent then
        InevSelection(Self.Selection).AddBlock(Start, Cursor)
       else
        //InevSelection(Self.Selection).AddBlock(StartMark, Cursor);
        InevSelection(Self.Selection).AddBlock(StartMarkForCtrlKBCtrlKK, Cursor);
        // http://mdp.garant.ru/pages/viewpage.action?pageId=227478574
        // http://mdp.garant.ru/pages/viewpage.action?pageId=227478574&focusedCommentId=296097324#comment-296097324
      Result := true;
     end;//ev_ocFinishSelection

     ev_ocSetMarker0..ev_ocSetMarker9 :
     begin
      TextSource.DocumentContainer.SubList.SubEx[Cmd - ev_ocSetMarker0, Ord(ev_sbtMarker)].SetTo(Selection.Cursor.MostInner.Obj^.AsObject);
      Result := true;
     end;//ev_ocSetMarker0..ev_ocSetMarker9

     ev_ocGotoMarker0..ev_ocGotoMarker9 :
     begin
      TextSource.DocumentContainer.SubList.SubEx[Cmd - ev_ocGotoMarker0, Ord(ev_sbtMarker)].Select(Selection);
      Result := true;
     end;//ev_ocGotoMarker0..ev_ocGotoMarker9

     ev_ocCopy:
     begin
      Copy;
      Result := true;
     end;//ev_ocCopy

     ev_ocPaste:
     begin
      Paste;
      Result := true;
     end;//ev_ocCopy

     ev_ocCut:
     begin
      Cut;
      Result := true;
     end;//ev_ocCopy

     ev_ocToggleInsertMode:
     begin
      InsertMode := not InsertMode;
      Result := true;
      // - сигнализируем, что обработали операцию
     end;//ev_ocToggleInsertMode

     else
     begin
      l_Pack := StartOp(Cmd);
      try
       Case Cmd of
        ev_ocDeleteChar:
         Result := Selection.Text.Modify.DeleteChar(View, false, l_Pack);
        else
        begin
         Case Cmd of
          ev_ocBreakPara:
           Cmd := ev_msgBreakPara;
          ev_ocBackspace:
           Cmd := ev_msgBackspace;
         end;//Case Cmd..
         try
          Case Cmd of
           ev_msgBreakPara:
            Result := DoBreakPara(Selection.DrawLines{aSubCmd <> 0}, l_Pack);
           else
            Result := Selection.ProcessCommand(Cmd, aSubCmd, l_Pack, aCount);
          end;//Case Cmd
         except
          on EevLimitReached do
          begin
           if (l_Pack <> nil) then
            l_Pack.Undo(Processor);
            // - надо откатить всю текущую пачку
           Result := false;
          end;//on EevLimitReached
          on E : EevReadOnly do
          begin
           if HandledReadOnly(E) then
            Result := false
           else
            raise;
          end;//EevReadOnly
         end;//try..except
        end;//else
       end;//Case Cmd
      finally
       l_Pack := nil;
      end;//try..finally
     end;//else
    end;//Case Cmd
  end;//(Selection = nil) OR (Selection.Cursor = nil)
 end;//Cmd = ev_ocShortCut
end;//ProcessCommandEx

function TevCustomEditorWindow.DoBreakPara(aDrawLines : Boolean;
                                           const anOp : InevOp): Boolean;
  //virtual;
  {-}
begin
 if Assigned(Selection) then
 try
  Result := Selection.Text.Modify.InsertBreak(View, aDrawLines, anOp);
 except
  on E: EevReadOnly do
  begin
   if HandledReadOnly(E) then
    Result := false
   else
    raise;
  end;//EevReadOnly
 end else
  Result := False;
end;

procedure TevCustomEditorWindow.CreateWnd;
  {-взята из Orpheus}
begin
 inherited;
 fl_VScroll := ScrollStyle in [ssVertical, ssBoth];
 fl_HScroll := ScrollStyle in [ssHorizontal, ssBoth];
 UpdateScrollRange;
 SetEditRect;
end;

procedure TevCustomEditorWindow.WndProc(var Message: TMessage);
  {override;}
  {-}
var
 l_QueryCardContainer: InevQueryDocumentContainer;
begin
 if (Cardinal(Message.Msg) = WM_MOUSEWHEEL) {or
    (Cardinal(Message.Msg) = Cardinal(WMH_MouseWheel))} then
 begin  
  TextSource.DocumentContainer.QueryInterface(InevQueryDocumentContainer,
    l_QueryCardContainer);
  if not ((l_QueryCardContainer <> nil) and (l_QueryCardContainer.ModelNotify <> nil) and 
    l_QueryCardContainer.ModelNotify.MouseWheel(l3TestBit(Message.wParam, 31))) then
   begin
    if l3TestBit(Longint(Message.wParam), 31) then
     Perform(WM_VScroll, SB_WheelDown, 0)
    else
     Perform(WM_VScroll, SB_WheelUp, 0);
   end;//(f_DropTree <> nil) and not f_ListExists
 end//(Message.Msg = $20A) or (Message.Msg = WMH_MouseWheel)
 else
  inherited;
end;

procedure TevCustomEditorWindow.pm_SetHRuler(const aValue: IevRuler);
  {-}
begin
 if (f_HRuler <> aValue) then
 begin
  if (f_HRuler <> nil) then
  begin
   f_HRuler.OnSetMarker := nil;
   f_HRuler.Control := nil;
  end;//f_HRuler <> nil
  f_HRuler := aValue;
  if (f_HRuler <> nil) then
  begin
   f_HRuler.OnSetMarker := DoHRulerSetMarker;
   f_HRuler.Margin := LMargin;
   f_HRuler.Control := Self;
   f_HRuler.Zoom := Zoom;
   //f_HRuler.Delta := Top.X;
   f_HRuler.ControlMoved;
  end;//HRuler <> nil
 end;//f_HRuler <> aValue
end;

procedure TevCustomEditorWindow.pm_SetVRuler(const aValue: IevRuler);
  {-}
begin
 if (f_VRuler <> aValue) then
 begin
  if (f_VRuler <> nil) then
   f_VRuler.Control := nil;
  f_VRuler := aValue;
  if (f_VRuler <> nil) then
  begin
   f_VRuler.Margin := 0;
   f_VRuler.Control := Self;
   f_VRuler.Zoom := Zoom;
   //f_VRuler.Delta := Top.Y;
   f_VRuler.ControlMoved;
  end;//f_VRuler <> nil
 end;//f_VRuler <> aValue
end;

procedure TevCustomEditorWindow.DoSignalScroll(aDeltaY   : Integer;
                                             aNeedVert : Boolean);
  {-}
begin
 WasScroll;
 // - надо будет перерисовать каретку
 if aNeedVert then
 begin
  SetVScrollPos(-1);
  if (VSubPanel <> nil) then
   if (aDeltaY = 0) then
    (VSubPanel As IevSubCache).ClearSubs
    // - это временная мера - пока не научимся считать точное смещение Sub'ов.
   else
    VSubPanel.Scroll(aDeltaY);
  if (VRuler <> nil) then VRuler.Scroll(aDeltaY);
 end//aNeedVert
 else
  if (HRuler <> nil) then HRuler.Scroll(aDeltaY); 
 SetHScrollPos;
 if (aDeltaY = 0) then
  Invalidate
 else
 if aNeedVert then
  ScrollWindow(l3PointY(aDeltaY))
 else
  ScrollWindow(l3PointX(aDeltaY));
end;

function TevCustomEditorWindow.GetLMargin: Long;
  {override;}
begin
 if (f_LeftIndentDelta = 0) OR
    (TextSource = nil) OR
    not TextSource.HasDocument then
  // - проверка на HasDocument вставлена, чтобы не прогружать невидимый документ
 begin
//  if (f_LeftIndentDelta = 0) then
   Result := f_LMargin
{  else
   Result := f_LeftIndentDelta}; 
 end//f_LeftIndentDelta = 0..
 else
 begin
  with TextSource.Document.Attr[k2_tiLeftIndent] do
   if IsValid then
   begin
    if (AsLong = 0) then
     Result := f_LeftIndentDelta
    else
     Result := Min(-(GetInfoCanvas.LP2DP(l3PointX(AsLong)).X - f_LeftIndentDelta), 0);
   end
   else
    Result := f_LeftIndentDelta;
  if (Result <> f_LMargin) then
  begin
   f_LMargin := Result;
   if (HRuler <> nil) then
    HRuler.Margin := Result;
  end;//Result <> f_LMargin
 end;//f_LeftIndentDelta = 0..
end;

procedure TevCustomEditorWindow.pm_SetLMargin(Value: TevPixel);
  {-}
begin
 if (f_LMargin <> Value) then
 begin
  f_LMargin := Value;
  if (HRuler <> nil) then
   HRuler.Margin := LMargin;
  Include(fl_UpdateFlags, ev_uwfCursor);
  Invalidate;
 end;//f_LMargin <> Value
end;

function TevCustomEditorWindow.LMarginStored: Boolean;
  {-}
begin
 Result := (f_LeftIndentDelta = 0);
end;

procedure TevCustomEditorWindow.pm_SetLeftIndentDelta(aValue: Long);
  {-}
begin
 if (f_LeftIndentDelta <> aValue) then
 begin
  f_LeftIndentDelta := aValue;
  f_LMargin := 0;
  if (HRuler <> nil) then
   HRuler.Margin := LMargin;
  Include(fl_UpdateFlags, ev_uwfCursor);
  Invalidate;
 end;//f_LeftIndentDelta <> aValue
end;
  
function  TevCustomEditorWindow.pm_GetDocument: InevParaList;
begin
 if HasDocument then
 begin
  if (f_Document <> nil) AND not f_Document.AsObject.IsSame(TextSource.Document) then
  begin
   //f_Document := nil;
   FreeView;
  end;//f_Document <> nil
  if (f_Document = nil) then
  begin
   TextSource.Document.QT(InevParaList, f_Document);
   MakeView;
  end;//f_Document = nil
  if (f_Document = nil) and TextSource.DocumentContainer.AbortedLoad then
   Result := nev.NullParaList
  else
   Result := f_Document;
 end//HasDocument
 else
 begin
  //Redirect := nil;
  f_Document := nil;
  Result := nev.NullParaList{(Processor)};
  if not HasDocument then
   FreeCursor
  else
  begin
   // !!! ЗАМЕТИМ, что Processor мы теперь не дёргаем !!!
   {$IfNdef DesignTimeLibrary}
   Assert(false, 'Документ неожиданно появился из ниоткуда');
   {$EndIf  DesignTimeLibrary}
   // Документ получили в результате получения Processor
   // Во View._TopAnchor может залипуть предыдущий документ - зачистим его (ЦК27928)
   FreeView;
  end;//not HasDocument
 end;//HasDocument
end;

procedure TevCustomEditorWindow.DoAfterFirstPaint;
  {* - событие после первой отрисовки. }
begin
 if Assigned(f_OnAfterFirstPaint) then
  f_OnAfterFirstPaint(Self);
end;

procedure TevCustomEditorWindow.CheckView(
  const anAnchor: InevBasePoint);
var
 l_Document: InevObject;
begin
 l_Document := anAnchor.Obj^;
 if (l_Document <> nil) AND l_Document.AsObject.IsValid then
 begin
  MakeView;
  if TextSource.Document.IsSame(l_Document.AsObject) then
  // Проверка родилась из CQ 29061. Иначе падали с assert т.к. документ поменялся
  // и получение FormatInfo падало. 
   f_Document := l_Document.AsPara.AsList
  else
  // - документ изменился в базе. CQ 29061.
   f_Document := nil;
   // - не уверен, что это все действия. Может надо что-то ещё.
  //Redirect := f_Document; 
  if (Selection <> nil) then
   Selection.LinkView(f_View);
 end;//(aDocument <> nil) AND aDocument.IsValid
end;

procedure TevCustomEditorWindow.Resize;
begin
 AdjustHeightByText;
 inherited;
end;

function TevCustomEditorWindow.AllowDrawDocumentEdge: Boolean;
  {virtual;}
  {-}
begin
 Result := true;
end;

function TevCustomEditorWindow.GetPaintSelection: InevRange;
  //virtual;
  {-}
begin
 if (Selection <> nil) AND (Focused OR not AutoHideSelection) then
 begin
  with Selection do
  begin
   if (FoundBlock <> nil) then
    Result := FoundBlock
   else
   if HasSelection then
    Result := InevSelection(Self.Selection).GetBlock
   else
    Result := nil;
  end;//with Selection
 end//Focused OR not AutoHideSelection
 else
  Result := nil;
end;
  
procedure TevCustomEditorWindow.SetTextColor(const aCanvas: Il3Canvas);
  //virtual;
  {-}
begin
 aCanvas.Font.ForeColor := clWindowText;
end;

function TevCustomEditorWindow.DoDrawDocument(const aCanvas: Il3Canvas; out aMap: InevMap): Boolean;
begin
 if not InClose then
  Result := View.Draw(GetPaintSelection, aMap)
 else
  Result := false;  
end;

procedure TevCustomEditorWindow.Paint(const aCanvas: Il3Canvas);
  {-отрисовка документа}

 procedure InitColors;
 begin//InitColors
  aCanvas.Font.BackColor := Color;
  aCanvas.BackColor := Color;
  SetTextColor(aCanvas);
 end;//InitColors

var
 l_CaretCursor : InevBasePoint;

 procedure DrawDocument;
 var
  l_Map     : InevMap;
  l_Focused : Boolean;
 begin{DrawDocument}
  InitColors;
  l_Focused := Focused;
  if Assigned(f_OnCheckFocusedInPaint) then
   f_OnCheckFocusedInPaint(Self, l_Focused);
  aCanvas.NotFocused := not l_Focused;
  if (View = nil) then
   Assert(false)
  else
   DoDrawDocument(aCanvas, l_Map);
  if (l_Map <> nil) AND AllowDrawDocumentEdge AND View.IsDocumentTailVisible then
  begin
   // - рисуем черточку внизу документа
   aCanvas.WindowOrg := l3Point(0, -l_Map.Bounds.Bottom);
   aCanvas.PushBC;
   try
    aCanvas.BackColor := clBlack;
    aCanvas.FillRect(l3SRect(0, 0, 30, 2));
   finally
    aCanvas.PopBC;
   end;//try..finally
  end;//AllowDrawDocumentEdge

 end;//DrawDocument

 procedure SendNeedDocPrim;
 var
  l_C : TWinControl;
 begin//SendNeedDocPrim
  l_C := Self;
  while (l_C <> nil) do
  begin
   if not l_C.Visible then
    Exit;
   l_C := l_C.Parent; 
  end;//l_C <> nil
  // - http://mdp.garant.ru/pages/viewpage.action?pageId=265391594
  //   проверяем что все родители видимы, чтобы лишний раз не пытать грузить
  //   "ненужный" документ
  PostMessage(Handle, ev_msgNeedDoc, 0, 0);
 end;//SendNeedDocPrim

 procedure SendNeedDoc;
 begin//SendNeedDoc
  if (f_TextSource <> nil) AND
     (f_NeedDocCalled < 1000) AND HandleAllocated then
   SendNeedDocPrim;
 end;//SendNeedDoc

var
 l_ClipRect     : Tl3Rect;
 l_MarginRect   : Tl3SRect;
 l_CR           : Tl3SRect;
 l_WasScroll    : Boolean;
begin
 aCanvas.BeginPaint;
 try
  InitColors;

  aCanvas.DrawEnabled := true;
  // рисуем левый отступ:
  l_MarginRect.R.Left := 0;
  l_MarginRect.R.Top := 0;
  l_MarginRect.R.Right := l_MarginRect.R.Left + LMargin;
  l_MarginRect.R.Bottom := Height;
  l_MarginRect := l_MarginRect.AddPt(aCanvas.SWindowOrg);
  // - есть мнение, что это - ЛИШНЕЕ, в тех же баллонах
  // http://mdp.garant.ru/pages/viewpage.action?pageId=265398068
  // - мнение ошибочно - http://mdp.garant.ru/pages/viewpage.action?pageId=271193455
  //   видимо если и учитывать, то aCanvas.InitialDCOffset
  //aCanvas.FillEmptyRect(l_MarginRect);
  aCanvas.FillRect(l_MarginRect);

  if not fl_WasAsyncLoop then
   f_WasScroll := false;
  if (f_TextSource = nil) OR
     (not f_TextSource.HasDocument AND
     ((f_Cursor = nil) OR not f_Cursor.Document.IsValid)) then
  begin
   with aCanvas do
    FillRect(ClipRect);
   SendNeedDoc;
  end//f_TextSource = nil
  else
  begin
   f_NeedDocCalled := 0;
   l_ClipRect := aCanvas.ClipRect;
   if not (ev_uwfCursor in fl_UpdateFlags) AND
      ((l_ClipRect.R.Left >= l_ClipRect.R.Right) OR
       (l_ClipRect.R.Top >= l_ClipRect.R.Bottom)) then
    Exit; {- пока спорно}
   if Locked AND not ForceRepaint then
   begin
    if (TextSource = nil) then
    begin
     f_NeedInvalidate := true;
     //PostMessage(Handle, ev_msgNeedPaint, 0, 0);
     {-здесь надо что-то делать с текущим незаполненным регионом};
     Exit;
    end;//TextSource = nil
   end;//Locked
   begin
    Inc(f_InPaint);
    try
     if (ev_uwfScrollCaret in fl_UpdateFlags) then
      Include(fl_UpdateFlags, ev_uwfCursor);
     l_WasScroll := (ev_uwfWasScroll in fl_UpdateFlags);
     aCanvas.DrawEnabled := (ev_uwfRegion in fl_UpdateFlags) OR
                            (ev_uwfBlock in fl_UpdateFlags);
     if (ev_uwfBlock in fl_UpdateFlags) then
     begin
      if l_WasScroll then
       aCanvas.DrawEnabled := true;
     end;//ev_uwfBlock in fl_UpdateFlags
     if Focused then
     begin
      if (Selection = nil) then
       l_CaretCursor := nil
      else
       l_CaretCursor := Selection.Cursor;
      if (l_CaretCursor <> nil) then
      begin
       with l_CaretCursor.MostInner do
        if not NeedWindowsCaret then
         aCanvas.ShowCursor := true
        else
        if ([ev_uwfCursor, ev_uwfRegion] * fl_UpdateFlags) <> [] then
         aCanvas.ShowCursor := true
        else
         l_CaretCursor := nil;
      end;//l_CaretCursor <> nil
     end//Focused
     else
      l_CaretCursor := nil;

     fl_UpdateFlags := fl_UpdateFlags - evViewFlags;

     if not HasDocument then
     begin
      SendNeedDoc;
      with aCanvas do FillRect(ClipRect);
     end//not HasDocument
     else//if not HasDocument
     if not Document.AsObject.IsValid then
      with aCanvas do FillRect(ClipRect)
     else
     begin
      if aCanvas.DrawEnabled then
      begin
       l_CR.InitRect(ClientRect);

       // рисуем правый отступ:
       l_MarginRect := l_CR;
       l_MarginRect.R.Left := l_MarginRect.R.Right - RMargin;
       //aCanvas.FillEmptyRect(l_MarginRect);
       l_MarginRect := l_MarginRect.AddPt(aCanvas.SWindowOrg);
  // - есть мнение, что это - ЛИШНЕЕ, в тех же баллонах
  // http://mdp.garant.ru/pages/viewpage.action?pageId=265398068
  // - мнение ошибочно - http://mdp.garant.ru/pages/viewpage.action?pageId=271193455
  //   видимо если и учитывать, то aCanvas.InitialDCOffset
       aCanvas.FillRect(l_MarginRect);

       //l_ClipRect := aCanvas.ClipRect;
       with ClientRect do
        l_ClipRect := aCanvas.DR2LR(l3SRect(Left{ - 2}, Top, Right, Bottom));
                                               //^ это запил для http://mdp.garant.ru/pages/viewpage.action?pageId=207004464
                                               // !!! ОТКРУТИЛ нах, ибо скроллирование МАЖЕТ
       l_ClipRect.Left := l_ClipRect.Left + aCanvas.DP2LP(PointX(LMargin)).X;
       l_ClipRect.Right := l_ClipRect.Right - aCanvas.DP2LP(PointX(RMargin)).X;

       // надо, когда редактор лежит на vgscene, иначе текст в баллонах будет снизу обрезан
       l_ClipRect.BottomRight := l_ClipRect.BottomRight.Sub(aCanvas.InitialDCOffset);

       l_ClipRect := l_ClipRect.AddPt(aCanvas.WindowOrg);

       aCanvas.ClipRect := l_ClipRect;
       DrawDocument;

       InitColors;
       //aCanvas.WindowOrg := evPoint0;
       aCanvas.WindowOrg := aCanvas.InitialDCOffset;
       with aCanvas do
        FillEmptyRect(ClipRect.SubPt(InitialDCOffset));
      end//aCanvas.DrawEnabled
      else
       DrawDocument;
     end;//not Document.IsValid
     if (Selection <> nil) then
     begin
      if aCanvas.ShowCursor then
      // - каретку так и не нарисовали
       DrawCaret(false)
       // - нарисуем ее
      else
      if not l_WasScroll then
       Selection.Caret.CheckHidden
      else
      if Selection.Caret.Hidden then
       DrawCaret(false);
     end;//Selection <> nil
    finally
     Dec(f_InPaint);
     if f_NeedSetVScrollRange then
      UpdateScrollRange([afw_sbVert]);
    end;//try..finally
   end;{Locked}
   // Это событие нужно для производства замеров времени открытия документа:
   if not f_WasFirstPaint and Assigned(View) and View.IsCaretVisible then
   begin
    DoAfterFirstPaint;
    f_WasFirstPaint := True;
   end;
  end;//f_TextSource = nil..
 finally
  aCanvas.EndPaint;
 end;//try..finally
end;

procedure TevCustomEditorWindow.Notification(AComponent: TComponent; Operation: TOperation);
  {override;}
begin
 inherited;
 if (Operation = opRemove) then
 begin
  if (AComponent = f_HScrollBar) then
   HScrollBar := nil
  else
  {$IfDef l3ProgressComponentIsComponent}
  if (AComponent = f_TextSource) then
   TextSource := nil
  {$EndIf l3ProgressComponentIsComponent}
  else
   if csDestroying in ComponentState then
   begin
    HRuler := nil;
    f_VSubPanel := nil;
    VRuler := nil;
   end // if csDestroying in ComponentState then
   else
    if l3IEQ(AComponent, f_HRuler) then
     HRuler := nil
    else
    if l3IEQ(AComponent, f_VRuler) then
     VRuler := nil
    else
    if l3IEQ(AComponent, VSubPanel) then
     VSubPanel := nil;
 end;//Operation = opRemove
end;

procedure TevCustomEditorWindow.DrawCaret(weNeedCheckPaint : Boolean);
  {-}
var
 l_Map : InevMap;
begin
 if not afw.IsActionUpdateLocked AND HasDocument then
 begin
  if not weNeedCheckPaint OR (f_InPaint <= 0) then
   if (View <> nil) AND View.IsCaretVisible then
   begin
    if (Selection <> nil) then
    begin
     with Selection do
     begin
      if (Cursor <> nil) then
      begin
       Inc(f_InPaint);
       try
        with Il3Canvas(Canvas) do
        begin
         BeginPaint;
         try
          ShowCursor := true;
          if not weNeedCheckPaint OR (f_InPaint <= 1) then
          begin
           DrawEnabled := false;
           MoveWindowOrg(l3SPoint(0, -GetTopMargin));
           SetTextColor(Self.Canvas);
          end;//not weNeedCheckPaint OR (f_InPaint <= 1)
          Exclude(fl_UpdateFlags, ev_uwfCursor);
          View.Draw(nil{GetPaintSelection}, l_Map);
         finally
          EndPaint;
         end;{try..finally}
        end;//with Canvas
       finally
        Dec(f_InPaint);
       end;//try..finally
       // Покажем курсор
       with Cursor do
       begin
        if MostInner.NeedWindowsCaret then
         Caret.CheckHidden
        else
         Caret.Hidden := true;
       end;//with Cursor
      end;//Assigned(Cursor)
     end;//with Selection
    end;//Selection <> nil
   end//(View <> nil) AND View.IsCaretVisible
   else
   if (Selection <> nil) then
    Selection.Caret.Hidden := true;
 end;//not afw.IsActionUpdateLocked then   
end;

procedure TevCustomEditorWindow.AfterOperation;
  //virtual;
  {-}
begin
 if (f_TextSource <> nil) AND f_TextSource.HasDocument then
 // - документа нету, ну и нефига дергаться
 begin
  inherited Update;
(*  if fl_WasAsyncLoop then
   inherited Update
  else
  if f_WasScroll then
  begin
   f_WasScroll := false;
   inherited Update;
  end;//f_WasScroll*)
  if ([ev_uwfBlock, ev_uwfCursor] * fl_UpdateFlags <> []) then
  begin
   if not Locked then
   begin
    if (ev_uwfPara in fl_UpdateFlags) then
     DoParaChange;
    if (ev_uwfBlock in fl_UpdateFlags) then
     DoUpdateBlock;
   end;//not Locked
   //PaintWindow(0);
   // - непонятно нафига это нужно, пока открутил, т.к. из за этого тормозит вставка
   //   параграфов (см. комментарий ниже).
   if Assigned(View.RootMap) and not (ev_uwfBlock in fl_UpdateFlags) then
    // - надо перерисовать курсор
    DrawCaret(true)
   else
    Invalidate;
   // - нашел зачем это нужно - чтобы перерисовать курсор/выделение
  end;//[ev_uwfBlock, ev_uwfCursor] * fl_UpdateFlags <> []
 end;//f_TextSource <> nil
end;

procedure TevCustomEditorWindow.Update;
  {override;}
  {-}
begin
 if not Locked AND HandleAllocated then
 begin
  if (f_View <> nil) AND not f_View.InMakeCaretVisible then
  begin
   if f_NeedUpdateRange then
    UpdateScrollRange;
   if IsLastHistoryStep then
    AfterOperation;
  end;//(f_View <> nil) AND not f_View.InMakeCaretVisible
 end;//not Locked
end;

function TevCustomEditorWindow.HasDocument: Boolean;
  {-}
begin
 Result := (f_TextSource <> nil) AND f_TextSource.HasDocument;
end;

function TevCustomEditorWindow.GetHotspotOnPoint(const aPt      : TPoint;
                                                 out theHotSpot : IevHotSpot;
                                                 NeedStorePoint : Boolean): Boolean;
  {-}
var
 l_sPt           : TPoint;
 l_Pt            : Tl3Point;
 l_V             : InevBasePoint;
 l_State         : TevCursorState;
 l_HotSpotTester : InevHotSpotTester2;
 l_HotSpot       : IevHotSpot;
 l_Map           : InevMap;
begin
 if (View = nil) OR not HasDocument then
 begin
  Result := false;
  Exit;
 end;//View = nil..
 l_sPt := aPt;
 l_Pt := DP2LP(l_sPt);
 if NeedStorePoint then
 begin
  f_Pt := l_Pt;
  f_sPt := Tl3SPoint(l_sPt); 
 end;//NeedStorePoint
 l_V := View.PointByPt(l_Pt);
 if (l_V = nil) then
  Result := false
 else
 begin
  l3FillChar(l_State, SizeOf(l_State), 0);
  l_State.rInitialPoint := l_Pt;
  l_State.rPoint := l_Pt;
  l_State.rKeys := KeyboardStateToShiftState;
  l_Map := View.RootMap;
  if (l_Map <> nil) AND Document.AsObject.IsValid then
  begin
   Result := true;
   if Document.AsObject.QT(InevHotSpotTester2, l_HotSpotTester, Processor) then
    try
     if l_HotSpotTester.GetAdvancedHotSpot(View,
                                           l_State,
                                           l_V,
                                           l_Map,
                                           l_HotSpot) then
      try
       theHotSpot := HotSpotClass.Make(Self, l_HotSpot);
      finally
       l_HotSpot := nil;
      end//try..finally
     else
      theHotSpot := HotSpotClass.Make(Self);
    finally
     l_HotSpotTester := nil;
    end//try..finally
   else
    theHotSpot := HotSpotClass.Make(Self);
  end//Document.IsValid
  else
   Result := false;
 end;//l_V = nil
end;
  
procedure TevCustomEditorWindow.DoHitTest(const aHotSpot : IevHotSpot;
                                          const aState   : TafwCursorState;
                                          var theInfo    : TafwCursorInfo);
  {-}
begin
 if Assigned(f_OnGetHotSpotInfo) then
  f_OnGetHotSpotInfo(Self, aHotSpot, aState, theInfo);
end;

function TevCustomEditorWindow.IsEmpty: Boolean;
var
 l_Start: InevBasePoint;
 l_Finish: InevBasePoint;
begin
 l_Start := Selection.Cursor.ClonePoint(View);
 l_Start.Move(View, ev_ocTopLeft);
 l_Finish := Selection.Cursor.ClonePoint(View);
 l_Finish.Move(View, ev_ocBottomRight);
 Result := l_Finish.Compare(l_Start) <= 0;
end;

function TevCustomEditorWindow.Paste: Boolean;
  {* вставить из буфера обмена. }
begin
 Result := AACLike = nev_aacLeft;
 if not Result then
  //http://mdp.garant.ru/pages/viewpage.action?pageId=425282245
  try
   Result := Inherited Paste;
  except
   on EevLimitReached do
    Result := False;
  end;
end;

procedure TevCustomEditorWindow.Print(const aPrinter    : Il3Printer = nil;
                                      aPrintSelection   : Boolean = false;
                                      const aMacroReplacer: IafwHAFMacroReplacer = nil);
  {-печать документа}
var
 l_Preview : IafwComplexDocumentPreview;
begin
 l_Preview := Preview(aMacroReplacer);
 if (l_Preview <> nil) then
 begin
  if (aPrinter <> nil) then
   l_Preview.Printer := aPrinter;
  if aPrintSelection then
  begin
   if (l_Preview.Selection <> nil) then
    l_Preview.Selection.Print;
  end//aPrintSelection
  else
  if (l_Preview.Document <> nil) then
   l_Preview.Document.Print;
 end;//l_Preview <> nil
end;

procedure TevCustomEditorWindow.WMGetDlgCode(var Msg : TWMGetDlgCode);
begin
  inherited;
  if (csDesigning in ComponentState) then
    Msg.Result := DLGC_STATIC
  else
  begin
    Msg.Result := Msg.Result or DLGC_WANTCHARS or DLGC_WANTARROWS or
                    DLGC_WANTALLKEYS;
    if WantTab then
     Msg.Result := Msg.Result or DLGC_WANTTAB
    else
     Msg.Result := Msg.Result AND not DLGC_WANTTAB;
  end;//csDesigning in ComponentState
end;

procedure TevCustomEditorWindow.ConvertInputChar(const aStr: Tl3PCharLen);
  {-}
begin
 if not l3IsNil(aStr) then
  Case aStr.S^ of
   cc_HardSpace:
    if l3System.Keyboard.Key[vk_Control].Down then
     aStr.S^ := cc_SoftSpace;
  end;{Case aStr.S^}
end;

procedure TevCustomEditorWindow.WMChar(var Msg : TWMChar);
var
 l_S        : Il3CString;
 l_Unicode  : WideString;
 l_HasTatar : Boolean;
 l_WSE      : Boolean;
begin
 afw.BeginOp;
 try
  l_Unicode := f_UnicodeChar;
  f_UnicodeChar := '';
  Msg.Result := -1;
  {&&& !!! &&&}
  if (Selection <> nil) then
  begin
   if (Msg.CharCode = Ord(cc_CtrlBackspace)) then
   begin
    if IsReadOnly then
     Exit
    else
     with Range do
      if Collapsed then
       Part[ed_rpToLeftWord].Delete
      else
       Delete;
   end//Msg.CharCode = Ord(cc_CtrlBackspace)
   else
   begin
    l_HasTatar := l3HasTatar(l_Unicode);
    l_WSE := WantSoftEnter;
    if (Msg.CharCode >= Ord(cc_HardSpace)) OR
       ((Msg.CharCode = Ord(cc_SoftEnter)) AND l_WSE) OR
       l_HasTatar then
    // - эту проверку я вернул назад - она была потеряна при переходе к Unicode
    //   если будет соблазн опять вытереть ее - обратите внимание, что Esc это тоже "буква"
    //   и он затирает выделенный текст.
    begin
     if not l_HasTatar then
      l_S := l3System.PeekString(Handle,
                                 l3PCharLen(Char(Msg.CharCode), l3KeyboardCodePage),
                                 ConvertInputChar,
                                 l_WSE,
                                 Msg.KeyData AND $FF)
     else
      l_S := l3System.PeekString(Handle, l3PCharLen(l_Unicode), ConvertInputChar, l_WSE);
     try
      with Selection, Text.Modify do
       if DrawLines then
       begin
        if InsertString(View, l_S,
                        StartOp(ev_msgInsertString),
                        InsertMode, [misfDraw]) then
         Msg.Result := 0;
       end//DrawLines
       else
       begin
        if InsertString(View, l_S,
                        StartOp(ev_msgInsertString),
                        InsertMode) then
         Msg.Result := 0;
       end;//DrawLines
     finally
      l_S := nil;
     end;//try..finally
    end;//Msg.CharCode = Ord(cc_CtrlBackspace)
   end;//Msg.CharCode = Ord(cc_CtrlBackspace)
  end;//Selection <> nil
  inherited;
 finally
  afw.EndOp;
 end;//try..finally
end;

function TevCustomEditorWindow.ColumnLeft: Boolean;
  {-}
begin
 Result := MoveLeafCursor(ev_ocColumnLeft, true);
end;

function TevCustomEditorWindow.ColumnRight: Boolean;
  {-}
begin
 Result := MoveLeafCursor(ev_ocColumnRight, true);
end;

function TevCustomEditorWindow.Tabulate: Boolean;
  //virtual;
  {-}
begin
 Result := ColumnRight;
end;

function TevCustomEditorWindow.Untabulate: Boolean;
  //virtual;
  {-}
begin
 Result := ColumnLeft;
end;

function TevCustomEditorWindow.StartOp(Op     : Long = 0;
                                       DoLock : Boolean = true): InevOp;
  {-}
begin
 Result := TextSource.StartOp(Op, DoLock);
 if (Result <> nil) AND IsReadOnly then
  Result.ReadOnly := true; 
end;

{$IF not Defined(Archi) and not Defined(EverestLite)}
procedure TevCustomEditorWindow.Invalidate;
begin
 if Assigned(FInvalidateTimerK329646239) then
  FInvalidateTimerK329646239.Enabled := False;
 inherited;
end;

procedure TevCustomEditorWindow.InvalidateByTimerK329646239;
begin
 if not Assigned(FInvalidateTimerK329646239) then
 begin
  FInvalidateTimerK329646239 := TTimer.Create(Self);
  FInvalidateTimerK329646239.Interval := 100;
  FInvalidateTimerK329646239.OnTimer := OnIvalidateTimerK329646239;
 end;
 FInvalidateTimerK329646239.Enabled := False;
 FInvalidateTimerK329646239.Enabled := True;
end;

procedure TevCustomEditorWindow.OnIvalidateTimerK329646239(ASender: TObject);
begin
// FInvalidateTimerK329646239.Enabled := False;
 Invalidate;
end;
{$IFEND}

function TevCustomEditorWindow.ScrollWindow(const aDelta: TafwSPoint): Boolean;
  {overload;}
  {-}
var
 l_R : TRect;
begin
 if HandleAllocated then
 begin
  with aDelta.P do
   if (X = 0) OR ((RMargin = 0) AND (LMargin = 0)) then
    Result := Windows.ScrollWindow(Handle, X, Y, nil, nil)
   else
   begin
    l_R := ClientRect;
    l_R.Left := l_R.Left + LMargin;
    l_R.Right := l_R.Right - RMargin;
    Result := Windows.ScrollWindow(Handle, X, Y, @l_R, @l_R);
//    Result := Windows.ScrollWindow(Handle, X, Y, @l_R, nil);
   end;//X = 0..
 end//if HandleAllocated 
 else
  Result := false;
end;

function TevCustomEditorWindow.ScrollWindow(const aDelta: TafwPoint): Boolean;
  //override;
  {-}
var
 l_Extent : TafwPoint;
begin
 if (f_Cursor = nil) then
  Result := false
 else
 begin
  Selection.Caret.Hidden := true;
  Include(fl_UpdateFlags, ev_uwfCursor);
  l_Extent := pm_GetExtent;
  if //Locked OR
     // - это закомментировано, т.к. неправильно рисуется при вставке параграфов
     //   по-бырому - как и следовало ожидать - только кошки родятся.
     not CanScroll OR
     (Abs(aDelta.P.X) >= l_Extent.P.X) OR
     (Abs(aDelta.P.Y) >= l_Extent.P.Y) OR
     (l_Extent.P.Y - Abs(aDelta.P.Y) < l_Extent.P.Y div 4) then
  begin
   Invalidate;
   Result := true;
  end//not CanScroll..
  else
  begin
   with Il3Canvas(Canvas) do
    Result := Self.ScrollWindow(LP2DP(Tl3Point(aDelta)).Zoom(Zoom));
   if Result then
   begin
    WasScroll;
    {$IF not Defined(Archi) and not Defined(EverestLite)}
    if (aDelta.P.Y <> 0) then
     InvalidateByTimerK329646239;
    {$IFEND}
    Update;
   end;//Result
  end;//not CanScroll..
  if not f_InScroll then
   Selection.Caret.Scrolled;
 end;//f_Cursor = nil
end;

function  TevCustomEditorWindow.WantEnter: Boolean;
  //virtual;
  {-}
begin
 Result := true;
end;

function TevCustomEditorWindow.WantTab(aKeyPressed: Boolean): Boolean;
  //virtual;
  {-}
begin
 Result := true;
end;

function TevCustomEditorWindow.GetAvaliableFormats(out theFormats: Tl3ClipboardFormats): Boolean;
  //override;
  {-}
begin
 Result := TextSource.GetAvaliableFormats(theFormats);
end;

function TevCustomEditorWindow.DoGetAcceptableFormats: Tl3ClipboardFormats;
  //override;
  {-}
begin
 if PlainText then
  Result := l3FormatArray(evPlainTextFormats)
 else
  Result := l3FormatArray(evAllFormats);
end;

function TevCustomEditorWindow.DoKeys2Effect(aKeys: Long): Long;
  //override;
  {-}
begin
 Result := DROPEFFECT_COPY;
end;
  
function TevCustomEditorWindow.DoDoDrop(aFormat       : Tl3ClipboardFormat;
                                      const aMedium : Tl3StoragePlace;
                                      var dwEffect  : Longint): Boolean;
  //override;
  {-}
var
 l_Stream : TStream;
 l_Pool   : IStream;
begin
 with Selection do
  if not IsActiveDropSource OR not InevSelection(Self.Selection).Contains(Cursor) then
  begin
   Self.Lock(Self);
   // http://mdp.garant.ru/pages/viewpage.action?pageId=278135821
   // чтобы не дёргаться на каждый чих при вставке по DnD, которое операцию
   // то открыло, а окно - не залочило, что правильно, ну вот тут - надо бы уже залочить.
   try
    if (aFormat = cf_Bitmap) then
    begin
     if aMedium.tymed = TYMED_GDI then
      Result := InsertData(aFormat, aMedium.hBitmap)
     else
      Result := false;
    end//aFormat = cf_Bitmap
    else
    begin
     Case aMedium.tymed of
      TYMED_HGLOBAL :
       try
        Result := InsertData(aFormat, aMedium.hGlobal);
       except
        on EevUnstableProcessWhileInsertUserComment do
        begin
        // http://mdp.garant.ru/pages/viewpage.action?pageId=255980313
         Result := true;
         raise;
        end;//on EevUnstableProcessWhileInsertUserComment
       end;//try..except
      TYMED_ISTREAM :
      begin
       l3IStream2Stream(IStream(aMedium.stm), l_Stream);
       try
        l_Stream.Seek(0, soBeginning);
        if Supports(l_Stream, IStream, l_Pool) then
         try
          Result := Cursor.Text.Modify.InsertStream(View, l_Pool, aFormat);
         finally
          l_Pool := nil;
         end//try..finally
        else
         Result := false;
       finally
        l3Free(l_Stream);
       end;//try..finally
      end;//TYMED_ISTREAM
      else
       Result := false;
     end;//Case aMedium.tymed
    end;//aFormat = cf_Bitmap
   finally
    Self.Unlock(Self);
   end;//try..finally
  end//not IsActiveDropSource..
  else
   Result := false;
end;

function TevCustomEditorWindow.DoDoDragOver(const aData  : IDataObject;
                                            const aPoint : TPoint): Boolean;
  //override;
  {-}
var
 l_Pt : TPoint;
begin
 if (Selection = nil) or IsReadOnly or DisableDragAndDropSupport then
  Result := false
 else
 begin
  inherited DoDoDragOver(aData, aPoint);
  l_Pt := ScreenToClient(aPoint);
  with InevSelection(Selection) do
  begin
   SelectPt(DP2LP(l_Pt), false);
   Result := not IsActiveDropSource OR not Contains(Self.Selection.Cursor);
  end;//with Selection
  if (l_Pt.Y <= 15) then
   View.Scroller[true].WheelUp
  else
  if (l_Pt.Y >= Height - 15) then
   View.Scroller[true].WheelDown
  else
   Update;
 end;//Selection = nil
end;

procedure TevCustomEditorWindow.WMKeyDown(var Msg : TWMKeyDown);
  //message CN_KEYDOWN;
var
 l_Time      : Cardinal;
 l_Cmd       : Word;
 l_Pt        : Tl3SPoint;
 l_Selection : Boolean;
 l_Map       : InevMap;
 l_View: InevControlView;
begin
 afw.BeginOp;
 try
  {get command to process}
  l_Time := GetTickCount;
  Msg.Result := 0;
  // View надо получить заранее. Поскольку при его получении могут снести Selection
  // K-137469208
  l_View := View;
  l_Selection := (Selection <> nil) AND (Selection.Cursor <> nil);
  if l_Selection AND Selection.Cursor.ProcessMessage(l_View, TMessage(Msg), l_Time) then
  begin
   Msg.Result := -1;
   Exit;
  end;//Selection.Cursor <> nil..
  if ProcessMessage(TMessage(Msg), l_Time) then
  begin
   Msg.Result := -1;
   Exit;
  end//ProcessCommand(TMessage(Msg), l_Time)
  else
  begin
   Msg.Result := -1;
   case Msg.CharCode of
    vk_Home:
     if l3System.Keyboard.Key[vk_Control].Down then
      MoveLeafCursor(ev_ocListHome, true);
 (*   vk_End:
     // - непонятно зачем это хакерство нужно, закомментировал
     //   если наткнусь - буду разбираться
     if l3System.Keyboard.Key[vk_Control].Down then
     begin
      if (f_TextSource <> nil) AND
         f_TextSource.HasDocument AND not f_TextSource.DocumentContainer.Loading then
       MoveLeafCursor(ev_ocListEnd, true);
     end;//l3System.Keyboard.Key[vk_Control].Down*)
    vk_Down: begin
     if l3System.Keyboard.Key[vk_Shift].Down then
      l_Cmd := ev_ocExtParaDown
     else
      l_Cmd := ev_ocParaDown;
     if l3System.Keyboard.Key[vk_Control].Down then
      ProcessCommand(l_Cmd, true, Lo(Msg.KeyData));
    end;{vk_Down}
    vk_Up: begin
     if l3System.Keyboard.Key[vk_Shift].Down then
      l_Cmd := ev_ocExtParaUp
     else
      l_Cmd := ev_ocParaUp;
     if l3System.Keyboard.Key[vk_Control].Down then
      ProcessCommand(l_Cmd, true, Lo(Msg.KeyData));
    end;{vk_Up}
    vk_Return : {start new line, cursor to next line}
      if WantEnter then
      begin
       if not l3System.Keyboard.Key[vk_Control].Down AND
          not l3System.Keyboard.Key[vk_Shift].Down then
       begin
        if not ProcessCommand(ev_msgBreakPara, true, Lo(Msg.KeyData)) then
         Msg.Result := 0;
        Exit;
       end;//..vk_Control..
      end//WantEnter
      else
      begin
       Msg.Result := 0;
       Exit;
      end;//WantEnter
    vk_Tab : {process tab command}
     if WantTab(True) then
     begin
      if not l3System.Keyboard.Key[vk_Shift].Down then
       Tabulate
      else
       Untabulate;
     end;//WantTab
   end;{Case Msg.CharCode}
 (*    {suppress the next key if this was a partial, otherwise clear flag}
   edSuppressChar := (Cmd = ccPartial);*)
  end;//ProcessCommand..
  if (Msg.CharCode = VK_APPS) then
  begin
(*   Inc(f_InPopup);
   try*)
    if l_Selection and Selection.Cursor.NeedWindowsCaret then
    begin
     GetCaretPos(TPoint(l_Pt));
     l_Pt := l_Pt.Convert(ClientToScreen);
     // Чуть сдвинем вниз, чтобы попадали в гиперссылку (cq22440)
     l_Pt.Y := l_Pt.Y + 1;
    end//l_Selection and Selection.Cursor.NeedWindowsCaret
    else
    if l_Selection AND (l_View <> nil) then
    begin
     l_Map := l_View.RootMap;
     if (l_Map = nil) then
     begin
      Msg.Result := -1;
      Exit;
     end//l_Map = nil
     else
      with Selection.Cursor.ViewBounds(l_View, l_Map) do
       l_Pt := Tl3SPoint(LP2DP(l3Point((Left + Right) div 2,
                                       (Top + Bottom) div 2), true));
    end//l_Selection..
    else
    begin
     Msg.Result := -1;
     Exit;
    end;//l_Selection..
    ShowMenu(TPoint(l_Pt));
(*   finally
    Dec(f_InPopup);
   end;//try..finally*)
   Msg.Result := -1;
   Exit;
  end;//Msg.CharCode = VK_APPS
  f_UnicodeChar := l3KeyToUnicode(Msg);
  inherited;
 finally
  afw.EndOp;
 end;//try..finally
end;

procedure TevCustomEditorWindow.WMSysKeyDown(var Msg : TWMSysKeyDown);
var
 l_Time : Cardinal;
 l_View: InevControlView;
begin
 l_Time := GetTickCount;
 {see if this command should be processed by us}
 // View надо получить заранее. Поскольку при его получении могут снести Selection
 // K-137469208
 l_View := View;
 if (Selection <> nil) AND
    (Selection.Cursor <> nil) AND
    Selection.Cursor.ProcessMessage(l_View, TMessage(Msg), l_Time) then
 begin
  Msg.Result := -1;
  Exit;
 end;//Selection.Cursor <> nil..
 if ProcessMessage(TMessage(Msg), l_Time) then
  Msg.Result := 0;
 inherited;
end;

procedure TevCustomEditorWindow.WMSetFocus(var Msg : TWMSetFocus);
{$IF Defined(Archi) or Defined(EverestLite)}
var
 l_Lock: Il3Lock;
{$IFEND}
begin
 if csDesigning in ComponentState then
  Exit;
 {$IfDef evNeedDisp}
 evOperationDispatcher.FocusChanged(Self, true);
 {$EndIf evNeedDisp}
 inherited;
 if Assigned(f_OnFocusChanged) then
  f_OnFocusChanged(Self);
 Include(fl_UpdateFlags, ev_uwfCursor);
 if (Selection <> nil) then
 begin
  if not Selection.Collapsed then
   Invalidate
  else
  if (Selection <> nil) AND
     // - эта проверка здесь нужна, т.к. проверка Selection.Collapsed может
     //   приводить к уничтожению курсора, что конечно неверно, но сейчас оно так есть.
     (Selection.Cursor <> nil) AND
     not Selection.Cursor.MostInner.NeedWindowsCaret then
   Invalidate;
 end;//Selection <> nil
 if (f_HScrollBar <> nil) then
 begin
  f_HScrollBar.OnScroll := HScrollEvent;
  SetHScrollPos;
 end;//f_HScrollBar <> nil
 {set our insert mode}
 InsertMode := Controller.InsertMode;
 if (f_Cursor <> nil) then
  f_Cursor.SetFocus;
 if (fl_UpdateFlags <> []) then
 begin
  {$IF Defined(Archi) or Defined(EverestLite)}
  Supports(Self, Il3Lock, l_Lock); // Временный запил для: [$380045677]
  try
   ParaChange;
   DoFontChange(TextPara.Font);
   StyleChangeEvent(TextPara.Style);
  finally
   l_Lock := nil;
  end;
  {$IFEND}
  if (fl_UpdateFlags = [ev_uwfCursor]) then
   // - не перерисовываем окно целиком если надо показать только курсор
   DrawCaret(true)
  else
   Invalidate;
 end;//fl_UpdateFlags <> []
end;

procedure TevCustomEditorWindow.WMKillFocus(var Msg : TWMKillFocus);
  {-}
begin
 {$IfDef evNeedDisp}
 evOperationDispatcher.FocusChanged(Self, false);
 {$EndIf evNeedDisp}
{ HideControls;}
 if (f_Cursor <> nil) then
  f_Cursor.KillFocus;
// if (f_HScrollBar <> nil) then
//  f_HScrollBar.OnScroll := nil;
 {set controller insert mode flag}
 Controller.InsertMode := InsertMode;
 inherited;

 if Assigned(f_OnFocusChanged) then
  f_OnFocusChanged(Self);
  
 if (Selection = nil) then
  Exit;
  
 if not Selection.Collapsed then
  Invalidate
 else
 if (Selection <> nil) AND (Selection.Cursor <> nil) then
 begin
  Selection.ForceStore;
  if not Selection.Cursor.MostInner.NeedWindowsCaret then
   Invalidate;
 end;//Selection.Cursor <> nil
end;

procedure TevCustomEditorWindow.WMEraseBkGnd(var Msg : TWMEraseBkGnd);
  {-}
begin
 Msg.Result := 1;  {don't erase background}
end;

procedure TevCustomEditorWindow.DoLButtonDown(const aHotSpot : IevHotSpot;
                                              const Keys     : TevMouseState;
                                              aWasSelect     : Boolean);
  {-}
var
  l_DragDC : hDC;
  l_Effect : TevMouseEffect;

  procedure InvertRect(const aPt: Tl3SPoint);
  var
   l_Rect : Tl3SRect;
  begin
   Case l_Effect.rStrob of
    afw_stVert :
    begin
     l_Rect.InitClientRect(Handle);
     l_Rect.Left := aPt.X;
     l_Rect.Right := aPt.X + 1;
     l_Rect.Invert(l_DragDC);
    end;//afw_stVert
    afw_stHorz :
    begin
     l_Rect.InitClientRect(Handle);
     l_Rect.Top := aPt.Y;
     l_Rect.Bottom := aPt.Y + 1;
     l_Rect.Invert(l_DragDC);
    end;//afw_stHorz
   end;//Case l_Effect.rStrob
  end;

 {$If not defined(NoVGScene)}
 procedure lp_ProcessVGSceneMessages;
 const
  PM_QS_PAINT = QS_PAINT shl 16;
 begin
  Tl3ProcessMessagesManager.Instance.ProcessMessages(0, 0, PM_REMOVE or PM_QS_PAINT);
 end;
 {$IfEnd} //not NoVGScene

var
  l_LeftButton    : Byte;
  l_Pt, l_OPt     : Tl3Point;
  l_sPt, l_sOpt   : Tl3SPoint;
  l_Pack          : InevOp;
  l_PrevCursor    : hCursor;
  l_Cursor        : TCursor;
  l_DeltaValue    : Tl3SPoint;
  l_Delta         : IevHotSpotDelta;
  l_Keys          : TevMouseState;
  l_Info          : TafwCursorInfo;
  l_State         : TafwCursorState;
begin
 f_WasMouseUp := false;
 Assert(SizeOf(l_State) = SizeOf(l_Keys));
 if (aHotSpot <> nil) then
 begin
  afw.BeginOp;
  try
   l_Pack := StartOp(ev_msgMove, false);
   try
    l_Pt := f_Pt;
    l_sPt := f_sPt;
    l_PrevCursor := GetCursor;
    try
     l3FillChar(l_Info, SizeOf(l_Info), 0);
     l3FillChar(l_Effect, SizeOf(l_Effect), 0);
     l_Effect.rNeedAsyncLoop := true;
     f_WasScroll := false;
     l_Keys := Keys;
     l_Keys.rInitialPoint := l_Pt;
     l_Keys.rPoint := l_Pt;
     if aWasSelect OR
        aHotSpot.LButtonDown(View, l_Keys, l_Effect) then
      if l_Effect.rNeedAsyncLoop then
       try
        with l3System.Mouse do
        begin
         l_LeftButton := LeftButton;
         SetCapture(Self.Handle);
         // - activate capture
        end;//with l3System.Mouse
        try
         fl_Capture := true;
         {get the physical left button}
         {drag highlight initially if shift key is being pressed}
        {DragH := (GetKeyState(VK_SHIFT) < 0);}
         {watch the mouse position while the left button is down}
         if (l_Effect.rStrob = afw_stNone) then
         begin
          l_DragDC := 0;
          l_DeltaValue := Point0;
         end//l_Effect.rStrob = afw_stNone
         else
         begin
          if l3IOk(aHotSpot.QueryInterface(IevHotSpotDelta, l_Delta)) then
           try
            with GetInfoCanvas do
            begin
             Lock;
             try
              l_DeltaValue := LP2DP(l3PointX(l_Delta.Delta));
             finally
              Unlock;
             end;//try..finally
            end;//with evCtrIC
           finally
            l_Delta := nil;
           end
          else
           l_DeltaValue := Point0;
          l_DragDC := l3System.GetDCEx(Handle, 0, dcx_Cache or dcx_ClipSiblings);
         end;//l_Effect.rStrob = afw_stNone
         try
          l_OPt := l_Pt;
          l_sPt.Dec(l_DeltaValue);
          l_sOPt := l_sPt;
          InvertRect(l_sPt);
          repeat
           l_Pt := GetMousePos(l_sPt);
           if f_WasScroll then
           begin
            if (l_sPt.Y >= 0) AND (l_sPt.Y <= Self.Height) then
            begin
             f_WasScroll := false;
             inherited Update;
            end;//l_sPt.Y >= 0
           end;//f_WasScroll
           if l_OPt.EQ(l_Pt) AND
              not f_WasScroll and
              not l_Effect.rExtendingSelection then
           {$If defined(Nemesis) and not defined(NoVGScene)}
            lp_ProcessVGSceneMessages
           {$IfEnd} //Nemesis and not NoVGScene
            //afw.ProcessMessages
            //ничего не делаем: были проблемы собработкой событий при мультивыделении (с Ctrl)
           else
           begin
            f_WasScroll := false;
            // - сбрасываем флаг, о том, что было скроллирование
            fl_WasAsyncLoop := true;
            l_sPt.Dec(l_DeltaValue);
            InvertRect(l_sOPt);
            InvertRect(l_sPt);
            l_Keys.rInMove := true;
            l_Keys.rPoint := l_Pt;
            if aHotSpot.MouseMove(View, l_Keys) then
            begin
             l3Move(l_Keys, l_State, SizeOf(l_State));
             aHotSpot.HitTest(View, l_State, l_Info);
             l_Cursor := evCursorShape2Cursor(l_Info.rCursor);
             if (l_Cursor = crDefault) then
              SetCursor(l_PrevCursor)
             else
              SetCursor(Screen.Cursors[l_Cursor]);
            end//aHotSpot.MouseMove(View, l_Pt, l_Keys)
            else
             SetCursor(Screen.Cursors[crNoDrop]);
            l_sOPt := l_sPt;
            l_OPt := l_Pt;
           end;//l_OPt.EQ(l_Pt) AND not f_WasScroll
          until not l3System.Keyboard.AsyncKey[l_LeftButton].Down;
         finally
          if (l_DragDC <> 0) then
          begin
           InvertRect(l_sOPt);
           l3System.ReleaseDC(Handle, l_DragDC);
          end;//l_DragDC <> 0
         end;//try..finally
        finally
         fl_Capture := false;
         l3System.Mouse.ReleaseCapture;
        end;//try..finally
       finally
        if not l3System.Keyboard.Key[vk_Control].Down then
         l_Keys.rKeys := l_Keys.rKeys - [ssCtrl];
        l_Keys.rPoint := l_Pt; 
        f_WasMouseUp := true;
        aHotSpot.LButtonUp(View, l_Keys);
        // - предыдущие две строчки намерянно местами поменяны, т.к.
        //   иначе внутри aHotSpot.LButtonUp бывают ProcessMessages и они всю малину портят
        //   http://mdp.garant.ru/pages/viewpage.action?pageId=274465892
        l_Keys.rInMove := false;
        // Это должно быть здесь, а не выше.
        // http://mdp.garant.ru/pages/viewpage.action?pageId=290264293
       end;//try..finally
    finally
     SetCursor(l_PrevCursor);
    end;//try..finally
   finally
    l_Pack := nil;
    if (TextSource <> nil) then
     TextSource.CheckCloseWindow;
   end;//try..finally
  finally
   afw.EndOp;
  end;//try..finally
 end;//aHotSpot <> nil
end;

function TevCustomEditorWindow.CheckMouseUp(const aHotSpot : IevHotSpot;
                                            const aState   : TevMouseState): Boolean;
  //virtual
  {-}
begin
 Result := false;
end;

function TevCustomEditorWindow.VScrollWidth(const anIC: Il3InfoCanvas): Integer;
begin
 if not IsVScrollBarVisible then
  Result := anIC.DP2LP(PointX(GetSystemMetrics(SM_CYVSCROLL))).X
 else
  Result := 0;
end;

function TevCustomEditorWindow.WrapLimit: Integer;
  {-}
var
 IC            : Il3InfoCanvas;
 l_Dec         : Long;
 l_ScrollWidth : Integer;
 W             : Integer;
begin
 W := pm_GetExtent.X;
 IC := GetInfoCanvas;
 IC.Font.AssignFont(Font);
 //l_Dec := LMargin;
 l_Dec := 0;
 // - это уже учли при расчёте WindowExtent
 if (l_Dec < 0) then
  Inc(l_Dec, 40);
 //Inc(l_Dec, RMargin);
 // - это уже учли при расчёте WindowExtent
 l_ScrollWidth := VScrollWidth(IC);

 Result := W - IC.DP2LP(PointX(l_Dec)).X
             - RightIndentMul*IC.AverageCharWidth
             - l_ScrollWidth;
end;

function TevCustomEditorWindow.RightIndentMul: Integer;
  //virtual;
  {-}
begin
 if AACLike = nev_aacLeft then
  Result := 0
 else
  Result := 2;
end;

function TevCustomEditorWindow.SelectWhenUnfocused: Boolean;
  {-}
begin
 {$IfDef Nemesis}
 Result := true;
 {$Else  Nemesis}
 Result := false;
 {$EndIf Nemesis}
end;

procedure TevCustomEditorWindow.DoBeforeRMouseClick;
begin

end;

procedure TevCustomEditorWindow.MouseDown(Button : TMouseButton;
                                          Shift  : TShiftState;
                                          X, Y   : Integer);
  //override;
  {-}
var
 l_HotSpot        : IevHotSpot;
 l_NeedSelectPara : Boolean;
 l_Keys           : TevMouseState;
begin
 if GetHotspotOnPoint(Point(X, Y), l_HotSpot, true) then
  try
   l3FillChar(l_Keys, SizeOf(l_Keys), 0);
   l_Keys.rInitialPoint := f_Pt;
   l_Keys.rPoint := f_Pt;
   l_Keys.rKeys := Shift;
   Case Button of
    mbLeft :
    begin
     if not Focused then
     begin
      if TabStop then
      begin
       SetFocusViaMouse;
       if not SelectWhenUnfocused then
       //Чтобы не ломать логику работы с курсором в обычном редакторе.
       begin
        f_WasMouseUp := true;
        // http://mdp.garant.ru/pages/viewpage.action?pageId=292913360
        Exit;
       end;//not SelectWhenUnfocused
      end;//TabStop
     end;//not Focused
     l_NeedSelectPara := (MilliSecondsBetween(Now, f_DoubleClickMoment) < 1000);
     if l_NeedSelectPara then
     begin
      if InevSelection(Self.Selection).Contains(Selection.Mouse) then
      begin
       Select(ev_stPara);
       l_Keys.rInitialClick := afw_ckTriple;
      end//Selection.Contains(Selection.Mouse)
      else
       l_NeedSelectPara := false;
     end;//l_NeedSelectPara
     DoLButtonDown(l_HotSpot, l_Keys, l_NeedSelectPara);
     Exit;
    end;//mbLeft
    mbRight :
    begin
     if not Focused then
      if TabStop then
       SetFocusViaMouse;
     DoBeforeRMouseClick;
     if l_HotSpot.RButtonDown(View, l_Keys) then
      Exit;
    end;//mbRight
    mbMiddle :
    begin
     if not Focused then
      if TabStop then
       SetFocusViaMouse;
     if l_HotSpot.MButtonDown(View, l_Keys) then
      Exit;
    end;//mbMiddle
   end;//Case Button
  finally
   l_HotSpot := nil;
  end;
 inherited;
end;

procedure TevCustomEditorWindow.MouseUp(Button : TMouseButton;
                                        Shift  : TShiftState;
                                        aX, aY : Integer);
  //override;
  {-}
var
 l_HotSpot : IevHotSpot;
 l_Keys    : TevMouseState;
 l_WasAsyncLoop : Boolean;
const
 c_KeyToShift: array [TMouseButton] of TShiftState = (
  [ssLeft], //mbLeft,
  [ssRight], //mbRight,
  [ssMiddle] //mbMiddle
 );
begin
 l_WasAsyncLoop := f_WasMouseUp;
 f_WasMouseUp := false;
 fl_WasAsyncLoop := false;
 if GetHotspotOnPoint(Point(aX, aY), l_HotSpot, true) then
  try
   l3FillChar(l_Keys, SizeOf(l_Keys), 0);
   l_Keys.rInitialPoint := f_Pt;
   l_Keys.rPoint := f_Pt;
   // Поправка с c_KeyToShift нужна поскольку почему-то Message.wParams = 0
   // А должны содржать MK_LBUTTON/MK_RBUTTON/MK_MBUTTON..
   // Найдено по ходу разборок с [$140287160]
   // http://mdp.garant.ru/pages/viewpage.action?pageId=140287160&focusedCommentId=142610627#comment-142610627
   l_Keys.rKeys := c_KeyToShift[Button] + Shift;
   Case Button of
    mbLeft :
    begin
     if not l_WasAsyncLoop then
      if l_HotSpot.LButtonUp(View, l_Keys) then
       Exit;
    end;//mbLeft
    mbRight :
    begin
     if not l_HotSpot.RButtonUp(View, l_Keys) then
      ShowMenu(ClientToScreen(Point(aX, aY)));
     Exit;
    end;//mbRight
    mbMiddle :
    begin
     if l_HotSpot.MButtonUp(View, l_Keys) then
      Exit;
    end;//mbMiddle
   end;//Case Button
  finally
   l_HotSpot := nil;
  end;//try..finally
 inherited;
end;

procedure TevCustomEditorWindow.SetEditRect;
  //virtual;
  {-}
begin
end;

procedure TevCustomEditorWindow.DoScrollEvent;
  {-}
begin
end;

procedure TevCustomEditorWindow.HScrollEvent(aSender          : TObject;
                                             aScrollCode      : TScrollCode;
                                             var theScrollPos : Integer);
  {-событие для горизонтального скроллинга}
begin
 if (View <> nil) then
 begin
  f_InScroll := true;
  DoScrollEvent;
  with View.Scroller[false] do
   case aScrollCode of
     scLineDown  : LineDown(1);
     scLineUp    : LineUp(1);
     scPageDown  : PageDown;
     scPageUp    : PageUp;
     scPosition,
     scTrack     : ScrollTo(theScrollPos);
     scTop       : Top;
     scBottom    : Bottom;
     scEndScroll :
     begin
      f_InScroll := false;
      if (Selection <> nil) AND
         (Selection.Caret <> nil) then
       Selection.Caret.Scrolled;
      EndScroll;
     end;//scEndScroll
   end;//Case aScrollCode
 end;//View <> nil
end;

procedure TevCustomEditorWindow.VScrollEvent(aSender          : TObject;
                                             aScrollCode      : TScrollCode;
                                             var theScrollPos : Integer);
  {* - событие для вертикального  скроллинга. }
{$IfDef Nemesis}
 {$IfOpt D-}
  {$Define NonTrackScroll}
 {$EndIf D-}
  {$Define NonTrackScroll}
{$EndIf Nemesis}
var
 l_Hint : AnsiString;
 {$IfDef NonTrackScroll}
 l_D    : Integer;
 {$EndIf NonTrackScroll}
 l_A    : InevBasePoint;
begin
 if (View <> nil) then
 begin
  DoScrollEvent;
  f_InScroll := true;
  with View.Scroller[true] do
   case aScrollCode of
     scLineDown:
      LineDown(1);
     scLineUp:
      LineUp(1);
     scPageDown:
      PageDown;
     scPageUp:
      PageUp;
     scPosition:
      ScrollTo(theScrollPos);
     scTrack:
     begin
      {$IfDef NonTrackScroll}
      l_D := theScrollPos - View.Scroller[true].Pos;
      l_A := View.TopAnchor.ClonePoint(View);
      l_A.IncLine(View, l_D, false);
      l_Hint := GetVScrollerHint(l_A);
      SetVScrollPos(theScrollPos);
      //ScrollTo(theScrollPos);
      {$Else  NonTrackScroll}
      ScrollTo(theScrollPos);
      l_A := View.TopAnchor.ClonePoint(View);
      l_Hint := GetVScrollerHint(l_A);
      {$EndIf NonTrackScroll}
      Hint := l_Hint;
      ShowHint := False;
      ActivateHint;
     end;//scTrack
     scTop:
      Top;
     scBottom:
      Bottom;
     scEndScroll :
     begin
      f_InScroll := false;
      if (Selection <> nil) AND
         (Selection.Caret <> nil) then
       Selection.Caret.Scrolled;
      CancelHint;
      EndScroll;
     end;//scEndScroll
   end;//Case aScrollCode
 end;//View <> nil
end;

procedure TevCustomEditorWindow.WMHScroll(var Msg : TWMHScroll);
var
 l_ScrollInfo : TScrollInfo;
begin
 case Msg.ScrollCode of
  SB_THUMBTRACK :
  begin
   with l_ScrollInfo do
   begin
    cbSize := SizeOf(l_ScrollInfo);
    fMask := SIF_TrackPos;
   end;//with l_ScrollInfo
   GetScrollInfo(Handle, SB_Horz, l_ScrollInfo);
  end;//SB_THUMBTRACK
  else
   l_ScrollInfo.nTrackPos := GetScrollPos(Handle, SB_Horz);
 end;//case Msg.ScrollCode
 HScrollEvent(Self, TScrollCode(Msg.ScrollCode), l_ScrollInfo.nTrackPos);
end;

procedure TevCustomEditorWindow.WMVScroll(var Msg: TWMVScroll);
  //message WM_VSCROLL;
  {-}
var
 l_ScrollInfo : TScrollInfo;
begin
 if (View <> nil) then
 begin
  case Msg.ScrollCode of
   SB_WheelUp:
   begin
    if not AutoHeightByText then
     View.Scroller[true].WheelUp;
    Exit;
  end;//SB_WheelUp
   SB_WheelDown:
   begin
    if not AutoHeightByText then
     View.Scroller[true].WheelDown;
    Exit;
   end;//SB_WheelDown
   SB_THUMBTRACK :
   begin
    with l_ScrollInfo do
    begin
     cbSize := SizeOf(l_ScrollInfo);
     fMask := SIF_TrackPos;
    end;//with l_ScrollInfo
    GetScrollInfo(Handle, SB_Vert, l_ScrollInfo);
   end;//SB_THUMBTRACK
   else
    l_ScrollInfo.nTrackPos := GetScrollPos(Handle, SB_Vert);
  end;//case Msg.ScrollCode
  VScrollEvent(Self, TScrollCode(Msg.ScrollCode), l_ScrollInfo.nTrackPos);
 end;//View <> nil
end;

procedure TevCustomEditorWindow.Select(aTarget: TevSelectTarget);
  {-выделить текущее слово, строку, параграф etc.}
begin
 if (Selection <> nil) then
  Selection.Select(aTarget);
end;

procedure TevCustomEditorWindow.WMLButtonDown(var Msg : TWMLButtonDown);
  {message WM_LBUTTONDOWN;}
  {-}
begin
 if not Focused then
 begin
  if (Selection <> nil) AND (Selection.FoundBlock <> nil) then
  begin
   SetFocusViaMouse;
   inherited;
   Exit;
  end;//FoundBlock <> nil
 end;//not Focused
 DeleteFoundRgn;
 inherited;
end;

procedure TevCustomEditorWindow.WMLButtonDblClk(var Msg : TWMLButtonDblClk);
  {message WM_LBUTTONDBLCLK;}
  {-}
var
 l_HotSpot : IevHotSpot;
 l_Effect  : TevMouseEffect;
 l_Keys    : TevMouseState;
begin
 if (csDesigning in ComponentState) then
  inherited
 else
 if GetHotspotOnPoint(Point(Msg.XPos, Msg.YPos), l_HotSpot, true) then
  try
   l3FillChar(l_Effect, SizeOf(l_Effect), 0);
   l_Effect.rNeedAsyncLoop := true;
   l_Effect.rAllowAutoSelect := true;
   l3FillChar(l_Keys, SizeOf(l_Keys), 0);
   l_Keys.rKeys := KeysToShiftState(Msg.Keys);
   l_Keys.rInitialPoint := f_Pt;
   l_Keys.rPoint := f_Pt;
   l_HotSpot.LButtonDoubleClick(View, l_Keys, l_Effect);
   if l_Effect.rNeedAsyncLoop then
   begin
    f_DoubleClickMoment := Now;
    l_Keys.rInitialClick := afw_ckDouble; 
    DoLButtonDown(l_HotSpot, l_Keys, true);
   end;//l_Effect.rNeedAsyncLoop
  finally
   l_HotSpot := nil;
  end;//try..finally
end;

procedure TevCustomEditorWindow.WMSize(var Msg: TWMSize);
  {message WM_SIZE;}
begin
 if not((Msg.Height = $FFFF) AND (Msg.Width = $FFFF)) AND HandleAllocated then
  inherited;
 Include(fl_UpdateFlags, ev_uwfCursor);
 Include(fl_UpdateFlags, ev_uwfForceHScroll);
 if (f_VRuler <> nil) then
  f_VRuler.ControlMoved;
 if (f_HRuler <> nil) then
  f_HRuler.ControlMoved;
 if HandleAllocated then
  SetEditRect;
end;

procedure TevCustomEditorWindow.evmsgNeedDoc(var Msg: TMessage);
  //message ev_msgNeedDoc;
  {-}
var
 l_Doc : Tl3Variant;  
begin
 if (f_TextSource <> nil) then
 begin
  l_Doc := f_TextSource.Document;
  // - типа прогружаем документ
  if (l_Doc = nil) OR not l_Doc.IsValid OR not f_TextSource.HasDocument then
  begin
   Inc(afwFacade.g_DisableMessageHook);
   // - временно залечиваем K290271457.script
   // http://mdp.garant.ru/pages/viewpage.action?pageId=531318437&focusedCommentId=531960334#comment-531960334
   try
    f_TextSource.DocumentContainer;
    // - пытаемся создать контейнер
    l_Doc := f_TextSource.Document;
    // - типа прогружаем документ
    if (l_Doc = nil) OR not l_Doc.IsValid OR not f_TextSource.HasDocument then
     Inc(f_NeedDocCalled);
     // - не прогрузилось :-(
     //   больше вызывать не надо
   finally
    Dec(afwFacade.g_DisableMessageHook);
   end;//try..finally
  end;//l_Doc = nil..
 end;//f_TextSource <> nil
end;

procedure TevCustomEditorWindow.WMMove(var Msg: TWMMove);
  {message WM_Move;}
begin
 inherited;
 if (f_VRuler <> nil) then
  f_VRuler.ControlMoved;
 if (f_HRuler <> nil) then
  f_HRuler.ControlMoved;
end;

procedure TevCustomEditorWindow.WMCut(var Msg: TMessage);
  {message WM_Cut;}
begin
 Cut;
 Msg.Result := 1;
end;

procedure TevCustomEditorWindow.WMCopy(var Msg: TMessage);
  {message WM_Copy;}
begin
 Copy;
 Msg.Result := 1;
end;

procedure TevCustomEditorWindow.WMPaste(var Msg: TMessage);
  {message WM_Paste;}
begin
 LongBool(Msg.Result) := Paste;
end;

procedure TevCustomEditorWindow.WMClear(var Msg: TMessage);
  {message WM_Clear;}
begin
 if IsReadOnly then
  Msg.Result := 0
 else
 begin
  Range.Delete;
  Msg.Result := 1;
 end;//IsReadOnly
end;

procedure TevCustomEditorWindow.WMUndo(var Msg: TMessage);
  {message WM_Undo;}
begin
 if Processor.Undo then
  Msg.Result := 1
 else
  Msg.Result := 0;
end;

procedure TevCustomEditorWindow.EMUndo(var Msg: TMessage);
  {message EM_Undo;}
begin
 if Processor.Undo then
  Msg.Result := 1
 else
  Msg.Result := 0;
end;

procedure TevCustomEditorWindow.EMRedo(var Msg: TMessage);
  {message EM_Redo;}
  {-}
begin
 if Processor.Redo then
  Msg.Result := 1
 else
  Msg.Result := 0;
end;

function TevCustomEditorWindow.pm_GetModified: Boolean;
  {-}
begin
 if (TextSource = nil) then
  Result := false
 else
  Result := TextSource.Modified;
end;

procedure TevCustomEditorWindow.pm_SetModified(aValue: Boolean);
  {-}
begin
 if (TextSource <> nil) then
  TextSource.Modified := aValue;
end;

procedure TevCustomEditorWindow.EMGetModify(var Msg: MemGetModify);
  {message EM_GetModify;}
begin
 Msg.Modified := Modified;
end;

procedure TevCustomEditorWindow.EMSetModify(var Msg: MemSetModify);
  {message EM_SetModify;}
begin
 Modified := Msg.Modified;
end;

procedure TevCustomEditorWindow.EMCanPaste(var Msg: TMessage);
  {message EM_CanPaste;}
var
 l_Formats : Tl3ClipboardFormats;
 l_Index   : Integer;
begin
 LongBool(Msg.Result) := false;
 l_Formats := GetAcceptableFormats;
 for l_Index := Low(l_Formats) to High(l_Formats) do
  if (Cardinal(Msg.wParam) = l_Formats[l_Index]) then
  begin
   LongBool(Msg.Result) := true;
   break;
  end;//Msg.wParam = l_Formats[l_Index]
end;

procedure TevCustomEditorWindow.EMPasteSpecial(var Msg: TMessage);
  {message EM_PasteSpecial;}
begin
 if (Msg.wParam = 0) then
  Paste
 else
  PasteFromClipboard(Msg.wParam, nil);
end;

procedure TevCustomEditorWindow.EMScrollCaret(var Msg: TMessage);
  {message EM_ScrollCaret;}
begin
 Msg.Result := Ord((f_Cursor <> nil) AND f_Cursor.Show);
end;

procedure TevCustomEditorWindow.EMSetReadOnly(var Msg: TEMSetReadOnly);
  {message EM_SetReadOnly;}
begin
 f_ReadOnly := Msg.ReadOnly;
 Msg.Result := true;
end;

{$IfDef Nemesis}
procedure TevCustomEditorWindow.WMWindowPosChanging(var Msg: TWMWindowPosChanging);
  {message WM_WINDOWPOSCHANGING;}
var
 l_WindowPosFlags: UINT;
 l_AllowZOrderChanging: Boolean;
begin
 inherited;
 l_AllowZOrderChanging := True;
 l_WindowPosFlags := Msg.WindowPos^.flags;
 // Костыль для http://mdp.garant.ru/pages/viewpage.action?pageId=488604061
 // Ибо по-другому - не получилось и медали все равно исчезают.
 // Пусть снаружи решает, можно ли менять Z-порядок
 if ((l_WindowPosFlags and SWP_NOZORDER) = 0) and (Assigned(f_OnZOrderChanging)) then
 begin
  f_OnZOrderChanging(Self, l_AllowZOrderChanging);
  if (not l_AllowZOrderChanging) then
  begin
   l_WindowPosFlags := l_WindowPosFlags OR SWP_NOZORDER;
   Msg.WindowPos^.flags := l_WindowPosFlags;
   Msg.Result := 0;
  end;
 end;
end;
{$EndIf Nemesis}

function TevCustomEditorWindow.IsReadOnly: Boolean;
  {-}
begin
 Result := f_ReadOnly;
end;

procedure TevCustomEditorWindow.CreateWindowHandle(const Params: TCreateParams);
  //override;
  {-}
begin
 inherited;
 if HandleAllocated then
  ShowScrollBar(Handle, SB_Horz, false);
 Include(fl_UpdateFlags, ev_uwfForceHScroll);
end;

function TevCustomEditorWindow.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  {override;}
  {-}
begin
 Result.SetOk;
 if IID.EQ(Il3Progress) then
 begin
  if Supports(TextSource, IID.IID, Obj) then
   Result.SetOk
  else
   Result.SetNoInterface;
 end
 else
 if IID.EQ(InevProcessor) then
 begin
  Assert(false, 'Кому бы это могло понадобится так получать процессор');
  if Supports(Processor, IID.IID, Obj) then
   Result.SetOk
  else
   Result.SetNoInterface;
 end
 {$IfNDef DesignTimeLibrary}
 else
 if IID.EQ(Il3FontInfo) then
  Result := Tl3HResult_C(TextPara.Font.QueryInterface(Il3FontInfo, Obj))
 else
 if IID.EQ(Il3Font) then
  Il3Font(Obj) := TextPara.Font
 {$EndIf  DesignTimeLibrary}
 else
 if IID.EQ(Il3FontInfo2) then
 begin
  if (f_CurFont[false] = nil) then
   Result.SetNoInterface
  else
   Il3FontInfo2(Obj) := Il3FontInfo2(f_CurFont[false].AsFont(false));
 end//IID.EQ(Il3FontInfo2)
 {$IfNDef DesignTimeLibrary}
 else
 if IID.EQ(IedParagraphFormatting) then
  IedParagraphFormatting(Obj) := TextPara.Formatting
 else
 if IID.EQ(IedTextParagraph) then
  IedTextParagraph(Obj) := TextPara
 {$EndIf DesignTimeLibrary}
 else
 if IID.SomeOf([IevSubFlagsSpy, IevSubCache]) then
 begin
  if Supports(VSubPanel, IID.IID, Obj) then
   Result.SetOk
  else
   Result.SetNoInterface;
 end//..IevSubFlagsSpy, IevSubCache..
 else
 if IID.EQ(IevRange) then
 begin
  if (Selection = nil) then
   Result.SetNoInterface
  else
   IevRange(Obj) := Selection;
 end//IID.EQ(IevRange)
 else
  Result := inherited COMQueryInterface(IID, Obj);
end;

function TevCustomEditorWindow.GetHorzDelta: Integer;
  //virtual;
  {- зазор, после которого начинается скроллирование вправо. }
begin
 Result := l3Inch div 2;
end;

procedure TevCustomEditorWindow.MakeView;
  {-}
begin
 if (f_View = nil) then
 begin
  f_WasFirstPaint := False;
  f_View := TnevView.Make(Self, GetHorzDelta);
  if HRuler <> nil then
   HRuler.ViewChanged(f_View);
  if VRuler <> nil then
   VRuler.ViewChanged(f_View);
  UpdateScrollRange;
  if (f_Cursor <> nil) then
   f_Cursor.LinkView(f_View);
 end;//f_View = nil
end;

procedure TevCustomEditorWindow.MakeCursor;
  {-}
var
 l_FI         : TnevFormatInfoPrim;
 l_Point      : TPoint;
 l_Document   : Tl3Variant;
 l_NeedScroll : Boolean;
begin
 AdjustHeightByText;
 {.$IfNDef DesignTimeLibrary}
 if (f_InPaint <= 0) then
 begin
  try
   if (f_Cursor = nil) then
   begin
    if (f_TextSource = nil) then
     Exit;
    DoMakeCursorHolder;
   end;
   if (f_TextSource = nil) then
   begin
    FreeCursor;
    Exit;
   end;//TextSource = nil
   if (f_Cursor = nil) then
   begin
    Assert(not TextSource.HasDocument);
    Exit;
   end;//f_Cursor = nil
   l_Document := TextSource.Document;
   if (f_Cursor = nil) then
    // - если быстро перегружать документы, то в момент получения документа
    //   курсор могли грохнуть.
    //   Раньше было: f_Cursor.Document := TextSource.Document;
    Exit;
   l_NeedScroll := not f_Cursor.Document.IsSame(l_Document);
    // - проверяем, что документ изменился
   f_WasFirstPaint := False;
    // - документ поменялся сбросим флаг первой отрисовки
   if l_NeedScroll AND (f_Cursor <> nil) then
   begin
    f_Cursor.ForceStore;
   end;//l_NeedScroll AND (f_Cursor <> nil)
   MakeView;
   if (f_Cursor <> nil) then
   begin
    Assert((f_View = nil) OR (f_View.Control <> nil));
    Assert(l3IEQ(f_Cursor.View, f_View));
    f_Cursor.Document := l_Document;
    if l_NeedScroll AND (f_Cursor <> nil) then
    // проверка видимости параграфа для http://mdp.garant.ru/pages/viewpage.action?pageId=88081570
     if (f_Cursor.Cursor <> nil) then
      with f_Cursor.Cursor.MostInner do
      begin
       l_FI := View.FormatInfoByPara(Obj);
       if (l_FI <> nil) and l_FI.IsHidden(false, true) then
       begin
        Inc(f_LockForceRepaint);
        // http://mdp.garant.ru/pages/viewpage.action?pageId=244712636&focusedCommentId=263292913#comment-263292913
        try
         Move(View, ev_ocParaDown);
        finally
         Dec(f_LockForceRepaint);
        end;//try..finally
       end;//Obj.IsHiddenPrim..
      end;
   end;//f_Cursor <> nil
   if l_NeedScroll then
    // - боремся с http://mdp.garant.ru/pages/viewpage.action?pageId=135597645&focusedCommentId=135598772#comment-135598772
   begin
    if f_CursorFromHistory then
     InitAACLikeCursor;
    if HandleAllocated then
     ShowScrollBar(Handle, SB_Horz, false);
    Include(fl_UpdateFlags, ev_uwfForceHScroll);
   end;//l_NeedScroll 
   if l_NeedScroll then
    View.Scroller[true].Top;
    // - иначе при смене документа могла показываться "середина" нового документа
   if HasDocument then
    f_NeedDocCalled := 0;
  {$IF not Defined(Archi) and not Defined(EverestLite)}
   // Передеонем виндовый курсор - чтобы обновился HotSpot.
   if HandleAllocated and Visible and GetCursorPos(l_Point) and
    PtInRect(ClientRect,ScreenToCLient(l_Point)) then
     UpdateCursorFromHotSpot;
  {$IFEND}
  finally
   Include(fl_UpdateFlags, ev_uwfCursor);
  end;//try..finally
 end;//f_InPaint <= 0
 {.$EndIf DesignTimeLibrary}
end;

procedure TevCustomEditorWindow.InitAACLikeCursor;
begin
 DoInitAACLikeCursor;
end;

procedure TevCustomEditorWindow.DoInitAACLikeCursor;
begin

end;

function TevCustomEditorWindow.GetCaret: Il3Caret;
  //virtual;
  {-}
begin
 if (Selection <> nil) then
  Result := Selection.Caret
 else
  Result := nil;
end;

procedure TevCustomEditorWindow.SetSelectionFromHistory(aSelection       : TnevSelection;
                                                        const aContainer : InevDocumentContainer);
  {-}
var
 l_Lock : Long;
begin
 f_CursorFromHistory := False;
 if (f_Cursor = nil) AND (aSelection = nil) AND (aContainer <> nil) then
  TextSource.SetDocumentContainerFromHistory(aContainer)
 else
 if (f_Cursor <> aSelection) then
 begin
  if (f_Cursor <> nil) then
   l_Lock := f_Cursor.xxxLock
  else
   l_Lock := 0;
  FreeCursor;
  if l3Set(f_Cursor, aSelection) then
  begin
   if (f_Cursor <> nil) then
    f_Cursor.xxxLock := l_Lock;
   Lock(Self);
   try
    f_CursorFromHistory := True;
    if (f_Cursor <> nil) then
     f_Cursor.Caret.Owner := Self;
    TextSource.SetDocumentContainerFromHistory(aContainer);
   finally
    Unlock(Self);
   end;//try..finally
  end//l3Set(f_Cursor, aSelection)
  else
  if (aContainer <> nil) then
   TextSource.SetDocumentContainerFromHistory(aContainer);
 end;//f_Cursor <> aSelection
end;

function TevCustomEditorWindow.MouseAction(const aHotSpot : IevHotSpot;
                                           aButton        : TevMouseButton;
                                           anAction       : TevMouseAction;
                                           const Keys     : TevMouseState;
                                           var Effect     : TevMouseEffect): Boolean;
  {-}
begin
 if Assigned(f_OnMouseAction) then
  Result := f_OnMouseAction(aHotSpot, aButton, anAction, Keys.rKeys, Effect.rNeedAsyncLoop)
 else
  Result := false; 
end;

function TevCustomEditorWindow.IevReplacer_pm_GetText: AnsiString;
  {-}
begin
 Result := '';
end;

function TevCustomEditorWindow.IevReplacer_pm_GetOptions: TevSearchOptionSet;
  {-}
begin
 Result := f_SearchOptions;
end;

procedure TevCustomEditorWindow.IevReplacer_pm_SetOptions(Value: TevSearchOptionSet);
  {-}
begin
 f_SearchOptions := Value;
end;

procedure TevCustomEditorWindow.IevReplacer_Start;
  {* - начало поиска. }
begin
end;

procedure TevCustomEditorWindow.IevReplacer_Finish(aCancel: Boolean; const aBlock: InevRange);
  {* - конец поиска. }
begin
end;

function TevCustomEditorWindow.IevReplacer_Get_Searcher: IevSearcher;
  {-}
begin
 Result := nil;
end;

procedure TevCustomEditorWindow.IevReplacer_Set_Searcher(const aValue: IevSearcher);
  {-}
begin
end;

function TevCustomEditorWindow.Get_ReplaceCount: Integer;
begin
 Result := 0;
end;

function TevCustomEditorWindow.FakeReplace(const Container : InevOp;
                                           const aBlock    : InevRange;
                                           const aConfirm  : InevConfirm): Boolean;
  {-}
begin
 Result := false;
 if not (ev_soNoSelection in f_SearchOptions) then
  Selection.FoundBlock := aBlock;
end;

function TevCustomEditorWindow.IevReplacer_NeedProgress: Boolean;
  {-}
begin
 Result := false;
end;

procedure TevCustomEditorWindow.DoSetFlag(aFlag: TevUpdateWindowFlag);
  {-}
begin
 Include(fl_UpdateFlags, aFlag);
(* if ([ev_uwfWasScroll, ev_uwfBlock] * fl_UpdateFlags =
     [ev_uwfWasScroll, ev_uwfBlock]) then*)
 if (aFlag = ev_uwfBlock) then
 begin
  if not DeleteFoundRgn then
   Invalidate;
 end;//aFlag = ev_uwfBlock
end;

procedure TevCustomEditorWindow.RedrawCaret;
  {-}
begin
 SetFlag(ev_uwfCursor);
end;

procedure TevCustomEditorWindow.WasScroll;
  {-}
begin
 SetFlag(ev_uwfWasScroll);
 SetFlag(ev_uwfCursor);
end;

function TevCustomEditorWindow.DataCodePage: Integer;
  //override;
  {-}
begin
 Result := CurText.SCodePage;
end;

{$IfDef evNeedDisp}
function TevCustomEditorWindow.Get_ActionData(Action: Long): Long;
begin
 Case TevOperation(Action) of
  ev_ccZoom:
   Result := Zoom;
  else
   Result := 0;
 end;//Case TevOperation(Action)
end;

procedure TevCustomEditorWindow.Set_ActionData(Action: Long; Value: Long);
  {-}
begin
 Case TevOperation(Action) of
  ev_ccZoom: begin
   if (f_Canvas <> nil) then
    Canvas.Zoom := Value;
   if (HRuler <> nil) then
    HRuler.Zoom := Value;
   if (VRuler <> nil) then
    VRuler.Zoom := Value;
   if (VSubPanel <> nil) then
    VSubPanel.Zoom := Value;
   if HandleAllocated then
   begin
    UpdateScrollRange;
    Invalidate;
   end;//HandleAllocated
  end;//ev_ccZoom
 end;//Case TevOperation(Action)
end;
{$EndIf evNeedDisp}

type
  IevBaseEditorState = interface(IUnknown)
    ['{0EEEC8CA-EF49-4713-BCFD-A706D7A32302}']
    // public methods
      function  GetTopTag: InevBasePoint;
        {-}
  end;//IevBaseEditorState

  IevEditorStatePrim = interface(IevBaseEditorState)
    ['{8A5F9909-5F63-4212-96D6-83A99F19B736}']
    // public methods
      function  GetCursor: InevBasePoint;
        {-}
      procedure SetAll(const aTag    : InevBasePoint;
                       const aCursor : InevBasePoint);
        {-}
  end;//IevEditorStatePrim

  IevEditorState = interface(IevBaseEditorState)
    ['{94FD0226-9512-442F-813C-84EB488F965B}']
    // public methods
      function  GetSelection: TnevSelection;
        {-}
      function  GetContainer: InevDocumentContainer;
        {-}
      function  GetCacheKey: TevPreviewCacheKey;
        {-}
      procedure SetAll(const aTag       : InevBasePoint;
                       aSelection       : TnevSelection;
                       const aContainer : InevDocumentContainer;
                       const aCacheKey : TevPreviewCacheKey);
        {-}
  end;//IevEditorState

  TevBaseEditorState = class(Tl3CacheableBase)
    private
    // internal fields
      f_Tag : InevBasePoint;
    private
    // interface methods
      // IevEditorStatePrim
      function  GetTopTag: InevBasePoint;
        {-}
      procedure SetAllPrim(const aTag: InevBasePoint);
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(const aTag : InevBasePoint);
        reintroduce;
        {-}
  end;//TevBaseEditorState

constructor TevBaseEditorState.Create(const aTag : InevBasePoint);
  //reintroduce;
  {-}
begin
 inherited Create;
 f_Tag := aTag;
end;

procedure TevBaseEditorState.Cleanup;
  //override;
  {-}
begin
 f_Tag := nil;
 inherited;
end;

function TevBaseEditorState.GetTopTag: InevBasePoint;
  {-}
begin
 Result := f_Tag;
end;

procedure TevBaseEditorState.SetAllPrim(const aTag: InevBasePoint);
  {-}
begin
 f_Tag := aTag;
end;

type
  TevEditorStatePrim = class(TevBaseEditorState, IevEditorStatePrim)
    private
    // internal fields
      f_Cursor : InevBasePoint;
    private
    // interface methods
      // IevEditorStatePrim
      function  GetCursor: InevBasePoint;
        {-}
      procedure SetAll(const aTag    : InevBasePoint;
                       const aCursor : InevBasePoint);
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(const aTag    : InevBasePoint;
                         const aCursor : InevBasePoint);
        reintroduce;
        {-}
      class function Make(const aTag    : InevBasePoint;
                          const aCursor : InevBasePoint): IevEditorStatePrim;
        {-}
  end;//TevEditorStatePrim

constructor TevEditorStatePrim.Create(const aTag    : InevBasePoint;
                                      const aCursor : InevBasePoint);
  //reintroduce;
  {-}
begin
 inherited Create(aTag);
 f_Cursor := aCursor;
end;

class function TevEditorStatePrim.Make(const aTag    : InevBasePoint;
                                       const aCursor : InevBasePoint): IevEditorStatePrim;
  {-}
var
 l_State : TevEditorStatePrim;
begin
 l_State := Create(aTag, aCursor);
 try
  Result := l_State;
 finally
  l3Free(l_State);
 end;//try..finally
end;

procedure TevEditorStatePrim.Cleanup;
  //override;
  {-}
begin
 f_Cursor := nil;
 inherited;
end;

function TevEditorStatePrim.GetCursor: InevBasePoint;
  {-}
begin
 Result := f_Cursor;
end;

procedure TevEditorStatePrim.SetAll(const aTag    : InevBasePoint;
                                    const aCursor : InevBasePoint);
  {-}
begin
 SetAllPrim(aTag);
 f_Cursor := aCursor;
end;

type
  TevEditorState = class(TevBaseEditorState, IevEditorState)
    private
    // internal fields
      f_Selection    : TnevSelection;
      f_Container    : InevDocumentContainer;
      f_CacheKey: TevPreviewCacheKey;
    private
    // interface methods
      // IevEditorState
      function  GetSelection: TnevSelection;
        {-}
      function  GetContainer: InevDocumentContainer;
        {-}
      function  GetCacheKey: TevPreviewCacheKey;
        {-}
      procedure SetAll(const aTag       : InevBasePoint;
                       aSelection       : TnevSelection;
                       const aContainer : InevDocumentContainer;
                       const aCacheKey: TevPreviewCacheKey);
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(const aTag       : InevBasePoint;
                         aSelection       : TnevSelection;
                         const aContainer : InevDocumentContainer;
                         const aCacheKey: TevPreviewCacheKey);
        reintroduce;
        {-}
      class function Make(const aTag       : InevBasePoint;
                          aSelection       : TnevSelection;
                          const aContainer : InevDocumentContainer;
                          const aCacheKey: TevPreviewCacheKey): IevEditorState;
        {-}
      function  COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
  end;//TevEditorState

constructor TevEditorState.Create(const aTag       : InevBasePoint;
                                  aSelection       : TnevSelection;
                                  const aContainer : InevDocumentContainer;
                                  const aCacheKey: TevPreviewCacheKey);
  //reintroduce;
  {-}
begin
 inherited Create(aTag);
 SetAll(aTag, aSelection, aContainer, aCacheKey);
end;

class function TevEditorState.Make(const aTag       : InevBasePoint;
                                   aSelection       : TnevSelection;
                                   const aContainer : InevDocumentContainer;
                                   const aCacheKey: TevPreviewCacheKey): IevEditorState;
  {-}
var
 l_State : TevEditorState;
begin
 l_State := Create(aTag, aSelection, aContainer, aCacheKey);
 try
  Result := l_State;
 finally
  l3Free(l_State);
 end;//try..finally
end;

function TevEditorState.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {-}
begin
 Result := inherited COMQueryInterface(IID, Obj);
 if Result.Fail then
  if Supports(f_Container, IID.IID, Obj) then
   Result.SetOk;
end;

procedure TevEditorState.Cleanup;
  //override;
  {-}
begin
 l3Free(f_Selection);
 f_Container := nil;
 inherited;
end;

function TevEditorState.GetCacheKey: TevPreviewCacheKey;
begin
 Result := f_CacheKey;
end;

function TevEditorState.GetSelection: TnevSelection;
  {-}
begin
 Result := f_Selection;
end;

function TevEditorState.GetContainer: InevDocumentContainer;
  {-}
begin
 Result := f_Container;
end;

procedure TevEditorState.SetAll(const aTag       : InevBasePoint;
                                aSelection       : TnevSelection;
                                const aContainer : InevDocumentContainer;
                                const aCacheKey: TevPreviewCacheKey);
  {-}
begin
 SetAllPrim(aTag);
 l3Set(f_Selection, aSelection);
 f_Container := aContainer;
 if (f_Selection <> nil) then
  f_Selection.ForceStore;
 f_CacheKey := aCacheKey;
end;

{$IfNDef NoVCM}
function TevCustomEditorWindow.IvcmState_SaveState(out aState : IUnknown;
                                                   aStateType : TvcmStateType): Boolean;
var
 l_Anchor : InevBasePoint;
begin
 if not HasDocument then
  // - документа нет, сохранять нечего;
 begin
  Result := True;
  Case aStateType of
   vcm_stContent:
    aState := TevEditorState.Make(nil, nil, nil, MakePreviewKey);
   vcm_stPosition:
    aState := TevEditorStatePrim.Make(nil, nil);
  end;
  Exit;
 end;//if not HasDocument then
 if (View = nil) then
  l_Anchor := nil
 else
 if (View.TopAnchor = nil) then
  l_Anchor := nil
 else
  l_Anchor := View.TopAnchor.ClonePoint(View);
 Case aStateType of
  vcm_stContent :
  begin
   Result := true;
   if (f_TextSource <> nil) then
   begin
    //f_CheckedBookmarks := false;
    if (f_TextSource.DocumentContainer <> nil) AND
     f_TextSource.DocumentContainer.AbortedLoad then
    begin
     aState := TevEditorState.Make(l_Anchor,
                                   nil,
                                   TextSource.DocumentContainer,
                                   MakePreviewKey);
     Exit;
    end
    else
     aState := TevEditorState.Make(l_Anchor,
                                   Selection,
                                   TextSource.DocumentContainer,
                                   MakePreviewKey);
   end//f_TextSource <> nil
   else
   begin
    aState := TevEditorState.Make(l_Anchor,
                                  Selection,
                                  nil,
                                  MakePreviewKey);
   end;//f_TextSource <> nil
   FreeCursor;  
   if (f_TextSource <> nil) then
    f_TextSource.DocumentContainer := nil;
  end;//vcm_stContent
  vcm_stPosition :
  begin
   Result := true;
   aState := TevEditorStatePrim.Make(l_Anchor, Selection.Cursor.ClonePoint(View));
  end;//vcm_stPosition
  else
   Result := false;
 end;//Case aStateType
end;

function TevCustomEditorWindow.IvcmState_LoadState(const aState : IUnknown;
                                             aStateType : TvcmStateType;
                                             aClone: Boolean): Boolean;
var
 l_Selection    : TnevSelection;
 l_Container    : InevDocumentContainer;
 l_Tag          : InevBasePoint;
 l_Anchor       : InevBasePoint;
 l_Cursor       : InevBasePoint;
begin
 // Документа нет, создавать его тоже нельзя, так как в процессе перехода форме
 // еще не подменили контейнер данных (_IvcmFormDataSource) и соответственно
 // после завершения перехода будет показан неправильный документ (CQ: OIT5-26463):
 if HasDocument then
 begin
  if (View = nil) OR (View.TopAnchor = nil) then
   l_Anchor := nil
  else
   l_Anchor := View.TopAnchor.ClonePoint(View);
 end//HasDocument
 else
  l_Anchor := nil;
 Case aStateType of
  vcm_stContent :
  begin
   //f_CheckedBookmarks := false;
   Result := true;
   Lock(Self);
   try
    with (aState As IevEditorState) do
    begin
     l_Tag := GetTopTag;
     l_Container := GetContainer;
     f_HiddenStyles := GetCacheKey.HiddenStyles;
     f_PreviewCaleeArea := GetCacheKey.CaleeArea;
     try
      l_Selection := GetSelection.Use;
      try
       if TextSource.HasDocument then
        SetAll(l_Anchor,
               Selection,
               TextSource.DocumentContainer,
               MakePreviewKey)
       else
        SetAll(l_Anchor,
               Selection,
               nil,
               MakePreviewKey);
       SetSelectionFromHistory(l_Selection, l_Container);
      finally
       l3Free(l_Selection);
      end;//try..finally
     finally
      l_Container := nil;
     end;//try..finally
     if (l_Tag <> nil) then
     begin
      CheckView(l_Tag);
      //  V - http://mdp.garant.ru/pages/viewpage.action?pageId=342859301, ибо в CheckView в случае переключения базы f_Document := nil
      if (f_Document <> nil) and (View <> nil) AND (View.TopAnchor <> nil) then
       View.TopAnchor.AssignPoint(View, l_Tag);
     end;//l_Tag <> nil
    end;//with (aState As IevEditorState) do
   finally
    UnLock(Self);
   end;//try..finally
  end;//vcm_stContent
  vcm_stPosition :
  begin
   Result := true;
   Lock(Self);
   try
    with (aState As IevEditorStatePrim) do
    begin
     l_Tag := GetTopTag;
     l_Cursor := GetCursor;
     SetAll(l_Anchor, Selection.Cursor.ClonePoint(View));
     if (l_Tag <> nil) then
     begin
      CheckView(l_Tag);
      InevSelection(Self.Selection).SelectPoint(l_Cursor, false, false);
      if (View <> nil) then
       View.TopAnchor.AssignPoint(View, l_Tag);
     end;//l_Tag <> nil
    end;//with (aState As IevEditorStatePrim)
    Invalidate;
   finally
    UnLock(Self);
   end;//try..finally
  end;//vcm_stPosition
  else
   Result := false;
 end;//Case aStateType
end;

function TevCustomEditorWindow.IvcmCloneableState_SaveState(out aState : IUnknown;
                                                            aStateType : TvcmStateType): Boolean;
begin
 Result := False;
end;

function TevCustomEditorWindow.IvcmCloneableState_LoadState(const aState : IUnknown;
                                                            aStateType   : TvcmStateType): Boolean;
begin
 Result := False;
end;                              

{$EndIf  NoVCM}

function TevCustomEditorWindow.GetLimitWidth: Integer;
  {-}
(*var
 l_Canvas: InevInfoCanvas;*)
begin
 if WebStyle then
  Result := WrapLimit
 else
 begin
  Result := Document.AsObject.IntA[k2_tiWidth];
  // - иначе форматировли не по ширине документа
(*  l_Canvas := pm_GetInfoCanvas;
  if l_Canvas <> nil then
   Result := (l_Canvas as Il3Canvas).PageSetup.PaperWidth
  else
  Result := l3NilLong;*) 
 end;
end; 

procedure TevCustomEditorWindow.InvalidateShape(const aShape      : InevObject;
                                                aParts : TnevShapeParts);
  {-}
begin
 if (f_View <> nil) then
 begin
  if (f_InPaint > 0) then
   Exclude(aParts, nev_spExtent);
   // - чтобы не выдернуть форматирование из под ног в процессе отрисовки
   //   http://mdp.garant.ru/pages/viewpage.action?pageId=121831634.
  f_View.InvalidateShape(aShape, aParts);
 end;//f_View <> nil
end;

procedure TevCustomEditorWindow.Changed(aPlace: TnevChangePlace);
  {-}
begin
 DoChanged(aPlace);
end;

procedure TevCustomEditorWindow.DoChanged(aPlace: TnevChangePlace);
  {-}
begin
 if (aPlace <> nev_cpView) then
 begin
  if Locked then
   Include(fl_UpdateFlags, ev_uwfText)
  else
   if f_MakingTextSourceCounter = 0 then
    TextChange;
 end;//aPlace <> nev_cpView
 if (aPlace in [nev_cpView, nev_cpPara]) then
 begin
  // Assert(f_InPaint <= 0);
  // ^ - Закомментировано: http://mdp.garant.ru/pages/viewpage.action?pageId=610313141
  if (f_InPaint <= 0) then
  // http://mdp.garant.ru/pages/viewpage.action?pageId=296096620
  begin
   if (f_View <> nil) then
    f_View.ClearShapes;
   Invalidate;
  end;//f_InPaint <= 0
 end;//aPlace in [nev_cpView, nev_cpPara]
end;

procedure TevCustomEditorWindow.pm_SetShowDocumentParts(Value: Boolean);
  {-}
begin
 if (f_ShowDocumentParts <> Value) then
 begin
  f_ShowDocumentParts := Value;
  if (VSubPanel <> nil) then
   (VSubPanel As IevSubCache).ClearSubs;
  {$IfDef evNotArchi}
  {$Else  evNotArchi}
  if not Value then
   if (TextSource <> nil) then
    TextSource.ShowLevel := 0;
  {$EndIf evNotArchi}
  if (f_View <> nil) then
   f_View.ClearShapes;
  SetFlag(ev_uwfCursor);
  Invalidate;
  if Assigned(f_OnShowDocumentPartsChanged) then
   f_OnShowDocumentPartsChanged(Self);
 end;//f_ShowDocumentParts <> Value
end;

function TevCustomEditorWindow.GetInClose: Boolean; 
begin
 Result := HasDocument and TextSource.DocumentContainer.AbortedLoad;
end;

function TevCustomEditorWindow.GetViewArea: InevViewArea;
  {-}
begin
 Result := Self;
end;

function TevCustomEditorWindow.GetData: InevObject;
  {-}
begin
 Result := Document;
end;

function TevCustomEditorWindow.GetProcessor: InevProcessor;
  {-}
begin
 Result := Processor;
end;

function TevCustomEditorWindow.GetSelection: InevSelection;
  {-}
begin
 Result := Selection;
end;

function TevCustomEditorWindow.UpdateCursorFromHotSpotEx(anX, anY : Integer): Boolean;
var
 l_HotSpot : IevHotSpot;
 l_sPt     : Tl3SPoint;
 l_Pt      : Tl3Point;
begin
 // Этот метод сделан чисто для тестов, как ручка, чтобы получить HotSpot в указанном месте
 l_Pt := GetMousePos(l_sPt);
 if GetHotspotOnPoint(Point(anX, anY), l_HotSpot, true) then
  try
   Result := true;
   try
    DoSetCursor(l_Pt, l_HotSpot);
   except
    // - это лечили 'Невозможно получить процессор операций.' при перегрузке
    //   документа после перехода по ссылке
    // on что-то do ;
   end;//try..except
  finally
   l_HotSpot := nil;
  end//try..finally
 else
  Result := false;
end;

function TevCustomEditorWindow.UpdateCursorFromHotSpot: Boolean;
var
 l_Canvas  : InevInfoCanvas;
 l_HotSpot : IevHotSpot;
 l_sPt     : Tl3SPoint;
 l_Pt      : Tl3Point;
begin
 { избавляюсь от повторяющегося кода }
 // - не надо UpdateCursorFromHotSpotEx - чисто для тестов ручка
 try
  l_Pt := GetMousePos(l_sPt);
  if GetHotspotOnPoint(Point(l_sPt.X, l_sPt.Y), l_HotSpot, true) then
   try
    Result := true;
    try
     DoSetCursor(l_Pt, l_HotSpot);
    except
     // - это лечили 'Невозможно получить процессор операций.' при перегрузке
     //   документа после перехода по ссылке
     // on что-то do ;
    end;//try..except
   finally
    l_HotSpot := nil;
   end//try..finally
  else
   Result := false;
 except
  on EIntOverflow do
  begin
   l_Canvas := GetInfoCanvas;
   try
    l3System.Msg2Log('EIntOverflow: DC = %d, l_sPt.X = %d, l_sPt.Y = %d', [l_Canvas.DC, l_sPt.X, l_sPt.Y]);
    l3System.Msg2Log('EIntOverflow: PixelsPerInchX = %d, PixelsPerInchY = %d', [l_Canvas.PixelsPerInchX, l_Canvas.PixelsPerInchY]);
   finally
    l_Canvas := nil;
   end;
   Result := False;
  end;
 end;
 //Result := UpdateCursorFromHotSpotEx(l_sPt.X, l_sPt.Y);
end;

function TevCustomEditorWindow.MakePreviewKey: TevPreviewCacheKey;
  {-}
begin
 Result.HiddenStyles := HiddenStyles;
 Result.CaleeArea := PreviewCaleeArea;
end;

function TevCustomEditorWindow.ProcessHotSpots: Boolean;
  //virtual;
  {-}
begin
 Result := true;
end;

procedure TevCustomEditorWindow.WMSetCursor(var Msg : TWMSetCursor);
var
 Control  : TControl;
 P        : TPoint;
 l_Cursor : TCursor;
begin
 if (not (csDesigning in ComponentState)) and
    (Msg.HitTest = HTCLIENT) then
  begin
   if ProcessHotSpots then
   begin
    GetCursorPos(P);
    Control := ControlAtPos(ScreenToClient(P), False);
    if (Control <> nil) then
    begin
     inherited;
     Exit;
    end;//Control <> nil
    if not UpdateCursorFromHotSpot then
     inherited;
   end//ProcessHotSpots
   else
   begin
    GetCursorPos(P);
    l_Cursor := crDefault;
    RecalcScreenCursor(ScreenToClient(P), l_Cursor);
    if (l_Cursor <> crDefault) then
     SetCursorToScreen(l_Cursor)
    else
     inherited;
   end;//ProcessHotSpots
 end//not (csDesigning in ComponentState)..
 else
  inherited;
end;

function TevCustomEditorWindow.SetVScrollPos(aPos: Integer): Boolean;
  {-устанавливает позицию вертикального ScrollBar'а}
var
 l_Pos        : Integer;
 l_ScrollInfo : TScrollInfo;
 l_Scroller   : InevScroller;
begin
 Result := false;
 if not HandleAllocated then
  Exit; // - нечего скроллировать, если окна не было
 l_Scroller := View.Scroller[true];
 if (l_Scroller = nil) then
  Exit;
 l3FillChar(l_ScrollInfo, SizeOf(l_ScrollInfo), 0);
 with l_ScrollInfo do
 begin
  cbSize := SizeOf(l_ScrollInfo);
  fMask := SIF_POS;
 end;//with l_ScrollInfo
 if (aPos < 0) then
  l_Pos := l_Scroller.Pos
 else
  l_Pos := aPos;
 if fl_VScroll then
 begin
  GetScrollInfo(Handle, SB_VERT, l_ScrollInfo);
  if (l_ScrollInfo.nPos <> l_Pos) then
   SetScrollPos(Handle, SB_VERT, l_Pos, true);
 end;//fl_VScroll
 Result := (l_ScrollInfo.nPos <> l_Pos);
 l_ScrollInfo.nPos := l_Pos;
 ScrollInfoChange(true, l_ScrollInfo, true);
 f_WasScroll := true;
end;

function TevCustomEditorWindow.SetHScrollPos: Boolean;
  {-устанавливает позицию горизонтального ScrollBar'а}
var
 l_ScrollInfo : TScrollInfo;
 l_Scroller   : InevScroller;
 l_Pos        : Integer;
begin
 Result := false;
 if not HandleAllocated then
  Exit; // - нечего скроллировать, если окна не было
 if (View = nil) then
  Exit;
 l_Scroller := View.Scroller[false];
 if (l_Scroller = nil) then
  Exit;
 l3FillChar(l_ScrollInfo, SizeOf(l_ScrollInfo), 0);
 with l_ScrollInfo do
 begin
  cbSize := SizeOf(l_ScrollInfo);
  fMask := SIF_POS;
 end;//with l_ScrollInfo
 l_Pos := l_Scroller.Pos;
 if (f_HScrollBar = nil) then
 begin
  GetScrollInfo(Handle, SB_HORZ, l_ScrollInfo);
  if fl_HScroll then
   if (l_ScrollInfo.nPos <> l_Pos) then
    SetScrollPos(Handle, SB_HORZ, l_Pos, true);
 end//f_HScrollBar = nil
 else
 begin
  l_ScrollInfo.nPos := f_HScrollBar.Position;
  f_HScrollBar.Position := l_Pos;
 end;//f_HScrollBar = nil
 Result := (l_ScrollInfo.nPos <> l_Pos);
 l_ScrollInfo.nPos := l_Pos;
 ScrollInfoChange(false, l_ScrollInfo, true);
end;

procedure TevCustomEditorWindow.ScrollInfoChange(aVert             : Boolean;
                                                 const aScrollInfo : TScrollInfo;
                                                 aPosChanged       : Boolean);
  //virtual;
  {-}
begin
end;

procedure TevCustomEditorWindow.SetHScrollRange;
  {-устанавливает параметры горизонтального ScrollBar'а}
var
 l_ScrollInfo       : TScrollInfo;
 l_OldScrollInfo    : TScrollInfo;
 l_Scroller         : InevScroller;
 l_MakeCaretVisible : Boolean;
 l_IsThemes         : Boolean;
begin
 if not f_InHScrollRange then
 begin
  f_InHScrollRange := true;
  try
   if not Document.AsObject.IsValid OR (TextSource = nil) then
   begin
    f_NeedUpdateRange := true;
    Exit;
   end;//not Document.IsValid..
   l_Scroller := View.Scroller[false];
   if (l_Scroller = nil) then
    Exit;
   l_MakeCaretVisible := not afw.IsActionUpdateLocked AND (View <> nil) AND View.IsCaretVisible;
   l3FillChar(l_ScrollInfo, SizeOf(l_OldScrollInfo), 0);
   with l_ScrollInfo do
   begin
    cbSize := SizeOf(l_ScrollInfo);
    fMask := SIF_PAGE or SIF_RANGE or SIF_POS;
    nPos := l_Scroller.Pos;
    nMin := 0;
    nMax := Max(0, l_Scroller.Max);
    nPage := Min(nMax, Max(0, l_Scroller.Page));
   end;//with l_ScrollInfo
   if (f_HScrollBar = nil) then
   begin
    if fl_HScroll then
    begin
     l3FillChar(l_OldScrollInfo, SizeOf(l_OldScrollInfo), 0);
     with l_OldScrollInfo do
     begin
      cbSize := SizeOf(l_ScrollInfo);
      fMask := SIF_PAGE or SIF_RANGE or SIF_Pos;
     end;//with l_OldScrollInfo
     GetScrollInfo(Handle, SB_Horz, l_OldScrollInfo);
     {$IFDEF Delphi7}
     l_IsThemes := ThemeServices.ThemesAvailable and IsThemeActive;
     {$ELSE}
     l_IsThemes := false;
     {$ENDIF Delphi7}
     if (ev_uwfForceHScroll in fl_UpdateFlags) OR
        not CompareMem(@l_OldScrollInfo, @l_ScrollInfo, SizeOf(l_OldScrollInfo)) then
     begin
      Exclude(fl_UpdateFlags, ev_uwfForceHScroll);
      if not l_IsThemes then
       SetScrollInfo(Handle, SB_Horz, l_ScrollInfo, false);
      if (Cardinal(l_ScrollInfo.nMax) <= l_ScrollInfo.nPage) then
       ShowScrollBar(Handle, SB_Horz, false)
      else
       ShowScrollBar(Handle, SB_Horz, true);
      if l_IsThemes then
      begin
       SetScrollInfo(Handle, SB_Horz, l_ScrollInfo, true);
       if (Cardinal(l_ScrollInfo.nMax) <= l_ScrollInfo.nPage) then
        ShowScrollBar(Handle, SB_Horz, false);
      end;//l_IsThemes
     end//not CompareMem
     else
      l_MakeCaretVisible := false;
    end//fl_HScroll
    else
     l_MakeCaretVisible := false;
   end//f_HScrollBar = nil
   else
   with f_HScrollBar do
   begin
    with l_ScrollInfo do
    begin
     PageSize := nPage;
     SetParams(nPos, nMin, nMax);
     SmallChange := l3MinMax.Max(1, nev.LineScrollDelta.X);
     LargeChange := l3MinMax.Min(l3MinMax.Max(1, nMax div 3), High(TScrollBarInc));
     {$IfDef Nemesis}
     Visible := (Cardinal(l_ScrollInfo.nMax) > l_ScrollInfo.nPage);
     // http://mdp.garant.ru/pages/viewpage.action?pageId=269064902
     {$EndIf Nemesis}
    end;//with l_ScrollInfo
   end;//f_HScrollBar = nil
   ScrollInfoChange(false, l_ScrollInfo, true);
   if l_MakeCaretVisible then
    View.MakeCaretVisible;
  finally
   f_InHScrollRange := false;
  end;//try..finally
 end;//f_InHScrollRange
end;

procedure TevCustomEditorWindow.SetVScrollRange;
  {-устанавливает параметры вертикального ScrollBar'а}
var
 l_ScrollInfo    : TScrollInfo;
 l_OldScrollInfo : TScrollInfo;
 l_Scroller      : InevScroller;
begin
 if not f_InVScrollRange AND (View <> nil) then
 begin
  if (f_InPaint > 0) OR f_InScroll then
   f_NeedSetVScrollRange := true
   // - нельзя обновлять скроллер внутри обработчика WM_Paint
   // - при скроллировании тоже нежелательно обновлять скроллер
  else
  begin
   l_Scroller := View.Scroller[true];
   if (l_Scroller = nil) then
    Exit;
   f_NeedSetVScrollRange := false;
   f_InVScrollRange := true;
   try
    if fl_VScroll then
    begin
     {determine the maximum scroll range}
     l3FillChar(l_OldScrollInfo, SizeOf(l_OldScrollInfo), 0);
     with l_OldScrollInfo do
     begin
      cbSize := SizeOf(l_ScrollInfo);
      fMask := SIF_PAGE or SIF_RANGE or SIF_Pos;
     end;//with l_OldScrollInfo
     GetScrollInfo(Handle, SB_VERT, l_OldScrollInfo);
     l3FillChar(l_ScrollInfo, SizeOf(l_OldScrollInfo), 0);
     with l_ScrollInfo do
     begin
      cbSize := SizeOf(l_ScrollInfo);
      fMask := l_OldScrollInfo.fMask;
      nMin := l_Scroller.Min;
      nMax := l_Scroller.Max;
      nPage := l_Scroller.Page;
      nPos := l_Scroller.Pos;
     end;//with l_ScrollInfo
     if not CompareMem(@l_OldScrollInfo, @l_ScrollInfo, SizeOf(l_OldScrollInfo)) then
     begin
      if not ((Cardinal(l_OldScrollInfo.nMax) <= l_OldScrollInfo.nPage) AND
         (Cardinal(l_ScrollInfo.nMax) <= l_ScrollInfo.nPage)) then
      begin
       SetScrollInfo(Handle, SB_VERT, l_ScrollInfo, true);
       ScrollInfoChange(true, l_ScrollInfo, l_OldScrollInfo.nPos <> l_ScrollInfo.nPos);
      end;//not ((l_OldScrollInfo.nMax <= l_OldScrollInfo.nPage) AND
     end;//not CompareMem
    end//fl_VScroll
    else
    begin
     l3FillChar(l_ScrollInfo, SizeOf(l_ScrollInfo), 0);
     with l_ScrollInfo do
     begin
      cbSize := SizeOf(l_ScrollInfo);
      fMask := SIF_PAGE or SIF_RANGE or SIF_Pos;
      nMin := l_Scroller.Min;
      nMax := l_Scroller.Max;
      nPage := l_Scroller.Page;
      nPos := l_Scroller.Pos;
     end;//with l_ScrollInfo
     ScrollInfoChange(true, l_ScrollInfo, true);
    end;//fl_VScroll
   finally
    f_InVScrollRange := false;
   end;//try..finally
  end;//f_InPaint
 end;//not f_InVScrollRange
end;

procedure TevCustomEditorWindow.pm_SetHScrollBar(Value: TvtScrollBar);
  {-}
begin
 if (f_HScrollBar <> Value) then
 begin
  f_HScrollBar := Value;
  if (f_HScrollBar <> nil) then
  begin
   if (ScrollStyle in [ssVertical, ssBoth]) then
    ScrollStyle := ssVertical
   else
    ScrollStyle := ssNone;
   f_HScrollBar.OnScroll := HScrollEvent;
  end;{ else ScrollStyle := ssBoth};
  UpdateScrollRange([afw_sbHorz]);
 end;//f_HScrollBar <> Value
end;

function TevCustomEditorWindow.pm_GetVSubPanel: IevSubPanel;
  {-}
begin
 Result := IevSubPanel(f_VSubPanel);
end;

procedure TevCustomEditorWindow.pm_SetVSubPanel(const aValue: IevSubPanel);
  {-}
begin
 if not l3IEQ(IUnknown(f_VSubPanel), aValue) then
 begin
  if (f_VSubPanel <> nil) then
   IevSubPanel(f_VSubPanel).Control := nil;
  f_VSubPanel := Pointer(aValue);
  if (f_VSubPanel <> nil) then
  begin
   IevSubPanel(f_VSubPanel).Control := Self;
   IevSubPanel(f_VSubPanel).Zoom := Zoom;
   IevSubPanel(f_VSubPanel).Invalidate;
  end;//f_VSubPanel <> nil
 end;//not l3IEQ(IUnknown(f_VSubPanel), aValue)
end;

function TevCustomEditorWindow.pm_GetCurPara: Tl3Variant;
  {-}
begin
 if (f_Cursor = nil) OR (f_Cursor.Cursor = nil) then
  Result := k2NullTag
 else
  Result := f_Cursor.Cursor.MostInner.Obj^.AsObject;
end;

function TevCustomEditorWindow.pm_GetLocked: Boolean;
  {-}
begin
 Result := //inherited InUpdating OR
           // - закомментировано, т.к "шумит" на Lock/Unlock - в частности на
           //   обновление скроллеров.
           ((f_Cursor <> nil) AND f_Cursor.Locked);
end;

function TevCustomEditorWindow.pm_GetRange: IedRange;
  {-}
var
 l_Selection : Tl3Base;  
begin
 if HasDocument then
 begin
  l_Selection := Selection;
  if (l_Selection = nil) OR
     l3IFail(l_Selection.QueryInterface(IedRange, Result)) then
   Result := TedRangeImplementation.Make(View, nil, Processor);
 end
 else
  Result := nil;
end;

function TevCustomEditorWindow.pm_GetCurText: Tl3PCharLen;
  {-возвращает указатель на текст текущего параграфа}
begin
 with CurPara.Attr[k2_tiText] do
  if IsValid then
   Result := (AsObject As Tl3CustomString).AsPCharLen
  else
   l3AssignNil(Result);
end;

function TevCustomEditorWindow.pm_GetInsertMode: Boolean;
  {-}
begin
 if (f_Cursor = nil) then
  Result := true
 else
  Result := f_Cursor.Caret.InsertMode;
end;

procedure TevCustomEditorWindow.pm_SetInsertMode(Value: Boolean);
  {-}
begin
 if (f_Cursor <> nil) then
  f_Cursor.Caret.InsertMode := Value;
end;

procedure TevCustomEditorWindow.pm_SetScrollStyle(Value: TScrollStyle);
  //override;
  {-устанавливает какие ScrollBar'ы нужны}
begin
 inherited;
 if (ScrollStyle in [ssHorizontal, ssBoth]) then
  f_HScrollBar := nil;
end;

function TevCustomEditorWindow.Get_View: InevView;
begin
 Result := View;
end;

function TevCustomEditorWindow.GetView: InevInputView;
  {-}
begin
 if (f_View = nil) then
  Document;
  // - дергаем документ, чтобы создать View 
 Result := f_View;
end;

function TevCustomEditorWindow.pm_GetPlainText: Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

procedure TevCustomEditorWindow.pm_SetPlainText(aValue: Boolean);
  //virtual;
  {-}
begin
end;

function TevCustomEditorWindow.pm_GetProcessor: InevProcessor;
  {-}
begin
 Result := TextSource.Processor;
end;

procedure TevCustomEditorWindow.DoCursorChanged;
  //virtual;
  {-}
begin
 {$IfNDef DesignTimeLibrary}
 if not fl_Capture then
 begin
  CheckCurFont;
  if not CheckCursorInSelection then
   DoFontChange(TextPara.Font);
 end;//not fl_Capture
 {$EndIf  DesignTimeLibrary}
 if Assigned(f_OnCursorChange) then
  f_OnCursorChange(Self);
end;

procedure TevCustomEditorWindow.DoUpdateBlock;
  {-}
begin
 if not fl_Capture then
 begin
  BlockChange;
  {$IfNDef DesignTimeLibrary}
  if CheckBlockFont(false) then
  begin
{$IFDEF Nemesis}
   if CheckBlockStyle(false) then
{$ELSE}
   if CheckBlockStyle(true) then
{$ENDIF Nemesis}
   begin
    if not CheckCursorInSelection then
    begin
{$IFDEF Nemesis}
     //Для редактора: вызов этих строк портит получение реального текущего шрифта и стиля в редакторе.
     //И до конца не понятно зачем они вообще здесь нужны.
     DoFontChange(TextPara.Font);
     DoStyleChange(TextPara.Style);
{$ENDIF Nemesis}
    end;//not CheckCursorInSelection
   end;//CheckBlockStyle
  end;//CheckBlockFont
  {$EndIf  DesignTimeLibrary}
 end;//not fl_Capture
end;

procedure TevCustomEditorWindow.BlockChange;
  {virtual;}
  {-}
begin
end;

function TevCustomEditorWindow.CheckBlockFont(aNow: Boolean): Boolean;
  {-}
begin
 {$IfDef evNeedGetBlockFont}
 if (fl_BlockFontCalls = l3NilLong) then
 begin
  fl_BlockFontCalls := 0;
  if (TextSource <> nil) then
   TextSource.CheckCloseWindow;
  Result := false;
 end//fl_BlockFontCalls = l3NilLong
 else
 begin
  Inc(fl_BlockFontCalls);
  Result := CheckBlockFontPrim(aNow);
 end;//fl_BlockFontCalls = l3NilLong
 {$Else  evNeedGetBlockFont}
 Result := false;
 {$EndIf evNeedGetBlockFont}
end;

function TevCustomEditorWindow.CheckCursorInSelection: Boolean;
  {-}
begin
 Result := ((f_Cursor <> nil) AND InevSelection(Self.Selection).Contains(Selection.Cursor)) <> f_CursorInSelection;
 if Result then
 begin
  f_CursorInSelection := not f_CursorInSelection;
  DoCursorInSelectionChange;
 end;//Result
end;

{$IfDef evNeedGetBlockFont}
function TevCustomEditorWindow.CheckBlockFontPrim(aNow: Boolean): Boolean;
  {-}
var
 l_Map: TnevFormatInfoPrim; 
begin
 Result := true;
 if not fl_Capture then
 begin
  f_CurFont[true] := nil;
  if HasSelection then
  begin
   if (fl_BlockFontCalls <= 1) then
   begin
    l_Map := View.RootFormatInfo;
    if aNow and (l_Map <> nil) then
     f_CurFont[true] := InevSelection(Self.Selection).GetBlock.Formatting.GetFont(View, l_Map,
                                                             @fl_BlockFontCalls);
    if (fl_BlockFontCalls = l3NilLong) then
    begin
     fl_BlockFontCalls := 0;
     if (TextSource <> nil) then
      TextSource.CheckCloseWindow;
     Result := false;
     Exit;
    end;//fl_BlockFontCalls = l3NilLong
    if (fl_BlockFontCalls > 0) then
     Dec(fl_BlockFontCalls);
    if (fl_BlockFontCalls > 0) then
    begin
     if (csDestroying in ComponentState) then
      fl_BlockFontCalls := 0
     else
      CheckBlockFontPrim(aNow);
    end;//fl_BlockFontCalls > 0
   end//fl_BlockFontCalls <= 1
   else
    Dec(fl_BlockFontCalls);
  end//HasSelection
  else
   fl_BlockFontCalls := 0;
 end//not fl_Capture
 else
  fl_BlockFontCalls := 0;
end;
{$EndIf evNeedGetBlockFont}

function TevCustomEditorWindow.CheckBlockStyle(aNow: Boolean): Boolean;
  {-}
begin
 {$IfDef evNeedGetBlockStyle}
 if (fl_BlockStyleCalls = l3NilLong) then
 begin
  fl_BlockStyleCalls := 0;
  if (TextSource <> nil) then
   TextSource.CheckCloseWindow;
  Result := false;
 end//fl_BlockStyleCalls = l3NilLong
 else
 begin
  Inc(fl_BlockStyleCalls);
  Result := CheckBlockStylePrim(aNow);
 end;//fl_BlockStyleCalls = l3NilLong
 {$Else  evNeedGetBlockStyle}
 Result := false;
 {$EndIf evNeedGetBlockStyle}
end;

{$IfDef evNeedGetBlockStyle}
function TevCustomEditorWindow.CheckBlockStylePrim(aNow: Boolean): Boolean;
  {-}
var
 l_Style : Tl3Variant;  
begin
 Result := true;
 if not fl_Capture then
 begin
  if HasSelection then
  begin
   if (fl_BlockStyleCalls <= 1) then
   begin
    if aNow then
    begin
     l_Style := InevSelection(Self.Selection).GetBlock.Formatting.GetStyle(@fl_BlockStyleCalls);
     if (l_Style = nil) then
      f_CurStyle[true] := nil
     else
      f_CurStyle[true] := l_Style.AsRef;
    end;//aNow
    if (fl_BlockStyleCalls = l3NilLong) then
    begin
     fl_BlockFontCalls := 0;
     if (TextSource <> nil) then
      TextSource.CheckCloseWindow;
     Result := false;
     Exit;
    end;//fl_BlockStyleCalls = l3NilLong
    if (fl_BlockStyleCalls > 0) then
     Dec(fl_BlockStyleCalls);
    if (fl_BlockStyleCalls > 0) then
    begin
     if (csDestroying in ComponentState) then
      fl_BlockStyleCalls := 0
     else
      CheckBlockStylePrim(aNow);
    end;//fl_BlockStyleCalls > 0
   end//fl_BlockStyleCalls <= 1
   else
    Dec(fl_BlockStyleCalls);
  end//HasSelection
  else
  begin
   fl_BlockStyleCalls := 0;
   f_CurStyle[true] := Tl3NullTag.Instance;
  end;//HasSelection
 end//not fl_Capture
 else
  fl_BlockStyleCalls := 0;
end;
{$EndIf evNeedGetBlockStyle}

procedure TevCustomEditorWindow.CheckCurFont;
  {-}
{$IfDef evNeedGetBlockFont}
var
 l_Map : TnevFormatInfoPrim;
{$EndIf evNeedGetBlockFont}
begin
 f_CurFont[false] := nil;
 {$IfDef evNeedGetBlockFont}
 if (f_Cursor <> nil) AND (f_Cursor.Cursor <> nil) then
 begin
  Assert(View.Control <> nil);
  l_Map := View.RootFormatInfo;
  if (l_Map = nil) then
   f_CurFont[false] := nil
  else
   f_CurFont[false] := f_Cursor.Cursor.Formatting.GetFont(View, l_Map);
 end;//f_Cursor <> nil
 {$EndIf evNeedGetBlockFont}
end;

procedure TevCustomEditorWindow.CheckCurStyle;
  {-}
var
 l_Style : Tl3Variant;  
begin
 {$IfDef evNeedGetBlockStyle}
 if not fl_Capture then
 begin
  if (f_Cursor = nil) OR (f_Cursor.Cursor = nil) then
   f_CurStyle[false] := Tl3NullTag.Instance
  else
  begin
   l_Style := f_Cursor.Cursor.Formatting.GetStyle;
   if (l_Style = nil) then
    f_CurStyle[false] := nil
   else
    f_CurStyle[false] := l_Style.AsRef;
  end;//(f_Cursor = nil) OR (f_Cursor.Cursor = nil)
 end;//not fl_Capture
 {$EndIf evNeedGetBlockStyle}
end;

procedure TevCustomEditorWindow.DoMarkerChange;
  {-}
var
 l_MarkersSource : IevMarkersSource;
begin
 Include(fl_UpdateFlags, ev_uwfCursor);
 if Locked then
  Include(fl_UpdateFlags, ev_uwfRuler)
 else
 begin
  Exclude(fl_UpdateFlags, ev_uwfRuler);
  if (Selection <> nil) AND (Selection.Cursor <> nil) then
  begin
   if (HRuler <> nil) then
   begin
    l_MarkersSource := Selection.Cursor.MarkersSource;
    if (l_MarkersSource <> nil) then
     try
      HRuler.MarkersChanged(View, l_MarkersSource);
     finally
      l_MarkersSource := nil;
     end;//try..finally
   end;//HRuler <> nil
  end;//Selection <> nil..
 end;//Locked
end;

procedure TevCustomEditorWindow.DoParaChange;
  {virtual;}
  {-}
begin
 if not fl_Capture then
 begin
  if Locked then
   Include(fl_UpdateFlags, ev_uwfPara)
  else
  begin
   Exclude(fl_UpdateFlags, ev_uwfPara);
   DoMarkerChange;
   CheckCurStyle;
   {$IfNDef DesignTimeLibrary}
   if not CheckCursorInSelection then
    DoStyleChange(TextPara.Style);
   {$EndIf  DesignTimeLibrary}
   ParaChange;
  end;//Locked
 end;//not fl_Capture..
end;

procedure TevCustomEditorWindow.TextChange;
  //virtual;
  {* - вызывается при смене текста. }
begin
end;
  
procedure TevCustomEditorWindow.ParaChange;
  {virtual;}
  {-}
begin
 if (csDestroying in ComponentState) then Exit;
 {$IfNDef DesignTimeLibrary}
 if Assigned(f_OnParaChange) then
  OnParaChange(Self, TextPara);
 {$EndIf  DesignTimeLibrary}
end;

procedure TevCustomEditorWindow.DoCursorInSelectionChange;
  {virtual;}
  {-}
begin
 {$IfNDef DesignTimeLibrary}
 DoFontChange(TextPara.Font);
 DoStyleChange(TextPara.Style);
 {$EndIf  DesignTimeLibrary}
 if Assigned(f_OnCursorInSelectionChange) then
  f_OnCursorInSelectionChange(Self);
end;

procedure TevCustomEditorWindow.DoFontChange(const Font: Il3Font);
  {virtual;}
  {-}
begin
 if (csDestroying in ComponentState) then Exit;
 {$IfNDef DesignTimeLibrary}
 if Assigned(f_OnFontChange) then
  OnFontChange(Self, Font);
 {$EndIf  DesignTimeLibrary}
end;

function TevCustomEditorWindow.SetCursorToScreen(aCursor : TCursor): Boolean;
  {-}
begin
 if (aCursor <> crDefault) then
 begin
  SetCursor(Screen.Cursors[aCursor]);
  Result := true;
 end//l_Cursor <> crDefault
 else
 begin
  //Screen.Cursor := Self.Cursor;
  SetCursor(Screen.Cursors[Self.Cursor]);
  Result := false;
 end;//aCursor <> crDefault
end;
  
function TevCustomEditorWindow.DoSetCursor(const aPt      : Tl3Point;
                                           const aHotSpot : IevHotSpot): Boolean;
  {virtual;}
  {-}
var
 l_Cursor : TCursor;
 l_Hint   : Il3CString;
 l_Info   : TafwCursorInfo;
 l_State  : TafwCursorState;
begin
 Result := false;
 if not f_InScroll then
 begin
  if (aHotSpot = nil) then
   CancelHint
  else
  begin
   if Assigned(f_OnSetCursor) then
    Result := OnSetCursor(Self, aHotSpot);
   if not Result then
   begin
    l3FillChar(l_State, SizeOf(l_State), 0);
    l3FillChar(l_Info, SizeOf(l_Info), 0);
    l_State.rInitialPoint := aPt;
    l_State.rPoint := aPt;
    l_State.rKeys := KeyboardStateToShiftState;
    aHotSpot.HitTest(View, l_State, l_Info);
    l_Cursor := evCursorShape2Cursor(l_Info.rCursor);
    RecalcScreenCursor(TPoint(GetInfoCanvas.LP2DP(aPt)), l_Cursor);
    Result := SetCursorToScreen(l_Cursor);
    l_Hint := l_Info.rHint;
    if l3IsNil(l_Hint) then
     CancelHint
    else
    begin
     Hint := l3Str(l_Hint);
     ActivateHint;
    end;//l3IsNil(l_Hint)
   end;//not Result
  end;//aHotSpot <> nil
 end;//not f_InScroll
end;

procedure TevCustomEditorWindow.DoStyleChange(const aStyle: IedStyle);
  {virtual;}
  {-}
begin
 DoMarkerChange;
 StyleChangeEvent(aStyle);
end;

procedure TevCustomEditorWindow.StyleChangeEvent(const aStyle: IedStyle);
begin
 if Assigned(f_OnStyleChange) then
  OnStyleChange(Self, aStyle);
end;

procedure TevCustomEditorWindow.DoDrawSub(aSubTarget : TObject;
                                          const Canvas     : Il3Canvas;
                                          const R          : Tl3Rect;
                                          SubType          : Tl3Handle;
                                          aSub       : TObject);
  {virtual;}
  {-}
var
 l_Sub    : IevSub;
 l_Tag    : Tl3Tag;
 l_SubTag : Tl3Tag;
begin
 inherited;
 if (VSubPanel <> nil) AND VSubPanel.Visible then
 begin
  l_SubTag := aSub As Tl3Tag;
  l_Sub := TextSource.DocumentContainer.SubList.SubEx[l_SubTag.IntA[k2_tiHandle],
                            SubType];
  if (l_Sub <> nil) then
  { TODO -cзаплатка : После обновления, если на экране был автореферат, получался Sub = nil }
  begin
   if not l_Sub.IsInIndex then
   begin
    l_Tag := aSubTarget As Tl3Tag;
    TextSource.DocumentContainer.RealizeSub(SubType, l_SubTag, l_Tag);
    l_Sub := TextSource.DocumentContainer.SubList.SubEx[l_SubTag.IntA[k2_tiHandle], SubType];
   end;//not l_Sub.IsInIndex
   VSubPanel.NeedDrawSub(R, l_Sub);
  end;//l_Sub <> nil
 end;//VSubPanel <> nil..
end;

procedure TevCustomEditorWindow.DoHRulerSetMarker(Sender       : TObject;
                                                  const Marker : IevMarker;
                                                  Value        : Long);
  {-}
begin
 {$IfDef evNeedMarkers}
 if (Marker <> nil) then
  Selection.ChangeParam(Marker, Value);
 {$EndIf evNeedMarkers} 
end;

procedure TevCustomEditorWindow.WMPaint(var Msg : TWMPaint);
  {message WM_Paint;}
begin
 Include(fl_UpdateFlags, ev_uwfRegion);
 inherited;
end;

function TevCustomEditorWindow.CopyToClipboardEx(aFormat  : Tl3ClipboardFormat;
                                                 NeedAdd : Boolean = false): Boolean;
  {-сохранить выделенный блок в буфер обмена в формате aFormat}
var
 Mem        : Tl3MemoryPool;
 OldData    : TStream;
 l_NewData  : TStream;
 l_Pool     : IStream;
 l_Data     : THandle;
 MemUnicode : Tl3MemoryPool;
 {$IfDef evUseOleClipboard}
 l_IData    : IDataObject;
 l_IStream  : IStream;
 {$EndIf evUseOleClipboard}
begin
 Result := false;
 if not Selection.Collapsed then
 begin
  l_NewData := nil;
  Mem       := nil;
  try
   {$IfDef evUseOleClipboard}
   if not NeedAdd OR l3IFail(OleGetClipboard(l_IData)) then
    l_IData := nil;
   try
    if (aFormat = cf_EverestBin) AND
       Supports(l_IData, IStream, l_IStream) then
     try
      l3IStream2Stream(l_IStream, l_NewData);
      l_NewData.Seek(0, soEnd)
     finally
      l_IStream := nil;
     end//try..finally
    else
   {$EndIf evUseOleClipboard}
    begin
     Mem := Tl3MemoryPool.Create{(Self)};
     l_NewData := Tl3MemoryStream.Create(Mem);
     if NeedAdd then
     begin
      if IsClipboardFormatAvailable(aFormat) then
       l_Data := GetClipboardData(aFormat)
      else
       l_Data := 0;
      if (l_Data <> 0) then
      begin
       Case aFormat of
        cf_Text, cf_OEMText:
         OldData := Tl3HPCharStream.Create(l_Data);
        cf_UnicodeText:
         OldData := Tl3HPWideCharStream.Create(l_Data);
        else
         OldData := Tl3HMemoryStream.Create(l_Data);
       end;//Case aFormat
       try
        l_NewData.CopyFrom(OldData, 0);
       finally
        l3Free(OldData);
       end;{try..finally}
      end;//l_Data <> 0
     end;//NeedAdd
    end;
    if Supports(l_NewData, IUnknown, l_Pool) then
     try
      InevSelection(Self.Selection).GetBlock.Data.Store(aFormat, l_Pool, MakeExportFilters(false, false));
     finally
      l_Pool := nil;
     end;//try..finally
    if (l_NewData.Size > 0) then
    begin
     Result := true;
     if (aFormat = cf_Text) then
     begin
      if (Win32Platform = VER_PLATFORM_WIN32_NT) then
      begin
       MemUnicode := Tl3MemoryPool.Create{(Self)};
       try
        MemUnicode.Size := Mem.Size * 2;
        MultiByteToWideChar(CP_RussianWin, 0, Mem.AsPointer, Mem.Size, PWideChar(MemUnicode.AsPointer), Mem.Size);
        SetClipboardData(cf_UnicodeText, l3System.ReleaseHandle(MemUnicode.ReleaseHandle));
        SetClipboardData(aFormat, l3System.ReleaseHandle(Mem.ReleaseHandle));
       finally
        l3Free(MemUnicode);
       end;{try..finally}
      end//Win32Platform = VER_PLATFORM_WIN32_NT
      else
      begin
       SetClipboardData(aFormat, l3System.ReleaseHandle(Mem.ReleaseHandle));
       SetClipboardData(cf_Locale, Lang_Russian);
      end;//Win32Platform = VER_PLATFORM_WIN32_NT
     end//aFormat = cf_Text
     else
     if (Mem <> nil) then
     begin
      l_Data := Mem.ReleaseHandle;
      Result := WinBool(SetClipboardData(aFormat, l_Data));
      if Result then
       l3System.ReleaseHandle(l_Data)
      else
      begin
       {$IfDef evUseOleClipboard}
       Result := l3System.SetClipboardData(Data2DataObject(l_Data));
       if not Result then
       {$Else  evUseOleClipboard}
       l3System.GlobalFree(l_Data);
       {$EndIf evUseOleClipboard}
      end;//Result
     end;//Mem <> nil
    end;//l_NewData.Size > 0
   {$IfDef evUseOleClipboard}
   finally
    l_IData := nil;
   end;//try..finally
   {$EndIf evUseOleClipboard}
  finally
   l3Free(l_NewData);
   l3Free(Mem);
  end;//try..finally
 end;//not Selection.Collapsed
end;

function TevCustomEditorWindow.HandledReadOnly(E: EevReadOnly): Boolean;
  //virtual;
  {-}
begin
 Result := true;
end;

procedure TevCustomEditorWindow.DoContextPopup(aMousePos: TPoint; var Handled: Boolean);
  //override;
  {-}
begin
 if (InPopup > 0) then
  inherited
 else
  Handled := true;
end;

{$IfNDef DesignTimeLibrary}
procedure TevCustomEditorWindow.DoStyleTableChanged;
begin
 AdjustHeightByText;
 inherited;
end;
{$EndIf}

procedure TevCustomEditorWindow.WebStyleChanged;
  //override;
  {-}
begin
 inherited;
 DoMarkerChange;
 {$IfDef evNeedDisp}
 if Focused then
  evOperationDispatcher.
   SetOpIntegerData(ev_ccWebStyle, Ord(WebStyle));
 {$EndIf evNeedDisp}
end;
  
function TevCustomEditorWindow.InsertData(aFormat : Tl3ClipboardFormat;
                                          aData   : THandle): Boolean;
  {* - вставить текст из буфера обмена в формате aFormat. }
var
 l_BitmapReader : TevBitmapHandleReader;
 l_Format       : Tl3ClipboardFormat;
 l_Mem          : TObject;
 l_Pool         : IStream;
 l_Pack         : InevOp;
begin
 l_Pack := StartOp(ev_msgInsertPara);
 try
  Result := false;
  if (aFormat = cf_RTFLite) then
   l_Format := cf_RTF
  else
   l_Format := aFormat;
  if (l_Format = cf_Bitmap) then
  begin
   l_BitmapReader := TevBitmapHandleReader.Make(aData);
   try
    Result := True;
    try
     TextSource.DocumentContainer.TagWriter.WriteTagEx(View, l_BitmapReader, Selection);
    except
     on E: EevReadOnly do
      if HandledReadOnly(E) then
      begin
       Result := False;
       if (Selection <> nil) then
        InevSelection(Selection).Unselect;
        // - снимаем выделение
      end//HandledReadOnly(E)
      else
       raise;
    end;//try..except
   finally
    l3Free(l_BitmapReader);
   end;{try..finally}
  end//l_Format = cf_Bitmap
  else
  begin
   case l_Format of
    cf_Text, cf_OEMText:
     l_Mem := Tl3HPCharStream.Create(aData);
    cf_UnicodeText:
     l_Mem := Tl3HPWideCharStream.Create(aData);
    cf_hDrop:
     l_Mem := Tl3MemoryPool.Make(aData);
    else
     l_Mem := Tl3HMemoryStream.Create(aData);
   end;//case l_Format
   try
    if Supports(l_Mem, IStream, l_Pool) then
     try
      try
       Result := Selection.Text.Modify.InsertStream(View, l_Pool, aFormat, l_Pack);
       Selection.ForceStore;
      except
       on E: EevReadOnly do
        if HandledReadOnly(E) then
        begin
         Result := False;
         if (Selection <> nil) then
          InevSelection(Selection).Unselect;
          // - снимаем выделение
        end//HandledReadOnly(E)
        else
         raise;
      end;//try..except
     finally
      l_Pool := nil;
     end;//try..finally
   finally
    l3Free(l_Mem);
   end;//try..finally
  end;//l_Format = cf_Bitmap
  if Result then
   DoUnselectAfterInsertData;
   // - снимаем выделение
 finally
  l_Pack := nil;
 end;//try..finally
end;
  
procedure TevCustomEditorWindow.InsertFrom(const aTextSource: InevTagReader);
  {* - вставить данные из другого источника текста. }
var
 l_MemoryPool : Tl3MemoryPool;
begin
 l_MemoryPool := Tl3MemoryPool.Create;
 try
  aTextSource.ReadTag(cf_EverestBin, l_MemoryPool As IStream, MakeExportFilters(false, false));
  InsertData(cf_EverestBin, l_MemoryPool.AsHandle);
 finally
  l3Free(l_MemoryPool);
 end;//try..finally
end;

function TevCustomEditorWindow.PasteFromClipboard(aFormat     : Tl3ClipboardFormat;
                                                  const aData : IDataObject): Boolean;
  {-}
begin
 if (aFormat = cf_RTFLite) then
  Result := inherited PasteFromClipboard(cf_RTF, aData)
 else
  Result := inherited PasteFromClipboard(aFormat, aData);
end;

function TevCustomEditorWindow.IsVScrollBarVisible: Boolean;
  {-}
var
 l_PageMax  : Integer;
 l_RangeMax : Integer;
 l_PageInfo : TScrollInfo;
begin
 if AutoHeightByText then
  Result := false
  // - давим вертикальный скроллбар, т.к. он не должен быть виден, и мешает при
  //   переходных процессах. Найдено в процессе исправления CQ 29145.
 else
 begin
  if not HandleAllocated or (csDesigning in ComponentState) or not fl_VScroll then
  begin
   Result := False;
   Exit;
  end;
  with l_PageInfo do
  begin
   cbSize := SizeOf(l_PageInfo);
   fMask := SIF_ALL;
  end;//with l_ScrollInfo
  GetScrollInfo(Handle, SB_VERT, l_PageInfo);
  l_PageMax := l_PageInfo.nPage;
  l_RangeMax := l_PageInfo.nMax;
  Result := l_RangeMax > l_PageMax;
 end;//AutoHeightByText
end;

function TevCustomEditorWindow.DocumentFullHeight: Integer;
  {* - возвращает полную высоту документа. ОСТОРОЖНО: для вычисления используется виртуальная отрисовка, которая может быть достаточно медленной. }
var
 l_View     : InevView;
 l_Canvas   : Il3Canvas;
 l_Document : InevObject;
 l_Map      : InevMap;
 l_Area     : TnevShapeAreaEx;
begin
 Result := 0;
 l_Document := Document;
 if l_Document.AsObject.IsValid then
 begin
  l_Canvas := Tl3VirtualCanvas.Make(l3Point(pm_GetLimitWidth,MaxInt));
  l_Canvas.Zoom := Zoom;
  try
   l_View := TnevVirtualDrawView.Make(l_Document, nil, l_Canvas, View.Metrics);
   try
    try
     SetTextColor(l_Canvas);
     l_Area.Init(l_View, l_Canvas, false);
     try
      l_Map := evDrawPara(l_Area{$IfDef XE4}.rTnevShapeArea{$EndIf}, l_Document, nil{l_Document.Anchor}, nil, 0).rMap;
     finally
      l_Area.Free;
     end;//try..finally
     Result := l_Canvas.LP2DP(Tl3Rect(l_Map.Bounds).BottomRight).Y;
     if AllowDrawDocumentEdge then
      inc(Result, 3);
    finally
     l_Map := nil;
     l_View.ClearShapes;
    end;//try..finally
   finally
    l_View := nil;
   end;//try..finally
  finally
   l_Canvas := nil;
  end;//try..finally
 end;//l_Document.IsValid
end;

procedure TevCustomEditorWindow.DoAdjustHeightByText;
  {-}
var
 l_OldHeight : Integer;
 l_Height : Integer;
begin
 if not f_AdjustingHeight and HasDocument then
 begin
  f_AdjustingHeight := true;
  try
   l_OldHeight := Height;
   l_Height := DocumentFullHeight;
   if (Height <> l_Height) then
   begin
    if (Align = alClient) and Assigned(Parent) then
     Parent.Height := Parent.Height + (l_Height - Height);
    Height := l_Height;
    if Assigned(f_AfterAdjustHeight) then
     f_AfterAdjustHeight(Self, l_OldHeight, l_Height);
   end;//Height <> l_Height
  finally
   f_AdjustingHeight := False;
  end;//try..finally
 end;//not f_AdjustingHeight
end;
  
procedure TevCustomEditorWindow.AdjustHeightByText;
  {-}
begin
 {$IfNdef DesignTimeLibrary}
 if AutoHeightByText then
  DoAdjustHeightByText;
 {$EndIf DesignTimeLibrary}
end;

procedure TevCustomEditorWindow.pm_SetAutoHeightByText(const Value: Boolean);
begin
 if (f_AutoHeightByText <> Value) then
 begin
  f_AutoHeightByText := Value;
  AdjustHeightByText;
 end;//f_AutoHeightByText <> Value
end;

procedure TevCustomEditorWindow.pm_SetPreviewCaleeArea(const aValue: TafwPreviewCaleeArea);
begin
 if (f_PreviewCaleeArea <> aValue) then
 begin
  f_PreviewCaleeArea := aValue;
 end;//f_PreviewCaleeArea <> Value
end;

function TevCustomEditorWindow.GetTopMargin: Integer;
  //virtual;
  {-}
begin
 Result := 0;
end;

function TevCustomEditorWindow.IsLastHistoryStep: Boolean;
  {-}
begin
 if Assigned(f_OnHistory) then
  f_OnHistory(Self, Result)
 else
  Result := True;
end;

procedure TevCustomEditorWindow.pm_SetHiddenStyles(
  aValue: TevStandardStyles);
begin
 if f_HiddenStyles <> aValue then
 begin
  f_HiddenStyles := aValue;
  if HasDocument then
   Document.Invalidate([nev_spExtent]);
  if (VSubPanel <> nil) then
   (VSubPanel As IevSubCache).ClearSubs;
 end;
end;

function TevCustomEditorWindow.pm_GetShowComments: Boolean;
begin
 Result := not(cCommentStyles * HiddenStyles <> []);
end;

function TevCustomEditorWindow.pm_GetShowUserComments: Boolean;
begin
 Result := not(-ev_saUserComment in HiddenStyles);
end;

procedure TevCustomEditorWindow.pm_SetShowComments(aValue: Boolean);
begin
 if (ShowComments <> aValue) then
 begin
  if aValue then
   HiddenStyles := HiddenStyles - cCommentStyles
  else
   HiddenStyles := HiddenStyles + cCommentStyles;
  DoCommentsVisibleChanged;
 end;//ShowComments <> Value
end;

procedure TevCustomEditorWindow.pm_SetShowUserComments(aValue: Boolean);
begin
 if (ShowUserComments <> aValue) then
 begin
  if aValue then
   HiddenStyles := HiddenStyles - [-ev_saUserComment]
  else
   HiddenStyles := HiddenStyles + [-ev_saUserComment];
  DoCommentsVisibleChanged;
 end;//ShowUserComments <> Value
end;

function TevCustomEditorWindow.pm_GetShowVersionComments: Boolean;
begin
 Result := not(cVersionCommentStyles * HiddenStyles <> []);
end;

procedure TevCustomEditorWindow.pm_SetShowVersionComments(aValue: Boolean);
begin
 if (ShowVersionComments <> aValue) then
 begin
  if aValue then
   HiddenStyles := HiddenStyles - cVersionCommentStyles
  else
   HiddenStyles := HiddenStyles + cVersionCommentStyles;
  {$IfDef evNeedCollapsedVersionComments}
  if (View <> nil) then
   View.VersionInfoVisabilityChanged(aValue);
  {$EndIf evNeedCollapsedVersionComments}  
  DoCommentsVisibleChanged;
 end;//ShowVersionComments <> Value
end;

function TevCustomEditorWindow.MakeExportFilters(aSelection: Boolean; aForExport : Boolean): Ik2TagGenerator;
begin
 Result := TevHiddenFilter.Make(HiddenStyles, true);
 if Assigned(OnMakeExportFilters) then
  OnMakeExportFilters(aSelection, aForExport, Result);
end;

procedure TevCustomEditorWindow.DoCommentsVisibleChanged;
begin
 if Assigned(f_OnCommentsVisibleChanged) then
  f_OnCommentsVisibleChanged(Self);
end;

function TevCustomEditorWindow.pm_GetShowTechComments: Boolean;
begin
 Result := not(-ev_saTechComment in HiddenStyles);
end;

procedure TevCustomEditorWindow.pm_SetShowTechComments(
  aValue: Boolean);
begin
 if (ShowTechComments <> aValue) then
 begin
  if aValue then
   HiddenStyles := HiddenStyles - [-ev_saTechComment]
  else
   HiddenStyles := HiddenStyles + [-ev_saTechComment];
  DoCommentsVisibleChanged;
 end;//ShowUserComments <> Value
end;

function TevCustomEditorWindow.GetMacroReplacer(const aTransit: IafwHAFMacroReplacer): IafwHAFMacroReplacer;
 {-}
begin
 Result := aTransit;
 if Assigned(f_OnMakeMacroReplacer) then
  f_OnMakeMacroReplacer(Self, Result);
end;

function TevCustomEditorWindow.GetDocumentPartByPoint(const aPoint: InevBasePoint): IevDocumentPart;
var
 l_B : Tl3Variant;
begin
 if evInPara(aPoint.MostInner.Obj^.AsObject, k2_typBlock, l_B) then
 begin
  if l_B.IsKindOf(k2_typDocument) then
   Result := TevSubImplementation.Make(l_B, Processor, 0, Ord(ev_sbtSub)) As IevDocumentPart
  else 
   Result := Document.DocumentContainer.SubList.Block[l_B.IntA[k2_tiHandle]];
 end//evInPara(aPoint.MostInner.Obj^, k2_idBlock, l_B)
 else
  Result := nil
end;

procedure TevCustomEditorWindow.DoUnselectAfterInsertData;
begin
 if (Selection <> nil) then
  InevSelection(Selection).Unselect;
end;

procedure TevCustomEditorWindow.pm_SetExcludeSuper(
  const aValue: TevNormalSegLayerHandleSet);
begin
 if (f_ExcludeSuper <> aValue) then
 begin
  f_ExcludeSuper := aValue;
  if HasDocument then
   Document.Invalidate([nev_spExtent]);
 end;//f_ExcludeSuper <> aValue
end;

procedure TevCustomEditorWindow.DoAfterSetZoom;
begin
 if (HRuler <> nil) then
  HRuler.Zoom := Zoom;
 if (VRuler <> nil) then
  VRuler.Zoom := Zoom;
 if (VSubPanel <> nil) then
  VSubPanel.Zoom := Zoom;
 if HandleAllocated then
 begin
  UpdateScrollRange;
  Invalidate;
 end;//HandleAllocated
end;

function TevCustomEditorWindow.CheckAACMode(aCommand: Long; aForce: Boolean; aCount: Integer): Boolean;
begin
 Result := False;
end;

function TevCustomEditorWindow.Get_AutoHideSelection: Boolean;
begin
 Result := f_AutoHideSelection;
end;

function TevCustomEditorWindow.HasTextSource: Boolean;
begin
 Result := f_TextSource <> nil;
end;   
                             
{$IfNDef DesignTimeLibrary}
function IevEditorWindowStyle.GetStylesForBlock: Il3Strings;
begin
 Result := TevStyleInterface.MakeListForBlock(GetTagType);
end;
{$endif}

end.
