unit nevShapesPainted;

{ Библиотека "Эверест"                                                 }
{ Начал: Морозов М.А.                                                  }
{ Модуль: nevShapesPainted - коллекция отрисованных параграфов.        }
{ Начат: 29.06.2005 16:51                                              }
{ $Id: nevShapesPainted.pas,v 1.280 2016/04/15 06:27:38 dinishev Exp $ }

// $Log: nevShapesPainted.pas,v $
// Revision 1.280  2016/04/15 06:27:38  dinishev
// {Requestlink:620674289}
//
// Revision 1.279  2016/04/11 08:45:39  dinishev
// {Requestlink:620674289}
//
// Revision 1.278  2016/03/25 11:06:01  dinishev
// {Requestlink:620261162}
//
// Revision 1.277  2015/12/30 06:48:34  dinishev
// {Requestlink:570533216}. Откатил. Тесты отъехали, да проблему не решило.
//
// Revision 1.276  2015/12/29 11:31:42  dinishev
// {Requestlink:570533216}. Продолжаю дотачивать.
//
// Revision 1.275  2015/12/28 09:45:58  dinishev
// Cleanup
//
// Revision 1.274  2015/12/24 10:42:13  dinishev
// Bug fix: падали с циклической печатью.
//
// Revision 1.273  2015/12/22 13:39:07  dinishev
// {Requestlink:570533216}. Непроходили тесты. Продолжаю дотачивать.
//
// Revision 1.272  2015/12/18 12:24:13  dinishev
// {Requestlink:570533216}. Последствия правок.
//
// Revision 1.271  2015/12/18 10:42:16  dinishev
// {Requestlink:570533216}
//
// Revision 1.270  2015/10/12 13:56:51  dinishev
// Чистка кода.
//
// Revision 1.269  2015/10/12 09:24:51  dinishev
// {Requestlink:609429714}
//
// Revision 1.268  2015/10/09 14:48:41  kostitsin
// {requestlink: 604917289 } - инициализируем неинициализированное
//
// Revision 1.267  2015/10/09 11:44:31  dinishev
// {Requestlink:609150339}. Лишняя заливка для текста заголовка.
//
// Revision 1.266  2015/08/25 13:05:12  dinishev
// Bug fix: Assert при прокрутке в тестах.
//
// Revision 1.265  2015/08/24 06:47:57  dinishev
// Bug fix: зацикливались.
//
// Revision 1.264  2015/08/20 12:59:35  dinishev
// {Requestlink:602009846}
//
// Revision 1.263  2015/08/19 14:23:08  dinishev
// {Requestlink:602009846}
//
// Revision 1.262  2015/08/19 10:43:05  dinishev
// {Requestlink:605147467}
//
// Revision 1.261  2015/08/18 13:27:45  dinishev
// {Requestlink:602009846}
//
// Revision 1.260  2015/08/18 10:28:41  dinishev
// {Requestlink:602009846}
//
// Revision 1.259  2015/07/28 14:17:32  dinishev
// {Requestlink:602505046}
//
// Revision 1.258  2015/06/25 06:14:19  dinishev
// Bug fix: AV на переходных процессах.
//
// Revision 1.257  2015/05/18 12:47:48  dinishev
// {Requestlink:599801215}. Head.
//
// Revision 1.256  2015/04/24 10:12:49  dinishev
// {Requestlink:597332678}. Часть вторая.
//
// Revision 1.255  2015/04/17 12:25:57  dinishev
// {Requestlink:596845383}
//
// Revision 1.254  2015/04/16 13:26:59  dinishev
// {Requestlink:596845383}
//
// Revision 1.253  2015/03/30 12:53:31  dinishev
// {Requestlink:589882366}
//
// Revision 1.252  2015/02/03 10:31:36  dinishev
// Bug fix: не проходил тест TK233014754
//
// Revision 1.251  2015/01/29 13:54:27  dinishev
// Недокоммител: {Requestlink:587145017}
//
// Revision 1.250  2014/11/21 12:43:13  dinishev
// {Requestlink:576541850}
//
// Revision 1.249  2014/11/06 13:02:14  dinishev
// Не проходили тесты в EverestLite.
//
// Revision 1.248  2014/11/06 08:29:23  dinishev
// Отладка тестов прокрутки в EverestLite.
//
// Revision 1.247  2014/11/06 06:31:09  dinishev
// Bug fix: отъехал тест после вчерашних правок.
//
// Revision 1.246  2014/11/05 11:42:50  dinishev
// {Requestlink:570533434}. Не всегда правильно инициализировали BottomAnchor
//
// Revision 1.245  2014/05/20 16:18:06  lulin
// - пытаемся восстановить компилируемость под XE.
//
// Revision 1.244  2014/04/30 11:23:54  lulin
// - выпрямляем зависимости.
//
// Revision 1.243  2014/04/29 13:38:53  lulin
// - вычищаем ненужные зависимости.
//
// Revision 1.242  2014/04/29 12:03:52  lulin
// - вычищаем ненужный метод.
//
// Revision 1.241  2014/04/24 12:26:08  lulin
// [$531960334]
//
// Revision 1.240  2014/04/21 11:45:04  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.239  2014/04/16 12:23:34  dinishev
// {Requestlink:529040320}. Убрал костыль - без него все прекрасно работает.
//
// Revision 1.238  2014/04/15 12:14:31  dinishev
// {Requestlink:529040320}
//
// Revision 1.237  2014/04/11 09:39:08  dinishev
// Bug fix: неициализированная переменная.
//
// Revision 1.236  2014/04/08 14:16:58  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.235  2014/03/28 12:15:27  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.234  2014/02/13 11:23:56  kostitsin
// {requestlink: 516180498 } - по задаче
//
// Revision 1.233  2013/12/13 06:01:03  dinishev
// {Requestlink:507439888}
//
// Revision 1.232  2013/10/21 15:43:02  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.231  2013/10/21 10:30:46  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.230  2013/08/07 11:37:30  dinishev
// {Requestlink:471769519}
//
// Revision 1.229  2013/05/27 13:18:40  dinishev
// {Requestlink:382406560}. Лечим быстро.
//
// Revision 1.228  2013/05/24 15:59:48  lulin
// - пытаемся портироваться под XE4.
//
// Revision 1.227  2013/05/24 09:49:19  dinishev
// {Requestlink:452381851}
//
// Revision 1.226  2013/04/25 10:59:59  dinishev
// {Requestlink:452365172}
//
// Revision 1.225  2013/04/23 11:59:37  dinishev
// Bug fix: зацикливались тесты.
//
// Revision 1.224  2013/04/23 10:28:47  dinishev
// {Requestlink:450291144}
//
// Revision 1.223  2013/04/22 10:57:31  dinishev
// {Requestlink:450291144}
//
// Revision 1.222  2013/04/04 11:19:11  lulin
// - портируем.
//
// Revision 1.221  2013/01/16 09:47:07  dinishev
// Cleanup
//
// Revision 1.220  2013/01/15 12:49:54  dinishev
// AV в тестах под F1
//
// Revision 1.219  2013/01/14 08:12:19  dinishev
// {Requestlink:423593340}
//
// Revision 1.218  2012/12/24 07:23:06  dinishev
// Bug fix: не компилировался Арчи.
//
// Revision 1.217  2012/12/17 11:09:36  dinishev
// {Requestlink:379247543}
//
// Revision 1.216  2012/11/27 08:20:52  dinishev
// {Requestlink:404361004}
//
// Revision 1.215  2012/11/13 11:53:50  dinishev
// {Requestlink:407736033}
//
// Revision 1.214  2012/10/29 16:56:59  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.213  2012/10/12 08:39:04  dinishev
// {Requestlink:235872912}
//
// Revision 1.212  2012/10/08 12:23:13  dinishev
// {Requestlink:400523879}
//
// Revision 1.211  2012/10/02 10:05:28  dinishev
// {Requestlink:395658761}
//
// Revision 1.210  2012/08/21 12:09:47  dinishev
// {Requestlink:382421131}
//
// Revision 1.209  2012/08/20 14:18:34  dinishev
// {Requestlink:382421131}
//
// Revision 1.208  2012/07/26 12:58:05  dinishev
// {Requestlink:156371013}
//
// Revision 1.207  2012/07/25 06:54:02  dinishev
// {Requestlink:156371013}
//
// Revision 1.206  2012/07/24 16:11:59  lulin                     
// - правим за Димой недокоммиченное.
//
// Revision 1.205  2012/07/18 13:34:08  dinishev
// {Requestlink:377753634}
//
// Revision 1.204  2012/07/17 12:35:08  dinishev
// {Requestlink:377753634}
//
// Revision 1.203  2012/07/09 10:01:22  dinishev
// {Requestlink:371647970}
//
// Revision 1.202  2012/07/05 12:51:17  dinishev
// {Requestlink:370383768}
//
// Revision 1.201  2012/05/24 07:12:53  dinishev
// Убираем _evOld
//
// Revision 1.200  2012/02/27 17:12:04  kostitsin
// [$342331979]
//
// Revision 1.199  2012/02/27 17:02:06  kostitsin
// [$338461566]
//
// Revision 1.198  2012/02/21 11:05:24  lulin
// - вставляем Assert'ы про чудеса присвоения.
//
// Revision 1.197  2011/12/23 10:49:50  dinishev
// Bug fix: могло быть AV при работе с таблицами.
//
// Revision 1.196  2011/10/31 12:21:41  lulin
// {RequestLink:283148869}
//
// Revision 1.195  2011/10/28 15:19:28  lulin
// {RequestLink:283148869}
//
// Revision 1.194  2011/10/28 14:23:25  lulin
// {RequestLink:283148869}
// - проверяем целостность цепочек форматирования.
//
// Revision 1.193  2011/09/19 09:46:11  lulin
// {RequestLink:266898633}.
//
// Revision 1.192  2011/09/15 18:32:09  lulin
// {RequestLink:278824896}.
//
// Revision 1.191  2011/09/15 16:23:27  lulin
// {RequestLink:278824896}.
//
// Revision 1.190  2011/09/14 07:51:46  lulin
// {RequestLink:278824896}.
//
// Revision 1.189  2011/09/12 17:39:55  lulin
// {RequestLink:278839709}.
//
// Revision 1.188  2011/09/12 16:34:17  lulin
// {RequestLink:278839709}.
//
// Revision 1.187  2011/09/02 18:50:42  lulin
// {RequestLink:280006084}.
//
// Revision 1.186  2011/09/01 13:44:31  lulin
// {RequestLink:280006084}.
//
// Revision 1.185  2011/08/24 12:44:26  dinishev
// [$280003264]
//
// Revision 1.184  2011/08/11 12:42:03  dinishev
// [$269064546]
//
// Revision 1.183  2011/07/19 16:17:30  lulin
// {RequestLink:274834200}.
//
// Revision 1.182  2011/07/18 14:34:03  dinishev
// [$273595400]
//
// Revision 1.181  2011/07/12 12:03:26  dinishev
// Bug fix: AV при печати.
//
// Revision 1.180  2011/07/11 17:48:04  lulin
// {RequestLink:228688745}.
//
// Revision 1.179  2011/07/08 17:43:50  lulin
// {RequestLink:228688745}.
//
// Revision 1.178  2011/07/08 17:05:53  lulin
// {RequestLink:228688745}.
//
// Revision 1.177  2011/06/10 13:27:10  dinishev
// [$269062270]
//
// Revision 1.176  2011/06/10 09:47:22  dinishev
// [$269062270]
//
// Revision 1.175  2011/05/25 11:29:10  dinishev
// [$265392359]
//
// Revision 1.174  2011/05/19 12:07:38  dinishev
// [$266405030]
//
// Revision 1.173  2011/04/12 06:53:49  dinishev
// [$259164768]
//
// Revision 1.172  2011/03/24 17:26:35  dinishev
// [$258610458]
//
// Revision 1.171  2010/12/02 12:55:13  dinishev
// [$242844505]
//
// Revision 1.170  2010/10/19 12:43:48  dinishev
// [$235869058]
//
// Revision 1.169  2010/10/11 15:51:50  lulin
// {RequestLink:235870786}.
// - подготавливаем инфраструктуру.
//
// Revision 1.168  2010/10/08 17:13:12  lulin
// {RequestLink:235870994}.
// - [$235871850].
//
// Revision 1.167  2010/10/07 16:18:00  lulin
// {RequestLink:235870087}.
//
// Revision 1.166  2010/10/07 13:48:41  dinishev
// [$235866981]
//
// Revision 1.165  2010/10/06 17:51:21  lulin
// {RequestLink:235868845}.
// - поправил Димину ошибку.
// - сделал задел на создание страниц.
// - сделал ссылки на приложенные аттачи.
//
// Revision 1.164  2010/10/06 17:16:47  lulin
// {RequestLink:235868845}.
// [$235869183].
//
// Revision 1.163  2010/10/06 12:24:07  dinishev
// [$235864277]. Тест.
//
// Revision 1.162  2010/10/05 12:42:03  lulin
// {RequestLink:235866221}.
// - более внятная дианостика о месте различий.
//
// Revision 1.161  2010/10/04 11:01:52  lulin
// {RequestLink:235864341}.
//
// Revision 1.160  2010/10/01 16:26:18  lulin
// {RequestLink:235864309}.
//
// Revision 1.159  2010/08/19 08:27:14  dinishev
// [$233014754]
//
// Revision 1.158  2010/08/18 06:36:40  dinishev
// [$224789453]
//
// Revision 1.157  2010/08/13 12:37:43  dinishev
// [$224133855]
//
// Revision 1.156  2010/07/22 08:25:27  dinishev
// Cleanup
//
// Revision 1.155  2010/07/19 09:09:58  dinishev
// [$227477159]. Убираем устаревший Assert.
//
// Revision 1.154  2010/07/13 12:50:34  dinishev
// [$218824805]
//
// Revision 1.153  2010/07/09 11:04:19  dinishev
// [$224789069]
//
// Revision 1.152  2010/07/08 14:13:19  dinishev
// [$224134537]. Недоделал.
//
// Revision 1.151  2010/07/08 13:41:27  dinishev
// [$224134537]. Забыли про aNeedInsert
//
// Revision 1.150  2010/07/08 09:45:59  dinishev
// [$224134537]. Немного меняем проверку
//
// Revision 1.149  2010/07/08 09:32:32  dinishev
// [$224134537]
//
// Revision 1.148  2010/07/07 08:30:12  dinishev
// [$224134476]
//
// Revision 1.147  2010/06/29 07:01:37  dinishev
// [$220595669]
//
// Revision 1.146  2010/06/28 15:23:24  dinishev
// [$220594193]. Bug fix: если даже PID совпадают, то это не значит что найденный шейп принадлежит одному и тому же параграфу, т.к. f_PIDOfs мог быть перед этим сброшен.
//
// Revision 1.145  2010/06/24 15:53:36  dinishev
// [$217688170]
//
// Revision 1.144  2010/06/21 09:33:23  dinishev
// [$218464384]. Bug fix: не забываем, что можем скроллироваться по объдиненной ячейке.
//
// Revision 1.143  2010/06/21 07:35:37  dinishev
// [$219120094]. Вычищаем f_NeedIncludeHeight.
//
// Revision 1.142  2010/06/21 07:24:18  dinishev
// [$219120094]
//
// Revision 1.141  2010/06/11 07:18:56  dinishev
// [$217684334]
//
// Revision 1.140  2010/06/11 06:21:35  dinishev
// Cleanup
//
// Revision 1.139  2010/06/11 06:05:50  dinishev
// Cleanup
//
// Revision 1.138  2010/06/11 05:46:50  dinishev
// Cleanup
//
// Revision 1.137  2010/06/11 05:41:51  dinishev
// Убираем лишнюю проверку
//
// Revision 1.136  2010/06/10 11:20:52  dinishev
// [$217684334]. Bug fix: не всегда "дорисовывали" базовую линию после её заполнения в nevShapesPainted.
//
// Revision 1.135  2010/06/09 11:18:06  lulin
// {RequestLink:217684334}.
// - добавлен тест.
//
// Revision 1.134  2010/06/08 08:35:31  dinishev
// [$217681540]. Не всегда полностью инициализировали базовую линию по отрисованным ячейкам.
//
// Revision 1.133  2010/06/04 14:32:22  lulin
// {RequestLink:213713120}.
// - более тонко настраиваем тест, чтобы было как у Ушакова.
// - правим Assert'ы.
//
// Revision 1.132  2010/06/03 09:32:58  dinishev
// Cleanup
//
// Revision 1.131  2010/06/02 08:43:26  dinishev
// [$216793505]
//
// Revision 1.130  2010/06/01 06:59:46  dinishev
// [$216531291]
//
// Revision 1.129  2010/05/28 18:05:50  lulin
// {RequestLink:216073902}.
//
// Revision 1.128  2010/05/27 11:19:13  dinishev
// [$216074128]
//
// Revision 1.127  2010/05/25 13:22:31  lulin
// {RequestLink:213713120}.
//
// Revision 1.126  2010/05/24 05:57:35  dinishev
// Не сохраняем данные о выравнивании линий при печати
//
// Revision 1.125  2010/05/20 08:24:43  dinishev
// Избавляемся от лишнего параграфа aFake
//
// Revision 1.124  2010/05/20 08:19:42  dinishev
// Cleanup
//
// Revision 1.123  2010/05/20 08:16:33  dinishev
// [$213713837]
//
// Revision 1.122  2010/05/18 12:07:06  dinishev
// Bug fix: не всегда ставился курсор в объединеных ячейках
//
// Revision 1.121  2010/05/18 08:14:04  dinishev
// Bug fix: тесты отъехали после вчерашних правок.
//
// Revision 1.120  2010/05/17 09:46:43  dinishev
// Восстанавливаем курсор.
//
// Revision 1.118  2010/05/17 09:29:30  dinishev
// Избавляемся от f_Fake
//
// Revision 1.117  2010/05/17 09:18:17  dinishev
// Убираем f_UpperShape и FakeChildStatus
//
// Revision 1.116  2010/05/17 09:11:06  dinishev
// Избавляемся от поля OverlapType
//
// Revision 1.115  2010/05/14 15:01:10  lulin
// [$213254820].
//
// Revision 1.114  2010/05/14 14:31:23  dinishev
// [$210438932]
//
// Revision 1.113  2010/05/14 08:24:01  dinishev
// Не инициализировали переменную.
//
// Revision 1.112  2010/05/13 14:25:58  lulin
// {RequestLink:210438932}.
// - сделано построчное сроллирование.
// - уменьшен размер тестового файла.
//
// Revision 1.111  2010/05/13 12:00:46  lulin
// {RequestLink:210438932}.
// - обильно расставляем Assert'ы.
//
// Revision 1.110  2010/05/06 09:56:24  dinishev
// Bug fix: не всегда инициализировали точки для продолжения объединенных ячеек
//
// Revision 1.109  2010/04/27 13:57:48  dinishev
// [$206079285]
//
// Revision 1.108  2010/04/16 08:16:55  dinishev
// Bug fix: AV в Арчи при работе с таблицами (логи подсказали)
//
// Revision 1.107  2010/04/12 08:35:16  dinishev
// [$201493907]
//
// Revision 1.106  2010/04/08 08:11:19  dinishev
// [$201490621]
//
// Revision 1.105  2010/04/07 12:15:05  dinishev
// [$201491457]
//
// Revision 1.104  2010/04/06 12:06:49  dinishev
// [$198673042]
//
// Revision 1.103  2010/03/25 14:30:25  dinishev
// [$199591291]
//
// Revision 1.102  2010/03/22 10:55:44  dinishev
// Cleanup
//
// Revision 1.101  2010/03/22 10:36:57  dinishev
// [$156369879]
//
// Revision 1.100  2010/03/18 08:54:10  dinishev
// [$156369879]. Боремся с AV. Bug fix: имена и назначение переменных не всегда совпадают. :-(
//
// Revision 1.99  2010/03/17 14:16:27  dinishev
// [$156369879]
//
// Revision 1.98  2010/03/17 08:53:16  dinishev
// [$156369879]. Позиционирование в объединенной ячейке, если начало не видно.
//
// Revision 1.97  2010/03/16 11:47:37  dinishev
// [$156369879]. Позиционирование в ячейках после объединенной.
//
// Revision 1.96  2010/03/15 10:36:33  dinishev
// [$156369879]
//
// Revision 1.95  2010/03/15 10:17:26  dinishev
// [$156369879]
//
// Revision 1.94  2010/03/13 09:17:54  dinishev
// Объединяем AnchorByPt и PointByPt
//
// Revision 1.93  2010/03/13 08:49:51  dinishev
// Объединяем AnchorByPt и PointByPt
//
// Revision 1.92  2010/03/12 10:45:37  dinishev
// [$177538022]
//
// Revision 1.91  2010/03/09 10:55:25  dinishev
// [$191398305]
//
// Revision 1.90  2010/03/05 10:50:03  dinishev
// [$183337716]
//
// Revision 1.89  2010/02/26 11:44:20  lulin
// {RequestLink:190677208}.
// - делаем возможность указывать нужные параметры операций примесей.
//
// Revision 1.88  2010/02/25 15:39:01  lulin
// {RequestLink:190677208}.
// - переносим коллекцию форм частично на модель.
//
// Revision 1.87  2010/02/18 08:25:19  dinishev
// [$185828614]
//
// Revision 1.86  2010/02/18 07:33:26  dinishev
// [$177964315]
//
// Revision 1.85  2009/12/10 10:45:19  dinishev
// Bug fix: не изменяем высоту строки при скроллинге.
//
// Revision 1.84  2009/11/19 14:26:52  dinishev
// [$89109196]
//
// Revision 1.83  2009/11/12 09:34:01  dinishev
// [$169541822]
//
// Revision 1.82  2009/10/31 13:27:19  dinishev
// [$159361037]
//
// Revision 1.81  2009/10/23 07:23:26  dinishev
// [$159361037].Немного поправил логику NeedIncludeHeight.
//
// Revision 1.80  2009/09/23 13:43:36  dinishev
// [$163068489]. Более правильные рабочие константы.
//
// Revision 1.79  2009/09/22 08:04:41  dinishev
// [$161123393]
//
// Revision 1.78  2009/09/16 17:19:04  lulin
// {RequestLink:163063106}. Боремся с переходными процессами при скроллинге.
//
// Revision 1.77  2009/09/09 11:58:02  dinishev
// [$162072845]
//
// Revision 1.76  2009/08/26 10:40:55  dinishev
// [$159369630]
//
// Revision 1.75  2009/08/26 10:32:17  dinishev
// Забытая ссылка на обсуждение.
//
// Revision 1.74  2009/08/25 15:00:56  dinishev
// [$159367236]
//
// Revision 1.73  2009/08/20 07:26:43  dinishev
// [$159359432]
//
// Revision 1.72  2009/07/29 13:58:38  lulin
// {RequestLink:158793936}.
//
// Revision 1.71  2009/07/14 14:56:41  lulin
// {RequestLink:141264340}. №25.
//
// Revision 1.70  2009/07/13 13:25:24  lulin
// {RequestLink:141264340}. №14.
//
// Revision 1.69  2009/07/13 12:31:48  lulin
// {RequestLink:141264340}. №23ac.
//
// Revision 1.68  2009/07/11 17:11:08  lulin
// {RequestLink:141264340}. №19.
//
// Revision 1.67  2009/07/11 12:46:28  lulin
// {RequestLink:141264340}. №14.
//
// Revision 1.66  2009/07/11 09:24:50  lulin
// - избавляемся от лишнего дёрганья счётчиков ссылок.
//
// Revision 1.65  2009/07/10 12:32:49  lulin
// - bug fix: скроллеры равняли по максимальной отрисованной области, а не по вычисленной ширине параграфа.
//
// Revision 1.64  2009/07/09 14:04:14  lulin
// - передаём кешированные отступы параграфов.
//
// Revision 1.63  2009/07/09 13:31:16  lulin
// - передаём кешированные отступы параграфов.
//
// Revision 1.62  2009/07/09 06:53:09  dinishev
// [$155027193]
//
// Revision 1.61  2009/07/02 12:27:40  lulin
// - добавил ссылки на обсуждение.
//
// Revision 1.60  2009/07/02 12:08:41  lulin
// [$155027034].
//
// Revision 1.59  2009/07/01 12:50:39  lulin
// - убрана ненужная функциональность.
//
// Revision 1.58  2009/07/01 12:22:27  lulin
// {RequestLink:141262980}. № 2b.
//
// Revision 1.57  2009/06/25 12:57:37  lulin
// - вычищаем ненужный контекст.
//
// Revision 1.56  2009/06/19 12:54:57  lulin
// - переносим TnevAnchor на модель.
//
// Revision 1.55  2009/04/29 06:22:16  dinishev
// <K> : 142610284
//
// Revision 1.54  2009/04/28 09:56:30  dinishev
// <K> : 142610284
//
// Revision 1.53  2009/04/09 14:12:46  lulin
// [$140837386]. №15.
//
// Revision 1.52  2009/03/31 12:04:41  lulin
// [$140286997].
//
// Revision 1.51  2009/03/04 13:32:57  lulin
// - <K>: 137470629. Генерируем идентификаторы типов с модели и убираем их из общей помойки.
//
// Revision 1.50  2009/02/13 06:51:01  dinishev
// <K> : 135602193
//
// Revision 1.49  2008/10/06 13:47:55  dinishev
// Bug fix: Assert в дереве словарей
//
// Revision 1.48  2008/08/27 12:45:41  lulin
// - <K>: 110986409.
//
// Revision 1.47  2008/08/20 09:36:25  lulin
// - <K>: 108626317.
//
// Revision 1.46  2008/08/13 09:24:16  lulin
// - <K>: 108233847.
//
// Revision 1.45  2008/07/03 13:23:23  lulin
// - <K>: 87589015.
//
// Revision 1.44  2008/05/08 14:02:42  lulin
// - не очищали объекты.
//
// Revision 1.43  2008/05/08 13:48:48  lulin
// http://mdp.garant.ru/pages/viewpage.action?pageId=86479273&focusedCommentId=90442637#comment-90442637
//
// Revision 1.42  2008/05/08 13:07:17  lulin
// - написан комментарий.
//
// Revision 1.41  2008/05/08 13:05:30  lulin
// - боремся с <K>: 86479273.
//
// Revision 1.40  2008/05/08 11:24:16  lulin
// http://mdp.garant.ru/pages/viewpage.action?pageId=86479273&focusedCommentId=90442368#comment-90442368
//
// Revision 1.39  2008/05/07 14:54:12  lulin
// - <K>: 90441797.
//
// Revision 1.38  2008/05/07 13:50:00  lulin
// - <K>: 90441635.
//
// Revision 1.37  2008/05/06 17:33:30  lulin
// - изменения в рамках <K>: 90441024.
//
// Revision 1.36  2008/05/06 15:49:02  lulin
// - изменения в рамках <K>: 90441024.
//
// Revision 1.35  2008/05/05 15:22:31  lulin
// - <K>: 90440235.
//
// Revision 1.34  2008/05/04 14:52:11  lulin
// - вычищены ненужные методы.
//
// Revision 1.33  2008/05/04 14:42:04  lulin
// - вычищен ненужный модуль.
//
// Revision 1.32  2008/05/04 07:42:10  lulin
// - <K>: 89109224.
//
// Revision 1.31  2008/04/29 16:56:55  lulin
// - работы по <K>: 89106312.
//
// Revision 1.30  2008/04/28 14:24:01  lulin
// - работы по <K>: 89106312.
//
// Revision 1.29  2008/04/25 13:40:42  lulin
// - работа в рамках <K>: 89107692.
//
// Revision 1.28  2008/04/24 18:40:46  lulin
// - подготавливаемся к хранению форматированияв пуле, в рамках <K>: 89106312.
//
// Revision 1.27  2008/04/24 18:32:20  lulin
// - подготавливаемся к хранению форматированияв пуле, в рамках <K>: 89106312.
//
// Revision 1.26  2008/04/24 15:22:14  lulin
// - изменения в рамках <K>: 89106312.
//
// Revision 1.25  2008/04/24 12:26:21  lulin
// - изменения в рамках <K>: 89106312.
//
// Revision 1.24  2008/04/23 14:20:09  lulin
// - <K>: 89106322.
//
// Revision 1.23  2008/04/21 11:31:29  lulin
// - <K>: 89098709.
//
// Revision 1.22  2008/04/14 13:46:44  lulin
// - <K>: 89096854.
//
// Revision 1.21  2008/04/11 14:26:21  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.20  2008/04/08 13:59:25  lulin
// - <K>: 89096920.
//
// Revision 1.19  2008/04/08 10:21:15  lulin
// - выделяем листьевую точку.
//
// Revision 1.18  2008/04/07 13:51:48  lulin
// - поправлено имя метода.
//
// Revision 1.17  2008/04/07 13:34:10  lulin
// - изменения в рамках <K>: 89096854.
//
// Revision 1.16  2008/04/07 11:59:59  lulin
// - <K>: 89096763.
//
// Revision 1.15  2008/04/07 05:27:07  lulin
// - <K>: 89096346.
//
// Revision 1.14  2008/04/04 13:15:56  lulin
// - трудимся над <K>: 88640902.
//
// Revision 1.13  2008/03/27 11:44:48  dinishev
// Борьба с медленным скроллингом длинной таблицы
//
// Revision 1.12  2008/03/19 12:00:01  dinishev
// Cleanup
//
// Revision 1.11  2008/03/18 16:22:01  dinishev
// Bug fix: корректная отрисовка таблиц с длинной объединенной ячейкой
//
// Revision 1.10  2008/03/03 13:20:30  lulin
// - nevTools перенесён на модель. Теперь всё компилируется.
//
// Revision 1.9  2008/02/27 18:19:52  lulin
// - подгоняем код под модель.
//
// Revision 1.8  2008/02/27 17:25:00  lulin
// - подгоняем код под модель.
//
// Revision 1.7  2008/02/19 16:45:36  lulin
// - используем типизацию элементов.
//
// Revision 1.6  2008/02/14 17:09:01  lulin
// - cleanup.
//
// Revision 1.5  2008/02/12 12:53:03  lulin
// - избавляемся от излишнего метода на базовом классе.
//
// Revision 1.4  2008/02/04 13:30:19  lulin
// - базовые списки выделены в отдельные файлы.
//
// Revision 1.3  2008/01/24 12:47:52  dinishev
// Bug fix: линия блока иногда рисовалась до начала экрана
//
// Revision 1.2  2007/12/04 12:47:52  lulin
// - перекладываем ветку в HEAD.
//
// Revision 1.1.2.149  2007/11/28 16:00:17  dinishev
// Восстанавливаем отрисовку evNodePainter и корректно отрисовываем объединенные ячейки
//
// Revision 1.1.2.148  2007/10/24 12:41:04  oman
// - fix: Не всегда правильно корректировали Top от вложенных квадратов.
//  Ломался вертикальный скроллинг (cq27172)
//
// Revision 1.1.2.147  2007/10/18 09:01:19  oman
// - fix: Для частично сформатированных блоков некорректно считался Top
//
// Revision 1.1.2.146  2007/10/17 11:26:13  oman
// - fix: Первый элемент горизонтального параграфа отрисовываем
//  тоже с учтеом дельты (отваливается рамка PictireLabel в КЗ) (К-56295766)
//
// Revision 1.1.2.145  2007/10/11 14:42:02  lulin
// - bug fix: не сбрасывалась суперпозиция сегментов при набивке текста.
//
// Revision 1.1.2.144  2007/10/10 19:12:37  lulin
// - храним суперпозицию сегментов в карте форматирования.
//
// Revision 1.1.2.143  2007/10/05 07:50:23  oman
// - fix: Для поиска _MapByPoint точку приводим к "точке зрения" не всего
//  документа, а верхнего отрисованного уровня (К-56295766)
//
// Revision 1.1.2.142  2007/10/05 07:04:56  oman
// - fix: Для поиска _MapByPoint точку приводим к "точке зрения" не всего
//  документа, а верхнего отрисованного уровня (К-56295766)
//
// Revision 1.1.2.141  2007/10/03 16:54:29  lulin
// - давим ошибку доступа к неверному параграфу при отрисовке после удаления.
//
// Revision 1.1.2.140  2007/10/01 14:37:07  oman
// - fix: При скроллировании корректируем верх неполносью влезшего
//  родительского Shape (К-55935116)
//
// Revision 1.1.2.139  2007/08/21 11:57:51  oman
// - fix: Не всегда была готова карта отрисовки для коррекции по
//  якорю. Коррекцию перенес в другое место, когда уже все есть (cq26365)
//
// Revision 1.1.2.138  2007/08/14 19:31:34  lulin
// - оптимизируем очистку памяти.
//
// Revision 1.1.2.137  2007/03/16 14:47:21  lulin
// - cleanup.
//
// Revision 1.1.2.136  2007/01/05 14:37:27  lulin
// - cleanup.
//
// Revision 1.1.2.135  2006/12/28 14:32:39  lulin
// - bug fix: курсор попадал в пустой блок (без детей) - в результате были всякие рудименты (CQ OIT5-23953, 23596).
//
// Revision 1.1.2.134  2006/11/20 16:33:16  lulin
// - удален ненужный метод.
//
// Revision 1.1.2.133  2006/11/20 15:55:13  lulin
// - cleanup: не используем позицию курсора по вертикали, вне _View_.
//
// Revision 1.1.2.132  2006/11/10 17:15:59  lulin
// - объединил с веткой.
//
// Revision 1.1.2.131  2006/11/03 11:00:18  lulin
// - объединил с веткой 6.4.
//
// Revision 1.1.2.130.2.23  2006/11/03 10:07:18  lulin
// - выделена функция проверки гарантированного существования корневой карты форматирования.
//
// Revision 1.1.2.130.2.22  2006/11/02 09:09:07  lulin
// - bug fix: не пытаемся скроллировать текст, если курсор и так видимый.
//
// Revision 1.1.2.130.2.21  2006/11/01 15:47:02  lulin
// - правильно рассчитываем количество дочерних элементов для горизонтальных списков.
//
// Revision 1.1.2.130.2.20  2006/11/01 13:56:23  lulin
// - подготавливаемся к правильному расчету количества отрисованных элементов в горизонтальных структурах.
//
// Revision 1.1.2.130.2.19  2006/10/31 09:14:52  lulin
// - bug fix: поиск карты форматирования по объекту портил уже вычисленные границы объекта.
//
// Revision 1.1.2.130.2.18  2006/10/30 11:53:01  lulin
// - избавляемся от зацикливания при поиске карты форматирования.
//
// Revision 1.1.2.130.2.17  2006/10/29 15:06:47  lulin
// - bug fix: длинные параграфы портили ширину ячеек таблиц (CQ OIT5-22824).
//
// Revision 1.1.2.130.2.16  2006/10/29 14:28:41  lulin
// - убран ненужный, код, оставшийся после переноса части функциональности в другое место.
//
// Revision 1.1.2.130.2.15  2006/10/29 13:16:18  lulin
// - вычисляем вертикальное смещение в тот момент, когда известна карта форматирования.
//
// Revision 1.1.2.130.2.14  2006/10/27 08:33:35  lulin
// - список отрисованных параграфов не хранит ссылку на _View.
//
// Revision 1.1.2.130.2.13  2006/10/26 10:48:51  lulin
// - избавляемся от преобразования карты форматирования к тегу.
//
// Revision 1.1.2.130.2.12  2006/10/25 17:55:39  lulin
// - в функцию расчета вертикального смещения передаем карту форматирования.
//
// Revision 1.1.2.130.2.11  2006/10/25 08:48:05  lulin
// - используем базовую точку, а не якорь.
//
// Revision 1.1.2.130.2.10  2006/10/25 07:04:22  lulin
// - bug fix: неверным способом пытались удалять пустые элементы - не учитывая то, что у нас индексный массив, а не список. Сейчас удаление закоментировано.
// - bug fix: неверно печатали при наличии пустых (неотрисованных) элементов в карте форматирования (CQ OIT5-23145).
//
// Revision 1.1.2.130.2.9  2006/10/23 13:41:19  lulin
// - bug fix: падали при переходных процессах, когда карта форматирования еще не была построена.
//
// Revision 1.1.2.130.2.8  2006/10/23 13:18:08  lulin
// - коррекцию начала коорданат прячем в метод инициализации точки.
//
// Revision 1.1.2.130.2.7  2006/10/23 12:47:42  lulin
// - метод инициализации смещения перенесен с базовой точки на курсор.
//
// Revision 1.1.2.130.2.6  2006/10/23 10:34:16  lulin
// - cleanup.
//
// Revision 1.1.2.130.2.5  2006/10/20 10:54:06  lulin
// - более правильно делаем курсор для картинки.
//
// Revision 1.1.2.130.2.4  2006/10/18 12:07:16  lulin
// - добавлен интерфес - "отображаемый объект".
//
// Revision 1.1.2.130.2.3  2006/10/18 11:14:36  lulin
// - cleanup.
//
// Revision 1.1.2.130.2.2  2006/10/16 08:41:25  lulin
// - bug fix: падали при печати документов с разрывами разделов (CQ OIT5-22830).
//
// Revision 1.1.2.130.2.1  2006/10/13 11:15:46  lulin
// - поборолся с неправильной подгонкой каретки по-горизонтали.
//
// Revision 1.1.2.130  2006/10/10 16:08:09  lulin
// - переполучаем карту форматирования, если текущая уже не соответствует представлению.
//
// Revision 1.1.2.129  2006/10/10 15:12:30  lulin
// - убран излишний метод.
//
// Revision 1.1.2.128  2006/10/10 14:13:11  lulin
// - очищаем ссылку на всю коллекцию отрисованных.
//
// Revision 1.1.2.127  2006/10/10 13:50:30  lulin
// - получаем карту форматирования собственно по курсору, а не по параграфу.
//
// Revision 1.1.2.126  2006/10/10 13:03:33  lulin
// - cleanup.
//
// Revision 1.1.2.125  2006/10/03 11:26:21  lulin
// - временно не подгоняем размеры по последнему ребенку, т.к. последний - не факт, что нарисован.
//
// Revision 1.1.2.124  2006/10/02 11:38:40  lulin
// - объединяем с веткой в которой размеры параграфов подсчитываются методами канвы.
//
// Revision 1.1.2.123.2.19  2006/09/29 11:39:18  lulin
// - вычищены ненужные методы.
//
// Revision 1.1.2.123.2.18  2006/09/29 08:10:14  lulin
// - bug fix: не учитывали правый отступ списков параграфов.
//
// Revision 1.1.2.123.2.17  2006/09/28 18:11:00  lulin
// - избавляемся от рекурсивной очистки отрисованных регионов.
//
// Revision 1.1.2.123.2.16  2006/09/28 16:55:22  lulin
// - bug fix: закрытие группы не приводило к уменьшению ее высоты.
//
// Revision 1.1.2.123.2.15  2006/09/28 14:16:47  lulin
// - запоминаем координаты нижнего угла списка параграфов.
//
// Revision 1.1.2.123.2.14  2006/09/28 13:06:29  lulin
// - bug fix: не учитывалашь ширина преформатированных параграфов.
//
// Revision 1.1.2.123.2.13  2006/09/27 16:26:40  lulin
// - используем стек отрисованных регионов для параграфов любой вложенности.
//
// Revision 1.1.2.123.2.12  2006/09/27 15:02:00  lulin
// - bug fix: контроллируем, что конец списка параграфов не может быть выше его начала.
//
// Revision 1.1.2.123.2.11  2006/09/27 14:34:43  lulin
// - bug fix: размеры элементов таблиц не уменьшались при модификации содержимого ячеек.
//
// Revision 1.1.2.123.2.10  2006/09/26 12:57:06  lulin
// - bug fix: падали при рисовании пустых списков параграфов.
//
// Revision 1.1.2.123.2.9  2006/09/25 09:00:10  lulin
// - убран ненужный параметр.
//
// Revision 1.1.2.123.2.8  2006/09/22 16:33:27  lulin
// - bug fix: иногда возвращалась карта форматирования не от того параграфа, например для свернутой группы в КЗ или при переходных процессах начала отрисовки документа.
//
// Revision 1.1.2.123.2.7  2006/09/22 16:31:59  lulin
// - от листьевых параграфов теперь требуются не размеры, а реальный нижний правый угол.
//
// Revision 1.1.2.123.2.6  2006/09/22 13:39:36  lulin
// - разнес вычисление прямоугольника для листьевого и нелистьевого параграфов.
//
// Revision 1.1.2.123.2.5  2006/09/22 11:52:39  lulin
// - восстановлен ошибочно утерянный код.
//
// Revision 1.1.2.123.2.4  2006/09/22 11:23:56  lulin
// - используем полиморфизм вместо условных операторов.
//
// Revision 1.1.2.123.2.3  2006/09/22 09:43:51  lulin
// - правильно очищаем верхний список элементов.
//
// Revision 1.1.2.123.2.2  2006/09/22 09:19:31  lulin
// - если параграф отрисован снизу целиком, то учитываем его нижний отступ.
//
// Revision 1.1.2.123.2.1  2006/09/22 08:49:17  lulin
// - начинаем переводить отрисовку на использование карты форматирования.
//
// Revision 1.1.2.123  2006/09/16 10:36:40  lulin
// - bug fix: при частичной отрисовке портились размеры параграфов, сохраняемые в карте форматирования.
//
// Revision 1.1.2.122  2006/08/31 09:08:35  oman
// - fix: Зацикливание при подсчете страниц для превью/печати (cq22433)
//
// Revision 1.1.2.121  2006/08/30 14:03:17  lulin
// - удален ненужный код.
//
// Revision 1.1.2.120  2006/08/30 14:00:23  lulin
// - bug fix: при рисовании курсора портилась реальная высота параграфа (CQ OIT5-22343).
//
// Revision 1.1.2.119  2006/08/30 08:46:22  lulin
// - bug fix: неправильно скроллировались многострочные комментарии.
//
// Revision 1.1.2.118  2006/08/02 10:52:00  lulin
// - объединил с веткой в которой боролся со скроллингом.
//
// Revision 1.1.2.117.2.9  2006/08/01 12:56:30  lulin
// - bug fix: опять убраны пустые строки при печати.
//
// Revision 1.1.2.117.2.8  2006/07/31 16:05:09  lulin
// - убрано по возможности повторное форматирование сложных структур, типа таблиц.
//
// Revision 1.1.2.117.2.7  2006/07/31 14:42:11  lulin
// - восстановлено рисование рамок таблиц.
//
// Revision 1.1.2.117.2.6  2006/07/28 10:00:15  lulin
// - убираем корректировку размера.
//
// Revision 1.1.2.117.2.5  2006/07/26 13:28:27  lulin
// - устанавливаем высоту и ширину не параграфа, а карты форматирования.
//
// Revision 1.1.2.117.2.4  2006/07/26 10:27:56  lulin
// - вместо указателя на запись используем ссылку на интерфейс.
//
// Revision 1.1.2.117.2.3  2006/07/26 09:33:57  lulin
// - при инициализации точки в параграфе передаем карту форматирования.
//
// Revision 1.1.2.117.2.2  2006/07/24 16:36:10  lulin
// - отрисовннный прямоугольник параграфа теперь тоже хранится в информации о форматировании.
//
// Revision 1.1.2.117.2.1  2006/07/24 16:23:59  lulin
// - теперь форматирование параграфа хранится в коллекции отрисованных элементов.
//
// Revision 1.1.2.117  2006/07/24 13:26:47  lulin
// - подготавливаемся к хранению карты форматирования параграфов в коллекции отрисованных элементов.
//
// Revision 1.1.2.116  2006/07/21 11:24:05  lulin
// - была потеряна корректировка размеров.
//
// Revision 1.1.2.115  2006/07/21 11:16:06  lulin
// - борьба с тормозами при вводе.
//
// Revision 1.1.2.114  2006/07/21 10:02:33  lulin
// - не держим ссылку на исходные данные отрисованного элемента.
//
// Revision 1.1.2.113  2006/07/21 09:57:47  lulin
// - получаем прямоугольник объекта, по его пути, а не паребором отрисованных элементов.
//
// Revision 1.1.2.112  2006/07/21 09:44:29  lulin
// - теперь умеен находить элемент по поданной точке.
//
// Revision 1.1.2.111  2006/07/21 09:06:43  lulin
// - переименованы методы - в соответствии с возвращаемыми значениями.
//
// Revision 1.1.2.110  2006/07/21 08:59:27  lulin
// - при поиске объекта по точке теперь возвращается курсор на заданную точку.
//
// Revision 1.1.2.109  2006/07/21 06:53:11  lulin
// - игнорируем параметр, который указывает требуемую вложенность.
//
// Revision 1.1.2.108  2006/07/21 06:33:33  lulin
// - для построения курсора начинаем использовать данные от вью.
//
// Revision 1.1.2.107  2006/07/21 06:13:35  lulin
// - возвращаем объект, а не его представление.
//
// Revision 1.1.2.106  2006/07/21 06:03:33  lulin
// - убран запил.
//
// Revision 1.1.2.105  2006/07/21 05:05:11  lulin
// - убраны лишние параметры.
//
// Revision 1.1.2.104  2006/07/20 17:23:54  lulin
// - переписан алгоритм поиска ближайшего вложенного параграфа.
//
// Revision 1.1.2.103  2006/07/20 15:51:55  lulin
// - cleanup.
//
// Revision 1.1.2.102  2006/07/20 15:47:04  lulin
// - теперь в списке отрисованных элементов запоминается ориентация элемента.
//
// Revision 1.1.2.101  2006/07/20 13:40:24  lulin
// - bug fix: не инициализировали видимость документа.
// - bug fix: при поиска элемента ближайшего к точке не учитывали его видимость.
//
// Revision 1.1.2.100  2006/07/20 13:19:12  lulin
// - избавляемся от дублирования кода.
//
// Revision 1.1.2.99  2006/07/20 13:05:26  lulin
// - cleanup.
//
// Revision 1.1.2.98  2006/07/20 12:35:22  lulin
// - cleanup.
//
// Revision 1.1.2.97  2006/07/20 12:23:28  lulin
// - переименовал параметр.
//
// Revision 1.1.2.96  2006/07/20 11:53:41  lulin
// - убран лишний параметр.
//
// Revision 1.1.2.95  2006/07/20 11:39:25  lulin
// - переприсваиваем начало параграфа, если он начинается ниже верхнего края экрана.
//
// Revision 1.1.2.94  2006/07/20 11:26:40  lulin
// - cleanup.
//
// Revision 1.1.2.93  2006/07/19 15:50:26  lulin
// - переименован метод - в соответствии с его параметрами.
//
// Revision 1.1.2.92  2006/07/19 15:43:11  lulin
// - с формы убран ненужный метод - теперь тот кто рисует определяет сколько по высоте стоит в попугаях рисуемый объект.
//
// Revision 1.1.2.91  2006/07/19 15:17:36  lulin
// - cleanup.
//
// Revision 1.1.2.90  2006/07/19 15:10:17  lulin
// - при печати не корректируем размеры отрисованного элемента.
//
// Revision 1.1.2.89  2006/07/19 14:40:10  lulin
// - cleanup.
//
// Revision 1.1.2.88  2006/07/19 14:24:16  lulin
// - теперь для определения прямоугольника вывода работаем с исходным объектом, а не с формой.
//
// Revision 1.1.2.87  2006/07/19 13:49:33  lulin
// - переименован класс.
//
// Revision 1.1.2.86  2006/07/19 13:46:16  lulin
// - форма теперь сама является коллекцией других форм.
//
// Revision 1.1.2.85  2006/07/19 12:47:43  lulin
// - убираем поиск дочернего параграфа в цикле - получаем его по ID в родителе.
//
// Revision 1.1.2.84  2006/07/19 12:00:25  lulin
// - убран ненужный параметр.
//
// Revision 1.1.2.83  2006/07/19 11:51:13  lulin
// - не распределяем место для неотрисованных параграфов в начале блока.
//
// Revision 1.1.2.82  2006/07/19 11:42:38  lulin
// - изменены названия методов.
//
// Revision 1.1.2.81  2006/07/19 11:39:13  lulin
// - складываем отрисованные элементы по индексам параграфов.
//
// Revision 1.1.2.80  2006/07/19 10:40:23  lulin
// - выделен метод добавления отрисованного элемента с проверкой на его существование.
//
// Revision 1.1.2.79  2006/07/19 10:13:28  lulin
// - изменены параметры инициализации отрисованного элемента.
//
// Revision 1.1.2.78  2006/07/19 10:04:09  lulin
// - изменены названия методов.
//
// Revision 1.1.2.77  2006/07/18 15:52:13  lulin
// - bug fix: не учитывалось скроллирование параграфов по-горизонтали.
//
// Revision 1.1.2.76  2006/07/18 15:06:52  lulin
// - bug fix: неправильное условие в заплатке - всегда считали, что попадаем в нижний край экрана.
//
// Revision 1.1.2.75  2006/07/18 14:13:36  lulin
// - временно отключил незатирание начала параграфа - иначе ссылки отваливаются.
//
// Revision 1.1.2.74  2006/07/18 13:49:03  lulin
// - cleanup.
//
// Revision 1.1.2.73  2006/07/18 13:26:44  lulin
// - не трогаем начальные координаты параграфа, если он уже находится в кеше.
//
// Revision 1.1.2.72  2006/07/17 14:52:13  lulin
// - из комментариев убрано название метода - чтобы не искался контекстным поиском.
//
// Revision 1.1.2.71  2006/06/27 10:18:10  mmorozov
// - new behaviour: если просили параграф точно  и при этом ткнули в документ (блок верхнего уровня), то возвращаем ближайший к точке параграф, см. комментарии в _TnevShapesPainted.GetShape (CQ: OIT500021356);
//
// Revision 1.1.2.70  2006/06/26 14:06:42  mmorozov
// - new: вывод в лог ближайшего координате параграфа;
//
// Revision 1.1.2.69  2006/06/21 09:18:02  lulin
// - buf fix: теперь не на печати не выкидываем пустые параграфы из списка отрисованны, т.к. иначе портилось определение конца документа (CQ OIT5-21381).
//
// Revision 1.1.2.68  2006/06/19 11:36:55  lulin
// - bug fix: после предыдущих правок глючило скроллирование за пределы многострочных параграфов в начале блоков, т.к. не учитывался отступ внутри многострочного параграфа.
//
// Revision 1.1.2.67  2006/06/19 11:15:45  lulin
// - bug fix: при скроллировании не учитывались верхние отступы списков параграфов (CQ OIT5-20792).
//
// Revision 1.1.2.66  2006/06/19 09:45:05  lulin
// - bug fix: при скроллировании вверх не учитывали отступы от списков параграфов (отчасти CQ OIT5-20792).
//
// Revision 1.1.2.65  2006/06/15 12:34:09  lulin
// - bug fix: иногда пропадали строки при печати или построении предварительного просмотра (CQ OIT5-21287).
//
// Revision 1.1.2.64  2006/06/02 09:27:32  lulin
// - cleanup.
//
// Revision 1.1.2.63  2006/06/02 09:21:52  lulin
// - избавляемся от излишней реккурсии к родителю, при корректировке размера параграфа.
//
// Revision 1.1.2.62  2006/06/02 09:02:49  lulin
// - не учитываем невидимые параграфы в процессе подсчета размера родителя.
//
// Revision 1.1.2.61  2006/06/02 08:51:51  lulin
// - cleanup.
//
// Revision 1.1.2.60  2006/06/02 08:25:38  lulin
// - cleanup.
//
// Revision 1.1.2.59  2006/06/02 08:07:30  lulin
// - упрощено определение видимости параграфа после скроллирования.
//
// Revision 1.1.2.58  2006/06/02 07:25:02  lulin
// - cleanup.
//
// Revision 1.1.2.57  2006/06/02 07:18:55  lulin
// - добавлен метод сдвига коллекции отрисованных элементов.
//
// Revision 1.1.2.56  2006/06/02 07:02:43  lulin
// - добавлен метод сдвига отрисованного элемента.
//
// Revision 1.1.2.55  2006/06/02 06:41:58  lulin
// - инкапсулируем признак видимости отрисованного элемента.
//
// Revision 1.1.2.54  2006/06/02 06:06:37  lulin
// - new behavior: у параграфа запоминаем признак видимости в окне редактора.
//
// Revision 1.1.2.53  2006/06/01 13:31:40  lulin
// - bug fix: размер ползунка скроллера менялся при скроллировании колесом мыши.
//
// Revision 1.1.2.52  2006/05/31 13:20:41  lulin
// - bug fix: боремся с изменением ползунка при частичной отрисовке текста.
//
// Revision 1.1.2.51  2006/05/16 11:36:11  mmorozov
// - bugfix: при поиске точного вхождения результат затирался (CQ: OIT500020192);
//
// Revision 1.1.2.50  2006/04/24 12:58:36  lulin
// - выпиливаем из списков общую функциональность.
//
// Revision 1.1.2.49  2006/03/27 13:19:57  lulin
// - cleanup.
//
// Revision 1.1.2.48  2006/03/06 10:57:26  lulin
// - bug fix: не всегда вставлялись комментарии.
//
// Revision 1.1.2.47  2006/03/02 15:34:09  lulin
// - теперь в PaintedShapes хранятся не _InevShape, а _Ik2Tag - чтобы избежать циклических ссылок между _View и _Shape.
//
// Revision 1.1.2.46  2006/02/17 08:48:13  lulin
// - bug fix: при скроллировании была рассинхронизация строк параграфов.
//
// Revision 1.1.2.45  2006/02/17 08:10:54  mmorozov
// - _format code;
//
// Revision 1.1.2.44  2006/02/17 08:10:05  mmorozov
// - change: сигнатура _InevShapesPainted._VertScroll;
//
// Revision 1.1.2.43  2006/02/17 07:32:42  lulin
// - bug fix: был перепутан знак дельты.
//
// Revision 1.1.2.42  2006/02/14 15:23:38  lulin
// - bug fix: использовался неправильный входной параметр.
//
// Revision 1.1.2.41  2006/02/14 15:05:00  mmorozov
// - new: реализация смещения по вертикали;
//
// Revision 1.1.2.40  2006/02/14 15:02:23  lulin
// - bug fix: не компилировалось.
//
// Revision 1.1.2.39  2006/02/14 14:41:36  mmorozov
// - new: метод коллекции _VertScroll;
//
// Revision 1.1.2.38  2006/01/23 17:44:00  lulin
// - cleanup.
//
// Revision 1.1.2.37  2006/01/23 17:31:57  lulin
// - bug fix: избавляемся от паразитного горизонтального скроллера в КЗ.
//
// Revision 1.1.2.36  2006/01/19 14:34:24  lulin
// - bug fix: неправильно вычислялась максимальная ширина скроллера - если его оризонтальная позиция не была равна нулю.
//
// Revision 1.1.2.35  2006/01/11 14:12:31  mmorozov
// - bugfix: для отицательно смещенных параграфов не правильно вычислялись размеры (cq: 00017579);
//
// Revision 1.1.2.34  2005/11/29 12:42:40  lulin
// - вернул хранение _Shape'ов, а не _Tag'ов, т.к. в КЗ иначе неправильно работал курсор мыши.
//
// Revision 1.1.2.33  2005/11/29 11:57:01  lulin
// - bug fix: избавляемся от циклических ссылок.
//
// Revision 1.1.2.32  2005/11/23 15:37:25  lulin
// - вернул кешируемость коллекции отрисованных параграфов.
// - добавил _assert, что на первом уровне не может быть больше одного параграфа.
//
// Revision 1.1.2.31  2005/11/23 13:40:39  lulin
// - cleanup.
//
// Revision 1.1.2.30  2005/11/23 12:25:09  lulin
// - cleanup.
//
// Revision 1.1.2.28  2005/11/11 17:01:34  lulin
// - bug fix: зависала оболочка при переключении документа с пустого на непустой (CQ OIT5-17961).
//
// Revision 1.1.2.27  2005/11/08 13:00:56  lulin
// - bug fix: пропадал горизонтальный скроллер если изменить размеры окна при отскроллированном документе.
//
// Revision 1.1.2.26  2005/11/04 10:04:01  lulin
// - optimization: избавился от необходимости расчета _AbsIndex при листании по странице вниз.
//
// Revision 1.1.2.25  2005/10/28 07:34:26  lulin
// - new behavior: горизонтальный скроллер теперь рассчитывается исходя из реально отрисованных размеров параграфов.
//
// Revision 1.1.2.24  2005/10/26 07:39:13  lulin
// - спрятал ненужные локальные переменные.
//
// Revision 1.1.2.23  2005/09/28 15:32:30  mmorozov
// bugfix: при пересчете размеров блоков не учитывались меж параграфные отступы;
//
// Revision 1.1.2.22  2005/09/22 12:37:21  lulin
// - bug fix: после back не работали переходы по ссылкам.
//
// Revision 1.1.2.21  2005/09/13 08:57:34  mmorozov
// - написана процедура AddShapeItem, закомментирована, может потребоваться, добавляет параграф в сортированный список параграфов;
// new behaviour: повторно отрисовываемые параграфы не удаляются, используются только для коррекции размеров (улучшена ситуация с мышью);
//
// Revision 1.1.2.20  2005/07/26 12:46:51  mmorozov
// new behaviour: всегда пересчитываем размеры параграфа после отрисовки;
//
// Revision 1.1.2.19  2005/07/25 10:24:32  mmorozov
// - hint fix;
//
// Revision 1.1.2.18  2005/07/25 07:08:39  mmorozov
// new: global functions ShapeOrientation, ShapeSize;
// new: при отрисовке параграфа корректируем размеры родителя, необходимо при частичной отрисовке блока;
//
// Revision 1.1.2.17  2005/07/12 15:47:28  lulin
// - cleanup.
//
// Revision 1.1.2.16  2005/07/12 13:58:46  mmorozov
// new: вывод в лог отладочной информации;
//
// Revision 1.1.2.15  2005/07/08 13:44:36  mmorozov
// bugfix: учитываем при поиске наиболее подходящего координату X;
//
// Revision 1.1.2.14  2005/07/08 07:54:57  mmorozov
// new: получение информации о параграфе (TnevShapesCollectionItem) по _InevShape;
//
// Revision 1.1.2.13  2005/07/05 08:47:45  mmorozov
// new behaviour: отдаем последний параграф, если курсор вышел за пределы экрана снизу;
//
// Revision 1.1.2.12  2005/07/04 14:51:07  mmorozov
// bugfix: поиск ближайшего к координатам параграфа;
//
// Revision 1.1.2.11  2005/07/04 14:20:33  lulin
// - убран WriteLn.
//
// Revision 1.1.2.10  2005/07/04 14:10:10  mmorozov
// - add comments;
//
// Revision 1.1.2.9  2005/07/04 14:05:17  mmorozov
// new: при повторной отрисовке параграфы удаляеются из коллекции;
// new: получение ближайшего к координатам курсора параграфа;
//
// Revision 1.1.2.8  2005/07/01 14:30:18  mmorozov
// change: сигнатура методов (aMaxDepthChild - первого самого глубокого ребенка параграфа в который ткнули);
//
// Revision 1.1.2.7  2005/07/01 14:04:04  mmorozov
// bugfix: работа GetShapeItem;
//
// Revision 1.1.2.6  2005/07/01 13:01:53  lulin
// - временно закомментировано удаление дубликатов - чтобы не падало.
//
// Revision 1.1.2.5  2005/07/01 12:08:40  mmorozov
// new: перед помещением параграфа в коллекцию удаляем дубликат;
//
// Revision 1.1.2.4  2005/07/01 08:25:37  mmorozov
// change: вместо списка открытых параграфов используем указатель на текущий открытый, ссылку на родительский параграф и числовое поле для определения Z координаты;
//
// Revision 1.1.2.3  2005/06/30 12:50:51  lulin
// - наследуемся от кешируемых объектов.
//
// Revision 1.1.2.2  2005/06/30 11:31:44  mmorozov
// remove: глобальная процедура;
//
// Revision 1.1.2.1  2005/06/30 09:28:59  mmorozov
// new: unit - коллекция отрисованных параграфов;
//

{$Include nevDefine.inc }

interface

uses
  l3Interfaces,
  l3Base,
  l3CacheableBase,
  l3Units,
  l3ProtoDataContainer,

  k2Interfaces,

  afwInterfaces,

  nevBase,
  nevTools,
  nevShapePrim,
  nevBasePointList,
  nevShapePrimRefList
  ;

type
  TnevShapesPainted = class;

  TnevShape = class(TnevShapePrim, InevMap)
  {* - Элемент коллекции отрисованных параграфов. }
  private
  // private fields
    f_PIDOfs            : Integer;
    f_Parent            : TnevShape;
    f_OnScreen          : Boolean;
    f_AllShapes         : TnevShapesPainted;
    f_Bounds            : Tl3Rect;
    f_AppliesToMaxWidth : Boolean;
      {-}
    f_FI                : TnevFormatInfoPrim;
    f_Obj               : InevObject;
  private
  // property methods
    procedure pm_SetVisible(aValue: Boolean);
      {-}
    function  pm_GetItem(aIndex : Integer) : TnevShape;
    procedure pm_SetItem(aIndex      : Integer;
                         const Value : TnevShape);
      {-}
  protected
  // interface methods
    // InevMap
    function GetMaxTop: Integer;
      virtual;
      {-}
    function GetChildenRight4Fill: Integer;
      virtual;
      {* - Ищет самую правую границу у дочерних. }
    function  Get_FI: TInevFormatInfoRet;
      {-}
    function  rVisible: Boolean;
      {-}
    procedure ValidateFormatInfo;
      virtual;
      {-}
    function  CheckFormatInfo(const anObject: InevObject): TInevFormatInfoRet;
      virtual;
      {-}
    function  pm_GetBounds: TafwRect; virtual;
      {-}
    function  pm_GetOuter: IafwShape;
      {-}
    function  ReserveMap(const aShape : InevObject): InevMap;
      {-}
    function  IsLinked: Boolean;
      {-}
    procedure AdjustTopByAnchor(const aView: InevView;const anAnchor: InevBasePoint);
      {-}
    function  EndDraw: TnevShape;
      {-}
    procedure SetDrawnBottom(const aBottom: TnevPoint);
      virtual;
      {-}
    procedure DoClearBounds; 
      {-}
    procedure ClearBounds;
      {-}
    procedure UpdateSubShapes(aDelta : Integer);
      virtual;
      abstract;
      {-}
    procedure UpdateBounds(aChild : TnevShape);
      virtual;
      abstract;
      {-}
    procedure CheckStoredLines(const aDelta: TnevPoint);
      virtual;
      {-}
    function GetRealVisible: TnevShape; virtual;
      {-}
    procedure SetRealVisible(const Value: TnevShape); virtual;
      {-}
    function GetUpperShape: TnevShape; virtual;
      {-}
    function MakeUpperPoint: InevBasePoint; virtual;
      {-}
    function GetChildMap(anIndex: Integer): InevMap;
      {-}
    procedure SetDrawnTop(aTop: Integer); virtual;
      {-}
  protected
  // protected methods
    function IsBottomShape(aTopShape: Integer; aShape: TnevShape): Boolean; virtual;
      {-}
    procedure CheckBounds; virtual;
      {-}
    function OverlapType: TOverlapType;
      {-}
    function  AbsIndexDelta: Integer;
      virtual;
      {-}
    function  IsVertical: Boolean;
      virtual;
      {-}
    function  CreateShape(const aShape   : InevObject;
                          const aTopLeft : TnevPoint): TnevShape;
      {-}
    function  AddShape(const aShape   : InevObject;
                       const aTopLeft : TnevPoint;
                       MakeVisible    : Boolean;
                       const aHacker  : InevK235870994Hacker): TnevShape;
      virtual;
      abstract;
      {-}
    procedure Cleanup;
      override;
      {-}
    function GetBottomShape: TnevShape; virtual;
      {-}
    function IsMapValid: Boolean;
  public
  // public methods
    constructor Create(anAllShapes    : TnevShapesPainted;
                       const aShape   : InevObject;
                       const aParent  : TnevShape;
                       const aTopLeft : TnevPoint);
      reintroduce;
      virtual;
      {-}
    procedure CleanupRefs;
      override;
      { Очищает ссылки на сторонние объекты. }
    procedure Clear;
      override;
      {-}
    procedure MoveBy(const aDelta: TnevPoint); 
      {-}
    procedure SaveLinesList; virtual;
      {-}
    procedure RestoreFromLineList; virtual;
      {-}
    function IsRowShape: Boolean; virtual;
      {-}
    function GetBoundsWithFakeShapes(const aTopShape: TnevShape): TnevRect; virtual;
      {-}
    function ChangeFakeItem(out aNewItem   : TnevShape;
                            out aParentObj : InevObjectList;
                            out aNew       : Boolean): Boolean; virtual;
      {-}
    procedure FoundFakeOwnerItem(out aNewItem : TnevShape); virtual;
      {-}
    function IsGreater: Boolean; virtual;
      {* - Самая длинная ячейка. }
    function NeedIncHeight: Boolean; virtual;
      {* - Нужно ли учитывать высоту элемента при расчете родительcкого. }
    function IsTable: Boolean; virtual;
      {-}
  public
  // public properties
    property Bounds: Tl3Rect
      read f_Bounds
      write f_Bounds;
      {-}
    property Parent: TnevShape
      read f_Parent;
      {-}
    property Visible: Boolean
      read f_OnScreen
      write pm_SetVisible;
      {-}
    property Items[aIndex : Integer] : TnevShape
      read pm_GetItem
      write pm_SetItem;
      default;
      {-}
    property RealVisible: TnevShape
      read GetRealVisible
      write SetRealVisible;
    property __Obj : InevObject
      read f_Obj;
      {-}
    property __FI : TnevFormatInfoPrim
      read f_FI;
      {-}
  end;//TnevShape

  TnevLeafShape = class(TnevShape)
  protected
  // protected methods
    function  AbsIndexDelta: Integer;
      override;
      {-}
    procedure SetDrawnBottom(const aBottom: TnevPoint);
      override;
      {-}
    function  AddShape(const aShape   : InevObject;
                       const aTopLeft : TnevPoint;
                       MakeVisible    : Boolean;
                       const aHacker  : InevK235870994Hacker): TnevShape;
        override;
        {-}
  end;//TnevLeafShape

  TnevTextParaShape = class(TnevLeafShape)
  protected
  // protected methods
    procedure CheckBounds; override;
      {-}
    procedure UpdateSubShapes(aDelta : Integer);
      override;
      {-}
    procedure UpdateBounds(aChild : TnevShape);
      override;
      {-}
    function  AddShape(const aShape   : InevObject;
                       const aTopLeft : TnevPoint;
                       MakeVisible    : Boolean;
                       const aHacker  : InevK235870994Hacker): TnevShape;
      override;
      {-}
  end;//TnevTextParaShape

  TnevHeaderTextParaShape = class(TnevTextParaShape)
  protected
   function  pm_GetBounds: TafwRect; override;
    {-}
  end;

  TnevBaseTopShape = class(TnevShape)
  public
   property TopObject: InevObject
      read f_Obj;
  end;

  TnevListShape = class(TnevBaseTopShape)
  private
  // private fields
    f_BottomShape: TnevShape;
     {* - Самый нижний Shape. Для инициализации BottomAnchor. }
    f_SubShapesCount  : Integer;
  protected
  // protected methods
    function CheckViewBottom(aTop: Integer): Boolean; virtual;
      {-}
    function GetChildenRight4Fill: Integer; override;
      {* - Ищет самую правую границу у дочерних. }
    function IsBottomShape(aTopShape: Integer; aShape: TnevShape): Boolean; override;
      {-}
    function GetBottomShape: TnevShape; override;
      {-}
    procedure SetDrawnBottom(const aBottom: TnevPoint);
      override;
      {-}
    function  AddShape(const aShape   : InevObject;
                       const aTopLeft : TnevPoint;
                       MakeVisible    : Boolean;
                       const aHacker  : InevK235870994Hacker): TnevShape;
      override;
      {-}
    procedure UpdateBounds(aChild : TnevShape);
      override;
      {-}
    procedure UpdateSubShapes(aDelta : Integer);
      override;
      {-}
    function  AbsIndexDelta: Integer;
      override;
      {-}
    procedure Cleanup;
      override;
      {-}
    procedure Clear;
      override;
      {-}  
  public
  // public methods
    constructor Create(anAllShapes    : TnevShapesPainted;
                       const aShape   : InevObjectList;
                       const aParent  : TnevShape;
                       const aTopLeft : TnevPoint);
      reintroduce;
      virtual;
      {-}
  end;//TnevListShape

  TnevTableShape = class(TnevListShape)
  private
    f_LinesArray  : Il3IntegerList;
     {* - Массив выравненных верхних линий для хранения. }
    f_WasScrolled : Boolean;
     {* - Была прокрутка. }
  protected
    procedure Cleanup;
      override;
      {-}
    procedure CheckStoredLines(const aDelta: TnevPoint);
      override;
      {-}
  public
    function IsTable: Boolean; override;
      {-}
    procedure SaveLinesList; override;
      {-}
    procedure RestoreFromLineList; override;
      {-}
  end;

  TnevHorzListShape = class(TnevListShape)
  protected
  // protected methods
    function  IsVertical: Boolean;
      override;
      {-}
    procedure UpdateSubShapes(aDelta : Integer);
      override;
      {-}
  end;//TnevHorzListShape

  TnevCellShape = class(TnevListShape)
  private
    f_RealVisible : TnevShape;
     {* -  Отображаемая ячейка. }
    f_UpperShape  : TnevShape;
     {* - Shape для начальной ячейки объединения. Будет инициализирован, толькое если сама ячейка не видна на экране. И будет установлен у первой "видимой" (!) ячейки объединения. У других ячеек снизу установлен не будет(!) }
  protected
    procedure Cleanup;
      override;
      {-}
    function GetRealVisible: TnevShape;
     override;
      {-}
    procedure SetRealVisible(const Value: TnevShape);
     override;
     {-}
    function GetUpperShape: TnevShape;
     override;
      {-}
    function MakeUpperPoint: InevBasePoint;
     override;
      {-}
  public
    function NeedIncHeight: Boolean; override;
      {* - Нужно ли учитывать высоту элемента при расчете родительcкого. }
    function IsGreater: Boolean;
      override;
      {* - Самая длинная ячейка. }
    function GetBoundsWithFakeShapes(const aTopShape: TnevShape): TnevRect;
      override;
      {-}
    function ChangeFakeItem(out aNewItem   : TnevShape;
                            out aParentObj : InevObjectList;
                            out aNew       : Boolean): Boolean;
      override;
     {* - Возвращает aNewItem Shape для начальной объединенной ячейки, если он существует. Если его нет, то возвращается aNew = True. }
    procedure FoundFakeOwnerItem(out aNewItem : TnevShape);
      override;
      {-}
  end;//TnevCellShape

  TnevRowShape = class(TnevHorzListShape)
  protected
   procedure UpdateBounds(aChild : TnevShape); override;
      {-}
   function GetMaxTop: Integer; override;
     {-}
   procedure SetDrawnTop(aTop: Integer); override;
      {-}
  public
   function IsRowShape: Boolean; override;
     {-}
  end;//TnevRowShape

  TnevDocumentShape = class(TnevListShape)
  private
   f_DecorShapes : TnevShapePrimRefList;
  protected
  // protected methods
    procedure Cleanup;
      override;
      {-}
    function  AddShape(const aShape   : InevObject;
                       const aTopLeft : TnevPoint;
                       MakeVisible    : Boolean;
                       const aHacker  : InevK235870994Hacker): TnevShape;
      override;
      {-}
  end;//TnevDocumentShape

  TnevTopShape = class(TnevDocumentShape)
  protected
    procedure ValidateFormatInfo;
     override;
      {-}
   function  CheckFormatInfo(const anObject: InevObject): TInevFormatInfoRet;
     override;
     {-}
  public
  // public methods
   constructor Create(anAllShapes    : TnevShapesPainted;
                      const aShape   : InevObjectList;
                      const aTopLeft : TnevPoint);
     reintroduce;
      {-}
  end;//TnevTopShape

  TnevHorzTopShape = class(TnevTopShape)
  // protected methods
    function  IsVertical: Boolean;
      override;
      {-}
    procedure UpdateSubShapes(aDelta : Integer);
      override;
      {-}
  end;//TnevHorzTopShape

  TnevShapesPainted = class(Tl3CacheableBase)
  {* - реализует интерфейс InevShapesPainted. }
  private
  // internal methods
    f_Current    : TnevShape;
      {* - Текущий открытый параграф. }
    f_DecorationsHolder : TnevShape;
    f_Shapes     : TnevBaseTopShape;
      {* - Содержит элементы коллекции параграфов первого уровня. }
    f_ZOrder     : Integer;
    f_MaxWidth   : Integer;
    f_ViewExtent : TnevPoint;
    f_View       : Pointer;
    f_TablePoints: TnevBasePointList;
  private
  // private methods
    procedure OffsetShapes(const aDelta : TnevPoint;
                           const anEx   : TnevPoint);
      {* - Сместить все параграфы на указанную величину. }
    function GetInnerAnchor(const aView: InevView; aShape: TnevShape; aSimple: Boolean; var aNeedMoveDown: Boolean): InevBaseLine4Anchor;
      {-}
    function CheckRowShape(const aView: InevView;
                          aShape: TnevShape;
                          const anAnchor: InevBaseLine4Anchor;
                          aSimple: Boolean;
                          var aNeedMoveDown: Boolean): Boolean;
      {-}
    function CorrectShape(aBottom: Integer; const aView: InevView; const aShape: TnevShape): TnevShape;
     {-}
    procedure SaveTablePoint(const aPoint: InevBaseLine4Anchor);
     {-}
    function RestoreTablePoint(const aRowObj: InevObject): InevBaseLine4Anchor;
     {-}
    procedure ClearList;
     {-}
  protected
  // proteced methods
    procedure Cleanup;
      override;
      {-}
  public
  // public methods
    function GetBottomAnchor(const aView: InevView; aSimple: Boolean; var aNeedMoveDown: Boolean): InevBaseLine4Anchor;
      {-}
    function  ItemByPoint(const aPoint      : InevBasePoint;
                          var aMostInner    : InevBasePoint;
                          out aFromBaseLine : Boolean;
                          aCheckVisible     : Boolean = False;
                          const aCheck      : InevObject = nil): TnevShape;
      {* - Возвращает элемент коллекции по точке. }
    function  Root: InevMap;
      {-}
    function  CheckRoot(const aShape   : InevObject;
                        const aTopLeft : TnevPoint): TnevShape;
      {-}
    function  PointByPt(const aView    : InevView;
                        const aPt      : TafwPoint;
                        aMode          : TnevPointByPtMode) : InevBaseLine4Anchor;
      {* - Возвращает параграф самого нижнего уровня по координатам. }
    function  MapByPoint(const aPoint : InevBasePoint; aCheckTopVisible: Boolean = False): InevMap;
      {-}
    function  Empty: Boolean;
      {-}
    function  SubShapesCount: Integer;
      {-}
    procedure Clear;
      {* - Очищает список. }
    procedure ClearEx;
      {* - Очищает список. }
    procedure BeginDraw(const aShape   : InevObject;
                        const anAnchor : InevBasePoint;
                        const aTopLeft : TnevPoint;
                        var theMap     : InevMap;
                        aFake          : Boolean;
                        const aHacker  : InevK235870994Hacker);
      {-}
    procedure EndDraw;
      {-}
    function  MaxWidth: Integer;
      {-}
    function VertScroll(const aView: InevView;
                        const aFrom : InevBasePoint;
                        const aTo   : InevBasePoint;
                        const anEx  : TnevPoint): Integer;
      {* - Изменяется координаты элементы коллекции на расстояние от aFrom до
           aTo и возвращает расстояние между верхними границами параграфов. }
    function  HorzScroll(aFrom : Integer;
                         aTo   : Integer;
                         const anEx  : TnevPoint): Integer;
      {* - Изменяется координаты элементы коллекции на расстояние от aFrom до
           aTo и возвращает расстояние между верхними границами параграфов. }
    constructor Create(const aView: InevView);
      reintroduce;
      {-}
  public
  // public properties
    property ViewExtent: TnevPoint
      read f_ViewExtent;
      {-}
  end;//TnevShapesPainted

implementation

uses
  Math,
  SysUtils,
  Classes,

  evConst,

  k2Tags,

  evdTypes,

  evParaTools,

  Table_Const,
  TableRow_Const,
  TableCell_Const,
  TextPara_Const,
  evTextParaConst,
  ObjectSegment_Const

  {$IfDef nsTest}
  ,
  nevShapesPaintedSpy
  {$EndIf nsTest}

  ,
  nevFacade,
  Document_Const,
  Block_Const,
  ControlsBlock_Const
  ;

const
 cnShepeYNil = 0;

// start class TnevShapesPainted

constructor TnevShapesPainted.Create(const aView: InevView);
//reintroduce;
//virtual;
{-}
begin
 inherited Create;
 f_View := Pointer(aView);
 f_MaxWidth := 0;
 f_ZOrder := 0;
end;

procedure TnevShapesPainted.OffsetShapes(const aDelta : TnevPoint;
                                         const anEx   : TnevPoint);
  {* - Сместить все параграфы на указанную величину. }
begin
 f_ViewExtent := anEx;
 if (f_Shapes <> nil) then
  f_Shapes.MoveBy(aDelta);
end;

procedure TnevShapesPainted.Cleanup;
//override;
{-}
begin
 f_View := nil;
 l3Free(f_Current);
 l3Free(f_Shapes);
 l3Free(f_TablePoints);
 FreeAndNil(f_DecorationsHolder);
 inherited;
end;

function TnevShapesPainted.ItemByPoint(const aPoint      : InevBasePoint;
                                       var aMostInner    : InevBasePoint;
                                       out aFromBaseLine : Boolean;
                                       aCheckVisible     : Boolean = False;
                                       const aCheck      : InevObject = nil): TnevShape;
  {* - Возвращает элемент коллекции по точке. }
var
 l_Point     : InevBasePoint absolute aMostInner;
 l_Pos       : Integer;
 l_Inn       : InevBasePoint;
 l_FoundFake : Boolean;
begin
 Assert((aPoint = nil) or not aPoint.Obj.IsDecorationElement);
 Result := f_Shapes;
 aFromBaseLine := False;
 l_FoundFake := False;
 l_Point := aPoint;
 while (l_Point <> nil) AND (Result <> nil) AND not Result.Empty AND
       l_Point.Obj.IsList do
 begin
  if (aCheck = nil) and l_Point.HasBaseLine then
  begin
   l_Inn := l_Point.InnerForChildThatNotAfterEnd(Result.f_FI, nev_itNone);
   if (l_Inn <> nil) and not l_Inn.Obj^.AsObject.Owner.IsSame(Result.f_Obj.AsObject) then
   begin
    l_Pos := l_Inn.Obj^.OwnerObj.PID;
    if (l_Pos < Result.Parent.f_PIDOfs) then
     Result := nil
    else
     Result := Result.Parent[l_Pos - Result.Parent.f_PIDOfs];
   end; // if not l_Inn.Obj^.Owner.IsSame(Result.f_Obj) then
   aFromBaseLine := True;
   // ^ - Раз уж мы сюда попали, то флаг ставится всегда! [$218824805] 
  end // if (aCheck = nil) and l_Point.HasBaseLine then
  else
   l_Inn := l_Point.Inner;
  if (l_Inn = nil) or (Result = nil) then
   Break;
   // - указателя на ребенка нет, выходим
  l_Pos := l_Inn.Obj.PID;
  if (l_Pos < Result.f_PIDOfs) then
   Result := nil
  else
   Result := Result[l_Pos - Result.f_PIDOfs];
  l_Point := l_Inn;
 end;//while (l_Point <> nil)
 l_FoundFake := aCheckVisible and
                (Result <> nil) and
                (Result.Parent <> nil) and
                Result.Parent.IsRowShape and
                (Result.GetUpperShape <> nil);
 if (Result <> nil) and l_FoundFake then
  Result := Result.GetUpperShape;
 if (aCheck <> nil) and not aCheckVisible then
 begin
  if (l_Point <> nil) AND not l_Point.Obj.AsObject.IsSame(aCheck.AsObject) then
   Result := nil;
  if (Result <> nil) AND not Result.f_Obj.AsObject.IsSame(aCheck.AsObject) then
   Result := nil;
 end;//aCheck <> nil
end;

function TnevShapesPainted.Root: InevMap;
  {-}
begin
 Result := f_Shapes;
end;

function TnevShapesPainted.PointByPt(const aView : InevView;
                                     const aPt   : TafwPoint;
                                     aMode       : TnevPointByPtMode) : InevBaseLine4Anchor;
  {-}
var
 l_Found     : TnevShape; //Указатель на найденный shape
 l_Index     : Integer; //Счетчик в цикле
 l_Temp      : TnevShape; //Временная буферная переменная для хранения предыдущего shape
 l_Item      : TnevShape; //Текущий в цикле
 l_Top       : InevObject; //Верхний объект(родительский)
 l_List      : InevObjectList; //Список объектов
 l_Point     : InevBaseLine4Anchor; //Текущая точка (для верхнего объекта)
 l_Parent    : InevBaseLine4Anchor;
 l_PID       : Integer;
 l_Fisrt     : Boolean;
 l_RowAnchor : InevBaseLine4Anchor;

  procedure lp_AddInner(const aParent  : InevBaseLine4Anchor;
                        const anAnchor : InevBaseLine4Anchor;
                        aPID           : Integer;
                        anIsHead       : Boolean);
  begin
   if l_RowAnchor = nil then
    l_RowAnchor := aParent;
   aParent.AddInner(aView, anAnchor, aPID, l_Fisrt, TnevAddInnerMode(anIsHead))
  end;

  procedure SetTemp(const aTop   : InevObject = nil;
                    const aPoint : InevBaseLine4Anchor = nil);
  var
   l_Leaf   : InevLeafPoint;
   l_Anchor : InevBaseLine4Anchor;
  begin//SetTemp
   l_Temp := l_Item;
   {$IF not (Defined(InsiderTest) and Defined(Archi))}
   try
   {$IFEND}
    if aTop = nil then
     l_Top := l_List[l_PID]
    else
     l_Top := aTop;
   {$IF not (Defined(InsiderTest) and Defined(Archi))}
   except
    on EListError do
     Exit;
   end;//try..except
   {$IFEND}
   if aPoint = nil then
    l_Point := l_Top.MakePoint
   else
    l_Point := aPoint;
   if (l_Point <> nil) then
   begin
    if l_Temp.f_Obj.AsObject.IsSame(l_Point.Obj^.AsObject) or (aTop <> nil) {or CheckFake} then
    // ^ - http://mdp.garant.ru/pages/viewpage.action?pageId=86479273&focusedCommentId=90442637#comment-90442637
    begin
     l_Leaf := l_Point.AsLeaf;
     if (l_Leaf <> nil) then
      l_Leaf.InitPointByPt(aView, aPt, l_Temp);
     if aMode = nev_ppmNeedAnchor then
     begin
      l_Anchor := l_Top.MakeAnchor;
      if l_Leaf <> nil then
       l_Anchor.AssignPoint(aView, l_Point);
      if l_Found.IsRowShape then
       lp_AddInner(l_Parent, l_Anchor, l_PID, aTop <> nil)
      else
       l_Parent.Inner := l_Anchor;
      l_Point := l_Anchor;
     end
     else
      l_Parent.Inner := l_Point;
    end//l_Temp.f_Obj.IsSame(l_Point.Obj))
    else
     l_Parent.Inner := nil;
   end;//l_Point <> nil
  end;//SetTemp

var
 l_PrevFound  : TnevShape; // Указатель на предыдущий найденный Shape.
 l_PrevList   : InevObjectList;
 l_PrevParent : InevBaseLine4Anchor;
 l_StartIndex : Integer;
 l_PrevIndex  : Integer;
 l_PrevTop    : InevObject;
 l_PrevPID    : Integer;

  procedure SaveData(aInitIndex: Boolean);
  begin
   l_PrevFound := l_Found;
   l_PrevList  := l_List;
   l_PrevTop   := l_Top;
   l_PrevPID   := l_PID;
   if aInitIndex then
   begin
    l_PrevIndex := l_Index;
    l_StartIndex := 0;
   end
   else
    l_PrevIndex := 0;
   l_PrevParent := l_Parent;
  end;

var
 l_NeedBottom : Boolean;

  procedure RestoreData(aRestoreIndex: Boolean);
  begin
   if aRestoreIndex then
   begin
    if (l_Parent.Obj^.OverlapType = otUpper) and (l_Parent.Inner <> nil) then
     lp_AddInner(l_PrevParent, l_Parent, l_PrevIndex + l_PrevFound.f_PIDOfs, l_PrevParent.Obj^.PID <> l_Parent.Obj^.OwnerObj.PID);
    l_StartIndex := l_PrevIndex + 1;
    if l_PrevFound[l_PrevIndex].IsGreater and l_Parent.AtEnd(aView) then 
    begin
     l_NeedBottom := True;
     l_Parent := l_PrevParent;
     Exit;
    end; // if l_PrevFound[l_PrevIndex].IsGreater and l_Parent.AtEnd(aView) then
   end; // if aRestoreIndex then
   l_Found := l_PrevFound;
   l_List := l_PrevList;
   l_Top := l_PrevTop;
   l_Parent := l_PrevParent;
   l_PID := l_PrevPID;
  end;

  procedure ChangeTableInner(const anObject : InevObject;
                             const anItem   : TnevShape;
                             const aPoint   : InevBaseLine4Anchor);
  var
   l_SaveTemp : TnevShape;
  begin
   // Дальше инициализируем новый Inner для таблицы:
   l_Item := anItem;
   l_Parent := RestoreTablePoint(l_Item.f_Obj);
   l_SaveTemp := l_Temp;
   SetTemp(anObject, aPoint);
   l_Temp := l_SaveTemp;
  end;

var
 l_SaveFound  : TnevShape; // Указатель на предыдущий найденный Shape.
 l_SaveList   : InevObjectList;
 l_SaveParent : InevBaseLine4Anchor;
 l_SavePoint  : InevBaseLine4Anchor;
 l_SaveTop    : InevObject;
 l_SavePID    : Integer;

  procedure SavePrevData;
  begin
   l_SaveFound := l_Found;
   l_SaveList := l_List;
   l_SaveTop := l_Top;
   l_SaveParent := l_Parent;
   l_SavePoint := l_Point;
   l_SavePID   := l_PID;
  end;

  procedure RestroreSavedData;
  begin
   ChangeTableInner(l_SaveList, l_SaveFound, l_SaveParent);
   l_List := l_SaveList;
   l_Top := l_SaveTop;
   l_Point := l_SavePoint;
   l_SaveList := nil;
   l_PID := l_SavePID;
  end;

var
 l_RowShape : TnevShape;
 l_RealItem : TnevShape;
 l_RowObj   : InevObjectList;

 procedure lp_ChangeCursorItem;
 begin
  if (aMode <> nev_ppmNeedAnchor) and (l_RealItem <> nil) then
  begin
   SaveData(False);
   ChangeTableInner(l_RowObj, l_Found, nil);
   l_Parent := l_Point;
   l_List := l_RowObj;
   l_Found := l_RealItem.Parent;
   l_PID := l_RealItem.f_Obj.PID;
   l_Item := l_RealItem;
  end; // if not aNeedAnchor and (l_RealItem <> nil) then
 end;

 procedure lp_CheckNeedRestor4Cursor;
 begin
  l_RealItem := nil;
  if (aMode <> nev_ppmNeedAnchor) and (l_PrevList <> nil) then
  begin
   SavePrevData;
   ChangeTableInner(l_PrevFound.f_Obj, l_PrevFound, l_PrevParent);
   RestoreData(False);
   l_PrevList := nil;
  end; // if not aNeedAnchor and (l_PrevList <> nil) then
 end;

 procedure lp_Try2SaveData(const aRealItem: TnevShape);
 begin
  if (aMode = nev_ppmNeedAnchor) and l_Found.IsRowShape then
   SaveData(True);
  if aRealItem = nil then
   SetTemp
  else
   begin
    SetTemp(aRealItem.f_Obj); // Inner - для начала объединения, а Item - для первой видимой ячейки объединения.
    l_Temp := aRealItem;
   end;
 end;

 procedure lp_CheckPrevItem4Cursor;
 var
  l_IsNew : Boolean;
 begin
  if (aMode <> nev_ppmNeedAnchor) and (l_Item.OverlapType = otLower) then
  begin
   l_RealItem := l_Item.GetUpperShape;
   if l_RealItem = nil then
    l_Item.ChangeFakeItem(l_RealItem, l_RowObj, l_IsNew);
   if (aMode = nev_ppmSetCursor) and l_IsNew and (l_RealItem = nil) then Exit;
   l_RowObj := nil;
   if (l_RealItem <> nil) then
   begin
    l_RowObj := l_RealItem.Parent.f_Obj.ToList;
    if l_RowObj <> nil then
     l_Item := l_RealItem;
   end; // if l_Cell <> nil then
  end; // if l_Item.OverlapType = otLower then
 end;

 function lp_CheckBottom: Boolean;
 begin
  Result := l_Item.IsGreater;
  l_NeedBottom := Result;
  if not Result then
   lp_AddInner(l_Parent, nil, l_PID, False);
 end;

 function lp_CheckInHeadCell: Boolean;
 begin
  if aMode in [nev_ppmCheckHidden, nev_ppmSetCursor] then
   Result := (l_Found <> nil) and (l_Found.OverlapType = otUpper)
  else
   Result := False;
 end;

 function lp_CheckCellShape: Boolean;
 var
  l_Inner      : InevBasePoint;
  l_ResultPoint: InevBasePoint;
 begin
  Result := False;
  if (aMode <> nev_ppmNeedAnchor) and (l_RowObj <> nil) and (l_Item.OverlapType = otLower) and (l_Item.Bounds.Top = l_Item.Bounds.Bottom) then
  begin
   Result := (l_Item.Bounds.Left <= aPt.X) and (aPt.X < l_Item.Bounds.Right);
   if Result then
   begin
    l_ResultPoint := l_RowObj.MakePoint;
    l_Inner := l_Item.MakeUpperPoint;
    if l_Inner <> nil then
     l_Inner.SetAtEnd(InevView(f_View), True);
    l_ResultPoint.Inner := l_Inner;
    l_Parent.ParentPoint.Inner := l_ResultPoint;
   end; // if Result then
   l_RowObj := nil;
  end; // if l_RowObj <> nil then
 end;

var
 i            : Integer;
 l_Count      : Integer;
 l_Obj        : InevObject;
 l_P          : InevBaseLine4Anchor; //Фактически Result
 l_Bounds     : TnevRect;
 l_TableShape : TnevShape;
 l_IsNew      : Boolean;
begin
 if (aView = nil) OR (f_Shapes = nil) then
  Result := nil
 else
 begin
  l_Top := aView.Data;
  if (l_Top = nil) OR not l_Top.AsObject.IsValid then
   Result := nil
  else
  begin
   l_StartIndex := 0;
   l_PrevList := nil;
   l_RowAnchor := nil;
   if (aMode = nev_ppmNeedAnchor) then
    l_P := l_Top.MakeAnchor
   else
    l_P := l_Top.MakePoint;
   Result := l_P;
   l_Found := f_Shapes;
   //l_P.InitPointByPt(aView, aPt, l_Found);
   // - это не листьевой курсор, нечего и дёргаться
   if (l_Found <> nil) AND l_Top.IsList then
   begin
    l_Parent := l_P;
    l_List := l_Top.ToList;
    l_SaveList := nil;
    l_PrevList := nil;
    ClearList;
    l_Fisrt := True;
    l_NeedBottom := False;
    while not l_Found.Empty do
    begin
     Assert(l_Found.f_Obj.IsList);
     l_Temp := nil;
     for l_Index := l_StartIndex to Pred(l_Found.Count) do
     begin
      lp_CheckNeedRestor4Cursor;
      l_Item := l_Found[l_Index];
      l_PID := l_Index + l_Found.f_PIDOfs;
(*      if aNeedAnchor then
       if not l_Found.IsRowShape then
        l_Parent.Inner := l_Item.f_Obj.MakeAnchor;*)
      // - тут бы попробовать для not l_Item.Visible проинициализировать ВСЮ цепочку
      //   Inner у якоря, только непонятно как это эффективно сделать
      if (l_Item <> nil) AND (l_Item.Visible or lp_CheckInHeadCell) then
      begin
       lp_CheckPrevItem4Cursor;
       if lp_CheckCellShape then Exit;
       if not (aMode in [nev_ppmCheckHidden, nev_ppmSetCursor]) OR (l_Item.Bounds.Top < l_Item.Bounds.Bottom) then
       begin
        if Tl3Rect(l_Item.Bounds).ContainsPt(aPt) then
        begin
         lp_ChangeCursorItem;
         lp_Try2SaveData(nil);
         Break;
        end;//l_Item.Bounds.ContainsPt(aPt)
        if l_Found.IsVertical then
        begin
         if (l_Item.Bounds.Top > aPt.Y) then
         begin
          if (l_Temp = nil) then
          begin
           lp_ChangeCursorItem;
           SetTemp;
          end; // if (l_Temp = nil) then
          Break;
         end;//l_Item.Bounds.Top > aPt.Y
        end//l_Found.IsVertical
        else
        begin
         if (aMode = nev_ppmNeedAnchor) and l_Found.IsRowShape and (l_Found.Count > 1) then
         begin
          if (l_Item.Bounds.Top <= aPt.Y) and (l_Item.Bounds.Bottom >= aPt.Y) and (l_Item.OverlapType <> otLower) then
          begin
           lp_Try2SaveData(nil);
           Break;
          end
          else // нам такой Inner не нужен!
          begin
           if l_Item.OverlapType = otLower then
           begin
            if l_Item.ChangeFakeItem(l_RealItem, l_RowObj, l_IsNew) then
            begin
             if l_IsNew then
              l_Bounds := l_Item.GetBoundsWithFakeShapes(nil)
             else
              l_Bounds := l_Item.GetBoundsWithFakeShapes(l_RealItem);
             if (l_Bounds.Top <= aPt.Y) and (l_Bounds.Bottom >= aPt.Y) then
             begin
              lp_Try2SaveData(l_RealItem);
              Break;
             end // if (l_Bounds.Top <= aPt.Y) and (l_Bounds.Bottom >= aPt.Y) then
             else
              if lp_CheckBottom then
               Break;
            end // if l_Item.ChangeFakeItem(l_RealItem, l_RowObj, l_New) then
            else
             lp_AddInner(l_Parent, nil, l_PID, False);
           end // if l_Item.OverlapType = otLower then
           else
            if lp_CheckBottom then
             Break;
           Continue;
          end
         end // if aNeedAnchor and l_Found.IsRowShape then
         else
          if (l_Item.Bounds.Left > aPt.X) then
          begin
           if (l_Temp = nil) then
           begin
            l_SaveList := nil;
            lp_ChangeCursorItem;
            SetTemp;
           end // if (l_Temp = nil) then
           else
            if l_SaveList <> nil then
             RestroreSavedData;
           Break;
          end;//l_Item.Bounds.Left > aPt.X
        end;//l_Found.IsVertical
        l_SaveList := nil;
        lp_ChangeCursorItem;
        SetTemp;
       end;//if (not CheckHidden OR ...
      end;//if (l_Item <> nil)
     end;//for l_Index
     if (aMode <> nev_ppmNeedAnchor) then
     begin
      l_PrevList := nil;
      if (l_Temp <> nil) and
         (l_Temp.f_Parent <> nil) and
         l_Temp.f_Parent.IsRowShape and
         not l_Temp.f_Obj.AsObject.IsSame(l_Top.AsObject) then
       if l_SaveList <> nil then
        RestroreSavedData;
      l_SaveList := nil;
     end; // if not aNeedAnchor then
     if (l_Temp = nil) then
      Break
     else
      l_Found := l_Temp;
     if l_NeedBottom then
      Break
     else
      if l_Top.IsList then
       l_List := l_Top.ToList
      else
       if (aMode = nev_ppmNeedAnchor) and (l_PrevList <> nil) then
       begin
        RestoreData(True);
        if l_NeedBottom then
         Break
        else
         Continue;
       end // if aNeedAnchor and (l_PrevList <> nil) then
       else
        Break;
     if l_Parent.AsObject.IsKindOf(k2_typTable) then
      SaveTablePoint(l_Parent);
     l_Parent := l_Point;
    end;//while not l_Found.Empty
    if (aMode = nev_ppmNeedAnchor) then
    begin
     if l_NeedBottom then
      l_Parent.Bottom(aView)
     else
      if (l_RowAnchor <> nil) then
       l_RowAnchor.CompareWithOtherInner(aView);
    end;//if aNeedAnchor then    
   end;//l_Found <> nil..
  end;//l_Top = nil
 end;//l_View = nil
end;

function TnevShapesPainted.MapByPoint(const aPoint : InevBasePoint; aCheckTopVisible: Boolean): InevMap;
  {-}
var
 l_MI : InevBasePoint;
 l_BL : Boolean;
begin
 if (aPoint = nil) then
  Result := nil
 else
 if Assigned(f_Shapes) then
  // раз f_Shapes не присвоено, то и мапу мы уже не найдём.
  Result := ItemByPoint(aPoint.PointToParent(f_Shapes.TopObject), l_MI, l_BL, aCheckTopVisible, aPoint.Obj^)
 else
  Result := nil;
end;
                                                         
function TnevShapesPainted.Empty: Boolean;
  {-}
begin
 Result := (f_Shapes = nil) OR f_Shapes.Empty;
end;

function TnevShapesPainted.SubShapesCount: Integer;
  {-}
begin
 if (f_Shapes = nil) then
  Result := 0
 else
  Result := f_Shapes.AbsIndexDelta;
end;

procedure TnevShapesPainted.Clear;
 {* - Очищает список. }
begin
 {$IfDef nsTest}
 try
  if (f_Shapes <> nil) then
  begin
   if (f_View <> nil) then
   begin
    if TnevShapesPaintedSpy.Exists then
     if TnevShapesPaintedSpy.Instance.LogScreen(InevView(f_View)) then
      TnevShapesPaintedSpy.Instance.LogShapes(InevView(f_View), f_Shapes);
   end;//f_View <> nil
  end;//f_Shapes <> nil
 finally
 {$EndIf nsTest}
  l3Free(f_Current);
  l3Free(f_Shapes);
  inherited;
 {$IfDef nsTest}
 end;//try..finally
 {$EndIf nsTest}
end;

procedure TnevShapesPainted.ClearEx;
 {* - Очищает список. }
begin
 f_MaxWidth := 0;
 Clear;
end;

function TnevShapesPainted.CheckRoot(const aShape   : InevObject;
                                     const aTopLeft : TnevPoint): TnevShape;
  {-}
begin
 if (f_Shapes = nil) then
  if aShape.IsVertical then
   f_Shapes := TnevTopShape.Create(Self, aShape.ToList, aTopLeft)
  else
   f_Shapes := TnevHorzTopShape.Create(Self, aShape.ToList, aTopLeft);
 Result := f_Shapes;
end;

procedure TnevShapesPainted.BeginDraw(const aShape   : InevObject;
                                      const anAnchor : InevBasePoint;
                                      const aTopLeft : TnevPoint;
                                      var theMap     : InevMap;
                                      aFake          : Boolean;
                                      const aHacker  : InevK235870994Hacker);
  {-}
var
 l_Shape     : TnevShape;
 l_RealShape : TnevShape;
 l_Decor     : Boolean;
begin
 l_Decor := aShape.IsDecorationElement;
 if l_Decor then
  l3Set(f_Current, f_DecorationsHolder);
 Assert(aShape.AsObject.IsValid);
 if (f_Current = nil)
    //OR f_Current.f_Obj.Box.IsSame(aShape.Box)
    // - временно залечиваем K290271457.script
    // http://mdp.garant.ru/pages/viewpage.action?pageId=531318437&focusedCommentId=531960334#comment-531960334
    then
  l_Shape := CheckRoot(aShape, aTopLeft)  
 else
 begin
  Assert(not f_Current.f_Obj.AsObject.Box.IsSame(aShape.AsObject.Box));
  // - временно залечиваем K290271457.script
  // http://mdp.garant.ru/pages/viewpage.action?pageId=531318437&focusedCommentId=531960334#comment-531960334
  if aFake then
  begin
   f_Current.FoundFakeOwnerItem(l_RealShape);
   Assert(l_RealShape.f_Obj.AsObject.IsSame(aShape.AsObject.Owner));                  
   l_Shape := l_RealShape.AddShape(aShape, aTopLeft, True, aHacker);
   l_RealShape.RealVisible := f_Current;
  end//aFake
  else
  begin
   // http://mdp.garant.ru/pages/viewpage.action?pageId=210438932&focusedCommentId=212435042#comment-212435042
   // М.б. ТУТ надо будет учесть aFake и вставлять не в f_Current, а в правильного родителя
   Assert(l_Decor OR
          f_Current.f_Obj.AsObject.IsSame(aShape.AsObject.Owner) OR
          (aShape.AsObject.Owner.IsKindOf(k2_typObjectSegment){ AND
           f_Current.f_Obj.IsSame(aShape.Owner.Owner)}));
   l_Shape := f_Current.AddShape(aShape, aTopLeft, True, aHacker);
   f_Current.RealVisible := nil;
  end;//aFake
 end;//f_Current = nil
 Assert(l_Shape.f_Obj.AsObject.IsSame(aShape.AsObject));
 theMap := l_Shape;
 l3Set(f_Current, l_Shape);
 if not l_Decor then
  f_Current.RestoreFromLineList;
 Inc(f_ZOrder);
end;

procedure TnevShapesPainted.EndDraw;
  {-}
var
 l_Decor : Boolean;
begin
 l_Decor := f_Current.f_Obj.IsDecorationElement;
 if l_Decor then
 begin
  l3Set(f_DecorationsHolder, f_Current.Parent);
  // - вот и стек
  l3Set(f_Current, f_Current.Parent.Parent);
 end//l_Decor
 else
 begin
  f_Current.SaveLinesList;
  // Вернемся на уровень вверх
(*  if f_Current.f_Obj.IsKindOf(k2_typTextPara) then
   // - заточка конечно же*)
   if f_Current.f_Obj.DecorObj(nev_dtHeader).IsValid OR
      f_Current.f_Obj.DecorObj(nev_dtFooter).IsValid then
    // - вообще-то надо тут подумать о стеке f_DecorationsHolder
    //   хотя, см. выше  
    l3Set(f_DecorationsHolder, f_Current);
  l3Set(f_Current, f_Current.EndDraw);
 end;//l_Decor
 Dec(f_ZOrder);
end;

function TnevShapesPainted.VertScroll(const aView : InevView;
                                      const aFrom : InevBasePoint;
                                      const aTo   : InevBasePoint;
                                      const anEx  : TnevPoint): Integer;
  {* - изменяется координаты элементы коллекции на расстояние от aFrom до
       aTo и возвращает расстояние между верхними границами параграфов. }
       
 procedure ProcessDelta(const aPara  : InevBasePoint;
                        const anItem : TnevShape;
                        aInc         : Boolean;
                        aOfs         : Integer;
                        aFromBaseLine: Boolean);
 var
  l_Para : InevObject;
  l_Item : TnevShape;
  l_PBnd : TnevRect;
 begin//ProcessDelta
  if (aOfs = 0) then
  begin
   l_Para := aPara.Obj^;
   l_Item := anItem;
   while l_Para.AsObject.IsValid AND (aFromBaseLine or (l_Para.PID <= 0)) do
   begin
    if (l_Item.Parent = nil) then
    begin
     if (l_Para.PID < 0) then
     // - специальным образом учитываем верхний отступ документа
     // http://mdp.garant.ru/pages/viewpage.action?pageId=108233847
     begin
      if aInc then
       Inc(Result, l_Item.Bounds.Top - 0)
      else
       Dec(Result, l_Item.Bounds.Top - 0);
     end;//l_Para.PID < 0
     break;
    end;//l_Item.Parent = nil
    l_PBnd := l_Item.Parent.Bounds;
    if not l_Para.OwnerObj.AsObject.BoolA[k2_tiCollapsed] then
     if aInc then
      Inc(Result, l_Item.Bounds.Top - l_PBnd.Top)
     else
      Dec(Result, l_Item.Bounds.Top - l_PBnd.Top);
    l_Item := l_Item.Parent;
    l_Para := l_Para.OwnerObj;
   end;//l_Para.IsValid
  end;//aOfs = 0
 end;//ProcessDelta

var
 l_DYFrom : Integer;
 l_DYTo   : Integer;
 l_FromA  : InevBasePoint;
 l_ToA    : InevBasePoint;
 l_FromBL : Boolean;
 l_ToBL   : Boolean;

 procedure CorrectByTop(aFrom, aTo : TnevShape);
 begin//CorrectByTop
  if Assigned(aFrom) and Assigned(aTo) AND
     ({aTo.Visible OR }(aTo.Bounds.Top < aTo.Bounds.Bottom)) then
  begin
   if (aTo.Parent <> nil) and
      (aTo.Parent.Bounds.Top > aTo.Bounds.Top) and
      (aTo.f_Obj.PID = 0) then
    Exit;
   Result := l_DYFrom + aFrom.Bounds.Top - aTo.Bounds.Top - l_DYTo;
   if (Result < 0) then
   begin
    ProcessDelta(l_FromA, aFrom, false, l_DYFrom, l_FromBL);
    ProcessDelta(l_ToA, aTo, true, l_DYTo, l_ToBL);
   end//Result < 0
   else
   if (Result > 0) then
   begin
    ProcessDelta(l_ToA, aTo, true, l_DYTo, l_ToBL);
    ProcessDelta(l_FromA, aFrom, false, l_DYFrom, l_FromBL);
   end;//Result > 0
  end;//Assigned(aFrom)..
 end;//CorrectByTop

var
 l_From : TnevShape;
 l_To   : TnevShape;
 l_FL   : InevLeafPoint;
 l_TL   : InevLeafPoint;
begin
 Result := 0;
 if (f_Shapes <> nil) AND Assigned(aFrom) and Assigned(aTo) then
 begin
  l_From := ItemByPoint(aFrom, l_FromA, l_FromBL);
  l_To := ItemByPoint(aTo, l_ToA, l_ToBL);
  l_FL := l_FromA.AsLeaf;
  if (l_FL = nil) then
   l_DYFrom := 0
  else
  if (l_From = nil) then
  // ^- http://mdp.garant.ru/pages/viewpage.action?pageId=86479273&focusedCommentId=90442368#comment-90442368
   l_DYFrom := l_FL.PaintOffsetY(aView, aView.FormatInfoByPara(l_FromA.Obj)) // !!! наверное Container.FormatInfoByPoint(l_FromA.Obj.Point)
  else
   l_DYFrom := l_FL.PaintOffsetY(aView, l_From.f_FI);
  l_TL := l_ToA.AsLeaf;
  if (l_TL = nil) then
   l_DYTo := 0
  else                                                                                                  
  if (l_To = nil) then
   l_DYTo := l_TL.PaintOffsetY(aView, aView.FormatInfoByPara(l_ToA.Obj)) // !!! наверное Container.FormatInfoByPoint(l_ToA.Obj.Point)
  else
   l_DYTo := l_TL.PaintOffsetY(aView, l_To.f_FI);
  if l_FromA.Obj.AsObject.IsSame(l_ToA.Obj^.AsObject) then
  begin
   Result := l_DYFrom - l_DYTo;
   if (Result < 0) then
    ProcessDelta(l_FromA, l_From, false, l_DYFrom, l_FromBL)
   else
   if (Result > 0) then
    ProcessDelta(l_ToA, l_To, true, l_DYTo, l_ToBL);
  end//l_FromA.Obj.IsSame(l_ToA.Obj)
  else
   CorrectByTop(l_From, l_To);
  if Abs(Result) >= evEpsilon then
   OffsetShapes(l3Point(0, Result), anEx);
 end;//if Assigned(aFrom) and Assigned(aTo) then
end;

function TnevShapesPainted.HorzScroll(aFrom : Integer;
                                      aTo   : Integer;
                                      const anEx  : TnevPoint): Integer;
  {* - изменяется координаты элементы коллекции на расстояние от aFrom до
       aTo и возвращает расстояние между верхними границами параграфов. }
begin
 Result := aFrom - aTo;
 OffsetShapes(l3Point(Result, 0), anEx);
end;
       
function TnevShapesPainted.MaxWidth: Integer;
  {-}
begin
 Result := f_MaxWidth;
end;

// start class TnevShape

constructor TnevShape.Create(anAllShapes    : TnevShapesPainted;
                             const aShape   : InevObject;
                             const aParent  : TnevShape;
                             const aTopLeft : TnevPoint);
  //reintroduce;
  //virtual;
  {-}
begin
 f_Obj := aShape;
 f_OnScreen := false;
 f_AllShapes := anAllShapes;

 f_Bounds.TopLeft := Tl3Point(aTopLeft);
 f_Bounds.BottomRight := Tl3Point(aTopLeft);
 
 f_AppliesToMaxWidth := aShape.AppliesToMaxWidth;
 inherited Create;
 Assert(aParent <> Self);
 Assert((aParent = nil) OR (aParent.Parent <> Self));
 Assert((aParent = nil) OR
        f_Obj.AsObject.Owner.IsSame(aParent.f_Obj.AsObject) OR
        f_Obj.IsDecorationElement OR
        (f_Obj.AsObject.Owner.IsKindOf(k2_typObjectSegment){ AND
         f_Obj.Owner.Owner.IsSame(aParent.f_Obj)})
        );
 f_Parent := aParent;
end;

procedure TnevShape.Cleanup;
  //override;
  {-}
begin
 f_Obj := nil;
 FreeAndNil(f_FI);
 DoClearBounds;
 l3FillChar(f_Bounds, SizeOf(f_Bounds));
 CleanupRefs;
 inherited;
end;

function TnevShape.GetMaxTop: Integer;
begin
 Result := Bounds.Top;
end;

function TnevShape.NeedIncHeight: Boolean;
begin
 Result := True; // Нужно проверять только для ячеек
end;

function TnevShape.GetRealVisible: TnevShape;
begin
 Result := Self;
end;

procedure TnevShape.SetRealVisible(const Value: TnevShape);
begin
 Assert((Value = nil) OR (Value = Self), 'Обычным параграфам невозможно менять RealVisible');
end;

function TnevShape.GetUpperShape: TnevShape;
begin
 Result := nil;
end;

function TnevShape.CreateShape(const aShape   : InevObject;
                               const aTopLeft : TnevPoint): TnevShape;
  {-}
begin
 if aShape.IsList then
 begin
  if aShape.IsVertical then
  begin
   if aShape.AsObject.IsKindOf(k2_typTable) then
    Result := TnevTableShape.Create(f_AllShapes,
                                              aShape.ToList,
                                              Self,
                                              aTopLeft)
   else
   if aShape.AsObject.IsKindOf(k2_typTableCell) then
    Result := TnevCellShape.Create(f_AllShapes,
                                   aShape.ToList,
                                   Self,
                                   aTopLeft)
   else
   begin
    if aShape.AsObject.IsKindOf(k2_typDocument) then
     Result := TnevDocumentShape.Create(f_AllShapes,
                                    aShape.ToList,
                                    Self,
                                    aTopLeft)
    else
     Result := TnevListShape.Create(f_AllShapes,
                                    aShape.ToList,
                                    Self,
                                    aTopLeft);
   end;//aShape.IsKindOf(k2_typTableCell)
  end//aShape.IsVertical
  else
   if aShape.AsObject.IsKindOf(k2_typTableRow) then
    Result := TnevRowShape.Create(f_AllShapes,
                                  aShape.ToList,
                                  Self,
                                  aTopLeft)   

   else
   Result := TnevHorzListShape.Create(f_AllShapes,
                                      aShape.ToList,
                                      Self,
                                      aTopLeft);
 end//aShape.IsList
 else
 if aShape.AsObject.IsKindOf(k2_typTextPara) then
  if EvHeaderTextPara(aShape) then
   Result := TnevHeaderTextParaShape.Create(f_AllShapes,
                                      aShape,
                                      Self,
                                      aTopLeft)

  else
   Result := TnevTextParaShape.Create(f_AllShapes,
                                      aShape,
                                      Self,
                                      aTopLeft)
 else
  Result := TnevLeafShape.Create(f_AllShapes,
                                 aShape,
                                 Self,
                                 aTopLeft);
end;

procedure TnevShape.MoveBy(const aDelta: TnevPoint);
  {-}
var
 l_Index : Integer;
 l_Item  : TnevShape;
begin
 Tl3Rect(Bounds).Offset(aDelta.X, aDelta.Y);
 for l_Index := Pred(Count) downto 0 do
 begin
  l_Item := Items[l_Index];
  if (l_Item <> nil) then
   l_Item.MoveBy(aDelta);
 end;//for l_Index
 with Bounds do
  Visible := (Bottom >= 0) AND (Top < f_AllShapes.ViewExtent.Y);
 CheckStoredLines(aDelta); 
end;

procedure TnevShape.pm_SetVisible(aValue: Boolean);
  {-}
begin
 if (f_OnScreen <> aValue) then
 begin
  f_OnScreen := aValue;
  if (Parent <> nil) then
  begin
   if aValue then
    Parent.UpdateSubShapes(AbsIndexDelta)
   else
    Parent.UpdateSubShapes(-AbsIndexDelta);
  end;//Parent <> nil
  if aValue then
  begin
   if (Parent <> nil) then
    Parent.UpdateBounds(Self);
  end;//aValue
 end;//f_OnScreen <> aValue
end;

function TnevShape.EndDraw: TnevShape;
  {-}
var
 l_R : Tl3Rect;
 l_FirstChild : TnevShape;
 l_Top        : Integer;
begin
 Assert(not f_Obj.IsDecorationElement);
 if f_Obj.IsList then
 begin
  // Установим размеры параграфа
  if (Count > 0) and Visible then
  begin
   l_R := Bounds;
   l_FirstChild := Items[0];
   Assert(not l_FirstChild.f_Obj.IsDecorationElement);
   if l_FirstChild.Visible then
   begin
    l_Top := l_FirstChild.Bounds.Top - Self.Get_FI.Spacing.Top;
    if (l_R.Top > l_Top) then
    begin
     l_R.Top := l_Top;
     Bounds := l_R;
    end;//l_R.Top > l_Top
   end;//l_FirstChild.Visible
  end;//(Count > 0) and Visible
 end;//f_Obj.IsList
 Result := Parent;
 if (f_AllShapes.f_ZOrder > 1) AND f_AppliesToMaxWidth then
  if (f_FI <> nil) then
   f_AllShapes.f_MaxWidth := {Max(}
                              Max(f_AllShapes.f_MaxWidth,
                                  Bounds.Left + f_FI.Width + 6 * evEpsilon){,
                                  Bounds.Right + 6 * evEpsilon)}
  else
   f_AllShapes.f_MaxWidth := Max(f_AllShapes.f_MaxWidth,
                                 Bounds.Right{-Min(Bounds.Left, 0)});
                                          // ^ - закомментировано, т.к при
 // скроллировании по горизонтали неправильно вычислялась максимальная ширина.
 Visible := true;
 if (Result <> nil) then
 begin
  Result.UpdateBounds(Self);
  Result := Result.RealVisible;
 end;//Result <> nil
end;

procedure TnevShape.SetDrawnBottom(const aBottom: TnevPoint);
  //virtual;
  {-}
begin
end;

function TnevShape.IsGreater: Boolean;
begin
 Result := False;                                      
end;

function TnevShape.Get_FI: TInevFormatInfoRet;
  {-}
begin
 Result := CheckFormatInfo(f_Obj);
 // http://mdp.garant.ru/pages/viewpage.action?pageId=86479273&focusedCommentId=90442520#comment-90442520
 //Result := f_FI;
end;

function TnevShape.rVisible: Boolean;
  {-}
begin
 Result := Visible;
end;

procedure TnevShape.ValidateFormatInfo;
 //override;
  {-}
begin
 if (f_FI <> nil) then
 begin
  if (f_FI.ParentInfo = nil) then
  begin
   if not f_Obj.IsDecorationElement then
    InevView(f_AllShapes.f_View).FormatInfoByPoint(f_Obj.MakePoint).SetRefTo(f_FI)
   else
    Assert(false); 
  end;//f_FI.ParentInfo = nil
 end;//f_FI <> nil
 Assert(Parent <> nil);
 Parent.ValidateFormatInfo;
end;
  
function TnevShape.CheckFormatInfo(const anObject: InevObject): TInevFormatInfoRet;
  {-}
var
 l_ParentFI : TInevFormatInfoRet;
begin
 if (Parent = nil) then
 begin
  Assert(false);
  FreeAndNil(f_FI);
 end//Parent = nil
 else
 begin
  //Assert(not f_Obj.IsDecorationElement);
  Assert(f_Obj.AsObject.IsSame(anObject.AsObject));
  ValidateFormatInfo;
  // http://mdp.garant.ru/pages/viewpage.action?pageId=260447845
  if (Parent.f_FI = nil) then
   l_ParentFI := Parent.CheckFormatInfo(Parent.f_Obj)
  else
   l_ParentFI := Parent.f_FI;
  // begin "стреляем" ещё раз 
  ValidateFormatInfo;
  // http://mdp.garant.ru/pages/viewpage.action?pageId=260447845
  if (Parent.f_FI = nil) then
   l_ParentFI := Parent.CheckFormatInfo(Parent.f_Obj)
  else
   l_ParentFI := Parent.f_FI;
  // end "стреляем" ещё раз 
  Assert(l_ParentFI <> nil);
  Assert((Parent.Parent = nil) OR
         (l_ParentFI.ParentInfo <> nil));
  // http://mdp.garant.ru/pages/viewpage.action?pageId=283148869
  l_ParentFI.InfoForChild(anObject).SetRefTo(f_FI);
 end;//Parent = nil
 Result := f_FI;
end;

function TnevShape.pm_GetBounds: TafwRect;
  {-}
begin
 CheckBounds;
 Result := f_Bounds;
end;

function TnevShape.pm_GetOuter: IafwShape;
  {-}
begin
 Result := InevMap(Parent);
end;

function TnevShape.ReserveMap(const aShape : InevObject): InevMap;
  {-}
begin
 Result := AddShape(aShape, nevPt0, false, nil);
end;

function TnevShape.IsLinked: Boolean;
  {-}
begin
 Result := (f_AllShapes <> nil);
end;

procedure TnevShape.AdjustTopByAnchor(const aView: InevView;const anAnchor: InevBasePoint);
var
 l_Y  : Integer;
 l_LP : InevLeafPoint;
begin
 l_LP := anAnchor.AsLeaf;
 if (l_LP <> nil) then
 begin
  l_Y := l_LP.PaintOffsetY(aView, f_FI);
  if (l_Y <> 0) then
   f_Bounds.R.Top := Bounds.R.Top - l_Y;
 end;//Top >= 0
end;

function TnevShape.AbsIndexDelta: Integer;
  //virtual;
  {-}
begin
 Result := 0;
end;

function TnevShape.IsVertical: Boolean;
  //virtual;
  {-}
begin
 Result := True;
end;

procedure TnevShape.CleanupRefs;
  { Очищает ссылки на сторонние объекты. }
begin
 f_Parent := nil;
 f_AllShapes := nil;
end;

procedure TnevShape.Clear;
  {-}
begin
 f_Obj := nil;
 f_PIDOfs := 0;
 inherited;
end;

function TnevShape.pm_GetItem(aIndex : Integer) : TnevShape;
begin
 Result := TnevShape(inherited Items[aIndex]);
end;

procedure TnevShape.pm_SetItem(aIndex      : Integer;
                               const Value : TnevShape);
begin
 inherited Items[aIndex] := Value;
end;

procedure TnevShape.CheckStoredLines(const aDelta: TnevPoint);
begin

end;

function TnevShape.IsRowShape: Boolean;
begin
 Result := False;
end;

procedure TnevShape.DoClearBounds;
begin
{ //http://mdp.garant.ru/pages/viewpage.action?pageId=159367236&focusedCommentId=159368511#comment-159368511
 with Bounds do
 begin
  Left := evShapeNil;
  Top := 0;
  Right := evShapeNil;
  Bottom := 0;
 end;}
 Bounds := l3Rect(evShapeNil, cnShepeYNil, evShapeNil, cnShepeYNil);
end;

procedure TnevShape.RestoreFromLineList;
begin

end;

procedure TnevShape.SaveLinesList;
begin

end;

function TnevShape.OverlapType: TOverlapType;
begin
 Result := f_Obj.OverlapType;
end;

procedure TnevShape.ClearBounds;
  {-}
begin
 Assert(not f_Obj.IsDecorationElement);
 DoClearBounds;
 if (Parent <> nil) then
  Parent.ClearBounds;
  // - это чтобы пересчитать прямоугольник родителя
end;

function TnevShape.GetBoundsWithFakeShapes(const aTopShape: TnevShape): TnevRect;
begin
 Result := Bounds;
end;

function TnevShape.ChangeFakeItem(out aNewItem   : TnevShape;
                                  out aParentObj : InevObjectList;
                                  out aNew       : Boolean): Boolean;
begin
 Result := True;
 aNewItem := Self;
 aParentObj := Parent.f_Obj.ToList;
 aNew := False;
end;

procedure TnevShape.FoundFakeOwnerItem(out aNewItem: TnevShape);
begin
 aNewItem := Self;
end;

// start class TnevLeafShape

function TnevLeafShape.AbsIndexDelta: Integer;
  //override;
  {-}
begin
 Result := 1;
end;

procedure TnevLeafShape.SetDrawnBottom(const aBottom: TnevPoint);
  //override;
  {-}
begin
  Bounds := l3Rect(Bounds.R.TopLeft,
                   l3Point(Max(aBottom.X, Bounds.Left + f_FI.rLimitWidth),
                               aBottom.Y));
end;

function TnevLeafShape.AddShape(const aShape   : InevObject;
                                const aTopLeft : TnevPoint;
                                MakeVisible    : Boolean;
                                const aHacker  : InevK235870994Hacker): TnevShape;
  //override;
  {-}
begin
 Result := nil;
 Assert(false);
end;

// start class TnevListShape

constructor TnevListShape.Create(anAllShapes    : TnevShapesPainted;
                                 const aShape   : InevObjectList;
                                 const aParent  : TnevShape;
                                 const aTopLeft : TnevPoint);
  //override;
  {-}
begin
 inherited Create(anAllShapes, aShape, aParent, aTopLeft);
 f_BottomShape := nil;
end;

procedure TnevListShape.Cleanup;
  //override;
  {-}
begin
 f_BottomShape := nil;
 f_SubShapesCount := 0;
 inherited;
end;

procedure TnevListShape.SetDrawnBottom(const aBottom: TnevPoint);
  //override;
  {-}
begin
 Bounds := l3Rect(Bounds.R.TopLeft,
                   l3Point(Max(Max(Bounds.Right, aBottom.X), Bounds.Left + f_FI.rLimitWidth),
                           Max(Bounds.Bottom, aBottom.Y)));
end;

function TnevListShape.AddShape(const aShape   : InevObject;
                                const aTopLeft : TnevPoint;
                                MakeVisible    : Boolean;
                                const aHacker  : InevK235870994Hacker): TnevShape;
  {-}
var
 i      : Integer;
 l_PID  : Integer;
 l_Item : TnevShape;
begin
 // Assert(not aShape.IsDecorationElement);
 l_PID := Max(0, aShape.PID);
 if (l_PID < f_PIDOfs) then
  Result := nil
 else
  Result := Items[l_PID - f_PIDOfs];
 if (Result <> nil) and not Result.f_Obj.AsObject.IsSame(aShape.AsObject) then
  Result := nil;
 if (Result = nil) then
 begin
  l_Item := CreateShape(aShape, aTopLeft); 
  try
   if Empty then 
    f_PIDOfs := l_PID
   else
    if (f_PIDOfs > l_PID) then
    begin
     for i := f_PIDOfs - 1 downto l_PID do
      if i = l_PID then
       Insert(0, l_Item)
      else
       Insert(0, nil);
     f_PIDOfs := l_PID;
     Result := l_Item;
     Exit;
    end; // if (f_PIDOfs > l_PID) then
   Items[l_PID - f_PIDOfs] := l_Item;
   Result := l_Item;
   if IsVertical then
    if (f_BottomShape = nil) or (f_BottomShape.f_Obj.PID <= l_PID) then
     f_BottomShape := l_Item;
  finally
   l3Free(l_Item);
  end;//try..finally
 end//Result = nil
 else
 begin
  if MakeVisible then
  begin
   if (aHacker <> nil) then
    if aHacker.HackK235870994(Result) then
     Exit;
   if not Tl3Rect(Result.Bounds).TopLeft.EQ(aTopLeft) then
   begin
    {$IfDef XE4}
    Result.f_Bounds.TopLeft := aTopLeft;
    Result.f_Bounds.BottomRight := aTopLeft;
    {$Else  XE4}
    Result.f_Bounds.TopLeft := aTopLeft;
    Result.f_Bounds.BottomRight := aTopLeft;
    {$EndIf XE4}
   end;//not Result.Bounds.TopLeft
  end;//MakeVisible
 end;//Result = nil
end;

procedure TnevListShape.UpdateBounds(aChild : TnevShape);
  {-}
var
 l_Rect   : Tl3Rect;
 l_Bottom : Integer;
begin
 l_Rect := Bounds;
 l_Rect.Top := Min(l_Rect.Top, aChild.Bounds.Top - Self.Get_FI.Spacing.Top);
 l_Bottom := Max(l_Rect.Bottom, aChild.Bounds.Bottom + Self.Get_FI.Spacing.Bottom);
 if aChild.NeedIncHeight then
  l_Rect.Bottom := l_Bottom;
 Bounds := l_Rect;
 if IsVertical then
  if (f_BottomShape = nil) or not f_BottomShape.Visible or ((f_BottomShape.f_Obj.PID <= aChild.f_Obj.PID) and IsBottomShape(l_Rect.Bottom, f_BottomShape)) then
   f_BottomShape := aChild;
end;

procedure TnevListShape.UpdateSubShapes(aDelta : Integer);
  //virtual;
  {-}
begin
 if (aDelta <> 0) then
 begin
  Inc(f_SubShapesCount, aDelta);
  if Visible AND (Parent <> nil) then
   Parent.UpdateSubShapes(aDelta);
 end;//aDelta <> 0
end;

function TnevListShape.AbsIndexDelta: Integer;
  //override;
  {-}
begin
 Result := f_SubShapesCount;
end;

// start class TnevHorzListShape

procedure TnevHorzListShape.UpdateSubShapes(aDelta : Integer);
  //override;
  {-}
var
 l_Index : Integer;
 l_Old   : Integer;
 l_Item  : TnevShape;
begin
 if (aDelta <> 0) then
 begin
  l_Old := f_SubShapesCount;
  f_SubShapesCount := 0;
  for l_Index := 0 to Pred(Count) do
  begin
   l_Item := Items[l_Index];
   if (l_Item <> nil) then
    f_SubShapesCount := Max(f_SubShapesCount, l_Item.AbsIndexDelta);
  end;//for l_Index
  if (l_Old <> f_SubShapesCount) AND Visible AND (Parent <> nil) then
   Parent.UpdateSubShapes(f_SubShapesCount - l_Old);
 end;//aDelta <> 0
end;

function TnevHorzListShape.IsVertical: Boolean;
  //override;
  {-}
begin
 Result := false;
end;

// start class TnevTopShape

procedure TnevTopShape.ValidateFormatInfo;
 //override;
  {-}
begin
end;

function TnevTopShape.CheckFormatInfo(
  const anObject: InevObject): TInevFormatInfoRet;
begin
 Assert(TopObject.AsObject.IsSame(anObject.AsObject));
 InevView(f_AllShapes.f_View).RootFormatInfo.SetRefTo(f_FI);
 Result := f_FI;
end;

constructor TnevTopShape.Create(anAllShapes    : TnevShapesPainted;
                                const aShape   : InevObjectList;
                                const aTopLeft : TnevPoint);
  //reintroduce;
  //virtual;
  {-}
begin
 inherited Create(anAllShapes, aShape, nil, aTopLeft);
end;

{ TnevHorzTopShape }

function TnevHorzTopShape.IsVertical: Boolean;
begin
 Result := False;
end;

procedure TnevHorzTopShape.UpdateSubShapes(aDelta: Integer);
var
 l_Index : Integer;
 l_Old   : Integer;
 l_Item  : TnevShape;
begin
 if (aDelta <> 0) then
 begin
  l_Old := f_SubShapesCount;
  f_SubShapesCount := 0;
  for l_Index := 0 to Pred(Count) do
  begin
   l_Item := Items[l_Index];
   if (l_Item <> nil) then
    f_SubShapesCount := Max(f_SubShapesCount, l_Item.AbsIndexDelta);
  end;//for l_Index
  if (l_Old <> f_SubShapesCount) AND Visible AND (Parent <> nil) then
   Parent.UpdateSubShapes(f_SubShapesCount - l_Old);
 end;//aDelta <> 0
end;

// start class TnevTextParaShape

procedure TnevTextParaShape.UpdateSubShapes(aDelta : Integer);
  //override;
  {-}
begin
 // - ничего не делаем
end;

procedure TnevTextParaShape.UpdateBounds(aChild : TnevShape);
  //override;
  {-}
begin
 // - ничего не делаем
end;

function TnevTextParaShape.AddShape(const aShape   : InevObject;
                                    const aTopLeft : TnevPoint;
                                    MakeVisible    : Boolean;
                                    const aHacker  : InevK235870994Hacker): TnevShape;
  //override;
  {-}
var
 l_Index : Integer;
 l_Item  : TnevShape;
begin
 for l_Index := 0 to Pred(Count) do
 begin
  l_Item := Items[l_Index];
  if l_Item.f_Obj.AsObject.IsSame(aShape.AsObject) then
  begin
   Result := l_Item;
   Exit;
  end;//l_Item.f_Obj.IsSame(aShape)
 end;//for l_Index
 l_Item := CreateShape(aShape, aTopLeft);
 try
  Add(l_Item);
  Result := l_Item;
 finally
  FreeAndNil(l_Item);
 end;//try..finally
end;

{ TnevTableShape }

procedure TnevTableShape.CheckStoredLines(
  const aDelta: TnevPoint);
begin
 if aDelta.Y <> 0 then
  f_WasScrolled := True;
end;

procedure TnevTableShape.Cleanup;
begin
 f_LinesArray := nil;
 inherited;
end;

function TnevTableShape.IsTable: Boolean;
begin
 Result := True;
end;

procedure TnevTableShape.RestoreFromLineList;
begin
 if f_WasScrolled and (f_LinesArray <> nil) and (f_LinesArray.Count > 0) then
  with InevView(f_AllShapes.f_View).Metrics.InfoCanvas do
   if not Printing and (FrameLines <> nil) then
    FrameLines.WriteAlignData(Integer(f_Obj.AsObject.Box), f_LinesArray);
end;

procedure TnevTableShape.SaveLinesList;
begin
 with InevView(f_AllShapes.f_View).Metrics.InfoCanvas do
  if not Printing and (FrameLines <> nil) then
  begin
   f_LinesArray := FrameLines.ReadAlignData(Integer(f_Obj.AsObject.Box));
   {$IFDEF nsTest}
   FrameLines.ClearFrameObject(Integer(f_Obj.AsObject.Box));
   {$ENDIF nsTest}
  end; // if not InevView(f_AllShapes.f_View).Metrics.InfoCanvas.Printing then
 f_WasScrolled := False;
end;

{ TnevRowShape }

function TnevRowShape.GetMaxTop: Integer;
var
 i : Integer;
begin
 Result := 0;
 for i := 0 to Count - 1 do
  Result := Max(Result, Items[i].Bounds.Top);
end;

function TnevRowShape.IsRowShape: Boolean;
begin
 Result := True;
end;

procedure TnevRowShape.SetDrawnTop(aTop: Integer);
begin
 Bounds := l3Rect(l3Point(Bounds.Left, Min(aTop, Bounds.Top)),
                  Bounds.R.BottomRight);
end;

procedure TnevRowShape.UpdateBounds(aChild: TnevShape);
  {-}
var
 l_Rect   : Tl3Rect;
 l_Height : Integer;
 l_Bottom : Integer;
begin
 l_Rect := Bounds;
 l_Rect.Top := Min(l_Rect.Top, aChild.Bounds.Top - Self.Get_FI.Spacing.Top);
 l_Bottom := Max(l_Rect.Bottom, aChild.Bounds.Bottom + Self.Get_FI.Spacing.Bottom);
 if aChild.NeedIncHeight then
 begin
  l_Rect.Bottom := l_Bottom;
  if not InevView(f_AllShapes.f_View).Metrics.InfoCanvas.Printing then
  begin
   if (f_BottomShape = nil) or (aChild.Bounds.Bottom > f_BottomShape.Bounds.Bottom) then
    f_BottomShape := aChild;
   // V - http://mdp.garant.ru/pages/viewpage.action?pageId=620261162
   if f_BottomShape <> nil then
   begin
    l_Height := f_BottomShape.f_FI.Height + f_BottomShape.f_FI.Spacing.Bottom  + f_BottomShape.f_FI.Spacing.Top;
    if (l_Rect.Bottom - l_Rect.Top) > l_Height then
    begin
     l_Rect.Top := f_BottomShape.Bounds.Top - Self.Get_FI.Spacing.Top;
     l_Rect.Bottom := f_BottomShape.Bounds.Bottom + Self.Get_FI.Spacing.Bottom;
    end // if (l_Rect.Bottom - l_Rect.Top) > l_Height then
    else
    begin
     l_Rect.Top := Min(l_Rect.Top, f_BottomShape.Bounds.Top - Self.Get_FI.Spacing.Top);
     l_Rect.Bottom := Max(l_Rect.Bottom, f_BottomShape.Bounds.Bottom + Self.Get_FI.Spacing.Bottom);
    end;
   end; // if f_BottomShape <> nil then
  end; // if not InevView(f_AllShapes.f_View).Metrics.InfoCavas.Printing then
 end; // if aChild.NeedIncHeight then
 Bounds := l_Rect;
end;

{ TnevCellShape }

function TnevCellShape.ChangeFakeItem(out aNewItem   : TnevShape;
                                      out aParentObj : InevObjectList;
                                      out aNew       : Boolean): Boolean;
var
 l_Cell      : InevTableCell;
 l_TempPoint : InevBasePoint;
 l_MostInner : InevBasePoint;
 l_FormBL    : Boolean;
begin
 Result := False;
 aParentObj := nil;
 aNewItem := Self;
 f_Obj.AsObject.QT(InevTableCell, l_Cell);
 Assert(l_Cell <> nil);
 l_Cell := l_Cell.GetMergeHead;
 if l_Cell <> nil then
 begin
  Result := True;
  l_TempPoint := l_Cell.MakePoint;
  l_TempPoint := l_TempPoint.PointToParent(f_AllShapes.f_Shapes.f_Obj);
  aNewItem := f_AllShapes.ItemByPoint(l_TempPoint, l_MostInner, l_FormBL);
  aParentObj := l_Cell.OwnerObj;
 end; // if l_Cell <> nil then
 aNew := (aNewItem = nil) or not aNewItem.Visible;
end;

procedure TnevCellShape.Cleanup;
begin
 inherited;
 f_RealVisible := nil;
 f_UpperShape := nil;
end;

procedure TnevCellShape.FoundFakeOwnerItem(
  out aNewItem: TnevShape);
var
 l_Cell       : InevTableCell;
 l_RowShape   : TnevShape;
 l_RowPara    : InevParaList;
 l_TableShape : TnevShape;
begin
 inherited;
 f_Obj.AsObject.QT(InevTableCell, l_Cell);
 Assert(l_Cell <> nil);
 l_Cell := l_Cell.GetMergeHead;
 if l_Cell <> nil then
 begin
  l_TableShape := Parent.Parent;
  l_RowPara := l_Cell.OwnerPara;
  l_RowShape := l_TableShape.AddShape(l_RowPara, nevPt0, False, nil);
  Assert(l_RowShape <> nil);
  aNewItem := l_RowShape.AddShape(l_Cell, nevPt0, False, nil);
 end; // if l_Cell <> nil then
end;

function TnevCellShape.GetBoundsWithFakeShapes(const aTopShape: TnevShape): TnevRect;
var
 l_Last   : Integer;
 l_Shape  : TnevShape;
 l_Bottom : Integer;
begin
 Result := inherited GetBoundsWithFakeShapes(aTopShape);
 if aTopShape = nil then
 begin
  l_Last := Count - 1;
  if l_Last >= 0 then
  begin
   l_Shape := Items[l_Last];
   Result := l3Rect(l3Point(Result.Left, Result.Top),
                    l3Point(Result.Right, Min(l_Shape.Bounds.Bottom, Parent.Bounds.Bottom)));
  end; // if l_Last >= 0 then
 end // if aTopShape = nil then
 else
 begin
  l_Last := aTopShape.Count - 1;
  if l_Last >= 0 then
  begin
   l_Shape := aTopShape.Items[l_Last];
   if Parent.f_FI.CompareWithMax(f_Obj.PID) = 0 then
    l_Bottom := Max(l_Shape.Bounds.Bottom, Parent.Bounds.Bottom)
   else
    l_Bottom := Min(l_Shape.Bounds.Bottom, Parent.Bounds.Bottom);
   Result := l3Rect(l3Point(Result.Left, Result.Top),
                    l3Point(Result.Right, l_Bottom));
  end; // if l_Last >= 0 then
 end;
end;

function TnevCellShape.GetRealVisible: TnevShape;
begin
 if f_RealVisible = nil then
  Result := inherited GetRealVisible
 else
  Result := f_RealVisible;
end;

function TnevCellShape.MakeUpperPoint: InevBasePoint;
var
 l_Cell: InevTableCell;
begin
 if (OverlapType = otLower) then
 begin
  f_Obj.AsObject.QT(InevTableCell, l_Cell);
  Assert(l_Cell <> nil);
  l_Cell := l_Cell.GetMergeHead;
  if l_Cell = nil then
   Result := nil
  else
   Result := l_Cell.MakePoint;
 end // if (OverlapType = otLower) then
 else
  Result := inherited MakeUpperPoint;
end;

function TnevCellShape.GetUpperShape: TnevShape;
begin
 Result := f_UpperShape;
end;

function TnevCellShape.IsGreater: Boolean;
begin
 Result := (Parent.f_FI.GreatestObjPID = f_Obj.PID) or
           ((f_Obj.AsObject.IntA[k2_tiVerticalAligment] = Ord(ev_valBottom)) and (f_Obj.OverlapType = otNone));
end;

function TnevCellShape.NeedIncHeight: Boolean;
var
 l_Diff: Integer;
begin
 l_Diff := Parent.f_FI.CompareWithMax(f_Obj.PID);
 Result := (l_Diff  > evUndefHeight) and f_Obj.NeedIncludeHeight;
end;

procedure TnevCellShape.SetRealVisible(const Value: TnevShape);
begin
 if Value = nil then
 begin
  if f_RealVisible <> nil then
   f_RealVisible := nil
 end
 else
  (Value as TnevCellShape).f_UpperShape := Self;
 f_RealVisible := Value;
end;

function TnevShape.MakeUpperPoint: InevBasePoint;
begin
 Result := Self.f_Obj.MakePoint;
end;

// start class TnevDocumentShape

procedure TnevDocumentShape.Cleanup;
  //override;
  {-}
begin
 FreeAndNil(f_DecorShapes);
 inherited;
end;
  
function TnevDocumentShape.AddShape(const aShape   : InevObject;
                                    const aTopLeft : TnevPoint;
                                    MakeVisible    : Boolean;
                                    const aHacker  : InevK235870994Hacker): TnevShape;
  //override;
  {-}
var
 l_Index : Integer;
 l_Item  : TnevShape;
begin
 if aShape.IsDecorationElement then
 begin
  if (f_DecorShapes <> nil) then
  begin
   for l_Index := 0 to Pred(f_DecorShapes.Count) do
   begin
    l_Item := TnevShape(f_DecorShapes.Items[l_Index]{$IfOpt D+} As TnevShape{$EndIf});
    if l_Item.f_Obj.AsObject.IsSame(aShape.AsObject) then
    begin
     Result := l_Item;
     Exit;
    end;//l_Item.f_Obj.IsSame(aShape)
   end;//for l_Index
  end;//f_DecorShapes <> nil
  if (f_DecorShapes = nil) then
   f_DecorShapes := TnevShapePrimRefList.Create;
  l_Item := CreateShape(aShape, aTopLeft);
  try
   f_DecorShapes.Add(l_Item);
   Result := l_Item;
  finally
   FreeAndNil(l_Item);
  end;//try..finally
  Exit;
 end;//aShape.IsDecorationElement
 Result := inherited AddShape(aShape, aTopLeft, MakeVisible, aHacker);
end;

function TnevShape.GetChildMap(anIndex: Integer): InevMap;
begin
 if (anIndex < f_PIDOfs) then
  Result := nil
 else
  Result := Items[anIndex - f_PIDOfs];
end;

procedure TnevShape.CheckBounds;
begin

end;

procedure TnevTextParaShape.CheckBounds;
begin
 // V - http://mdp.garant.ru/pages/viewpage.action?pageId=371647970
 if (f_Obj.AsObject.IntA[k2_tiJustification] = Ord(ev_itPreformatted)) and (f_Bounds.Right < Abs(evShapeNil)) then
  f_Bounds := l3Rect(f_Bounds.Left, f_Bounds.Top, Abs(evShapeNil), f_Bounds.Bottom);
end;

procedure TnevListShape.Clear;
begin
 f_BottomShape := nil;
 inherited;
end;

function TnevShapesPainted.GetBottomAnchor(const aView: InevView; aSimple: Boolean; var aNeedMoveDown: Boolean): InevBaseLine4Anchor;
begin
 Result := GetInnerAnchor(aView, f_Shapes, aSimple, aNeedMoveDown);
end;

function TnevShape.GetBottomShape: TnevShape;
begin
 Result := nil;
end;

function TnevShape.IsMapValid: Boolean;
begin
 Result := Assigned(Parent);
end;

function TnevListShape.GetBottomShape: TnevShape;
begin
 Result := f_BottomShape
end;

function TnevShapesPainted.GetInnerAnchor(const aView: InevView;
                                          aShape: TnevShape;
                                          aSimple: Boolean;
                                          var aNeedMoveDown: Boolean): InevBaseLine4Anchor;
var
 l_Prev         : InevBasePoint;
 l_Bottom       : Integer;
 l_Parent       : InevBaseLine4Anchor;
 l_Shape        : TnevShape;
 l_Point        : InevPoint;
 l_Anchor       : InevBaseLine4Anchor;
 l_HalfBottom   : Integer;
 l_BottomWOSpace: Integer;
begin
 Result := nil;
 l_Shape := aShape;
 l_Bottom := aView.Metrics.Extent.Y - evEpsilon;
 while l_Shape <> nil do
 begin
  l_Anchor := l_Shape.f_Obj.MakeAnchor;
  if not l_Shape.f_Obj.IsList then
  begin
   l_Point := l_Shape.f_Obj.MakePoint;
   l_Point.AsLeaf.InitPointByPt(aView, l3PointY(l_Bottom), l_Shape);
   l_Anchor.AssignPoint(aView, l_Point);
   l_BottomWOSpace := l_Bottom - aShape.f_FI.Spacing.Bottom;
   if ((l_Shape.Bounds.Bottom - l_BottomWOSpace) > evFindCellDelta) and l_Parent.Obj.IsKindOf(k2_typBlock) then
   begin
    l_Prev := l_Parent.Inner;
    l_Parent.Inner := l_Anchor;
    if l_Parent.TopParentPoint.AtEnd(aView) then
    begin
     l_Parent.Inner := l_Prev;
     aNeedMoveDown := True;
     Exit;
    end // if l_Parent.AtEnd(aView) then
   end; // if (l_Shape.Bounds.Bottom > l_Bottom) then
   if (aShape.Bounds.Bottom < l_Bottom) then
   begin
    if not l_Anchor.AtEnd(aView) then
     l_Anchor.Bottom(aView);
    l_Parent.Inner := l_Anchor;
    l_HalfBottom := (l_Bottom div 2);
    aNeedMoveDown := (aShape.Bounds.Bottom < l_HalfBottom);
    Exit;
   end; // if aShape.Bounds.Bottom < l_Bottom then
  end; // if not l_Shape.f_Obj.IsList then
  if Result = nil then
  begin
   Result := l_Anchor;
   l_Parent := Result;
  end // if Result = nil then
  else
  begin
   l_Parent.Inner := l_Anchor;
   l_Parent := l_Anchor;
  end;
  if CheckRowShape(aView, l_Shape, l_Anchor, aSimple, aNeedMoveDown) then Break;
  l_Shape := l_Shape.GetBottomShape;
  l_Shape := CorrectShape(l_Bottom, aView, l_Shape);
 end; // while l_Shape <> do
end;

function TnevShapesPainted.CheckRowShape(const aView   : InevView;
                                         aShape        : TnevShape;
                                         const anAnchor: InevBaseLine4Anchor;
                                         aSimple       : Boolean;
                                         var aNeedMoveDown: Boolean): Boolean;
var
 l_Item    : TnevShape;
 l_AddMode : TnevAddInnerMode;

 function lp_CheckItem(aCheckMaxItem: Boolean): Boolean;
 var
  l_CellShape: TnevShape;

  function lp_GetUpperFromPrevRows: TnevShape;
  var
   l_Cell      : InevTableCell;
   l_TableShape: TnevShape;

   function lp_CheckHead: TnevShape;
   var
    l_Head    : InevTableCell;
    l_RowID   : Integer;
    l_CellID  : Integer;
    l_RowShape: TnevShape;
   begin
    Result := nil;
    l_Head := l_Cell.GetMergeHead;
    if l_Head <> nil then
    begin
     l_RowID := l_Head.OwnerObj.PID - l_TableShape.f_PIDOfs;
     if l_RowID >= 0 then
     begin
      l_RowShape := l_TableShape[l_RowID];
      l_CellID := l_Head.PID - l_RowShape.f_PIDOfs;
      if l_CellID >= 0 then
       Result := l_RowShape[l_CellID];
     end; // if l_RowID > 0 then
    end; // if l_Head <> nil then
   end;

  var
   l_RowID    : Integer;
   l_CellID   : Integer;
   l_RowShape : TnevShape;
  begin
   Result := nil;
   l_RowID := 0;
   l_CellShape.f_Obj.AsObject.QT(InevTableCell, l_Cell);
   Assert(l_Cell <> nil);
   l_RowShape := nil;
   l_TableShape := l_CellShape.Parent.Parent;
   Result := lp_CheckHead;
   while Result = nil do
   begin
    l_Cell := l_Cell.GetContinueCell(True, fc_Up);
    if l_Cell = nil then                                   
     Break
    else
     if l_RowShape = nil then
     begin
      l_RowID := l_Cell.OwnerPara.PID;
      l_RowID := l_RowID - l_TableShape.f_PIDOfs;
      if l_RowID < 0 then
       l_RowShape := nil
      else
       l_RowShape := l_TableShape[l_RowID];
     end // if l_Cell <> nil then
     else
     begin
      Dec(l_RowID);
      if (l_RowID < 0) then Break;
      l_RowShape := l_TableShape[l_RowID];
     end;
    if l_RowShape = nil then Break;
    l_CellID := l_Cell.PID - l_RowShape.f_PIDOfs;
    if l_CellID < 0 then
     l_CellShape := nil
    else
     l_CellShape := l_RowShape[l_CellID];
    if l_CellShape = nil then
     Break
    else
     Result := l_CellShape.GetUpperShape;
   end; // while Result = nil then
  end;

 begin
  Result := False;
  if l_Item.OverlapType = otLower then
  begin
   if aSimple then
    l_AddMode := nev_aimSingleHead
   else
    l_AddMode := nev_aimHead;
   l_CellShape := l_Item;
   l_Item := l_Item.GetUpperShape;
   if aCheckMaxItem and (l_Item = nil) then
    l_Item := lp_GetUpperFromPrevRows;
   Result := (l_Item = nil) or not aShape.IsBottomShape(aView.Metrics.Extent.Y - evEpsilon, l_Item);
  end; // if l_Item.OverlapType = otLower then
 end;

var
 l_Loop: Integer;
 l_Index  : Integer;
 l_Fisrt  : Boolean;
 l_MaxID  : Integer;
 l_Anchor : InevBaseLine4Anchor;
 l_MaxItem: TnevShape;
begin
 Result := (aShape <> nil) and aShape.IsRowShape;
 if Result then
 begin
  if aShape.f_FI = nil then Exit;
  l_MaxItem := nil;
  l_Fisrt := True;
  if aSimple then
   l_AddMode := nev_aimSingleUsual
  else
   l_AddMode := nev_aimUsual;
  l_Index := aShape.f_FI.GreatestObjPID;
  l_MaxID := l_Index;
  l_Item := aShape.Items[l_Index];
  if (l_Item <> nil) and not lp_CheckItem(True) then
   l_MaxItem := l_Item;
  if l_MaxItem = nil then // Не видна самая длинная ячейка, но это не повод ничего не возвращать...
   for l_Loop := 0 to aShape.Count - 1 do
   begin
    l_Index := l_Loop;
    l_Item := aShape.Items[l_Index];
    if (l_Item <> nil) then
    begin
     if lp_CheckItem(False) then Continue;
     if (l_MaxItem = nil) or (l_Item.Bounds.Bottom > l_MaxItem.Bounds.Bottom) then
     begin
      l_MaxItem := l_Item;
      l_MaxID := l_MaxItem.f_Obj.PID;
     end;
    end; // if (l_Item <> nil) then
   end; // for l_Index := 0 to aShape.Count - 1 do
  if l_MaxItem = nil then // Не смогли найти самую длинную ячейку...
   anAnchor.Bottom(aView) // Если использовать точку от TopAnchor, то можно и правильно посчитать...
  else
  begin
   l_Anchor := GetInnerAnchor(aView, l_MaxItem, aSimple, aNeedMoveDown);
   anAnchor.AddInner(aView, l_Anchor, l_MaxID, l_Fisrt, l_AddMode);
   if not aSimple then
    anAnchor.CompareWithOtherInner(aView, l_Index);
  end; // if l_MaxItem <> nil then
 end; // if l_Shape.IsRowShape then
end;

function TnevShape.IsBottomShape(aTopShape: Integer; aShape: TnevShape): Boolean;
begin
 Result := False;
end;

function TnevListShape.IsBottomShape(aTopShape: Integer; aShape: TnevShape): Boolean;
begin
 Result := (aTopShape > aShape.Bounds.Bottom) or
     ((aTopShape < aShape.Bounds.Bottom) and (aTopShape > aShape.Bounds.Top));
 if Result then
  Result := CheckViewBottom(aShape.Bounds.Top);
end;

procedure TnevShapesPainted.ClearList;
begin
 if f_TablePoints <> nil then
  f_TablePoints.Clear;
end;

function TnevShapesPainted.RestoreTablePoint(const aRowObj: InevObject): InevBaseLine4Anchor;
var
 l_Index: Integer;
begin
 Result := nil;
 if (f_TablePoints <> nil) then
 begin
  for l_Index := 0 to f_TablePoints.Count - 1 do
   if f_TablePoints[l_Index].AsObject.IsSame(aRowObj.AsObject.Owner) then
   begin
    Result := InevBaseLine4Anchor(f_TablePoints[l_Index]);
    Break;
   end; // if f_TablePoints[l_Index].IsSame(aRowObj.Owner) then
 end; // if (f_TablePoints <> nil) then
end;

procedure TnevShapesPainted.SaveTablePoint(const aPoint: InevBaseLine4Anchor);
var
 l_Index: Integer;
 l_Found: Boolean;
begin
 if f_TablePoints = nil then
  f_TablePoints := TnevBasePointList.Make;
 l_Found := False;
 for l_Index := 0 to f_TablePoints.Count - 1 do
  if f_TablePoints[l_Index].AsObject.IsSame(aPoint.Obj^.AsObject) then
  begin
   l_Found := True;
   Break;
  end; // if f_TablePoints[l_Index].IsSame(aPoint.Obj^) then 
 if not l_Found then
  f_TablePoints.Add(aPoint);
end;

procedure TnevShape.SetDrawnTop(aTop: Integer);
begin

end;

function TnevListShape.CheckViewBottom(aTop: Integer): Boolean;
var
 l_ExtBottom : Integer;
begin
 Result := True;
 if (f_AllShapes.f_View <> nil) then
 begin
  l_ExtBottom := InevView(f_AllShapes.f_View).Metrics.Extent.Y;
  Result := (l_ExtBottom - aTop) > nev.LineScrollDelta.Y;
 end; // if Result then
end;

function TnevShapesPainted.CorrectShape(aBottom: Integer; const aView: InevView; const aShape: TnevShape): TnevShape;
var
 l_IDShape : Integer;
begin
 Result := aShape;
 if (aShape <> nil) and aShape.IsRowShape then
 begin
  if not aShape.IsBottomShape(aBottom, aShape) then
  begin
   l_IDShape := aShape.f_Obj.PID - aShape.Parent.f_PIDOfs - 1;
   if l_IDShape >= 0 then
    Result := aShape.Parent[l_IDShape];
  end; // if not aShape.IsBottomShape(l_Bottom, l_Item) then
 end; // if (aShape <> nil) and aShape.IsRowShap then
end;

function TnevListShape.GetChildenRight4Fill: Integer;
var
 i, k        : Integer;
 l_Shape     : TnevShape;
 l_RowShape  : TnevShape;
 l_CellShape : TnevShape;
begin
 Result := 0;
 l_RowShape := nil;
 if IsVertical then
  for i := 0 to Count - 1 do
  begin
   l_Shape := Items[i];
   if l_Shape.IsTable then
    if f_PIDOfs = 0 then
     Result := l_Shape.Bounds.Right + 2 * evEpsilon
    else
    begin
     for k := 0 to l_Shape.Count - 1 do
     begin
      l_RowShape := l_Shape.Items[k];
      if l_RowShape.Visible then Break;
     end; // for k := 0 to Count - 1 do
     l_CellShape := TnevShape(l_RowShape.Last);
     Result := l_CellShape.Bounds.Right;
    end; // if l_Shape.IsTable then
  end; // for i := 0 to Count - 1 do
 if Result = 0 then
  Result := inherited GetChildenRight4Fill;
end;

function TnevShape.GetChildenRight4Fill: Integer;
begin
 Result := f_Bounds.Right;
end;

function TnevShape.IsTable: Boolean;
begin
 Result := False;
end;

{ TnevHeaderTextParaShape }

function TnevHeaderTextParaShape.pm_GetBounds: TafwRect;
var
 l_Left: Integer;
begin
 if f_FI <> nil then
  l_Left := f_FI.Spacing.Left - cnPlusIconSpace
 else
  l_Left := 0;
 Result := l3Rect(f_Bounds.Left + l_Left, f_Bounds.Top, f_Bounds.Right, f_Bounds.Bottom);
end;

end.
