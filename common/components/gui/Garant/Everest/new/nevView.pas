unit nevView;

{ Библиотека "Эверест"    }
{ Начал: Люлин А.В.       }
{ Модуль: nevView -       }
{ Начат: 09.04.2005 16:51 }
{ $Id: nevView.pas,v 1.118 2015/02/26 09:29:01 kostitsin Exp $ }

// $Log: nevView.pas,v $
// Revision 1.118  2015/02/26 09:29:01  kostitsin
// List*ner -> Listener
//
// Revision 1.117  2015/02/25 13:53:23  kostitsin
// List*ner -> Listener
//
// Revision 1.116  2014/09/28 16:07:43  kostitsin
// {requestlink: 565503132 }
//
// Revision 1.115  2014/05/13 10:27:17  lulin
// {RequestLink:532625195}.
//
// Revision 1.114  2014/04/30 11:23:54  lulin
// - выпрямляем зависимости.
//
// Revision 1.113  2014/04/29 13:38:53  lulin
// - вычищаем ненужные зависимости.
//
// Revision 1.112  2014/04/29 12:03:52  lulin
// - вычищаем ненужный метод.
//
// Revision 1.111  2014/04/07 17:57:03  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.110  2013/04/29 10:18:58  dinishev
// {Requestlink:452367754}
//
// Revision 1.109  2013/04/25 10:59:59  dinishev
// {Requestlink:452365172}
//
// Revision 1.108  2012/08/21 12:09:47  dinishev
// {Requestlink:382421131}
//
// Revision 1.107  2012/08/20 14:16:54  dinishev
// {Requestlink:382421131}
//
// Revision 1.106  2012/07/27 08:20:29  dinishev
// {Requestlink:379234051}
//
// Revision 1.105  2012/07/26 12:55:06  dinishev
// {Requestlink:156371013}
//
// Revision 1.104  2012/03/14 10:53:32  dinishev
// {Requestlink:342859055}
//
// Revision 1.103  2012/03/05 12:55:12  kostitsin
// [$342852355]
//
// Revision 1.102  2011/12/13 10:04:59  kostitsin
// http://mdp.garant.ru/pages/viewpage.action?pageId=287211613
//
// Revision 1.101  2011/10/27 15:11:29  lulin
// {RequestLink:278135821}
// - написал комментарии.
//
// Revision 1.100  2011/10/27 15:05:17  lulin
// {RequestLink:278135821}
//
// Revision 1.99  2011/10/26 16:56:00  lulin
// {RequestLink:278135821}.
//
// Revision 1.98  2011/09/19 09:46:12  lulin
// {RequestLink:266898633}.
//
// Revision 1.97  2011/09/15 18:32:09  lulin
// {RequestLink:278824896}.
//
// Revision 1.96  2011/09/14 07:51:46  lulin
// {RequestLink:278824896}.
//
// Revision 1.95  2011/04/20 12:19:37  dinishev
// [$259163537]
//
// Revision 1.94  2011/03/01 17:38:06  lulin
// {RequestLink:255956509}.
//
// Revision 1.93  2011/02/24 16:36:23  lulin
// {RequestLink:254938079}.
// - экономим на счётчике ссылок.
//
// Revision 1.92  2011/02/24 16:30:09  lulin
// {RequestLink:254938079}.
// - чудная заплаточка - если возможно - перебираем параграфы не к началу документа, а к концу.
//
// Revision 1.91  2011/02/24 15:31:34  lulin
// {RequestLink:254938079}.
// - запилил для перехода в самый конец документа.
//
// Revision 1.90  2011/02/14 18:09:52  lulin
// {RequestLink:231670346}.
// - при всякого рода навигациях по тексту учитываем, что параграфы могут быть схлопнутыми.
//
// Revision 1.89  2010/12/13 18:22:34  lulin
// {RequestLink:215549559}.
//
// Revision 1.88  2010/10/08 17:13:12  lulin
// {RequestLink:235870994}.
// - [$235871850].
//
// Revision 1.87  2010/07/27 11:19:11  lulin
// {RequestLink:228691314}.
//
// Revision 1.86  2010/07/13 15:48:15  dinishev
// [$226002079]
//
// Revision 1.85  2010/06/15 13:37:55  dinishev
// Вычистил запил  для задачи [$210436976]
//
// Revision 1.84  2010/06/09 15:13:08  dinishev
// [$217682021]. Недокоммител.
//
// Revision 1.83  2010/06/09 11:18:06  lulin
// {RequestLink:217684334}.
// - добавлен тест.
//
// Revision 1.82  2010/06/04 14:32:22  lulin
// {RequestLink:213713120}.
// - более тонко настраиваем тест, чтобы было как у Ушакова.
// - правим Assert'ы.
//
// Revision 1.81  2010/06/04 11:31:54  dinishev
// [$197493616]. Вычищаем GetBottomAnchor4PgDown
//
// Revision 1.80  2010/06/02 08:43:26  dinishev
// [$216793505]
//
// Revision 1.79  2010/05/31 10:56:40  lulin
// {RequestLink:216531388}.
//
// Revision 1.78  2010/05/28 14:28:02  lulin
// {RequestLink:171969856}.
//
// Revision 1.77  2010/05/27 14:49:57  lulin
// {RequestLink:193823276}.
// - задел на более правильную обработку позицилнирования на Sub из Waiter'а.
// - с перемещением на ИЗМЕНЁННЫЕ фрагменты и синхронизацией редакций не работает пока.
//
// Revision 1.76  2010/05/18 05:51:56  dinishev
// [$210436976]
//
// Revision 1.75  2010/05/04 13:02:47  lulin
// {RequestLink:208701246}.
//
// Revision 1.74  2010/04/28 10:14:54  dinishev
// [$207006496]. Тесты рулят. :-)
//
// Revision 1.73  2010/04/27 08:05:58  dinishev
// [$206079241]
//
// Revision 1.72  2010/04/08 06:34:15  dinishev
// [$201492444]
//
// Revision 1.70  2010/04/07 12:15:05  dinishev
// [$201491457]
//
// Revision 1.69  2010/04/06 12:06:49  dinishev
// [$198673042]
//
// Revision 1.68  2010/03/23 14:03:37  dinishev
// Cleanup
//
// Revision 1.67  2010/03/23 14:02:54  dinishev
// [$195756452]
//
// Revision 1.66  2010/03/05 10:59:34  dinishev
// [$183337716]
//
// Revision 1.65  2010/01/20 18:11:25  lulin
// {RequestLink:177964038}. Избавляемся от лишних вызовов.
//
// Revision 1.64  2010/01/20 18:04:56  lulin
// {RequestLink:177964038}. Борьба с тем, что отрисовка не проходит и условия того что документ пролистан до конца - не проходят.
//
// Revision 1.63  2010/01/19 17:59:50  lulin
// {RequestLink:139430176}. Ловушка для предполагаемого места зависания теста.
//
// Revision 1.62  2009/12/02 12:13:58  lulin
// - откручиваем изменения. Ибо замедлился скроллинг.
//
// Revision 1.61  2009/11/20 16:28:54  lulin
// - поставлены ссылки на обсуждение.
//
// Revision 1.60  2009/11/20 16:27:45  lulin
// {RequestLink:171969856}. Не было нотификации о смене параграфа, таким образом не запоминали эту смену и потом слали событие о смене параграфа в совершенно неподходящем месте.
//
// Revision 1.59  2009/11/19 13:35:46  lulin
// {RequestLink:171968601}.
//
// Revision 1.58  2009/10/19 06:53:25  lulin
// {RequestLink:166856878}.
//
// Revision 1.57  2009/08/20 14:29:47  lulin
// {RequestLink:159364448}.
//
// Revision 1.56  2009/08/19 18:07:14  lulin
// {RequestLink:158795592}. Вставленный фрагмент из документа гаранта (вложенный k2_idDocument) сделать read-only, чтобы его можно было удалить только целиком.
//
// Revision 1.55  2009/07/23 08:14:45  lulin
// - вычищаем ненужное использование процессора операций.
//
// Revision 1.54  2009/07/14 14:56:42  lulin
// {RequestLink:141264340}. №25.
//
// Revision 1.53  2009/07/13 13:25:24  lulin
// {RequestLink:141264340}. №14.
//
// Revision 1.52  2009/07/13 12:31:48  lulin
// {RequestLink:141264340}. №23ac.
//
// Revision 1.51  2009/07/13 08:05:23  lulin
// {RequestLink:141264340}. №24bc.
//
// Revision 1.50  2009/07/11 15:55:17  lulin
// {RequestLink:141264340}. №22.
//
// Revision 1.49  2009/07/11 12:46:28  lulin
// {RequestLink:141264340}. №14.
//
// Revision 1.48  2009/07/11 11:21:44  lulin
// - убираем лишний интерфейс модификации якоря.
//
// Revision 1.47  2009/07/11 09:24:50  lulin
// - избавляемся от лишнего дёрганья счётчиков ссылок.
//
// Revision 1.46  2009/07/02 10:40:49  lulin
// - выключаем приём нотификаций об изменении курсора, там где он не нужен.
//
// Revision 1.45  2009/07/01 18:37:17  lulin
// - не пытаемся подогнать курсор при заведомо плохих условиях.
//
// Revision 1.44  2009/06/26 08:47:57  lulin
// - вычищен ненужный модуль.
//
// Revision 1.43  2009/06/16 10:48:43  lulin
// [$142610581].
//
// Revision 1.42  2009/04/08 12:56:41  lulin
// [$142610892]. Вычищаем ненужные контексты.
//
// Revision 1.41  2009/03/06 13:47:51  lulin
// - <K>: 138543640.
//
// Revision 1.40  2008/11/24 14:25:23  lulin
// - <K>: 125404953.
//
// Revision 1.39  2008/11/11 11:09:28  lulin
// - <K>: 122672539.
//
// Revision 1.38  2008/09/10 16:41:28  lulin
// - <K>: 98828579.
//
// Revision 1.37  2008/08/20 14:03:54  lulin
// - добавил комментарий.
//
// Revision 1.36  2008/08/20 14:02:46  lulin
// - <K>: 109086509.
//
// Revision 1.35  2008/08/05 10:29:54  lulin
// - <K>: 96481508.
//
// Revision 1.34  2008/06/20 14:49:05  lulin
// - используем префиксы элементов.
//
// Revision 1.33  2008/06/02 13:18:02  lulin
// - <K>: 89096952.
//
// Revision 1.32  2008/05/30 09:09:08  lulin
// - <K>: 93257910.
//
// Revision 1.31  2008/05/28 07:58:26  lulin
// - <CQ>: 29146.
//
// Revision 1.30  2008/05/15 17:31:39  lulin
// - чистка использования модулей.
// - убираем неочевидную логику скроллирования.
//
// Revision 1.29  2008/05/07 18:29:52  lulin
// - изменения в рамках <K>: 90441963.
//
// Revision 1.28  2008/04/29 17:24:30  lulin
// - работы по <K>: 89106312.
//
// Revision 1.27  2008/04/29 16:56:55  lulin
// - работы по <K>: 89106312.
//
// Revision 1.26  2008/04/25 15:27:11  lulin
// - <K>: 89107853.
//
// Revision 1.25  2008/04/25 13:56:29  lulin
// - <K>: 89107692.
//
// Revision 1.24  2008/04/24 15:22:14  lulin
// - изменения в рамках <K>: 89106312.
//
// Revision 1.23  2008/04/24 12:26:21  lulin
// - изменения в рамках <K>: 89106312.
//
// Revision 1.22  2008/04/15 08:23:54  lulin
// - передаём вью в качестве параметра.
//
// Revision 1.21  2008/04/11 14:26:21  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.20  2008/04/11 12:01:36  lulin
// - <K>: 89100701.
//
// Revision 1.19  2008/04/11 11:30:03  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.18  2008/04/09 17:57:19  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.17  2008/04/09 11:20:28  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.16  2008/04/08 18:02:18  lulin
// - передаём вью в рамках <K>: 89096854.
//
// Revision 1.15  2008/04/08 16:41:27  lulin
// - передаём View в AssignPoint. <K>: 89096854.
//
// Revision 1.14  2008/04/07 13:34:10  lulin
// - изменения в рамках <K>: 89096854.
//
// Revision 1.13  2008/04/02 14:22:07  lulin
// - cleanup.
//
// Revision 1.12  2008/03/27 11:46:02  dinishev
// Борьба с медленным скроллингом длинной таблицы
//
// Revision 1.11  2008/03/20 14:27:52  lulin
// - <K>: 87590297.
//
// Revision 1.10  2008/03/19 14:23:36  lulin
// - cleanup.
//
// Revision 1.9  2008/03/18 16:29:16  dinishev
// Уменьшаем число вызовов виртуальной отрисовки таблиц
//
// Revision 1.8  2008/03/04 08:28:00  lulin
// - <K>: 85721148.
//
// Revision 1.7  2008/02/27 17:25:00  lulin
// - подгоняем код под модель.
//
// Revision 1.6  2008/02/14 17:09:01  lulin
// - cleanup.
//
// Revision 1.5  2008/02/04 08:51:27  lulin
// - класс _Tl3InterfaceList выделен в отдельный модуль.
//
// Revision 1.4  2007/12/19 12:56:16  oman
// - fix: На переключении баз очищаем коллекцию отрисованных (cq27870)
//
// Revision 1.3  2007/12/04 12:47:52  lulin
// - перекладываем ветку в HEAD.
//
// Revision 1.1.4.229  2007/10/10 14:20:11  lulin
// - bug fix: в результате переходных процессов убращались к уже убитому объекту (CQ OIT5-27006).
//
// Revision 1.1.4.228  2007/09/07 14:47:37  lulin
// - добавлено удаление последнего элемента списка.
//
// Revision 1.1.4.227  2007/04/05 05:58:19  lulin
// - bug fix: скроллировали редактор вверх, когда курсор мыши попадал за нижнюю границу экрана, а в конце документа стоит пустой блок (CQ OIT5-23596).
//
// Revision 1.1.4.226  2006/11/27 12:10:39  lulin
// - bug fix: не подравнивали найденный текст по горизонтали - чтобы был виден в окне редактора (CQ OIT5-23730).
//
// Revision 1.1.4.225  2006/11/23 15:03:22  lulin
// - bug fix: могла теряться нотификация о смене позиции курсора.
//
// Revision 1.1.4.224  2006/11/23 14:51:39  lulin
// - функция показа точки теперь возвращает резутьтат - изменилось что-гибудь или нет.
//
// Revision 1.1.4.223  2006/11/22 14:43:46  lulin
// - переставляем кусоры в паре местами, если они не в правильном порядке.
//
// Revision 1.1.4.222  2006/11/20 17:40:17  lulin
// - не даем модифицировать якорь не в рамках вью.
//
// Revision 1.1.4.221  2006/11/20 16:33:16  lulin
// - удален ненужный метод.
//
// Revision 1.1.4.220  2006/11/15 14:02:50  lulin
// - cleanup.
//
// Revision 1.1.4.219  2006/11/15 13:57:36  lulin
// - bug fix: невовремя обновляли позицию скроллера - до ее реального присвоения (CQ OIT5-22696).
//
// Revision 1.1.4.218  2006/11/15 12:42:45  lulin
// - убран ненужный параметр.
//
// Revision 1.1.4.217  2006/11/15 11:38:35  lulin
// - теперь умеем делать любую базовую точку видимой.
//
// Revision 1.1.4.216  2006/11/15 11:20:30  lulin
// - bug fix: не скроллировались ко вновь вставленному параграфу (CQ OIT5-23607).
//
// Revision 1.1.4.215  2006/11/15 10:26:18  lulin
// - cleanup.
//
// Revision 1.1.4.214  2006/11/15 09:51:30  lulin
// - перехлест сверху страницы меряем не в строках, а в параграфах (CQ OIT5-22590).
//
// Revision 1.1.4.213  2006/11/15 09:43:07  lulin
// - bug fix: постраничным листанием вниз никогда не достигали конца документа (CQ OIT5-23640).
//
// Revision 1.1.4.212  2006/11/10 17:15:59  lulin
// - объединил с веткой.
//
// Revision 1.1.4.211  2006/11/03 11:00:18  lulin
// - объединил с веткой 6.4.
//
// Revision 1.1.4.210.2.32  2006/11/03 09:48:13  lulin
// - вычищено ненужное рисование на виртуальной канве.
//
// Revision 1.1.4.210.2.31  2006/11/03 07:50:58  lulin
// - cleanup.
//
// Revision 1.1.4.210.2.30  2006/11/02 19:23:26  lulin
// - смещение по вертикали храним на скроллере, а не на вью.
//
// Revision 1.1.4.210.2.29  2006/11/02 18:59:53  lulin
// - смещение по горизонтали храним на скроллере, а не на вью.
//
// Revision 1.1.4.210.2.28  2006/11/02 18:19:50  lulin
// - cleanup.
//
// Revision 1.1.4.210.2.27  2006/11/02 18:11:31  lulin
// - избавляемся от хранения лишних данных.
//
// Revision 1.1.4.210.2.26  2006/11/02 17:47:24  lulin
// - используем полиморфизм, вместо условного оператора.
//
// Revision 1.1.4.210.2.25  2006/11/02 17:22:35  lulin
// - используем полиморфизм, вместо условного оператора.
//
// Revision 1.1.4.210.2.24  2006/11/02 16:59:44  lulin
// - используем полиморфизм, вместо условного оператора.
//
// Revision 1.1.4.210.2.23  2006/11/02 15:26:37  lulin
// - bug fix: по-другому пытаемся определять - виден конец документа или нет.
//
// Revision 1.1.4.210.2.22  2006/11/02 14:56:59  lulin
// - cleanup.
//
// Revision 1.1.4.210.2.21  2006/11/02 14:07:02  lulin
// - разделил нотификацию о горизонтальном и вертикальном скроллировании.
//
// Revision 1.1.4.210.2.20  2006/11/02 13:50:25  lulin
// - выделен интерфейс принимающий нотификацию об изменении скроллера.
//
// Revision 1.1.4.210.2.19  2006/11/02 09:09:07  lulin
// - bug fix: не пытаемся скроллировать текст, если курсор и так видимый.
//
// Revision 1.1.4.210.2.18  2006/11/02 08:09:33  lulin
// - cleanup.
//
// Revision 1.1.4.210.2.17  2006/11/01 15:47:02  lulin
// - правильно рассчитываем количество дочерних элементов для горизонтальных списков.
//
// Revision 1.1.4.210.2.16  2006/11/01 10:03:30  lulin
// - bug fix: не подгоняли курсор по горизонтали (CQ OIT5-23363).
//
// Revision 1.1.4.210.2.15  2006/10/31 11:09:37  lulin
// - в функцию сравнения точек передаем карту форматирования.
//
// Revision 1.1.4.210.2.14  2006/10/30 09:04:48  lulin
// - cleanup.
//
// Revision 1.1.4.210.2.13  2006/10/29 15:30:01  lulin
// - bug fix: ползунком мыши нельзя было добраться до конца документа (CQ OIT5-23088).
//
// Revision 1.1.4.210.2.12  2006/10/29 12:44:37  lulin
// - требуем, чтобы карта форматирования была ненулевая.
//
// Revision 1.1.4.210.2.11  2006/10/27 10:38:30  lulin
// - при определении горизонтальной координаты курсора передаем карту форматирования.
//
// Revision 1.1.4.210.2.10  2006/10/25 18:12:28  lulin
// - убрана лишняя типизация объекта к его представлению.
//
// Revision 1.1.4.210.2.9  2006/10/25 17:14:33  lulin
// - удалено ненужное свойство.
//
// Revision 1.1.4.210.2.8  2006/10/25 15:49:30  lulin
// - cleanup.
//
// Revision 1.1.4.210.2.7  2006/10/25 09:45:05  lulin
// - операция клонирования спущена на базовую точку.
//
// Revision 1.1.4.210.2.6  2006/10/24 10:00:05  lulin
// - убран ненужный метод.
//
// Revision 1.1.4.210.2.5  2006/10/18 13:38:01  lulin
// - наследование заменяем агрегацией.
//
// Revision 1.1.4.210.2.4  2006/10/18 13:23:18  lulin
// - cleanup.
//
// Revision 1.1.4.210.2.3  2006/10/18 13:17:06  lulin
// - cleanup.
//
// Revision 1.1.4.210.2.2  2006/10/13 11:38:12  lulin
// - теперь при горизонтальном скроллировании двигаем уже нарисованное изображение.
//
// Revision 1.1.4.210.2.1  2006/10/13 11:15:46  lulin
// - поборолся с неправильной подгонкой каретки по-горизонтали.
//
// Revision 1.1.4.210  2006/10/10 18:19:26  lulin
// - убран ненужный параметр.
//
// Revision 1.1.4.209  2006/10/10 17:42:48  lulin
// - разносим модифицируемый и немодифицируемый якоря.
//
// Revision 1.1.4.208  2006/10/10 13:29:08  lulin
// - вызываем более правильную функцию очистки карты форматирования.
//
// Revision 1.1.4.207  2006/10/10 13:03:33  lulin
// - cleanup.
//
// Revision 1.1.4.206  2006/10/06 08:10:49  oman
// - fix: Очередной перепил ЦК22879, 22864
//
// Revision 1.1.4.205  2006/10/05 12:09:14  oman
// - fix: В мемо для КЗ не срабатывал первый Enter (cq22879)
// - refix: При смене текста документа на лету было AV (cq22864)
//
// Revision 1.1.4.204  2006/10/04 12:10:10  lulin
// - bug fix: был AV при попытке обновить скроллеры внутри создания View (CQ OIT5-22864).
//
// Revision 1.1.4.203  2006/10/03 13:33:37  lulin
// - используем более базовый интерфейс.
//
// Revision 1.1.4.202  2006/10/03 12:35:20  lulin
// - спрятан интерфейс, ненужный в F1 - чтобы не мешал выпрямлять кривизну.
//
// Revision 1.1.4.201  2006/10/02 11:38:40  lulin
// - объединяем с веткой в которой размеры параграфов подсчитываются методами канвы.
//
// Revision 1.1.4.200.2.7  2006/09/28 18:21:27  lulin
// - убрано перепривязывание параграфа к вью, т.к. это вроде как не нужно.
//
// Revision 1.1.4.200.2.6  2006/09/28 18:11:01  lulin
// - избавляемся от рекурсивной очистки отрисованных регионов.
//
// Revision 1.1.4.200.2.5  2006/09/28 17:56:59  lulin
// - разборки с переформатированием перенесены на вью.
//
// Revision 1.1.4.200.2.4  2006/09/28 17:41:02  lulin
// - не переформатируем списки параграфов, когда это не нужно.
//
// Revision 1.1.4.200.2.3  2006/09/22 13:39:37  lulin
// - разнес вычисление прямоугольника для листьевого и нелистьевого параграфов.
//
// Revision 1.1.4.200.2.2  2006/09/22 11:41:06  lulin
// - удален ненужный метод.
//
// Revision 1.1.4.200.2.1  2006/09/22 08:49:17  lulin
// - начинаем переводить отрисовку на использование карты форматирования.
//
// Revision 1.1.4.200  2006/09/22 06:01:32  oman
// - fix: VirtualCanvas переехал из afw в l3
//
// Revision 1.1.4.199  2006/09/21 06:30:37  lulin
// - bug fix: ползунок скроллера оставался внизу, после перехода на метку при открытии документа (CQ OIT5-22674).
//
// Revision 1.1.4.198  2006/09/20 11:07:01  lulin
// - bug fix: не появлялся горизонтальный скроллер (CQ OIT5-22309).
//
// Revision 1.1.4.197  2006/09/15 13:33:14  lulin
// - bug fix: в переходных процессах портилась позиция скроллера.
//
// Revision 1.1.4.196  2006/09/15 07:37:49  lulin
// - bug fix: при пребразованиях якорь<->курсор терялось форматирование текущего объекта.
//
// Revision 1.1.4.195  2006/08/02 10:52:00  lulin
// - объединил с веткой в которой боролся со скроллингом.
//
// Revision 1.1.4.194.2.6  2006/07/31 13:31:55  lulin
// - убран ненужный метод.
//
// Revision 1.1.4.194.2.5  2006/07/28 12:42:33  lulin
// - убран запил для строки реквизитов.
//
// Revision 1.1.4.194.2.4  2006/07/26 11:03:18  lulin
// - убран ненужный параметр.
//
// Revision 1.1.4.194.2.3  2006/07/26 10:27:57  lulin
// - вместо указателя на запись используем ссылку на интерфейс.
//
// Revision 1.1.4.194.2.2  2006/07/24 16:36:10  lulin
// - отрисовннный прямоугольник параграфа теперь тоже хранится в информации о форматировании.
//
// Revision 1.1.4.194.2.1  2006/07/24 16:23:59  lulin
// - теперь форматирование параграфа хранится в коллекции отрисованных элементов.
//
// Revision 1.1.4.194  2006/07/21 12:52:44  lulin
// - пытаемся переформатировать таблицу, пока неудачно...
//
// Revision 1.1.4.193  2006/07/21 09:44:29  lulin
// - теперь умеен находить элемент по поданной точке.
//
// Revision 1.1.4.192  2006/07/21 06:25:27  lulin
// - у вью появилась ссылка на данные.
//
// Revision 1.1.4.191  2006/07/20 19:14:54  lulin
// - с якоря убрана ответственность хранения значения позиции горизонтального скроллера.
//
// Revision 1.1.4.190  2006/07/20 12:55:48  lulin
// - имя метода убрано из комментариев - чтобы не находилось контекстным поиском.
//
// Revision 1.1.4.189  2006/07/19 15:50:26  lulin
// - переименован метод - в соответствии с его параметрами.
//
// Revision 1.1.4.188  2006/07/19 15:05:37  lulin
// - в функцию подготовки объекта для отрисовки теперь передаем _View_ для которого надо подготовить объект.
//
// Revision 1.1.4.187  2006/07/19 14:33:30  lulin
// - теперь для обновления прямоугольника вывода работаем с исходным объектом, а не с формой.
//
// Revision 1.1.4.186  2006/07/19 14:24:16  lulin
// - теперь для определения прямоугольника вывода работаем с исходным объектом, а не с формой.
//
// Revision 1.1.4.185  2006/07/19 09:46:35  lulin
// - bug fix: при изменении ширины окна не очищалась коллекция отрисованных параграфов.
//
// Revision 1.1.4.184  2006/07/17 17:28:00  lulin
// - стараемся уменьшить количество расчета абсолютного индекса при небольшом изменении параграфа верхнего угла редактора.
//
// Revision 1.1.4.183  2006/07/17 17:03:39  lulin
// - расчет абсолютного индекса переехал на View, т.к. большо он никому не нужен.
//
// Revision 1.1.4.182  2006/07/17 15:14:48  lulin
// - из комментариев убрано название метода - чтобы не искался контекстным поиском.
//
// Revision 1.1.4.181  2006/07/17 14:52:14  lulin
// - из комментариев убрано название метода - чтобы не искался контекстным поиском.
//
// Revision 1.1.4.180  2006/07/17 14:26:03  lulin
// - метод переименован в соответствии с тем, что он делает.
//
// Revision 1.1.4.179  2006/07/17 13:55:39  lulin
// - распиливаем один метод на два, т.к. комплексный метод практически не используется.
//
// Revision 1.1.4.178  2006/06/28 14:40:14  lulin
// - bug fix: не всегда скроллировались за картинку вверх.
//
// Revision 1.1.4.177  2006/06/21 11:19:20  lulin
// - bug fix: не скроллировались мышью ниже длинной картинки (CQ OIT5-21374).
//
// Revision 1.1.4.176  2006/06/20 11:15:38  lulin
// - bug fix: скроллер был не в самом низу, хотя конец документа был достигнут (CQ OIT5-21380).
//
// Revision 1.1.4.175  2006/06/13 17:29:16  lulin
// - перекладываем расчет и кеширование вертикальной позиции скроллера с якоря на View.
//
// Revision 1.1.4.174  2006/06/13 15:37:28  lulin
// - пытаемся избавится от излишних знаний на якоре, необходимых на самом деле только View.
//
// Revision 1.1.4.173  2006/06/08 13:37:57  lulin
// - подготавливаем контролы к обработке числа повторений нажатия клавиши.
//
// Revision 1.1.4.172  2006/06/06 11:22:18  oman
// - fix: В конце документа PgDn продолжал аккумулировать последние
//  страницы и требовалось столько же раз сделать PgUp чтобы
// сдвинутся с места (cq21212)
//
// Revision 1.1.4.171  2006/06/02 14:13:40  lulin
// - запоминаем верхний курсор во временную переменную.
//
// Revision 1.1.4.170  2006/06/02 13:54:43  lulin
// - не вычисляем два раза нижний курсор.
//
// Revision 1.1.4.169  2006/05/30 13:16:19  lulin
// - bug fix: на были синхронизированны движения на страницу вниз и на страницу вверх.
//
// Revision 1.1.4.168  2006/05/17 13:50:49  lulin
// - new behavior: если виден конец документа - ЯВНО говорим скроллеру, что он в самом низу.
//
// Revision 1.1.4.167  2006/05/16 14:06:48  lulin
// - cleanup.
//
// Revision 1.1.4.166  2006/05/16 13:12:30  lulin
// - bug fix: не появлялся скроллер при уменьшении высоты окна на маленьком тексте (ТС) (CQ OIT5-19850).
//
// Revision 1.1.4.165  2006/05/16 12:41:24  lulin
// - new behavior: более точно пытаемся вычислять размер страницы текста - исходя из количества отрисованных параграфов.
//
// Revision 1.1.4.164  2006/04/28 08:36:27  lulin
// - new behavior: подравниваем текст по левому краю экрана, если он целиком на экране умещается (CQ OIT5-20664).
//
// Revision 1.1.4.163  2006/04/18 09:03:04  lulin
// - bug fix: было AV при отрисовке информации о списке при его изменении (CQ OIT5-20506).
//
// Revision 1.1.4.162  2006/04/17 11:17:44  lulin
// - bug fix: неправильно рассчитывались координаты курсора из-за этого неправильно переходили по ссылке (CQ OIT5-20305).
//
// Revision 1.1.4.161  2006/03/31 09:16:29  lulin
// - new behavior: при контекстном поиске стараемся, чтобы и начало и конец блока были видны на экране.
//
// Revision 1.1.4.160  2006/03/08 15:02:25  lulin
// - bug fix: AV при Back из документа в список.
//
// Revision 1.1.4.159  2006/03/06 11:41:59  dinishev
// Remove warning
//
// Revision 1.1.4.158  2006/03/06 10:57:26  lulin
// - bug fix: не всегда вставлялись комментарии.
//
// Revision 1.1.4.157  2006/03/03 12:52:17  dinishev
// Bug fix: более корреткная реакция на изменение текста в контролах
//
// Revision 1.1.4.156  2006/03/02 13:25:05  lulin
// - теперь View не хранит ссылку на Shape, а получает его у контрола.
//
// Revision 1.1.4.155  2006/03/02 11:18:07  lulin
// - cleanup: View теперь не владеет курсором, а запрашивает его у контрола.
//
// Revision 1.1.4.154  2006/03/01 12:27:23  lulin
// - cleanup: избавляемся от обращения к нетипизированному Owner'у.
//
// Revision 1.1.4.153  2006/03/01 10:27:15  lulin
// - bug fix: при движении с Shift-ом не всегда изменялось выделение.
//
// Revision 1.1.4.152  2006/02/26 13:33:18  lulin
// - bug fix: неправильно подголся курсор по экрану в КЗ.
// - optimization: при подгонке курсора сначала пытаемся смещать верхний угол, и только потом, если не получилось - пытаемся ориентироваться на курсор.
//
// Revision 1.1.4.151  2006/02/21 07:48:58  lulin
// - cleanup.
//
// Revision 1.1.4.150  2006/02/20 18:07:19  lulin
// - new behavior: для определения верхнего угла отрисовки, при подгонке экрана под курсор, используем виртуальную канву.
//
// Revision 1.1.4.149  2006/02/17 19:03:35  lulin
// - cleanup.
//
// Revision 1.1.4.148  2006/02/17 18:48:49  lulin
// - выделен класс View для реальной отрисовки документа в пустоту.
//
// Revision 1.1.4.147  2006/02/17 18:21:43  lulin
// - выделен базовый View с возможностью отрисовки в пустоту.
//
// Revision 1.1.4.146  2006/02/17 15:02:49  lulin
// - начинаем выделять базовый View с возможностью отрисовки в пустоту.
//
// Revision 1.1.4.145  2006/02/17 14:39:14  lulin
// - cleanup.
//
// Revision 1.1.4.144  2006/02/17 14:23:59  lulin
// - cleanup.
//
// Revision 1.1.4.143  2006/02/17 08:10:05  mmorozov
// - change: сигнатура InevShapesPainted._VertScroll;
//
// Revision 1.1.4.142  2006/02/15 18:25:28  lulin
// - прикрутил скроллирование окна на основе коллекции отрисованных параграфов. Пока немного глючит.
//
// Revision 1.1.4.141  2006/02/14 15:26:07  lulin
// - вставлена начальная инициализация дельты.
//
// Revision 1.1.4.140  2006/02/14 15:02:58  lulin
// - вставлен вызов метода скроллирования коллекции отрисованных параграфов.
//
// Revision 1.1.4.139  2006/02/14 13:36:46  lulin
// - new behavior: не очищаем список отрисованных параграфов, если позиция скроллера реально не изменилась.
//
// Revision 1.1.4.138  2006/02/14 12:11:11  lulin
// - bug fix: редактор не перерисовывался при изменении позиции горизонтального скроллера.
//
// Revision 1.1.4.137  2006/02/14 10:51:53  lulin
// - откатил предыдущие изменения - чтобы ничего не испортить перед выпуском.
//
// Revision 1.1.4.136  2006/02/14 10:49:43  lulin
// - очищаем список отрисованных параграфов только если скроллер реально изменился.
//
// Revision 1.1.4.135  2006/02/10 15:19:54  lulin
// - не сигнализируем контролу, если позиция скроллера не изменилась.
//
// Revision 1.1.4.134  2006/02/09 15:10:40  lulin
// - cleanup.
//
// Revision 1.1.4.133  2006/02/07 11:54:12  lulin
// - bug fix: не исчезал вертикальный скролле (CQ OIT5-19420).
//
// Revision 1.1.4.132  2006/02/07 09:59:58  lulin
// - bug fix: при редактировании статьи словаря верхний параграф уезжал за экран - даже если был виден нижний (CQ OIT5-18141).
//
// Revision 1.1.4.131  2006/02/06 15:06:05  lulin
// - bug fix: падало при скроллинге, когда документ еще не загрузился (CQ OIT5-19491).
//
// Revision 1.1.4.130  2006/02/03 15:41:54  lulin
// - не даем скроллировать скроллером за пределы документа.
//
// Revision 1.1.4.129  2006/02/03 14:56:00  lulin
// - bug fix: избавился от неадекватного поведения скроллера в КЗ (CQ OIT5-19361).
//
// Revision 1.1.4.128  2006/01/24 14:15:56  lulin
// - cleanup.
//
// Revision 1.1.4.127  2006/01/24 13:58:34  lulin
// - bug fix: после поиска по тексту выделенный фрагмент не был виде целиком (CQ OIT5-19183).
//
// Revision 1.1.4.126  2006/01/24 12:54:13  lulin
// - cleanup.
//
// Revision 1.1.4.125  2006/01/23 17:44:00  lulin
// - cleanup.
//
// Revision 1.1.4.124  2006/01/23 17:31:57  lulin
// - bug fix: избавляемся от паразитного горизонтального скроллера в КЗ.
//
// Revision 1.1.4.123  2006/01/23 12:40:45  lulin
// - bug fix: не всегда появлялся и не всегда исчезал горизонтальный скроллер.
//
// Revision 1.1.4.122  2006/01/19 15:15:07  lulin
// - bug fix: неправильно скроллировались по горизонтали при переходе курсором вверх.
//
// Revision 1.1.4.121  2006/01/19 13:37:48  lulin
// - new behavior: скроллируем редактор в 0 - если курсор помещается в ширину контрола.
//
// Revision 1.1.4.120  2006/01/19 13:16:45  lulin
// - bug fix: при контекстном поиске редактор неправильно скроллировался по горизонтали - найденного фрагмента не было видно (CQ OIT5-19183).
//
// Revision 1.1.4.119  2006/01/18 13:21:20  lulin
// - bug fix: не скроллируем документ вправо, если горизонтального скроллера нету (CQ OIT5-19149).
//
// Revision 1.1.4.118  2006/01/13 16:57:37  lulin
// - bug fix: не всегда правильно скроллировались по горизонтали.
//
// Revision 1.1.4.117  2006/01/13 15:12:56  lulin
// - выделен локальный метод, чтобы избежать лишней секции try.
//
// Revision 1.1.4.116  2006/01/13 14:40:26  lulin
// - скроллируем окно, если курсор находится правее видимой области.
//
// Revision 1.1.4.115  2006/01/13 14:14:05  lulin
// - скроллируем окно, если курсор находится левее видимой области.
//
// Revision 1.1.4.114  2006/01/13 11:12:02  lulin
// - корректнее вычисляем горизонтальную позицию курсора в дюймах.
//
// Revision 1.1.4.113  2005/12/15 12:24:24  lulin
// - bug fix: при зажатой клавише PgUp/PgDn не обновлялся экран редактора.
//
// Revision 1.1.4.112  2005/12/12 15:50:22  lulin
// - и в четвертый раз починил проблему с провисшей ссылкой :-(.
//
// Revision 1.1.4.111  2005/12/08 17:40:36  lulin
// - bug fix: в 3-й раз починил циклические ссылки между объектами.
// - bug fix: висло при Back по истории - т.к. циклически создавался контейнер документа.
//
// Revision 1.1.4.110  2005/12/05 11:15:42  lulin
// - bug fix: все падало при подгрузке документа из потока - из за того, что пытались рекурсивно войти в процедуру отрисовки.
//
// Revision 1.1.4.109  2005/11/29 11:56:00  lulin
// - bug fix: не привязывали новый документ ко View.
//
// Revision 1.1.4.108  2005/11/28 15:59:10  lulin
// - bug fix: не скроллируем если курсор уже и так на экране.
//
// Revision 1.1.4.107  2005/11/23 15:25:36  lulin
// - bug fix: провисала ссылка на уже освобожденный объект.
//
// Revision 1.1.4.106  2005/11/23 10:29:49  lulin
// - bug fix: оставался ненужный горизонтальный скроллер.
//
// Revision 1.1.4.105  2005/11/21 05:50:03  lulin
// - виртуальная канва перенесена в отдельный модуль.
//
// Revision 1.1.4.104  2005/11/10 19:57:51  lulin
// - откатил предыдущие изменения - т.к. прыгал скроллер.
//
// Revision 1.1.4.102  2005/11/10 09:39:23  lulin
// - снимаем копию прадыдущего якоря.
//
// Revision 1.1.4.101  2005/11/08 17:06:36  lulin
// - bug fix: после  back портилась КЗ (CQ OIT5-17846).
// - были утечки объектов в той же ситуации (!!!). См. письмо в debates.
//
// Revision 1.1.4.100  2005/11/08 15:06:29  lulin
// - new behavior: запрещаем скроллировать горизонтальным скроллером за пределами документа.
//
// Revision 1.1.4.99  2005/11/08 11:42:11  lulin
// - bug fix: при движении курсора не снималось выделение (CQ OIT5-17691).
//
// Revision 1.1.4.98  2005/11/04 14:34:11  lulin
// - выделяем у якоря и у курсора общую функциональность.
//
// Revision 1.1.4.97  2005/11/04 12:45:59  lulin
// - optimization: избавился от необходимости расчета _AbsIndex если якорь документа находится в самом начале или в самом конце.
//
// Revision 1.1.4.96  2005/11/04 10:04:02  lulin
// - optimization: избавился от необходимости расчета _AbsIndex при листании по странице вниз.
//
// Revision 1.1.4.95  2005/11/03 09:53:43  lulin
// - new behavior: не даем скроллировать вверх, если конец документа уже виден.
//
// Revision 1.1.4.94  2005/11/03 09:28:47  lulin
// - оптимизированно скроллирование с клавиатуры по одной строке.
//
// Revision 1.1.4.93  2005/11/03 07:49:53  lulin

// - bug fix: при переходных процессах визуализации курсора лишний раз считался _AbsIndex верхнего параграфа.
//
// Revision 1.1.4.92  2005/11/03 07:15:54  lulin
// - оптимизируем скроллирование документа с клавиатуры (CQ OIT5-17499).
//
// Revision 1.1.4.91  2005/11/02 13:19:07  lulin
// - не пересчитываем шрифт при смене выделения, будем потом пересчитывать его on-demand (CQ OIT5-17495).
//
// Revision 1.1.4.90  2005/10/28 10:17:39  lulin
// - bug fix: был AV из-за того, что были перепутаны типы.
//
// Revision 1.1.4.89  2005/10/28 09:32:29  lulin
// - bug fix: не очищали список страниц при навигации курсором.
//
// Revision 1.1.4.88  2005/10/28 07:34:26  lulin
// - new behavior: горизонтальный скроллер теперь рассчитывается исходя из реально отрисованных размеров параграфов.
//
// Revision 1.1.4.87  2005/10/26 15:17:04  lulin
// - bug fix: при обработке PageUp/PageDown изменялся только _Top, а курсор оставался на месте.
//
// Revision 1.1.4.86  2005/10/26 11:11:19  lulin
// - объекты теперь создают немодифицуруемые якоря. Для их модификации надо применять метод Modify.
//
// Revision 1.1.4.85  2005/10/25 13:43:41  lulin
// - подготавливаем _preview к корректному расчету первого параграфа следующей страницы.
//
// Revision 1.1.4.84  2005/10/25 13:09:22  lulin
// - выделен общий предок для View.
//
// Revision 1.1.4.83  2005/10/25 11:59:47  lulin
// - cleanup.
//
// Revision 1.1.4.82  2005/10/25 11:05:51  lulin
// - не получаем напрямую информационную канву экрана, а получаем ее через фасад.
//
// Revision 1.1.4.81  2005/10/25 09:50:00  lulin
// - корректнее обрабатываем повторный вход в процедуру рисования объекта.
//
// Revision 1.1.4.80  2005/10/24 12:36:47  lulin
// - bug fix: неправильно подгоняли экран по курсору - если курсор был ниже экрана.
//
// Revision 1.1.4.79  2005/10/10 06:24:51  lulin
// - bug fix: не перерисовывались иконки на панели Sub'ов при back.
// - bug fix: Back/Forward в документе не восстанавливали позицию (если переход был локальным).
//
// Revision 1.1.4.78  2005/10/04 11:31:21  lulin
// - bug fix: при поиске с начала документа, после поиска до конца текста, переставал показываться найденный фрагмент.
//
// Revision 1.1.4.77  2005/09/30 09:21:13  lulin
// - bug fix: после листания скроллером по страницам вниз блокировался любой другой скроллинг.
//
// Revision 1.1.4.76  2005/09/23 16:04:04  lulin
// - выделен модуль с общими интерфейсами.
//
// Revision 1.1.4.75  2005/09/22 12:37:21  lulin
// - bug fix: после back не работали переходы по ссылкам.
//
// Revision 1.1.4.74  2005/09/22 10:16:52  lulin
// - bug fix: не совсем точно работал Ctrl-Enter.
//
// Revision 1.1.4.73  2005/09/20 07:08:36  lulin
// - задел на корректное переформатирование ячеек таблиц, после уменьшения размеров внутренних параграфов.
//
// Revision 1.1.4.72  2005/09/19 11:05:16  lulin
// - bug fix: PageUp работало не так как PageDown.
//
// Revision 1.1.4.71  2005/09/19 09:10:30  lulin
// - bug fix: ползунок скроллера не соответствовал действительности.
//
// Revision 1.1.4.70  2005/09/19 05:41:32  lulin
// - bug fix: неправильно работал PageDown если уже достигли конца документа.
//
// Revision 1.1.4.69  2005/09/14 11:06:17  lulin
// - bug fix: пропадал скроллер.
//
// Revision 1.1.4.68  2005/09/14 10:53:43  lulin
// - bug fix: пропадал скроллер.
//
// Revision 1.1.4.67  2005/09/12 13:15:50  lulin
// - bug fix: на маленьких документах был вертикальный скроллер.
//
// Revision 1.1.4.66  2005/09/12 10:09:51  lulin
// - восстановлено рисование черточки внизу документа.
//
// Revision 1.1.4.65  2005/09/12 08:23:04  lulin
// - bug fix: перемещение курсора с клавиатуры не всегда обновляло каретку в окне редактора.
//
// Revision 1.1.4.64  2005/09/12 08:10:46  lulin
// - bug fix: неправильно работала обработка клавиатуры для перемещения на строку вверх/вниз.
//
// Revision 1.1.4.63  2005/09/12 06:04:21  lulin
// - bug fix: не правильно позиционировались в начало и конец документа при помощи клавиатуры.
//
// Revision 1.1.4.62  2005/09/09 15:47:25  lulin
// - при редактировании текста не перерисовываем все окно - если высота параграфа не изменилась - сильно помогло с вводом в КЗ.
//
// Revision 1.1.4.61  2005/09/01 11:29:45  lulin
// - список спрятанных стилей теперь известен View.
//
// Revision 1.1.4.60  2005/07/21 05:27:44  lulin
// - обеспечена возможность повторного входа в процедуру отрисовки, без потери ресурсов.
//
// Revision 1.1.4.59  2005/07/20 12:48:35  lulin
// - bug fix: забывали запомнить предыдущее значение размера контрола.
//
// Revision 1.1.4.58  2005/07/20 12:41:07  lulin
// - bug fix: не падаем при повтором входе в процедуру рисовани - когда она вызвалась из-за дозагрузки документа.
//
// Revision 1.1.4.57  2005/07/20 12:22:59  lulin
// - new behavior: скорость скроллера вверх теперь также зависит от того насколько далеко находится курсор за пределами окна.
//
// Revision 1.1.4.56  2005/07/20 12:11:22  lulin
// - new behavior: скорость скроллера теперь зависит от того насколько далеко находится курсор за пределами окна.
//
// Revision 1.1.4.55  2005/07/19 15:32:27  lulin
// - убрана часть обращений к интересующим интерфейсам через цепочку Parent'ов диапазонов и курсоров.
//
// Revision 1.1.4.54  2005/07/15 15:45:33  lulin
// - new behavior: перерисовываем строки параграфов, через _InevSimpleView.
//
// Revision 1.1.4.53  2005/07/15 13:56:07  lulin
// - new behavior: перерисовываем параграфы, через _InevSimpleView.
//
// Revision 1.1.4.52  2005/07/11 13:17:35  lulin
// - bug fix: слишком рано начинали скроллировать окно.
//
// Revision 1.1.4.51  2005/07/11 09:49:29  lulin
// - bug fix: при скроллировании окна по курсору текст уезжал по горизонтали.
//
// Revision 1.1.4.50  2005/07/08 12:50:13  lulin
// - bug fix: при скроллировании окна по курсору съезжала координата X.
//
// Revision 1.1.4.49  2005/07/08 09:45:33  lulin
// - используем коллекцию отрисованных параграфов для определения прямоугольника с параграфом.
//
// Revision 1.1.4.48  2005/07/07 17:29:25  lulin
// - new method: InevView._ShapeRect.
//
// Revision 1.1.4.47  2005/07/07 17:15:48  lulin
// - InevAnchor и InevViewPoint теперь наследуются от InevLocation.
//
// Revision 1.1.4.46  2005/07/07 16:54:05  lulin
// - cleanup.
//
// Revision 1.1.4.45  2005/07/07 15:38:07  lulin
// - InevViewPoint теперь не наследуется от InevAnchor.
//
// Revision 1.1.4.44  2005/07/07 14:25:34  lulin
// - new behavior: InevViewPoint теперь отдает точные координаты курсора внутри параграфа, не обращая внимания на Position.
//
// Revision 1.1.4.43  2005/07/07 13:58:23  lulin
// - спрятана возможность получения от View координат якоря в точках.
//
// Revision 1.1.4.42  2005/07/07 13:30:33  lulin
// - спрятана возможность прямой модификации _TopAnchor.
//
// Revision 1.1.4.41  2005/07/07 13:09:31  lulin
// - упорядочены названия интерфейсов.
//
// Revision 1.1.4.40  2005/07/05 16:02:46  lulin
// - bug fix: восстановлен скроллинг при выделении текста мышью.
//
// Revision 1.1.4.39  2005/07/01 15:06:53  lulin
// - используем возможность попросить самый вложенный параграф.
//
// Revision 1.1.4.38  2005/07/01 14:44:05  lulin
// - bug fix: не сбрасывали нижний якорь при изменении размеров контрола.
//
// Revision 1.1.4.37  2005/07/01 14:10:02  lulin
// - bug fix: защищаемся от AV при отсутствии информации о отрисованных параграфах.
//
// Revision 1.1.4.36  2005/07/01 13:30:54  lulin
// - для определения нижней точки окна пользуемся коллекцией отрисованных параграфов.
//
// Revision 1.1.4.35  2005/07/01 12:50:20  lulin
// - для определения курсора пользуемся коллекцией отрисованных параграфов.
//
// Revision 1.1.4.34  2005/06/30 14:13:53  lulin
// - очищаем Shapes при полной отрисовке окна редактора.
//
// Revision 1.1.4.33  2005/06/30 11:31:17  mmorozov
// new behaviour: TnevView свой InevShapesPainted, а не глобальный;
//
// Revision 1.1.4.32  2005/06/30 09:30:20  mmorozov
// new: использование коллекции отрисованных параграфов (nevShapesPainted);
//
// Revision 1.1.4.31  2005/06/29 12:21:26  lulin
// - new prop: InevROParaList._AlmostLinear.
//
// Revision 1.1.4.30  2005/06/29 11:51:07  lulin
// - метод InevAnchor._IncLine получил параметр - определяющий длинное или короткое перемещение предполагается.
//
// Revision 1.1.4.29  2005/06/29 10:30:21  lulin
// - введен собственный тип для множества скроллбар'ов - чтобы не такскать везде это виндовое уродство.
//
// Revision 1.1.4.28  2005/06/29 07:35:04  lulin
// - с var параметра перешел на возвращаемое значение.
//
// Revision 1.1.4.27  2005/06/28 16:08:09  lulin
// - new behavior: скроллер теперь скроллирует почти правильно по общему числу параграфов (осталось только нижний конец обработать).
//
// Revision 1.1.4.26  2005/06/28 13:43:35  lulin
// - new behavior: считаем размер страницы не в строках, а в параграфах.
//
// Revision 1.1.4.25  2005/06/28 12:00:17  lulin
// - new behavior: теперь _AbsIndex подсчитывается рекурсивно исходя из информации дочерних курсоров.
//
// Revision 1.1.4.24  2005/06/28 10:29:14  lulin
// - new behavior: теперь контрол инициализирует свой скроллер исходя из параметров соответствующего скроллера от View.
//
// Revision 1.1.4.23  2005/06/27 14:16:49  lulin
// - new behavior: для вертикального скроллера используем AllChildrenCount.
//
// Revision 1.1.4.22  2005/06/25 14:25:01  lulin
// - new behavior: View теперь умеет контроллировать изменение размеров скроллера и сообщать об этом контролу.
//
// Revision 1.1.4.21  2005/06/25 12:19:48  lulin
// - bug fix: при таскании за ползунок скроллер пытался скроллировать не в ту сторону.
//
// Revision 1.1.4.20  2005/06/23 15:16:02  lulin
// - new behavior: теперь View может обладать контекстом форматирования, который используется при форматирования параграфа при его отрисовке.
//
// Revision 1.1.4.19  2005/06/22 15:00:59  lulin
// - убран метод перемещающий якорь на абсолютное смещение.
//
// Revision 1.1.4.18  2005/06/22 14:08:33  lulin
// - new behavior: при смещении скроллера в самый верх просто строим новый якорь.
//
// Revision 1.1.4.17  2005/06/21 14:54:36  lulin
// - new method: InevView._ShapeByPt.
//
// Revision 1.1.4.16  2005/06/21 14:18:09  lulin
// - new methods: InevView._BeginDrawShape, _EndDrawShape.
//
// Revision 1.1.4.15  2005/06/21 12:03:01  lulin
// - new behavior: View во время отрисовки держит ссылку на канву, на которой рисует.
//
// Revision 1.1.4.14  2005/06/20 15:42:14  lulin
// - cleanup: избавляемся от абсолютных координат.
//
// Revision 1.1.4.13  2005/06/16 11:24:18  lulin
// - убрана косвенная типизация параграфов (при помощи _QI и QT).
//
// Revision 1.1.4.12  2005/06/15 13:06:03  lulin
// - убрана инициализация блоков выделения в явном виде.
//
// Revision 1.1.4.11  2005/06/11 12:13:46  lulin
// - убраны излишние зависимости между объектами.
//
// Revision 1.1.4.10  2005/06/11 11:56:50  lulin
// - уменьшаем количество получения необходимых интерфейсов косвенно (через _QI).
//
// Revision 1.1.4.9  2005/06/10 16:43:55  lulin
// - new behavior: сразу прячем каретку, если курсор не на экране.
//
// Revision 1.1.4.8  2005/06/10 12:54:36  lulin
// - cleanup: у редактора убрано знание про верхнюю позицию скроллирования.
//
// Revision 1.1.4.7  2005/06/10 09:38:05  lulin
// - bug fix: некорректно перечитывали новый документ.
//
// Revision 1.1.4.6  2005/06/09 17:20:27  lulin
// - более чувствительно проверяем выход курсора за нижнюю границу экрана.
//
// Revision 1.1.4.5  2005/06/09 16:35:26  lulin
// - позиционируем якорь по курсору.
//
// Revision 1.1.4.4  2005/06/09 16:12:03  lulin
// - задел на то, чтобы подгонять видимую часть документа по каретке.
//
// Revision 1.1.4.3  2005/06/08 13:55:26  lulin
// - new prop: InevScrollView._TopAnchor.
//
// Revision 1.1.4.2  2005/05/27 12:05:59  lulin
// - убраны лишние зависимости.
//
// Revision 1.1.4.1  2005/05/18 12:43:00  lulin
// - отвел новую ветку.
//
// Revision 1.1.2.15  2005/04/14 16:15:42  lulin
// - вычищен код, связанный с отрисовкой по абсолютным координатам.
//
// Revision 1.1.2.14  2005/04/14 15:14:33  lulin
// - сделана специальная процедура мещения якоря "по строкам".
//
// Revision 1.1.2.13  2005/04/14 12:48:55  lulin
// - более правильно уходим от рекурсии.
//
// Revision 1.1.2.12  2005/04/14 12:01:27  lulin
// - добавлена константа.
//
// Revision 1.1.2.11  2005/04/14 10:30:15  lulin
// - сделана возможность привязывать каретку к View.
//
// Revision 1.1.2.10  2005/04/14 10:13:50  lulin
// - new interfaces: InevSelectionView, InevInputView.
//
// Revision 1.1.2.9  2005/04/14 09:30:36  lulin
// - вся логика спущена в базовый класс якоря.
//
// Revision 1.1.2.8  2005/04/13 10:30:04  lulin
// - new behavior: используем _Top от View.
//
// Revision 1.1.2.7  2005/04/13 10:20:02  lulin
// - cleanup.
//
// Revision 1.1.2.6  2005/04/12 14:31:23  lulin
// - new methods: InevAnchorEx._LinkView, _UnlinkView.
//
// Revision 1.1.2.5  2005/04/12 14:14:38  lulin
// - new interface: InevAnchorEx.
//
// Revision 1.1.2.4  2005/04/12 13:47:30  lulin
// - убрано использование хитрой точки для рисования.
//
// Revision 1.1.2.3  2005/04/12 13:22:31  lulin
// - рисование параграфов частично переведено на InevAnchor.
//
// Revision 1.1.2.2  2005/04/12 11:04:36  lulin
// - new behavior: инициализируем _Top при подключении View к контролу.
//
// Revision 1.1.2.1  2005/04/12 10:18:47  lulin
// - новые файлы переехали в новый каталог.
//
// Revision 1.1.2.14  2005/04/12 09:26:06  lulin
// - борьба с циклическими ссылками.
//
// Revision 1.1.2.13  2005/04/12 09:13:20  lulin
// - new interface: InevAnchor.
//
// Revision 1.1.2.12  2005/04/12 08:23:00  lulin
// - горизонтальный скроллер также переключен на View.
//
// Revision 1.1.2.11  2005/04/12 07:58:08  lulin
// - new behavior: созвращена возможность таскать скроллер (на больших документах пока выглядит ужасно).
//
// Revision 1.1.2.10  2005/04/11 18:53:45  lulin
// - new interface: InevCaret.
//
// Revision 1.1.2.9  2005/04/11 17:53:22  lulin
// - new behavior: поддержка колеса мыши и синхронизация со скроллером собственно окна.
//
// Revision 1.1.2.8  2005/04/11 17:37:13  lulin
// - примитивная реализация скроллера, стоящего отдельно от собственно окна редактирования.
//
// Revision 1.1.2.7  2005/04/11 16:52:28  lulin
// - new interface: InevScroller.
//
// Revision 1.1.2.6  2005/04/11 16:31:34  lulin
// - new methods: IevScrollView.LinkShape, UnlinkShape.
//
// Revision 1.1.2.5  2005/04/11 16:06:16  lulin
// - new type: TnevFrame.
//
// Revision 1.1.2.4  2005/04/11 15:25:45  lulin
// - new interface: IevScrollView.
//
// Revision 1.1.2.3  2005/04/11 13:53:13  lulin
// - new prop: InevViewMetrics.ShowDocumentParts.
//
// Revision 1.1.2.2  2005/04/11 11:24:49  lulin
// - new interface: InevViewMetrics.
//
// Revision 1.1.2.1  2005/04/09 14:20:32  lulin
// - new interfaces: InevView, InevControl, _InevLinkedShape.
//

{$Include nevDefine.inc }

interface

uses
  l3Types,
  l3Base,
  l3CacheableBase,

  evdStyles,

  nevBase,
  nevTools,
  nevBaseDrawView,
  nevBasePointList
  ;

type
  TnevView = class;

  TnevViewControl = class(Tl3CacheableBase, InevViewControl)
    private
    // internal fields
      f_View : TnevView;
    protected
    // interface methods
      // InevViewControl
      procedure Top;
        virtual;
        {-}
      procedure Bottom;
        virtual;
        {-}
      procedure PageUp;
        virtual;
        {-}
      function  PageDown: Boolean;
        virtual;
        {-}
      procedure LineUp(aCount : Integer);
        virtual;
        {-}
      procedure LineDown(aCount : Integer);
        virtual;
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
  end;//TnevViewControl

  TnevScroller = class(TnevViewControl, InevScroller)
    protected
    // interface methods
      // InevScroller
      function  Min: Integer;
        {-}
      function  Max: Integer;
        virtual;
        abstract;
        {-}
      function  Page: Integer;
        virtual;
        abstract;
        {-}
      function  Pos: Integer;
        virtual;
        abstract;
        {-}
      function  ScrollTo(aPosition: Integer): Boolean;
        virtual;
        abstract;
        {-}
      function  IncTop(const aDelta: TnevPoint): Boolean;
        virtual;
        abstract;
        {-}
      procedure Top;
        override;
        {-}
      procedure Bottom;
        override;
        {-}
      procedure PageUp;
        override;
        {-}
      function  PageDown: Boolean;
        override;
        {-}
      procedure LineUp(aCount : Integer);
        override;
        {-}
      procedure LineDown(aCount : Integer);
        override;
        {-}
      function  WheelMul: Integer;
        {-}
      procedure WheelUp;
        virtual;
        {-}
      procedure WheelDown;
        virtual;
        {-}
      procedure EndScroll;
        virtual;
        {-}
      procedure ResetPos(aTopDiff  : Integer);
        virtual;
        {-}  
    public
    // public methods
      class function Make: InevScroller;
        {-}
  end;//TnevScroller

  TnevCaret = class(TnevViewControl, InevCaret)
    protected
    // interface methods
      // InevCaret
      procedure Home;
        {-}
      procedure EndLine;
        {-}
    protected
    // internal methods
      procedure ClearPages;
        {-}
      function MoveCaret(aCode: Integer; aCount: Integer): Boolean;
        {-}  
      procedure Top;
        override;
        {-}
      procedure Bottom;
        override;
        {-}
      procedure PageUp;
        override;
        {-}
      function  PageDown: Boolean;
        override;
        {-}
      procedure LineUp(aCount : Integer);
        override;
        {-}
      procedure LineDown(aCount : Integer);
        override;
        {-}
  end;//TnevCaret

  TnevView = class(TnevBaseDrawView,
                   InevScrollView,
                   InevSelectionView,
                   InevInputView)
    private
    // internal fields
      f_Scroll           : array [Boolean] of TnevScroller;
      f_Caret            : TnevCaret;
      f_LastHeight       : Integer;
      f_LastPageHeight   : Integer;
      f_LastTailVisible  : Boolean;
      f_LastControlWidth : Integer;
      f_LastMaxWidth     : Integer;
      f_InMakeVisible    : Boolean;
      f_PointToShow      : InevBasePoint;
      f_StartToShow      : InevBasePoint;
      f_HorzDelta        : Integer;
    protected
    // interface methods
      // InevSimpleView
      procedure DoInvalidateShape(const aShape      : InevObject;
                                  aParts : TnevShapeParts);
        override;
        {-}
      // InevScrollView
      function  pm_GetScroller(aVert: Boolean): InevScroller;
        {-}
      function  GetCanvas(const anExtent: TnevPoint): InevCanvas;
        override;
        {-}
      function  DoDraw(const aBlock : InevRange;
                       var theMap   : InevMap): Boolean;
        override;             
        {-}
      // InevSelectionView  
      function  pm_GetMousePos: TnevPoint;
        {-}
      function  pm_GetAllowMultiSelect: Boolean;
        {-}
      // InevInputView
      function  pm_GetCaret: InevCaret;
        {-}
      function  InMakeCaretVisible: Boolean;
        {-}
      procedure MakeCaretVisible;
        {-}
      procedure ClearPointToShow;
        {-}
      function  MakePointVisible(const aPoint: InevBasePoint): Boolean;
        {-}
      procedure MakePairVisible(const aStart, aFinish: InevBasePoint);
        {-}  
      function  IsCaretVisible: Boolean;
        {-}
      function PartiallyVisible(const aPoint     : InevBasePoint;
                                const aTopAnchor : InevAnchor;
                                const aFI        : TnevFormatInfoPrim): Boolean;
        {* - Проверка на частично видимую точку. }
      function CheckTableCursor(const aPoint        : InevBasePoint;
                                 const aBottomAnchor: InevAnchor): Boolean;
    protected
    // internal methods
        {* - Возвращает пул виртульаных View. }
      function  CaretCursor: InevBasePoint;
        override;
        {-}
      procedure DoSignalScroll(aTopDiff : Integer;
                               aDeltaY  : Integer);
        override;
        {-}
      function  MaxWidth: Integer;
        {-}
      procedure CheckScrollers;
        {-}
      procedure ClearShapesPrim;
        override;
        {* - очищает список отображаемых форм. }
      function  LMargin: Integer;
        override;
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(const aControl: InevControl; aHorzDelta: Integer);
        reintroduce;
        {-}
      class function Make(const aControl: InevControl; aHorzDelta: Integer): InevInputView;
        reintroduce;
        {-}
    public
    // public properties
      property LimitWidth: TnevInch
        read pm_GetLimitWidth;
        {-}
      property Scroller[aVert: Boolean]: InevScroller
        read pm_GetScroller;
        {-}
      property Caret: InevCaret
        read pm_GetCaret;
        {-}
  end;//TnevView

  TnevHScroller = class(TnevScroller)
    private
    // internal fields
      f_XOfs : Integer;
    protected
    // internal methods
      function  Page: Integer;
        override;
        {-}
      function  Max: Integer;
        override;
        {-}
      function  Pos: Integer;
        override;
        {-}
      function  ScrollTo(aPosition: Integer): Boolean;
        override;
        {-}
      procedure Bottom;
        override;
        {-}
      function  IncTop(const aDelta: TnevPoint): Boolean;
        override;
        {-}
      procedure Cleanup;
        override;
        {-}
  end;//TnevHScroller

  TnevVScroller = class(TnevScroller)
    private
    // internal fields
      f_LastPages : TnevBasePointList;
      f_Pos       : Integer;
      f_Lock      : Integer;
    protected
    // internal methods
      function  Page: Integer;
        override;
        {-}
      function  Max: Integer;
        override;
        {-}
      function  Pos: Integer;
        override;
        {-}
      function  ScrollTo(aPosition: Integer): Boolean;
        override;
        {-}
      function  IncTop(const aDelta: TnevPoint): Boolean;
        override;
        {-}
      procedure PageUp;
        override;
        {-}
      function  PageDown: Boolean;
        override;
        {-}
      procedure ResetPos(aTopDiff  : Integer);
        override;
        {-}
      procedure MakePointVisible(const aTop   : InevAnchor;
                                 const aPoint : InevBasePoint);
        {-}
      procedure Cleanup;
        override;
        {-}
  end;//TnevVScroller

implementation

uses
  Windows,

  SysUtils,

  ElTools,

  l3Const,
  l3Units,
  l3MinMax,

  k2Tags,
  k2OpMisc,

  afwInterfaces,

  evInternalInterfaces,
  evOp,
  evMsgCode,
  evConst,

  nevFacade,
  nevMeasureView,

  {$IFDEF nsTest}
  nevVScrollerSpy,
  {$ENDIF nsTest}

  evParaTools
  ;

// start class TnevView

constructor TnevView.Create(const aControl: InevControl; aHorzDelta: Integer);
  //reintroduce;
  {-}
begin
 inherited Create;
 LinkControl(aControl);
 f_HorzDelta := aHorzDelta;
end;

class function TnevView.Make(const aControl: InevControl; aHorzDelta: Integer): InevInputView;
  //reintroduce;
  {-}
var
 l_View : TnevView;
begin
 l_View := Create(aControl, aHorzDelta);
 try
  Result := l_View;
 finally
  l3Free(l_View);
 end;//try..finally
end;

procedure TnevView.Cleanup;
  //override;
  {-}
begin
 inherited;
 f_PointToShow := nil;
 f_StartToShow := nil;
 f_LastMaxWidth := 0;
 f_LastHeight := 0;
 if (f_Caret <> nil) then
  f_Caret.f_View := nil;
 l3Free(f_Caret);
 if (f_Scroll[false] <> nil) then
  f_Scroll[false].f_View := nil;
 l3Free(f_Scroll[false]);
 if (f_Scroll[true] <> nil) then
  f_Scroll[true].f_View := nil;
 l3Free(f_Scroll[true]);
end;

function TnevView.LMargin: Integer;
  //override;
  {-}
begin
 if (f_Scroll[false] = nil) then
  Result := 0
 else
  Result := f_Scroll[false].Pos;
end;

procedure TnevView.ClearShapesPrim;
  //override;
  {* - очищает список отображаемых форм. }
begin
 DoClearShapes((f_LastControlWidth <> ViewExtent.X));
end;

function TnevView.MaxWidth: Integer;
  {-}
begin
 Result := ShapesPainted.MaxWidth + ControlLMargin;
end;

procedure TnevView.CheckScrollers;
  {-}

 procedure CheckVert;

  procedure SignalVert;
  begin//SignalVert
   if (pm_GetControl <> nil) then
    pm_GetControl.UpdateScrollRange([afw_sbVert]);
  end;//SignalVert

 var
  l_Height : Integer;
  l_Page   : Integer;
 begin//CheckVert
  l_Height := Shape.ToList.LeafShapeCount;
  l_Page := ShapesPainted.SubShapesCount;
  if (f_LastHeight <> l_Height) OR (f_LastPageHeight <> l_Page) then
  begin
   f_LastHeight := l_Height;
   f_LastPageHeight := l_Page;
   SignalVert;
  end//f_LastHeight <> l_Height
  else
  if (f_LastTailVisible <> IsDocumentTailVisible) then
  begin
   f_LastTailVisible := not f_LastTailVisible;
   if (f_Scroll[true] <> nil) then
    f_Scroll[true].ResetPos(0);
   SignalVert;
  end;//f_LastTailVisible <> IsDocumentTailVisible
 end;//CheckVert

var
 l_Extent : TnevPoint;
 l_Pt     : InevBasePoint;
begin
 if (Shape <> nil) then
 begin
  if (pm_GetControl <> nil) then
  begin
   l_Extent := ViewExtent;
   if (f_LastControlWidth <> l_Extent.X) then
    f_LastMaxWidth := 0;
   f_LastControlWidth := l_Extent.X;
  end;//pm_GetControl <> nil
  CheckVert;
  if (f_LastMaxWidth <> Self.MaxWidth) then
  begin
   f_LastMaxWidth := Self.MaxWidth;
   if (pm_GetControl <> nil) then
    pm_GetControl.UpdateScrollRange([afw_sbHorz]);
  end;//f_LastMaxWidth <> ShapesPainted.MaxWidth
  if (f_StartToShow <> nil) then
  begin
   l_Pt := f_StartToShow;
   f_StartToShow := nil;
   MakePointVisible(l_Pt);
  end;//f_StartToShow <> nil
  if (f_PointToShow <> nil) then
  begin
   l_Pt := f_PointToShow;
   f_PointToShow := nil;
   MakePointVisible(l_Pt);
  end;//f_PointToShow <> nil
 end;//Shape <> nil
end;

procedure TnevView.DoSignalScroll(aTopDiff : Integer;
                                  aDeltaY  : Integer);
  //override;
  {-}
begin
 if (f_Scroll[true] <> nil) then
  f_Scroll[true].ResetPos(aTopDiff);
 if (pm_GetControl <> nil) then
 begin
  if f_LastTailVisible AND ((pm_GetTopAnchor = nil) OR pm_GetTopAnchor.AtStart) then
   f_LastTailVisible := false;
  pm_GetControl.SignalScroll(aDeltaY, true);
 end;//pm_GetControl <> nil
end;

procedure TnevView.DoInvalidateShape(const aShape      : InevObject;
                                     aParts : TnevShapeParts);
  {-}
var
 //l_FI  : TnevFormatInfoPrim;
 l_Map : InevMap;
 //l_Obj : InevObject;
 //l_H   : Integer;
begin
 inherited;
 if (aShape <> nil) AND (pm_GetControl <> nil) then
 begin
  l_Map := MapByPoint(aShape.MakePoint, True);
  if (l_Map = nil) then
  begin
   // Если мапу не нашли и сменилось форматирование очищаем коллекцию отрисованных
   // Чиним К-78938187 ЦК27870
   if (nev_spExtent in aParts) then
    DoClearShapes(True);
   pm_GetControl.ViewArea.Invalidate;
  end
  else
  begin
   if (nev_spExtent in aParts) then
   begin
    if aShape.IsList then
    begin
     Assert(false);
     // - ловим когда это случится
(*     ClearShapes;
     pm_GetControl.ViewArea.Invalidate;*)
    end//aShape.IsList
    else
    begin
     l_Map.ClearBounds;
     // - это чтобы пересчитать прямоугольник с параграфом и его родителей
     pm_GetControl.ViewArea.Invalidate;
    end;//aShape.IsList
   end//(nev_spExtent in aParts)
   else
    pm_GetControl.InvalidateRect(l_Map.Bounds);
  end;//l_Map = nil
 end;//aShape <> nil
end;

function TnevView.CaretCursor: InevBasePoint;
  //override;
  {-}
begin
 if (pm_GetControl = nil) OR (pm_GetControl.Selection = nil) then
  Result := nil
 else
  Result := pm_GetControl.Selection.Point;
end;

function TnevView.pm_GetScroller(aVert: Boolean): InevScroller;
  {-}
begin
 if (f_Scroll[aVert] = nil) then
 begin
  if aVert then
   f_Scroll[aVert] := TnevVScroller.Create
  else
   f_Scroll[aVert] := TnevHScroller.Create;
  f_Scroll[aVert].f_View := Self;
 end;//f_Scroll[aVert] = nil
 Result := f_Scroll[aVert];
end;

function TnevView.pm_GetMousePos: TnevPoint;
  {-}
begin
 if (pm_GetControl = nil) then
  Result := nevPt0
 else
  Result := pm_GetControl.MousePos;
end;

function TnevView.pm_GetAllowMultiSelect: Boolean;
  {-}
begin
 if (pm_GetControl = nil) then
  Result := false
 else
  Result := pm_GetControl.AllowMultiSelect;
end;

function TnevView.pm_GetCaret: InevCaret;
  {-}
begin
 if (f_Caret = nil) then
 begin
  f_Caret := TnevCaret.Create;
  f_Caret.f_View := Self;
 end;//f_Caret = nil
 Result := f_Caret;
end;

function TnevView.InMakeCaretVisible: Boolean;
  {-}
begin
 Result := f_InMakeVisible;
end;

procedure TnevView.ClearPointToShow;
  {-}
begin
 f_PointToShow := nil;
end;

procedure TnevView.MakeCaretVisible;
  {-}
begin
 MakePointVisible(CaretCursor);
end;

function TnevView.MakePointVisible(const aPoint: InevBasePoint): Boolean;
  {-}
var
 l_Map : InevMap;
 l_VE  : TnevPoint;

 procedure AdjustX;
 var
  l_CX : Integer;
  l_W  : Integer;
  l_S  : TnevScroller;
  l_InnerMap : InevMap;
  l_NeedVisible : Boolean;
 begin//AdjustX
  l_S := f_Scroll[false];
  if (l_S <> nil) then                                                     
  begin

   l_CX := aPoint.DeltaX(Self, l_Map);
   if not Result AND (f_PointToShow = nil) and aPoint.MostInner.NeedWindowsCaret then
   begin
    // http://mdp.garant.ru/pages/viewpage.action?pageId=208701246
    // Лечим тут не переход на параграф внутри ячейки таблицы, который ещё не
    // отрисовался и не сформатировался.
    l_InnerMap := MapByPoint(aPoint.MostInner);
    if (l_InnerMap = nil) then
    begin
     f_PointToShow := aPoint.ClonePoint(Self);
     Exit;
    end//l_InnerMap = nil
    else
    if not l_InnerMap.rVisible OR (l_CX < evShapeNil div 2) then
    begin
     if not l_InnerMap.FI.IsHidden(true, true) then
      f_PointToShow := aPoint.ClonePoint(Self);
     Exit;
    end;//not l_InnerMap.rVisible OR (l_CX < evShapeNil div 2)
   end;//not Result

   l_CX := l_S.Pos + l_CX;
   l_W := l_VE.X - f_HorzDelta;
   if (l_CX < l_S.Pos) OR
      ((l_S.Pos > 0) AND (l_CX < l_S.Pos + 10 * l3Epsilon))
                                      // ^ http://mdp.garant.ru/pages/viewpage.action?pageId=109086509&focusedCommentId=109511691#comment-109511691
                                      // http://mdp.garant.ru/pages/viewpage.action?pageId=287211613
      then
   // - курсор левее экрана
   begin
    if (l_CX < l_W) then
     l_CX := 0;
    l_S.ScrollTo(Max(0, l_CX));
    Result := true;
   end//l_CX < l_S.Pos
   else
   // - здесь проверим не правее ли курсор экрана
   begin
    if (l_S.Page < l_S.Max) then
    begin
     if (l_S.Pos + l_W < l_CX + l3Epsilon) then
     begin
      l_S.ScrollTo(Max(0, l_CX + (f_HorzDelta div 2) - l_W));
      Result := true;
     end;//l_S.Pos + l_W < l_CX + l3Epsilon
    end//l_S.Page < l_S.Max
    else
    if (l_S.Pos > 0) then
    begin
     l_S.ScrollTo(0);
     Result := true;
    end;//l_S.Pos > 0
   end;//l_CX < l_S.Pos
  end;//l_S <> nil
 end;//AdjustX

var
 l_TA : InevAnchor;

 procedure AdjustY;
 var
  l_Diff : Integer;
  l_BA   : InevAnchor;
  l_VB   : TnevRect;
  l_S    : TnevVScroller;
 begin//AdjustY
  l_Diff := aPoint.Diff(Self, l_TA, l_Map.FI);
  if (l_Diff < 0) then
  // - курсор выше экрана
  begin
   if not PartiallyVisible(aPoint, l_TA, l_Map.FI) then
   begin
    l_TA.AssignPoint(Self, aPoint);
    Result := aPoint.MostInner.NeedWindowsCaret;
   end;
  end//l_Diff < 0
  else
  if (l_Diff > 0) then
  // - здесь проверим, что курсор ниже экрана
  begin
   l_BA := BottomAnchor(False);
   if l_BA.AtStart then
    Exit;
    // - хрень какая-то, конечный курсор в начале документа - наверное что-то не сформатировалось
   l_Diff := aPoint.Diff(Self, l_BA, l_Map.FI);
   if (l_Diff >= 0) then
   begin
    // - курсор ниже экрана
    if (l_Diff <= 1) then
    begin
     l_VB := aPoint.ViewBounds(Self, l_Map);
     if (l_VB.Top < l_VB.Bottom) AND (l_VB.Bottom <= l_VE.Y) then
      Exit;
     // - не надо никуда сдвигать, т.к. курсор видимый
     if (l_Diff = 0) AND (l_VB.Top = l_VB.Bottom) AND IsDocumentTailVisible then
      Exit;
     // - не надо никуда сдвигать, т.к. курсор видимый, и попал он на последний
     //   блок у которого нет дочерних параграфов.
    end;//l_Diff <= 1
    (*if CheckTableCursor(aPoint, l_BA) then
    begin
     l_TA.IncLine(Self, l_Diff, True);
     Result := True;
    end // if CheckTableCursor(aPoint, l_BA) then
    else*)
    begin
     Result := true;
     l_S := TnevVScroller(f_Scroll[true]);
     if (l_S <> nil) then
      l_S.MakePointVisible(l_TA, aPoint);
    end;
   end;//l_Diff >= 0
  end;//l_Diff > 0
 end;//AdjustY

var
 l_InnerMap : InevMap;
begin
 Result := false;
 if not f_InMakeVisible then
 begin
  f_InMakeVisible := true;
  try
   l_TA := pm_GetTopAnchor;
   if (aPoint <> nil) AND (l_TA <> nil) then
   begin
    l_Map := RootMap;
    if (l_Map = nil) then
     f_PointToShow := aPoint.ClonePoint(Self)
    else
    begin
     l_VE := ViewExtent;
     AdjustY;
     if not l_Map.IsLinked then
      f_PointToShow := aPoint.ClonePoint(Self)
     else
     begin
      if Result then
      begin
       l_InnerMap := MapByPoint(aPoint.MostInner);
       if (l_InnerMap = nil) then
       begin
        f_PointToShow := aPoint.ClonePoint(Self);
        Exit;
       end//l_InnerMap = nil
       else
       if not l_InnerMap.rVisible then
       begin
        if not l_InnerMap.FI.IsHidden(true, true) then
         f_PointToShow := aPoint.ClonePoint(Self);
        Exit;
       end;//not l_InnerMap.rVisible
      end;//Result
      AdjustX;
     end;//not l_Map.IsLinked
    end;//l_Map = nil
   end;//aPoint <> nil
  finally
   f_InMakeVisible := false;
  end;//try..finally
 end;//not f_InMakeVisible
end;

procedure TnevView.MakePairVisible(const aStart, aFinish: InevBasePoint);
  {-}
begin
 if (aStart.Compare(aFinish) <= 0) then
 begin
  MakePointVisible(aStart);
  MakePointVisible(aFinish);
  if (f_PointToShow = nil) then
   f_PointToShow := aStart.ClonePoint(Self)
  else
   f_StartToShow := aStart.ClonePoint(Self)
 end//aStart.Compare(aFinish) <= 0
 else
 begin
  MakePointVisible(aFinish);
  MakePointVisible(aStart);
  if (f_PointToShow = nil) then
   f_PointToShow := aFinish.ClonePoint(Self)
  else
   f_StartToShow := aFinish.ClonePoint(Self)
 end;//aStart.Compare(aFinish) <= 0
end;

function TnevView.IsCaretVisible: Boolean;
  {-}
var
 l_CC  : InevBasePoint;
 l_Map : InevMap;
 l_TA  : InevAnchor;
 l_Less: Boolean;
begin
 l_CC := CaretCursor;
 if (l_CC = nil) then
  Result := false
 else
 begin
  l_Map := RootMap;
  if (l_Map = nil) OR (l_Map.FI = nil) then
   Result := false
  else
  begin
   l_TA := pm_GetTopAnchor;
   if l_TA.Obj.AsObject.Owner.IsValid then
   begin
    l_Less := l_CC.Diff(Self, l_TA, l_Map.FI) >= 0;
    if not l_Less then
     l_Less := PartiallyVisible(l_CC, l_TA, l_Map.FI);
    Result := l_Less AND
              (l_CC.Diff(Self, BottomAnchor(False), l_Map.FI) <= 0)
   end           
   else
    Result := true;
  end;//l_Map = nil
 end;//l_CC = nil
end;

function TnevView.GetCanvas(const anExtent: TnevPoint): InevCanvas;
  //override;
  {-}
begin
 Result := pm_GetControl.DrawCanvas;
end;
  
function TnevView.DoDraw(const aBlock : InevRange;
                         var theMap   : InevMap): Boolean;
  {-}
begin
 if (f_LastControlWidth <> ViewExtent.X) AND pm_GetIsWebStyle then
  ClearShapes;
 Result := inherited DoDraw(aBlock, theMap);
 if Result then
  CheckScrollers;
end;

// start class TnevScroller

class function TnevScroller.Make: InevScroller;
  {-}
var
 l_Scroller : TnevScroller;
begin
 l_Scroller := Create;
 try
  Result := l_Scroller;
 finally
  l3Free(l_Scroller);
 end;//try..finally
end;

function TnevScroller.Min: Integer;
  {-}
begin
 Result := 0;
end;

procedure TnevScroller.Top;
  {-}
begin
 ScrollTo(nevTop);
end;

procedure TnevScroller.Bottom;
  {-}
begin
 ScrollTo(nevBottom);
end;

procedure TnevScroller.PageUp;
  {-}
begin
 if (f_View <> nil) AND (f_View.pm_GetControl <> nil) then
  IncTop(Tl3Point(f_View.ViewExtent).Neg);
end;

function TnevScroller.PageDown: Boolean;
  {-}
begin
 if (f_View <> nil) AND (f_View.pm_GetControl <> nil) then
  Result := IncTop(f_View.ViewExtent)
 else
  Result := false;
end;

procedure TnevScroller.LineUp(aCount : Integer);
  {-}
begin
 if (f_View <> nil) then
  IncTop(nev.LineScrollDelta.Neg);
end;

procedure TnevScroller.LineDown(aCount : Integer);
  {-}
begin
 if (f_View <> nil) then
  IncTop(nev.LineScrollDelta);
end;

function TnevScroller.WheelMul: Integer;
  {-}
begin                                                       
 if IsWinNT or IsWin98 then
  SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, @Result, SPIF_SENDCHANGE)
 else
  Result := 3;
end;
  
procedure TnevScroller.WheelUp;
  //virtual;
  {-}
begin
 if (f_View <> nil) then
  IncTop(nev.LineScrollDelta.Mul(l3Point1(WheelMul)).Neg);
end;

procedure TnevScroller.WheelDown;
  //virtual;
  {-}
begin
 if (f_View <> nil) then
  IncTop(nev.LineScrollDelta.Mul(l3Point1(WheelMul)));
end;

procedure TnevScroller.EndScroll;
  //virtual;
  {-}
begin
end;

procedure TnevScroller.ResetPos(aTopDiff  : Integer);
  //virtual;
  {-}
begin
end;

// start class TnevHScroller

procedure TnevHScroller.Cleanup;
  //override;
  {-}
begin
 inherited;
 f_XOfs := 0;
end;

function TnevHScroller.Page: Integer;
  {-}
begin
 if (f_View = nil) then
  Result := 0
 else
  Result := f_View.ViewExtent.X;
end;

function TnevHScroller.Max: Integer;
  {-}
begin
 if (f_View = nil) then
  Result := 0
 else
  Result := l3MinMax.Max(0, l3MinMax.Max(f_View.MaxWidth, f_View.LimitWidth));
end;

function TnevHScroller.Pos: Integer;
  //override;
  {-}
begin
 Result := f_XOfs;
end;

function TnevHScroller.ScrollTo(aPosition: Integer): Boolean;
  //override;
  {-}
var
 l_Delta   : Integer;
begin
 {$IfDef Nemesis}
 aPosition := l3MinMax.Max(l3MinMax.Min(aPosition,
                                        Max - Page + (f_View.f_HorzDelta div 2)), 0);
 {$EndIf Nemesis}
 if (f_XOfs = aPosition) then
  Result := false
 else
 begin
  Result := true;
  if (f_View = nil) then
   f_XOfs := aPosition
  else 
  begin
   with f_View do
   begin
    l_Delta := ShapesPainted.HorzScroll(f_XOfs,
                                        aPosition,
                                        ViewExtent);
    f_XOfs := aPosition;
    if (pm_GetControl <> nil) then
     pm_GetControl.SignalScroll(l_Delta, false);
   end;//with f_View
  end;//f_View = nil
 end;//f_XOfs <> aPosition
end;

function TnevHScroller.IncTop(const aDelta: TnevPoint): Boolean;
  {-}
begin
 Result := ScrollTo(f_XOfs + aDelta.X);
end;

// start class TnevViewControl

procedure TnevViewControl.Cleanup;
  //override;
  {-}
begin
 f_View := nil;
 inherited;
end;

procedure TnevViewControl.Top;
  //virtual;
  {-}
begin
end;

procedure TnevViewControl.Bottom;
  //virtual;
  {-}
begin
end;

procedure TnevViewControl.PageUp;
  //virtual;
  {-}
begin
end;

function TnevViewControl.PageDown: Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

procedure TnevViewControl.LineUp(aCount : Integer);
  //virtual;
  {-}
begin
end;

procedure TnevViewControl.LineDown(aCount : Integer);
  //virtual;
  {-}
begin
end;

// start class TnevCaret

procedure TnevCaret.Home;
  {-}
begin
 if (f_View <> nil) then
  f_View.Scroller[false].Top;
end;

procedure TnevCaret.EndLine;
  {-}
begin
 if (f_View <> nil) then
  f_View.Scroller[false].Bottom;
end;

procedure TnevCaret.ClearPages;
  {-}
begin
 if (f_View.f_Scroll[true] Is TnevVScroller) then
  if (TnevVScroller(f_View.f_Scroll[true]).f_LastPages <> nil) then
   TnevVScroller(f_View.f_Scroll[true]).f_LastPages.Clear;
end;
  
function TnevCaret.MoveCaret(aCode: Integer; aCount: Integer): Boolean;
  {-}
begin
 if (f_View <> nil) AND (f_View.CaretCursor <> nil) then
  Result := f_View.CaretCursor.Move(f_View,
                                       aCode,
                                       k2StartOp(f_View.Processor, ev_msgMove),
                                       aCount)
 else
  Result := false;
end;

procedure TnevCaret.Top;
  //override;
  {-}
begin
 MoveCaret(ev_ocTopLeft, 1);
 ClearPages;
end;

procedure TnevCaret.Bottom;
  //override;
  {-}
begin
 MoveCaret(ev_ocBottomRight, 1);
 ClearPages;
end;

procedure TnevCaret.PageUp;
  //override;
  {-}
var
 l_Op : InevOp;
begin
 if (f_View <> nil) then
 begin
  f_View.Scroller[true].PageUp;
  l_Op := k2StartOp(f_View.Processor, ev_msgMove);
  try
   f_View.CaretCursor.AsObject.ForceStore;
   if (l_Op <> nil) then
    (l_Op As IevCursorContext).RecordCursor(f_View.CaretCursor);
   f_View.CaretCursor.AssignPoint(f_View, f_View.pm_GetTopAnchor);
  finally
   l_Op := nil;
  end;//try.finally
 end;//f_View <> nil
end;

function TnevCaret.PageDown: Boolean;
  //override;
  {-}
var
 l_Op : InevOp;
 l_A  : InevBasePoint;
 l_L  : Integer;
 l_CC : InevBasePoint;
 l_Para : InevPara;
 l_C  : InevControl;
begin
 if (f_View <> nil) then
 begin
  Result := true;
  if f_View.Scroller[true].PageDown then
  begin
   l_Op := k2StartOp(f_View.Processor, ev_msgMove);
   try
    l_CC := f_View.CaretCursor;
    l_CC.AsObject.ForceStore;
    if (l_Op <> nil) then
     (l_Op As IevCursorContext).RecordCursor(l_CC);
    l_A := f_View.pm_GetTopAnchor.ClonePoint(f_View);
    l_L := 1;
    l_A.IncLine(f_View, l_L, false{true});
    with l_CC do
    begin
     DisableListener;
     try
      AssignPoint(f_View, l_A);
     finally
      EnableListener;
     end;//try..finally
    end;//l_CC
    l_C := f_View.pm_GetControl;
    if (l_C <> nil) then
     // http://mdp.garant.ru/pages/viewpage.action?pageId=171969856&focusedCommentId=172359833#comment-172359833
     // http://mdp.garant.ru/pages/viewpage.action?pageId=171969856&focusedCommentId=172359840#comment-172359840
     l_C.ParaChanged;
     // - открутил Люлин А.В. ибо - http://mdp.garant.ru/pages/viewpage.action?pageId=154075236&focusedCommentId=172359849#comment-172359849
     // - вернул Люлин А.В. - http://mdp.garant.ru/pages/viewpage.action?pageId=171969856&focusedCommentId=216074489#comment-216074489
   finally
    l_Op := nil;
   end;//try.finally
  end//f_View.Scroller[true].PageDown
  else
  begin
   l_Para := EvNextOverallPara(f_View.CaretCursor.MostInner.Obj^.AsPara);
   Result := MoveCaret(ev_ocBottomRight, 1);
   if Result then
    if (l_Para = nil) OR not l_Para.AsObject.IsValid then
     Result := false;
  end;//else
 end//f_View <> nil
 else
  Result := false;
end;

procedure TnevCaret.LineUp(aCount : Integer);
  //override;
  {-}
begin
 MoveCaret(ev_ocLineUp, aCount);
end;

procedure TnevCaret.LineDown(aCount : Integer);
  //override;
  {-}
begin
 MoveCaret(ev_ocLineDown, aCount);
end;

// start class TnevVScroller

procedure TnevVScroller.Cleanup;
  //override;
  {-}
begin
 inherited;
 l3Free(f_LastPages);
 f_Pos := 0;
end;

function TnevVScroller.Page: Integer;
  {-}
var
 l_Control : InevControl;
begin
 if (f_View = nil) then
  Result := 0
 else
 begin
  l_Control := f_View.pm_GetControl;
  if (l_Control = nil) then
   Result := 0
  else
  begin
   Result := f_View.ShapesPainted.SubShapesCount;
   if (Result = 0) then
    Result := l_Control.Metrics.Extent.Y div nev_ParaListFakeParaEx.Y;
  end;//l_Control = nil
 end;//f_View = nil
end;

function TnevVScroller.Max: Integer;
  {-}
var
 l_Shape : InevObject;
 l_Page  : Integer;
begin
 if (f_View = nil) then
  Result := 0
 else
 begin
  l_Shape := f_View.Shape;
  if (l_Shape = nil) then
   Result := 0
  else
  begin
   l_Page := Page;
   if f_View.IsDocumentTailVisible then
    if ((f_View.pm_GetTopAnchor = nil) OR f_View.pm_GetTopAnchor.AtStart) then
    begin
     Result := l3MinMax.Max(0, l_Page - 1);
     f_View.f_LastTailVisible := true;
     Exit;
    end;//(f_View.pm_GetTopAnchor = nil) OR f_View.pm_GetTopAnchor.AtStart
   Result := l3MinMax.Max(0, l_Shape.ToList.LeafShapeCount);
(*   if (Result = l_Page) then
    if ((f_View.pm_GetTopAnchor = nil) OR f_View.pm_GetTopAnchor.AtStart) then
    begin
     Result := l3MinMax.Max(0, l_Page - 1);
     Exit;
    end;//(f_View.pm_GetTopAnchor = nil) OR f_View.pm_GetTopAnchor.AtStart*)
   if (Result <= l_Page) then
    Result := l_Page + 1;
  end;//l_Shape = nil
 end;//f_View = nil
end;

function TnevVScroller.Pos: Integer;
  //override;
  {-}

 function AbsIndex(const aParent : InevObjectList;
                   const aPara   : InevObject): Integer;
 var
  l_Para : InevObject;
  l_PID  : Integer;
  l_PCC  : Integer;
 begin//AbsIndex
  if aParent.AsObject.IsValid then
  begin
   l_PID := aPara.PID;
   if not aParent.AlmostLinear then
   begin
    l_PCC := aParent.AsObject.ChildrenCount;
    Assert(l_PCC > 0, 'Список параграфов пустой');
    // http://mdp.garant.ru/pages/viewpage.action?pageId=278135821
    if (l_PID > l_PCC div 2) then
    // - здесь постараемся перебирать параграфы не с начала, а с конца
    //   типа так быстрее будет
    begin
     Result := aParent.LeafShapeCount;
     Assert(Result > 0, 'Высота списка параграфов почему-то нулевая');
     // http://mdp.garant.ru/pages/viewpage.action?pageId=278135821
     //Inc(l_PID);
     // - http://mdp.garant.ru/pages/viewpage.action?pageId=255956509
     while (l_PID < l_PCC) do
     begin
      l_Para := aParent[l_PID];
      if l_Para.IsList then
       Dec(Result, l_Para.ToList.LeafShapeCount)
      else
       Dec(Result);
      Assert(Result >= 0, 'Неправильно посчиталась позиция скроллера');
      if (Result <= 0) then
      // - типа беда всё же случилась
      begin
       Result := 0;
       Exit;
      end;//Result <= 0
      Inc(l_PID);
     end;//while (l_PID < l_PCC)
    end//l_PID > l_PCC div 2
    else
    begin
     Result := 0;
     Dec(l_PID);
     while (l_PID > 0) do
     begin
      l_Para := aParent[l_PID];
      if l_Para.IsList then
       Inc(Result, l_Para.ToList.LeafShapeCount)
      else
       Inc(Result);
      Dec(l_PID);
     end;//while (l_PID > 0)
    end;//l_PID > l_PCC div 2
   end//not aParent.AlmostLinear
   else
    Result := l_PID;
    // - абсолютный индекс совпадает с индексом в родителе
  end//aParent.IsValid
  else
   Result := 0;
 end;//AbsIndex

var
 l_TA : InevAnchor;
 l_Pt : InevBasePoint;
 l_S  : PInevObject;
 l_CS : InevObjectList;
begin
 if (f_View = nil) then
  Result := 0
 else
 with f_View do
 begin
  l_TA := pm_GetTopAnchor;
  if (l_TA <> nil) AND l_TA.AtStart then
  begin
   if (f_Lock <= 0) OR (f_Pos < 0) then
    f_Pos := 0;
  end//l_TA <> nil..
  else
  if IsDocumentTailVisible then
  begin
   if (f_Lock <= 0) OR (f_Pos < 0) then
   begin
    f_Pos := Max;
    f_LastTailVisible := true;
   end;//f_Lock <= 0..
  end//IsDocumentTailVisible
  else
  if (f_Pos < 0) then
  begin
   if (l_TA = nil) then
    f_Pos := 0
   else
   begin
    if (f_InMakeVisible OR IsCaretVisible) AND
    // - запил для http://mdp.garant.ru/pages/viewpage.action?pageId=254938079&focusedCommentId=255492233#comment-255492233
       CaretCursor.AtEnd(f_View) then
    begin
     f_Pos := Max;
     f_LastTailVisible := true;
    end//f_InMakeVisible OR IsCaretVisible..
    else
    begin
     f_Pos := 0;
     l_Pt := l_TA;
     l_S := l_Pt.Obj;
     while l_S.IsList do
     begin
      l_CS := l_S.ToList;
      l_Pt := l_Pt.Inner;
      if (l_Pt = nil) then
       break;
      l_S := l_Pt.Obj;
      Inc(f_Pos, AbsIndex(l_CS, l_S^));
     end;//l_Pt <> nil
    end;//l_TA = nil
   end;//f_InMakeVisible OR IsCaretVisible..
  end;//f_Pos < 0
  Result := f_Pos;
  {$IFDEF nsTest}
  if TnevVScrollerSpy.Exists then
   TnevVScrollerSpy.Instance.LogPos(f_Pos);
  {$ENDIF nsTest}
 end;//with f_View
end;

function TnevVScroller.ScrollTo(aPosition: Integer): Boolean;
  //override;
  {-}
var
 l_Line  : Integer;
 l_OLine : Integer;
 l_Point : InevBasePoint;
 l_D     : InevObject;
 l_TA    : InevAnchor;
begin
 Result := false;
 if (f_LastPages <> nil) then
  f_LastPages.Clear;
 if (f_View <> nil) then
  with f_View do
  begin
   l_TA := pm_GetTopAnchor;
   if (l_TA <> nil) then
   begin
    if (aPosition <= 0) then
    begin
     f_Pos := 0;
     l_D := Data;
     if (l_D <> nil) then
     begin
      if not l_TA.Obj.AsObject.IsSame(l_D.AsObject) then
      // - проверяем - а не устарел ли якорь
      //   http://mdp.garant.ru/pages/viewpage.action?pageId=93257910
      begin
       Top := nil;
       l_TA := pm_GetTopAnchor;
       Assert(l_TA <> nil);
      end;//not l_TA.Obj.IsSame(l_D)
      Assert(l_TA.Obj.AsObject.IsSame(l_D.AsObject));
      l_TA.AssignPoint(f_View, l_D.MakeAnchor);
     end;//l_D <> nil
     Result := true;
    end//aPosition = nevTop
    else
    if (aPosition = nevBottom) OR (aPosition + Page >= Max) then
    begin
     f_Pos := aPosition;
     l_Point := Data.MakePoint;
     l_Point.Move(f_View, ev_ocBottomRight);
     MakePointVisible(l_Point);
     Result := true;
    end//aPosition = nevBottom
    else
    begin
     if (f_Pos = -1) then
     // - был вызван TnevVScroller.ResetPos
     // http://mdp.garant.ru/pages/viewpage.action?pageId=215549559&focusedCommentId=216072883#comment-216072883
      Pos;
      // - чтобы заново позицию проинициализировать
      // http://mdp.garant.ru/pages/viewpage.action?pageId=215549559&focusedCommentId=216072796#comment-216072796
     Assert(f_Pos >= 0); 
     l_Line := (aPosition - f_Pos);
     f_Pos := aPosition;
     if (l_Line <> 0) then
     begin
      Inc(f_Lock);
      try
       l_OLine := l_Line;
       if (l_Line < 0) OR not IsDocumentTailVisible then
       begin
        l_TA.IncLine(f_View, l_Line, false);
        Result := true;
       end;//l_Line < 0..
       if (l_OLine = l_Line) then
        if (pm_GetControl <> nil) then
         pm_GetControl.SignalScroll(0, true);
      finally
       Dec(f_Lock);
      end;//try..finally
     end;//aPosition = nevBottom
    end//l_Line <> 0
   end;//l_TA <> nil
  end;//with f_View
end;

function TnevVScroller.IncTop(const aDelta: TnevPoint): Boolean;
  {-}
var
 l_Line  : Integer;
 l_OldLine : Integer;
 l_Value : Integer;
 l_H     : Integer;
 l_TA    : InevAnchor;
 l_BA    : InevAnchor;
 l_SSC   : Integer;
begin
 Result := false;
 with f_View do
 begin
  l_TA := pm_GetTopAnchor;
  if (l_TA <> nil) then
  begin
   l_SSC := ShapesPainted.SubShapesCount;
   l_H := ViewExtent.Y;
   if (aDelta.Y = l_H) then
   begin
    if not IsDocumentTailVisible then
    begin
     Inc(f_Lock);
     try
      l_BA := BottomAnchor(False);
      if (l_BA <> nil) then
      begin
       Inc(f_Pos, l_SSC);
       l_TA.AssignPoint(f_View, l_BA);
       Result := true;
       Exit;
      end;//l_BA <> nil
     finally
      Dec(f_Lock);
     end;//try..finally
    end//not IsDocumentTailVisible
    else
     Exit;
   end;//aDelta.Y = ViewExtent.Y
   //else
   begin
    if (l_SSC > 0) then
    begin
     if (aDelta.Y = -l_H) then
      l_Line := -l_SSC
     else
     if (aDelta.Y = l_H) then
      l_Line := l_SSC
     else
     l_Line := aDelta.Y div nev.LineScrollDelta.Y;
    end//l_SSC > 0
    else
     l_Line := aDelta.Y div nev.LineScrollDelta.Y;
    if (l_Line <= 0) OR not IsDocumentTailVisible then
    begin
     Inc(f_Lock);
     try
      Result := true;
      l_TA.UnlinkListener(f_View);
      try
       l_OldLine := l_Line;
       if (pm_GetTopAnchor = nil) then
       begin
        Result := False;
        Exit;
       end;
       l_Value := pm_GetTopAnchor.IncLine(f_View, l_Line, true);
       if (f_Pos >= 0) then
        Inc(f_Pos, l_Value);
       Result := (l_OldLine > l_Line);
      finally
       l_TA.LinkListener(f_View);
      end;//try..finally
     finally
      Dec(f_Lock);
     end;//try..finally
    end;//l_Line <= 0..
   end;//aDelta.Y = ViewExtent.Y
  end;//pm_GetTopAnchor <> nil
 end;//with f_View
end;

procedure TnevVScroller.PageUp;
  //override;
  {-}
var
 l_Top : InevBasePoint;
begin
 if (f_LastPages <> nil) AND not f_LastPages.Empty then
 begin
  with f_LastPages do
  begin
   l_Top := Last;
   DeleteLast;
  end;//with f_LastPages
  if (f_View <> nil) then
   f_View.pm_GetTopAnchor.AssignPoint(f_View, l_Top);
  Exit;
 end;//f_LastPages <> nil
 inherited;
end;

{$IfDef nsTest}
type
  TnevLastPagesList = class(TnevBasePointList)
 protected
 // overridden protected methods
   class function IsCacheable: Boolean; override;
     {* функция класса, определяющая могут ли объекты данного класса попадать в кэш повторного использования. }
  end;//TnevLastPagesList

class function TnevLastPagesList.IsCacheable: Boolean;
begin
 Result := false;
end;
{$Else  nsTest}
type
  TnevLastPagesList = TnevBasePointList;
{$EndIf nsTest}

function TnevVScroller.PageDown: Boolean;
  //override;
  {-}
var
 l_Top : InevBasePoint;
{$IfOpt D+}
 l_OldMI : InevBasePoint;
 l_OldInn: InevBasePoint;
 l_NewInn: InevBasePoint;
 l_NewMI : InevBasePoint;
 l_FI    : TnevFormatInfoPrim;
 l_OldFI : TnevFormatInfoPrim;
{$EndIf}
begin
 if (f_View <> nil) then
  l_Top := f_View.pm_GetTopAnchor.ClonePoint(f_View);
 Result := inherited PageDown;
 if Result AND (l_Top <> nil) then
 begin
{$IfOpt D+}
  l_OldMI := l_Top.MostInner;
  l_NewMI := f_View.pm_GetTopAnchor.MostInner;
  if l_NewMI.HasBaseLine and l_OldMI.HasBaseLine then
  begin
   if l_OldMI.AsObject.IsSame(l_NewMI.MostInner.AsObject) then
   begin
    l_FI := f_View.FormatInfoByPoint(l_NewMI);
    l_NewInn := l_NewMI.InnerForChildThatNotAfterEnd(l_FI, nev_itNone);
    if l_NewInn <> nil then
     l_NewMI := l_NewInn.MostInner;
    l_OldInn := l_OldMI.InnerForChildThatNotAfterEnd(l_FI, nev_itNone);
    if l_OldInn <> nil then
     l_OldMI := l_OldInn.MostInner;
    if l_OldMI.AsObject.IsSame(l_NewMI.AsObject) then
    begin
     l_OldFI := f_View.FormatInfoByPoint(l_OldMI); // Не забываем про вложенные таблицы...
     Assert(l_OldMI.Diff(f_View, l_NewMI, l_OldFI) <>  0, 'При удачном смещении курсора на страницу предыдущее и новое значение якорей не должны совпадать');
    end; // if l_OldMI.IsSame(l_NewMI) then
   end; // if l_OldMI.IsSame(l_NewMI.MostInner) then
  end // if l_NewMI.HasBaseLine and l_OldMI.HasBaseLine then
  else
  begin
   l_OldMI := l_Top;
   l_NewMI := f_View.pm_GetTopAnchor;
   l_OldFI := f_View.FormatInfoByPoint(l_OldMI);
   Assert(l_OldMI.Diff(f_View, l_NewMI, l_OldFI) <>  0, 'При удачном смещении курсора на страницу предыдущее и новое значение якорей не должны совпадать');
  end;//l_NewMI.HasBaseLine and l_OldMI.HasBaseLine
{$EndIf}
  if (f_LastPages = nil) then
   f_LastPages := TnevLastPagesList.Make;
  try
   f_LastPages.Add(l_Top);
   {$IfDef nsTest}
   Assert(f_LastPages.Count < 1000 * 1000);
   {$EndIf nsTest}
  except
   FreeAndNil(f_LastPages);
   raise;
  end;//try..except
 end;//l_Top <> nil
end;

procedure TnevVScroller.ResetPos(aTopDiff  : Integer);
  //override;
  {-}
begin
 if (f_Lock <= 0) AND (f_Pos >= 0) then
 begin
  (*if (aTopDiff = 1) AND (f_View <> nil) then
  begin
   with f_View do
    if not PrevTop.MostInner.IsSame(pm_GetTopAnchor.MostInner) then
     Dec(f_Pos);
   Exit;
  end;//aTopDiff = 1*)
  // Это комментировал Люлин А.В. подробности - http://mdp.garant.ru/pages/viewpage.action?pageId=171968601&focusedCommentId=171969512#comment-171969512
  f_Pos := -1;
 end;//f_Lock <= 0
end;

procedure TnevVScroller.MakePointVisible(const aTop   : InevAnchor;
                                         const aPoint : InevBasePoint);
  {-}
var
 l_View : InevMeasureView;
begin
 l_View := TnevMeasureView.Make(f_View.pm_GetControl);
 if (l_View <> nil) then
  try
   Inc(f_Lock);
   try
    l_View.MakePointVisible(aTop, aPoint, f_Pos);
   finally
    Dec(f_Lock);
   end;//try..finally
  finally
   l_View := nil;
  end;//try..finally
end;

function TnevView.PartiallyVisible(const aPoint     : InevBasePoint;
                                   const aTopAnchor : InevAnchor;
                                   const aFI        : TnevFormatInfoPrim): Boolean;
var
 l_Outer    : IafwShape;
 l_CheckMap : InevMap;
begin
 Result := aPoint.PartiallyVisible(Self, aTopAnchor, aFI);
 if Result then
 begin
  l_CheckMap := MapByPoint(aPoint.MostInner);
  Result := l_CheckMap = nil;
  if not Result then
  begin
   l_Outer := l_CheckMap.Outer;
   Result := l_Outer = nil;
   if not Result then
   begin
    l_Outer := l_Outer.Outer;
    Result := l_Outer = nil;
    if not Result then
     Result := not (l_Outer as InevMap).rVisible;
   end; // if not Result then
  end; // if not Result then
 end; // if Result then
end;

procedure TnevHScroller.Bottom;
begin
 ScrollTo(Max - Page + (f_View.f_HorzDelta div 2));
end;

function TnevView.CheckTableCursor(const aPoint: InevBasePoint;
  const aBottomAnchor: InevAnchor): Boolean;
begin
 Result := aBottomAnchor.MostInner.HasBaseLine;
end;

end.

