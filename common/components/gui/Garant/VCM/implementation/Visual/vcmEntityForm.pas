unit vcmEntityForm;
{ Базовый класс для отображения сущностей из модуля приложения
  построенного на основе библиотеки VCM.                       }

{ Библиотека "vcm"        }
{ Автор: Люлин А.В. ©     }
{ Модуль: vcmEntityForm - }
{ Начат: 24.02.2003 14:07 }
{ $Id: vcmEntityForm.pas,v 1.629 2016/08/23 11:46:43 kostitsin Exp $ }

// $Log: vcmEntityForm.pas,v $
// Revision 1.629  2016/08/23 11:46:43  kostitsin
// {requestlink: 624862173 }
//
// Revision 1.628  2016/07/19 08:57:49  morozov
// {RequestLink: 604485202}
//
// Revision 1.627  2016/07/14 10:23:14  morozov
// {RequestLink: 624709489}
//
// Revision 1.626  2016/06/29 11:09:57  kostitsin
// {requestlink: 625252835 }
//
// Revision 1.625  2016/06/28 14:55:26  kostitsin
// {requestlink: 625252835 }
//
// Revision 1.624  2016/06/17 12:13:09  kostitsin
// {requestlink: 497687364 } - подтачиваем
//
// Revision 1.623  2016/06/16 13:45:54  kostitsin
// {requestlink: 497687364 }
//
// Revision 1.622  2016/06/15 13:55:57  kostitsin
// {requestlink: 497687364 }
//
// Revision 1.621  2016/06/15 13:24:27  kostitsin
// {requestlink: 497687364 }
//
// Revision 1.620  2016/05/18 08:58:21  morozov
// {RequestLink: 612733136}
//
// Revision 1.619  2015/10/26 13:41:44  kostitsin
// {requestlink: 601992498 }
//
// Revision 1.618  2015/10/14 10:19:00  morozov
// {RequestLink: 607767761}
//
// Revision 1.617  2015/10/14 10:06:15  morozov
// {RequestLink: 607767761}
//
// Revision 1.616  2015/10/13 10:09:03  morozov
// {RequestLink: 609584154}
//
// Revision 1.615  2015/09/29 10:53:57  morozov
// {RequestLink: 607762283}
//
// Revision 1.614  2015/09/13 15:31:44  kostitsin
// {requestlink: 605157327 }
//
// Revision 1.613  2015/09/08 12:25:05  morozov
// {RequestLink: 606434309}
//
// Revision 1.612  2015/09/08 12:08:25  morozov
// {RequestLink: 606434309}
//
// Revision 1.611  2015/08/26 09:17:32  morozov
// {RequestLink: 606118851}
//
// Revision 1.610  2015/08/24 12:59:58  morozov
// {RequestLink: 604485184}
//
// Revision 1.609  2015/08/06 12:34:00  kostitsin
// {requestlink: 392173415 }
//
// Revision 1.608  2015/08/05 13:45:07  kostitsin
// {requestlink: 127042272 }
//
// Revision 1.607  2015/07/30 12:36:55  morozov
// {RequestLink: 604472165}
//
// Revision 1.606  2015/07/09 09:54:21  kostitsin
// чтобы не мешалось.
//
// Revision 1.605  2015/07/09 09:49:04  kostitsin
// {requestlink: 127042272 } - грохнул ещё пачку _TvcmInterfaceList.
//
// Revision 1.604  2015/06/03 12:26:29  lulin
// - пытаемся разрулить зависимости.
//
// Revision 1.603  2015/04/28 14:35:20  lulin
// - рефакторим.
//
// Revision 1.602  2015/04/28 13:40:30  lulin
// - рефакторим.
//
// Revision 1.601  2015/04/28 13:24:59  lulin
// - рефакторим.
//
// Revision 1.600  2015/04/28 10:45:16  lulin
// - рефакторим.
//
// Revision 1.599  2015/04/14 07:12:14  morozov
// {RequestLink: 596403594}
//
// Revision 1.598  2015/04/09 14:36:18  kostitsin
// {requestlink: 595977194 }
//
// Revision 1.597  2015/03/31 16:51:38  lulin
// - перетряхиваем зависимости.
//
// Revision 1.596  2015/03/19 11:38:07  lulin
// - переворачиваем зависимости.
//
// Revision 1.595  2015/03/12 10:12:56  lulin
// - перетряхиваем слова.
//
// Revision 1.594  2015/03/02 14:00:20  morozov
// {RequestLink: 588809860}
//
// Revision 1.593  2015/02/26 09:29:04  kostitsin
// List*ner -> Listener
//
// Revision 1.592  2015/02/25 13:53:25  kostitsin
// List*ner -> Listener
//
// Revision 1.591  2014/12/16 13:50:39  morozov
// {RequestLink: 569221018}
//
// Revision 1.590  2014/12/16 08:02:52  morozov
// {RequestLink: 570121096}
//
// Revision 1.589  2014/11/20 11:56:10  kostitsin
// {requestlink: 576532040 }
//
// Revision 1.588  2014/11/19 07:36:47  kostitsin
// {requestlink: 573694057 }
//
// Revision 1.587  2014/11/17 12:39:09  kostitsin
// {requestlink: 573694057 } - ждем багфикса
//
// Revision 1.586  2014/11/17 12:25:17  kostitsin
// {requestlink: 573694057 }
//
// Revision 1.585  2014/11/11 11:54:54  morozov
// {RequestLink: 567555267}
//
// Revision 1.584  2014/10/21 09:09:17  morozov
// Недокоммиченное
//
// Revision 1.583  2014/09/08 07:39:08  morozov
// {RequestLink: 392173415}
//
// Revision 1.582  2014/08/20 04:32:50  morozov
// {RequestLink: 562604291}
//
// Revision 1.581  2014/08/19 07:29:57  morozov
// {RequestLink: 562604291}
//
// Revision 1.580  2014/08/11 10:25:44  morozov
// {RequestLink: 560991207}
//
// Revision 1.579  2014/07/17 11:51:23  morozov
// {RequestLink: 340174500}
//
// Revision 1.578  2014/06/18 11:21:04  morozov
// {RequestLink: 518765917}
//
// Revision 1.577  2014/06/02 10:28:32  kostitsin
// {requestlink: 540160525 }
//
// Revision 1.576  2014/06/02 08:20:20  kostitsin
// {requestlink: 539634560 }
//
// Revision 1.575  2014/06/01 16:52:37  kostitsin
// {requestlink: 539634560 }
//
// Revision 1.574  2014/05/23 09:37:09  morozov
// {RequestLink: 518765917}
//
// Revision 1.573  2014/04/24 12:26:10  lulin
// [$531960334]
//
// Revision 1.572  2014/04/23 12:05:11  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.571  2014/04/23 11:13:47  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.570  2014/02/18 17:31:11  lulin
// - подготавливаемся к обобщению словарей.
//
// Revision 1.569  2013/12/13 17:10:08  kostitsin
// [$508169367]
//
// Revision 1.568  2013/12/13 08:28:28  morozov
// {RequestLink: 505415962}
//
// Revision 1.567  2013/12/09 07:47:08  morozov
// {RequestLink: 400528621}
//
// Revision 1.566  2013/11/25 20:48:07  kostitsin
// переносим настройки форм в нужное место
//
// Revision 1.565  2013/11/22 12:22:59  morozov
// {RequestLink: 502978335}
//
// Revision 1.564  2013/11/22 10:51:12  morozov
// {RequestLink: 502978335}
//
// Revision 1.563  2013/11/11 15:35:25  lulin
// - вычищаем устаревший код.
//
// Revision 1.562  2013/11/11 15:21:15  lulin
// - вычищаем устаревший код.
//
// Revision 1.561  2013/10/15 12:45:47  lulin
// {RequestLink:485885765}
//
// Revision 1.560  2013/10/14 14:20:43  kostitsin
// [$377169452] - Registration
//
// Revision 1.559  2013/09/25 17:12:54  lulin
// - рефакторим подписку к настройкам.
//
// Revision 1.558  2013/08/07 10:24:59  morozov
// {RequestLink:429695931}
//
// Revision 1.557  2013/07/05 14:34:53  lulin
// - переименовал свойство про возможность редактирования тулбара и немного переделал правки Виктора касательно редактирования тулбаров во внутренней версии.
//
// Revision 1.556  2013/07/05 13:16:47  lulin
// - вставляем ловушечку.
//
// Revision 1.555  2013/05/21 15:11:11  lulin
// - боремся с фокусом.
//
// Revision 1.554  2013/05/21 15:09:42  lulin
// - боремся с фокусом.
//
// Revision 1.553  2013/05/21 14:52:05  lulin
// - боремся с фокусом.
//
// Revision 1.552  2013/05/15 12:20:42  lulin
// - разборки с упавшими тестами.
//
// Revision 1.551  2013/05/14 15:08:34  lulin
// - разборки с упавшими тестами.
//
// Revision 1.550  2013/05/14 14:29:51  lulin
// - разборки с упавшими тестами.
//
// Revision 1.549  2013/05/14 14:04:04  lulin
// - разборки с упавшими тестами.
//
// Revision 1.548  2013/04/24 09:35:37  lulin
// - портируем.
//
// Revision 1.547  2013/04/08 12:28:45  morozov
// {RequestLink:429695931} откат изменений (не прошли тесты)
//
// Revision 1.546  2013/04/05 12:02:41  lulin
// - портируем.
//
// Revision 1.545  2013/04/04 14:39:32  morozov
// {RequestLink:429695931}
//
// Revision 1.544  2013/02/20 15:00:16  lulin
// - улучшаем диагностику.
//
// Revision 1.543  2013/02/07 15:40:17  kostitsin
// [$428281545]
//
// Revision 1.542  2013/01/31 13:13:35  kostitsin
// [$425036429]
//
// Revision 1.541  2012/11/23 08:23:33  kostitsin
// чиню сборку
//
// Revision 1.540  2012/10/26 18:33:45  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.539  2012/10/25 18:51:01  lulin
// {RequestLink:406489593}
//
// Revision 1.538  2012/08/10 14:22:09  lulin
// - bug fix: не собирались библиотеки.
//
// Revision 1.537  2012/08/06 17:46:43  lulin
// {RequestLink:380046115}
//
// Revision 1.536  2012/08/06 17:04:04  lulin
// {RequestLink:380046115}
//
// Revision 1.535  2012/07/18 17:56:52  lulin
// {RequestLink:378541177}
//
// Revision 1.534  2012/07/18 13:18:07  lulin
// {RequestLink:378550793}
//
// Revision 1.533  2012/07/17 13:33:44  lulin
// {RequestLink:377753673}
//
// Revision 1.532  2012/07/17 11:52:48  lulin
// {RequestLink:378541134}
//
// Revision 1.531  2012/07/13 13:19:26  lulin
// {RequestLink:237994598}
//
// Revision 1.530  2012/07/11 18:25:29  lulin
// {RequestLink:237994598}
//
// Revision 1.529  2012/07/10 18:58:50  lulin
// {RequestLink:237994598}
//
// Revision 1.528  2012/06/01 10:03:59  lulin
// {RequestLink:269058296}
//
// Revision 1.527  2012/05/31 19:13:00  lulin
// {RequestLink:269058296}
//
// Revision 1.526  2012/05/30 14:24:06  lulin
// {RequestLink:290264810}
//
// Revision 1.525  2012/05/29 08:54:55  kostitsin
// багфикс
//
// Revision 1.524  2012/05/28 16:50:18  kostitsin
// [$367201314]
//
// Revision 1.523  2012/05/28 12:29:55  lulin
// {RequestLink:356848399}
//
// Revision 1.522  2012/05/28 11:27:45  lulin
// - подтачиваем VCM чтобы и стандартные диалоги могли быть "родными".
//
// Revision 1.520  2012/05/21 11:30:05  kostitsin
// [$290265170]
//
// Revision 1.519  2012/05/17 12:29:09  kostitsin
// добавляем в _shell.mo.en объекты vg_scene
//
// Revision 1.518  2012/04/28 10:38:53  lulin
// {RequestLink:361404275}
//
// Revision 1.517  2012/04/13 18:23:24  lulin
// {RequestLink:237994598}
//
// Revision 1.516  2012/04/13 14:38:46  lulin
// {RequestLink:237994598}
//
// Revision 1.515  2012/04/13 11:51:49  lulin
// {RequestLink:237994598}
//
// Revision 1.514  2012/04/09 08:39:12  lulin
// {RequestLink:237994598}
// - думаем о VGScene.
//
// Revision 1.513  2012/04/09 06:14:07  lulin
// {RequestLink:237994598}
//
// Revision 1.512  2012/04/04 17:55:45  lulin
// {RequestLink:237994598}
// - разбираемся с упавшими тестами.
//
// Revision 1.511  2012/04/04 14:48:07  lulin
// {RequestLink:237994598}
// - чистим код.
//
// Revision 1.510  2012/03/30 15:34:37  lulin
// {RequestLink:354684138}
//
// Revision 1.509  2012/03/22 14:57:38  lulin
// - заготовочка.
//
// Revision 1.508  2012/03/22 06:40:13  lulin
// - чистим код от мусора.
//
// Revision 1.507  2012/03/15 07:27:30  lulin
// {RequestLink:344754050}
// - чистим код.
//
// Revision 1.506  2012/02/01 16:20:29  lulin
// {RequestLink:332566005}
//
// Revision 1.505  2012/01/27 17:49:47  lulin
// {RequestLink:321989072}
//
// Revision 1.504  2012/01/25 16:43:04  lulin
// {RequestLink:326773370}
//
// Revision 1.503  2011/12/21 15:03:33  lulin
// - типизируем исключение о попытке входа в модальный режим.
//
// Revision 1.502  2011/12/14 11:37:58  lulin
// {RequestLink:297703519}
//
// Revision 1.501  2011/11/10 14:11:14  lulin
// {RequestLink:297701079}
//
// Revision 1.500  2011/09/21 18:13:35  lulin
// {RequestLink:278836572}.
//
// Revision 1.499  2011/09/21 17:27:59  lulin
// {RequestLink:278836572}.
//
// Revision 1.498  2011/09/21 16:31:26  lulin
// {RequestLink:278836572}.
//
// Revision 1.497  2011/08/03 17:13:20  lulin
// {RequestLink:276546391}.
//
// Revision 1.496  2011/07/27 14:27:14  lulin
// {RequestLink:276529877}.
//
// Revision 1.495  2011/06/23 17:01:35  lulin
// {RequestLink:254944102}.
//
// Revision 1.494  2011/06/23 12:03:46  dinishev
// [$269080484]. Поддержка Wait:XXX на уровне _vtDialogs
//
// Revision 1.493  2011/06/17 08:00:20  lulin
// - боремся с модальными диалогами.
//
// Revision 1.492  2011/06/08 12:42:24  lulin
// - разбираемся с упавшими тестами.
//
// Revision 1.491  2011/06/08 12:12:32  lulin
// - разбираемся с упавшими тестами.
//
// Revision 1.490  2011/05/04 15:22:37  lulin
// {RequestLink:265404457}.
//
// Revision 1.489  2011/04/20 11:45:20  lulin
// {RequestLink:263292879}.
// - подготавливаем инфраструктуру для возможности прятанья не VCM форм. Правда - пока не понадобилось - ошибка сама собой рассосалась.
//
// Revision 1.488  2011/04/15 14:50:09  lulin
// {RequestLink:228688732}.
// - делаем оснастку для возможности придания каждой медали своего баллона.
//
// Revision 1.487  2011/03/28 12:16:13  lulin
// {RequestLink:259169894}.
//
// Revision 1.486  2011/03/25 16:12:45  lulin
// {RequestLink:259168102}.
//
// Revision 1.485  2011/03/24 19:49:19  lulin
// {RequestLink:256934739}.
//
// Revision 1.484  2011/03/16 18:07:37  lulin
// - не затираем уже существующий заголовок формы.
//
// Revision 1.483  2011/03/15 16:19:41  lulin
// {RequestLink:228688510}.
// [$255978845].
// [$255983129].
// - не даём таскать сплиттер у толкования без перевода.
//
// Revision 1.482  2011/03/15 13:50:50  lulin
// {RequestLink:228688510}.
// - №6.
//
// Revision 1.481  2011/03/10 15:29:46  lulin
// {RequestLink:228688510}.
// - впихиваем ТС в специально подготовленный контейнер.
//
// Revision 1.480  2010/09/17 09:19:59  lulin
// {RequestLink:235048722}.
//
// Revision 1.479  2010/07/15 11:43:17  lulin
// {RequestLink:207389954}.
//
// Revision 1.478  2010/07/15 11:40:38  lulin
// {RequestLink:207389954}.
//
// Revision 1.477  2010/06/01 17:49:17  lulin
// {RequestLink:215549303}.
// - теперь локализуем параметры пользовательских типов форм через стандартный механизм локализации строк.
//
// Revision 1.476  2010/05/31 18:16:11  lulin
// {RequestLink:215549303}.
// - вычищаем всякие Морозовские штучки.
//
// Revision 1.475  2010/05/04 10:16:16  lulin
// {RequestLink:207389954}.
// - bug fix: падали при запуске приложения, т.к. операции контролов публиковались позже _ExcludeUserTypes.
//
// Revision 1.474  2010/04/30 17:44:18  lulin
// {RequestLink:207389954}.
//
// Revision 1.473  2010/04/30 16:22:42  lulin
// {RequestLink:207389954}.
//
// Revision 1.472  2010/04/30 15:15:48  lulin
// {RequestLink:207389954}.
// - чистка комментариев.
//
// Revision 1.471  2010/04/27 18:02:46  lulin
// {RequestLink:159352361}.
// - признак возможности закрытия формы переносим на модель.
//
// Revision 1.470  2010/03/10 12:48:45  lulin
// {RequestLink:193826739}.
//
// Revision 1.469  2010/01/29 12:30:20  lulin
// {RequestLink:184615311}.
//
// Revision 1.468  2010/01/14 17:14:10  lulin
// {RequestLink:177963681}.
//
// Revision 1.467  2010/01/14 13:04:49  lulin
// {RequestLink:177963744}.
//
// Revision 1.466  2009/12/22 16:46:52  lulin
// - удалось запустить тест создающий форму.
//
// Revision 1.465  2009/12/17 11:30:53  oman
// - new: {RequestLink:173933853}
//
// Revision 1.464  2009/11/18 18:47:37  lulin
// {RequestLink:159352361}.
//
// Revision 1.463  2009/11/18 16:31:39  lulin
// {RequestLink:159352361}.
//
// Revision 1.462  2009/11/12 18:08:13  lulin
// - убираем ненужные возвращаемые значения.
//
// Revision 1.461  2009/10/23 12:46:07  lulin
// {RequestLink:167353056}. Пляски с бубном вокруг тулбаров.
//
// Revision 1.460  2009/10/21 17:55:39  lulin
// {RequestLink:167351472}.
//
// Revision 1.459  2009/10/20 13:05:34  oman
// - fix: {RequestLink:167346473}
//
// Revision 1.458  2009/10/19 13:07:58  lulin
// {RequestLink:159360578}. №7.
//
// Revision 1.457  2009/10/16 15:14:30  lulin
// {RequestLink:159360578}. №52.
//
// Revision 1.456  2009/10/15 17:22:48  lulin
// {RequestLink:166856141}. Попытки ещё что-нибудь полечить.
//
// Revision 1.455  2009/10/15 14:42:36  lulin
// {RequestLink:166856141}.
//
// Revision 1.454  2009/10/14 18:39:54  lulin
// {RequestLink:166855347}.
//
// Revision 1.453  2009/10/14 13:24:16  lulin
// - чистка кода.
//
// Revision 1.452  2009/10/13 16:02:42  lulin
// - чистка кода.
//
// Revision 1.451  2009/10/13 15:55:32  lulin
// - чистка кода.
//
// Revision 1.450  2009/10/06 19:02:11  lulin
// {RequestLink:162596818}. Добавляем ссылки на поиски.
//
// Revision 1.449  2009/10/02 19:10:10  lulin
// - окончательно избавился от инициализации форм переменными списками параметров. Всё перевёл на фабрики.
//
// Revision 1.448  2009/10/02 16:48:36  lulin
// - избавляемся от неоправданного вызова операции с параметрами.
//
// Revision 1.447  2009/10/02 14:37:47  lulin
// - форма настройки страницы переведена на фабрику.
//
// Revision 1.446  2009/10/02 13:43:53  lulin
// - теперь формы инициализируются честными параметрами, поданными в фабрику, а не через список переменных параметров.
//
// Revision 1.445  2009/10/01 15:59:32  lulin
// {RequestLink:159360578}. №47.
//
// Revision 1.444  2009/10/01 15:08:25  lulin
// - чистка кода.
//
// Revision 1.443  2009/10/01 14:58:33  lulin
// - убираем сферического коня в вакууме.
//
// Revision 1.442  2009/10/01 12:52:10  lulin
// - вычищаем операции получения информации о закладках. Переходим на простые методы объектов.
//
// Revision 1.441  2009/09/30 16:18:36  lulin
// {RequestLink:159360578}. №44.
//
// Revision 1.440  2009/09/30 15:39:12  lulin
// - чистка кода.
//
// Revision 1.439  2009/09/30 15:23:02  lulin
// - убираем ненужное приведение ко вполне понятным интерфейсам.
//
// Revision 1.438  2009/09/25 12:09:16  lulin
// - выкидываем ненужное.
//
// Revision 1.437  2009/09/24 10:13:08  lulin
// - вычищаем ненужный параметр операции.
//
// Revision 1.436  2009/09/02 11:48:55  lulin
// {RequestLink:159360578}. №20.
//
// Revision 1.435  2009/08/21 12:44:00  lulin
// {RequestLink:159360578}. №8.
//
// Revision 1.434  2009/08/21 12:18:02  lulin
// {RequestLink:159360578}. №8.
//
// Revision 1.433  2009/08/21 11:02:26  lulin
// - меняем порядок инициализации.
//
// Revision 1.432  2009/08/21 07:00:13  oman
// - fix:  {RequestLink:159364476}
//
// Revision 1.431  2009/08/18 17:43:05  lulin
// {RequestLink:159352475}.
//
// Revision 1.430  2009/08/13 13:53:28  lulin
// - убираем ненужные панельки.
//
// Revision 1.429  2009/08/06 16:08:18  lulin
// {RequestLink:159352843}.
//
// Revision 1.428  2009/08/03 18:40:39  lulin
// - используем предусловия.
//
// Revision 1.427  2009/07/29 06:56:39  oman
// - new: {RequestLink:158336069}
//
// Revision 1.426  2009/06/16 12:38:27  lulin
// [$144575595].
//
// Revision 1.425  2009/05/29 09:49:02  lulin
// - вычищаем ненужный код.
//
// Revision 1.424  2009/05/29 09:34:50  lulin
// - всегда нотифицируем системный фреймворк о смене даннах формы.
//
// Revision 1.423  2009/05/29 09:09:53  lulin
// - переписываем код, чтобы проще было читать и править.
//
// Revision 1.422  2009/05/26 10:30:03  oman
// - new: Рисуем пока без клавиатуры - [$148018532]
//
// Revision 1.421  2009/04/21 15:59:59  lulin
// [$124453728]. Параметризуем прецедент Интернет-агента путём, который надо открыть.
//
// Revision 1.420  2009/02/20 18:50:25  lulin
// - <K>: 136941122. Убираем передачу параметров при запросе состояния операции.
//
// Revision 1.419  2009/02/20 17:57:43  lulin
// - <K>: 136941122. Чистка кода.
//
// Revision 1.418  2009/02/20 17:29:21  lulin
// - чистка комментариев.
//
// Revision 1.417  2009/02/20 15:19:08  lulin
// - <K>: 136941122.
//
// Revision 1.416  2009/02/20 11:34:23  lulin
// - избавляемся от завязок на модуль, которые всё равно никто не использует.
//
// Revision 1.415  2009/02/20 11:06:20  lulin
// - избавляемся от завязок на модуль, которые всё равно никто не использует.
//
// Revision 1.414  2009/02/20 10:56:50  lulin
// - избавляемся от завязок на модуль, которые всё равно никто не использует.
//
// Revision 1.413  2009/02/20 10:08:37  lulin
// - чистка комментариев.
//
// Revision 1.412  2009/02/19 14:16:35  lulin
// - <K>: 136941122. Убираем локальные интерфейсы.
//
// Revision 1.411  2009/02/16 12:59:42  lulin
// - <K>: 135604584.
//
// Revision 1.410  2009/02/12 18:42:08  lulin
// - <K>: 135604584. Выделен модуль с интерфейсами диспетчера форм.
//
// Revision 1.409  2009/02/12 18:22:29  lulin
// - <K>: 135604584. Выделен модуль с интерфейсами тулбаров.
//
// Revision 1.408  2009/02/12 17:09:18  lulin
// - <K>: 135604584. Выделен модуль с внутренними константами.
//
// Revision 1.407  2009/02/12 15:08:21  lulin
// - <K>: 135604584. Выделен новый интерфейсный модуль.
//
// Revision 1.406  2009/02/12 12:26:42  lulin
// - <K>: 135604584. Выделен новый интерфейсный модуль.
//
// Revision 1.405  2009/02/04 19:01:57  lulin
// - bug fix: падение при обращении к истории при закрытии приложения.
//
// Revision 1.404  2009/02/04 09:03:19  lulin
// - <K>: 135136020. Переносим из формы на модель.
//
// Revision 1.403  2009/02/03 15:00:41  lulin
// - <K>: 135136020. Переносим код из формы в предка, описанного на модели.
//
// Revision 1.402  2009/01/30 13:51:37  lulin
// - чистка кода.
//
// Revision 1.401  2009/01/28 15:47:23  lulin
// - <K>: 133138664.
//
// Revision 1.400  2009/01/28 12:10:20  lulin
// - <K>: 133138664. №27.
//
// Revision 1.399  2009/01/27 09:25:41  lulin
// - чистка кода.
//
// Revision 1.398  2009/01/19 12:53:37  lulin
// - выводим все интерфейсы, которые обязан реализовывать объект, реализующий данный интерфейс.
//
// Revision 1.397  2008/12/19 13:58:28  lulin
// - <K>: 128288713. Подкладываем под форму контроллер области ввода.
//
// Revision 1.396  2008/12/12 19:19:25  lulin
// - <K>: 129762414.
//
// Revision 1.395  2008/08/27 13:13:59  oman
// - fix: Не учитывали вложенные контролы (K-110986639)
//
// Revision 1.394  2008/08/20 06:24:36  oman
// - fix: Диспетчера может не быть
//
// Revision 1.393  2008/08/19 10:58:03  mmorozov
// - new behaviour: "вручную" обновить строку состояния после закрытия модальной формы, т.к. форме может не прийти CM_ACTIVATE (<K> - 107840079);
//
// Revision 1.392  2008/08/04 07:26:12  oman
// - fix: Некорректно искали вложенную сущность (K-105579285)
//
// Revision 1.391  2008/07/15 12:46:07  lulin
// - <K>: 100958755.
//
// Revision 1.390  2008/07/14 17:43:52  lulin
// - <K>: 100958755.
//
// Revision 1.389  2008/07/08 09:48:44  lulin
// - не перекладываем строки в ноды, а просто реализуем интерфейс ноды.
//
// Revision 1.388  2008/06/25 09:24:06  mmorozov
// - new: Оптимизация панелей инструментов ---|> в списке доступных форм показываем только объединенные панели инструментов + рефакторинг + список форм проекта при редактировании доступных для выбора операций (CQ: OIT5-28281);
//
// Revision 1.387  2008/05/29 12:26:56  mmorozov
// - new: возможность определить от какого типа использовать панель инструментов (CQ: OIT5-28281).
//
// Revision 1.386  2008/04/02 14:22:15  lulin
// - cleanup.
//
// Revision 1.385  2008/03/26 17:59:08  lulin
// - <K>: 88080901.
//
// Revision 1.384  2008/03/26 14:44:23  lulin
// - <K>: 88080898.
//
// Revision 1.383  2008/03/26 11:37:01  lulin
// - зачистка в рамках <K>: 88080898.
//
// Revision 1.382  2008/03/26 11:13:13  lulin
// - зачистка в рамках <K>: 88080898.
//
// Revision 1.381  2008/03/24 15:46:15  lulin
// http://mdp.garant.ru/pages/viewpage.action?pageId=87591840&focusedCommentId=87592645#comment-87592645
//
// Revision 1.380  2008/03/19 14:23:47  lulin
// - cleanup.
//
// Revision 1.379  2008/03/11 13:05:37  oman
// - fix: Пряталась медалька (cq28605)
//
// Revision 1.378  2008/02/28 13:14:08  oman
// - fix: Могли обновлять заголок не своего главного окна (cq28494)
//
// Revision 1.377  2008/01/31 18:53:36  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.376  2007/12/28 17:59:40  lulin
// - удалена ненужная глобальная переменная - ссылка на метод получения настроек.
//
// Revision 1.375  2007/12/25 11:36:35  mmorozov
// - new: подписка на обновление данных приложения (CQ: OIT5-27823);
//
// Revision 1.374  2007/12/21 07:34:29  mmorozov
// - new: подписка на уведомление об обновлении данных (CQ: OIT5-27823);
//
// Revision 1.373  2007/12/12 12:38:21  lulin
// - модуль afwInterfaces теперь генерируется с модели целиком.
//
// Revision 1.372  2007/12/10 12:44:52  mmorozov
// - new: реализуем шаблон publisher\subscriber при редактировании настроек, замены настроек (переключения конфигураций), настройке панелей инструментов (в рамках CQ: OIT5-27823);
//
// Revision 1.371  2007/11/09 10:06:25  oman
// - fix: Не заливались Tl3Strings.Text (cq27322 и еще какая-то)
//
// Revision 1.370  2007/10/15 14:11:56  lulin
// - вычищен устаревший код.
//
// Revision 1.369  2007/10/15 11:28:16  lulin
// - вычищено устаревшее свойство.
//
// Revision 1.368  2007/10/12 15:14:17  lulin
// - вычищено ненужное свойство.
//
// Revision 1.367  2007/10/12 15:04:32  lulin
// - cleanup.
//
// Revision 1.366  2007/10/11 12:41:27  lulin
// - вычищен ненужный метод.
//
// Revision 1.365  2007/08/16 07:01:06  mmorozov
// - format code;
//
// Revision 1.364  2007/08/09 08:07:41  oman
// - fix: Более правильно пытаемся закрывать окно во вкладке
//
// Revision 1.363  2007/08/07 15:06:46  lulin
// - метод регистрации сущностей зовем и тогда когда форма создана фиктивно.
//
// Revision 1.362  2007/08/07 14:23:57  lulin
// - добавлен метод для определения сущностей в run-time.
//
// Revision 1.361  2007/07/27 10:11:13  oman
// - new: Локализуем свойство "EmptyHint" (cq25825)
//
// Revision 1.360  2007/07/26 12:24:30  oman
// - fix: Заточки для локализации vtHeader - новые обработчики
// _OnGetLocalizationInfo (cq24480)
//
// Revision 1.359  2007/05/29 12:06:29  oman
// - fix: Если сначала вытаскивается вложенный контейнер, то во
//   внешнем контейнере "залипает" _ActiveControl от убиваемой формы -
//   расширил условие
//
// Revision 1.358  2007/05/23 12:51:19  oman
// - fix: Если при установке фокуса у нас еще нет _ActiveControl, ставим
//  его на первый доступный контрол (cq25393)
//
// Revision 1.357  2007/05/21 13:33:19  lulin
// - cleanup.
//
// Revision 1.356  2007/05/10 08:14:31  oman
// - new: Новый обработчик OnCreateEx - дергается перед вставкой в
//  контейнер (cq25145)
//
// Revision 1.355  2007/04/10 14:06:24  lulin
// - используем строки с кодировкой.
//
// Revision 1.354  2007/04/10 13:29:11  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.353  2007/03/21 16:17:59  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.352  2007/03/21 09:45:35  lulin
// - исправляем кривые зависимости.
//
// Revision 1.351  2007/03/21 09:33:29  lulin
// - исправляем кривые зависимости.
//
// Revision 1.350  2007/03/20 07:50:40  lulin
// - теперь у формы заголовок поддерживает различные кодировки (отрисовка пока не изменена).
//
// Revision 1.349  2007/03/16 13:56:56  lulin
// - переходим на собственную функцию форматирования строк.
//
// Revision 1.348  2007/03/14 06:49:07  mmorozov
// - change: отказ от рассылки нотификации формой при удалении;
//
// Revision 1.347  2007/03/13 13:56:27  oman
// - fix: При настройке тулбаров не мерджим их - иначе AV (cq24640)
//
// Revision 1.346  2007/03/12 12:36:20  lulin
// - cleanup.
//
// Revision 1.345  2007/03/06 13:35:54  mmorozov
// - new: панель задач;
//
// Revision 1.344  2007/02/12 16:40:31  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.343  2007/02/09 15:11:38  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.342  2007/01/24 13:44:10  mmorozov
// - MERGE WITH B_NEMESIS_6_4;
//
// Revision 1.321.2.12.4.4  2007/01/24 13:30:20  mmorozov
// - cleanup: UnSubscribeToFS;
//
// Revision 1.341  2007/01/23 10:06:19  lulin
// - интерфейсу формы добавлен метод показа в модальном режиме.
//
// Revision 1.340  2007/01/22 06:40:42  mmorozov
// - change: в стилей панелей инструментов используем интерфейс контейнера, а не класс;
//
// Revision 1.339  2007/01/20 15:31:10  lulin
// - разделяем параметры операции для выполнения и для тестирования.
//
// Revision 1.338  2007/01/19 09:47:39  lulin
// - выделяем интерфейс параметров для создания формы.
//
// Revision 1.337  2007/01/18 13:54:21  oman
// - new: Локализация библиотек - vcm - избавляемся от значений по
//  умолчанию - более радикальный вариант (cq24078)
//
// Revision 1.336  2007/01/18 13:33:55  oman
// - new: Локализация библиотек - vcm - избавляемся от значений по
//  умолчанию (cq24078)
//
// Revision 1.335  2007/01/18 11:47:41  oman
// - new: Локализация библиотек - vcm (cq24078)
//
// Revision 1.334  2006/12/27 15:20:27  mmorozov
// - new behaviour: не инициализируем стиль в Design-Time;
//
// Revision 1.333  2006/12/27 15:05:21  mmorozov
// - new: проверка необходимости сохранения стиля формы;
//
// Revision 1.332  2006/12/27 14:44:57  mmorozov
// - change: механизм объединения панелей инструментов (CQ: OIT5-23903);
//
// Revision 1.331  2006/12/25 09:08:57  mmorozov
// - new behaviour: если у формы определен компонент "строка состояния", то у формы создается контейнер для зон стыковки. Для исключения случая когда панели инструментов попадают под строку состояния (CQ: OIT5-23903);
//
// Revision 1.330  2006/12/22 12:19:26  oman
// - new: Для статусбара кроме списка строк передаем еще признак о
//  необходимости вывода переливающегося  прогресс-индикатора
//  (cq23938)
//
// Revision 1.329  2006/12/13 09:22:08  mmorozov
// - new: возможность указывать фиксированный размер для зон стыковки панелей инструментов формы, в рамках работы над CQ: OIT5-13323;
//
// Revision 1.328  2006/12/10 18:26:07  lulin
// - не вычисляем каждый раз идентификатор формы.
//
// Revision 1.327  2006/12/10 17:45:18  lulin
// - cleanup.
//
// Revision 1.326  2006/12/10 17:34:41  lulin
// - cleanup.
//
// Revision 1.325  2006/12/10 16:35:38  lulin
// - cleanup.
//
// Revision 1.324  2006/12/07 13:22:48  lulin
// - убрана запись свойств по-умолчанию.
//
// Revision 1.323  2006/11/13 15:21:08  oman
// Merge from B_NEMESIS_6_4
//
// Revision 1.322  2006/11/03 11:00:34  lulin
// - объединил с веткой 6.4.
//
// Revision 1.321.2.12.4.1  2006/11/13 15:18:57  oman
// - fix: Если форма создана виртуально, то не выдергиваем для нее
//  OnCloseQuery (cq23616)
//
// Revision 1.321.2.12  2006/10/25 09:51:35  oman
// - fix: Не выливали/заливали хинты у контролов (cq23207)
//
// Revision 1.321.2.11  2006/10/23 15:02:15  oman
// - fix: Заливаем Items.Text (cq23158)
//
// Revision 1.321.2.10  2006/10/23 12:47:45  mmorozov
// - bugfix: ограничение размеров формы (навеяно UltraMon, быстрый перенос окон);
//
// Revision 1.321.2.9  2006/10/23 07:41:03  lulin
// - заливаем свойство Text.
//
// Revision 1.321.2.8  2006/10/18 08:23:41  lulin
// - bug fix: не локализовывались вторые копии форм.
//
// Revision 1.321.2.7  2006/10/18 08:00:34  lulin
// - заголовок для настроек приобрел общее название.
//
// Revision 1.321.2.6  2006/10/17 12:21:07  lulin
// - bug fix: заливались не все контролы.
//
// Revision 1.321.2.5  2006/10/17 12:11:16  mmorozov
// - bugfix: реакция на изменение размеров формы меньше допустимых;
//
// Revision 1.321.2.4  2006/10/17 11:08:13  lulin
// - bug fix: заливались не все контролы.
//
// Revision 1.321.2.3  2006/10/17 09:19:06  lulin
// - bug fix: не все контролы локализовывались.
//
// Revision 1.321.2.2  2006/10/17 08:13:21  lulin
// - заголовки контролов вычитываем из загруженных ресурсов.
//
// Revision 1.321.2.1  2006/10/16 14:09:45  mmorozov
// - bugfix: при достижении минимальных размеров окно не перемещается вправо(вниз) (CQ: OIT5-22919);
//
// Revision 1.321  2006/10/10 13:22:00  mmorozov
// - bugfix: избавляемся от мерцания; определяем положение формы до ее показа; (CQ: OIT500022932);
//
// Revision 1.320  2006/06/08 13:38:03  lulin
// - подготавливаем контролы к обработке числа повторений нажатия клавиши.
//
// Revision 1.319  2006/05/23 07:12:02  mmorozov
// - new behaviour: отказываемся от публикации операции для записи в настройки перед сменой конфигурации, открытия диалога настроек. Вместо этого поддерживаем интерфейс IvcmSettingsUser (CQ: 21000);
//
// Revision 1.318  2006/05/16 12:44:28  oman
// - fix:  задвоение основной области (cq20934)
//
// Revision 1.317  2006/05/15 09:21:03  oman
// - fix: При вложенном контейнере в контейнере неправильно определялся
//  _ActiveControl (cq20702)
//
// Revision 1.316  2006/04/18 09:03:50  oman
// cleanup (убирание rCaption из vcmPathPair)
//
// Revision 1.315  2006/03/30 14:17:04  lulin
// - cleanup.
//
// Revision 1.314  2006/03/30 14:02:57  lulin
// - операция инициализации разделена на две - с параметрами и без - для того, чтобы в итоге избавится от первой.
//
// Revision 1.313  2006/03/30 12:39:28  lulin
// - вытерто ненужное событие.
//
// Revision 1.312  2006/03/24 10:10:49  lulin
// - cleanup: не пишем пустые коллекции.
//
// Revision 1.311  2006/03/21 11:34:05  mmorozov
// - change: comment;
//
// Revision 1.310  2006/03/21 11:07:58  mmorozov
// - new: у сборки появилось понятие смены позиции (CQ: 17125);
//
// Revision 1.309  2006/03/16 14:12:56  lulin
// - убрана возможность изменения входного параметра - идентификатора операции.
//
// Revision 1.308  2006/03/15 12:27:24  lulin
// - cleanup.
//
// Revision 1.307  2006/03/14 15:06:57  lulin
// - bug fix: не обновлялся заголовок основного окна.
//
// Revision 1.306  2006/03/14 14:32:58  lulin
// - вычитываем имена форм из ресурсов.
//
// Revision 1.305  2006/03/14 13:04:54  lulin
// - разделяем UserType'ы в репозитарии и в формах.
//
// Revision 1.304  2006/03/13 14:25:10  mmorozov
// - warning fix;
// - new behaviour: всегда запоминаем новый _DataSource, событие ChangedDataSource вызывается в случае если старый и новый DS не равны;
//
// Revision 1.303  2006/02/09 08:46:00  mmorozov
// - new behaviour: не верно определялся активный компонент формы, в следствии чего в параметры операции подавался не верный компонент (CQ: 19429);
//
// Revision 1.302  2006/02/07 15:47:22  mmorozov
// - new: вес UserType-а формы можно изменять динамически в Run-Time-е она автоматически будет переразмещена в PageControl-е;
// - рефакторинг ElPgCtl: упрощена процедура стыковки компонента на PC; объединены интерфейсы, в следствии чего изжит IelpcNotifyPageChanged;
// - new: появилась возможность при обновлении сборки указывать веса форм;
//
// Revision 1.301  2006/02/02 14:48:46  mmorozov
// new: вычисление модуля в котором зарегистрирована формы, по классу формы;
// change: убрано указание модуля при создании формы;
//
// Revision 1.300  2006/01/30 13:13:29  mmorozov
// new behaviour: установка активной первой закладки при обновлении новой сборки;
//
// Revision 1.299  2005/12/15 12:22:20  mmorozov
// - cleanup: вычещены методы Close у FormDataSources, для работы достаточно нотификации об уничтожении FormDataSource;
//
// Revision 1.298  2005/12/15 11:43:26  mmorozov
// - new: уведомление бизнес объекта о закрытии формы руками;
//
// Revision 1.297  2005/12/08 16:10:15  oman
// cleanup (лишний приватный метод)
//
// Revision 1.296  2005/12/08 13:15:29  oman
// - new behavior: обработка операции System_WriteBackSettings - заточка
// перед рефакторингом настроек
//
// Revision 1.295  2005/11/21 14:20:34  mmorozov
// change: откат изменений;
//
// Revision 1.294  2005/11/21 09:04:32  mmorozov
// new behaviour: при смене бизнес объекта формы, по причине перехода по истории, обновляем ссылку на этот бизнес объект в бизнес объекте сборки;
//
// Revision 1.293  2005/11/04 12:37:06  mmorozov
// change: форме позже устанавливается _DataSource, после инициализации компонентов формы интерфейсом работы с настройками;
//
// Revision 1.292  2005/10/21 14:23:39  mmorozov
// change: переименована функция;
//
// Revision 1.291  2005/10/19 08:14:18  mmorozov
// bugfix: сломалось управление закладками;
//
// Revision 1.290  2005/10/13 12:38:17  mmorozov
// new behaviour: при смене _DataSource у формы, меняем агрегацию;
//
// Revision 1.289  2005/10/05 14:25:43  mmorozov
// new: у vcmEntityForm появился дополнительный идентификатор SubUserType;
//
// Revision 1.288  2005/10/04 10:06:11  mmorozov
// new: вложенная в контейнер форма уведомляет его о смене источника данных (событие на контейнере OnChildDataSourceChanged);
// new: на контейнере новое событие OnNeedUpdateTab (вызывается при вставке формы и смене _DataSource у вложенной формы);
//
// Revision 1.287  2005/09/28 18:16:21  mmorozov
// new: в ChangedDataSource подается параметр aFromHistory;
//
// Revision 1.286  2005/09/23 16:17:24  demon
// - fix: в операции Subscribe был неверный вызов RemoveEntity
//
// Revision 1.285  2005/09/23 10:10:22  lulin
// - bug fix: при шагании по истории не изменялся _DataSource формы.
//
// Revision 1.284  2005/09/22 16:30:32  mmorozov
// new behaviour: методы для работы с закладками не органичиваются опросом ближайшего родителя, делают это пока не закончатся родители или не придет ответ от закладки;
//
// Revision 1.283  2005/09/22 11:05:55  mmorozov
// - работа с историей в контексте сборок;
//
// Revision 1.282  2005/09/13 13:18:25  mmorozov
// - warning fix;
//
// Revision 1.281  2005/09/08 13:14:13  lulin
// - скобка закрывалась слишком поздно.
//
// Revision 1.280  2005/08/25 12:52:34  lulin
// - new behavior: по возможности используем не имена, а индексы форм.
//
// Revision 1.279  2005/08/05 07:17:05  mmorozov
// change: сигнатура TvcmChangedDataSourceEvent;
//
// Revision 1.278  2005/08/03 12:08:40  mmorozov
// new: регистрация формы в сборке;
//
// Revision 1.277  2005/08/02 12:50:40  mmorozov
// new: property _OnChangedDataSource;
//
// Revision 1.276  2005/07/27 13:55:30  lulin
// - IvcmFormSetFactoryDataSource сделан сохраняемым в историю.
//
// Revision 1.275  2005/07/27 10:20:23  lulin
// - теперь в параметрах есть свойство, указывающее, что форма создается из истории.
//
// Revision 1.274  2005/07/26 14:50:06  mmorozov
// new: реализация новых методов _IvcmEntityForm;
//
// Revision 1.273  2005/07/13 15:12:46  mmorozov
// - изменения связанные с измерением загрузки документа;
//
// Revision 1.272  2005/07/11 06:33:56  lulin
// - bug fix: был AV при попытке записи в лог, когда модальную форму уже убили.
//
// Revision 1.271  2005/07/08 12:30:41  mmorozov
// new: profile _TvcmEntityForm._Make;
//
// Revision 1.270  2005/06/27 13:21:16  mmorozov
// - не компилировалась библиотека;
//
// Revision 1.269  2005/06/27 07:14:47  mmorozov
// new: method InitSettingsSource (_TvcmEntityForm);
// new behaviour: инициализируем держателей интерфейса _IvcmSettingsSource после конструирования формы и установки UserType;
//
// Revision 1.268  2005/06/23 16:01:49  mmorozov
// change: в метод _Entities._LinkControls подаем BaseId (идентификатор настройки формы);
//
// Revision 1.267  2005/06/02 07:33:34  mmorozov
// new behaviour: при формировании TvcmUserTypeDef устанавливаем ему UserVisibleOperationsCount;
//
// Revision 1.266  2005/03/30 13:37:04  am
// change: откатил предыдущее
//
// Revision 1.264  2005/03/30 12:57:24  lulin
// - bug fix: при задании UserType'а не менялось HelpKeyword (CQ OIT5-12988).
//
// Revision 1.263  2005/03/11 07:46:08  mmorozov
// new: определяем Caption формы на основании UserType-а;
//
// Revision 1.262  2005/02/25 14:41:22  mmorozov
// new: _TvcmEntityForm держит список dock-ов;
// new: _TvcmEntityForm properties DocksHeight, DocksWidth;
//
// Revision 1.261  2005/02/14 14:36:40  am
// bugfix: док для плавающих тулбаров сохранялся неправильно (правда в виде ошибки это проявилось в одной форме из всех, в виде восстановления на доке вместо плавающего состояния)
//
// Revision 1.260  2005/01/27 13:43:30  lulin
// - bug fix: не все контролы отвязывались от операций (CQ OIT5-11924).
//
// Revision 1.259  2005/01/14 17:24:21  lulin
// - в ProcessCommand добавлен параметр aForce - сигнализирующий, что такого ShortCut'а нету в VCM и что не надо умничать с обработкой комманды.
//
// Revision 1.258  2005/01/14 10:42:32  lulin
// - методы Get*ParentForm переехали в библиотеку AFW.
//
// Revision 1.257  2005/01/12 12:02:41  lulin
// - транслируем запрос интерфейсов от proxy объектов к форме.
//
// Revision 1.256  2005/01/11 08:19:54  lulin
// - bug fix: не компилировалось.
//
// Revision 1.255  2004/12/25 12:06:17  mmorozov
// - warning fix;
//
// Revision 1.254  2004/12/24 13:49:42  lulin
// - bug fix: очередной раз отъехало обновление Caption формы _Preview.
//
// Revision 1.253  2004/12/24 12:03:58  am
// bugfix: не проверяли на существование _Entities в _GetInner
//
// Revision 1.252  2004/12/23 10:05:07  lulin
// - компоненты теперь могут сами сообщать значения для строки статуса - в частности это сделано в списке.
//
// Revision 1.251  2004/12/23 07:27:56  lulin
// - перевел обработку статусной строки на библиотеку AFW.
//
// Revision 1.250  2004/12/21 11:40:04  mmorozov
// new: операции сущностей привязанных к TComponent вызываются всегда, не зависимо от фокуса;
//
// Revision 1.249  2004/12/17 12:44:07  mmorozov
// new: в _LinkControls подаём IvcmSettings;
//
// Revision 1.248  2004/12/09 15:26:05  lulin
// - new behavior: обновляем статусную строку после каждой операции.
//
// Revision 1.247  2004/11/24 14:54:18  lulin
// - bug fix: регистрируем операции из контролов в правильном месте - чтобы они появлялись в Design-Time.
//
// Revision 1.246  2004/11/23 10:30:50  am
// change: перетащил _vcmGetHelpKeyword в vcmUtils
//
// Revision 1.244  2004/11/18 16:29:57  lulin
// - отвязываем библиотеки от VCM без использования inc'ов.
//
// Revision 1.243  2004/11/17 15:29:27  am
// change: нормальная работа и при несуществующем _Dispatcher'е
// change: перенёс код, выставляющий HelpContext из _Make в Create
//
// Revision 1.242  2004/11/17 10:18:35  am
// change: поменял дефайны для _NeedCancelModal
//
// Revision 1.241  2004/11/17 10:01:09  am
// change: дефайны
//
// Revision 1.240  2004/11/16 15:42:35  am
// change: перекрываем _NeedCancelModal
//
// Revision 1.239  2004/11/16 14:51:16  mmorozov
// new: при создании формы если она не вписывается в размеры экрана, то ее размер корректируется (формы с не изменяемыми размерами масштабируются до тех пока не впишутся в размер экрана);
//
// Revision 1.238  2004/11/12 15:02:45  am
// change: выташил HasFormFloatingZoneTypeAndVisible из локальных процедур в методы класса, сделал виртуальной. Самый простой способ в форме наследнике запретить show\_hide форм при переключении фокуса
//
// Revision 1.237  2004/10/15 12:36:27  am
// change: открутил сохранение главного тулбара совместно с сохраняемым.
//
// Revision 1.236  2004/10/13 16:21:42  mmorozov
// new behaviour: при изменении родителя используем g_MenuManager.SaveFormZones и расслаем нотификацию;
//
// Revision 1.235  2004/10/13 14:18:04  am
// change: сделал LoadState/_SaveState виртуальными
//
// Revision 1.234  2004/10/13 13:54:58  am
// change: сделал LoadState/_SaveState виртуальными
//
// Revision 1.233  2004/10/12 14:21:43  am
// change: вызываем LockPopupMessage/UnlockPopupMessage в _ShowModal
//
// Revision 1.232  2004/10/11 08:42:22  mmorozov
// - не компилировался пакет;
//
// Revision 1.231  2004/10/09 08:43:17  mmorozov
// new: при изменении родителя сохраняем параметры формы в настройки;
//
// Revision 1.230  2004/10/07 14:17:04  lulin
// - new: теперь у _IvcmParams можно присваивать только свойство DoneStatus - код завершения. На основе этого "по-хитрому" обрабатываем ShortCut'ы для запрещенных операций (CQ OIT5-10123).
//
// Revision 1.229  2004/10/05 11:54:55  mmorozov
// new: поддержан _IvcmEntityForm._ZoneControl;
//
// Revision 1.228  2004/09/27 14:34:27  am
// change: прикрутил к форме обработку шорткатов
//
// Revision 1.227  2004/09/27 14:22:41  lulin
// - bug fix: по-новому формируем идентификаторы страниц help'а.
//
// Revision 1.226  2004/09/24 13:46:28  fireton
// - bug fix: починка design time для форм VCM
//
// Revision 1.225  2004/09/23 13:37:48  lulin
// - bug fix: внутри операции не освобождались модальные формы (CQ OIT5-9796).
//
// Revision 1.224  2004/09/22 09:34:36  lulin
// - оптимизщация - кешируем результат преобразования Name -> ID при посылке операций.
//
// Revision 1.223  2004/09/14 12:32:17  lulin
// - bug fix: _UpdateMainCaption стало вызываться слишком рано.
//
// Revision 1.222  2004/09/14 12:12:25  fireton
// - bug fix: нарушение Z-order в модальных окнах
//
// Revision 1.221  2004/09/13 14:27:53  mmorozov
// new: method _TvcmEntityForm.NotifyContainer;
//
// Revision 1.220  2004/09/11 11:37:33  lulin
// - cleanup.
//
// Revision 1.219  2004/09/11 10:59:37  lulin
// - кешируем список описателей сущностей.
//
// Revision 1.218  2004/09/11 10:32:22  lulin
// - small fix.
//
// Revision 1.217  2004/09/11 09:48:52  lulin
// - bug fix: оставалась закладка при переходе по истории.
//
// Revision 1.216  2004/09/10 16:54:32  mmorozov
// new: methods RegInContainer, UnregInContainer;
//
// Revision 1.215  2004/09/10 12:47:43  lulin
// - new type: TvcmEffectiveUserType.
// - new behavior: не возвращаем интерфейсы для операции, если у нее нету имени.
//
// Revision 1.214  2004/09/10 12:23:57  lulin
// - оптимизация - гораздо аккуратнее обращаемся с UserType'ами и VisibleOpCount. В итоге уменьшено количество различных вызовов.
//
// Revision 1.213  2004/09/10 10:39:32  lulin
// - закомментировал вчерашнюю оптимизацию с убиванием Handle, т.к. пока есть проблемы с фокусом.
//
// Revision 1.212  2004/09/09 16:44:30  mmorozov
// change: _TvcmEntityForm._Make (Восстанавливаем удаленное, перед построением меню и toolbar-ов в  TvcmCustomMenuManager . RegisterChildInMenu, окно, чтобы не было артефактов отрисовки);
//
// Revision 1.211  2004/09/09 13:56:31  lulin
// - эксперименты с уменьшением количества вызовов оконной процедуры в процессе создания новой формы (пока все закоментированно).
//
// Revision 1.210  2004/09/08 07:15:36  am
// bugfix: _ManualUpdateActions
//
// Revision 1.209  2004/09/07 16:19:49  law
// - перевел VCM на кшированные обьекты.
//
// Revision 1.208  2004/09/07 08:54:52  am
// bugfix: _ManualUpdateActions
//
// Revision 1.207  2004/09/06 12:07:14  am
// change: теперь при Unlock диспетчера, во время вызовов ManualUpdateActinos, не бегаем по одним и тем же формам
//
// Revision 1.206  2004/09/03 11:46:41  mmorozov
// new: property _TvcmEntityForm.IsSmallImages;
//
// Revision 1.205  2004/09/03 10:14:09  am
// bugfix: _ManualUpdateActions
//
// Revision 1.204  2004/09/03 06:55:26  am
// change: если _ManualUpdateActions вызывают при залоченном диспетчере, откладываем вызов до разлочивания.
//
// Revision 1.203  2004/09/02 04:54:26  am
// new: _TvcmEntityFormImplementation._MakeAggregate
//
// Revision 1.202  2004/08/31 07:57:01  am
// change: перенёс вычисление "видимости" операции с def'а на item
//
// Revision 1.201  2004/08/27 07:36:22  am
// new: новое свойство у юзертипа - _LongCaption - показывается в диалоге настройки тулбаров
//
// Revision 1.200  2004/08/26 11:30:09  am
// bugfix: _GetUserTypes
//
// Revision 1.199  2004/08/26 11:14:38  am
// bugfix: _GetUserVisibleOperationsCount
//
// Revision 1.198  2004/08/26 09:14:16  fireton
// - аварийный commit ;)
//
// Revision 1.197  2004/08/25 17:02:28  law
// - cleanup.
//
// Revision 1.196  2004/08/25 14:02:43  am
// change: снимаем лок отрисовки перед показом модальной формы
//
// Revision 1.195  2004/08/19 14:21:58  am
// new: _GetUserVisibleOperationsCount
// change: при создании UserType прописываем ему число видимых пользователю операций
//
// Revision 1.194  2004/08/11 16:14:25  law
// - более просто из ContextID вычисляем KeyWord.
//
// Revision 1.193  2004/08/11 14:56:24  law
// - bug fix: не вызывался Help для Control'ов.
//
// Revision 1.192  2004/08/11 14:30:00  law
// - new behavior: сделан вызов Help'а для пунктов меню.
//
// Revision 1.191  2004/08/11 09:06:50  law
// - bug fix: при отсутствии UserType'а не показывалась контекстная справка (CQ OIT5-8606).
//
// Revision 1.190  2004/08/05 08:09:06  am
// change: при поднятии модальной формы прячем видимые плавающие формы. После закрытия модальной - показываем.
//
// Revision 1.189  2004/08/04 14:05:01  am
// change: перед _ShowModal vcm'ной формы для всех floating форм вызываем SafeClose
//
// Revision 1.188  2004/08/02 16:10:51  law
// - new methods: _TvcmEntityForm._Lock/Unlock.
//
// Revision 1.187  2004/08/02 15:52:25  law
// - new methods: _IvcmEntityForm._LockFocus/UnlockFocus.
//
// Revision 1.186  2004/08/02 14:05:40  law
// - открутил VCM от тесной интеграции с моделью Немезиса.
//
// Revision 1.185  2004/07/27 12:12:16  law
// - new prop: _TvcmEntityForm.AfterToolbarsInited.
//
// Revision 1.184  2004/07/14 13:51:55  law
// - добавлен define.
//
// Revision 1.183  2004/07/14 13:49:31  law
// - optimiztion: пореже создаем формы сущностей.
// - optimization: стараемся не создавать Handle форм только для информации.
//
// Revision 1.182  2004/07/13 10:43:21  law
// - bug fix: операции передавались из модальной формы ее контейнеру.
//
// Revision 1.181  2004/07/13 07:22:12  am
// change: при сохранении тулбара, независимо от его состояния, сохраняем плавающие координаты
//
// Revision 1.180  2004/07/05 13:44:14  voba
// -bug fix: не скрывались "зависимые" окна при минимизации "основного"
//
// Revision 1.179  2004/06/25 08:45:30  voba
// - bug fix : Передавался фокус с модального окна
//
// Revision 1.178  2004/06/21 15:46:49  mmorozov
// - заглушка для комментария;
//
// Revision 1.177  2004/06/02 10:59:47  mmorozov
// bugfix: в _TvcmEntityFormImplementation._SaveState проверяем что _f_Form <> nil;
//
// Revision 1.176  2004/06/02 10:20:50  law
// - удален конструктор Tl3VList.MakeIUnknown - пользуйтесь _Tl3InterfaceList._Make.
//
// Revision 1.175  2004/06/01 13:20:18  nikitin75
// _SetMyFocus только для парент-зоны
//
// Revision 1.174  2004/05/27 11:37:31  am
// new: _Lock\Unlock - пока предотвращают установку\снятие фокуса, когда лок установлен. В дальнейшем ещё на что-нить можно распространить.
//
// Revision 1.173  2004/05/24 13:13:07  law
// - bug fix: при смене фокуса не очищалась строка статуса (CQ OIT5-6941).
//
// Revision 1.172  2004/05/20 16:49:36  law
// - метим контролы.
//
// Revision 1.171  2004/05/19 12:56:57  am
// change: бэкапим состояние счётчика локов перед _ShowModal
//
// Revision 1.170  2004/04/19 09:15:26  mmorozov
// new: не сохраняем значения по умолчанию для OnQueryHints;
//
// Revision 1.169  2004/04/16 08:32:42  mmorozov
// new: properties QueryMaximizedHint, QueryOpenHint, QueryCloseHint;
// new: общие методы для определения событий OnQuerty и hint-ов к ним на форме;
//
// Revision 1.168  2004/04/12 08:10:43  nikitin75
// + _IvcmEntityForm.IsModalForm;
// + по shortcut не зовем операцию модуля, если форма активной сущноси модальная;
//
// Revision 1.167  2004/04/09 16:20:06  law
// - bug fix: борьба с остающимися объектами.
//
// Revision 1.166  2004/04/07 14:41:10  law
// - bug fix: не закрывалась модальная форма.
//
// Revision 1.165  2004/04/06 10:32:34  mmorozov
// new: method SetActiveAndShowInParent;
// change: методы _SetActiveInParent, _SetInactiveInParent, _IsActiveInParent реализованы в _TvcmEntityForm, _TvcmEntityFormImplementation вызываем методы _TvcmEntityForm;
//
// Revision 1.164  2004/04/06 06:29:48  mmorozov
// bugfix: в процедурах SetActiveInParent, _SetInactiveInParent, _IsActiveInParent в сообщениях передавался интерфейс, а не форма;
//
// Revision 1.163  2004/04/05 16:55:32  law
// - cleanup: удален метод виртуальный _TvcmEntityForm.BuildMenus - как ненужный.
//
// Revision 1.162  2004/04/05 16:50:14  law
// - new behavior: если Owner'а не задавали, то делаем, чтобы он в итоге стал равным контейнеру (CQ OIT5-6946).
//
// Revision 1.161  2004/04/05 16:13:29  law
// - bug fix: восстановил вызов события OnClose у формы - это Лехе Никитину надо было для контекстного поиска.
//
// Revision 1.160  2004/04/05 15:49:36  law
// - new behavior: в _DoClose VCM'ной формы вставлен Assert о необходимости пользоваться другим методом.
//
// Revision 1.159  2004/04/05 10:54:06  migel
// - fix: CQ6822, активируем окно по клику мыши, если над ним "висит" модальная форма.
//
// Revision 1.158  2004/04/04 17:44:32  migel
// - fix: проблемы с фокусом.
//
// Revision 1.157  2004/04/01 13:44:43  law
// - bug fix: поиск по истории при _MakeSingleChild не учитывал GUID формы (CQ OIT5-6957).
//
// Revision 1.156  2004/03/31 06:14:27  nikitin75
// _IsMainObjectForm добавлен параметр aOrModal: Boolean;
//
// Revision 1.155  2004/03/30 10:26:08  mmorozov
// new: methods _TvcmEntityForm (_IsActiveInParent, SetActiveInParent, _SetInactiveInParent);
//
// Revision 1.154  2004/03/29 16:56:47  law
// - bug fix: ошибка "Interface not supported" при закрытии приложения с окном фильтров в плавающем навигаторе.
//
// Revision 1.153  2004/03/26 16:10:40  mmorozov
// no message
//
// Revision 1.152  2004/03/26 15:45:32  mmorozov
// new: реализованы методы активации формы интерфейса _IvcmEntityForm;
//
// Revision 1.151  2004/03/26 14:33:49  am
// change: сохранение тулбаров
//
// Revision 1.150  2004/03/26 10:48:01  am
// change: сброс\восстановление лока доков в _ShowModal
//
// Revision 1.149  2004/03/26 10:21:16  mmorozov
// bugfix: aParams.Container не приходил в операцию;
//
// Revision 1.148  2004/03/25 08:56:45  law
// - change: изменен тип параметра anOwner.
//
// Revision 1.147  2004/03/24 14:45:58  law
// - new define: vcmGetToolbarPosesFromContainer - включен для Немезиса.
//
// Revision 1.146  2004/03/24 10:33:18  nikitin75
// + SetFocus in _SetMyFocus if _IsMainObjectForm;
//
// Revision 1.145  2004/03/23 13:42:46  law
// - new behavior: сохраняем размеры зон (CQ OIT5-6694).
//
// Revision 1.144  2004/03/23 13:27:33  nikitin75
// + SetFocus in _SetMyFocus;
//
// Revision 1.143  2004/03/23 07:05:44  am
// change: не записываем\загружаем позиции тулбаров при вызове из "диалога настройки тулбаров"
//
// Revision 1.142  2004/03/22 17:00:15  law
// - bug fix: Закрытие первого окна немезиса ведет к закрытию только что открытого нового (CQ OIT5-6999).
//
// Revision 1.141  2004/03/16 16:38:03  am
// change: DoSaveInSettings из protected в _public
//
// Revision 1.140  2004/03/16 08:47:50  am
// new: Сохранение формы плавающего тулбара
//
// Revision 1.139  2004/03/15 12:21:44  migel
// - fix: для модальных форм не убираем кнопку `maximize`.
//
// Revision 1.138  2004/03/13 14:26:27  law
// - new behavior: сохраняем состояние формы до сохранения состояния контролов (CQ OIT5-6401).
//
// Revision 1.137  2004/03/11 17:02:46  law
// - bug fix: неправильно показывалась форма выбора атрибутов из ППР.
// - new behavior: запоминаем/восстанавливаем состояние формы Floating.
//
// Revision 1.136  2004/03/05 14:33:49  law
// - new behavior: при реальном закрытии формы уже ничего не записываем.
//
// Revision 1.135  2004/03/05 08:39:24  am
// new: TvcmCustomMenuManager.MergedToMainForm - смержены ли тулбары данной формы в главную форму.
//
// Revision 1.134  2004/03/04 09:37:33  am
// change: MainForm.MenuManager в загрузке форм ->g_MenuManager
//
// Revision 1.133  2004/03/04 08:10:52  am
// new: SaveToolbars
//
// Revision 1.132  2004/03/02 07:51:44  am
// bugfix: IfDef'ы
//
// Revision 1.131  2004/03/01 14:52:21  am
// new: сохранение позиций при закрытии формы
//
// Revision 1.130  2004/03/01 14:24:09  law
// - bug fix: поставлена заплатка на чтение положения и размеров форм в подходящий момент.
//
// Revision 1.129  2004/03/01 13:53:30  law
// - new behavior: сохраняем/восстанавливаем положение и размеры всех плавающих и модальных форм.
//
// Revision 1.128  2004/03/01 12:09:06  law
// - change: задел на сохранение позиции и размеров всех "плавающих" форм, а не только основной.
//
// Revision 1.127  2004/02/28 10:40:52  law
// - new prop: _IvcmEntityForm._CurUserTypeDef.
//
// Revision 1.126  2004/02/26 12:46:00  demon
// - new behavior: объект TvcmStateItem при QueryInterface получил возможность дополнительно спрашивать его у поля _f_State
// - new behavior: TvcmFormState теперь поддерживает интерфейс IvcmDataReset
//
// Revision 1.125  2004/02/11 12:18:41  law
// - new behavior: пересоздаем Toollbar'ы для всех заинтересованных форм.
//
// Revision 1.124  2004/02/10 15:35:19  law
// - new prop: IvcmUserTypeDef.FormClass.
//
// Revision 1.123  2004/02/10 15:28:54  law
// - new prop: IvcmUserTypeDef.ID.
//
// Revision 1.122  2004/02/10 14:59:12  law
// - change: вместо пары UserType.Name/Caption используем интерфейс IvcmUserTypeDef.
//
// Revision 1.121  2004/02/10 12:59:52  law
// - change: IvcmUserTypesIterator теперь возвращает IvcmUserTypeDef.
//
// Revision 1.120  2004/02/09 17:14:06  law
// - new unit: vcmUserTypeDef
//
// Revision 1.119  2004/02/05 12:44:34  law
// - new interface: IvcmUserInteractive.
//
// Revision 1.118  2004/02/04 11:24:54  am
// change: prop _ToolbarPos теперь всегда stored False;
//
// Revision 1.117  2004/01/30 14:15:09  law
// - bug fix: в EntityFormDef приходили неправильные имена.
//
// Revision 1.116  2004/01/29 16:16:30  law
// - new class method: _TvcmEntityForm._FormID.
//
// Revision 1.115  2004/01/22 19:13:05  law
// - remove method: _TvcmEntityForm.GetUserTypesIterator.
//
// Revision 1.114  2004/01/22 19:01:31  law
// - bug fix: забыл, что итераторов можно получать несколько.
//
// Revision 1.113  2004/01/22 18:42:45  law
// - new prop: IvcmEntityFormDef.UserTypesIterator.
//
// Revision 1.112  2004/01/22 18:27:03  law
// - new behavior: _TvcmEntityForm теперь поддерживает интерфейс IvcmEntityFormDef.
//
// Revision 1.111  2004/01/22 18:21:03  law
// - new prop: _IvcmEntityForm.FormDef.
//
// Revision 1.110  2004/01/22 18:07:23  law
// - new unit: vcmEntityFormDef.
// - new class: TvcmEntityFormDef.
//
// Revision 1.109  2004/01/22 17:44:51  law
// - new method: _TvcmEntityForm.GetUserTypesIterator.
//
// Revision 1.108  2004/01/16 13:04:24  law
// - new behavior: если форма "закрывается", то она не обрабатывает операции.
//
// Revision 1.107  2004/01/14 17:12:13  migel
// - fix: прячем плавующие окна при переключении на другогое приложение и показываем при переключении обратно.
//
// Revision 1.106  2004/01/12 14:48:14  am
// change: работа контекстных операций из выпадающего окна тулбара (vcmEntityForm._getInner)
//
// Revision 1.105  2004/01/08 17:55:08  migel
// - fix: устанавливаем фокус (+активный контрол), если форма может его принимать.
//
// Revision 1.104  2003/12/26 16:51:20  law
// - new behavior: переделана логика обработки BottonCombo - теперь если меню нету, то и стрелки вниз нету.
// - bug fix: иногда при восстановлении из истории портился Caption главного окна.
//
// Revision 1.103  2003/12/25 15:53:51  law
// - new behavior: не сохраняем повторно закрываемую форму.
//
// Revision 1.102  2003/12/25 11:59:24  mmorozov
// + published property: _TvcmEntityForm.OnQueryOpen;
//
// Revision 1.101  2003/12/25 08:19:04  migel
// - fix: не перекрываем `WndProc` в дезайнтайм.
//
// Revision 1.100  2003/12/18 10:55:37  law
// - new behavior: пересоздаем окно только для модальных форм.
//
// Revision 1.99  2003/12/15 19:29:47  mmorozov
// + функция проверки диапазона UserType _TvcmEntityForm.CheckUserTypeRange;
// + свойство _TvcmEntityForm.OnQueryMaximized;
//
// Revision 1.98  2003/12/05 16:51:39  law
// - bug fix: если текущий UserType неправильный, то _CurUserType возвращает nil.
//
// Revision 1.97  2003/12/05 15:59:39  law
// - new prop: _TvcmEntityForm._CurUserType.
//
// Revision 1.96  2003/12/04 15:54:46  law
// - new event: _TvcmEntityForm.OnGetStatus.
//
// Revision 1.95  2003/12/01 12:17:56  migel
// - fix: в качестве `WndParent` выставляем `Owner.Handle`, если это возможно.
//
// Revision 1.94  2003/12/01 11:01:45  law
// - bug fix: поправлена генерация UserType'ов.
// - bug fix: свойство Weigth переименовано в _Weight.
//
// Revision 1.93  2003/12/01 08:52:46  migel
// - fix: более корректно выставляем `WndParent`.
//
// Revision 1.92  2003/11/30 18:47:52  migel
// - fix: более корректно переключаемся на модальное окно.
//
// Revision 1.91  2003/11/29 18:13:24  law
// - bug fix: пересоздаем окно, при смене _ZoneType (нужно Мишане, для корректого выставления флагов для модальных окон).
//
// Revision 1.90  2003/11/28 20:04:40  migel
// - fix: поведение окон в таскбаре и при выборе по `Alt+Tab`.
//
// Revision 1.89  2003/11/28 13:01:34  law
// - new behavior: опираемся на идентификаторы форм, а не на имена.
//
// Revision 1.88  2003/11/27 15:56:26  law
// - new prop: _TvcmEntityForm.OnNeedUpdateStatus.
//
// Revision 1.87  2003/11/26 17:33:44  law
// - bug fix: учитвыаем, что Container не может быть = nil, а может быть IsNull.
//
// Revision 1.86  2003/11/25 16:42:51  law
// - new method versions: _TvcmEntityForm._Operation.
//
// Revision 1.85  2003/11/18 12:32:10  law
// - bug fix: AV при Back, когда не задавали Owner'а формы. Теперь в качестве Owner'а берем Container (CQ OIT5-00005249).
//
// Revision 1.84  2003/11/12 13:08:31  law
// - new behavior: сделана возможность определять на форме до 4-х областей докинга.
// - new behavior: сделано рекурсивное объединение toolbar'ов child->container->container ...
//
// Revision 1.83  2003/11/11 18:12:32  law
// - new behavior: записываем свойство _Toolbars, а не _ToolbarPos.
//
// Revision 1.82  2003/11/05 15:13:23  law
// - bug fix: нижние Toolbar'ы уехали наверх.
//
// Revision 1.81  2003/11/05 14:12:05  law
// - new prop: _TvcmEntityForm._Toolbars.
//
// Revision 1.80  2003/10/31 13:47:59  law
// - new behvaior: прикрутил Help к VCM.
//
// Revision 1.79  2003/10/17 09:39:23  mmorozov
// - свойство _CanClose из published перенесено в _public;
//
// Revision 1.78  2003/10/16 15:05:48  mmorozov
// + работа со свойством _CanClose и событием OnQueryClose транслируется текущему UserType;
//
// Revision 1.77  2003/10/16 12:35:57  mmorozov
// + опубликовано событие _TvcmEntityForm.OnQueryClose (возникает при закрытии формы кнопкой закрытия);
// + опубликовано свойство _TvcmEntityForm._CanClose;
// + метод _TvcmEntityForm.DoQueryClose который связывается с OnClick кнопки закрытия окна;
//
// Revision 1.76  2003/10/15 10:34:59  mmorozov
// + поддержка _TvcmEntityForm интерфейса IvcmWeight;
//
// Revision 1.75  2003/09/26 11:38:38  law
// - bug fix: не закрывались модальные формы.
//
// Revision 1.74  2003/09/25 17:00:28  law
// - new behavior: сделано отложенное убивание форм.
//
// Revision 1.73  2003/09/23 17:28:48  law
// - bug fix: в первом приближении заборол проблему с фокусом при вложенных формах.
//
// Revision 1.72  2003/09/10 15:12:48  law
// - new method: TvcmForm._ManualUpdateActions.
//
// Revision 1.71  2003/09/04 11:49:10  law
// - new behavior: Caption основного объекта выводится в Caption главного окна.
//
// Revision 1.70  2003/09/04 11:12:16  law
// - new method: _IvcmEntityForm._IsMainObjectForm.
//
// Revision 1.69  2003/09/04 10:27:36  law
// - new prop: _IvcmEntityForm._MainCaption.
//
// Revision 1.68  2003/09/03 14:04:32  law
// - change: добавлен тип TvcmStateType (задел на сохранение перехода по локальным ссылкам).
//
// Revision 1.67  2003/07/28 11:42:28  law
// - new behavior: в форму настройки Toolbar'ов выводим список пользовательских типов объектов.
//
// Revision 1.66  2003/07/25 17:52:01  law
// - new behavior: начал получать список UserType'ов.
//
// Revision 1.65  2003/07/25 11:03:45  law
// - new units: vcmUserTypesCollection, _vcmUserTypesCollectionItem.
//
// Revision 1.64  2003/07/24 13:07:18  law
// - new prop: IvcmOperationDef._ExcludeUserTypes.
//
// Revision 1.63  2003/07/24 11:35:15  law
// - new prop: _TvcmEntityForm._ToolbarPos.
//
// Revision 1.62  2003/07/22 14:22:50  law
// - new behavior: практически избавились от мерцания toolbar'ов (для Toolbar 97).
//
// Revision 1.61  2003/07/22 13:17:05  law
// - new behavior: насильно обновляем меню и Toolbar'ы - это первый шаг к борьбе с мерцанием Toolbar'ов.
//
// Revision 1.60  2003/07/21 13:57:59  law
// - bug fix: был AV при приведении формы, которая закрывается к _IvcmEntityForm.
//
// Revision 1.59  2003/07/21 12:14:50  law
// - new const: vcm_ztManualModal.
//
// Revision 1.58  2003/07/14 14:57:07  law
// - bug fix: не возвращался фокус после показа модального окна. Вообще-то это bug Borland'а, но я его обошел заплаткой.
//
// Revision 1.57  2003/07/14 12:23:04  law
// - bug fix: модальные окна "прилипали" к родителю.
//
// Revision 1.56  2003/07/02 15:20:05  law
// - new prop: _IvcmEntityForm.UserType - поле, которое характеризует некий тип формы и записывается в историю.
//
// Revision 1.55  2003/06/30 15:39:43  law
// - cleanup: удаление возможности подмены Owner'а у _TvcmEntityForm.
//
// Revision 1.54  2003/06/27 16:31:19  law
// - new behavior: сделано восстановление состояния компонент формы, которые отдают интерфейс IvcmState.
//
// Revision 1.53  2003/06/27 15:50:18  law
// - new behavior: сделано запоминание состояния компонент формы, которые отдают интерфейс IvcmState.
//
// Revision 1.52  2003/06/27 14:37:08  law
// - new unit: vcmExternalInterfaces.
//
// Revision 1.51  2003/06/23 15:03:24  law
// - change: свойство IvcmContainer.GUID переехало в _IvcmEntityForm.GUID - теперь каждая форма имеет свой идентификатор.
// - remove interface: IvcmGUIDSetter.
// - new param: конструктор _TvcmEntityForm._Make имее еще один параметр - aGUID - для восстановления идентификатора формы при операциях Back/Forward.
//
// Revision 1.50  2003/06/23 14:27:07  law
// - new behavior: теперь контейнер восстанавливает свой GUID при операциях Back/Forward.
//
// Revision 1.49  2003/06/23 13:45:12  law
// - new prop: _IvcmEntityForm._Module.
//
// Revision 1.48  2003/06/19 11:46:07  law
// - bug fix: не работала история навигации. До конца не починено - сейчас восстанавливается только самая верхняя форма.
//
// Revision 1.47  2003/06/17 08:51:25  law
// - new method: _TvcmEntityForm.HasOwnedForm.
//
// Revision 1.46  2003/06/10 11:01:26  law
// - bug fix: _IvcmEntityForm не приводилось к _IvcmEntity.
//
// Revision 1.45  2003/06/09 13:33:40  law
// - new prop: IvcmFormDispatcher._CurrentMainForm.
// - new behavior: если Owner = nil, для формы сущности, то пытаемся сделать ей Owner'ом текущую основную форму.
// - new behavior: для плавающей формы неправильно находилась основная форма приложения.
//
// Revision 1.44  2003/06/09 12:28:30  nikitin75
// - опубликовано свойство _Aggregate.
//
// Revision 1.43  2003/06/09 11:58:27  nikitin75
// - bug fix: неправильно организовывался перебор форм, для которых надо заменить Owner'а.
//
// Revision 1.42  2003/06/06 12:56:30  law
// - new prop: IvcmDispathcher.History.
// - new behavior: сохранение форм в истории по их закрытии (пока до конца не доделано).
//
// Revision 1.41  2003/06/06 11:41:23  law
// - new methods: _IvcmEntityForm.LoadState, _SaveState.
// - new prop: _TvcmEntityForm.OnLoadState, OnSaveState.
//
// Revision 1.40  2003/06/06 09:34:17  law
// - new param: _TvcmEntityForm._Make - anOldOwner - форма, дочерним формам, которой, надо вместо Owner'а установить вновь созданную форму.
//
// Revision 1.39  2003/06/03 14:08:15  law
// - bug fix: не собиралось с опцией _vcmNeedL3.
// - bug fix: при закрытии приложения не освобождались модули.
//
// Revision 1.38  2003/06/02 15:19:47  narry
// - update: продолжение документирования библиотеки
//
// Revision 1.37  2003/05/22 09:08:04  narry
// - update: начало документирования
//
// Revision 1.36  2003/05/21 07:17:58  law
// no message
//
// Revision 1.35  2003/05/20 15:15:11  law
// - bug fix: при уничтожении формы не пропадала связанная с ней закладка.
//
// Revision 1.34  2003/05/20 14:03:45  law
// - bug fix: иногда у _TvcmEntityForm вызывалось только Free (без Close) - соответственно потом не доходила нотификация об удалении дочерних форм.
//
// Revision 1.33  2003/05/20 12:03:07  law
// - bug fix: при Close формы не сразу удалялись дочерние формы.
//
// Revision 1.32  2003/04/29 13:28:54  law
// - new methods: IvcmFormDispatcher._Lock, Unlock.
//
// Revision 1.31  2003/04/29 12:00:46  law
// - new prop: _TvcmEntityForm.MergeToolbarsToContainer.
//
// Revision 1.30  2003/04/28 09:36:11  law
// - cleanup: переделана логика работы с параметрами операций.
//
// Revision 1.29  2003/04/25 16:18:29  law
// - cleanup: у _TvcmEntityForm._Make убран параметр anOwner, т.к. он есть в aParams.
//
// Revision 1.28  2003/04/25 15:25:42  law
// - new method version: _TvcmEntityForm._Make.
//
// Revision 1.27  2003/04/25 13:53:29  law
// - bug fix: пытаемся починить потерю фокуса.
//
// Revision 1.26  2003/04/25 13:24:14  law
// - new behavior: активным считается не только контрол в фокусе, но и его родители.
//
// Revision 1.25  2003/04/24 12:30:35  law
// - new method version: _TvcmEntityForm._Make.
//
// Revision 1.24  2003/04/23 13:32:28  law
// - new behavior: теперь _TvcmEntityForm закрываются всегда.
//
// Revision 1.23  2003/04/23 12:53:05  law
// - bug fix.
//
// Revision 1.22  2003/04/23 12:49:59  law
// - new param: _Make -> aZoneType.
//
// Revision 1.21  2003/04/23 11:19:01  demon
// - bug fix: _IvcmEntityForm не приводился к IvcmContainer.
//
// Revision 1.20  2003/04/22 19:02:07  law
// - new behavior: отказываемся от MDI форм при включенном флаге _SDI.
//
// Revision 1.19  2003/04/22 17:33:43  law
// - new prop: TvcmMainForm._SDI.
//
// Revision 1.18  2003/04/22 15:00:31  law
// - bug fix: оттестировал вставку форм в контейнер.
//
// Revision 1.17  2003/04/22 14:03:01  law
// - new behavior: сделана обработка операций, описанных на основной форме.
//
// Revision 1.16  2003/04/22 12:26:03  law
// - new method version: _Make.
//
// Revision 1.15  2003/04/21 15:27:00  law
// - new interface: IvcmContainerForm.
//
// Revision 1.14  2003/04/09 12:32:17  law
// - cleanup.
//
// Revision 1.13  2003/04/09 08:57:34  law
// - экспериментируем с ComboBox в Toolbar'е.
//
// Revision 1.12  2003/04/07 15:10:48  law
// - bug fix: сделано, чтобы компилировалось под Builder'ом.
//
// Revision 1.11  2003/04/04 10:58:59  law
// - bug fix: была ошибка в имени типа TvcmControlID.
//
// Revision 1.10  2003/04/03 16:55:08  law
// - new method: _IvcmEntityForm.SameName.
//
// Revision 1.9  2003/04/03 14:29:29  law
// - bug fix: _TvcmEntityForm не отдавала интерфейс IvmcEntityForm.
//
// Revision 1.8  2003/04/03 14:07:07  law
// - new prop: _IvcmEntityForm._Aggregate.
//
// Revision 1.7  2003/04/03 13:50:55  law
// - доделана подписка на события.
//
// Revision 1.6  2003/04/03 12:41:16  law
// - change: изменен список параметров _TvcmEntityForm._Make.
// - new prop: _TvcmEntityForm.OnInit.
//
// Revision 1.5  2003/04/03 12:14:08  law
// - new prop: _TvcmEntityForm._Module.
// - new method: _TvcmEntityForm._MakeAggregate.
// - new method: IvcmModule._MakeAggregate.
//
// Revision 1.4  2003/04/02 11:10:38  law
// - new interface: IvcmAggregate.
//
// Revision 1.3  2003/04/01 16:10:45  law
// - new behavior: сделана регистрация сущностей от форм в списке у главной формы.
//
// Revision 1.2  2003/04/01 15:27:51  law
// - new interface: _IvcmEntityForm.
//
// Revision 1.1  2003/04/01 12:54:49  law
// - переименовываем MVC в VCM.
//
// Revision 1.45  2003/03/26 12:38:06  law
// - cleanup.
//
// Revision 1.44  2003/03/26 12:13:42  law
// - cleanup.
//
// Revision 1.43  2003/03/25 09:56:55  law
// - new prop: TvcmOperationsCollectionItem.Hint, TvcmOperationsCollectionItem.LongHint.
//
// Revision 1.42  2003/03/24 14:04:07  law
// - change: продолжаем заковыривать все относящееся к операции в _IvcmParams.
//
// Revision 1.41  2003/03/24 13:25:48  law
// - change: продолжаем заковыривать все относящееся к операции в _IvcmParams.
//
// Revision 1.40  2003/03/21 14:46:57  law
// - bug fix: не освобождался активный объект.
// - new behavior: расширен пример.
//
// Revision 1.39  2003/03/21 12:34:44  law
// - new behavior: операциям добавлен список параметров.
//
// Revision 1.38  2003/03/20 16:42:58  law
// - change: всем объектам кроме Name добавлено свойство Caption.
//
// Revision 1.37  2003/03/20 12:30:02  law
// - new behavior: сделана обработка контекстных операций.
//
// Revision 1.36  2003/03/19 16:31:52  law
// - new behavior: сделана более интеллектуальная сборка контекстного меню.
//
// Revision 1.35  2003/03/19 11:51:04  law
// - cleanup: добавлен метод TvcmCustomEntities.GetFirstFormItem.
//
// Revision 1.34  2003/03/18 16:57:17  law
// - new behavior: сделана привязка к форме не только нулевой сущности.
//
// Revision 1.33  2003/03/14 18:24:12  law
// - наконец-то родил пример под BCB.
//
// Revision 1.32  2003/03/14 14:55:48  law
// - new units: vcmBaseMenuManager, vcmMenuManager.
//
// Revision 1.31  2003/03/14 12:20:54  law
// - change: отвязываем vcm от l3.
//
// Revision 1.30  2003/03/14 09:22:37  law
// - change: отвязываем vcm от l3.
//
// Revision 1.29  2003/03/11 15:34:31  law
// - new behavior: сделаны обработчики операций.
//
// Revision 1.28  2003/03/11 13:03:58  law
// - new behavior: сделано автоматическое определение идентификаторов сущностей и операций.
//
// Revision 1.27  2003/03/11 12:44:43  law
// - new behavior: сделано вытаскивание сущностей и их операций из TvcmCustomEntities, которые лежат на форме для сущностей.
//
// Revision 1.26  2003/03/06 15:15:56  law
// - new behavior: сделано построение меню для форм сущностей.
//
// Revision 1.25  2003/03/05 09:12:43  law
// - обновление help.
//
// Revision 1.24  2003/03/05 08:46:38  law
// - new behavior: _TvcmEntityForm теперь сама регистрируется в диспетчере форм.
// - new method: IvcmFormDispatcher._RemoveForm.
//
// Revision 1.23  2003/02/28 16:11:39  law
// - cleanup.
//
// Revision 1.22  2003/02/27 17:23:53  law
// - change: объединил методы ExecuteOperation и OperationEnabled.
//
// Revision 1.21  2003/02/27 16:37:06  law
// - bug fix: теперь, если сущность привязывается к экземпляру, то класс контрола не анализируется.
//
// Revision 1.20  2003/02/27 16:26:57  law
// - new behavior: сделана возможность подвязывать несколько типов сущностей к одному контролу.
//
// Revision 1.19  2003/02/27 15:42:00  law
// - new behavior: добавлена возможность подвязывать события к сущностям управляющих элементов формы.
//
// Revision 1.18  2003/02/27 15:21:53  law
// - new unit: vcmEventedIdentifiedControlEntity.
//
// Revision 1.17  2003/02/27 14:51:09  law
// - new behavior: сделана возможность определять идентификатор сущности для управляющего элемента.
// - change: в соответствии с этой возможностью расширен пример.
//
// Revision 1.16  2003/02/27 14:05:32  law
// - new behavior: сделана возможность получать идентификатор сущности для управляющего элемента.
//
// Revision 1.15  2003/02/27 13:58:30  law
// - new unit: vcmIdentifiedControlEntity.
//
// Revision 1.14  2003/02/27 13:43:43  law
// - new method: _TvcmEntityForm._GetInnerForControl.
//
// Revision 1.13  2003/02/27 13:09:29  law
// - new unit: vcmFormEntity.
//
// Revision 1.12  2003/02/27 12:55:50  law
// - new prop: _IvcmEntity._Inner.
//
// Revision 1.11  2003/02/27 12:33:38  law
// - new units: vcmEntity, vcmControlEntity.
//
// Revision 1.10  2003/02/27 12:12:05  law
// - new behavior: определяется разрешенность операций сущности.
//
// Revision 1.9  2003/02/27 11:35:46  law
// - new method: _TvcmEntityForm._GetEntityID.
//
// Revision 1.8  2003/02/27 11:14:54  law
// - new behavior: вчерне сделал выполнение операций сущности.
//
// Revision 1.7  2003/02/27 10:06:09  law
// - change: модулю и сущности добавлен идентификатор.
//
// Revision 1.6  2003/02/27 09:37:57  law
// - new behavior: к описанию сущности добавлены операции.
//
// Revision 1.5  2003/02/27 07:57:38  law
// - new behavior: сделано получение сущностей модуля.
//
// Revision 1.4  2003/02/26 18:12:35  law
// - new property: IvcmDispatcher._ActiveEntity.
//
// Revision 1.3  2003/02/26 16:22:43  law
// - new behavior: сделана обработка операция и создание форм.
//
// Revision 1.2  2003/02/24 13:02:24  law
// - help added.
//
// Revision 1.1  2003/02/24 11:11:31  law
// - new unit: vcmEntityForm.
//

{$Include vcmDefine.inc }

interface

{$If not defined(NoVCM)}

uses
  Windows,
  Messages,
  Menus,

  Classes,
  Controls,

  Forms,

  l3Interfaces,
  l3StringIDEx,
  l3Base,
  l3ObjectList,
  l3IID,
  l3InternalInterfaces,
  l3Types,

  afwInterfaces,

  vcmUserControls,
  vcmInterfaces,
  vcmExternalInterfaces,

  vcmBase,
  vcmEntities,
  vcmForm,
  vcmUserTypesCollectionItem,
  vcmUserTypesCollection,
  vcmBaseUserTypesCollectionItem,
  vcmStyle,
  vcmGUI,
  vcmToolbar,
  vcmToolbarsInterfaces,
  vcmFormDispatcherInterfaces,
  vcmEntityFormModelPart,
  vcmBaseEntitiesCollectionItem,
  vcmEntityFormImplementationModelPart,
  vcmFormSetFormItemList,
  vcmUserTypeDefList,
  vcmEntitiesDefList,
  vcmControlList
  ;

type
  //TvcmInitProc = procedure (aForm : TvcmForm);
  //TvcmInitEvent = procedure of object;
  TvcmLoadStateEvent = procedure (const aState : IvcmBase;
                                  aStateType   : TvcmStateType;
                                  var Loaded   : Boolean) of object;
    {-}
  TvcmSaveStateEvent = procedure (out aState : IvcmBase;
                                  aStateType : TvcmStateType;
                                  var Saved  : Boolean) of object;
    {-}
  TvcmChangedDataSourceEvent = procedure(aSender            : TObject;
                                         const aOld         : IvcmFormDataSource;
                                         const aNew         : IvcmFormDataSource;
                                         const aFromHistory : Boolean) of Object;
    {* - генерируется при изменении данных. aNew = True, если форме был присвоен
         прежний бизнес объект. }
  TvcmGetStatusEvent = procedure (aSender       : TObject;
                                  out theStatus : TvcmStatusStrings) of object;
    {-}
(*  TvcmGetLocalizationInfo = procedure (Sender: TObject; var theInfo: String) of object;
    {-}
  TvcmSetLocalizationInfo = procedure (Sender: TObject; const theInfo: String) of object;
    {-}*)
  _afwSettingsReplace_Parent_ = TvcmEntityFormModelPart;
  {$Include afwSettingsReplace.imp.pas}
  _afwApplicationDataUpdate_Parent_ = _afwSettingsReplace_;
  {$Include afwApplicationDataUpdate.imp.pas}
  TvcmEntityForm = class(_afwApplicationDataUpdate_,
                         IafwForm,
                         IafwTabSheetControl,
                         Il3CommandTarget
                         {$IfDef vcmUseSettings}
                         , IvcmToolbarsCustomizeListener
                         , IvcmFormDispatcherListener
                         {$EndIf vcmUseSettings}
                         )
   {* Базовый класс для отображения сущностей из модуля приложения построенного на основе библиотеки vcm. }
    private
    // internal fields
      f_LockFocusCount   : Integer;
      f_Aggregate        : IvcmAggregate;
      f_Entity           : IvcmEntity;
      f_EntityForm       : IvcmEntityForm;
      f_FormDef          : IvcmEntityFormDef;
      f_Entities         : TvcmCustomEntities;
      f_WasSaved         : Boolean;
      f_UserType         : TvcmUserType;
      f_SubUserType      : TvcmUserType;
      f_UserTypes        : TvcmUserTypesCollection;
      f_EntitiesList     : TvcmEntitiesDefList;
      f_ZoneControl      : TControl;
      f_DockList         : TvcmControlList;
      f_DataSource       : IvcmFormDataSource;
      f_Style            : TvcmFormStyle;
      {$IfNDef DesignTimeLibrary}
      f_FormID         : TvcmFormID;
      {$EndIf  DesignTimeLibrary}
      f_FloatingVisible : Boolean;
      f_TabCaption       : IvcmCString;
    protected
    // internal fields
      f_GUID           : TGUID;
    private
    // event fields
      f_OnLoadState         : TvcmLoadStateEvent;
      f_OnSaveState         : TvcmSaveStateEvent;
      f_OnGetStatus         : TvcmGetStatusEvent;
      f_OnChangedDataSource : TvcmChangedDataSourceEvent;
(*      f_OnInit              : TvcmInitEvent;*)
(*      f_OnGetLocalizationInfo : TvcmGetLocalizationInfo;
      f_OnSetLocalizationInfo : TvcmSetLocalizationInfo;*)
    {$IfDef InsiderTest}
    public
      g_AllowModal : Integer;
    {$EndIf InsiderTest}
    protected
    // IafwTabSheetControl
      function pm_GetWeight: Integer;
        {-}
      procedure PageInactive;
        virtual;
        {* - активная закладка стала не активной. }
      procedure PageActive;
        virtual;
        {* - закладка стала активной. }
      procedure DoBeforeHistoryNavigate;
        virtual;
    protected
    // interface methods
      function FocusLocked : Boolean;
      procedure UpdateCaption(const aCaption: Il3CString);
        virtual;
        {-}
      function pm_GetBoundsRect: TRect;
        {-}
      function pm_GetEntity: IvcmEntity;
        {-}
      procedure BeforeHistoryNavigate;
    private
    // message handlers
      procedure WMWindowPosChanging(var aMessage: TWMWindowPosChanging);
        message WM_WINDOWPOSCHANGING;
        {* - при достижении минимальных размеров окно не перемещается
             вправо(вниз).

             Дело в том, что в WindowPos.x(y) приходят значения в соответствии
             с положением курсора. Т.е. у пользователя появился тяни-толкайчик
             на границе окна <-->, дальше пользователь немного сдвинул курсор
             вправо, в сообщение приходит граница окна x(y) в соответствии с
             положением курсора. Дальше мы выяснили, что уменьшать размер формы
             нельзя (Constraints), корректируем cx(cy) (на уровне vcl), но x(y)
             оставляем без изменения, в результате окно не меняет размер, но
             смещается вправо. }
      procedure WMSizing(var aMessage: TMessage);
        message WM_SIZING;
        {-}
      procedure CMTextChanged(var Message: TMessage);
        message CM_TEXTCHANGED;
        {-}
      procedure CMVisibleChanged(var Message: TMessage);
        message CM_VISIBLECHANGED;
        {-}
      procedure WMHelp(var Message: TWMHelp);
        message WM_HELP;
        {-}
      procedure CNKeyDown(var Message: TWMKeyDown);
        message CN_KEYDOWN;
        {-}
      procedure WMPaint(var Message: TWMPaint);
        message WM_PAINT;
        {-}
      procedure WMNCPaint(var Message: TWMNCPaint);
        message WM_NCPAINT;
        {-}
      procedure WMContextMenu(var Message: TWMContextMenu);
        message WM_CONTEXTMENU;
        {-}
      procedure WMSetIcon(var Message: TWMSetIcon);
        message WM_SETICON;
        {-}
      procedure CMActivate(var Message: TMessage);
        message CM_ACTIVATE;
    private
    // private methods
      function CommonDocksSize(aHeight : Boolean) : Integer;
        {-}
      procedure NotifyContainer;
        {* - сообщает контейнеру об удалении формы. }
      function CheckUserTypeRange: Boolean;
        {-}
      {$IfDef vcmUseSettings}
      procedure SaveToolbars;
        {-}
      {$EndIf vcmUseSettings}
      function GetQueryEvent(aQueryType : TvcmQueryType) : TNotifyEvent;
        {* - см. SetQueryEvent. }
      procedure UserTypeWeightChanged(aSender: TObject);
        {-}
(*      procedure SetLocalizationInfo(const aComponent: TComponent; const anInfo: String);
        {-}*)
      function MakeUserTypeDef(aValue: TvcmBaseUserTypesCollectionItem): IvcmUserTypeDef;
        {-}
      procedure NotifyFormSetFormIsClosed;
        {* - Форма закрывается - нужно изменить флажок на сборке. }
    protected
      function  InHistoryStep: Boolean;
        {-}
      procedure CheckFloatingToolbarVisibility;
    protected
    // propeprty methods
      function  pm_GetFormSet: IvcmFormSet;
        {-}
      function  pm_GetDataSource: IvcmFormDataSource;
      procedure pm_SetDataSource(const aValue: IvcmFormDataSource);
        {-}
      function pm_GetDocksHeight : Integer;
        {-}
      procedure pm_SetZoneControl(const aValue : TControl);
        {-}
(*      procedure pm_SetStyle(const aValue: TvcmFormStyle);
        {-}*)
      function pm_GetIsStoredStyle: Boolean;
        {-}
      function pm_GetQueryMaximized : TNotifyEvent;
        {-}
      procedure pm_SetAggregate(const aValue : IvcmAggregate);
        {-}
      function  Get_MainCaption : IvcmCString;
        virtual;
        {-}
      function  Get_FormDef: IvcmEntityFormDef;
        {-}
      function  GetCanClose: TvcmCanClose;
        {-}
      procedure SetCanClose(const Value: TvcmCanClose);
        {-}
      function  pm_GetCurUserType: TvcmBaseUserTypesCollectionItem;
        {-}
      function  pm_GetCurUserTypeDef: IvcmUserTypeDef;
        {-}
      function pm_GetCurUseToolbarOfUserType: IvcmUserTypeDef;
        {* - тип формы для чтения настроек. }
      function GetQueryOpen : TNotifyEvent;
        {-}
      function pm_GetIsMainInFormSet: Boolean;
        {-}
      function pm_GetKeyInFormSet: TvcmFormSetFormItemDescr;
        {-}
      function pm_GetUseCaseIconIndex: Integer;
        virtual;
        {-}
      function pm_GetTabCaption: IvcmCString;
        {-}
      procedure pm_SetTabCaption(const aTabCaption: IvcmCString);
        {-}
      function pm_GetNeedAddFormToTasksPanel: Boolean;
        {-}
    {$IfDef vcmUseSettings}
    protected
    // IvcmFormDispatcherListener
      procedure StartNewMainForm;
        {* - вызывается перед созданием главной формы. }
    protected
    // IvcmToolbarsCustomizeListener
      procedure BeforeToolbarsCustomize;
      procedure IvcmToolbarsCustomizeListener.BeforeCustomize = BeforeToolbarsCustomize;
        {* - вызывается перед вызовом окна редактирования панелей инструментов. }
    protected
    // IafwSettingsReplaceListener
      procedure SettingsReplaceStart;
        override;
        {* - перед заменой настроек. }
      procedure SettingsReplaceFinish;
        override;
        {* - после замены настроек. }
    protected
    {$EndIf vcmUseSettings}
    // internal methods
      procedure InitStyle;
        {* - определить стиль формы. }
      {$IfDef vcmUseSettings}
      procedure InitSettingsSource;
        {-}
      {$EndIf vcmUseSettings}
      class function FormImplementationClass: TClass;
        override;
        {-}
      function  CanRemoveInKillFromVCM: Boolean;
        virtual;
        {-}
      procedure KillFromVCM;
        {-}
      procedure Activate;
        override;
        {-}
      procedure Deactivate;
        override;
        {-}
      procedure BecomeActive;
        virtual;
        {-}
      procedure BecomeInactive;
        virtual;
        {-}
      procedure MakeAggregate;
        {-}
      function DoLoadState(const aState: IvcmBase;
                           aStateType: TvcmStateType;
                           aClone: Boolean): Boolean;
        virtual;
        {-}
      function  LoadState(const aState : IvcmBase;
                          aStateType   : TvcmStateType): Boolean;
        //virtual;
        {-}
      function  SaveOwnFormState(out theState : IvcmBase;
                                aStateType   : TvcmStateType;
                                aForClone: Boolean): Boolean;
        virtual;
        {-}
      function  DoSaveState(out theState : IvcmBase;
                            aStateType   : TvcmStateType;
                            aForClone    : Boolean): Boolean;
        virtual;
        {-}
      function  SaveState(out theState : IvcmBase;
                          aStateType   : TvcmStateType): Boolean;
        //virtual;
        {-}
      function DoSaveStateForClone(out theState: IvcmBase;
                                   aStateType: TvcmStateType): Boolean;
        virtual;
        {-}
      function NeedLoadFormStateForClone(const aState: IvcmBase;
                                         aStateType: TvcmStateType): Boolean;
        virtual;
        {-}                               
      function DoLoadCloneState(const theState: IvcmBase;
                                aStateType: TvcmStateType): Boolean;
        virtual;
        {-}
      function SaveStateForClone(out theState: IvcmBase;
                                 aStateType: TvcmStateType): Boolean;
        {-}
      function LoadCloneState(const theState: IvcmBase;
                              aStateType: TvcmStateType): Boolean;
        {-}
      procedure SetParent(AParent: TWinControl);
        override;
        {-}
      procedure SetMyFocus;
        {-}
      procedure RemoveMyFocus;
        {-}
      function  IsModal: Boolean;
        override;
        {-}
      function  IsContained: Boolean;
        override;
        {-}
      procedure CreateParams(var aParams: TCreateParams);
        override;
        {-}
      procedure WndProc(var aMessage: TMessage);
        override;
        {-}
      procedure DoLoadFromSettings;
        override;
        {-}
      function HasFormFloatingZoneTypeAndVisible: Boolean;
        virtual;
        {-}
      function  ProcessCommand(Cmd    : Tl3OperationCode;
                               aForce : Boolean;
                               aCount : Integer): Boolean;
        virtual;
        {-}
      procedure InitFields;
        override;
        {-}
      procedure CallDoInit(aFormHistory : Boolean);
      function IsVCMScalingNeeded: Boolean; virtual;
      procedure VCMScaleControls;
      procedure DoVCMScaleControls; virtual;
      procedure DoInit(aFormHistory : Boolean);
        {* Инициализация формы. Для перекрытия в потомках }
        virtual;
        {-}
      function  SafeClose: Boolean; override;
        {-}
      function  AddUsertype(const aName : String;
                            const aCaption : Tl3StringIDEx;
                            const aSettingsCaption : Tl3StringIDEx;
                            aVisibleToUser : Boolean;
                            anImageIndex : Integer;
                            aWeight : Integer;
                            const aUseToolbarOfUserTypeName : String;
                            aOnQueryMaximized : TNotifyEvent;
                            aOnQueryOpen : TNotifyEvent;
                            aOnQueryClose : TNotifyEvent;
                            aCanClose : TvcmCanClose): TvcmUserTypesCollectionItem;
        {-}
      procedure AddUserTypeExclude(const aName : String;
                                    const anEn  : String;
                                    const anOp  : String;
                                    aNoPrefix   : Boolean);
        {-}
      procedure Cleanup;
        override;
        {-}
      procedure CleanDependencies; virtual;
        {-}
      procedure CreateWnd; override;
        {-}
      procedure UpdateStatusInfo;
        {-}
      function DoGetTabInfo(out theCaption: Il3CString;
       out theItemIndex: Integer): Boolean; virtual;
        {* Информация о закладке, в которую вставляется форма. Для перекрытия в потомках }
      procedure NotifyUserTypeSet; virtual;
      procedure SetupFormLayout; virtual;
      procedure CreateFormGUID(var theGUID : TGUID);
        virtual;
      {-}
      procedure ReleaseResources; virtual;
      procedure BeforeClosing; virtual;
      function NeedTerminateApp: Boolean; virtual;
      {-}
      function DoGetTabCaption: IvcmCString; virtual;
      {-}
      function HasFormModalState: Boolean;
      {-}
      procedure DoOnShowModal; virtual;
      {-}
      function DoGetNeedAddFormToTasksPanel: Boolean; virtual;      
      {-}
      function DoGetNeedSaveToTabHistory: Boolean; virtual;
      {-}
      function NeedSaveToTabHistory: Boolean;
      {-}
      class function GetExistingInstance(const aContainer: IvcmContainer;
                                         const aParams: IvcmMakeParams;
                                         aZoneType: TvcmZoneType = vcm_ztAny;
                                         aUserType: TvcmUserType = 0;
                                         aGUID: PGUID = nil;
                                         const aDataSource: IvcmFormDataSource = nil;
                                         aSubUserType: TvcmUserType = vcm_utAny): IvcmEntityForm;
        virtual;
    protected
    // internal properties
      property Entity: IvcmEntity
        read pm_GetEntity;
        {-}
      property GUID: TGUID
        read f_GUID
        write f_GUID;
        {-}
      property WasSaved: Boolean
        read f_WasSaved;
        {-}
    public
    // public methods
      constructor Create(anOwner: TComponent);
        override;
        {-}
      function NeedSaveInSettings: Boolean; override;

      procedure CheckFloatingVisibility; virtual;
        {-}
      procedure Loaded;
        override;
        {-}
      procedure DoUpdateStatus;
        override;
        {-}
      class function Make(const aParams     : IvcmMakeParams;
                          aZoneType         : TvcmZoneType = vcm_ztAny;
                          aUserType         : TvcmEffectiveUserType = 0;
                          aGUID             : PGUID = nil;
                          const aDataSource : IvcmFormDataSource = nil;
                          aSubUserType      : TvcmUserType = vcm_utAny;
                          aAfterCreate      : TvcmInitProc = nil) : IvcmEntityForm;
        reintroduce;
        {* - создает форму сущности и добавляет ее к диспетчеру форм. }
      class function MakeSingleChild(const aCont       : IvcmContainer;
                               const aParams     : IvcmMakeParams;
                               aZoneType         : TvcmZoneType = vcm_ztAny;
                               aUserType         : TvcmUserType = 0;
                               aGUID             : PGUID = nil;
                               const aDataSource : IvcmFormDataSource = nil;
                               aSubUserType      : TvcmUserType = vcm_utAny;
                               aAfterCreate      : TvcmInitProc = nil): IvcmEntityForm;
        {* - создает форму сущности если таковой не было и вставляет ее в контейнер. }
      {$IfNDef DesignTimeLibrary}
      {$IfDef l3HackedVCL}
      function IsRealInstance: Boolean; {V}
        override;
        {-}
      {$EndIf l3HackedVCL}
      {$EndIf DesignTimeLibrary}
      function  COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
      procedure GetEntitiesDef(aList : TvcmEntitiesDefList);
        //virtual;
        {*- возвращает список описаний сущностей. Для перекрытия в потомках. }
      class procedure ClassGetEntitiesDef(aList      : TvcmEntitiesDefList;
                                          aUserTypes : TvcmUserTypeDefList);
        {*- возвращает список описаний сущностей. }
      procedure GetUserTypes(aList : TvcmUserTypeDefList);
        {-}
      function GetEntitiesDefIterator: IvcmEntitiesDefIterator;
        {*- возвращает итератор описаний сущностей. }
      function Operation(const anOperationID : TvcmControlID;
                         aMode               : TvcmOperationMode;
                         const aParams       : IvcmParams): Boolean;
        overload;
        virtual;
        {* - выполняет операцию сущности. }
      function Operation(const anOp    : TvcmOPID;
                         const aParams : IvcmExecuteParams): Boolean;
        overload;
        { Выполнение операции по имени сущности. }
      function Operation(const anOp    : TvcmOPID;
                         const aParams : IvcmTestParams): Boolean;
        overload;
        { Выполнение операции по имени сущности. }
      function Operation(const anOp : TvcmOPID;
                         aMode      : TvcmOperationMode = vcm_omExecute): Boolean;
        overload;
        { Выполнение операции по имени сущности. }
      function GetEntityID: TvcmControlID;
        //virtual;
        {* - возвращает идентификатор сущности формы. Для перекрытия в потомках. }
      function GetInner(const anEntityID : TvcmControlID): IvcmEntity;
        virtual;
        {* - возвращает вложенную сущность для формы. Для перекрытия в потомках. }
      function GetInnerForControl(const anEntityID : TvcmControlID;
                                  aControl         : TComponent;
                                  aX               : Integer = High(Integer);
                                  aY               : Integer = High(Integer)): IvcmEntity;
        //virtual;
        {* - возвращает вложенную сущность для элемента управления. Для перекрытия в потомках. }
      procedure Notification(aComponent: TComponent; anOperation: TOperation);
        override;
        {-}
      function  IsModalForm: Boolean;
        {-}
      function  GetStatus(out theStatus : TvcmStatusStrings): Boolean;
        {-}
      procedure ManualUpdateActions;
        override;
        {-}
      procedure KillMe;
        override;
        {-}
      class function cFormID: TvcmFormID;
        {-}
      function FormID: TvcmFormID;
        {-}
      procedure ReloadToolbars;
        virtual;
        {-}
      procedure DoSaveInSettings;
        override;
        {-}
      {$IfNDef DesignTimeLibrary}
      {$IfDef l3HackedVCL}
      function NeedCancelModal: Boolean;
        override;
        {-}
      {$EndIf l3HackedVCL}
      {$EndIF DesignTimeLibrary}
      function ShowModal: integer;
        override;
        {-}
      procedure SetActiveAndShowInParent;
        {* - сделать активным в родителе с возможностью определения типа активации. }
      procedure SetActiveInParent;
        {* - сделать активным в родителе. Применяется для форм находящихся в PageControl-е. }
      procedure SetInactiveInParent;
        {* - сделать активным предыдующего в родителе. Применяется для форм находящихся в PageControl-е. }
      procedure SetFirstActiveInParent;
        {* - сделать активным первого в родителе. }
      function IsActiveInParent : Boolean;
        {* - является ли форма активная в родителе. Применяется для форм находящихся в PageControl-е. }
      procedure CloseInParent;
        {* - Попытаться закрыть форму во вкладке }
      function SendMessageToPage(const aParent : TWinControl;
                                 const aMsg    : Cardinal;
                                 const WParam  : Integer;
                                 const LParam  : Integer): Boolean;
        {* - посылает рекурсивно пока не получит ответ или не закончатся родители. }
      procedure LockFocus;
        { Пока лочит установку фокуса при изменении Visible. Может что-то ещё можно лочить }
      procedure UnlockFocus;
        { Пока лочит установку фокуса при изменении Visible. Может что-то ещё можно лочить }
      procedure Lock;
        virtual;
        {-}
      procedure Unlock;
        virtual;
        {-}
      function  GetUserVisibleOperationsCount(aUserType: TvcmUserType): Integer;
        {-}
      procedure AddDock(aDock : TControl);
        {* - область стыковки toolbar-ов добавляется при создании, для
             вычисления клиентской области занимаемой toolbar-ами. }
      function CallCloseQuery(aCaller : TCustomForm): Boolean;
        override;
        {-}
      function DefineDockContainer(const aPos: TvcmEffectiveToolBarPos): TvcmEntityForm;
        {* - используя стиль формы определяем контейнер для панели
             инструментов. }
(*      function GetLocalizationInfo(const aComponent: TComponent): String;
        {-}*)
      procedure SetPositionByDS; virtual;
        {-}
      function NeedDrawCaption: Boolean; virtual;
        {-}
      function SettingsSuffix: AnsiString; virtual;
        {-}
      function As_IvcmEntityForm: IvcmEntityForm;
        {-}
      procedure SetActiveControl;
        virtual;
        { Устанавливает текущий контрол. Какой? Сама форма решает. Для перекрытия в потомках }
      procedure Paint;
        override;
        {-}
      function IsFloatingState: Boolean;
       {* Определяет - находится ли вкладка формы в плавающем состоянии } 
      function IsFloatingStateAndParentNotVisible: Boolean;
      procedure MakeFloatingParentVisible;
      procedure SetTargetGetter(const anEntity : TvcmString;
                                anEvent : TvcmGetTargetEvent);
        {-}
      procedure MakeEntitySupportedByControl(const anEntity : TvcmString;
                                       aControl : TComponent);
        {-}
    public
    // public properties
      property ZoneControl : TControl
        read f_ZoneControl
        write pm_SetZoneControl;
        {* - компонент зоны, в которую была вставлена форма. }
      property Entities: TvcmCustomEntities
        read f_Entities;
        { Description


          Summary
          Описания сущностей. }
      property Aggregate: IvcmAggregate
        read f_Aggregate
        write pm_SetAggregate;
        {-}
      property UserType: TvcmUserType
        read f_UserType;
        {-}
      property SubUserType: TvcmUserType
        read f_SubUserType;
        {-}
      property CurUserType: TvcmBaseUserTypesCollectionItem
        read pm_GetCurUserType;
        {-}
      property CurUserTypeDef: IvcmUserTypeDef
        read pm_GetCurUserTypeDef;
        {-}
      property CurUseToolbarOfUserType: IvcmUserTypeDef
        read pm_GetCurUseToolbarOfUserType;
        {-}
      property MainCaption: IvcmCString
        read Get_MainCaption;
        {-}
      property FormDef: IvcmEntityFormDef
        read Get_FormDef;
        {-}
      property CanClose: TvcmCanClose
        read GetCanClose
        write SetCanClose;
        {-}
      property DocksHeight : Integer
        read pm_GetDocksHeight;
        {* - высота занимаемая dock-ами выровненными вверх и вниз. }
      property DocksWidth : Integer
        read pm_GetDocksHeight;
        {* - ширина занимаемая dock-ами выровненными влево, вправо. }
      property DataSource : IvcmFormDataSource
        read pm_GetDataSource
        write pm_SetDataSource;
        {-}
      property FormSet : IvcmFormSet
        read pm_GetFormSet;
        {-}
      property FloatingVisible: Boolean
        read f_FloatingVisible
        write f_FloatingVisible;
        {-}  
      property UserTypes: TvcmUserTypesCollection
        read f_UserTypes
        stored false{UserTypesStored};
        {-}
      property KeyInFormSet: TvcmFormSetFormItemDescr
        read pm_GetKeyInFormSet;  
        {-}
      property NeedAddFormToTasksPanel: Boolean
        read pm_GetNeedAddFormToTasksPanel;
        {-}        
    public
    // public _events
      procedure DefaultQueryClose(Sender: TObject);
        virtual;
        {-}
      property OnQueryMaximized: TNotifyEvent
        read pm_GetQueryMaximized;
        {-}
      property OnQueryOpen: TNotifyEvent
        read GetQueryOpen;
        {-}
      property Style: TvcmFormStyle
        read f_Style
//        write pm_SetStyle
        stored pm_GetIsStoredStyle;
        {-}
    published
    // published properties
      property AutoScroll
        stored false;
        {-}
      property ZoneType
        default vcm_ztAny;
        { Summary
          Тип зоны, куда может встраиваться форма.

          Note
          Для приложений, построенных с использованием стиля _SDI тип
          зоны не может быть равным vcm_ztAny. }
      property HelpType
        default htKeyWord;
        {-}
      property OldCreateOrder
        default true;
        {-}  
    published
    // published _events
      property OnChangedDataSource : TvcmChangedDataSourceEvent
        read f_OnChangedDataSource
        write f_OnChangedDataSource;
        {-}
(*      property OnInit: TvcmInitEvent
        read f_OnInit
        write f_OnInit;
        {-}*)
      property OnLoadState: TvcmLoadStateEvent
        read f_OnLoadState
        write f_OnLoadState;
        {-}
      property OnSaveState: TvcmSaveStateEvent
        read f_OnSaveState
        write f_OnSaveState;
        {-}
      property OnGetStatus: TvcmGetStatusEvent
        read f_OnGetStatus
        write f_OnGetStatus;
        {-}
      property UseCaseIconIndex: Integer
        read pm_GetUseCaseIconIndex;
(*      property OnGetLocalizationInfo: TvcmGetLocalizationInfo
        read f_OnGetLocalizationInfo
        write f_OnGetLocalizationInfo;
        {-}
      property OnSetLocalizationInfo: TvcmSetLocalizationInfo
        read f_OnSetLocalizationInfo
        write f_OnSetLocalizationInfo;
        {-}*)
      property TabCaption: IvcmCString
        read pm_GetTabCaption
        write pm_SetTabCaption;
  end;{ Форма для отображения сущности.

        Description
        Взаимодействие приложения и пользователя происходит через
        формы сущностей.                                          }

  TvcmEntityFormImplementation = class(TvcmEntityFormImplementationModelPart, IafwGUIDHolder, IvcmEntityForm)
    private
    // interface methods
      // IvcmEntityForm
      function pm_GetStyle: IvcmFormStyle;
        {* - стиль VCM формы. }
      function pm_GetIsMainInFormSet: Boolean;
        {-}
      function  pm_GetFormSet : IvcmFormSet;
        {-}
      function  pm_GetDataSource : IvcmFormDataSource;
      procedure pm_SetDataSource(const aValue : IvcmFormDataSource);
        {-}
      function pm_GetZoneControl : TControl;
        {-}
      procedure pm_SetZoneControl(aValue : TControl);
        {-}
      function Get_Entity: IvcmEntity;
        {-}
      function Get_Aggregate: IvcmAggregate;
        {-}
      function Get_ZoneType: TvcmZoneType;
        {-}
      function  pm_GetGUID: TGUID;
        {-}
      procedure pm_SetGUID(const aValue: TGUID);
        {-}
      function  pm_GetUserType: TvcmUserType;
        {-}
      function  pm_GetSubUserType: TvcmUserType;
        {-}
      function  Get_MainCaption: IvcmCString;
        {-}
      function  Get_FormDef: IvcmEntityFormDef;
        {-}
      function  pm_GetCurUserTypeDef: IvcmUserTypeDef;
        {-}
      function  pm_GetCurUseToolbarOfUserType: IvcmUserTypeDef;
        {-}
      function  pm_GetKeyInFormSet: TvcmFormSetFormItemDescr;
        {-}
      function pm_GetTabCaption: IvcmCString;
        {-}
      procedure pm_SetTabCaption(const aTabCaption: IvcmCString);
        {-}
      function pm_GetNeedAddFormToTasksPanel: Boolean;
        {-}
      function  SameName(const aName: TvcmFormID): Boolean;
        {-}
      function  LoadState(const aState : IvcmBase;
                          aStateType   : TvcmStateType): Boolean;
        {-}
      function  SaveState(out theState : IvcmBase;
                          aStateType   : TvcmStateType): Boolean;
        {-}
      function SaveStateForClone(out theState: IvcmBase;
                                 aStateType: TvcmStateType): Boolean;
        {-}
      function LoadCloneState(const theState: IvcmBase;
                              aStateType: TvcmStateType): Boolean;
        {-}
      function  IsMainObjectForm: Boolean;
        {-}
      function  IsModalForm: Boolean;
        {-}
      function  IsModal: Boolean;
        {-}
      function  GetStatus(out theStatus : TvcmStatusStrings): Boolean;
        {-}
      procedure LockFocus;
        { Пока лочит установку фокуса при изменении Visible. Может что-то ещё можно лочить }
      procedure UnlockFocus;
        { Пока лочит установку фокуса при изменении Visible. Может что-то ещё можно лочить }
      procedure MakeAggregate;
        {-}
      procedure RegInContainer;
        {-}
      procedure UnregInContainer;
        {-}
      procedure CheckFloatingVisibility;
        {-}
   function GetTabInfo(out theCaption: Il3CString;
    out theItemIndex: Integer): Boolean;
     {* Информация для закладки, в которую вставляется форма }
      function NeedSaveToTabHistory: Boolean;
        {-}
      procedure BeforeHistoryNavigate;
    protected
      function  Get_AsContainer : IvcmContainer;
        virtual;
        {-}
    public
    // public methods
      function  COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
      procedure SetActiveAndShowInParent;
        {* - сделать активным в родителе с возможностью определения типа активации. }
      procedure SetActiveInParent;
        {* - сделать активным в родителе. Применяется для форм находящихся в PageControl-е. }
      procedure SetInactiveInParent;
        {* - сделать активным предыдующего в родителе. Применяется для форм находящихся в PageControl-е. }
      function IsActiveInParent : Boolean;
        {* - является ли форма активная в родителе. Применяется для форм находящихся в PageControl-е. }
      procedure SetFirstActiveInParent;
        {* - сделать активным первого в родителе. }
      procedure CloseInParent;
        {* - Попытаться закрыть форму во вкладке }
  end;//TvcmEntityFormImplementation

  RvcmEntityForm = class of TvcmEntityForm;
  
{$IfEnd}

implementation

{$If not defined(NoVCM)}
uses
  l3Except,
  l3Memory,
  l3MinMax,
  RTLConsts,

  TypInfo,
  Consts,
  SysUtils,
  Graphics,
  ComCtrls,

  l3InterfacesMisc,
  l3VCLStrings,
  l3String,

  afwFacade,

  OvcBase,
  OvcCmd,
  OvcConst
  ,

  l3VCLFormPtrList,

  {$IFDEF nsTest}
  afwAnswer,
  seModalSupport,
  {$ENDIF nsTest}

  vcmInternalInterfaces,

  vcmFormEntity,
  vcmFormsUtils,
  vcmEntitiesDefIterator,

  vcmEntitiesCollectionItem,

  vcmMainForm,

  vcmBaseCollectionItem,
  vcmControlsCollectionItem,
  vcmControlsCollection,
  vcmBaseOperationsCollection,
  vcmBaseOperationsCollectionItem,
  vcmEntitiesCollectionItemEntity,
  vcmEntityFormDef,
  vcmUserTypeDef,
  vcmBaseMenuManager,
  vcmMenuManager
  {$IfDef vcmUseSettings}
  ,
  vcmSettings
  {$EndIf vcmUseSettings}
  ,
  vcmRepositoryEx,
  vcmUtils,
  vcmExportConst,
  vcmComponentResCollectionItem,
  vcmTaskPanelInterfaces,
  vcmInternalConst,
  vcmLocalInterfaces,
  vcmAggregate,
  vcmIEntityFormList,
  vcmMessages,

  vcmOperationsCollectionItem,

  vcmHistoryService,
  vcmAggregateContainerRegistry

  {$IfNDef NoVGScene}
  ,
  vg_scene
  {$EndIf  NoVGScene}

  ,
  afwSettingsChangePublisher,

  vcmBaseTypes,

  l3BatchService,
  l3ProtoDataContainer
  ;

{$Include afwSettingsReplace.imp.pas}

{$Include afwApplicationDataUpdate.imp.pas}

// start class TvcmEntityForm

constructor TvcmEntityForm.Create(anOwner: TComponent);
  //override;
  {-}
begin
 f_FloatingVisible := true;
 f_WasSaved := false;
 f_UserTypes := TvcmUserTypesCollection.Create(Self);
 f_UserTypes.OnWeightChanged := UserTypeWeightChanged;
// Toolbars := [vcm_tbpTop];
 f_Style := TvcmFormStyle.Create;
 inherited Create(anOwner);
 if (UserType < UserTypes.Count) then
  HelpKeyword := TvcmBaseUserTypesCollectionItem(UserTypes.Items[UserType]).Name
 else
  HelpKeyword := Name;
 HelpType := htKeyword;
 f_DockList := TvcmControlList.Make;
 f_SubUserType := vcm_utAny;
end;

function TvcmEntityForm.pm_GetWeight: Integer;
  {-}
begin
 Result := -1;
 if Assigned(CurUserType) then
  Result := CurUserType.Weight;
end;

procedure TvcmEntityForm.PageInactive;
  // virtual;
  {* - активная закладка стала не активной. }
begin
 CheckFloatingToolbarVisibility;
 // - http://mdp.garant.ru/pages/viewpage.action?pageId=596403594
end;

procedure TvcmEntityForm.CheckFloatingToolbarVisibility;
var
 I: Integer;
 l_Toolbar: TvcmToolbarDef;
begin
 for I := 0 to ComponentCount - 1 do
 begin
  if Components[I] is TvcmToolbarDef then
  begin
   l_Toolbar := Components[I] as TvcmToolbarDef;
   if l_Toolbar.Visible then
    if not l_Toolbar.Docked then
     l_Toolbar.UpdateVisibility;
  end;
 end;
end;

procedure TvcmEntityForm.PageActive;
  // virtual;
  {* - закладка стала активной. }
begin
 CheckFloatingToolbarVisibility;
end;

procedure TvcmEntityForm.DoBeforeHistoryNavigate;
var
 I: Integer;
 l_Form: IvcmEntityForm;
begin
 for I := 0 to ComponentCount - 1 do
  if Supports(Components[I], IvcmEntityForm, l_Form) then
   l_Form.BeforeHistoryNavigate;
end;

procedure TvcmEntityForm.BeforeHistoryNavigate;
begin
 DoBeforeHistoryNavigate;
end;

{$IfDef vcmUseSettings}
procedure TvcmEntityForm.InitSettingsSource;
  {-}
var
 l_Path     : TvcmPathPairs;
 l_BaseId   : String;
 l_Index    : Integer;
 l_Settings : IvcmSettingsSource;
begin
 if ComponentCount > 0 then
 begin
  vcmGetFormPath(Self, l_Path);
  l_BaseId := vcmArrayPathPairToString(l_Path);
  for l_Index := 0 to Pred(ComponentCount) do
   // Установим интерфейс настроек
   if Supports(Components[l_Index], IvcmSettingsSource, l_Settings) then
    try
     l_Settings.Settings := afw.Settings;
     l_Settings.BaseId   := l_BaseId;
    finally
     l_Settings := nil;
    end;//try..finally
 end;//if ComponentCount > 0 then
end;//InitSettingsSource

procedure TvcmEntityForm.StartNewMainForm;
  {* - вызывается перед созданием главной формы. }
begin
 DoSaveInSettings;
end;

procedure TvcmEntityForm.BeforeToolbarsCustomize;
  {* - вызывается перед вызовом окна редактирования панелей инструментов. }
begin
 if (ZoneType <> vcm_ztForToolbarsInfo) then
  SaveToolbars;
end;

procedure TvcmEntityForm.SettingsReplaceStart;
  {* - перед заменой настроек. }
begin
 DoSaveInSettings;
end;

procedure TvcmEntityForm.SettingsReplaceFinish;
  {* - после замены настроек. }
begin
end;
{$EndIf vcmUseSettings}

{$IfNDef DesignTimeLibrary}
type
  THackControl = class(TControl);
{$EndIf  DesignTimeLibrary}

procedure TvcmEntityForm.Loaded;
  //override;
  {-}
{$IfNDef DesignTimeLibrary}
var
 l_Item  : TvcmBaseCollectionItem;
 l_Index : Integer;
 l_C     : TComponent;
 l_Name  : String;
 l_CI    : TvcmComponentResCollectionItem;
 l_Items : TObject;
{$EndIf  DesignTimeLibrary}
begin
 {$IfNDef DesignTimeLibrary}
 MakeControls;
 SetControlsResources;
 AutoScroll := false;
 if (Owner <> nil) AND (ZoneType <> vcm_ztForToolbarsInfo) then
 begin
  DisableAlign;
  try
   InitControls;
  finally
   EnableAlign;
  end;//try..finally
 end;//Owner <> nil
 {$EndIf  DesignTimeLibrary}
 inherited;
 {$IfNDef DesignTimeLibrary}
 if (g_MenuManager <> nil) then
 begin
  l_Name := FormID.rName;
  if (Caption <> '') then
  begin
   l_Item := g_MenuManager.ObjectByType(vcm_objForm, l_Name);
   if (l_Item <> nil) then
    if (l_Item.Caption <> '') then
     Caption := l_Item.Caption;
  end;//Caption <> ''
  for l_Index := 0 to Pred(ComponentCount) do
  begin
   l_C := Components[l_Index];
   if (l_C Is TControl)
      {$IfNDef NoVGScene}
      or (l_C Is TvgControl)
      {$EndIf  NoVGScene}
      then
   begin
    if (l_C.Name <> '') then
    begin
     l_Item := g_MenuManager.ObjectByType(vcm_objControl, l_Name, l_C.Name);
     if (l_Item <> nil) then
     begin
      if (l_Item.Caption <> '') then
      begin
       if l_C is TControl then
        if (THackControl(l_C).Caption <> '') then
         THackControl(l_C).Caption := l_Item.Caption;
       if (GetPropInfo(l_C, c_vcmCaption) <> nil) AND
          (GetStrProp(l_C, c_vcmCaption) <> '') then
        SetStrProp(l_C, c_vcmCaption, l_Item.Caption);
      end;//l_Item.Caption <> ''
      l_CI := l_Item As TvcmComponentResCollectionItem;
      if (l_CI.Text <> '') then
      begin
       if (GetPropInfo(l_C, c_vcmText) <> nil) AND
          (GetStrProp(l_C, c_vcmText) <> '') then
        SetStrProp(l_C, c_vcmText, l_CI.Text);
      end;//l_CI.Text <> ''

      if (l_CI.Hint <> '') then
      begin
       if (GetPropInfo(l_C, c_vcmHint) <> nil) AND
          (GetStrProp(l_C, c_vcmHint) <> '') then
        SetStrProp(l_C, c_vcmHint, l_CI.Hint);
      end;//l_CI.Hint <> ''

      if (l_CI.EmptyHint <> '') then
      begin
       if (GetPropInfo(l_C, c_vcmEmptyHint) <> nil) AND
          (GetStrProp(l_C, c_vcmEmptyHint) <> '') then
        SetStrProp(l_C, c_vcmEmptyHint, l_CI.EmptyHint);
      end;//l_CI.EmptyHint <> ''

      if (l_CI.FooterCaption <> '') then
      begin
       if (GetPropInfo(l_C, c_vcmFooterCaption) <> nil) AND
          (GetStrProp(l_C, c_vcmFooterCaption) <> '') then
        SetStrProp(l_C, c_vcmFooterCaption, l_CI.FooterCaption);
      end;//l_CI.FooterCaption <> ''

      if (l_CI.ItemsText <> '') then
      begin
       if (GetPropInfo(l_C, c_vcmItems) <> nil) then
       begin
        l_Items := GetObjectProp(l_C, c_vcmItems);
        if (l_Items <> nil) then
        begin
         if (GetPropInfo(l_Items, c_vcmStrings) <> nil) AND
            (GetStrProp(l_Items, c_vcmStrings) <> '') then
          SetStrProp(l_Items, c_vcmStrings, l_CI.ItemsText)
         else
          if l_Items is TStrings then
           TStrings(l_Items).Text := l_CI.ItemsText
          else
          if (l_Items Is Tl3Strings) then
           Tl3Strings(l_Items).SetText(l_CI.ItemsText);
        end;//l_Items <> nil
       end;//GetPropInfo(l_Comp, c_vcmItems) <> nil
      end;//l_CI.ItemsText <> ''

//      SetLocalizationInfo(l_C, l_CI.AdditionalInfo);
     end;//l_Item <> nil
    end;//l_Comp.Name <> ''
   end;//l_C Is TControl
  end;//for l_Index
 end;//g_MenuManager <> nil
 if (f_Entities = nil) then
  f_Entities := TvcmEntities.Create(Self);
  // - заточка для форм без dfm
 {$EndIf  DesignTimeLibrary}
 if Assigned(Entities) then
  Entities.LinkControls;
 {$IfNDef DesignTimeLibrary}
 InitEntities;
 {$EndIf  DesignTimeLibrary}
 {$IfNDef DesignTimeLibrary}
 if (Owner <> nil) AND (ZoneType <> vcm_ztForToolbarsInfo) then
  EntitiesInited;
 {$EndIf  DesignTimeLibrary}
end;

procedure TvcmEntityForm.CallDoInit(aFormHistory : Boolean);
begin
 DoInit(aFormHistory);
(* if Assigned(f_OnInit) then
  f_OnInit;*)
end;

function TvcmEntityForm.IsVCMScalingNeeded: Boolean;
begin
 Result := Parent = nil;
end;

const
 c_DefaultDPI = 96;

procedure TvcmEntityForm.VCMScaleControls;
begin
 if IsVCMScalingNeeded and (c_DefaultDPI <> Screen.PixelsPerInch) then
  DoVCMScaleControls;
end;

procedure TvcmEntityForm.DoVCMScaleControls;
 procedure lp_ChangeScale(aControl: TWinControl; M, D: Integer);
 var
   X, Y, W, H: Integer;
   I: Integer;
 begin
  for I := 0 to aControl.ControlCount - 1 do
  begin
   with aControl.Controls[I] do
   begin
    if not (Align in [alLeft, alRight]) then
     X := MulDiv(Left, M, D)
    else
     X := Left;
    if not (Align in [alTop, alBottom]) then
     Y := MulDiv(Top, M, D)
    else
     Y := Top;
    if not (csFixedWidth in ControlStyle) then
     if Align <> alRight then
      W := MulDiv(Left + Width, M, D) - X
     else
      W := Parent.Width - MulDiv(Left, M, D)
    else
     W := Width;
    if not (csFixedHeight in ControlStyle) then
     if not (Align in [alTop, alBottom]) then
      H := MulDiv(Top + Height, M, D) - Y
     else
      H := MulDiv(Height, M, D)
    else
     H := Height;
    SetBounds(X, Y, W, H);
   end;
   if aControl.Controls[I] is TWinControl then
    lp_ChangeScale(aControl.Controls[I] as TWinControl, M, D);
  end;
 end;
var
 H: Integer;
 M, D: Integer;
begin
 M := Screen.PixelsPerInch;
 D := c_DefaultDPI;
 DisableAlign;
 try
  if Parent = nil then
  begin
   H := ClientHeight;
   ClientWidth := MulDiv(ClientWidth, M, D);
   ClientHeight := MulDiv(H, M, D);
  end;
  lp_ChangeScale(Self, M, D);
 finally
  EnableAlign;
 end;
end;

procedure TvcmEntityForm.DoInit(aFormHistory : Boolean);
  //virtual;
  {-}
begin
end;

procedure TvcmEntityForm.CreateFormGUID(var theGUID : TGUID);
  //virtual;
  {-}
begin
 SysUtils.CreateGUID(theGUID);
end;

procedure TvcmEntityForm.ReleaseResources;
  //virtual;
begin

end;

procedure TvcmEntityForm.BeforeClosing;
  //virtual
begin

end;

function TvcmEntityForm.NeedTerminateApp: Boolean;
  //virtual
var
 l_Main: TCustomForm;
begin
 l_Main := Application.MainForm;
 Result := ((l_Main = Self) OR (Self Is TvcmMainForm)) AND
           (Dispatcher.FormDispatcher.MainFormsCount = 1);
end;

function TvcmEntityForm.DoGetTabCaption: IvcmCString;
begin
 Result := MainCaption;
end;

function TvcmEntityForm.HasFormModalState: Boolean;
begin
 Result := ((fsModal in FormState) and IsWindowEnabled(Handle) and IsWindowVisible(Handle));
end;

procedure TvcmEntityForm.DoOnShowModal;
begin
 // Ничего не делаем
end;

function TvcmEntityForm.DoGetNeedAddFormToTasksPanel: Boolean;
begin
 Result := True;
end;

function TvcmEntityForm.DoGetNeedSaveToTabHistory: Boolean;
begin
 Result := True;
end;

function TvcmEntityForm.NeedSaveToTabHistory: Boolean;
begin
 Result := DoGetNeedSaveToTabHistory;
end;

class function TvcmEntityForm.GetExistingInstance(const aContainer: IvcmContainer;
                                                  const aParams: IvcmMakeParams;
                                                  aZoneType: TvcmZoneType = vcm_ztAny;
                                                  aUserType: TvcmUserType = 0;
                                                  aGUID: PGUID = nil;
                                                  const aDataSource: IvcmFormDataSource = nil;
                                                  aSubUserType: TvcmUserType = vcm_utAny): IvcmEntityForm;
begin
 if aContainer.HasForm(Self.cFormID, aZoneType, true, @Result, aUserType, aGUID,
   aSubUserType) then
 begin
  Assert(not Result.VCMClosing);
  // - если форма УЖЕ закрывается, то её наверное повторно использовать НЕЛЬЗЯ
  Result.DataSource := aDataSource;
 end//aCont.HasForm(Self.cFormID, aZoneType, true, @Result, aUserType, aGUID
end;


class function TvcmEntityForm.Make(const aParams     : IvcmMakeParams;
                                   aZoneType         : TvcmZoneType = vcm_ztAny;
                                   aUserType         : TvcmEffectiveUserType = 0;
                                   aGUID             : PGUID = nil;
                                   const aDataSource : IvcmFormDataSource = nil;
                                   aSubUserType      : TvcmUserType = vcm_utAny;
                                   aAfterCreate      : TvcmInitProc = nil): IvcmEntityForm;
  // reintroduce;
  {* - создает форму сущности. }
var
 l_ArrangeOwner : Boolean;
 l_Container    : IvcmContainer;
 l_OVContainer  : TWinControl;
 l_VContainer   : TWinControl;
 l_FD           : IvcmFormDispatcher;
 l_MainForm     : IvcmEntityForm;
 l_FromHistory  : Boolean;
 l_Inst         : TvcmEntityForm;
 l_Params       : IvcmMakeParams;
begin
 l_ArrangeOwner := false;
 l_FromHistory := (aGUID <> nil);
 if (aParams = nil) then
  l_Params := vcmMakeParams
 else
  l_Params := aParams; 
 if (l_Params.Owner = nil) then
 begin
  l_ArrangeOwner := true;
  if not (aZoneType in [vcm_ztModal, vcm_ztManualModal, vcm_ztSimpleFloat]) then
  begin
   if (l_Params.Container = nil) then
   begin
    if (vcmDispatcher <> nil) then
     l_MainForm := vcmDispatcher.FormDispatcher.CurrentMainForm
    else
     l_MainForm := nil;
    if (l_MainForm <> nil) then
     l_Inst := Create(l_MainForm.VCLWinControl)
    else
    if (Application.MainForm <> nil) then
     l_Inst := Create(Application.MainForm)
    else
     l_Inst := Create(Application);
   end//l_Params.Container = nil
   else
    l_Inst := Create(l_Params.Container.AsForm.VCLWinControl);
  end//not (aZoneType in [vcm_ztModal, vcm_ztManualModal, vcm_ztSimpleFloat])
  else
   l_Inst := Create(Application);
 end//l_Params.Owner = nil
 else
  l_Inst := Create(l_Params.Owner);
 Assert(l_Inst <> nil); 
 Result := l_Inst.As_IvcmEntityForm; 
 with l_Inst do
 begin
  if (f_UserType <> aUserType) then
  begin
   f_UserType := aUserType;
   if (UserType < UserTypes.Count) then
    HelpKeyword := TvcmBaseUserTypesCollectionItem(UserTypes.Items[UserType]).Name
   else
    HelpKeyword := Name;
  end;//f_UserType <> aUserType
  f_SubUserType := aSubUserType;
  NotifyUserTypeSet;
  // Определим Caption в ссответствии с UserType. Если Caption пустой, то значит
  // форма не принимает участие в формировании Caption главного окна, ей не
  // нужно устанавливать Caption
  if (Caption <> '') and CheckUserTypeRange then
   Caption := UserTypes[f_UserType].Caption;
  if (aGUID = nil) then
   CreateFormGUID(f_GUID)
  else
   f_GUID := aGUID^;
  if (Dispatcher <> nil) then
   l_FD := Dispatcher.FormDispatcher
  else
   l_FD := nil;
  if (l_FD <> nil) then
   l_FD.Lock;
  try
   if (aZoneType <> vcm_ztAny) then
    ZoneType := aZoneType;
   if (ZoneType <> vcm_ztForToolbarsInfo) then
   begin
    if Assigned(aAfterCreate) then
     aAfterCreate(l_Inst);
   end;//ZoneType <> vcm_ztForToolbarsInfo
   if not (ZoneType in [vcm_ztModal, vcm_ztManualModal, vcm_ztSimpleFloat]) then
   begin
    if (l_Params.Container <> nil) then
    begin
     //DataSource := aDataSource;
     // - нельзя это тут :-(
     // http://mdp.garant.ru/pages/viewpage.action?pageId=259169613
     // Открываем флеш №5451001. Тыкаем в ссылку. Огребаем AV.
     Aggregate := l_Params.Aggregate;
     // - т.к. можем хотеть вызвать операцию через агрегацию например в TExTextForm.FormInsertedIntoContainer
     l_Params.Container.InsertForm(Result);
     l_Container := Container;
     if l_ArrangeOwner AND (l_Container <> nil) AND not l_Container.IsNull then
     begin
      l_VContainer := l_Container.AsForm.VCLWinControl;
      l_OVContainer := l_Params.Container.AsForm.VCLWinControl;
      if (l_VContainer <> l_OVContainer) then
      begin
       // - надо подменить контейнер
       l_OVContainer.RemoveComponent(l_Inst);
       l_VContainer.InsertComponent(l_Inst);
      end;//l_VContainer <> l_OVContainer
     end;//l_ArrangeOwner..
    end;//l_Params.Container <> nil
   end//not (ZoneType
   else
   begin
    // - здесь надо проверить что с Owner'ом
    if l_ArrangeOwner then
    begin
     if (Owner <> Application) then
     begin
      if (Owner <> nil) then
       Owner.RemoveComponent(l_Inst);
      Application.InsertComponent(l_Inst);
     end;//Owner <> Application
    end;//l_ArrangeOwner
   end;//not (ZoneType in [vcm_ztModal, vcm_ztManualModal, vcm_ztSimpleFloat])
   if (ZoneType <> vcm_ztForToolbarsInfo) then
   begin
    //http://mdp.garant.ru/pages/viewpage.action?pageId=505415962
    SetupFormLayout;
    VCMScaleControls;
    // Установим позицию перед отображением формы:
    DoLoadFromSettings;
   end;
   if (l_FD <> nil) then
    l_FD.AddForm(Result);
   if (ZoneType <> vcm_ztForToolbarsInfo) then
   begin
    Result.RegInContainer;
    if Result.IsMainObjectForm then
     vcmDispatcher.FormDispatcher.UpdateMainCaption(Result);
   end;//ZoneType <> vcm_ztForToolbarsInfo
   Aggregate := l_Params.Aggregate;
   if (ZoneType <> vcm_ztForToolbarsInfo) then
    CallDoInit(l_FromHistory);
   if ZoneType <> vcm_ztForToolbarsInfo then
   begin
    l_Inst.ManualUpdateActions;
    g_MenuManager.PostBuild(l_Inst);
    vcmCorrectWindowBounds(l_Inst);
   end;//ZoneType <> vcm_ztForToolbarsInfo
   {$IfDef vcmUseSettings}
   InitSettingsSource;
   {$EndIf vcmUseSettings}
   DataSource := aDataSource;
   if (ZoneType = vcm_ztModal) then
   begin
    try
     Assert(l_FD <> nil);
     l_FD.Unlock;
     try
      l_Inst.ShowModal;
     finally
      l_FD.Lock;
     end;//try..finally
    finally
     l_Inst.Free;
     Result := nil;
    end;//try..finally
   end;//ZoneType = vcm_ztModal
  finally
   if (l_FD <> nil) then
    l_FD.UnLock;
  end;//try..finally
 end;//with l_Inst
end;

class function TvcmEntityForm.MakeSingleChild(const aCont       : IvcmContainer;
                                        const aParams     : IvcmMakeParams;
                                        aZoneType         : TvcmZoneType = vcm_ztAny;
                                        aUserType         : TvcmUserType = 0;
                                        aGUID             : PGUID = nil;
                                        const aDataSource : IvcmFormDataSource = nil;
                                        aSubUserType      : TvcmUserType = vcm_utAny;
                                        aAfterCreate      : TvcmInitProc = nil): IvcmEntityForm;
  {* - создает форму сущности если таковой не было и вставляет ее в контейнер. }
begin
 Result := nil;
 Assert(aCont <> nil);
 Result := {TvcmEntityForm.}GetExistingInstance(aCont, aParams, aZoneType, aUserType, aGUID,
   aDataSource, aSubUserType);
 if (Result = nil) then
  Result := Self.Make(vcmMakeParams(aParams.Aggregate, aCont, aParams.Owner),
                      aZoneType,
                      aUserType,
                      aGUID,
                      aDataSource,
                      aSubUserType,
                      aAfterCreate);
end;

function TvcmEntityForm.CanRemoveInKillFromVCM: Boolean;
  //virtual;
  {-}
begin
 Result := true;
end;

procedure TvcmEntityForm.KillFromVCM;
  {-}
var
 l_Index : Integer;
begin
 if (Entities <> nil) then
  Entities.UnlinkControls;
 l_Index := 0;
 while (l_Index < ComponentCount) do
 begin
  if (Components[l_Index] Is TvcmEntityForm) then
   TvcmEntityForm(Components[l_Index]).KillFromVCM;
  Inc(l_Index);
 end;//l_Index < ComponentCount
 if (Aggregate <> nil) then
  Aggregate.RemoveEntity(Entity);
 if (Owner <> nil) and (Dispatcher <> nil) then
  if CanRemoveInKillFromVCM then
   Dispatcher.FormDispatcher.RemoveForm(As_IvcmEntityForm);
end;

function TvcmEntityForm.FocusLocked : Boolean;
begin
 Result := (f_LockFocusCount > 0);
end;

procedure TvcmEntityForm.UpdateCaption(const aCaption: Il3CString);
  //virtual;
  {-}
begin
 if (CurUserTypeDef = nil) then
  CCaption := aCaption
 else
  CCaption := vcmFmt('%s: %s', [CurUserTypeDef.Caption, aCaption])
end;

function TvcmEntityForm.pm_GetBoundsRect: TRect;
  {-}
begin
 Result := BoundsRect;
end;

procedure TvcmEntityForm.WMWindowPosChanging(var aMessage: TWMWindowPosChanging);
  //message WM_WINDOWPOSCHANGING;
  {* - при достижении минимальных размеров окно не перемещается вправо(вниз).

       Дело в том, что в WindowPos.x(y) приходят значения в соответствии
       с положением курсора. Т.е. у пользователя появился тяни-толкайчик
       на границе окна <-->, дальше пользователь немного сдвинул курсор
       вправо, в сообщение приходит граница окна x(y) в соответствии с
       положением курсора. Дальше мы выяснили, что уменьшать размер формы
       нельзя (Constraints), корректируем cx(cy) (на уровне vcl), но x(y)
       оставляем без изменения, в результате окно не меняет размер, но
       смещается вправо. }
var
 l_Pos    : TWindowPos;
 l_Bounds : TRect;
begin
// l_Pos := aMessage.WindowPos^;
 inherited;
 // Нижестоящее шаманство заменил на более другое в WM_SIZING, совместимое с Aero Snap в W7/W8
 // http://mdp.garant.ru/pages/viewpage.action?pageId=570121096

(* l_Bounds := Self.BoundsRect;
 with aMessage.WindowPos^, Constraints do
  if not (csLoading in ComponentState) and (flags and SWP_NOSIZE = 0) then
  begin
//    Пользователь двигает вправо и двигать дальше некуда:
   if (l_Pos.cx < Self.Width) and (MinWidth > 0) and
     (l_Bounds.Right - l_Pos.x < MinWidth) then
    x := l_Bounds.Right - MinWidth;
//    Пользователь двигает вниз и двигать дальше некуда:
   if (l_Pos.cy < Self.Height) and (MinHeight > 0) and
     (l_Bounds.Bottom - l_Pos.y < MinHeight) then
    y := l_Bounds.Bottom - MinHeight;
  end;                 *)
end;

procedure TvcmEntityForm.WMSizing(var aMessage: TMessage);
var
 l_Rect: TRect;
begin
 // Смысл этого следующий.
 // 1) Пользователь ресайзит окно, уменьшая его высоту
 // 2) при достижении минимального размера (Constraints) - окно вместо
 //   ресайза начинает двигаться вверх или вниз (зачем-то).
 // Вся эта беда была поправлена в TvcmEntityForm.WMWindowPosChanging,
 // но в Windows 7 это привело к косякам в работе Aero Snap.
 // Утверждается, что "WM_SIZING message sent to a window that the user is resizing.
 // By processing this message, an application can monitor the size and position
 // of the drag rectangle and, if needed, change its size or position".
 // http://mdp.garant.ru/pages/viewpage.action?pageId=570121096

 l_Rect := PRect(aMessage.LParam)^;
 if ((Constraints.MinWidth > 0) AND
    (l_Rect.Right < l_Rect.Left + Constraints.MinWidth)) then
 begin
  case aMessage.WParam of
   WMSZ_LEFT,
   WMSZ_TOPLEFT,
   WMSZ_BOTTOMLEFT:
    l_Rect.Left := l_Rect.Right - Constraints.MinWidth;
   WMSZ_RIGHT,
   WMSZ_TOPRIGHT,
   WMSZ_BOTTOMRIGHT:
    l_Rect.Right := l_Rect.Left + Constraints.MinWidth;
  end;//case aMessage.WParam
 end;//if ((MinWidth > 0) AND...

 if ((Constraints.MinHeight > 0) AND
    (l_Rect.Bottom < l_Rect.Top + Constraints.MinHeight)) then
 begin
  case aMessage.WParam of
   WMSZ_TOP,
   WMSZ_TOPLEFT,
   WMSZ_TOPRIGHT:
    l_Rect.Top := l_Rect.Bottom - Constraints.MinHeight;
   WMSZ_BOTTOM,
   WMSZ_BOTTOMLEFT,
   WMSZ_BOTTOMRIGHT:
    l_Rect.Bottom := l_Rect.Top + Constraints.MinHeight;
  end;//case aMessage.WParam
 end;//if ((MinHeight > 0) AND...

 if ((Constraints.MaxWidth > 0) AND
    (l_Rect.Right > l_Rect.Left + Constraints.MaxWidth)) then
 begin
  case aMessage.WParam of
   WMSZ_LEFT,
   WMSZ_TOPLEFT,
   WMSZ_BOTTOMLEFT:
    l_Rect.Left := l_Rect.Right - Constraints.MaxWidth;
   WMSZ_RIGHT,
   WMSZ_TOPRIGHT,
   WMSZ_BOTTOMRIGHT:
     l_Rect.Right := l_Rect.Left + Constraints.MaxWidth;
  end;//case aMessage.WParam
 end;//if ((MaxWidth > 0) AND...

 if ((Constraints.MaxHeight > 0) AND
    (l_Rect.Bottom > l_Rect.Top + Constraints.MaxHeight)) then
 begin
  case aMessage.WParam of
   WMSZ_TOP,
   WMSZ_TOPLEFT,
   WMSZ_TOPRIGHT:
    l_Rect.Top := l_Rect.Bottom - Constraints.MaxHeight;
   WMSZ_BOTTOM,
   WMSZ_BOTTOMLEFT,
   WMSZ_BOTTOMRIGHT:
    l_Rect.Bottom := l_Rect.Top + Constraints.MaxHeight;
  end;//case aMessage.WParam
 end;//if ((Constraints.MaxHeight > 0) AND
 PRect(aMessage.LParam)^ := l_Rect;
end;

procedure TvcmEntityForm.CMTextChanged(var Message: TMessage);
  //message CM_TEXTCHANGED;
  {-}
begin
 inherited;
 if not (csDesigning in ComponentState) then
 begin
  if IsMainObjectForm AND (Dispatcher <> nil) then
   Dispatcher.FormDispatcher.UpdateMainCaption(As_IvcmEntityForm);
 end;//not (csDesigning in ComponentState)
end;

procedure TvcmEntityForm.pm_SetAggregate(const aValue: IvcmAggregate);
  {-}
var
 l_Entity : IvcmEntity;
begin
 if (f_Aggregate <> aValue) then
 begin
  l_Entity := Self.Entity;
  if (f_Aggregate <> nil) AND (l_Entity <> nil) then
  begin
   f_Aggregate.RemoveEntity(l_Entity);
   TvcmAggregateContainerRegistry.Instance.UnregisterAggregate(Aggregate);
  end;
  f_Aggregate := aValue;
  if (f_Aggregate <> nil) then
  begin
   f_Aggregate.AddEntity(l_Entity);
   TvcmAggregateContainerRegistry.Instance.RegisterFormAggregate(As_IvcmEntityForm);   
  end;
 end;//f_Aggregate <> aValue
end;

function TvcmEntityForm.Get_MainCaption: IvcmCString;
  {-}
begin
 Result := vcmCStr(Caption);
end;

function TvcmEntityForm.Get_FormDef: IvcmEntityFormDef;
  {-}
begin
 if (f_FormDef = nil) then
  f_FormDef := TvcmEntityFormDef.Make(FormID.rName, vcmCStr(Caption), ClassType);
 Result := f_FormDef;
end;

class function TvcmEntityForm.FormImplementationClass: TClass;
  //override;
  {-}
begin
 Result := TvcmEntityFormImplementation;
end;

procedure TvcmEntityForm.DoUpdateStatus;
  //override;
  {-}
begin
 inherited;
 if Assigned(Dispatcher) then
  Dispatcher.UpdateStatus;
end;

function TvcmEntityForm.pm_GetEntity: IvcmEntity;
  {-}
begin
 if (f_Entity = nil) then
  Result := Self As IvcmEntity
 else
  Result := f_Entity;
end;

function TvcmEntityForm.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {* - метод для реализации QueryInterface (Для перекрытия в потомках). }
begin
 if IID.SomeOf([IafwGUIDHolder, IvcmEntityForm]) then
 begin
  if (f_Form = nil) then
   Result.SetNoInterface
  else
   Result := Tl3HResult_C(f_Form.QueryInterface(IID.IID, Obj))
 end//IID.EQ(IvcmEntityForm)
 else
 if IID.EQ(IvcmEntity) then
 begin
  if (f_Entity = nil) then
   Pointer(f_Entity) := Pointer(IvcmEntity(TvcmFormEntity.Create(Self)));
  Result.SetOk;
  IvcmEntity(Obj) := Entity;
 end//IID.EQ(IvcmEntity)
 else
 if IID.EQ(IvcmEntityFormDef) then
  Result := Tl3HResult_C(FormDef.QueryInterface(IID.IID, Obj))
 else
  Result := inherited COMQueryInterface(IID, Obj);
end;

class procedure TvcmEntityForm.ClassGetEntitiesDef(aList      : TvcmEntitiesDefList;
                                                   aUserTypes : TvcmUserTypeDefList);
  {-}
begin
 with Create(nil) do
 try
  GetEntitiesDef(aList);
  GetUserTypes(aUserTypes);
 finally
  Free;
 end;//try..finally
end;

procedure TvcmEntityForm.GetUserTypes(aList : TvcmUserTypeDefList);
  {-}
var
 l_Index   : Integer;
 l_Caption : IvcmCString;
begin
 if (UserTypes <> nil) AND (aList <> nil) then
  with UserTypes do
   for l_Index := 0 to Pred(Count) do
   begin
    with TvcmBaseUserTypesCollectionItem(Items[l_Index]) do
    begin
     l_Caption := vcmCStr(TrimRight(Caption));
     if f_UserType >= 0 then
       aList.Add(TvcmUserTypeDef.Make(Name,
                                      l_Caption,
                                      Index,
                                      Self.ClassType,
                                      AllowCustomizeToolbars,
                                      SettingsCaption,
                                      Index <> UseToolbarOfUserType.Index,
                                      GetUserVisibleOperationsCount(l_Index)))
      else
       aList.Add(TvcmUserTypeDef.Make(Name,
                                      l_Caption,
                                      l_Index,
                                      Self.ClassType,
                                      false,
                                      vcmStr(l_Caption),
                                      False))
    end;//with TvcmBaseUserTypesCollectionItem(Items[l_Index])
   end;
end;

procedure TvcmEntityForm.GetEntitiesDef(aList : TvcmEntitiesDefList);
  //virtual;
  {-}
begin
 if (aList <> nil) AND (Entities <> nil) then
  Entities.GetEntitiesDef(aList);
end;

function TvcmEntityForm.GetEntitiesDefIterator: IvcmEntitiesDefIterator;
  {*- возвращает итератор описаний сущностей. }
var
 l_EntitiesIterator : TvcmEntitiesDefIterator;
begin
 if (f_EntitiesList = nil) then
 begin
  f_EntitiesList := TvcmEntitiesDefList.Create;
  try
   GetEntitiesDef(f_EntitiesList);
  except
   vcmFree(f_EntitiesList);
   raise;
  end;//try..except
 end;//f_EntitiesList = nil
 if f_EntitiesList.Empty then
  Result := nil
 else
 begin
  l_EntitiesIterator := TvcmEntitiesDefIterator.Create(f_EntitiesList);
  try
   Result := l_EntitiesIterator;
  finally
   vcmFree(l_EntitiesIterator);
  end;//try..finally
 end;//f_EntitiesList.Empty
end;

procedure TvcmEntityForm.BecomeActive;
begin
 if (Owner <> nil) then
  DoUpdateStatus;
end;

procedure TvcmEntityForm.BecomeInactive;
  //virtual;
  {-}
begin
end;

procedure TvcmEntityForm.Activate;
  //override;
  {-}
begin
 inherited;
 if not (csDesigning in ComponentState) then
  BecomeActive;
end;

procedure TvcmEntityForm.Deactivate;
  //override;
  {-}
begin
 inherited;
 if not (csDesigning in ComponentState) then
  BecomeInactive;
end;

procedure TvcmEntityForm.MakeAggregate;
  {-}
begin
 if (Aggregate = nil) then
  Aggregate := TvcmAggregate.Make;
end;

type
 IvcmStateItem = interface(IUnknown)
   ['{89686484-2090-46E7-B98A-E464E86DC4FD}']
   procedure LoadState(aForm: TvcmEntityForm;
     aStateType: TvcmStateType;
     aClone: Boolean);
 end;//IvcmStateItem

  TvcmStateItem = class(TvcmCacheableBase, IvcmStateItem)
    private
    // internal fields
      f_Name  : String;
      f_State : IUnknown;
    private
    // interface methods
      // IvcmStateItem
      procedure LoadState(aForm      : TvcmEntityForm;
                          aStateType : TvcmStateType;
                          aClone: Boolean);
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(const aName  : String;
                         const aState : IUnknown);
        reintroduce;
        {-}
      class function Make(const aName  : String;
                          const aState : IUnknown): IvcmStateItem;
        {-}
      function  COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
  end;//TvcmStateItem

constructor TvcmStateItem.Create(const aName  : String;
                                 const aState : IUnknown);
  //reintroduce;
  {-}
begin
 inherited Create;
 f_Name := aName;
 f_State := aState;
end;

class function TvcmStateItem.Make(const aName  : String;
                                  const aState : IUnknown): IvcmStateItem;
  {-}
var
 l_State : TvcmStateItem;
begin
 l_State := Create(aName, aState);
 try
  Result := l_State;
 finally
  vcmFree(l_State);
 end;//try..finally
end;

function TvcmStateItem.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {-}
begin
 Result := inherited COMQueryInterface(IID, Obj);
 if Result.Fail then
  Result := Tl3HResult_C(l3QueryInterface(f_State, IID.IID, Obj));
end;

procedure TvcmStateItem.Cleanup;
  //override;
  {-}
begin
 f_Name := '';
 f_State := nil;
 inherited;
end;

procedure TvcmStateItem.LoadState(aForm      : TvcmEntityForm;
                                  aStateType : TvcmStateType;
                                  aClone: Boolean);
  {-}
var
 l_State : IvcmState;
 l_St    : IvcmBase;
begin
 if (f_Name = '') then
 begin
  if Supports(f_State, IvcmBase, l_St) then
  try
   aForm.DoLoadState(l_St, aStateType, aClone);
  finally
   l_St := nil;
  end;//try..finally
 end//aName = ''
 else
 if Supports(aForm.FindComponent(f_Name), IvcmState, l_State) then
  try
   l_State.LoadState(f_State, vcmExternalInterfaces.TvcmStateType(aStateType), aClone);
  finally
   l_State := nil;
  end;//try..finally
end;

type
 IvcmFormState = interface(IvcmBase)
   ['{BB487EA1-7432-4B8B-B634-114A5634FE7D}']
   procedure LoadState(aForm: TvcmEntityForm;
     aStateType: TvcmStateType;
     aClone: Boolean);
 end;//IvcmFormState

  _ItemType_ = IvcmStateItem;
  _l3InterfaceRefList_Parent_ = Tl3ProtoDataContainer;
 {$Define l3Items_IsProto}
 {$Include w:\common\components\rtl\Garant\L3\l3InterfaceRefList.imp.pas}
  TvcmFormState = class(_l3InterfaceRefList_, IvcmBase, IvcmFormState)
  protected
  // realized methods
   procedure LoadState(aForm: TvcmEntityForm;
      aStateType: TvcmStateType;
      aClone: Boolean);
  public
  // public methods
   procedure AddState(const aName: AnsiString;
      const aState: IUnknown);
  end;//TvcmFormState

type _Instance_R_ = TvcmFormState;

{$Include w:\common\components\rtl\Garant\L3\l3InterfaceRefList.imp.pas}

// start class TvcmFormState

procedure TvcmFormState.AddState(const aName: AnsiString;
  const aState: IUnknown);
//#UC START# *55C1FE41015B_55C1F803015D_var*
//#UC END# *55C1FE41015B_55C1F803015D_var*
begin
//#UC START# *55C1FE41015B_55C1F803015D_impl*
 if (aState <> nil) then
  Add(TvcmStateItem.Make(aName, aState));
//#UC END# *55C1FE41015B_55C1F803015D_impl*
end;//TvcmFormState.AddState

procedure TvcmFormState.LoadState(aForm: TvcmEntityForm;
  aStateType: TvcmStateType;
  aClone: Boolean);
//#UC START# *55C1F7D50220_55C1F803015D_var*
var
 l_Index : Integer;
//#UC END# *55C1F7D50220_55C1F803015D_var*
begin
//#UC START# *55C1F7D50220_55C1F803015D_impl*
 for l_Index := Lo to Hi do
  Items[l_Index].LoadState(aForm, aStateType, aClone);
//#UC END# *55C1F7D50220_55C1F803015D_impl*
end;//TvcmFormState.LoadState

function TvcmEntityForm.DoLoadState(const aState : IvcmBase;
                                    aStateType   : TvcmStateType;
                                    aClone: Boolean): Boolean;
  //virtual;
  {-}
begin
 if Assigned(f_OnLoadState) then
 begin
  Result := true;
  f_OnLoadState(aState, aStateType, Result);
 end
 else
  Result := false;
end;

function TvcmEntityForm.LoadState(const aState : IvcmBase;
                                  aStateType   : TvcmStateType): Boolean;
  {-}
var
 l_FormState : IvcmFormState;
begin
 if Supports(aState, IvcmFormState, l_FormState) then
  try
   l_FormState.LoadState(Self, aStateType, False);
   Result := true;
  finally
   l_FormState := nil;
  end//try..finally
 else
  Result := DoLoadState(aState, aStateType, False);
end;

function TvcmEntityForm.SaveOwnFormState(out theState : IvcmBase;
                                         aStateType   : TvcmStateType;
                                         aForClone    : Boolean): Boolean;
  //virtual;
  {-}
begin
 if Assigned(f_OnSaveState) then
 begin
  Result := true;
  f_OnSaveState(theState, aStateType, Result);
 end//Assigned(f_OnSaveState)
 else
  Result := false;
end;
  
function TvcmEntityForm.DoSaveState(out theState : IvcmBase;
                      aStateType   : TvcmStateType;
                      aForClone    : Boolean): Boolean;
  //virtual;
  {-}

var
 l_FormState : TvcmFormState;

 procedure SaveControls(aControl: TWinControl);

  procedure lp_AddChildState(const aState: IUnknown; const aName: String);
  begin
   if (l_FormState = nil) then
    l_FormState := TvcmFormState.Create;
   l_FormState.AddState(aName, aState);
  end;//lp_AddChildState

 var
  l_Index          : Integer;
  l_Child          : TComponent;
  l_State          : IvcmState;
  l_CloneableState : IvcmCloneableState;
  l_St             : IUnknown;
  l_Name           : String;
 begin//SaveControls
  with aControl do
   for l_Index := 0 to Pred(ComponentCount) do
   begin
    l_Child := Components[l_Index];
    l_Name := l_Child.Name;
    if (l_Name <> '') then
    begin
     if aForClone and Supports(l_Child, IvcmCloneableState, l_CloneableState) then
     try
      if l_CloneableState.SaveStateForClone(l_St, aStateType) then
       lp_AddChildState(l_St, l_Name);
     finally
      l_State := nil;
     end
     else
     if Supports(l_Child, IvcmState, l_State) then
     try
      if l_State.SaveState(l_St, aStateType) then
       lp_AddChildState(l_St, l_Name);
     finally
      l_State := nil;
     end//try..finally
    end;
   end;//for l_Index
 end;//SaveControls

begin
 theState := nil;
 l_FormState := nil;
 try
  Result := SaveOwnFormState(theState, aStateType, aForClone);
  SaveControls(Self);
  if (l_FormState <> nil) then
  begin
   if Result AND (theState <> nil) then
    l_FormState.AddState('', theState);
    // - здесь надо заковырять состояние в l_FormState
   theState := IvcmFormState(l_FormState);
   Result := true;
  end;//l_FormState <> nil
 finally
  vcmFree(l_FormState);
 end;//try..finally
end;

function TvcmEntityForm.SaveState(out theState : IvcmBase;
                                  aStateType   : TvcmStateType): Boolean;
  {-}
begin
 (*if IsBaloon then
 begin
  Result := false;
  Exit;
 end;//IsBaloon*)
 if VCMClosing then
 begin
  if f_WasSaved then
  begin
   Result := false;
   Exit;
  end//f_WasSaved
  else
   f_WasSaved := true;
 end;//VCMClosing
 Result := DoSaveState(theState, aStateType, False);
end;

function TvcmEntityForm.DoSaveStateForClone(out theState: IvcmBase;
                                            aStateType: TvcmStateType): Boolean;
begin
 Result := DoSaveState(theState, aStateType, True);
end;

function TvcmEntityForm.NeedLoadFormStateForClone(const aState: IvcmBase;
                               aStateType: TvcmStateType): Boolean;
  {-}
begin
 Result := True;
end;

function TvcmEntityForm.DoLoadCloneState(const theState: IvcmBase;
                                         aStateType: TvcmStateType): Boolean;

begin
 Result := DoLoadState(theState, aStateType, True);
end;

function TvcmEntityForm.SaveStateForClone(out theState: IvcmBase;
                                          aStateType: TvcmStateType): Boolean;
begin
 Result := DoSaveStateForClone(theState, aStateType);
end;

function TvcmEntityForm.LoadCloneState(const theState: IvcmBase;
                                       aStateType: TvcmStateType): Boolean;
var
 l_FormState : IvcmFormState;
begin
 if Supports(theState, IvcmFormState, l_FormState) and
   NeedLoadFormStateForClone(l_FormState, aStateType) then
  try
   l_FormState.LoadState(Self, aStateType, True);
   Result := true;
  finally
   l_FormState := nil;
  end//try..finally
 else
  Result := DoLoadCloneState(theState, aStateType);
end;

function TvcmEntityForm.IsModalForm: Boolean;
  {-}
var
 l_Form   : TvcmEntityForm;
 l_Parent : TCustomForm;
begin
 Result := false;
 l_Form := Self;
 while true do
 begin
  Result := l_Form.IsModal;
  if Result then
   break;
  l_Parent := afw.GetAnotherParentForm(l_Form);
  if (l_Parent Is TvcmEntityForm) then
   l_Form := TvcmEntityForm(l_Parent)
  else
   break;
 end;//while true
end;

function TvcmEntityForm.GetStatus(out theStatus : TvcmStatusStrings): Boolean;
  {-}
var
 l_Element      : IafwStatusElement;
 l_Caption      : Il3CString;
 l_NeedProgress : Boolean;
begin
 Result := true;
 theStatus.rNeedProgress := False;
 // - если ничего не вернули, то статус все равно надо очищать
 if Supports(ActiveControl, IafwStatusElement, l_Element) then
  try
   l_Element.GetStatusInfo(l_Caption, l_NeedProgress);
   with theStatus do
   begin
    rNeedProgress := rNeedProgress or l_NeedProgress;
    if not vcmIsNil(l_Caption) then
    begin
     SetLength(rStrings, 1);
     rStrings[0] := l_Caption;
     Exit;
    end;//l_Caption <> ''
   end;
  finally
   l_Element := nil;
  end;//try..finally
 if Assigned(f_OnGetStatus) then
  f_OnGetStatus(Self, theStatus);
end;

procedure TvcmEntityForm.ManualUpdateActions;
  //override;
  {-}
var
 l_Form    : TCustomForm;
 l_VcmForm : IvcmEntityForm;
begin
 if (Dispatcher <> nil) and
    Dispatcher.FormDispatcher.Locked then
 begin
  Dispatcher.FormDispatcher.AddFormForUpdateActions(Self.As_IvcmEntityForm);
  l_Form := afw.GetAnotherParentForm(Self);
  if Supports(l_Form, IvcmEntityForm, l_VcmForm) then
   Dispatcher.FormDispatcher.AddFormForUpdateActions(l_VcmForm);
 end
 else
 begin
  inherited;
  l_Form := afw.GetAnotherParentForm(Self);
  if (l_Form Is TvcmForm) then
   TvcmForm(l_Form).ManualUpdateActions;
 end;
end;

procedure TvcmEntityForm.KillMe;
  //override;
  {-}

 procedure CleanQueue(aControl : TWinControl);
 var
  l_Msg   : TMsg;
  l_Index : Integer;
 begin//CleanQueue
  with aControl do
  begin
   while HandleAllocated AND
         l3System.
          PeekMessage(l_Msg,
                      Handle,
                      0, 0, PM_REMOVE) do
    if (l_Msg.message = WM_Paint) then
     break;
   for l_Index := 0 to Pred(ControlCount) do
    if (Controls[l_Index] Is TWinControl) then
     CleanQueue(TWinControl(Controls[l_Index]));
  end;//with aControl
 end;//CleanQueue

begin//KillMe
 CleanDependencies;
 KillFromVCM;
 CleanQueue(Self);
 if (HandleAllocated AND (g_Dispatcher <> nil) AND g_Dispatcher.InOp) then
 begin
  if IsModal then
   ClearModal;
   // - иначе форма никогда не закроется
  g_Dispatcher.FormDispatcher.AddToCloseQueue(Self.As_IvcmEntityForm);
  DestroyHandle;
 end//HandleAllocated
 else
 begin
  BeforeKill;
  Free;
 end;//HandleAllocated..
end;//KillMe

class function TvcmEntityForm.cFormID: TvcmFormID;
  {-}
begin
 Result.rID := fm_Any.rID;
 Result.rName := ClassName;
 if SameText(Result.rName[1], 'T') then
  System.Delete(Result.rName, 1, 1);
 // - отрезаем букву T
end;

function TvcmEntityForm.FormID: TvcmFormID;
  {-}
begin
 {$IfNDef DesignTimeLibrary}
 if (f_FormID.rName = '') then
  f_FormID := cFormID;
 Result := f_FormID;
 {$Else   DesignTimeLibrary}
 Result := cFormID;
 {$EndIf  DesignTimeLibrary}
end;

procedure TvcmEntityForm.ReloadToolbars;
  {-}
var
 l_Form     : IvcmEntityForm;
 l_UserType : IvcmUserTypeDef;
 l_Index    : Integer;
begin
 l_UserType := CurUserTypeDef;
 if (l_UserType <> nil) then
 begin
  with Dispatcher do
   for l_Index := 0 to Pred(EntitiesCount) do
   begin
    l_Form := Entity[l_Index].AsForm;
    if (l_Form.UserType = l_UserType.ID) AND
       l_Form.VCLWinControl.InheritsFrom(l_UserType.FormClass) then
    begin
     g_MenuManager.ReloadToolbars(l_Form);
     // - здесь надо перегрузить Toolbar'ы
    end;//UserType = l_UserType.ID..
   end;//for l_Index
 end;//l_UserType <> nil
end;

procedure TvcmEntityForm.SetParent(AParent: TWinControl);
  //override;
  {-}
begin
 if not (csDesigning in ComponentState) then
  RemoveMyFocus;
 inherited;
 if not (csDesigning in ComponentState) then
 begin
  SetMyFocus;
  if AParent <> nil then
  begin
   {$IfDef vcmUseSettings}
   // чтобы в настройках пользователя отображались актуальные настройки сохраним
   // форму:
   if (ZoneType in g_MenuManager.SaveFormZones) then
    vcmSaveForm(Self);
   {$EndIf vcmUseSettings}
  end;//if AParent <> nil then
 end;// not (csDesigning in ComponentState)
end;//SetParent

type
  THackCustomForm = class(TScrollingWinControl)
  private
    FActiveControl: TWinControl;
    FFocusedControl: TWinControl;
    FBorderIcons: TBorderIcons;
    FBorderStyle: TFormBorderStyle;
    FSizeChanging: Boolean;
    FWindowState: TWindowState;
    FShowAction: TShowAction;
    FKeyPreview: Boolean;
    FActive: Boolean;
    FFormStyle: TFormStyle;
    FPosition: TPosition;
    FDefaultMonitor: TDefaultMonitor;
    FTileMode: TTileMode;
    FDropTarget: Boolean;
    FOldCreateOrder: Boolean;
    FPrintScale: TPrintScale;
    FCanvas: TControlCanvas;
    FHelpFile: string;
    FIcon: TIcon;
    FInCMParentBiDiModeChanged: Boolean;
    FMenu: TMainMenu;
    FModalResult: TModalResult;
    FDesigner: IDesignerHook;
  end;//THackCustomForm

  THackForm = class(TCustomForm)
  end;//THackForm

procedure HackSetWindowFocus(aForm: TForm);
var
  FocusControl: TWinControl;
begin
 with THackCustomForm(aForm) do
  if (FActiveControl <> nil) and (FDesigner = nil) then
    FocusControl := FActiveControl else
    FocusControl := aForm;
  Windows.SetFocus(FocusControl.Handle);
  if GetFocus = FocusControl.Handle then
    FocusControl.Perform(CM_UIACTIVATE, 0, 0);
end;

procedure HackSetActiveControl(aForm: TForm; Control: TWinControl);
begin
 with THackCustomForm(aForm) do
  if FActiveControl <> Control then
  begin
    if not ((Control = nil) or (Control <> aForm) {and
      (GetParentForm(Control) = Self)} and ((csLoading in ComponentState) or
        Control.CanFocus)) then
      raise EInvalidOperation.Create(SCannotFocus);
    FActiveControl := Control;
    if not (csLoading in ComponentState) then
    begin
      if FActive then HackSetWindowFocus(aForm);
      THackForm(aForm).ActiveChanged;
    end;
  end;
end;

procedure TvcmEntityForm.SetMyFocus;
  {-}
var
 l_Container : IvcmContainer;
 l_Form      : IvcmEntityForm;
 l_VForm     : TForm;
begin
 if f_LockFocusCount > 0 then
  exit;
 if (Parent <> nil) then
  if CanFocus then
   if NeedSetMyFocus then
   begin
    // Если нет ActiveControl попытаемся его вычислить и задать
    // Иначе при смене контекста в главной зоне в ActiveControl
    // контейнеров мог залипать умерший контрол (cq25393)
    if (ActiveControl = nil) then
     HackSetActiveControl(Self, FindNextControl(nil, true, true, false));
    if (ActiveControl <> nil) AND ActiveControl.Visible then
    begin
     l_Container := Container;
     while (l_Container <> nil) AND not l_Container.IsNull do
     begin
      l_Form := l_Container.AsForm;
      l_VForm := (l_Form.VCLWinControl As TForm);
      if not l_VForm.Visible then
       break;
   // Игрища с фокусом. Раньше было
   //   if (l_VForm.ActiveControl = nil) then
   // но при вставке контейнера в контейнер и последующей повторной активации
   // фокус вставал в "никуда".
      if (l_VForm.ActiveControl <> ActiveControl) then
       HackSetActiveControl(l_VForm, ActiveControl);
      Assert(l_VForm Is TvcmEntityForm);
      if not TvcmEntityForm(l_VForm).NeedSetMyFocus then
       break;
      l_Container := l_Form.Container;
     end;//l_Container <> nil
    end;//(ActiveControl <> nil) AND ActiveControl.Visible
   end;//NeedSetMyFocus
   
 if Visible AND Enabled then
  if (IsMainObjectForm OR IsModalForm) then
   if NeedSetMyFocus then
    SetFocus;
end;

procedure TvcmEntityForm.RemoveMyFocus;
  {-}
var
 l_Container : IvcmContainer;
 l_Form      : IvcmEntityForm;
 l_VForm     : TForm;
begin
 if f_LockFocusCount > 0 then
  exit;

 if (Parent <> nil) then
 begin
  l_Container := Container;
  while (l_Container <> nil) AND not l_Container.IsNull do
  begin
   if Supports(l_Container, IvcmEntityForm, l_Form) then
    try
     l_VForm := (l_Form.VCLWinControl As TForm);
     if (l_VForm.ActiveControl <> nil) AND
        ((l_VForm.ActiveControl.Parent = Self) OR
        (l_VForm.ActiveControl.Owner = Self) OR
        ContainsControl(l_VForm.ActiveControl)) then
      l_VForm.ActiveControl := nil;
     l_Container := l_Form.Container;
    finally
     l_Form := nil;
    end//try..finally
   else
    break;
  end;//l_Container <> nil
 end;//Parent <> nil
end;

function TvcmEntityForm.IsModal: Boolean;
  //override;
  {-}
begin
 Result := (ZoneType in [vcm_ztModal, vcm_ztManualModal]);
end;

function TvcmEntityForm.IsContained: Boolean;
  //override;
  {-}
begin
 Result := not (ZoneType in vcm_NotContainedForm);
end;

procedure TvcmEntityForm.CreateParams(var aParams: TCreateParams);
  //override;
  {-}
begin
 inherited;
 if not (csDesigning in ComponentState) then
 begin
  with aParams do
   if IsModal then
   begin
    Style := Style and not(WS_MINIMIZEBOX) or WS_POPUP;
    ExStyle := ExStyle and not(WS_EX_TOOLWINDOW);
    if ((Owner <> nil) and (Owner is TWinControl)) then
     WndParent := (Owner as TWinControl).Handle;
   end//IsModal
   else
   if (ZoneType = vcm_ztFloating) then
   begin
    Style := Style and not(WS_MAXIMIZEBOX or WS_MINIMIZEBOX);
    ExStyle := ExStyle and not(WS_EX_APPWINDOW) or WS_EX_TOOLWINDOW;
    WndParent := HWND(0);
   end//ZoneType = vcm_ztFloating
   else
   if (ZoneType = vcm_ztSimpleFloat) then
   begin
    ExStyle := ExStyle and not (WS_EX_TOOLWINDOW) or WS_EX_APPWINDOW;
    WndParent := Application.Handle;
   end;//ZoneType = vcm_ztSimpleFloat
 end;//not (csDesigning in ComponentState)
end;

procedure TvcmEntityForm.WndProc(var aMessage: TMessage);
  //override;
  {-}
const
 WM_REACTIVATE_FORM = WM_USER+$0900;
var
 I : Integer;
 //
 function IsActivateAppMessage: Boolean;
 begin
  Result := ((aMessage.Msg = WM_ACTIVATEAPP) and TWMActivateApp(aMessage).Active);
 end;
 //
 function IsDeactivateAppMessage: Boolean;
 begin
  Result := ((aMessage.Msg = WM_ACTIVATEAPP) and not(TWMActivateApp(aMessage).Active));
 end;
 //
 function IsReactivateFormMessage: Boolean;
 begin
  Result := ((aMessage.Msg = WM_REACTIVATE_FORM) and (GetActiveWindow <> Handle));
 end;
 //
 function IsMainActivate: Boolean;
 var
  lPlacement: TWindowPlacement;
 begin
  Result := (aMessage.Msg = WM_ACTIVATE) and
            (TWMActivate(aMessage).Active = WA_ACTIVE) and
            (Self is TvcmMainForm);
  if not Result then Exit;
  if HandleAllocated then
  begin
   lPlacement.length := SizeOf(TWindowPlacement);
   GetWindowPlacement(Handle, @lPlacement);
   Result := lPlacement.showCmd <> SW_SHOWMINIMIZED;
  end;
 end;
 //
function IsSetCursorByLeftButtonMessage: Boolean;
 begin
  Result := ((aMessage.Msg = WM_SETCURSOR) and (aMessage.LParamHi = WM_LBUTTONDOWN) and not(IsWindowEnabled(Handle)));
 end;
 //
 function HasFormModalState: Boolean;
 begin
  Result := ((fsModal in FormState) and IsWindowEnabled(Handle) and IsWindowVisible(Handle));
 end;
 //
 function IsMainMinimized : boolean;
 var
  lPlacement: TWindowPlacement;
 begin
  Result := false;
  if (Application.MainForm = nil) then Exit;

  with Application.MainForm do
   if HandleAllocated then
   begin
    lPlacement.length := SizeOf(TWindowPlacement);
    GetWindowPlacement(Handle, @lPlacement);
    if lPlacement.showCmd = SW_SHOWMINIMIZED then
     Result := True;
   end;
 end;

begin
 if not(csDesigning in ComponentState) then
 begin
  if IsActivateAppMessage then
  begin
   if HasFormModalState then
   begin
    aMessage.Result := 0;
    PostMessage(Handle, WM_REACTIVATE_FORM, 0, 0);
    Exit;
   end
   else
    if HasFormFloatingZoneTypeAndVisible then
     if not IsMainMinimized then
      SetWindowPos(Handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or SWP_SHOWWINDOW)
     else
      SetWindowPos(Handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or SWP_HIDEWINDOW);
  end
  else
   if IsDeactivateAppMessage then
   begin
    if HasFormFloatingZoneTypeAndVisible then
     SetWindowPos(Handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or SWP_HIDEWINDOW);
   end
   else
    if IsSetCursorByLeftButtonMessage then
    begin
     with Screen do
      if (ActiveForm <> nil) then
       with ActiveForm do
        if (Handle <> HWND(0)) and IsWindowEnabled(Handle) then
        begin
         PostMessage(Handle, WM_REACTIVATE_FORM, 0, 0);
         aMessage.Result := 0;
         Exit;
        end;
    end
    else
     if IsReactivateFormMessage then
     begin
      aMessage.Result := 0;
      SetWindowPos(Handle, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or SWP_SHOWWINDOW);
      SetActiveWindow(Handle);
      Exit;
     end
     else
      if IsMainActivate then
       with Screen do
       begin
        for I := 0 to Pred(FormCount) do
         if Forms[I] is TvcmEntityForm then
          with TvcmEntityForm(Forms[I]) do
          if (ZoneType = vcm_ztFloating) and Visible then
           SetWindowPos(Handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or SWP_SHOWWINDOW)
       end;
 end;
 //
 inherited;
end;

procedure TvcmEntityForm.DoLoadFromSettings;
  //override;
  {-}
begin
 {$IfDef vcmUseSettings}
 vcmLoadForm(Self);
 {$EndIf vcmUseSettings}
end;

{$IfNDef DesignTimeLibrary}
{$IfDef l3HackedVCL}
function TvcmEntityForm.IsRealInstance: Boolean; {V}
  //override;
  {-}
begin
 Result := (Owner <> nil);
 // - масштабировать надо только если форма создается для показа, а не для информации о сущностях
end;
{$EndIf l3HackedVCL}
{$EndIf DesignTimeLibrary}

procedure TvcmEntityForm.DoSaveInSettings;
  //override;
  {-}
begin
 {$IfDef vcmUseSettings}
 if not VCMClosing and NeedSaveInSettings then
 begin
  vcmSaveForm(Self);
  if ZoneType <> vcm_ztForToolbarsInfo then
   SaveToolbars;
 end;//not VCMClosing
 {$EndIf vcmUseSettings}
end;                 

procedure TvcmEntityForm.CMVisibleChanged(var Message: TMessage);
  //message CM_VISIBLECHANGED;
  {-}
begin
// Игрища с фокусом. Раньше RemoveMyFocus звался после inherited.
//   if (l_VForm.ActiveControl = nil) then
 if not Visible then     
  RemoveMyFocus;
 inherited;
 if Visible then
  SetMyFocus;
end;

procedure TvcmEntityForm.WMHelp(var Message: TWMHelp);
  //message WM_HELP;
  {-}
var
 l_KeyWord: string;
begin
 if not (csDesigning in ComponentState) then
 begin
  l_KeyWord := vcmGetHelpKeyword(Message.HelpInfo, Menu, PopupMenu);
  if l_KeyWord <> '' then
   Application.HelpKeyword(l_Keyword);
 end;//not (csDesigning in ComponentState)
end;

procedure TvcmEntityForm.CNKeyDown(var Message: TWMKeyDown);
  {-}
var
 l_Controller: TOvcController;
 l_Translation: Word;
begin
 l_Controller := GetDefController;
 if l_Controller <> nil then
  with l_Controller.EntryCommands do
  begin
   l_Translation := TranslateUsing(OvcCmd.ovcTextEditorCommands,
                                   TMessage(Message),
                                   GetTickCount,
                                   Il3CommandTarget(Self)
                                   );
   case l_Translation of
    ccShortCut: begin
     Message.CharCode := 0;
     Message.Result := 1;
     exit;
    end;
   end;
  end;
 inherited;
end;

procedure TvcmEntityForm.WMPaint(var Message: TWMPaint);
  //message WM_Paint;
  {-}
var
  PS: TPaintStruct;
begin
 if (csDesigning in ComponentState) then
  inherited
 else if (Dispatcher = nil) or (Dispatcher.FormDispatcher <> nil) or not Dispatcher.FormDispatcher.Locked then
  inherited
 else
 begin
  // - это ОБЯЗАТЕЛЬНО - иначе WM_Paint будет приходить бесконечно
  BeginPaint(Handle, PS);
  EndPaint(Handle, PS);
  Dispatcher.FormDispatcher.AddFormForInvalidate(Self.As_IvcmEntityForm);
 end;//not Dispatcher.FormDispatcher.Locked
end;

procedure TvcmEntityForm.WMNCPaint(var Message: TWMNCPaint);
  //message WM_NCPAINT;
  {-}
begin
 if (csDesigning in ComponentState) then
  inherited
 else if (Dispatcher = nil) or (Dispatcher.FormDispatcher = nil) or not Dispatcher.FormDispatcher.Locked then
  inherited
 else
 begin
  Dispatcher.FormDispatcher.AddFormForInvalidate(Self.As_IvcmEntityForm);
 end;//not Dispatcher.FormDispatcher.Locked
end;

procedure TvcmEntityForm.WMContextMenu(var Message: TWMContextMenu);
var
 l_HitTestResult: LongInt;
begin
 l_HitTestResult := SendMessage(Handle, WM_NCHITTEST, 0, TMessage(Message).LParam);
 if (l_HitTestResult = HTCLIENT) and (WindowFromPoint(Point(Message.XPos, Message.YPos)) = Handle) then
  inherited
 else
  Message.Result := 1;
 // - не даем показывать контекстное меню, если клик пришелся не в клиентскую область
 // http://mdp.garant.ru/pages/viewpage.action?pageId=392173415
end;

procedure TvcmEntityForm.WMSetIcon(var Message: TWMSetIcon);
begin
 if (Message.Icon <> 0) then
  inherited
 else
  Message.Result := SendMessage(Handle, WM_GETICON, 1, 0);
 // - вот так попробуем, если что-то сломается (утечка ресурсов GDI и т.п.) - нужно будет открутить.
 // http://mdp.garant.ru/pages/viewpage.action?pageId=569221018
end;

procedure TvcmEntityForm.CMActivate(var Message: TMessage);
begin
 inherited;
 if HasFormModalState then
  DoOnShowModal;
end;

function TvcmEntityForm.Operation(const anOperationID : TvcmControlID;
                                  aMode               : TvcmOperationMode;
                                  const aParams       : IvcmParams): Boolean;
  //overload;
  //virtual;
  {-}
var
 l_Item : TvcmEntitiesCollectionItem;
begin
 if VCMClosing then
  aParams.DoneStatus := vcm_dsFormInClose
 else
 begin
  l_Item := Entities.GetFirstFormItem;
  if (l_Item <> nil) then
   l_Item.Operation(Self, nil, anOperationID, aMode, aParams);
 end;//VCMClosing
 Result := aParams.Done;
end;

function TvcmEntityForm.Operation(const anOp    : TvcmOPID;
                                  const aParams : IvcmExecuteParams): Boolean;
  //overload;
  { Выполнение операции по имени сущности. }
begin
 Result := Self.Entity.Operation(anOp, aParams);
end;

function TvcmEntityForm.Operation(const anOp    : TvcmOPID;
                                  const aParams : IvcmTestParams): Boolean;
  //overload;
  { Выполнение операции по имени сущности. }
begin
 Result := Self.Entity.Operation(anOp, aParams);
end;

function TvcmEntityForm.Operation(const anOp : TvcmOPID;
                                  aMode      : TvcmOperationMode = vcm_omExecute): Boolean;
  //overload;
  { Выполнение операции по имени сущности. }
begin
 if (aMode = vcm_omTest) then
  Result := Operation(anOp, TvcmTestParams.Make)
 else
  Result := Operation(anOp, vcmParams);
end;

function TvcmEntityForm.GetEntityID: TvcmControlID;
  //virtual;
  {* - возвращает идентификатор сущности формы. }
var
 l_Item : TvcmEntitiesCollectionItem;
begin
 Result := vcm_cidEmpty;
 if (Entities <> nil) then begin
  l_Item := Entities.GetFirstFormItem;
  if (l_Item <> nil) then
   Result := l_Item.EntityID;
 end;//Entities <> nil
end;

function TvcmEntityForm.GetInner(const anEntityID : TvcmControlID): IvcmEntity;
  //virtual;
  {* - возвращает вложенную сущность. Для перекрытия в потомках. }

 function _MakeEntity(aComponent : TComponent;
                      aItem      : TvcmBaseEntitiesCollectionItem) : IvcmEntity;
 var
  lClass : TvcmEntitiesCollectionItemEntity;
 begin
  lClass := TvcmEntitiesCollectionItemEntity.Create(aComponent, aItem);
  try
   Result := lClass;
  finally
   vcmFree(lClass);
  end;
 end;

var
 l_Control : TControl;
 l_Form: TCustomForm;
 l_Item    : TvcmBaseEntitiesCollectionItem;
begin
 Result := nil;

 // Возможно это операция привязанная к TComponent, ее нужно вызывать всегда,
 // т.к. он никогда не будет в фокусе
 if not Assigned(Result) and Assigned(Entities) then
 begin
  // Найдем сущность
  l_Item := TvcmBaseEntitiesCollectionItem(Entities.Entities.FindItemByID(anEntityID));
  // Если в списке есть исключительно TComponent, то сконструируем IvcmEntity
  if Assigned(l_Item) and l_Item.Controls.IsTComponents then
  begin
   // Компонент может быть только один
   Result := _MakeEntity(l_Item.Controls.FirstTComponent, l_Item);
   Exit;
  end;//Assigned(l_Item) and l_Item.Controls.IsTComponents
 end;//not Assigned(Result) and Assigned(Entities)

 try
  (*-----------------------------------------------------------------------------
     Изменения связнны с CQ: 19429.

     Не верно определялся активный компонент формы. Дело в том, что при переводе
     фокуса в компонент формы, свойство ActiveControl меняется не у
     непосредественного родителя-формы компонента, а у формы родителя самого
     верхнего уровня (см. TWinControl.SetFocus), т.е. главной формы.*)

 // А вот бегать прийдется - т.к. ScreenActiveControl может быть совсем в другом месте - навигаторе например.
 // Но поскольку с починкой правильной расстановкой ActiveControl на формах при фокусировке долго и упорно боролись
 // хождения по парентам быть не должно
     l_Form := Self;
     l_Control := Screen.ActiveControl;
     if afw.GetParentForm(l_Control) <> Self then
      l_Control := ActiveControl;

     while (l_Form <> nil) AND (l_Control = nil) do begin
      if (l_Form.ActiveControl <> nil) then
       l_Control := l_Form.ActiveControl
      else
       l_Form := afw.GetAnotherParentForm(l_Form);
     end;

  if (l_Control <> nil) and (csDestroying in l_Control.ComponentState) then
  begin
   Result := nil;
   Exit;
  end;
  // - http://mdp.garant.ru/pages/viewpage.action?pageId=607767761
  
 (* -----------------------------------------------------------------------------*)
    // Чтобы каждый раз не бегать по родителям воспользуемся Screen, а в
    // следующих строках проверим "наш" ли это компонент
 //   l_Control := Screen.ActiveControl;
  (*---------------------------------------------------------------------------*)
  // Активный компонент принадлежит нашей форме
  
  if (l_Control <> nil) AND
   (afw.GetParentForm(l_Control) <> Self) then
   l_Control := nil;
 {
   правка для нормальной работы операций из выпадающего окна тулбара.
   утверждается, что отъехать ничего не должно.
  if (l_Control Is TWinControl) AND
     not TWinControl(l_Control).Focused then
   l_Control := nil;
 }
  if (l_Control = nil) then
   l_Control := FindControl(Windows.GetFocus);
  Result := GetInnerForControl(anEntityID, l_Control);
 except
  Result := nil;
  // http://mdp.garant.ru/pages/viewpage.action?pageId=259169613
  // Открываем флеш №5451001. Тыкаем в ссылку. Огребаем AV.
  Assert(false);
 end;//try..except
 if (Result = nil) AND (Entities <> nil) then
 begin
  l_Item := TvcmBaseEntitiesCollectionItem(Entities.Entities.FindItemByID(anEntityID));
  if Assigned(l_Item) then
   Result := _MakeEntity(nil, l_Item);
 end;//Result = nil
end;

function TvcmEntityForm.GetInnerForControl(const anEntityID : TvcmControlID;
                                           aControl         : TComponent;
                                           aX               : Integer = High(Integer);
                                           aY               : Integer = High(Integer)): IvcmEntity;
  //virtual;
  {* - возвращает вложенную сущность для элемента управления. Для перекрытия в потомках. }
begin
 if (Entities = nil) then
  Result := nil
 else
  Result := Entities.GetEntityForControl(anEntityID, aControl, aX, aY);
 if (Result = nil) AND (aControl <> nil) then begin
  if (aControl Is TControl) then begin
   aControl := TControl(aControl).Parent;
   if (aControl = Self) then
    aControl := nil;
   Result := GetInnerForControl(anEntityID, aControl);
   //aControl
  end else
   Result := GetInnerForControl(anEntityID, nil);
 end;//Result = nil
end;

procedure TvcmEntityForm.Notification(aComponent: TComponent; anOperation: TOperation);
  //override;
  {-}
begin
 inherited;
 Case anOperation of
  opInsert : begin
   if (aComponent Is TvcmCustomEntities) AND (f_Entities = nil) then
   begin
    f_Entities := TvcmCustomEntities(aComponent);
(*    if (Entities <> nil) then
     Entities.LinkControls;*)
   end;//aComponent Is TvcmCustomEntities..
  end;//opInsert
  opRemove : begin
   if (aComponent = f_Entities) then
    f_Entities := nil;
   // В принципе на текущий момент логики работы попадать сюда мы не должны:
   if (aComponent = f_ZoneControl) then
    f_ZoneControl := nil;
  end;//opRemove
 end;//Case anOperation
end;//Notification

// start class TvcmEntityFormImplementation

procedure TvcmEntityFormImplementation.MakeAggregate;
begin
 TvcmEntityForm(Control).MakeAggregate;
end;

procedure TvcmEntityFormImplementation.RegInContainer;
var
 lContainer : IvcmContainer;
begin
 lContainer := TvcmForm(Control).Container;
 if Assigned(lContainer) then
 try
  lContainer.RegForm(Self);
 finally
  lContainer := nil;
 end;//try..finally
end;

procedure TvcmEntityFormImplementation.pm_SetZoneControl(aValue : TControl);
begin
 TvcmEntityForm(Control).ZoneControl := aValue;
end;

function TvcmEntityFormImplementation.pm_GetStyle: IvcmFormStyle;
  {* - стиль VCM формы. }
begin
 Result := TvcmEntityForm(Control).Style;
end;//pm_GetStyle

function TvcmEntityFormImplementation.pm_GetIsMainInFormSet: Boolean;
  {-}
begin
 Result := TvcmEntityForm(Control).pm_GetIsMainInFormSet;
end;

function TvcmEntityFormImplementation.pm_GetFormSet : IvcmFormSet;
  {-}
begin
 Result := TvcmEntityForm(Control).FormSet;
end;

function TvcmEntityFormImplementation.pm_GetDataSource : IvcmFormDataSource;
  {-}
begin
 Result := TvcmEntityForm(Control).DataSource;
end;

procedure TvcmEntityFormImplementation.pm_SetDataSource(const aValue : IvcmFormDataSource);
  {-}
begin
 TvcmEntityForm(Control).DataSource := aValue;
end;

function TvcmEntityFormImplementation.pm_GetZoneControl : TControl;
begin
 Result := TvcmEntityForm(Control).ZoneControl;
end;

procedure TvcmEntityFormImplementation.UnregInContainer;
var
 lContainer : IvcmContainer;
begin
 lContainer := TvcmForm(Control).Container;
 if Assigned(lContainer) then
 try
  lContainer.UnregForm(Self);
 finally
  lContainer := nil;
 end;//try..finally
end;

procedure TvcmEntityFormImplementation.CheckFloatingVisibility;
  {-}
begin
 TvcmEntityForm(Control).CheckFloatingVisibility;
end;

function TvcmEntityFormImplementation.GetTabInfo(out theCaption: Il3CString;
 out theItemIndex: Integer): Boolean;
  {* Информация для закладки, в которую вставляется форма }
begin
 Result := TvcmEntityForm(Control).DoGetTabInfo(theCaption, theItemIndex);
end;

function TvcmEntityFormImplementation.NeedSaveToTabHistory;
begin
 Result := TvcmEntityForm(Control).NeedSaveToTabHistory;
end;

procedure TvcmEntityFormImplementation.BeforeHistoryNavigate;
begin
 TvcmEntityForm(Control).BeforeHistoryNavigate;
end;

function TvcmEntityFormImplementation.Get_AsContainer : IvcmContainer;
  {-}
begin
 Result := nil;
 //Assert(false);
end;

function TvcmEntityFormImplementation.Get_Entity: IvcmEntity;
  {-}
begin
 Result := TvcmEntityForm(Control).Entity;
end;

function TvcmEntityFormImplementation.Get_Aggregate: IvcmAggregate;
  {-}
begin
 Result := TvcmEntityForm(Control).Aggregate;
end;

function TvcmEntityFormImplementation.Get_ZoneType: TvcmZoneType;
  {-}
begin
 Result := TvcmEntityForm(Control).ZoneType;
end;

function TvcmEntityFormImplementation.pm_GetGUID: TGUID;
  {-}
begin
 Result := TvcmEntityForm(Control).GUID;
end;

procedure TvcmEntityFormImplementation.pm_SetGUID(const aValue: TGUID);
  {-}
begin
 TvcmEntityForm(Control).GUID := aValue;
end;

function TvcmEntityFormImplementation.pm_GetSubUserType: TvcmUserType;
  {-}
begin
 Result := TvcmEntityForm(Control).SubUserType;
end;

function TvcmEntityFormImplementation.pm_GetUserType: TvcmUserType;
  {-}
begin
 Result := TvcmEntityForm(Control).UserType;
end;

function TvcmEntityFormImplementation.Get_MainCaption: IvcmCString;
  {-}
begin
 Result := TvcmEntityForm(Control).MainCaption;
end;

function TvcmEntityFormImplementation.Get_FormDef: IvcmEntityFormDef;
  {-}
begin
 Result := TvcmEntityForm(Control).FormDef;
end;

function TvcmEntityFormImplementation.pm_GetCurUseToolbarOfUserType: IvcmUserTypeDef;
  {-}
begin
 //Assert(Form <> nil);
 if (Control = nil) then
  Result := nil
 else
  Result := TvcmEntityForm(Control).CurUseToolbarOfUserType;
end;

function TvcmEntityFormImplementation.pm_GetCurUserTypeDef: IvcmUserTypeDef;
  {-}
begin
 Result := TvcmEntityForm(Control).CurUserTypeDef;
end;

function  TvcmEntityFormImplementation.pm_GetKeyInFormSet: TvcmFormSetFormItemDescr;
begin
 Result := TvcmEntityForm(Control).KeyInFormSet;
end;

function TvcmEntityFormImplementation.pm_GetTabCaption: IvcmCString;
begin
 Result := TvcmEntityForm(Control).TabCaption;
end;

procedure TvcmEntityFormImplementation.pm_SetTabCaption(const aTabCaption: IvcmCString);
begin
 TvcmEntityForm(Control).TabCaption := aTabCaption;
end;

function TvcmEntityFormImplementation.pm_GetNeedAddFormToTasksPanel: Boolean;
begin
 Result := TvcmEntityForm(Control).NeedAddFormToTasksPanel;
end;

function TvcmEntityFormImplementation.SameName(const aName: TvcmFormID): Boolean;
  {-}
begin
 if (Control = nil) then
  Result := false
 else
  Result := TvcmEntityForm(Control).FormID.EQ(aName);
end;

function TvcmEntityFormImplementation.LoadState(const aState : IvcmBase;
                                                aStateType   : TvcmStateType): Boolean;
  {-}
begin
 Result := TvcmEntityForm(Control).LoadState(aState, aStateType);
end;

function TvcmEntityFormImplementation.SaveState(out theState : IvcmBase;
                                                aStateType   : TvcmStateType): Boolean;
  {-}
begin
 {$IfDef InsiderTest}
 try
 {$EndIf InsiderTest}
  if (Control = nil) then
   Result := false
  else
   Result := TvcmEntityForm(Control).SaveState(theState, aStateType);
 {$IfDef InsiderTest}
 except
  on E : Exception do
  begin
   l3System.Exception2Log(E);
   Result := false;
  end;//on E : Exception
 end;//try..except
 {$EndIf InsiderTest}
end;

function TvcmEntityFormImplementation.SaveStateForClone(out theState: IvcmBase;
                                                        aStateType: TvcmStateType): Boolean;
  {-}
begin
 Result := TvcmEntityForm(Control).SaveStateForClone(theState, aStateType);
end;

function TvcmEntityFormImplementation.LoadCloneState(const theState: IvcmBase;
                                                     aStateType: TvcmStateType): Boolean;
  {-}
begin
 Result := TvcmEntityForm(Control).LoadCloneState(theState, aStateType);
end;

function TvcmEntityFormImplementation.IsMainObjectForm: Boolean;
  {-}
begin
 Result := TvcmEntityForm(Control).IsMainObjectForm;
end;

function TvcmEntityFormImplementation.IsModalForm: Boolean;
  {-}
begin
 Result := TvcmEntityForm(Control).IsModalForm;
end;

function TvcmEntityFormImplementation.IsModal: Boolean;
  {-}
begin
 Result := TvcmEntityForm(Control).IsModal;
end;

function TvcmEntityFormImplementation.GetStatus(out theStatus : TvcmStatusStrings): Boolean;
  {-}
begin
 Result := TvcmEntityForm(Control).GetStatus(theStatus);
end;

procedure TvcmEntityFormImplementation.LockFocus;
  { Пока лочит установку фокуса при изменении Visible. Может что-то ещё можно лочить }
begin
 TvcmEntityForm(Control).LockFocus;
end;

procedure TvcmEntityFormImplementation.UnlockFocus;
  { Пока лочит установку фокуса при изменении Visible. Может что-то ещё можно лочить }
begin
 TvcmEntityForm(Control).UnlockFocus;
end;

procedure TvcmEntityFormImplementation.SetActiveAndShowInParent;
  {* - сделать активным в родителе с возможностью определения типа активации. }
begin
 TvcmEntityForm(Control).SetActiveAndShowInParent;
end;

procedure TvcmEntityFormImplementation.SetActiveInParent;
  {* - сделать активным в родителе. Применяется для форм находящихся в PageControl-е. }
begin
 TvcmEntityForm(Control).SetActiveInParent;
end;

procedure TvcmEntityFormImplementation.SetInactiveInParent;
  {* - сделать активным предыдующего в родителе. Применяется для форм находящихся в PageControl-е. }
begin
 TvcmEntityForm(Control).SetInactiveInParent;
end;

procedure TvcmEntityFormImplementation.SetFirstActiveInParent;
  {* - сделать активным первого в родителе. }
begin
 TvcmEntityForm(Control).SetFirstActiveInParent;
end;

function TvcmEntityFormImplementation.IsActiveInParent : Boolean;
  {* - является ли форма активная в родителе. Применяется для форм находящихся в PageControl-е. }
begin
 Result := TvcmEntityForm(Control).IsActiveInParent;
end;

procedure TvcmEntityFormImplementation.CloseInParent;
begin
 TvcmEntityForm(Control).CloseInParent;
end;

function TvcmEntityFormImplementation.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {-}
begin
 if IID.SomeOf([IvcmContainer, IvcmEntity, IvcmEntityFormDef, IvcmUserInteraction]) then
 begin
  if Supports(Control, IID.IID, Obj) then
   Result.SetOk
  else
   Result.SetNoInterface;
 end//IID.SomeOf([IvcmContainer, IvcmEntity, IvcmEntityFormDef, IvcmUserInteraction])
 else
 begin
  Result := inherited COMQueryInterface(IID, Obj);
  if Result.Fail then
  begin
   if Supports(Control, IID.IID, Obj) then
    Result.SetOk
   else
    Result.SetNoInterface;
  end;//Failed(Result)
 end;//IID.SomeOf([IvcmContainer, IvcmEntity, IvcmEntityFormDef, IvcmUserInteraction])
end;

procedure TvcmEntityForm.NotifyContainer;
begin
 (* Если Owner = nil, то это значит, что форма создавалась для вспомогательных
    действий (например чтение операций модуля), т.е. она не вставлялась в
    контейнер *)
 if Assigned(Owner) or
   (* Проверяем ещё и parent, потому, что при удалении формы контейнера она
      уничтожает компонент и прибивает Owner-а *)
   Assigned(Parent) then
  if (f_Form <> nil) then
   (As_IvcmEntityForm).UnregInContainer;
end;

procedure TvcmEntityForm.InitFields;
  {-}
begin
 inherited;
 {$IfDef InsiderTest}
 g_AllowModal := 0;
 {$EndIf InsiderTest}
 {$IfDef vcmUseSettings}
 if Dispatcher <> nil then
  Dispatcher.FormDispatcher.Notify.AddListener(Self);
 if g_ToolbarsCustomize <> nil then
  g_ToolbarsCustomize.Notify.
   AddListener(IvcmToolbarsCustomizeListener(Self));
 {$EndIf vcmUseSettings}
end;

procedure TvcmEntityForm.Cleanup;
begin
 NotifyFormSetFormIsClosed;
 TvcmSlayedEntityFormsList.Instance.Remove(Self);
 {$IfDef vcmUseSettings}
 if Dispatcher <> nil then
  Dispatcher.FormDispatcher.Notify.RemoveListener(Self);
 if g_ToolbarsCustomize <> nil then
  g_ToolbarsCustomize.Notify.
   RemoveListener(IvcmToolbarsCustomizeListener(Self));
 {$EndIf vcmUseSettings}
 FreeAndNil(f_Style);
 Aggregate := nil;
 DataSource := nil;
 vcmFree(f_DockList);
 NotifyContainer;
 vcmFree(f_EntitiesList);
 KillFromVCM;
 f_EntityForm := nil;
 f_Entity := nil;
 f_FormDef := nil;
 FreeAndNil(f_UserTypes);
 inherited;
end;//Cleanup

procedure TvcmEntityForm.UpdateStatusInfo;
begin
 Dispatcher.UpdateStatus;
end;

function TvcmEntityForm.NeedSaveInSettings: Boolean;
begin
 Result := True;
end;

procedure TvcmEntityForm.CheckFloatingVisibility;
  {-}
begin
 // - ничего не делаем
end;

function TvcmEntityForm.DoGetTabInfo(out theCaption: Il3CString;
 out theItemIndex: Integer): Boolean;
  {* Информация о закладке, в которую вставляется форма. Для перекрытия в потомках }
begin
 Result := false;
end;

procedure TvcmEntityForm.NotifyUserTypeSet;
begin
end;

procedure TvcmEntityForm.SetupFormLayout;
begin
end;

procedure TvcmEntityForm.AddDock(aDock : TControl);
{* - область стыковки toolbar-ов добавляется при создании, для
     вычисления клиентской области занимаемой toolbar-ами. }
begin
 f_DockList.Add(aDock);
end;//AddDock

function TvcmEntityForm.GetUserVisibleOperationsCount(aUserType: TvcmUserType): Integer;
var
 l_Operations: TvcmBaseOperationsCollection;
 l_EnIndex,
 l_OpIndex: Integer;
 l_Op: TvcmBaseOperationsCollectionItem;
begin
 Result := 0;
 for l_EnIndex := 0 to Entities.Entities.Count - 1 do
 begin
  l_Operations := TvcmBaseEntitiesCollectionItem(Entities.Entities.Items[l_EnIndex]).Operations;
  for l_OpIndex := 0 to l_Operations.Count - 1 do
  begin
   l_Op := TvcmBaseOperationsCollectionItem(l_Operations.Items[l_OpIndex]);
   if not (aUserType in l_Op.ExcludeUserTypes) and
      l_Op.VisibleToUser then
    inc(Result);
  end;//for l_OpIndex := 0 
 end;//for l_EnIndex := 0 
end;//GetUserVisibleOperationsCount

procedure TvcmEntityForm.DefaultQueryClose(Sender: TObject);
  {-}
begin
 CloseInParent;
end;

function TvcmEntityForm.CheckUserTypeRange: Boolean;
  {-}
begin
 Result := (f_UserType >= 0) and (f_UserType < UserTypes.Count);
end;

function TvcmEntityForm.GetCanClose: TvcmCanClose;
  {-}
begin
 Result := vcm_ccNone;
 if CheckUserTypeRange then
  Result := TvcmBaseUserTypesCollectionItem(UserTypes.Items[f_UserType]).CanClose;
end;

procedure TvcmEntityForm.SetCanClose(const Value: TvcmCanClose);
  {-}
begin
 if CheckUserTypeRange then
  TvcmBaseUserTypesCollectionItem(UserTypes.Items[f_UserType]).CanClose := Value;
end;

function TvcmEntityForm.MakeUserTypeDef(aValue: TvcmBaseUserTypesCollectionItem): IvcmUserTypeDef;
  {-}
begin
 if aValue = nil then
  Result := nil
 else
  with aValue do
   Result := TvcmUserTypeDef.Make(Name,
                                  vcmCStr(TrimRight(Caption)),
                                  Index,
                                  Self.ClassType,
                                  AllowCustomizeToolbars,
                                  SettingsCaption,
                                  Index <> UseToolbarOfUserType.Index);
end;//MakeUserTypeDef

procedure TvcmEntityForm.NotifyFormSetFormIsClosed;
  {* - Форма закрывается - нужно изменить флажок на сборке. }
begin
 if (FormSet <> nil) then
  FormSet.SetFormClosed(As_IvcmEntityForm);
end;

function TvcmEntityForm.pm_GetCurUserTypeDef: IvcmUserTypeDef;
  {-}
begin
 Result := MakeUserTypeDef(CurUserType);
end;

function TvcmEntityForm.pm_GetCurUseToolbarOfUserType: IvcmUserTypeDef;
  {* - тип формы для чтения настроек. }
begin
 if CurUserType <> nil then
  Result := MakeUserTypeDef(CurUserType.UseToolbarOfUserType)
 else
  Result := nil;
end;//pm_GetCurUseToolbarOfUserType

function TvcmEntityForm.pm_GetCurUserType: TvcmBaseUserTypesCollectionItem;
  {-}
begin
 Assert(UserTypes <> nil);
 if (UserTypes = nil) then
  Result := nil
 else
 if (UserType < UserTypes.Count) then
  Result := UserTypes[UserType]
 else
  Result := nil; 
end;//pm_GetCurUserType

function TvcmEntityForm.pm_GetQueryMaximized: TNotifyEvent;
  {-}
begin
 Result := GetQueryEvent(qtMaximized);
end;

function TvcmEntityForm.GetQueryOpen: TNotifyEvent;
  {-}
begin
 Result := GetQueryEvent(qtOpen);
end;

{$IfDef vcmUseSettings}
procedure TvcmEntityForm.SaveToolbars;
  {-}
Var
 l_Index      : integer;
 l_Toolbar    : TvcmToolbarDef;
 l_UserType   : TvcmBaseUserTypesCollectionItem;

 procedure SaveToolbar(aUTName    : string;
                       aToolbar   : TvcmToolbarDef);
 Var
  l_ToolbarPos : TvcmToolbarPositions;

 begin
  if aToolbar.DockedTo <> nil then
  begin
   if aToolbar.Owner is TvcmEntityForm then
   begin
    l_ToolbarPos.rFloatX := l_Toolbar.FloatingPosition.X;
    l_ToolbarPos.rFloatY := l_Toolbar.FloatingPosition.Y;
    l_ToolbarPos.rPos := aToolbar.DockPos;
    l_ToolbarPos.rRow := aToolbar.DockRow;
    l_ToolbarPos.rFloating := false;
    l_ToolbarPos.rFloatingWidth := aToolbar.FloatingWidth;
    l_ToolbarPos.rDock := Cardinal(l_Toolbar.DockedTo.Position);
    vcmSaveToolbarPos(aUTName, aToolbar.Name, l_ToolbarPos);
   end;
  end
  else
  begin
   l_ToolbarPos.rFloatX := l_Toolbar.FloatingPosition.X;
   l_ToolbarPos.rFloatY := l_Toolbar.FloatingPosition.Y;
   l_ToolbarPos.rPos := aToolbar.DockPos;
   l_ToolbarPos.rRow := aToolbar.DockRow;
   l_ToolbarPos.rFloating := true;
   if aToolbar.LastDock <> nil then
    l_ToolbarPos.rDock := Cardinal(aToolbar.LastDock.Position)
   else
    l_ToolbarPos.rDock := 0;
   l_ToolbarPos.rFloatingWidth := l_Toolbar.FloatingWidth;
   vcmSaveToolbarPos(aUTName, aToolbar.Name, l_ToolbarPos);
  end;
 end;

begin
 if UserTypes.Count > 0 then
 begin
  for l_Index := 0 to ComponentCount-1 do
  begin
   if Components[l_Index] is TvcmToolbarDef then
   begin
    l_Toolbar := Components[l_Index] as TvcmToolbarDef;
    if UserTypes.Count > 0 then
    begin
     l_UserType := UserTypes[UserType];
     SaveToolbar(l_UserType.Name, l_Toolbar);
    end
   end;
  end;
 end;

{
 Открутил пока сохранение главного тулбара
 if g_MenuManager.MergedToMainForm(Self) then
 begin
  // Сохраняем главный тулбар
  l_MainForm := (_NativeMainForm as XXIvcmEntityForm).VclForm;
  if not (Self is TvcmMainForm) then
   for l_Index := 0 to l_MainForm.ComponentCount - 1 do
   begin
    if l_MainForm.Components[l_Index] is TvcmToolbarDef then
    begin
     l_Toolbar := l_MainForm.Components[l_Index] as TvcmToolbarDef;
     if UserTypes.Count > 0 then
     begin
      l_UserType := UserTypes[UserType];
      SaveToolbar(l_UserType.Name, l_UserType.Caption, l_Toolbar);
      if (l_MainForm is TvcmMainForm) and ((l_MainForm as TvcmMainForm).UserTypes.Count > 0) then
      begin
       l_UserType := (l_MainForm as TvcmMainForm).UserTypes[(l_MainForm as TvcmMainForm).UserType];
       SaveToolbar(l_UserType.Name, l_UserType.Caption, l_Toolbar); 
      end;
     end;
    end;
   end;
 end;
}
end;
{$EndIf vcmUseSettings}

(*type
 EvcmTryEnterModalState = class(Exception)
 end;//EvcmTryEnterModalState*)

function TvcmEntityForm.ShowModal: Integer;
Var
 l_Index: integer;
 l_Form: IvcmEntityForm;
 l_List: Tl3VCLFormPtrList;
begin
 Result := mrCancel;
 {$IfDef InsiderTest}
 Assert(g_AllowModal >= 0);
 if Tl3BatchService.Instance.IsBatchMode then
  if (g_AllowModal <= 0) then
   if (Application.MainForm <> nil) then
    if not Tl3BatchService.Instance.HasModalWorker then
     raise EafwTryEnterModalState.Create('Здесь надо обрабатывать модальность формы: ' + ClassName);
 {$EndIf InsiderTest}
 try
  if (g_MenuManager <> nil) then
   g_MenuManager.BackupOpStatus;
  try
   if (g_Dispatcher <> nil) and (g_Dispatcher.FormDispatcher <> nil) then
    g_Dispatcher.FormDispatcher.BackupLockStatus;
   try
    l_List := Tl3VCLFormPtrList.Make;
    try
     // гасим все Floating формы
     if (vcmDispatcher <> nil) then
      with vcmDispatcher do
       for l_Index := 0 to EntitiesCount - 1 do
        if Supports(Entity[l_Index], IvcmEntityForm, l_Form) then
         if l_Form.VCLWinControl.Visible then
          if (l_Form.ZoneType = vcm_ztFloating) then
          begin
           l_Form.VCLWinControl.Hide;
           l_List.Add(l_Form.VCLWinControl As TCustomForm);
          end;//l_Form.ZoneType = vcm_ztFloating
     try
      Result := inherited ShowModal;
     except
      PostMessage(Handle, CM_RELEASE, 0, 0);
      // http://mdp.garant.ru/pages/viewpage.action?pageId=485885765
      raise;
     end;//try..except
     for l_Index := 0 to l_List.Count - 1 do
      l_List[l_Index].Show;
    finally
     FreeAndNil(l_List);
    end;//try..finally
   finally
    if (g_Dispatcher <> nil) and (g_Dispatcher.FormDispatcher <> nil) then
     g_Dispatcher.FormDispatcher.RestoreLockStatus;
   end;//try..finally
  finally
   if (g_MenuManager <> nil) then
    g_MenuManager.RestoreOpStatus;
  end;//try..finally
 finally
  if (g_Dispatcher <> nil) then
  begin
   // - нужно "вручную" обновить строку состояния, т.к. форме может не прийти
   //   CM_ACTIVATE(<K> - 107840079).
   g_Dispatcher.UpdateStatus;
  end;//g_Dispatcher <> nil
 end;//try..finally
end;

function TvcmEntityForm.SendMessageToPage(const aParent : TWinControl;
                                          const aMsg    : Cardinal;
                                          const WParam  : Integer;
                                          const LParam  : Integer): Boolean;
  {* - посылает рекурсивно пока не получит ответ или не закончатся родители. }
var
 lParent : TWinControl;
 lResult : Integer;
begin
 Result := False;
 lParent := aParent;
 while Assigned(lParent) do
 begin
  lResult := lParent.Perform(aMsg, WParam, LParam);
  // Сообщение не было обработано
  if (LongRec(lResult).Lo = 0) then
   lParent := lParent.Parent
  // Сообщение обработано
  else
  begin
   Result := LongRec(lResult).Hi = 1;
   Break;
  end;//LongRec(lResult).Lo = 0
 end;//Assigned(lParent)
end;

{$IfDef vcmNeedElPack}
const
 {$Include ElPgCtlConsts.inc}
{$EndIf vcmNeedElPack}

function TvcmEntityForm.IsActiveInParent: Boolean;
begin
 Result := False;
 {$IfDef vcmNeedElPack}
 if Assigned(Parent) then
  Result := SendMessageToPage(Parent, PM_ISACTIVECONTROL, Integer(Self), 0);
 {$EndIf vcmNeedElPack}
end;

procedure TvcmEntityForm.SetActiveInParent;
begin
 {$IfDef vcmNeedElPack}
 if Assigned(Parent) then
  SendMessageToPage(Parent, PM_SETACTIVEPAGEWITHCONTROL, Integer(Self), 0);
 {$EndIf vcmNeedElPack} 
end;

procedure TvcmEntityForm.SetFirstActiveInParent;
  {* - сделать активным первого в родителе. }
begin
 {$IfDef vcmNeedElPack}
 if Assigned(Parent) then
  SendMessageToPage(Parent, PM_SETFIRSTACTIVE, 0, 0);
 {$EndIf vcmNeedElPack}
end;

procedure TvcmEntityForm.SetInactiveInParent;
begin
 {$IfDef vcmNeedElPack}
 if Assigned(Parent) then
  SendMessageToPage(Parent, PM_ACTIVEPREVPAGE, Integer(Self), 0);
 {$EndIf vcmNeedElPack} 
end;

procedure TvcmEntityForm.SetActiveAndShowInParent;
begin
 {$IfDef vcmNeedElPack}
 if Assigned(Parent) then
  SendMessageToPage(Parent, PM_ACTIVATEANDSHOW, Integer(Self), 0);
 {$EndIf vcmNeedElPack} 
end;

function TvcmEntityForm.CommonDocksSize(aHeight : Boolean) : Integer;
var
 l_Index : Integer;
 l_Dock  : IvcmDock;
begin
 Result := 0;
 for l_Index := 0 to Pred(f_DockList.Count) do
  if Supports(f_DockList[l_Index], IvcmDock, l_Dock) then
  try
   // Вычисляем по высоте
   if aHeight then
    case l_Dock.Pos of
     vcm_tbpBottom, vcm_tbpTop:
      Inc(Result, l_Dock.FullHeight);
    end
   // Вычисляем по ширине
   else
    case l_Dock.Pos of
     vcm_tbpLeft, vcm_tbpRight:
      Inc(Result, l_Dock.FullHeight);
    end;
  finally
   l_Dock := nil;
  end;
end;

function TvcmEntityForm.pm_GetFormSet: IvcmFormSet;
  {-}
begin
 vcmInFormSet(f_DataSource, @Result);
end;

function TvcmEntityForm.pm_GetDataSource : IvcmFormDataSource;
  {-}
begin
 Result := f_DataSource;
end;

procedure TvcmEntityForm.InitStyle;
  {* - определить стиль формы. }

  {$IfNDef DesignTimeLibrary}
  procedure lp_ClearNullContainers;

   procedure lp_Clear(const aStyle: TvcmToolbarStyle);
   begin
    with aStyle do
     if (MergeWithContainer = vcm_bTrue) and (Container = nil) then
      MergeWithContainer := vcm_bNone;
   end;//lp_Clear

  begin
   with f_Style.Toolbars do
   begin
    lp_Clear(Left);
    lp_Clear(Top);
    lp_Clear(Right);
    lp_Clear(Bottom);
   end;//with f_Style do
  end;//lp_ClearNullContainers

  procedure lp_DefineContainers;
  var
   l_Container: IvcmEntityForm;

   procedure lp_Define(const aStyle: TvcmToolbarStyle);
   begin
    if aStyle.MergeWithContainer = vcm_bTrue then
     aStyle.Container := l_Container;
   end;//lp_Define

  begin
   if Supports(Container, IvcmEntityForm, l_Container) then
   try
    with f_Style.Toolbars do
    begin
     lp_Define(Left);
     lp_Define(Top);
     lp_Define(Right);
     lp_Define(Bottom);
    end;//with f_Style do
   finally
    l_Container := nil;
   end;{try..finally}
  end;//lp_DefineAll
  {$EndIf DesignTimeLibrary}

begin
 {$IfNDef DesignTimeLibrary}
 if not Container.IsNull and not (ZoneType = vcm_ztForToolbarsInfo) and
  not (ZoneType in vcm_NotContainedForm) then
 begin
  lp_DefineContainers;
  Container.FormStyle(Self.As_IvcmEntityForm, Style);
  lp_ClearNullContainers;
 end//if not Container.IsNull then
 else
  Style.Toolbars.ForbidMerge;
 {$EndIf DesignTimeLibrary}
end;//InitStyle

procedure TvcmEntityForm.UserTypeWeightChanged(aSender: TObject);
  {-}
var
 l_Tab: IafwWeightListener;
begin
 if not (csLoading in ComponentState) and
  (CurUserType = TvcmBaseUserTypesCollectionItem(aSender)) and
  Supports(Parent, IafwWeightListener, l_Tab) then
 try
  Assert(false, 'Вес UserType не должен меняться в Run-Time');
  l_Tab.WeightChanged;
 finally
  l_Tab := nil;
 end;{try..finally}
end;//UserTypeWeightChanged

function TvcmEntityForm.InHistoryStep: Boolean;
  {-}
var
 l_Main : IvcmMainForm;
begin
 Result := false;
 if not (ZoneType in [vcm_ztModal, vcm_ztManualModal, vcm_ztSimpleFloat]) then
  Result := TvcmHistoryService.Instance.IsInBF(As_IvcmEntityForm);
end;

procedure TvcmEntityForm.pm_SetDataSource(const aValue : IvcmFormDataSource);
  {-}

 procedure DoDataSourceChanged(const anOld : IvcmFormDataSource;
                               const aNew  : IvcmFormDataSource);

  procedure SubscribeToFS(const aDataSource: IvcmFormDataSource);
  var
   l_FormSet: IvcmFormSet;
  begin
   if Assigned(Entity) then
   begin
    if vcmInFormSet(aDataSource, @l_FormSet) then
    try
     // Поменяем агрегацию:
     Aggregate := l_FormSet;
    finally
     l_FormSet := nil;
    end;{try..finally}
   end;//if Assigned(Entity) then
  end;//SubscribeToFS

 var
  l_Listener : IvcmDatasourceChangeListener;
 begin
  // Подпишем форму:
  SubscribeToFS(aNew);
  SignalDataSourceChanged(anOld, aNew);
  // - обновляем ссылки на контроллеры ViewArea и производные от них 
  if (aValue = nil) OR
     ((anOld = nil) or not anOld.IsSame(aValue)) then
  begin
   // Сообщим пользователю формы:
   if (anOld <> nil) OR (aNew <> nil) then
    NotifyDataSourceChanged(anOld, aNew);
   if Assigned(f_OnChangedDataSource) then
    f_OnChangedDataSource(Self, anOld, aNew, InHistoryStep);
   // Уведомим контейнер:
   Container.ChildDataSourceChanged(Self.As_IvcmEntityForm, anOld, aNew);
  end;//..((anOld = nil) or not anOld.IsSame(aValue))..
  if (aNew <> nil) then
   if (Parent <> nil) then
    if Supports(Parent.Owner, IvcmDatasourceChangeListener, l_Listener) then
     try
      l_Listener.DataSourceChanged(Self);
     finally
      l_Listener := nil;
     end;//try..finally
 end;//DoDataSourceChanged

var
 l_Temp: IvcmFormDataSource;
begin
 if (f_DataSource <> aValue) then
 begin
  l_Temp := f_DataSource;
  try
   f_DataSource := aValue;
   DoDataSourceChanged(l_Temp, aValue);
  finally
   l_Temp := nil;
  end;//try..finally
 end;//f_DataSource <> aValue
end;

function TvcmEntityForm.pm_GetDocksHeight : Integer;
begin
 Result := CommonDocksSize(True);
end;

procedure TvcmEntityForm.pm_SetZoneControl(const aValue : TControl);
begin
 if Assigned(f_ZoneControl) then
  f_ZoneControl.RemoveFreeNotification(Self);
 f_ZoneControl := aValue;
 if Assigned(f_ZoneControl) then
  f_ZoneControl.FreeNotification(Self);
 InitStyle;
 if (f_ZoneControl <> nil) then
  FormInsertedIntoContainer;
end;//pm_SetZoneControl

function TvcmEntityForm.pm_GetIsStoredStyle: Boolean;
  {-}
begin
 Result := not Style.IsDefault;
end;//pm_GetIsStoredStyle

(*procedure TvcmEntityForm.pm_SetStyle(const aValue: TvcmFormStyle);
begin
 f_Style.Assign(aValue);
end;//pm_SetStyle*)

function TvcmEntityForm.GetQueryEvent(aQueryType : TvcmQueryType) : TNotifyEvent;
begin
 Result := nil;
 if CheckUserTypeRange then
  Result := TvcmBaseUserTypesCollectionItem(UserTypes.Items[f_UserType]).
   GetQueryEvent(aQueryType);
end;//GetQueryEvent

function TvcmEntityForm.pm_GetIsMainInFormSet: Boolean;
  {-}
begin
 Result := False;
 if Assigned(DataSource) then
  Result := DataSource.IsMainInFormSet(Self.As_IvcmEntityForm);
end;

function TvcmEntityForm.pm_GetKeyInFormSet: TvcmFormSetFormItemDescr;
begin
 Result := TvcmFormSetFormItemDescr_C(FormID, ZoneType, UserType,
  SubUserType)
end;

function TvcmEntityForm.pm_GetUseCaseIconIndex: Integer;
begin
 Result := 0;
end;

function TvcmEntityForm.pm_GetTabCaption: IvcmCString;
var
 l_TabCaption: IvcmCString;
begin
 l_TabCaption := DoGetTabCaption;

 if (l3IsNil(l_TabCaption)) then
  l_TabCaption := f_TabCaption;

 Result := l_TabCaption;
end;

procedure TvcmEntityForm.pm_SetTabCaption(const aTabCaption: IvcmCString);
begin
 f_TabCaption := aTabCaption;
end;

function TvcmEntityForm.pm_GetNeedAddFormToTasksPanel: Boolean;
begin
 Result := DoGetNeedAddFormToTasksPanel;
end;

procedure TvcmEntityForm.LockFocus;
begin
 inc(f_LockFocusCount);
end;

procedure TvcmEntityForm.UnlockFocus;
begin
 dec(f_LockFocusCount);
end;

procedure TvcmEntityForm.Lock;
  //virtual;
  {-}
begin
 Dispatcher.FormDispatcher.Lock;
end;

procedure TvcmEntityForm.Unlock;
  //virtual;
  {-}
begin
 Dispatcher.FormDispatcher.Unlock;
end;

function TvcmEntityForm.ProcessCommand(Cmd    : Tl3OperationCode;
                                       aForce : Boolean;
                                       aCount : Integer): Boolean;
begin
 Result := False;
end;

function TvcmEntityForm.HasFormFloatingZoneTypeAndVisible: Boolean;
begin
 Result := (ZoneType = vcm_ztFloating) and Visible;
end;

{$IfNDef DesignTimeLibrary}
{$IfDef l3HackedVCL}
function TvcmEntityForm.NeedCancelModal: Boolean;
begin
 {$IfDef InsiderTest}
 if Tl3BatchService.Instance.IsBatchMode then
 begin
  try
   if (g_AllowModal <= 0) AND Tl3BatchService.Instance.ExecuteCurrentModalWorker then
   begin
    if (ModalResult = 0) then
    begin
     Result := true;
     Exit;
    end;//ModalResult = 0
   end//seExecuteCurrentModalWorker
   else
   begin
    Result := true;
    if (g_AllowModal <= 0) then
     Exit;
   end;//seExecuteCurrentModalWorker
  except
(*   on E : Exception do
   begin
    Result := true;
    l3System.Exception2Log(E);
   end;//on E : Exception*)
   // - чтобы форма по-любому закрылась
   raise;
   // - догадка - не прошла
  end;//try..except
 end;//g_BatchMode
 {$EndIf InsiderTest}
 //Result := inherited NeedCancelModal;
 if (Dispatcher <> nil) then
  Result := Dispatcher.InCancelModal
 else
  Result := False;
end;
{$EndIf l3HackedVCL}
{$EndIf DesignTimeLibrary}

function TvcmEntityForm.DefineDockContainer(const aPos: TvcmEffectiveToolBarPos): TvcmEntityForm;
  {* - используя стиль формы определяем контейнер для панели
       инструментов. }
var
 l_Style: TvcmToolbarStyle;
begin
 Result := Self;
 if zonetype <> vcm_ztForToolbarsInfo then
 begin
  l_Style := nil;
  with Style.Toolbars do
  begin
   case aPos of
    vcm_tbpLeft:
     l_Style := Left;
    vcm_tbpTop:
     l_Style := Top;
    vcm_tbpRight:
     l_Style := Right;
    vcm_tbpBottom:
     l_Style := Bottom;
   end;//case aPos of
  end;//with aForm.Style.Toolbars do
  if (l_Style <> nil) then
   with l_Style do
    if (MergeWithContainer = vcm_bTrue) then
     Result := (Container.VCLWinControl As TvcmEntityForm);
 end;//zonetype <> vcm_ztForToolbarsInfo
end;//DefineDockContainer

function TvcmEntityForm.CallCloseQuery(aCaller: TCustomForm): Boolean;
begin
 Result := (ZoneType = vcm_ztForToolbarsInfo) or inherited CallCloseQuery(aCaller);
end;//CallCloseQuery

(*function TvcmEntityForm.GetLocalizationInfo(
  const aComponent: TComponent): String;
begin
 Result := '';
 if Assigned(f_OnGetLocalizationInfo) then
  f_OnGetLocalizationInfo(aComponent, Result);
end;*)

procedure TvcmEntityForm.SetPositionByDS;
  {-}
begin
end;

function TvcmEntityForm.NeedDrawCaption: Boolean;
begin
 Result := true;
end;

function TvcmEntityForm.SettingsSuffix: AnsiString;
begin
 Result := '';
end;

function TvcmEntityForm.As_IvcmEntityForm: IvcmEntityForm;
  {-}
begin
 if (f_EntityForm = nil) then
 begin
  if (f_Form = nil) then
   f_EntityForm := Self As IvcmEntityForm
  else
   f_EntityForm := f_Form As IvcmEntityForm;
 end;//f_EntityForm = nil
 Result := f_EntityForm;
end;

procedure TvcmEntityForm.SetActiveControl;
  //virtual;
  {-}
begin
end;

procedure TvcmEntityForm.Paint;
  //override;
  {-}
begin
 if (csDesigning in ComponentState) then
  inherited
 else
 if (Dispatcher = nil) or
    (Dispatcher.FormDispatcher = nil) or
    not Dispatcher.FormDispatcher.Locked then
  inherited
 else
  Dispatcher.FormDispatcher.AddFormForInvalidate(Self.As_IvcmEntityForm);
end;

function TvcmEntityForm.IsFloatingState: Boolean;
var
 l_P : TafwCustomForm;
begin
 Result := false;
 l_P := afw.GetAnotherParentForm(Self);
 if (l_P <> nil) AND (TForm(l_P).FormStyle = fsStayOnTop) then
  Result := true;
end;//TvcmEntityForm.IsFloatingState

function TvcmEntityForm.IsFloatingStateAndParentNotVisible: Boolean;
var
 l_P : TafwCustomForm;
begin
 Result := false;
 l_P := afw.GetAnotherParentForm(Self);
 if (l_P <> nil) AND (TForm(l_P).FormStyle = fsStayOnTop) then
  Result := not l_P.Visible;
end;

procedure TvcmEntityForm.MakeFloatingParentVisible;
var
 l_P : TafwCustomForm;
begin
 l_P := afw.GetAnotherParentForm(Self);
 if (l_P <> nil) AND (TForm(l_P).FormStyle = fsStayOnTop) then
  l_P.Visible := true;
end;

procedure TvcmEntityForm.SetTargetGetter(const anEntity : TvcmString;
                                         anEvent : TvcmGetTargetEvent);
  {-}
begin
 Entities.SetTargetGetter(anEntity, anEvent);
end;

procedure TvcmEntityForm.MakeEntitySupportedByControl(const anEntity : TvcmString;
                                 aControl : TComponent);
  {-}
begin
 Entities.MakeSupportedByControl(anEntity, aControl);
end;

(*procedure TvcmEntityForm.SetLocalizationInfo(const aComponent: TComponent;
  const anInfo: String);
begin
 if (anInfo<>'') and Assigned(f_OnSetLocalizationInfo) then
  f_OnSetLocalizationInfo(aComponent, anInfo);
end;*)

procedure TvcmEntityForm.CloseInParent;
var
 l_Event: TNotifyEvent;
begin
 l_Event := nil;
 if (f_UserType >= 0) and (f_UserType < UserTypes.Count) then
  l_Event := TvcmBaseUserTypesCollectionItem(UserTypes.Items[f_UserType]).
   OnQueryClose;
 if not Assigned(l_Event) then
  Self.SafeClose
 else
  l_Event(Self);
end;

function TvcmEntityForm.SafeClose: Boolean;
  {-}

var
 l_Main : TCustomForm;

 procedure CleanTB(aForm: TComponent);
 var
  l_Index     : Integer;
  l_Component : TComponent;
  l_RH: IvcmResourceHolder;
 begin//CleanTB
  if (aForm Is TvcmEntityForm) then
  begin
   TvcmEntityForm(aForm).f_VCMClosing := true;
   TvcmEntityForm(aForm).Hide;
   TvcmEntityForm(aForm).ReleaseResources;
  end;//aForm Is TvcmEntityForm

  l_Index := 0;
  with aForm do
   while (l_Index < ComponentCount) do
   begin
    l_Component := Components[l_Index];

    if Supports(l_Component, IvcmResourceHolder, l_RH) then
     l_RH.ReleaseResources;

    if (l_Component Is TvcmToolbarDef) then
    begin
     if g_Dispatcher.InOp then
     begin
      if (l_Main = nil) OR not l_Main.HandleAllocated then
       FreeAndNil(l_Component)
      else
      begin
       TvcmToolbarDef(l_Component).Hide;
       RemoveComponent(l_Component);
       TvcmToolbarDef(l_Component).Parent := nil;
       PostMessage(l_Main.Handle, vcm_msgFreeComponent, 0, LParam(l_Component));
      end;//l_Main = nil
     end//g_Dispatcher.InOp
     else
      FreeAndNil(l_Component);
     continue;
    end
    else
    //if (Components[l_Index] Is TCustomForm) then
     CleanTB(Components[l_Index]);
    Inc(l_Index);
   end;//l_Index < ComponentCount
 end;//CleanTB

 procedure lp_ClearActiveControl;
 var
  l_Ctrl: TWinControl;
 begin
  l_Ctrl := Self;
  while (l_Ctrl.Parent <> nil) do
  begin
   if (l_Ctrl is TForm) then
    if (TForm(l_Ctrl).ActiveControl <> nil) and
       (GetParentForm(TForm(l_Ctrl).ActiveControl) = Self) then
     TForm(l_Ctrl).ActiveControl := nil;
   l_Ctrl := l_Ctrl.Parent;
  end;
 end;

var
 l_Close : Boolean;
begin
 if IsModal then
 begin
  if (ModalResult = 0) then
   ModalResult := mrCancel;
  Result := true;
 end//IsModal
 else
 begin
  lp_ClearActiveControl;
  {$IfDef InsiderTest}
  try
  {$EndIf InsiderTest}
   // http://mdp.garant.ru/pages/viewpage.action?pageId=505415962 
   if (ZoneType <> vcm_ztForToolbarsInfo) then
    l_Close := CloseQuery
   else
    l_Close := True;
  {$IfDef InsiderTest}
  except
   on E : Exception do
   begin
    l3System.Exception2Log(E);
    l_Close := true;
   end;//on E : Exception
  end;//try..except
  {$EndIf InsiderTest}
  if l_Close then
  begin
   BeforeClosing;
   f_VCMClosing := true;
   Result := false;
   if (FormStyle <> fsMDIChild) then
   // - MDI-формы прятаться не умеют :-(
    Hide;
   l_Main := Application.MainForm;
   if NeedTerminateApp then
    Application.Terminate
   else
   begin
    if HandleAllocated then
    begin
     CleanTB(Self);
(*     if (g_Dispatcher <> nil) AND g_Dispatcher.InOp then
      g_Dispatcher.FormDispatcher._AddToCloseQueue(Self.As_IvcmEntityForm)
     else*)
     PostMessage(Handle, vcm_msgCloseForm, 0, LParam(Self));
    end//HandleAllocated
    else
    begin
     if (l_Main = nil) OR not l_Main.HandleAllocated then
     begin
      KillMe;
      Result := true;
     end//l_Main = nil
     else
     begin
      CleanTB(Self);
      //Assert(false, 'Такая ситуация исключена');
      // - оказавыется, что не исключена - если ДВА главных окна было и одно закрывают

      // Если владелец убивается, то нечего пытаться самоубиться..
      if (Owner <> nil) and (not (csDestroying in Owner.ComponentState)) then
      begin
       // http://mdp.garant.ru/pages/viewpage.action?pageId=425036429
       TvcmSlayedEntityFormsList.Instance.Add(Self);
       PostMessage(l_Main.Handle, vcm_msgCloseChildForm, 0, LParam(Self));
      end;
     end;//l_Main = nil
    end;//HandleAllocated
   end;//l_Main = Self
  end//CloseQuery
  else
   Result := false;
 end;//IsModal
end;

function TvcmEntityForm.AddUsertype(const aName : String;
                                     const aCaption : Tl3StringIDEx;
                                     const aSettingsCaption : Tl3StringIDEx;
                                     aVisibleToUser : Boolean;
                                     anImageIndex : Integer;
                                     aWeight : Integer;
                                     const aUseToolbarOfUserTypeName : String;
                                     aOnQueryMaximized : TNotifyEvent;
                                     aOnQueryOpen : TNotifyEvent;
                                     aOnQueryClose : TNotifyEvent;
                                     aCanClose : TvcmCanClose): TvcmUserTypesCollectionItem;
  {-}
var
 l_Item : TvcmUserTypesCollectionItem;
begin
 l_Item := TvcmUserTypesCollectionItem(UserTypes.FindItemByName(aName));
 if (l_Item = nil) then
 begin
  l_Item := TvcmUserTypesCollectionItem(UserTypes.Add);
  l_Item.Name := aName;
 end;//l_Item = nil
 l_Item.Caption := aCaption.AsStr;
 l_Item.SettingsCaption := aSettingsCaption.AsStr;
 l_Item.AllowCustomizeToolbars := aVisibleToUser;
 l_Item.ImageIndex := anImageIndex;
 l_Item.Weight := aWeight;
 l_Item.UseToolbarOfUserTypeName := aUseToolbarOfUserTypeName;
 l_Item.OnQueryMaximized := aOnQueryMaximized;
 l_Item.OnQueryOpen := aOnQueryOpen;
 l_Item.OnQueryClose := aOnQueryClose;
 l_Item.CanClose := aCanClose;
 Result := l_Item;
end;

procedure TvcmEntityForm.AddUserTypeExclude(const aName : String;
                                             const anEn  : String;
                                             const anOp  : String;
                                             aNoPrefix   : Boolean);
  {-}
var
 l_Item : TvcmUserTypesCollectionItem;
 l_En   : TvcmBaseEntitiesCollectionItem;
 l_Op   : TvcmOperationsCollectionItem;
begin
 l_Item := TvcmUserTypesCollectionItem(UserTypes.FindItemByName(aName));
 Assert(l_Item <> nil);
 l_En := TvcmBaseEntitiesCollectionItem(Entities.Entities.FindItemByName('en' + anEn));
 Assert(l_En <> nil);
 if aNoPrefix then
  l_Op := TvcmOperationsCollectionItem(l_En.Operations.FindItemByName(anOp))
 else
  l_Op := TvcmOperationsCollectionItem(l_En.Operations.FindItemByName('op' + anOp));
 Assert(l_Op <> nil);
 l_Op.ExcludeUserTypes := l_Op.ExcludeUserTypes + [l_Item.Index];
end;

procedure TvcmEntityForm.CleanDependencies;
// Все это - чтобы выполнить какие-то действия с формой в самом начале процедуры
// ее закрытия.
// http://mdp.garant.ru/pages/viewpage.action?pageId=429695931
 procedure lp_CleanControlDependencies(aControl: TControl);
 var
  l_Index: Integer;
  l_WinControl: TWinControl;
 begin
  if (aControl is TWinControl) then
  begin
   l_WinControl := TWinControl(aControl);
   for l_Index := 0 to l_WinControl.ControlCount - 1 do
    if (l_WinControl.Controls[l_Index] is TvcmEntityForm) then
     TvcmEntityForm(l_WinControl.Controls[l_Index]).CleanDependencies
    else
     lp_CleanControlDependencies(l_WinControl.Controls[l_Index]);
  end;
 end;

begin
 lp_CleanControlDependencies(Self);
end;

procedure TvcmEntityForm.CreateWnd;
var
 l_ParentClassName: String;
begin
  inherited;
  if (ZoneType = vcm_ztForToolbarsInfo) then
  begin
   if Parent <> nil then
    l_ParentClassName := Parent.ClassName;
   l3System.Msg2Log('%s %s %s %d', [Self.ClassName, Self.Name, l_ParentClassName, Ord(UserType)]);
  end;
end;
{$IfEnd}

end.

