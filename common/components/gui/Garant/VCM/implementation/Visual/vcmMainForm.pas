unit vcmMainForm;
{ Базовый класс для главной формы приложения построенного на
  библиотеке VCM.                                            }

{ Библиотека "vcm"    }
{ Автор: Люлин А.В. ©     }
{ Модуль: vcm -           }
{ Начат: 24.02.2003 13:50 }
{ $Id: vcmMainForm.pas,v 1.504 2016/08/04 11:33:17 morozov Exp $ }

// $Log: vcmMainForm.pas,v $
// Revision 1.504  2016/08/04 11:33:17  morozov
// {RequestLink: 624700597}
//
// Revision 1.503  2016/07/13 16:36:28  lulin
// - перегенерация.
//
// Revision 1.502  2015/09/29 11:55:49  kostitsin
// пишем исключение в лог
//
// Revision 1.501  2015/09/17 09:07:13  kostitsin
// {requestlink: 605157327 }
//
// Revision 1.500  2015/09/17 08:26:33  kostitsin
// {requestlink: 605157327 }
//
// Revision 1.499  2015/09/17 07:56:01  kostitsin
// {requestlink: 605157327 }
//
// Revision 1.498  2015/09/16 13:21:39  kostitsin
// {requestlink: 605157327 }
//
// Revision 1.497  2015/09/16 11:28:15  kostitsin
// {requestlink: 605157327 }
//
// Revision 1.496  2015/08/26 12:05:48  morozov
// {RequestLink: 606119805}
//
// Revision 1.495  2015/08/13 12:31:39  morozov
// {RequestLink: 605134793}
//
// Revision 1.494  2015/06/24 11:11:00  kostitsin
// {requestlink: 602478904 }
//
// Revision 1.493  2015/03/31 16:51:38  lulin
// - перетряхиваем зависимости.
//
// Revision 1.492  2015/03/16 15:04:40  lulin
// - делаем стереотипы Service и ServiceImplementation.
//
// Revision 1.491  2015/03/12 10:12:56  lulin
// - перетряхиваем слова.
//
// Revision 1.490  2015/01/13 14:56:08  kostitsin
// {requestlink: 586186354 }
//
// Revision 1.489  2014/11/11 07:45:01  morozov
// Не собиралось (убрал у vcmModule знание про вкладки)
//
// Revision 1.488  2014/11/06 11:49:53  morozov
// {RequestLink: 570120466}
//
// Revision 1.487  2014/10/03 11:07:11  morozov
// {RequestLink: 565861782}
//
// Revision 1.486  2014/09/26 06:22:25  morozov
// {RequestLink: 565491670}
//
// Revision 1.485  2014/09/17 06:01:23  morozov
// Не собиралось
//
// Revision 1.484  2014/09/16 08:50:01  kostitsin
// {requestlink: 562611367 }
//
// Revision 1.483  2014/09/05 06:59:46  morozov
// {RequestLink: 564737453}
//
// Revision 1.482  2014/09/02 16:30:04  kostitsin
// {requestlink: 548185834 }
//
// Revision 1.481  2014/07/25 10:17:06  morozov
// {RequestLink: 340174500}
//
// Revision 1.480  2014/07/17 11:50:45  morozov
// {RequestLink: 340174500}
//
// Revision 1.479  2014/07/16 06:34:18  morozov
// {RequestLink: 554580393}
//
// Revision 1.478  2014/07/14 06:26:47  morozov
// {RequestLink: 554580393}
//
// Revision 1.477  2014/07/09 08:55:53  morozov
// {RequestLink: 340174500}
//
// Revision 1.476  2014/07/02 15:06:48  lulin
// - собираем библиотеки.
//
// Revision 1.475  2014/06/26 10:02:26  morozov
// {RequestLink: 340174500}
//
// Revision 1.474  2014/06/24 05:15:26  morozov
// {RequestLink: 340174500}
//
// Revision 1.473  2014/05/29 09:58:40  morozov
// {RequestLink: 518765917}
//
// Revision 1.472  2014/05/28 11:44:47  morozov
// {RequestLink: 518765917}
//
// Revision 1.471  2014/05/26 08:17:03  morozov
// {RequestLink: 518765917}
//
// Revision 1.470  2014/05/26 07:32:59  morozov
// {RequestLink: 518765917}
//
// Revision 1.469  2014/05/23 09:37:09  morozov
// {RequestLink: 518765917}
//
// Revision 1.468  2014/03/19 14:49:16  lulin
// - bug fix: правим за Мишей.
//
// Revision 1.467  2013/11/11 15:21:15  lulin
// - вычищаем устаревший код.
//
// Revision 1.466  2013/08/26 14:46:23  morozov
// Локализуемые строки в сообщении о максимальном количестве открытых окон
//
// Revision 1.465  2013/08/26 14:11:52  lulin
// - пытаемся собрать тестовое приложение.
//
// Revision 1.464  2013/07/10 09:09:50  morozov
// {RequestLink: 414849606}
//
// Revision 1.463  2013/07/05 14:34:54  lulin
// - переименовал свойство про возможность редактирования тулбара и немного переделал правки Виктора касательно редактирования тулбаров во внутренней версии.
//
// Revision 1.462  2013/06/03 10:14:05  lulin
// - портируем под XE4.
//
// Revision 1.461  2013/05/15 16:39:11  lulin
// - боремся за стабильность тестов.
//
// Revision 1.460  2013/04/25 14:22:38  lulin
// - портируем.
//
// Revision 1.459  2013/04/05 12:02:41  lulin
// - портируем.
//
// Revision 1.458  2013/02/18 16:14:11  lulin
// - улучшаем диагностику.
//
// Revision 1.457  2013/02/07 15:40:18  kostitsin
// [$428281545]
//
// Revision 1.456  2013/02/05 15:22:50  lulin
// {RequestLink:427756489}.
//
// Revision 1.455  2013/01/31 13:13:35  kostitsin
// [$425036429]
//
// Revision 1.454  2013/01/22 15:52:17  kostitsin
// [$424399029]
//
// Revision 1.453  2012/12/05 14:49:36  lulin
// {RequestLink:371649474}
//
// Revision 1.452  2012/11/12 10:25:10  fireton
// - не собирался AllArchiComponents7
//
// Revision 1.451  2012/10/25 18:40:28  lulin
// {RequestLink:406489593}
//
// Revision 1.450  2012/10/18 17:09:02  lulin
// {RequestLink:404363289}. Убираем Assert.
//
// Revision 1.449  2012/10/18 16:51:11  lulin
// {RequestLink:404363289}
//
// Revision 1.448  2012/10/01 10:27:50  kostitsin
// [$397290965]
//
// Revision 1.447  2012/09/28 17:47:04  lulin
// {RequestLink:371649542}
//
// Revision 1.446  2012/08/06 17:26:07  lulin
// {RequestLink:380046115}
//
// Revision 1.445  2012/08/06 17:04:04  lulin
// {RequestLink:380046115}
//
// Revision 1.444  2012/07/12 12:57:20  lulin
// {RequestLink:237994598}
//
// Revision 1.443  2012/07/12 10:21:23  lulin
// {RequestLink:237994598}
//
// Revision 1.442  2012/07/11 16:02:00  lulin
// {RequestLink:237994598}
//
// Revision 1.441  2012/07/10 18:58:51  lulin
// {RequestLink:237994598}
//
// Revision 1.440  2012/06/08 16:41:58  kostitsin
// [$370385808]
//
// Revision 1.439  2012/05/31 19:13:01  lulin
// {RequestLink:269058296}
//
// Revision 1.438  2012/05/28 12:29:55  lulin
// {RequestLink:356848399}
//
// Revision 1.437  2012/05/17 12:29:09  kostitsin
// добавляем в _shell.mo.en объекты vg_scene
//
// Revision 1.436  2012/04/28 10:38:54  lulin
// {RequestLink:361404275}
//
// Revision 1.435  2012/04/13 18:23:24  lulin
// {RequestLink:237994598}
//
// Revision 1.434  2012/04/13 14:38:46  lulin
// {RequestLink:237994598}
//
// Revision 1.433  2012/04/13 11:51:49  lulin
// {RequestLink:237994598}
//
// Revision 1.432  2012/04/13 08:59:36  lulin
// {RequestLink:237994598}
//
// Revision 1.431  2012/04/09 08:39:13  lulin
// {RequestLink:237994598}
// - думаем о VGScene.
//
// Revision 1.430  2012/04/09 06:14:07  lulin
// {RequestLink:237994598}
//
// Revision 1.429  2012/04/04 08:57:04  lulin
// {RequestLink:237994598}
//
// Revision 1.428  2012/03/30 12:50:36  lulin
// {RequestLink:352452629}
//
// Revision 1.427  2012/03/30 12:11:46  lulin
// {RequestLink:352452629}
//
// Revision 1.426  2012/03/29 16:46:04  lulin
// {RequestLink:352452629}
//
// Revision 1.425  2012/03/23 13:03:46  lulin
// - отпиливаем настройки.
//
// Revision 1.424  2012/03/22 14:57:38  lulin
// - заготовочка.
//
// Revision 1.423  2012/03/22 11:43:53  lulin
// - заготовочка.
//
// Revision 1.422  2012/02/01 16:20:29  lulin
// {RequestLink:332566005}
//
// Revision 1.421  2012/01/25 16:43:05  lulin
// {RequestLink:326773370}
//
// Revision 1.420  2012/01/25 12:11:24  lulin
// - сделал выливку и картинок 24х24. Для Стаса.
//
// Revision 1.419  2012/01/24 18:28:07  lulin
// [$330142701]
//
// Revision 1.418  2012/01/24 16:30:51  lulin
// {RequestLink:330139744}
// - вставляем диагностику на предмет того, что формы не могут иметь одинаковые идентификаторы.
// - избавляемся от нетипизированных списков.
//
// Revision 1.417  2011/11/16 05:48:43  dinishev
// Bug fix: не компилировался Арчи.
//
// Revision 1.416  2011/11/15 11:04:07  lulin
// - выливаем все возможные списки картинок.
//
// Revision 1.415  2011/08/11 09:27:50  vkuprovich
// {RequestLink:276531833}
// Подчищаем ненужный код
//
// Revision 1.414  2011/08/03 17:09:55  vkuprovich
// {RequestLink:276531833}
// - fix : Окантовка главного меню
//
// Revision 1.413  2011/08/01 14:51:36  lulin
// {RequestLink:274825697}.
//
// Revision 1.412  2011/07/20 12:35:32  vkuprovich
// {RequestLink:271758721}
//
// Revision 1.411  2011/07/04 16:41:53  vkuprovich
// {RequestLink:269082891}
// Переносим вызов SetMainMenuBackgroundColor на сторону TvcmMainForm
//
// Revision 1.410  2011/06/28 15:17:47  vkuprovich
// {RequestLink:269082891}
// Устанавливаем фон меню
//
// Revision 1.409  2011/06/23 17:01:35  lulin
// {RequestLink:254944102}.
//
// Revision 1.408  2011/06/08 12:12:32  lulin
// - разбираемся с упавшими тестами.
//
// Revision 1.407  2011/05/19 17:05:16  lulin
// {RequestLink:266418093}.
//
// Revision 1.406  2011/05/18 17:45:41  lulin
// {RequestLink:266409354}.
//
// Revision 1.405  2011/03/29 15:50:38  lulin
// - обрабатываем операции основной формы и на баллоне тоже.
//
// Revision 1.404  2011/03/28 17:20:29  lulin
// {RequestLink:257393788}.
//
// Revision 1.403  2011/03/16 13:26:17  lulin
// - вычищаем мусорок.
//
// Revision 1.402  2010/09/21 09:47:17  oman
// - fix: {RequestLink:235049691}
//
// Revision 1.401  2010/09/15 15:11:10  lulin
// {RequestLink:235047275}.
//
// Revision 1.400  2010/09/13 14:49:49  lulin
// {RequestLink:235047275}.
//
// Revision 1.399  2010/09/13 09:51:13  lulin
// {RequestLink:197496539}.
// - №2.
//
// Revision 1.398  2010/05/04 11:15:05  oman
// - fix: {RequestLink:208700924}
//
// Revision 1.397  2010/04/30 15:15:48  lulin
// {RequestLink:207389954}.
// - чистка комментариев.
//
// Revision 1.396  2010/02/19 14:43:06  lulin
// - вычищаем неиспользуемое.
//
// Revision 1.395  2010/02/19 14:27:21  lulin
// - вычищаем неиспользуемое.
//
// Revision 1.394  2010/02/19 14:04:51  lulin
// {RequestLink:191730544}.
//
// Revision 1.393  2010/01/14 13:04:49  lulin
// {RequestLink:177963744}.
//
// Revision 1.392  2009/12/23 16:13:03  lulin
// - делаем тест загрузкии скроллирования ГК.
//
// Revision 1.391  2009/11/13 08:38:34  oman
// Не собиралась библиотека
//
// Revision 1.390  2009/11/12 18:08:13  lulin
// - убираем ненужные возвращаемые значения.
//
// Revision 1.389  2009/11/12 15:59:59  lulin
// - вычищаем ненужные версии методов.
//
// Revision 1.388  2009/11/12 15:31:39  lulin
// {RequestLink:171540596}.
//
// Revision 1.387  2009/10/20 13:05:34  oman
// - fix: {RequestLink:167346473}
//
// Revision 1.386  2009/10/16 16:04:27  lulin
// {RequestLink:167348174}.
//
// Revision 1.385  2009/10/16 11:20:03  lulin
// - вычищаем очередного коня в вакууме.
//
// Revision 1.384  2009/10/15 17:22:48  lulin
// {RequestLink:166856141}. Попытки ещё что-нибудь полечить.
//
// Revision 1.383  2009/10/15 14:42:36  lulin
// {RequestLink:166856141}.
//
// Revision 1.382  2009/10/14 18:39:54  lulin
// {RequestLink:166855347}.
//
// Revision 1.381  2009/10/14 13:24:16  lulin
// - чистка кода.
//
// Revision 1.380  2009/10/13 15:55:32  lulin
// - чистка кода.
//
// Revision 1.379  2009/10/05 07:05:12  lulin
// {RequestLink:159360578}. №50.
//
// Revision 1.378  2009/10/02 16:48:36  lulin
// - избавляемся от неоправданного вызова операции с параметрами.
//
// Revision 1.377  2009/10/01 15:59:32  lulin
// {RequestLink:159360578}. №47.
//
// Revision 1.376  2009/10/01 14:58:33  lulin
// - убираем сферического коня в вакууме.
//
// Revision 1.375  2009/09/30 15:23:02  lulin
// - убираем ненужное приведение ко вполне понятным интерфейсам.
//
// Revision 1.374  2009/09/28 18:50:38  lulin
// - убираем лишние ручки для вызова операций.
//
// Revision 1.373  2009/09/28 17:12:50  lulin
// {RequestLink:159360578}. №31.
//
// Revision 1.372  2009/09/25 12:09:16  lulin
// - выкидываем ненужное.
//
// Revision 1.371  2009/09/22 10:47:48  oman
// - fix: {RequestLink:164070694}
//
// Revision 1.370  2009/09/22 08:38:41  lulin
// - защищаемся от падения в нотификации, для удобства отладки.
//
// Revision 1.369  2009/09/17 15:51:36  lulin
// - регистрация модулей и сборок с главной формы перенесена на приложение.
//
// Revision 1.368  2009/09/14 17:23:40  lulin
// - чистка кода.
//
// Revision 1.367  2009/09/02 11:48:55  lulin
// {RequestLink:159360578}. №20.
//
// Revision 1.366  2009/09/01 09:02:14  lulin
// - bug fix: не собиралась бибилиотека.
//
// Revision 1.365  2009/08/11 14:24:05  lulin
// {RequestLink:129240934}. №16.
//
// Revision 1.364  2009/08/06 16:08:18  lulin
// {RequestLink:159352843}.
//
// Revision 1.363  2009/08/05 14:49:52  lulin
// - избегаем бесконечного цикла, когда ни одна из форм не обрабатывает операций.
//
// Revision 1.362  2009/08/04 16:53:02  lulin
// - наконец-то дошли до вызова сравнения редакций, которое падает.
//
// Revision 1.361  2009/07/29 06:56:40  oman
// - new: {RequestLink:158336069}
//
// Revision 1.360  2009/06/15 12:08:43  lulin
// [$146376785].
//
// Revision 1.359  2009/05/26 10:30:03  oman
// - new: Рисуем пока без клавиатуры - [$148018532]
//
// Revision 1.358  2009/02/20 17:57:43  lulin
// - <K>: 136941122. Чистка кода.
//
// Revision 1.357  2009/02/20 17:29:21  lulin
// - чистка комментариев.
//
// Revision 1.356  2009/02/20 15:19:08  lulin
// - <K>: 136941122.
//
// Revision 1.355  2009/02/20 10:56:51  lulin
// - избавляемся от завязок на модуль, которые всё равно никто не использует.
//
// Revision 1.354  2009/02/19 18:13:52  lulin
// - <K>: 136941122. Прячем фасеты друг в друга.
//
// Revision 1.353  2009/02/19 14:03:33  lulin
// - <K>: 136941122. Выделяем интерфейсы писателей.
//
// Revision 1.352  2009/02/17 08:14:14  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.351  2009/02/16 12:59:43  lulin
// - <K>: 135604584.
//
// Revision 1.350  2009/02/12 18:42:08  lulin
// - <K>: 135604584. Выделен модуль с интерфейсами диспетчера форм.
//
// Revision 1.349  2009/02/12 17:09:18  lulin
// - <K>: 135604584. Выделен модуль с внутренними константами.
//
// Revision 1.348  2009/02/12 12:26:42  lulin
// - <K>: 135604584. Выделен новый интерфейсный модуль.
//
// Revision 1.347  2009/01/13 06:51:49  oman
// - fix: Экспериментальная залечка (К-133891591)
//
// Revision 1.346  2009/01/12 15:08:01  oman
// - fix: Экспериментальная залечка (К-133891591)
//
// Revision 1.345  2009/01/12 15:00:02  oman
// - test: Эксперимент (К-133891591)
//
// Revision 1.344  2008/12/12 19:19:25  lulin
// - <K>: 129762414.
//
// Revision 1.343  2008/12/03 08:25:58  oman
// - new: Более структурно пишем информацию (К-104431648)
//
// Revision 1.342  2008/12/02 14:55:50  oman
// - new: Более структурно пишем информацию (К-104431648)
//
// Revision 1.341  2008/12/02 13:07:40  oman
// - new: Более структурно пишем информацию (К-104431648)
//
// Revision 1.340  2008/12/01 15:05:10  oman
// - new: Экспортируем недостающую информацию (К-104431648)
//
// Revision 1.339  2008/10/22 08:46:58  oman
// - fix: На время LockActionUpdate запрещаем обновлять еще и Status  (К-121158511)
//
// Revision 1.338  2008/09/17 09:05:00  oman
// - fix: Не инициализировали значением по умолчанию
//
// Revision 1.337  2008/09/09 07:32:27  oman
// - fix: Некорректно сбрасывали максимизацию (К-113508785)
//
// Revision 1.336  2008/07/15 12:46:07  lulin
// - <K>: 100958755.
//
// Revision 1.335  2008/07/14 17:43:52  lulin
// - <K>: 100958755.
//
// Revision 1.334  2008/07/11 12:04:02  lulin
// -<K>: 101417264.
//
// Revision 1.333  2008/06/25 09:24:06  mmorozov
// - new: Оптимизация панелей инструментов ---|> в списке доступных форм показываем только объединенные панели инструментов + рефакторинг + список форм проекта при редактировании доступных для выбора операций (CQ: OIT5-28281);
//
// Revision 1.332  2008/06/17 07:25:15  mmorozov
// - не собиралась библиотека.
//
// Revision 1.331  2008/06/10 13:25:36  lulin
// - отдаём управление сплешу.
//
// Revision 1.330  2008/06/04 10:51:15  mmorozov
// - new: возможность найстройки доступных для редактирования панели инструментов операций (CQ: OIT5-28281);
//
// Revision 1.329  2008/04/02 05:46:37  oman
// - fix: Сглатываем шортакты до показа первой главной формы (cq28762)
//
// Revision 1.328  2008/03/24 15:46:15  lulin
// http://mdp.garant.ru/pages/viewpage.action?pageId=87591840&focusedCommentId=87592645#comment-87592645
//
// Revision 1.327  2008/03/20 09:48:21  lulin
// - cleanup.
//
// Revision 1.326  2008/03/19 14:23:47  lulin
// - cleanup.
//
// Revision 1.325  2008/02/28 13:14:08  oman
// - fix: Могли обновлять заголок не своего главного окна (cq28494)
//
// Revision 1.324  2008/02/21 19:47:42  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.323  2008/02/21 10:53:36  lulin
// - <CQ>: 28434.
//
// Revision 1.322  2008/02/19 11:05:51  lulin
// - восстановил всякие экзотические поиски в списках объектов.
//
// Revision 1.321  2008/02/07 19:13:05  lulin
// - избавляемся от излишне универсальных методов базовых списков.
//
// Revision 1.320  2008/01/31 18:53:36  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.319  2007/12/19 09:06:15  oman
// - fix: Если операция есть на форме и она запрещена, не пускаем ее
// в родителя (cq27931)
//
// Revision 1.318  2007/12/12 12:25:55  mmorozov
// - отказывамся от подписки, управляет перевставкой форм и перечиткой панелей инструментов оболочка (в рамках CQ: OIT5-27823);
//
// Revision 1.317  2007/12/11 13:39:26  mmorozov
// - продолжаем переходить на уведомления о системных событиях (в рамках CQ: OIT5-27823);
//
// Revision 1.316  2007/12/10 12:44:53  mmorozov
// - new: реализуем шаблон publisher\subscriber при редактировании настроек, замены настроек (переключения конфигураций), настройке панелей инструментов (в рамках CQ: OIT5-27823);
//
// Revision 1.315  2007/10/31 07:22:28  oman
// - fix: Если сущность модальная, не транслируем операции в
//  родительскую зону главного окна (cq27249)
//
// Revision 1.314  2007/10/01 13:45:59  lulin
// - для форм сборок выливаем зоны.
//
// Revision 1.313  2007/09/30 09:14:44  lulin
// - сделана выливка состава сборок.
//
// Revision 1.312  2007/09/30 08:20:16  lulin
// - регистрируем фабрики перед выливкой ресурсов.
//
// Revision 1.311  2007/09/19 15:40:08  mmorozov
// - bugfix: окно не становилось на место предыдущего закрытого (CQ: OIT5- 26671), подробно см. в K<49513268>;
//
// Revision 1.310  2007/09/17 12:04:54  mmorozov
// - new: в интерфейс слушаетеля разблокировки добавлено событие, для контроля ситуации когда переходные процессы уже закончились, но отрисовка визуалки ещё запрещена, используется в панели задач чтобы раньше времени не отрисовывались полосы прокрутки (в рамках CQ: OIT5-26623);
//
// Revision 1.309  2007/09/17 10:42:51  mmorozov
// New:
// - выделен интерфейс для получения уведомления о блокировке\разблокировки диспетчера форм на время выполенения операций модуля любым желающим (раньше только IvcmForm);
// - панель задач должна работать побыстрее, посколько перечитываем операции после добавления последней формы прецедента, а не каждой как это было раньше;
// - избавились от анимации в панели задач, при навигации между прецедентами;
// - почищен код;
//
// В рамках задачи CQ: OIT5-26623;
//
// Revision 1.308  2007/09/14 14:03:39  oman
// - new: Перетранслируем OnTest и для модальных форм (cq24729)
//
// Revision 1.307  2007/08/30 12:06:42  mmorozov
// - format code;
//
// Revision 1.306  2007/08/10 14:03:02  lulin
// - сделал выливку картинок в разные директории.
//
// Revision 1.305  2007/08/10 12:11:58  lulin
// - для Интранета выливаем png-иконки.
//
// Revision 1.304  2007/08/08 13:26:04  lulin
// - были недоступны пункты меню (<K>-34505100).
//
// Revision 1.303  2007/07/27 11:57:30  oman
// - new: В механизм локализации включаем фабрики сборок (cq25775)
//
// Revision 1.302  2007/07/27 10:11:13  oman
// - new: Локализуем свойство "EmptyHint" (cq25825)
//
// Revision 1.301  2007/07/26 12:24:31  oman
// - fix: Заточки для локализации vtHeader - новые обработчики
// _OnGetLocalizationInfo (cq24480)
//
// Revision 1.300  2007/07/10 12:40:12  lulin
// - теперь если у формы в фокусе нет операции, то транслируем операцию форме в Parent-зоне (CQ-25867, <K>-29392957).
//
// Revision 1.299  2007/06/18 13:38:46  mmorozov
// - new behaviour: при открытии нового прецедента сначала удаляем формы из панели задач потом регистрируем новые, алгоритм по которому выполнены измнения см. в К<18219426>;
//
// Revision 1.298  2007/05/17 11:54:46  oman
// cleanup
//
// Revision 1.297  2007/05/10 14:45:23  oman
// - new: На FormDispatcher добавлена возможность подписаться на
//  нотификацию о последнем Unlock (cq25145)
//
// Revision 1.296  2007/05/04 07:45:14  oman
// - fix: Интерфейсы для базового поиска перенесены в проект (cq25145)
//
// Revision 1.295  2007/04/28 12:02:48  oman
// - new: Интерфейсы для поддержки базовогопоиска (cq25145)
//
// Revision 1.294  2007/04/23 06:35:12  oman
// - fix: Выгружаем в ресурсы Tl3Strings.
//
// Revision 1.293  2007/04/10 13:29:11  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.292  2007/04/10 13:20:11  lulin
// - используем строки с кодировкой.
//
// Revision 1.291  2007/04/04 07:24:38  lulin
// - bug fix: на ХП-темах не обновлялся заголовок окна (CQ OIT5-24880).
//
// Revision 1.290  2007/03/20 07:50:40  lulin
// - теперь у формы заголовок поддерживает различные кодировки (отрисовка пока не изменена).
//
// Revision 1.289  2007/03/16 14:17:04  lulin
// - bug fix: падали при форматировании строки.
//
// Revision 1.288  2007/03/16 13:56:56  lulin
// - переходим на собственную функцию форматирования строк.
//
// Revision 1.287  2007/03/14 06:53:29  mmorozov
// - new: у каждой главной формы свой компонент панели задач;
//
// Revision 1.286  2007/03/12 12:52:29  lulin
// - cleanup.
//
// Revision 1.285  2007/03/12 12:36:20  lulin
// - cleanup.
//
// Revision 1.284  2007/03/06 13:35:54  mmorozov
// - new: панель задач;
//
// Revision 1.283  2007/02/26 12:59:50  oman
// - fix: Не выливали Message._CustomButtonCaption (cq24518)
//
// Revision 1.282  2007/02/13 08:35:20  lulin
// - метод переименован в соответствии с его функциональность.
//
// Revision 1.281  2007/01/26 13:52:56  lulin
// - убрал с параметров выполнения нефоксированные элементы + поправил обращение к неправильному параметру.
//
// Revision 1.280  2007/01/20 17:35:47  lulin
// - разрешаем вызывать операции только по заранее известным идентификаторам.
//
// Revision 1.279  2007/01/20 15:31:10  lulin
// - разделяем параметры операции для выполнения и для тестирования.
//
// Revision 1.278  2007/01/19 11:53:22  lulin
// - данные переехали с общих параметров на более специализированные.
//
// Revision 1.277  2007/01/18 13:13:46  lulin
// - разводим в стороны параметры для теста и для выполнения.
//
// Revision 1.276  2007/01/18 12:09:23  lulin
// - разводим в стороны параметры для теста и для выполнения.
//
// Revision 1.275  2007/01/18 09:06:53  lulin
// - с общих параметров убраны тестовые опции.
//
// Revision 1.274  2007/01/17 14:02:47  lulin
// - вычищены последние нефиксированные параметры в тестах операций.
//
// Revision 1.273  2006/12/27 14:44:57  mmorozov
// - change: механизм объединения панелей инструментов (CQ: OIT5-23903);
//
// Revision 1.272  2006/12/15 12:57:31  mmorozov
// - new behaviour: Встраивание панелей навигатора под основной тулбар (CQ: OIT5-21250). Положение главного тулбара определяется директивой vcmUseMainToolbarPanel;
//
// Revision 1.271  2006/12/10 18:59:01  lulin
// - класс формы переименован в соответствии с библиотекой.
//
// Revision 1.270  2006/12/10 18:32:23  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.269  2006/11/17 14:23:11  oman
// Merge from B_NEMESIS_6_4
//
// Revision 1.268  2006/11/16 14:30:47  mmorozov
// MERGE WITH B_NEMESIS_6_4 (new: обновление заголовка окна при переключении базы (CQ: OIT5-23663));
//
// Revision 1.267  2006/11/03 11:00:34  lulin
// - объединил с веткой 6.4.
//
// Revision 1.266.2.10.2.2  2006/11/17 14:18:11  oman
// - fix: AV на закрытии приложения, если в зоне навигатора лежит
//  форма из сборки и главная форма в собрке лежит в _ParentZone
//  (cq23655)
//
// Revision 1.266.2.10.2.1  2006/11/16 13:54:23  mmorozov
// - new: обновление заголовка окна при переключении базы (CQ: OIT5-23663);
//
// Revision 1.266.2.10  2006/10/31 14:55:21  lulin
// - bug fix: не хватало пробела.
//
// Revision 1.266.2.9  2006/10/25 09:51:35  oman
// - fix: Не выливали/заливали хинты у контролов (cq23207)
//
// Revision 1.266.2.8  2006/10/23 07:50:41  lulin
// - bug fix: были ошибки в константах.
//
// Revision 1.266.2.7  2006/10/23 07:29:03  lulin
// - выливаем для контролов свойства Text и ItemsText.
//
// Revision 1.266.2.6  2006/10/19 08:07:26  lulin
// - некорректно выливали формы уже имеющие существующую копию (например - сплеш).
//
// Revision 1.266.2.5  2006/10/18 08:36:30  lulin
// - выливаем подсказки для сообщений.
//
// Revision 1.266.2.4  2006/10/18 08:11:34  lulin
// - выливаем сообщения для настроек.
//
// Revision 1.266.2.3  2006/10/18 08:00:34  lulin
// - заголовок для настроек приобрел общее название.
//
// Revision 1.266.2.2  2006/10/17 12:47:40  lulin
// - bug fix: не выливались длинные имена пользовательских типов.
//
// Revision 1.266.2.1  2006/10/17 11:07:33  lulin
// - bug fix: выливались не все контролы.
//
// Revision 1.266  2006/10/10 14:32:03  mmorozov
// - bugfix: range check error (CQ: OIT5-22956);
//
// Revision 1.265  2006/07/19 13:41:24  mmorozov
// - new behaviour: если пользователь закрыл любую форму при количестве форм больше одной, то новые формы будут складываться ровно в это место (не каскадом), т.е. они будут прятаться одна за другой (CQ: OIT500021545);
//
// Revision 1.264  2006/07/18 10:52:02  oman
// - fix: Более адекватное имя параметра
// - fix: Потенциальная проблема с Rage check error (cq21919)
//
// Revision 1.263  2006/06/23 10:42:26  mmorozov
// - new: профайлеры в библиотеке VCM;
//
// Revision 1.262  2006/03/30 14:02:58  lulin
// - операция инициализации разделена на две - с параметрами и без - для того, чтобы в итоге избавится от первой.
//
// Revision 1.261  2006/03/23 14:39:51  lulin
// - new behavior: выливаем строковые константы.
//
// Revision 1.260  2006/03/20 13:03:55  lulin
// - new behavior: выливаем параметры состояний операции.
//
// Revision 1.259  2006/03/16 14:12:56  lulin
// - убрана возможность изменения входного параметра - идентификатора операции.
//
// Revision 1.258  2006/03/16 11:28:54  lulin
// - вычищены имена сущностей и операций - перешли на их идентификаторы.
//
// Revision 1.257  2006/03/13 14:23:56  lulin
// - new behavior: записываем UserType'ы.
//
// Revision 1.256  2006/03/13 12:00:13  lulin
// - загрузка ресурсов переехала в более правильное место.
//
// Revision 1.255  2006/03/10 18:22:06  lulin
// - работа над заливкой/выливкой строковых ресурсов.
//
// Revision 1.254  2006/03/10 09:30:00  lulin
// - bug fix: сборки форм регистрировались в неправильном месте.
//
// Revision 1.253  2006/03/09 20:07:38  lulin
// - bug fix: строки с кавычками обрезались.
// - new behavior: выливаем сообщения системы.
//
// Revision 1.252  2006/03/09 19:02:45  lulin
// - не выводим контролы, у которых неопубликовано свойство _Caption.
// - выводим не только WinControl'ы.
//
// Revision 1.251  2006/03/09 18:43:27  lulin
// - выделяем константы.
// - записываем тип элемента.
//
// Revision 1.250  2006/03/09 17:58:06  lulin
// - еще раз выдлены константы.
//
// Revision 1.249  2006/03/09 16:50:35  lulin
// - покоммител работы Земцова по выливке ресурсов VCM.
//
// Revision 1.248  2006/02/02 14:48:46  mmorozov
// new: вычисление модуля в котором зарегистрирована формы, по классу формы;
// change: убрано указание модуля при создании формы;
//
// Revision 1.247  2005/12/08 13:09:38  oman
// cleanup (ненужная ссылка на vcmGBLInterfaces)
//
// Revision 1.246  2005/11/10 17:59:42  lulin
// - bug fix: не становились доступными стрелочки у кнопок с множественным выбором (CQ OIT5-17940).
//
// Revision 1.245  2005/09/29 10:54:53  mmorozov
// new: блокировка Action.Update;
//
// Revision 1.244  2005/09/13 13:18:25  mmorozov
// - warning fix;
//
// Revision 1.243  2005/09/05 14:35:08  fireton
// - bug fix: если окно контекстного поиска vcm-ное (как в Немезисе) ,
//         то его надо закрывать принудительно
//
// Revision 1.242  2005/08/10 14:57:27  fireton
// - обрамление define (для отвязки некоторых модулей в проектах, которым они не нужны)
//
// Revision 1.241  2005/07/28 14:30:12  mmorozov
// new: methods _RegisterFormSetFactories, _RegisterFormSetFactory;
//
// Revision 1.240  2005/07/14 16:02:51  lulin
// - new behavior: в run-time получаем ID операции по ее имени из информации, содержащейся в MenuManager'е.
//
// Revision 1.239  2005/06/27 07:08:24  mmorozov
// new: после загрузки из потока зовем InitSettingsSource (TvcmMainForm);
//
// Revision 1.238  2005/06/23 16:10:56  mmorozov
// change: TvcmDispatcher ничего не знает про ISettings;
//
// Revision 1.237  2005/06/02 09:26:10  dinishev
// Bug fix: В процедуре UnlockPopupMessage содержалась очень интересная строка: PostMessage(HWND(f_PopupLockForms), _vcm_msgClearPopup, 0, f_PopupLockMsgs[l_Index]); Поэтому сообщение посылалось по адресу списка форм. А ему оно не очень-то было нужно. :-)
//
// Revision 1.236  2005/06/01 09:15:38  mmorozov
// - _format code;
//
// Revision 1.235  2005/05/13 14:27:18  lulin
// - new behavior: теперь help выливается по ключу -vcmExportHelp.
//
// Revision 1.234  2005/05/12 14:13:31  lulin
// - cleanup.
//
// Revision 1.233  2005/04/28 15:03:54  lulin
// - переложил ветку B_Tag_Box в HEAD.
//
// Revision 1.232  2005/04/21 10:59:30  mmorozov
// change: счетчик f_Op в  TvcmDispatcherюEndOp сбрасываем после освобождения объектов, иначе в процессе освобождения _EndOp мог быть вызван повторно и возникала ошибка;
//
// Revision 1.231.2.1  2005/04/25 09:03:43  lulin
// - объединил с HEAD.
//
// Revision 1.232  2005/04/21 10:59:30  mmorozov
// change: счетчик f_Op в  TvcmDispatcherюEndOp сбрасываем после освобождения объектов, иначе в процессе освобождения _EndOp мог быть вызван повторно и возникала ошибка;
//
// Revision 1.231  2005/04/19 15:41:37  lulin
// - переходим на "правильный" ProcessMessages.
//
// Revision 1.230  2005/04/15 15:57:04  fireton
// - bug fix: изменены параметры создания главного окна (CreateParams) с тем,
//       чтобы не-vcm окна ("Сохранить как") вели себя корректно
//
// Revision 1.229  2005/04/14 14:52:14  mmorozov
// bugfix: AV при открытии формы в DesignTime;
//
// Revision 1.228  2005/04/08 12:05:04  am
// bugfix: модуль в _uses попал внутрь дефайна
//
// Revision 1.227  2005/04/08 10:46:15  am
// change: регистрируем модуль Tvcm_dmToolbarMenu
//
// Revision 1.226  2005/03/02 11:28:40  lulin
// - new unit: vcmXMLWriter (выкушен из vcmMainForm).
//
// Revision 1.225  2005/03/01 17:51:32  lulin
// - удалены ненужные зависимости.
//
// Revision 1.224  2005/03/01 17:43:24  lulin
// - new class: TevXMLWriter (выкушен из VCM).
//
// Revision 1.223  2005/02/15 15:24:08  am
// new: f_StoredFocusLock - счётчик для _StoreFocus/_RestoreFocus
// change: теперь и _EntityOperation смотрит на Params._FocusMustStored
//
// Revision 1.222  2005/01/20 13:25:21  lulin
// - new consts: _vcm_otModuleInternal, _vcm_otFormConstructor.
//
// Revision 1.221  2005/01/19 12:42:46  am
// change: при освобождении объектов из ObjectsForFree пользуем _vcmFree вместо FreeAndNil
//
// Revision 1.220  2005/01/17 09:30:38  lulin
// - bug fix: не компилировалось.
//
// Revision 1.219  2005/01/14 16:36:45  lulin
// - восстановил собственную копию статусной строки для кождой основной формы приложения.
//
// Revision 1.218  2005/01/14 15:51:52  lulin
// - remove prop: IafwApplication.StatusBar.
// - new prop: _IafwMainForm.StatusBar.
//
// Revision 1.217  2005/01/14 15:20:17  lulin
// - new prop: IafwApplication._CurrentMainForm.
//
// Revision 1.216  2005/01/14 15:01:21  lulin
// - new interface: _IafwMainForm.
//
// Revision 1.215  2005/01/14 10:42:32  lulin
// - методы Get*ParentForm переехали в библиотеку AFW.
//
// Revision 1.214  2005/01/12 16:22:29  lulin
// - контекстный поиск полностью переведен с операций VCM на интерфейсы AFW.
//
// Revision 1.213  2005/01/12 12:47:40  lulin
// - перевел модуль afwFacade в глобальных процедур на метакласс.
//
// Revision 1.212  2004/12/28 18:41:12  lulin
// - new prop: IafwApplication.Settings.
//
// Revision 1.211  2004/12/23 08:26:04  lulin
// - new interface: IafwStatusBar.
//
// Revision 1.210  2004/12/23 07:27:56  lulin
// - перевел обработку статусной строки на библиотеку AFW.
//
// Revision 1.209  2004/12/20 15:39:39  lulin
// - обработка статусной строки частично переведена на библиотеку AFW.
//
// Revision 1.208  2004/12/09 15:26:05  lulin
// - new behavior: обновляем статусную строку после каждой операции.
//
// Revision 1.207  2004/12/07 14:56:48  mmorozov
// - не компилировалась библиотека;
//
// Revision 1.206  2004/12/07 11:54:22  lulin
// - new method: _Tl3LongintList._IndexOf.
//
// Revision 1.205  2004/11/18 16:29:57  lulin
// - отвязываем библиотеки от VCM без использования inc'ов.
//
// Revision 1.204  2004/11/16 15:43:32  am
// new proc: _BeginCancelModal\EndCancelModal\_InCancelModal - выставить\сбросить флаг выхода из модальной формы, проверка того, что этот флаг выставлен
//
// Revision 1.203  2004/11/16 14:55:31  mmorozov
// new: property TvcmMainForm._GiveFocusToZone;
// new: method TvcmDispatcher._ReinsertForms;
//
// Revision 1.202  2004/11/15 14:29:56  demon
// - new behavior: если фокус попадает в главное окно, пытаемся передать его вложенной форме из _ParentZone
//
// Revision 1.201  2004/11/10 14:20:02  mmorozov
// - заглушки для комментариев;
//
// Revision 1.200  2004/10/29 12:35:24  mmorozov
// new: линия отделяющая командное меню от компонентов формы;
//
// Revision 1.199  2004/10/22 07:50:17  lulin
// - bug fix: не создавался главный Toolbar и пункты меню перемешивались.
//
// Revision 1.198  2004/10/19 09:26:01  lulin
// - bug fix: для каждого главного окна создавался свой диспетчер (CQ OIT5-10460).
//
// Revision 1.197  2004/10/18 12:34:17  lulin
// - new behavior: не отрисовываем заголовок основного окна, когда диспетчер залочен (CQ OIT5-10321).
//
// Revision 1.196  2004/10/15 13:15:52  am
// change: дёргаем _PostBuild при создании главной формы (для позиционирования главного  тулбара)
//
// Revision 1.195  2004/10/13 16:19:33  mmorozov
// change: _HistoryZones перенесены на TvcmBaseMenuManager;
//
// Revision 1.194  2004/10/13 11:31:09  lulin
// - bug fix: были случаи, когда по команде выход приложение оставалось в цикле обработки сообщений.
//
// Revision 1.193  2004/10/13 09:26:54  demon
// - new property: _Dispatcher.InClosingAllWindows: Boolean показывает, что мы находимся в процессе закрытия всех главных окон (в процессе выхода).
//
// Revision 1.192  2004/10/12 14:20:42  am
// new: LockPopupMessage/UnlockPopupMessage/IsPopupMessageLocked - лок сообщения _vcm_msgClearPopup. При выставленном локе пришедшее сообщение не обрабатывается главной формой. При вызове UnlockPopupMessage сообшение снова помещается в очередь.
//
// Revision 1.191  2004/10/12 13:13:15  mmorozov
// bugfix: CloseAllWindows;
//
// Revision 1.190  2004/10/12 12:43:20  mmorozov
// change: при закрытии приложения (TvcmDispatcher.CloseAllWindows) вместо PostQuitMessage закрываем все формы по _SafeClose;
//
// Revision 1.189  2004/10/11 13:51:21  lulin
// - bug fix: не компилировалось.
//
// Revision 1.188  2004/10/09 07:52:04  mmorozov
// TvcmDispatcher:
// - new: method Get_IsRestoringAllSettings;
// - new: method BeginRestoreAllSettings;
// - new: method EndRestoreAllSettings;
// - new: property IsRestoringAllSettings;
//
// Revision 1.187  2004/10/07 14:17:04  lulin
// - new: теперь у _IvcmParams можно присваивать только свойство DoneStatus - код завершения. На основе этого "по-хитрому" обрабатываем ShortCut'ы для запрещенных операций (CQ OIT5-10123).
//
// Revision 1.186  2004/10/07 12:42:52  mmorozov
// new: field TvcmMainForm._f_FormInfo;
// new: method TvcmMainForm._RestoreFormSize;
// new: method TvcmDispacher.ReloadAllToolbars;
// new: method TvcmDispacher._RestoreFormSize;
// new: запоминаем параметры главной формы после загрузки (Loaded);
//
// Revision 1.185  2004/10/06 17:15:09  lulin
// - борьба за кошерность.
//
// Revision 1.184  2004/09/24 13:46:28  fireton
// - bug fix: починка design time для форм VCM
//
// Revision 1.183  2004/09/23 13:37:48  lulin
// - bug fix: внутри операции не освобождались модальные формы (CQ OIT5-9796).
//
// Revision 1.182  2004/09/22 09:34:36  lulin
// - оптимизщация - кешируем результат преобразования Name -> ID при посылке операций.
//
// Revision 1.181  2004/09/21 12:55:57  lulin
// - Release заменил на Cleanup.
//
// Revision 1.180  2004/09/10 12:47:44  lulin
// - new type: TvcmEffectiveUserType.
// - new behavior: не возвращаем интерфейсы для операции, если у нее нету имени.
//
// Revision 1.179  2004/09/10 12:23:57  lulin
// - оптимизация - гораздо аккуратнее обращаемся с UserType'ами и VisibleOpCount. В итоге уменьшено количество различных вызовов.
//
// Revision 1.178  2004/09/07 16:19:49  law
// - перевел VCM на кшированные обьекты.
//
// Revision 1.177  2004/09/06 13:05:48  am
// change: во время Unlock'а дёргаю статический _UpdateActions на TvcmForm
//
// Revision 1.176  2004/09/06 12:07:14  am
// change: теперь при Unlock диспетчера, во время вызовов ManualUpdateActinos, не бегаем по одним и тем же формам
//
// Revision 1.175  2004/09/03 10:16:28  am
// bugfix: Unlock
//
// Revision 1.174  2004/09/03 06:53:36  am
// new: _f_UpdateForms - список форм, для отложенного вызова _ManualUpdateActions
//
// Revision 1.173  2004/09/02 17:19:26  mmorozov
// new: method TvcmMainForm.SmallToolbarSize (сообщаем компонентам зон поддерживающим IvcmToolbarNotifier о размере toolbar-а);
//
// Revision 1.172  2004/09/01 14:48:56  demon
// - new behavior: из операций IvcmDispatcher BeginOp/_EndOp убраны вызовы _StoreFocus/_RestoreFocus. Где требовалось сохранение фокуса эти вызовы вставлены явно.
//
// Revision 1.171  2004/08/25 14:03:51  am
// new: BackupLockStatus\RestoreLockStatus - сохранить\восстановить лок отрисовки (на момент показа модальной формы, например)
//
// Revision 1.170  2004/08/05 14:48:03  mmorozov
// bugfix: когда форма умирает удаляем её из очереди форм на удаление, иначе в _EndOp были проблемы;
//
// Revision 1.169  2004/08/04 12:27:41  law
// - bug fix: был RangeCheckError - т.к. hWnd - беззнаковый.
//
// Revision 1.168  2004/08/02 14:05:40  law
// - открутил VCM от тесной интеграции с моделью Немезиса.
//
// Revision 1.167  2004/07/30 11:44:40  mmorozov
// new: в UnLock используем RedrawWindow;
//
// Revision 1.166  2004/07/30 11:30:09  mmorozov
// new: при размораживании отрисовки используем RedrawWindow;
//
// Revision 1.165  2004/07/22 15:04:55  am
// bugfix: защитил AddDockManager _g_UnlockProtection
//
// Revision 1.164  2004/07/20 11:16:54  am
// change: защита от вызова _Lock\Unlock внутри Unlock'а
//
// Revision 1.163  2004/07/19 13:25:23  mmorozov
// new: перед закрытием приложения проверяем буфер обмена (если _vcmNeedL3);
//
// Revision 1.162  2004/07/13 10:43:21  law
// - bug fix: операции передавались из модальной формы ее контейнеру.
//
// Revision 1.161  2004/07/13 07:18:33  am
// bugfix: RestoreFocus. Проверяли на возможность установки фокуса только сам контрол и родителя. А надо всю цепочку наследования.
//
// Revision 1.160  2004/07/09 12:25:15  law
// - bug fix: не компилировалось.
//
// Revision 1.159  2004/07/09 11:19:39  am
// new: в _Dispatcher.Unlock перерисовываем не только формы, но и отдельные контролы.
//
// Revision 1.158  2004/06/25 11:47:31  law
// - bug fix: в результате прошлых исправлений сломались ShortCut'ы.
//
// Revision 1.157  2004/06/25 11:36:48  law
// - new behavior: контролы в Toolbar'ах транслируют операции той форме к которой они принадлежат.
//
// Revision 1.156  2004/06/02 11:44:51  nikitin75
// +TvcmDispatcher.StoreFocused
// +аккуратнее восстанавливаем фокус
//
// Revision 1.155  2004/06/02 10:58:57  mmorozov
// change: для создания списка агрегаций используем MakeSorted;
//
// Revision 1.154  2004/06/02 10:20:50  law
// - удален конструктор Tl3VList.MakeIUnknown - пользуйтесь _Tl3InterfaceList.Make.
//
// Revision 1.153  2004/06/01 14:56:38  law
// - удалены конструкторы Tl3VList.MakeLongint, MakeLongintSorted - пользуйтесь _Tl3LongintList.
//
// Revision 1.152  2004/06/01 07:43:56  nikitin75
// + Store\RestoreFocus at Begin\_EndOp
//
// Revision 1.151  2004/05/31 12:18:14  am
// new: скобки LockCursor\UnlockCursor
//
// Revision 1.150  2004/05/28 10:48:55  mmorozov
// new behaviour: перед упорядочиванием снимаем Constraints у форм;
// bugfix: перед упорядочиванием нормализуем окна (SetWindowPos позволяет изменить размер максимизированного окна, при этом кнопка  "Максимизировать" остаётся в состоянии "Восстановить");
//
// Revision 1.149  2004/05/28 08:00:10  nikitin75
//  в TvcmMainForm.BecomeActive становимся главной формой приложения
//
// Revision 1.148  2004/05/19 12:56:19  am
// change: развязал MenuManager.BeginOp\_EndOp и _Dispatcher.BeginOp\_EndOp.
//
// Revision 1.147  2004/05/11 07:23:11  am
// bugfix: временно: обрамил _f_Entities._Clone дефайном DesignTimeLibrary
//
// Revision 1.146  2004/05/07 13:07:36  am
// bugfix: при рассылке сообщений броадкастом бежим не по _f_Entities, а по копии (поскольку _f_Entities может изменяться в процессе)
//
// Revision 1.145  2004/05/01 11:37:37  law
// - new prop: TvcmMainForm._NeedVersionInCaption (CQ OIT5-6235).
//
// Revision 1.144  2004/04/23 14:39:37  mmorozov
// new: method TvcmDispatcher.GetCurrentMonitorRect;
// new: написана собственная реализация CascadeWindows, TileWindowsHorizontal, TileWindowsVertical, ArrangeAll;
//
// Revision 1.143  2004/04/19 15:45:59  mmorozov
// new: method TvcmDispatcher.ShowMainForm;
// change: в методе TvcmDispatcher.CloseAllWindows появился параметр aCurrent : IvcmEntityForm - форма, которую не нужно закрывать;
//
// Revision 1.142  2004/04/19 10:30:42  mmorozov
// change: при упорядочивании окон используем вместо Application.Components список _f_MainForms;
//
// Revision 1.141  2004/04/17 10:55:26  mmorozov
// new: type TvcmTileWindowType;
// new: type PvcmTileWindowType;
// new: type TvcmPlaceWindowType;
// new: method TvcmDispatcher.PlaceWindows;
// new: method TvcmDispatcher.TileWindows;
// new: method TvcmDispatcher.TileWindowsHorizontal;
// new: method TvcmDispatcher.TileWindowsVertical;
// new: method TvcmDispatcher.CascadeWindows;
// new: method TvcmDispatcher.CloseAllWindows;
//
// Revision 1.140  2004/04/12 08:10:43  nikitin75
// + IvcmEntityForm.IsModalForm;
// + по shortcut не зовем операцию модуля, если форма активной сущноси модальная;
//
// Revision 1.139  2004/04/09 11:50:49  law
// - new behavior: прикручен контроль за Tl3Form.
//
// Revision 1.138  2004/04/09 11:27:49  law
// - new class: _TvcmStringList.
//
// Revision 1.137  2004/04/04 17:44:32  migel
// - fix: проблемы с фокусом.
//
// Revision 1.136  2004/03/31 06:17:37  nikitin75
// Get_ActiveEntity: каждый раз заново определяем _ActiveEntity (временно);
//
// Revision 1.135  2004/03/26 10:46:53  am
// new: Прокидываем BeginOp\_EndOp в MenuManager
//
// Revision 1.134  2004/03/25 15:21:26  mmorozov
// new behavior: aParams : _IvcmParams в событие OnTest приходит с установленным Container;
//
// Revision 1.133  2004/03/25 12:30:56  law
// - bug fix: AV при вставке списка после возврата по Alt-Tab (CQ OIT5-6798).
//
// Revision 1.132  2004/03/22 17:00:16  law
// - bug fix: Закрытие первого окна немезиса ведет к закрытию только что открытого нового (CQ OIT5-6999).
//
// Revision 1.131  2004/03/19 13:22:21  mmorozov
// new: регистрация операций управления формой;
//
// Revision 1.130  2004/03/10 14:55:02  law
// - new: изменен формат выливки xml-файла, для hlp.
//
// Revision 1.129  2004/03/01 15:34:35  law
// - bug fix: в настройки пишем более правильный заголовок осносной формы.
//
// Revision 1.128  2004/03/01 13:53:30  law
// - new behavior: сохраняем/восстанавливаем положение и размеры всех плавающих и модальных форм.
//
// Revision 1.127  2004/03/01 12:09:06  law
// - change: задел на сохранение позиции и размеров всех "плавающих" форм, а не только основной.
//
// Revision 1.126  2004/02/27 16:27:51  law
// - bug fix: новое окно открывается с правильной позицией и размерами.
// - optimization: совершенно случайно серъезно уменьшено время открытия нового окна.
//
// Revision 1.125  2004/02/27 14:40:29  law
// - bug fix.
//
// Revision 1.124  2004/02/27 09:33:50  law
// - new behavior: при открытии нового окна учитываем свои текущие размеры.
//
// Revision 1.123  2004/02/26 15:54:26  law
// - new behavior: сохраняем состояние Maximized основной формы.
//
// Revision 1.122  2004/02/13 16:10:57  law
// - поправлена генерация Help в связи с изменениями относительно ImageIndex.
//
// Revision 1.121  2004/02/11 17:54:37  law
// - new behavior: возможность выбора Toolbar'а верхний/нижний etc.
//
// Revision 1.120  2004/02/11 15:55:12  law
// - bug fix: при генерации Help для основного окна делаем псевдо-модуль.
//
// Revision 1.119  2004/02/11 12:18:41  law
// - new behavior: пересоздаем Toollbar'ы для всех заинтересованных форм.
//
// Revision 1.118  2004/02/11 09:52:13  law
// - bug fix: убрана, каким-то загадочным образом появившаяся, ошибочная строка.
//
// Revision 1.117  2004/02/10 17:45:11  law
// - new behavior: ищем экземпляр уже созданной формы и если не нашли, то только в этом случае создаем новую.
//
// Revision 1.116  2004/02/10 17:09:40  law
// - new: в нулевом приближении сделана настройка Toolbar'ов при выборе объекта из списка.
//
// Revision 1.115  2004/02/06 13:08:44  law
// - new event: TvcmMainForm._OnDispatcherCreated.
//
// Revision 1.114  2004/01/23 15:16:30  nikitin75
// - bug fix: в TvcmDispatcher.Get_ActiveEntity не проверяли на то, что форма уже закрывается и никак не может стать _ActiveEntity.
//
// Revision 1.113  2004/01/21 18:49:28  migel
// - fix: чиним фокус и апдейт заголовков основной формы.
//
// Revision 1.112  2004/01/21 18:07:13  law
// - change: для Help'а добавлена выливка тегов 'container' и 'operationtype'.
//
// Revision 1.111  2004/01/16 17:15:43  law
// - new behavior: делаем Delete, а не Remove - иначе мог ломаться итератор.
//
// Revision 1.110  2004/01/15 13:40:12  mmorozov
// new behaviour: при получении _ActiveEntity, если значение = nil, то проверяем нет ли текущей активной сущности IvcmEntity в приложении, если есть, то возвращаем ее в качестве активной (метод TvcmDispatcher.Get_ActiveEntity);
//
// Revision 1.109  2004/01/15 13:04:21  law
// - bug fix: не удаляем компоненты во время операции (CQ OIT5-5892).
//
// "demon (14.01.2004): Идем в любой документ с редакциями (например 79140 с "галкой").
// Переходим на неактуальную редакцию.
// Теперь в тулбаре Предупреждения кликаем на операцию "Открыть актуальную редакцию" видим AV."
//
// Revision 1.108  2004/01/10 14:00:30  law
// - bug fix: Разные окна стали связанны (CQ OIT5-5181).
//
// Revision 1.107  2003/12/27 18:24:29  migel
// - bug fix: не создавались toolbar'ы при старте приложения, когда не было ни одной CurrentForm.
//
// Revision 1.106  2003/12/26 16:51:20  law
// - new behavior: переделана логика обработки BottonCombo - теперь если меню нету, то и стрелки вниз нету.
// - bug fix: иногда при восстановлении из истории портился _Caption главного окна.
//
// Revision 1.105  2003/12/25 15:54:58  law
// - bug fix: восстановил вызов WM_NCPaint - т.к. отъезжали "рамки".
//
// Revision 1.104  2003/12/18 17:20:01  law
// - борьба с мерцанием.
//
// Revision 1.103  2003/12/04 15:54:46  law
// - new event: _TvcmEntityForm.OnGetStatus.
//
// Revision 1.102  2003/12/02 14:18:23  law
// - bug fix: сообщение о неосвобожденном объекте History.
//
// Revision 1.101  2003/11/30 17:01:42  law
// - change: _ModuleOperation переходим от имен к идентификаторам.
//
// Revision 1.100  2003/11/30 13:09:28  law
// - change: _EntityOperationBroadcast переходим от имен к идентификаторам.
//
// Revision 1.99  2003/11/30 13:03:12  law
// - new method version: IvcmDispatcher._EntityOperationBroadcast.
//
// Revision 1.98  2003/11/30 12:58:16  law
// - new method version: IvcmDispatcher._EntityOperation.
//
// Revision 1.97  2003/11/30 12:49:44  law
// - new method version: IvcmDispatcher._ModuleOperation.
//
// Revision 1.96  2003/11/30 12:38:19  law
// - bug fix: при убивании формы удаляем ссылку на нее из MenuManager'а.
//
// Revision 1.95  2003/11/30 11:56:14  law
// - cleanup: убраны "странные" вызовы операции модуля, без указания собственно модуля.
//
// Revision 1.94  2003/11/30 09:25:25  law
// - bug fix: для главной формы не вызывалось событие OnInit.
//
// Revision 1.93  2003/11/28 20:04:40  migel
// - fix: поведение окон в таскбаре и при выборе по `Alt+Tab`.
//
// Revision 1.92  2003/11/28 13:01:34  law
// - new behavior: опираемся на идентификаторы форм, а не на имена.
//
// Revision 1.91  2003/11/28 11:20:43  law
// - new consts: vcm_etActiveEntityChange, _vcm_evpOldActive, _vcm_evpNewActive.
//
// Revision 1.90  2003/11/25 10:22:46  law
// - bug fix: не компилировалось с директивой vcmExportHelp.
//
// Revision 1.89  2003/11/21 13:00:47  law
// - change: параметр aMode перенесен в конец и сделан необязательным.
//
// Revision 1.88  2003/11/21 12:10:01  law
// - change: параметр aMode перенесен в конец и сделан необязательным.
//
// Revision 1.87  2003/11/20 20:38:00  law
// - new behavior: корректно генерируем список идентификаторов операций.
// - new behavior: вызов операций сущностей возможен теперь только по идентификатору.
// - cleanup: пытаемся в Design-Time отвязаться от GblAdapter (не получилось).
//
// Revision 1.86  2003/11/18 17:10:41  nikitin75
// fix: begin..end;//with FileLongVersion
//
// Revision 1.85  2003/11/13 13:49:13  law
// - bug fix: привел тестовый проект в актуальное состояние.
//
// Revision 1.84  2003/11/11 15:54:30  law
// - new behavior: при подписке на события "*" означает "Все модули".
//
// Revision 1.83  2003/10/28 09:57:50  law
// - new behavior: пункты основного меню строятся на основе MainMenuItems.
//
// Revision 1.82  2003/10/23 16:24:27  law
// - bug fix: запись не в ту историю.
//
// Revision 1.81  2003/10/23 15:36:36  law
// - new interface: IvcmMainForm.
//
// Revision 1.80  2003/10/23 15:09:51  law
// - new behavior: History теперь знает про MainForm, что более правильно.
//
// Revision 1.79  2003/10/23 14:13:36  law
// - new behavior: в методе TvcmDispatcher._EntityOperationBroadcast фиксируем набор форм.
//
// Revision 1.78  2003/10/23 12:41:03  law
// - new method: IvcmDispatcher._EntityOperationBroadcast.
//
// Revision 1.77  2003/10/22 15:38:09  law
// no message
//
// Revision 1.76  2003/10/22 12:33:55  law
// - bug fix: невовремя убивался Toolbar.
//
// Revision 1.75  2003/10/17 13:17:58  law
// - new behavior: склеиваем MainForm._Caption из Application.Title и VersionMajor.
//
// Revision 1.74  2003/10/15 16:17:33  law
// - new behavior: выливаем список Control'ов формы.
//
// Revision 1.73  2003/10/15 13:14:28  law
// - new behavior: выливаем _ExcludeUserTypes.
// - bg fix: более корректно выливаем флаи принадлежности операции меню и toolbar'ам.
//
// Revision 1.72  2003/10/08 12:16:28  law
// - new behavior: при обновлении статуса, проверяем, что aSender, это _ActiveEntity.
//
// Revision 1.71  2003/10/08 12:06:12  law
// - new param: IvcmDispatcher.UpdateStatus - aSender.
//
// Revision 1.70  2003/10/06 14:33:10  demon
// - bug fix: При вызове _EntityOperation с параметром vcm_omTest, не верно возвращались aParams.
//
// Revision 1.69  2003/10/03 09:14:03  law
// - bug fix: очищаем PopupMenu в подходящий момент.
//
// Revision 1.68  2003/09/30 11:37:20  law
// - bug fix.
//
// Revision 1.67  2003/09/29 15:12:14  law
// - new behavior: вместе со строковыми ресурсами сохраняем иконки.
//
// Revision 1.66  2003/09/26 16:11:46  law
// - new behavior: начал делать слитие строковых ресурсов.
//
// Revision 1.65  2003/09/26 15:24:02  law
// - new behavior: начал делать слитие строковых ресурсов.
//
// Revision 1.64  2003/09/25 17:00:28  law
// - new behavior: сделано отложенное убивание форм.
//
// Revision 1.63  2003/09/22 15:54:27  law
// - bug fix: вкручены скобки _EnableAlign/_DisableAlign в _Lock/Unlock.
//
// Revision 1.62  2003/09/16 17:05:14  law
// - new methods: IvcmHistory.AddForm, _RemoveForm (пока только добавляют,удпляют формы, но не записывают их при Start).
//
// Revision 1.61  2003/09/04 11:49:10  law
// - new behavior: _Caption основного объекта выводится в _Caption главного окна.
//
// Revision 1.60  2003/07/30 16:35:22  law
// - new prop: IvcmDispatcher.Settings.
//
// Revision 1.59  2003/07/30 16:02:36  law
// - bug fix: не перерисовывались элементы оформления форм.
//
// Revision 1.58  2003/07/21 16:30:26  law
// - bug fix: неправильно вставлялась форма в зоне vcm_ztManualModal.
//
// Revision 1.57  2003/07/21 15:53:10  law
// - bug fix: был AV когда пытались удалить форму = nil.
//
// Revision 1.56  2003/07/17 14:36:52  demon
// - bug fix: после удаления формы в залоченной операции шла попытка ее перерисовки (цикл с For заменен на While).
//
// Revision 1.55  2003/07/16 16:30:11  law
// - bug fix: список форм для отрисовки не очищался после Unlock.
//
// Revision 1.54  2003/07/16 16:18:57  law
// - new behavior: перерисовываем формы, после Unlock диспетчера форм.
//
// Revision 1.53  2003/07/14 12:23:04  law
// - bug fix: модальные окна "прилипали" к родителю.
//
// Revision 1.52  2003/07/14 11:38:49  law
// - bug fix: модальная форма поднималась в залоченном состоянии.
//
// Revision 1.51  2003/07/14 09:40:46  law
// - new const: vcm_ztModal - добавлен новый тип зоны, в котором окно поднимается как модальный диалог.
//
// Revision 1.50  2003/07/01 18:56:31  demon
// - bug fix: у MainForm не задавался GUID
//
// Revision 1.49  2003/07/01 15:58:38  law
// - bug fix: неправильно определялась текущая MainForm'а для Floating формы. Проблемы остались - Мише Морозову надо для плавающего окна Owner'ом делать не Application, а Self.
//
// Revision 1.48  2003/06/27 14:25:09  law
// - new prop: TvcmMainForm._HistoryZones.
// - new behavior: не восстанавливаем по новой формы, которые уже восстановили (почему они два раза пишутся в историю - надо разбираться отдельно).
//
// Revision 1.47  2003/06/23 15:14:39  law
// Задел на восстановление Owner'а форм при операциях Back/Forward:
// - remove method: IvcmFormDispatcher.FindContainer.
// - new method: IvcmFormDispatcher._FindForm.
//
// Revision 1.46  2003/06/23 15:03:25  law
// - change: свойство IvcmContainer.GUID переехало в IvcmEntityForm.GUID - теперь каждая форма имеет свой идентификатор.
// - remove interface: IvcmGUIDSetter.
// - new param: конструктор _TvcmEntityForm.Make имее еще один параметр - aGUID - для восстановления идентификатора формы при операциях Back/Forward.
//
// Revision 1.45  2003/06/23 13:59:34  law
// - new behavior: при поиске контейнера по GUID'у просматриваем не только список сущностей, но и список MainForm.
//
// Revision 1.44  2003/06/23 13:37:30  law
// - new behavior: сделано запоминание контейнера при операциях Back/Forward.
//
// Revision 1.43  2003/06/23 12:24:39  law
// - new method: IvcmDispatcher.FindAggregate.
//
// Revision 1.42  2003/06/23 12:18:28  law
// - new methods: IvcmDispatcher.AddAggregate, IvcmDispatcher.RemoveAggregate.
//
// Revision 1.41  2003/06/19 15:12:04  law
// - new method: IvcmDispatcher.UpdateStatus.
// - new prop: TvcmMainForm.OnUpdateStatus.
//
// Revision 1.40  2003/06/17 11:42:50  narry
// - update: продолжение документирования
//
// Revision 1.39  2003/06/17 09:34:51  law
// - new const: vcm_ztFloating.
//
// Revision 1.38  2003/06/09 13:33:41  law
// - new prop: IvcmFormDispatcher._CurrentMainForm.
// - new behavior: если Owner = nil, для формы сущности, то пытаемся сделать ей Owner'ом текущую основную форму.
// - new behavior: для плавающей формы неправильно находилась основная форма приложения.
//
// Revision 1.37  2003/06/06 12:56:30  law
// - new prop: IvcmDispathcher.History.
// - new behavior: сохранение форм в истории по их закрытии (пока до конца не доделано).
//
// Revision 1.36  2003/06/06 10:32:47  law
// - change: введена новая категория свойств vcm.
//
// Revision 1.35  2003/06/06 09:45:19  law
// - cleanup.
//
// Revision 1.34  2003/06/03 14:08:15  law
// - bug fix: не собиралось с опцией _vcmNeedL3.
// - bug fix: при закрытии приложения не освобождались модули.
//
// Revision 1.33  2003/06/02 15:19:47  narry
// - update: продолжение документирования библиотеки
//
// Revision 1.32  2003/05/22 11:38:06  law
// - new prop:  IvcmFormDispatcher.MainFormsCount, IvcmFormDispatcher.MainForm.
//
// Revision 1.31  2003/05/22 09:08:04  narry
// - update: начало документирования
//
// Revision 1.30  2003/05/20 13:33:01  law
// - bug fix: первый экземпляр основной формы не подписывался на события.
//
// Revision 1.29  2003/04/29 13:28:54  law
// - new methods: IvcmFormDispatcher._Lock, Unlock.
//
// Revision 1.28  2003/04/28 13:02:35  law
// - remove const: vcm_opDone.
// - new prop: _IvcmParams.Done.
//
// Revision 1.27  2003/04/28 09:36:11  law
// - cleanup: переделана логика работы с параметрами операций.
//
// Revision 1.26  2003/04/25 16:34:47  law
// - cleanup: _IvcmParams._Dispatcher - теперь Read-Only.
//
// Revision 1.25  2003/04/25 15:56:06  law
// - new behavior: у _IvcmParams теперь нельзя править контейнер - надо создавать копию параметров.
//
// Revision 1.24  2003/04/24 14:53:54  law
// - новая сборка dll.
// - изменилися формат вызова eeGetGenerator, eeGetFileGenerator.
//
// Revision 1.23  2003/04/23 17:13:03  law
// - new behavior: в режиме _SDI если клиентская область основной формы занята, то делаем новую копию.
//
// Revision 1.22  2003/04/23 17:02:12  law
// - new method: TvcmMainForm.MakeClone.
//
// Revision 1.21  2003/04/23 16:33:51  law
// - new prop: TvcmMainFor.MenuManager - для вынесения одной его копии в DataModule.
//
// Revision 1.20  2003/04/23 15:50:06  law
// - bug fix: в операцию модуля не передавался активный контенер.
//
// Revision 1.19  2003/04/23 15:05:05  law
// - new behavior: в параметры операции заковыриваем текущий контейнер верхнего уровня.
//
// Revision 1.18  2003/04/23 14:13:35  law
// - new behavior: теперь не вставляем панель, если был контрол с alClient.
//
// Revision 1.17  2003/04/23 11:04:06  demon
// - bug fix: компилировалось без вызова _AddRef - вообще-то ошибка от Борланда. Изменил "узорчик".
//
// Revision 1.16  2003/04/22 19:02:07  law
// - new behavior: отказываемся от MDI форм при включенном флаге _SDI.
//
// Revision 1.15  2003/04/22 17:33:43  law
// - new prop: TvcmMainForm._SDI.
//
// Revision 1.14  2003/04/22 15:00:31  law
// - bug fix: оттестировал вставку форм в контейнер.
//
// Revision 1.13  2003/04/22 14:03:01  law
// - new behavior: сделана обработка операций, описанных на основной форме.
//
// Revision 1.12  2003/04/21 15:27:00  law
// - new interface: IvcmContainerForm.
//
// Revision 1.11  2003/04/09 11:05:44  law
// - change: изменен список параметров одного из методов IvcmDispatcher._ModuleOperation.
//
// Revision 1.10  2003/04/09 08:57:34  law
// - экспериментируем с ComboBox в Toolbar'е.
//
// Revision 1.9  2003/04/04 10:58:59  law
// - bug fix: была ошибка в имени типа TvcmControlID.
//
// Revision 1.8  2003/04/03 15:46:31  law
// - bug fix: поздно создавался диспетчер.
//
// Revision 1.7  2003/04/03 15:43:55  law
// - change: из TvcmMainForm выделил класс TvcmDispatcher.
//
// Revision 1.6  2003/04/03 11:25:11  law
// - new behavior: изменена подписка.
// - new method version: IvcmAggregate.Operation.
//
// Revision 1.5  2003/04/03 09:26:19  law
// - new behavior: сделал возможность подписки на события.
//
// Revision 1.4  2003/04/01 16:15:31  law
// - new prop: IvcmDispatcher.EntitiesCount, IvcmDispatcher.Entity.
//
// Revision 1.3  2003/04/01 16:10:45  law
// - new behavior: сделана регистрация сущностей от форм в списке у главной формы.
//
// Revision 1.2  2003/04/01 15:27:51  law
// - new interface: IvcmEntityForm.
//
// Revision 1.1  2003/04/01 12:54:49  law
// - переименовываем MVC в VCM.
//
// Revision 1.33  2003/03/24 14:04:07  law
// - change: продолжаем заковыривать все относящееся к операции в _IvcmParams.
//
// Revision 1.32  2003/03/24 13:25:48  law
// - change: продолжаем заковыривать все относящееся к операции в _IvcmParams.
//
// Revision 1.31  2003/03/21 12:34:44  law
// - new behavior: операциям добавлен список параметров.
//
// Revision 1.30  2003/03/21 10:13:37  law
// - cleanup: удалены модули vcm*Repository.
//
// Revision 1.29  2003/03/20 15:46:12  law
// - new method versions: IvcmDispatcher._ModuleOperation.
//
// Revision 1.28  2003/03/20 15:38:12  law
// - new methods: IvcmDispatcher.GetModuleCount, IvcmDispatcher.GetModule.
//
// Revision 1.27  2003/03/20 15:22:50  law
// - new methods: IvcmDispatcher.GetModuleByID, IvcmDispatcher._ModuleOperation.
//
// Revision 1.26  2003/03/20 15:10:11  law
// - new method: IvcmDispatcher._GetModuleByName.
// - new method version: IvcmDispatcher._EntityOperation.
//
// Revision 1.25  2003/03/17 12:24:51  law
// - new behavior: в нулевом приближении сделана автоматическая сборка контекстного меню.
//
// Revision 1.24  2003/03/17 10:29:19  law
// - new behavior: привязал к компонентам пустое (пока) контекстное меню.
//
// Revision 1.23  2003/03/14 18:24:12  law
// - наконец-то родил пример под BCB.
//
// Revision 1.22  2003/03/14 14:55:49  law
// - new units: vcmBaseMenuManager, vcmMenuManager.
//
// Revision 1.21  2003/03/06 15:15:56  law
// - new behavior: сделано построение меню для форм сущностей.
//
// Revision 1.20  2003/03/05 08:46:38  law
// - new behavior: _TvcmEntityForm теперь сама регистрируется в диспетчере форм.
// - new method: IvcmFormDispatcher._RemoveForm.
//
// Revision 1.19  2003/03/04 16:06:05  law
// - new method version: TvcmMainForm._RegisterModule.
//
// Revision 1.18  2003/03/04 15:38:31  law
// - new behavior: для сущностей без операций не делаем пункт меню.
//
// Revision 1.17  2003/02/27 17:23:53  law
// - change: объединил методы ExecuteOperation и OperationEnabled.
//
// Revision 1.16  2003/02/27 12:12:05  law
// - new behavior: определяется разрешенность операций сущности.
//
// Revision 1.15  2003/02/27 11:14:54  law
// - new behavior: вчерне сделал выполнение операций сущности.
//
// Revision 1.14  2003/02/27 10:55:12  law
// - new unit: vcmEntityAction.
//
// Revision 1.13  2003/02/27 10:06:09  law
// - change: модулю и сущности добавлен идентификатор.
//
// Revision 1.12  2003/02/27 09:51:45  law
// - new behavior: сделано добавление операций сущности в меню.
//
// Revision 1.11  2003/02/27 09:00:03  law
// - cleanup.
//
// Revision 1.10  2003/02/27 07:57:38  law
// - new behavior: сделано получение сущностей модуля.
//
// Revision 1.9  2003/02/26 18:12:35  law
// - new property: IvcmDispatcher._ActiveEntity.
//
// Revision 1.8  2003/02/26 16:22:43  law
// - new behavior: сделана обработка операция и создание форм.
//
// Revision 1.7  2003/02/25 17:59:46  law
// - new behavior: начал писать обвязку для выполнения операций модуля.
//
// Revision 1.6  2003/02/25 11:08:06  law
// - change: добавлено определение операций модуля.
//
// Revision 1.5  2003/02/24 14:19:35  law
// - change: первая визуализация нашей модели.
//
// Revision 1.4  2003/02/24 13:44:01  law
// - new behavior: добавлен вызов метода _RegisterModules из конструктора формы.
//
// Revision 1.3  2003/02/24 13:02:24  law
// - help added.
//
// Revision 1.2  2003/02/24 11:11:31  law
// - new unit: vcmEntityForm.
//

{$I vcmDefine.inc }

interface

{$IfDef vcmNeedL3}
 {$IfNDef DesignTimeLibrary}
  {$Define vcmExportHelp}
  {$Define vcmExportContent}
 {$EndIf DesignTimeLibrary} 
{$EndIf vcmNeedL3}

{$IfNDef DesignTimeLibrary}
 {$IfDef vcmExportContent}
  {$Define vcmExportHelp}
 {$EndIf}
{$EndIf  DesignTimeLibrary}

uses
  Windows,
  Messages,
  ActiveX,

  StrUtils,
  Classes,
  Controls,
  Forms,
  ExtCtrls,
  Graphics,
  Menus,
  {$IfDef vcmExportHelp}
  ImgList,
  {$EndIf vcmExportHelp}

  l3Types,
  l3IID,

  afwInterfaces,

  vcmExternalInterfaces,
  vcmUserControls,
  vcmInterfaces,

  vcmBase,
  vcmMessages,
  vcmModule,

  vcmForm,
  vcmEntityForm,
  vcmContainerForm,

  vcmBaseMenuManager,
  vcmTasksPanel,
  vcmHistory,
  vcmStatusElement,
  {$IfDef vcmUseProfilers}
  vcmProfilersCollection,
  {$EndIf vcmUseProfilers}
  vcmTaskPanelInterfaces,
  vcmFormDispatcherInterfaces,
  vcmWritersInterfaces,

  vcmFormSetFactory,
  vcmIEntityFormPtrList,
  vcmIEntityList,
  vcmDockManagerList,
  vcmLockListenerList,
  vcmFormDispatcherListenerList,
  vcmAggregateRefList,
  vcmMainFormModelPart
  ;

type
  _vcmComponentDestroyer_Parent_ = TvcmMainFormModelPart;
  {$Include W:\common\components\gui\Garant\VCM\implementation\Visual\vcmComponentDestroyer.imp.pas}
  TvcmMainForm = class(_vcmComponentDestroyer_, IafwMainForm, IvcmContainerMaker)
   {* Базовый класс для главной формы приложения построенного на библиотеке vcm. }
    private
    // internal fields
      {$IfDef vcmExportHelp}
      f_HelpOut                     : IvcmXMLWriter;
      f_NeedExportHelp              : Boolean;
      f_NeedExportContent           : Boolean;
      {$IfDef InsiderTest}
      f_ModulesRegistered           : Boolean;
      {$EndIf InsiderTest}
      {$EndIf vcmExportHelp}
      f_Dispatcher                  : IvcmDispatcher;
      f_MenuManager                 : TvcmBaseMenuManager;
      f_SDI                         : Boolean;
      f_ClientZone                  : TControl;
      f_History                     : TvcmHistory;
      f_NeedVersionInCaption        : Boolean;
      f_CaptionPrefix               : IvcmCString;
      f_FormInfo                    : TvcmMainFormInfo;
      f_StatusBar                   : Pointer;
      f_Status                      : IafwStatus;
      f_StatusElement               : IafwStatusElement;
      f_NeedUpdateMainCaptionPrefix : Boolean;
      f_TasksPanelZone              : Integer;
    // internal _events
      f_TasksPanel                  : TvcmCustOps;
    private
    // messages
      procedure WMSysCommand(var Message: TWMSysCommand);
        message WM_SysCommand;
        {-}
      procedure vcmMsgCloseForm(var Message: TMessage);
        message vcm_msgCloseForm;
        {-}
      procedure vcmMsgUpdateStatus(var Message: TMessage);
        message vcm_msgUpdateStatus;
        {-}
      procedure CMTextChanged(var Message: TMessage);
        message CM_TEXTCHANGED;
        {-}
      procedure WMSetText(var Message: TMessage);
        message WM_SetText;
        {-}
      procedure WMSetFocus(var Message: TMessage);
       message WM_SetFocus;
        {-}
    protected
    // interface methods
      // IafwMainForm forms
      function  pm_GetStatusBar: IafwStatusBar;
      procedure pm_SetStatusBar(const aValue: IafwStatusBar);
        {-}
      function  pm_GetStatus: IafwStatus;
      procedure pm_SetStatus(const aValue: IafwStatus);
        {-}
      // IvcmContainerMaker
      function MakeContainer: IvcmContainer;
        {-}
    protected
    // property methods
      function Get_Dispatcher: IvcmDispatcher;
        {-}
      function pm_GetMenuManager: TvcmBaseMenuManager;
        {-}
      function pm_GetHistory: IvcmHistory;
        {-}
      {$IfDef vcmUseProfilers}
      function pm_GetProfilers: TvcmProfilersCollection;
        {* - коллекция профайлеров. }
      {$EndIf vcmUseProfilers}
      function pm_GetTasksPanel: IvcmCustOps;
        {* - панель задач. }
    protected
    // internal methods
      {$IfDef vcmExportHelp}
      function  SaveEntity(const anOp : IvcmEntityDef;
                           aForm      : TCustomForm): Bool;
        {-}
      procedure SaveEntities(const anOps : IvcmEntitiesDefIterator;
                             aForm       : TCustomForm);
        {-}
      function  SaveOperation(const anOp : IvcmOperationDef;
                              aForm      : TCustomForm): Bool;
        {-}
      procedure SaveOperations(const anOps : IvcmOperationsDefIterator;
                               aForm       : TCustomForm);
        {-}
      function  SaveForm(aForm : TvcmEntityForm; aNeedCutCaption : Boolean; aSaveControls : Boolean): Boolean;
        {-}
      procedure SaveForms(aList: TvcmClassList);
        {-}
      procedure SaveHelp(const aModuleDef : IvcmModuleDef);
        {-}
      procedure DoSaveBitmaps(aBitmaps : TCustomImageList);
        {-}
      procedure SaveBitmaps;
        {-}
      {$EndIf vcmExportHelp}
      procedure RegisterModule(const aModuleDef : IvcmModuleDef);
        overload;
        { Description
          Регистрирует модуль в диспетчере и менеджере меню.
          
          Summary
          Регистрирует модуль приложения                     }
      procedure RegisterModuleInMenu(const aModuleDef : IvcmModuleDef);
        {* - регистрирует модуль в меню, toolbar'ах, etc. }
      procedure RegisterModules;
        {$IfNDef Nemesis}
        virtual;
        {$EndIf  Nemesis}
        { Description
          Для того, чтобы приложение могло обрабатывать операции
          модулей, модули нужно зарегистрировать. Делается это примерно
          так:


          <CODE>
          procedure TMainForm.RegisterModules;
          begin
           inherited;
           RegisterModule(TmoDocument);
          end;
          </CODE>
          
          Summary
          Регистрирует все модули приложения.
          
          Note
          Перекрывается в потомках. В шаблоне проекта данный метод
          перекрыт по умолчанию.                                        }
      procedure ShowForm(const aForm: IvcmEntityForm);
        virtual;
        {* - показать форму. }
      procedure BecomeActive;
        override;
        {-}
      procedure BecomeInactive;
        override;
        {-}
      procedure Cleanup;
        override;
        { Освобождает память, выделенную под форму. }
      procedure CreateParams(var Params: TCreateParams);
        override;
        {-}
      function  CanRemoveInKillFromVCM: Boolean;
        override;
        {-}
      procedure BeforeKill;
        override;
        {-}
      procedure CorrectApplicationMainForm;
        {-}
      procedure DoClose(var Action: TCloseAction);
        override;
        {-}
      procedure UpdateMainCaption;
        virtual;
        {-}
      procedure DoUpdateMainCaptionPrefix;
        {* - обновить префикс заголовка. Используется при создании формы и при
             переключении базы. }
      class function FormImplementationClass: TClass;
        override;
        {-}
      procedure DoGiveFocusToZone;
        {* - если фокус находится у главной формы, то она передаёт его
             зоне с типом _vcm_ztParent. }
      procedure UpdateActions;
        override;
        {-}
      procedure DoShow;
        override;
        {-}
      {$IfDef Nemesis}
      // http://mdp.garant.ru/pages/viewpage.action?pageId=414849606
      function LimitOpenedWindowsCount: Boolean; virtual;
        {* - ограничивается ли количество открытых окон. }
      function MaxOpenedWindowsCount: Integer; virtual;
        {* - максимальное количество открытых окон. }
      {$EndIf Nemesis}
      function DoMakeClone(aNeedShow: Boolean): TvcmMainForm; virtual;
        {-}
      procedure BecomeMainForm; virtual;
        {-}
      procedure ReleaseResources; override;
        {-}
      procedure DoExitApplication; virtual;
        {-}
      procedure InitClone(aForm: TvcmMainForm); virtual;
        {-}
//      procedure SetHistory(const aHistory: IvcmHistory);
        {-}
    public
    // public methods
      constructor Create(anOwner: TComponent);
        override;
        {-}
      {$IfDef vcmExportHelp}
      procedure DoExportRes(const aWriter : IvcmXMLWriter; aSaveStrings : Boolean);
        {-}
      procedure DoExportHelp(const aFileName : String; aSaveStrings : Boolean);
        {-}
      {$EndIf vcmExportHelp}
      procedure Loaded;
        override;
        {* - запоминаем состояние окна и его положение. }
      function  GetIsMainObjectForm: Boolean;
        override;
        {-}
      procedure SmallToolbarSize(const aValue : Integer);
        {* - уведомление зон о размере toolbar-а с маленькими иконками и
             компонентами TvcmDateEdit, TvcmEdit. }
      function MakeClone(aNeedShow: Boolean = True): TvcmMainForm;
        { Description
          Основное предназначение данной функции - создать копию
          главной формы в _SDI приложениях.

          Summary
          Создает точную копию формы.

          Returns
          Возвращает указатель на вновь созданную форму.         }
      function  COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
      procedure ReloadToolbars;
        override;
        {-}
      procedure RestoreFormSize;
        {* - перечитывает размер формы, сначала на основе информации
             Design-Time, потом из настроек. }
      procedure UpdateMainCaptionPrefix;
        {* - обновить префикс заголовка. Используется при создании формы и при
             переключении базы. Если Dispather.Locked, то выставляем флаг для
             обновления префикса в _UpdateMainCaption. }
      function IsTasksPanelForm(const aForm: IvcmEntityForm): Boolean;
        {* - определяет используется ли форма для панели задач. }
      procedure AddFormToTasksPanel(const aEntityForm: IvcmEntityForm);
        {-}
      procedure RemoveFormFromTasksPanel(const aEntityForm: IvcmEntityForm);
        {-}
      procedure RegisterModule(aModule : RvcmModule);
        overload;
        { Description
          Регистрирует модуль в диспетчере и менеджере меню.

          Summary
          Регистрирует модуль приложения                     }
    public
    // public properties
      property CaptionPrefix: IvcmCString
        read f_CaptionPrefix;
        {-}
      property Dispatcher: IvcmDispatcher
        read Get_Dispatcher;
        { Description
          Позволяет напрямую вызывать операции у модулей и сущностей.

          Summary
          Диспетчер приложения                                        }
      property History: IvcmHistory
        read pm_GetHistory;
        {-}
      property StatusBar: IafwStatusBar
        read pm_GetStatusBar
        write pm_SetStatusBar;
        {* - объект, отображающий строку статуса. }
      property Status: IafwStatus
        read pm_GetStatus
        write pm_SetStatus;
        {* - строка статуса. }
      property TasksPanel: IvcmCustOps
        read pm_GetTasksPanel;
        {* - панель задач. }
      property SDI: Boolean
        read f_SDI
        write f_SDI
        default false;
        { Description
          Для приложений, созданных на основе библиотеки VCM
          переключение между стилями SDI и MDI производится изменением
          свойства SDI главной формы. По умолчанию SDI = False.
          
          Summary
          Стиль приложения.
          
          Note
          Формы сущностей не могут свойство ZoneType установленным в
          vcm_ztAny.                                                   }
      property NeedVersionInCaption: Boolean
        read f_NeedVersionInCaption
        write f_NeedVersionInCaption
        default false;
        {-}
      property TasksPanelZone: Integer
        read f_TasksPanelZone
        write f_TasksPanelZone
        default -1;
        {* - зона, формы которой используются для панели задач. }
    published
    // published properties
      property MenuManager: TvcmBaseMenuManager
        read pm_GetMenuManager
        write f_MenuManager;
        { Summary
          Менеджер меню

          Description
          Менеджер меню отвечает за сборку и отображение меню операций
          модулей.                                                     }
      {$IfDef vcmUseProfilers}
      property Profilers: TvcmProfilersCollection
        read pm_GetProfilers;
        {* - коллекция профайлеров. }
      {$EndIf vcmUseProfilers}
  end;{ Главная форма приложения. У SDI приложения их может быть
        несколько.                                               }

  TvcmMainFormImplementation = class(TvcmContainerFormImplementation, IvcmMainForm)
    protected
    // property methods
      function pm_GetTasksPanel: IvcmCustOps;
        {-}
      function pm_GetHistory: IvcmHistory;
        {-}
    // public methods
      procedure AddFormToTasksPanel(const aEntityForm: IvcmEntityForm);
        {-}
      procedure RemoveFormFromTasksPanel(const aEntityForm: IvcmEntityForm);
        {-}
  end;//TvcmMainFormImplementation

  RvcmMainForm = class of TvcmMainForm;

  TvcmTileWindowType  = (vcm_twHorizontal, vcm_twVertical);
    {* - тип размещения окон (горизонтально, вертикально). }
  PvcmTileWindowType  = ^TvcmTileWindowType;
    {* - указатель на тип размещения окон. }
  TvcmPlaceWindowType = (vcm_pwCascade, vcm_pwTile);
    {* - вид расположения титульно или каскадом. }
  TvcmLockNotify = (
   {* - типы уведомления о блокировке\разблокировке действий. }
    vcm_lnLock,
     // - работа с визуалкой заблокирована;
    vcm_lnBeforeUnlock,
     // - здесь мы можем обновлять данные, переходные процессы закончились, но
     //   визуалка ещё не рисуется;
    vcm_lnUnlock
     // - здесь уже можно рисоваться; 
  );//TvcmLockNotify

  TvcmDispatcher = class(TvcmCacheableBase,
                         IvcmDispatcher,
                         IvcmFormDispatcher,
                         IvcmFormDispatcherNotify)
    private
    // internal fields
      f_NeedUpdateMainCaption : Boolean;
      f_Form                  : TvcmMainForm;
      f_Entities              : TvcmIEntityList;
      f_MainForms             : TvcmIEntityFormPtrList;
      f_FormsForClose         : TvcmIEntityFormPtrList;
      f_ObjectsForFree        : TvcmObjectList;
      f_InvalidateForms       : TvcmIEntityFormPtrList;
      f_UpdateForms           : TvcmIEntityFormPtrList;
      f_InvalidateCtrls       : TvcmLongintList; // list of hwnd
      f_DockManagers          : TvcmDockManagerList;
      f_LockListeners         : TvcmLockListenerList;
      f_FDListeners           : TvcmFormDispatcherListenerList;
      f_Aggregates            : TvcmAggregateRefList;
      f_Lock                  : Integer;
      f_CursorLock            : Integer;
      f_StoredFocusLock       : Integer;
      f_OldCursor             : TCursor;
      f_Op                    : Integer;
      f_CancelModalLock       : Integer;
      f_PrevFocused           : THandle;
      f_SaveLockCounter       : TvcmLongintList;
      f_RestoreAllSettings    : Integer;
      f_ClosingAllWindows     : Boolean;
      f_ActionUpdateCount     : Integer;
      f_InternalOp            : Boolean;
      f_NewMainFormBounds     : TRect;
      f_NeedUpdateStatus      : Boolean;
      f_UnlockProtection      : Boolean;
      f_MainFormProvider      : Pointer;
      f_LockInOpCount: Integer;
    private
    // IvcmFormDispatcherNotify
      procedure AddFDListener(const aListener: IvcmFormDispatcherListener);
      procedure IvcmFormDispatcherNotify.AddListener = AddFDListener;
      procedure RemoveFDListener(const aListener: IvcmFormDispatcherListener);
      procedure IvcmFormDispatcherNotify.RemoveListener = RemoveFDListener;
        {-}
    protected
    // property methods
      function  pm_GetForm: TvcmMainForm;
        {-}
      function  Get_IsRestoringAllSettings: Boolean;
        {-}
      function  Get_InClosingAllWindows: Boolean;
        {-}
      function  pm_GetIsLockActionUpdate: Boolean;
        {-}
      procedure LockInOp;
      procedure UnlockInOp;
    protected
    // internal methods
      procedure LockNotify(const aLock: TvcmLockNotify);
        {* - рассылает нотификацию о блокировке\разблокировке действий на период
             выполнения операции модуля. }
      procedure PrepareWindows(const aForms: IvcmEntityFormsIterable = nil);
        {* - подготавливает окна к упорядочиванию. }
      function GetCurrentMonitorRect : TRect;
        {* - получить TRect экрана, на котором находится курсор мыши. }
(*      procedure PlaceWindowsByWindows(aType : TvcmPlaceWindowType;
                             aTile : PvcmTileWindowType = nil);*)
        {* - упорядочить окна. }
      procedure TileWindows(aType : TvcmTileWindowType; const aForms: IvcmEntityFormsIterable = nil);
        {-}
      procedure ArrangeAll(const aForms: IvcmEntityFormsIterable);
        {-}
      procedure SetWindowPosition(aHandle: THandle; aLeft, aTop, aWidth, aHeight: Integer);
        {-}
      procedure StoreFocus;
        {-}
      procedure RestoreFocus;
        {-}
    protected
    // interface methods
      // IvcmFormDispatcher
      function Get_Notify: IvcmFormDispatcherNotify;
        {-}
      function Get_Locked: Boolean;
        {-}
      function Get_MainFormsCount: Integer;
        {-}
      function Get_MainForm(anIndex: Integer): IvcmEntityForm;
        {-}
      function Get_CurrentMainForm: IvcmEntityForm;
        {-}
      procedure AddForm(const aForm: IvcmEntityForm);
        {* - добавить новую форму в приложение. }
      procedure RemoveForm(const aForm: IvcmEntityForm);
        {* - удалить форму из приложения. }
      procedure Lock;
        {-}
      procedure UnLock;
        {-}
      procedure BackupLockStatus;
        {-}
      procedure RestoreLockStatus;
        {-}
      procedure LockCursor;
        {-}
      procedure UnlockCursor;
        {-}
      function  FindForm(const aGUID : TGUID;
                         out theForm : IvcmEntityForm): Boolean;
        {-}
      procedure AddFormForInvalidate(const aForm: IvcmEntityForm);
        {-}
      procedure AddFormForUpdateActions(const aForm: IvcmEntityForm);
        {-}
      procedure AddControlForInvalidate(aControl : TObject);
        {-}
      procedure AddDockManager(const aDockManager: IDockManager);
        {-}
      procedure AddLockListener(const aListener: IvcmLockListener);
        {-}
      procedure RemoveLockListener(const aListener: IvcmLockListener);
        {-}
      procedure UpdateMainCaption(const aForm: IvcmEntityForm = nil);
        {-}
      procedure AddToCloseQueue(const aForm: IvcmEntityForm);
        {-}
      procedure AddObjectForFree(O: TObject);
        {-}
      procedure PlaceNewMainForm(aSource : TCustomForm;
                                 aNew    : TCustomForm);
        {* - разместить новую главную форму.
             aSourceMainForm:
               - форма на которой вызвали создание новой. }
      // IvcmDispatcher
      function  Get_FormDispatcher: IvcmFormDispatcher;
        {-}
      function  Get_History: IvcmHistory;
        {-}
      function  Get_ActiveEntity: IvcmEntity;
        {-}
      function  Get_EntitiesCount: Integer;
        {-}
      function  Get_Entity(anIndex: Integer): IvcmEntity;
        {-}
      procedure EntityOperation(const anOp    : TvcmOPID;
                               const aParams : IvcmParams;
                               aMode         : TvcmOperationMode);
        overload;
        {* - выполняет операцию сущности. }
      function EntityOperation(const anOp    : TvcmOPID;
                               const aParams : IvcmExecuteParams): Boolean;
        overload;
        {* - выполняет операцию сущности. }
      procedure EntityOperation(const anOp    : TvcmOPID;
                               const aParams : IvcmTestParams);
        overload;
        {* - выполняет операцию сущности. }
      procedure EntityOperationBroadcast(const anOp    : TvcmOPID;
                                        const aParams : IvcmExecuteParams);
        {-}
      procedure ModuleOperation(const anOp    : TvcmMOPID;
                               const aParams : IvcmParams;
                               aMode         : TvcmOperationMode);
        overload;
        {* - выполняет операцию модуля. }
      procedure CallModuleOperation(const anOp    : TvcmMOPID;
                               const aParams : IvcmExecuteParams);
        {* - выполняет операцию модуля. }
      procedure ModuleOperation(const anOp    : TvcmMOPID;
                               const aParams : IvcmTestParams);
        overload;
        {* - выполняет операцию модуля. }
      function ModuleOperation(const anOp : TvcmMOPID): Boolean;
        overload;
        {* - выполняет операцию модуля. }
      function GetModuleByID(aModuleID: TvcmControlID): IvcmModule;
        {* - возвращает модуль по идентификатору. }
      function Get_ModulesCount: Integer;
        {* - возвращает количество зарегистрированных модулей. }
      function Get_Module(anIndex: Integer): IvcmModule;
        {* - возвращает модуль по индексу. }
      function pm_GetMainFormProvider: IvcmMainFormProvider;
        {-}
      procedure pm_SetMainFormProvider(const aValue: IvcmMainFormProvider);
        {-}
      procedure UpdateStatus;
        {-}
      procedure AddAggregate(const anAggregate: IvcmAggregate);
        {-}
      procedure RemoveAggregate(const anAggregate: IvcmAggregate);
        {-}
      function  FindAggregate(const aGUID      : TGUID;
                              out theAggregate : IvcmAggregate): Boolean;
        {-}
      procedure BeginOp(anInternal: Boolean = false);
        {-}
      procedure EndOp;
        {-}
      function  InOp(anInternal: Boolean = false): Boolean;
        {-}
      procedure BeginCancelModal;
        {-}
      procedure EndCancelModal;
        {-}
      function InCancelModal: Boolean;
        {-}
      procedure StoreFocused(aHandle : THandle);
        {-}
      procedure Cleanup;
        override;
        {-}
      procedure StartNewMainForm;
        {* - вызывается перед началом создания главной формы. }
    public
    // public methods
      constructor Create(aForm: TvcmMainForm);
        reintroduce;
        {-}
      class function Make: IvcmDispatcher;
        reintroduce;
        {-}
      procedure BeginRestoreAllSettings;
        {-}
      procedure EndRestoreAllSettings;
        {-}
      procedure TileWindowsHorizontal(const aForms: IvcmEntityFormsIterable = nil);
        {* - упорядочить открытые окна приложения горизонтально. }
      procedure TileWindowsVertical(const aForms: IvcmEntityFormsIterable = nil);
        {* - упорядочить открытые окна приложения ветикально. }
      procedure CascadeWindows(const aForms: IvcmEntityFormsIterable = nil);
        {* - расположить открытые окна каскадом. }
      procedure CloseAllWindows(const aForms: IvcmEntityFormsIterable = nil;
       const aCurrent: IvcmEntityForm = nil);
        {* - закрыть все открытые окна. }
      procedure ShowMainForm(const aForm : IvcmEntityForm);
        {* - показать главную форму. }
      procedure ReloadAllToolbars;
        {* - перезагружает информацию toolbar-ов у всех открытых в данный момент
             форм. }
      procedure RestoreFormSize;
        {* - перечитывает размер компонентов на форме (восстанавливает сначала
             размеры Design-Time, потом читает из настроек). }
      procedure ReinsertForms;
        {* - перечитывает значения форм. }
      procedure LockActionUpdate;
      procedure UnlockActionUpdate;
        {* - блокировать OnTest-ы операций. Необходимо когда система находится в
             переходном состоянии и не все данные актуальны. }
    public
    // public properties
      property Locked: Boolean
        read Get_Locked;
        {-}
      property MainFormsCount: Integer
        read Get_MainFormsCount;
        {-}
      property MainForm[anIndex: Integer]: IvcmEntityForm
        read Get_MainForm;
        {-}
      property Form: TvcmMainForm
        read pm_GetForm;
        {-}
      property ActiveEntity: IvcmEntity
        read Get_ActiveEntity;
        {* - активная сущность. }
  end;//TvcmDispatcher

implementation

uses
  {$IfDef vcmExportHelp}
  TypInfo,
  {$EndIf vcmExportHelp}
  Types,
  {$IfDef Nemesis}
  Dialogs,
  {$EndIf Nemesis}
  SysUtils,

  l3Base,
  l3VCLStrings,
  l3Defaults,
  {$IfDef Nemesis}
  l3StringIDEx,
  {$EndIf Nemesis}
  {$IfDef vcmExportHelp}
  l3Interfaces,
  l3InterfacesMisc,
  l3String,
  l3FileUtils,
  {$EndIf vcmExportHelp}

  afwFacade,
  {$IfNDef DesignTimeLibrary}
  afwStatus,
  afwApplication,
  // - это нужно, чтобы подключить Application Framework
  {$EndIf  DesignTimeLibrary}

  {$IfDef vcmExportHelp}
  vcmExportConst,
  vcmInternalInterfaces,
  {$EndIf vcmExportHelp}

  vcmSettings,
  vcmZonesCollectionItem,
  vcmRepositoryEx,
  vcmFormsUtils,
  vcmUtils,
  vcmMessagesSupport

  {$IfDef vcmExportHelp}
  ,
  vcmUserTypesCollectionItem,
  vcmBaseEntitiesCollectionItem,
  vcmEntitiesCollectionItem,
  vcmControlsCollectionItem,
  vcmMenus,
  vcmMenuManager,
  vcmMenuItemsCollectionItem,
  //vcmFormSetFactoriesCollectionItem,
  vcmMessagesCollectionItem,
  vcmFormSetFormsCollection,
  vcmFormSetFormsCollectionItem
  {$EndIf vcmExportHelp}

  {$IfDef vcmExportHelp}
  ,
  vcmXMLWriter,
  vcmContentWriter
  {$EndIf vcmExportHelp}
  ,
  vtVerInf
  {$IfDef Nemesis}
  ,
  vtInterfaces,
  vtPngImgList,
  vtPngImgListUtils
  {$EndIf Nemesis}

  ,
  vtPanel

  ,
  vcmInternalConst,
  vcmApplication

  {$IfNDef NoVGScene}
  ,
  vg_scene
  {$EndIf  NoVGScene}

  {$IfDef Nemesis}
  ,
  vcmMainFormRes
  {$EndIf Nemesis}

  , vcmModulesForRegister
  ;

 {$Include W:\common\components\gui\Garant\VCM\implementation\Visual\vcmComponentDestroyer.imp.pas}

// start class TvcmDispatcher

constructor TvcmDispatcher.Create(aForm: TvcmMainForm);
  //reintroduce;
  {-}
begin
 inherited Create;
 f_Form := aForm;
 f_Entities := TvcmIEntityList.Make;
 f_MainForms := TvcmIEntityFormPtrList.Make;
 f_FormsForClose := TvcmIEntityFormPtrList.Make;
 f_ObjectsForFree := TvcmObjectList.Make;
 f_InvalidateForms := TvcmIEntityFormPtrList.Make;
 f_UpdateForms := TvcmIEntityFormPtrList.Make;
 f_InvalidateCtrls := TvcmLongintList.Make;
 f_DockManagers := TvcmDockManagerList.Make;
 f_LockListeners := TvcmLockListenerList.Make;
 f_RestoreAllSettings := 0;
 f_CursorLock := 0;
 f_Lock := 0;
 f_PrevFocused := 0;
 f_SaveLockCounter := TvcmLongintList.Make;
 f_StoredFocusLock := 0;
 f_ActionUpdateCount := 0;
 f_MainFormProvider := nil;
 f_LockInOpCount := 0;
end;

class function TvcmDispatcher.Make: IvcmDispatcher;
  //reintroduce;
  {-}
var
 l_Dispatcher : TvcmDispatcher;
begin
 l_Dispatcher := TvcmDispatcher.Create(nil);
 try
  Result := l_Dispatcher;
 finally
  vcmFree(l_Dispatcher);
 end;//try..finally
end;
  
procedure TvcmDispatcher.StartNewMainForm;
  {* - вызывается перед началом создания главной формы. }
var
 l_Index: Integer;
begin
 if f_FDListeners <> nil then
  for l_Index := 0 to Pred(f_FDListeners.Count) do
   f_FDListeners[l_Index].StartNewMainForm;
end;//StartNewMainForm

procedure TvcmDispatcher.Cleanup;
  //override;
  {-}
begin
 vcmFree(f_Aggregates);
 vcmFree(f_Entities);
 vcmFree(f_MainForms);
 vcmFree(f_ObjectsForFree);
 vcmFree(f_FormsForClose);
 vcmFree(f_DockManagers);
 vcmFree(f_InvalidateForms);
 vcmFree(f_UpdateForms);
 vcmFree(f_InvalidateCtrls);
 vcmFree(f_SaveLockCounter);
 vcmFree(f_LockListeners);
 vcmFree(f_FDListeners);
 f_ClosingAllWindows := False;
 f_MainFormProvider := nil;
 inherited;
end;

function _GetMain(aForm: TCustomForm): TvcmMainForm;
var
 l_Form : TCustomForm;
 l_Container: IafwMainFormContainer;
 l_CurrentMainForm: TCustomForm;
begin//_GetMain
 Result := nil;
 l_Form := aForm;
 if Assigned(l_Form) and not (csDestroying in l_Form.ComponentState) then
  if Supports(l_Form, IafwMainFormContainer, l_Container) then
  try
   l_CurrentMainForm := l_Container.CurrentMainForm;
   if (l_CurrentMainForm <> nil) then
    Result := l_CurrentMainForm as TvcmMainForm
  finally
   l_Container := nil;
  end;//try..finally

 if (Result = nil) then
 begin
  while (l_Form <> nil) AND (Result = nil) do
   if (l_Form Is TvcmMainForm) then
    Result := TvcmMainForm(l_Form)
   else
    l_Form := afw.GetAnotherParentForm(l_Form);
  if (Result = nil) then
  begin
   l_Form := aForm;
   while (l_Form <> nil) AND (Result = nil) do
    if (l_Form Is TvcmMainForm) then
     Result := TvcmMainForm(l_Form)
    else
     l_Form := afw.GetParentForm(l_Form.Owner);
  end;//Result = nil
 end;
end;//_GetMain

function TvcmDispatcher.Get_IsRestoringAllSettings: Boolean;
begin
 Result := f_RestoreAllSettings > 0;
end;

function TvcmDispatcher.pm_GetIsLockActionUpdate: Boolean;
  {-}
begin
 Result := f_ActionUpdateCount > 0;
end;

procedure TvcmDispatcher.LockInOp;
begin
 Inc(f_LockInOpCount);
end;

procedure TvcmDispatcher.UnlockInOp;
begin
 Assert(f_LockInOpCount > 0);
 Dec(f_LockInOpCount);
end;

function TvcmDispatcher.Get_InClosingAllWindows: Boolean;
begin
 Result := f_ClosingAllWindows;
end;

procedure TvcmDispatcher.AddFDListener(const aListener: IvcmFormDispatcherListener);
var
 l_Index: Integer;
begin
 if f_FDListeners = nil then
  f_FDListeners := TvcmFormDispatcherListenerList.Make;
 l_Index := f_FDListeners.IndexOf(aListener);
 if l_Index = -1 then
  f_FDListeners.Add(aListener);
end;

procedure TvcmDispatcher.RemoveFDListener(const aListener: IvcmFormDispatcherListener);
begin
 if f_FDListeners <> nil then
  f_FDListeners.Remove(aListener);
end;

function TvcmDispatcher.pm_GetForm: TvcmMainForm;
  {-}
begin
 if (f_Form = nil) then
 begin
  Result := _GetMain(Screen.ActiveForm);
  if (Result = nil) then
   Result := _GetMain(Screen.ActiveCustomForm);
  if (Result = nil) then
   Result := _GetMain(Application.MainForm);
 end else
  Result := f_Form;
end;

procedure TvcmDispatcher.AddForm(const aForm: IvcmEntityForm);
  {* - добавить новую форму в приложение. }
var
 l_Main: TvcmMainForm;
 l_Index : Integer;
 l_Form : IvcmEntityForm;
begin
 if (aForm.VCLWinControl Is TvcmMainForm) then
  f_MainForms.Add(aForm)
 else
 begin
  // begin http://mdp.garant.ru/pages/viewpage.action?pageId=330139744&focusedCommentId=330142461#comment-330142461
  // - тут проверяем, что нельзя добавлять ДВЕ формы с ОДИНАКОВЫМ GUID
  with f_Entities do
   for l_Index := Lo to Hi do
   begin
    l_Form := Items[l_Index].AsForm;
    //if Supports(Items[l_Index], IvcmEntityForm, l_Form) then
    if (l_Form <> nil) then
    begin
     if IsEqualGUID(l_Form.GUID, aForm.GUID) then
      if not vcmIEQ(l_Form, aForm) then
       if (l_Form.NativeMainForm.AsForm.VCLWinControl <>
           aForm.NativeMainForm.AsForm.VCLWinControl) then
        // - http://mdp.garant.ru/pages/viewpage.action?pageId=327826220&focusedCommentId=330142701#comment-330142701   
        Assert(false);
    end;//Supports(Items[l_Index]
   end;//for l_Index
  // end http://mdp.garant.ru/pages/viewpage.action?pageId=330139744&focusedCommentId=330142461#comment-330142461
  f_Entities.Add(aForm.Entity);
  { Зарегистрируем операции управления формой }
  if Assigned(g_MenuManager) then
   g_MenuManager.AddForm(aForm);
  l_Main := Form;
  if (l_Main = nil) then
   l_Main := _GetMain(aForm.VCLWinControl As TCustomForm);
  if (l_Main <> nil) then
   l_Main.ShowForm(aForm);
 end;//aForm.VCLForm Is TvcmMainForm
end;//AddForm

procedure TvcmDispatcher.RemoveForm(const aForm: IvcmEntityForm);
  {* - удалить форму из приложения. }
var
 l_Index   : Integer;
 l_Entity  : IvcmEntity;
 l_History : IvcmHistory;
begin
 if (aForm <> nil) then
 begin
  if (g_MenuManager <> nil) then
   g_MenuManager.RemoveForm(aForm);
  l_History := Get_History;
  if (l_History <> nil) then
   l_History.RemoveForm(aForm);
  if (f_InvalidateForms <> nil) then
   f_InvalidateForms.Remove(aForm);
  if (f_UpdateForms <> nil) then
   f_UpdateForms.Remove(aForm);
  if (aForm.VCLWinControl Is TvcmMainForm) then 
  begin
   // Новую форму будем открывать на месте предыдущей закрытой:
   if f_MainForms.Count > 1 then
   begin
    // Если закрываемая форма максимизирована, то просто сбрасываем размеры,
    // чтобы они не применялись в TvcmDispatcher.PlaceNewMainForm, т.к. если
    // текущая форма не развернута, то новой форме присвоят размер развернутой
    // при этом работать с ней будет не удобно:
    // 1. Запустили приложение, состояние окна Normal;
    // 2. Открыли новое окно и устновили состояние Maximized;
    // 3. Открываем новое окно;
    // 4. Перед открытие в настройки будет записано Normal (SaveActiveForms);
    // 5. Читаем настройки для нового окна, состояние Normal;
    // 6. Размещаем окно в TvcmDispatcher.PlaceNewMainForm устанавливая ему
    //    размер максимизированного (f_NewMainFormBounds);
    // 7. Получается некрасиво;
    if (aForm.VCLWinControl As TCustomForm).WindowState = wsMaximized then
     SetRectEmpty(f_NewMainFormBounds)
    else
     f_NewMainFormBounds := aForm.VCLWinControl.BoundsRect;
   end;//if f_MainForms.Count > 1 then
   f_MainForms.Remove(aForm);
  end//if (aForm <> nil) then
  else
  begin
   l_Entity := aForm.Entity;
   with f_Entities do
    for l_Index := Lo to Hi do
     if vcmIEQ(f_Entities[l_Index], l_Entity) then
     begin
      Delete(l_Index);
      break;
     end;//vcmIEQ(f_Entities[l_Index], l_Entity)
  end;//aForm.VCLForm Is TvcmMainForm
  //if not InOp then
    with f_FormsForClose do
    begin
     l_Index := IndexOf(aForm);
     if l_Index <> -1 then
      Delete(l_Index);
    end;//with f_FormsForClose
 end;//aForm <> nil
end;

function TvcmDispatcher.Get_Notify: IvcmFormDispatcherNotify;
  {-}
begin
 Result := Self;
end;
      
function TvcmDispatcher.Get_Locked: Boolean;
  {-}
begin
 Result := (f_Lock > 0);
end;

function TvcmDispatcher.Get_MainFormsCount: Integer;
  {-}
begin
 Result := f_MainForms.Count;
end;

function TvcmDispatcher.Get_MainForm(anIndex: Integer): IvcmEntityForm;
  {-}
begin
 Result := f_MainForms.Items[anIndex];
end;

function TvcmDispatcher.Get_CurrentMainForm: IvcmEntityForm;
  {-}

 function lp_DoGetCurrentMainForm: IvcmEntityForm;
 var
  l_MF: IafwMainForm;
 begin
  Result := nil;
  if (f_MainFormProvider <> nil) then
   Result := IvcmMainFormProvider(f_MainFormProvider).CurrentMainForm
  else
  begin
   l_MF := afw.Application.CurrentMainForm;
   if (l_MF <> nil) then
   try
    Supports(l_MF, IvcmEntityForm, Result);
   finally
    l_MF := nil;
   end;//try..finally
  end;
 end;//lp_DoGetCurrentMainForm

var
 l_MF    : IafwMainForm;
 l_Index : Integer;
begin
 if (afw.Application = nil) then
  Result := nil
 else
 begin
  Result := lp_DoGetCurrentMainForm;
  if (Result = nil) then
  begin
   for l_Index := 0 to Screen.FormCount - 1 do
    if (Screen.Forms[l_Index] Is TvcmMainForm) then
     if Supports(Screen.Forms[l_Index], IvcmEntityForm, Result) then
      break;
  end;//l_MF <> nil
 end;//afw.Application = nil
end;

procedure TvcmDispatcher.LockNotify(const aLock: TvcmLockNotify);
  {* - рассылает нотификацию о блокировке\разблокировке действий на период
       выполнения операции модуля. }
var
 l_Index: Integer;
begin
 if (f_LockListeners <> nil) then
  with f_LockListeners do
  begin
   l_Index := Lo;
   while (l_Index <= Hi) do
   begin
    {$IfOpt D+}
    try
    {$EndIf}
     with Items[l_Index] do
      case aLock of
       vcm_lnLock: Lock;
       vcm_lnBeforeUnlock: BeforeUnlock;
       vcm_lnUnlock: UnLock;
      end;//case aLock of
    {$IfOpt D+}
    except
     // - падение - не повод замораживать всё приложение
     on E: Exception do
      l3System.Exception2Log(E);
    end;//try..except
    {$EndIf}
    Inc(l_Index);
   end;//while (l_Index <= Hi) do
  end;//with f_LockListeners do
end;//LockNotify

procedure TvcmDispatcher.Lock;
  {-}
begin
 if not f_UnlockProtection then
 begin
  if not Locked then
   LockNotify(vcm_lnLock);
  Inc(f_Lock);
 end;//if not f_UnlockProtection then
end;//Lock

procedure TvcmDispatcher.UnLock;
  {-}
var
 l_Index : Integer;
 l_Form  : IvcmEntityForm;
 l_DM    : IDockManager; 
begin
 if f_UnlockProtection then
  exit;
 if (f_Lock = 1) then
 begin
  if (f_InvalidateForms <> nil) then
   with f_InvalidateForms do
   begin
    l_Index := Lo;
    while (l_Index <= Hi) do
    begin
     l_Form := Items[l_Index];
     try
      if (l_Form.VCLWinControl <> nil) then
       l_Form.VCLWinControl.EnableAlign;
(*       with l_Form.VCLWinControl do
       begin
        EnableAlign;
        {Invalidate;
        Perform(WM_NCPaint, 0, 0);}
       end;//with l_Form.VCLForm*)
     finally
      l_Form := nil;
     end;//try..finally
     Inc(l_Index);
    end;//while (l_Index <= Hi)
   end;//with f_InvalidateForms
 end;//f_Lock = 1

 if (f_Lock = 1) then
 begin
  LockNotify(vcm_lnBeforeUnlock);
  Assert(f_Lock = 1);
 end;//f_Lock = 1

 f_UnlockProtection := true;
 try
  Dec(f_Lock);
  if (f_Lock = 0) then
  begin

   if (f_DockManagers <> nil) then
    with f_DockManagers do
    begin
     l_Index := Lo;
     while (l_Index <= Hi) do
     begin
      l_DM := Items[l_Index];
      try
       l_DM.EndUpdate;
      finally
       l_DM := nil;
      end;//try..finally
      Inc(l_Index);
     end;//while (l_Index <= Hi)
     Clear;
    end;//with f_DockManagers
    LockNotify(vcm_lnUnlock);

    if (f_UpdateForms <> nil) then
     with f_UpdateForms do
     begin
      l_Index := Lo;
      while (l_Index <= Hi) do
      begin
       l_Form := Items[l_Index];
       try
        if l_Form.VCLWinControl is TvcmForm then
         TvcmForm(l_Form.VCLWinControl).UpdateActions;
       finally
        l_Form := nil;
       end;//try..finally
       Inc(l_Index);
      end;//while (l_Index <= Hi)
      Clear;
     end;// with f_UpdateForms

    if (f_InvalidateForms <> nil) then
     with f_InvalidateForms do
     begin
      l_Index := Lo;
      while (l_Index <= Hi) do
      begin
       l_Form := Items[l_Index];
       try
        if (l_Form.VCLWinControl <> nil) then
         RedrawWindow(l_Form.VCLWinControl.Handle, nil, 0, RDW_ERASE or
          RDW_INTERNALPAINT or RDW_FRAME or RDW_INVALIDATE);
       finally
        l_Form := nil;
       end;//try..finally
       Inc(l_Index);
      end;//while (l_Index <= Hi)
      Clear;
     end;//with f_InvalidateForms

    if (f_InvalidateCtrls <> nil) then
     with f_InvalidateCtrls do
     begin
      l_Index := Lo;
      while (l_Index <= Hi) do
      begin
       RedrawWindow(hWND(Items[l_Index]), nil, 0, RDW_ERASE or RDW_INTERNALPAINT or
        RDW_FRAME or RDW_INVALIDATE);
       Inc(l_Index);
      end;//while (l_Index <= Hi)
      Clear;
     end;//with f_InvalidateCtrls
    if f_NeedUpdateMainCaption then
    begin
     f_NeedUpdateMainCaption := false;
     for l_Index := 0 to Pred(MainFormsCount) do
      (MainForm[l_Index].VCLWinControl As TvcmMainForm).UpdateMainCaption;
    end;//f_NeedUpdateMainCaption
  end;//f_Lock = 0
 finally
  f_UnlockProtection := false;
 end;
end;

function TvcmDispatcher.FindForm(const aGUID : TGUID;
                                 out theForm : IvcmEntityForm): Boolean;
  {-}
var
 l_Index : Integer;
begin
 Result := false;
 if (f_Entities <> nil) then
  with f_Entities do
   for l_Index := Lo to Hi do
   begin
    theForm := Items[l_Index].AsForm;
    //if Supports(Items[l_Index], IvcmEntityForm, theForm) then
    if (theForm <> nil) then
    begin
     if IsEqualGUID(theForm.GUID, aGUID) then
     begin
      Result := true;
      Exit;
     end;//IsEqualGUID(theForm.GUID, aGUID)
    end;//Supports(Items[l_Index]
   end;//for l_Index
 if (f_MainForms <> nil) then
  with f_MainForms do
   for l_Index := Lo to Hi do
   begin
    theForm := Items[l_Index];
    //if Supports(Items[l_Index], IvcmEntityForm, theForm) then
    if (theForm <> nil) then
    begin
     if IsEqualGUID(theForm.GUID, aGUID) then
     begin
      Result := true;
      Exit;
     end;//IsEqualGUID(theForm.GUID, aGUID)
    end;//Supports(Items[l_Index]
   end;//for l_Index
end;

procedure TvcmDispatcher.AddFormForInvalidate(const aForm: IvcmEntityForm);
  {-}
var
 l_Index : Integer;
begin
 l_Index := f_InvalidateForms.IndexOf(aForm);
 if (l_Index < 0) then
 begin
  f_InvalidateForms.Add(aForm);
  aForm.VCLWinControl.DisableAlign;
 end;//l_Index < 0
end;

procedure TvcmDispatcher.AddLockListener(const aListener: IvcmLockListener);
  {-}
var
 l_Index : Integer;
begin
 l_Index := f_LockListeners.IndexOf(aListener);
 if (l_Index < 0) then
  f_LockListeners.Add(aListener);
end;//AddLockListener

procedure TvcmDispatcher.RemoveLockListener(const aListener: IvcmLockListener);
  {-}
begin
 if (f_LockListeners <> nil) then
  f_LockListeners.Remove(aListener);
end;//RemoveLockListener

procedure TvcmDispatcher.AddDockManager(const aDockManager: IDockManager);
  {-}
var
 l_Index : Integer;
begin
 if (aDockManager <> nil) then
 begin
  l_Index := f_DockManagers.IndexOf(aDockManager);
  if (l_Index < 0) and not f_UnlockProtection then
  begin
   f_DockManagers.Add(aDockManager);
   aDockManager.BeginUpdate;
  end;//l_Index < 0
 end;//aDockManager <> nil
end;//AddDockManager

procedure TvcmDispatcher.UpdateMainCaption(const aForm: IvcmEntityForm);
  {-}

 procedure lp_DoUpdateMainCaption(const aMainForm: TvcmMainForm);
 begin
  if Locked then
   // - не обновляем заголовок окна при залочке
   f_NeedUpdateMainCaption := true
  else
   aMainForm.UpdateMainCaption;
 end;//lp_DoUpdateMainCaption

var
 l_CMF : IvcmEntityForm;
 l_Container: IafwMainFormContainer;
begin
 // Если форма еще не видна и мы знаем о ней (aForm <> nil), то пытаемся использовать ее.
 if (aForm <> nil) and aForm.IsMainObjectForm then
 begin
  if not Supports(afw.GetTopParentForm(aForm.VCLWinControl), IvcmEntityForm, l_CMF) then
   l_CMF := Get_CurrentMainForm;
 end//(aForm <> nil) and aForm.IsMainObjectForm
 else
  l_CMF := Get_CurrentMainForm;
 if (l_CMF <> nil) then
 begin
  if (l_CMF.VCLWinControl Is TvcmMainForm) then
   lp_DoUpdateMainCaption(TvcmMainForm(l_CMF.VCLWinControl))
  else
  if Supports(l_CMF, IafwMainFormContainer, l_Container) then
  try
   // Главной формой оказался контейнер, содержащий TvcmMainForm - нужно
   // обновить заголовок текущей активной главной формы в контейнере
   lp_DoUpdateMainCaption(TvcmMainForm(l_Container.CurrentMainForm));
   l_Container.UpdateFormCaption(aForm.VCLWinControl as TafwCustomForm);
  finally
   l_Container := nil;
  end;//try..finally
 end;//l_CMF <> nil..
end;

procedure TvcmDispatcher.AddToCloseQueue(const aForm: IvcmEntityForm);
  {-}
begin
 Assert(InOp);
 if (f_FormsForClose.IndexOf(aForm) < 0) then
  f_FormsForClose.Add(aForm);
end;

procedure TvcmDispatcher.PlaceNewMainForm(aSource : TCustomForm;
                                          aNew    : TCustomForm);
  {* - разместить новую главную форму.
       aSourceMainForm:
         - форма на которой вызвали создание новой. }
begin
 if (aSource.WindowState = wsMaximized) then
   aNew.WindowState := wsMaximized
 else
  // Разместим форму на месте предыдущей закрытой:
  if not IsRectEmpty(f_NewMainFormBounds) then
  begin
   // Уберем ограничения т.к. f_NewMainFormBounds в них не вписываются:
   with aNew.Constraints, f_NewMainFormBounds do
    if ((MinHeight <> 0) and (MinHeight < Bottom - Top)) or
      ((MinWidth <> 0) and (MinWidth < Right - Left)) then
     vcmDropConstraints(aNew);
   aNew.BoundsRect := f_NewMainFormBounds;
  end
  // Смещаем относительно главной на который вызвали создание нового главного
  // окна:
  else
  begin
   aNew.WindowState := wsNormal;
   aNew.Top := aSource.Top + 50;
   aNew.Left := aSource.Left + 50;
   aNew.Width := aSource.Width;
   aNew.Height := aSource.Height;
  end;
end;

procedure TvcmDispatcher.AddObjectForFree(O: TObject);
  {-}
begin
 if (f_ObjectsForFree.IndexOf(O) < 0) then
  f_ObjectsForFree.Add(O);
end;

function TvcmDispatcher.Get_FormDispatcher: IvcmFormDispatcher;
  {-}
begin
 Result := Self;
end;

function TvcmDispatcher.Get_History: IvcmHistory;
  {-}
var
 l_MainForm : TvcmMainForm;
begin
 l_MainForm := Form;
 if (l_MainForm = nil) then
  Result := nil
 else
  Result := l_MainForm.History;
end;

function TvcmDispatcher.Get_ActiveEntity: IvcmEntity;
  {-}
var
 l_Form    : TCustomForm;
 l_EForm   : IvcmEntityForm;
 l_Control : TWinControl;
 l_Parent  : TWinControl;
 l_Container: IafwMainFormContainer;
 l_Menu: IvcmMainMenuForChromeLike;
begin
 Result := nil;//f_ActiveEntity;//каждый раз заново определяем _ActiveEntity (временно)
 if (Result = nil) then
 begin
  l_Control := FindControl(Windows.GetFocus);
  if Supports(l_Control, IvcmMainMenuForChromeLike, l_Menu) then
  try
   // новое "вкладочное" главное меню забирает на себя фокус. Нам это не нужно. http://mdp.garant.ru/pages/viewpage.action?pageId=562611367
   // l_Control := f_FocusedControl
   // - фокус не прошел. Построили список, закрыли в нем панель поиска,
   // нажали в меню "файл" - "сохранить в мои документы". В f_FocusedControl - мусор.
   // http://mdp.garant.ru/pages/viewpage.action?pageId=565861782
   l_Control := l_Menu.FocusedControl;
   // - меню знает, что было в фокусе до него - видимо нам это и нужно
  finally
   l_Menu := nil;
  end;
  // else
  // f_FocusedControl := l_Control;
  if (l_Control = nil) and (Form <> nil) then
   l_Control := Form.ActiveControl;
  if Assigned(l_Control) then
  begin
   //Assert(not (l_Control Is TvtCustomPanel),
   //       'http://mdp.garant.ru/pages/viewpage.action?pageId=352452629&focusedCommentId=354683670#comment-354683670');
   // - не прокатил Assert :-(
   l_Parent := l_Control.Parent;
   if (l_Parent <> nil) AND not (l_Parent Is TCustomForm) then
    // - эта ветка нужна для контролов, которые лежат в Toolbar'е - чтобы транслировать
    //   операции той форме, к которой относится контрол.
    if Supports(l_Parent.Owner, IvcmEntityForm, l_EForm) AND
       not l_EForm.InClose then
     Result := l_EForm.Entity;
     //Supports(l_EForm, IvcmEntity, Result);
   if (Result = nil) then
   begin
    if (l_Control Is TvtCustomPanel) then
    begin
     // http://mdp.garant.ru/pages/viewpage.action?pageId=352452629&focusedCommentId=354683670#comment-354683670
     if (l_Control.ControlCount = 1) then
     begin
      if Supports(l_Control.Controls[0], IvcmEntityForm, l_EForm) then
       if l_EForm.IsBaloon then
        Result := l_EForm.Entity;
     end;//l_Control.ControlCount = 1
    end;//l_Control Is TvtCustomPanel
    if (Result = nil) then
    begin
     l_Form := afw.GetParentForm(l_Control);
     if not Supports(l_Form, IvcmEntityForm, l_EForm) OR
        not l_EForm.InClose then
      //Result := l_Form.Entity;
      Supports(l_Form, IvcmEntity, Result)
    end;//Result = nil
   end;//Result = nil
  end;//Assigned(l_Control)
  if not Assigned(Result) and (Form <> nil) then
   Result := Form.Entity;
 end;//Result = nil

 { СТАРЫЙ КОД:

   Result := f_ActiveEntity;
   if (Result = nil) then
    Result := Form As XIvcmEntity;

   Комментарий:
    Изменения сделаны для следующий ситуации:
     1. Открываем модальную форму (f_ActiveEntity = модальная форма);
     2. Закрываем модальную форму (f_ActiveEntity = nil);
     3. Активной форме приложения не пришло уведомление, что она активна
      f_ActiveEntity = nil, а на самом деле f_ActiveEntity = активной форме; }
 if Supports(Result, IafwMainFormContainer, l_Container) then
 try
  l_Form := l_Container.CurrentMainForm;
  if (l_Form <> nil) AND (l_Form is TvcmEntityForm) then
  begin
   Result := TvcmEntityForm(l_Form).As_IvcmEntityForm.Entity;
  end;
 finally
  l_Container := nil;
 end;
end;

function TvcmDispatcher.Get_EntitiesCount: Integer;
  {-}
begin
 Result := f_Entities.Count;
end;

function TvcmDispatcher.Get_Entity(anIndex: Integer): IvcmEntity;
  {-}
begin
 Result := f_Entities[anIndex];
end;

procedure TvcmDispatcher.EntityOperation(const anOp    : TvcmOPID;
                                        const aParams : IvcmParams;
                                        aMode         : TvcmOperationMode);
  {* - выполняет операцию сущности. }

 function TranslateToContainerZone(const aCont : IvcmContainer;
                                   aZone       : TvcmZoneType) : Boolean;
 var
  l_Cont : IvcmContainer;
  l_Form : IvcmEntityForm;
  l_Entity : IvcmEntity;
 begin//TranslateToContainerZone
  Result := false;
  l_Cont := aCont;
  while (l_Cont <> nil) do
  begin
   l_Cont.HasForm(aZone, false, @l_Form);
   if (l_Form = nil) then
    break;

   l_Entity := l_Form.Entity;
   l_Entity.Operation(anOp, aParams, aMode);
   Case aMode of
   vcm_omTest :
    if aParams.Done then
    //if aParams.TestPart.Op.Flag[vcm_ofEnabled] then
    begin
     Result := true;
     break;
    end;//aParams.Done
   vcm_omExecute :
    begin
     if aParams.Done then
     begin
      Result := true;
      break;
     end;//aParams.Done 
    end;//vcm_omExecute
   end;//Case aMode

   if vcmIEQ(l_Form, l_Cont) then
    break;
   if (l_Form.VCLWinControl = l_Cont.AsForm.VCLWinControl) then
    break;
   l_Cont := l_Form.AsContainer;
   //Supports(l_Form, IvcmContainer, l_Cont);
  end;//while l_Cont <> nil
 end;//TranslateToContainerZone

var
 l_Entity      : IvcmEntity;
 l_Form        : IvcmEntityForm;
 l_WasDisabled : Boolean;
 l_MainFormCont : IvcmContainer;
 l_HasModal: Boolean;
begin
 aParams.SetContainerPrim(Form, false);
 l_Entity := ActiveEntity;
 aParams.DoneStatus := vcm_dsNotDone;
 Case aMode of
  vcm_omTest :
   aParams.TestPart.Op.Flag[vcm_ofEnabled] := false;
 end;//Case aMode
 l_WasDisabled := false;
 l_HasModal := false;
 while (l_Entity <> nil) do
 begin
  l_Entity.Operation(anOp, aParams, aMode);
  Case aMode of
  vcm_omTest :
   if aParams.Done then
   //if aParams.TestPart.Op.Flag[vcm_ofEnabled] then
    break;
  vcm_omExecute :
   begin
    if aParams.Done then
     break;
   end;//vcm_omExecute
  end;//Case aMode
  if (aParams.DoneStatus = vcm_dsDisabled) then
   l_WasDisabled := true;
   // - операция типа есть, но запрещена
  l_Form := l_Entity.AsForm;
  if (l_Form <> nil) then
   try
    l_Entity := nil;
    l_HasModal := l_HasModal or l_Form.IsModal;
    if l_HasModal AND (aMode <> vcm_omTest) then
    begin
     Assert(l_Form.VCLWinControl.Visible, Format('Попытка выполнить операцию на невидимой модальной форме (%s), которая наверное закрывается. См. http://mdp.garant.ru/pages/viewpage.action?pageId=427756504&focusedCommentId=427759367#comment-427759367', [l_Form.VCLWinControl.Name]));
    end;//l_HasModal
    if (not l_Form.IsModal or (aMode = vcm_omTest)) AND
       not l_WasDisabled AND
       // - если САМА форма не модальная или тестируем операцию (cq24729), то надо передать операцию родителю
       Supports(afw.GetAnotherParentForm(l_Form.VCLWinControl), IvcmEntityForm, l_Form) then
     try
      l_Entity := l_Form.Entity;
     finally
      l_Form := nil;
     end;//try..finally
   finally
    l_Form := nil;
   end//try..finally
  else
   l_Entity := nil;
 end;//while (l_Entity <> nil)
 if (not l_HasModal) and (aParams.DoneStatus in [vcm_dsExcludedInUserType, vcm_dsNoEntity]) then
 begin
  if l_WasDisabled then
  begin
   // - операция запрещена, а вверх никого не нашли
   aParams.DoneStatus := vcm_dsDisabled;
   // - надо сообщить что ShortCut обрабатывать не надо
  end//l_WasDisabled
  else
  begin
  // - здесь пытаемся транслировать оперцию форме в Parent-зоне.
   if Supports(Get_CurrentMainForm, IvcmContainer, l_MainFormCont) then
   begin
//    TranslateToContainerZone(l_MainFormCont, _vcm_ztParent);
    TranslateToContainerZone(l_MainFormCont, vcm_ztMainObjectForm);
    if not aParams.Done and (aParams.DoneStatus in [vcm_dsNoEntity]) then
    begin
    // - типа перенаправляем из баллона в основную форму
     if not l_MainFormCont.AsForm.Entity.Operation(anOp, aParams, aMode) then
     begin
      if not aParams.Done and (aParams.DoneStatus in [vcm_dsNoEntity]) then
      begin
       // - типа перенаправляем из баллона в его владельца
       l_Entity := ActiveEntity;
       l_Form := l_Entity.AsForm;
       if (l_Form <> nil) then
        if l_Form.IsBaloon then
         if Supports(l_Form.VCLWinControl.Owner, IvcmEntity, l_Entity) then
          l_Entity.Operation(anOp, aParams, aMode);
      end;//not aParams.Done and (aParams.DoneStatus in [vcm_dsNoEntity])
     end;//not l_MainFormCont.AsForm.Entity.Operation(anOp, aParams, aMode)
    end;//not aParams.Done and (aParams.DoneStatus in [vcm_dsNoEntity])
   end;//Supports(Get_CurrentMainForm, IvcmContainer, l_Cont)
  end;//l_WasDisabled
 end;//aParams.DoneStatus in [vcm_dsExcludedInUserType, vcm_dsNoEntity]
end;

function TvcmDispatcher.EntityOperation(const anOp    : TvcmOPID;
                                        const aParams : IvcmExecuteParams): Boolean;
  //overload;
  {* - выполняет операцию сущности. }
begin
 Assert(anOp.rEnID > 0);
 Assert(anOp.rOpID > 0);
 EntityOperation(anOp, aParams.BasePart, vcm_omExecute);
 Result := aParams.DoneStatus in [vcm_dsDone, vcm_dsDisabled];
end;

procedure TvcmDispatcher.EntityOperation(const anOp    : TvcmOPID;
                                        const aParams : IvcmTestParams);
  //overload;
  {* - выполняет операцию сущности. }
begin
 Assert(anOp.rEnID > 0);
 Assert(anOp.rOpID > 0);
 EntityOperation(anOp, aParams.BasePart, vcm_omTest);
end;

procedure TvcmDispatcher.EntityOperationBroadcast(const anOp    : TvcmOPID;
                                                 const aParams : IvcmExecuteParams);
  //overload;
  {-}
{$IfNDef DesignTimeLibrary}

type
 PIvcmEntity = ^IvcmEntity;

  //function DoIt(anItem: PIUnknown; anIndex: Integer): Boolean;
  function DoIt(anItem: PIvcmEntity; anIndex: Integer): Boolean;
(*  var
   l_Entity : IvcmEntity;*)
  begin//DoIt
   Result := true;
   aParams.DoneStatus := vcm_dsNotDone;
   anItem^.Operation(anOp, aParams);
(*   if Supports(anItem^, IvcmEntity, l_Entity) then
    try
     l_Entity.Operation(anOp, aParams);
    finally
     l_Entity := nil;
    end;//try..finally*)
  end;//DoIt

  function DoIt1(anItem: PIvcmEntityForm; anIndex: Integer): Boolean;
  begin//DoIt1
   Result := true;
   aParams.DoneStatus := vcm_dsNotDone;
   anItem^.Entity.Operation(anOp, aParams);
  end;//DoIt1

var
 l_CloneList  : TvcmIEntityList;
{$EndIf DesignTimeLibrary}
begin
 {$IfNDef DesignTimeLibrary}
 Assert(anOp.rEnID > 0);
 Assert(anOp.rOpID > 0);
 BeginOp;
 // - фиксируем набор форм
 try
  aParams.DoneStatus := vcm_dsNotDone;
  // в процессе пробегания по листу, список f_Entities может изменяться
  {$IfNDef DesignTimeLibrary}
  l_CloneList := f_Entities.Clone;
  {$Else  DesignTimeLibrary}
  l_CloneList := nil;
  {$EndIf DesignTimeLibrary}
  try
   l_CloneList.IterateAllF(l3L2IA(@DoIt));
  finally
   vcmFree(l_CloneList);
  end;//try..finally
  f_MainForms.IterateAllF(l3L2IA(@DoIt1));
 finally
  EndOp;
 end;//try..finally
 {$EndIf DesignTimeLibrary}
end;

procedure TvcmDispatcher.ModuleOperation(const anOp    : TvcmMOPID;
                                        const aParams : IvcmParams;
                                        aMode         : TvcmOperationMode);
  //overload;
  {* - выполняет операцию модуля. }
var
 l_Module : IvcmModule;
begin
 aParams.SetContainerPrim(Form, false);
 l_Module := GetModuleByID(anOp.rMoID);
 if (l_Module = nil) then
 begin
  Case aMode of
   vcm_omTest :
    aParams.TestPart.Op.Flag[vcm_ofEnabled] := false;
   vcm_omExecute :
    aParams.DoneStatus := vcm_dsNotDone;
  end;//Case aMode
 end//l_Module = nil
 else
  l_Module.Operation(anOp.rOpID, aParams, aMode);
end;

procedure TvcmDispatcher.CallModuleOperation(const anOp    : TvcmMOPID;
                                        const aParams : IvcmExecuteParams);
  {* - выполняет операцию модуля. }
begin
 Assert(anOp.rMoID > 0);
 Assert(anOp.rOpID > 0);
 ModuleOperation(anOp, aParams.BasePart, vcm_omExecute);
end;

procedure TvcmDispatcher.ModuleOperation(const anOp    : TvcmMOPID;
                                        const aParams : IvcmTestParams);
  {* - выполняет операцию модуля. }
begin
 Assert(anOp.rMoID > 0);
 Assert(anOp.rOpID > 0);
 ModuleOperation(anOp, aParams.BasePart, vcm_omTest);
end;

function TvcmDispatcher.ModuleOperation(const anOp : TvcmMOPID): Boolean;
  //overload;
  {* - выполняет операцию модуля. }
var
 l_P : IvcmExecuteParams;
begin
 l_P := vcmParams;
 ModuleOperation(anOp, l_P.BasePart, vcm_omExecute);
 Result := l_P.DoneStatus in [vcm_dsDone, vcm_dsDisabled];
end;

function TvcmDispatcher.GetModuleByID(aModuleID: TvcmControlID): IvcmModule;
  {* - возвращает модуль по идентификатору. }
begin
 Result := TvcmModule.GetModuleByID(aModuleID);
end;

function TvcmDispatcher.Get_ModulesCount: Integer;
  {* - возвращает количество зарегистрированных модулей. }
begin
 Result := TvcmModule.GetModuleCount;
end;

function TvcmDispatcher.Get_Module(anIndex: Integer): IvcmModule;
  {* - возвращает модуль по индексу. }
begin
 Result := TvcmModule.GetModule(anIndex);
end;

function TvcmDispatcher.pm_GetMainFormProvider: IvcmMainFormProvider;
  {-}
begin
 Result := IvcmMainFormProvider(f_MainFormProvider);
end;

procedure TvcmDispatcher.pm_SetMainFormProvider(const aValue: IvcmMainFormProvider);
  {-}
begin
 if (f_MainFormProvider <> Pointer(aValue)) then
  f_MainFormProvider := Pointer(aValue);
end;

procedure TvcmDispatcher.UpdateStatus;
  {-}
begin
 if (afw.Application <> nil) AND
    (afw.Application.CurrentMainForm <> nil) AND
    (afw.Application.CurrentMainForm.Status <> nil) then
 begin
  if pm_GetIsLockActionUpdate then
   f_NeedUpdateStatus := True
  else
   afw.Application.CurrentMainForm.Status.Update;
 end
end;

procedure TvcmDispatcher.AddAggregate(const anAggregate: IvcmAggregate);
  {-}
begin
 if (f_Aggregates = nil) then
  f_Aggregates := TvcmAggregateRefList.MakeSorted;
 f_Aggregates.Add(anAggregate); 
end;

procedure TvcmDispatcher.RemoveAggregate(const anAggregate: IvcmAggregate);
  {-}
begin
 f_Aggregates.Remove(anAggregate);
end;

function TvcmDispatcher.FindAggregate(const aGUID      : TGUID;
                                      out theAggregate : IvcmAggregate): Boolean;
  {-}
var
 l_Index : Integer;
begin
 Result := false;
 if (f_Aggregates <> nil) then
  with f_Aggregates do
   for l_Index := Lo to Hi do
   begin
    theAggregate := Items[l_Index];
    if IsEqualGUID(theAggregate.GUID, aGUID) then
    begin
     Result := true;
     break;
    end;//IsEqualGUID(anAggregate.GUID, aGUID)
   end;//for l_Index
end;

procedure TvcmDispatcher.BeginOp(anInternal: Boolean = false);
  {-}
begin
 if (f_Op = 0) then
  f_InternalOp := anInternal; 
 Inc(f_Op);
end;

procedure TvcmDispatcher.EndOp;
  {-}

 function l_FreeObject(anObj: PObject; anIndex: Integer): Boolean;
 var
  l_Object : TObject;
 begin//l_FreeObject
  Result := true;
  l_Object := anObj^;
  f_ObjectsForFree.Delete(anIndex);
  vcmFree(l_Object);
 end;//l_FreeObject

 function l_CloseForm(aForm: PIvcmEntityForm; anIndex: Integer): Boolean;
 var
  l_Form : TCustomForm;
 begin//l_CloseForm
  Result := true;
  l_Form := aForm^.VCLWinControl As TCustomForm;
  f_FormsForClose.Delete(anIndex);
  if (l_Form Is TvcmForm) then
   TvcmForm(l_Form).SafeClose
  else
   l_Form.Free;
 end;//l_CloseForm

begin
 if (f_Op <= 1) then
 begin
  if (f_ObjectsForFree <> nil) then
   f_ObjectsForFree.IterateAllF(l3L2IA(@l_FreeObject));
  if (f_FormsForClose <> nil) then
   f_FormsForClose.IterateAllF(l3L2IA(@l_CloseForm));
 end;//f_Op <= 0
 // Уменьшаем здесь осознано, чтобы защитить повторный вызов кода выше
 Dec(f_Op);
 Assert(f_Op >= 0);
end;

function TvcmDispatcher.InOp(anInternal: Boolean = false): Boolean;
  {-}
begin
 if f_LockInOpCount > 0 then
  Result := False
 else
 if anInternal then
 begin
  if f_InternalOp then
   Result := false
  else
   Result := (f_Op > 0);
 end//anInternal
 else
  Result := (f_Op > 0);
end;

// start class TvcmMainForm

{$IfDef vcmExportHelp}
procedure TvcmMainForm.DoExportRes(const aWriter : IvcmXMLWriter; aSaveStrings : Boolean);
  {-}

 {$IfDef vcmExportHelp}
(* procedure OutSetForms(aForms: TvcmFormSetFormsCollection);
 var
  l_F : TvcmFormSetFormsCollectionItem;
  l_I : Integer;
 begin//OutSetForms
  if (aForms <> nil) AND (aForms.Count > 0) then
  begin
   with f_HelpOut do
   begin
    OpenLevel('forms');
    try
     for l_I := 0 to Pred(aForms.Count) do
     begin
      l_F := TvcmFormSetFormsCollectionItem(aForms.Items[l_I]);
      OpenSubLevel(Format(cTitID + ' zone="%s"', [l_F.FormDescriptor.rName, l_F.Name, GetEnumName(TypeInfo(TvcmZoneType), Ord(l_F.ZoneType))]));
      try
       OutSetForms(l_F.Childs As TvcmFormSetFormsCollection);
      finally
       CloseLevel;
      end;//try..finally
     end;//for l_I
    finally
     CloseLevel;
    end;//try..finally
   end;//with f_HelpOut
  end;//aForms <> nil
 end;//OutSetForms*)
 {$EndIf vcmExportHelp}

 {$IfDef vcmExportHelp}
var 
 l_Ver     : String;
 l_Index   : Integer;
// l_FS      : TvcmFormSetFactoriesCollectionItem;
 l_F       : TvcmFormSetFactory;
 l_Message : String;
 l_B       : Integer;
 {$EndIf vcmExportHelp}
begin
 f_HelpOut := aWriter;
  {$IfDef vcmExportHelp}
   with TVersionInfo.Create do
   try
    if (FixedFileInfo <> nil) then
     with FileLongVersion do
     begin
      {$IfDef InsiderTest}
      l_B := 666;
      {$Else  InsidefTest}
      l_B := All[3];
      {$EndIf InsidefTest}
      l_Ver := Format('versionmajor="%d" versionminor="%d" release="%d" build="%d"',
                      [All[2], All[1], All[4], l_B]);
     end;//with FileLongVersion
   finally
    Free;
   end;//try..finally
  {$EndIf vcmExportHelp}
 try
  with f_HelpOut do
  begin
   Start;
   try
    OpenLevel('application', Format(cTit + ' exename="%s" %s',
                                    [CS(Application.Title), CS(ExtractFileName(Application.ExeName)), l_Ver]));
    try
     if (MenuManager Is TvcmCustomMenuManager) AND
        (TvcmCustomMenuManager(MenuManager).MainMenuItems <> nil) AND
        (TvcmCustomMenuManager(MenuManager).MainMenuItems.Count > 0) then
     begin
      OpenLevel('menu');
      try
       with TvcmCustomMenuManager(MenuManager).MainMenuItems do
        for l_Index := 0 to Pred(Count) do
        begin
         with TvcmMenuItemsCollectionItem(Items[l_Index]) do
         begin
          if (CS(Name) = '') then
           OpenLevel(c_vcmMenuItem, Format(cTit, [CS(Caption)]))
          else
           OpenLevel(c_vcmMenuItem, Format(cTitID, [CS(Caption), CS(Name)]));
          try
          finally
           CloseLevel;
          end;//try..finally
         end;//with TvcmMenuItemsCollectionItem(Items[l_Index])
        end;//for l_Index
      finally
       CloseLevel;
      end;//try..finally
     end;//MenuManager Is TvcmCustomMenuManager..
     OpenLevel(c_vcmModule+'s');
     try
      UpdateMainCaption;
      OpenLevel(c_vcmModule,
                Format(cTitID, [Trim(ev_psPrefix(Self.CaptionForSaving, '-')),
                                Self.FormID.rName]));
                                // - http://mdp.garant.ru/pages/viewpage.action?pageId=564737453 
      try
       OpenLevel('forms');
       try
        SaveForm(Self, true, aSaveStrings);
       finally
        CloseLevel;
       end;//try..finally
      finally
       CloseLevel;
      end;//try..finally
      RegisterModules;
     finally
      CloseLevel;
     end;//try..finally
     if (MenuManager.Messages <> nil) AND (MenuManager.Messages.Count > 0) then
     begin
      OpenLevel(c_vcmMessage+'s');
      try
       with MenuManager.Messages do
        for l_Index := 0 to Pred(Count) do
        begin
         with TvcmMessagesCollectionItem(Items[l_Index]) do
         begin
          l_Message := Format(cTitID + ' %s="%s" %s="%s" %s="%s"',
                              [CS(Caption), CS(Name),
                               c_vcmLongCaption, CS(SettingsCaption),
                               c_vcmLongHint, CS(LongHint),
                               c_vcmCustomButtonCaption, CS(CustomButtonCaption)]);
          OpenSubLevel(l_Message);
          try
           ; 
          finally
           CloseLevel;
          end;//try..finally
         end;//with TvcmMessagesCollectionItem(Items[l_Index])
        end;//for l_Index
      finally
       CloseLevel;
      end;//try..finally
     end;//MenuManager.Messages <> nil..
(*     if (MenuManager.FormSetFactories <> nil) and (MenuManager.FormSetFactories.Count > 0) then
     begin
      OpenLevel(c_vcmFormSetFactory+'s');
      try
       with MenuManager.FormSetFactories do
        for l_Index := 0 to Pred(Count) do
        begin
         l_FS := TvcmFormSetFactoriesCollectionItem(Items[l_Index]);
         with l_FS do
         begin
          OpenSubLevel(Format(cID, [CS(Name)]));
          //OpenSubLevel(Format(cTitID, [CS(Caption), CS(Name)]));
          try
           l_F := TvcmFormSetFactory.FactoryById(FactoryId);
           if (l_F <> nil) then
           begin
            OutSetForms(l_F.Forms);
           end;//l_F <> nil
          finally
           CloseLevel;
          end;//try..finally
         end;//with TvcmFormSetFactoriesCollectionItem(Items[l_Index])
        end;//for l_Index
      finally
       CloseLevel;
      end;//try..finally
     end;//MenuManager.FormSetFactories <> nil..*)
     if aSaveStrings then
      if (MenuManager.Strings <> nil) AND (MenuManager.Strings.Count > 0) then
      begin
       OpenLevel(c_vcmString+'s');
       try
        with MenuManager.Strings do
         for l_Index := 0 to Pred(Count) do
         begin
          with Items[l_Index] do
          begin
           OpenSubLevel(Format(cTitID, [CS(Caption), CS(Name)]));
           try
            ;
           finally
            CloseLevel;
           end;//try..finally
          end;//with Items[l_Index]
         end;//for l_Index
       finally
        CloseLevel;
       end;//try..finally
      end;//MenuManager.Strings <> nil..
 //    SaveEntities(GetEntitiesDefIterator, Self);
    finally
     CloseLevel;
    end;//try..finally
   finally
    Finish;
   end;//try..finally
  end;//with f_HelpOut
 finally
  f_HelpOut := nil;
 end;//try..finally
end;//DoExportRes

procedure TvcmMainForm.DoExportHelp(const aFileName : String; aSaveStrings : Boolean);
  {-}
var
 l_Old : Boolean;  
begin
 l_Old := f_NeedExportHelp;
 f_NeedExportHelp := true;
 try
  DoExportRes(TvcmXMLWriter.Make(aFileName), aSaveStrings);
 finally
  f_NeedExportHelp := l_Old;
 end;//try..finally
end;
{$EndIf vcmExportHelp}

constructor TvcmMainForm.Create(anOwner: TComponent);

var
 l_NeedSubscribe : Boolean;
begin
 f_TasksPanelZone := -1;
 l_NeedSubscribe := (vcmBase.g_Dispatcher = nil);
 if not (csDesigning in ComponentState) then
 begin
  if (g_Dispatcher = nil) then
   g_Dispatcher := Dispatcher
  else
   f_Dispatcher := g_Dispatcher;
 end;//not (csDesigning in ComponentState)
 inherited Create(anOwner);
 {$IfDef vcmUseSettings}
 InitSettingsSource;
 {$EndIf vcmUseSettings}
 if not (csDesigning in ComponentState) then
 begin
  // отбиваем линией чтобы компоненты формы были отделены от командного меню
  with TBevel.Create(Self) do
  begin
   Parent := Self;
   Shape  := bsTopLine;
   Height := 1;
   Align  := alTop;
  end;//with TBevel.Create(Self)
  if l_NeedSubscribe then
   Self.DispatcherCreated;
  if (anOwner <> nil) then
   DoLoadFromSettings;
  {$IfNDef DesignTimeLibrary}
  MenuManager.MainCreated(Self);
  {$EndIf  DesignTimeLibrary}
  afw.ProcessMessages;
  MenuManager.PostBuild(Self);
  afw.ProcessMessages;
 end;//not (csDesigning in ComponentState)..
 DoUpdateMainCaptionPrefix;
 {$IfDef vcmExportHelp}
 f_NeedExportHelp := AnsiSameText(ParamStr(1), '-vcmExportHelp');
 f_NeedExportContent := AnsiSameText(ParamStr(1), '-vcmExportContent');
 if f_NeedExportHelp or f_NeedExportContent then
 begin
  if f_NeedExportHelp then
   DoExportRes(TvcmXMLWriter.Make(ChangeFileExt(Application.ExeName, '.res.xml')), true)
  else
  if f_NeedExportContent then
   DoExportRes(TvcmContentWriter.Make(ChangeFileExt(Application.ExeName, '.res.lng')), true);
  SaveBitmaps;
 end//f_NeedExportHelp or f_NeedExportContent
 else
 begin
 {$EndIf vcmExportHelp}
  RegisterModules;
  afw.ProcessMessages;
 {$IfDef vcmExportHelp}
  {$IfDef InsiderTest}
  f_ModulesRegistered := true;
  {$EndIf InsiderTest}
 end;//f_NeedExportHelp
 {$EndIf vcmExportHelp}
 if not (csDesigning in ComponentState) then begin
  Dispatcher.FormDispatcher.AddForm(Self.As_IvcmEntityForm);
  MenuManager.RegisterMainInMenu(Self);
  CreateGUID(f_GUID);
 end;//not (csDesigning in ComponentState)
 CallDoInit(false);
// MakeContainer;
end;

function TvcmMainForm.MakeClone(aNeedShow: Boolean = True): TvcmMainForm;
  {-}
begin
 Result := DoMakeClone(aNeedShow);
end;

function TvcmMainForm.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {-}
begin
 if IID.EQ(IvcmMainForm) then
 begin
  if (f_Form = nil) then
   Result.SetNoInterface
  else
   Result := Tl3HResult_C(f_Form.QueryInterface(IID.IID, Obj))
 end//IID.EQ(IvcmMainForm)
 else
  Result := inherited COMQueryInterface(IID, Obj);
end;

procedure TvcmMainForm.DoGiveFocusToZone;
{* - если фокус находится у главной формы, то она передаёт его
     определенной зоне. }
begin
 if (Handle = GetFocus) then
  Self.SetFocusToMainObjectForm;
end;

procedure TvcmMainForm.UpdateActions;
  //override;
  {-}
var
 l_Menu  : TMenuItem;
 l_Item  : TMenuItem;
 l_Index : Integer;
begin
 inherited;
 if (csDesigning in ComponentState) or
    (csDestroying in ComponentState) then
  Exit;
 if (Menu <> nil) AND not VCMClosing then
 begin
  l_Menu := Menu.Items;
  if (l_Menu <> nil) then
   for l_Index := 0 to Pred(l_Menu.Count) do
   begin
    l_Item := l_Menu[l_Index];
    if (l_Item <> nil) AND not l_Item.Visible then
     l_Item.InitiateAction;
   end;//for l_Index
 end;//Menu <> nil
end;

procedure TvcmMainForm.RestoreFormSize;
{* - перечитывает размер формы, сначала на основе информации
     Design-Time, потом из настроек. }
begin
 (* Прочитаем размер из настроек *)
 if not vcmLoadFormStateAndBounds(Self) then
  (* Установим размер на основе Design-Time информации *)
 begin
  WindowState := f_FormInfo.rWindowState;
  if WindowState <> wsMaximized then
   BoundsRect := f_FormInfo.rBounds;
 end;
 (* Восстановим размер компонентов *)
 RestoreControlSize;
end;

procedure TvcmMainForm.ReloadToolbars;
  //override;
  {-}
var
 l_Form     : IvcmEntityForm;
 l_UserType : IvcmUserTypeDef;
 l_Index    : Integer;
begin
 l_UserType := CurUserTypeDef;
 if (l_UserType <> nil) then
 begin
  with Dispatcher.FormDispatcher do
   for l_Index := 0 to Pred(MainFormsCount) do
   begin
    l_Form := MainForm[l_Index];
    with l_Form do
    begin
     if (UserType = l_UserType.ID) AND
        VCLWinControl.InheritsFrom(l_UserType.FormClass) then
     begin
      MenuManager.ReloadToolbars(l_Form);
      // - здесь надо перегрузить Toolbar'ы
     end;//UserType = l_UserType.ID..
    end;//with l_Form
   end;//for l_Index
 end;//l_UserType <> nil
end;

procedure TvcmMainForm.Cleanup;
  //override;
  {-}
begin
 vcmFree(f_TasksPanel);
 // Надо сбросить FocusedControl и ActiveControl
 // Иначе ездим по памяти при закрытии форм в области навигатора.
// DefocusControl(Self, True);
 Status := nil;
 StatusBar := nil;
 f_StatusElement := nil;
 f_CaptionPrefix := nil;
 vcmFree(f_History);
 Dispatcher.FormDispatcher.RemoveForm(Self.As_IvcmEntityForm);
 inherited;
 if not SDI AND vcmIEQ(vcmBase.g_Dispatcher, f_Dispatcher) then
  vcmBase.g_Dispatcher := nil;
 f_Dispatcher := nil;
end;

{$IfDef vcmExportHelp}
function TvcmMainForm.SaveForm(aForm : TvcmEntityForm; aNeedCutCaption : Boolean; aSaveControls : Boolean): Boolean;
  {-}
var
 l_Index   : Integer;
 l_Suffix  : AnsiString;
 l_UT      : TvcmUserTypesCollectionItem;
 l_Control : TComponent;
 l_Cont    : Integer;
 l_MainForm: Integer;
 l_Items   : TObject;
 l_Text    : AnsiString;
 l_SIndex  : Integer;
 l_Cap     : AnsiString;
begin
 if (aForm = nil) then
  Result := false
 else
 begin
  Result := true;
  l_Cont := Ord((aForm Is TvcmContainerForm));
  l_MainForm := Ord((aForm Is TvcmMainForm));
  with f_HelpOut do
  begin
   l_Cap := aForm.CaptionForSaving;
   // - http://mdp.garant.ru/pages/viewpage.action?pageId=564737453
   if aNeedCutCaption then
    l_Cap := Trim(ev_psPrefix(l_Cap, '-'));
   OpenLevel(c_vcmForm, Format(cTitID + ' %s="%d" %s="%d"',
                            [CS(l_Cap),
                             CS(aForm.FormID.rName),
                             c_vcmContainerForm,
                             l_Cont,
                             c_vcmMainForm,
                             l_MainForm]));
   try
    if (aForm.UserTypes <> nil) AND
       (aForm.UserTypes.Count > 0) then
    begin
     OpenLevel(c_vcmUserType+'s');
     try
      with aForm.UserTypes do
       for l_Index := 0 to Pred(Count) do
       begin
        l_UT := TvcmUserTypesCollectionItem(Items[l_Index]);
        if (l_UT <> nil) then
        begin
         l_Suffix := Format(cTitID, [CS(l_UT.Caption), CS(l_UT.Name)]);
         if (l_UT.ImageIndex > 0) then
          l3CatSuff(l_Suffix, Format('%s="%d.bmp"', [c_vcmUserTypeIcon, l_UT.ImageIndex]));
         l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmLongCaption, CS(l_UT.SettingsCaption)]));
         l3CatSuff(l_Suffix, Format('%s="%d"', [c_vcmEditableUserType, ord(l_UT.AllowCustomizeToolbars)]));
         if l_UT.UseToolbarOfUserTypeName <> '' then
          l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmParentUserType, l_UT.UseToolbarOfUserTypeName]));
         OpenSubLevel(l_Suffix);
         try
          ;
         finally
          CloseLevel;
         end;//try..finally
        end;//l_UT <> nil
       end;//for l_Index
     finally
      CloseLevel;
     end;//try..finally
    end//aForm.UserTypes <> nil
    else
    begin
     OpenLevel(c_vcmUserType+'s');
     try
      OpenSubLevel(Format(cTitID, [CS(aForm.Caption), CS(aForm.Name)]));
      try
       ;
      finally
       CloseLevel;
      end;//try..finally
     finally
      CloseLevel;
     end;//try..finally
    end;//aForm.UserTypes <> nil
    if aSaveControls AND (aForm.ComponentCount > 0) then
    begin
     OpenLevel(c_vcmControl+'s');
     try
      for l_Index := 0 to Pred(aForm.ComponentCount) do
      begin
       l_Control := aForm.Components[l_Index];
       if (l_Control Is TControl)
          {$IfNDef NoVGScene}
          or (l_Control Is TvgControl)
          {$EndIf  NoVGScene}
          then
       begin
        if (GetPropInfo(l_Control, c_vcmCaption) = nil) then
         l_Suffix := ''
        else
         l_Suffix := Format(cTit, [CS(GetStrProp(l_Control, c_vcmCaption))]);
        l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmID, CS(l_Control.Name)]));
        if (GetPropInfo(l_Control, c_vcmText) <> nil) then
         l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmText, CS(GetStrProp(l_Control, c_vcmText))]));
        if (GetPropInfo(l_Control, c_vcmHint) <> nil) then
         l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmHint, CS(GetStrProp(l_Control, c_vcmHint))]));
        if (GetPropInfo(l_Control, c_vcmEmptyHint) <> nil) then
         l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmEmptyHint, CS(GetStrProp(l_Control, c_vcmEmptyHint))]));
        if (GetPropInfo(l_Control, c_vcmFooterCaption) <> nil) then
         l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmFooterCaption, CS(GetStrProp(l_Control, c_vcmFooterCaption))]));
        if (GetPropInfo(l_Control, c_vcmItems) <> nil) then
        begin
         l_Items := GetObjectProp(l_Control, c_vcmItems);
         if (l_Items <> nil) then
         begin
          l_Text := '';
          if (GetPropInfo(l_Items, c_vcmStrings) <> nil) then
           l_Text := GetStrProp(l_Items, c_vcmStrings)
          else
          if (l_Items Is TStrings) then
          begin
           for l_SIndex := 0 to Pred(TStrings(l_Items).Count) do
           begin
            if (l_Text <> '') then
             l_Text := l_Text + #13#10;
            l_Text := l_Text + TStrings(l_Items)[l_SIndex];
           end;//for l_SIndex
          end//l_Items Is TStrings
          else
          if (l_Items Is Tl3Strings) then
          begin
           for l_SIndex := 0 to Pred(Tl3Strings(l_Items).Count) do
           begin
            if (l_Text <> '') then
             l_Text := l_Text + #13#10;
            l_Text := l_Text + vcmStr(Tl3Strings(l_Items).ItemC[l_SIndex]);
           end;//for l_SIndex
          end//(l_Items Is Tl3Strings)
          ;
          if (l_Text <> '') then
           l3CatSuff(l_Suffix, Format('%s%s="%s"', [c_vcmItems, c_vcmText, CS(l_Text)]))
         end;//l_Items <> nil
        end;//GetPropInfo(l_Control, c_vcmItems) <> nil
//        l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmAdditionalInfo, CS(aForm.GetLocalizationInfo(l_Control))]));
        OpenSubLevel(l_Suffix);
        try
         ;
        finally
         CloseLevel;
        end;//try..finally
       end;//l_Control <> nil
      end;//for l_Index
     finally
      CloseLevel;
     end;//try..finally
    end;//aForm.ComponentCount > 0
    SaveEntities(aForm.GetEntitiesDefIterator, aForm);
   finally
    CloseLevel;
   end;//try..finally
  end;//with f_HelpOut
 end;//anOp = nil
end;

procedure TvcmMainForm.SaveForms(aList: TvcmClassList);
  {-}
var
 l_Index : Integer;
 l_Form  : TvcmEntityForm;
begin
 if not aList.Empty then
 begin
  with f_HelpOut do
  begin
   OpenLevel('forms');
   try
    with aList do
     for l_Index := Lo to Hi do
     begin
      l_Form := RvcmEntityForm(Items[l_Index]).Create(nil);
      try
       SaveForm(l_Form, false, true);
      finally
       FreeAndNil(l_Form);
      end;//try..finally
     end;//for l_Index
   finally
    CloseLevel;
   end;//try..finally
  end;//with f_HelpOut
 end;//not aList.Empty
end;

function TvcmMainForm.SaveEntity(const anOp : IvcmEntityDef;
                                 aForm      : TCustomForm): Bool;
  {-}
var
 l_EntitiesCollectionItem : TvcmBaseEntitiesCollectionItem;
 l_ControlsCollectionItem : TvcmControlsCollectionItem;
 l_Index                  : Integer;
 l_Control                : TComponent;
begin
 if (anOp = nil) then
  Result := false
 else
 begin
  Result := true;
  if not l3Same(anOp.Caption, anOp.Name, true) then
  begin
   with f_HelpOut do
   begin
    SaveUF(c_vcmEntity, anOp, false);
    try
     SaveOperations(anOp.OperationsDefIterator, aForm);
     if (aForm Is TvcmEntityForm) then
     begin
      l_EntitiesCollectionItem := TvcmEntityForm(aForm).Entities.GetItemByName(anOp.Name);
      if (l_EntitiesCollectionItem <> nil) then
      begin
       if (l_EntitiesCollectionItem.Controls <> nil) AND
          (l_EntitiesCollectionItem.Controls.Count > 0) then
       begin
        OpenLevel(c_vcmControl+'s');
        try
         with l_EntitiesCollectionItem.Controls do
          for l_Index := 0 to Pred(Count) do
          begin
           l_ControlsCollectionItem := TvcmControlsCollectionItem(Items[l_Index]);
           if (l_ControlsCollectionItem <> nil) then
           begin
            l_Control := l_ControlsCollectionItem.Control;
            if (l_Control = nil) then
             l_Control := aForm;
            OpenSubLevel(Format('%s="%s"', [c_vcmID, CS(l_Control.Name)]));
            try
             ;
            finally
             CloseLevel;
            end;//try..finally
           end;//l_ControlsCollectionItem <> nil
          end;//for l_Index
        finally
         CloseLevel;
        end;//try..finally
       end;//l_EntitiesCollectionItem.Controls <> nil..
      end;//l_EntitiesCollectionItem <> nil
     end;//aForm Is TvcmEntityForm
    finally
     CloseLevel;
    end;//try..finally
   end;//with f_HelpOut 
  end;//not l3Same(anOp.Caption, anOp.Name) <> 0
 end;//anOp = nil
end;

procedure TvcmMainForm.SaveEntities(const anOps : IvcmEntitiesDefIterator;
                                    aForm       : TCustomForm);
  {-}
begin
 if (anOps <> nil) then
 begin
  with f_HelpOut do
  begin
   OpenLevel(c_vcmEntities);
   try
    while SaveEntity(anOps.Next, aForm) do;
   finally
    CloseLevel;
   end;//try..finally
  end;//with f_HelpOut
 end;//anOps <> nil
end;

function TvcmMainForm.SaveOperation(const anOp : IvcmOperationDef;
                                    aForm      : TCustomForm): Bool;
  {-}
var
 l_OO     : TvcmOperationOption;
 l_Suffix : AnsiString;
 l_S      : AnsiString;
 l_UT     : TvcmEffectiveUserType;
 l_Ex     : TvcmOperationOptions;
 l_MM     : TvcmCustomMenuManager;
 l_St     : Integer;
begin
 if (anOp = nil) then
  Result := false
 else
 begin
  Result := true;
  if not (anOp.OperationType in vcm_InternalOperations) then
  begin
   l_Suffix := '';
   l_Ex := [];
   if (MenuManager Is TvcmCustomMenuManager) then
   begin
    l_MM := TvcmCustomMenuManager(MenuManager);
    if (aForm = nil) then
    begin
     // - это модуль
     l_Ex := [vcm_ooShowInChildToolbar,
              vcm_ooShowInContextMenu,
              vcm_ooShowInChildMenu];
     if not (vcm_toModulesInMainToolbar in l_MM.ToolbarOptions) then
      Include(l_Ex, vcm_ooShowInMainToolbar);
    end//aForm = nil
    else 
    if (aForm = Self) then
    begin
     // - это основная форма
     l_Ex := [vcm_ooShowInChildToolbar,
              vcm_ooShowInContextMenu,
              vcm_ooShowInChildMenu];
    end//aForm = Self
    else
    begin
     // - это форма сущности
     Include(l_Ex, vcm_ooShowInMainToolbar);
     Include(l_Ex, vcm_ooShowInChildMenu);
(*     if (anOp.ImageIndex < 0) then
      Include(l_Ex, vcm_ooShowInChildToolbar);*)
     // - это потеряло актуальность 
(*     if not (vcm_toEntitiesInChildToolbar in l_MM.ToolbarOptions) then
      Include(l_Ex, vcm_ooShowInChildToolbar);
     if not (vcm_toEntitiesInMainToolbar in l_MM.ToolbarOptions) then
      Include(l_Ex, vcm_ooShowInMainToolbar);
     if not (vcm_moEntitiesInMainMenu in l_MM.MenuOptions) then
      Include(l_Ex, vcm_ooShowInMainMenu);
     if not (vcm_moEntitiesInChildMenu in l_MM.MenuOptions) then
      Include(l_Ex, vcm_ooShowInChildMenu);
     if not (vcm_moEntitesInContextMenu in l_MM.MenuOptions) then
      Include(l_Ex, vcm_ooShowInContextMenu);*)
    end;
   end;//MenuManager Is TvcmCustomMenuManager
   for l_OO := Low(TvcmOperationOption) to High(TvcmOperationOption) do
   begin
    if (l_OO in (anOp.Options - l_Ex)) then
     l3CatSuff(l_Suffix, GetEnumName(TypeInfo(TvcmOperationOption), Ord(l_OO)) + '="1"');
   end;//for l_OO
   with f_HelpOut do
   begin
    l_S := ShortCutToText(anOp.ShortCut);
    if (l_S <> '') then
     l3CatSuff(l_Suffix, Format('shortcut="%s"', [CS(l_S)]));
    l3CatSuff(l_Suffix, Format('operationtype="%s"', [GetEnumName(TypeInfo(TvcmOperationType), Ord(anOp.OperationType))]));
    if (anOp.GroupID >= 100) then
     l3CatSuff(l_Suffix, Format('groupid="%d"', [anOp.GroupID]));
    l_S := anOp.Category;
    if (l_S <> '') then
     l3CatSuff(l_Suffix, Format('%s="%s"', [c_vcmCategory, CS(l_S)]));
    SaveUF(c_vcmOperation, anOp, l_Suffix, false);
    try
     if (anOp.ExcludeUserTypes <> []) then
     begin
      OpenLevel(c_vcmExcludeUserTypes);
      try
       for l_UT := Low(TvcmEffectiveUserType) to High(TvcmEffectiveUserType) do
       begin
        if (l_UT in anOp.ExcludeUserTypes) then
        begin
         l_Suffix := Format('index="%d"', [l_UT]);
         if (aForm Is TvcmEntityForm) AND
            (l_UT < TvcmEntityForm(aForm).UserTypes.Count) then
         begin
          l3CatSuff(l_Suffix,
                Format('%s="%s"',
                [c_vcmID, CS(TvcmUserTypesCollectionItem(TvcmEntityForm(aForm).UserTypes.Items[l_UT]).Name)]));
         end;//aForm Is TvcmEntityForm
         OpenLevel(c_vcmUserType, l_Suffix);
         try
         finally
          CloseLevel;
         end;//try..finally
        end;//l_UT in anOp.ExcludeUserTypes
       end;//for l_UT
      finally
       CloseLevel;
      end;//try..finally
     end;//anOp.ExcludeUserTypes <> []
     if (anOp.StatesCount > 0) then
     begin
      OpenLevel(c_vcmState+'s');
      try
       for l_St := 0 to Pred(anOp.StatesCount) do
        SaveUF(c_vcmState, anOp.State[l_St]);
      finally
       CloseLevel;
      end;//try..finally
     end;//anOp.StatesCount > 0
    finally
     CloseLevel;
    end;//try..finally
   end;//with f_HelpOut
  end;//not (anOp.OperationType in vcm_InternalOperations)
 end;//anOp = nil
end;

procedure TvcmMainForm.SaveOperations(const anOps : IvcmOperationsDefIterator;
                                      aForm       : TCustomForm);
  {-}
begin
 if (anOps <> nil) then
 begin
  with f_HelpOut do
  begin
   OpenLevel(c_vcmOperation+'s');
   try
    while SaveOperation(anOps.Next, aForm) do;
   finally
    CloseLevel;
   end;//try..finally
  end;//f_HelpOut
 end;//anOps <> nil
end;

procedure TvcmMainForm.DoSaveBitmaps(aBitmaps : TCustomImageList);
  {-}
var
 l_BmpDir : String;
 l_Bmp    : TBitmap;
 l_Index  : Integer;
 {$IfDef Nemesis}
 l_16     : String;
 l_24     : String;
 l_32     : String;
 {$EndIf Nemesis}
begin
 l_BmpDir := ChangeFileExt(Application.ExeName, '.bitmaps');
 if (aBitmaps <> vcmGetActionList.Images) then
 begin
  Assert(aBitmaps.Name <> '');
  l_BmpDir := l_BmpDir + '\' + aBitmaps.Name;
 end;//aBitmaps <> vcmGetActionList.Images
 MakeDir(l_BmpDir);
 {$IfDef Nemesis}
 l_16 := l_BmpDir + '\' + '16';
 l_24 := l_BmpDir + '\' + '24';
 l_32 := l_BmpDir + '\' + '32';
 MakeDir(l_16);
 MakeDir(l_24);
 MakeDir(l_32);
 {$EndIf Nemesis}
 l_Bmp := TBitmap.Create;
 try
  if (aBitmaps <> nil) then
  begin
   l_Bmp.Width := aBitmaps.Width;
   l_Bmp.Height := aBitmaps.Height;
   for l_Index := 0 to Pred(aBitmaps.Count) do
   begin
    with l_Bmp do
     Canvas.FillRect(Rect(0, 0, Width, Height));
    aBitmaps.Draw(l_Bmp.Canvas, 0, 0, l_Index);
    l_Bmp.SaveToFile(l_BmpDir + '\' + IntToStr(l_Index) + '.bmp');
   end;//for l_Index
   {$IfDef Nemesis}
   if (aBitmaps Is TvtPngImageList) then
    for l_Index := 0 to Pred(aBitmaps.Count) do
    begin
     TvtPngImageList(aBitmaps).SaveImage(l_16 + '\' + IntToStr(l_Index) + '.png', l_Index, ps16x16, bpp24);
     TvtPngImageList(aBitmaps).SaveImage(l_24 + '\' + IntToStr(l_Index) + '.png', l_Index, ps24x24, bpp24);
     TvtPngImageList(aBitmaps).SaveImage(l_32 + '\' + IntToStr(l_Index) + '.png', l_Index, ps32x32, bpp24);
    end;//for l_Index
   {$EndIf Nemesis}
  end;//aBitmaps <> nil
 finally
  FreeAndNil(l_Bmp);
 end;//try..finally
end;

procedure TvcmMainForm.SaveBitmaps;
  {-}

{$IFDEF Nemesis}
 function DoBitmaps(aData: PObject; anIndex: Integer): Boolean;
 begin//DoBitmaps
  Result := true;
  DoSaveBitmaps(aData^ As TCustomImageList);
 end;//DoBitmaps
{$ENDIF Nemesis}

begin
{$IFDEF Nemesis}
 IterateExistingImageListsF(l3L2IA(@DoBitmaps));
{$ENDIF Nemesis}
end;

procedure TvcmMainForm.SaveHelp(const aModuleDef : IvcmModuleDef);
  {-}
var
 l_List  : TvcmClassList;
 l_Forms : IvcmForms;
begin
 if f_NeedExportHelp or f_NeedExportContent then
  with f_HelpOut do
  begin
   SaveUF(c_vcmModule, aModuleDef, false);
   try
    SaveOperations(aModuleDef.OperationsDefIterator, nil);
  //  SaveEntities(aModuleDef.EntitiesDefIterator);
    l_List := TvcmClassList.Make;
    try
     if Supports(aModuleDef.Make, IvcmForms, l_Forms) then
      try
       l_Forms.GetEntityForms(l_List);
       SaveForms(l_List);
      finally
       l_Forms := nil;
      end;//try..finally
    finally
     vcmFree(l_List);
    end;//try..finally
   finally
    CloseLevel;
   end;//try..finally
  end;//with f_HelpOut
end;
{$EndIf vcmExportHelp}

procedure TvcmMainForm.RegisterModule(const aModuleDef : IvcmModuleDef);
var
 l_RE: IvcmCustOpsRepository;
{$IfNDef DesignTimeLibrary}
var
 l_List  : TvcmClassList;
 l_Forms : IvcmForms;
 l_Index : Integer;
{$EndIf  DesignTimeLibrary}
begin
 {$IfDef vcmExportHelp}
 {$IfDef InsiderTest}
 if not f_ModulesRegistered then
 {$EndIf InsiderTest}
 {$EndIf vcmExportHelp}
 begin
  RegisterModuleInMenu(aModuleDef);
  if Supports(TasksPanel, IvcmCustOpsRepository, l_RE) then
   l_RE.AddModule(aModuleDef);
 end;//not f_ModulesRegistered
 {$IfNDef DesignTimeLibrary}
 l_List := TvcmClassList.Make;
 try
  if Supports(aModuleDef.Make, IvcmForms, l_Forms) then
   try
    l_Forms.GetEntityForms(l_List);
    for l_Index := 0 to Pred(l_List.Count) do
     g_MenuManager.AppForms.AddForm(RvcmEntityForm(l_List[l_Index]));
   finally
    l_Forms := nil;
   end//try..finally
  else
   Assert(false);
 finally
  vcmFree(l_List);
 end;//try..finally
 {$EndIf DesignTimeLibrary}
 {$IfDef vcmExportHelp}
 SaveHelp(aModuleDef);
 {$EndIf vcmExportHelp}
end;

procedure TvcmMainForm.RegisterModule(aModule : RvcmModule);
begin
 RegisterModule(aModule.GetModuleDef);
end;

function TvcmMainForm.pm_GetMenuManager: TvcmBaseMenuManager;
  {-}
var
 l_Index : Integer;
begin
 if (f_MenuManager = nil) then
  for l_Index := 0 to Pred(ComponentCount) do
   if (Components[l_Index] Is TvcmBaseMenuManager) then begin
    f_MenuManager := TvcmBaseMenuManager(Components[l_Index]);
    break;
   end;//Components[l_Index] Is TvcmBaseMenuManager
 Result := f_MenuManager;
 if (Result = nil) then
 begin
  f_MenuManager := g_MenuManager;
  Result := g_MenuManager;
 end;//Result = nil
end;

{$IfDef vcmUseProfilers}
function TvcmMainForm.pm_GetProfilers: TvcmProfilersCollection;
  {* - коллекция профайлеров. }
begin
 Result := vcmProfilers;
end;
{$EndIf vcmUseProfilers}

function TvcmMainForm.pm_GetTasksPanel: IvcmCustOps;
  {* - панель задач. }
const
 ctp_stTasksPanel = 'vcm_TasksPanelSettings';
begin
 if f_TasksPanel = nil then
  f_TasksPanel := TvcmCustOps.Create(ctp_stTasksPanel);
 Result := f_TasksPanel;
end;//pm_GetTasksPanel

function TvcmMainForm.pm_GetHistory: IvcmHistory;
  {-}
begin
 if (f_History = nil) AND not (csDestroying in ComponentState) then
  f_History := TvcmHistory.Create(Self.As_IvcmEntityForm);
 Result := f_History;
end;

procedure TvcmMainForm.RegisterModuleInMenu(const aModuleDef : IvcmModuleDef);
  {* - регистрирует модуль в меню, toolbar'ах, etc. }
begin
 {$IfNDef DesignTimeLibrary}
 MenuManager.RegisterModuleInMenu(Self, aModuleDef);
 {$EndIf  DesignTimeLibrary}
end;

procedure TvcmMainForm.RegisterModules;
var
 l_Index : Integer;
begin
 {$IfNDef DesignTimeLibrary}
 if TvcmModulesForRegister.Exists then
 begin
  with TvcmModulesForRegister.Instance do
  begin
   for l_Index := 0 to Pred(Count) do
   begin
    with ItemSlot(l_Index)^ do
     Self.RegisterModule(rModule);
   end;//for l_Index
  end;//with TvcmModulesForRegister.Instance
 end;//TvcmModulesForRegister.Exists
 //TvcmApplication.Instance.RegisterModules(Self);
 AfterModulesRegistered;
 {$EndIf DesignTimeLibrary}
end;

procedure TvcmMainForm.ShowForm(const aForm: IvcmEntityForm);
  {* - показать форму. }
var
 l_Form  : TForm;
 l_Index : Integer;
begin
 l_Form := aForm.VCLWinControl As TForm;
 {$IfNDef DesignTimeLibrary}
 if (l_Form Is TvcmEntityForm) then
  MenuManager.RegisterChildInMenu(TvcmEntityForm(l_Form));
 {$EndIf  DesignTimeLibrary} 
 if (l_Form.Parent = nil) then
 begin
  if (aForm.ZoneType <> vcm_ztForToolbarsInfo) then
  begin
   if SDI then begin
    Case aForm.ZoneType of
     vcm_ztFloating :
     begin
      l_Form.FormStyle := fsStayOnTop;
      l_Form.Show;
      Exit;
     end;//vcm_ztFloating
     vcm_ztModal,
     vcm_ztManualModal:
      Exit;
     vcm_ztSimpleFloat:
     begin
      l_Form.Show;
      Exit;
     end;
     else
     begin
      if HasForm(fm_Any, aForm.ZoneType, false) then begin
       MakeClone.ShowForm(aForm);
       Exit;
      end;//HasForm..
     end;//else
    end;//Case aForm.ZoneType
    if not InsertForm(aForm) then begin
     if (f_ClientZone = nil) then begin
      for l_Index := 0 to Pred(ControlCount) do
       if (Controls[l_Index].Align = alClient) then begin
        f_ClientZone := Controls[l_Index];
        break;
       end;//Controls[l_Index] Is TControl
      if (f_ClientZone = nil) then begin
       f_ClientZone := TPanel.Create(Self);
       f_ClientZone.Align := alClient;
       f_ClientZone.Parent := Self;
      end;//f_ClientZone = nil
     end;//f_ClientZone
     with TvcmZonesCollectionItem(Zones.Add) do begin
      ZoneType := aForm.ZoneType;
      Control := f_ClientZone;
     end;//with TvcmZonesCollectionItem..
     InsertForm(aForm);
    end;//not InsertForm(aForm)
   end//SDI
   else
   begin
    Case aForm.ZoneType of
     vcm_ztFloating :
     begin
      l_Form.FormStyle := fsStayOnTop;
      l_Form.Show;
      Exit;
     end;//vcm_ztFloating
     vcm_ztModal,
     vcm_ztManualModal:
      Exit;
     vcm_ztSimpleFloat:
     begin
      l_Form.Show;
      Exit;
     end;
     else
      l_Form.FormStyle := fsMDIChild;
    end;//Case aForm.ZoneType
   end;//SDI
  end;//l_Form.ZoneType <> vcm_ztForToolbarsInfo
 end;//l_Form.Parent = nil
end;

type
  {$IfDef XE}
  {$Align 8}
  [RootDesignerSerializerAttribute('', '', False)]
  {$IfDef XE4}
  THackApplication = class(TComponent)
  private type
    TBiDiKeyboard = record
      private
        BiDiKeyboard, NonBiDiKeyboard: string;
        BiDiKeyboardHKL, NonBiDiKeyboardHKL: HKL;
    end;
  private
    FAppIconic: Boolean;
    FBiDiMode: TBiDiMode;
    FBiDiKeyboard: TBiDiKeyboard;
    FDefaultFont: TFont;
    FMainForm: TForm;
  end;//THackApplication
  {$Else  XE4}
  THackApplication = class(TComponent)
  private
    FAppIconic: Boolean;
    FBiDiMode: TBiDiMode;
    FBiDiKeyboard: string;
    FDefaultFont: TFont;
    FNonBiDiKeyboard: string;
    FMainForm: TForm;
  end;//THackApplication
  {$EndIf XE4}
  {$Align 1}
  {$Else XE}
  THackApplication = class(TComponent)
  private
   FHandle          : HWnd;
   FBiDiMode        : TBiDiMode;
   FBiDiKeyboard    : string;
   FNonBiDiKeyboard : string;
   FObjectInstance  : Pointer;
   FMainForm        : TForm;
  end;//THackApplication
  {$EndIf XE}

procedure TvcmMainForm.BecomeActive;
  //override;
  {-}
var
 l_ActiveEntity : IvcmEntity;
 l_EntityForm   : IvcmEntityForm;
begin
 BecomeMainForm;
 // FIX CQ: 00005918
 // Устанавливаем (через `inherited`) основную форму в качестве активной сущности.
 // Раньше этот медод был пустым.
 l_ActiveEntity := Dispatcher.ActiveEntity;
 if (l_ActiveEntity <> nil) then
  try
   with l_ActiveEntity do
    if Succeeded(QueryInterface(IvcmEntityForm, l_EntityForm)) then
     try
      with l_EntityForm do
       if (GetParentForm(VCLWinControl) = Self) then
        Exit;
     finally
      l_EntityForm := nil;
     end;
  finally
   l_ActiveEntity := nil;
  end;
 inherited;
end;

procedure TvcmMainForm.BecomeInactive;
  //override;
  {-}
var
 l_ActiveEntity : IvcmEntity;
begin
 // FIX CQ: 00005918
 // Убираем (через `inherited`) основную форму из качества активной сущности.
 // Раньше этот медод был пустым.
 l_ActiveEntity := Dispatcher.ActiveEntity;
 if (l_ActiveEntity <> nil) then
  try
   if vcmIEQ(l_ActiveEntity, Self) then
    inherited;
  finally
   l_ActiveEntity := nil;
  end;
end;

function TvcmMainForm.pm_GetStatusBar: IafwStatusBar;
  {-}
begin
 Result := IafwStatusBar(f_StatusBar);
end;

procedure TvcmMainForm.pm_SetStatusBar(const aValue: IafwStatusBar);
  {-}
begin
 f_StatusBar := Pointer(aValue);
end;

function TvcmMainForm.pm_GetStatus: IafwStatus;
  {-}
begin
 {$IfNDef DesignTimeLibrary}
 if (f_Status = nil) then
  Status := TafwStatus.Make(Self);
 {$EndIf  DesignTimeLibrary} 
 Result := f_Status;
end;

procedure TvcmMainForm.pm_SetStatus(const aValue: IafwStatus);
  {-}
begin
 if (f_Status <> aValue) then
 begin
  if (f_Status <> nil) AND (f_StatusElement <> nil) then
   f_Status.RemoveElement(f_StatusElement);
  f_Status := aValue;
  if (f_Status <> nil) then
  begin
   if (f_StatusElement = nil) then
    f_StatusElement := TvcmStatusElement.Make;
   f_Status.AddElement(f_StatusElement);
  end;//f_Status <> nil
 end;//f_Status <> aValue
end;

function TvcmMainForm.MakeContainer: IvcmContainer;
var
 l_Clone: TvcmMainForm;
begin
 l_Clone := MakeClone(False);
 InitClone(l_Clone);
 Result := l_Clone as IvcmContainer;
 Assert(Result <> nil);
end;

function TvcmMainForm.Get_Dispatcher: IvcmDispatcher;
  {-}
var
 l_Dispatcher : TvcmDispatcher;
begin
 if (f_Dispatcher = nil) then
 begin
  if (g_Dispatcher <> nil) then
   f_Dispatcher := g_Dispatcher
  else
   f_Dispatcher := TvcmDispatcher.Make;
 end;//f_Dispatcher = nil
 Result := f_Dispatcher;
end;

procedure TvcmMainForm.WMSysCommand(var Message: TWMSysCommand);
begin
 if not (csDesigning in ComponentState) then
 begin
  with Message do begin
   if SDI AND (CmdType and $FFF0 = SC_MINIMIZE) AND (Application.MainForm = Self) then
    DefaultHandler(Message)
   else
    inherited;
  end;//with Message
 end
 else
  inherited;
end;

procedure TvcmMainForm.vcmMsgCloseForm(var Message: TMessage);
  //message vcm_msgCloseForm;
  {-}
begin
 if (Dispatcher = nil) OR (Dispatcher.FormDispatcher.MainFormsCount = 1) then
  Application.Terminate
 else
  inherited;
end;
  
procedure TvcmMainForm.CMTextChanged(var Message: TMessage);
  //message CM_TEXTCHANGED;
  {-}
var
 l_Container: IafwMainFormContainer;
begin
 if (Parent <> nil) and Supports(Parent, IafwMainFormContainer, l_Container) then
 try
  l_Container.UpdateFormCaption(Self);
 finally
  l_Container := nil;
 end;
 if (Dispatcher = nil) OR not Dispatcher.FormDispatcher.Locked then
  inherited;
end;

procedure TvcmMainForm.WMSetText(var Message: TMessage);
  //message WM_SetText;
  {-}
begin
 if (Dispatcher = nil) OR not Dispatcher.FormDispatcher.Locked then
  inherited;
end;

procedure TvcmMainForm.WMSetFocus(var Message: TMessage);
begin
 inherited;
 DoGiveFocusToZone;
end;

procedure TvcmMainForm.CreateParams(var Params: TCreateParams);
  //override;
  {-}
var
 l_ExtendedStyle : Integer;
begin
 inherited;
 if SDI AND not (csDesigning in ComponentState) then
 begin
  with Params do
  begin
   ExStyle := ExStyle or WS_EX_APPWINDOW;
   // fireton: 15.04.2005 - исправлено WndParent и добавлен WS_OVERLAPPED в Style
   // Сделано для того, чтобы не-vcm модальные окна ("Сохранить как...") могли нормально
   // диспатчить сообщения главному окну
   Style := Style or WS_OVERLAPPED;
   if (Parent = nil) then
    WndParent := Application.Handle; //GetDesktopWindow;
  end;
  l_ExtendedStyle := GetWindowLong(Application.Handle, GWL_EXSTYLE);
  SetWindowLong(Application.Handle,
                GWL_EXSTYLE,
                l_ExtendedStyle or WS_EX_TOOLWINDOW {AND NOT WS_EX_APPWINDOW});
 end;//SDI..
end;

procedure TvcmMainForm.CorrectApplicationMainForm;
  {-}
var
 i      : Integer;
 l_Form : TForm;
begin
 inherited;
 if SDI AND not (csDesigning in ComponentState) then begin
  if (Application.MainForm = Self) AND (Screen.FormCount > 1) then begin
   for i := 0 to Pred(Screen.FormCount) do begin
    l_Form := Screen.Forms[i];
    if (l_Form <> Self) AND (l_Form Is TvcmMainForm) then begin
     THackApplication(Application).FMainForm := l_Form;
    end;//l_Form <> Self
   end;//for i
  end;
 end;//SDI..
end;

function TvcmMainForm.CanRemoveInKillFromVCM: Boolean;
  //override;
  {-}
begin
 Result := not (HandleAllocated AND (g_Dispatcher <> nil) AND g_Dispatcher.InOp);
 // - не удаляем основную форму в процессе открытия другой основной
end;

procedure TvcmMainForm.BeforeKill;
  //override;
  {-}
begin
 inherited;
 CorrectApplicationMainForm;
end;

procedure TvcmMainForm.DoClose(var Action: TCloseAction);
  //override;
  {-}
begin
 CorrectApplicationMainForm;
 Action := caFree;
 inherited;
end;

procedure TvcmMainForm.DoUpdateMainCaptionPrefix;
  {* - обновить префикс заголовка. Используется при создании формы и при
       переключении базы. }
begin
 if NeedVersionInCaption then
  with TVersionInfo.Create do
  try
   if (FixedFileInfo <> nil) then
    with FileLongVersion do
      f_CaptionPrefix := vcmFmt('%s %d', [Application.Title, All[2]])
  finally
   Free;
  end//try..finally
 else
  f_CaptionPrefix := vcmCStr(Application.Title);
end;

procedure TvcmMainForm.AddFormToTasksPanel(const aEntityForm: IvcmEntityForm);
  {-}
var
 l_RE: IvcmCustOpsRepository;
begin
 if IsTasksPanelForm(aEntityForm) and
   Supports(TasksPanel, IvcmCustOpsRepository, l_RE) then
  l_RE.AddForm(aEntityForm);
end;//AddFormToTasksPanel

procedure TvcmMainForm.RemoveFormFromTasksPanel(const aEntityForm: IvcmEntityForm);
  {-}
var
 l_RE: IvcmCustOpsRepository;
begin
 if IsTasksPanelForm(aEntityForm) and
   Supports(TasksPanel, IvcmCustOpsRepository, l_RE) then
  l_RE.RemoveForm(aEntityForm);
end;//RemoveFormFromTasksPanel

function TvcmMainForm.IsTasksPanelForm(const aForm: IvcmEntityForm): Boolean;
  {* - определяет используется ли форма для панели задач. }
var
 l_EntityForm : IvcmEntityForm;
 l_Container  : IvcmContainer;
 l_Parent     : TWinControl;
begin
 Result := False;
 if not (csDestroying in ComponentState) and (f_TasksPanelZone <> -1) then
 begin
  l_Container := IvcmContainer(Self);
  try
   if (aForm.Container <> nil) then
   begin
    l_EntityForm := aForm;
    while (l_EntityForm <> nil) and (l_EntityForm.Container <> l_Container) do
     Supports(l_EntityForm.Container, IvcmEntityForm, l_EntityForm);
    if (l_EntityForm <> nil) then
    begin
     l_Parent := l_EntityForm.VCLWinControl.Parent;
     if (l_Parent = nil) then
      Result := false
     else
      Result := (Zones.FindZone(l_Parent) = Zones.Items[f_TasksPanelZone]);
    end;//l_EntityForm <> nil
   end;//if aForm.Container <> nil then
  finally
   l_Container := nil;
  end;//try..finally
 end;//if f_TasksPanelZone <> -1 then
end;//IsTasksPanelForm

procedure TvcmMainForm.UpdateMainCaptionPrefix;
  {* - обновить префикс заголовка. Используется при создании формы и при
       переключении базы. }
begin
 f_NeedUpdateMainCaptionPrefix := True;
 Dispatcher.FormDispatcher.UpdateMainCaption;
  // - Сейчас мы не можем обновить caption окна потому, что FormDispatcher.
  //   Locked, см. обработчик WMSetText. Поэтому мы зовем FormDispatcher.
  //   UpdateMainCaption, который выставит запрос на необходимость обновления
  //   (f_NeedUpdateMainCaption) в Dispatcher. Когда произойдет UnLock, то
  //   вызовется vcmMainForm.UpdateMainCaption и тогда обновиться CaptionPrefix;
end;

procedure TvcmMainForm.UpdateMainCaption;
  {-}
var
 {$IfNDef DesignTimeLibrary}
 l_Pref : IvcmCString;
 {$EndIf  DesignTimeLibrary}
 l_Main : IvcmCString;
begin
 if f_NeedUpdateMainCaptionPrefix then
 begin
  DoUpdateMainCaptionPrefix;
  f_NeedUpdateMainCaptionPrefix := False;
 end;
 l_Main := MainCaption;
 if vcmIsNil(f_CaptionPrefix) then
  CCaption := l_Main
 else
 begin
  {$IfDef DesignTimeLibrary}
  CCaption := l_Main;
  {$Else  DesignTimeLibrary}
  l_Pref := vcmCat(f_CaptionPrefix, ' - ');
  if l3Starts(l_Pref, l_Main, true) then
   CCaption := l_Main
  else
   CCaption := vcmCat(l_Pref, l_Main);
  {$EndIf DesignTimeLibrary}
 end;//vcmIsNil(f_CaptionPrefix)
end;

class function TvcmMainForm.FormImplementationClass: TClass;
  //override;
  {-}
begin
 Result := TvcmMainFormImplementation;
end;

procedure TvcmMainForm.Loaded;
  //override;
  {* - запоминаем состояние окна и его положение. }
begin
 inherited;
 with f_FormInfo do
 begin
  rWindowState := WindowState;
  Windows.GetWindowRect(Handle, rBounds);
 end;
 {$IfNDef DesignTimeLibrary}
 if (g_MenuManager <> nil) and (g_MenuManager is TvcmCustomMenuManager) then
  TvcmCustomMenuManager(g_MenuManager).InitToolbarMetrics(Self);
 {$EndIf DesignTimeLibrary}
 InitStyle;
end;//Loaded

function TvcmMainForm.GetIsMainObjectForm: Boolean;
  //override;
  {-}
begin
 Result := true;
end;

// start class TvcmMainFormImplementation

procedure TvcmMainFormImplementation.AddFormToTasksPanel(const aEntityForm: IvcmEntityForm);
  {-}
begin
 if (Control Is TvcmMainForm) then
  TvcmMainForm(Control).AddFormToTasksPanel(aEntityForm)
 else
  Assert(False);
end;//AddFormToTasksPanel

procedure TvcmMainFormImplementation.RemoveFormFromTasksPanel(const aEntityForm: IvcmEntityForm);
  {-}
begin
 if (Control Is TvcmMainForm) then
  TvcmMainForm(Control).RemoveFormFromTasksPanel(aEntityForm)
 else
  Assert(False);
end;//RemoveFormFromTasksPanel

function TvcmMainFormImplementation.pm_GetTasksPanel: IvcmCustOps;
  {-}
begin
 if (Control Is TvcmMainForm) then
  Result := TvcmMainForm(Control).TasksPanel
 else
  Result := nil;
end;//TvcmMainFormImplementation

function TvcmMainFormImplementation.pm_GetHistory: IvcmHistory;
  {-}
begin
 if (Control Is TvcmMainForm) then
  Result := TvcmMainForm(Control).History
 else
  Result := nil;
end;

procedure TvcmDispatcher.CascadeWindows(const aForms: IvcmEntityFormsIterable);
var
 lCurrentPoint: TPoint;
 lWidth: Integer;
 lHeight: Integer;
 lOffsetPoint  : TPoint;

 function lp_DoCascadeWindows(anItem: PIvcmEntityForm; anIndex: Integer): Boolean;
 var
  l_Form: IvcmEntityForm;
 begin
  l_Form := anItem^;
  try
   SetWindowPos(l_Form.VCLWinControl.Handle, HWND_TOP,
                lCurrentPoint.X, lCurrentPoint.Y,
                lWidth, lHeight,
                SWP_SHOWWINDOW);
   with lCurrentPoint do
   begin
    X := X + lOffsetPoint.X;
    Y := Y + lOffsetPoint.Y;
   end;//with lCurrentPoint
  finally
   l_Form := nil;
  end;//try..finally
 end;//lp_DoCascadeWindos

begin
 PrepareWindows(aForms);
 lCurrentPoint := Point(GetCurrentMonitorRect.Left, GetCurrentMonitorRect.Top);
 with lOffsetPoint do
 begin
  // сдвиг вправо
  X := GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYSIZEFRAME);
  // сдвиг вниз
  Y := X;
 end;
 with GetCurrentMonitorRect do
 begin
  lHeight := ((Bottom - Top) div 4) * 3;
  lWidth := ((Right - Left) div 5) * 4;
 end;//with GetCurrentMonitorRect
 if (aForms <> nil) then
  aForms.IterateFormsF(l3L2IA(@lp_DoCascadeWindows))
 else
  f_MainForms.IterateAllF(l3L2IA(@lp_DoCascadeWindows));
end;

procedure TvcmDispatcher.ArrangeAll(const aForms: IvcmEntityFormsIterable);
const
 ROWS = 3;
var
 lAddHeight    : Integer;           
 lIndex        : Integer;
 lHeightRest   : Integer;
 lWindowsRest  : Integer;
 lWindowsInRow : Integer;
 lMonitor      : TRect;
 lScreenWidth  : Integer; // ширина экрана
 lScreenHeight : Integer; // высота экрана
 lWindowHeight : Integer; // высота всех форм на экране
 lCursor       : Integer; // текущая обрабатываемая форма, увеличивается после
                          // работы с формой

 function lp_GetForm(aIndex: Integer): IvcmEntityForm;
 var
  l_Form: IvcmEntityForm;

  function lp_DoGetForm(anItem: PIvcmEntityForm; anIndex: Integer): Boolean;
  begin
   if (anIndex = aIndex) then
   begin
    Result := False;
    l_Form := anItem^;
   end
   else
    Result := True;
  end;//lp_DoGetForm

 begin
  if (aForms <> nil) then
  begin
   l_Form := nil;
   aForms.IterateFormsF(l3L2IA(@lp_DoGetForm));
   Result := l_Form;
  end
  else
   Result := Get_MainForm(aIndex);
 end;//lp_GetForm

 procedure BuildRow(const aTop    : Integer;
                    const aHeight : Integer);
 var
  lRest        : Integer;
  lIndex       : Integer;
  lCount       : Integer;
  lAddHeight   : Integer;
  lWindowWidth : Integer;
 begin
  lAddHeight := 0;
  lCount := lWindowsInRow;
  if lWindowsRest > 0 then
  begin
   // мы забрали одну "лишнуюю" форму для отображения в нашей строке
   Dec(lWindowsRest);
   // в нашем столбце на одну форму будет больше
   Inc(lCount);
  end;
  // ширина формы в нашем столбце
  lWindowWidth := lScreenWidth div lCount;
  // остаток который отдадим последней форме
  lRest := lScreenWidth mod lCount;

  for lIndex := 0 to Pred(lCount) do
  begin
   // остаток
   if lIndex = Pred(lCount) then
    lAddHeight := lRest;
   // позиционируем
   SetWindowPosition(lp_GetForm(lCursor).VCLWinControl.Handle,
                     lMonitor.Left + lWindowWidth * lIndex, aTop,
                     lWindowWidth, aHeight + lAddHeight);
   Inc(lCursor);
  end;//for lIndex
 end;

var
 l_MainFormsCount: Integer;
begin
 if (aForms <> nil) then
  l_MainFormsCount := aForms.FormsCount
 else
  l_MainFormsCount := f_MainForms.Count;
 PrepareWindows;
 // текущая форма
 lCursor := 0;
 lAddHeight := 0;
 // текущий монитор
 lMonitor := GetCurrentMonitorRect;
 lScreenWidth := (lMonitor.Right - lMonitor.Left);
 lScreenHeight := (lMonitor.Bottom - lMonitor.Top);
 // высота строк
 lWindowHeight := lScreenHeight div ROWS;
 // остаток окон
 lWindowsRest := l_MainFormsCount mod ROWS;
 // остаток высоты
 lHeightRest := lScreenHeight mod ROWS;
 // количество форм в строке
 lWindowsInRow := l_MainFormsCount div ROWS;
 // строим
 for lIndex := 0 to Pred(ROWS) do
 begin
  if lIndex = Pred(ROWS) then
   lAddHeight := lHeightRest;
  BuildRow(lWindowHeight * lIndex + lMonitor.Top, lWindowHeight + lAddHeight);
 end;
end;

procedure TvcmDispatcher.StoreFocus;
  {-}
begin
 if f_StoredFocusLock = 0  then
  StoreFocused(Windows.GetFocus);
 inc(f_StoredFocusLock);
end;

procedure TvcmDispatcher.RestoreFocus;
  {-}
var
 l_Parent,
 l_Control : TWinControl;

 function lp_TrySetFocus(aControl: TControl): boolean;
 Var
  l_LocControl: TControl;
  l_FCS: IafwFocusableControlParent;  
 begin
  Result := False;
  l_LocControl := aControl;
  while l_LocControl <> nil do
  begin
   if not l_LocControl.Enabled or not l_LocControl.Visible then
   begin
    if Supports(l_LocControl, IafwFocusableControlParent, l_FCS) then
    begin
     l_FCS.SetFocusToControl(l_Control);
     Result := True;
    end;
    exit;
   end;
   l_LocControl := l_LocControl.Parent;
  end;
  Result := True;
  if l_Control.CanFocus then
   l_Control.SetFocus;
 end;

begin
 dec(f_StoredFocusLock);
 if (f_StoredFocusLock = 0) and
    (f_PrevFocused <> 0) then
 begin
  if Windows.GetFocus <> f_PrevFocused then
  begin
   l_Control := FindControl(f_PrevFocused);
   l_Parent := l_Control;
   while Assigned(l_Parent) do
    if l_Parent is TvcmEntityForm then
    begin
     lp_TrySetFocus(l_Control);
     l_Parent := nil;
    end
    else
     l_Parent := l_Parent.Parent;
  end;
  f_PrevFocused := 0;
 end;
end;

procedure TvcmDispatcher.PrepareWindows(const aForms: IvcmEntityFormsIterable);

 function lp_DoPrepareWindow(anItem: PIvcmEntityForm; anIndex: Integer): Boolean;
 begin
  vcmDropConstraints(anItem^.VCLWinControl As TCustomForm);
  Result := True;
 end;//lp_DoPrepareWindow

begin
 if (aForms <> nil) then
  aForms.IterateFormsF(l3L2IA(@lp_DoPrepareWindow))
 else
  f_MainForms.IterateAllF(l3L2IA(@lp_DoPrepareWindow));
end;

procedure TvcmDispatcher.TileWindows(aType : TvcmTileWindowType; const aForms: IvcmEntityFormsIterable = nil);
var
 l_Step: Integer;
 l_Monitor: TRect;
 l_Cursor: Integer;
 l_Width: Integer;
 l_Height: Integer;
 l_MainFormsCount: Integer;
 l_RestDiv : Integer;

 function lp_DoTileWindows(anItem: PIvcmEntityForm; anIndex: Integer): Boolean;
 var
  l_Form: IvcmEntityForm;
  l_FormHandle: HWND;
 begin
  l_Form := anItem^;
  try
   l_FormHandle := l_Form.VCLWinControl.Handle;
   // добавим остаток от деления
   if anIndex = Pred(l_MainFormsCount) then
    l_Step := l_Step + l_RestDiv;
   // установим позицию формы
   case aType of
    vcm_twHorizontal:
     SetWindowPosition(l_FormHandle, l_Monitor.Left, l_Cursor, l_Width, l_Step);
    vcm_twVertical:
     SetWindowPosition(l_FormHandle, l_Cursor, l_Monitor.Top, l_Step, l_Height);
   end;//case aType
   // положение следующего окна
   Inc(l_Cursor, l_Step);
   Result := True;
  finally
   l_Form := nil;
  end;//try..finally
 end;//lp_DoTileWindows

const
 TILE_COUNT = 3;
begin
 PrepareWindows(aForms);
 if (aForms <> nil) then
  l_MainFormsCount := aForms.FormsCount
 else
  l_MainFormsCount := f_MainForms.Count;
 if (l_MainFormsCount > TILE_COUNT) then
  ArrangeAll(aForms)
 else
 begin
  l_Monitor := GetCurrentMonitorRect;
  l_Height  := l_Monitor.Bottom - l_Monitor.Top;
  l_Width   := l_Monitor.Right  - l_Monitor.Left;
  // высота/ширина формы
  if aType = vcm_twHorizontal then
  begin
   l_RestDiv := l_Height mod l_MainFormsCount;
   l_Step    := l_Height div l_MainFormsCount;
   l_Cursor  := l_Monitor.Top;
  end//aType = vcm_twHorizontal
  else
  begin
   l_RestDiv := l_Width mod l_MainFormsCount;
   l_Step    := l_Width div l_MainFormsCount;
   l_Cursor  := l_Monitor.Left;
  end;//aType = vcm_twHorizontal
  // установим размеры
  if (aForms <> nil) then
   aForms.IterateFormsF(l3L2IA(@lp_DoTileWindows))
  else
   f_MainForms.IterateAllF(l3L2IA(@lp_DoTileWindows));
 end;//f_MainForms.Count > TILE_COUNT
end;

procedure TvcmDispatcher.BeginRestoreAllSettings;
begin
 Inc(f_RestoreAllSettings);
end;

procedure TvcmDispatcher.EndRestoreAllSettings;
begin
 Dec(f_RestoreAllSettings);
end;

procedure TvcmDispatcher.TileWindowsHorizontal(const aForms: IvcmEntityFormsIterable);
begin
 TileWindows(vcm_twHorizontal, aForms);
end;

procedure TvcmDispatcher.TileWindowsVertical(const aForms: IvcmEntityFormsIterable);
begin
 TileWindows(vcm_twVertical, aForms);
end;

(*procedure TvcmDispatcher.PlaceWindowsByWindows(aType : TvcmPlaceWindowType;
                                               aTile : PvcmTileWindowType = nil);
const
 cTypeTile : array [Low(TvcmTileWindowType)..High(TvcmTileWindowType)] of Integer =
  (MDITILE_HORIZONTAL,
   MDITILE_VERTICAL);
var
 l_Index      : Integer;
 l_MemPointer : Pointer;
 l_Size       : Integer;
 l_Cursor     : PPointer;
 l_Handles    : array of THandle;

begin
 // получим handles открытых окон (TvcmMainForm)
 for l_Index := 0 to Pred(f_MainForms.Count) do
 begin
   SetLength(l_Handles, Succ(Length(l_Handles)));
   with IvcmEntityForm(f_MainForms.Items[l_Index]).VCLForm do
    l_Handles[High(l_Handles)] := Handle;
 end;//for l_Index := 0 to ..
 // упорядочим окна
 if Length(l_Handles) > 0 then
 begin
  l_Size := Length(l_Handles)*SizeOf(Pointer);
  // выделим память
  vcmGetMem(l_MemPointer, l_Size);
  try
   // установим указатели
   l_Cursor := l_MemPointer;
   for l_Index := 0 to High(l_Handles) do
   begin
    l_Cursor^ := Pointer(l_Handles[l_Index]);
    Inc(l_Cursor);
   end;//for l_Index := 0 to...
   // попросим Windows сделать работку
   case aType of
    // титульно
    vcm_pwTile:
    begin
     Assert(Assigned(aTile));
     Windows.TileWindows(0, cTypeTile[aTile^], nil, Length(l_Handles), l_MemPointer);
    end;
    // каскадом
    vcm_pwCascade:
     Windows.CascadeWindows(0, MDITILE_SKIPDISABLED, nil, Length(l_Handles), l_MemPointer);
   end;//case aPlace of
  finally
   vcmFreeMem(l_MemPointer);
  end;
  // освободим память
 end;//if Length(..
end;*)

procedure TvcmDispatcher.CloseAllWindows(const aForms: IvcmEntityFormsIterable;
 const aCurrent: IvcmEntityForm);

 function lp_DoCloseWindow(anItem: PIvcmEntityForm; anIndex: Integer): Boolean;
 begin
  if f_ClosingAllWindows or
    (anItem^ <> aCurrent) then
   anItem^.SafeClose;
  Result := True;
 end;//lp_DoCloseWindow

var
 l_Index: Integer;
begin
 f_ClosingAllWindows := not Assigned(aCurrent);
 // clipboard содержит большой кусок информации, пользователь не хочет закрывать
 // приложение
 if f_ClosingAllWindows and
    (l3System.CheckClipboard(afw.Application.AskClearClipboardProc) = IDCancel) then
 begin
  f_ClosingAllWindows := False;
  Exit;
 end;
 // закрываем все кроме текущего или выходим
 if (aForms <> nil) then
  aForms.IterateFormsF(l3L2IA(@lp_DoCloseWindow))
 else
  f_MainForms.IterateAllF(l3L2IA(@lp_DoCloseWindow));
end;

procedure TvcmDispatcher.RestoreFormSize;
{* - перечитывает размер компонентов на форме (восстанавливает сначала
     размеры Design-Time, потом читает из настроек). }
var
 l_Index : Integer;
 l_Form  : IvcmEntityForm;
begin
 (* Главные формы не регистрируются в списке сущностей *)
 for l_Index := 0 to Pred(Get_MainFormsCount) do
  (Get_MainForm(l_Index).VCLWinControl As TvcmMainForm).RestoreFormSize; 
 (* Пройдемся по зарегистрированным формам *)
 for l_Index := 0 to Pred(Get_EntitiesCount) do
  if Supports(Get_Entity(l_Index), IvcmEntityForm, l_Form) then
  try
   if (l_Form.VCLWinControl is TvcmContainerForm) then
    TvcmContainerForm(l_Form.VCLWinControl).RestoreControlSize;
  finally
   l_Form := nil;
  end;//try..finally
end;

procedure TvcmDispatcher.ReloadAllToolbars;
  {* - перезагружает информацию toolbar-ов у всех открытых в данный момент
       форм. }
var
 l_Index : Integer;
 l_Form  : IvcmEntityForm;
begin
 for l_Index := 0 to Pred(Get_MainFormsCount) do
 begin
  (Get_MainForm(l_Index).VCLWinControl as TvcmEntityForm).ReloadToolbars;
  afw.ProcessMessages;
 end;//for l_Index

 for l_Index := 0 to Pred(Get_EntitiesCount) do
  if Supports(Get_Entity(l_Index), IvcmEntityForm, l_Form) then
  try
   with (l_Form.VCLWinControl As TvcmEntityForm) do
   begin
    ReloadToolbars;
    // ManualUpdateActions надо, иначе имеем на экране не реальное состояние
    // формы
    ManualUpdateActions;
   end;//with (l_Form.VCLWinControl As TvcmEntityForm)
   afw.ProcessMessages;
  finally
   l_Form := nil;
  end;//try..finally
end;

procedure TvcmDispatcher.ShowMainForm(const aForm: IvcmEntityForm);
begin
 if ((aForm.VCLWinControl As TForm).WindowState = wsMinimized) then
  (aForm.VCLWinControl As TForm).WindowState := wsNormal;
 SetWindowPos(aForm.VCLWinControl.Handle, 0, -1, -1, -1, -1, SWP_NOSIZE or
  SWP_SHOWWINDOW or SWP_NOMOVE);
end;

procedure TvcmDispatcher.StoreFocused(aHandle : THandle);
  {-}
begin
 f_PrevFocused := aHandle;
end;

function TvcmDispatcher.GetCurrentMonitorRect : TRect;
begin
 Result := Screen.MonitorFromPoint(Mouse.CursorPos).WorkareaRect;
end;

procedure TvcmDispatcher.LockCursor;
begin
 if f_CursorLock = 0 then
 begin
  f_OldCursor := Screen.Cursor;
  Screen.Cursor := crHourGlass;
 end;
 inc(f_CursorLock);
end;

procedure TvcmDispatcher.UnlockCursor;
begin
 dec(f_CursorLock);
 if f_CursorLock = 0 then
  Screen.Cursor := f_OldCursor;
end;

procedure TvcmDispatcher.AddControlForInvalidate(aControl : TObject);
var
 l_Index   : Integer;
 l_Control : TWinControl;
begin
 if (aControl is TWinControl) then
 begin
  l_Control := TWinControl(aControl);
  l_Index := f_InvalidateCtrls.IndexOf(Integer(l_Control.Handle));
  if (l_Index < 0) then
   f_InvalidateCtrls.Add(Integer(l_Control.Handle));
 end;
end;

procedure TvcmDispatcher.BackupLockStatus;
begin
 f_SaveLockCounter.Add(f_Lock);
 f_Lock := 1;
 Unlock;
end;

procedure TvcmDispatcher.LockActionUpdate;
  {* - блокировать OnTest-ы операций. Необходимо когда система находится в
       переходном состоянии и не все данные актуальны. }
begin
 afw.LockActionUpdate;
 Inc(f_ActionUpdateCount);
end;

procedure TvcmDispatcher.UnlockActionUpdate;
  {* - блокировать OnTest-ы операций. Необходимо когда система находится в
       переходном состоянии и не все данные актуальны. }
begin
 Dec(f_ActionUpdateCount);
 if (f_ActionUpdateCount = 0) and f_NeedUpdateStatus then
 begin
  PostMessage(pm_GetForm.Handle, vcm_msgUpdateStatus, 0, 0);
  f_NeedUpdateStatus := false;
 end;
 afw.UnlockActionUpdate;
end;

procedure TvcmDispatcher.ReinsertForms;
{* - перечитывает значения форм. }
var
 l_Form      : IvcmEntityForm;
 l_CloneList : TvcmIEntityList;
 l_Count     : Integer;
 l_Flag      : Boolean;
begin
 // для того, чтобы умерли старые формы и мы случайно не вставили их повторно
 afw.ProcessMessages;
 l_CloneList := TvcmIEntityList.Create;
 try
  for l_Count := 0 to Pred(Get_EntitiesCount) do
   l_CloneList.Add(Get_Entity(l_Count));
  for l_Count := 0 to Pred(l_CloneList.Count) do
  begin
   l_Form := l_CloneList[l_Count].AsForm;
   //if Supports(l_CloneList[l_Count], IvcmEntityForm, l_Form) then
   if (l_Form <> nil) then
   begin
    l_Form.LockFocus;
    try
(*     if (l_Form.VCLWinControl.Visible) then
     begin
      l_Form.VCLWinControl.Hide;
      l_Flag := true;
     end//l_Form.VCLWinControl.Visible
     else*)
     // http://mdp.garant.ru/pages/viewpage.action?pageId=371649474
      l_Flag := false;
     (l_Form.VCLWinControl as TvcmEntityForm).Container.InsertForm(l_Form);
     if l_Flag then
      l_Form.VCLWinControl.Show;
    finally
     l_Form.UnlockFocus;
    end;//try..finally
   end;//Supports(l_CloneList[l_Count], IvcmEntityForm, l_Form)
  end;//for l_Count
  // установим фокус
  l_Form := Get_CurrentMainForm;
  if Assigned(l_Form) and Assigned(l_Form.VCLWinControl) then
   (l_Form.VCLWinControl As TvcmMainForm).DoGiveFocusToZone;
 finally
  FreeAndNil(l_CloneList);
 end;//try..finally
end;

procedure TvcmDispatcher.RestoreLockStatus;
begin
 assert(f_SaveLockCounter.Count > 0);
 f_Lock := f_SaveLockCounter[f_SaveLockCounter.Count - 1];
 f_SaveLockCounter.Delete(f_SaveLockCounter.Count - 1);
end;

procedure TvcmDispatcher.AddFormForUpdateActions(const aForm: IvcmEntityForm);
var
 l_Index : Integer;
begin
 l_Index := f_UpdateForms.IndexOf(aForm);
 if (l_Index < 0) then
  f_UpdateForms.Add(aForm);
end;

procedure TvcmMainForm.SmallToolbarSize(const aValue : Integer);
var
 l_Index    : Integer;
 l_Control  : TObject;
 l_Notifier : IvcmToolbarNotifier;
begin
 for l_Index := 0 to Pred(Zones.Count) do
 begin
  l_Control := TvcmZonesCollectionItem(Zones.Items[l_Index]).Control;
  if Assigned(l_Control) and
     Supports(l_Control, IvcmToolbarNotifier, l_Notifier) then
  try
   l_Notifier.SmallToolbarSize(aValue);
  finally
   l_Notifier := nil;
  end;//try..finally
 end;//for l_Index
end;

procedure TvcmDispatcher.BeginCancelModal;
begin
 inc(f_CancelModalLock);
end;

procedure TvcmDispatcher.EndCancelModal;
begin
 dec(f_CancelModalLock);
end;

function TvcmDispatcher.InCancelModal: Boolean;
begin
 Result := f_CancelModalLock > 0;
end;

procedure TvcmMainForm.DoShow;
begin
 vcmStartupComplete;
 inherited DoShow;
end;

{$IfDef Nemesis}
function TvcmMainForm.LimitOpenedWindowsCount: Boolean;
begin
 Result := True;
end;

function TvcmMainForm.MaxOpenedWindowsCount: Integer;
begin
 Result := 10;
end;

{$EndIf Nemesis}

function TvcmMainForm.DoMakeClone(aNeedShow: Boolean): TvcmMainForm;
  {-}
var
 l_Control: TWinControl;
begin
 Dispatcher.FormDispatcher.StartNewMainForm;
 // http://mdp.garant.ru/pages/viewpage.action?pageId=414849606
{$IfDef Nemesis}
 if (not LimitOpenedWindowsCount) or (Dispatcher.FormDispatcher.MainFormsCount < MaxOpenedWindowsCount) then
 begin
 {$EndIf Nemesis}
  Result := RvcmMainForm(ClassType).Create(Application);
  if aNeedShow then
   Result.Show;
  Dispatcher.FormDispatcher.PlaceNewMainForm(Self, Result);
 {$IfDef Nemesis}
 end
 else
  if (Ask(str_TooManyWindowsOpened, [])) then
   Result := Self
  else
   Result := nil;
 {$EndIf Nemesis}
end;

procedure TvcmMainForm.BecomeMainForm;
begin
 // становимся MainForm
 THackApplication(Application).FMainForm := Self;
end;

procedure TvcmMainForm.ReleaseResources;
begin
 DefocusControl(Self, True);
 inherited;
end;

procedure TvcmMainForm.DoExitApplication;
begin
 Dispatcher.CloseAllWindows;
end;

procedure TvcmMainForm.InitClone(aForm: TvcmMainForm);
begin
 //
end;

procedure TvcmMainFormSetHistory(const aHistory: IvcmHistory);
begin
 Assert(aHistory <> nil);

end;

procedure TvcmDispatcher.SetWindowPosition(aHandle: THandle; aLeft, aTop, aWidth,
  aHeight: Integer);
var
 l_Placement: TWindowPlacement;
begin
 l_Placement.Length := SizeOf(l_Placement);
 GetWindowPlacement(aHandle, @l_Placement);
 l_Placement.rcNormalPosition := Rect(aLeft, aTop, aLeft + aWidth, aTop + aHeight);
 l_Placement.showCmd := SW_SHOWNORMAL;
 SetWindowPlacement(aHandle, @l_Placement);
end;

procedure TvcmMainForm.vcmMsgUpdateStatus(var Message: TMessage);
begin
 if g_Dispatcher <> nil then
  Dispatcher.UpdateStatus;
end;

end.
