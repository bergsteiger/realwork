unit uL3ParserVsNewParser;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, System.SysUtils, Vcl.Graphics, Winapi.Windows, System.Variants,
  Vcl.Dialogs, Vcl.Controls, Vcl.Forms, Winapi.Messages, System.Classes, uMain,
  l3Parser
  ,uTypes
  ;

type
 TTokenRec = record
  rToken : string;
  rTokenType : Tl3TokenType;
 constructor Create(const aToken : string; const aTokenType : Tl3TokenType);
 function ToString : String;
 class operator Equal(const Left, Right : TTokenRec) : Boolean;
 class operator NotEqual(const Left, Right : TTokenRec) : Boolean;
 end;

type
 TokenArray = array of TTokenRec;

type
 TL3ParserVsTNewParser = class(TTestCase)
  private
   f_NotEqualTestCount : Integer;
   f_ExceptionCount : Integer;
   function IsArraysEqual(const aArrayLeft, aArrayRight : TokenArray) : Boolean;
  published
   procedure First;
   procedure CheckTokenEquals;
   procedure CheckTokenNotEquals;
   procedure CheckArraysIsEqual;
   procedure CheckArraysIsNotEqual;
   procedure CheckArraysLengthIsNotEqual;
   procedure CheckArrayToString;
   procedure CheckL3Parser;
   procedure CheckTokenRecToString;
 end;

implementation

uses
 l3Filer
 ,l3Types
 ,System.TypInfo
 ,uNewParser
 ,l3Chars
 ,Generics.Collections
 ,msLog
 ;

 function ArrayToString(const aArray : TokenArray) : string;
 var
  l_I : integer;
 begin
  Result := '';
  for l_I := Low(aArray) to High(aArray) do
   Result := Result + ' ' + aArray[l_I].ToString + ' |';
 end;

{ TL3ParserVsTNewParser }
const
 cParseOptions = [l3_poCheckKeyWords,
                  l3_poCheckInt,
                  //l3_poCheckFloat,
                  //l3_poCheckHex,
                  //l3_poCheckComment,
                  //l3_poCheckStringBracket,
                  l3_poAddDigits2WordChars,
                  l3_poNullAsEOF];

procedure TL3ParserVsTNewParser.First;
begin
 Check(True);
end;

function TL3ParserVsTNewParser.IsArraysEqual(const aArrayLeft : TokenArray;
  const aArrayRight: TokenArray): Boolean;
var
 l_i : integer;
begin
 Result := False;
 if Length(aArrayLeft) <> Length(aArrayRight) then
  Exit;

 for l_i := Low(aArrayLeft) to High(aArrayRight) do
  if (aArrayLeft[l_i] <> aArrayRight[l_i]) then
   Exit;

 Result := True;
end;

procedure TL3ParserVsTNewParser.CheckArraysIsEqual;
var
 l_l3ParserTokens, l_NewParserTokens : TokenArray;
begin
 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

 l_l3ParserTokens[0].Create('qwe', l3_ttSymbol);
 l_NewParserTokens[0].Create('qwe', l3_ttSymbol);

 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

 l_l3ParserTokens[1].Create('asd', l3_ttSymbol);
 l_NewParserTokens[1].Create('asd', l3_ttSymbol);

 Check(IsArraysEqual(l_l3ParserTokens, l_NewParserTokens));
end;

procedure TL3ParserVsTNewParser.CheckArraysIsNotEqual;
var
 l_l3ParserTokens, l_NewParserTokens : TokenArray;
begin
 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

 l_l3ParserTokens[0].Create('qwe', l3_ttSymbol);
 l_NewParserTokens[0].Create('asd', l3_ttSymbol);

 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

 l_l3ParserTokens[1].Create('qwe', l3_ttSymbol);
 l_NewParserTokens[1].Create('asd', l3_ttSymbol);

 Check(not IsArraysEqual(l_l3ParserTokens, l_NewParserTokens));
end;

procedure TL3ParserVsTNewParser.CheckArraysLengthIsNotEqual;
var
 l_l3ParserTokens, l_NewParserTokens : TokenArray;
begin
 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 2);

 Check(not IsArraysEqual(l_l3ParserTokens, l_NewParserTokens));
end;

procedure TL3ParserVsTNewParser.CheckArrayToString;
var
 l_l3ParserTokens : TokenArray;
 l_ExpectedString : string;
begin
 SetLength(l_l3ParserTokens, 2);

 l_l3ParserTokens[0].rToken := 'ABC';
 l_l3ParserTokens[0].rTokenType := l3_ttSymbol;
 l_l3ParserTokens[1].rToken := 'CBA';
 l_l3ParserTokens[1].rTokenType := l3_ttSymbol;

 l_ExpectedString := ' ABC - l3_ttSymbol | CBA - l3_ttSymbol |';

 Check(ArrayToString(l_l3ParserTokens) = l_ExpectedString);
end;

procedure TL3ParserVsTNewParser.CheckL3Parser;
var
 l_ExceptionFileName : string;
 l_SR: TSearchRec;
 l_Path : string;
 l_Log : TmsLog;
 procedure DoSome(aName: string);
 var
  l_l3Parser : Tl3CustomParser;
  l_NewParser : TNewParser;
  l_Filer : Tl3DosFiler;
  l_l3ParserTokens, l_NewParserTokens : TokenArray;
  l_i : integer;
 begin
  try
   l_Filer := Tl3DosFiler.Make(aName);
   l_l3Parser := Tl3CustomParser.Create;
   try
    if (l_l3Parser <> nil) then
    begin
     l_l3Parser.CheckFloat := false;
     l_l3Parser.CheckComment := false;
     l_l3Parser.CheckStringBracket := false;
     l_l3Parser.AddDigits2WordChars := true;
     l_l3Parser.WordChars := l_l3Parser.WordChars +
                      cc_ANSIRussian +
                      [':', '.', '-', '+', '=', '<', '>', '?', '!', '&', '|',
                       '(', ')', '"', '@', '[', ']', ',',
                       '/', '^', '№', '~', '$', '%', '*', '\',
                       ';', '`'] +
                      cc_Digits;
     l_l3Parser.CheckStringBracket := false;
     // - не смотрим на символ '<' в строковых константах
     l_l3Parser.SkipSoftEnter := true;
     // - плюём на #10 модели, которые не смогли победить
     l_l3Parser.SkipHardEnter := true;
     // - плюём на #13 модели, которые не смогли победить
     l_l3Parser.CheckKeyWords := false;
     // - ключевые слова будем обрабатывать сами
    end;//f_Parser <> nil

    l_Filer.Open;
    l_l3Parser.Filer := l_Filer;

    SetLength(l_l3ParserTokens, 1);
    l_i := 0;
    while not (l_l3Parser.TokenType = l3_ttEOF) do
    begin
     l_l3Parser.NextToken;
     l_l3ParserTokens[l_i].Create(l_l3Parser.TokenString,
                                  l_l3Parser.TokenType);

     if l_l3Parser.TokenType <> l3_ttEOF then
      SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);

     Inc(l_i);
    end;
   finally
    FreeAndNil(l_Filer);
    FreeAndNil(l_l3Parser);
   end;

   l_NewParser := TNewParser.Create(aName);
   try
    SetLength(l_NewParserTokens, 1);
    l_i := 0;
    while not l_NewParser.EOF do
    begin
     l_NewParser.NextToken;
     l_NewParserTokens[l_i].Create(l_NewParser.TokenString,
                                   l_NewParser.TokenType);

     if l_NewParser.TokenType <> l3_ttEOF then
      SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

     Inc(l_i);
    end;

   finally
    FreeAndNil(l_NewParser);
   end;

  finally
   if not IsArraysEqual(l_l3ParserTokens, l_NewParserTokens) then
   begin
    Inc(f_NotEqualTestCount);
    l_Log.ToLog('----------------------------------------');
    l_Log.ToLog(aName);
    l_Log.ToLog('----------------------------------------');
    l_Log.ToLog('l_l3ParserTokens');
    l_Log.ToLog(ArrayToString(l_l3ParserTokens));
    l_Log.ToLog('l_NewParserTokens');
    l_Log.ToLog(ArrayToString(l_NewParserTokens));
   end;
  end;
 end;
begin
 l_ExceptionFileName := '';
 f_NotEqualTestCount := 0;
 f_ExceptionCount := 0;
 l_Path :=  '*.txt';
 l_Log := TmsLog.Create('UnEqualTokens.log');

 if FindFirst(l_Path, faAnyFile, l_SR) = 0 then
 begin
  repeat
    if (l_SR.Attr <> faDirectory) then
    begin
     try
      DoSome(l_SR.Name);
     except
      Inc(f_ExceptionCount);
      l_ExceptionFileName := l_ExceptionFileName + ' ' + l_SR.Name;
     end;
    end;
  until FindNext(l_SR) <> 0;
  FindClose(l_SR.FindHandle);
 end;
 l_Log.ToLog('NotEqualTestCount = ' + IntToStr(f_NotEqualTestCount));
 l_Log.ToLog('ExceptionTests = ' + IntToStr(f_ExceptionCount));
 l_Log.ToLog('ExceptionTests = ' + l_ExceptionFileName);
 FreeAndNil(l_Log);
end;

procedure TL3ParserVsTNewParser.CheckTokenEquals;
var
 l_Token1, l_Token2 : TTokenRec;
begin
 l_Token1 := TTokenRec.Create('qwe', l3_ttSymbol);
 l_Token2 := TTokenRec.Create('qwe', l3_ttSymbol);

 Check(l_Token1 = l_Token2);
end;

procedure TL3ParserVsTNewParser.CheckTokenNotEquals;
var
 l_Token1, l_Token2 : TTokenRec;
begin
 l_Token1 := TTokenRec.Create('qwe', l3_ttSymbol);
 l_Token2 := TTokenRec.Create('asd', l3_ttSymbol);

 Check(l_Token1 <> l_Token2);
end;

procedure TL3ParserVsTNewParser.CheckTokenRecToString;
var
 l_TokenRec : TTokenRec;
begin
 l_TokenRec := TTokenRec.Create('ABC', l3_ttSymbol);
 Check(l_TokenRec.ToString = 'ABC - l3_ttSymbol');
end;

{ TTokenRec }

constructor TTokenRec.Create(const aToken: string;
  const aTokenType: Tl3TokenType);
begin
 Self.rToken := aToken;
 Self.rTokenType := aTokenType;
end;

class operator TTokenRec.Equal(const Left, Right: TTokenRec): Boolean;
begin
 Result := False;
 if (Left.rToken = Right.rToken) and (Left.rTokenType = Right.rTokenType) then
  Result := True;
end;

class operator TTokenRec.NotEqual(const Left, Right: TTokenRec): Boolean;
begin
 Result := False;
 if (Left.rToken <> Right.rToken) or (Left.rTokenType <> Right.rTokenType) then
  Result := True;
end;

function TTokenRec.ToString: String;
begin
 Result := rToken + ' - ' + GetEnumName(TypeInfo(Tl3TokenType), Ord(self.rTokenType));
end;

initialization
  // Register any test cases with the test runner
 RegisterTest(TL3ParserVsTNewParser.Suite);
end.

