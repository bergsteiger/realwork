// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 17:17
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -iw:\ W:\shared\CoreSrv\SecuritySrvComm\SecuritySrvComm.idl" 
//                                                                            
unit SecuritySrvComm;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, SecuritySrvComm_int, RootSrv_int, RootSrv, poa_int, poa;

type

  TCoreSrv_AccessDenied_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:garant.ru/CoreSrv/AccessDenied:1.0 } 
  TCoreSrv_AccessDenied = class(UserException,ICoreSrv_AccessDenied)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TCoreSrv_AccessDenied); overload;
    constructor Create(); overload;
  end;

  {** IDL:garant.ru/CoreSrv/SessionInterceptor:1.0 } 
  TCoreSrv_SessionInterceptor = class(TORBObject,ICoreSrv_SessionInterceptor)
  protected
    procedure after_session_created(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID); virtual; abstract;
    procedure before_session_delete(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICoreSrv_SessionInterceptor;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:garant.ru/CoreSrv/SessionInterceptor:1.0} 
  TCoreSrv_SessionInterceptor_stub = class(TCoreSrv_SessionInterceptor)
  protected
    procedure after_session_created(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID); override;
    procedure before_session_delete(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID); override;
  end;

  {** POA stub for interface IDL:garant.ru/CoreSrv/SessionInterceptor:1.0} 
  TCoreSrv_SessionInterceptor_stub_clp = class(TPOAStub,IPOAStub,ICoreSrv_SessionInterceptor)
  protected
    procedure after_session_created(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID); virtual;
    procedure before_session_delete(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:garant.ru/CoreSrv/SessionInterceptor:1.0} 
  TCoreSrv_SessionInterceptor_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICoreSrv_SessionInterceptor)
  protected
    procedure after_session_created(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID); virtual; abstract;
    procedure before_session_delete(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICoreSrv_SessionInterceptor;
    class function _narrow(const srv : IServant): ICoreSrv_SessionInterceptor;
  end;

  TCoreSrv_SessionInterceptor_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TCoreSrv_AlreadyLogged_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:garant.ru/CoreSrv/AlreadyLogged:1.0 } 
  TCoreSrv_AlreadyLogged = class(UserException,ICoreSrv_AlreadyLogged)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TCoreSrv_AlreadyLogged); overload;
    constructor Create(); overload;
  end;

var
  CoreSrv_AccessDenied_marshaller : IStaticTypeInfo;
  CoreSrv_SessionInterceptor_marshaller : IStaticTypeInfo;
  CoreSrv_AlreadyLogged_marshaller : IStaticTypeInfo;
  _tc_CoreSrv_AccessDenied : ITypeCodeConst;
  _tc_CoreSrv_SessionInterceptor : ITypeCodeConst;
  _tc_CoreSrv_AlreadyLogged : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TCoreSrv_AccessDenied_marshaller
//***********************************************************
function TCoreSrv_AccessDenied_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TCoreSrv_AccessDenied_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:garant.ru/CoreSrv/AccessDenied:1.0');
  enc.except_end;
end;

procedure TCoreSrv_AccessDenied_marshaller._free(var addr: Pointer);
begin
  ICoreSrv_AccessDenied(addr^) := nil;
end;

procedure TCoreSrv_AccessDenied_marshaller._create(var addr: Pointer);
begin
  ICoreSrv_AccessDenied(addr^) := TCoreSrv_AccessDenied.Create();
end;

procedure TCoreSrv_AccessDenied_marshaller._assign(dst, src: Pointer);
begin
  ICoreSrv_AccessDenied(dst^) := ICoreSrv_AccessDenied(src^);
end;

function TCoreSrv_AccessDenied_marshaller.typecode: ITypeCode;
begin
  result := _tc_CoreSrv_AccessDenied.typecode;
end;

//***********************************************************
// TCoreSrv_AccessDenied
//***********************************************************
constructor TCoreSrv_AccessDenied.Create(ex: TCoreSrv_AccessDenied);
begin
  inherited Create();
end;

procedure TCoreSrv_AccessDenied.throw;
begin
  raise TCoreSrv_AccessDenied.Create(self);
end;

function TCoreSrv_AccessDenied.clone(): IORBException;
begin
  result := TCoreSrv_AccessDenied.Create(self);
end;

procedure TCoreSrv_AccessDenied.encode(const enc: IEncoder);
var
  int : ICoreSrv_AccessDenied;
begin
  int := self;
  CoreSrv_AccessDenied_marshaller.marshal(enc,@int);
end;

procedure TCoreSrv_AccessDenied.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(CoreSrv_AccessDenied_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TCoreSrv_AccessDenied.Create();
begin
  inherited Create();
end;

function TCoreSrv_AccessDenied.repoid(): RepositoryID;
begin
  result := 'IDL:garant.ru/CoreSrv/AccessDenied:1.0';
end;

//***********************************************************
// TCoreSrv_SessionInterceptor
//***********************************************************
function TCoreSrv_SessionInterceptor.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:garant.ru/CoreSrv/SessionInterceptor:1.0' then
    begin
      result := Pointer(self as ICoreSrv_SessionInterceptor);
      exit;
    end;
end;

class function TCoreSrv_SessionInterceptor._narrow(const obj : IORBObject): ICoreSrv_SessionInterceptor;
var
  p: Pointer;
  stub: TCoreSrv_SessionInterceptor_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:garant.ru/CoreSrv/SessionInterceptor:1.0');
  if p <> nil then
    result := ICoreSrv_SessionInterceptor(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:garant.ru/CoreSrv/SessionInterceptor:1.0') then
        begin
          stub := TCoreSrv_SessionInterceptor_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCoreSrv_SessionInterceptor.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:garant.ru/CoreSrv/SessionInterceptor:1.0'
end;

//***********************************************************
// TCoreSrv_SessionInterceptor_stub
//***********************************************************
procedure TCoreSrv_SessionInterceptor_stub.after_session_created(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID);
var
  req: IStaticRequest;
  _sid: IStaticAny;
  _uid: IStaticAny;
begin
  _sid := StaticAny(stat_ulong,@sid);
  _uid := StaticAny(stat_ulong,@uid);
  req := StaticRequest(self,'after_session_created');
  req.add_in_arg(_sid);
  req.add_in_arg(_uid);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TCoreSrv_SessionInterceptor_stub.before_session_delete(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID);
var
  req: IStaticRequest;
  _sid: IStaticAny;
  _uid: IStaticAny;
begin
  _sid := StaticAny(stat_ulong,@sid);
  _uid := StaticAny(stat_ulong,@uid);
  req := StaticRequest(self,'before_session_delete');
  req.add_in_arg(_sid);
  req.add_in_arg(_uid);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TCoreSrv_SessionInterceptor_stub_clp
//***********************************************************
function TCoreSrv_SessionInterceptor_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:garant.ru/CoreSrv/SessionInterceptor:1.0' then
    begin
      result := Pointer(self as ICoreSrv_SessionInterceptor);
      exit;
  end;
end;

procedure TCoreSrv_SessionInterceptor_stub_clp.after_session_created(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID);
var
  _srv: IServant;
  srv: ICoreSrv_SessionInterceptor;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoreSrv_SessionInterceptor_serv._narrow(_srv);
      if srv <> nil then
        srv.after_session_created(sid, uid)
    end;
  _postinvoke();
end;

procedure TCoreSrv_SessionInterceptor_stub_clp.before_session_delete(const sid: TCoreSrv_SessionID; const uid: TCoreSrv_UserID);
var
  _srv: IServant;
  srv: ICoreSrv_SessionInterceptor;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoreSrv_SessionInterceptor_serv._narrow(_srv);
      if srv <> nil then
        srv.before_session_delete(sid, uid)
    end;
  _postinvoke();
end;

//***********************************************************
// TCoreSrv_SessionInterceptor_serv
//***********************************************************
function TCoreSrv_SessionInterceptor_serv._this(): ICoreSrv_SessionInterceptor;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCoreSrv_SessionInterceptor._narrow(obj);
end;

function TCoreSrv_SessionInterceptor_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:garant.ru/CoreSrv/SessionInterceptor:1.0';
end;

function TCoreSrv_SessionInterceptor_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:garant.ru/CoreSrv/SessionInterceptor:1.0';
end;

function TCoreSrv_SessionInterceptor_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCoreSrv_SessionInterceptor_stub_clp.Create(poa,obj);
end;

procedure TCoreSrv_SessionInterceptor_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCoreSrv_SessionInterceptor_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:garant.ru/CoreSrv/SessionInterceptor:1.0' then
    begin
      result := Pointer(ICoreSrv_SessionInterceptor(self));
      exit;
    end;
end;

class function TCoreSrv_SessionInterceptor_serv._narrow(const srv : IServant): ICoreSrv_SessionInterceptor;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:garant.ru/CoreSrv/SessionInterceptor:1.0');
  if p <> nil then
    result := ICoreSrv_SessionInterceptor(p)
end;

function TCoreSrv_SessionInterceptor_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  after_session_created_sid: TCoreSrv_SessionID;
  after_session_created_uid: TCoreSrv_UserID;
  before_session_delete_sid: TCoreSrv_SessionID;
  before_session_delete_uid: TCoreSrv_UserID;
begin
  result := true;
  if req.op_name = 'after_session_created' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@after_session_created_sid) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@after_session_created_uid) as IStaticAny);
      if not req.read_args() then  exit;
      after_session_created(after_session_created_sid, after_session_created_uid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'before_session_delete' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@before_session_delete_sid) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@before_session_delete_uid) as IStaticAny);
      if not req.read_args() then  exit;
      before_session_delete(before_session_delete_sid, before_session_delete_uid);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCoreSrv_SessionInterceptor_marshaller
//***********************************************************
function TCoreSrv_SessionInterceptor_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICoreSrv_SessionInterceptor(addr^) := TCoreSrv_SessionInterceptor._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCoreSrv_SessionInterceptor_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICoreSrv_SessionInterceptor(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCoreSrv_SessionInterceptor_marshaller._free(var addr: Pointer);
begin
  ICoreSrv_SessionInterceptor(addr^) := nil;
end;

procedure TCoreSrv_SessionInterceptor_marshaller._create(var addr: Pointer);
begin
  ICoreSrv_SessionInterceptor(addr^) := TCoreSrv_SessionInterceptor_stub.Create();
end;

procedure TCoreSrv_SessionInterceptor_marshaller._assign(dst, src: Pointer);
begin
  ICoreSrv_SessionInterceptor(dst^) := ICoreSrv_SessionInterceptor(src^);
end;

function TCoreSrv_SessionInterceptor_marshaller.typecode: ITypeCode;
begin
  result := _tc_CoreSrv_SessionInterceptor.typecode;
end;

//***********************************************************
// TCoreSrv_AlreadyLogged_marshaller
//***********************************************************
function TCoreSrv_AlreadyLogged_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TCoreSrv_AlreadyLogged_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:garant.ru/CoreSrv/AlreadyLogged:1.0');
  enc.except_end;
end;

procedure TCoreSrv_AlreadyLogged_marshaller._free(var addr: Pointer);
begin
  ICoreSrv_AlreadyLogged(addr^) := nil;
end;

procedure TCoreSrv_AlreadyLogged_marshaller._create(var addr: Pointer);
begin
  ICoreSrv_AlreadyLogged(addr^) := TCoreSrv_AlreadyLogged.Create();
end;

procedure TCoreSrv_AlreadyLogged_marshaller._assign(dst, src: Pointer);
begin
  ICoreSrv_AlreadyLogged(dst^) := ICoreSrv_AlreadyLogged(src^);
end;

function TCoreSrv_AlreadyLogged_marshaller.typecode: ITypeCode;
begin
  result := _tc_CoreSrv_AlreadyLogged.typecode;
end;

//***********************************************************
// TCoreSrv_AlreadyLogged
//***********************************************************
constructor TCoreSrv_AlreadyLogged.Create(ex: TCoreSrv_AlreadyLogged);
begin
  inherited Create();
end;

procedure TCoreSrv_AlreadyLogged.throw;
begin
  raise TCoreSrv_AlreadyLogged.Create(self);
end;

function TCoreSrv_AlreadyLogged.clone(): IORBException;
begin
  result := TCoreSrv_AlreadyLogged.Create(self);
end;

procedure TCoreSrv_AlreadyLogged.encode(const enc: IEncoder);
var
  int : ICoreSrv_AlreadyLogged;
begin
  int := self;
  CoreSrv_AlreadyLogged_marshaller.marshal(enc,@int);
end;

procedure TCoreSrv_AlreadyLogged.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(CoreSrv_AlreadyLogged_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TCoreSrv_AlreadyLogged.Create();
begin
  inherited Create();
end;

function TCoreSrv_AlreadyLogged.repoid(): RepositoryID;
begin
  result := 'IDL:garant.ru/CoreSrv/AlreadyLogged:1.0';
end;

initialization
{!touched!}{$IfDef LogInit} WriteLn('W:\common\components\rtl\Garant\DUnitTuning\KPageTest2\SecuritySrvComm.pas initialization enter'); {$EndIf}
  CoreSrv_AccessDenied_marshaller := TCoreSrv_AccessDenied_marshaller.Create();
  CoreSrv_SessionInterceptor_marshaller := TCoreSrv_SessionInterceptor_marshaller.Create();
  CoreSrv_AlreadyLogged_marshaller := TCoreSrv_AlreadyLogged_marshaller.Create();
  _tc_CoreSrv_AccessDenied := CreateTypeCodeConst('010000001600000048000000010000002700000049444c3a676172616e742e72752f436f72655372762f41636365737344656e6965643a'+
    '312e3000000d00000041636365737344656e6965640000000000000000');
  _tc_CoreSrv_SessionInterceptor := CreateTypeCodeConst('010000000e0000004f000000010000002d00000049444c3a676172616e742e72752f436f72655372762f53657373696f6e496e74657263'+
    '6570746f723a312e30000000001300000053657373696f6e496e746572636570746f7200');
  _tc_CoreSrv_AlreadyLogged := CreateTypeCodeConst('010000001600000048000000010000002800000049444c3a676172616e742e72752f436f72655372762f416c72656164794c6f67676564'+
    '3a312e30000e000000416c72656164794c6f6767656400000000000000');
{!touched!}{$IfDef LogInit} WriteLn('W:\common\components\rtl\Garant\DUnitTuning\KPageTest2\SecuritySrvComm.pas initialization leave'); {$EndIf}
end.
