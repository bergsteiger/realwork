unit k2Base;
{* Базовые классы библиотеки K-2. }

{ Библиотека "K-2"        }
{ Автор: Люлин А.В. ©     }
{ Модуль: k2Base - }
{ Начат: 12.04.1998 11:28 }
{ $Id: k2Base.pas,v 1.891 2015/10/21 17:41:31 lulin Exp $ }

// $Log: k2Base.pas,v $
// Revision 1.891  2015/10/21 17:41:31  lulin
// {RequestLink:605383118}.
// - Добавляем фильтр некоторых стилей, которые глупо ставить на сегмент.
//
// Revision 1.890  2015/03/20 12:14:00  lukyanets
// Дополнительное логирование
//
// Revision 1.889  2015/03/12 15:32:48  lulin
// - перетряхиваем слова.
//
// Revision 1.888  2015/01/20 17:54:08  lulin
// http://mdp.garant.ru/pages/viewpage.action?pageId=586352031&focusedCommentId=586679370#comment-586679370
//
// Revision 1.887  2015/01/15 16:46:53  lulin
// - по-другому очищаем кеш.
//
// Revision 1.886  2015/01/15 16:30:16  lulin
// {RequestLink:585926571}. Время от времени очищаем кеш.
//
// Revision 1.885  2014/08/14 12:56:21  lulin
// - боремся с незащищёнными ресурсами.
//
// Revision 1.884  2014/07/17 15:23:05  lulin
// - делаем регистрацию схемы документа в скриптовой машине.
//
// Revision 1.883  2014/06/25 15:01:21  lulin
// - делаем регистрацию атрибутов в отдельном списке.
//
// Revision 1.882  2014/06/25 14:19:45  lulin
// - делаем регистрацию атрибутов в отдельном списке.
//
// Revision 1.881  2014/06/06 08:54:12  lulin
// - не падаем на невалидных данных, а лишь сообщаем в лог о их наличии.
//
// Revision 1.880  2014/05/12 16:39:12  lulin
// - меньше дёргаем счётчик ссылок.
//
// Revision 1.879  2014/05/12 15:46:48  lulin
// - чистим код.
//
// Revision 1.878  2014/04/30 15:03:20  lulin
// - выпрямляем зависимости.
//
// Revision 1.877  2014/04/29 10:36:10  lulin
// - чистим код.
//
// Revision 1.876  2014/04/29 10:29:04  lulin
// - чистим код.
//
// Revision 1.875  2014/04/29 10:15:28  lulin
// - реализуем интерфейс.
//
// Revision 1.874  2014/04/23 14:12:55  lulin
// - подтачиваем скрипты под новое виденье медалей.
//
// Revision 1.873  2014/04/23 12:05:13  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.872  2014/04/23 11:28:26  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.870  2014/04/22 17:32:36  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.869  2014/04/22 14:55:24  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.868  2014/04/22 14:20:18  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.867  2014/04/22 10:56:18  lulin
// - прячем ненужный метод.
//
// Revision 1.865  2014/04/21 17:21:26  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.864  2014/04/11 16:48:23  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.863  2014/04/11 15:30:47  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.862  2014/04/10 13:09:49  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.861  2014/04/10 12:09:57  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.860  2014/04/10 11:50:09  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.859  2014/04/09 10:34:50  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.858  2014/04/08 12:35:19  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.857  2014/04/08 07:04:15  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.856  2014/04/07 17:57:11  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.855  2014/04/03 17:10:38  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.854  2014/03/28 12:15:33  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.853  2014/03/25 16:23:47  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.852  2014/03/25 12:43:17  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.851  2014/03/25 11:53:36  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.850  2014/03/21 16:24:58  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.849  2014/03/20 14:52:25  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.848  2014/03/20 12:24:03  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.847  2014/03/20 08:07:40  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.846  2014/03/19 18:11:11  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.845  2014/03/19 16:26:16  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.844  2014/03/18 09:59:12  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.843  2014/03/18 06:52:06  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.842  2014/03/17 16:12:12  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.841  2014/03/14 13:27:33  lulin
// - удаляем ненужный интерфейс.
//
// Revision 1.840  2014/03/13 16:50:57  lulin
// - разделяем реализацию Tag и Box.
//
// Revision 1.839  2014/03/12 16:26:30  lulin
// - причёсываем код.
//
// Revision 1.838  2014/03/12 15:22:48  lulin
// - причёсываем код.
//
// Revision 1.837  2014/03/12 14:21:43  lulin
// - причёсываем код.
//
// Revision 1.836  2014/03/11 16:57:01  lulin
// - причёсываем код.
//
// Revision 1.835  2014/03/11 15:18:51  lulin
// - причёсываем код.
//
// Revision 1.834  2014/03/11 14:12:11  lulin
// - причёсываем код.
//
// Revision 1.833  2014/03/11 11:37:13  lulin
// - чистим код.
//
// Revision 1.832  2014/03/07 14:53:50  lulin
// - перетряхиваем списки тегов.
//
// Revision 1.831  2014/03/07 11:25:01  lulin
// - вставляем ловушки.
//
// Revision 1.830  2014/03/07 11:05:54  lulin
// - вычищаем ненужное.
//
// Revision 1.824  2014/03/06 17:23:26  lulin
// - избавляемся от теговых обёрток.
//
// Revision 1.823  2014/03/04 15:38:31  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.822  2014/03/04 14:23:49  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.821  2014/03/04 14:12:18  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.820  2014/03/04 13:16:58  lulin
// - переводим идентификаторы Sub'ов и сегментов на нормальные Enum'ы.
//
// Revision 1.819  2014/03/03 15:24:03  lulin
// - вставляем ловушки.
//
// Revision 1.818  2014/03/03 15:08:34  lulin
// - рефакторинг менеджера шрифтов.
//
// Revision 1.817  2014/02/28 14:54:26  lulin
// - перетряхиваем генераторы.
//
// Revision 1.816  2014/02/27 10:42:21  lulin
// - контроллируем атомарность тегов.
//
// Revision 1.815  2014/02/26 14:12:18  lulin
// {RequestLink:518768694}
//
// Revision 1.814  2014/02/25 17:45:53  lulin
// - правим прозрачность.
//
// Revision 1.813  2014/02/25 17:01:03  lulin
// - причёсываем код.
//
// Revision 1.812  2014/02/25 11:35:53  lulin
// - bug fix: не падаем когда присваивают поток, а не пул.
//
// Revision 1.811  2014/02/21 18:08:43  lulin
// - избавляемся от обёрток над тегами.
//
// Revision 1.810  2014/02/21 17:34:44  lulin
// - избавляемся от обёрток над тегами.
//
// Revision 1.809  2014/02/21 17:23:19  lulin
// - избавляемся от обёрток над тегами.
//
// Revision 1.808  2014/02/21 12:32:45  lulin
// - избавляемся от обёрток над тегами.
//
// Revision 1.807  2014/02/20 10:49:49  lulin
// - переводим словари на теги.
//
// Revision 1.806  2014/02/19 13:17:36  lulin
// {RequestLink:517768790}
//
// Revision 1.805  2014/02/18 16:31:25  lulin
// - подготавливаемся к обобщению словарей.
//
// Revision 1.804  2014/02/18 11:33:18  lulin
// {RequestLink:517479550}
//
// Revision 1.803  2014/02/17 16:26:01  lulin
// - избавляемся от ошибок молодости.
//
// Revision 1.802  2014/02/14 16:27:12  lulin
// - избавляемся от ошибок молодости.
//
// Revision 1.801  2014/02/14 09:51:01  lulin
// - bug fix: [$516869361]
//
// Revision 1.800  2014/02/13 17:14:37  lulin
// - рефакторим безликие списки.
//
// Revision 1.799  2014/02/13 16:13:14  lulin
// - рефакторим безликие списки.
//
// Revision 1.798  2014/02/13 13:53:29  lulin
// - рефакторим безликие списки.
//
// Revision 1.797  2013/12/26 14:57:11  lulin
// {RequestLink:509706011}
//
// Revision 1.796  2013/12/26 12:49:18  lulin
// {RequestLink:509706011}
//
// Revision 1.795  2013/12/25 15:10:33  lulin
// {RequestLink:509706011}
// - перетрясаем модель.
//
// Revision 1.794  2013/11/11 11:36:24  lulin
// - вычищаем ненужное.
//
// Revision 1.793  2013/11/07 10:00:37  lulin
// - вычищаем устаревшие ненужные классы.
//
// Revision 1.792  2013/11/07 09:00:16  lulin
// - вычищаем устаревшие ненужные классы.
//
// Revision 1.791  2013/11/05 12:59:20  lulin
// - вставляем ловушечку.
//
// Revision 1.790  2013/11/05 12:37:44  lulin
// - атомарные теги теперь реализуются специальным классом реализации для каждого типа тега.
//
// Revision 1.789  2013/11/01 14:24:10  lulin
// - упрощаем поиск типа по идентификатору.
//
// Revision 1.788  2013/10/28 10:07:56  lulin
// - готовимся к смене типа значения по-муоолчанию.
//
// Revision 1.787  2013/10/24 14:02:08  lulin
// - кешируем атомарные теги.
//
// Revision 1.786  2013/10/23 16:04:44  lulin
// - правильнее определяем "автоматические" типы.
//
// Revision 1.785  2013/10/23 15:35:45  lulin
// - правильнее определяем "автоматические" типы.
//
// Revision 1.784  2013/10/23 15:03:57  lulin
// - правильнее определяем "автоматические" типы.
//
// Revision 1.783  2013/10/23 15:00:20  lulin
// - правильнее определяем "автоматические" типы.
//
// Revision 1.782  2013/10/23 12:26:04  lulin
// - автоматически определяемые типы тоже генерируем с модели.
//
// Revision 1.781  2013/10/22 09:21:28  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.780  2013/10/21 17:31:10  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.779  2013/10/21 15:43:13  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.778  2013/10/21 10:31:01  lulin
// - потихоньку избавляемся от использования идентификаторов типов тегов.
//
// Revision 1.777  2013/10/18 08:01:18  lulin
// - работа по избавлению от ненужного Enum.
//
// Revision 1.776  2013/10/17 17:15:58  lulin
// - работа по избавлению от ненужного Enum.
//
// Revision 1.775  2013/10/17 16:47:01  lulin
// - работа по избавлению от ненужного Enum.
//
// Revision 1.774  2013/10/17 14:48:53  lulin
// - работа по избавлению от ненужного Enum.
//
// Revision 1.773  2013/10/17 14:11:51  lulin
// - работа по избавлению от ненужного Enum.
//
// Revision 1.771  2013/04/09 11:08:14  lulin
// - пытаемся отладиться под XE.
//
// Revision 1.770  2013/04/04 11:21:37  lulin
// - портируем.
//
// Revision 1.769  2012/11/01 09:42:54  lulin
// - забыл точку с запятой.
//
// Revision 1.768  2012/11/01 07:45:04  lulin
// - делаем возможность логирования процесса загрузки модулей.
//
// Revision 1.767  2012/10/26 17:36:46  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.766  2012/07/24 18:01:08  lulin
// {RequestLink:378540022}.
//
// Revision 1.765  2012/07/12 18:33:21  lulin
// {RequestLink:237994598}
//
// Revision 1.764  2012/01/30 14:06:03  lulin
// {RequestLink:332563400}
//
// Revision 1.763  2011/12/20 11:07:26  lulin
// - меняем тип параметра.
//
// Revision 1.762  2011/09/28 17:13:04  lulin
// {RequestLink:284165571}.
//
// Revision 1.761  2011/08/04 09:45:11  dinishev
// [$235058873]. Округление для маркеров.
//
// Revision 1.760  2011/07/26 13:22:36  lulin
// {RequestLink:275780190}.
//
// Revision 1.759  2011/07/07 19:54:50  lulin
// {RequestLink:228688745}.
//
// Revision 1.758  2011/05/23 15:33:31  lulin
// {RequestLink:266423791}.
//
// Revision 1.757  2011/05/18 17:45:49  lulin
// {RequestLink:266409354}.
//
// Revision 1.756  2011/05/17 14:55:12  lulin
// {RequestLink:266409354}.
//
// Revision 1.755  2010/11/25 14:16:28  lulin
// {RequestLink:238945411}.
// - по-другому обрабатываем флаги модифицированности.
//
// Revision 1.754  2010/11/24 20:16:32  lulin
// {RequestLink:238945411}.
//
// Revision 1.753  2010/11/03 16:20:04  lulin
// {RequestLink:238947629}.
// - правим ошибку клонирования свойства тега, которая приводила к кривизне схемы и зависанию.
//
// Revision 1.752.2.1  2010/11/03 15:52:04  lulin
// {RequestLink:238947629}.
// - определяем, что элемент олавления может иметь идентификатор.
// - правим ошибку клонирования свойства тега, которая приводила к кривизне схемы и зависанию.
//
// Revision 1.752  2010/06/17 12:45:19  lulin
// Отвалился тест [SHD:TextLoad] [SHD:LoadBigTableFromTextEVD] т.к. он содержит блоки в таблице. Из-за - {RequestLink:215548927}.
//
// Revision 1.751  2010/06/16 15:35:46  lulin
// {RequestLink:215548927}.
//
// Revision 1.750  2010/06/15 14:09:36  lulin
// {RequestLink:215548927}.
// - настраиваем инфраструктуру.
//
// Revision 1.749  2010/04/19 12:22:51  lulin
// {RequestLink:140286381}.
// - используем итератор.
//
// Revision 1.748  2010/04/14 10:31:20  lulin
// {RequestLink:203129522}.
//
// Revision 1.747  2010/04/12 14:53:52  lulin
// {RequestLink:203129570}.
// - убираем ненужный тип подитеративной функции.
//
// Revision 1.746  2010/04/12 14:16:31  lulin
// {RequestLink:203129570}.
//
// Revision 1.745  2010/04/09 16:02:39  lulin
// {RequestLink:201493388}.
//
// Revision 1.744  2010/03/30 17:50:29  lulin
// {RequestLink:198672902}.
// - учимся обрабатывать вложенные вызовы итераторов.
//
// Revision 1.743  2010/02/24 18:37:30  lulin
// - перепутал условие.
//
// Revision 1.742  2010/02/24 18:15:45  lulin
// - избавляемся от ненужного и вредного параметра, доставшегося в наследство от ошибок молодости.
//
// Revision 1.741  2009/12/22 11:58:34  lulin
// {RequestLink:174719000}.
//
// Revision 1.740  2009/12/15 10:56:32  lulin
// - не дёргаем дурацкий динамический метод.
//
// Revision 1.739  2009/07/28 10:24:49  voba
// - bug fix от Шуры
//
// Revision 1.738  2009/07/27 07:15:03  lulin
// Недоделки по {RequestLink:141264340}. №44.
//
// Revision 1.737  2009/07/24 13:06:39  lulin
// - bug fix: не собиралось тестовое приложение в ветке.
//
// Revision 1.736  2009/07/23 19:31:17  lulin
// - bug fix: не работал Немезис.
//
// Revision 1.735  2009/07/23 18:22:02  lulin
// - вычищаем ненужный враппер тега.
//
// Revision 1.734  2009/07/23 17:28:54  lulin
// - убираем ненужный запрос интерфейса.
// - правим наследование у SomeDataContainer.
//
// Revision 1.733  2009/07/23 13:42:34  lulin
// - переносим процессор операций туда куда надо.
//
// Revision 1.732  2009/07/22 18:04:56  lulin
// - не пишем статистику по тегам.
//
// Revision 1.731  2009/07/22 17:46:40  lulin
// - bug fix: не работало тестовое приложение в ветке.
//
// Revision 1.730  2009/07/22 17:16:40  lulin
// - оптимизируем использование счётчика ссылок и преобразование к интерфейсам при установке атрибутов тегов.
//
// Revision 1.729  2009/07/22 14:05:27  lulin
// - bug fix: не собиралось и не работало тестовое приложение в ветке.
//
// Revision 1.728  2009/07/22 12:29:56  lulin
// - пытаемся оптимизировать установку атомарных тегов.
//
// Revision 1.727  2009/07/21 18:23:16  lulin
// - подготавливаемся к уменьшению преобразования типов при записи атрибутов.
//
// Revision 1.726  2009/07/21 16:38:39  lulin
// - убираем ненужное создание нулевого объекта.
//
// Revision 1.725  2009/07/21 16:23:37  lulin
// - убран ненужный параметр.
//
// Revision 1.724  2009/07/21 16:00:05  lulin
// - учитываем, что строка теперь имеет другой корень наследования.
//
// Revision 1.723  2009/07/21 15:10:16  lulin
// - bug fix: не собирался и не работал Архивариус в ветке.
//
// Revision 1.722  2009/07/21 14:36:10  lulin
// - убираем поддержку IUnknown со строк.
//
// Revision 1.721  2009/07/21 13:10:09  lulin
// - вставляем Assert на непонятную функциональность.
//
// Revision 1.720  2009/07/20 14:13:44  lulin
// - разрешаем конфликт имён.
//
// Revision 1.719  2009/07/20 12:49:39  lulin
// - подготавливаемся к переносу изменений в ветку.
//
// Revision 1.718  2009/07/17 13:47:23  lulin
// - bug fix: неправильно обрабатывали удаление дочерних тегов.
//
// Revision 1.717  2009/07/17 12:42:02  lulin
// {RequestLink:141264340}. №7, 32, 33.
//
// Revision 1.716  2009/07/16 10:43:38  lulin
// - в тесте выводим статистику по тегам.
//
// Revision 1.715  2009/07/15 15:12:25  lulin
// - удалено ненужное свойство списков параграфов.
//
// Revision 1.714  2009/07/15 10:20:44  lulin
// - bug fix: неправильно писались атрибуты в виде "стилей".
//
// Revision 1.713  2009/07/10 15:04:49  lulin
// - избавляемся от лишнего дёрганья счётчиков ссылок.
//
// Revision 1.712  2009/07/09 14:54:29  lulin
// {RequestLink:140837386}. №3.
//
// Revision 1.711  2009/07/08 12:27:11  lulin
// - bug fix: не собирался Эверест в ветке.
//
// Revision 1.710  2009/07/07 14:18:01  lulin
// - реализуем определение имени описателей в базовых объектах.
//
// Revision 1.709  2009/07/07 12:58:15  lulin
// - избавляемся от ненужной виртуальности.
//
// Revision 1.708  2009/07/07 11:46:20  lulin
// - избавляемся от ненужной виртуальности.
//
// Revision 1.707  2009/07/07 10:48:27  lulin
// - вычищаем ненужный интерфейс.
//
// Revision 1.706  2009/07/07 09:54:04  lulin
// - bug fix: не собирался Эверест в ветке.
//
// Revision 1.705  2009/07/07 09:23:57  lulin
// - вычищаем ненужный интерфейс.
//
// Revision 1.704  2009/07/07 08:58:27  lulin
// - вычищаем ненужное.
//
// Revision 1.703  2009/07/06 16:57:40  lulin
// - вычищаем ненужное.
//
// Revision 1.702  2009/07/06 16:28:47  lulin
// - вычищаем ненужное.
//
// Revision 1.701  2009/07/06 15:46:29  lulin
// - возвращаемся от интерфейсов к объектам.
//
// Revision 1.700  2009/07/06 13:32:12  lulin
// - возвращаемся от интерфейсов к объектам.
//
// Revision 1.699  2009/07/06 11:13:24  lulin
// - переносим примеси в более базовый пакет.
//
// Revision 1.698  2009/07/03 17:05:31  lulin
// - шаг к переходу от интерфейсов к объектам.
//
// Revision 1.697  2009/07/03 16:24:13  lulin
// - шаг к переходу от интерфейсов к объектам.
//
// Revision 1.696  2009/07/01 15:26:10  lulin
// - убрана ненужная функциональность.
//
// Revision 1.695  2009/06/29 14:35:18  lulin
// - убираем рассылку лишних нотификаций.
//
// Revision 1.694  2009/06/29 05:59:11  lulin
// - не рассылаем никому ненужную нотификацию.
//
// Revision 1.693  2009/06/24 15:53:23  lulin
// {RequestLink:140286381}.
//
// Revision 1.692  2009/04/14 18:12:01  lulin
// [$143396720]. Подготовительная работа.
//
// Revision 1.691  2009/04/07 16:09:48  lulin
// [$140837386]. №13.
//
// Revision 1.690  2009/04/07 15:11:49  lulin
// [$140837386]. №13. Чистка кода.
//
// Revision 1.689  2009/03/25 16:11:19  voba
// - не компилялось
//
// Revision 1.688  2009/03/24 18:42:58  lulin
// - убраны ненужные свойства.
//
// Revision 1.687  2009/03/24 17:45:48  lulin
// [$137465982]. Избавляемся от ненужных промежуточных классов №2.
//
// Revision 1.686  2009/03/24 17:15:07  lulin
// [$137465982]. Избавляемся от ненужных промежуточных классов.
//
// Revision 1.685  2009/03/24 17:01:23  lulin
// [$137465982]. №5.
//
// Revision 1.684  2009/03/16 11:28:10  oman
// - fix: Не падаем на аварийном завершении (К-139436640)
//
// Revision 1.683  2009/03/11 12:08:36  lulin
// - <K>: 139429761. Гарантируем, что дети идут после всех тегов.
//
// Revision 1.682  2009/03/05 18:42:13  lulin
// - <K>: 137470629. Собираем Эверест в ветке.
//
// Revision 1.681  2009/03/05 17:23:58  lulin
// - <K>: 137470629. Для ветки тоже генерируем ссылки на теги.
//
// Revision 1.680  2009/03/05 17:04:37  lulin
// - <K>: 137470629. Чистка кода.
//
// Revision 1.679  2009/03/05 16:46:34  lulin
// - <K>: 137470629. Убран ненужный интерфейс.
//
// Revision 1.678  2009/03/05 16:20:42  lulin
// - <K>: 137470629. Убрана ненужная ссылка на тип по идентификатору.
//
// Revision 1.677  2009/03/05 15:43:23  lulin
// - <K>: 137470629. Убран ненужный метод.
//
// Revision 1.676  2009/03/05 09:45:01  lulin
// - <K>: 137470629. Генерируем ссылки на типы.
// - bg fix: перегенерировал, т.к. были ссылки на несуществующие модули.
//
// Revision 1.675  2009/03/04 19:01:59  lulin
// - <K>: 137470629. Удаляем ненужный тип.
//
// Revision 1.674  2009/03/04 17:38:13  lulin
// - <K>: 137470629. Удалён ненужный интерфейс.
//
// Revision 1.673  2009/03/04 17:20:04  lulin
// - <K>: 137470629. Избавляемся от ненужного использования интерфейса.
//
// Revision 1.672  2009/03/04 16:47:55  lulin
// - <K>: 137470629. Bug fix: не собирался Эверест в ветке.
//
// Revision 1.671  2009/03/04 13:33:11  lulin
// - <K>: 137470629. Генерируем идентификаторы типов с модели и убираем их из общей помойки.
//
// Revision 1.670  2009/03/03 12:46:15  lulin
// - <K>: 137465982. Отвязываемся от внутреннего определения дочерних типов.
//
// Revision 1.669  2009/03/03 09:40:50  lulin
// - <K>: 137465982. Выделяем метод для определения детей.
//
// Revision 1.668  2009/03/02 11:41:12  lulin
// - <K>: 137465982. Делаем генерацию свойств представляемых классами, так чтобы можно было отказаться от фиксированных идентификаторов.
//
// Revision 1.667  2009/02/27 19:05:06  lulin
// - <K>: 137465982. Добавляем в конструктор свойства необходимые параметры.
//
// Revision 1.666  2009/02/27 16:59:50  lulin
// - <K>: 137465982. Добавляем в конструктор дочернего свойства необходимые параметры.
//
// Revision 1.665  2009/02/27 16:52:49  lulin
// - <K>: 137465982. Используем контроль типов.
//
// Revision 1.663  2009/02/27 16:38:38  lulin
// - <K>: 137465982. Чистка кода.
//
// Revision 1.662  2009/02/27 14:23:00  lulin
// - <K>: 137465982. Делаем генерацию свойств перечислимых типов, так чтобы можно было отказаться от фиксированных идентификаторов.
//
// Revision 1.661  2009/02/27 13:35:48  oman
// - fix: Разруливаем дедлоки (К-135595449)
//
// Revision 1.660  2009/02/27 10:01:46  lulin
// - <K>: 137465982. Делаем генерацию свойств-массивов, так чтобы можно было отказаться от фиксированных идентификаторов.
//
// Revision 1.659  2009/02/27 07:14:58  lulin
// - <K>: 137465982. №26.
//
// Revision 1.658  2009/02/26 15:52:39  lulin
// - <K>: 137465982. №4.
//
// Revision 1.657  2009/02/26 15:11:52  lulin
// - <K>: 137465982. №3.
//
// Revision 1.656  2009/02/26 13:53:49  lulin
// - <K>: 137465982. Чистка кода..
//
// Revision 1.655  2009/02/26 13:30:33  lulin
// - <K>: 137465982. Чистка кода..
//
// Revision 1.654  2009/02/26 12:25:10  lulin
// - <K>: 137465982. №1
//
// Revision 1.653  2009/02/26 10:21:28  lulin
// - <K>: 137465982. №1
//
// Revision 1.652  2009/02/26 09:35:46  lulin
// - <K>: 137465982.
//
// Revision 1.651  2009/02/26 08:58:38  lulin
// - чистка кода.
//
// Revision 1.650  2009/02/26 08:25:34  lulin
// - чистка кода.
//
// Revision 1.649  2008/12/12 19:19:28  lulin
// - <K>: 129762414.
//
// Revision 1.648  2008/09/26 17:04:07  lulin
// - <K>: 119475439.
//
// Revision 1.647  2008/08/26 11:22:06  lulin
// - чистка кода.
//
// Revision 1.646  2008/07/04 10:27:44  lulin
// - <K>: 98828572.
//
// Revision 1.645  2008/06/25 14:47:59  lulin
// - сделана возможность использовать предопределённые значения для рамок.
//
// Revision 1.644  2008/06/24 13:07:54  lulin
// - определяем стили на модели.
//
// Revision 1.643  2008/06/19 09:20:09  lulin
// - bug fix: падала генерация схемы EVD.
//
// Revision 1.642  2008/06/18 11:00:58  lulin
// - bug fix: падал Эверест.
//
// Revision 1.641  2008/06/18 10:38:30  lulin
// - падали когда в nsTagNode в коде (k2.TypeTable _As _Ik2TypeTableEx)[aNode.GetType]  значение aNode.GetType было равно 0 - псевдонода оглавления.
//
// Revision 1.640  2008/06/18 10:07:39  lulin
// - не сохраняем ссылки на типы тегов внутри базовой таблицы тегов.
//
// Revision 1.639  2008/06/18 09:54:19  lulin
// - очищаем типы тегов в сгенерированном коде.
//
// Revision 1.638  2008/06/18 09:24:26  lulin
// - cleanup.
//
// Revision 1.637  2008/06/18 09:21:43  lulin
// - определяем функцию получения типа по ID.
//
// Revision 1.636  2008/06/18 08:54:59  lulin
// - избавляемся от ненужного использования интерфейса.
//
// Revision 1.635  2008/06/18 08:49:52  lulin
// - обеспечиваем автоматическое связывание с указанной таблицей тегов.
//
// Revision 1.634  2008/06/18 08:17:34  lulin
// - поддерживаем singleton для таблицы тегов на системном уровне.
//
// Revision 1.633  2008/06/17 21:19:57  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.632  2008/06/17 20:44:48  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.631  2008/06/10 19:38:31  lulin
// - генерируем функции для создания экземпляров тегов.
//
// Revision 1.630  2008/06/10 14:38:40  lulin
// - храним ссылки на типы в полях таблицы тегов.
//
// Revision 1.629  2008/06/10 14:00:36  lulin
// - таблицы тегов генерируем как классы.
//
// Revision 1.628  2008/06/09 15:29:58  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.627  2008/06/09 14:03:31  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.626  2008/06/09 06:11:01  lulin
// - bug fix: не собирался Архивариус.
//
// Revision 1.625  2008/06/07 15:37:11  lulin
// - используем сгенерированную таблицу тегов.
//
// Revision 1.624  2008/06/06 16:01:20  lulin
// - <K>: 93264011.
//
// Revision 1.623  2008/05/23 12:03:18  lulin
// - заплатка для старых SBS.
//
// Revision 1.622  2008/05/12 15:11:05  lulin
// - удалены ненужные интерфейсы.
//
// Revision 1.621  2008/04/16 12:26:35  lulin
// - cleanup.
//
// Revision 1.620  2008/04/15 12:25:06  dinishev
// Защищаемся от перегенерации
//
// Revision 1.619  2008/04/15 09:09:06  lulin
// - перекладываем исключение.
//
// Revision 1.618  2008/04/15 09:03:23  lulin
// - правим название директив - чтобы соответствовали смыслу.
//
// Revision 1.617  2008/04/15 08:25:45  dinishev
// Восстанавливаем старый редактор
//
// Revision 1.616  2008/02/21 19:24:16  lulin
// - упрощаем наследование.
//
// Revision 1.615  2008/02/21 16:04:28  lulin
// - упрощаем наследование.
//
// Revision 1.613  2008/02/21 13:48:21  lulin
// - cleanup.
//
// Revision 1.612  2008/02/21 10:55:13  lulin
// - упрощаем наследование.
//
// Revision 1.611  2008/02/20 19:01:27  lulin
// - удалён ненужный тип.
//
// Revision 1.610  2008/02/20 17:23:07  lulin
// - упрощаем строки.
//
// Revision 1.609  2008/02/20 12:39:14  lulin
// - определены методы сравнения тега.
//
// Revision 1.608  2008/02/19 11:05:58  lulin
// - восстановил всякие экзотические поиски в списках объектов.
//
// Revision 1.607  2008/02/18 17:04:26  lulin
// - подчистил логику списков, связанную с сортированностью и добавлением элемента.
//
// Revision 1.606  2008/02/14 17:09:12  lulin
// - cleanup.
//
// Revision 1.605  2008/02/14 09:40:41  lulin
// - удалён ненужный класс.
//
// Revision 1.604  2008/02/13 20:20:13  lulin
// - <TDN>: 73.
//
// Revision 1.603  2008/02/12 12:53:20  lulin
// - избавляемся от излишнего метода на базовом классе.
//
// Revision 1.602  2008/02/11 18:30:43  lulin
// - чистим ненужный код.
//
// Revision 1.601  2008/02/11 18:16:33  lulin
// - наводим красоту.
//
// Revision 1.600  2008/02/11 11:13:55  lulin
// - чистка списков.
//
// Revision 1.599  2008/02/08 17:59:19  lulin
// - теперь теги в списках храним как теги, а не как объекты.
//
// Revision 1.598  2008/02/08 17:06:20  lulin
// - класс _Tk2TagObject переехал на модель.
//
// Revision 1.597  2008/02/07 19:13:15  lulin
// - избавляемся от излишне универсальных методов базовых списков.
//
// Revision 1.596  2008/02/07 16:19:20  lulin
// - наводим порядок с наследованием и перекрытием методов.
//
// Revision 1.595  2008/02/06 15:37:08  lulin
// - каждому базовому объекту по собственному модулю.
//
// Revision 1.594  2008/02/06 09:55:29  lulin
// - глобальные объекты сделаны индексированным свойством.
//
// Revision 1.593  2008/02/05 18:20:39  lulin
// - удалено ненужное свойство строк.
//
// Revision 1.592  2008/02/05 09:58:09  lulin
// - выделяем базовые объекты в отдельные файлы и переносим их на модель.
//
// Revision 1.591  2008/02/01 15:14:52  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.590  2008/01/31 20:09:57  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.589  2007/12/24 15:25:30  lulin
// - удалены ненужные файлы.
//
// Revision 1.588  2007/12/05 14:15:14  lulin
// - восстановлена поддержка подписей в очень старых документах.
//
// Revision 1.587  2007/12/05 12:35:08  lulin
// - вычищен условный код, составлявший разницу ветки и Head'а.
//
// Revision 1.586  2007/09/21 12:10:47  lulin
// - bug fix: падали при сохранении документа, при отсутствии процессора.
//
// Revision 1.585  2007/09/17 18:26:14  lulin
// - вставлена диагностика того, что наследуемый тип тегов имеет такую же реализацию, как и родительский.
//
// Revision 1.584  2007/09/17 18:04:15  lulin
// - проверяем корректность определения таблицы тегов.
//
// Revision 1.583  2007/09/14 13:26:19  lulin
// - объединил с веткой B_Tag_Clean.
//
// Revision 1.582.2.25  2007/09/14 12:34:21  lulin
// - убрана дублирующаяся функциональность.
//
// Revision 1.582.2.24  2007/09/13 18:09:19  lulin
// - не спрашиваем интерфейс тега у объекта, который его заведомо не поддерживает.
//
// Revision 1.582.2.23  2007/09/13 17:51:45  lulin
// - упрощаем получение интерфейса у объекта - кешируем раз и навсегда информацию о смещении, которая вычисляется не очень уж просто.
//
// Revision 1.582.2.22  2007/09/13 17:18:32  lulin
// - удален, ставший ненужным фабричный метод.
//
// Revision 1.582.2.21  2007/09/13 16:38:59  lulin
// - проверку прозрачности переносим в другое место.
//
// Revision 1.582.2.20  2007/09/13 16:15:51  lulin
// - удален старый класс для атомарных тегов.
//
// Revision 1.582.2.19  2007/09/13 15:54:41  lulin
// - используем новый объект для атомарных тегов.
//
// Revision 1.582.2.18  2007/09/13 15:12:47  lulin
// - в первом приближении реализован атомарный тег.
//
// Revision 1.582.2.17  2007/09/13 13:21:19  lulin
// - добавлен новый модуль.
//
// Revision 1.582.2.16  2007/09/13 12:51:33  lulin
// - cleanup.
//
// Revision 1.582.2.15  2007/09/13 12:36:00  lulin
// - переименовано свойство.
//
// Revision 1.582.2.14  2007/09/13 12:00:04  lulin
// - убран ненужный метод.
//
// Revision 1.582.2.13  2007/09/13 11:53:31  lulin
// - убран ненужный метод.
//
// Revision 1.582.2.12  2007/09/12 20:23:52  lulin
// - возвращаем булевский результат, а не какой-то там код ошибки, который нафиг никому не нужен.
//
// Revision 1.582.2.11  2007/09/12 20:13:10  lulin
// - cleanup.
//
// Revision 1.582.2.10  2007/09/12 18:12:10  lulin
// - cleanup.
//
// Revision 1.582.2.9  2007/09/12 18:06:03  lulin
// - cleanup.
//
// Revision 1.582.2.8  2007/09/12 17:56:17  lulin
// - убрана ненужная функциональность.
//
// Revision 1.582.2.7  2007/09/12 17:51:50  lulin
// - cleanup.
//
// Revision 1.582.2.6  2007/09/12 17:19:06  lulin
// - убран ненужный параметр.
//
// Revision 1.582.2.5  2007/09/12 17:08:18  lulin
// - cleanup.
//
// Revision 1.582.2.4  2007/09/12 17:02:07  lulin
// - убран ненужный параметр по-умолчанию.
//
// Revision 1.582.2.3  2007/09/12 16:38:31  lulin
// - переименовано свойство.
//
// Revision 1.582.2.2  2007/09/12 16:14:12  lulin
// - убран ненужный параметр по-умолчанию.
//
// Revision 1.582.2.1  2007/09/12 15:23:11  lulin
// - избавляемся от метода, дублирующего функциональность получения атрибута.
//
// Revision 1.582  2007/09/11 18:50:04  lulin
// - удален ненужный параметр.
//
// Revision 1.581  2007/09/10 10:49:58  lulin
// - bug fix: не учитывали прозрачность.
//
// Revision 1.580  2007/09/10 10:20:59  lulin
// - падали с Assert (CQ OIT5-26635).
//
// Revision 1.579  2007/09/10 10:19:27  lulin
// - удален ненужный метод.
//
// Revision 1.578  2007/09/07 19:02:14  lulin
// - удален ненужный параметр.
//
// Revision 1.577  2007/09/07 18:50:54  lulin
// - удалены ненужные значения по-умолчанию.
//
// Revision 1.576  2007/09/07 14:17:08  lulin
// - вычищена функциональность, ненужная в ветке.
//
// Revision 1.575  2007/09/07 11:59:52  lulin
// - убрана ненужная нотификация.
//
// Revision 1.574  2007/09/07 10:48:07  lulin
// - оптимизируем преобразование атомарных тегов.
//
// Revision 1.573  2007/09/07 09:16:19  lulin
// - убран ненужный параметр.
//
// Revision 1.572  2007/09/07 09:07:25  lulin
// - cleanup.
//
// Revision 1.571  2007/09/07 08:51:28  lulin
// - cleanup.
//
// Revision 1.570  2007/09/07 08:27:33  lulin
// - теперь тегам можно устанавливать свойства в виде объектов.
//
// Revision 1.569  2007/09/06 15:21:28  lulin
// - переименовано свойство.
//
// Revision 1.568  2007/09/06 09:37:45  lulin
// - переименовано свойство.
//
// Revision 1.567  2007/09/04 18:06:22  lulin
// - cleanup.
//
// Revision 1.566  2007/09/04 17:27:43  lulin
// - убран ненужный параметр.
//
// Revision 1.565  2007/09/04 16:35:46  lulin
// - переименована структура данных.
//
// Revision 1.564  2007/09/04 16:29:06  lulin
// - cleanup.
//
// Revision 1.563  2007/09/04 15:54:20  lulin
// - убран ненужный параметр.
//
// Revision 1.562  2007/09/04 15:45:14  lulin
// - убран ненужный параметр.
//
// Revision 1.561  2007/09/04 14:24:58  lulin
// - убран ненужный параметр.
//
// Revision 1.560  2007/09/03 10:46:48  lulin
// - уменьшаем число параметров.
//
// Revision 1.559  2007/08/31 16:06:30  lulin
// - cleanup.
//
// Revision 1.558  2007/08/31 12:08:48  lulin
// - cleanup.
//
// Revision 1.557  2007/08/30 12:27:37  lulin
// - вычищены ненужные исключения.
//
// Revision 1.556  2007/08/30 12:19:07  lulin
// - cleanup.
//
// Revision 1.555  2007/08/30 11:45:02  lulin
// - удален ненужный модуль.
//
// Revision 1.554  2007/08/29 12:22:46  lulin
// - cleanup.
//
// Revision 1.553  2007/08/21 11:39:50  lulin
// - избавляемся от предупреждений компилятора.
//
// Revision 1.552  2007/08/14 15:56:47  lulin
// - описатели типов выделяем в блочной памяти.
//
// Revision 1.551  2007/08/13 17:41:20  lulin
// - вычищена ненужная функциональность по построению дерева тегов.
//
// Revision 1.550  2007/08/13 13:49:47  lulin
// - ведем себя как Null-объект, если Self = nil.
//
// Revision 1.549  2007/08/10 15:05:29  lulin
// - избавляемся от излишнего использования интерфейсов, т.к. переносимость может быть достигнута другими методами.
//
// Revision 1.548  2007/08/10 14:44:45  lulin
// - cleanup.
//
// Revision 1.547  2007/08/10 13:09:45  lulin
// - избавляемся от излишнего использования интерфейсов, т.к. переносимость может быть достигнута другими методами.
//
// Revision 1.546  2007/08/10 08:46:24  lulin
// - cleanup.
//
// Revision 1.545  2007/08/10 08:30:14  lulin
// - избавляемся от излишнего использования интерфейсов, т.к. переносимость может быть достигнута другими методами.
//
// Revision 1.544  2007/08/09 18:59:31  lulin
// - cleanup.
//
// Revision 1.543  2007/08/09 17:17:13  lulin
// - bug fix: не собирался Архивариус.
//
// Revision 1.542  2007/08/09 16:44:45  lulin
// - bug fix: не собирался Эверест.
//
// Revision 1.541  2007/08/09 14:55:27  lulin
// - избавляемся от излишнего использования интерфейсов.
//
// Revision 1.540  2007/08/09 12:38:17  lulin
// - убираем замороченную логику с присвоением таблицы тегов.
//
// Revision 1.539  2007/08/09 11:19:27  lulin
// - cleanup.
//
// Revision 1.538  2007/08/09 10:36:28  lulin
// - стараемся поменьше дергать счетчик ссылок свойств тегов при чтении EVD.
//
// Revision 1.537  2007/08/09 09:17:55  lulin
// - cleanup.
//
// Revision 1.536  2007/07/13 15:57:34  lulin
// - не сохраняем теги, которые непонятно как сохранять.
//
// Revision 1.535  2007/07/12 17:53:11  lulin
// - закончил описывать классы, реализующие теги.
//
// Revision 1.534  2007/07/12 17:32:07  lulin
// - генерируем теги определенные через простые классы.
//
// Revision 1.533  2007/07/09 08:18:09  lulin
// - упрощаем код для генерации.
//
// Revision 1.532  2007/07/06 08:32:22  lulin
// - упрощаем код для генерации.
//
// Revision 1.531  2007/07/05 15:02:40  lulin
// - упрощаем код для генерации.
//
// Revision 1.530  2007/07/05 11:36:20  lulin
// - упрощаем код для генерации.
//
// Revision 1.529  2007/05/24 11:37:38  lulin
// - new behavior: в тегах возможна комплексная сортировка, пока не более 4-х полей. Адреса гиперссылок теперь проверяются на дубликаты.
//
// Revision 1.528  2007/05/24 09:35:52  lulin
// - bug fix: не падаем, если хотим получить несуществующее свойство.
//
// Revision 1.527  2007/05/24 09:24:20  lulin
// - по-другому идентифицируем комплексную сортировку.
//
// Revision 1.526  2007/03/16 14:47:29  lulin
// - cleanup.
//
// Revision 1.525  2007/02/20 13:01:13  lulin
// - bug fix: не собирались утилиты от Арчи.
//
// Revision 1.524  2007/02/16 15:36:07  lulin
// - cleanup.
//
// Revision 1.523  2007/01/30 15:24:21  lulin
// - текст ноды - теперь более простого типа.
//
// Revision 1.522  2006/12/25 10:20:27  lulin
// - параметры строки теперь получаем одним вызовом, а не тремя.
//
// Revision 1.521  2006/11/03 11:00:44  lulin
// - объединил с веткой 6.4.
//
// Revision 1.520  2006/10/20 14:54:33  dinishev
// Bug fix: при выключении директивы _k2NeedChildSpy переставало компилироваться
//
// Revision 1.519  2006/10/02 11:11:35  lulin
// - cleanup.
//
// Revision 1.518  2006/10/02 10:35:15  lulin
// - контроллируем, что временные теги нельзя сохранять.
//
// Revision 1.517  2006/07/21 11:40:31  lulin
// - имя метода убрано из комментариев - чтобы не находилось контекстным поиском.
//
// Revision 1.516  2006/07/21 11:36:39  lulin
// - имя метода убрано из комментариев - чтобы не находилось контекстным поиском.
//
// Revision 1.515  2006/06/28 11:33:02  voba
// - bug fix от Шуры
//
// Revision 1.514  2006/06/27 12:18:40  lulin
// - избавляемся от шаманства с типом свойства, отвечающего за сохраняемость атрибута.
//
// Revision 1.513  2006/05/02 11:16:24  lulin
// - вытерта лишняя процедура сортировки.
//
// Revision 1.512  2006/05/02 08:47:45  lulin
// - вычищено значение по-умолчанию.
//
// Revision 1.511  2006/05/02 07:01:16  lulin
// - сделан метод установки порядка тегов.
//
// Revision 1.510  2006/04/24 12:58:44  lulin
// - выпиливаем из списков общую функциональность.
//
// Revision 1.509  2006/04/20 13:35:36  voba
// -  change in Tl3_CustomString - вместо pm_GetSt теперь перекрываем DoGetSt
//
// Revision 1.508  2006/04/11 17:55:28  lulin
// - оптимизируем при помощи вынесения строк (по следам того как Вован наиграл в фильтрах 20% производительности).
//
// Revision 1.507  2006/04/11 16:35:36  lulin
// - оптимизируем при помощи вынесения строк (по следам того как Вован наиграл в фильтрах 20% производительности).
//
// Revision 1.506  2006/01/30 09:49:49  lulin
// - убран ненужный параметр.
//
// Revision 1.505  2006/01/18 15:27:24  lulin
// - new behavior: сделана возможность ограничивать количество дочерних тегов.
//
// Revision 1.504  2006/01/18 10:38:20  lulin
// - bug fix: не компилировалось тестовое приложение.
//
// Revision 1.503  2006/01/17 15:10:40  lulin
// - выделен метод установки атрибута тега.
//
// Revision 1.502  2006/01/16 17:56:41  lulin
// - cleanup.
//
// Revision 1.501  2006/01/16 16:41:43  lulin
// - сделана возможность работать со строками без теговых оберток (почему-то на производительность не повлияло).
//
// Revision 1.500  2006/01/16 11:31:08  lulin
// - убран метод удаления параграфа, т.к. для этих целей полностью подходит метод удаления тега.
//
// Revision 1.499  2006/01/13 12:59:10  lulin
// - bug fix: в Undo-буфер попадала лишняя запись (CQ OIT5-19077).
//
// Revision 1.498  2006/01/11 15:30:10  lulin
// - сделано взведение флага Modified для словарных атрибутов документа.
//
// Revision 1.497  2005/12/28 12:54:28  lulin
// - bug fix: не компилировалось.
//
// Revision 1.496  2005/12/26 13:26:54  lulin
// - bug fix: не всегда отображалось изменение комментариев (CQ OIT5-18865).
//
// Revision 1.495  2005/12/14 09:42:10  lulin
// - убрал лишний параметр, из-за которого не компилировался HEAD.
//
// Revision 1.494  2005/12/09 15:44:17  lulin
// - bug fix: слишком поздно корректировали стиль параграфов в комментарии (CQ OIT5-18487).
//
// Revision 1.493  2005/12/02 22:03:51  lulin
// - запрос валидности операции посылается теперь через базовые объекты, а не шаманскими методами.
//
// Revision 1.492  2005/12/02 18:23:36  lulin
// - обрабока нотфификации об удалении/добавлении параграфа практически полностью перенесена на процессор.
//
// Revision 1.491  2005/12/02 13:31:23  lulin
// - установкой/сбрасыванием родительского тега управляем в базовых методах.
//
// Revision 1.490  2005/12/02 12:36:51  lulin
// - выделен шаблон для тегов, которые имеют владельца.
//
// Revision 1.489  2005/11/21 11:02:51  lulin
// - bug fix: при уходе документа в историю не сохранялись комментарии.
//
// Revision 1.488  2005/11/07 12:30:25  lulin
// - bug fix: не форматировались напрогруженные, но отображаемые параграфы.
//
// Revision 1.487  2005/11/04 10:04:04  lulin
// - optimization: избавился от необходимости расчета AbsIndex при листании по странице вниз.
//
// Revision 1.486  2005/11/03 16:33:49  lulin
// - optimization: при переформатировании документа итерируем только непрогруженные параграфы.
//
// Revision 1.485  2005/10/18 07:19:45  lulin
// - new behavior: теперь методы вставки и добавления дочерних тегов могут подменять вставляемые теги.
//
// Revision 1.484  2005/09/06 14:52:36  lulin
// - bug fix: не редактировались названия словарных статей.
//
// Revision 1.483  2005/08/31 13:02:49  lulin
// - спрятаны методы, которые не нужны в ветке.
//
// Revision 1.482  2005/08/29 15:03:07  lulin
// - cleanup.
//
// Revision 1.481  2005/08/29 14:43:20  lulin
// - new behavior: при вставке нескольких текстовых параграфов вставляем несколько контролов.
//
// Revision 1.480  2005/08/24 06:10:26  mmorozov
// change: изжит Tk2Bool вместо него используется Tl3Bool;
//
// Revision 1.479  2005/08/23 07:19:10  mmorozov
// change: названия перечислимого типа Tk2Bool, который стал Tl3Bool;
//
// Revision 1.478  2005/07/19 09:54:35  lulin
// - приводим родителя к контейнеру документа более дешевым способом.
//
// Revision 1.477  2005/07/04 14:45:57  lulin
// - оптимизация - приводим Tl3Stream к IStream без использования _Supports.
//
// Revision 1.476  2005/07/04 12:20:47  lulin
// - попытка открутить тип реализации и базовый тип.
// - bug fix: для Tl3Stream не было подсчета ссылок.
// - bug fix: IUnknown не приводился к IStream, даже если такое было возможно.
//
// Revision 1.475  2005/06/30 13:39:24  lulin
// - оптимизирован метод _Tk2Type._InheritsFrom - в результате ГК стал грузится вместо 1.8 - 1.5 сек.
//
// Revision 1.474  2005/06/29 15:15:53  lulin
// - записываем названия типов.
//
// Revision 1.473  2005/06/29 08:33:14  lulin
// - запил для скорости - не сообщаем об изменении AllChildrenCount.
//
// Revision 1.472  2005/04/28 15:04:09  lulin
// - переложил ветку B_Tag_Box в HEAD.
//
// Revision 1.471  2005/04/22 12:08:34  demon
// - fix: был AV при попытке выделения строки таблицы (в операцию _Tk2ObjectTag._rLong добавлена проверка l_Prop <> nil).
//
// Revision 1.470.2.29  2005/04/27 07:15:23  lulin
// - bug fix: криво описывался тип дочерних тегов - в результате например не ставились ссылки.
//
// Revision 1.470.2.28  2005/04/26 16:07:10  lulin
// - уменьшаем число лишних вызовов.
//
// Revision 1.470.2.27  2005/04/26 14:30:54  lulin
// - ускоряем l3Free и _l3Use.
//
// Revision 1.470.2.26  2005/04/25 15:43:26  lulin
// - попроще получаем ссылку.
//
// Revision 1.470.2.25  2005/04/25 14:27:32  lulin
// - изменена стратегия приведения.
//
// Revision 1.470.2.24  2005/04/25 13:07:42  lulin
// - избавился от Assert'а.
//
// Revision 1.470.2.23  2005/04/25 11:21:00  lulin
// - борьба с остающимся объектом (пока неудачно).
//
// Revision 1.470.2.22  2005/04/25 08:22:44  lulin
// - cleanup: убрал сообщение о присваивании тега с обертки.
//
// Revision 1.470.2.21  2005/04/23 16:33:07  lulin
// - удален ненужный метод.
//
// Revision 1.470.2.20  2005/04/23 16:23:02  lulin
// - remove prop: _Ik2Tag.AttrWP.
//
// Revision 1.470.2.19  2005/04/23 16:07:35  lulin
// - удален временный интерфейс Ik2TagBox.
//
// Revision 1.470.2.18  2005/04/23 15:19:25  lulin
// - remove method: _Ik2Tag._SetSubAtom - как сложный и ведущий к неоптимальному коду.
//
// Revision 1.470.2.17  2005/04/23 13:28:39  lulin
// - new define: _k2TagUseDefaultValue.
//
// Revision 1.470.2.16  2005/04/23 12:44:12  lulin
// - cleanup.
//
// Revision 1.470.2.15  2005/04/23 11:54:36  lulin
// - уменьшено количество преобразований. Чуть чуть выиграл время.
//
// Revision 1.470.2.14  2005/04/23 10:38:00  lulin
// - избавился от динамического преобразования типов.
//
// Revision 1.470.2.13  2005/04/23 09:42:49  lulin
// - уменьшено количество изменений счетчиков ссылок интерфейсов.
//
// Revision 1.470.2.12  2005/04/22 15:31:56  lulin
// - bug fix: восстановлена работоспособность параграфов с контролами.
//
// Revision 1.470.2.11  2005/04/22 15:23:23  lulin
// - вернул работоспособность параграфов с картинками и формул.
//
// Revision 1.470.2.10  2005/04/22 14:46:50  lulin
// - вернул работоспособность параграфов с картинками.
//
// Revision 1.470.2.9  2005/04/22 12:47:56  lulin
// - вернулся от интерфейсов к объектам.
//
// Revision 1.470.2.8  2005/04/22 12:14:29  lulin
// - remove interface: Ik2PropertyBag.
//
// Revision 1.470.2.7  2005/04/22 10:47:20  lulin
// - cleanup: убрано ненужное и непонятное свойство.
//
// Revision 1.470.2.6  2005/04/22 10:40:30  lulin
// - cleanup: убраны ненужные параметры.
//
// Revision 1.470.2.5  2005/04/22 09:04:37  lulin
// - cleanup: убраны ненужные параметры.
//
// Revision 1.470.2.4  2005/04/21 17:28:16  lulin
// - cleanup.
//
// Revision 1.470.2.3  2005/04/21 16:30:19  lulin
// - избавился от лишних оберточных классов.
//
// Revision 1.470.2.2  2005/04/21 15:36:42  lulin
// - окончательно избавился от необходимости обертки.
//
// Revision 1.470.2.1  2005/04/21 14:47:02  lulin
// - избавляемся от обертки над тегами - теперь объекты посредством шаблонов сами реализуют интерфейс _Ik2Tag.
//
// Revision 1.470  2005/04/21 05:11:48  lulin
// - используем _Box (пока из-за постоянных преобразований туда и обратно - по скорости стало только хуже).
//
// Revision 1.469  2005/04/20 17:40:57  lulin
// - избавился от промежуточного интерфейса Ik2TagBoxQT.
//
// Revision 1.468  2005/04/20 13:38:45  lulin
// - new method: Ik2TagBox._InheritsFrom.
//
// Revision 1.467  2005/04/20 13:17:57  lulin
// - подготовительная работа для возможности не преобразовывать целые числа в теги.
//
// Revision 1.466  2005/04/19 18:23:16  lulin
// - подготовительная работа для возможности не преобразовывать целые числа в теги.
//
// Revision 1.465  2005/04/19 18:11:09  lulin
// - не делаем лишние действия для тегов, которые про это все равно не знают.
//
// Revision 1.464  2005/04/19 18:02:14  lulin
// - выделен метод _DeleteMapped.
//
// Revision 1.463  2005/04/19 17:55:22  lulin
// - выделен дублирующийся код.
//
// Revision 1.462  2005/04/19 17:22:05  lulin
// - небольшая оптимизация.
//
// Revision 1.461  2005/04/19 16:57:30  lulin
// - new interface: IevSimpleView.
//
// Revision 1.460  2005/04/19 13:55:29  lulin
// - оптимальнее "перетасовал" код :-(.
//
// Revision 1.459  2005/04/19 13:25:14  lulin
// - оптимальнее "перетасовал" код :-(.
//
// Revision 1.458  2005/04/19 12:22:19  lulin
// - убраны лишние преобразования.
//
// Revision 1.457  2005/04/19 08:48:24  lulin
// - убран лишний запрос интерфейса вверх к родителю.
//
// Revision 1.456  2005/04/19 07:14:52  lulin
// - небольшая оптимизация.
//
// Revision 1.455  2005/04/18 17:18:29  lulin
// - используем _Box, а не _Ik2Tag (пока выигрыша в производительности не дало).
//
// Revision 1.454  2005/04/18 09:51:44  lulin
// - кешируем целочисленные теги.
//
// Revision 1.453  2005/04/15 09:19:59  lulin
// - убран лишний вызов.
//
// Revision 1.452  2005/04/15 08:59:57  lulin
// - теперь держим ссылку на тег, а не собственно тег.
//
// Revision 1.451  2005/04/12 09:53:09  lulin
// - объединил с веткой - в попытках починить List Index Out Of Bounds.
//
// Revision 1.450.2.6  2005/04/10 11:15:47  lulin
// - отключил k2CacheChild для ветки.
//
// Revision 1.450.2.5  2005/04/10 11:08:35  lulin
// - new define: k2CacheChild.
//
// Revision 1.450.2.3  2005/04/10 10:58:32  lulin
// - new define: k2CacheInner.
//
// Revision 1.450.2.2  2005/04/08 12:00:38  lulin
// - _Processor стал обязательным параметром.
//
// Revision 1.450.2.1  2005/04/08 11:42:11  lulin
// - теперь инструменты получают нотификацию об удалении тегов.
//
// Revision 1.450  2005/04/07 16:20:43  lulin
// - new method: Ik2TagBoxQT._MakeInterface.
//
// Revision 1.449  2005/04/07 14:35:35  lulin
// - remove proc: evGetTopPara.
//
// Revision 1.448  2005/04/06 14:34:04  lulin
// - bug fix: отдавали не тот интерфейс, который нас просили.
//
// Revision 1.447  2005/04/06 12:19:53  lulin
// - bug fix: не сохранялись картинки.
//
// Revision 1.446  2005/04/06 08:47:20  lulin
// - связываем инструменты в цепочки для более быстрого получения интересующего инструмента.
//
// Revision 1.445  2005/04/05 16:07:07  lulin
// - new behavior: теперь иструменты имеют возможность получать нотификацию об изменении атрибутов.
//
// Revision 1.444  2005/04/04 07:19:06  lulin
// - cleanup.
//
// Revision 1.443  2005/04/04 06:44:07  lulin
// - в связи с появлением механизма событий и фасада библиотеки K-2, удалены глобальные "заплатки" связанные с созданием/уничтожением таблицы тегов.
//
// Revision 1.442  2005/04/01 16:18:42  lulin
// - new behavior: теперь рассылаем всем объектам извещение о том, что таблица тегов сейчас уничтожится.
//
// Revision 1.441  2005/03/31 14:47:00  lulin
// - new behavior: используем InevParaList.InsertPara вместо evDir_InsertPara.
//
// Revision 1.440  2005/03/31 11:03:30  lulin
// - добавлен параметр - _Processor.
//
// Revision 1.439  2005/03/30 17:39:31  lulin
// - исправлен префикс у типов.
//
// Revision 1.438  2005/03/30 16:09:22  lulin
// - не сохраняем блоки в (старый) кеш ибо незачем.
//
// Revision 1.437  2005/03/30 15:56:30  lulin
// - TevLocation теперь наследуется от Tk2Tool - базового класса для инструментов тегов.
//
// Revision 1.436  2005/03/30 15:12:24  lulin
// - в _QueryTool теперь подаем тег для которого надо сделать инструмент.
//
// Revision 1.435  2005/03/30 14:56:11  lulin
// - спрятан старый интерфейс.
//
// Revision 1.434  2005/03/30 13:31:46  lulin
// - bug fix: иногда целые числа попадали в слот объектов.
//
// Revision 1.433  2005/03/30 09:44:36  lulin
// - bug fix: неправильно работала функция _FindChild - в Undo буфер в итоге клались записи невалидной структуры.
//
// Revision 1.432  2005/03/30 09:17:31  lulin
// - bug fix: не добавлялись дети по индексу.
//
// Revision 1.431  2005/03/29 14:29:08  lulin
// - bug fix: не сохраняем тег в Generator = nil.
//
// Revision 1.430  2005/03/29 12:40:24  lulin
// - new method: _Ik2Tag._FindChild.
//
// Revision 1.429  2005/03/29 08:48:00  lulin
// - bug fix: пытались присвоить _ReadOnly-свойства в методе _Assign - в результате exception - в результате невозможно было вставить колонку таблицы.
//
// Revision 1.428  2005/03/28 17:45:17  lulin
// - избавился от шаманства при присваивании параметров сортировки детей тега.
//
// Revision 1.427  2005/03/28 16:59:44  lulin
// - пореже дергаем QueryInterface по всей цепочке родителей.
//
// Revision 1.426  2005/03/28 14:30:09  lulin
// - от класса генераторов переходим к интерфейсу.
//
// Revision 1.425  2005/03/28 11:32:28  lulin
// - интерфейсы переехали в "правильный" модуль.
//
// Revision 1.424  2005/03/28 06:37:16  lulin
// - remove object: Tk2AtomW.
//
// Revision 1.423  2005/03/25 18:29:35  lulin
// - избавляемся от метода Tk2AtomW.sClass.
//
// Revision 1.422  2005/03/25 17:53:24  lulin
// - cleanup.
//
// Revision 1.421  2005/03/25 17:09:17  lulin
// - избавляемся от метода Tk2AtomW.sLong.
//
// Revision 1.420  2005/03/25 12:12:17  lulin
// - используем _Ik2Type вместо _Tk2Type.
//
// Revision 1.419  2005/03/25 11:20:37  lulin
// - cleanup.
//
// Revision 1.417  2005/03/25 10:28:47  lulin
// - cleanup.
//
// Revision 1.416  2005/03/24 18:39:30  lulin
// - remove object: Tk2AtomR.
//
// Revision 1.415  2005/03/24 16:15:30  lulin
// - bug fix: при запросе атрибутов - прозрачность трактовалась как отсутствие атрибута - в итоге например неправильно выливались в NSRC ссылки в комментариях.
//
// Revision 1.414  2005/03/24 15:25:54  lulin
// - удалены ненужные методы.
//
// Revision 1.413  2005/03/24 14:10:40  lulin
// - удалены ненужные методы.
//
// Revision 1.412  2005/03/24 13:30:53  lulin
// - удалена функция преобразования Tk2AtomR к Ik2TagBox.
//
// Revision 1.411  2005/03/24 13:14:43  lulin
// - уделена ненужная функция преобразования Tk2AtomR к _Ik2Tag.
//
// Revision 1.410  2005/03/24 12:18:02  lulin
// - удален ненужный _Make.
//
// Revision 1.409  2005/03/24 12:08:21  lulin
// - remove method: Ik2TagBox.Tag.
// - new method: Ik2TagBox._Target.
//
// Revision 1.408  2005/03/23 15:48:13  lulin
// - cleanup.
//
// Revision 1.407  2005/03/23 15:37:07  lulin
// - удалено ненужное исключение.
//
// Revision 1.406  2005/03/23 15:29:20  lulin
// - итератор по свойствам внутри тега приобрел нормальный вид, а не какой-то шаманский.
//
// Revision 1.405  2005/03/23 12:09:22  lulin
// - bug fix: не учитывались прозрачные значения.
//
// Revision 1.404  2005/03/23 12:00:53  lulin
// - cleanup.
//
// Revision 1.403  2005/03/23 11:16:32  lulin
// - удалено ненужное исключение.
//
// Revision 1.402  2005/03/23 10:23:51  lulin
// - bug fix: был AV при попытке освобождения прозрачного свойства, которое в нормальных условиях представляется объектом.
//
// Revision 1.401  2005/03/23 09:52:01  lulin
// - new prop: _Ik2Tag.BoolA.
//
// Revision 1.400  2005/03/23 08:55:23  lulin
// - bug fix: не компилировалось.
//
// Revision 1.399  2005/03/23 08:46:35  lulin
// - методы для установки свойств перенесены на _Ik2Tag.
//
// Revision 1.398  2005/03/22 17:03:07  lulin
// - спрятаны ненужные методы. Чуть подоптимизирована загрузка - ГК в Эвересте на 1 сек меньше.
//
// Revision 1.397  2005/03/22 15:45:30  lulin
// - убраны ненужные методы.
//
// Revision 1.396  2005/03/22 14:50:43  lulin
// - new method: _Ik2TypeTable.VariantToTag.
//
// Revision 1.395  2005/03/22 14:30:12  lulin
// - new method: _Ik2TypeTable._IUnknownToTag.
//
// Revision 1.394  2005/03/22 14:25:30  lulin
// - new method: _Ik2TypeTable.ObjectToTag.
//
// Revision 1.393  2005/03/22 14:18:15  lulin
// - new method: _Ik2TypeTable.StringToTag.
//
// Revision 1.392  2005/03/22 14:11:38  lulin
// - new method: _Ik2TypeTable._BoolToTag.
//
// Revision 1.391  2005/03/22 14:08:55  lulin
// - new method: _Ik2TypeTable.LongToTag.
//
// Revision 1.390  2005/03/22 13:40:16  lulin
// - new method: _Ik2Tag._IsStream.
//
// Revision 1.389  2005/03/22 13:35:51  lulin
// - используем честный итератор, вместо шаманского запроса интерфейса.
//
// Revision 1.388  2005/03/22 13:23:20  lulin
// - new class: _Tk2StreamTag.
//
// Revision 1.387  2005/03/22 13:16:16  lulin
// - вместо _Tl3Base импользуем TObject.
//
// Revision 1.386  2005/03/22 13:07:15  lulin
// - bug fix: была возможность присвоить неправильный тип.
//
// Revision 1.385  2005/03/22 12:50:54  lulin
// - bug fix: для объектов = nil создавался ненулевой тег.
//
// Revision 1.384  2005/03/22 12:42:18  lulin
// - bug fix: установка стиля убивала гиперссылки.
//
// Revision 1.383  2005/03/22 10:38:03  lulin
// - cleanup.
//
// Revision 1.382  2005/03/22 10:15:43  lulin
// - оптимизация: при поиске слота для дочернего элемента сравниваем типы по ID, а не по имени.
//
// Revision 1.381  2005/03/22 10:02:15  lulin
// - оптимизирован поиск места размещения дочерних тегов.
//
// Revision 1.380  2005/03/22 09:47:58  lulin
// - убраны ненужные преобразования между Tk2AtomR и _Ik2Tag.
//
// Revision 1.379  2005/03/22 07:54:52  lulin
// - remove method: Tk2AtomR.AsIUnknown.
//
// Revision 1.378  2005/03/21 17:11:36  lulin
// - new method: _Ik2Type._IsOrd.
//
// Revision 1.377  2005/03/21 16:45:04  lulin
// - new method: _Ik2BaseDef._IsNull.
//
// Revision 1.376  2005/03/21 16:28:21  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.375  2005/03/21 13:43:04  lulin
// - убраны ненужные методы.
//
// Revision 1.374  2005/03/21 12:25:27  lulin
// - bug fix: не компилировалось.
//
// Revision 1.373  2005/03/21 11:59:09  lulin
// - new proc: _k2NullArrayProp.
//
// Revision 1.372  2005/03/21 11:12:01  lulin
// - new procs: _k2NullDef, k2NullType.
//
// Revision 1.371  2005/03/21 10:05:05  lulin
// - new interface: _Ik2Type.
//
// Revision 1.370  2005/03/21 06:45:01  lulin
// - убраны ненужные методы.
//
// Revision 1.369  2005/03/19 16:40:04  lulin
// - спрятаны ненужные методы.
//
// Revision 1.368  2005/03/18 17:23:28  lulin
// - более правильно получаем вложенный тег.
//
// Revision 1.367  2005/03/18 17:15:52  lulin
// - в методе записи тега итерируем дочерние теги через методы интерфейса, а не через какое-то заднее крыльцо.
//
// Revision 1.366  2005/03/18 16:11:33  lulin
// - remove method: Tk2AtomR._Write.
//
// Revision 1.365  2005/03/18 15:12:25  lulin
// - с интерфейса убран ненужный и непонятный метод.
//
// Revision 1.364  2005/03/18 15:00:20  lulin
// - new interface: Ik2TagGenerator.
//
// Revision 1.363  2005/03/18 14:36:25  lulin
// - функция заменена на свойство.
//
// Revision 1.362  2005/03/18 14:14:25  lulin
// - функция заменена на свойство.
//
// Revision 1.361  2005/03/18 13:18:22  lulin
// - bug fix: пересоздаем обертку вокруг дочернего тега - если типы отличаются.
//
// Revision 1.360  2005/03/18 12:59:56  lulin
// - метод _IndexOfChild распилен по нескольким разным объектам.
//
// Revision 1.359  2005/03/18 12:05:47  lulin
// - дочерние теги закешированы.
//
// Revision 1.358  2005/03/17 17:57:07  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.357  2005/03/17 11:33:59  lulin
// - bug fix: не компилировалось.
//
// Revision 1.356  2005/03/17 10:29:56  lulin
// - cleanup.
//
// Revision 1.355  2005/03/16 17:36:07  lulin
// - cleanup.
//
// Revision 1.354  2005/03/16 17:24:02  lulin
// - cleanup.
//
// Revision 1.353  2005/03/16 17:04:26  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.352  2005/03/16 16:05:13  lulin
// - bug fix: контроллируем, что описатель свойства правильный.
//
// Revision 1.351  2005/03/16 15:57:04  lulin
// - заготовка для Assert'ов.
//
// Revision 1.350  2005/03/16 14:07:10  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.349  2005/03/16 12:17:02  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.348  2005/03/16 10:20:26  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.347  2005/03/16 09:50:12  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.346  2005/03/16 09:20:39  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.345  2005/03/16 08:20:05  lulin
// - декларация _Ik2Tag перенесена повыше.
//
// Revision 1.344  2005/03/15 16:09:22  lulin
// - cleanup.
//
// Revision 1.343  2005/03/15 11:18:23  lulin
// - cleanup.
//
// Revision 1.342  2005/03/15 10:30:28  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.341  2005/03/15 08:11:04  lulin
// - спрятаны ненужные методы.
//
// Revision 1.340  2005/03/15 08:01:41  lulin
// - выделен метод: _Tk2ListTag.DoIterateChildren.
//
// Revision 1.339  2005/03/15 07:52:37  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.338  2005/03/11 16:26:47  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.337  2005/03/11 15:21:21  lulin
// - добавлен Assert.
//
// Revision 1.336  2005/03/11 15:15:12  lulin
// - bug fix: не изменялся тип наследования на прозрачный (CQ OIT5-12630).
//
// Revision 1.335  2005/03/10 11:35:17  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.334  2005/03/10 10:30:57  lulin
// - в Ik2Value._IsSame теперь передается Ik2Value, а не _Ik2Tag.
//
// Revision 1.333  2005/03/10 10:21:57  lulin
// - new prop: _Ik2Tag._Attr.
//
// Revision 1.332  2005/03/10 10:13:16  lulin
// - remove method: Tk2AtomR._SetSubAtom.
//
// Revision 1.331  2005/03/10 09:58:49  lulin
// - remove method: Tk2AtomR._DeleteChildren.
// - new method: _Ik2Tag._DeleteChildren.
//
// Revision 1.330  2005/03/10 09:32:20  lulin
// - optimization: избегаем цикла, при доступе к описанию атрибутов типа _Tk2Type.
//
// Revision 1.329  2005/03/10 09:16:03  lulin
// - optimization: избегаем цикла, при подсчете числа атрибутов типа _Tk2Type.
//
// Revision 1.328  2005/03/09 19:06:09  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.327  2005/03/09 18:50:28  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.326  2005/03/09 18:40:24  lulin
// - remove method: Tk2AtomR._DeleteChild.
// - new method: _Ik2Tag._DeleteChild.
//
// Revision 1.325  2005/03/09 17:29:09  lulin
// - от Tk2AtomR переходим к Ik2TagWrap.
//
// Revision 1.324  2005/03/09 17:11:55  lulin
// - remove method: Tk2AtomR._ChildAdded.
//
// Revision 1.323  2005/03/09 17:05:22  lulin
// - remove method: Tk2AtomR._InsertChild.
// - new method: _Ik2Tag._InsertChild.
//
// Revision 1.322  2005/03/09 15:43:14  lulin
// - remove method: Tk2AtomR._AssignCloneParams.
// - new class: Tk2TT - утилитные функции для работы с тегами (структурами документа) не инкапсулированные самими тегами (в частности туда перенесен метод _AssignCloneParams).
//
// Revision 1.321  2005/03/09 15:05:17  lulin
// - от Tk2AtomR переходим к Ik2TagWrap.
//
// Revision 1.320  2005/03/09 14:28:55  lulin
// - от Tk2AtomR переходим к Ik2TagWrap.
//
// Revision 1.319  2005/03/09 14:16:07  lulin
// - убран отладочный код.
//
// Revision 1.318  2005/03/09 13:47:16  lulin
// - bug fix: проеб со счетчиком ссылок на объекты внутри документа, в результате которого в частности "разъезжался" текст (CQ OIT5-12595).
//
// Revision 1.317  2005/03/09 12:10:54  lulin
// - от Tk2AtomR переходим к Ik2TagWrap.
//
// Revision 1.316  2005/03/05 11:27:58  lulin
// - bug fix: Abstract Method Call при вызове редактора стилей.
//
// Revision 1.315  2005/03/04 19:43:35  lulin
// - remove method: Tk2AtomR._Assign.
//
// Revision 1.314  2005/03/04 18:52:42  lulin
// - bug fix: после перехода на _MakeTag неправильно использовался метод _Assign.
//
// Revision 1.313  2005/03/04 16:43:18  lulin
// - remove method: Tk2AtomR.New.
//
// Revision 1.312  2005/03/04 15:49:10  lulin
// - спрятана процедура _Tk2Type.New.
//
// Revision 1.311  2005/03/04 14:15:56  lulin
// - удален ненужный тип.
//
// Revision 1.310  2005/03/04 14:14:28  lulin
// - спрятаны методы, которые не должны интересовать пользователя.
//
// Revision 1.309  2005/03/04 13:59:25  lulin
// - remove method: Tk2AtomR._AddChild.
//
// Revision 1.308  2005/02/22 12:50:30  lulin
// - new interface: _Ik2TagBoxContainer.
//
// Revision 1.307  2005/02/02 09:54:23  lulin
// - bug fix: не совсем корректно обрабатывались флаги записи тега - в результате не печатались параграфы preformatted.
//
// Revision 1.306  2005/01/24 11:43:20  lulin
// - new behavior: при освобождении заглушки очищаем указатель на нее.
//
// Revision 1.305  2004/11/17 11:30:33  lulin
// - new behavior: закрываем/открываем комментарий пользователя с клавиатуры.
//
// Revision 1.304  2004/11/16 11:25:01  lulin
// - bug fix: при переходе от классов к интерфейсам сломался маппинг свойств в таблице тегов - в результате свойства смапированныей например на стиль параграфа не очищались.
//
// Revision 1.303  2004/11/15 13:53:58  lulin
// - remove method: Tk2AtomR.AssignSubAtomEx.
// - new method: Tk2AtomR._AssignCloneParams.
//
// Revision 1.302  2004/11/15 13:40:48  lulin
// - теперь для типа параграфа можно определять _ParamsForClone - список атрибутов, которые нужно присваивать при клонировании параграфа.
//
// Revision 1.301  2004/11/10 14:21:06  lulin
// - optimization: за счет выкидывания поддержки ненужного интерфейса уменьшаем размер каждого параграфа на 4 байта.
//
// Revision 1.300  2004/11/09 17:06:27  lulin
// - переходим от классов к интерфейсам.
//
// Revision 1.299  2004/11/09 15:36:03  lulin
// - bug fix: не компилировалось.
//
// Revision 1.298  2004/11/09 14:07:19  lulin
// - переходим от классов к интерфейсам.
//
// Revision 1.297  2004/11/09 13:37:59  lulin
// - переходим от классов к интерфейсам.
//
// Revision 1.296  2004/11/09 12:35:36  lulin
// - bug fix: не компилировалось.
//
// Revision 1.295  2004/11/09 12:23:06  lulin
// - переходим от классов к интерфейсам.
//
// Revision 1.294  2004/11/09 11:07:32  lulin
// - new interfaces: _Ik2Property, _Ik2ArrayProperty.
//
// Revision 1.293  2004/11/05 16:32:05  lulin
// - cleanup.
//
// Revision 1.292  2004/11/05 16:10:01  lulin
// - cleanup.
//
// Revision 1.291  2004/11/04 17:43:46  lulin
// - new interface: _Ik2TypeTable.
//
// Revision 1.290  2004/11/02 14:52:14  lulin
// - new behavior: не пытаемся присваивать _ReadOnly-свойства.
//
// Revision 1.289  2004/10/29 15:33:05  lulin
// - new behavior: уменьшаем диапазон форматируемых строк внутри таблиц с ячейчами, объединенными по-вертикали.
//
// Revision 1.288  2004/10/29 13:05:24  lulin
// - new methods: Tk2AtomR._IterateChildrenBack(_F).
//
// Revision 1.287  2004/10/12 13:28:10  lulin
// - bug fix: отъехала прозрачность стилей сегментов.
//
// Revision 1.286  2004/10/11 08:14:29  lulin
// - new class: _TevDocumentsCache.
//
// Revision 1.285  2004/10/06 15:23:09  lulin
// - bug fix: из клипборда текст вставлялся не как комментарии (CQ OIT5-10087).
//
// Revision 1.284  2004/09/28 17:22:11  lulin
// - в первом приближении сделал кеш документов. Пока без вымещения покументов на диск.
//
// Revision 1.283  2004/09/27 10:59:13  lulin
// - вместо AV выкидываем исключение о ненайденном свойстве.
//
// Revision 1.282  2004/09/21 12:04:25  lulin
// - Release заменил на Cleanup.
//
// Revision 1.281  2004/07/12 13:10:56  law
// - bug fix: был Range Check при доступе к _ReadOnly свойствам.
//
// Revision 1.280  2004/07/09 09:18:12  law
// - bug fix: неправильно переформатировались параграфы при включенном фоновом форматировании.
//
// Revision 1.279  2004/07/07 13:26:29  law
// - optimiztaion: _Tk2Type._GetPropByOffset - стараемся обходится без итератора.
//
// Revision 1.278  2004/07/05 14:55:57  law
// - optimization.
//
// Revision 1.277  2004/07/05 14:45:48  law
// - new interface: Ik2Value.
//
// Revision 1.276  2004/07/05 14:22:03  law
// - remove class: Tk2StructObjectTag.
//
// Revision 1.275  2004/07/05 14:07:53  law
// - укорочены имена методов.
//
// Revision 1.274  2004/07/05 13:46:32  law
// - new method: _Ik2Tag.rBoolAtom.
//
// Revision 1.273  2004/07/05 13:01:44  law
// - bug fix.
//
// Revision 1.272  2004/07/05 12:50:37  law
// - bug fix.
//
// Revision 1.271  2004/07/05 12:35:08  law
// - вернул старые названия методов _rAtom и wAtom.
//
// Revision 1.270  2004/07/05 11:21:12  law
// - bug fix.
//
// Revision 1.269  2004/07/05 10:17:03  law
// no message
//
// Revision 1.268  2004/07/02 15:19:23  law
// - замена Tk2AtomR -> _Ik2Tag.
//
// Revision 1.267  2004/07/02 13:13:15  law
// - оптимизирована работа тегами.
//
// Revision 1.266  2004/07/02 12:21:11  law
// - оптимизирована работа тегами.
//
// Revision 1.265  2004/07/02 10:57:51  law
// - замена Tk2AtomR -> _Ik2Tag.
//
// Revision 1.264  2004/07/02 10:21:10  law
// - вставлен Assert.
//
// Revision 1.263  2004/07/02 10:17:01  law
// - оптимизирован перебор детей.
//
// Revision 1.262  2004/07/01 17:41:51  law
// - new behavior: Formatter'ы переведены с Tk2AtomR на _Ik2Tag.
//
// Revision 1.261  2004/07/01 16:29:30  law
// - bug fix.
//
// Revision 1.260  2004/07/01 16:24:48  law
// - bug fix.
//
// Revision 1.259  2004/07/01 16:15:22  law
// - bug fix.
//
// Revision 1.258  2004/07/01 16:06:03  law
// - оптимизированы _pm_GetChild и _pm_GetChildrenCount.
//
// Revision 1.257  2004/07/01 15:34:35  law
// - new methods: _Ik2Tag._IterateChildren, _IterateChildrenF.
//
// Revision 1.256  2004/07/01 15:05:25  law
// - new class: _Tk2ListTag.
//
// Revision 1.255  2004/07/01 14:59:41  law
// - new prop: _Ik2Tag.ChildrenCount.
//
// Revision 1.254  2004/07/01 14:31:19  law
// - new method: _Tk2ObjectTag._SetSubAtom.
//
// Revision 1.253  2004/07/01 13:58:21  law
// - new method: _Ik2Tag.wAtom.
//
// Revision 1.252  2004/07/01 10:21:04  law
// - new method: _Ik2Tag._AddChild.
//
// Revision 1.251  2004/06/30 15:57:03  law
// - new prop: _Ik2Tag.Child.
//
// Revision 1.250  2004/06/30 15:40:55  law
// - cleanup.
//
// Revision 1.249  2004/06/30 15:36:11  law
// - new method version: _Ik2Tag.rAttr.
//
// Revision 1.248  2004/06/30 14:49:25  law
// - new method: _Ik2Tag.rAttr.
//
// Revision 1.247  2004/06/30 14:23:05  law
// - new methods: _Ik2Tag.AsLong, AsString.
//
// Revision 1.246  2004/06/30 14:00:18  law
// - перетасованы реализации методов.
//
// Revision 1.245  2004/06/30 13:52:43  law
// - new method: _Tk2ValuedTag.GetValue.
//
// Revision 1.244  2004/06/30 13:34:54  law
// - bug fix: _Tk2TransparentTag._IsSame не учитывала _f_Type.
//
// Revision 1.243  2004/06/30 13:32:47  law
// - реализация метода _IsSame перенесена на _Tk2ValuedTag.
//
// Revision 1.242  2004/06/30 13:25:59  law
// - класс _Tk2TagBase теперь не поддерживает непосредственно Ik2TagBox, а только _Ik2Tag.
//
// Revision 1.241  2004/06/30 13:09:36  law
// - new class: Tk2StructObjectTag.
//
// Revision 1.240  2004/06/30 12:53:17  law
// - new class: _Tk2TypedTag.
//
// Revision 1.239  2004/06/30 12:48:43  law
// - new class: _Tk2ValuedTag.
//
// Revision 1.238  2004/06/30 12:33:15  law
// - изменены сигнатуры методов.
//
// Revision 1.237  2004/06/30 12:14:59  law
// - bug fix: бесконечная рекурсия в Tk2*Tag.COMQueryInterface.
//
// Revision 1.236  2004/06/30 10:48:45  law
// - изменен тип параметра _Parent у методов IevVisualShapedTag._ParentToClient, _ClientToParent с IUnknown на _Ik2Tag.
//
// Revision 1.235  2004/06/30 09:35:23  law
// - new class: _Tk2IUnknownTag.
//
// Revision 1.234  2004/06/30 09:30:10  law
// - new class: _Tk2StringTag.
//
// Revision 1.233  2004/06/30 09:13:39  law
// - new method: _Ik2Tag._IsOrd.
//
// Revision 1.232  2004/06/30 09:09:29  law
// - new class: _Tk2TransparentTag.
//
// Revision 1.231  2004/06/30 08:15:23  law
// - new behavior: транслируем запрос интерфейса от _Tk2Tag к Ik2TagWrap.
//
// Revision 1.230  2004/06/30 08:01:28  law
// - new class: _Tk2TagBase.
//
// Revision 1.229  2004/06/29 17:01:13  law
// - new class: _Tk2ObjectTag.
//
// Revision 1.228  2004/06/29 16:44:26  law
// - new class: _Tk2OrdTag.
//
// Revision 1.227  2004/06/29 16:29:30  law
// - new method: _Ik2Tag._IsSame.
//
// Revision 1.226  2004/06/29 16:22:29  law
// - new method: _Ik2Tag.Owner.
//
// Revision 1.225  2004/06/29 16:01:37  law
// - bug fix: зацикливание в получении документа в evNode.
//
// Revision 1.224  2004/06/29 15:47:07  law
// - new methods: _Ik2Tag._IsNull, IsValid.
//
// Revision 1.223  2004/06/29 15:36:21  law
// - new method: _Ik2Tag._Clone.
//
// Revision 1.222  2004/06/29 15:13:46  law
// - new interface: _Ik2Tag.
//
// Revision 1.221  2004/06/29 14:58:13  law
// - new interface: Ik2TagBox.
//
// Revision 1.220  2004/06/29 14:26:52  law
// - избавляемся от метода Tk2AtomR._Set.
//
// Revision 1.219  2004/06/28 16:22:41  law
// - подоптимизирована _IsNull.
//
// Revision 1.217  2004/06/28 13:46:36  law
// - remove unit: k2IntfStub.
//
// Revision 1.216  2004/06/28 13:42:07  law
// - remove proc: k2MakeInterface.
//
// Revision 1.215  2004/06/28 13:34:49  law
// - remove class: Il3Pointer.
//
// Revision 1.214  2004/06/28 12:06:17  law
// - remove class: Il3Unknown.
//
// Revision 1.213  2004/06/25 10:53:21  law
// - optimization.
//
// Revision 1.212  2004/06/25 07:23:42  law
// - optimization.
//
// Revision 1.211  2004/06/23 16:22:39  law
// - оптимизирован доступ к дочерним тегам.
//
// Revision 1.210  2004/06/18 16:28:09  law
// - Tk2AtomR.QueryInterface оптимизирована по скорости.
//
// Revision 1.209  2004/06/17 15:58:59  law
// - свойство Empty переместилось с класса _Tl3Base на класс _Tl3SomeDataContainer.
//
// Revision 1.208  2004/06/17 13:57:48  law
// - bug fix: курсоры не владели параграфами - соответственно были потенциальные ошибки, когда параграфы умирали, а курсоры нет.
// - bug fix: в результате переделок механизма поиска перестал работать поиск в выборке.
//
// Revision 1.207  2004/06/10 16:26:39  law
// - продолжаем оптимизировать загрузку документа кусками.
//
// Revision 1.206  2004/06/10 11:03:22  law
// - свойство _Tl3CustomString.Len сделано статическим.
//
// Revision 1.205  2004/06/08 10:28:09  law
// - change: сделана возможность присваивать теги не целиком, а только то, что "приехало" (для догрузки параграфов).
//
// Revision 1.204  2004/06/04 15:51:55  law
// - интерфейс _Il3StringList сделан наследником от _Il3List.
//
// Revision 1.203  2004/06/04 14:49:44  law
// - new param: theIndex: PLong = nil, в методах Tk2AtomR._rAtom и Tk2AtomR._cAtomEx.
//
// Revision 1.202  2004/06/04 09:25:40  narry
// - bug fix
//
// Revision 1.201  2004/06/03 17:15:47  law
// - new interface: _Ik2Base.
//
// Revision 1.200  2004/06/03 15:59:54  law
// - убрал прямое обращение к _Tl3PVList (т.к. для оптимизации предполагается, что в теле документа не всегда он может хранится).
//
// Revision 1.199  2004/06/03 14:59:40  law
// - убрал прямое обращение к _Tl3PVList (т.к. для оптимизации предполагается, что в теле документа не всегда он может хранится).
//
// Revision 1.198  2004/06/03 12:42:42  law
// - new interface: _Il3PointerList.
//
// Revision 1.197  2004/06/03 11:00:45  law
// - используем _Il3List и _Il3ListIterator вместо _Tl3PVList.
//
// Revision 1.196  2004/06/03 09:53:50  law
// - начал использовать _Il3ListIterator вместо _Tl3PVList.
//
// Revision 1.195  2004/06/02 08:30:27  law
// - удален конструктор Tl3VList.MakePersistentSorted - пользуйтесь _Tl3ObjectRefList._MakeSorted.
//
// Revision 1.194  2004/06/01 16:51:27  law
// - удален конструктор Tl3VList.MakePersistent - пользуйтесь _Tl3ObjectRefList.
//
// Revision 1.193  2004/05/31 11:44:36  law
// - new class: _Tl3PVList - список с виртуальными методами распределения/освобождения памяти.
//
// Revision 1.192  2004/05/25 13:08:52  law
// - change: Tk2AtomR.ArrayProp - теперь property, а не функция.
// - bug fix: при вставке из буфера вставлялись "левые" элементы оглавления.
//
// Revision 1.191  2004/05/14 14:49:04  law
// - исправлены префиксы у констант.
//
// Revision 1.190  2004/05/14 14:08:57  law
// - change: TevVariant переименован в _Tk2Variant и переехал в k2Types.
//
// Revision 1.189  2004/05/07 12:21:05  law
// - bug fix: при наследовании не сохранялась сортировка тегов.
//
// Revision 1.188  2004/04/12 13:29:32  law
// - new: добавлен тип документов "словарная статья", их свойство ShortName теперь представляется не строкой, а массивом строк.
//
// Revision 1.187  2004/04/09 11:06:27  law
// - new class: Tl3CVList.
//
// Revision 1.186  2004/03/24 16:50:00  law
// - new behavior: сделана возможность иметь дубликаты в сортированном списке тегов.
// - new behavior: списку ActiveIntervals у документа разрешено иметь дубликаты.
//
// Revision 1.185  2004/03/03 18:04:02  law
// - rename unit: l3Tree2 -> l3Tree.
//
// Revision 1.184  2004/02/27 12:50:58  law
// - bug fix: опять-таки пропадали "синие человечки".
//
// Revision 1.183  2003/12/11 16:26:52  law
// - rename: все упоминания ChildsCount переименованы в AllChildrenCount.
//
// Revision 1.182  2003/11/11 12:35:23  law
// - new behavior: защитил редактор/TextSource от "переходных" процессов.
//
// Revision 1.181  2003/11/10 16:18:38  law
// - cleanup.
//
// Revision 1.180  2003/10/17 12:03:55  law
// - change: часть функций заменены на свойства (property).
//
// Revision 1.179  2003/10/09 15:24:58  law
// - new behavior: оптимизирован процесс форматирования.
//
// Revision 1.178  2003/09/23 08:37:59  law
// - new prop: IevHyperlink.Hint.
// - rename proc: ev_plAssignNil -> l3AssignNil.
//
// Revision 1.177  2003/07/07 12:30:13  demon
// - bug fix: была странная ситуация - когда документ пустой и его просили очиститься, то он поднимал Exception - EListError.
//
// Revision 1.176  2003/05/16 15:42:29  law
// - bug fix: невозможно было добавить непосредственно к текстовому параграфу сегмент типа k2_idTextSegment.
//
// Revision 1.175  2003/05/14 13:17:14  law
// - change _format: текстовому параграфу добавлен массив позиций табуляции.
//
// Revision 1.174  2003/05/12 09:20:23  law
// - rename proc: ev_plIsNil -> l3IsNil.
//
// Revision 1.173  2003/03/31 12:53:20  voba
// no message
//
// Revision 1.172  2003/03/06 09:38:52  law
// - bug fix.
//
// Revision 1.171  2003/03/06 09:23:29  law
// - new behavior: добавлена возможность описывать пользовательские имена атомов тегов.
//
// Revision 1.170  2003/03/06 08:54:49  law
// - new behavior: добавлена возможность описывать пользовательские имена типов тегов.
//
// Revision 1.169  2003/03/06 08:35:40  law
// - rename method: MultiInheriteType -> _InheriteType.
//
// Revision 1.168  2003/03/05 09:56:29  law
// - new method: _Tk2TypeTable._IterateTypesF.
//
// Revision 1.167  2003/03/05 09:29:28  law
// - new method: _Tk2Type._IteratePropertiesF.
//
// Revision 1.166  2003/02/10 16:06:20  law
// - cleanup: удалена процедура l3NodeActionL2FA - надо вместо нее использовать l3L2NA.
//
// Revision 1.165  2003/02/03 13:56:47  law
// - new behavior: сделана возможность определять массивы тегов, изменение которых взводило бы флаг Modified.
//
// Revision 1.164  2003/02/03 13:31:42  law
// - bug fix: не взводим флаг Modified в режиме IOProcess.
//
// Revision 1.163  2003/02/03 12:49:56  law
// - new behavior: сделана возможность определять теги, изменение которых взводило бы флаг Modified.
//
// Revision 1.162  2002/12/26 15:11:34  law
// - new dll: собрана более легкая версия dll-печати.
//
// Revision 1.161  2002/12/26 14:35:25  law
// - new dll: собрана более легкая версия dll-печати.
//
// Revision 1.160  2002/12/17 12:20:44  law
// - new unit: k2Unknown.
//
// Revision 1.159  2002/12/17 10:32:59  law
// - cleanup.
//
// Revision 1.158  2002/12/15 13:38:08  law
// - new behaivor: вчерновую прикрутил рисование формул.
//
// Revision 1.157  2002/11/29 16:33:38  law
// - new behavior: сделана синхронизация меток с деревом.
//
// Revision 1.156  2002/11/19 15:32:47  law
// - rename method: Tk2AtomR._rAtom -> _rAtom.
//
// Revision 1.155  2002/11/19 15:09:11  law
// - new behavior: обрабатываем параметр AssignTransparent.
//
// Revision 1.154  2002/11/19 13:52:41  law
// - change: Tk2AtomR._Assign - теперь функция.
//
// Revision 1.153  2002/11/11 11:29:39  law
// - bug fix: к текстовому параграфу не добавлялись гиперссылки.
//
// Revision 1.152  2002/11/05 17:13:09  law
// - cleanup.
//
// Revision 1.151  2002/11/01 18:49:55  law
// - new prop: _Tk2ChildrenProperty._OnValidateChild.
//
// Revision 1.150  2002/09/23 12:18:20  law
// - new prop: _Tk2ChildrenProperty._DefaultChildType.
//
// Revision 1.149  2002/09/19 14:08:53  law
// - new method: _Tk2Type._QueryTool.
// - comments.
//
// Revision 1.148  2002/09/18 07:08:03  law
// - new units: k2StackGenerator, _k2Ver.
// - new behavior: Tk2CustomReader теперь наследуется от Tk2CustomStackGenerator и соответственно наследует его поведение.
//
// Revision 1.147  2002/09/09 13:25:06  law
// - cleanup.
//
// Revision 1.146  2002/07/12 12:38:23  law
// - new method version: _InheritsFrom.
//
// Revision 1.145  2002/07/10 11:24:52  law
// - rename method: _HasSubAtom -> _HasSubAtom.
//
// Revision 1.144  2002/07/08 15:37:42  law
// - new behavior: не записываем несохраняемые дочерние теги.
//
// Revision 1.143  2002/07/08 12:09:57  law
// - _default param: Context.
//
// Revision 1.142  2002/01/29 16:18:49  law
// - bug fix: Range Check Error при записывании размера маски.
//
// Revision 1.141  2002/01/08 07:58:02  law
// - cleanup.
//
// Revision 1.140  2001/12/27 15:32:25  law
// - rename proc: l3GetStrLen -> l3StrLen.
//
// Revision 1.139  2001/12/27 15:03:31  law
// - new constructors: добавлены два конструктора _Tl3String._Make.
//
// Revision 1.138  2001/09/28 12:24:48  narry
// - bug fix: AV после выхода после поиска по листу.
//
// Revision 1.137  2001/09/25 08:04:00  law
// - comments: xHelpGen.
//
// Revision 1.136  2001/09/21 09:58:55  law
// - cleanup.
//
// Revision 1.135  2001/08/31 08:50:07  law
// - cleanup: первые шаги к кроссплатформенности.
//
// Revision 1.134  2001/08/31 07:16:23  law
// - cleanup: убраны ненужные ссылки на Windows.
//
// Revision 1.133  2001/08/30 16:34:22  law
// - new version: портировал на Delphi 6.
//
// Revision 1.132  2001/08/29 08:53:39  law
// - comments: xHelpGen.
//
// Revision 1.131  2001/08/28 08:50:37  law
// - comments: xHelpGen.
//
// Revision 1.130  2001/08/02 11:43:19  law
// - cleanup & comments.
//
// Revision 1.129  2001/07/17 14:59:02  law
// - bug fix: в соответствии с задачей №722.
//
// Revision 1.128  2001/06/05 15:13:21  law
// - new method: IevDocumentPart.Merge.
//
// Revision 1.127  2001/05/31 08:04:56  law
// - cleanup: убрана запись компонент.
//
// Revision 1.126  2001/04/18 13:25:23  law
// - comments: добавлены комментарии для xHelpGen.
//
// Revision 1.125  2001/04/16 14:42:35  law
// - bug fix: попытка вызова Tk2AtomR_rAtom при (IsValid <> true) приводила к AV.
//
// Revision 1.124  2001/04/09 10:11:16  law
// - new behavior: оптимизирован алгоритм изменения флага переформатирования параграфа.
//
// Revision 1.123  2001/03/21 12:23:24  law
// - bug fix: AV получении атома у пустого тега.
//
// Revision 1.122  2001/03/15 14:52:23  law
// - cleaning & coments.
//
// Revision 1.121  2001/03/13 18:44:34  law
// - some cleaning, tuning & comments.
//
// Revision 1.120  2001/03/11 10:25:17  law
// - процедура ListError переименована в _k2ListError и объявлена в интерфейсной секции.
//
// Revision 1.119  2001/03/05 14:08:18  law
// - поменялся порядок у методов _IterateChildren...
//
// Revision 1.118  2001/02/28 17:50:26  law
// - изменены параметры метода AssignSubAtomEx.
//
// Revision 1.117  2001/02/28 16:30:01  law
// - отсечение пересекающихся сегментов.
//
// Revision 1.116  2001/02/28 13:15:02  law
// - расширен интерфейс Ik2PropertyBag.
//
// Revision 1.115  2001/02/28 10:12:40  law
// - процедуры _Write и WriteEx объединены в одну - _Write.
//
// Revision 1.114  2001/02/20 10:23:52  law
// - some tuning
//
// Revision 1.113  2001/01/31 10:37:31  law
// - оптимизировано использование QueryInterface.
//
// Revision 1.112  2001/01/04 14:58:51  voba
// - bug fix: установка стиля по умолчанию.
//
// Revision 1.111  2000/12/19 12:53:09  law
// - удалены ненужные ссылки на k2Context.
//
// Revision 1.110  2000/12/15 15:18:58  law
// - вставлены директивы Log.
//

{$Include k2Define.inc }

interface

uses
  TypInfo,
  Classes,

  l3Types,
  l3Struct,
  l3IID,
  l3Msg,
  l3Base,
  l3Interfaces,
  l3InternalInterfaces,
  l3Const,
  l3BitArr,
  k2Dictionary,
  l3Tree_TLB,
  l3ProtoObject,
  l3CacheableBase,
  l3PrimString,
  l3SimpleObject,
  l3CProtoObject,
  l3ProtoObjectWithCOMQI,
  l3Variant,

  k2BaseTypes,
  k2Types,
  k2Tags,
  k2Except,
  k2Interfaces,
  k2ChildrenPathList,
  k2Prim,
  k2BaseStruct,
  k2TypeModelPart,

  k2AtomWrapPrim,
  k2ToolPrim,
  k2InterfaceList,
  k2InterfaceCache,
  k2InterfaceFactory,
  k2NotStructuredTag,
  k2AtomicTag,
  k2AtomicTagRefList
  ;

type
  Tk2Type = class;

  Tk2CustomProperty = class;

  Wk2Atom = class(Tk2AtomWrapPrim)
   {* Инструмент для реализации операций с тегами. }
    protected
    // internal fields
      AtomType : Tk2Type;
    public
    // public methods
      function  PreGetAtomData(AE : Tl3Variant;
                               aProp    : Tk2CustomProperty;
                               out Data : Tl3Variant): Boolean;
        virtual;
        {-}
      function  GetAtomData(AE : Tl3Variant;
                            aProp    : Tk2CustomProperty;
                            out Data : Tl3Variant): Boolean;
        virtual;
        {-}
      function  AsString(A: Tl3Variant): AnsiString;
        virtual;
        {-}
      function  StrToTag(const aValue: AnsiString): Tl3Tag;
        virtual;
        {-}
      function  ObjToTag(aValue: TObject): Il3TagRef;
        virtual;
        {-}
      procedure ForceStore(aTag : Tl3Variant);
        virtual;
        {-}
      function  MarkModified(aTag : Tl3Variant): Boolean;
        virtual;
        {-}
  end;//Wk2Atom
  Rk2Atom = class of Wk2Atom;

  Tk2BeforeChangePropProc = function(const V       : Tk2Values;
                                     const aProp   : Tk2CustomProperty;
                                     const Context : Ik2Op): Boolean;
  Tk2AfterChangePropProc = procedure(const V       : Tk2Values;
                                     const aProp   : Tk2CustomProperty;
                                     const Context : Ik2Op);
  Tk2StoredPropProc = function(P       : Tl3Variant;
                               Value   : Tl3Variant;
                               const aProp   : Tk2CustomProperty;
                               const Context : Ik2Op): Boolean;
  Tk2StoredChildProc = function(P       : Tl3Variant;
                                Child   : Tl3Variant;
                                const aProp   : Tk2CustomProperty;
                                const Context : Ik2Op): Boolean;
  Tk2GetChildTypeForParentProc = procedure(aParent : Tl3Variant;
                                            var theType  : Tk2Type);
  Tk2ValidateChildProc = procedure(aParent : Tl3Variant;
                                   var aChild    : Tl3Variant;
                                   var aValid    : Boolean);

  Ek2ParamNotDefined = class(Ek2Warning);

  Tk2Base = k2Prim.Tk2Base;

  Tk2CustomPropertyPrim = k2Prim.Tk2CustomPropertyPrim;

  Tk2CustomProperty = class(Tk2CustomPropertyPrim)
   {* Базовый класс для описания свойства тега. }
    protected
      f_Weight       : Long;
      {$IfDef k2NeedUserInfo}
      f_UserName     : AnsiString;
      {$EndIf k2NeedUserInfo}
    protected
      f_BeforeChange : Tk2BeforeChangePropProc;
      f_AfterChange  : Tk2AfterChangePropProc;
      f_Stored       : Long;
    protected
    // property methods
      function  GetIsProp: Boolean;
        override;
        {-}
      function  pm_GetEmptyMapping: Long;
        override;
      procedure pm_SetEmptyMapping(Value: Long);
        virtual;
        {-}
      procedure pm_SetStoredProc(Value: Tk2StoredPropProc);
        {-}
      procedure pm_SetStored(Value: Boolean);
        {-}
      function  pm_GetDefaultValue: Long;
        virtual;
        //override;
        {-}
      function  pm_GetReadOnly: Boolean;
        override;
      procedure pm_SetReadOnly(Value: Boolean);
        virtual;
        {-}
      procedure pm_SetTagIndex(Value: Long);
        {-}
      function  pm_GetOrderKey: Tl3OrderKey;
      procedure pm_SetOrderKey(const Value: Tl3OrderKey);
        {-}
      function  pm_GetIsArray: Boolean;
        virtual;
        {-}
      function  pm_GetMappingTarget: Long;
        override;
      procedure pm_SetMappingTarget(aValue: Long);
        virtual;
        {-}
    protected
    // internal methods
    public
    // public methods
      constructor Create(aParentType     : Tk2Type;
                         anID            : Integer;
                         const aUserName : AnsiString);
        reintroduce;
        {* - создает описатель свойства. }
      function Clone(aParentType: Tk2Type): Pointer;
        {* Создайт копию свойства. }
      procedure AssignProperty(P: Tk2CustomProperty);
        virtual;
        {-}
      function  DoBeforeChange(var V         : Tk2Values;
                               const Context : Ik2Op): Boolean;
        {-}
      procedure DoAfterChange(var V         : Tk2Values;
                              const Context : Ik2Op);
        {-}
      function  GetStored(const P       : Tl3Variant;
                          const Value   : Tl3Variant;
                          const Context : Ik2Op): Boolean;
        {-}
      procedure pm_SetDefaultValue(Value: Long);
        virtual;
        {-}
    public
    // public properties
      property EmptyMapping: Long
        read pm_GetEmptyMapping
        write pm_SetEmptyMapping;
        {-}
      property DefaultValue: Long
        read pm_GetDefaultValue
        write pm_SetDefaultValue;
        {* - значение по умолчанию. }
      property OrderKey: Tl3OrderKey
        read pm_GetOrderKey
        write pm_SetOrderKey;
        {-}
      property IsArray: Boolean
        read pm_GetIsArray;
        {* - скалярное или векторное свойство? }
      {$IfDef k2NeedUserInfo}
      property UserName: AnsiString
        read f_UserName;
        {* - название свойства для пользователя. }
      {$EndIf k2NeedUserInfo}
      property MappingTarget: Long
        read pm_GetMappingTarget
        write pm_SetMappingTarget;
        {-}
    public
    // public procedures
      property BeforeChange: Tk2BeforeChangePropProc
        read f_BeforeChange
        write f_BeforeChange;
        {-}
      property AfterChange: Tk2AfterChangePropProc
        read f_AfterChange
        write f_AfterChange;
        {-}
      property StoredProc: Tk2StoredPropProc
        write pm_SetStoredProc;
        {-}
      property Stored: Boolean
        write pm_SetStored;
        {-}
      property ReadOnly: Boolean
        read pm_GetReadOnly
        write pm_SetReadOnly;
        {* - "только для чтения"? }
  end;//Tk2CustomProperty
  Pk2CustomProperty = ^Tk2CustomProperty;
  Tk2Prop = Tk2CustomProperty;

  Tk2Property = class(Tk2CustomProperty)
   {* Описание свойства тега. }
    private
    // property fields
      f_EmptyMapping  : Long;
      f_DefaultValue  : Long;
      f_MappingTarget : Long;
      f_ReadOnly      : Boolean;
    protected
    // property methods
      function  pm_GetEmptyMapping: Long;
        override;
      procedure pm_SetEmptyMapping(Value: Long);
        override;
        {-}
      function  pm_GetReadOnly: Boolean;
        override;
      procedure pm_SetReadOnly(Value: Boolean);
        override;
        {-}
      function  pm_GetDefaultValue: Long;
        override;
        {-}
      function  pm_GetMappingTarget: Long;
        override;
        {-}
      procedure pm_SetMappingTarget(aValue: Long);
        override;
        {-}
      procedure InitFields;
        override;
        {-}
    public
    // public methods
      constructor Create(aParentType     : Tk2Type;
                         anID            : Integer;
                         anAtomType      : Tk2Type;
                         const aUserName : AnsiString);
        reintroduce;
        {-}
      procedure pm_SetDefaultValue(Value: Long);
        override;
        {-}
  end;//Tk2Property

  Tk2ChildrenProperty = class(Tk2CustomProperty)
    private
    // property fields
      f_ChildType               : Tk2Type;
      f_DefaultChildType        : Tk2Type;
      f_StoredChild             : Long;
      f_SortIndex               : Long;
      f_Duplicates              : Tl3Duplicates;
      f_OnValidateChild         : Tk2ValidateChildProc;
      f_OnGetChildTypeForParent : Tk2GetChildTypeForParentProc;
      f_MaxChildrenCount        : Integer;
    protected
    // property methods
      procedure pm_SetChildType(Value: Tk2Type);
        {-}
      procedure pm_SetDefaultChildType(Value: Tk2Type);
        {-}
      procedure pm_SetStoredChildProc(Value: Tk2StoredChildProc);
        {-}
      function  pm_GetIsArray: Boolean;
        override;
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(aParentType     : Tk2Type;
                         aChildType      : Tk2Type;
                         aAtomType       : Tk2Type;
                         const aUserName : AnsiString);
        reintroduce;
        {-}
      procedure DoAfterChildAdded(anAtom   : Tl3Variant;
                                  aChild   : Tl3Variant;
                                  const anOpPack : Ik2Op;
                                  anIndex        : Long;
                                  aTotal         : Integer);
        {-}
      function  IsThisArray(out theProp: Tl3VariantDef): Boolean;
        override;
        {-}
      function  ValidateChild(aParent : Tl3Variant;
                              var aChild    : Tl3Variant;
                              const Context : Ik2Op;
                              anIndex       : Integer): Boolean;
        {-}
      procedure AssignProperty(P: Tk2CustomProperty);
        override;
        {-}
      function  GetStoredChild(P       : Tl3Variant;
                               Value   : Tl3Variant;
                               const Context : Ik2Op): Boolean;
        {-}
      function  GetChildTypeForParent(aList: Tl3Variant): Tk2Type;
        {-}
      procedure SetSortTags(const aTag : array of Integer);
        {-}
    public
    // public properties
      property MaxChildrenCount: Integer
        read f_MaxChildrenCount
        write f_MaxChildrenCount;
        {-}
      property ChildType: Tk2Type
        read f_ChildType
        write pm_SetChildType;
        {-}
      property DefaultChildType: Tk2Type
        read f_DefaultChildType
        write pm_SetDefaultChildType;
        {-}
      property StoredChild: Long
        read f_StoredChild
        write f_StoredChild;
        {-}
      property StoredChildProc: Tk2StoredChildProc
        write pm_SetStoredChildProc;
        {-}
      property SortIndex: Long
        read f_SortIndex
        write f_SortIndex;
        {-}
      property Duplicates: Tl3Duplicates
        read f_Duplicates
        write f_Duplicates;
        {-}
      property OnValidateChild : Tk2ValidateChildProc
        read f_OnValidateChild
        write f_OnValidateChild;
        {-}
      property OnGetChildTypeForParent: Tk2GetChildTypeForParentProc
        read f_OnGetChildTypeForParent
        write f_OnGetChildTypeForParent;
        {-}  
  end;//Tk2ChildrenProperty

  Tk2ArrayProperty = Tk2ChildrenProperty;
  Tk2TypeTable = class;

  Tk2TypePrim = k2Prim.Tk2TypePrim;

  Tk2Type = class(Tk2TypeModelPart)
   {* Описание типа тега. }
    private
    // internal fields
      f_TagsByOffset     : array of Tk2CustomProperty;
      f_Wrapper          : Wk2Atom;
      f_ParamsForClone   : TLongArray;
      f_InterfaceFactory : Tk2InterfaceFactory;
      f_IDIndex          : Long;
      f_ValueTable       : Tk2Dictionary;
      f_ChildrenPath     : Tk2ChildrenPathList;
      f_ReadOnlyPropertyCount : Long;
      //f_PropertyCount         : Long;
      {$IfDef k2NeedUserInfo}
      f_UserName              : AnsiString;
      {$EndIf k2NeedUserInfo}
      f_LastChildPath         : record
       rPath   : TLongArray;
       rTypeID : Integer;
      end;//f_LastChildPath
      f_Cache                 : array of Tk2AtomicTag;
      f_Cache1                : Tk2AtomicTagRefList;
      f_TransparentTag        : Tk2NotStructuredTag;
      f_RemoveCacheObjectsAtStart : Boolean;
    protected
    // property methods
      function  pm_GetHasProperties: Boolean;
        {-}
      function  pm_GetHasProperty(Index: Long): Boolean;
        {-}
      function  pm_GetAtomClass: TClass;
      procedure pm_SetAtomClass(Value: TClass);
        {-}
      function  pm_GetArrayProp(TagIndex: Long): Tk2ChildrenProperty;
        {-}
      function  pm_GetPropertyCount: Long;
        {-}
      procedure pm_SetInterfaceFactoryType(Value: Rk2InterfaceFactory);
        {-}
      procedure pm_SetInterfaceFactory(Value: Tk2InterfaceFactory);
        {-}
      function  pm_GetWrapperType: Rk2Atom;
      procedure pm_SetWrapperType(Value: Rk2Atom);
        {-}
      procedure pm_SetValueTable(Value: Tk2Dictionary);
        {-}
    protected
    // internal methods
      function  MakeFromInt(aRef : Integer; anImplementator: Rk2AtomicTag): Tk2NotStructuredTag;
        {-}    
      procedure InheriteFrom(aType: Tk2Type);
        {-}
      procedure UndefineProperty(aTagIndex: Long);
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(anOwner          : Tk2TypeTable;
                         const anUserName : AnsiString);
        reintroduce;
        virtual;
        {* - создает новый тип. }
      procedure Clear;
        //override;
        {-}
      procedure Recalc;
        {-}
      function  DefineProperty(aTagIndex       : Long;
                               aPropType       : Tk2Type;
                               const aUserName : AnsiString = ''): Tk2Property;
        {* - определяет скалярное свойство типа тега. }
      procedure UndefineProperties(const aTags: array of Long);
        {-}
      function  DefineChildren(aChildType: Tk2Type{; aListType : Tk2Type = nil}): Tk2ChildrenProperty;
        {-}
      procedure DefineChildrenPath(aTagType: Tk2Type; const Path : array of Long);
        {-}
      function  FindChildPath(aTagType: Tk2TypePrim): TLongArray;
        {-}
      function  GetPropByOffset(anAtomIndex: Long): Tk2CustomProperty;
        {-}
      procedure IteratePropertiesF(anAction: Tl3IteratorAction);
        {-}
      procedure SetNeedMarkModified(const aProp : array of Long;
                                    aValue      : Boolean = true);
        {-}
      procedure SetNeedMarkModifiedAll(aValue: Boolean = true);
        {-}
      procedure SetNeedMarkModifiedAllExcept(aProp : Long);
        {-}
      procedure SetTagOrder(const aTag : array of Integer);
        {-}
      function  DoDoMakeTag(aRef: Integer): Il3TagRef; override;
        {* - создает атом данного типа. }
    public
    // методы для работы с атомами данного типа
      function  DoMakeTag(aRef: Integer): Il3TagRef;
        virtual;
        {* - создает атом данного типа. }
      procedure AddValue(aValue: Tl3Variant);
        {-}
      function  StrToTag(const aValue : AnsiString): Tl3Tag;
        {-}
      function  ObjToTag(aValue: TObject): Il3TagRef;
        {-}
      function  TransparentTag: Tk2NotStructuredTag;
        {-}
      function  IsAuto: Boolean; virtual;
        {-}
    public
    // public properties
      property HasProperties: Boolean
        read pm_GetHasProperties;
        {* - определены ли свойства для данного типа. }
      property HasProperty[Index: Long]: Boolean
        read pm_GetHasProperty;
        {* - определено ли свойство Index? }
      property AtomClass: TClass
        read pm_GetAtomClass
        write pm_SetAtomClass;
        {-}
      property ArrayProp[TagIndex: Long]: Tk2ChildrenProperty
        read pm_GetArrayProp;
        {-}
   private
      property PropertyCount: Long
        read pm_GetPropertyCount;
        {* - количество свойст определенных у данного типа. }
   public
      property IDIndex: Long
        read f_IDIndex
        write f_IDIndex;
        {-}
      property InterfaceFactory: Tk2InterfaceFactory
        read f_InterfaceFactory
        write pm_SetInterfaceFactory;
        {-}
      property InterfaceFactoryType: Rk2InterfaceFactory
        write pm_SetInterfaceFactoryType;
        {-}
      property WrapperType: Rk2Atom
        read pm_GetWrapperType
        write pm_SetWrapperType;
        {-}
      property ValueTable: Tk2Dictionary
        read f_ValueTable
        write pm_SetValueTable;
        {-}
      property ReadOnlyPropertyCount: Long
        read f_ReadOnlyPropertyCount;
        {* - количество Read-only свойств. }
   protected
      property Properties: Tk2PropertyArray
        read f_Tags;
        {* - свойства типа. }
   public
      {$IfDef k2NeedUserInfo}
      property UserName: AnsiString
        read f_UserName;
        {* - имя типа для пользователя. }    
      {$EndIf k2NeedUserInfo}
      property ParamsForClone: TLongArray
        read f_ParamsForClone
        write f_ParamsForClone;
        {* - параметры, которые копируются при клонировании. }
      property Wrapper: Wk2Atom                                 
        read f_Wrapper;
        {-}
  end;//Tk2Type

  Rk2Type = class of Tk2Type;

  Tk2AutoType = class(Tk2Type)
    public
      function  IsAuto: Boolean; override;
        {-}
  end;//Tk2AutoType

  Rk2AutoType = class of Tk2AutoType;

  Tk2TypeTable = class(Tk2TypeTablePrim)
   {* Таблица типов тегов. }
    private
    // property fields
      f_MaxTypeID : Integer;
      f_TypesByHandle : TObject;
    protected
    // property methods
      function  pm_GetMaxTypeID : Integer;
        {-}
      function  pm_GetTypeByHandle(anID: Integer): Tk2Type;
        //virtual;
        {-}
      function  pm_GetTypeByName(const aName: AnsiString): Tk2Type;
        {-}
    protected
    // internal methods
      procedure InitFields;
        override;
      procedure BeforeRelease;
        override;
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      class procedure AddCreatedListener(aListener: TNotifyEvent); override;
      constructor Create;
        reintroduce;
        virtual;
        {-}
      class function GetInstance: Tk2TypeTable;
        {-}
      class procedure SetAsDefault;
        {-}
      class procedure CheckAndCleanupReferences;
        {-}
    protected
      function  DefineType(anID                : Long;
                             const aTagParents : array of Tk2Type;
                             const anUserName  : AnsiString;
                             aTypeRef          : Rk2Type): Tk2Type;
        {* - определить тип со множественным наследованием. }
      function  DefineAutoType(const aTagParents : array of Tk2Type;
                               const anUserName  : AnsiString;
                               aTypeRef          : Rk2AutoType): Tk2Type;
        {-}
    public
    // public properties
      property TypeByHandle[anID: Integer]: Tk2Type
        read pm_GetTypeByHandle;
        //default;
        {* - тип с идентификатором H. }
      property TypeByName[const aName: AnsiString]: Tk2Type
        read pm_GetTypeByName;
        {-}
      property MaxTypeID : Integer
        read pm_GetMaxTypeID;
        {-}
  end;//Tk2TypeTable

procedure ConvertError(const N1, N2: AnsiString);
  {-}
procedure k2FreeTIA(var Stub: Mk2Children_IterateChildrenF_Action);
  {-}
procedure k2ListError(anIndex: Long);
  {* - ошибка доступа к элементу списка }
function  k2NullTag: Tk2NotStructuredTag;
  {-}

var
 g_DisableCheckDisabledChildren : Integer = 0;

implementation

uses
  SysUtils,
  {$IfDef Delphi6}
  RTLConsts,
  {$Else  Delphi6}
  Consts,
  {$EndIf Delphi6}
  Messages,

  l3Except,
  l3MinMax,
  l3Chars,
  l3String,
  l3Stream,
  l3InterfacesMisc,
  l3BaseStream,
  l3Memory,
  l3CObjectRefList,
  l3ProtoObjectRefList,

  k2Const,
  k2Facade,
  k2InternalInterfaces,
  k2Strings,
  //k2AtomicTag,
  k2TagList,
  k2PropSorter,
  k2NullTagImpl,
  k2PropertyArray,

  k2Long_Const,
  k2Bool_Const,
  k2String_Const,
  k2l3Base_Const,
  k2Object_Const,
  k2IUnknown_Const,
  k2TransparentTag,
  k2String,
  k2DictionaryEx,

  l3Filer,

  k2SortTagsList
  {$IfOpt D+}
  ,
  k2ParentedTypedSmallLeafTag,
  k2TypedSmallLeafTag,
  k2ParentedTypedSmallListTag,
  k2DictRec
  {$EndIf}
  ,
  k2TypesByHandleList,
  k2TypedAtomicTag,
  k2ChildrenPath,
  k2IUnknownTag,
  k2TypeTableCreatedListeners
  ;

function k2NullTag: Tk2NotStructuredTag;
  {-}
begin
 Result := Tk2NullTagImpl.Instance;
end;

procedure k2FreeTIA(var Stub: Mk2Children_IterateChildrenF_Action);
  register;
  {-}
asm
          jmp  l3FreeLocalStub
end;{asm}

procedure ConvertError(const N1, N2: AnsiString);
  {-}
begin
 raise Ek2ConversionError.CreateFmt(k2_errConvertError, [N1, N2]);
 {&Exception&}
end;

procedure k2ListError(anIndex: Long);
  {-ошибка доступа к элементу списка}
begin
 raise EListError.CreateFmt(SListIndexError, [anIndex])
end;

// start object Wk2Atom

function Wk2Atom.PreGetAtomData(AE : Tl3Variant;
                                aProp    : Tk2CustomProperty;
                                out Data : Tl3Variant): Boolean;
  //virtual;
  {-}
begin
 Result := false;
 Data := nil;
end;

function Wk2Atom.GetAtomData(AE : Tl3Variant;
                             aProp    : Tk2CustomProperty;
                             out Data : Tl3Variant): Boolean;
  {virtual;}
  {-}
begin
 Result := false;
 Data := nil;
end;

function Wk2Atom.AsString(A: Tl3Variant): AnsiString;
  {virtual;}
  {-}
begin
 ConvertError(AtomType.AsString, 'AnsiString');
 Result := '';
end;

function Wk2Atom.StrToTag(const aValue: AnsiString): Tl3Tag;
  //virtual;
  {-}
begin
 ConvertError('AnsiString', AtomType.AsString);
end;

function Wk2Atom.ObjToTag(aValue: TObject): Il3TagRef;
  //virtual;
  {-}
begin
 if (aValue = nil) then
  ConvertError(k2_strNil, AtomType.AsString)
 else
  ConvertError(aValue.ClassName, AtomType.AsString);
end;

procedure Wk2Atom.ForceStore(aTag : Tl3Variant);
  //virtual;
  {-}
begin
end;

function Wk2Atom.MarkModified(aTag : Tl3Variant): Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

// start class Tk2CustomProperty

constructor Tk2CustomProperty.Create(aParentType     : Tk2Type;
                                     anID            : Integer;
                                     const aUserName : AnsiString);
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 pm_SetTagIndex(anID);
 inherited Create(aParentType);
 f_Stored := Ord((anID <= k2_tiChildren) OR (anID > k2_tiLast));
 {$IfDef k2NeedUserInfo}
 f_UserName := aUserName;
 {$EndIf k2NeedUserInfo}
end;

function Tk2CustomProperty.Clone(aParentType: Tk2Type): Pointer;
type
  Rk2CustomProperty = class of Tk2CustomProperty;
begin
 Result := Rk2CustomProperty(ClassType).Create(aParentType,
                                               Self.TagIndex,
                                               {$IfDef k2NeedUserInfo}
                                               Self.UserName
                                               {$Else  k2NeedUserInfo}
                                               ''
                                               {$EndIf k2NeedUserInfo}
                                               );
 Tk2CustomProperty(Result).AssignProperty(Self);
end;

function Tk2CustomProperty.GetIsProp: Boolean;
  //override;
  {-}
begin
 Result := true;
end;

function  Tk2CustomProperty.pm_GetEmptyMapping: Long;
  {virtual;}
  {-}
begin
 Result := k2_tiMask;
end;

procedure Tk2CustomProperty.pm_SetEmptyMapping(Value: Long);
  {virtual;}
  {-}
begin
end;

function Tk2CustomProperty.pm_GetDefaultValue: Long;
  {virtual;}
  {-}
begin
 Result := l3NilLong;
end;

function Tk2CustomProperty.pm_GetReadOnly: Boolean;
  {virtual;}
  {-}
begin
 Result := false;
end;

procedure Tk2CustomProperty.pm_SetReadOnly(Value: Boolean);
  {virtual;}
  {-}
begin
end;

procedure Tk2CustomProperty.pm_SetDefaultValue(Value: Long);
  {virtual;}
  {-}
begin
end;

procedure Tk2CustomProperty.pm_SetTagIndex(Value: Long);
  {-}
begin
 IDw := Value;
 AtomIndex := Value;
end;

function Tk2CustomProperty.pm_GetOrderKey: Tl3OrderKey;
  {-}
begin
 Result.Primary := AtomIndex;
 Result.Delta := f_Weight;
end;

procedure Tk2CustomProperty.pm_SetOrderKey(const Value: Tl3OrderKey);
  {-}
begin
 AtomIndex := Value.Primary;
 f_Weight := Value.Delta;
end;

function Tk2CustomProperty.pm_GetIsArray: Boolean;
  {virtual;}
  {-}
begin
 Result := false;
end;

function Tk2CustomProperty.pm_GetMappingTarget: Long;
  //virtual;
  {-}
begin
 Result := 0;
end;

procedure Tk2CustomProperty.pm_SetMappingTarget(aValue: Long);
  //virtual;
  {-}
begin
end;
  
procedure Tk2CustomProperty.pm_SetStoredProc(Value: Tk2StoredPropProc);
  {-}
begin
 Tk2StoredPropProc(f_Stored) := Value;
end;

procedure Tk2CustomProperty.pm_SetStored(Value: Boolean);
  {-}
begin
 if (f_Stored <> Ord(Value)) then
 begin
  Assert(not Value OR (TagIndex <= k2_tiChildren));
  f_Stored := Ord(Value);
 end;//f_Stored <> Value
end;

procedure Tk2CustomProperty.AssignProperty(P: Tk2CustomProperty);
  {override;}
  {-}
var
 l_Prop : Tk2CustomProperty absolute P;
begin
 pm_SetTagIndex(l_Prop.TagIndex);
 AtomType := l_Prop.AtomType;
 DefaultValue := l_Prop.DefaultValue;
 BeforeChange := l_Prop.BeforeChange;
 AfterChange := l_Prop.AfterChange;
 Shared := l_Prop.Shared;
 f_Stored := l_Prop.f_Stored;
 ReadOnly := l_Prop.ReadOnly;
 NeedMarkModified := l_Prop.NeedMarkModified;
 {$IfDef k2NeedUserInfo}
 f_UserName := l_Prop.f_UserName;
 {$EndIf k2NeedUserInfo}
 OrderKey := l_Prop.OrderKey;
end;

function  Tk2CustomProperty.DoBeforeChange(var V         : Tk2Values;
                                           const Context : Ik2Op): Boolean;
  {-}
begin
 if Assigned(f_BeforeChange) then
  Result := f_BeforeChange(V, Self, Context)
 else
  Result := true;
end;

procedure Tk2CustomProperty.DoAfterChange(var V         : Tk2Values;
                                          const Context : Ik2Op);
  {-}

 procedure SignalAfterChange;
 begin//
  if Assigned(f_AfterChange) then
  begin
   f_AfterChange(V, Self, Context)
  end;//Assigned(f_AfterChange)
 end;//SignalAfterChange

begin
 if (TagIndex = k2_tiAllChildrenCount) then
  Exit;
 if V.IsChanged then
 begin
  if (Context <> nil) AND not Context.InIOProcess then
   Context.Processor.NotifyPropChanged(Self, V, Context);
  //not OldValue.EQ(NewValue)
  SignalAfterChange;
 end;//V.IsChanged
end;

function Tk2CustomProperty.GetStored(const P       : Tl3Variant;
                                     const Value   : Tl3Variant;
                                     const Context : Ik2Op): Boolean;
  {-}
begin
 if (ULongComp(f_Stored, High(Word)) > 0) then
  Result := Tk2StoredPropProc(f_Stored)(P, Value, Self, Context)
 else
  Result := Boolean(f_Stored);
end;

// start class Tk2Property 

constructor Tk2Property.Create(aParentType     : Tk2Type;
                               anID            : Integer;
                               anAtomType      : Tk2Type;
                               const aUserName : AnsiString);
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 inherited Create(aParentType, anID, aUserName);
 f_EmptyMapping := k2_tiMask;
 f_DefaultValue := l3NilLong;
 AtomType := anAtomType;
end;

procedure Tk2Property.InitFields;
  //override;
  {-}
begin
 inherited;
 f_EmptyMapping := k2_tiMask;
 f_DefaultValue := l3NilLong;
end;

function  Tk2Property.pm_GetEmptyMapping: Long;
  {override;}
  {-}
begin
 Result := f_EmptyMapping;
end;

procedure Tk2Property.pm_SetEmptyMapping(Value: Long);
  {override;}
  {-}
var
 l_Prop : Tk2CustomProperty;
begin
 if (f_EmptyMapping <> Value) then
 begin
  if (f_EmptyMapping <> k2_tiMask) then
  begin
   l_Prop := Tk2CustomProperty(Tk2TypePrim(ParentType).Prop[f_EmptyMapping]);
   if (l_Prop <> nil) then
    l_Prop.MappingTarget := l_Prop.MappingTarget - 1;
  end;//f_EmptyMapping <> k2_tiMask
  f_EmptyMapping := Value;
  if (Value <> k2_tiMask) then
  begin
   l_Prop := Tk2CustomProperty(Tk2TypePrim(ParentType).Prop[Value]);
   if (l_Prop <> nil) then
    l_Prop.MappingTarget := l_Prop.MappingTarget + 1;
  end;//Value <> k2_tiMask
 end;//f_EmptyMapping <> Value
end;

function Tk2Property.pm_GetReadOnly: Boolean;
  {override;}
  {-}
begin
 Result := f_ReadOnly;
end;

procedure Tk2Property.pm_SetReadOnly(Value: Boolean);
  {override;}
  {-}
begin
 if (f_ReadOnly <> Value) then
 begin
  f_ReadOnly := Value;
  if Value then
   Inc(Tk2Type(ParentType).f_ReadOnlyPropertyCount)
  else
   Dec(Tk2Type(ParentType).f_ReadOnlyPropertyCount);
 end;//f_ReadOnly <> Value
end;

function  Tk2Property.pm_GetDefaultValue: Long;
  {override;}
  {-}
begin
 Result := f_DefaultValue;
end;

function Tk2Property.pm_GetMappingTarget: Long;
  //override;
  {-}
begin
 Result := f_MappingTarget;
end;

procedure Tk2Property.pm_SetMappingTarget(aValue: Long);
  //override;
  {-}
begin
 f_MappingTarget := aValue;
end;

procedure Tk2Property.pm_SetDefaultValue(Value: Long);
  {override;}
  {-}
begin
 f_DefaultValue := Value;
end;

// start class Tk2ChildrenProperty 

constructor Tk2ChildrenProperty.Create(aParentType     : Tk2Type;
                                       aChildType      : Tk2Type;
                                       aAtomType       : Tk2Type;
                                       const aUserName : AnsiString);
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 inherited Create(aParentType, k2_tiChildren, aUserName);
 f_StoredChild := Ord(true);
 f_SortIndex := k2_tiSelfID;
 f_Duplicates := l3_dupIgnore;
 f_MaxChildrenCount := High(f_MaxChildrenCount);
 ChildType := aChildType;
 AtomType := aAtomType;
end;

procedure Tk2ChildrenProperty.Cleanup;
  {override;}
  {-}
begin
 l3Free(f_ChildType);
 l3Free(f_DefaultChildType);
 inherited;
end;

procedure Tk2ChildrenProperty.AssignProperty(P: Tk2CustomProperty);
  {override;}
  {-}
var
 Prop : Tk2ChildrenProperty absolute P;
begin
 inherited;
 if (P Is Tk2ChildrenProperty) then
 begin
  pm_SetTagIndex(Prop.TagIndex);
  // - это чтобы перетереть OrderKey - чтобы дети были вседа ЗА тегами
  //   См. http://mdp.garant.ru/pages/viewpage.action?pageId=139429761 
  ChildType := Prop.ChildType;
  DefaultChildType := Prop.DefaultChildType;
  SortIndex := Prop.SortIndex;
  Duplicates := Prop.Duplicates;
  f_StoredChild := Prop.f_StoredChild;
  f_OnValidateChild := Prop.f_OnValidateChild;
  f_OnGetChildTypeForParent := Prop.f_OnGetChildTypeForParent;
  f_MaxChildrenCount := Prop.f_MaxChildrenCount;
 end;//P Is Tk2ChildrenProperty
end;

function Tk2ChildrenProperty.ValidateChild(aParent : Tl3Variant;
                                           var aChild    : Tl3Variant;
                                           const Context : Ik2Op;
                                           anIndex       : Integer): Boolean;
  {-}
begin
 if (ChildType = nil) then
  Result := false
 else
  Result := aChild.IsKindOf(ChildType);
 if (g_DisableCheckDisabledChildren <= 0) then
  if Result then
   if ParentType.IsDisabledChildTypeID(Tk2Type(aChild.TagType).ID) then
    Result := false;
 if Assigned(f_OnValidateChild) then
  f_OnValidateChild(aParent, aChild, Result);
 if Result AND (Context <> nil) AND
    not Context.InUndo AND not Context.InIOProcess then
  Context.Processor.CheckInsert(aParent, aChild, anIndex);
end;

procedure Tk2ChildrenProperty.DoAfterChildAdded(anAtom   : Tl3Variant;
                                                aChild   : Tl3Variant;
                                                const anOpPack : Ik2Op;
                                                anIndex        : Long;
                                                aTotal         : Integer);
  {-}
begin
 aChild.Owner := anAtom;
 if (anIndex >= 0) AND (anOpPack <> nil) then
 begin
  if not anOpPack.InIOProcess then
   if NeedMarkModified then
    anOpPack.MarkModified(anAtom);
  if (anOpPack.Processor <> nil) then
   anOpPack.Processor.NotifyInsert(anAtom, Self, aChild, anIndex, anOpPack);
 end;//anIndex >= 0
end;

procedure Tk2ChildrenProperty.pm_SetChildType(Value: Tk2Type);
  {-}
begin
 if Value.SetRefTo(f_ChildType) then
  DefaultChildType := Value;
end;

procedure Tk2ChildrenProperty.pm_SetDefaultChildType(Value: Tk2Type);
  {-}
begin
 Value.SetRefTo(f_DefaultChildType);
end;

procedure Tk2ChildrenProperty.pm_SetStoredChildProc(Value: Tk2StoredChildProc);
  {-}
begin
 Tk2StoredChildProc(f_StoredChild) := Value;
end;

function Tk2ChildrenProperty.pm_GetIsArray: Boolean;
  {override;}
  {-}
begin
 Result := true;
end;

function Tk2ChildrenProperty.IsThisArray(out theProp: Tl3VariantDef): Boolean;
  //override;
  {-}
begin
 Result := true;
 theProp := Self;
end;

function Tk2ChildrenProperty.GetStoredChild(P       : Tl3Variant;
                                            Value   : Tl3Variant;
                                            const Context : Ik2Op): Boolean;
  {-}
begin
 if (ULongComp(f_StoredChild, High(Word)) > 0) then
  Result := Tk2StoredChildProc(f_StoredChild)(P, Value, Self, Context)
 else
  Result := Boolean(f_StoredChild);
end;

function Tk2ChildrenProperty.GetChildTypeForParent(aList: Tl3Variant): Tk2Type;
  {-}
var
 l_T : Tk2Type;
begin
 l_T := ChildType;
 if Assigned(f_OnGetChildTypeForParent) then
  f_OnGetChildTypeForParent(aList, l_T);
 Result := l_T; 
end;

procedure Tk2ChildrenProperty.SetSortTags(const aTag : array of Integer);
  {-}
var
 l_Index : Integer;
 l_A     : TLongArray;
 l_SI    : Integer;
begin
 if (High(aTag) = 0) AND (aTag[0] >= 0) then
  SortIndex := aTag[0]
 else
 if (High(aTag) > 0) then
 begin
  l_A := l3LongArray(aTag);
  l_Index := Tk2SortTagsList.Instance.IndexOf(l_A);
  if (l_Index >= 0) then
   l_SI := l_Index
  else
   l_SI := Tk2SortTagsList.Instance.Add(l_A);
  SortIndex := l_SI + k2_tiComplexBase;
 end;//High(aTag) > 0
end;

// start class Tk2Type

var
  k2TypeBuffers : Pl3MemoryChain = nil;

constructor Tk2Type.Create(anOwner          : Tk2TypeTable;
                           const anUserName : AnsiString);
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 WrapperType := Wk2Atom;
 f_Tags := Tk2PropertyArray.Create;
 inherited Create{(anOwner)};
 TypeTable := anOwner;
 {$IfDef k2NeedUserInfo}
 f_UserName := anUserName;    
 {$EndIf k2NeedUserInfo}
 //f_PropertyCount := -1;
 f_LastChildPath.rTypeID := -1;
 f_IDIndex := k2_tiSelfID;
end;

procedure Tk2Type.Cleanup;
  {override;}
  {-}
var
 l_Index : Integer;
begin
 FreeAndNil(f_TransparentTag);
 FreeAndNil(f_Cache1);
 for l_Index := Low(f_Cache) to High(f_Cache) do
  FreeAndNil(f_Cache[l_Index]);
 f_TagsByOffset := nil;
 Clear;
 //ToolFactory := nil;
 FreeAndNil(f_Wrapper);
 inherited;
end;

(*function __FreeProp1(P: Pointer; BitNum: Long): Boolean; far;
begin
 if (BitNum <> k2_tiMask) then
  l3Free(Pk2CustomProperty(P)^);
 Result := true;
end;*)

function __FreeProp2(Prop: Pointer): Boolean; far;
begin
 l3Free(Prop^);
 Result := true;
end;

procedure Tk2Type.Clear;
  {override;}
  {-}
begin
 FreeAndNil(f_Cache1);
 FreeAndNil(f_InterfaceFactory);
 FreeAndNil(f_ValueTable);
 FreeAndNil(f_ChildrenPath);
 FreeAndNil(f_Tags);
 inherited;
end;

procedure Tk2Type.SetNeedMarkModified(const aProp : array of Long;
                                      aValue      : Boolean = true);
  {-}
var
 l_Prop  : Tk2CustomProperty;
 l_Index : Integer;
begin
 for l_Index := Low(aProp) to High(aProp) do
 begin
  l_Prop := Tk2CustomProperty(Prop[aProp[l_Index]]);
  if (l_Prop <> nil) then
   l_Prop.NeedMarkModified := aValue;
 end;//for l_Index
end;
  
procedure Tk2Type.SetNeedMarkModifiedAll(aValue: Boolean = true);
  {-}

 function DoProp(aProp: Pk2CustomProperty; Index: Long): Boolean;
 begin//DoProp
  Result := true;
  if (aProp^ <> nil) then
   aProp^.NeedMarkModified := aValue;
 end;//DoProp

begin
 IteratePropertiesF(l3L2IA(@DoProp));
end;
  
procedure Tk2Type.SetNeedMarkModifiedAllExcept(aProp : Long);
  {-}
begin
 SetNeedMarkModifiedAll;
 SetNeedMarkModified([aProp], false);
end;
  
procedure Tk2Type.SetTagOrder(const aTag : array of Integer);
  {-}
var
 l_Key   : Tl3OrderKey;
 l_Index : Integer;
begin
 l_Key := Tk2CustomProperty(Prop[aTag[Low(aTag)]]).OrderKey.StrengthPred;
 for l_Index := Low(aTag) + 1 to High(aTag) do
 begin
  with Tk2CustomProperty(Prop[aTag[l_Index]]) do
  begin
   OrderKey := l_Key;
   l_Key := OrderKey.Succ;
  end;//with Prop[aTag[l_Index]]
 end;//for l_Index
end;

function Tk2Type.pm_GetHasProperties: Boolean;
  {virtual;}
  {-}
begin
 Result := (f_Tags.Count <> 0);
end;

function Tk2Type.pm_GetHasProperty(Index: Long): Boolean;
  {-}
begin
 Result := f_Tags.Items[Index] <> nil;
end;

function Tk2Type.pm_GetAtomClass: TClass;
  {-}
var
 AT : PTypeInfo;
begin
 AT := AtomType;
 if (AT^.Kind = tkClass) then
  Result := GetTypeData(AT)^.ClassType
 else
  Result := nil;
end;

procedure Tk2Type.pm_SetAtomClass(Value: TClass);
  {-}
begin
 if (Value = nil) then
  AtomType := nil
 else
 begin
  AtomType := Value.ClassInfo;
  Assert(AtomType <> nil);
 end;//Value = nil
end;

function Tk2Type.pm_GetArrayProp(TagIndex: Long): Tk2ChildrenProperty;
  {-}
begin
 if (TagIndex = k2_tiChildren) then
  Result := Tk2ChildrenProperty(Self.Prop[TagIndex])
 else
  Result := nil;
end;

function Tk2Type.pm_GetPropertyCount: Long;
  {-}
  
var
 l_Result : Integer absolute Result;

 function DoIt(Prop: Pk2CustomProperty; Index: Long): Boolean;
 begin
  Result := true;
  if (Prop^ <> nil) then
   Inc(l_Result);
 end;
 
begin
 Result := 0;
 f_Tags.IterateAllF(l3L2IA(@DoIt));
(* if (f_PropertyCount = -1) then
  f_PropertyCount := f_Tags.Count;
 Result := f_PropertyCount;*) 
end;

procedure Tk2Type.pm_SetInterfaceFactoryType(Value: Rk2InterfaceFactory);
  {-}
var
 _IF : Tk2InterfaceFactory;
begin
 _IF := Value.Create;
 try
  InterfaceFactory := _IF;
 finally
  l3Free(_IF);
 end;{try..finally}
end;

procedure Tk2Type.pm_SetInterfaceFactory(Value: Tk2InterfaceFactory);
  {-}
begin
 Value.SetRefTo(f_InterfaceFactory);
end;

function  Tk2Type.pm_GetWrapperType: Rk2Atom;
begin
 Result := Rk2Atom(f_Wrapper.ClassType);
end;

procedure Tk2Type.pm_SetWrapperType(Value: Rk2Atom);
  {-}
begin
 l3Free(f_Wrapper);
 f_Wrapper := Value.Create;
 f_Wrapper.AtomType := Self;
end;

procedure Tk2Type.pm_SetValueTable(Value: Tk2Dictionary);
  {-}
begin
 Value.SetRefTo(f_ValueTable);
end;

const
 cReadOnlyTagIndex = -2;
 
function Tk2Type.GetPropByOffset(anAtomIndex: Long): Tk2CustomProperty;
  {-}

 function SearchProp(aProp: Pk2CustomProperty; Index: Long): Boolean; 
 begin//SearchProp
  if (aProp^.AtomIndex = anAtomIndex) then
  begin
   GetPropByOffset := aProp^;
   Result := false;
  end//(aProp^.AtomIndex = anAtomIndex)
  else
   Result := true;
 end;//SearchProp

var
 l_Len : Long;
begin
 Result := nil;
 if (anAtomIndex <> cReadOnlyTagIndex) then
 // - ReadOnly-свойства физически нигде не хранятся таким образом они не могут быть
 //   вычислены по смещению.
 begin
  l_Len := Length(f_TagsByOffset);
  if (anAtomIndex < l_Len) then
   Result := f_TagsByOffset[anAtomIndex];
  if (Result = nil) then
  begin
   IteratePropertiesF(l3L2IA(@SearchProp));
   if (Result <> nil) then
   begin
    if (l_Len <= anAtomIndex) then
     SetLength(f_TagsByOffset, Succ(anAtomIndex));
    f_TagsByOffset[anAtomIndex] := Result;
   end;//Result <> nil
  end;//Result <> nil
 end;//anAtomIndex <> cReadOnlyTagIndex
end;

procedure Tk2Type.IteratePropertiesF(anAction: Tl3IteratorAction);
  {-}

 function DoIt(Prop: Pk2CustomProperty; Index: Long): Boolean;
 begin
  Result := true;
  if (Prop^ <> nil) then
   Result := anAction(Prop, Index);
 end;

begin
 try
  f_Tags.IterateAllF(l3L2IA(@DoIt));
 finally
  l3FreeIA(anAction);
 end;//try..finally
end;

type
  Tk2HackString = class(Tl3PrimString);

procedure Tk2Type.InheriteFrom(aType: Tk2Type);
  {-}

 function InheriteProperty(Prop: Pk2CustomProperty; BitNum: Long): Boolean; far;

 var
  NewProp : Tk2CustomProperty;

 begin
  Result := true;
  if (Prop^ = nil) then
   Exit;
  NewProp := Prop^.Clone(Self);
  try
   Assert(Tk2HackString(NewProp).GetOwner = Self);
   f_Tags.Items[BitNum] := NewProp;
  finally
   FreeAndNil(NewProp);
  end;//try..finally
 end;

 function InheriteMapping(_Prop: Pk2CustomProperty; BitNum: Long): Boolean; far;
 begin
  Result := true;
  if (_Prop^ <> nil) then
  begin
   Assert(Prop[BitNum] <> nil);
   Tk2CustomProperty(Prop[BitNum]).EmptyMapping := _Prop^.EmptyMapping;
  end;//_Prop^ <> nil
 end;

var
 _IF : Tk2InterfaceFactory;
begin
 WrapperType := aType.WrapperType;
 _IF := aType.InterfaceFactory;
 if (_IF <> nil) then
  InterfaceFactory := _IF;
 aType.IteratePropertiesF(l3L2IA(@InheriteProperty));
 aType.IteratePropertiesF(l3L2IA(@InheriteMapping));
 AtomType := aType.AtomType;
 TypeTable := aType.TypeTable;
 ValueTable := aType.ValueTable;
 aType.f_ChildrenPath.SetRefTo(f_ChildrenPath);
 IDIndex := aType.IDIndex;
 ParamsForClone := aType.ParamsForClone;
 DisabledChildTypeIDs := aType.DisabledChildTypeIDs;
end;

{$IfDef nsTest}
 {.$Define k2OutTagStat}
{$EndIf nsTest}

{$IfDef k2OutTagStat}
var
 F : Tl3DOSFiler;

procedure FreeF;
begin
 F.Close;
 FreeAndNil(F);
end;
{$EndIf k2OutTagStat}

procedure Tk2Type.Recalc;
  {-}

var
 l_PL : Tk2PropSorter;

 function SortProperty(Prop: Pk2CustomProperty; Index: Long): Boolean; 
 begin
  Result := true;
  if (Prop^ <> nil) then
   l_PL.Add(Prop^);
 end;

var
 l_OrderKey : Tl3OrderKey;
const
 l_ReadOnlyKey : Tl3OrderKey = (Primary : cReadOnlyTagIndex; Delta : 0);

 function RecalcProperty(Prop: Pk2CustomProperty; Index: Long): Boolean; 
 begin//RecalcProperty
  Result := true;
  if Prop^.ReadOnly then
   Prop^.OrderKey := l_ReadOnlyKey
  else
  begin
   Prop^.OrderKey := l_OrderKey;
   Inc(l_OrderKey.Primary);
  end;//Prop^.ReadOnly 
 end;//RecalcProperty

{$IfDef k2OutTagStat}
var
 l_IS : Integer;
 l_AC : AnsiString;
{$EndIf k2OutTagStat}
var
 l_Index : Integer; 
begin
 {$IfDef k2OutTagStat}
 if (F = nil) then
 begin
  F := Tl3DOSFiler.Make('c:\1\types.csv', l3_fmWrite);
  l3System.AddExitProc(FreeF);
  F.Open;
 end;//F = nil
 {$EndIf k2OutTagStat}
 f_IsOrd := l3_bUnknown;
 for l_Index := Low(f_Cache) to High(f_Cache) do
  FreeAndNil(f_Cache[l_Index]);
 FreeAndNil(f_Cache1);
 //f_PropertyCount := -1;
 f_LastChildPath.rTypeID := -1;
(* f_LastProperty.rProp := nil;
 f_LastProperty.rID := -1;*)
 l_PL := Tk2PropSorter.Make;
 try
  l_PL.Duplicates := l3_dupAccept;
  { сортируем свойства по весам: }
  IteratePropertiesF(l3L2IA(@SortProperty));
  { выставляем свойствам новые веса: }
  l_PL.Sorted := true;
  l_OrderKey.SetNull;
  l_PL.IterateAllF(l3L2IA(@RecalcProperty));
 finally
  l3Free(l_PL);
 end;//try..finally
 if (f_ChildrenPath <> nil) then
  f_ChildrenPath.Sort;
 {$IfDef k2OutTagStat}
 l_IS := 0;
 l_AC := '';
 if (AtomType <> nil) AND (AtomClass <> nil) then
 begin
  l_IS := AtomClass.InstanceSize;
  l_AC := AtomClass.ClassName;
 end;//AtomClass <> nil
 F.WriteLn(AsString + ', ' + IntToStr(PropertyCount - ReadOnlyPropertyCount) + ', ' + l_AC + ', ' + IntToStr(l_IS));
 {$EndIf k2OutTagStat}
 {$IfOpt D+}
 if (AtomType <> nil) then
  if (AtomClass <> nil) then
   if //(AtomClass.InheritsFrom(Tk2SmallTagObject)) OR
      (AtomClass.InheritsFrom(Tk2TypedSmallLeafTag)) OR
      (AtomClass.Inheritsfrom(Tk2ParentedTypedSmallListTag)) OR
      (AtomClass.InheritsFrom(Tk2DictRec)) then
    Assert(PropertyCount - ReadOnlyPropertyCount <= 32,
           Format('Тип %s имеет больше свойств %d чем может (32) AtomClass = %s',
                  [Self.AsString,
                   PropertyCount - ReadOnlyPropertyCount,
                   AtomClass.ClassName
                   ]));
 {$EndIf}                
end;

function __CheckPropExists(P: Tk2CustomProperty): Boolean; 
begin
 if (P <> nil) then
  raise Ek2PropertyAlreadyDefined.CreateFmt(k2_errPropExists,
                                            [P.TagIndex,
                                             Tk2Type(P.ParentType).AsString,
                                             P.AsString]);
 {&Exception&}
end;

function Tk2Type.DefineProperty(aTagIndex       : Long;
                                aPropType       : Tk2Type;
                                const aUserName : AnsiString = ''): Tk2Property;
  {-}

begin
 Result := Tk2Property.Create(Self, aTagIndex, aPropType, aUserName);
 try
  __CheckPropExists(Tk2CustomProperty(f_Tags.Items[aTagIndex]));
  f_Tags.Items[aTagIndex] := Result;
 finally
  Result.Free;
 end;//try..except
end;

procedure Tk2Type.UndefineProperty(aTagIndex: Long);
  {-}
var
 l_Prop : Tk2CustomProperty;

 function ClearEmptyMapping(aProp: Pk2CustomProperty; Index: Long): Boolean; far;
 begin
  if (aProp^ <> l_Prop) then begin
   if (aProp^.EmptyMapping = aTagIndex) then
    aProp^.EmptyMapping := k2_tiMask;
  end;{aProp^ <> l_Prop}
  Result := (Tk2Property(l_Prop).f_MappingTarget > 0);
 end;

begin
 l_Prop := Tk2CustomProperty(Prop[aTagIndex]);
 if (l_Prop <> nil) then begin
  if (l_Prop Is Tk2Property) AND (Tk2Property(l_Prop).f_MappingTarget > 0) then
  begin
   IteratePropertiesF(l3L2IA(@ClearEmptyMapping));
  end;//(l_Prop Is Tk2Property) AND ..
  f_Tags.Items[aTagIndex] := nil;
 end;{l_Prop <> nil}
end;
  
procedure Tk2Type.UndefineProperties(const aTags: array of Long);
  {-}
var
 i : Long;  
begin
 for i := Low(aTags) to High(aTags) do
  UndefineProperty(aTags[i]);
end;

(*function __CheckChildrenExists(P: Pointer): Boolean; far;
begin
 Result := true;
 l3Free(P^);
end;*)

function Tk2Type.DefineChildren(aChildType: Tk2Type{; aListType : Tk2Type = nil}): Tk2ChildrenProperty;
  {-}
begin
 Result := nil;
 try
{  if (aListType = nil) then
   aListType := Self;}
  Result := Tk2ChildrenProperty.Create(Self, aChildType, Self{aListType}, 'Дочерние теги');
  f_Tags.Items[k2_tiChildren] := Result;
  Self.Recalc;
 finally
  Result.Free;
 end;//try..except
end;

procedure Tk2Type.DefineChildrenPath(aTagType: Tk2Type; const Path : array of Long);
  {-}
var
 CP : Tk2ChildrenPath;
begin
 if (f_ChildrenPath = nil) then
  f_ChildrenPath := Tk2ChildrenPathList.MakeSorted;
 CP := Tk2ChildrenPath.Create(aTagType.ID, l3LongArray(Path));
 try
  f_ChildrenPath.Add(CP);
 finally
  l3Free(CP);
 end;//try..finally
end;

function Tk2Type.FindChildPath(aTagType: Tk2TypePrim): TLongArray;
  {-}
var
 i  : Long;
 CP : Tk2ChildrenPathList;
begin
 if (f_LastChildPath.rTypeID = aTagType.ID) then
  Result := f_LastChildPath.rPath
 else
 begin
  CP := f_ChildrenPath;
  if CP.Empty then
   Result := nil
  else
  begin
   if CP.FindData(aTagType.ID, i) then
    Result := Tk2ChildrenPath(CP[i]).Path
   else
    Result := nil;
  end;//CP.Empty
  f_LastChildPath.rTypeID := aTagType.ID;
  f_LastChildPath.rPath := Result;
 end;//f_LastChildPath.rTypeID = aTagType.ID
end;

function Tk2Type.DoMakeTag(aRef: Integer): Il3TagRef;
  //virtual;
  {* - создает атом данного типа. }
begin
 Result := nil;
 Assert(false, 'Невозможно создать тег типа: ' + Self.AsString + ' враппером: ' + ClassName);
end;

function Tk2Type.DoDoMakeTag(aRef: Integer): Il3TagRef;
  {* - создает атом данного типа. }
begin
 if (aRef <> l3NilLong) then
 begin
  if (aRef = k2_TransparentValue) then
  begin
   Result := TransparentTag;
   Exit;
  end//aRef = k2_TransparentValue
  else
  if not IsOrd then
  begin
   if (ValueTable = nil) then
   begin
    {$IfNDef k2NoIntToTagCheck}
    l3System.Stack2Log('Попытка привести целое число к ' + Self.AsString);
    {$EndIf  k2NoIntToTagCheck}
    Result := k2NullTag.AsRef;
   end//ValueTable = nil
   else
   begin
    Assert(ValueTable <> nil);
    Result := ValueTable.DRbyID[aRef].AsRef;
   end;//ValueTable = nil 
   Exit;
  end;//not IsOrd
 end;//aRef <> l3NilLong
 Assert((aRef = l3NilLong) OR Self.IsOrd);
 Result := DoMakeTag(aRef);
 Assert(Result <> nil);
end;

procedure Tk2Type.AddValue(aValue: Tl3Variant);
var
 l_VT : Tk2DictionaryEx;
begin
 if (ValueTable = nil) then
 begin
  l_VT := Tk2DictionaryEx.Create(Self);
  try
   ValueTable := l_VT;
  finally
   l3Free(l_VT);
  end;//try..finally
 end;//ValueTable = nil
 ValueTable.Add(aValue);
end;

function Tk2Type.StrToTag(const aValue : AnsiString): Tl3Tag;
  {-}
begin
 if (f_Wrapper = nil) then
 begin
  Assert(false);
  Result := nil;
 end//f_Wrapper = nil
 else
  Result := f_Wrapper.StrToTag(aValue);
end;

function Tk2Type.ObjToTag(aValue: TObject): Il3TagRef;
  {-}
begin
 Result := f_Wrapper.ObjToTag(aValue);
end;

function Tk2Type.MakeFromInt(aRef : Integer; anImplementator: Rk2AtomicTag): Tk2NotStructuredTag;
  {-}
const
 cLimit = 5000;  
var  
 l_Len : Integer;
 l_Atomic : Tk2TypedAtomicTag;
 l_Index : Integer;
begin
 Assert(IsOrd);
 Assert(anImplementator <> nil);
 Assert(anImplementator.InheritsFrom(Tk2TypedAtomicTag));
 if (aRef = k2_TransparentValue) then
 begin
  Result := TransparentTag;
  Exit;
 end;//aRef = k2_TransparentValue
 l3System.EnterGlobalCS;
 try
  if (aRef >= 0) AND (aRef <= 1024) then
  begin
   l_Len := Length(f_Cache);
   if (aRef >= l_Len) then
   begin
    SetLength(f_Cache, Succ(aRef));
    l_Atomic := Rk2TypedAtomicTag(anImplementator).Create(aRef, Self);
    //try
     f_Cache[aRef] := l_Atomic{.Use};
     Result := l_Atomic;
     Exit;
    //finally
    // FreeAndNil(l_Atomic);
    //end;//try..finally
   end//aRef >= l_Len
   else
   if (f_Cache[aRef] = nil) then
   begin
    l_Atomic := Rk2TypedAtomicTag(anImplementator).Create(aRef, Self);
    //try
     f_Cache[aRef] := l_Atomic{.Use};
     Result := l_Atomic;
     Exit;
    //finally
    // FreeAndNil(l_Atomic);
    //end;//try..finally
   end;//f_Cache[aRef] = nil
   Result := f_Cache[aRef];
   Exit;
  end;//(aRef >= 0) AND (aRef <= 1024)
  Result := nil;
  if (f_Cache1 <> nil) then
  begin
   if f_Cache1.FindData(aRef, l_Index) then
   begin
    Result := f_Cache1.Items[l_Index];
    Exit;
   end;//f_Cache1.FindData(aRef, l_Index)
  end;//f_Cache1 <> nil
  if (f_Cache1 = nil) then
  begin
   f_Cache1 := Tk2AtomicTagRefList.Create;
   f_Cache1.Sorted := true;
   f_Cache1.Duplicates := l3_dupError;
  end//f_Cache1 = nil
  else
  if (f_Cache1.Count > cLimit) then
  begin
   if f_RemoveCacheObjectsAtStart then
   begin
    while (f_Cache1.Count > cLimit div 2) do
     f_Cache1.Delete(0);
   end//f_RemoveCacheObjectsAtStart
   else
    f_Cache1.Count := f_Cache1.Count div 2;
   // - т.к. кеш всё равно сортированный, то глупо удалять объекты в начале
   f_RemoveCacheObjectsAtStart := not f_RemoveCacheObjectsAtStart;
  end;//f_Cache1.Count > cLimit
  l_Atomic := Rk2TypedAtomicTag(anImplementator).Create(aRef, Self);
  try
   f_Cache1.Add(l_Atomic);
   Result := l_Atomic;
   Exit;
  finally
   FreeAndNil(l_Atomic);
  end;//try..finally

  Assert(false, 'По идее все атомарные теги должны кешироваться');
  Result := nil;
 finally
  l3System.LeaveGlobalCS;
 end;//try..finally
end;

function Tk2Type.TransparentTag: Tk2NotStructuredTag;
  {-}
begin
 if (f_TransparentTag = nil) then
  f_TransparentTag := Tk2TransparentTag.Create(Self);
 Result := f_TransparentTag;
end;

function Tk2Type.IsAuto: Boolean;
  {-}
begin
 Result := false;
end;

// start class Tk2AutoType

function Tk2AutoType.IsAuto: Boolean;
  {-}
begin
 Result := true;
end;

// start class Tk2TypeTable

type
 Rk2TypeTable = class of Tk2TypeTable;
var
 g_StandardTypeTableClass : Rk2TypeTable = nil;
 g_StandardTypeTable : Tk2TypeTable = nil;

procedure _FreeSchema;
begin
 FreeAndNil(g_StandardTypeTable);
end;

class procedure Tk2TypeTable.AddCreatedListener(aListener: TNotifyEvent);
begin
 if (g_StandardTypeTable = nil) then
  inherited
 else
  aListener(g_StandardTypeTable); 
end;

procedure Tk2TypeTable.InitFields;
begin
 inherited;
 Tk2TypeTableCreatedListeners.Instance.NotifyListeners(Self);
end;

constructor Tk2TypeTable.Create;
  //virtual;
  {-}
begin
 f_MaxTypeID := 0;
 inherited Create;
 if g_StandardTypeTable <> nil then
 begin
  l3System.Stack2Log(Format('Пока не можем определять больше, чем одну EVD-схему (%s => %s)', [ClassName, g_StandardTypeTable.ClassName]));
  Assert(False, 'Пока не можем определять больше, чем одну EVD-схему');
 end;
 //Tl3String.Create.Free;
 // - hack - для того чтобы кеш объектов добавился раньше, чем таблица типов
 g_StandardTypeTable := Self.Use;
 l3System.AddExitProc(_FreeSchema);
end;

class procedure Tk2TypeTable.CheckAndCleanupReferences;
  {-}
begin
 if g_StandardTypeTable <> nil then
  k2.SignalEvent(g_StandardTypeTable, k2_eidTypeTableWillBeDestroyed);
end;

class function Tk2TypeTable.GetInstance: Tk2TypeTable;
  {-}
begin
 if (g_StandardTypeTable = nil) then
 begin
  if (g_StandardTypeTableClass = nil) then
   raise Ek2Error.Create('Не определена EVD-схема');
  with l3System do
  begin
   EnterGlobalCS;
   try
    Result := g_StandardTypeTableClass.Create.Free;
   finally
    LeaveGlobalCS;
   end;//try..finally
  end;//with l3System
 end//g_StandardTypeTable = nil
 else
  Result := g_StandardTypeTable;
end;

class procedure Tk2TypeTable.SetAsDefault;
  {-}
begin
 Assert(g_StandardTypeTable = nil, 'Нельзя переопределять тип уже созданной таблицы стилей');
 if (g_StandardTypeTableClass <> nil) then
 begin
  if not Self.Inheritsfrom(g_StandardTypeTableClass) then
   if g_StandardTypeTableClass.InheritsFrom(Self) then
    Exit
   else 
    raise Ek2Error.Create('Тип схемы ' + Self.ClassName + ' не совместим с ' + g_StandardTypeTableClass.ClassName);
 end;//g_StandardTypeTableClass <> nil
 g_StandardTypeTableClass := Self;
end;  

procedure Tk2TypeTable.BeforeRelease;
  //override;
begin
 k2.SignalEvent(Self, k2_eidTypeTableWillBeDestroyed);
 inherited;
end;

procedure Tk2TypeTable.Cleanup;
  //override;
  {-}
begin
 FreeAndNil(f_TypesByHandle);
 inherited;
end;

var
 //g_InnerTypeID : Integer = Ord(High(Tk2TypeID)) + 1;
 g_InnerTypeID : Integer = 150;
 {* Идентификатор следующео определяемого внутреннего типа. }

function Tk2TypeTable.DefineAutoType(const aTagParents : array of Tk2Type;
                                     const anUserName  : AnsiString;
                                     aTypeRef          : Rk2AutoType): Tk2Type;
  {-}
begin
 Result := DefineType(g_InnerTypeID, aTagParents, anUserName, aTypeRef);
 Inc(g_InnerTypeID);
end;

function Tk2TypeTable.DefineType(anID              : Long;
                                 const aTagParents : array of Tk2Type;
                                 const anUserName  : AnsiString;
                                 aTypeRef          : Rk2Type): Tk2Type;
  {-}
var
 l_T0 : Tk2Type;
 l_T1 : Tk2Type;
 AT   : Tk2Type;
 i    : Long;
begin
 if (f_MaxTypeID < anID) then
  f_MaxTypeID := anID;
 Case Length(aTagParents) of
  0:
  begin
   if (aTypeRef = nil) then
   begin
    Assert(false);
    l_T0 := Tk2Type.Create(Self, anUserName);
   end//aTypeRef = nil
   else
    l_T0 := aTypeRef.Create(Self, anUserName);
   try
    l_T0.TypeTable := Self;
    l_T0.IDw := anID;
    Result := l_T0;
   except
    l3Free(l_T0);
    raise;
   end;//try..except
  end;//0
  1:
  begin
   if (aTypeRef = nil) then
   begin
    l_T1 := nil;
    Assert(false);
   end//aTypeRef = nil
   else
   begin
    l_T1 := aTypeRef.Create(Self, anUserName);
   end;//aTypeRef = nil
   try
    l_T1.IDw := anID;
    l_T1.InheriteFrom(aTagParents[0]);
    Result := l_T1;
   except
    l3Free(l_T1);
    raise;
   end;//try..except
  end;//1
  else
  begin
   if (aTypeRef = nil) then
   begin
    AT := nil;
    Assert(false);
   end//aTypeRef = nil
   else
   begin
    AT := aTypeRef.Create(Self, anUserName);
   end;//aTypeRef = nil
   try
    AT.IDw := anID;
    for i := High(aTagParents) downto Low(aTagParents) do
     AT.InheriteFrom(aTagParents[i]);
    Result := AT;
   except
    l3Free(AT);
    raise;
   end;//try..except
  end;//else
 end;//Case Length(aTagParents)
 if (f_TypesByHandle = nil) then
  f_TypesByHandle := Tk2TypesByHandleList.Create;
 Assert(Tk2TypesByHandleList(f_TypesByHandle).Items[Result.ID] = nil); 
 Tk2TypesByHandleList(f_TypesByHandle).Items[Result.ID] := Result;
end;

function Tk2TypeTable.pm_GetMaxTypeID : Integer;
  {-}
begin
 Result := Max(g_InnerTypeID - 1, f_MaxTypeID);
end;

function Tk2TypeTable.pm_GetTypeByName(const aName: AnsiString): Tk2Type;
  {-}
var
 l_Index : Integer;
 l_Type : Tk2Type;  
begin
 Result := nil;
 for l_Index := 0 to Self.MaxTypeID do
 begin
  l_Type := TypeByHandle[l_Index];
  if (l_Type <> nil) then
   if l3Same(l_Type.AsWStr, aName, true) then
   begin
    Result := l_Type;
    Exit;
   end;//l3Same(l_Type, aName, true)
 end;//for l_Index
 if (Result = nil) then
  if (aName = 'TableColumn') then
   Result := Self.TypeByHandle[27{k2_idTableCell}];
end;

function Tk2TypeTable.pm_GetTypeByHandle(anID: Integer): Tk2Type;
  {-}
begin
 Assert(f_TypesByHandle <> nil);
 Result := Tk2TypesByHandleList(f_TypesByHandle).Items[anID];
 Assert((Result = nil) OR (Result.ID = anID));
end;

initialization
 k2TypeBuffers := l3NewMemoryChain(Succ(Ord(High(Tk2TagID))) shl 2);

end.

