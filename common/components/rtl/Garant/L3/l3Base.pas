unit l3Base;
{* Базовые объекты библиотеки L3. Часть их реализации присутствует в модуле l3List. }

{ Библиотека "L3 (Low Level Library)" }
{ Автор: Люлин А.В. ©                 }
{ Модуль: l3Base -                    }
{ Начат: 12.04.1998 16:28             }
{ $Id: l3Base.pas,v 1.583 2015/10/01 12:55:36 lukyanets Exp $ }

// $Log: l3Base.pas,v $
// Revision 1.583  2015/10/01 12:55:36  lukyanets
// Разделяем логи
//
// Revision 1.582  2015/09/24 07:01:05  lukyanets
// Не собиралось
//
// Revision 1.581  2015/09/23 16:53:17  lulin
// - оптимизируем.
//
// Revision 1.580  2015/09/14 04:59:40  fireton
// - форматирование
//
// Revision 1.579  2015/08/28 13:52:09  lulin
// - пытаемся вырезать VCL.
//
// Revision 1.578  2015/06/11 07:24:30  lulin
// - причёсываем код.
//
// Revision 1.577  2015/06/01 13:40:26  lulin
// - регистрируем слова для строк в другом месте.
//
// Revision 1.576  2015/03/11 09:21:20  lukyanets
// Если диалог об утечках отключен - выводим диагностику в лог.
//
// Revision 1.575  2015/03/10 13:33:51  lukyanets
// Если диалог об утечках отключен - выводим диагностику в лог.
//
// Revision 1.574  2015/01/20 17:54:10  lulin
// http://mdp.garant.ru/pages/viewpage.action?pageId=586352031&focusedCommentId=586679370#comment-586679370
//
// Revision 1.573  2015/01/16 15:51:51  lulin
// - рисуем на модели.
//
// Revision 1.572  2015/01/16 13:53:35  lulin
// - рисуем на модели.
//
// Revision 1.571  2015/01/15 17:00:51  lulin
// - боремся с Integer Overflow.
//
// Revision 1.570  2015/01/15 15:52:56  lulin
// {RequestLink:585926571}. Используем Interlocked.
//
// Revision 1.569  2015/01/15 13:50:25  lulin
// {RequestLink:585926571}. Используем Interlocked.
//
// Revision 1.568  2015/01/15 11:57:55  lulin
// - диагностика.
//
// Revision 1.567  2015/01/14 17:58:05  lulin
// - рисуем на модели.
//
// Revision 1.566  2014/11/07 17:08:56  lulin
// {RequestLink:571638581}.
//
// Revision 1.565  2014/11/07 16:38:36  lulin
// {RequestLink:571638581}.
//
// Revision 1.564  2014/11/07 15:01:19  lulin
// {RequestLink:571638581}.
//
// Revision 1.562  2014/11/07 13:56:02  lulin
// {RequestLink:571638581}.
//
// Revision 1.561  2014/11/06 14:52:02  lukyanets
// Боремся с обрывами связи.
//
// Revision 1.560  2014/11/06 11:53:37  lulin
// - перетряхиваем код.
//
// Revision 1.559  2014/10/29 14:44:05  lukyanets
// Заготавливаем посылающий поток
//
// Revision 1.558  2014/09/09 10:39:07  lulin
// - более по-человечески называем класс.
//
// Revision 1.557  2014/09/04 12:50:50  dinishev
// {Requestlink:564733710}. Еще не все символы перебрали...
//
// Revision 1.556  2014/08/20 11:42:01  lulin
// - боремся с кривым AppTitle.
//
// Revision 1.555  2014/08/06 13:18:03  lukyanets
// {Requestlink:556143119}. Меняем в логе имя станции
//
// Revision 1.554  2014/07/17 12:33:08  lukyanets
// {Requestlink:555415882}. Вытащил наружу флажок о завершении исполнения
//
// Revision 1.553  2014/07/16 15:56:57  lulin
// - чистим код и упрощаем наследование.
//
// Revision 1.552  2014/06/23 13:55:57  lulin
// - защищаем счётчик ресурсов критической секцией.
//
// Revision 1.551  2014/06/20 14:10:42  lulin
// - пытаемся найти ошибку при выходе из парня.
//
// Revision 1.550  2014/06/16 12:41:03  lulin
// - стабилизируем пути.
//
// Revision 1.549  2014/06/10 17:56:55  lulin
// - стараемся не падать во время вывода статистики.
//
// Revision 1.548  2014/05/26 05:42:25  kostitsin
// no message
//
// Revision 1.547  2014/05/23 14:46:36  lulin
// {RequestLink:537249703}
//
// Revision 1.546  2014/05/23 14:39:16  lulin
// {RequestLink:537249703}
//
// Revision 1.545  2014/05/12 16:06:18  lulin
// - чистим код.
//
// Revision 1.544  2014/05/12 15:34:21  lulin
// - чистим код.
//
// Revision 1.543  2014/05/12 14:56:49  lulin
// - чистим код.
//
// Revision 1.542  2014/03/07 17:09:24  lulin
// - перетряхиваем списки тегов.
//
// Revision 1.541  2014/02/17 16:26:02  lulin
// - избавляемся от ошибок молодости.
//
// Revision 1.540  2014/02/13 12:35:07  lulin
// - рефакторим безликие списки.
//
// Revision 1.539  2014/02/13 10:12:59  lulin
// - рефакторим безликие списки.
//
// Revision 1.538  2013/12/25 15:10:35  lulin
// {RequestLink:509706011}
// - перетрясаем модель.
//
// Revision 1.537  2013/07/10 16:29:35  lulin
// - чистим код.
//
// Revision 1.536  2013/07/10 15:06:08  lulin
// - рисуем на модели работу с памятью.
//
// Revision 1.535  2013/07/08 17:13:25  lulin
// - выделяем работу с размером куска памяти.
//
// Revision 1.534  2013/07/08 16:43:15  lulin
// - выделяем работу с размером куска памяти.
//
// Revision 1.533  2013/07/01 05:42:46  lulin
// - подтачиваем под XE.
//
// Revision 1.532  2013/04/19 13:08:17  lulin
// - портируем.
//
// Revision 1.531  2013/04/15 13:54:54  lulin
// - правим последствия портирования.
//
// Revision 1.530  2013/04/12 16:25:07  lulin
// - отлаживаем под XE3.
//
// Revision 1.529  2013/04/09 17:40:34  lulin
// - пытаемся отладиться под XE.
//
// Revision 1.528  2013/04/08 10:16:44  lulin
// - портируем.
//
// Revision 1.527  2013/04/04 11:22:01  lulin
// - портируем.
//
// Revision 1.526  2013/04/03 15:28:56  lulin
// - портируем.
//
// Revision 1.525  2013/04/03 15:03:20  lulin
// - портируем.
//
// Revision 1.524  2013/03/28 15:09:44  lulin
// - портируем.
//
// Revision 1.523  2013/03/28 14:03:17  lulin
// - портируем.
//
// Revision 1.522  2013/01/30 11:52:00  narry
// исправление непрошедших тестов Арчи
//
// Revision 1.521  2012/11/01 09:42:57  lulin
// - забыл точку с запятой.
//
// Revision 1.520  2012/11/01 07:45:08  lulin
// - делаем возможность логирования процесса загрузки модулей.
//
// Revision 1.519  2012/11/01 07:09:29  lulin
// - вычищаем мусор.
//
// Revision 1.518  2012/10/26 19:42:23  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.517  2012/03/12 05:49:09  lulin
// - выделяем четырёхбайтные строки отдельно и перегенерируем эталоны.
//
// Revision 1.516  2012/03/11 15:34:19  lulin
// [$344136994].
// - пробуем побороться с утечкой и заодним пытаемся немножкл пооптимизировать.
//
// Revision 1.515  2012/02/23 20:17:33  lulin
// - немножко оптимизируем.
//
// Revision 1.514  2012/02/23 18:55:24  lulin
// - немножко оптимизируем.
//
// Revision 1.513  2012/02/23 14:38:21  lulin
// - немножко оптимизируем.
//
// Revision 1.512  2011/11/08 10:33:55  lulin
// {RequestLink:272666699}
// - улучшаем код.
//
// Revision 1.511  2011/10/14 13:54:15  lulin
// {RequestLink:293280527}.
//
// Revision 1.510  2011/10/05 09:48:43  voba
// - k : 281525254 Борьба с утечками
//
// Revision 1.509  2011/09/15 12:41:16  voba
// - подзаточил procedure Tl3System.MemUsage2Log;
//
// Revision 1.508  2011/07/11 17:48:13  lulin
// {RequestLink:228688745}.
//
// Revision 1.507  2011/07/06 14:11:05  lulin
// {RequestLink:254944102}.
//
// Revision 1.506  2011/06/29 13:31:57  lulin
// {RequestLink:254944102}.
//
// Revision 1.505  2011/05/23 15:33:33  lulin
// {RequestLink:266423791}.
//
// Revision 1.504  2011/05/19 12:24:21  lulin
// {RequestLink:266409354}.
//
// Revision 1.503  2011/05/19 10:36:07  lulin
// {RequestLink:266409354}.
//
// Revision 1.502  2011/05/18 17:46:00  lulin
// {RequestLink:266409354}.
//
// Revision 1.501  2011/05/18 12:09:16  lulin
// {RequestLink:266409354}.
//
// Revision 1.500  2011/01/13 15:53:15  lulin
// {RequestLink:248195582}.
// - подготавливаем инфраструктуру для синхронизации списка закладок.
//
// Revision 1.499  2010/12/08 19:04:29  lulin
// {RequestLink:228688602}.
// - закругляем край у строки ввода.
//
// Revision 1.498  2010/11/30 11:47:14  lulin
// {RequestLink:228688602}.
// - борьба с предупреждениями.
//
// Revision 1.497  2010/11/16 06:48:56  voba
// - не компилировалось
//
// Revision 1.496  2010/09/21 09:47:15  oman
// - fix: {RequestLink:235049691}
//
// Revision 1.495  2010/09/13 14:43:41  dinishev
// Переименовал метод, сделанный для тестов.
//
// Revision 1.494  2010/09/13 14:00:09  dinishev
// Более корректно избавляемся от утечек.
//
// Revision 1.493  2010/06/18 13:08:53  lulin
// {RequestLink:216530971}.
//
// Revision 1.492  2010/05/26 14:32:07  lulin
// {RequestLink:216072357}.
// - теперь падение при отрисовке неправильного документа считается положительным результатом теста.
//
// Revision 1.491  2010/04/30 06:15:46  oman
// Забыли директиву.
//
// Revision 1.490  2010/04/29 07:34:49  fireton
// - MemUsage2Log
//
// Revision 1.489  2010/02/26 18:55:26  lulin
// {RequestLink:190677208}.
// - списки "записей для Вована" выделены в отдельный модуль.
//
// Revision 1.488  2010/01/26 15:33:42  lulin
// - пытаемся писать максимум ошибок в лог.
//
// Revision 1.487  2010/01/20 19:10:32  lulin
// {RequestLink:139430176}. Выводим статистику использования памяти стандартными библиотеками.
//
// Revision 1.486  2010/01/20 18:54:39  lulin
// {RequestLink:139430176}. Выводим статистику использования памяти.
//
// Revision 1.485  2010/01/19 17:49:31  lulin
// {RequestLink:139430176}. Выводим ошибки в лог и выводим этот лог на страницу с результатами тестов.
//
// Revision 1.484  2009/12/16 17:22:36  lulin
// - опубликован метод проверки MMX.
//
// Revision 1.483  2009/12/16 13:41:42  lulin
// {RequestLink:174293583}.
//
// Revision 1.482  2009/09/02 13:05:04  oman
// - new: Зачистка - {RequestLink:159369920}
//
// Revision 1.481  2009/08/27 12:20:12  lulin
// {RequestLink:159355445}.
//
// Revision 1.480  2009/07/21 15:10:18  lulin
// - bug fix: не собирался и не работал Архивариус в ветке.
//
// Revision 1.479  2009/07/21 13:03:52  lulin
// - более правильно приводим к константным строкам.
//
// Revision 1.478  2009/07/21 12:43:10  lulin
// - убираем ненужные приведения типов.
//
// Revision 1.477  2009/07/21 10:13:22  lulin
// - bug fix: падали на классах без поддержки IUnknown.
//
// Revision 1.476  2009/07/20 12:49:42  lulin
// - подготавливаемся к переносу изменений в ветку.
//
// Revision 1.475  2009/07/20 11:22:19  lulin
// - заставляем работать F1 после - {RequestLink:141264340}. №7, 32, 33.
//
// Revision 1.474  2009/04/22 14:39:57  voba
// - cc
//
// Revision 1.473  2009/02/26 17:28:44  lulin
// - <K>: 137465982. №20.
//
// Revision 1.472  2009/02/26 08:25:36  lulin
// - чистка кода.
//
// Revision 1.471  2009/02/25 12:04:16  lulin
// - <K>: 90441983. Чистка кода для переноса на модель.
//
// Revision 1.470  2008/12/15 16:06:19  lulin
// - <K>: 131137753.
//
// Revision 1.469  2008/12/12 19:19:30  lulin
// - <K>: 129762414.
//
// Revision 1.468  2008/10/09 10:49:40  lulin
// - <K>: 121145106.
//
// Revision 1.467  2008/06/27 21:50:48  lulin
// - добавлена функция прибавляющая к массиву число.
//
// Revision 1.466  2008/06/06 06:53:29  lulin
// - собираем без SSE.
//
// Revision 1.465  2008/05/14 11:20:20  narry
// - уровень логгирования сообщений
//
// Revision 1.464  2008/03/20 10:59:48  lulin
// - cleanup.
//
// Revision 1.463  2008/03/20 09:48:40  lulin
// - cleanup.
//
// Revision 1.462  2008/03/11 11:29:13  lulin
// - <K>: 85721297.
//
// Revision 1.461  2008/03/11 08:51:22  lulin
// - <K>: 85721144.
//
// Revision 1.460  2008/02/21 18:13:28  lulin
// - избавляемся от ненужных типов.
//
// Revision 1.459  2008/02/21 16:04:30  lulin
// - упрощаем наследование.
//
// Revision 1.458  2008/02/21 13:21:25  lulin
// - упрощаем наследование.
//
// Revision 1.457  2008/02/21 10:55:15  lulin
// - упрощаем наследование.
//
// Revision 1.456  2008/02/20 17:23:09  lulin
// - упрощаем строки.
//
// Revision 1.455  2008/02/20 14:06:41  lulin
// - удалены избыточные операции сравнения.
//
// Revision 1.454  2008/02/19 20:32:17  lulin
// - добавлен список процедур.
//
// Revision 1.453  2008/02/19 18:48:21  lulin
// - удалены ненужные классы.
//
// Revision 1.452  2008/02/19 14:58:58  lulin
// - переводим сортировку списков на новые, менее виртуальные, рельсы.
//
// Revision 1.451  2008/02/14 18:57:08  lulin
// - выпилил часть виртуальной функциональности списков.
//
// Revision 1.450  2008/02/14 17:09:14  lulin
// - cleanup.
//
// Revision 1.449  2008/02/14 11:38:40  lulin
// - <K>: 84312124.  TDN 74 Убрать нетипизированность GlobalObject.
//
// Revision 1.448  2008/02/13 16:03:13  lulin
// - убраны излишне гибкие методы поиска.
//
// Revision 1.447  2008/02/12 14:39:42  lulin
// - методы для чтения списка переехали на примесь.
//
// Revision 1.446  2008/02/12 10:31:25  lulin
// - избавляемся от излишнего метода на базовом классе.
//
// Revision 1.445  2008/02/11 18:30:45  lulin
// - чистим ненужный код.
//
// Revision 1.444  2008/02/11 11:13:58  lulin
// - чистка списков.
//
// Revision 1.443  2008/02/08 19:52:45  lulin
// - продолжаем санацию списков.
//
// Revision 1.442  2008/02/07 19:13:17  lulin
// - избавляемся от излишне универсальных методов базовых списков.
//
// Revision 1.441  2008/02/07 16:19:23  lulin
// - наводим порядок с наследованием и перекрытием методов.
//
// Revision 1.440  2008/02/07 15:41:28  lulin
// - базовый класс списков переехал в отдельный модуль.
//
// Revision 1.439  2008/02/07 14:44:45  lulin
// - класс _Tl3LongintList переехал в собственный модуль.
//
// Revision 1.438  2008/02/07 09:33:00  lulin
// - подготавливаемся к переносу списка целых на модель.
//
// Revision 1.437  2008/02/07 08:37:59  lulin
// - каждому базовому объекту по собственному модулю.
//
// Revision 1.436  2008/02/06 15:37:10  lulin
// - каждому базовому объекту по собственному модулю.
//
// Revision 1.435  2008/02/06 13:28:19  lulin
// - каждому базовому объекту по собственному модулю.
//
// Revision 1.434  2008/02/06 12:32:23  lulin
// - базовый список ссылок на объекты переехал в отдельный файл.
//
// Revision 1.433  2008/02/06 11:44:42  lulin
// - список строк переехал в отдельный файл.
//
// Revision 1.432  2008/02/06 09:55:31  lulin
// - глобальные объекты сделаны индексированным свойством.
//
// Revision 1.431  2008/02/06 09:30:56  lulin
// - базовые списки объектов выделяем в отдельные файлы.
//
// Revision 1.430  2008/02/05 18:55:11  lulin
// - запрещаем напрямую устанавливать буфер строке.
//
// Revision 1.429  2008/02/05 18:20:42  lulin
// - удалено ненужное свойство строк.
//
// Revision 1.428  2008/02/05 17:39:39  lulin
// - избавляемся от ненужного именованного объекта.
//
// Revision 1.427  2008/02/05 16:13:18  lulin
// - избавляем базовый объект от лишнего свойства.
//
// Revision 1.426  2008/02/05 15:25:21  lulin
// - переносим на модель самые базовые объекты.
//
// Revision 1.425  2008/02/05 13:09:16  lulin
// - базовая строка переехала в отжельный файл.
//
// Revision 1.424  2008/02/05 12:49:26  lulin
// - упрощаем базовые объекты.
//
// Revision 1.423  2008/02/05 09:58:12  lulin
// - выделяем базовые объекты в отдельные файлы и переносим их на модель.
//
// Revision 1.422  2008/02/04 13:30:24  lulin
// - базовые списки выделены в отдельные файлы.
//
// Revision 1.421  2008/02/04 11:56:19  lulin
// - bug fix: падали при открытии документа в Архивариусе.
//
// Revision 1.420  2008/02/04 08:51:37  lulin
// - класс _Tl3InterfaceList выделен в отдельный модуль.
//
// Revision 1.419  2008/02/01 15:14:54  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.418  2008/01/31 20:38:13  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.417  2008/01/31 20:10:00  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.416  2008/01/31 18:53:43  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.415  2008/01/31 16:15:55  lulin
// - cleanup.
//
// Revision 1.414  2008/01/31 12:35:54  lulin
// - используем параметризацию примесей.
//
// Revision 1.413  2008/01/30 19:34:47  lulin
// - рефакторинг с думами о шаблонах.
//
// Revision 1.412  2008/01/29 13:34:51  lulin
// - подгоняем под модель.
//
// Revision 1.411  2008/01/18 13:26:16  lulin
// - <TDN>: 16.
//
// Revision 1.410  2008/01/18 12:42:52  lulin
// - <TDN>: 14.
//
// Revision 1.409  2008/01/17 20:08:35  lulin
// - <TDN>: 8.
//
// Revision 1.408  2008/01/17 19:18:46  lulin
// - cleanup.
//
// Revision 1.407  2007/12/24 15:25:32  lulin
// - удалены ненужные файлы.
//
// Revision 1.406  2007/12/24 13:25:48  lulin
// - модуль l3InternalInterfaces полностью перенесен на модель.
//
// Revision 1.405  2007/12/24 08:15:12  lulin
// - удален ненужный интерфейс.
//
// Revision 1.404  2007/10/04 14:30:18  lulin
// - сделана передача строкового параметра.
//
// Revision 1.403  2007/09/07 15:27:41  lulin
// - сделана возможность удаления элементов без проверки индексов.
//
// Revision 1.402  2007/09/06 16:24:58  lulin
// - оптимизируем добавление объектов в кеш.
//
// Revision 1.401  2007/09/06 15:23:55  lulin
// - специализируем списки кешей.
//
// Revision 1.400  2007/09/06 12:13:24  voba
// - bug fix от Шуры
//
// Revision 1.399  2007/09/06 11:12:02  lulin
// - сделана возможность выключать использование MMX.
//
// Revision 1.398  2007/09/05 12:28:28  lulin
// - директивы перенесены в файл с директивами.
//
// Revision 1.397  2007/09/05 09:33:06  lulin
// - убран лишний параметр.
//
// Revision 1.396  2007/09/04 18:41:34  lulin
// - убран ненужный параметр.
//
// Revision 1.395  2007/09/04 16:20:56  lulin
// - убран ненужный параметр.
//
// Revision 1.394  2007/09/04 14:08:46  lulin
// - заполняем большими блоками.
//
// Revision 1.393  2007/09/04 13:24:26  voba
// - выключил l3UseSSE
//
// Revision 1.392  2007/09/04 11:29:52  lulin
// - добавлена проверка поддержки необходимого набора инструкций.
//
// Revision 1.391  2007/08/31 18:59:29  lulin
// - bug fix: падало сравнение строк.
//
// Revision 1.390  2007/08/31 15:18:34  lulin
// - оптимизируем списки.
//
// Revision 1.389  2007/08/31 14:38:01  lulin
// - избавляем обобщенный список от излишних функций, присущих только спискам строк.
//
// Revision 1.388  2007/08/31 11:37:16  lulin
// - удалена ненужная универсальная функциональность.
//
// Revision 1.387  2007/08/30 19:24:50  lulin
// - с обобщенного списка удалены излишние методы вставки и добавления, присущие только спискам целых чисел.
//
// Revision 1.386  2007/08/30 19:06:19  lulin
// - с обобщенного списка удалены излишние методы вставки и добавления, присущие только спискам строк.
//
// Revision 1.385  2007/08/30 18:48:38  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.384  2007/08/30 18:05:07  lulin
// - избавляемся от лишнего кода по очистке строк.
//
// Revision 1.383  2007/08/30 14:35:59  lulin
// - вычисляем размер элемента только перед началом итератора.
//
// Revision 1.382  2007/08/29 15:54:32  lulin
// - заменяем _Case полиморфизмом.
//
// Revision 1.381  2007/08/28 18:45:53  lulin
// - уменьшаем число передаваемых параметров - чтобы влезали в регистры.
//
// Revision 1.380  2007/08/27 18:36:37  lulin
// - уменьшаем количество проверок источника и приемника.
//
// Revision 1.379  2007/08/27 18:15:52  lulin
// - блоки длиной 36 двигаем отдельно.
//
// Revision 1.378  2007/08/27 18:03:24  lulin
// - блоки длиной 30 двигаем отдельно.
//
// Revision 1.377  2007/08/27 17:57:01  lulin
// - блоки длиной 24 и 26 двигаем отдельно.
//
// Revision 1.376  2007/08/27 17:33:47  lulin
// - блоки длиной 21 и 22 двигаем отдельно.
//
// Revision 1.375  2007/08/24 20:12:44  lulin
// - bug fix: не выключали режим MMX - в итоге падали на плавающих операциях, в частности со временем.
//
// Revision 1.374  2007/08/24 19:45:53  lulin
// - используем таблицу переходов, если это возможно.
//
// Revision 1.373  2007/08/24 19:40:39  lulin
// - если возможно - двигаем сразу по 16 байт.
//
// Revision 1.372  2007/08/24 19:33:34  lulin
// - отдельно перемещаем память в 19 байт.
//
// Revision 1.371  2007/08/24 19:15:26  lulin
// - используем SSE.
//
// Revision 1.370  2007/08/24 18:50:11  lulin
// - отдельно перемещаем память в 17 байт.
//
// Revision 1.369  2007/08/24 18:44:04  lulin
// - отдельно перемещаем память в 15 байт.
//
// Revision 1.368  2007/08/24 18:27:35  lulin
// - пытался убрать loop. Закомментировал, т.к. непонятно - стоит ли - надо искать литературу. В примерах почему=то его избегают. Почему - не нашел.
//
// Revision 1.367  2007/08/24 18:16:13  lulin
// - используем SSE.
//
// Revision 1.366  2007/08/24 17:18:41  lulin
// - избавляемся от использования стека.
//
// Revision 1.365  2007/08/24 17:07:42  lulin
// - используем блоки в 24 байта - там где возможно.
//
// Revision 1.364  2007/08/24 17:05:16  lulin
// - отдельно перемещаем память в 13 байт.
//
// Revision 1.363  2007/08/24 16:55:29  lulin
// - отдельно перемещаем память в 11 байт.
//
// Revision 1.362  2007/08/24 16:49:24  lulin
// - для 7-к обходимся без анализа направления.
//
// Revision 1.361  2007/08/24 16:41:53  lulin
// - для 6-к обходимся без анализа направления.
//
// Revision 1.360  2007/08/24 16:35:48  lulin
// - для 5-к обходимся без анализа направления.
//
// Revision 1.359  2007/08/24 16:33:44  lulin
// - для 3-к обходимся без анализа направления.
//
// Revision 1.358  2007/08/24 16:30:30  lulin
// - двигаем куски по 14 и 18 байт.
//
// Revision 1.357  2007/08/24 16:14:57  lulin
// - сделаны процедуры для перемещения 7-к и 9-к.
//
// Revision 1.356  2007/08/24 16:02:31  lulin
// - вернул отдельное перемещение для коротких кусочков.
//
// Revision 1.355  2007/08/24 15:15:34  lulin
// - двигаем по 32 байта.
//
// Revision 1.354  2007/08/24 14:25:08  lulin
// - написаны ассемблерные эквиваленты.
//
// Revision 1.353  2007/08/24 13:29:30  lulin
// - убираем странности от компилятора.
//
// Revision 1.352  2007/08/24 12:54:48  lulin
// - используем 8-байтное заполнение.
//
// Revision 1.351  2007/08/24 11:05:52  lulin
// - используем индексные инструкции.
//
// Revision 1.350  2007/08/24 10:44:57  lulin
// - используем MMX для двиганья блоков памяти.
//
// Revision 1.349  2007/08/23 14:44:47  lulin
// - чистим память 4-ками и 8-ками.
//
// Revision 1.348  2007/08/23 14:02:18  lulin
// - чистим память 8-ками (без Case).
//
// Revision 1.347  2007/08/23 13:30:08  lulin
// - чистим память 8-ками.
//
// Revision 1.346  2007/08/21 11:39:52  lulin
// - избавляемся от предупреждений компилятора.
//
// Revision 1.345  2007/08/21 08:00:16  oman
// - fix: Не учитывали, что размер обнуляемой памяти может быть нулем
//
// Revision 1.344  2007/08/20 19:50:13  lulin
// - включил проверку памяти для Немезиса.
//
// Revision 1.343  2007/08/20 17:33:56  lulin
// - _Assert'ы для проверки операций с памятью выключены.
//
// Revision 1.342  2007/08/20 17:26:35  lulin
// - вставлены _Assert'ы для проверки операций работы с памятью.
//
// Revision 1.341  2007/08/15 15:01:41  lulin
// - объединил ветки.
//
// Revision 1.340  2007/08/15 13:56:24  lulin
// - избавляемся от Case.
//
// Revision 1.339  2007/08/15 12:10:40  lulin
// - убираем ненужные проверки.
//
// Revision 1.338  2007/08/15 11:45:17  lulin
// - убираем Case.
//
// Revision 1.337  2007/08/15 10:51:23  lulin
// - вместо Case используем таблицу переходов.
//
// Revision 1.336  2007/08/14 19:31:59  lulin
// - оптимизируем очистку памяти.
//
// Revision 1.335  2007/08/14 17:14:31  lulin
// - оптимизируем очистку памяти.
//
// Revision 1.334  2007/08/14 16:51:05  lulin
// - уменьшаем количество обращений к свойствам списка.
//
// Revision 1.333  2007/08/14 16:33:42  lulin
// - уменьшаем количество обращений к свойствам списка.
//
// Revision 1.332  2007/08/14 15:19:28  lulin
// - оптимизируем перемещение блоков памяти.
//
// Revision 1.331  2007/08/14 14:30:12  lulin
// - оптимизируем перемещение блоков памяти.
//
// Revision 1.330  2007/08/14 11:11:14  lulin
// - cleanup.
//
// Revision 1.329  2007/08/13 17:23:34  lulin
// - cleanup.
//
// Revision 1.328  2007/08/13 16:20:20  lulin
// - уменьшаем ненужные действия при работе с кешом.
//
// Revision 1.327  2007/07/24 19:21:13  lulin
// - скомпилировался F1 с модулем l3Interfaces, сгенерированным с модели.
//
// Revision 1.326  2007/07/24 18:14:49  lulin
// - собрался первый проект со сгенерированным модулем l3Interfaces.
//
// Revision 1.325  2007/04/05 11:16:58  lulin
// - cleanup.
//
// Revision 1.324  2007/04/03 13:35:14  mmorozov
// - new: строка с данными в виде интерфейса;
//
// Revision 1.323  2007/03/29 17:02:41  lulin
// - отделяем мух от котлет.
//
// Revision 1.322  2007/03/28 19:42:59  lulin
// - ЭлПаковский редактор переводим на строки с кодировкой.
//
// Revision 1.321  2007/03/27 14:27:39  lulin
// - используем кошерный список строк.
//
// Revision 1.320  2007/03/23 13:35:22  lulin
// - убран лишний параметр.
//
// Revision 1.319  2007/03/19 11:56:45  lulin
// - сделана функция класса, создающая реализацию константной строки.
//
// Revision 1.318  2007/03/16 13:56:58  lulin
// - переходим на собственную функцию форматирования строк.
//
// Revision 1.317  2007/03/16 12:21:28  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.316  2007/03/14 18:27:35  lulin
// - cleanup.
//
// Revision 1.315  2007/03/09 15:55:11  lulin
// - не копируем строки, определенные, как константы.
//
// Revision 1.314  2007/03/06 13:49:38  mmorozov
// - hint fix;
//
// Revision 1.313  2007/03/01 11:58:27  lulin
// - добавлен класс, реализующий пустую строку.
//
// Revision 1.312  2007/03/01 11:52:38  lulin
// - выделены родные классы для реализации интерфейса константной строки.
//
// Revision 1.311  2007/03/01 08:39:52  lulin
// - не копируем данные строки, если их держит интерфейс строки.
//
// Revision 1.310  2007/02/28 16:17:02  lulin
// - корректнее обрабатываем юникодные строки.
//
// Revision 1.309  2007/02/13 17:15:05  lulin
// - добавлены функции обрабокти строк с кодировкой.
//
// Revision 1.308  2007/02/07 14:30:38  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.307  2007/02/07 09:15:52  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.306  2007/02/06 15:21:20  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.305  2007/02/02 14:08:54  lulin
// - bug fix: не учитывали кодировку.
//
// Revision 1.304  2007/02/02 12:25:40  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.303  2007/02/02 09:11:09  lulin
// - упрощаем преобразование строк.
//
// Revision 1.302  2007/02/02 08:39:24  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.301  2007/01/30 15:24:24  lulin
// - текст ноды - теперь более простого типа.
//
// Revision 1.300  2007/01/22 15:20:13  oman
// - new: Локализация библиотек - l3 (cq24078)
//
// Revision 1.299  2007/01/18 10:49:41  lulin
// - заменяем объект менеджера памяти на интерфейс.
//
// Revision 1.298  2007/01/17 17:12:07  lulin
// - избавляемся от ненужной виртуальности.
//
// Revision 1.297  2007/01/17 15:39:21  lulin
// - bug fix: защищаемся от падения при выходе из приложения при другом порядке линковке модулей.
//
// Revision 1.296  2007/01/17 12:13:13  lulin
// - выносим очистку объекта при положении в кеш из под критической секции.
//
// Revision 1.295  2007/01/17 12:03:39  lulin
// - вводим постусловие, гласящее о том, что объект обязательно должен попасть в кеш.
//
// Revision 1.294  2007/01/17 11:20:20  lulin
// - cleanup.
//
// Revision 1.293  2007/01/17 10:57:57  lulin
// - проверка условия заменена предусловием.
//
// Revision 1.292  2007/01/17 10:49:36  lulin
// - cleanup.
//
// Revision 1.291  2007/01/17 10:17:31  lulin
// - cleanup.
//
// Revision 1.290  2006/12/29 11:52:32  lulin
// - выделена базовая реализация списка VCL-ных строк.
//
// Revision 1.289  2006/12/27 17:32:55  lulin
// - добавлена утилитная функция.
//
// Revision 1.288  2006/12/27 14:39:21  lulin
// - упрощена работа со списками форматов.
//
// Revision 1.287  2006/12/25 10:20:29  lulin
// - параметры строки теперь получаем одним вызовом, а не тремя.
//
// Revision 1.286  2006/12/18 09:57:23  lulin
// - выделен метод установки данных буферу обмена.
//
// Revision 1.284  2006/12/15 13:48:49  lulin
// - cleanup.
//
// Revision 1.283  2006/12/08 14:21:08  lulin
// - очищаем кешированные компоненты так, как будто они заново родились.
//
// Revision 1.282  2006/12/08 13:25:54  lulin
// - сделана возможность управлять полной очисткой данных объекта при укладывании их в кеш.
//
// Revision 1.281  2006/11/20 13:52:55  lulin
// - cleanup.
//
// Revision 1.280  2006/11/20 09:47:44  lulin
// - cleanup.
//
// Revision 1.279  2006/11/20 09:07:35  lulin
// - убрана защита через счетчик.
//
// Revision 1.278  2006/11/20 08:52:02  lulin
// - безуспешная попытка заменить критическую секцию на счетчик.
//
// Revision 1.277  2006/11/07 11:17:30  voba
// - _add comment
//
// Revision 1.276  2006/11/01 12:13:43  fireton
// - Tl3LoopThread: Suspend := True вынесено в виртуальную функцию AfterEachIneration, ибо не в каждом случае этот суспенд нужен.
//
// Revision 1.275  2006/10/06 08:50:49  lulin
// - cleanup.
//
// Revision 1.274  2006/10/06 08:22:22  oman
// - fix: Tl3ThreadContainer.WaitFor из-за FreeOnTerminate мог падать с
//  InvalidHandle
//
// Revision 1.273  2006/09/27 16:18:41  voba
// - _add procedure DeleteList(aList : _Tl3LongintList);
// - _add procedure InsertList(aList : _Tl3LongintList);
// - _add procedure IntersectList(aList : _Tl3LongintList);
//
// Revision 1.272  2006/09/25 14:42:00  voba
// - _add  aNeedSort to LoadFromStream
//
// Revision 1.271  2006/09/13 15:14:42  lulin
// - добавлен отладочный код.
//
// Revision 1.270  2006/09/13 14:44:24  lulin
// - сделано "автоматическое" освобождение оберток. Пока выключено, т.к. не работает.
//
// Revision 1.269  2006/09/13 13:37:13  lulin
// - оптимизируем обращение со стеком относительно 3-го параметра.
//
// Revision 1.268  2006/09/13 06:43:25  lulin
// - эмулируем заглушку для 1-го параметра.
//
// Revision 1.267  2006/09/13 06:40:51  lulin
// - сделаны заглушки для процедур stdcall.
//
// Revision 1.266  2006/09/11 13:11:51  lulin
// - заглушка для трех параметров теперь регистровая.
//
// Revision 1.265  2006/09/11 13:07:15  lulin
// - заглушка для двух параметров теперь регистровая.
//
// Revision 1.263  2006/09/09 14:34:48  lulin
// - почистили.
//
// Revision 1.262  2006/09/09 14:18:45  lulin
// - почистили.
//
// Revision 1.261  2006/09/09 14:09:44  lulin
// - добавлена функция, которая делает двухпараметрную заглушку для трехпараметрной процедуры. Третий параметр выкидывается при вызове заглушки.
//
// Revision 1.260  2006/09/09 13:46:02  lulin
// - теперь можно делать заглушки для процедур с одним и двумя параметрами.
//
// Revision 1.259  2006/09/09 12:45:51  lulin
// - написал комментарии.
//
// Revision 1.257  2006/09/09 12:34:11  lulin
// - заставил заглушку работать.
//
// Revision 1.256  2006/09/08 14:18:11  lulin
// - добавлена процедура, создающая заглушку для паскалевской локальной процедуры.
//
// Revision 1.255  2006/05/17 13:09:53  lulin
// - cleanup.
//
// Revision 1.254  2006/05/05 07:41:40  lulin
// - cleanup.
//
// Revision 1.253  2006/05/04 12:48:53  voba
// - _ItemSize теперь property
//
// Revision 1.252  2006/05/02 09:12:39  lulin
// - избавился от предупреждения компилятора, о конструкторе, перекрывающий базовый.
//
// Revision 1.251  2006/04/25 09:17:46  voba
// - _add function l3SmallIntArray
//
// Revision 1.250  2006/04/25 08:09:26  lulin
// - сделан полноценный редактируемый список, для хранения записей фиксированной длинны.
//
// Revision 1.249  2006/04/25 07:26:28  lulin
// - упорядочена работа с сортировкой списков и поиском в них.
// - начат класс, для хранения записей фиксированного размера.
//
// Revision 1.248  2006/04/24 17:10:58  lulin
// - cleanup.
//
// Revision 1.247  2006/04/24 16:33:33  lulin
// - испольуем "правильную" функцию, перестановки слов местами.
// - используем правильную функцию получения элемента.
//
// Revision 1.246  2006/04/24 12:58:47  lulin
// - выпиливаем из списков общую функциональность.
//
// Revision 1.245  2006/04/20 13:34:40  voba
// -  change in _Tl3_CustomString - вместо pm_GetSt теперь перекрываем DoGetSt
//
// Revision 1.244  2006/04/19 14:36:20  lulin
// - cleanup.
//
// Revision 1.243  2006/04/19 13:56:23  lulin
// - cleanup.
//
// Revision 1.242  2006/04/13 17:08:54  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.241  2006/04/05 13:28:22  lulin
// - cleanup.
//
// Revision 1.240  2006/04/05 10:59:37  lulin
// - bug fix: не очищались удаляемые элементы.
//
// Revision 1.239  2006/04/04 14:51:52  lulin
// - для списка объектов не делаем кучу лишних действий при очистке.
//
// Revision 1.238  2006/04/04 11:48:02  lulin
// - cleanup.
//
// Revision 1.237  2006/04/04 11:02:51  lulin
// - для списка целых чисел не делаем кучу лишних действий при очистке.
//
// Revision 1.236  2006/04/04 10:47:49  lulin
// - для списка целых чисел не делаем кучу лишних действий при очистке.
//
// Revision 1.235  2006/03/09 11:57:52  narry
// - изменение: процедуры записи-чтения в поток с указанием количества элементов
//
// Revision 1.234  2006/03/06 15:10:54  mmorozov
// - new: изменения связанные с выдачей сообщения при сохранении буфера (cq: 19834);
//
// Revision 1.233  2006/03/06 12:02:29  oman
// - new behavior: контроль провисания ресурсов при добавлении объектов в кэш
//
// Revision 1.232  2006/02/20 16:00:26  lulin
// - bug fix: пытаемся обойти DEP установкой правильных флагов странице со Stub'ом.
//
// Revision 1.231  2005/10/24 10:54:58  narry
// - обновление: перекрыта функция _Tl3System.Msg2Log для вывода форматированной строки
//
// Revision 1.230  2005/10/18 08:04:45  lulin
// - добавлены комментарии.
//
// Revision 1.229  2005/10/05 06:35:49  lulin
// - cleanup: из форматтера убрана лишняя функциональность.
//
// Revision 1.228  2005/10/03 08:48:12  voba
// - new type El3InfoException
//
// Revision 1.227  2005/07/27 11:53:22  lulin
// - кеш документов теперь полностью переведен на интерфейс контейнера и ничего не знает про его реализацию.
//
// Revision 1.226  2005/07/08 12:32:13  mmorozov
// new: лог может выводиться с отступами;
//
// Revision 1.225  2005/07/06 10:31:03  lulin
// - new method: l3System.Time2Log.
// - new proc: l3RaiseOSError.
//
// Revision 1.224  2005/05/27 12:06:04  lulin
// - убраны лишние зависимости.
//
// Revision 1.223  2005/05/24 11:07:37  lulin
// - cleanup.
//
// Revision 1.222  2005/04/28 15:04:11  lulin
// - переложил ветку B_Tag_Box в HEAD.
//
// Revision 1.221.2.6  2005/04/26 14:30:56  lulin
// - ускоряем _l3Free и _l3Use.
//
// Revision 1.221.2.5  2005/04/26 12:52:57  lulin
// - ускоряем _l3Free.
//
// Revision 1.221.2.4  2005/04/26 12:24:21  lulin
// - еще наиграл время за счет уменьшения количества Use.
//
// Revision 1.221.2.3  2005/04/26 10:38:35  lulin
// - уменьшаем количество вызываемых методов.
//
// Revision 1.221.2.2  2005/04/26 10:22:33  lulin
// - не вызываем ненужный метод.
//
// Revision 1.221.2.1  2005/04/22 09:04:39  lulin
// - cleanup: убраны ненужные параметры.
//
// Revision 1.221  2005/04/16 13:48:01  lulin
// - список классов в "следилке" теперь сортируется более дешевым способом.
//
// Revision 1.220  2005/04/16 13:32:14  lulin
// - убрана ненужная сортировка.
//
// Revision 1.219  2005/04/08 08:14:45  voba
// - _add procedure _Stack2Log
//
// Revision 1.218  2005/04/06 12:25:37  lulin
// - bug fix: стрелочки не учитывались как псевдографика.
//
// Revision 1.217  2005/04/01 15:35:36  narry
// - новое свойство: ShowObjectsWindow
//
// Revision 1.216  2005/03/31 12:45:52  mmorozov
// remove: проверка кодовой страницы;
//
// Revision 1.211  2005/03/14 13:48:22  lulin
// - bug fix: из-за некорректной проверки на то, что приложение закрывается - оставался один объект TafwApplication.
//
// Revision 1.210  2005/03/14 10:44:21  lulin
// - new method: _Tl3InterfaceList.Remove.
//
// Revision 1.209  2005/03/09 12:13:50  lulin
// - удалено ненужное поле класса.
//
// Revision 1.208  2005/02/02 18:24:44  lulin
// - класс _Tl3_CBase переведен на шаблон _Unknown_.
//
// Revision 1.207  2005/02/02 11:59:56  lulin
// - класс _Tl3_CBase вынесен в отдельный модуль.
//
// Revision 1.206  2005/01/24 11:43:23  lulin
// - new behavior: при освобождении заглушки очищаем указатель на нее.
//
// Revision 1.205  2005/01/19 16:47:31  lulin
// - статусная строка теперь меньше моргает.
//
// Revision 1.204  2004/12/30 11:46:34  lulin
// - интерфейсы относящиеся к Preview переехали в библиотеку _AFW.
//
// Revision 1.203  2004/12/08 13:12:22  lulin
// - добавлена возможность указать число повторов.
//
// Revision 1.202  2004/12/07 11:54:24  lulin
// - new method: _Tl3LongintList._IndexOf.
//
// Revision 1.201  2004/12/07 11:45:31  lulin
// - new prop: _Tl3LongintList.Last.
//
// Revision 1.200  2004/11/19 16:33:17  lulin
// - bug fix: съедались двухбуквенные ShortCut'ы.
//
// Revision 1.199  2004/11/15 13:40:50  lulin
// - теперь для типа параграфа можно определять _ParamsForClone - список атрибутов, которые нужно присваивать при клонировании параграфа.
//
// Revision 1.198  2004/10/20 10:40:51  lulin
// - new behavior: увеличиваем частоту использования пула объектов.
//
// Revision 1.197  2004/10/07 10:07:21  lulin
// - статистику распределения памяти выводим в отдельный лог и в форматированном для Excel виде.
//
// Revision 1.196  2004/10/07 09:34:17  lulin
// - раздельно собираем статистику распределения памяти для System и  L3.
//
// Revision 1.195  2004/10/07 09:21:20  lulin
// - new directive: _l3TraceMemAllocStat.
//
// Revision 1.194  2004/10/07 08:29:54  lulin
// - new directive: _l3DirectUseSystemMemManager.
//
// Revision 1.193  2004/10/07 07:57:11  lulin
// - new prop: l3System.SysLocalMemUsed.
//
// Revision 1.192  2004/10/07 07:27:43  lulin
// - new: сделана возможность следить за выделением/освобождением памяти стандартными средствами.
//
// Revision 1.191  2004/10/01 09:22:56  lulin
// - new method version: _l3Free чтобы не наступать на грабли с освобождением интерфейсов.
//
// Revision 1.190  2004/09/28 17:22:15  lulin
// - в первом приближении сделал кеш документов. Пока без вымещения покументов на диск.
//
// Revision 1.189  2004/09/20 16:11:51  lulin
// - для Немезиса уменьшен размер пула объектов.
//
// Revision 1.188  2004/09/20 12:42:58  lulin
// - оптимизация - путем перемещения части объектов в пул, время загрузки ГК (до показа оглавления) уменьшено с 3.5 сек до 2.6 сек.
//
// Revision 1.187  2004/09/16 16:19:00  lulin
// - убраны лишние проверки типа.
//
// Revision 1.186  2004/09/16 09:25:15  lulin
// - bug fix: наследники от evCtrl убивались в DesignTime произвольным образом.
//
// Revision 1.185  2004/09/13 07:33:05  lulin
// - new behavior: _Tl3InterfacedComponent теперь может распределять свою память в пуле объектов.
//
// Revision 1.184  2004/09/11 14:15:53  lulin
// - класс _Tl3InterfacedComponent сделан кешируемым.
//
// Revision 1.183  2004/09/11 13:29:32  lulin
// - отвязываем кеш объектов от использования только _Tl3Base.
//
// Revision 1.182  2004/09/08 11:22:54  lulin
// - new define: _l3NoTrace.
// - new define: _l3TraceObjects.
//
// Revision 1.181  2004/08/18 12:27:22  law
// - перевел процедуру m4BuildIndexNew на использование m3IterateDocuments.
//
// Revision 1.180  2004/08/05 16:58:19  law
// - new behavior: для Немезиса в оглавлении вместо имени документа выводим "Оглавление" (CQ OIT5-8572).
// - избавился от ряда Warning'ов и Hint'ов.
//
// Revision 1.179  2004/08/03 10:12:32  migel
// - fix: вызываем `ExitProcs` в обратном порядке.
//
// Revision 1.178  2004/07/28 14:54:11  law
// - bug fix: падало при закрытии окна во время форматирования.
//
// Revision 1.177  2004/07/28 09:40:36  voba
// - _add comment
//
// Revision 1.176  2004/07/26 15:03:14  law
// - bug fix: вызываем ExitProcs в правильном порядке.
//
// Revision 1.175  2004/07/07 11:59:51  law
// - new behavior: теперь ссылка на кэш объектов содержится в самом классе.
//
// Revision 1.174  2004/07/05 17:13:23  law
// - optimization.
//
// Revision 1.173  2004/07/05 16:32:51  law
// - optimization.
//
// Revision 1.172  2004/07/02 11:24:16  law
// - оптимизирована работа с кешом объектов.
//
// Revision 1.171  2004/07/02 10:16:19  law
// - оптимизирована работа с кешом объектов.
//
// Revision 1.170  2004/06/25 16:47:24  migel
// - change/fix: для совместимости с win9x перешли на собственную реализацию `Interlocked*` функций.
//
// Revision 1.169  2004/06/18 16:28:11  law
// - Tk2AtomR.QueryInterface оптимизирована по скорости.
//
// Revision 1.168  2004/06/17 15:59:02  law
// - свойство Empty переместилось с класса _Tl3Base на класс _Tl3SomeDataContainer.
//
// Revision 1.167  2004/06/16 14:50:45  law
// - bug fix: все-таки менеджеры пулов надо освобождать до окошка с ресурсами, но надо давить _Assert.
//
// Revision 1.166  2004/06/16 14:43:47  law
// - bug fix: поздно освобождал глобальные объекты (после окна со статистикой).
//
// Revision 1.165  2004/06/16 14:37:51  law
// - bug fix: рано освобождали менеджеры пулов (до окна со статистикой).
//
// Revision 1.164  2004/06/10 11:03:24  law
// - свойство _Tl3CustomString.Len сделано статическим.
//
// Revision 1.163  2004/06/04 15:51:59  law
// - интерфейс _Il3StringList сделан наследником от _Il3List.
//
// Revision 1.162  2004/06/03 16:54:46  law
// - new method: Il3Base.CheckStamp.
//
// Revision 1.161  2004/06/03 15:59:57  law
// - убрал прямое обращение к _Tl3PVList (т.к. для оптимизации предполагается, что в теле документа не всегда он может хранится).
//
// Revision 1.160  2004/06/03 14:59:43  law
// - убрал прямое обращение к _Tl3PVList (т.к. для оптимизации предполагается, что в теле документа не всегда он может хранится).
//
// Revision 1.159  2004/06/03 12:42:45  law
// - new interface: _Il3PointerList.
//
// Revision 1.158  2004/06/03 11:00:48  law
// - используем _Il3List и _Il3ListIterator вместо _Tl3PVList.
//
// Revision 1.157  2004/06/03 09:53:54  law
// - начал использовать _Il3ListIterator вместо _Tl3PVList.
//
// Revision 1.156  2004/06/03 09:37:27  law
// - new interface: _Il3List.
//
// Revision 1.155  2004/06/02 16:57:50  law
// - cleanup.
//
// Revision 1.154  2004/06/02 16:42:39  law
// - удален класс Tl3VList.
//
// Revision 1.153  2004/06/02 16:07:34  law
// - bug fix: используем "правильные" списки.
//
// Revision 1.152  2004/06/02 15:12:10  law
// - конструкторы Make перенесены с _Tl3PVList на _Tl3PtrRecList.
//
// Revision 1.151  2004/06/02 14:04:30  law
// - удален конструктор Tl3VList.MakeSortedEx.
//
// Revision 1.150  2004/06/02 13:52:21  law
// - удален конструктор Tl3VList._MakeClass - пользуйтесь _Tl3ClassList.Make.
//
// Revision 1.149  2004/06/02 13:50:20  law
// - new class: _Tl3ClassList.
//
// Revision 1.148  2004/06/02 13:46:18  law
// - удален конструктор Tl3VList.MakeObject - пользуйтесь _Tl3ObjectList.Make.
//
// Revision 1.147  2004/06/02 13:35:57  law
// - new class: _Tl3ObjectList.
//
// Revision 1.146  2004/06/02 13:11:28  law
// - удален конструктор Tl3VList.MakeDataPointer - пользуйтесь _Tl3DataRefList.MakeSorted.
//
// Revision 1.145  2004/06/02 13:06:12  law
// - new class: _Tl3DataRefList.
//
// Revision 1.144  2004/06/02 10:47:44  law
// - удален конструктор Tl3VList.MakeIUnknownSorted - пользуйтесь _Tl3InterfaceList.MakeSorted.
//
// Revision 1.143  2004/06/02 10:20:54  law
// - удален конструктор Tl3VList.MakeIUnknown - пользуйтесь _Tl3InterfaceList.Make.
//
// Revision 1.141  2004/06/02 08:30:31  law
// - удален конструктор Tl3VList.MakePersistentSorted - пользуйтесь _Tl3ObjectRefList.MakeSorted.
//
// Revision 1.140  2004/06/01 16:51:30  law
// - удален конструктор Tl3VList.MakePersistent - пользуйтесь _Tl3ObjectRefList.
//
// Revision 1.139  2004/06/01 15:44:40  law
// - удалены конструкторы Tl3VList.MakeString, MakeStringSorted - пользуйтесь _Tl3StringList.
//
// Revision 1.138  2004/06/01 15:34:03  law
// - удалены конструкторы Tl3VList.MakeLongint, MakeLongintSorted - пользуйтесь _Tl3LongintList.
// - подчистил VCM, за сегодняшними переделками Маркова.
//
// Revision 1.137  2004/06/01 14:23:13  law
// - удалены конструкторы Tl3VList.MakeLongint, MakeLongintSorted - пользуйтесь _Tl3LongintList.
//
// Revision 1.136  2004/06/01 11:20:36  law
// - new class: _Tl3StringList.
//
// Revision 1.135  2004/06/01 11:08:08  law
// - change: _Tl3LongintList теперь наследуется от _Tl3PtrRecList.
//
// Revision 1.134  2004/06/01 09:40:57  law
// - change: _Tl3ObjectRefList теперь не хранит тип элементов.
//
// Revision 1.133  2004/06/01 09:03:05  law
// - new classes: _Tl3ObjectRefList, _Tl3CObjectRefList.
//
// Revision 1.132  2004/06/01 07:13:21  law
// - change: конструкторы перенесены с _Tl3_VList на _Tl3PVList.
//
// Revision 1.131  2004/05/31 14:38:36  law
// - change: _Tl3PVList теперь честный класс, а не алиас.
//
// Revision 1.130  2004/05/31 14:19:17  law
// - new method: _Tl3System._GetSizedMM.
//
// Revision 1.129  2004/05/31 13:12:37  law
// - добавлены константы.
//
// Revision 1.128  2004/05/31 13:08:13  law
// - new behavior: все пулы объектов объединены в единый список.
//
// Revision 1.127  2004/05/31 12:52:03  law
// - new behavior: убираем принудительное доставание объектов из кеша, т.к. кешируемые объекты удаляются все равно раньше специализированных пулов.
//
// Revision 1.126  2004/05/31 12:10:12  law
// - change: _Tl3PtrRecList переехал в l3Base и стал Tl3VList.
//
// Revision 1.125  2004/05/31 11:44:39  law
// - new class: _Tl3PVList - список с виртуальными методами распределения/освобождения памяти.
//
// Revision 1.124  2004/05/28 16:02:32  law
// - new method: _Tl3System._GetBoxMM.
//
// Revision 1.123  2004/05/28 15:57:09  law
// - new unit: l3BoxMM.
//
// Revision 1.122  2004/05/28 09:45:24  law
// - new behavior: не по вторазу не учитываем памать на объекты, которые попадают в пул.
//
// Revision 1.121  2004/05/27 15:48:22  law
// - new behavior: Pool памяти перетащен в класс _Tl3Base.
// - new behavior: память под класс Tl3String теперь распределяется из Pool'а.
//
// Revision 1.120  2004/05/27 14:32:14  law
// - new methods: _Tl3_CBase.IsCacheable, _NeedStoreInPool.
//
// Revision 1.119  2004/05/27 10:47:20  law
// - bug fix: заработала директива _k2CacheTagObject.
//
// Revision 1.118  2004/05/14 13:29:38  law
// - new method: Tl3KeyWords.AddKeyWords.
//
// Revision 1.117  2004/05/12 11:44:12  law
// - new behavior: уменьшаем вероятность появления Unicode-строк в редакторе.
//
// Revision 1.116  2004/04/15 09:59:04  law
// - bug fix: защитил глобальные объекты для многозадачности.
//
// Revision 1.115  2004/04/15 06:59:08  law
// - закомментирована неиспользуемая переменная.
//
// Revision 1.114  2004/04/15 06:45:51  law
// - change: убрана хитрая трансляция клавиш, оказавшаяся ненужной на системах где не "подхачено" _1252 = _1251.
//
// Revision 1.113  2004/04/14 15:58:08  law
// - new behavior: пытаемся поменьше плодить Unicode-параграфов.
//
// Revision 1.112  2004/04/14 14:34:43  law
// - new behavior: даем возможность вводить символы немецкого и других европейских языков.
//
// Revision 1.111  2004/04/14 08:50:19  law
// - new procs: l3KeyboardCodePage, l3KeyToUnicode.
//
// Revision 1.110  2004/04/09 15:26:11  law
// - bug fix: некорректно подсчитывалась память для объектов не L3.
//
// Revision 1.109  2004/04/09 11:06:31  law
// - new class: Tl3CVList.
//
// Revision 1.108  2004/04/02 06:33:23  law
// - bug fix: AV - при выгрузке библиотеки (и соответственно при выходе из Delphi).
//
// Revision 1.107  2004/04/01 14:06:30  law
// - new behavior: при выходе из приложения не пытаемся складывать объекты в кэш.
//
// Revision 1.106  2004/03/24 17:21:28  law
// - bug fix: AV при выходе из Эвереста.
//
// Revision 1.105  2004/03/24 10:37:57  law
// - bug fix: было неправильное сообщение о неосвобожденных объектах, когда Application освобождается ПОСЛЕ l3System.
//
// Revision 1.104  2004/02/27 19:08:48  vasonik
//  - bug fix: Добавлена проверка на nil в функции l3FreeLocalStub
//
// Revision 1.103  2004/01/16 14:18:18  nikitin75
// - new field: Tl3ThreadContainer.f_Executed.
// - new method: Tl3ThreadContainer.DoExecute - виртуальный, вместо Execute, который стал статическим.
//
// Revision 1.102  2004/01/08 15:19:57  law
// - new behavior: ограничил количество объектов каждого класса, которые попадают в кеш числом в 10000.
//
// Revision 1.101  2003/12/17 14:17:15  law
// - some optimization.
//
// Revision 1.100  2003/12/05 17:01:11  voba
// - _add procedure Remove
//
// Revision 1.99  2003/09/17 13:26:30  law
// - bug fix: поправлена несимметричность методов _Tl3LongintList.LoadFromStream и SaveToStream.
//
// Revision 1.98  2003/07/08 14:54:49  law
// - bug fix: параметры _Tl3System.PeekMessage приведены в соответствие с типами в Windows.pas.
//
// Revision 1.97  2003/07/04 19:39:59  law
// - оптимизация переформатирования текста в фоновом режиме (до конца не доделано, но светлые мысли есть).
//
// Revision 1.96  2003/04/16 09:29:36  voba
// -  _add class Tl3Array
//
// Revision 1.95  2003/04/15 15:09:15  law
// - bug fix: валился линкер с опцией Include TD32 Debug Info.
//
// Revision 1.92  2003/04/15 13:26:49  law
// - new unit: evUnits.
//
// Revision 1.91  2003/03/19 14:13:57  law
// - bug fix: падало после дерегистрации объекта когда l3System уже была освобождена.
//
// Revision 1.90  2003/03/13 16:37:20  law
// - change: попытка портировать на Builder.
//
// Revision 1.89  2003/01/16 14:46:41  law
// - new behavior: защитил многопоточную работу с заглушками локальных процедур.
//
// Revision 1.88  2002/12/05 12:00:47  law
// - new directive: _l3TraceAllocStub.
//
// Revision 1.87  2002/10/21 11:59:37  law
// - bug fix: синхронизация с Delphi 7.
//
// Revision 1.86  2002/10/15 09:51:34  voba
// - new behavior: обрабатываем ситуацию, когда нет "честной" нити, а контейнер "спит".
//
// Revision 1.85  2002/10/15 09:44:21  voba
// - change: NeedThread - перенесен в секцию public.
//
// Revision 1.84  2002/07/18 11:59:14  law
// - new unit: l3Message.
//
// Revision 1.83  2002/06/11 15:57:18  narry
// - bug fix: Handle -> ThreadID.
//
// Revision 1.82  2002/06/11 15:35:32  law
// - new behavior: при завершении нити посылаем ей сообщение WM_Quit.
//
// Revision 1.81  2002/05/30 10:53:42  law
// - new behavior: сообщение об исключительной ситуации записывается вместе со стеком.
//
// Revision 1.80  2002/05/23 14:48:20  law
// - new class: Tl3NonAbsLoopThread.
//
// Revision 1.79  2002/05/16 08:25:43  law
// - new behavior: отсекаем cc_CtrlBackspace из вводимой строки.
//
// Revision 1.78  2002/05/15 14:45:17  narry
// - bug fix: изменена логика освобождения нити.
//
// Revision 1.77  2002/05/15 13:47:32  law
// - change: метод Tl3ThreadContainer.Create теперь виртуальный.
//
// Revision 1.76  2002/05/14 08:37:32  law
// - new methods: Tl3VList: LoadFromStream, LoadFromFile, SaveToStream, SaveToFile.
//
// Revision 1.75  2002/04/16 12:04:25  law
// - new mathod: CallSynchronize.
//
// Revision 1.74  2002/04/11 12:38:37  law
// - bug fix: сделана сортировка после загрузки списка.
//
// Revision 1.73  2002/04/03 14:41:04  law
// - bug fix: вставлена проверка на то что из потока есть, что читать.
//
// Revision 1.72  2002/04/03 13:13:14  law
// - new methods: _Tl3LongintList.LoadFromFile, LoadFromStream.
//
// Revision 1.71  2002/04/01 16:05:13  law
// - bug fix: выставление Suspended когда убивается "живая" нитка.
//
// Revision 1.70  2002/02/27 17:06:24  law
// - optimization: попытка оптимизации путем применения менеджера памяти, выделяющего большие блоки.
//
// Revision 1.69  2002/02/07 13:43:21  voba
// - bug fix: AV при закрытии формы с окном редактора.
//
// Revision 1.68  2002/01/10 09:58:58  law
// - bug fix: _l3Free не работала для компонент без счетчика ссылок.
//
// Revision 1.67  2001/12/28 14:57:19  law
// - change: типы переименованы в соответствии с названием библиотеки.
//
// Revision 1.66  2001/11/09 10:16:07  law
// - new interface: IevTextOpProcessor.
//
// Revision 1.65  2001/11/02 15:11:19  law
// - change.
//
// Revision 1.64  2001/11/01 14:48:29  law
// - comments: xHelpGen.
//
// Revision 1.63  2001/10/15 15:42:47  law
// - cleanup.
//
// Revision 1.62  2001/10/15 14:57:11  law
// - new proc: _Tl3System.CheckClipboard.
//
// Revision 1.61  2001/10/12 17:52:00  law
// - new behavior: работа с буфером обмена через _OleSetClipboard.
//
// Revision 1.60  2001/09/26 14:06:59  law
// - cleanup: l3NilObject заменен на _l3NilOp.
//
// Revision 1.59  2001/08/29 07:01:09  law
// - split unit: l3Intf -> l3BaseStream, l3BaseDraw, l3InterfacedComponent.
//
// Revision 1.58  2001/08/02 11:43:20  law
// - cleanup & comments.
//
// Revision 1.57  2001/07/27 15:46:04  law
// - comments: xHelpGen.
//
// Revision 1.56  2001/06/26 16:28:36  law
// - comments & cleanup.
//
// Revision 1.55  2001/06/19 08:46:57  law
// - cleanup.
//
// Revision 1.54  2001/04/19 11:20:41  law
// - new behavior: в отсутствии Thread у ThreadContainer'а Suspended всегда равно true, если не выполняется метод Execute.
//
// Revision 1.53  2001/04/18 13:25:23  law
// - comments: добавлены комментарии для xHelpGen.
//
// Revision 1.52  2001/01/31 10:37:32  law
// - оптимизировано использование QueryInterface.
//
// Revision 1.51  2001/01/22 10:44:16  voba
// - bug fix: finalization AV.
//
// Revision 1.50  2000/12/19 15:06:27  law
// - #13#10 -> cc_EOL.
//
// Revision 1.49  2000/12/15 15:18:59  law
// - вставлены директивы Log.
//

{$Include l3Define.inc }

interface

uses
  SysUtils,
  Windows,

  SyncObjs,
  Classes,

  Refcounted,
  l3MemUtils,

  l3ExceptionsLog,
  l3Chars,
  l3Types,
  l3BitArr,
  l3IID,
  l3Interfaces,
  l3TreeInterfaces,
  l3_Base,
  l3CustomString,
  l3_String,
  l3InternalInterfaces,
  l3PrimString,
  l3CacheableBase,
  l3ProcedureList,
  l3DataContainerWithoutIUnknownPrim,
  l3ProtoObject,
  l3CProtoObject,
  l3ObjectCache,
  l3SimpleObject,
  l3BoxMemoryManager,
  //l3SimpleMM
  l3ObjectsMemoryManager
  ;

{.$Define l3AutoFreeStubs}

type
  Tl3Base = l3_Base.Tl3_Base;

  Tl3String = l3_String.Tl3_String;
  Rl3String = l3_String.Rl3_String;
  Tl3CustomString = l3CustomString.Tl3CustomString;
  Tl3PrimString = l3PrimString.Tl3PrimString;
  Pl3CustomString = ^Tl3CustomString;

  Tl3ConstString = class(Tl3CustomString, Il3CString)
   {* Константная строка. }
    private
    // property fields
      f_St : Tl3PCharLen;
    protected
    // property methods
      function  GetAsPCharLen: Tl3PCharLenPrim;
        override;
        {-}
      procedure DoSetAsPCharLen(const Value: Tl3PCharLen);
        override;
        {-}
    protected
    // internal methods
      procedure CannotModify;
        {-}
    public
    // public methods
      constructor Make(const aSt: Tl3WString);
        {* - создает новую строку как копию aSt. }
      class function MakeI(const aSt: Tl3WString): Il3CString;
        {-}
      procedure Assign(P: TPersistent);
        override;
        {-}
  end;//Tl3ConstString

  Tl3IntfString = class(Tl3CustomString)
   {* Константная строка. }
    private
    // property fields
      f_St : Il3CString;
    protected
    // property methods
      function  GetAsPCharLen: Tl3PCharLenPrim;
        override;
        {-}
      procedure DoSetAsPCharLen(const Value: Tl3PCharLen);
        override;
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Make(const aSt: Il3CString);
        {* - создает новую строку как копию aSt. }
      function COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
  end;//Tl3IntfString

  Tl3DataIntfString = class(Tl3IntfString
                            ,
                            IUnknown
                            )
   {* Строка с данными. }
    private
    // internal fields
      f_Data: IUnknown;
    protected
    // methods
       procedure Cleanup;
         override;
         {-}
    public
    // public methods
      constructor Make(const aSt   : Il3CString;
                       const aData : IUnknown);
        reintroduce;
        {-}
      function COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
  end;//Tl3DataIntfString

  Tl3ObjPtrString = class(Tl3String)
    private
    // internal fields
      f_Object : TObject;
    protected
    // internal methods
      function  pm_GetLinkedObject: TObject;
        override;
      procedure pm_SetLinkedObject(aValue: TObject);
        override;
        {-}
      procedure Cleanup;
        override;
        {-}
  end;//Tl3ObjPtrString

  Tl3ObjPtrIntfString = class(Tl3IntfString)
    private
    // internal fields
      f_Object : TObject;
    protected
    // internal methods
      function  pm_GetLinkedObject: TObject;
        override;
      procedure pm_SetLinkedObject(aValue: TObject);
        override;
        {-}
      procedure Cleanup;
        override;
        {-}
  end;//Tl3ObjPtrIntfString

  Tl3ObjRefString = class(Tl3String)
  {*! Класс реализующий строки с возможностью хранения объекта.}
  // Связанный объект автоматически освобождается при удалении строки
   private
    f_Object : TObject;
   protected
   // internal methods
      function  pm_GetLinkedObject: TObject;
        override;
      procedure pm_SetLinkedObject(aValue: TObject);
        override;
        {-}
   protected
    procedure Cleanup;
      override;
   public
    constructor Make(const aSt: Tl3PCharLen; const anObj: Tl3ProtoObject);
      overload;
      {* - создает новую строку как копию aSt. }
  end;//Tl3ObjRefString

  Tl3CResString = class(Tl3CProtoObject{Tl3CacheableBase}, Il3CString)
    private
    // internal fields
      f_S  : PResStringRec;
      f_St : AnsiString;
    protected
    // internal methods
      function  pm_GetAsWStr: Tl3WString;
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      class function MakeI(const aStr: PResStringRec): Il3CString;
        {-}
  end;//Tl3CResString

  Tl3CNodeString = class(Tl3CProtoObject{Tl3CacheableBase}, Il3CString)
    private
    // internal fields
      f_Node : Il3SimpleNode;
    protected
    // internal methods
      function  pm_GetAsWStr: Tl3WString;
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      class function MakeI(const aNode: Il3SimpleNode): Il3CString;
        {-}
  end;//Tl3CNodeString

  Tl3CWideString = class(Tl3CProtoObject{Tl3CacheableBase}, Il3CString)
    private
    // internal fields
      f_S : WideString;
    protected
    // internal methods
      function pm_GetAsWStr: Tl3WString;
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      class function MakeI(const aStr: WideString): Il3CString;
        {-}
  end;//Tl3CWideString
  
  Tl3CConstDelphiString = class(Tl3CProtoObject{Tl3CacheableBase}, Il3CString)
    private
    // internal fields
      f_S : Pointer;
    protected
    // internal methods
      function pm_GetAsWStr: Tl3WString;
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      class function MakeI(const aStr: AnsiString): Il3CString;
        {-}
  end;//Tl3CConstDelphiString

  Tl3CDelphiString = class(Tl3CProtoObject{Tl3CacheableBase}, Il3CString)
    private
    // internal fields
      f_S : AnsiString;
    protected
    // internal methods
      function pm_GetAsWStr: Tl3WString;
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(const aStr: AnsiString); reintroduce;
        {-}
      class function MakeI(const aStr: AnsiString): Il3CString;
        {-}
  end;//Tl3CDelphiString

  Tl3ObjectHash = object(Tl3PtrHash)
    public
    // public methods
      function SetItem(ItemIndex: Long; Item: Tl3ProtoObject): PObject;
        {-}
      function GetItemP(ItemIndex: Long): PObject;
        {-}
      procedure Clear;
        {-}
  end;//Tl3ObjectHash

  Tl3Windows = class(Tl3ProtoObject)
    public
    {public methods}
      procedure ScrollWindow(Wnd: HWnd; XAmount, YAmount: Integer; Rect: PRect; ClipRect: PRect);
        {-}
      function  Focused: hWnd;
        {-}
  end;{Tl3Windows}

  Tl3InputDevice = class(Tl3ProtoObject)
   {* Устройство ввода. }
  end;{Tl3InputDevice}

  Tl3Mouse = class(Tl3InputDevice)
   {* Мышь. }
    public
    {public methods}
      function  SetCapture(Wnd: hWnd): hWnd;
        {* - установить захват мыши. }
      procedure ReleaseCapture;
        {* - освободить мышь. }
      function  LeftButton: Byte;
        {-}
  end;{Tl3Mouse}

  Tl3Key = object
   {* Состояние клавиши. }
    public
    //public fields
      Down    : Bool;
        {* - клавиша нажата? }
      Toggled : Bool;
        {* - переключатель включен? }
  end;{Tl3Key}

  Tl3Keyboard = class(Tl3InputDevice)
   {* Клавиатура. }
    protected
    {property methods}
      function  pm_GetKey(Index: Integer): Tl3Key;
        {-}
      function  pm_GetAsyncKey(Index: Integer): Tl3Key;
        {-}
    public
    {public properties}
      property Key[Index: Integer]: Tl3Key
        read pm_GetKey;
        {* - синхронный статус клавиши. }
      property AsyncKey[Index: Integer]: Tl3Key
        read pm_GetAsyncKey;
        {* - асинхронный статус клавиши. }
  end;{Tl3Keyboard}

  Tl3ConvertCharProc = procedure (const aStr: Tl3PCharLen) of object;
   {* Событие для преобразования символов. }

  Tl3StringListPrim = class(TStringList)
    protected
    // internal methods
      function CompareStrings(const S1, S2: String): Integer;
        override;
        {-}
  end;//Tl3StringListPrim

  Tl3CacheProcs = record
   aGet              : Tl3GetClassCacheEntryEvent;
   aSet              : Tl3SetClassCacheEntryEvent;
   aBeforeAddToCache : Tl3BeforeAddToCacheEvent
  end;//Tl3CacheProcs

  Tl3SystemPrim = class(Tl3MemUtils{TRefcounted}{Tl3ProtoObject})
   {* Базовый класс менеджеров ресурсов. }
    private
    // internal fields
      f_ExitProcs        : Tl3ProcedureList;
      {$IfDef l3TraceClasses}
      f_ClassList        : TStringList;
      {$EndIf l3TraceClasses}
      FShowObjectsWindow : Boolean;
      f_AllLocalMemUsed  : Long;
      f_ObjectMemUsed    : Long;
      f_ObjectCount      : Long;
      f_CanCache         : Bool;
      f_CacheCS          : TCriticalSection;
      f_GlobalCS         : TCriticalSection;
      f_ObjectCache      : Tl3ObjectCache;
    public
      MaxLocalMemUsed    : Long;
      MaxGlobalMemUsed   : Long;
      MaxObjectMemUsed   : Long;
      MaxObjectCount     : Long;
      MaxAllLocalMemUsed : Long;
    protected
    // property methods
      function pm_GetLocalMemUsed     : Long;
      function pm_GetGlobalMemUsed     : Long;
      function pm_GetCanCache: Boolean;
        {-}
      function pm_GetSysLocalMemUsed: Long;
        {-}
    protected
    // internal methods
      class procedure CheckMaxes; override;
        {-}
      class procedure StatMemAlloc(aSize: Long; aL3: Boolean); override;
        {-}
      function  CheckResources: AnsiString;
        virtual;
        {-}
      procedure BeforeRelease;
        override;
        {-}
      procedure Release;
        override;
        {-}
      procedure CallExitProcs;
        {-}
    public
    {public methods}
      constructor Create{(anOwner: TObject = nil)};
        //override;
        {- P - адрес указателя куда будет положен Self}
      procedure AddExitProc(P: TProcedure);
        {* - добавить процедуру, вызываемую при выходе из приложения. }
      function  GlobalAlloc(Flags: Cardinal; Bytes: LongInt): THandle;
        {* - получить кусок глобальной памяти. }
      function  GlobalFree(Mem: THandle): THandle;
        {* - освободить кусок глобальной памяти. }
      function  GlobalReallocPtr(P: Pointer; Bytes: Longint; Flags: Cardinal): Pointer;
        {-}
      function  GlobalRealloc(Mem: THandle; Bytes: Longint; Flags: Cardinal): THandle;
        {* - перераспределить кусок глобальной памяти. }
      procedure CorrectGlobalMemSize(aDelta: Long);
        {* - скорректировать размер учитываемой глобальной памяти. }
      function  Send(O: TObject; _Msg: uInt; _wParam: WParam; _lParam: LParam): LongInt;
        {* - послать сообщение объекту. }
      procedure Translate(O: TObject; var Message);
        {* - транслировать сообщение объекту. }
      {$IfDef l3TraceObjects}
      procedure RegisterObject(anObject: TObject; aStoreInPool : Bool = false);
        {* - зарегистрировать созданный объект. }
      procedure UnRegisterObject(anObject: TObject; aStoreInPool : Bool = false);
        {* - отрегистрировать ранее зарегистрированный объект. }
      {$EndIf l3TraceObjects}  
      procedure IncObjectMemUsed(Sz: Long);
        {-}
      procedure DecObjectMemUsed(Sz: Long);
        {-}
      function  AddToCache(O        : TObject;
                           const aP : Tl3CacheProcs): Bool;
        reintroduce;
        {* - добавить объект в кэш объектов. }
      function  GetFromCache(aGet : Tl3GetClassCacheEntryEvent): Pointer;
        reintroduce;
        {* - получить объект класса C из кеша. }
      procedure EnterGlobalCS;
        {-}
      procedure LeaveGlobalCS;
        {-}
    public
    {public properties}
      property LocalMemUsed: Long
        read pm_GetLocalMemUsed;
        {* - сколько локальной памяти выделено? }
      property AllLocalMemUsed: Long
        read f_AllLocalMemUsed;
        {* - сколько локальной памяти выделено? (И стандартными библиотками тоже). }
      property SysLocalMemUsed: Long
        read pm_GetSysLocalMemUsed;
        {* - сколько локальной памяти выделено? (ТОЛЬКО стандартными библиотками). }
      property GlobalMemUsed: Long
        read pm_GetGlobalMemUsed;
        {* - сколько глобальной памяти выделено? }
      property ObjectMemUsed: Long
        read f_ObjectMemUsed;
        {* - сколько памяти выделено под объекты?}
      property ObjectCount: Long
        read f_ObjectCount;
        {* - количество живых объектов зарегистрированных в системе. }
      property CanCache: Bool
        read pm_GetCanCache;
        {* - включен ли режим кэширования объектов для повторного использования. }
      property ShowObjectsWindow: Boolean
       read FShowObjectsWindow
       write FShowObjectsWindow;
        {* - Показывать или нет окно с неосвобожденными ресурсами по окончании работы программы }
      {$IfDef l3TraceClasses}
      property ClassList: TStringList
        read f_ClassList;
        {-}
      {$EndIf l3TraceClasses}
  end;//Tl3SystemPrim

  Tl3ObjectsMemoryManager = l3ObjectsMemoryManager.Tl3ObjectsMemoryManager;

  Tl3System = class(Tl3SystemPrim)
   {*! Класс менеджеров ресурсов. }
    private
    // internal fields
      f_Keyboard      : Tl3Keyboard;
      f_Mouse         : Tl3Mouse;
      f_Windows       : Tl3Windows;
      f_DCCount       : Long;
      f_RgnCount      : Long;
      f_SimpleMM      : Tl3ObjectsMemoryManager;
      f_BoxMM         : Tl3BoxMemoryManager;
      {$IfDef l3UseOleClipboard}
      f_ClipboardData : IDataObject;
      {$EndIf l3UseOleClipboard}
      f_Stamp         : TGUID;
      f_StampInited   : Boolean;
      f_LogIndent     : Integer;
      f_MessageLevel: Byte;
        {* - определяет отступ при выводе в лог. }
    private
    // internal methods
      function AddLogIndent : AnsiString;
        {* - возвращает текущий отступ для лога. }
    protected
    // property methods
      function  pm_GetKeyboard: Tl3Keyboard;
      procedure pm_SetKeyboard(Value: Tl3Keyboard);
        {-}
      function  pm_GetMouse: Tl3Mouse;
      procedure pm_SetMouse(Value: Tl3Mouse);
        {-}
      function  pm_GetWindows: Tl3Windows;
      procedure pm_SetWindows(Value: Tl3Windows);
        {-}
      function  pm_GetAppTitle: AnsiString;
        {-}
      function  pm_GetLogMachineName: AnsiString;
      procedure pm_SetLogMachineName(const Value: AnsiString);
        {-}
      function  pm_GetLogFileName: AnsiString;
      procedure pm_SetLogFileName(const Value: AnsiString);
        {-}
    protected
    // internal methods
      function  CheckResources: AnsiString;
        override;
        {-}
      procedure Release;
        override;
        {-}
    protected
    // internal properties
      {$IfDef l3UseOleClipboard}
      property ClipboardData: IDataObject
        read f_ClipboardData
        write f_ClipboardData;
        {-}
      {$EndIf l3UseOleClipboard}
    public
    // internal properties
      {$IfDef l3UseOleClipboard}
      property ClipboardDataR: IDataObject
        read f_ClipboardData;
        {-}
      {$EndIf l3UseOleClipboard}
    public
    // public methods
      constructor Create{(anOwner: TObject = nil)};
        //override;
        {- P - адрес указателя куда будет положен Self}
      function  PeekMessage(var Msg      : TMsg;
                            Wnd          : HWnd;
                            MsgFilterMin : UINT;
                            MsgFilterMax : UINT;
                            RemoveMsg    : UINT): Bool;
        {* - достать сообщение из очереди событий окна. (см. Windows.PeekMessage) }
      function  TranslateMessage(var Msg: TMsg): Bool;
        {-}
      function  PeekString(Handle         : hWnd;
                           const aFirst   : Tl3PCharLen;
                           CCP            : Tl3ConvertCharProc;
                           aWantSoftEnter : Boolean;
                           aRepeat        : Long = 1): Il3CString;
        {* - получить введенную строку из очереди событий окна. }
      function  GetDC(Wnd: hWnd): hDC;
        {* - получить DC для окна. (см. Windows.GetDC) }
      function  GetDCEx(Wnd: hWnd; Rgn: Tl3Rgn; Flags: Cardinal): hDC;
        {* - получить DC для окна. (см. Windows.GetDCEx) }
      function  ReleaseDC(Wnd: hWnd; DC: hDC): Integer;
        {* - освободить DC. (см. Windows.ReleaseDC) }
      procedure IncRgnCount;
        {-}
      procedure DecRgnCount;
        {-}
      function  ReleaseHandle(H: THandle): THandle;
        {-}
      procedure Exception2Log(E: Exception);
        {* - вывести Exception в лог. }
      procedure Msg2Log(const S: AnsiString; aMsgLevel: Byte = l3_msgAll); overload;
        {* - вывести сообщение в лог. }
      procedure Msg2Log(const S : AnsiString; const Args: array of const; aMsgLevel: Byte = l3_msgAll); overload;
        {* - вывести сообщение в лог. }
      procedure OpenLog;
        {-}
      procedure CloseLog;
        {* - закрывает лог и выключает перехват ошибок. }  
      procedure DisableExceptionToLog;
      procedure EnableExceptionToLog;

      procedure Str2Log(const S: AnsiString); overload;
        {* - вывести строку в лог. }
      procedure Time2Log(const S     : AnsiString;
                         var theLast : DWord);
        {* - вывести сообщение в лог - с указанием дельты времени. }
      procedure Stack2Log(const S: AnsiString = '');
        {* - вывести текущий стек в лог. }
      procedure MemUsage2Log(Strict: Boolean = False);
        {* - вывести в лог статистику использования памяти. }
      procedure ClearClipboard(aValue: Integer = IDNo);
        {-}
      function  CheckClipboard(const anAskProc: Tl3AskClearClipboardProc = nil): Integer;
        {-}
      procedure Beep;
        {-}
      function  GetMM(aForFree : Boolean): Tl3ObjectsMemoryManager;
        {-}
      function  GetBoxMM: Tl3BoxMemoryManager;
        {-}
      function  GetStamp: TGUID;
        {-}
      function  IsLocalIntf(const anIntf: Il3Base): Boolean;
        {-}
      procedure IncLogIndent;
        {-}
      procedure DecLogIndent;
        {-}
      function  SetClipboardData(const aData: IDataObject): Boolean;
      procedure Str2Log(const S : AnsiString; const Args: array of const); overload;
        {-}
    public
    // public properties
      property Keyboard: Tl3Keyboard
        read pm_GetKeyboard
        write pm_SetKeyboard;
        {* - состояние клавиатуры. }
      property Mouse: Tl3Mouse
        read pm_GetMouse
        write pm_SetMouse;
        {* - состояние мыши. }
      property _Windows: Tl3Windows
        read pm_GetWindows
        write pm_SetWindows;
        {-}
      property AppTitle: AnsiString
        read pm_GetAppTitle;
        {* - заголовок текущего приложения. }
      property DCCount: Long
        read f_DCCount;
        {* - сколько DC распределено? }
      property RgnCount: Long
        read f_RgnCount;
        {* - сколько регионов распределено? }
      property MessageLevel: Byte
        read f_MessageLevel
        write f_MessageLevel;
         {* - уровень логгирования сообщений }
      property LogMachineName: AnsiString
        read pm_GetLogMachineName
        write pm_SetLogMachineName;
         {* - Имя машины которое будет писаться в лог }
      property LogFileName: AnsiString
        read pm_GetLogFileName
        write pm_SetLogFileName;
         {* - Имя файла лога }
  end;//Tl3System

  Tl3Thread = class(TThread)
   {* Нить процесса. }
    protected
    {internal methods}
      procedure Release;
        virtual;
        {* - метод, вызываемый при уничтожении нити. }
    public
    {public methods}
      destructor Destroy;
        override;
        {* - деструктор нити. Для освобождения ресурсов надо перекрывать метод Release. }
      procedure CallSynchronize(Method: TThreadMethod);
        {-}
    public
    {public properties}
      property Terminated;
        {* - нить прервана? }
  end;{Tl3Thread}

  Tl3ToolThread = class;
  Rl3ToolThread = class of Tl3ToolThread;

  Tl3ThreadContainer = class(Tl3ProtoObject)
   {* Контейнер для нити процесса. }
    private
    //internal fields
      f_ToolThreadClass : Rl3ToolThread;
      f_ToolThread      : Tl3ToolThread;
      f_Suspended       : Bool;
      f_Terminated      : Bool;
      f_Executed        : Boolean;
    protected
    //property methods
      function  pm_GetSuspended: Bool;
      procedure pm_SetSuspended(Value: Bool);
        {-}
    protected
    //internal methods
      procedure DoExecute;
        virtual;
        abstract;
        {* - основная процедура нити. Для перекрытия в потомках. }
      procedure Execute;
        {* - основная процедура нити. }
      procedure FreeThread;
        {* - освобождает Thread'у. }
      procedure ThreadTerminate(Sender: TObject);
        {-}
      procedure Release;
        override;
        {-}
      function  NeedContinue: Bool;
        virtual;
        {* - необходимо продолжить выполнение нити? }
    protected
    //internal properties
      property ToolThread: Tl3ToolThread
        read f_ToolThread;
        {* - нить в которой выполняется логика работы контейнера. }
    public
    //public methods
      constructor Create(aToolThreadClass: Rl3ToolThread = nil);
        reintroduce;
        virtual;
        {* - создать контейнер нити. }
      procedure Terminate;
        {* - прервать нить. }      
      procedure Synchronize(aMethod: TThreadMethod);
        {* - синхронизовать вызов метода с основной нитью процесса. }
      procedure WaitFor;
        {-}
      function  NeedThread: Bool;
        virtual;
        {* - нужно ли делать "настоящую" нить или выполнять в текущей? }  
    public
    //public properties
      property Suspended: Bool
        read pm_GetSuspended
        write pm_SetSuspended;
        {* - нить в спящем режиме? }
      property Terminated: Bool
        read f_Terminated;
        {* - нить прервана? }
      property Executed: Boolean
        read f_Executed;
        {* - Нить заврешила работу?}
  end;//Tl3ThreadContainer

  Tl3ToolThread = class(Tl3Thread)
   {* Нить, вложенная в контейнер. }
    private
    //internal fields
      f_ThreadContainer : Tl3ThreadContainer;
    protected
    //internal methods
      procedure Execute;
        override;
        {-}
  end;//Tl3ToolThread

procedure l3AnalizeCodePage(Buf, BufEnd: PAnsiChar; var OEMCount, ANSICount: Long);
  {* - анализирует частоты символов разных кодовых страниц в буфере. }
procedure l3AnalizeCodePageEx(Buf, BufEnd: PAnsiChar;
                             var OEMCount, ANSICount, GraphCount: Long;
                             var GraphCounts: T_cc_GraphCounts);
  {* - анализирует частоты символов разных кодовых страниц в буфере. }
function  l3AnalizeCodePageExEx(Buf, BufEnd: PAnsiChar): Long;
  {* - анализирует кодовую страницу буфера. }
function  l3AnalizeCodePageBuf(Buf: PAnsiChar; Len: Long): Long;
  {* - анализирует кодовую страницу буфера. }
function  l3Use(O: TObject): Pointer;
  overload;
  {* - увеличивает объекту счетчик ссылок. }
function  l3Use(O: Tl3ProtoObject): Pointer;
  overload;
  {* - увеличивает объекту счетчик ссылок. }
function  l3Use(O: Tl3DataContainerWithoutIUnknownPrim): Pointer;
  overload;
  {* - увеличивает объекту счетчик ссылок. }
procedure l3Set(var theStr: Tl3String; const aStr: Tl3WString);
  overload;
procedure l3Set(var theStr: Tl3String; const aStr: Il3CString);
  overload;  
function  l3Set(var F; V: TObject): Bool;
  overload;
  {* - присваивает переменной F объект со счетчиком ссылок V. }
function  l3Set(var F; V: Tl3ProtoObject): Bool;
  overload;
  {* - присваивает переменной F объект со счетчиком ссылок V. }
function  l3Set(var F; V: Tl3DataContainerWithoutIUnknownPrim): Bool;
  overload;
  {* - присваивает переменной F объект со счетчиком ссылок V. }
procedure l3Swap(var A, B : Cardinal);
  overload;
  {* - обменивает переменные значениями. }
procedure l3Swap(var A, B : Integer);
  overload;
  {* - обменивает переменные значениями. }
procedure l3Swap(var A, B : Pointer);
  overload;
  {* - обменивает переменные значениями. }
procedure l3Swap(var A, B; aSize: Integer);
  overload;
  {* - обменивает переменные значениями. }
procedure l3Free(var P);
  overload;
  {* - освобождает объект со счетчиком ссылок и очищает переменную P ПЕРЕД освобождением объекта.}
function  l3Free(var P: IUnknown): Pointer;
  overload;
  {-}
procedure l3FreeGlobal(var P);
  {* - освобождает ГЛОБАЛЬНЫЙ объект со счетчиком ссылок и очищает переменную P ПОСЛЕ освобождения объекта.
       Нужна для того, чтобы в процессе его освобождения была возможность обращаться к правильному экзаемпляру глобального объекта. }
function  l3IOK(Status: HRESULT): Bool;
  {* - проверяет Status, возвращаемый, методами интерфейсов на успех. }
function  l3IFail(Status: HRESULT): Bool;
  {* - проверяет Status, возвращаемый, методами интерфейсов на неуспех. }
function  l3System: Tl3System;
  {* - возвращает глобальный менеджер ресурсов. }
function  l3SystemDown: Boolean;
  {-}
function  l3MemUtilsDown: Boolean;
  {-}
function  l3LocalStub(Action: Pointer): Pointer;
  {*- делает заглушку для локальной процедуры.
      Локальная процедура должна быть регистровой (она таковой является по умолчанию или может быть объявлена register)
      Количество параметров локальной процедуры не может быть более двух (используются регистры EAX, EDX)
      Локальной процедура может быть объявлена как функция (возвращаемое значение помещается в EAX)}
      
function  l3PasLocalStub1(Action: Pointer): Pointer;
  {*- делает заглушку для локальной процедуры.
      Локальная процедура должна быть регистровой (она таковой является по умолчанию)
      Полученная обертка может быть подана в функцию, в которой прототип параметра-функции объявлен как глобальная
      функция с соглашением вызова Pascal и одним параметром}

function  l3PasLocalStub2(Action: Pointer): Pointer;
  {*- делает заглушку для локальной процедуры.
      Локальная процедура должна быть регистровой (она таковой является по умолчанию)
      Полученная обертка может быть подана в функцию, в которой прототип параметра-функции объявлен как глобальная
      функция с соглашением вызова Pascal и двумя параметрами}

function  l3PasLocalStub3(Action: Pointer): Pointer;
  {*- делает заглушку для локальной процедуры.
      Локальная процедура должна быть регистровой (она таковой является по умолчанию)
      Полученная обертка может быть подана в функцию, в которой прототип параметра-функции объявлен как глобальная
      функция с соглашением вызова Pascal и тремя параметрами}

function  l3StdLocalStub1(Action: Pointer): Pointer;
  {*- делает заглушку для локальной процедуры.
      Локальная процедура должна быть регистровой (она таковой является по умолчанию)
      Полученная обертка может быть подана в функцию, в которой прототип параметра-функции объявлен как глобальная
      функция с соглашением вызова StdCall и одним параметром}

function  l3StdLocalStub2(Action: Pointer): Pointer;
  {*- делает заглушку для локальной процедуры.
      Локальная процедура должна быть регистровой (она таковой является по умолчанию)
      Полученная обертка может быть подана в функцию, в которой прототип параметра-функции объявлен как глобальная
      функция с соглашением вызова StdCall и двумя параметрами}

function  l3StdLocalStub3(Action: Pointer): Pointer;
  {*- делает заглушку для локальной процедуры.
      Локальная процедура должна быть регистровой (она таковой является по умолчанию)
      Полученная обертка может быть подана в функцию, в которой прототип параметра-функции объявлен как глобальная
      функция с соглашением вызова StdCall и тремя параметрами}

procedure l3FreeLocalStub(var Stub: Pointer);
  {* - освобождает заглушку (Stub) для локальной процедуры, созданную процедурами l3LocalStub и т. д. }

function  l3L2IA(Action: Pointer): Tl3IteratorAction;
  {* - делает заглушку для локальной процедуры. }
procedure l3FreeIA(var Stub: Tl3IteratorAction);
  {* - освобождает заглушку для локальной процедуры. }
function  l3L2FA(Action: Pointer): Tl3FreeAction;
  {* - делает заглушку для локальной процедуры. }
procedure l3FreeFA(var Stub: Tl3FreeAction);
  {* - освобождает заглушку для локальной процедуры. }
function l3KW(const aName : AnsiString;
              anID        : Integer): Tl3KW;
  {-}

type
  Tl3Bytes = array of Byte;
function l3ByteArray(const anArray: array of Byte): Tl3Bytes;
  {-}

function l3FormatArray(const anArray: array of Tl3ClipboardFormat): Tl3ClipboardFormats;
  {-}
function l3FormatArrayHas(const anArray : array of Tl3ClipboardFormat;
                          aValue        : Tl3ClipboardFormat): Boolean;
  {-}
function l3SmallIntArray(const anArray: array of SmallInt): TSmallIntArray;
  {-}
function l3LongArray(const anArray: array of Long): TLongArray;
  {-}
function l3LongArrayCompare(const A, B: array of Long): Long;
  {-}
function l3CStringArray(const anArray: array of Il3CString): Tl3CStringArray;
  {-}
function l3CStringArrayFromS(const anArray: array of AnsiString): Tl3CStringArray;
  {-}
function l3CStringArrayEQ(const A, B: array of Il3CString): Boolean;
  {-}
function l3CStringArrayEmpty(const A: array of Il3CString): Boolean;
  {-}
function l3StringArray(const anArray: array of AnsiString): Tl3StringArray;
  {-}
function l3StringArrayEQ(const A, B: array of AnsiString): Boolean;
  {-}
function l3StringArrayEmpty(const A: array of AnsiString): Boolean;
  {-}
function l3CatFormatArray(const A: array of Tl3ClipboardFormat;
                          const B: array of Tl3ClipboardFormat): Tl3ClipboardFormats;
  {-}
function l3CatLongArray(const A : array of Long;
                        const B : array of Long): TLongArray;
  {-}
function l3CL(const A : array of Long;
              B : Long): TLongArray;
  {-}
procedure l3RaiseOSError(anError: Integer; const aTail: AnsiString = '');
  {-}
function  l3CStr(aStr: PResStringRec): Il3CString;
  overload;
function  l3CStr(const aNode: Il3SimpleNode): Il3CString;
  overload;
function  l3CStr(const aStr: AnsiString): Il3CString;
  overload;
function  l3CStr(const aStr: WideString): Il3CString;
  overload;
function  l3CStr(const aStr: Tl3WString): Il3CString;
  overload;
function  l3CStr(const aStr: Tl3PrimString): Il3CString;
  overload;
  {-}

procedure l3Move(const Source; var Dest; Count: Cardinal);
  {-}
procedure Move;
  {* - это чтобы не компилировался стандартный вызов Move, вместо него надо использовать l3Move. }
procedure l3ZeroMemory(aDest: Pointer; aLen: Cardinal);
  {-}
procedure ZeroMemory;
  {* - это чтобы не компилировался стандартный вызов ZeroMemory, вместо него надо использовать l3ZeroMemory. }
procedure l3FillChar(var X; Count: Integer; Value: Byte);
  overload;
procedure l3FillChar(var X; Count: Integer);
  overload;
  {-}
procedure FillChar;
  {* - это чтобы не компилировался стандартный вызов FillChar, вместо него надо использовать l3FillChar. }
function MMX_Supported: Boolean;

const
 PM_NOREMOVE = 0;
 PM_REMOVE   = 1;
 PM_NOYELD   = 2;

var
  g_l3System : Tl3SystemPrim = nil;
  g_FuckAddress : Pointer = nil;

{$IfOpt D+}
procedure __BP(const aStr : AnsiString = '');
// - специальная процедура для упрощения отладки примесей,
//   её вызов надо вставить там, где хочется поставить Break-Point в примеси.
{$EndIf D+}

implementation

uses
  SysConst,
  RTLConsts,

  {$IfDef l3UseOleClipboard}
  ActiveX,
  {$EndIf l3UseOleClipboard}

  {$IfDef l3ConsoleApp}
  {$Else  l3ConsoleApp}
  {$IfNDef NoVCL}
  Forms,
  Controls,
  {$EndIf  NoVCL}
  {$EndIf l3ConsoleApp}
  Messages,

  {$IfDef l3TraceMemAllocStat}
  {$If Declared(Gm0EXCLibDefSrv)}
  IniFiles,
  {$IfEnd Declared(Gm0EXCLibDefSrv)}
  {$EndIf l3TraceMemAllocStat}

  l3Bits,
  l3Except,
  //l3Const,
  l3Message,
  //l3SimpleMM,
  //l3BoxMM,
  l3MemorySizeUtils,
  l3Memory,
  //l3Stream,
  l3ClassCacheEntry
  {$IfDef l3TraceClasses}
  ,
  l3LeakObjects
  {$EndIf l3TraceClasses}
  ,
  l3String,
  l3InterfacedComponent,
  l3InterfacedString

  ,
  l3CEmptyString,
  l3OneByteCString,
  l3TwoByteCString,
  l3FourByteCString,
  l3Interlocked
  ;

{$If not Defined(l3TraceFill)}
 {$IfOpt O-}
  {$O+}
  {$Define _Opt_}
 {$EndIf}
{$IfEnd}

{$IfDef l3UseMMX}

type
  Tl3MoveProc = procedure (const Source; var Dest);

procedure M0(const Source; var Dest);
begin
end;

procedure M1(const Source; var Dest);
begin
 PAnsiChar(@Dest)^ := PAnsiChar(@Source)^;
end;

procedure M2(const Source; var Dest);
begin
 PWord(@Dest)^ := PWord(@Source)^;
end;

procedure M3(const Source; var Dest);
  register;
asm
   mov     cx, word ptr [eax]
   mov     al, byte ptr [eax + 2] // !!! eax теперь испорчен !!!
   mov     word ptr [edx], cx
   mov     byte ptr [edx + 2], al
end;//asm

procedure M4(const Source; var Dest);
begin
 PLong(@Dest)^ := PLong(@Source)^;
end;

procedure M5(const Source; var Dest);
  register;
asm
   mov     ecx, [eax]
   mov     al, byte ptr [eax + 4] // !!! eax теперь испорчен !!!
   mov     [edx], ecx
   mov     byte ptr [edx + 4], al
end;//asm

procedure M6(const Source; var Dest);
  register;
asm
   mov     ecx, [eax]
   mov     ax, word ptr [eax + 4] // !!! eax теперь испорчен !!!
   mov     [edx], ecx
   mov     word ptr [edx + 4], ax
end;//asm

procedure M7(const Source; var Dest);
  register;
asm
   movd    mm0, [eax]
   mov     cx, word ptr [eax + 4]
   mov     al, byte ptr [eax + 6] // !!! eax теперь испорчен !!!
   movd    [edx], mm0
   mov     word ptr [edx + 4], cx
   mov     byte ptr [edx + 6], al
   emms
end;//asm

procedure M8(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    [edx], mm0
   emms
end;//asm

procedure M9(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   mov     cl, byte ptr [eax + 8]
   movq    [edx], mm0
   mov     byte ptr [edx + 8], cl
   emms
end;//asm

procedure M10(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   mov     cx, word ptr [eax + 8]
   movq    [edx], mm0
   mov     word ptr [edx + 8], cx
   emms
end;//asm

procedure M11(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   mov     cx, word ptr [eax + 8]
   mov     al, byte ptr [eax + 10] // !!! eax теперь испорчен !!!
   movq    [edx], mm0
   mov     word ptr [edx + 8], cx
   mov     byte ptr [edx + 10], al
   emms
end;//asm

procedure M12(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   mov     ecx, [eax + 8]
   movq    [edx], mm0
   mov     [edx + 8], ecx
   emms
end;//asm

procedure M13(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   mov     ecx, [eax + 8]
   mov     al,  byte ptr [eax + 12] // !!! eax испорчен !!!
   movq    [edx], mm0
   mov     [edx + 8], ecx
   mov     byte ptr [edx + 12], al
   emms
end;//asm

procedure M14(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   mov     ecx, [eax + 8]
   mov     ax,  word ptr [eax + 12] // !!! eax испорчен !!!
   movq    [edx], mm0
   mov     [edx + 8], ecx
   mov     word ptr [edx + 12], ax
   emms
end;//asm

procedure M15(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movd    mm1, [eax + 8]
   mov     cx,  word ptr [eax + 12]
   mov     al,  byte ptr [eax + 14] // !!! eax испорчен !!!
   movq    [edx], mm0
   movd    [edx + 8], mm1
   mov     word ptr [edx + 12], cx
   mov     byte ptr [edx + 14], al
   emms
end;//asm

procedure M16(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   movups  [edx], xmm0
   emms
end;//asm
{$Else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   emms
end;//asm
{$EndIf l3UseSSE}

procedure M17(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   mov     cl, byte ptr [eax + 16]
   movups  [edx], xmm0
   mov     byte ptr [edx + 16], cl
   emms
end;//asm
{$Else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   mov     cl, byte ptr [eax + 16]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   mov     byte ptr [edx + 16], cl
   emms
end;//asm
{$EndIf l3UseSSE}

procedure M18(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   mov     cx, word ptr [eax + 16]
   movups  [edx], xmm0
   mov     word ptr [edx + 16], cx
   emms
end;//asm
{$else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   mov     cx, word ptr [eax + 16]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   mov     word ptr [edx + 16], cx
   emms
end;//asm
{$EndIf l3UseSSE}

procedure M19(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   mov     cx, word ptr [eax + 16]
   mov     al, byte ptr [eax + 18] // !!! eax испорчен !!!
   movups  [edx], xmm0
   mov     word ptr [edx + 16], cx
   mov     byte ptr [edx + 18], al
   emms
end;//asm
{$else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   mov     cx, word ptr [eax + 16]
   mov     al, byte ptr [eax + 18] // !!! eax испорчен !!!
   movq    [edx], mm0
   movq    [edx + 8], mm1
   mov     word ptr [edx + 16], cx
   mov     byte ptr [edx + 18], al
   emms
end;//asm
{$EndIf l3UseSSE}

procedure M20(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   mov     ecx,  [eax + 16]
   movups  [edx], xmm0
   mov     [edx + 16], ecx
   emms
end;//asm
{$else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   mov     ecx, [eax + 16]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   mov     [edx + 16], ecx
   emms
end;//asm
{$EndIf l3UseSSE}

procedure M21(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   mov     ecx,  [eax + 16]
   mov     al, byte ptr [eax + 20] // !!! eax испорчен !!!
   movups  [edx], xmm0
   mov     [edx + 16], ecx
   mov     [edx + 20], al
   emms
end;//asm
{$else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   mov     ecx, [eax + 16]
   mov     al, byte ptr [eax + 20] // !!! eax испорчен !!!
   movq    [edx], mm0
   movq    [edx + 8], mm1
   mov     [edx + 16], ecx
   mov     byte ptr [edx + 20], al
   emms
end;//asm
{$EndIf l3UseSSE}

procedure M22(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   mov     ecx,  [eax + 16]
   mov     ax, word ptr [eax + 20] // !!! eax испорчен !!!
   movups  [edx], xmm0
   mov     [edx + 16], ecx
   mov     word ptr [edx + 20], ax
   emms
end;//asm
{$else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   mov     ecx, [eax + 16]
   mov     ax, word ptr [eax + 20] // !!! eax испорчен !!!
   movq    [edx], mm0
   movq    [edx + 8], mm1
   mov     [edx + 16], ecx
   mov     word ptr [edx + 20], ax
   emms
end;//asm
{$EndIf l3UseSSE}

procedure M23(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movd    mm2, [eax + 16]
   mov     cx, word ptr [eax + 20]
   mov     al, byte ptr [eax + 22] // !!! eax испорчен !!!
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movd    [edx + 16], mm2
   mov     word ptr [edx + 20], cx
   mov     byte ptr [edx + 22], al
   emms
end;//asm

procedure M24(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   emms
end;//asm

procedure M26(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   mov     cx, word ptr [eax + 24]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   mov     word ptr [edx + 24], cx
   emms
end;//asm

procedure M28(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   mov     ecx, [eax + 24]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   mov     [edx + 24], ecx
   emms
end;//asm

procedure M30(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   mov     ecx, [eax + 24]
   mov     ax,  word ptr [eax + 28] // !!! eax испорчен !!!
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   mov     [edx + 24], ecx
   mov     word ptr [edx + 28], ax
   emms
end;//asm

procedure M32(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   movups  xmm1, [eax + 16]
   movups  [edx], xmm0
   movups  [edx + 16], xmm1
   emms
end;//asm
{$Else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   movq    mm3, [eax + 24]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   movq    [edx + 24], mm3
   emms
end;//asm
{$EndIf  l3UseSSE}

procedure M36(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   movq    mm3, [eax + 24]
   mov     ecx, [eax + 32]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   movq    [edx + 24], mm3
   mov     [edx + 32], ecx
   emms
end;//asm

procedure M40(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   movq    mm3, [eax + 24]
   movq    mm4, [eax + 32]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   movq    [edx + 24], mm3
   movq    [edx + 32], mm4
   emms
end;//asm

procedure M48(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   movups  xmm1, [eax + 16]
   movups  xmm2, [eax + 32]
   movups  [edx], xmm0
   movups  [edx + 16], xmm1
   movups  [edx + 32], xmm2
   emms
end;//asm
{$Else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   movq    mm3, [eax + 24]
   movq    mm4, [eax + 32]
   movq    mm5, [eax + 40]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   movq    [edx + 24], mm3
   movq    [edx + 32], mm4
   movq    [edx + 40], mm5
   emms
end;//asm
{$EndIf l3UseSSE}

procedure M56(const Source; var Dest);
  register;
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   movq    mm3, [eax + 24]
   movq    mm4, [eax + 32]
   movq    mm5, [eax + 40]
   movq    mm6, [eax + 48]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   movq    [edx + 24], mm3
   movq    [edx + 32], mm4
   movq    [edx + 40], mm5
   movq    [edx + 48], mm6
   emms
end;//asm

procedure M64(const Source; var Dest);
  register;
{$IfDef l3UseSSE}
asm
   movups  xmm0, [eax]
   movups  xmm1, [eax + 16]
   movups  xmm2, [eax + 32]
   movups  xmm3, [eax + 48]
   movups  [edx], xmm0
   movups  [edx + 16], xmm1
   movups  [edx + 32], xmm2
   movups  [edx + 48], xmm3
   emms
end;//asm
{$Else  l3UseSSE}
asm
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   movq    mm3, [eax + 24]
   movq    mm4, [eax + 32]
   movq    mm5, [eax + 40]
   movq    mm6, [eax + 48]
   movq    mm7, [eax + 56]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   movq    [edx + 24], mm3
   movq    [edx + 32], mm4
   movq    [edx + 40], mm5
   movq    [edx + 48], mm6
   movq    [edx + 56], mm7
   emms
end;//asm
{$EndIf l3UseSSE}

{$IfOpt R+}
 {$R-}
 {$Define _Range_}
{$EndIf}

{$IfNDef l3UseSSE}
procedure MoveBy8(const Source; var Dest; Count: Cardinal);
  register;
asm
   CMP     edx, eax
   JA      @@down
   JE      @@exit

@@lp1:
   movq    mm0, [eax]
   movq    [edx], mm0
   add     eax, 8
   add     edx, 8
   //dec     ecx
   //jnz     @@lp1
   loop    @@lp1

   JMP     @@done

@@down:

@@lp2:
   movq    mm0, [eax + ecx * 8 - 8]
   movq    [edx + ecx * 8 - 8], mm0
   //dec     ecx
   //jnz     @@lp2
   loop    @@lp2

@@done:
   emms

@@exit:
end;//asm
{$EndIf l3UseSSE}

procedure MoveBy16(const Source; var Dest; Count: Cardinal);
  register;
{$IfDef l3UseSSE}
asm
   CMP     edx, eax
   JA      @@down
   JE      @@exit

@@lp1:
   movups  xmm0, [eax]
   movups  [edx], xmm0
   add     eax, 16
   add     edx, 16
   loop    @@lp1

   JMP     @@done

@@down:
   shl     ecx, 4
   lea     eax, [eax + ecx - 16]
   lea     edx, [edx + ecx - 16]
   shr     ecx, 4

@@lp2:
   movups  xmm0, [eax]
   movups  [edx], xmm0
   sub     eax, 16
   sub     edx, 16
   loop    @@lp2

@@done:
   emms

@@exit:
end;//asm
{$Else  l3UseSSE}
asm
   CMP     edx, eax
   JA      @@down
   JE      @@exit

@@lp1:
   movq    mm1, [eax]
   movq    mm0, [eax + 8]
   movq    [edx], mm1
   movq    [edx + 8], mm0
   add     eax, 16
   add     edx, 16
   loop    @@lp1

   JMP     @@done

@@down:
   shl     ecx, 4
   lea     eax, [eax + ecx - 8]
   lea     edx, [edx + ecx - 8]
   shr     ecx, 4

@@lp2:
   movq    mm0, [eax]
   movq    mm1, [eax - 8]
   movq    [edx], mm0
   movq    [edx - 8], mm1
   sub     eax, 16
   sub     edx, 16
   loop    @@lp2

@@done:
   emms

@@exit:
end;//asm
{$EndIf l3UseSSE}

procedure MoveBy32(const Source; var Dest; Count: Cardinal);
  register;
{$IfDef l3UseSSE}
asm
   CMP     edx, eax
   JA      @@down
   JE      @@exit

@@lp1:
   movups  xmm0, [eax]
   movups  xmm1, [eax + 16]
   movups  [edx], xmm0
   movups  [edx + 16], xmm1
   add     eax, 32
   add     edx, 32
   loop    @@lp1

   JMP     @@done

@@down:
   shl     ecx, 5
   lea     eax, [eax + ecx - 16]
   lea     edx, [edx + ecx - 16]
   shr     ecx, 5

@@lp2:
   movups  xmm0, [eax]
   movups  xmm1, [eax - 16]
   movups  [edx], xmm0
   movups  [edx - 16], xmm1
   sub     eax, 32
   sub     edx, 32
   loop    @@lp2

@@done:
   emms

@@exit:
end;//asm
{$Else  l3UseSSE}
asm
   CMP     edx, eax
   JA      @@down
   JE      @@exit

@@lp1:
   movq    mm0, [eax]
   movq    mm1, [eax + 8]
   movq    mm2, [eax + 16]
   movq    mm3, [eax + 24]
   movq    [edx], mm0
   movq    [edx + 8], mm1
   movq    [edx + 16], mm2
   movq    [edx + 24], mm3
   add     eax, 32
   add     edx, 32
   loop    @@lp1

   JMP     @@done

@@down:
   shl     ecx, 5
   lea     eax, [eax + ecx - 8]
   lea     edx, [edx + ecx - 8]
   shr     ecx, 5

@@lp2:
   movq    mm0, [eax]
   movq    mm1, [eax - 8]
   movq    mm2, [eax - 16]
   movq    mm3, [eax - 24]
   movq    [edx], mm0
   movq    [edx - 8], mm1
   movq    [edx - 16], mm2
   movq    [edx - 24], mm3
   sub     eax, 32
   sub     edx, 32
   loop    @@lp2

@@done:
   emms

@@exit:
end;//asm
{$EndIf l3UseSSE}

const
 MoveProcs8 : array [0..8] of  Tl3MoveProc = (M0, M8, M16, M24, M32, M40, M48, M56, M64);

const
 MoveProcs16 : array [0..4] of  Tl3MoveProc = (M0, M16, M32, M56, M64);

procedure Move8(const Source; var Dest; Count: Cardinal);
{$IfDef l3AsmMove}
  register;
asm
   cmp     ecx, Type(MoveProcs8) / Type(Tl3MoveProc)
   jnb     @@notTable
   mov     ecx, [ecx * Type(Tl3MoveProc) + MoveProcs8]
   jmp     ecx

@@notTable:
   test    ecx, 1 // - проверяеи четность

   {$IfNDef l3UseSSE}
   jnz     MoveBy8
   {$Else   l3UseSSE}
   jz      @@Even

@@Odd:
   dec     ecx // - уменьшаем длину
   cmp     eax, edx
   jb      @@Down

   movq    mm0, [eax]
   movq    [edx], mm0
   add     eax, 8
   add     edx, 8
   jmp     @@Even

@@Down:
   movq    mm0, [eax + ecx * 8]
   movq    [edx + ecx * 8], mm0
   {$EndIf l3UseSSE}

@@Even:
   shr     ecx, 1
   cmp     ecx, Type(MoveProcs16) / Type(Tl3MoveProc)
   jnb     @@notTable1
   mov     ecx, [ecx * Type(Tl3MoveProc) + MoveProcs16]
   jmp     ecx

@@notTable1:
   test    ecx, 1 // - проверяеи четность
   jnz     MoveBy16
   shr     ecx, 1
   jmp     MoveBy32
   //jmp     MoveBy16
end;
{$Else  l3AsmMove}
begin
 if (Count <= High(MoveProcs8)) then
  MoveProcs8[Count](Source, Dest)
 else
 if (Count mod 2 = 0) then
 // - двигаем 16-ки
  MoveBy16(Source, Dest, Count shr 1)
 else
  MoveBy8(Source, Dest, Count);
end;
{$EndIf l3AsmMove}

const
 MoveProcs4 : array [0..10] of  Tl3MoveProc = (M0, M4, M8, M12, M16, M20, M24, M28, M32, M36, M40);

{$IfDef l3AsmMove}
procedure MoveBy4Up(const Source; var Dest; Count: Cardinal);
  register;
asm
   cmp     ecx, Type(MoveProcs4) / Type(Tl3MoveProc)
   jnb     @@notTable
   mov     ecx, [ecx * Type(Tl3MoveProc) + MoveProcs4]
   jmp     ecx

@@notTable:
   test    ecx, 1 // - проверяеи четность
   jz      @@Even

@@Odd:
   dec     ecx // - уменьшаем длину

   movd    mm0, [eax]
   movd    [edx], mm0
   emms
   add     eax, 4
   add     edx, 4
@@Even:
   shr     ecx, 1
   jmp     Move8{Up}
end;
{$EndIf  l3AsmMove}

procedure MoveBy4(const Source; var Dest; Count: Cardinal);
{$IfDef l3AsmMove}
  register;
asm
   cmp     ecx, Type(MoveProcs4) / Type(Tl3MoveProc)
   jnb     @@notTable
   mov     ecx, [ecx * Type(Tl3MoveProc) + MoveProcs4]
   jmp     ecx

@@notTable:
   test    ecx, 1 // - проверяеи четность
   jz      @@Even

@@Odd:
   dec     ecx // - уменьшаем длину
   cmp     eax, edx
   jb      @@Down

   movd    mm0, [eax]
   movd    [edx], mm0
   emms
   add     eax, 4
   add     edx, 4
   shr     ecx, 1
   jmp     Move8
@@Down:
   movd    mm0, [eax + ecx * 4]
   movd    [edx + ecx * 4], mm0
   emms

@@Even:
   shr     ecx, 1
   jmp     Move8
end;
{$Else  l3AsmMove}
begin
 if (Count <= High(MoveProcs4)) then
  MoveProcs4[Count](Source, Dest)
 else
 if (Count mod 2 = 0) then
 // - двигаем 8-ки
  Move8(Source, Dest, Count shr 1)
 else
 begin
  // - выравниваем на 1 long
  Dec(Count);
  if (Cardinal(@Source) > Cardinal(@Dest)) then
  begin
   PLong(@Dest)^ := PLong(@Source)^;
   Move8(PLong(PAnsiChar(@Source) + 4)^, PLong(PAnsiChar(@Dest) + 4)^, Count shr 1)
  end//Cardinal(@Source) > Cardinal(@Dest)
  else
  begin
   PLong(PAnsiChar(@Dest) + Count * 4)^ := PLong(PAnsiChar(@Source) + Count * 4)^;
   Move8(Source, Dest, Count shr 1);
  end;//Cardinal(@Source) > Cardinal(@Dest)
 end;//движение 4-ками
end;
{$EndIf l3AsmMove}

const
 MoveProcs2 : array [0..16] of  Tl3MoveProc = (M0, M2, M4, M6, M8, M10, M12, M14, M16, M18, M20, M22, M24, M26, M28, M30, M32);

{$IfDef l3AsmMove}
procedure MoveBy2Up(const Source; var Dest; Count: Cardinal);
  register;
asm
   cmp     ecx, Type(MoveProcs2) / Type(Tl3MoveProc)
   jnb     @@notTable
   mov     ecx, [ecx * Type(Tl3MoveProc) + MoveProcs2]
   jmp     ecx

@@notTable:
   test    ecx, 1 // - проверяеи четность
   jz      @@Even

@@Odd:
   dec     ecx // - уменьшаем длину

   push    ebx
   mov     bx, [eax]
   mov     [edx], bx
   pop     ebx
   add     eax, 2
   add     edx, 2
@@Even:
   shr     ecx, 1
   jmp     MoveBy4Up
end;
{$EndIf l3AsmMove}

procedure MoveBy2(const Source; var Dest; Count: Cardinal);
{$IfDef l3AsmMove}
  register;
asm
   cmp     ecx, Type(MoveProcs2) / Type(Tl3MoveProc)
   jnb     @@notTable
   mov     ecx, [ecx * Type(Tl3MoveProc) + MoveProcs2]
   jmp     ecx

@@notTable:
   test    ecx, 1 // - проверяеи четность
   jz      @@Even

@@Odd:
   dec     ecx // - уменьшаем длину
   cmp     eax, edx
   jb      @@Down

   push    ebx
   mov     bx, [eax]
   mov     [edx], bx
   pop     ebx
   add     eax, 2
   add     edx, 2
   shr     ecx, 1
   jmp     MoveBy4
@@Down:
   push    ebx
   mov     bx, [eax + ecx * 2]
   mov     [edx + ecx * 2], bx
   pop     ebx

@@Even:
   shr     ecx, 1
   jmp     MoveBy4
end;
{$Else  l3AsmMove}
begin
 if (Count <= High(MoveProcs2)) then
  MoveProcs2[Count](Source, Dest)
 else
 if (Count mod 2 = 0) then
 // - двигаем 4-ки
  MoveBy4(Source, Dest, Count shr 1)
 else
 begin
  // - выравниваем на 1 слово
  Dec(Count);
  if (Cardinal(@Source) > Cardinal(@Dest)) then
  begin
   PWord(@Dest)^ := PWord(@Source)^;
   MoveBy4(PWord(PAnsiChar(@Source) + 2)^, PWord(PAnsiChar(@Dest) + 2)^, Count shr 1)
  end//Cardinal(@Source) > Cardinal(@Dest)
  else
  begin
   PWord(PAnsiChar(@Dest) + Count * 2)^ := PWord(PAnsiChar(@Source) + Count * 2)^;
   MoveBy4(Source, Dest, Count shr 1);
  end;//Cardinal(@Source) > Cardinal(@Dest)
 end;//движение 2-ками
end;
{$EndIf l3AsmMove}

const
 MoveProcs1 : array [0..24] of  Tl3MoveProc =
  (M0, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M21, M22, M23, M24);

procedure l3Move(const Source; var Dest; Count: Cardinal);
{$IfDef l3AsmMove}
  register;
asm
   cmp     ecx, Type(MoveProcs1) / Type(Tl3MoveProc)
   jnb     @@notTable
   mov     ecx, [ecx * Type(Tl3MoveProc) + MoveProcs1]
   jmp     ecx

@@notTable:
   test    ecx, 1 // - проверяеи четность
   jz      @@Even

@@Odd:
   dec     ecx // - уменьшаем длину
   cmp     eax, edx
   jb      @@Down

   push    ebx
   mov     bl, [eax]
   mov     [edx], bl
   pop     ebx
   inc     eax
   inc     edx
   shr     ecx, 1
   jmp     MoveBy2Up
@@Down:
   push    ebx
   mov     bl, [eax + ecx]
   mov     [edx + ecx], bl
   pop     ebx

@@Even:
   shr     ecx, 1
   jmp     MoveBy2
end;
{$Else  l3AsmMove}
begin
 if (Count <= High(MoveProcs1)) then
  MoveProcs1[Count](Source, Dest)
 else
 if (Count mod 2 = 0) then
 // - двигаем четное число байт
  MoveBy2(Source, Dest, Count shr 1)
 else
 begin
  // - выравниваем на 1 байт
  Dec(Count);
  if (Cardinal(@Source) > Cardinal(@Dest)) then
  begin
   PAnsiChar(@Dest)^ := PAnsiChar(@Source)^;
   MoveBy2(PAnsiChar(@Source)[1], PAnsiChar(@Dest)[1], Count shr 1)
  end//Cardinal(@Source) > Cardinal(@Dest)
  else
  begin
   PAnsiChar(@Dest)[Count] := PAnsiChar(@Source)[Count];
   MoveBy2(Source, Dest, Count shr 1)
  end;//Cardinal(@Source) > Cardinal(@Dest)
 end;//нечетное число байт
end;
{$EndIf l3AsmMove}

{$IfDef _Range_}
 {$R+}
 {$Undef _Range_}
{$EndIf _Range_}

{$Else  l3UseMMX}
procedure l3Move(const Source; var Dest; Count: Cardinal);
begin
 System.Move(Source, Dest, Count);
end;
{$EndIf l3UseMMX}

procedure Move;
  {-}
begin
 Assert(false);
end;

{$IfNDef XE}
type
  Tl3FillProc = procedure (aDest: Pointer);

procedure F0(aDest: Pointer);
begin
end;//0

procedure F1(aDest: Pointer);
begin
 PAnsiChar(aDest)^ := #0;
end;//1

procedure F2(aDest: Pointer);
begin
 PWord(aDest)^ := 0;
end;//2

procedure F3(aDest: Pointer);
begin
 PWord(aDest)^ := 0;
 PAnsiChar(aDest)[SizeOf(Word)] := #0;
end;//3

procedure F4(aDest: Pointer);
begin
 PLong(aDest)^ := 0;
end;//4

procedure F5(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     byte ptr [eax + 4], cl
end;
(*begin
 PLong(aDest)^ := 0;
 PAnsiChar(aDest)[SizeOf(Long)] := #0;
end;//5*)

procedure F6(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     word ptr [eax + 4], cx
end;
(*begin
 PLong(aDest)^ := 0;
 PWord(PAnsiChar(aDest) + SizeOf(Long))^ := 0;
end;//6*)

procedure F7(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     word ptr [eax + 4], cx
   mov     byte ptr [eax + 6], cl
end;
(*begin
 PLong(aDest)^ := 0;
 PAnsiChar(aDest)[SizeOf(Long)+SizeOf(Word)] := #0;
 PWord(PAnsiChar(aDest) + SizeOf(Long))^ := 0;
end;//7*)

procedure F8(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  movq     [eax], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  fldz
  fst      qword ptr [eax]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}
(*begin
 PLarge(aDest)^ := 0;
end;//8*)

procedure F9(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
   mov     byte ptr [eax + 8], cl
end;

procedure F10(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
   mov     word ptr [eax + 8], cx
end;

procedure F11(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
   mov     word ptr [eax + 8], cx
   mov     byte ptr [eax + 10], cl
end;

procedure F12(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  movq     [eax], mm0
  movd     [eax + 8], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  fldz
  fst      qword ptr [eax]
  fst      dword ptr [eax + 8]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
   mov     [eax + 8], ecx
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F13(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
   mov     [eax + 8], ecx
   mov     byte ptr [eax + 12], cl
end;

procedure F14(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
   mov     [eax + 8], ecx
   mov     word ptr [eax + 12], cx
end;

procedure F15(aDest: Pointer);
  register;
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
   mov     [eax + 8], ecx
   mov     word ptr [eax + 12], cx
   mov     byte ptr [eax + 14], cl
end;

procedure F16(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  movq     [eax], mm0
  movq     [eax + 8], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  fldz
  fst      qword ptr [eax]
  fst      qword ptr [eax + 8]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
asm
   xor     ecx, ecx
   mov     [eax], ecx
   mov     [eax + 4], ecx
   mov     [eax + 8], ecx
   mov     [eax + 12], ecx
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F20(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  movq     [eax], mm0
  movq     [eax + 8], mm0
  movd     [eax + 16], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  fldz
  fst      qword ptr [eax]
  fst      qword ptr [eax + 8]
  fst      dword ptr [eax + 16]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
asm
   call    F10
   add     eax, 10
   call    F10
end;//20
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F24(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  movq     [eax], mm0
  movq     [eax + 8], mm0
  movq     [eax + 16], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  fldz
  fst      qword ptr [eax]
  fst      qword ptr [eax + 8]
  fst      qword ptr [eax + 16]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
asm
   call    F10
   add     eax, 10
   call    F10
   add     eax, 10
   call    F4
end;//24
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F28(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  movq     [eax], mm0
  movq     [eax + 8], mm0
  movq     [eax + 16], mm0
  movd     [eax + 24], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  fldz
  fst      qword ptr [eax]
  fst      qword ptr [eax + 8]
  fst      qword ptr [eax + 16]
  fst      dword ptr [eax + 24]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
asm
   call    F16
   add     eax, 16
   call    F12
end;//28
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure FillBy4(aDest: Pointer; aCount: Integer);
  register;
asm
  mov      ecx, edx
  push     edi
  mov      edi, eax
  xor      eax, eax
  rep      stosd
  pop      edi
end;//asm
(*begin
 System.FillChar(aDest^, aCount * 4, 0);
end;*)

procedure F32(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  movq     [eax], mm0
  movq     [eax + 8], mm0
  movq     [eax + 16], mm0
  movq     [eax + 24], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  fldz
  fst      qword ptr [eax]
  fst      qword ptr [eax + 8]
  fst      qword ptr [eax + 16]
  fst      qword ptr [eax + 24]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 32 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F36(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 4
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  movd     [eax], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 4
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  fst      dword ptr [eax]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 36 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F40(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 5
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 5
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 40 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F44(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 5
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  movd     [eax], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 5
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  fst      dword ptr [eax]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 44 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F48(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 6
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 6
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 48 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F52(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 6
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  movd     [eax], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 6
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  fst      dword ptr [eax]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 52 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F56(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 7
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 7
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 56 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F60(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 7
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  movd     [eax], mm0
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 7
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  fst      dword ptr [eax]
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 60 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F64(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 8
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 8
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 64 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F80(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 10
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 10
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 80 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F96(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 12
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 12
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 96 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure F128(aDest: Pointer);
  register;
{$IfDef l3UseMMX}
asm
  pxor     mm0, mm0
  mov      ecx, 16
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, 16
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, 128 div 4);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

procedure FillBy8(aDest: Pointer; aCount: Integer);
  register;
{$IfDef l3UseMMX}
asm
  mov      ecx, edx
  pxor     mm0, mm0
@@lp:
  movq     [eax], mm0
  add      eax, 8
  loop     @@lp
  emms
end;//asm
{$Else  l3UseMMX}
{$IfDef l3UseFPU}
asm
  mov      ecx, edx
  fldz
@@lp:
  fst      qword ptr [eax]
  add      eax, 8
  loop     @@lp
  ffree    st(0)
end;//asm
{$Else  l3UseFPU}
begin
 FillBy4(aDest, aCount * 2);
end;
{$EndIf l3UseFPU}
{$EndIf l3UseMMX}

{$IfDef l3UseSSE}
procedure FillBy16(aDest: Pointer; aCount: Integer);
  register;
asm
  mov      ecx, edx
  xorps    xmm0, xmm0
@@lp:
  movups   [eax], xmm0
  add      eax, 16
  loop     @@lp
  //emms
end;//asm
{$EndIf l3UseSSE}

const
 FillProcs : array [0..16] of  Tl3FillProc =
  (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16);
 FillProcs1 : array [5..16] of  Tl3FillProc =
  (F20, F24, F28, F32, F36, F40, F44, F48, F52, F56, F60, F64);
{$EndIf XE}

{$IfOpt R+}
 {$R-}
 {$Define _Range_}
{$EndIf}

procedure l3ZeroMemory(aDest: Pointer; aLen: Cardinal);
  {-}
{$IfDef l3TraceFill}
var
 l_Index : Integer;
{$EndIf l3TraceFill}
var
 l_I : Cardinal;
begin
(* System.FillChar(aDest^, aLen, 0);*)
//(* на время починки заменили на системную
 if (aLen <= High(FillProcs)) then
  FillProcs[aLen](aDest)
 else
 if ((aLen mod 4) <> 0) then
 begin
  System.FillChar(aDest^, aLen, 0);
  Exit;
 end//(aLen mod 4) <> 0
 else
 begin
  l_I := aLen shr 2;
  if (l_I <= High(FillProcs1)) then
   FillProcs1[l_I](aDest)
  else
  if ((l_I mod 2) <> 0) then
   FillBy4(aDest, l_I)
  else
  begin
   l_I := l_I shr 1;
   {$IfDef l3UseSSE}
   if ((l_I mod 2) <> 0) then
   {$EndIf l3UseSSE}
    FillBy8(aDest, l_I)
   {$IfDef l3UseSSE}
   else
   begin
    l_I := l_I shr 1;
    FillBy16(aDest, l_I)
   end//(l_I mod 2) <> 0
   {$EndIf l3UseSSE};
  end;//(l_I mod 2) <> 0
 end;//(aLen mod 4) <> 0
 {$IfDef l3TraceFill}
 if aLen > 0 then
  for l_Index := 0 to Pred(aLen) do
   Assert(PAnsiChar(aDest)[l_Index] = #0);
 {$EndIf l3TraceFill}
end;

{$IfDef _Range_}
 {$R+}
 {$Undef _Range_}
{$EndIf _Range_}

procedure ZeroMemory;
  {* - это чтобы не компилировался стандартный вызов ZeroMemory, вместо него надо использовать l3ZeroMemory. }
begin
 Assert(false);
end;

procedure SysFillChar(var X; Count: Integer; Value: Byte);
  register;
begin
 System.FillChar(X, Count, Value);
end;

procedure l3FillChar(var X; Count: Integer; Value: Byte);
  {-}
  register;
asm
   test    cl,cl
   jnz     SysFillChar
   jmp     l3ZeroMemory
end;//asm
(*begin
 if (Value = 0) then
  l3ZeroMemory(@X, Count)
 else
  System.FillChar(X, Count, Value);
end;*)

procedure l3FillChar(var X; Count: Integer);
  //overload;
  register;
asm
   jmp     l3ZeroMemory
end;//asm
(*begin
 l3ZeroMemory(@X, Count);
end;*)

procedure FillChar;
  {* - это чтобы не компилировался стандартный вызов FillChar, вместо него надо использовать l3FillChar. }
begin
 Assert(false);
end;

{$IfDef _Opt_}
 {$O-}
 {$Undef _Opt_}
{$EndIf _Opt_}

{$IfDef l3TraceMemAllocStat}
var
 g_MemStatInited : Boolean = false;
 g_MemStat : array [2 .. 2048] of array [Boolean] of Long;
{$EndIf l3TraceMemAllocStat}

procedure l3StatMemAlloc(aSize: Integer;
  aL3: Boolean);
begin
 {$IfDef l3TraceMemAllocStat}
 if not g_MemStatInited then
 begin
  l3FillChar(g_MemStat, SizeOf(g_MemStat), 0);
  g_MemStatInited := true;
 end;//not g_MemStatInited
 if (aSize >= Low(g_MemStat)) AND (aSize <= High(g_MemStat)) then
  Inc(g_MemStat[aSize][aL3]);
 {$EndIf l3TraceMemAllocStat}
end;

procedure l3OutMemStat;
{$IfDef l3TraceMemAllocStat}
var
 l_Index    : Long;
 {$If    Declared(Gm0EXCLibDefSrv)}
 l_FreeServ : Boolean;
 {$IfEnd Declared(Gm0EXCLibDefSrv)}
{$EndIf l3TraceMemAllocStat}
begin
 {$IfDef l3TraceMemAllocStat}
 if (g_l3System <> nil) then
  with Tl3System(g_l3System) do
  begin
   {$If Declared(Gm0EXCLibDefSrv)}
   if (Gm0EXCLibDefSrv = nil) then
   begin
    with TIniFile.Create(ChangeFileExt(ParamStr(0), '.ini')) do
     try
      Gm0EXCLibDefSrv := Tl3ExceptionsLog.Create(
       ReadString('EXE', 'MEMLOGFILE', ChangeFileExt(ParamStr(0), '.mem.log')), false);
     finally
      Free;
     end;
    l_FreeServ := true;
   end//Gm0EXCLibDefSrv = nil
   else
    l_FreeServ := false;
   try
   {$IfEnd}
    Msg2Log('MemStat Sys');
    for l_Index := Low(g_MemStat) to High(g_MemStat) do
     if (g_MemStat[l_Index][false] > 0) then
      Msg2Log(Format('%.7d %.6d', [l_Index, g_MemStat[l_Index][false]]));
    Msg2Log('MemStat L3');
    for l_Index := Low(g_MemStat) to High(g_MemStat) do
     if (g_MemStat[l_Index][true] > 0) then
      Msg2Log(Format('%.7d %.6d', [l_Index, g_MemStat[l_Index][true]]));
   {$If Declared(Gm0EXCLibDefSrv)}
   finally
    if l_FreeServ then
     FreeAndNil(Gm0EXCLibDefSrv);
   end;//try..finally
   {$IfEnd Declared(Gm0EXCLibDefSrv)}
  end;//g_l3System
 {$EndIf l3TraceMemAllocStat}
end;
  
const
{$IfDef l3TraceClasses}
 l3LeakSep = cc_EOL;
{$Else  l3TraceClasses}
 l3LeakSep = cc_HardSpace;
{$EndIf l3TraceClasses}

var
 l3StubHeadCS : TRTLCriticalSection;
{$IfDef l3AutoFreeStubs}
var
 l3StubBase   : THandle = 0;
 l3CurStub    : Integer = 0;
const
 l3StubCount  = 500;
{$Else  l3AutoFreeStubs}
var
 l3StubHead   : THandle = 0;
{$EndIf l3AutoFreeStubs}

function l3AllocStub: THandle;
  {-}
const
 cSize = 32{16};
var
 l_Old : Cardinal;
begin
 EnterCriticalSection(l3StubHeadCS);
 try
  {$IfDef l3AutoFreeStubs}
  if (l3StubBase = 0) then
  begin
   l3StubBase := {$IfDef l3TraceAllocStub}
             l3System
             {$Else  l3TraceAllocStub}
             Windows
             {$EndIf l3TraceAllocStub}.GlobalAlloc(GMem_Fixed + GMEM_ZEROINIT,
                                                   (l3StubCount + 1) * cSize);
   VirtualProtect(Pointer(l3StubBase), (l3StubCount + 1) * cSize, PAGE_EXECUTE_READWRITE, l_Old);
  end;//l3StubHead = 0
  Result := THandle(PAnsiChar(l3StubBase) + l3CurStub * cSize);
  Assert(PInteger(Result)^ = 0);
  if (l3CurStub < l3StubCount) then
   Inc(l3CurStub)
  else
   l3CurStub := 0;
  {$Else  l3AutoFreeStubs}
  if (l3StubHead = 0) then
  begin
   Result := {$IfDef l3TraceAllocStub}
             l3System
             {$Else  l3TraceAllocStub}
             Windows
             {$EndIf l3TraceAllocStub}.GlobalAlloc(GMem_Fixed, cSize);
   VirtualProtect(Pointer(Result), cSize, PAGE_EXECUTE_READWRITE, l_Old);
  end//l3StubHead = 0
  else
  begin
   Result := l3StubHead;
   l3StubHead := PHandle(Result)^;
  end;
  {$EndIf l3AutoFreeStubs}
 finally
  LeaveCriticalSection(l3StubHeadCS);
 end;//try..finally
end;

procedure l3FreeLocalStub(var Stub: Pointer);
  {-}
begin
 if (Stub <> nil) then 
 begin
  {$IfDef l3AutoFreeStubs}
  PInteger(Stub)^ := 0;
  {$Else  l3AutoFreeStubs}
  EnterCriticalSection(l3StubHeadCS);
  try
   PHandle(Stub)^ := l3StubHead;
   l3StubHead := THandle(Stub);
  finally
   LeaveCriticalSection(l3StubHeadCS);
  end;//try..finally
  {$EndIf l3AutoFreeStubs}
  Stub := nil;
 end;//Stub <> nil
end;

procedure l3FreeStubs;
{$IfDef l3AutoFreeStubs}
{$Else  l3AutoFreeStubs}
var
 Prev : THandle;
 Next : THandle;
{$EndIf l3AutoFreeStubs}
begin
 {$IfDef l3AutoFreeStubs}
 {$IfDef l3TraceAllocStub}
 l3System
 {$Else  l3TraceAllocStub}
 Windows
 {$EndIf l3TraceAllocStub}.GlobalFree(l3StubBase);
 {$Else  l3AutoFreeStubs}
 EnterCriticalSection(l3StubHeadCS);
 try
  Prev := l3StubHead;
  while (Prev <> 0) do begin
   Next := PHandle(Prev)^;
   {$IfDef l3TraceAllocStub}
   l3System
   {$Else  l3TraceAllocStub}
   Windows
   {$EndIf l3TraceAllocStub}.GlobalFree(Prev);
   Prev := Next;
  end;{Prev <> 0}
  l3StubHead := 0;
 finally
  LeaveCriticalSection(l3StubHeadCS);
 end;//try..finally
 {$EndIf l3AutoFreeStubs}
end;

function l3LocalStub(Action: Pointer): Pointer;
                     {eax}
  register;
  {-}
asm
          push edi                               { Save edi                }
          push eax                               { Save Action             }
          call l3AllocStub

          { Создаем новый код: }
          mov  edi, eax                          { Handle -> edi           }
          mov  edx, eax                          { Handle -> edx           }
          cld                                    { _Move forward            }

          mov  eax, $68
          stosb
          mov  eax, ebp                          { предыдущий ebp -> eax   }
          stosd                                  { "push OldBP" -> [edi]   }

          mov  eax, $B9
          stosb
          pop  eax                               { Action -> eax           }
          stosd                                  { "mov ecx, Action" -> [edi] }

          mov  eax, $D1FF
          stosw                                  { "call ecx" -> [edi]     }

          mov  eax, $59
          stosb                                  { "pop ecx" -> es:[di]    }

          mov  eax, $C3
          stosb                                  { "ret" -> [edi]          }

          mov  eax, edx                          { Handle -> eax           }
          pop  edi                               { Restore edi             }
end;{asm}

function l3PasLocalStub1(Action: Pointer): Pointer;
                     {eax}
  register;
  {-}
asm
          push edi                               { Save edi                }
          push eax                               { Save Action             }
          call l3AllocStub

          { Создаем новый код: }
          mov  edi, eax                          { Handle -> edi           }
          mov  edx, eax                          { Handle -> edx           }
          cld                                    { _Move forward            }

          mov  eax, $59                          // - снимаем адрес возврата
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $58                          // - снимаем параметр
          stosb                                  { "pop eax" -> [edi]    }

          mov  eax, $51                          // - кладем адрес возврата
          stosb                                  { "push ecx" -> [edi]   }

          mov  eax, $68
          stosb                                  // - кладем указатель фрейма
          mov  eax, ebp                          { предыдущий ebp -> eax   }
          stosd                                  { "push OldBP" -> [edi]   }

          mov  eax, $B9
          stosb                                  // - вызываем локальную процедуру
          pop  eax                               { Action -> eax           }
          stosd                                  { "mov ecx, Action" -> [edi] }
          mov  eax, $D1FF
          stosw                                  { "call ecx" -> [edi]     }

          mov  eax, $59                          // - снимаем указатель фрейма
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $C3                          // - возвращаемся в вызывающую процедуру
          stosb                                  { "ret" -> [edi]          }

          mov  eax, edx                          { Handle -> eax           }
          pop  edi                               { Restore edi             }
end;{asm}

function l3PasLocalStub2(Action: Pointer): Pointer;
                     {eax}
  register;
  {-}
asm
          push edi                               { Save edi                }
          push eax                               { Save Action             }
          call l3AllocStub

          { Создаем новый код: }
          mov  edi, eax                          { Handle -> edi           }
          mov  edx, eax                          { Handle -> edx           }
          cld                                    { _Move forward            }

          mov  eax, $59                          // - снимаем адрес возврата
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $5A                          // - снимаем параметр № 2
          stosb                                  { "pop edx" -> [edi]    }

          mov  eax, $58                          // - снимаем параметр № 1
          stosb                                  { "pop eax" -> [edi]    }

          mov  eax, $51                          // - кладем адрес возврата
          stosb                                  { "push ecx" -> [edi]   }

          mov  eax, $68
          stosb                                  // - кладем указатель фрейма
          mov  eax, ebp                          { предыдущий ebp -> eax   }
          stosd                                  { "push OldBP" -> [edi]   }

          mov  eax, $B9
          stosb                                  // - вызываем локальную процедуру
          pop  eax                               { Action -> eax           }
          stosd                                  { "mov ecx, Action" -> [edi] }
          mov  eax, $D1FF
          stosw                                  { "call ecx" -> [edi]     }

          mov  eax, $59                          // - снимаем указатель фрейма
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $C3                          // - возвращаемся в вызывающую процедуру
          stosb                                  { "ret" -> [edi]          }

          mov  eax, edx                          { Handle -> eax           }
          pop  edi                               { Restore edi             }
end;{asm}

function l3PasLocalStub3(Action: Pointer): Pointer;
                     {eax}
  register;
  {-}
asm
          push edi                               { Save edi                }
          push eax                               { Save Action             }
          call l3AllocStub

          { Создаем новый код: }
          mov  edi, eax                          { Handle -> edi           }
          mov  edx, eax                          { Handle -> edx           }
          cld                                    { _Move forward            }

          mov  eax, $59                          // - снимаем адрес возврата
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $5A                          // - снимаем параметр № 3
          stosb                                  { "pop edx" -> [edi]    }

          mov  eax, $5A                          // - снимаем параметр № 2
          stosb                                  { "pop edx" -> [edi]    }

          mov  eax, $58                          // - снимаем параметр № 1
          stosb                                  { "pop eax" -> [edi]    }

          mov  eax, $51                          // - кладем адрес возврата
          stosb                                  { "push ecx" -> [edi]   }

          mov  eax, $68
          stosb                                  // - кладем указатель фрейма
          mov  eax, ebp                          { предыдущий ebp -> eax   }
          stosd                                  { "push OldBP" -> [edi]   }

          mov  eax, $B9
          stosb                                  // - вызываем локальную процедуру
          pop  eax                               { Action -> eax           }
          stosd                                  { "mov ecx, Action" -> [edi] }
          mov  eax, $D1FF
          stosw                                  { "call ecx" -> [edi]     }

          mov  eax, $59                          // - снимаем указатель фрейма
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $C3                          // - возвращаемся в вызывающую процедуру
          stosb                                  { "ret" -> [edi]          }

          mov  eax, edx                          { Handle -> eax           }
          pop  edi                               { Restore edi             }
end;{asm}

function  l3StdLocalStub1(Action: Pointer): Pointer;
  {-}
  register;
  {-}
asm
          jmp  l3PasLocalStub1
end;

function l3StdLocalStub2(Action: Pointer): Pointer;
                     {eax}
  register;
  {-}
asm
          push edi                               { Save edi                }
          push eax                               { Save Action             }
          call l3AllocStub

          { Создаем новый код: }
          mov  edi, eax                          { Handle -> edi           }
          mov  edx, eax                          { Handle -> edx           }
          cld                                    { _Move forward            }

          mov  eax, $59                          // - снимаем адрес возврата
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $58                          // - снимаем параметр № 1
          stosb                                  { "pop eax" -> [edi]    }

          mov  eax, $5A                          // - снимаем параметр № 2
          stosb                                  { "pop edx" -> [edi]    }

          mov  eax, $51                          // - кладем адрес возврата
          stosb                                  { "push ecx" -> [edi]   }

          mov  eax, $68
          stosb                                  // - кладем указатель фрейма
          mov  eax, ebp                          { предыдущий ebp -> eax   }
          stosd                                  { "push OldBP" -> [edi]   }

          mov  eax, $B9
          stosb                                  // - вызываем локальную процедуру
          pop  eax                               { Action -> eax           }
          stosd                                  { "mov ecx, Action" -> [edi] }
          mov  eax, $D1FF
          stosw                                  { "call ecx" -> [edi]     }

          mov  eax, $59                          // - снимаем указатель фрейма
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $C3                          // - возвращаемся в вызывающую процедуру
          stosb                                  { "ret" -> [edi]          }

          mov  eax, edx                          { Handle -> eax           }
          pop  edi                               { Restore edi             }
end;{asm}

function l3StdLocalStub3(Action: Pointer): Pointer;
                     {eax}
  register;
  {-}
asm
          push edi                               { Save edi                }
          push eax                               { Save Action             }
          call l3AllocStub

          { Создаем новый код: }
          mov  edi, eax                          { Handle -> edi           }
          mov  edx, eax                          { Handle -> edx           }
          cld                                    { _Move forward            }

          mov  eax, $59                          // - снимаем адрес возврата
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $58                          // - снимаем параметр № 1
          stosb                                  { "pop eax" -> [edi]    }

          mov  eax, $5A                          // - снимаем параметр № 2
          stosb                                  { "pop edx" -> [edi]    }

          mov  eax, $51                          // - кладем адрес возврата
          stosb                                  { "push ecx" -> [edi]   }

          mov  eax, $68
          stosb                                  // - кладем указатель фрейма
          mov  eax, ebp                          { предыдущий ebp -> eax   }
          stosd                                  { "push OldBP" -> [edi]   }

          mov  eax, $B9
          stosb                                  // - вызываем локальную процедуру
          pop  eax                               { Action -> eax           }
          stosd                                  { "mov ecx, Action" -> [edi] }
          mov  eax, $D1FF
          stosw                                  { "call ecx" -> [edi]     }

          mov  eax, $59                          // - снимаем указатель фрейма
          stosb                                  { "pop ecx" -> [edi]    }

          mov  eax, $C2                          // - возвращаемся в вызывающую процедуру
          stosb                                  { "ret 4" -> [edi]        }

          mov  eax, $04                          // + снимаем параметр № 3
          stosw                                  {                         }

          mov  eax, edx                          { Handle -> eax           }
          pop  edi                               { Restore edi             }
end;{asm}

function  l3L2IA(Action: Pointer): Tl3IteratorAction;
                {eax}
  register;
  {-}
asm
          jmp  l3LocalStub
end;{asm}

procedure l3FreeIA(var Stub: Tl3IteratorAction);
                  {eax}
  register;
  {-}
asm
          jmp  l3FreeLocalStub
end;{asm}

function  l3L2FA(Action: Pointer): Tl3FreeAction;
  register;
  {-}
asm
          jmp  l3LocalStub
end;{asm}

procedure l3FreeFA(var Stub: Tl3FreeAction);
  register;
  {-}
asm
          jmp  l3FreeLocalStub
end;{asm}

procedure l3AnalizeCodePage(Buf, BufEnd: PAnsiChar; var OEMCount, ANSICount: Long);
var
 C : AnsiChar;
begin
 OEMCount  := 0;
 ANSICount := 0;
 while (Buf < BufEnd) do begin
  C := Buf^;
  Inc(Buf);
  if (C in cc_OEM_Criteria) then
   Inc(OEMCount)
  else if (C in cc_ANSI_Criteria) then
   Inc(ANSICount);
 end;{Buf < BufEnd}
end;

procedure l3AnalizeCodePageEx(Buf, BufEnd: PAnsiChar;
                             var OEMCount, ANSICount, GraphCount: Long;
                             var GraphCounts: T_cc_GraphCounts);
var
 C : AnsiChar;
begin
 OEMCount   := 0;
 ANSICount  := 0;
 GraphCount := 0;
 for C := Low(T_cc_GraphCounts) to High(T_cc_GraphCounts) do
  GraphCounts[C] := 0;
 while (Buf < BufEnd) do begin
  C := Buf^;
  Inc(Buf);
  if (C in cc_OEM_CriteriaEx) then Inc(OEMCount);
  if (C in cc_ANSI_CriteriaEx) then Inc(ANSICount);
  if (C in cc_Graph_CriteriaPrim) then begin
   Inc(GraphCounts[C]);
   Inc(GraphCount);
  end;
 end;{Buf < BufEnd}
end;

function l3AnalizeCodePageExEx(Buf, BufEnd: PAnsiChar): Long;
var
 OEMCount    : Long;
 ANSICount   : Long;
 GraphCount  : Long;
 GraphCount_2: Long;
 GraphCounts : T_cc_GraphCounts;
 C           : AnsiChar;
begin
 l3AnalizeCodePageEx(Buf, BufEnd, OEMCount, ANSICount, GraphCount, GraphCounts);
 if (OEMCount > ANSICount) then
  Result := CP_OEM
 else if (GraphCount + OEMCount >= ANSICount) then begin
                     {         }
  Result := CP_ANSI;
  GraphCount_2 := GraphCount div 2;
  for C := Low(T_cc_GraphCounts) to High(T_cc_GraphCounts) do begin
   if (GraphCounts[C] > GraphCount_2) then begin
    Result := CP_OEM;
    break;
   end;{GraphCounts[C] > ..}
  end;{for C}
 end else Result := CP_ANSI;
end;

function l3AnalizeCodePageBuf(Buf: PAnsiChar; Len: Long): Long;
  {-}
begin
 Result := l3AnalizeCodePageExEx(Buf, Buf + Len);
end;

function l3Use(O: TObject): Pointer;
  {-}
var
 Obj : Pointer;
begin
 if (O <> nil) then
  if not O.GetInterface(IUnknown, Obj) then
   if (O Is Tl3DataContainerWithoutIUnknownPrim) then
   begin
    Result := Tl3DataContainerWithoutIUnknownPrim(O).Use;
    Exit;
   end//O Is Tl3DataContainerWithoutIUnknownPrim
   else
    Assert(false);
 Result := O;
end;

function l3Use(O: Tl3ProtoObject): Pointer;
  //overload;
  {* - увеличивает объекту счетчик ссылок. }
begin
 Result := O.Use;
end;

function  l3Use(O: Tl3DataContainerWithoutIUnknownPrim): Pointer;
  //overload;
  {* - увеличивает объекту счетчик ссылок. }
begin
 Result := O.Use;
end;

procedure l3Set(var theStr: Tl3String; const aStr: Tl3WString);
  //overload;
begin
 if (theStr = nil) then
  theStr := Tl3String.Make(aStr)
 else
  theStr.AsWStr := aStr;
end;

procedure l3Set(var theStr: Tl3String; const aStr: Il3CString);
  //overload;
begin
 if (aStr = nil) then
  l3Free(theStr)
 else 
 if (theStr = nil) then
  theStr := Tl3String.Make(aStr.AsWStr)
 else
  theStr.AsWStr := aStr.AsWStr;
end;

function l3Set(var F; V: TObject): Bool;
  {-}
begin
 if (Pointer(F) = V) then
  Result := false
 else
 begin
  Result := true;
  TObject(F).Free;
  Pointer(F) := l3Use(V);
 end;//Pointer(F) = V
end;

function l3Set(var F; V: Tl3ProtoObject): Bool;
  //overload;
  {-}
begin
 if (Pointer(F) = V) then
  Result := false
 else
 begin
  Result := true;
  TObject(F).Free;
  Pointer(F) := V.Use;
 end;//Pointer(F) = V
end;

function  l3Set(var F; V: Tl3DataContainerWithoutIUnknownPrim): Bool;
  //overload;
  {* - присваивает переменной F объект со счетчиком ссылок V. }
begin
 if (Pointer(F) = V) then
  Result := false
 else
 begin
  Result := true;
  TObject(F).Free;
  Pointer(F) := V.Use;
 end;//Pointer(F) = V
end;

procedure l3Swap(var A, B : Cardinal);
  {-}
var
 l_Tmp : Cardinal;
begin
 l_Tmp := A;
 A := B;
 B := l_Tmp;
end;

procedure l3Swap(var A, B : Integer);
  {-}
var
 l_Tmp : Integer;
begin
 l_Tmp := A;
 A := B;
 B := l_Tmp;
end;

procedure l3Swap(var A, B : Pointer);
  {-}
var
 l_Tmp : Pointer;
begin
 l_Tmp := Pointer(A);
 Pointer(A) := Pointer(B);
 Pointer(B) := l_Tmp;
end;

procedure l3Swap(var A, B; aSize: Integer);
  //overload;
  {* - обменивает переменные значениями. }

 procedure Swap64(var A, B: Int64);
   {-}
 var
  l_Tmp : Int64;
 begin//Swap64
  l_Tmp := A;
  A := B;
  B := l_Tmp;
 end;//Swap64

 procedure Swap32(var A, B: Longint);
   {-}
 var
  l_Tmp : Longint;
 begin//Swap32
  l_Tmp := A;
  A := B;
  B := l_Tmp;
 end;//Swap32

 procedure Swap16(var A, B: Word);
   {-}
 var
  l_Tmp : Word;
 begin//Swap16
  l_Tmp := A;
  A := B;
  B := l_Tmp;
 end;//Swap16

 procedure Swap8(var A, B: Byte);
   {-}
 var
  l_Tmp : Byte;
 begin//Swap8
  l_Tmp := A;
  A := B;
  B := l_Tmp;
 end;//Swap8

var
 l_A, l_B : PLarge;
 l_Index  : Integer;
begin
 l_A := @A;
 l_B := @B;
 for l_Index := 0 to (aSize div SizeOf(Int64))-1 do
 begin
  Swap64(l_A^, l_B^);
  Inc(l_A);
  Inc(l_B);
  Dec(aSize, SizeOf(Int64));
 end;//for l_Index
 if (aSize div SizeOf(Longint) > 0) then
 begin
  Swap32(PLong(l_A)^, PLong(l_B)^);
  Inc(PLong(l_A));
  Inc(PLong(l_B));
  Dec(aSize, SizeOf(Longint));
 end;//aSize div SizeOf(Longint) > 0
 if (aSize div SizeOf(Word) > 0) then
 begin
  Swap16(PWord(l_A)^, PWord(l_B)^);
  Inc(PWord(l_A));
  Inc(PWord(l_B));
  Dec(aSize, SizeOf(Word));
 end;//aSize div SizeOf(Longint) > 0
 if (aSize div SizeOf(Byte) > 0) then
 begin
  Swap8(PByte(l_A)^, PByte(l_B)^);
  Inc(PByte(l_A));
  Inc(PByte(l_B));
  //Dec(aSize, SizeOf(Byte));
  // - закомментированно, т.к. уже больше никому не надо
 end;//aSize div SizeOf(Longint) > 0
end;

procedure l3Free(var P);
  {-}
begin
 FreeAndNil(P);
end;

procedure l3FreeGlobal(var P);
  //overload;
  {-}
var
 O : TObject;
begin
 O := TObject(P);
 O.Free;
 Pointer(P) := nil;
end;

function l3Free(var P: IUnknown): Pointer;
  {-}
begin
 P := nil;
 Result := nil;
end;
  
function l3IOK(Status: HRESULT): Bool;
  {-}
begin
 Result := Succeeded(Status);
end;

function l3IFail(Status: HRESULT): Bool;
  {-}
begin
 Result := Failed(Status);
end;

{$IfDef l3TraceSysGetMem}
function l3_GetMem(aSize: {$IfDef XE}NativeInt{$Else}Integer{$EndIf}): Pointer;
begin
 l3StatMemAlloc(aSize, false);
 Result := SysGetMem(aSize);
 if (g_l3System <> nil) then
 begin
  Inc(g_l3System.f_AllLocalMemUsed, l3MemorySize(Result));
  g_l3System.CheckMaxes;
 end;//g_l3System <> nil
end;

function l3_ReallocMem(aPointer : Pointer;
                       aSize    : {$IfDef XE}NativeInt{$Else}Integer{$EndIf}): Pointer;
begin
 if (g_l3System <> nil) then
  Dec(g_l3System.f_AllLocalMemUsed, l3MemorySize(aPointer));
 l3StatMemAlloc(aSize, false);
 Result := SysReallocMem(aPointer, aSize);
 if (g_l3System <> nil) then
 begin
  Inc(g_l3System.f_AllLocalMemUsed, l3MemorySize(Result));
  g_l3System.CheckMaxes;
 end;//g_l3System <> nil
end;

function l3_FreeMem(aPointer: Pointer): Integer;
begin
 if (g_l3System <> nil) then
  Dec(g_l3System.f_AllLocalMemUsed, l3MemorySize(aPointer));
 Result := SysFreeMem(aPointer);
end;

const
  cMemoryManager: TMemoryManager = (
   GetMem: l3_GetMem;
   FreeMem: l3_FreeMem;
   ReallocMem: l3_ReallocMem
  );

var
  gMemoryManager : TMemoryManager;


procedure l3InitMemManager;
begin
 GetMemoryManager(gMemoryManager);
 SetMemoryManager(cMemoryManager);
end;

procedure l3DoneMemManager;
begin
 SetMemoryManager(GMemoryManager);
end;
{$EndIf l3TraceSysGetMem}

function l3System: Tl3System;
  {-}
begin
 if (g_l3System = nil) then
 begin
  {$IfDef l3TraceSysGetMem}
  l3InitMemManager;
  {$EndIf l3TraceSysGetMem}
  InitializeCriticalSection(l3StubHeadCS);
  g_l3System := Tl3System.Create;
 end;//g_l3System = nil
 Result := Tl3System(g_l3System);
end;

function l3SystemDown: Boolean;
  {-}
begin
 Result := (g_l3System = nil) OR Tl3MemUtils.IsDown;
end;

function l3MemUtilsDown: Boolean;
  {-}
begin
 Result := Tl3MemUtils.IsDown;
end;

// start class Tl3ConstString

constructor Tl3ConstString.Make(const aSt: Tl3WString);
  {* - создает новую строку как копию aSt. }
begin
 Create;
 AsWStr := aSt;
end;

class function Tl3ConstString.MakeI(const aSt: Tl3WString): Il3CString;
  {-}
var
 l_S : Tl3ConstString;
begin
 l_S := Make(aSt);
 try
  Result := l_S;
 finally
  l3Free(l_S);
 end;//try..finally
end;

procedure Tl3ConstString.Assign(P: TPersistent);
  {override;}
  {-}
begin
 CannotModify;
end;

function Tl3ConstString.GetAsPCharLen: Tl3PCharLenPrim;
  //override;
  {-}
begin
 Result := f_St;
end;

procedure Tl3ConstString.DoSetAsPCharLen(const Value: Tl3PCharLen);
  //override;
  {-}
begin
 f_St := Value;
end;

procedure Tl3ConstString.CannotModify;
  {-}
begin
 raise El3CannotModify.CreateFmt(l3_MesCannotModifyConstantString, [AsString]);
end;

// start object Tl3ObjectHash 

function __FreeObject1(P: Pointer): Bool;
begin
 l3Free(P^);
 Result := true;
end;

function __FreeObject2(P: Pointer; Index: Long): Bool;
begin
 l3Free(P^);
 Result := true;
end;

function Tl3ObjectHash.SetItem(ItemIndex: Long; Item: Tl3ProtoObject): PObject;
  {-}
begin
 Item.Use;
 try
  Result := inherited SetItem(ItemIndex, __FreeObject1, Item);
 except
  l3Free(Item);
  raise;
 end;//try..except
end;

function Tl3ObjectHash.GetItemP(ItemIndex: Long): PObject;
  {-}
begin
 Result := inherited GetItem(ItemIndex);
end;

procedure Tl3ObjectHash.Clear;
  {-}
begin
 inherited Clear(__FreeObject2);
end;

// start class Tl3System 

procedure Tl3System.ClearClipboard(aValue: Integer = IDNo);
begin
{$IfDef l3UseOleClipboard}
 if (aValue = IDYes) then
  OleFlushClipboard
 else
 if (aValue = IDNo) then
  OleSetClipboard(nil)
 else
  Exit;
 ClipboardData := nil;
{$EndIf l3UseOleClipboard}
end;

function Tl3System.CheckResources: AnsiString;
  {override;}
  {-}
begin
 Result := inherited CheckResources;
 if (f_DCCount > 0) then
  Result := Result + Format('DC = %d'+l3LeakSep, [f_DCCount]);
 if (f_RgnCount > 0) then
  Result := Result + Format('RGN = %d'+l3LeakSep, [f_RgnCount]);
end;

function Tl3System.CheckClipboard(const anAskProc: Tl3AskClearClipboardProc = nil): Integer;
  {-}
{$IfDef l3UseOleClipboard}
var
 l_Info : Il3DataObjectInfo;
{$EndIf l3UseOleClipboard}
begin
 Result := IDNo;
 {$IfDef l3UseOleClipboard}
 if (ClipboardData <> nil) AND l3IOk(OleIsCurrentClipboard(ClipboardData)) then
 begin
  if Supports(ClipboardData, Il3DataObjectInfo, l_Info) then
   try
    if not l_Info.IsQuestionNeedBeforeFlush then
     Result := ID_YES;
   finally
    l_Info := nil;
   end;//try..finally
  if (Result <> IDYes) then
  begin
   if Assigned(anAskProc) then
    anAskProc(Result)
   else
   Result := MessageBox(0,
                        'Буфер обмена содержит большой кусок данных. Вы ' +
                        'хотите, чтобы эти данные были доступны другим '  +
                        'приложениям (операция может занять длительное время)?',
                        'Внимание',
                        MB_ICONQUESTION OR MB_YesNoCancel);
  end; 
  ClearClipboard(Result);
 end;//if (ClipboardData <> nil)
 {$EndIf l3UseOleClipboard}
end;//CheckClipboard

procedure Tl3System.Beep;
  {-}
begin
 Windows.MessageBeep($FFFF);
end;

function Tl3System.GetMM(aForFree : Boolean): Tl3ObjectsMemoryManager;
  {-}
begin
 Result := nil;
 if (Self <> nil) then
 begin
  if (f_SimpleMM <> nil) then
   Result := f_SimpleMM
  else
  if CanCache then
  begin
   if not aForFree then
   begin
    f_SimpleMM := Tl3ObjectsMemoryManager.Create;
    Result := f_SimpleMM;
   end;//not aForFree
  end;//CanCache
 end;//Self <> nil
end;

function Tl3System.GetBoxMM: Tl3BoxMemoryManager;
  {-}
begin
 Assert(Self <> nil);
 if (f_BoxMM <> nil) then
  Result := f_BoxMM
 else 
 if CanCache then
 begin
  f_BoxMM := Tl3BoxMemoryManager.Create;
  Result := f_BoxMM;
 end//CanCache
 else
  Result := nil;
end;

function Tl3System.GetStamp: TGUID;
  {-}
begin
 if not f_StampInited then
 begin
  EnterGlobalCS;
  try
   CreateGUID(f_Stamp);
   f_StampInited := true;
  finally
   LeaveGlobalCS;
  end;//try..finally
 end;//not f_StampInited
 Result := f_Stamp;
end;

procedure Tl3System.IncLogIndent;
  {-}
begin
 Inc(f_LogIndent);
end;

procedure Tl3System.DecLogIndent;
  {-}
begin
 Dec(f_LogIndent);
end;

function Tl3System.SetClipboardData(const aData: IDataObject): Boolean;
  {-}
begin
{$IfDef l3UseOleClipboard}
 if (aData = nil) then
  Result := false
 else
 begin
  Result := l3IOk(OleSetClipboard(aData));
  if Result then
   ClipboardData := aData;
 end//aData = nil
{$EndIf l3UseOleClipboard}
end;
  
function Tl3System.IsLocalIntf(const anIntf: Il3Base): Boolean;
  {-}
begin
 if (anIntf = nil) then
  Result := true
 else
  Result := anIntf.CheckStamp(GetStamp);
end;

procedure Tl3System.Release;
  {override;}
  {-}

begin
 if (Self = g_l3System) then
  Self.DownBegins;
 {$IfDef l3UseOleClipboard}
 ClipboardData := nil;
 {$EndIf l3UseOleClipboard}
 l3Free(f_Keyboard);
 l3Free(f_Mouse);
 l3Free(f_Windows);
 {$IfNDef DesignTimeLibrary}
 {$IfNDef l3ConsoleApp}
 if (Application <> nil) then
 begin
  // - иначе бывает получаем окно о неосвобожденных ресурсах
  Application.Free;
  Application := nil;
  Application := TApplication.Create(nil);
 end;//Application <> nil
 {$EndIf  l3ConsoleApp}
 {$EndIf DesignTimeLibrary}
 l3FreeGlobal(f_ObjectCache);
                      // ^ - очищаем поле специально с самом конце -
                      // чтобы другие объекты (которые лежат в этом списке )
                      // еще имели к нему доступ
 CallExitProcs;
 try
  FreeAndNil(f_BoxMM);
  FreeAndNil(f_SimpleMM);
  // - удаляем менеджеры памяти в самую последнюю очередь
 finally
  // - давим Assert - чтобы показалось окошко с ресурсами
  inherited;
 end;//try..finally
end;

constructor Tl3System.Create{(anOwner: TObject = nil)};
// override;
{- P - адрес указателя куда будет положен Self}
begin
 inherited;
 f_LogIndent := 0;
 f_MessageLevel := 0;
end;

function Tl3System.PeekMessage(var Msg      : TMsg;
                               Wnd          : HWnd;
                               MsgFilterMin : UINT;
                               MsgFilterMax : UINT;
                               RemoveMsg    : UINT): Bool;
  {-}
begin
 Result := Windows.PeekMessage(Msg, Wnd, MsgFilterMin, MsgFilterMax, RemoveMsg);
end;

function Tl3System.TranslateMessage(var Msg: TMsg): Bool;
  {-}
begin
 Result := Windows.TranslateMessage(Msg);
end;

function Tl3System.PeekString(Handle         : hWnd;
                              const aFirst   : Tl3PCharLen;
                              CCP            : Tl3ConvertCharProc;
                              aWantSoftEnter : Boolean;
                              aRepeat        : Long = 1): Il3CString;
  {-}

var
 Res : Tl3InterfacedString;

 function ProcessChar(const aStr: Tl3PCharLen): Bool;
 var
  l_Msg : TMsg;
 begin//ProcessChar
  if Assigned(CCP) then
   CCP(aStr);
  if ((aStr.S^ = cc_SoftEnter) AND aWantSoftEnter) OR
     ((aStr.S^ >= cc_HardSpace) AND (aStr.S^ <> cc_CtrlBackspace)) then
  begin
   Res.Append(aStr);
   PeekMessage(l_Msg, Handle, WM_KEYFIRST, WM_KEYLAST, PM_NOYELD + PM_REMOVE);
   Result := true;
  end//aStr.S^ = cc_SoftEnter..
  else
   Result := false;
 end;//ProcessChar

var
 l_Msg      : TMsg;
// l_Key      : TWMKeyDown;
// l_Unicode  : WideString;
 l_CodePage : Integer;
begin
 Res := Tl3InterfacedString.Create;
 try
  Result := Res;
  Res.CodePage := aFirst.SCodePage;
  if ProcessChar(aFirst) then
  begin
   if (Res.CodePage = CP_Unicode) then
    // - чтобы не портить юникодные символы, набиваемые с клавиатуры
    Exit;
   l_CodePage := l3KeyboardCodePage;
(*   if (Res.CodePage = CP_Unicode) then
   begin
    if (l_CodePage = CP_RussianWin) then
     Res.CodePage := CP_ANSI
    else
    if (l_CodePage = CP_WesternWin) then
     Res.CodePage := l_CodePage;
   end;//Res.CodePage = CP_Unicode*)
   while PeekMessage(l_Msg, Handle, WM_KEYFIRST, WM_KEYLAST, PM_NOYELD + PM_NOREMOVE) do
   begin
    Case l_Msg.Message of
     WM_Char:
     begin
      //if (l_Unicode = '') then
      begin
       if not ProcessChar(l3PCharLen(Char(l_Msg.wParam), l_CodePage)) then
        break;
      end//l_Unicode = nil
      {else
      begin
       if not ProcessChar(l3PCharLen(l_Unicode)) then
        break;
      end;//l_Unicode = nil
      l_Unicode := ''};
     end;//WM_Char
     {WM_KeyDown:
     begin
      if (Res.CodePage <> CP_ANSI) then
      begin
       l_Key.Msg := l_Msg.Message;
       l_Key.CharCode := Word(l_Msg.wParam);
       l_Key.KeyData := l_Msg.lParam;
       l_Unicode := l3KeyToUnicode(l_Key);
      end;//Res.CodePage = CP_Unicode
      PeekMessage(l_Msg, Handle, WM_KEYFIRST, WM_KEYLAST, PM_NOYELD + PM_REMOVE);
      TranslateMessage(l_Msg);
     end;//WM_KeyDown}
     else
     begin
      PeekMessage(l_Msg, Handle, WM_KEYFIRST, WM_KEYLAST, PM_NOYELD + PM_REMOVE);
      TranslateMessage(l_Msg);
     end;//else
    end;//Case M.Message
   end;//while PeekMessage..
  end;//ProcessChar(aFirst)
 finally
  l3Free(Res);
 end;//try..finally
end;

function Tl3System.GetDC(Wnd: hWnd): hDC;
  {-}
begin
 Inc(f_DCCount);
 Result := Windows.GetDC(Wnd);
end;

function Tl3System.GetDCEx(Wnd: hWnd; Rgn: Tl3Rgn; Flags: Cardinal): hDC;
  {-}
begin
 Inc(f_DCCount);
 Result := Windows.GetDCEx(Wnd, Rgn, Flags);
end;

function Tl3System.ReleaseDC(Wnd: hWnd; DC: hDC): Integer;
  {-}
begin
 Result := Windows.ReleaseDC(Wnd, DC);
 Dec(f_DCCount);
end;

procedure Tl3System.IncRgnCount;
  {-}
begin
 Inc(f_RgnCount);
end;

procedure Tl3System.DecRgnCount;
  {-}
begin
 Dec(f_RgnCount);
end;

function Tl3System.ReleaseHandle(H: THandle): THandle;
  {-}
begin
 Result := H;
 l3InterlockedExchangeAdd(l3MemUtils.f_GlobalMemUsed, -Integer(GlobalSize(Result)));
end;

procedure Tl3System.Stack2Log(const S: AnsiString = '');
  {-}
begin
 l3ExceptionsLog.Stack2Log(S);
end;

procedure Tl3System.Exception2Log(E: Exception);
  {-}
begin
 l3ExceptionsLog.Exception2Log(E);
end;

function Tl3System.AddLogIndent : AnsiString;
  {* - возвращает текущий отступ для лога. }
const
 cIndentSize = 2;
 {* - размер отступа в количестве пробелов. }
begin
 Result := '';
 if f_LogIndent > 0 then
  Result := l3String.ev_psFixLen('', f_LogIndent * cIndentSize, ' ');
end;

procedure Tl3System.Msg2Log(const S: AnsiString; aMsgLevel: Byte = l3_msgAll);
  {-}
begin
{$IfDef l3Requires_m0}
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) and (aMsgLevel <= MessageLevel) then
  Gm0EXCLibDefSrv.SaveMessage(Cm0EXCLibINF, AddLogIndent + S);
 {$IfEnd}
{$EndIf l3Requires_m0}
end;

procedure Tl3System.Msg2Log(const S : AnsiString; const Args: array of const; aMsgLevel: Byte = l3_msgAll);
  {-}
begin
 Msg2Log(Format(S, Args), aMsgLevel);
end;

procedure Tl3System.OpenLog;
  {-}
begin
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) then
  Exit;
 Assert(Gm0EXCLibDefSrv = nil);
 l3ExceptionsLog.OpenLog;
 {$IfEnd}
end;

procedure Tl3System.CloseLog;
  {* - закрывает лог и выключает перехват ошибок. }
begin
 {$If Declared(Gm0EXCLibDefSrv)}
 FreeAndNil(Gm0EXCLibDefSrv);
 {$IfEnd}
end;

procedure Tl3System.DisableExceptionToLog;
begin
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) then
  Gm0EXCLibDefSrv.DisableExceptionToLog;
 {$IfEnd}
end;

procedure Tl3System.EnableExceptionToLog;
begin
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) then
  Gm0EXCLibDefSrv.EnableExceptionToLog;
 {$IfEnd}
end;

procedure Tl3System.Str2Log(const S: AnsiString);
  {-}
begin
{$IfDef l3Requires_m0}
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) then
  Gm0EXCLibDefSrv.SaveString(AddLogIndent + S + cc_EOL);
 {$IfEnd}
{$EndIf l3Requires_m0}
end;

procedure Tl3System.Time2Log(const S     : AnsiString;
                             var theLast : DWord);
  {* - вывести сообщение в лог - с указанием дельты времени. }
var
 l_Time : DWord;
begin
 l_Time := GetTickCount - theLast;
 l3System.Msg2Log(Format('%s: %d sec %d msec', [S, l_Time div 1000,
  l_Time - l_Time div 1000 * 1000]));
 theLast := GetTickCount;
end;

procedure Tl3System.MemUsage2Log(Strict: Boolean = False);
{$IfDef l3TraceClasses}
var
 I: Integer;
{$EndIf l3TraceClasses}
begin
 Msg2Log('Memory Usage:');
{$IfDef l3TraceClasses}
 for I := 0 to f_ClassList.Count -1 do
  if Strict or (Long(f_ClassList.Objects[I]) > 12) then
  Msg2Log('  %s = %d', [f_ClassList[I], Long(f_ClassList.Objects[I])]);
{$EndIf l3TraceClasses}

 Msg2Log('local: %d (max: %d), Syslocal: %d (max: %d), global: %d (max: %d),'{$ifdef  MMTrace}+' SimplMM: %d, BoxMM: %d,'{$EndIf}+' objects: %d/%d',
 [LocalMemUsed, MaxLocalMemUsed, SysLocalMemUsed, MaxAllLocalMemUsed, GlobalMemUsed, MaxGlobalMemUsed,
 {$ifdef  MMTrace}
  f_SimpleMM.f_GlobalAlloc, f_BoxMM.f_GlobalAlloc,
 {$EndIf}
  ObjectCount, ObjectMemUsed]);
end;

function Tl3System.pm_GetKeyboard: Tl3Keyboard;
  {-}
begin
 if (f_Keyboard = nil) then
  f_Keyboard := Tl3Keyboard.Create;
 Result := f_Keyboard;
end;

procedure Tl3System.pm_SetKeyboard(Value: Tl3Keyboard);
  {-}
begin
 l3Set(f_Keyboard, Value);
end;

function Tl3System.pm_GetMouse: Tl3Mouse;
begin
 if (f_Mouse = nil) then
  f_Mouse := Tl3Mouse.Create;
 Result := f_Mouse;
end;

procedure Tl3System.pm_SetMouse(Value: Tl3Mouse);
  {-}
begin
 l3Set(f_Mouse, Value);
end;

function Tl3System.pm_GetWindows: Tl3Windows;
begin
 if (f_Windows = nil) then
  f_Windows := Tl3Windows.Create;
 Result := f_Windows;
end;

procedure Tl3System.pm_SetWindows(Value: Tl3Windows);
  {-}
begin
 l3Set(f_Windows, Value);
end;

function Tl3System.pm_GetAppTitle: AnsiString;
  {-}
{$IfDef l3ConsoleApp}
var
  P: PAnsiChar;
  ModuleName: array[0..255] of AnsiChar;
{$EndIf l3ConsoleApp}
begin
 {$IfDef l3ConsoleApp}
 GetModuleFileNameA(MainInstance, ModuleName, SizeOf(ModuleName));
 OemToAnsi(ModuleName, ModuleName);
 P := AnsiStrRScan(ModuleName, '\');
 if P <> nil then StrCopy(ModuleName, P + 1);
 P := AnsiStrScan(ModuleName, '.');
 if P <> nil then P^ := #0;
 AnsiLower(ModuleName + 1);
 Result := ModuleName;
 {$Else  l3ConsoleApp}
 Result := Application.Title;
 {$EndIf l3ConsoleApp}
 if l3CharSetPresent(l3PCharLen(Result), ['<', '>', cc_SingleQuote]) then
  Result := ExtractFileName(ParamStr(0));
 Assert(not l3CharSetPresent(l3PCharLen(Result), ['<', '>', cc_SingleQuote])); 
end;

function  Tl3System.pm_GetLogMachineName: AnsiString;
begin
 Result := '';
{$IfDef l3Requires_m0}
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) then
  Result := Gm0EXCLibDefSrv.LogMachineName;
 {$IfEnd}
{$EndIf l3Requires_m0}
end;

procedure Tl3System.pm_SetLogMachineName(const Value: AnsiString);
begin
{$IfDef l3Requires_m0}
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) then
  Gm0EXCLibDefSrv.LogMachineName := Value;
 {$IfEnd}
{$EndIf l3Requires_m0}
end;

function  Tl3System.pm_GetLogFileName: AnsiString;
begin
 Result := '';
{$IfDef l3Requires_m0}
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) then
  Result := Gm0EXCLibDefSrv.LogFileName;
 {$IfEnd}
{$EndIf l3Requires_m0}
end;

procedure Tl3System.pm_SetLogFileName(const Value: AnsiString);
begin
{$IfDef l3Requires_m0}
 {$If Declared(Gm0EXCLibDefSrv)}
 if (Gm0EXCLibDefSrv <> nil) then
  Gm0EXCLibDefSrv.LogFileName := Value;
 {$IfEnd}
{$EndIf l3Requires_m0}
end;

procedure Tl3System.Str2Log(const S : AnsiString; const Args: array of const);
  {-}
begin
 Str2Log(Format(S, Args));
end;

// start class Tl3Keyboard

function Tl3Keyboard.pm_GetKey(Index: Integer): Tl3Key;
  {-}
var
 KS : Integer;
begin
 KS := Windows.GetKeyState(Index);
 Result.Down := (KS < 0);
 Result.Toggled := l3TestBit(KS, 0);
end;

function Tl3Keyboard.pm_GetAsyncKey(Index: Integer): Tl3Key;
  {-}
var
 KS : Integer;
begin
 KS := Windows.GetAsyncKeyState(Index);
 Result.Down := (KS < 0);
 Result.Toggled := l3TestBit(KS, 0);
end;

// start class Tl3Mouse 

function Tl3Mouse.SetCapture(Wnd: hWnd): hWnd;
  {-}
begin
 Result := Windows.SetCapture(Wnd);
end;

procedure Tl3Mouse.ReleaseCapture;
  {-}
begin
 Windows.ReleaseCapture;
end;

function Tl3Mouse.LeftButton: Byte;
  {-}
const
  RLButton : array[Boolean] of Word = (VK_LBUTTON, VK_RBUTTON);
begin
 Result := RLButton[GetSystemMetrics(SM_SWAPBUTTON) <> 0];
end;
  
// start class Tl3Windows

procedure Tl3Windows.ScrollWindow(Wnd: HWnd; XAmount, YAmount: Integer; Rect: PRect; ClipRect: PRect);
  {-}
begin
 Windows.ScrollWindow(Wnd, XAmount, YAmount, Rect, ClipRect);
end;

function Tl3Windows.Focused: hWnd;
  {-}
begin
 Result := Windows.GetFocus;
end;

// start class Tl3SystemPrim 

constructor Tl3SystemPrim.Create{(anOwner: TObject)};
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 FShowObjectsWindow := True;
 f_ObjectCache := nil;
 if (g_l3System = nil) then
  g_l3System := Self;
 f_CacheCS := TCriticalSection.Create;
 f_GlobalCS := TCriticalSection.Create;
 f_CanCache := true;
 inherited;
end;

function Tl3SystemPrim.pm_GetLocalMemUsed     : Long;
begin
 Result := l3MemUtils.f_LocalMemUsed;
end;

function Tl3SystemPrim.pm_GetGlobalMemUsed     : Long;
begin
 Result := l3MemUtils.f_GlobalMemUsed;
end;

function Tl3SystemPrim.pm_GetCanCache: Boolean;
  {-}
begin
 Result := f_CanCache;
 {$IfNDef l3ConsoleApp}
 if Result AND (Application <> nil) AND Application.Terminated then
 begin
  Result := false;
  f_CanCache := false;
  if (Self = g_l3System) then
   Self.DownBegins;
 end;//Result
 {$EndIf  l3ConsoleApp}
end;

function Tl3SystemPrim.pm_GetSysLocalMemUsed: Long;
  {-}
begin
 {$IfDef l3DirectUseSystemMemManager}
 Result := AllLocalMemUsed;
 {$Else  l3DirectUseSystemMemManager}
 Result := AllLocalMemUsed - LocalMemUsed - ObjectMemUsed;
 {$EndIf l3DirectUseSystemMemManager}
end;

function Tl3SystemPrim.CheckResources: AnsiString;
  {virtual;}
  {-}
begin
 Result := EmptyStr;
 if (f_ObjectCount > 0) then
  Result := Result + Format('Objects = %d'+l3LeakSep, [f_ObjectCount]);
 if (l3MemUtils.f_LocalMemUsed > 0) then
  Result := Result + Format('LocalMem = %d'+l3LeakSep, [l3MemUtils.f_LocalMemUsed]);
 if (f_GlobalMemUsed > 0) then
  Result := Result + Format('GlobalMem = %d'+l3LeakSep, [f_GlobalMemUsed]);
end;

class procedure Tl3SystemPrim.CheckMaxes;
  {-}
begin
 inherited;
 with l3System do
 begin
  if (l3MemUtils.f_LocalMemUsed > MaxLocalMemUsed) then
   MaxLocalMemUsed := l3MemUtils.f_LocalMemUsed;
  if (f_GlobalMemUsed > MaxGlobalMemUsed) then
   MaxGlobalMemUsed := f_GlobalMemUsed;
  if (f_ObjectMemUsed > MaxObjectMemUsed) then
   MaxObjectMemUsed := f_ObjectMemUsed;
  if (f_ObjectCount > MaxObjectCount) then
   MaxObjectCount := f_ObjectCount;
  if (f_AllLocalMemUsed > MaxAllLocalMemUsed) then
   MaxAllLocalMemUsed := f_AllLocalMemUsed;
 end;//with l3System
end;

class procedure Tl3SystemPrim.StatMemAlloc(aSize: Long; aL3: Boolean); //override;
  {-}
begin
 inherited;
 l3StatMemAlloc(aSize, aL3);
end;
  
procedure Tl3SystemPrim.BeforeRelease;
  {override;}
  {-}
begin
 f_CanCache := false;
 inherited;
end;

procedure Tl3SystemPrim.CallExitProcs;
  {-}

 function _FreeItem(P: PPointer; Index: Long): Bool; far;
 begin
  if (P^ <> nil) then
   TProcedure(P^);
  P^ := nil;
  Result := true;
 end;

begin
 if (f_ExitProcs <> nil) then
  f_ExitProcs.IterateBackF(l3MaxIndex, l3MinIndex, l3L2IA(@_FreeItem));
 l3Free(f_ExitProcs);
end;

procedure Tl3SystemPrim.Release;
  {override;}
  {-}

var
 errSt      : AnsiString;
 {$IfDef l3TraceClasses}
 l_LeakForm : Tl3LeakObjectsForm;
 i          : Long;
 {$EndIf l3TraceClasses}
begin
 CallExitProcs;
 inherited;
 l3FreeStubs;
 errSt := CheckResources;
 if (errSt <> EmptyStr) then
 begin
  if True {$IfNDef nsTest} and FShowObjectsWindow {$EndIf} then
  begin
   {$IfDef l3TraceClasses}
   if (Application = nil) then
    Application := TApplication.Create(nil);
   l_LeakForm := Tl3LeakObjectsForm.Create(nil);
   try
    with l_LeakForm do
    begin
     memGeneral.Text := errSt;
     try
      if (f_ClassList = nil) OR (f_ClassList.Count = 0) then
      begin
       spMemo.Visible :=false;
       memClasses.Visible := false;
      end
      else
      begin
       with memClasses.Lines do
       begin
        BeginUpdate;
        try
         for i := 0 to f_ClassList.Count - 1 do
          Add(f_ClassList[i] + ' = ' + IntToStr(Long(f_ClassList.Objects[i])));
        finally
         EndUpdate;
        end;//try..finally
       end;//with memClasses
      end;//f_ClassList = nil..
     except
     end;//try..except
     Show;
     try
      SendMessage(Handle, CM_ACTIVATE, 0, 0);
      ModalResult := 0;
      repeat
       Application.HandleMessage;
      until ModalResult <> 0;
      SendMessage(Handle, CM_DEACTIVATE, 0, 0);
     finally
      Hide;
     end;{try..finally}
    end;{with l_LeakForm}
   finally
    l_LeakForm.Free;
   end;{try..finally}
   {$Else  l3TraceClasses}
   MessageBoxA(0, @ErrSt[1], 'INFORMATION', MB_OK or MB_ICONASTERISK);
   {$EndIf l3TraceClasses}
  end
  else
  begin
   l3System.Msg2Log('MEMORY LEAK DETECTED: %s', [errSt]);
   l3System.MemUsage2Log(True);
  end; // True {$IfNDef nsTest} and FShowObjectsWindow {$EndIf}
 end; // (errSt <> EmptyStr)
 {$IfDef l3TraceClasses}
 l3Free(f_ClassList);
 {$EndIf l3TraceClasses}
 {l3FreeStubs;}
 FreeAndNil(f_GlobalCS);
 FreeAndNil(f_CacheCS);
end;

procedure Tl3SystemPrim.AddExitProc(P: TProcedure);
  {-}
begin
 if (f_ExitProcs = nil) then
  f_ExitProcs := Tl3ProcedureList.Create;
 f_ExitProcs.Add(P);
end;

function Tl3SystemPrim.GlobalAlloc(Flags: Cardinal; Bytes: LongInt): THandle;
  {-}
var
 Sz : Long;
begin
 Result := Windows.GlobalAlloc(Flags, Bytes);
 Sz := GlobalSize(Result);
 l3InterlockedExchangeAdd(f_GlobalMemUsed, Sz);
 CheckMaxes;
end;

function Tl3SystemPrim.GlobalFree(Mem: THandle): THandle;
  {-}
var
 Sz : Long;
begin
 Sz := GlobalSize(Mem);
 Result := Windows.GlobalFree(Mem);
 if (Result = 0) then
  l3InterlockedExchangeAdd(f_GlobalMemUsed, -Sz);
end;

function Tl3SystemPrim.GlobalReallocPtr(P: Pointer; Bytes: Longint; Flags: Cardinal): Pointer;
  {-}
var
 Sz : LongInt;
begin
 Sz := GlobalSize(GlobalHandle(P));
 Result := Windows.GlobalReallocPtr(P, Bytes, Flags);
 if (Result <> nil) then
 begin
  l3InterlockedExchangeAdd(f_GlobalMemUsed, -Sz);
  Sz := GlobalSize(GlobalHandle(Result));
  l3InterlockedExchangeAdd(f_GlobalMemUsed, Sz);
  CheckMaxes;
 end;
end;

procedure Tl3SystemPrim.CorrectGlobalMemSize(aDelta: Long);
  {-}
begin
 l3InterlockedExchangeAdd(f_GlobalMemUsed, aDelta);
 CheckMaxes;
end;

function Tl3SystemPrim.GlobalRealloc(Mem: THandle; Bytes: Longint; Flags: Cardinal): THandle;
  {-}
var
 Sz : LongInt;
begin
 Sz := GlobalSize(Mem);
 Result := Windows.GlobalRealloc(Mem, Bytes, Flags);
 if (Result <> 0) then
 begin
  l3InterlockedExchangeAdd(f_GlobalMemUsed, -Sz);
  Sz := GlobalSize(Result);
  l3InterlockedExchangeAdd(f_GlobalMemUsed, Sz);
  CheckMaxes;
 end;
end;

function Tl3SystemPrim.Send(O: TObject; _Msg: uInt; _wParam: WParam; _lParam: LParam): LongInt;
var
 Message : TMessage;
begin
 with Message do
 begin
  Msg := _Msg;
  wParam := _wParam;
  lParam := _lParam;
  Result := 0;
 end;
 Translate(O, Message);
 Result := Message.Result;
end;

{$IfDef l3ConsoleApp}
{$Else  l3ConsoleApp}
type
  _TControl = class(TControl);
{$EndIf l3ConsoleApp}

procedure Tl3SystemPrim.Translate(O: TObject; var Message);
begin
 if (O <> nil) then
 begin
  {$IfDef l3ConsoleApp}
  O.Dispatch(Message);
  {$Else  l3ConsoleApp}
  if (O Is TControl) then
   _TControl(O).WndProc(TMessage(Message))
  else
   O.Dispatch(Message);
  {$EndIf l3ConsoleApp}
 end;{O <> nil..}
end;

{$IfDef l3TraceObjects}
procedure Tl3SystemPrim.RegisterObject(anObject: TObject; aStoreInPool : Bool);
  {-}
{$IfDef l3TraceClasses}
var
 i : Long;
{$EndIf l3TraceClasses}
begin
 if (anObject <> nil) AND (anObject <> Self) then
 begin
  {$IfDef l3TraceClasses}
  f_CacheCS.Enter;
  try
   if (f_ClassList = nil) then
   begin
    f_ClassList := Tl3StringListPrim.Create;
    f_ClassList.Sorted := true;
   end;{f_ClassList = nil}
   with f_ClassList do
    if Find(anObject.ClassName, i) then
     Objects[i] := Pointer(Long(Objects[i]) + 1)
    else
     AddObject(anObject.ClassName, Pointer(1));
  finally
   f_CacheCS.Leave;
  end;//try..finally
  {$EndIf l3TraceClasses}
  l3InterlockedIncrement(f_ObjectCount);
  //Inc(f_ObjectCount);
  CheckMaxes;
  if not aStoreInPool then
   IncObjectMemUsed(anObject.InstanceSize);
 end;//anObject <> nil
end;

procedure Tl3SystemPrim.UnRegisterObject(anObject: TObject; aStoreInPool : Bool);
  {-}
{$IfDef l3TraceClasses}
var
 i : Long;
{$EndIf l3TraceClasses}
begin
 if (anObject <> nil) AND (anObject <> Self) then
 begin
  if not aStoreInPool then
   DecObjectMemUsed(anObject.InstanceSize);
  l3InterlockedDecrement(f_ObjectCount);
  //Dec(f_ObjectCount);
  {$IfDef l3TraceClasses}
  if (f_ClassList <> nil) then
  begin
   f_CacheCS.Enter;
   try
    with f_ClassList do
     try
     if Find(anObject.ClassName, i) then
     begin
      Objects[i] := Pointer(Long(Objects[i]) - 1);
      if (Long(Objects[i]) = 0) then
       Delete(i);
     end;//Find..
     except
     Find(anObject.ClassName, i);
     end;//try..except
   finally
    f_CacheCS.Leave;
   end;//try..finally
  end;//f_ClassList <> nil
  {$EndIf l3TraceClasses}
 end;//anObject <> nil
end;
{$EndIf l3TraceObjects}

procedure Tl3SystemPrim.IncObjectMemUsed(Sz: Long);
  {-}
begin
 Inc(f_ObjectMemUsed, Sz);
 CheckMaxes;
end;

procedure Tl3SystemPrim.DecObjectMemUsed(Sz: Long);
  {-}
begin
 Dec(f_ObjectMemUsed, Sz);
end;

function Tl3SystemPrim.AddToCache(O        : TObject;
                                  const aP : Tl3CacheProcs): Bool;
  {* - добавить объект в кэш объектов. }
var
 l_ClassCache  : Tl3ClassCacheEntry;
 l_ObjectCache : Tl3ObjectCache;
begin
 if (O = nil) then
  Result := false
 else
 begin
  aP.aBeforeAddToCache;
  f_CacheCS.Enter;
  try
   l_ClassCache := aP.aGet;
   if (l_ClassCache <> nil) then
    Result := (l_ClassCache.Add(O) >= 0)
   else
   begin
    if (f_ObjectCache = nil) then
     f_ObjectCache := Tl3ObjectCache.Make;
    l_ObjectCache := f_ObjectCache;
    Assert(l_ObjectCache <> nil);
    l_ClassCache := Tl3ClassCacheEntry.Create;
    try
     l_ObjectCache.Add(l_ClassCache);
     aP.aSet(l_ClassCache);
     Result := (l_ClassCache.Add(O) >= 0);
    finally
     l3Free(l_ClassCache);
    end;//try..finally
   end;//l_ClassCache <> nil
   Assert(Result);
  finally
   f_CacheCS.Leave;
  end;//try..finally
 end;//O = nil
end;

function Tl3SystemPrim.GetFromCache(aGet : Tl3GetClassCacheEntryEvent): Pointer;
  {* - получить объект класса C из кеша. }
var
 l_ClassCache : Tl3ClassCacheEntry;
begin
 f_CacheCS.Enter;
 try
  l_ClassCache := aGet;
  if (l_ClassCache = nil) then
   Result := nil
  else 
   Result := l_ClassCache.DeleteTailWithoutFree;
 finally
  f_CacheCS.Leave;
 end;//try..finally
end;

procedure Tl3SystemPrim.EnterGlobalCS;
  {-}
begin
 Assert(f_GlobalCS <> nil);
 f_GlobalCS.Enter;
end;

procedure Tl3SystemPrim.LeaveGlobalCS;
  {-}
begin
 Assert(f_GlobalCS <> nil);
 f_GlobalCS.Leave;
end;

// start class Tl3Thread

procedure Tl3Thread.Release;
  {virtual;}
  {-}
begin
end;

destructor Tl3Thread.Destroy;
  {override;}
  {-}
begin
 inherited;
 Release;
end;

procedure Tl3Thread.CallSynchronize(Method: TThreadMethod);
  {-}
begin
 Synchronize(Method);
end;

// start class Tl3ThreadContainer

constructor Tl3ThreadContainer.Create(aToolThreadClass: Rl3ToolThread = nil);
  //reintroduce;
  {-}
begin
 inherited Create;
 if (aToolThreadClass = nil) then
  f_ToolThreadClass := Tl3ToolThread
 else
  f_ToolThreadClass := aToolThreadClass;
 f_Suspended := true;
end;

procedure Tl3ThreadContainer.Release;
  //override;
  {-}
begin
 FreeThread;
 inherited;
end;

procedure Tl3ThreadContainer.Terminate;
  {-}
begin
 FreeThread;
end;

procedure Tl3ThreadContainer.Synchronize(aMethod: TThreadMethod);
  {-}
begin
 if Assigned(aMethod) then
 begin
  if (ToolThread = nil) then
   aMethod
  else
   ToolThread.Synchronize(aMethod);
 end;//Assigned(aMethod)  
end;
  
function Tl3ThreadContainer.pm_GetSuspended: Bool;
  {-}
begin
 Result := f_Suspended;
end;

procedure Tl3ThreadContainer.pm_SetSuspended(Value: Bool);
  {-}
begin
 if (f_Suspended <> Value) then
 begin
  f_Suspended := Value;
  if (ToolThread = nil) then
  begin
   if not Value AND not Terminated then
   begin
    f_Executed := False;
    if NeedThread then
    begin
     f_ToolThread := f_ToolThreadClass.Create(true);
     with ToolThread do
     begin
      f_ThreadContainer := Self;
      FreeOnTerminate := true;
      OnTerminate := ThreadTerminate;
      Suspended := Value;
     end;//with ToolThread
    end
    else
    begin
     Execute;
     f_Suspended := true;
    end;//NeedThread
   end;//not Value
  end
  else
   ToolThread.Suspended := Value;
 end;//f_Suspended <> Value
end;

procedure Tl3ThreadContainer.WaitFor;
  {-}
begin
 if (ToolThread <> nil) AND not f_Executed then
 try
  ToolThread.WaitFor;
 // Из за баги в VCL
 // Если у потока выставить FreeOnTerminate
 // И вызвать WaitFor, то когда поток забъется, то
 // внутри WaitFor вылетит InvalidHadleValue 
 except
  {$IfDef Delphi7}
  on EThread do begin
   // - ловим ошибки ожидания завершения нити
  end;//EThread
  {$EndIf Delphi7}
  on EOSError do begin
   // - ловим ошибки ожидания завершения нити
  end;//EOSError
 end;//try..except
 ThreadTerminate(Self);
end;

procedure Tl3ThreadContainer.Execute;
  {* - основная процедура нити. }
begin
 f_Executed := False;
 try
  DoExecute;
 finally
  f_Executed := true;
 end; 
end;

procedure Tl3ThreadContainer.FreeThread;
  {-}
begin
 f_Terminated := true;
 if (ToolThread <> nil) then
 begin
  with ToolThread do
  begin
   Terminate;
   PostThreadMessage(ThreadID, WM_Quit, 0, 0);
   Suspended := false;
  end;//with ToolThread
  Sleep(0);
 end;//ToolThread <> nil
 WaitFor;
// Suspended := true;
end;

procedure Tl3ThreadContainer.ThreadTerminate(Sender: TObject);
  {-}
begin
 f_ToolThread := nil;
 f_Suspended := true;
end;

function Tl3ThreadContainer.NeedContinue: Bool;
  //virtual;
  {* - необходимо продолжить выполнение нити? }
begin
 Result := not Terminated;
 if Result AND Suspended AND not NeedThread then
  Result := false; 
end;

function Tl3ThreadContainer.NeedThread: Bool;
  //virtual;
  {-}
begin
 Result := true;
end;

// start class Tl3ToolThread

procedure Tl3ToolThread.Execute;
  //override;
  {-}
begin
 if (f_ThreadContainer <> nil) then f_ThreadContainer.Execute;
end;

function l3KW(const aName : AnsiString;
              anID        : Integer): Tl3KW;
  {-}
begin
 Result.rName := aName;
 Result.rID := anID;
end;

function l3FormatArray(const anArray: array of Tl3ClipboardFormat): Tl3ClipboardFormats;
  {-}
var
 l_Len   : Integer;
 l_Index : Integer;
begin
 l_Len := Length(anArray);
 SetLength(Result, l_Len);
 for l_Index := 0 to Pred(l_Len) do
  Result[l_Index] := anArray[l_Index];
end;

function l3FormatArrayHas(const anArray : array of Tl3ClipboardFormat;
                          aValue        : Tl3ClipboardFormat): Boolean;
  {-}
var
 l_Index : Integer;
begin
 Result := false;
 for l_Index := Low(anArray) to High(anArray) do
  if (anArray[l_Index] = aValue) then
  begin
   Result := true;
   Exit;
  end;//anArray[l_Index] = aValue
end;

function l3SmallIntArray(const anArray: array of SmallInt): TSmallIntArray;
  {-}
var
 l_Len   : Integer;
 l_Index : Integer;
begin
 l_Len := Length(anArray);
 SetLength(Result, l_Len);
 for l_Index := 0 to Pred(l_Len) do
  Result[l_Index] := anArray[l_Index];
end;

function l3LongArray(const anArray: array of Long): TLongArray;
  {-}
var
 l_Len   : Integer;
 l_Index : Integer;
begin
 l_Len := Length(anArray);
 SetLength(Result, l_Len);
 for l_Index := 0 to Pred(l_Len) do
  Result[l_Index] := anArray[l_Index];
end;

function l3ByteArray(const anArray: array of Byte): Tl3Bytes;
  {-}
var
 l_Len   : Integer;
 l_Index : Integer;
begin
 l_Len := Length(anArray);
 SetLength(Result, l_Len);
 for l_Index := 0 to Pred(l_Len) do
  Result[l_Index] := anArray[l_Index];
end;

function l3CStringArray(const anArray: array of Il3CString): Tl3CStringArray;
  {-}
var
 l_Len   : Integer;
 l_Index : Integer;
begin
 l_Len := High(anArray) + 1;
 SetLength(Result, l_Len);
 for l_Index := 0 to Pred(l_Len) do
  Result[l_Index] := anArray[l_Index];
end;

function l3CStringArrayFromS(const anArray: array of AnsiString): Tl3CStringArray;
  {-}
var
 l_Len   : Integer;
 l_Index : Integer;
begin
 l_Len := High(anArray) + 1;
 SetLength(Result, l_Len);
 for l_Index := 0 to Pred(l_Len) do
  Result[l_Index] := l3CStr(anArray[l_Index]);
end;

function l3LongArrayCompare(const A, B: array of Long): Long;
  {-}
var
 l_ALen  : Integer;
 l_BLen  : Integer;
 l_Index : Integer;
begin
 l_ALen := Succ(High(A));
 l_BLen := Succ(High(B));
 if (l_ALen <> l_BLen) then
  Result := l_ALen - l_BLen
 else
 begin
  Result := 0;
  for l_Index := 0 to Pred(l_ALen) do
  begin
   Result := A[l_Index] - B[l_Index];
   if (Result <> 0) then
    break;
  end;//for l_Index
 end;//l_ALen <> l_BLen
end;

function l3CStringArrayEQ(const A, B: array of Il3CString): Boolean;
  {-}
var
 l_ALen  : Integer;
 l_BLen  : Integer;
 l_Index : Integer;
begin
 l_ALen := Succ(High(A));
 l_BLen := Succ(High(B));
 if (l_ALen <> l_BLen) then
  Result := false
 else
 begin
  Result := true;
  for l_Index := 0 to Pred(l_ALen) do
   if not l3Same(A[l_Index], B[l_Index]) then
   begin
    Result := false;
    break;
   end;//not l3Same(A[l_Index], B[l_Index])
 end;//l_ALen <> l_BLen
end;

function l3CStringArrayEmpty(const A: array of Il3CString): Boolean;
  {-}
var
 l_Index : Integer;
begin
 Result := (Length(A) = 0);
 if not Result then
 begin
  for l_Index := Low(A) to High(A) do
   if not l3IsNil(l3Trim(A[l_Index])) then
    Exit;
  Result := true;
 end;//not Result
end;

function l3StringArray(const anArray: array of AnsiString): Tl3StringArray;
  {-}
var
 l_Len   : Integer;
 l_Index : Integer;
begin
 l_Len := High(anArray) + 1;
 SetLength(Result, l_Len);
 for l_Index := 0 to Pred(l_Len) do
  Result[l_Index] := anArray[l_Index];
end;

function l3StringArrayEQ(const A, B: array of AnsiString): Boolean;
  //overload;
  {-}
var
 l_ALen  : Integer;
 l_BLen  : Integer;
 l_Index : Integer;
begin
 l_ALen := Succ(High(A));
 l_BLen := Succ(High(B));
 if (l_ALen <> l_BLen) then
  Result := false
 else
 begin
  Result := true;
  for l_Index := 0 to Pred(l_ALen) do
   if (A[l_Index] <> B[l_Index]) then
   begin
    Result := false;
    break;
   end;//A[l_Index] <> B[l_Index]
 end;//l_ALen <> l_BLen
end;

function l3StringArrayEmpty(const A: array of AnsiString): Boolean;
  {-}
var
 l_Index : Integer;
begin
 Result := (Length(A) = 0);
 if not Result then
 begin
  for l_Index := Low(A) to High(A) do
   if (Trim(A[l_Index]) <> '') then
    Exit;
  Result := true;
 end;//not Result
end;

function l3CatFormatArray(const A: array of Tl3ClipboardFormat;
                          const B: array of Tl3ClipboardFormat): Tl3ClipboardFormats;
  {-}
var
 l_ALen  : Integer;
 l_BLen  : Integer;
 l_Index : Integer;
begin
 l_ALen := Succ(High(A));
 l_BLen := Succ(High(B));
 SetLength(Result, l_ALen + l_BLen);
 for l_Index := 0 to Pred(l_ALen) do
  Result[l_Index] := A[l_Index];
 for l_Index := 0 to Pred(l_BLen) do
  Result[l_ALen + l_Index] := B[l_Index];
end;

function l3CatLongArray(const A : array of Long;
                        const B : array of Long): TLongArray;
  {-}
var
 l_ALen  : Integer;
 l_BLen  : Integer;
 l_Index : Integer;
begin
 l_ALen := Succ(High(A));
 l_BLen := Succ(High(B));
 SetLength(Result, l_ALen + l_BLen);
 for l_Index := 0 to Pred(l_ALen) do
  Result[l_Index] := A[l_Index];
 for l_Index := 0 to Pred(l_BLen) do
  Result[l_ALen + l_Index] := B[l_Index];
end;

function l3CL(const A : array of Long;
              B : Long): TLongArray;
  {-}
var
 l_ALen  : Integer;
 l_Index : Integer;
begin
 l_ALen := Succ(High(A));
 SetLength(Result, l_ALen + 1);
 for l_Index := 0 to Pred(l_ALen) do
  Result[l_Index] := A[l_Index];
 Result[l_ALen] := B;
end;

procedure l3RaiseOSError(anError: Integer; const aTail: AnsiString = '');
  {-}
var
 l_Error : EOSError;
begin
 if (anError <> 0) then
  l_Error := EOSError.CreateResFmt(@SOSError,
                                   [
                                    anError,
                                    SysErrorMessage(anError) + aTail
                                    {$IfDef XE}, ''{$EndIf} // - dummy
                                   ])
 else
  l_Error := EOSError.Create(SUnkOSError + aTail);
 l_Error.ErrorCode := anError;
 raise l_Error;
end;

function l3CStr(aStr: PResStringRec): Il3CString;
  //overload;
begin
 Result := Tl3CResString.MakeI(aStr);
end;

function l3CStr(const aNode: Il3SimpleNode): Il3CString;
  //overload;
begin
 Result := Tl3CNodeString.MakeI(aNode);
end;

function l3CStr(const aStr: AnsiString): Il3CString;
  //overload;
  {-}
begin
 Result := Tl3CDelphiString.MakeI(aStr);
end;

function l3CStr(const aStr: WideString): Il3CString;
  //overload;
begin
 Result := Tl3CWideString.MakeI(aStr);
end;

function l3CStr(const aStr: Tl3WString): Il3CString;
  //overload;
  {-}
var
 l_S : Tl3InterfacedString;
begin
 if l3IsNil(aStr) then
 begin
  Result := Tl3CEmptyString.Instance;
  Exit;
 end;//l3IsNil(aStr)
 if l3IsAnsi(aStr.SCodePage) then
 begin
  if (aStr.SLen = 1) then
  begin
   Result := Tl3OneByteCString.Make(aStr.S^);
   Exit;
  end//aStr.SLen = 1
  else
  if (aStr.SLen = 2) then
  begin
   Result := Tl3TwoByteCString.Make(PWord(aStr.S)^);
   Exit;
  end//aStr.SLen = 2
  else
  if (aStr.SLen = 4) then
  begin
   Result := Tl3FourByteCString.Make(PLong(aStr.S)^);
   Exit;
  end;//aStr.SLen = 4
 end;//l3IsAnsi(aStr.SCodePage)
 l_S := Tl3InterfacedString.Make(aStr);
 try
  Result := l_S;
 finally
  l3Free(l_S);
 end;//try..finally
end;
  
function l3CStr(const aStr: Tl3PrimString): Il3CString;
  //overload;
begin
 if (aStr = nil) then
  Result := nil
 else
 if not l3IOk(aStr.QueryInterface(Il3CString, Result)) then
  Result := l3CStr(aStr.AsWStr);
end;

// start class Tl3StringListPrim

function Tl3StringListPrim.CompareStrings(const S1, S2: String): Integer;
  //override;
  {-}
begin
 Result := CompareStr(S1, S2);
end;

// start class Tl3IntfString

constructor Tl3IntfString.Make(const aSt: Il3CString);
  {* - создает новую строку как копию aSt. }
begin
 inherited Create;
 f_St := aSt;
end;

procedure Tl3IntfString.Cleanup;
  //override;
  {-}
begin
 f_St := nil;
 inherited;
end;

function Tl3IntfString.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {-}
begin
 if IID.EQ(Il3CString) then
 begin
  Result.SetOk;
  if (f_St = nil) then
   Il3CString(Obj) := l3CStr('')
  else
   Il3CString(Obj) := f_St;
 end//IID.EQ(Il3CString)
 else
  Result := inherited COMQueryInterface(IID, Obj);
end;

function Tl3IntfString.GetAsPCharLen: Tl3PCharLenPrim;
  //override;
  {-}
begin
 Result := l3PCharLen(f_St);
end;

procedure Tl3IntfString.DoSetAsPCharLen(const Value: Tl3PCharLen);
  //override;
  {-}
begin
 f_St := l3CStr(Value);
end;

// start class Tl3DataIntfString

procedure Tl3DataIntfString.Cleanup;
begin
 f_Data := nil;
 inherited;
end;//Cleanup

function Tl3DataIntfString.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
begin
 Result := inherited COMQueryInterface(IID, Obj);
 if Result.Fail then
  if f_Data <> nil then
   Result := Tl3HResult_C(f_Data.QueryInterface(IID.IID, Obj))
  else
   Result.SetNoInterface;
end;//COMQueryInterface

constructor Tl3DataIntfString.Make(const aSt   : Il3CString;
                                   const aData : IInterface);
begin
 inherited Make(aSt);
 f_Data := aData;
end;//Make

// start class Tl3ObjPtrString

procedure Tl3ObjPtrString.Cleanup;
  //override;
  {-}
begin
 f_Object := nil;
 inherited;
end;

function Tl3ObjPtrString.pm_GetLinkedObject: TObject;
  //override;
begin
 Result := f_Object;
end;

procedure Tl3ObjPtrString.pm_SetLinkedObject(aValue: TObject);
  //override;
  {-}
begin
 f_Object := aValue;
end;

// start class Tl3ObjPtrIntfString

procedure Tl3ObjPtrIntfString.Cleanup;
  //override;
  {-}
begin
 f_Object := nil;
 inherited;
end;

function Tl3ObjPtrIntfString.pm_GetLinkedObject: TObject;
  //override;
begin
 Result := f_Object;
end;

procedure Tl3ObjPtrIntfString.pm_SetLinkedObject(aValue: TObject);
  //override;
  {-}
begin
 f_Object := aValue;
end;

// start class Tl3ObjRefString

constructor Tl3ObjRefString.Make(const aSt   : Tl3PCharLen;
                                 const anObj : Tl3ProtoObject);
begin
 Make(aSt);
 anObj.SetRefTo(f_Object);
end;

procedure Tl3ObjRefString.Cleanup;
begin
 l3Free(f_Object);
 inherited;
end;

function Tl3ObjRefString.pm_GetLinkedObject: TObject;
  //override;
  {-}
begin
 Result := f_Object;
end;

procedure Tl3ObjRefString.pm_SetLinkedObject(aValue: TObject);
  //override;
  {-}
begin
 Assert((aValue = nil) OR (aValue Is Tl3ProtoObject));
 l3Set(f_Object, aValue);
end;

// start class Tl3CResString

class function Tl3CResString.MakeI(const aStr: PResStringRec): Il3CString;
  {-}
var
 l_S : Tl3CResString;
begin
 l_S := Create;
 try
  l_S.f_S := aStr;
  Result := l_S;
 finally
  l3Free(l_S);
 end;//try..finally
end;

function Tl3CResString.pm_GetAsWStr: Tl3WString;
  {-}
begin
 if (f_St = '') then
  f_St := LoadResString(f_S);
 Result := l3PCharLen(f_St); 
end;

procedure Tl3CResString.Cleanup;
  //override;
  {-}
begin
 f_St := '';
 f_S := nil;
 inherited;
end;

// start class Tl3CNodeString

class function Tl3CNodeString.MakeI(const aNode: Il3SimpleNode): Il3CString;
  {-}
var
 l_S : Tl3CNodeString;
begin
 l_S := Create;
 try
  l_S.f_Node := aNode;
  Result := l_S;
 finally
  l3Free(l_S);
 end;//try..finally
end;

function Tl3CNodeString.pm_GetAsWStr: Tl3WString;
  {-}
begin
 if (f_Node = nil) then
  l3AssignNil(Result)
 else
  Result := f_Node.Text;
end;

procedure Tl3CNodeString.Cleanup;
  //override;
  {-}
begin
 f_Node := nil;
 inherited;
end;

// start class Tl3CWideString

class function Tl3CWideString.MakeI(const aStr: WideString): Il3CString;
  {-}
var
 l_S : Tl3CWideString;
begin
 l_S := Create;
 try
  l_S.f_S := aStr;
  Result := l_S;
 finally
  l3Free(l_S);
 end;//try..finally
end;

procedure Tl3CWideString.Cleanup;
  //override;
  {-}
begin
 f_S := '';
 inherited;
end;

function Tl3CWideString.pm_GetAsWStr: Tl3WString;
  {-}
begin
 Result := l3PCharLen(f_S);
end;

// start class Tl3CDelphiString

constructor Tl3CDelphiString.Create(const aStr: AnsiString);
  {-}
begin
 inherited Create;
 f_S := aStr;
end;

class function Tl3CDelphiString.MakeI(const aStr: AnsiString): Il3CString;
  {-}
var
 l_S : Tl3CDelphiString;
 l_Len : Integer;
begin
 if (l3StrRefCount(aStr) = -1) then
  Result := Tl3CConstDelphiString.MakeI(aStr)
 else
 if (aStr = '') then
  Result := Tl3CEmptyString.Instance
 else
 begin
  l_Len := Length(aStr);
  if (l_Len = 1) then
  begin
   Result := Tl3OneByteCString.Make(aStr[1]);
   Exit;
  end//l_Len = 1
  else
  if (l_Len = 2) then
  begin
   Result := Tl3TwoByteCString.Make(PWord(@aStr[1])^);
   Exit;
  end//l_Len = 2
  else
  if (l_Len = 4) then
  begin
   Result := Tl3FourByteCString.Make(PLong(@aStr[1])^);
   Exit;
  end;//l_Len = 4
  l_S := Create(aStr);
  try
   Result := l_S;
  finally
   l3Free(l_S);
  end;//try..finally
 end;//l3StrRefCount(aStr) = -1
end;

procedure Tl3CDelphiString.Cleanup;
  //override;
  {-}
begin
 f_S := '';
 inherited;
end;

function Tl3CDelphiString.pm_GetAsWStr: Tl3WString;
  {-}
begin
 Result := l3PCharLen(f_S);
end;

// start class Tl3CConstDelphiString

class function Tl3CConstDelphiString.MakeI(const aStr: AnsiString): Il3CString;
  {-}
var
 l_S : Tl3CConstDelphiString;
begin
 l_S := Create;
 try
  l_S.f_S := Pointer(aStr);
  Assert(AnsiSameStr(PAnsiChar(l_S.f_S), aStr));
  Result := l_S;
 finally
  l3Free(l_S);
 end;//try..finally
end;

procedure Tl3CConstDelphiString.Cleanup;
  //override;
  {-}
begin
 f_S := nil;
 inherited;
end;

function Tl3CConstDelphiString.pm_GetAsWStr: Tl3WString;
  {-}
begin
 Result := l3PCharLen(PAnsiChar(f_S), l3StrPtrLength(f_S));
end;

function CPUID_Supported: Boolean;
asm
  pushfd
  pop eax
  mov edx, eax
  xor eax, $200000
  push eax
  popfd
  pushfd
  pop eax
  xor eax, edx
  setnz al
end;

type
  TRegisters = record
    RegEAX, RegEBX, RegECX, RegEDX: Integer;
  end;

function GetCPUID(AInfoRequired: Integer): TRegisters;
asm
  push ebx
  push esi
  mov esi, edx
  {cpuid instruction}
  cpuid
  {Save registers}
  mov TRegisters[esi].RegEAX, eax
  mov TRegisters[esi].RegEBX, ebx
  mov TRegisters[esi].RegECX, ecx
  mov TRegisters[esi].RegEDX, edx
  pop esi
  pop ebx
end;

function SSE_Supported: Boolean;
  register;
asm
   push    ebx
   mov     eax, 1
   cpuid
   test    edx, $2000000
   jnz     @@found
   xor     eax, eax
   jmp     @@ret
@@found:
   mov     eax, 1
@@ret:
   pop     ebx
end;//asm

function MMX_Supported: Boolean;
var
  LReg: TRegisters;
begin
  if CPUID_Supported then
  begin
    {Get the CPUID}
    LReg := GetCPUID(1);
    {Bit 23 must be set for MMX support}
    Result := LReg.RegEDX and $800000 <> 0;
  end
  else
    Result := False;
end;

{$IfOpt D+}
procedure __BP(const aStr : AnsiString = '');
begin
end;
{$EndIf D+}

initialization
{!touched!}{$IfDef LogInit} WriteLn('W:\common\components\rtl\Garant\L3\l3Base.pas initialization enter'); {$EndIf}
 l3MemU := Tl3System; 
 {$IfDef l3UseMMX}
 if not MMX_Supported then
  raise Exception.Create('MMX not supported');
 {$EndIf l3UseMMX}
 {$IfDef l3UseSSE}
 if not SSE_Supported then
  raise Exception.Create('SSE not supported');
 {$EndIf l3UseSSE}
 //{$IfDef l3TraceSysGetMem}
 //l3InitMemManager;
 //{$EndIf l3TraceSysGetMem}
 //InitializeCriticalSection(l3StubHeadCS);
 l3System;
{!touched!}{$IfDef LogInit} WriteLn('W:\common\components\rtl\Garant\L3\l3Base.pas initialization leave'); {$EndIf}
finalization
 l3OutMemStat;
 l3FreeGlobal(g_l3System);
 DeleteCriticalSection(l3StubHeadCS);
 {$IfDef l3TraceSysGetMem}
 l3DoneMemManager;
 {$EndIf l3TraceSysGetMem}

end.

