unit l3Canvas;
{* - попытка реализации своего уровня абстракции над DeviceContext. }

{ Библиотека "Эверест"    }
{ Автор: Люлин А.В.       }
{ Модуль: l3Canvas - дополнительные функции для работы с графикой. }
{ Начат: 15.12.1996 01:55 }
{ $Id: l3Canvas.pas,v 1.277 2015/08/13 10:13:14 dinishev Exp $ }

// $Log: l3Canvas.pas,v $
// Revision 1.277  2015/08/13 10:13:14  dinishev
// {Requestlink:602009846}
//
// Revision 1.276  2015/07/01 12:07:04  dinishev
// Перекодируем 866, CP_Tatar правильно.
//
// Revision 1.275  2015/06/03 14:53:31  lulin
// - пытаемся разрулить зависимости.
//
// Revision 1.274  2015/06/03 13:55:18  lulin
// - пытаемся разрулить зависимости.
//
// Revision 1.273  2015/06/03 12:43:16  lulin
// - пытаемся разрулить зависимости.
//
// Revision 1.272  2015/01/13 10:21:50  dinishev
// {Requestlink:567554160}
//
// Revision 1.271  2014/04/24 12:26:11  lulin
// [$531960334]
//
// Revision 1.270  2014/04/22 15:59:07  kostitsin
// {requestlink: 530837402 }
//
// Revision 1.269  2014/03/18 15:57:08  lulin
// - перетряхиваем работу с тегами.
//
// Revision 1.268  2014/03/03 14:03:53  lulin
// - рефакторинг менеджера шрифтов.
//
// Revision 1.267  2014/02/17 16:26:02  lulin
// - избавляемся от ошибок молодости.
//
// Revision 1.266  2014/02/14 15:58:25  lulin
// - избавляемся от ошибок молодости.
//
// Revision 1.265  2013/12/25 11:41:58  lulin
// - чистим код.
//
// Revision 1.264  2013/12/03 07:49:50  dinishev
// {Requestlink:497228500}. Массив залитого не очищаем между страницами. :-)
//
// Revision 1.263  2013/09/06 15:05:51  kostitsin
// [$377162741]
//
// Revision 1.262  2013/08/19 13:19:04  dinishev
// Bug fix: отвалились тесты.
//
// Revision 1.261  2013/08/16 10:03:41  dinishev
// {Requestlink:278849102}
//
// Revision 1.260  2013/04/04 11:22:01  lulin
// - портируем.
//
// Revision 1.259  2012/11/01 07:09:29  lulin
// - вычищаем мусор.
//
// Revision 1.258  2012/10/26 19:42:23  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.257  2012/10/03 13:25:12  dinishev
// {Requestlink:397289202}
//
// Revision 1.256  2012/07/11 15:20:55  lulin
// - ловушка рекурсии.
//
// Revision 1.255  2012/05/12 13:26:56  kostitsin
// [$362130929]
//
// Revision 1.254  2012/03/14 14:16:23  lulin
// {RequestLink:344139764}
//
// Revision 1.253  2012/03/12 13:29:40  kostitsin
// [$344135978]
//
// Revision 1.252  2012/02/03 17:09:31  lulin
// {RequestLink:333548940}
// - рисуем изменения Жени на модели.
//
// Revision 1.251  2011/12/19 12:00:53  kostitsin
// http://mdp.garant.ru/pages/viewpage.action?pageId=317262150
//
// Revision 1.250  2011/11/15 18:31:34  lulin
// {RequestLink:232098711}
//
// Revision 1.249  2011/11/07 07:25:51  lulin
// {RequestLink:296632270}
//
// Revision 1.248  2011/10/20 09:30:48  lulin
// {RequestLink:281527555}.
//
// Revision 1.247  2011/10/20 08:24:35  lulin
// {RequestLink:281527555}.
//
// Revision 1.246  2011/10/14 15:23:34  dinishev
// {Requestlink:281520291}
//
// Revision 1.245  2011/09/26 09:43:35  lulin
// {RequestLink:287220465}.
//
// Revision 1.244  2011/09/08 13:36:50  lulin
// {RequestLink:278837795}.
//
// Revision 1.243  2011/08/29 18:14:24  lulin
// {RequestLink:278833302}.
//
// Revision 1.242  2011/08/29 15:54:20  lulin
// {RequestLink:278833302}.
//
// Revision 1.241  2011/08/26 16:34:02  lulin
// {RequestLink:278833302}.
//
// Revision 1.240  2011/08/26 14:47:02  lulin
// {RequestLink:278833302}.
//
// Revision 1.239  2011/08/23 13:12:56  lulin
// {RequestLink:255960842}.
//
// Revision 1.238  2011/07/20 19:30:26  lulin
// {RequestLink:228688745}.
//
// Revision 1.237  2011/07/20 16:29:04  lulin
// {RequestLink:273596235}.
//
// Revision 1.236  2011/06/21 13:50:07  lulin
// {RequestLink:265398068}.
//
// Revision 1.235  2011/06/21 10:48:24  lulin
// {RequestLink:265393897}.
//
// Revision 1.234  2011/05/23 11:27:39  dinishev
// [$266421641]
//
// Revision 1.233  2011/05/23 09:02:09  dinishev
// [$266421641]
//
// Revision 1.232  2011/05/18 17:46:00  lulin
// {RequestLink:266409354}.
//
// Revision 1.231  2011/05/17 14:55:22  lulin
// {RequestLink:266409354}.
//
// Revision 1.230  2011/05/16 18:46:48  lulin
// {RequestLink:266409346}.
//
// Revision 1.229  2011/01/21 15:35:49  dinishev
// [$185830965]
//
// Revision 1.228  2010/12/29 18:06:51  lulin
// {RequestLink:172988589}.
//
// Revision 1.227  2010/12/08 19:04:29  lulin
// {RequestLink:228688602}.
// - закругляем край у строки ввода.
//
// Revision 1.226  2010/11/25 09:30:19  lulin
// {RequestLink:243700219}.
//
// Revision 1.225  2010/10/26 13:03:05  lulin
// {RequestLink:237503905}.
//
// Revision 1.224  2010/10/19 12:58:53  lulin
// - не инициализируем метрики лишний раз.
//
// Revision 1.223  2010/10/13 15:50:58  lulin
// {RequestLink:210437077}.
//
// Revision 1.222  2010/10/13 14:08:11  lulin
// {RequestLink:210437077}.
//
// Revision 1.221  2010/04/21 11:21:27  dinishev
// [$200902555]
//
// Revision 1.220  2010/03/26 10:11:56  lulin
// - убран assert, ибо - падает.
//
// Revision 1.219  2010/03/25 12:27:06  dinishev
// [$185830296]
//
// Revision 1.218  2009/12/15 12:54:00  lulin
// - пул памяти наследуем от более простого контейнера.
//
// Revision 1.217  2009/11/06 15:49:54  dinishev
// [$159364047]
//
// Revision 1.216  2009/07/20 11:22:19  lulin
// - заставляем работать F1 после - {RequestLink:141264340}. №7, 32, 33.
//
// Revision 1.215  2009/07/17 09:07:55  lulin
// - bug fix: не работала инверсия цвета.
//
// Revision 1.214  2009/07/02 18:42:44  lulin
// - уменьшаем область видимости переменных.
//
// Revision 1.213  2009/07/02 18:34:03  lulin
// - избегаем лишней работы с регионами как с интерфейсами.
//
// Revision 1.212  2009/07/02 17:42:28  lulin
// - распиливаем канву на несколько групп методов.
//
// Revision 1.211  2009/07/02 15:26:46  lulin
// - выделяем базового предка.
//
// Revision 1.210  2009/07/02 13:35:28  lulin
// - выделяем примесь.
//
// Revision 1.209  2009/07/02 13:00:13  lulin
// - убираем ненужный метод.
//
// Revision 1.208  2009/07/01 17:10:32  lulin
// - стараемся не использовать стороннюю канву.
//
// Revision 1.207  2009/07/01 14:04:07  lulin
// - убрана ненужная функциональность.
//
// Revision 1.206  2009/06/26 12:02:43  lulin
// - убираем ненужную функциональность.
//
// Revision 1.205  2009/06/26 09:54:05  lulin
// - вычищено ненужной свойство.
//
// Revision 1.204  2009/06/26 07:01:32  lulin
// - наследуем канву от более простого объекта.
//
// Revision 1.203  2009/05/19 11:46:15  dinishev
// неправильный IFDEF
//
// Revision 1.202  2009/05/19 11:27:24  dinishev
// неправильное позиционирование в комментариях
//
// Revision 1.201  2009/05/14 08:41:30  dinishev
// <K> : 137469295
//
// Revision 1.200  2009/03/13 18:30:01  lulin
// - <K>: 139436530. Метод клонорования принтера вынесен в отдельный метод.
// - При клонировании принтера учитываем его настройки (в частностиразрешение).
// - Правим ошибку с размером страницы при нестандартном разрешении.
//
// Revision 1.199  2009/03/13 15:49:11  lulin
// - <K>: 139436530. [$138969466]. По-другому клонируем принтер. В самой канве.
//
// Revision 1.198  2009/03/13 15:18:44  lulin
// - по-другому правим [$138969466]. Клонируем принтер.
//
// Revision 1.197  2009/03/12 13:54:56  lulin
// - <K>: 139430195. Не перетираем обработчики изменения у шрифта и кисти.
//
// Revision 1.196  2009/03/11 13:28:32  lulin
// - <K>: 139430195. Принудительно сообщаем об изменении шрифта.
//
// Revision 1.195  2009/03/10 19:44:02  lulin
// - <K>: 138969466.
//
// Revision 1.194  2009/03/06 12:46:06  lulin
// - эксперименты для <K>: 138969466.
//
// Revision 1.193  2008/09/11 17:07:47  lulin
// - убираем ссылки на канву, <K>:89096241.
//
// Revision 1.192  2008/09/10 15:24:53  lulin
// - вычищены ненужные методы.
//
// Revision 1.191  2008/09/10 15:10:01  lulin
// - <K>: 89103130.
//
// Revision 1.190  2008/09/09 20:50:50  lulin
// - чистка кода.
//
// Revision 1.189  2008/09/09 15:40:14  lulin
// - удалены ненужные свойства.
//
// Revision 1.188  2008/09/02 13:54:05  lulin
// - написан комментарий.
//
// Revision 1.187  2008/09/02 13:44:23  lulin
// - <K>: 112722934.
//
// Revision 1.186  2008/09/01 15:45:05  lulin
// - чистка кода.
//
// Revision 1.185  2008/08/27 09:09:50  lulin
// - <K>: 110986138.
//
// Revision 1.184  2008/08/26 11:22:08  lulin
// - чистка кода.
//
// Revision 1.183  2008/08/26 10:42:53  lulin
// - чистка кода.
//
// Revision 1.182  2008/08/26 10:30:07  lulin
// - чистка кода.
//
// Revision 1.181  2008/08/26 10:07:21  lulin
// - чистка кода.
//
// Revision 1.180  2008/08/26 09:34:45  lulin
// - чистка кода.
//
// Revision 1.179  2008/08/25 14:11:17  lulin
// - упрощаем сигнатуру метода.
//
// Revision 1.178  2008/08/25 14:01:28  lulin
// - выкинут ненужный параметр.
//
// Revision 1.177  2008/08/25 13:32:51  lulin
// - чистка кода.
//
// Revision 1.176  2008/08/25 12:26:10  lulin
// - <K>: 109904426.
//
// Revision 1.175  2008/08/25 11:34:43  lulin
// - не добавляем точку к наклонным пробелам. <K>: 109904354.
//
// Revision 1.174  2008/08/25 11:03:26  lulin
// - пытаемся бороться с <K>: 109904354. Безуспешно.
//
// Revision 1.173  2008/08/25 10:39:29  lulin
// - чистка кода.
//
// Revision 1.172  2008/08/25 10:28:55  lulin
// - чистка кода.
//
// Revision 1.171  2008/08/20 10:24:00  lulin
// - <K>: 96481959.
//
// Revision 1.170  2008/08/19 13:38:54  oman
// - fix: Шаманим с троеточием на конце (K-109086173)
//
// Revision 1.169  2008/08/18 16:06:24  lulin
// - <K>: 109085576.
//
// Revision 1.168  2008/08/15 11:33:20  lulin
// - <K>: 109085213.
//
// Revision 1.167  2008/08/14 09:51:53  lulin
// - <K>: 96481959.
//
// Revision 1.166  2008/08/11 13:28:30  lulin
// - <K>: 96484293.
//
// Revision 1.165  2008/08/06 11:19:50  lulin
// - <K>: 96484670.
//
// Revision 1.164  2008/08/04 08:28:41  oman
// - fix: Не всегда учитывали _PasswordChar (K-96484670)
//
// Revision 1.163  2008/07/15 20:49:12  lulin
// - при рисовании формулы учитываем выделение.
//
// Revision 1.162  2008/07/15 20:23:35  lulin
// - при рисовании формулы учитываем выделение.
//
// Revision 1.161  2008/07/10 10:43:46  lulin
// - правильнее работаем с системными цветами.
//
// Revision 1.160  2008/06/05 08:54:24  lulin
// - <K>: 93261783.
//
// Revision 1.159  2008/05/28 09:22:52  lulin
// - <K>: 91851798.
//
// Revision 1.158  2008/05/20 10:55:40  lulin
// - bug fix: не компилировался Архивариус.
// - <K>: 90443881.
//
// Revision 1.157  2008/04/15 09:20:16  lulin
// - правим модель.
//
// Revision 1.156  2008/04/15 09:03:25  lulin
// - правим название директив - чтобы соответствовали смыслу.
//
// Revision 1.155  2008/04/15 08:23:45  dinishev
// Восстанавливаем старый редактор
//
// Revision 1.154  2008/04/01 08:18:40  lulin
// - <K>: 88639598.
//
// Revision 1.153  2008/03/20 09:48:40  lulin
// - cleanup.
//
// Revision 1.152  2008/03/19 13:40:58  lulin
// - <K>: 87589297.
//
// Revision 1.151  2008/03/18 14:13:46  lulin
// - рисуем канву на модели.
//
// Revision 1.150  2008/02/28 15:12:11  lulin
// - переносим nevTools на модель.
//
// Revision 1.149  2008/02/27 18:19:56  lulin
// - подгоняем код под модель.
//
// Revision 1.148  2008/02/21 10:55:15  lulin
// - упрощаем наследование.
//
// Revision 1.147  2008/02/14 17:09:14  lulin
// - cleanup.
//
// Revision 1.146  2008/02/07 17:08:37  lulin
// - избавляемся от излишне универсальных методов базовых списков.
//
// Revision 1.145  2008/02/07 14:44:45  lulin
// - класс _Tl3LongintList переехал в собственный модуль.
//
// Revision 1.144  2008/01/23 18:53:45  lulin
// - переносим библиотеку _AFW в common.
//
// Revision 1.143  2008/01/16 20:08:35  lulin
// - модуль afwVirtualCaret перенесен на модель.
//
// Revision 1.142  2008/01/11 13:04:29  dinishev
// не дергаем при создании канвы SetZoom, т.к. это приводит к лишней перерисовке редактора (см. K<79856149>)
//
// Revision 1.141  2007/12/29 12:24:01  oman
// - fix: Правильная отрисовка полей - опечетки в названиях (cq23109, c79303231)
//
// Revision 1.140  2007/12/29 11:50:24  oman
// - fix: Правильная отрисовка полей (cq23109, c79303231)
//
// Revision 1.139  2007/12/25 12:56:37  oman
// - new: Правый и левый отсуп у параметров страницы (cq23109)
//
// Revision 1.138  2007/12/24 22:38:47  lulin
// - удален ненужный модуль.
//
// Revision 1.137  2007/12/24 15:25:32  lulin
// - удалены ненужные файлы.
//
// Revision 1.136  2007/12/24 13:25:48  lulin
// - модуль l3InternalInterfaces полностью перенесен на модель.
//
// Revision 1.135  2007/12/05 12:35:11  lulin
// - вычищен условный код, составлявший разницу ветки и Head'а.
//
// Revision 1.134  2007/11/28 14:57:35  dinishev
// Поддержка выравнивания линий таблиц + совместимость с Арчи
//
// Revision 1.133  2007/10/31 16:24:32  lulin
// - поправлен спецификатор параметра.
//
// Revision 1.132  2007/10/29 14:16:06  oman
// - fix: Более правильная починка ЦК16480 (cq27213)
//
// Revision 1.131  2007/10/25 11:39:46  fireton
// - LineTo: повторное использование кода
//
// Revision 1.130  2007/10/23 07:51:42  lulin
// - пытаемся предоставить старый метафайл (пока безуспешно).
//
// Revision 1.129  2007/10/11 13:06:18  lulin
// - bug fix: не затирали предыдущий атомарный шрифт (<K>-57966824).
//
// Revision 1.128  2007/09/25 08:19:34  lulin
// - выравниваем текст по-вертикали относительно формул.
//
// Revision 1.127  2007/09/25 08:05:19  lulin
// - используем индекс атомарного шрифта, если он задан.
//
// Revision 1.126  2007/09/25 07:57:05  lulin
// - cleanup.
//
// Revision 1.125  2007/09/20 18:10:40  lulin
// - форматируем параграф с учетом того, что он может содержать сегменты с объектами.
//
// Revision 1.124  2007/09/20 16:25:16  lulin
// - cleanup.
//
// Revision 1.123  2007/08/23 11:25:48  lulin
// - убрано эмпирическое определение того, что строку не надо нарезать на подстроки, т.к. не всегда работало (CQ OIT5-21471).
//
// Revision 1.122  2007/08/22 09:05:12  oman
// - fix: Возвращали пустой результат, хотя снаружи этого никто не
//  ждет (cq26444)
//
// Revision 1.121  2007/08/20 18:41:53  lulin
// - cleanup.
//
// Revision 1.120  2007/08/14 19:31:59  lulin
// - оптимизируем очистку памяти.
//
// Revision 1.119  2007/08/14 14:30:12  lulin
// - оптимизируем перемещение блоков памяти.
//
// Revision 1.118  2007/08/02 10:37:10  lulin
// - добавлены структуры для оптимизации хранения строк.
//
// Revision 1.117  2007/07/24 18:14:49  lulin
// - собрался первый проект со сгенерированным модулем l3Interfaces.
//
// Revision 1.116  2007/04/13 11:36:23  lulin
// - используем родную канву для подсчетов.
//
// Revision 1.115  2007/04/09 08:30:28  lulin
// - переименовываем класс в соответствии с библиотекой.
//
// Revision 1.114  2007/04/03 14:18:12  lulin
// - не пытаемся переформатировать однострочные заголовки.
//
// Revision 1.113  2007/04/03 13:52:56  lulin
// - увеличиваем ширину кнопки так, чтобы текст в итоге влез, без всяких многоточий.
//
// Revision 1.112  2007/04/02 05:46:46  lulin
// - bug fix: не учитывался флаг выравнивания по вертикали.
//
// Revision 1.111  2007/03/30 12:39:05  lulin
// - cleanup.
//
// Revision 1.110  2007/03/27 09:28:46  lulin
// - cleanup.
//
// Revision 1.109  2007/03/27 09:05:37  lulin
// - bug fix: на 2000-х Windows неправильно рисовались строчки шрифтом с суффиксом CYR (CQ OIT5-24756).
//
// Revision 1.108  2007/03/16 14:47:31  lulin
// - cleanup.
//
// Revision 1.107  2007/03/13 09:43:21  voba
// - bug fix от Шуры
//
// Revision 1.106  2007/02/12 18:06:19  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.105  2007/02/09 13:12:11  oman
// - fix: При рисовании на виртуальной канве неверно возвращали
//  размер канвы
//
// Revision 1.104  2007/01/30 15:24:24  lulin
// - текст ноды - теперь более простого типа.
//
// Revision 1.103  2007/01/17 15:05:55  lulin
// - по-другому защищаемся от потери цвета.
//
// Revision 1.102  2007/01/17 12:57:14  dinishev
// Bug fix: портился цвет шрифта в выделении
//
// Revision 1.101  2007/01/12 13:22:46  lulin
// - cleanup.
//
// Revision 1.100  2007/01/11 15:24:40  lulin
// - bug fix: не учитывалась кодовая страница шрифта.
//
// Revision 1.99  2007/01/11 14:09:49  oman
// - fix: После рисования для принтера восстанавливаем его
//  ориентацию, иначе неправильно считается количество страниц
//  (cq23948)
//
// Revision 1.98  2006/12/15 11:30:48  lulin
// - добавлена картинка со счетчиком ссылок.
//
// Revision 1.97  2006/12/07 11:39:59  lulin
// - рисуем панель средствами нашей канвы.
//
// Revision 1.96  2006/12/06 08:30:40  lulin
// - cleanup.
//
// Revision 1.95  2006/12/06 07:56:08  lulin
// - bug fix: не учитывали прозрачность.
//
// Revision 1.94  2006/12/04 15:39:41  lulin
// - модуль переименован в соответствии с его функциями.
//
// Revision 1.93  2006/12/04 13:32:26  lulin
// - cleanup.
//
// Revision 1.92  2006/11/30 14:51:45  lulin
// - cleanup.
//
// Revision 1.91  2006/11/30 14:47:26  lulin
// - cleanup.
//
// Revision 1.90  2006/11/30 14:37:55  lulin
// - cleanup.
//
// Revision 1.89  2006/11/30 14:34:23  lulin
// - cleanup.
//
// Revision 1.88  2006/11/30 14:30:28  lulin
// - cleanup.
//
// Revision 1.87  2006/11/30 14:15:44  lulin
// - убраны ненужные значения параметров по-умолчанию.
//
// Revision 1.86  2006/11/30 13:51:08  lulin
// - убран возвращаемый результат, который и так не используется.
//
// Revision 1.85  2006/11/30 13:46:02  lulin
// - не используем прямое преобразование кодовой страницы.
//
// Revision 1.84  2006/11/30 13:41:48  lulin
// - cleanup.
//
// Revision 1.83  2006/11/30 12:30:41  oman
// Merge from B_NEMESIS_6_4
//
// Revision 1.82  2006/11/27 10:06:54  lulin
// - cleanup.
//
// Revision 1.81  2006/11/27 09:14:53  lulin
// - cleanup.
//
// Revision 1.80  2006/11/27 08:43:26  lulin
// - cleanup.
//
// Revision 1.79  2006/11/25 14:36:23  lulin
// - cleanup.
//
// Revision 1.78  2006/11/24 12:54:07  lulin
// - bug fix: при подсчете высоты использовался не исходный прямоугольник, а исходный минус область отсечения, что неправильно (CQ OIT5-23742).
//
// Revision 1.77  2006/11/21 11:49:21  lulin
// - cleanup.
//
// Revision 1.76  2006/11/10 17:16:03  lulin
// - объединил с веткой.
//
// Revision 1.75  2006/11/08 08:52:13  oman
// Merge from B_NEMESIS_6_4
//
// Revision 1.74  2006/11/03 11:33:04  lulin
// - bug fix: не в ветке не компилировалась библиотека.
//
// Revision 1.73  2006/11/03 11:00:46  lulin
// - объединил с веткой 6.4.
//
// Revision 1.72.2.8.2.6  2006/11/30 12:22:42  oman
// - fix: правку для ЦК23742 внесли только для l3Rect, забыв про l3SRect
// - fix: На печати не учитывали ClipRect => обрезали недопечатанную
//  картинку (cq23783)
//
// Revision 1.72.2.8.2.5  2006/11/24 12:56:07  lulin
// - bug fix: при подсчете высоты использовался не исходный прямоугольник, а исходный минус область отсечения, что неправильно (CQ OIT5-23742).
//
// Revision 1.72.2.8.2.4  2006/11/10 10:38:49  lulin
// - позиционируемся за буквой, если курсор перевалил за половину символа (CQ OIT5-23191).
//
// Revision 1.72.2.8.2.3  2006/11/09 13:31:59  lulin
// - bug fix: если каретка не нужна, то и не рисуем ее.
//
// Revision 1.72.2.8.2.2  2006/11/08 09:58:11  lulin
// - cleanup.
//
// Revision 1.72.2.8.2.1  2006/11/08 08:48:14  oman
// - fix: При отрисовке каретки не передвигали _WindowOrg (cq23366)
//
// Revision 1.72.2.8  2006/11/02 16:24:09  lulin
// - cleanup.
//
// Revision 1.72.2.7  2006/10/25 10:04:35  lulin
// - bug fix: неправильно работали с курсором в ветке.
//
// Revision 1.72.2.6  2006/10/18 10:54:01  lulin
// - cleanup.
//
// Revision 1.72.2.5  2006/10/16 13:05:06  lulin
// - пытаемся оптимизировать скроллирование по-горизонтали.
//
// Revision 1.72.2.4  2006/10/16 09:03:11  lulin
// - cleanup.
//
// Revision 1.72.2.2  2006/10/16 08:41:28  lulin
// - bug fix: падали при печати документов с разрывами разделов (CQ OIT5-22830).
//
// Revision 1.72.2.1  2006/10/12 14:08:10  lulin
// - bug fix: при запрещенной отрисовке направильно подсчитывались заполненные регионы.
//
// Revision 1.72  2006/09/29 14:53:53  lulin
// - рамка теперь содержит свои размеры внутри себя.
//
// Revision 1.71  2006/09/29 14:10:33  lulin
// - учитываем нижний отступ нижней части рамки.
//
// Revision 1.70  2006/09/29 13:46:28  lulin
// - учитываем бесконечность рамок.
//
// Revision 1.69  2006/09/29 13:38:55  lulin
// - убрана двойная отрисовка текста рамок.
// - панели заголовков групп в КЗ теперь рисуются корректно.
//
// Revision 1.68  2006/09/29 13:13:17  lulin
// - учитываем верхний и левый отступы рамки.
//
// Revision 1.67  2006/09/29 12:48:00  lulin
// - стек цвета текста переехал на канву.
//
// Revision 1.66  2006/09/29 12:37:20  lulin
// - стек цвета текста переехал на канву.
//
// Revision 1.65  2006/09/29 12:20:19  lulin
// - на канве выделена процедура рисования рамки.
//
// Revision 1.64  2006/09/27 15:39:04  lulin
// - сделан стек отрисованных регионов.
//
// Revision 1.63  2006/09/27 15:23:13  lulin
// - стек начал координат перенесен на канву.
//
// Revision 1.62  2006/09/27 15:09:04  lulin
// - cleanup.
//
// Revision 1.61  2006/09/25 13:56:56  lulin
// - bug fix: у контролов терялась рамка оформления.
//
// Revision 1.60  2006/09/25 08:55:16  lulin
// - автоматизирован процесс подсчета размеров листьевых параграфов.
//
// Revision 1.59  2006/09/22 06:02:44  oman
// - fix: При отрисовке учитываем высоту нижнего колонтитула с
//  подправкой отрисовки нижнего отсутпа (cq22565)
//
// Revision 1.58  2006/08/25 06:03:27  oman
// - fix: Если в принтере выбран порт FILE, и при его выборе нажать
//  Отмена, то пытались все-равно печатать в несуществующий
//  файл (cq22394)
//
// Revision 1.57  2006/07/26 11:58:46  lulin
// - убрана ненужная информация о разбиении на страницы.
//
// Revision 1.56  2006/06/07 14:42:52  lulin
// - кешируем область отсечения, если ее уже получали.
//
// Revision 1.55  2006/06/07 13:56:24  lulin
// - не пытаемся рисовать текст, если он не попадает в область отсечения.
//
// Revision 1.54  2006/06/07 09:56:19  lulin
// - кешируем область отсечения, если ее уже получали.
//
// Revision 1.53  2006/06/07 08:00:43  lulin
// - уменьшаем лишние телодвижения при рисовании текста документа.
//
// Revision 1.52  2006/06/06 13:47:57  lulin
// - стараемся уменьшить число вызовов GDI.
//
// Revision 1.51  2006/06/06 11:58:41  lulin
// - cleanup.
//
// Revision 1.50  2006/06/06 10:38:14  lulin
// - по-другому отключаем нотификацию о смене масштаба - в Design-time.
//
// Revision 1.49  2006/06/06 10:04:55  lulin
// - отключаем нотификацию о смене масштаба - в Design-time.
//
// Revision 1.48  2006/06/05 14:23:13  lulin
// - боремся за производительность:
//  1. не вызываем реальные Lock/Unlock - т.к. они тормозят, а польза от них непонятна.
//  2. не запоминаем ненужные данные о табуляциях, если эти данные не понадобятся.
//
// Revision 1.47  2006/04/19 08:47:30  lulin
// - bug fix: в Preview практически никогда не рисовались рамки от комментариев пользователя (CQ OIT5-20339).
//
// Revision 1.46  2006/03/03 12:09:54  oman
// - fix: При интервальной печати не учитывались страницы-продолжения (cq19870)
//
// Revision 1.45  2006/02/27 11:53:31  lulin
// - bug fix: Integer overflow при позиционировании на параграфы без курсора (CQ OIT5-19797).
//
// Revision 1.44  2006/02/26 10:01:02  lulin
// - избавляемся от косвенного получения каретки у контрола - теперь канва владеет кареткой.
//
// Revision 1.43  2006/02/21 10:39:46  fireton
// - bugfix: черные квадраты на Win98 (00018747)
//
// Revision 1.42  2006/02/20 18:07:22  lulin
// - new behavior: для определения верхнего угла отрисовки, при подгонке экрана под курсор, используем виртуальную канву.
//
// Revision 1.41  2006/02/17 11:55:47  lulin
// - bug fix: не переворачивалось если поворот попадал на невидимую страницу.
//
// Revision 1.40  2006/02/17 11:10:49  lulin
// - bug fix: не начинался документ, не поворачивалась страница.
//
// Revision 1.39  2006/02/17 10:09:47  lulin
// - учитываем тройственность выбора.
//
// Revision 1.38  2006/02/17 09:46:18  lulin
// - попробовал полечить проблему печати своим способом.
//
// Revision 1.37  2006/02/17 09:30:45  lulin
// - откатил Ромины изменения.
//
// Revision 1.36  2006/02/16 18:49:43  demon
// - fix (Лукьянец): при смене ориентации по ходу печати не учитывались интервалы печати (cq19689, 19626)
//
// Revision 1.35  2006/02/15 15:58:58  lulin
// - борьба со скоростью скроллирования.
//
// Revision 1.34  2006/02/14 12:12:37  lulin
// - облегчаем функциональность виртуальной канвы.
//
// Revision 1.33  2006/02/14 11:46:27  lulin
// - облегчаем функциональность виртуальной канвы.
//
// Revision 1.32  2006/02/14 10:35:29  lulin
// - виртуальная канва теперь обходится без изпользования метафайла.
//
// Revision 1.31  2006/02/14 09:21:27  lulin
// - для виртуальной канвы не вызываем реальной функции рисования.
//
// Revision 1.30  2006/02/08 10:39:45  mmorozov
// - bugfix: обрезание управляющих символов при выводе;
//
// Revision 1.29  2006/02/06 14:21:11  lulin
// - bug fix: неправильно могли выводится практически любые строки.
//
// Revision 1.28  2006/02/06 11:53:15  mmorozov
// bugfix: обрезаем управляющие символы при выводе;
//
// Revision 1.27  2006/02/01 11:17:01  lulin
// - cleanup.
//
// Revision 1.26  2006/02/01 08:37:07  lulin
// - cleanup.
//
// Revision 1.25  2006/02/01 06:47:56  lulin
// - cleanup.
//
// Revision 1.24  2006/01/10 10:22:56  lulin
// - bug fix: отвалилась перерисовка при смене масштаба.
//
// Revision 1.23  2005/11/21 06:32:23  lulin
// - new behavior: при построении preview используем прозрачный фон.
//
// Revision 1.22  2005/11/21 05:35:09  lulin
// - cleanup.
//
// Revision 1.21  2005/11/10 08:25:52  lulin
// - убран устаревший метод.
//
// Revision 1.20  2005/11/01 14:05:29  lulin
// - bug fix: не печаталась текущая страница.
//
// Revision 1.19  2005/11/01 12:12:23  lulin
// - не пытаемся печатать дальше, если список страниц для печати закончился.
//
// Revision 1.18  2005/11/01 11:38:01  lulin
// - bug fix: сбрасываем счетчик страниц в начале документа.
//
// Revision 1.17  2005/11/01 11:25:48  lulin
// - bug fix: не печатались выбранные страницы.
//
// Revision 1.16  2005/10/31 16:36:56  migel
// - fix: утечка хендлов на win9x.
//
// Revision 1.15  2005/10/25 07:44:15  lulin
// - класс канвы переименован в соответствии с названием библиотеки.
//
// Revision 1.14  2005/10/25 07:30:15  lulin
// - cleanup.
//
// Revision 1.13  2005/10/24 12:36:50  lulin
// - bug fix: неправильно подгоняли экран по курсору - если курсор был ниже экрана.
//
// Revision 1.12  2005/10/12 13:38:23  lulin
// - bug fix: инвертированные строки рисовались через одну неправильным цветом.
//
// Revision 1.11  2005/10/12 09:52:46  lulin
// - bug fix: не всегда восстанавливался цвет текста (CQ OIT5-16901).
//
// Revision 1.10  2005/10/11 11:06:48  lulin
// - bug fix: деление на ноль при странных размерах окна.
//
// Revision 1.9  2005/10/03 11:22:06  fireton
// - bug fix: неправильно работал подсчет размера в _TabbedMultilineTextOut
//
// Revision 1.8  2005/09/19 11:38:04  fireton
// - bug fix: очередная затычка для Win 95/98/Me - не рисовал DrawTabbed
//
// Revision 1.7  2005/09/12 10:26:13  lulin
// - new behavior: чтобы черточка внизу документа не мерцала при сроллировании - рисуем правый и левый отступ в самый последний момент.
//
// Revision 1.6  2005/08/30 14:12:57  lulin
// - сделано выделение только параграфа.
//
// Revision 1.5  2005/07/04 06:51:20  lulin
// - bug fix: в документе, полученном как дерево, не рисовались Sub'ы.
//
// Revision 1.4  2005/05/30 11:38:35  fireton
// - bug fix: некорректный расчет позиций табуляции в _TabbedMultilineTextOut
//
// Revision 1.3  2005/05/27 14:42:36  lulin
// - базовый контрол переехал в быблиотеку L3.
//
// Revision 1.2  2005/05/27 09:44:30  lulin
// - базовая канва вывода переехала из Эвереста в L3.
//
// Revision 1.1  2005/05/26 17:44:41  lulin
// - базовая канва вывода переехала из Эвереста в L3.
//
// Revision 1.225.4.18  2005/05/26 16:29:54  lulin
// - директивы, настраивающие канву вывода перемещены в библиотеку L3.
//
// Revision 1.225.4.17  2005/05/26 16:09:32  lulin
// - избавил базовую канву вывода от знания об интерфейсах Эвереста.
//
// Revision 1.225.4.16  2005/05/26 16:01:46  lulin
// - избавил базовую канву вывода от знания о константах Эвереста.
//
// Revision 1.225.4.15  2005/05/26 15:34:57  lulin
// - базовая канва вывода теперь избавлена от знания о контролах управления.
//
// Revision 1.225.4.14  2005/05/26 13:19:28  lulin
// - new unit: _l3ScreenIC.
//
// Revision 1.225.4.13  2005/05/26 11:52:04  lulin
// - new unit: l3PrinterIC.
//
// Revision 1.225.4.12  2005/05/26 11:25:00  lulin
// - удален ненужный include.
//
// Revision 1.225.4.11  2005/05/26 11:21:28  lulin
// - удалено использование ненужного модуля.
//
// Revision 1.225.4.10  2005/05/26 11:06:11  lulin
// - bug fix: AV при неправильном освобождении регионов.
//
// Revision 1.225.4.9  2005/05/26 09:08:25  lulin
// - bug fix: не компилировалось.
//
// Revision 1.225.4.8  2005/05/24 15:38:10  lulin
// - cleanup: удалена ненужная версия метода.
//
// Revision 1.225.4.7  2005/05/24 15:30:32  lulin
// - new unit: evCanvasEx.
//
// Revision 1.225.4.6  2005/05/24 14:50:01  lulin
// - готовим модуль evGraph к переезду в L3.
//
// Revision 1.225.4.5  2005/05/24 13:53:29  lulin
// - rename unit: evFormattedLines -> l3FormattedLines.
//
// Revision 1.225.4.4  2005/05/24 13:43:29  lulin
// - rename unit: evLineAr -> l3LineArray.
//
// Revision 1.225.4.3  2005/05/24 13:11:48  lulin
// - bug fix: неправильно освобождали интерфейс.
//
// Revision 1.225.4.2  2005/05/24 12:48:15  lulin
// - для канвы используем интерфейс, а не объект.
//
// Revision 1.225.4.1  2005/05/18 12:42:46  lulin
// - отвел новую ветку.
//
// Revision 1.219.2.6  2005/05/18 12:32:08  lulin
// - очередной раз объединил ветку с HEAD.
//
// Revision 1.219.2.5  2005/04/28 09:18:29  lulin
// - объединил с веткой B_Tag_Box.
//
// Revision 1.219.2.4  2005/04/13 10:19:59  lulin
// - cleanup.
//
// Revision 1.219.2.3  2005/04/13 09:00:56  lulin
// - new method: _TevParaPainter.FocusRect.
//
// Revision 1.219.2.2  2005/04/13 07:48:57  lulin
// - ненужная функциональность спрятана под define.
//
// Revision 1.219.2.1  2005/04/13 07:33:32  lulin
// - cleanup.
//
// Revision 1.221  2005/04/16 11:41:22  lulin
// - слил с веткой. Теперь из ветки можно вытягивать ТОЛЬКО Everest.
//
// Revision 1.220  2005/04/16 10:41:05  lulin
// - для опции D- выключаем всякую трассировку.
//
// Revision 1.225  2005/05/12 05:29:13  mmorozov
// new: коррекция цветов фона и текста после инверсии цветов происходит с помощью цветовой схемы YIQ;
//
// Revision 1.224  2005/05/06 13:08:18  dk3
// - bug fix: ошибка при преобразовании Rect (преобразовывался и MaxInt)
//
// Revision 1.223  2005/05/05 09:28:56  mmorozov
// - не компилировалось;
//
// Revision 1.222  2005/05/05 08:11:57  mmorozov
// new behaviour: для Немезиса при инверсии цветов не производим дополнительные действия, если цвета фона и текста строго темные или светлые и "темность/светлось" у них разная;
//
// Revision 1.221  2005/04/16 11:41:22  lulin
// - слил с веткой. Теперь из ветки можно вытягивать ТОЛЬКО Everest.
//
// Revision 1.220  2005/04/16 10:41:05  lulin
// - для опции D- выключаем всякую трассировку.
//
// Revision 1.219  2005/04/05 13:50:42  am
// change: теперь _DrawText принимает во внимание флаги DT_LEFT, DT_RIGHT, DT_CENTER
//
// Revision 1.218  2005/04/05 13:26:52  mmorozov
// - использование l3IsDefaultCharset;
//
// Revision 1.217  2005/04/01 15:19:38  mmorozov
// new behaviour: Il3Font_AssignFont проверяем charset, если DEFAULT_CHARSET, то устанавливаем RUSSIAN_CHARSET;
//
// Revision 1.216  2005/03/30 09:19:33  mmorozov
// new: method Tl3Canvas.DrawFocusRect;
// new: property Tl3Canvas.Pen;
//
// Revision 1.215  2005/03/29 17:03:39  lulin
// - пытаемся поменьше делать телодвижений при имерении длины строки.
//
// Revision 1.214  2005/03/23 09:05:08  lulin
// - bug fix: попытка поборотся со Stack Overflow при получении канвы принтера когда внутри этого процесса возникали ошибки.
//
// Revision 1.213  2005/03/04 10:56:45  lulin
// - new behavior: еще раз изменен алгоритм изменения яркости цвета.
//
// Revision 1.212  2005/03/03 15:38:49  lulin
// - bug fix: не всегда было видно текст на "синем" фоне.
//
// Revision 1.211  2005/02/25 14:33:57  lulin
// - new behavior: печать теперь учитывает верхний отступ.
//
// Revision 1.210  2005/02/25 09:56:00  fireton
// - change: добавлен параметр aGap в функцию _TabbedMultilineTextOut
//       (теперь можно выводить текст с зазором между колонками)
//
// Revision 1.209  2005/02/24 16:05:41  lulin
// - new behavior: теперь печать документа учитывает нижний отступ. Борис, радуйся!
//
// Revision 1.208  2005/02/22 16:17:53  lulin
// - bug fix: более правильно устанавливаем область отсечения - чтобы параграфы не залезали на колонтитулы.
//
// Revision 1.207  2005/02/22 12:27:39  lulin
// - рефакторинг работы с Tl3Point и Tl3Rect.
//
// Revision 1.206  2005/02/22 10:28:18  lulin
// - new behavior: сделана возможность печати нижнего колонтитула.
//
// Revision 1.205  2005/02/21 18:38:53  lulin
// - в метод Il3HAFPainter._StartPage добавлен параметр aTop.
//
// Revision 1.204  2005/02/21 18:30:23  lulin
// - добавлено поле Tl3Canvas.f_BottomMargin.
//
// Revision 1.203  2005/02/21 18:24:16  lulin
// - учитываем небольшое непечатаемое поле (пока поставил четверть дюйма).
//
// Revision 1.202  2005/02/21 18:19:51  lulin
// - new behavior: учитываем нижнее поле при печати (пока зашил константу в пол-дюйма) (это я начал задачу CQ OIT5-7759).
//
// Revision 1.201  2005/02/02 13:31:48  lulin
// - bug fix: канва принтера разделялась между двумя канвами preview - в результате был AV при сложных условиях использования preview.
//
// Revision 1.200  2005/02/01 09:26:17  lulin
// - bug fix: было перепутано условие.
//
// Revision 1.199  2005/01/31 16:43:25  lulin
// - используем HSV для изменения яркости цвета.
//
// Revision 1.198  2005/01/31 16:32:04  lulin
// - используем структуру THSV.
//
// Revision 1.197  2005/01/31 16:22:20  lulin
// - переформатировал код.
//
// Revision 1.196  2005/01/31 16:18:19  lulin
// - используем тип TRGB.
//
// Revision 1.195  2005/01/31 16:14:24  lulin
// - добавлены процедуры HSV2RGB и RGB2HSV - с ними можно будет "поиграться" для получения корретного изменения яркости цветов фона и текста.
//
// Revision 1.193  2005/01/31 11:59:21  lulin
// - bug fix: при скроллировании вверх размножались картинки на панели сабов (CQ OIT5-9698).
//
// Revision 1.192  2005/01/28 12:27:48  voba
// -new beh. : доделано повышение контраста шрифт-фон
//
// Revision 1.191  2005/01/27 11:07:45  lulin
// - bug fix: иногда весь документ печатался на сером фоне.
//
// Revision 1.190  2005/01/26 13:30:19  lulin
// - bug fix: не очищались обработчики - _FontChanged и BrushChanged.
//
// Revision 1.189  2005/01/25 16:31:49  lulin
// - bug fix: для реального принтера неправильно вычислялась область вывода.
//
// Revision 1.188  2005/01/25 14:52:51  lulin
// - new behavior: при отсутствии принтера используем для preview канву экрана.
//
// Revision 1.187  2005/01/25 13:50:10  lulin
// - new behavior: если принтера нету, то считаем, что печатаем на странице A4.
//
// Revision 1.186  2005/01/21 18:05:37  dinishev
// Функция _DrawText получила необязательный параметр AFl: TObject = nil. Если этот параметр   	задан, то при вычислении размера не создается новый объект TevFormattedLines, а используется именно
//   параметр. При отрисовке текста - используется именно этот объект (без переформатирования!)
//
// Revision 1.185  2005/01/19 17:01:03  lulin
// - в очередной раз вычищен ненужный модуль.
//
// Revision 1.184  2005/01/13 16:22:49  voba
// - improvement корректировка цветов в инверсии
//
// Revision 1.183  2004/12/30 11:46:24  lulin
// - интерфейсы относящиеся к Preview переехали в библиотеку _AFW.
//
// Revision 1.182  2004/12/29 14:04:30  lulin
// - evGraph и Preview полностью переведены с класса TPrinter на интерфейс _Il3Printer.
//
// Revision 1.181  2004/12/27 15:54:37  dinishev
// убрано удаление пустой строки, т.к. можно удалить специально сделанное разбиение.
//
// Revision 1.180  2004/12/27 13:53:43  dinishev
// Подправлен пересчет координат hint'а
//
// Revision 1.179  2004/12/27 13:45:07  lulin
// - new behavior: вернул возможность печатать четные/нечетные страницы.
//
// Revision 1.178  2004/12/27 12:24:21  lulin
// - cleanup.
//
// Revision 1.177  2004/12/27 08:50:51  dinishev
// bugfix: при отрисовке многострочного текста иногда вставлялась пустая строчка.
//
// Revision 1.176  2004/12/25 16:07:01  lulin
// - многострочный Hint полностью переведен на evGraph (и подсчет и отрисовка).
//
// Revision 1.175  2004/12/14 13:33:24  voba
// - bug fix: выделениечерное на синем
//
// Revision 1.174  2004/12/10 12:41:02  lulin
// - сделана возможность построения Print-preview без печати во временный файл.
//
// Revision 1.173  2004/12/09 13:24:24  lulin
// - bug fix: не рисуем SoftEnter в конце строки.
//
// Revision 1.172  2004/12/08 15:09:59  lulin
// - поменьше пользуемся непроверенными функциями отрисовки Windows.
//
// Revision 1.171  2004/12/08 13:51:28  lulin
// - более интеллектуально ищем отсутствующие шрифты.
//
// Revision 1.170  2004/12/08 13:33:05  lulin
// - вместо набора символов CS_Default подставляем CS_Effective.
//
// Revision 1.169  2004/12/07 13:55:16  mmorozov
// bugfix: если задана 0-я ширина, то считаем, что размер области вывода расчитывается для SINGLELINE;
//
// Revision 1.168  2004/12/07 11:31:15  lulin
// - используем Tl3PCharLen вместо PAnsiChar, а также "правильные" функции расчета прямоугольника вывода.
//
// Revision 1.167  2004/12/07 10:52:35  lulin
// - bug fix: при пересчете координат не падаем когда подали MaxInt.
//
// Revision 1.166  2004/12/07 10:23:29  lulin
// - проще вычисляем размер прямоугольника для многострочного текста.
// - bug fix: неправильно рисовался многострочный табулированный текст (бралась не та координата).
// - "вырезаеем" кусок строки без Copy (просто подаем Len).
//
// Revision 1.165  2004/12/06 11:15:50  lulin
// - bug fix: не компилировалось.
//
// Revision 1.164  2004/12/06 10:26:43  lulin
// - cleanup.
//
// Revision 1.163  2004/12/04 11:48:29  mmorozov
// change: вывод текста с табуляцией осуществляется процедурой Tl3Canvas._DrawText (не Windows);
// change: _DrawText - самостоятельно выводим многострочный текст не прибегая к Windows._DrawText(... , DT_WORDBREAK);
// change: _DrawText - самостоятельно вычисляем область для многострочного текста Windows._DrawText(... , DT_CALCRECT);
//
// Revision 1.162  2004/11/29 17:32:32  lulin
// - bug fix: не всегда корректно обрабатывался шрифт параграфа.
//
// Revision 1.161  2004/11/29 16:35:43  lulin
// - переходим от TFont к Il3Font - для более корректной обработки цветов.
//
// Revision 1.160  2004/11/29 16:00:30  lulin
// - new prop: Tl3Canvas._Font: Il3Font.
//
// Revision 1.159  2004/11/29 15:48:14  lulin
// - rename prop: Tl3Canvas._Font -> _VCLFont.
//
// Revision 1.158  2004/11/29 15:28:26  lulin
// - bug fix: не обрабатывали значение Default у ForeColor.
//
// Revision 1.157  2004/11/16 17:28:46  lulin
// - bug fix: в выделении не рисовались рамки таблиц/блоков.
//
// Revision 1.156  2004/11/16 16:43:44  lulin
// - bug fix: неправильно отрисовывался фон инвертированных параграфов.
//
// Revision 1.155  2004/11/15 12:30:48  lulin
// - bug fix: неправильно рисовалась инверсия для параграфов, имеющих свой собственный BackColor.
//
// Revision 1.154  2004/11/10 13:00:43  fireton
// - bug fix: отрисовка юникода в превью под Win98
//
// Revision 1.153  2004/11/03 11:46:57  lulin
// - cleanup.
//
// Revision 1.152  2004/11/03 11:19:01  lulin
// - cleanup.
//
// Revision 1.151  2004/11/03 10:39:32  lulin
// - new unit: l3Region.
//
// Revision 1.150  2004/11/03 10:14:34  lulin
// - new unit: l3BitmapContainer.
//
// Revision 1.149  2004/11/03 09:55:13  lulin
// - new behavior: копирование параграфа в буфер обмена в формате CF_Bitmap теперь не завязано на тип параграфа, а использует интерфейс Il3Bitmap - в результате, кроме параграфов idBitmap в буфер обмена стали попадать все парагравы у которых атрибут tiObject поддерживает интерфейс Il3Bitmap, например idFormula.
//
// Revision 1.148  2004/11/02 16:39:17  lulin
// - bug fix: для параграфа с картинкой используем правильный контейнер.
//
// Revision 1.147  2004/10/26 16:31:56  lulin
// - new behavior: при подсчете страниц выставляем канве DrawEnabled := false, что по идее должно уменьшить количество реально вызываемых вызовов GDI.
//
// Revision 1.146  2004/10/22 14:00:23  lulin
// - refactoring: окружающие изолированы от знания про Metafile.
//
// Revision 1.145  2004/10/21 18:56:05  lulin
// - cleanup.
//
// Revision 1.144  2004/10/05 14:22:22  lulin
// - bug fix: заплатка для Win 9x где метафайлы неправильно выводят Unicode.
//
// Revision 1.143  2004/10/05 12:16:41  lulin
// - cleanup.
//
// Revision 1.142  2004/10/05 11:51:29  lulin
// - new method: Tl3Canvas._IsPreview.
//
// Revision 1.141  2004/10/01 14:45:58  fireton
// - change: переименование переменных
//
// Revision 1.140  2004/09/27 10:28:43  lulin
// - bug fix: не компилировалось с директивой l3ConsoleApp.
//
// Revision 1.139  2004/09/21 12:55:40  lulin
// - Release заменил на Cleanup.
//
// Revision 1.138  2004/09/01 13:00:44  law
// - new behavior: для нефокусированного редактора выводим неинвертированный текст.
//
// Revision 1.137  2004/09/01 12:27:59  law
// - new behavior: для редактора, для рисования выделения при включенной директиве evRealPaint используем системные цвета.
//
// Revision 1.136  2004/08/16 15:56:55  law
// - закомментировано l_Caret.CheckHidden, т.к. курсор МАЖЕТ при скроллинге.
//
// Revision 1.135  2004/08/16 13:28:48  law
// - bug fix: мусор при отрисовке параграфа, после того параграфа на котором стоит курсор.
// - bug fix: неправильно отрисовывался курсор после скроллинга.
//
// Revision 1.134  2004/08/02 11:25:13  law
// - bug fix: неправильно инициализировались метрики _DC и как следствие - неправильно рисовался текст (CQ OIT5-8487).
//
// Revision 1.133  2004/07/29 09:35:52  law
// - по совету друзей (Гарри) убрал прозрачность картинок в тексте.
//
// Revision 1.132  2004/07/29 09:00:49  law
// - bug fix: не компилировалось..
//
// Revision 1.131  2004/07/26 14:19:21  law
// - new behavior: для рисования картинок используем функции из ImageEn.
//
// Revision 1.130  2004/07/26 10:07:50  law
// - new behavior: картинки в тексте рисуем прозрачными.
//
// Revision 1.129  2004/07/19 09:34:06  nikitin75
// cleanup
//
// Revision 1.128  2004/07/19 09:30:43  nikitin75
// правка от Шуры
//
// Revision 1.127  2004/07/16 13:59:01  law
// - bug fix: Divizion by Zero при переходных процессах (CQ OIT5-8236).
//
// Revision 1.126  2004/07/12 15:27:03  law
// - bug fix: неправильно форматировались/печатались "почти влезающие" параграфы.
//
// Revision 1.125  2004/06/23 10:23:32  law
// - bug fix: не учитывалась смена ориентации бумаги - соответственно неправильно печатались альбомные листы.
//
// Revision 1.124  2004/06/21 17:04:23  law
// - оптимизирована процедура нарезки строки на подстроки - соответственно оптимизировано форматирование параграфов (это если верить AQTime, но на глаз не заметно).
//
// Revision 1.123  2004/06/18 07:56:18  voba
// - _move _FillRgn to peblic
//
// Revision 1.122  2004/06/17 15:58:53  law
// - свойство Empty переместилось с класса _Tl3Base на класс _Tl3SomeDataContainer.
//
// Revision 1.121  2004/06/02 11:20:49  law
// - bug fix: не работало с l3ConsoleApp.
//
// Revision 1.120  2004/06/02 11:14:33  law
// - bug fix: не компилировалось с l3ConsoleApp.
//
// Revision 1.119  2004/05/27 14:31:56  law
// - new methods: _Tl3_CBase.IsCacheable, _NeedStoreInPool.
//
// Revision 1.118  2004/05/19 12:17:57  law
// - bug fix: падало при присвоении пустого шрифта.
//
// Revision 1.117  2004/05/19 08:46:20  law
// - bug fix: падало при доступе к шрифту уже освобождаемой канвы.
//
// Revision 1.116  2004/05/17 13:18:40  nikitin75
// + используем сохраненные _DeviceCaps;
//
// Revision 1.115  2004/05/17 11:26:43  nikitin75
// используем запомненные PaperWidth/PaperHeight т.к. GetDeviceCaps на Me они недоступны между _StartPage-EndPage
//
// Revision 1.114  2004/05/14 14:55:51  law
// - перенесены типы из evTypesE в evTypes.
//
// Revision 1.113  2004/05/14 12:44:01  nikitin75
// try..except пока обращаемся к принтеру
//
// Revision 1.112  2004/05/14 12:37:49  law
// - new behavior: по-особому обрабатываем шрифты заканчивающиеся на ' Cyr'.
//
// Revision 1.111  2004/05/14 11:40:49  law
// - bug fix: оказалось, что функция DrawTextW не работает на Windows 9.x.
//
// Revision 1.110  2004/05/05 15:53:43  law
// - cleanup.
//
// Revision 1.109  2004/04/30 13:25:14  law
// - bug fix.
//
// Revision 1.108  2004/04/30 09:56:51  nikitin75
// если _Owner принтер, по дефолту отдаем его канву
//
// Revision 1.107  2004/04/29 14:57:00  law
// - bug fix: теперь табуляции корректно обрабатываются и в Unicode строке.
//
// Revision 1.106  2004/04/29 13:49:42  nikitin75
// + if f_Canvas._Font <> nil...
//
// Revision 1.105  2004/04/28 15:16:10  law
// - bug fix: неправильно рисовались русские строки шрифтом, не оканчивавшимся на CYR (временно отъехали табулированные строки).
//
// Revision 1.104  2004/04/19 16:08:15  law
// - new type: _Tl3PCharLenConst.
//
// Revision 1.103  2004/04/16 12:04:46  nikitin75
// в конструкторе Tl3Canvas: если _Owner is TPrinter, то PageOrientation бирем у него;
//
// Revision 1.102  2004/03/04 16:35:28  law
// - rename unit: VLister -> vtLister.
//
// Revision 1.101  2004/03/02 09:50:31  fireton
// - отступы при TabbedTextOut
//
// Revision 1.100  2004/01/27 08:27:43  fireton
// - add: в Il3TabStops добавлено NeedCutByTab - разрезание по табуляции
// - add: в Tl3Canvas добавлены и исправлены функции вывода текста с табуляцией
// - change: TEnhHeader теперь наследник от TevCustomPanel
// - change: TCustomvtLister теперь использует в качестве заголовка TEnhHeader
//
// Revision 1.99  2004/01/13 17:44:17  law
// - refactoring: выделяем из evTextSource методы рисования/печати.
//
// Revision 1.98  2003/12/27 18:29:35  law
// - new directive: l3NeedTabbedText - для Немезиса отключена, т.к. там по идее не бывает табуляций в параграфах.
//
// Revision 1.97  2003/11/05 17:23:02  nikitin75
// + добавлено свойство Tl3Canvas.PageWidthNumber;
//
// Revision 1.96  2003/10/30 16:18:46  law
// - new method: Tl3Canvas._MakeI.
//
// Revision 1.95  2003/10/29 15:37:57  law
// - cnange: добавлены модификаторы const.
//
// Revision 1.94  2003/10/22 14:06:27  nikitin75
// + procedure SetCurrentOffset(const aOffset: Integer); базовая (пустая) реализация;
//
// Revision 1.93  2003/10/21 06:51:15  nikitin75
// + TevCanvasEx: поддерживает цикл по выбранным листам;
//
// Revision 1.92  2003/10/17 13:08:12  nikitin75
// + procedure Il3Canvas._SetPageTop(const aTop: Integer); вызов метода сообщает сообщает Il3Canvas позицию в документе, с кторой начинается страница;
//
// Revision 1.91  2003/10/14 09:25:42  law
// - слили с веткой BPRINT_PREVIEW.
//
// Revision 1.90.2.1  2003/10/01 13:21:44  nikitin75
// + virtual modifier: BeginPaint, _EndPaint, _StartPage;
//
// Revision 1.90  2003/09/17 14:12:56  law
// - bug fix: integer overflow, кода отрисовывается закрывающееся окно (OIT500004649).
//
// Revision 1.89  2003/05/22 13:10:09  law
// - cleanup.
//
// Revision 1.88  2003/05/19 17:23:37  law
// - bug fix: пытаемся исправить Preview-режим.
//
// Revision 1.87  2003/05/16 14:42:22  law
// - new behavior: сделано рисование символов табуляции в зависимости от стиля выравнивания.
//
// Revision 1.86  2003/05/16 13:34:16  law
// - new behavior: сделано рисование табуляции символом-заполнителем.
//
// Revision 1.85  2003/05/16 12:05:22  law
// - new behavior: учитываем настраиваемые параметры табуляции.
//
// Revision 1.84  2003/05/15 16:14:39  law
// - new behavior: начинаем использование Il3TabStops (не забыть сделать Clone при возвращении Il3TabInfo).
//
// Revision 1.83  2003/05/15 15:14:58  law
// - new behavior: подготавливаем канву к возможности работы с настраиваемыми позициями табуляции.
//
// Revision 1.82  2003/05/14 15:48:10  law
// - bug fix: неправильно обрабатывались вложенные StartTabs/FinishTabs.
//
// Revision 1.81  2003/05/14 14:54:03  law
// - bug fix: неправильно позиционировался курсор в строке с табуляциями.
//
// Revision 1.80  2003/05/14 11:59:30  law
// - bug fix: строки с табуляцией неправильно разгонялись по ширине и неправильно выравнивались вправо.
//
// Revision 1.78  2003/05/14 08:07:38  law
// - bug fix: был AV при измерении пустой строки.
//
// Revision 1.77  2003/05/13 15:31:08  law
// - bug fix: в строке с табуляциями не рисовался "хвост" после выделения.
//
// Revision 1.76  2003/05/13 14:37:33  law
// - bug fix: неправильно позиционировался курсор в строке с табуляциями.
//
// Revision 1.75  2003/05/13 11:53:49  law
// - cleanup.
//
// Revision 1.74  2003/05/13 07:35:55  law
// - new behavior: делаем позиции табуляции кратными полудюйму.
//
// Revision 1.73  2003/05/12 16:07:56  law
// - bug fix: неправильно обрабатывались найденные табуляции (при граничных условиях - начало/конец строки).
//
// Revision 1.72  2003/05/12 14:49:25  law
// - bug fix: при нарезке абзаца на строки неправильно учитывалась табуляция.
//
// Revision 1.71  2003/05/12 14:25:59  law
// - new behavior: сделана обработка табуляций. Пока без учета правильных позиций, относительно реального текста.
//
// Revision 1.70  2003/05/12 13:24:16  law
// - new behavior: начинаем пытаться измерять табуляции по-правильному.
//
// Revision 1.69  2003/05/12 12:57:05  law
// - new behavior: в обычном режиме отображения сделана отрисовка табуляции в виде пробела.
//
// Revision 1.68  2003/05/12 12:51:26  law
// - new behavior: в режиме отображения спецсимволов сделана отрисовка табуляции в виде стрелочки.
//
// Revision 1.67  2003/05/12 09:20:23  law
// - rename proc: ev_plIsNil -> l3IsNil.
//
// Revision 1.66  2003/05/12 07:43:28  law
// - new methods: Il3InfoCanvas.StartTabs, Il3InfoCanvas.FinishTabs.
//
// Revision 1.65  2003/04/30 11:25:08  law
// - bug fix: в параграфе, разогнаном по ширине курсор позиционируется теперь именно на тот символ, на котором он стоит, а не на предыдущий пробел.
//
// Revision 1.64  2003/03/19 10:47:33  law
// - new directives: evForEE, _evNeedDisp, _evNotNeedDisp.
//
// Revision 1.63  2002/12/26 12:58:23  law
// - new dll: собрана pe.dll без evDisp.
//
// Revision 1.62  2002/10/10 13:26:21  law
// - bug fix: обрабатываем отсутствующий принтер.
//
// Revision 1.61  2002/10/07 11:00:48  law
// - bug fix: мусор при отрисовке текста, разогнанного по ширине, при выключенной директиве _l3UseWindowsWindowOrg.
//
// Revision 1.60  2002/08/02 08:32:13  law
// no message
//
// Revision 1.59  2002/08/01 11:23:43  law
// - bug fix: неправильно вычислялось _WindowOrg в режиме информационной канвы.
//
// Revision 1.58  2002/07/31 10:15:58  law
// - bug fix: неправильно устанавливалась область отсечения, после печати колонтитулов.
//
// Revision 1.57  2002/07/26 14:52:45  law
// - new prop: Il3Canvas.SWindowOrg.
//
// Revision 1.56  2002/07/26 12:37:20  law
// - bug fix: неправильно работала MoveWindowOrg.
// - comments.
//
// Revision 1.55  2002/07/26 10:08:03  law
// - new method version: Il3Canvas.Line.
//
// Revision 1.54  2002/07/26 09:55:19  law
// - new methods versions: Il3Canvas.MoveTo, Il3Canvas.LineTo.
//
// Revision 1.53  2002/07/25 17:18:46  law
// - new directive: _l3UseWindowsWindowOrg.
//
// Revision 1.52  2002/07/25 11:21:41  law
// - change: объединил с веткой SubAttrNode.
//
// Revision 1.51  2002/07/25 11:09:41  voba
// - new behavior: попытка полечить отрисовку
//
// Revision 1.50  2002/07/23 15:26:57  law
// - rename proc: evRectBnd -> l3RectBnd.
//
// Revision 1.49.2.1  2002/07/25 11:05:25  law
// no message
//
// Revision 1.49  2002/07/23 08:25:03  law
// - bug fix: опять неправильно разворачивались листы при нарезке по страницам в ширину.
//
// Revision 1.48  2002/07/16 15:44:50  law
// - some refactoring.
//
// Revision 1.47  2002/07/16 09:17:46  law
// - new behavior: теперь при печати выделения учитывается раздел в котором оно начинается.
//
// Revision 1.46  2002/07/16 07:50:12  law
// - cleanup and bugfix.
//
// Revision 1.45  2002/07/15 13:50:33  law
// - bug fix: поочередно вертелись страницы при печати.
//
// Revision 1.44  2002/07/12 17:44:11  law
// - new behavior: предварительно сделано синее выделение в дереве.
//
// Revision 1.43  2002/07/12 10:29:04  law
// - cleanup.
//
// Revision 1.42  2002/07/11 12:03:14  law
// - rename proc: evPoint -> l3Point, evRect -> l3Rect.
//
// Revision 1.41  2002/07/09 12:02:20  law
// - rename unit: evUnits -> l3Units.
//
// Revision 1.40  2002/04/25 12:11:56  law
// - optimization: изменяем методику распределения памяти.
//
// Revision 1.39  2002/02/14 15:27:50  law
// - optimization.
//
// Revision 1.38  2001/12/25 14:11:30  law
// - bug fix: в соответствии с задачей 1441.
//
// Revision 1.37  2001/11/23 13:30:46  law
// - new behavior: метод TevRegion.GetEmpty тепрь проверяет пустоту собственно региона.
//
// Revision 1.36  2001/11/22 15:01:36  law
// - new behavior: реализация _FillRectPrim при помощи _ExtTextOut.
//
// Revision 1.35  2001/11/22 14:21:00  law
// - cleanup.
//
// Revision 1.34  2001/11/22 14:06:42  law
// - optimize: 1. учитываем результат метода Combine.
//                      2. кешируем регионы.
//
// Revision 1.33  2001/11/22 13:17:53  law
// - bug fix: в EmptyFillRect два раза учитывался _WindowOrg.
//
// Revision 1.32  2001/11/22 12:58:56  law
// - optimize: FillEmptyRect.
//
// Revision 1.31  2001/11/19 15:08:46  law
// - rename class: Il3HAFPainter -> Tl3HAFPainter.
// - new interface: Il3HAFPainter.
//
// Revision 1.30  2001/09/25 12:31:00  law
// - bug fix: курсор при скроллинге иногда пачкал.
//
// Revision 1.29  2001/09/25 10:49:25  law
// - bug fix: странное поведение каретки при скроллинге.
//
// Revision 1.28  2001/09/07 08:53:01  law
// - rename procedures: evPointX -> l3PointX, evPointY -> l3PointY.
//
// Revision 1.27  2001/08/29 15:36:27  law
// - cleanup: удалены ненужные зависимости от Orpheus и SysTools.
//
// Revision 1.26  2001/08/29 07:01:08  law
// - split unit: l3Intf -> l3BaseStream, l3BaseDraw, l3InterfacedComponent.
//
// Revision 1.25  2001/07/27 15:46:03  law
// - comments: xHelpGen.
//
// Revision 1.24  2001/06/27 06:13:41  law
// - bug fix: когда правил печать - перепутал условие.
//
// Revision 1.23  2001/06/27 05:31:15  law
// - bug fix: изменена обработка ориентации страницы для широких секций.
//
// Revision 1.22  2001/06/26 17:02:32  law
// - bug fix: смена ориентации разрешена только на первой страницы широкой секции.
//
// Revision 1.21  2001/05/15 12:22:32  law
// - cleanup: немного подчищены ненужные типы и перекрестные ссылки между модулями.
// - comments: добавлены комментарии для xHelpGen.
//
// Revision 1.20  2001/04/20 14:03:52  law
// - cleanup: def_cm* => def_inch*, evCm2Pixel -> evCm2Inch.
//
// Revision 1.19  2001/04/19 17:14:44  law
// - new behavior: в первом приближении сделана подгонка ориентации страницы под ширину раздела.
//
// Revision 1.18  2001/04/19 13:01:55  law
// - new behavior: сделана печать широких страниц.
//
// Revision 1.17  2001/04/19 11:19:24  law
// - new prop: добавлено свойство PageOrientation.
//
// Revision 1.16  2001/04/18 16:44:16  law
// - new behavior: начата работа с параметрами текущего раздела для обеспечения печати на нескольких страницах в ширину.
//
// Revision 1.15  2001/04/13 13:52:21  law
// - cleanup.
//
// Revision 1.14  2001/04/04 14:26:34  law
// - new: добавлены директивы компиляции.
//
// Revision 1.13  2001/04/04 08:20:47  law
// - new interface: _Il3Region - представляет интерфейс для работы с hRgn.
//
// Revision 1.12  2001/04/04 06:59:00  law
// - bug fix: доделано рисование ячеек таблицы, объединенных по вертикали.
//
// Revision 1.11  2001/03/27 08:01:58  law
// - TevPoint -> Tl3Point, TevRect -> Tl3Rect.
//
// Revision 1.10  2001/01/31 15:10:40  law
// - изменен алгоритм изменения параметров разделов при печати документа - теперь документ из различных разделов печатается как одно задание, а не несколько.
//
// Revision 1.9  2001/01/31 10:37:30  law
// - оптимизировано использование QueryInterface.
//
// Revision 1.8  2001/01/04 09:44:51  law
// - bug fix: получение ClipRect для масштаба < 100%.
//
// Revision 1.7  2000/12/15 15:10:36  law
// - вставлены директивы Log.
//

{$Include l3Define.inc }

interface

uses
  Windows,

  Classes,
  Graphics,

  l3Interfaces,
  l3Defaults,
  l3MinMax,
  l3Types,
  l3Base,
  l3Memory,
  l3InternalInterfaces,
  l3Units,
  l3LongintList,
  l3SimpleObject,
  l3CanvasPrim,
  l3Region,
  l3PrinterInterfaces
  ;

type
  Tl3Canvas = class(Tl3CanvasPrim, Il3Canvas, Il3InfoCanvas, Il3Font, Il3EffectiveColors)
   {* - объект реализующий свой уровень абстракции над TCanvas и Device Context (hDC). }
    private
    // internal fields
      f_OldBrushChange  : TNotifyEvent;
      f_OldFontChange   : TNotifyEvent;
      f_CheckingColors  : Long;
      f_CheckingDrawing : Long;
      f_SuffixedFont    : Boolean;
    private
    // property fields
      f_AbortChecker : Il3AbortChecker;
      f_Zoom           : Long;
      f_FrameLines     : Il3FrameLines;
      f_etoFlags       : Word;
      f_Invert         : Long;
      f_Fore           : Long;
      f_DarkFore       : LongInt;
      f_Filled         : Tl3Region;
      f_Drawing        : Long;
      f_BackColor      : TColor;
      f_TextColor      : TColor;
      f_FontIndex      : Tl3FontIndex;
      f_FontIndexSet   : Tl3FontIndexes;
      f_WindowOrg      : Tl3Point;
      f_WindowOrgInited : Boolean;
      f_ClipRect       : Tl3Rect;
      f_ClipRectS      : Tl3SRect;
      f_Kerning        : Tl3MemoryPool;
      f_Canvas         : TCanvas;
      f_AlienCanvas    : Bool;
      f_Owner          : TObject;
      f_Painter        : Il3HAFPainter;
      f_AverageCharHeight  : Long;
      f_AverageCharWidth   : Long;
      f_pxAverageCharWidth : Long;
      f_TextMetrics        : TTextMetric;
      f_TextMetricsValid   : Bool;
      f_PageOrientation    : Tl3PageOrientation;
      f_SectionExtent      : Tl3Point;
      f_ConvertBuf         : PAnsiChar;
      f_Tabs               : Long;
      f_TabOffset          : Long;
      f_TabStops           : Il3TabStops;
      f_NotFocused         : Bool;
      f_DC                 : hDC;
      f_RegionBottomRight  : Tl3SPoint;
      f_WOs                : Tl3LongintList;
      f_Rgns               : Tl3LongintList;
      f_BCs                : Tl3LongintList;
      f_FCs                : Tl3LongintList;
      f_SaveOrientation    : Tl3PageOrientation;
      f_Font               : Il3Font;
      f_PasswordChar       : AnsiChar;
      f_OutString          : Tl3String;
      f_ConvertTable       : array [Bool] of Tl3MemoryPool;
      f_VirtualCanvas      : Il3Canvas;
    protected
    // property fields
      f_DCFlag             : TevDCFlag;
    private
    // event fields
      f_OnDrawSpecialChange : TNotifyEvent;
    protected
    // property methods
      function Get_EffectiveColors: Il3EffectiveColors;
        {-}
      function Get_FontColor: Tl3Color;
        {-}
      function  Get_PasswordChar: AnsiChar;
      procedure Set_PasswordChar(aValue: AnsiChar);
        {-}
      function  pm_GetInvert: Bool;
        {-}
      function  pm_GetDrawing: Bool;
        {-}
      function  pm_GetBackColor: TColor;
      procedure pm_SetBackColor(Value: TColor);
        {-}
      function  pm_GetDC: hDC;
        override;
      procedure pm_SetDC(aValue: hDC);
        {-}
      function  pm_GetTextColor: TColor;
      procedure pm_SetTextColor(Value: TColor);
        {-}
      function  pm_GetFontIndexSet: Tl3FontIndexes;
      procedure pm_SetFontIndexSet(Value: Tl3FontIndexes);
        {-}
      function  Get_Index: Tl3FontIndex;
      procedure pm_SetFontIndex(Value: Tl3FontIndex);
        {-}
      function  pm_GetWindowOrg: Tl3Point;
        override;
      procedure pm_SetWindowOrg(const Value: Tl3Point);
        override;
        {-}
      function  pm_GetSWindowOrg: Tl3SPoint;
        override;
      procedure pm_SetSWindowOrg(const Value: Tl3SPoint);
        override;
        {-}
      function  pm_GetClipRect: Tl3Rect;
        override;
      procedure pm_SetClipRect(const Value: Tl3Rect);
        override;
        {-}
      function  pm_GetGlobalClipRect: Tl3Rect;
        override;
        {-}
      function  pm_GetDrawSpecial: Bool;
      procedure pm_SetDrawSpecial(Value: Bool);
        {-}
      function  pm_GetPrinted: Bool;
      procedure pm_SetPrinted(Value: Bool);
        {-}
      procedure pm_SetNotFocused(Value: Bool);
        {-}
      function  pm_GetShowCursor: Bool;
      procedure pm_SetShowCursor(Value: Bool);
        {-}
      function  pm_GetDrawEnabled: Bool;
        {-}
      procedure pm_SetDrawEnabled(Value: Bool);
        {-}
      function  pm_GetCanvas: TCanvas;
      procedure pm_SetCanvas(Value: TCanvas);
        {-}
      function pm_GetFrameLines: Il3FrameLines;
        {-}
      procedure pm_SetPainter(const aValue: Il3HAFPainter);
        {-}
      function  pm_GetVCLFont: TFont;
      procedure pm_SetVCLFont(Value: TFont);
        {-}
      function  pm_GetBrush: TBrush;
      procedure pm_SetBrush(Value: TBrush);
        {-}
      function  pm_GetPen : TPen;
      procedure pm_SetPen(const aValue : TPen);
        {-}
      function  pm_GetZoom: Long;
      procedure pm_SetZoom(Value: Long);
        {-}
      function  pm_GetPageSetup: Il3PageSetup;
        {-}
      function  pm_GetPenWidth: Long;
        {-}
      function  pm_GetPageOrientation: Tl3PageOrientation;
      procedure pm_SetPageOrientation(Value: Tl3PageOrientation);
        {-}
      function  pm_GetSectionExtent: Tl3Point;
      procedure pm_SetSectionExtent(const Value: Tl3Point);
        {-}
      function pm_GetetoFlags: Word;
        {-}
      function GetGlobalClipRectWithZoom: Tl3Rect; override;
        {-}
    protected
    // interface methods
      // Il3Font
      function  Get_ForeColor: TColor;
      procedure Set_ForeColor(Value: TColor);
        {-}
      function  Get_BackColor: TColor;
      procedure Set_BackColor(Value: TColor);
        {-}
      function  Get_Height: Long;
      procedure Set_Height(Value: Long);
        {-}
      function  Get_Name: TFontName;
      procedure Set_Name(const Value: TFontName);
        {-}
      function  Get_Pitch: TFontPitch;
      procedure Set_Pitch(Value: TFontPitch);
        {-}
      function  Get_Size: Long;
      procedure Set_Size(Value: Long);
        {-}
      function  Get_Style: TFontStyles;
      procedure Set_Style(Value: TFontStyles);
        {-}
      procedure Il3Font.Set_Index = pm_SetFontIndex;
        {-}
      function  Get_Bold: Boolean;
      procedure Set_Bold(Value: Boolean);
        {-}
      function  Get_Italic: Boolean;
      procedure Set_Italic(Value: Boolean);
        {-}
      function  Get_Underline: Boolean;
      procedure Set_Underline(Value: Boolean);
        {-}
      function  Get_Strikeout: Boolean;
      procedure Set_Strikeout(Value: Boolean);
        {-}
      function  AssignFont(aFont: TFont): Bool;
        {-}
      function  IsAtomic: Boolean;
        {-}
      function  FM: Il3FontMetrics;
        {-}
      procedure Assign2Font(const aFont: Il3Font);
        {-}
      function HF: hFont;
        {-}  
      // Il3InfoCanvas 
      function  Get_Font: Il3Font;
        {-}
      procedure Set_Font(const Value: Il3Font);
        {-}
      function AdjustMarginsByPrintableArea(const aMargins: Tl3_Rect): Tl3_Rect;
        {* Откорректировать поля с учетом непечатаемой области }
      // Il3AbortChecker
      function Get_AbortChecker: Il3AbortChecker;
      procedure Set_AbortChecker(const aValue: Il3AbortChecker);
    protected
    // internal methods
      procedure DoStartDrawAAC(aType: TspBlockType); virtual;
        {-}
      procedure DoEndDrawAAC(const R: Tl3Rect); virtual;
        {-}
      procedure DoDrawLineTo(aX, aY: Integer);
        {-}
      procedure CheckColors;
        {-}
      procedure BrushChanged(ABrush: TObject);
        {-}
      procedure FontChanged(AFont: TObject);
        {-}
      function  xCheckFilled: Tl3Region;
        {-}
      procedure AddRgn(const aRgn: Il3Region);
        virtual;
        {-}
      procedure FreeDC;
        {-}
      procedure FreeAlienDC(aDC: hDC);
        virtual;
        {-}
      function AsIl3Canvas: Il3Canvas; override;
      function  CheckDrawing: Bool;
        {-}
      function  GetAlienDC: hDC;
        virtual;
        {-}  
      function  DrawingIsValid: Bool;
        {* - проверяет возможно ли рисование. }
      function  DeviceCaps(anIndex: Integer): Integer;
        override;
        {* - возвращает свойства устройства рисования. }
      procedure DoStartPage;
        virtual;
        {-}
      procedure StartPage;
        {-}
      procedure CheckOrientation;
        {-}  
      procedure Cleanup;
        override;
        {-}
      procedure FillRectPrim(const R: TRect);
        virtual;
        {-}
      function  WO(const aRect: Tl3Rect): Tl3SRect;
        overload;
        {-}
      function  WO(const aPt: Tl3Point): Tl3SPoint;
        overload;
        {-}
      function  WO(const aPt: Tl3SPoint): Tl3SPoint;
        overload;
        {-}
      procedure KerningTextOut(const P: Tl3Point;
                               const R: Tl3Rect;
                               const S: Tl3PCharLenPrim);
        overload;
        {-}
      procedure KerningTextOut(const P: Tl3SPoint;
                               const R: Tl3SRect;
                               const S: Tl3PCharLenPrim);
        overload;
        {-}
      function  GetTabWidth: Long;
        {-}
      function  KerningTextExtent(const S : Tl3PCharLenPrim): Tl3Point;
        virtual;
        {-}
      function  TabOffset: Long;
        {-}
      procedure RestoreTabInfo(const aTabInfo: Il3TabInfo);
        {-}
      procedure AssignDeviceCaps;
        override;
        {-}
      function  IsPreview: Boolean;
        virtual;
        {-}
      function GetClientRect: Tl3Rect;
        {-}
      function DoGetClientRect: Tl3Rect;
        virtual;
        {-}
      procedure Invalidate;
        virtual;
        {-}
      function  IsVirtual: Boolean;
        virtual;
        {-}
      procedure FireDCSetToNull;
        virtual;
        {-}
      procedure MakeScreenDC;
        {-}
      function  GetCaret: Il3Caret;
        virtual;
        {-}
      procedure DoAddRect(const aRect: Tl3SRect);
        {-}
      procedure DoAddRectPrim(const aRect: Tl3SRect);
        virtual;
        {-}
      procedure StartRegion;
        {-}
      procedure FinishRegion;
        {-}
      function  pm_GetRegionBottomRight: Tl3Point;
        {-}
      procedure RecordRegionBottomPrim(const aBottom: Tl3SPoint);
        {-}
      procedure PushWO;
        {-}
      procedure PopWO;
        {-}
      procedure PushBC;
        {-}
      function  TopBC: TColor;
        {-}
      procedure PopBC;
        {-}
      procedure PushFC;
        {-}
      procedure PopFC;
        {-}
      function CheckOutString(const aStr: Tl3PCharLen): Tl3PCharLen;
        {-}
      function CheckConvertTable(OEM : Bool): PAnsiChar;
        {-}
      function CheckConvertString(const aStr : Tl3PCharLen): Tl3PCharLen;
        {-}
      procedure InitFields;
        override;
        {-}
      procedure StartDrawAAC(aType: TspBlockType);
        {-}
      procedure EndDrawAAC(const R: Tl3Rect);
        {-}
    protected
    // internal properties
      property VCLFont: TFont
        read pm_GetVCLFont
        write pm_SetVCLFont;
        {-}
    public
    // public methods
      constructor CreateOwned(anOwner : TObject);
        {-}
      constructor CreateForPrinting(const aPrinter: Il3Printer);
        {-}
      class function Make: Il3Canvas;
        {-}
      class function MakeForPrinting(const aPrinter: Il3Printer): Il3InfoCanvas;
        {-}
      class function MakeForScreen: Il3InfoCanvas;
        {-}
      procedure SetCanvas(Value: TCanvas; Alien: Bool);
        virtual;
        {-}
      procedure AddRect(const aRect: Tl3SRect);
        {-}
      procedure DoFillForeRect(const R: Tl3SRect);
        virtual;
        {-}
      procedure FillForeRect(const R: Tl3SRect);
        {-}
      procedure FillRect(const R: Tl3SRect);
        overload;
        {-}
      procedure FillRect(const R: Tl3Rect);
        overload;
        {-}
      function  FillRgn(const Region: Il3Region): Bool;
        {-}
      procedure ExtTextOut(const aPt    : Tl3Point;
                           const aRect  : Tl3Rect;
                           const aSt    : Tl3PCharLenPrim;
                           aFl          : Tl3TextFormatFlag = l3_tffLeft;
                           aKerning     : PInteger = nil);
        overload;
        {-}
      procedure ExtTextOut(const P: Tl3SPoint;
                           const R: Tl3SRect;
                           const S: Tl3PCharLenPrim;
                           aFl: Tl3TextFormatFlag = l3_tffLeft;
                           aKerning: PInteger = nil);
        overload;
        {-}
      function  CaretLineOut(const aSt    : Tl3PCharLenPrim;
                             LineHeight   : Long;
                             aHidden      : Boolean;
                             var CaretPos : Long): Tl3Point;
        {* - выводит строку текста высотой LineHeight, со сдвигом курсора отрисовки.
             устанавливает курсор в CaretPos.
             Возвращает размеры выведенной строки. }
      function  DrawText(const aSt : Tl3PCharLenPrim;
                         var R     : TRect;
                         aFormat    : uInt;
                         AFl : TObject = nil): Il3MultiLines;
        {-}  
      function  StringOut(const P: Tl3Point; const Text: Tl3WString): Tl3Point;
        {-}
      function  InvertColor(aColor: TColor): TColor;
        {-}
      procedure StretchDraw(const R: Tl3Rect; Graphic: TGraphic);
        {-}
      function  LP2DP(const P: Tl3_Point; NeedZoom : Bool = false): Tl3SPoint;
        {-}
      function  LR2DR(const R: Tl3Rect): Tl3SRect;
        {-}
      function  DR2LR(const R: Tl3SRect): Tl3Rect;
        {-}
      function  TextExtent(const S : Tl3PCharLenPrim;
                           aNoTabs : Boolean = false): Tl3Point;
        {* - возвращает размеры строки текста в дюймах. }
      function  Pos2Index(W: Long; const S: Tl3PCharLen): Long;
        {* - находит индекс символа на рассоянии W дюймов от начала строки S. }
      function  Pos2IndexQ(W           : Long;
                           const S     : Tl3PCharLen;
                           var aNoTabs : Boolean): Long;
        {* - находит индекс символа на рассоянии W дюймов от начала строки S. }
      function  pxAverageCharWidth: Long;
        {* - средняя ширина символов контекста в пикселях. }
      function  AverageCharWidth: Long;
        {* - средняя ширина символов контекста в дюймах. }
      function  AverageCharHeight: Long;
        {* - средняя высота символов контекста в дюймах. }
      procedure MoveTo(const aPt: Tl3Point);
        overload;
        {-}
      procedure LineTo(const aPt: Tl3Point);
        overload;
        {-}
      procedure MoveTo(const aPt: Tl3SPoint);
        overload;
        {-}
      procedure LineTo(const aPt: Tl3SPoint);
        overload;
        {-}
      procedure Line(const A, B: Tl3Point);
        overload;
        {* - нарисовать линию. }
      procedure Line(const A, B: Tl3SPoint);
        overload;
        {* - нарисовать линию. }
      function  CaretExtent: Tl3Point;
        {-}
      procedure StartTabs(out theTabInfo  : Il3TabInfo;
                          const aTabStops : Il3TabStops;
                          aTabOffset      : Long = 0);
        overload;
        {-}
      procedure StartTabs(out theTabInfo : Il3TabInfo;
                          const aTabInfo : Il3TabInfo);
        overload;
        {-}
      procedure FinishTabs(var aTabInfo: Il3TabInfo);
        {-}
      function  TabInfo: Il3TabInfo;
        {-}
      function  EQ(const aCanvas: Il3InfoCanvas): Bool;
        {-}
      function  NeedOpenRealPage(aDoc : Boolean; ByWidth: Boolean = false): Tl3OpenPageResult;
        virtual;
        {-}
      procedure StartPrinterPage(aDoc : Boolean);
        virtual;
        {-}
      procedure BeginPaint;
        {-}
      procedure StartObject(anObjectID: Integer);
        {-}
      procedure DoStartObject(anObjectID: Integer);
        virtual;
        {-}
      procedure DoSetPageTop;
        virtual;
        {-}
      procedure SetPageTop;
        {-}
      procedure DoEndPaint;
        virtual;
        {-}
      procedure EndPaint;
        {-}
      procedure BeginDarkColor;
        {-}
      procedure EndDarkColor;
        {-}
      procedure BeginInvert;
        {-}
      procedure EndInvert;
        {-}
      function  CreateRectRgn(const aRect: Tl3SRect): Tl3Rgn;
        {-}
      function  OffsetRgn(const Rgn: Il3Region; const Pt: Tl3Point): Integer;
        {-}
      procedure FillEmptyRect(const R: Tl3Rect);
        overload;
        virtual;
        {-}
      procedure FillEmptyRect(const R: Tl3SRect);
        overload;
        virtual;
        {-}
      function  GetKerning(const aSt : Tl3PCharLenPrim;
                           aKerning  : PLong): Tl3Point;
        {-}
      function  TextOut(const P : Tl3Point;
                        const S : Tl3PCharLen;
                        FC      : TColor = clDefault;
                        BC      : TColor = clDefault): Tl3Point;
        {-}
      procedure SetDC(DC: HDC; Flag: TevDCFlag);
        {-}
      function  CheckKerning(Size: Long): Pointer;
        {-}
      function  NewPage(ByWidth: Bool = false): Boolean;
        {-}
      procedure SetCaret(const Origin, Extent: Tl3Point; aHidden: Bool = false);
        {-}
      procedure IncCaret(aDeltaX: Long);
        {-}
      function  DrawRgnOrBlock: Bool;
        {-}
      function  HasToDraw: Bool;
        {-}
      function  NearestColor(C: TColor): TColor;
        {-}
      procedure Lock;
        {-}
      procedure Unlock;
        {-}
      procedure MoveWindowOrg(const aDelta: Tl3Point);
        overload;
        {-}
      procedure MoveWindowOrg(const aDelta: Tl3SPoint);
        overload;
        {-}
      function  TextMetrics: PTextMetric;
        {-}
      procedure TabbedTextOut(const P: Tl3Point;
                              const R: Tl3Rect;
                              const S: Tl3PCharLenPrim;
                              const aTabStops: Il3TabStops);
        overload;
        {-}
      procedure TabbedTextOut(const P: Tl3SPoint;
                              const R: Tl3SRect;
                              const S: Tl3PCharLenPrim;
                              const aTabStops: Il3TabStops);
        overload;
        {-}
      procedure TabbedMultilineTextOut(const aSt    : Tl3PCharLenPrim;
                                       const Tabs   : Il3TabStops;
                                       var Rect     : Tl3Rect;
                                       Precalculate : Boolean;
                                       aGap         : Integer);
        {-}
      procedure DrawFocusRect(const aRect: Tl3SRect);
        {-}
    public
    // public properties
      property NotFocused: Bool
        read f_NotFocused
        write f_NotFocused;
        {-}
      property DCFlag: TevDCFlag
        read f_DCFlag;
        {-}
      property etoFlags: Word
        read pm_GetetoFlags
        write f_etoFlags
        default eto_Opaque{ + eto_Clipped};
        {-}
      property Invert: Bool
        read pm_GetInvert;
        {-}
      property Drawing: Bool
        read pm_GetDrawing;
        {-}
      property Canvas: TCanvas
        read pm_GetCanvas
        write pm_SetCanvas;
        {-}
      property FrameLines: Il3FrameLines
        read pm_GetFrameLines;
        {* - Парень, ответственный за выравниваение и отрисовку линий. }
      property Painter: Il3HAFPainter
        read f_Painter
        write f_Painter;
        {-}
      property BackColor: TColor
        read pm_GetBackColor
        write pm_SetBackColor
        default def_PaperColor;
        {-}
      property Printed: Bool
        read pm_GetPrinted
        write pm_SetPrinted;
        {-}
      property ShowCursor: Bool
        read pm_GetShowCursor
        write pm_SetShowCursor;
        {-}
      property DrawEnabled: Bool
        read pm_GetDrawEnabled
        write pm_SetDrawEnabled;
        {-}
      property Font: Il3Font
        read Get_Font
        write Set_Font;
        {-}
      property Brush: TBrush
        read pm_GetBrush
        write pm_SetBrush;
        {-}
      property Pen : TPen
        read pm_GetPen
        write pm_SetPen;
        {-}
      property TextColor: TColor
        read pm_GetTextColor
        write pm_SetTextColor
        default clBlack;
        {-}
      property FontIndexSet: Tl3FontIndexes
        read pm_GetFontIndexSet
        write pm_SetFontIndexSet
        default [];
        {-}
      property FontIndex: Tl3FontIndex
        read Get_Index
        write pm_SetFontIndex;
        {-}
      property PageNumber: Long
        read pm_GetPageNumber;
        {-}
      property PageWidthNumber: Long
        read pm_GetPageWidthNumber;
        {-}
      property PageSetup: Il3PageSetup
        read pm_GetPageSetup;
        {-}
      property PageOrientation: Tl3PageOrientation
        read pm_GetPageOrientation
        write pm_SetPageOrientation;
        {-}
      property SectionExtent: Tl3Point
        read pm_GetSectionExtent
        write pm_SetSectionExtent;
        {-}
      property DC: hDC
        read pm_GetDC;
        {-}
      property Owner: TObject
        read f_Owner;
        {-}
    public
    // public events
      property OnDrawSpecialChange: TNotifyEvent
        read f_OnDrawSpecialChange
        write f_OnDrawSpecialChange;
        {-изменение свойства - показывать или нет спецсимволы}
    public
    // public properties
      property DrawSpecial: Bool
        read pm_GetDrawSpecial
        write pm_SetDrawSpecial
        default false;
        {-}
      property Zoom: Long
        read f_Zoom
        write pm_SetZoom
        default def_Zoom;
        {-}
  end;//Tl3Canvas

  TRGB = packed record
   R : Byte;
   G : Byte;
   B : Byte;
  end;//TRGB

  THSV = packed record
   h : Integer;
   s : Integer;
   v : Integer;
  end;//THSV

  TYIQ = packed record
   y : Integer;
   i : Integer;
   q : Integer;
  end;//TYIQ

procedure RGB2HSV(const RGB : TRGB;
                  out HSV   : THSV);
  {-}
procedure HSV2RGB(out px    :TRGB;
                  const HSV : THSV);
  {-}
procedure RGB2YIQ(const RGB : TRGB;
                  out YIQ   : TYIQ);
  {-}
procedure YIQ2RGB(out RGB   : TRGB;
                  const YIQ : TYIQ);
  {-}
procedure CheckColorsYIQ(var aFC : TColor;
                         var aBC : TColor;
                         aDeltaY : Byte = 100);
  {* - коррекция цветов с использованием схемы YIQ.
       aDeltaY - разница интенсивности между цветами, которую необходимо
                 получить. }
procedure CheckColorsHSV(var aFore : TColor;
                         var aBack : TColor);
  {* - коррекция цветов с использованием схемы HSV. }
procedure CheckColors(var aFore : TColor;
                      var aBack : TColor);
  {* - общая корректировка цвета. }
function l3CharsToInch(aCount : Integer; aFontSize : Integer): Integer;
  {-}  

implementation

uses
  SysUtils,
  StrUtils,

  {$IfDef l3Requires_m0}
  m2XLtLib,
  {$EndIf l3Requires_m0}

  l3Const,
  l3Chars,
  l3Math,
  l3InterfacesMisc,
  l3String,
  l3StringEx,
  l3Utils,
  l3FontManager,
  l3LineArray,
  l3FormattedLines,
  l3ScreenIC,
  l3Bitmap,
  l3FontTools,
  l3VirtualCanvas,
  l3FrameLines,
  l3CacheableBase
  ;

const
 cMaxTextLength = 3000;  

procedure _GetKerning(aDC: HDC; aBuff: PAnsiChar; aSize: Longint; aKerning: PLong; aSWidth: PLong);
register;
var
 Sz : TSize;
asm
       push  esi
       push  edi
       push  ebx

       mov   ebx, eax

       mov   esi, aSWidth
       xor   eax, eax
       mov   [esi], eax

       jcxz  @@03

       mov   esi, edx
       mov   edi, aKerning

       lea   edx, Sz
       cld
       
 @@01: push  ecx
       push  edx

       push  edx
       xor   eax, eax
       inc   eax
       push  eax
       push  esi
       push  ebx
       call  GetTextExtentPoint32A

       pop   edx
       pop   ecx

       or    eax, eax
       jz    @@02

       mov   eax, [edx]

 @@02: stosd

       push  esi
       mov   esi, aSWidth

       add   [esi], eax

       pop   esi
       inc   esi

       loop  @@01

 @@03:
       pop   ebx
       pop   edi
       pop   esi
end;//_GetKerning

procedure _GetKerningW(aDC: HDC; aBuff: pWideChar; aSize: Longint; aKerning: PLong; aSWidth: PLong);
register;
var
 Sz : TSize;
asm
       push  esi
       push  edi
       push  ebx

       mov   ebx, eax

       mov   esi, aSWidth
       xor   eax, eax
       mov   [esi], eax

       jcxz  @@03

       mov   esi, edx
       mov   edi, aKerning

       lea   edx, Sz
       cld
       
 @@01: push  ecx
       push  edx

       push  edx
       xor   eax, eax
       inc   eax
       push  eax
       push  esi
       push  ebx
       call  GetTextExtentPoint32W

       pop   edx
       pop   ecx

       or    eax, eax
       jz    @@02

       mov   eax, [edx]

 @@02: stosd

       push  esi
       mov   esi, aSWidth

       add   [esi], eax

       pop   esi
       add   esi, 2 // увеличиваем на два байта так как это Unicode

       loop  @@01

 @@03:
       pop   ebx
       pop   edi
       pop   esi
end;//_GetKerningW

(*var
 f_BmpIC : TBitmap = nil;

procedure FreeInfoCanvas;
begin
 l3Free(f_BmpIC);
end;*)

// start class Tl3Canvas 

procedure Tl3Canvas.InitFields;
  {-}
begin
 inherited;
(* if Printing then
 begin
  {$IfDef nsTest}
  f_LineSpacing := l3CanvasPrim.g_PrintingLineSpacing;
  if (f_LineSpacing <= 0) then
   f_LineSpacing := def_PrintingLineSpacing;
  {$Else  nsTest}
  f_LineSpacing := def_PrintingLineSpacing;
  {$EndIf nsTest}
 end;//Printing*)
 etoFlags := eto_Opaque{ + eto_Clipped};
 BackColor := def_PaperColor;
 TextColor := clBlack;
 f_Zoom := def_Zoom;
 SectionExtent := l3Point(def_inchPaperWidth, def_inchPaperHeight);
 if (f_Printer <> nil) then
  PageOrientation := f_Printer.Orientation
 else
  PageOrientation := l3_poPortrait;
 f_WindowOrgInited := false;
 l3FillChar(f_RegionBottomRight, SizeOf(f_RegionBottomRight));
 l3FillChar(f_WindowOrg, SizeOf(f_WindowOrg));
end;

constructor Tl3Canvas.CreateOwned(anOwner : TObject);
  {-}
begin
 f_Owner := anOwner;
 if (anOwner Is TBitmap) then
  Canvas := TBitmap(anOwner).Canvas;
 Create;
end;

constructor Tl3Canvas.CreateForPrinting(const aPrinter: Il3Printer);
  {-}
begin
 if (aPrinter <> nil) then
  f_Printer := aPrinter.Clone
 else
  f_Printer := nil;
 Printing := (f_Printer <> nil);
 Create;
end;

class function Tl3Canvas.Make: Il3Canvas;
  {-}
var
 l_Self : Tl3Canvas;
begin
 l_Self := Create;
 try
  Result := l_Self;
 finally
  l3Free(l_Self);
 end;//try..finally
end;

class function Tl3Canvas.MakeForPrinting(const aPrinter: Il3Printer): Il3InfoCanvas;
  {-}
var
 l_Self : Tl3Canvas;
begin
 l_Self := CreateForPrinting(aPrinter);
 try
  Result := l_Self;
 finally
  l3Free(l_Self);
 end;//try..finally
end;

class function Tl3Canvas.MakeForScreen: Il3InfoCanvas;
  {-}
var
 l_Self : Tl3Canvas;
begin
 l_Self := Create;
 try
  l_Self.MakeScreenDC;
  Result := l_Self;
 finally
  l3Free(l_Self);
 end;//try..finally
end;

procedure Tl3Canvas.MakeScreenDC;
  {-}
begin
 SetDC(CreateIC('DISPLAY', nil, nil, nil), ev_dcfCreated);
end;

procedure Tl3Canvas.Cleanup;
  {override;}
  {-}
begin
 while Drawing do EndPaint; { - Принудительно освобождаем все ресурсы. }
 f_VirtualCanvas := nil;
 Canvas := nil;
 l3Free(f_Kerning);
 Painter := nil;
 FreeAndNil(f_Filled);
 f_FrameLines := nil;
 l3System.FreeLocalMem(f_ConvertBuf);
 l3Free(f_WOs);
 l3Free(f_BCs);
 l3Free(f_FCs);
 l3Free(f_Rgns);
 f_Font := nil;
 l3Free(f_OutString);
 l3Free(f_ConvertTable[false]);
 l3Free(f_ConvertTable[true]);
 f_AbortChecker := nil;
 inherited;
end;

procedure Tl3Canvas.AddRect(const aRect: Tl3SRect);
  {-}
begin
 DoAddRect(aRect);
end;

procedure Tl3Canvas.RecordRegionBottomPrim(const aBottom: Tl3SPoint);
  {-}
begin
 f_RegionBottomRight.X := Max(f_RegionBottomRight.X, aBottom.X);
 f_RegionBottomRight.Y := Max(f_RegionBottomRight.Y, aBottom.Y);
 if Printing then
  f_RegionBottomRight.Y := Min(f_RegionBottomRight.Y, LP2DP(GlobalClipRect.BottomRight).Y);
end;

procedure Tl3Canvas.PushWO;
  {-}
begin
 if (f_WOs = nil) then
  f_WOs := Tl3LongintList.Make;
 with WindowOrg do
 begin
  f_WOs.Add(X);
  f_WOs.Add(Y);
 end;//with WindowOrg
end;

procedure Tl3Canvas.PopWO;
  {-}
var
 l_WO : Tl3Point;
begin
 with f_WOs do
 begin
  l_WO.Y := Integer(Delete(Hi));
  l_WO.X := Integer(Delete(Hi));
 end;//with f_WOs
 WindowOrg := l_WO;
end;

procedure Tl3Canvas.PushBC;
  {-}
begin
 if (f_BCs = nil) then
  f_BCs := Tl3LongintList.Make;
 f_BCs.Add(BackColor);
end;

function Tl3Canvas.TopBC: TColor;
  {-}
begin
 if (f_BCs = nil) OR f_BCs.Empty then
  Result := BackColor
 else
  Result := f_BCs.Last;
end;

procedure Tl3Canvas.PopBC;
  {-}
begin
 with f_BCs do
  BackColor := TColor(Delete(Hi));
end;

procedure Tl3Canvas.PushFC;
  {-}
begin
 if (f_FCs = nil) then
  f_FCs := Tl3LongintList.Make;
 f_FCs.Add(TextColor);
end;

procedure Tl3Canvas.PopFC;
  {-}
begin
 with f_FCs do
  TextColor := TColor(Delete(Hi));
end;

procedure Tl3Canvas.DoAddRectPrim(const aRect: Tl3SRect);
  //virtual;
  {-}
begin
 if DrawEnabled then
  xCheckFilled.CombineRect(aRect, RGN_OR);
end;

procedure Tl3Canvas.StartRegion;
  {-}
begin
 if (f_Rgns = nil) then
  f_Rgns := Tl3LongintList.Make;
 with f_RegionBottomRight do
 begin
  f_Rgns.Add(X);
  f_Rgns.Add(Y);
 end;//with f_RegionBottomRight
 f_RegionBottomRight := WO(l3Point0).Sub(LP2DP(WindowOrg));
end;

procedure Tl3Canvas.FinishRegion;
  {-}
begin
 with f_Rgns do
 begin
  f_RegionBottomRight.Y := Integer(Delete(Hi));
  f_RegionBottomRight.X := Integer(Delete(Hi));
 end;//with f_Rgns
end;

function Tl3Canvas.pm_GetRegionBottomRight: Tl3Point;
  {-}
begin
 Result := DP2LP(f_RegionBottomRight);
end;

procedure Tl3Canvas.DoAddRect(const aRect: Tl3SRect);
  //virtual;
  {-}
var
 l_Rect : Tl3SRect;
begin
 l_Rect := aRect.SubPt(LP2DP(WindowOrg));
 if Drawing AND (aRect.Right - aRect.Left <> 0) AND 
    (aRect.Bottom - aRect.Top <> 0) then
  DoAddRectPrim(l_Rect);
 RecordRegionBottomPrim(l_Rect.BottomRight);
end;

procedure Tl3Canvas.AddRgn(const aRgn: Il3Region);
  {-}
var
 l_Rgn : Tl3Region;
begin
 l_Rgn := Tl3Region.Create;
 try
  l_Rgn.Il3Region_Assign(aRgn);
  OffsetRgn(l_Rgn, WindowOrg.Neg);
  if Invert then
   xCheckFilled.Combine(l_Rgn, RGN_OR)
  else
  begin
   xCheckFilled.Combine(l_Rgn, RGN_OR);
  end;//Invert
  RecordRegionBottomPrim(l_Rgn.Rect.BottomRight);
 finally
  FreeAndNil(l_Rgn);
 end;//try..finally
end;

function Tl3Canvas.WO(const aRect: Tl3Rect): Tl3SRect;
  //overload;
  {-}
begin
 Result := LR2DR(aRect);
end;

function Tl3Canvas.WO(const aPt: Tl3Point): Tl3SPoint;
  //overload;
  {-}
begin
 Result := LP2DP(aPt);
end;

function Tl3Canvas.WO(const aPt: Tl3SPoint): Tl3SPoint;
  //overload;
  {-}
begin
 Result := aPt;
end;

procedure Tl3Canvas.FillRectPrim(const R: TRect);
  {-}
begin
 Windows.ExtTextOut(DC, R.Left, R.Top, eto_Opaque, @R, nil, 0, nil);
// Canvas.FillRect(R);
end;

procedure Tl3Canvas.DoFillForeRect(const R: Tl3SRect);
  {-}
begin
 if Invert then
 begin
  Inc(f_Fore);
  try
   FillRect(R);
  finally
   Dec(f_Fore);
  end;//try..
 end//Invert
 else
  FillRect(R);
end;

procedure Tl3Canvas.FillForeRect(const R: Tl3SRect);
  {-}
begin
 DoFillForeRect(R);
end;

procedure Tl3Canvas.FillRect(const R: Tl3SRect);
  {override;}
  {-}
begin
 if DrawingIsValid then
 begin
  CheckColors;
  FillRectPrim(l3IntersectRect(R, LR2DR(ClipRect)).R.WR);
 end;//DrawingIsValid
 AddRect(R);
end;

procedure Tl3Canvas.FillRect(const R: Tl3Rect);
  {-}
begin
 if DrawingIsValid then
 begin
  CheckColors;
  FillRectPrim(WO(l3IntersectRect(R, ClipRect)).R.WR);
 end;//DrawingIsValid
 AddRect(WO(R));
end;

function ApplyLineSpacing(aValue : Integer; aLineSpacing : Integer): Integer;
begin
 if (aLineSpacing > 0) AND (aLineSpacing <> 100) then
  Result := l3MulDiv(aValue, aLineSpacing, 100)
 else
  Result := aValue;
end;

procedure SystemTextExtent(aDC : hDC; const aStr: Tl3WString; var theExtent : TSize; aLineSpacing : Integer);
begin
 if (aStr.SCodePage = CP_Unicode) then
  Windows.GetTextExtentPoint32W(aDC, PWideChar(aStr.S), aStr.SLen, theExtent)
 else
  Windows.GetTextExtentPoint32A(aDC, aStr.S, aStr.SLen, theExtent);
 theExtent.cY := ApplyLineSpacing(theExtent.cY, aLineSpacing);
end;

procedure Tl3Canvas.ExtTextOut(const aPt   : Tl3Point;
                               const aRect : Tl3Rect;
                               const aSt   : Tl3PCharLenPrim;
                               aFl         : Tl3TextFormatFlag = l3_tffLeft;
                               aKerning    : PInteger = nil);
  {-}
var
 l_SOffset : Tl3SPoint;
 R1        : Tl3SRect;
 l_DC      : HDC;

 procedure TextOut(const aSt: Tl3PCharLenPrim);


  function DrawTabbed(const aSt: Tl3PCharLenPrim): Bool;

  var
   l_TabbedRect : TRect;
   l_TabPos     : Integer;
   l_Width      : Long;
   l_OutRect    : TRect;
   l_Style      : Tl3TabStopStyle;

   procedure DrawTabSymbol(WasFiller: Bool);
   const
    cTabSymbol : array [Tl3TabStopStyle] of Tl3PCharLenConst =
     (
      (S         : #$E8;
       SLen      : 1;
       SCodePage : CP_ANSI;
       ),
      (S         : #$E8;
       SLen      : 1;
       SCodePage : CP_ANSI;
       ),
      (S         : #$E7;
       SLen      : 1;
       SCodePage : CP_ANSI;
       ),
      (S         : #$E8;
       SLen      : 1;
       SCodePage : CP_ANSI;
       ),
      (S         : #$E7;
       SLen      : 1;
       SCodePage : CP_ANSI;
       )
     );

   var
    l_OName     : String;
    l_OSize     : Long;
    l_OFColor   : TColor;
    l_E         : TSize;
    l_TabSymbol : Tl3PCharLenPrim;
    l_Flags     : Long;
   begin//DrawTabSymbol
    if DrawSpecial then
     l_TabSymbol := cTabSymbol[l_Style]
    else
     l_TabSymbol := cc_EmptyTabSymbol;
    if DrawSpecial OR not WasFiller then
    begin
     // Рисуем знак табуляции:
     with Il3Font(Self) do
     begin
      l_OName := Name;
      l_OSize := Size;
      l_OFColor := TextColor;
      try
       Name := def_WingdingsFontName;
       Size := 4;
       if WasFiller then
        l_Flags := eto_Clipped
       else
        l_Flags := etoFlags + eto_Clipped;
       with l_TabSymbol do
       begin
        SystemTextExtent(l_DC, l_TabSymbol, l_E, f_LineSpacing);
(*        Case l_Style of
         l3_tssRight :
          Windows.ExtTextOut(l_DC,
                             l_SOffset.X,
                             (l_OutRect.Top + l_OutRect.Bottom - l_E.cY) div 2,
                             l_Flags, @l_OutRect,
                             S, SLen,
                             Dx);
         else*)
          Windows.ExtTextOut(l_DC,
                             l_SOffset.X + ((l_Width - l_E.cX){ div 2}),
                             (l_OutRect.Top + l_OutRect.Bottom - l_E.cY) div 2,//l_SOffset.Y,
                             l_Flags, @l_OutRect,
                             S, SLen,
                             aKerning);
(*        end;//Case l_Style*)
       end;//with l_TabSymbol
      finally
       Name := l_OName;
       Size := l_OSize;
       TextColor := l_OFColor;
      end;//try..finally
     end;//with Il3Font(Self)
    end;//DrawSpecial
    l_OutRect.Left := l_OutRect.Right;
    Inc(l_SOffset.P.X, l_Width);
    Inc(aKerning, l_TabSymbol.SLen);
   end;//DrawTabSymbol

  var
   l_Filler : Tl3PCharLen;

   procedure DrawFiller;
   var
    l_Rect : TRect;
    l_E    : TSize;
    l_X    : Long;
   begin//DrawFiller
    l_Rect := l_OutRect;
    l_X    := l_SOffset.X;
    while (l_Rect.Left - l_OutRect.Left < l_Width) do
    begin
     with l_Filler do
     begin
      SystemTextExtent(l_DC, l_Filler, l_E, f_LineSpacing);
      l_Rect.Right := l_Rect.Left + l_E.cX;
      Windows.ExtTextOut(l_DC,
                         l_X,
                         l_SOffset.Y,
                         etoFlags, @l_Rect,
                         S, SLen,
                         aKerning);
     end;//with l_Filler
     Inc(l_X, l_E.cX);
     l_Rect.Left := l_Rect.Right;
    end;//while (l_Rect.Left - l_OutRect.Left < l_Width)
   end;//DrawFiller

  var
   l_S  : Tl3PCharLenPrim;

   function CalcWidth: Long;
   var
    l_Index : Long;
   begin//CalcWidth
    Result := 0;
    for l_Index := 0 to Pred(l_S.SLen) do
     Inc(Result, PLong(PAnsiChar(aKerning) + l_Index * SizeOf(Long))^);
   end;//CalcWidth

  var
   l_NS       : Tl3PCharLen;
   l_Last     : Bool;
   l_TabStops : Il3TabStops;
   l_CurTab   : Integer;
   l_Str      : Tl3Str;
  begin//DrawTabbed
   Result := true;
   l_S := aSt;
   l_OutRect := R1.R.WR;
   l_TabStops := nil;
   if (f_TabStops <> nil) and (f_TabStops.NeedCutByTab) then
    l_TabStops := f_TabStops.Clone;
   l_CurTab := 0;
   repeat
    l_NS := l3FindChar(cc_Tab, l_S);
    l_Last := Tl3PCharLen(l_S).IsLast(cc_Tab);
    if l_Last then
     Dec(l_S.SLen);

    // Рисуем текст:
    if l_TabStops <> nil then
    begin
     l_TabPos := LP2DP(l3PointX(l_TabStops.Next.rPosition)).X;
     l_Width :=  l_tabPos - l_CurTab;
     l_CurTab := l_TabPos;
    end
    else
     l_Width := CalcWidth;
    l_OutRect.Right := l_OutRect.Left + l_Width;
    if (l_TabStops <> nil) then
    begin
     l_TabbedRect := l_OutRect;
     Windows.InflateRect(l_TabbedRect, -4, 0);
     if (l_S.SCodePage = CP_Unicode) then
     begin
      if (Win32Platform = VER_PLATFORM_WIN32_NT) then
       Windows.DrawTextExW(l_DC, PWideChar(l_S.S), l_S.SLen, l_TabbedRect, DT_END_ELLIPSIS, nil)
      else
      begin
       l_Str.Init(l_S, CP_ANSI);
       try
        Windows.DrawTextExA(l_DC, l_Str.S, l_Str.SLen, l_TabbedRect, DT_END_ELLIPSIS, nil);
       finally
        l_Str.Clear;
       end;//try..finally
      end;//Win32Platform = VER_PLATFORM_WIN32_NT
     end
     else
      Windows.DrawTextExA(l_DC, l_S.S, l_S.SLen, l_TabbedRect, DT_END_ELLIPSIS, nil);
    end//l_TabStops <> nil
    else
    begin
     if (l_S.SCodePage = CP_Unicode) then
      Windows.ExtTextOutW(l_DC, l_SOffset.X, l_SOffset.Y, etoFlags, @l_OutRect,
                          PWideChar(l_S.S), Min(l_S.SLen, cMaxTextLength), aKerning)
     else
      Windows.ExtTextOut(l_DC, l_SOffset.X, l_SOffset.Y, etoFlags, @l_OutRect,
                         l_S.S, Min(l_S.SLen, cMaxTextLength), aKerning);
    end;//l_TabStops <> nil
    l_OutRect.Left := l_OutRect.Right;
    Inc(l_SOffset.P.X, l_Width);
    Inc(aKerning, l_S.SLen);

    if (l_TabStops = nil) and l_Last then
    begin
     l_Width := aKerning^;
     l_OutRect.Right := l_OutRect.Left + l_Width;
     if (f_TabStops = nil) then
     begin
      l_Style := l3_tssLeft;
      DrawTabSymbol(false);
     end//f_TabStops = nil
     else
     begin
      Tl3WString(l_Filler) := f_TabStops.Filler;
      l_Style := f_TabStops.Style;
      if l3IsNil(l_Filler) then
       DrawTabSymbol(false)
      else
      begin
       DrawFiller;
       DrawTabSymbol(true);
      end;//l3IsNil
     end;//f_TabStops = nil
    end;//l_Last..

    l_S := l_NS;
   until l3IsNil(l_NS);
  end;//DrawTabbed

 var
  l_S : Tl3PCharLenPrim;  
 begin//TextOut
  if Printing then
   Assert(aKerning = nil, 'aKerning <> 0 во время печати!!!');
  l_S := aSt;
  with l_S do
   if (SLen > 0) then
   begin
    if (SCodePage = CP_Unicode) then
    begin
     while (SLen > 0) and (l3WideToChar(PWideChar(S)[Pred(SLen)]) in [cc_SoftEnter, cc_HardEnter]) do
      Dec(SLen);
    end//SCodePage = CP_Unicode
    else
    begin
     while (SLen > 0) and (S[Pred(SLen)] in [cc_SoftEnter, cc_HardEnter]) do
      Dec(SLen);
    end;//SCodePage = CP_Unicode
   end;//SLen > 0
  SetBkColor(l_DC, ColorToRGB(Brush.Color));
  if (f_Tabs > 0) AND
     (aKerning <> nil) AND
     DrawTabbed(l_S) then
   Exit;
  if (l_S.SCodePage = CP_ANSI) then
   Windows.ExtTextOut(l_DC, l_SOffset.X, l_SOffset.Y, etoFlags, @R1,
                      l_S.S, Min(l_S.SLen, cMaxTextLength),
                      aKerning)
  else
   Win32Check(Windows.ExtTextOutW(l_DC, l_SOffset.X, l_SOffset.Y, etoFlags, @R1,
                       PWideChar(l_S.S), Min(l_S.SLen, cMaxTextLength),
                       aKerning));
 end;//TextOut

var
 D          : Long;
 l_Str      : Tl3Str;
 l_W        : Integer;
 l_FontSize : Integer;
 l_Pt       : Tl3Point;
 l_R        : Tl3Rect;
 l_St       : Tl3PCharLenPrim;
 l_Convert  : Tl3Str;
 l_Bmp      : TBitmap;
 l_Canvas   : Tl3Canvas;
 l_TmpPt    : Tl3Point;
 l_TmpRect  : Tl3Rect;
begin
 l_R := aRect;
 l_R.Right := Min(ClipRect.Right, l_R.Right);
 R1 := WO(l_R);
 if DrawingIsValid then
 begin
  l_St := aSt;
  if (f_PasswordChar <> #0) then
  begin
   l_Convert.Init(Tl3WString(l_St), CP_ANSI);
   l3FillChar(l_Convert.S^, l_Convert.SLen, Ord(f_PasswordChar));
   l_St := l_Convert;
  end//f_PasswordChar <> #0
  else
   l_Convert.Init;
  try
   l_Pt := aPt;
   if (aFl <> l3_tffLeft) then
   begin
    l_W := TextExtent(l_St).X;
    if aFl = l3_tffRight then
     l_Pt.X := aRect.Right - l_W - (aPt.X - aRect.Left)
    else
     l_Pt.X := aRect.Left + ((aRect.Right - aRect.Left) - l_W) div 2;
   end;//aFl <> l3_tffLeft
   l_DC := DC;
   if (l3_fiSub in f_FontIndexSet) then
    D := l3FontIndexDelta
   else
    D := 0;
   Case FontIndex of
    l3_fiNone:
     ;
    l3_fiSub:
     D := 0;
    l3_fiSuper:
     Inc(D, l3FontIndexDelta);
   end;//Case FontIndex
   l_SOffset := WO(l_Pt.Sub(l3PointY(D)));
   CheckColors;
   CheckDrawing; // http://mdp.garant.ru/pages/viewpage.action?pageId=200902555&focusedCommentId=205357164#comment-205357164
   if (f_SuffixedFont AND (l_St.SCodePage = CP_ANSI)) OR
      // - закомментировано, т.к. неправильно работало с 'Arial', а не 'Arial CYR'
      (l_St.SCodePage = CP_Unicode) then
    TextOut(l_St)
   else
   begin
    if IsPreview AND (Win32Platform <> VER_PLATFORM_WIN32_NT) then
    begin
     // Для Windows 98 делаем так: создаем битмап, рисуем текст на него, а потом
     // выводим на канву. Сделано для обхода проблемы с метафайлом и юникодом на Win98.
     l_Bmp := Tl3Bitmap.Create;
     l_Bmp.Handle := CreateCompatibleBitmap(Self.DC, R1.Right - R1.Left, R1.Bottom - R1.Top);
     l_Canvas := Tl3Canvas.CreateOwned(l_Bmp);
     try
      with l_TmpRect do
      begin
       Left := 0;
       Right := aRect.Right - aRect.Left;                                                       
       Top := 0;
       Bottom := aRect.Bottom - aRect.Top;
      end;

      with l_TmpPt do
      begin
       X := l_Pt.X - aRect.Left;
       Y := l_Pt.Y - aRect.Top;
      end;

      with l_Canvas do
      begin
       with Canvas do
       begin
        Font := Self.VCLFont;
        l_FontSize := Font.Size;
        Font.PixelsPerInch := Self.PixelsPerInchX;
        Font.Size := l_FontSize;
       end;//with Canvas
       f_DCFlag := ev_dcfLinked;
       BeginPaint;
       DrawEnabled := true;
       ExtTextOut(l_TmpPt, l_TmpRect, l_St, aFl, aKerning);
       EndPaint;
      end;//with..

      Self.StretchDraw(aRect, l_Bmp);
     finally
      l3Free(l_Canvas);
      FreeAndNil(l_Bmp);
     end;//try..finally
    end//IsPreview AND (Win32Platform <> VER_PLATFORM_WIN32_NT)
    else
    begin
     l_Str.Init(l_St, CP_Unicode, @f_ConvertBuf);
     TextOut(l_Str);
    end;//IsPreview AND (Win32Platform <> VER_PLATFORM_WIN32_NT)
   end;//l_St.SCodePage = CP_ANSI
  finally
   l_Convert.Clear;
  end;//try..finally
 end;//DrawingIsValid
 AddRect(R1);
end;

function Tl3Canvas.DrawText(const aSt : Tl3PCharLenPrim;
                            var R     : TRect;
                            aFormat   : uInt;
                            AFl       : TObject = nil): Il3MultiLines;
  {-}
 procedure _DrawText(const aSt: Tl3PCharLenPrim);

  procedure _CalcRect;
  var
   l_SingleLine : Boolean;

   procedure SetResult(const aPoint : Tl3Point);
   begin//SetResult
    with LP2DP(aPoint) do
    begin
     //if l_SingleLine then
      R.Right := R.Left + X;
     R.Bottom := R.Top + Y;
    end;
   end;//SetResult

  var
   l_FL    : Tl3FormattedLines;
   l_R     : Tl3Rect;
   l_Point : Tl3Point;
   l_Max   : Integer;
   l_Index : Integer;
   l_StrArr : TevBaseLineArray;
   l_OldFont: HFONT;
  begin//_CalcRect
   l_OldFont := SelectObject(DC, VCLFont.Handle); // http://mdp.garant.ru/pages/viewpage.action?pageId=344135978
   try
    l_SingleLine := (aFormat and DT_SINGLELINE = DT_SINGLELINE) or
     (R.Right - R.Left = 0) or not (aFormat and DT_WORDBREAK = DT_WORDBREAK);
    // Посчитаем для однострочного
    if l_SingleLine then
    begin
     if (AFl = nil) then
     begin
      l_FL := Tl3FormattedLines.Create;
      try
       Result := l_FL;
      finally
       l3Free(l_FL);
      end;//try..finally
     end//AFl = nil
     else
      Result := AFl as Tl3FormattedLines;
     SetResult(TextExtent(aSt));
     // K-109086173
     if (aFormat and DT_END_ELLIPSIS = DT_END_ELLIPSIS) and (fsBold in Get_Style) then
      Inc(R.Right, 3);
    end//l_SingleLine
    // Посчитаем для многострочного
    else
    begin
     if AFl = nil then
      l_FL := Tl3FormattedLines.Create
     else
      l_FL := AFl as Tl3FormattedLines;
     try
      // Переведем в дюймы
      l_R := DR2LR(l3SRect(R));
      // Разбиваем
      l_Point.Y := l_FL.FormatLine(Self, 0, aSt, l_R.R.Right - l_R.R.Left);
      l_SingleLine := l_FL.IsSingle;
      if l_SingleLine then
       l_Point.X := TextExtent(aSt).X
      else
      begin
       l_Max := 0; l_StrArr := TevBaseLineArray(l_FL.First);
       for l_Index := 1 to l_StrArr.Count do
        l_Max := Max(l_Max, l_StrArr.LineWidth[l_Index]);
       l_Point.X := l_Max; //Если просто сделать l_R.Right - l_R.Left, то
       //может получиться hint с запасом.
      end;
      SetResult(l_Point);
      Inc(R.Right, 3);
      Result := l_FL;
     finally
      if AFl = nil then
       l3Free(l_FL);
     end;//try..finally
    end;//l_SingleLine
   finally
    SelectObject(DC, l_OldFont);
   end;
  end;//_CalcRect

  procedure _DrawWordBreak;
  var
   l_FL     : Tl3FormattedLines;
   l_Index  : Integer;
   l_R      : Tl3Rect;
   l_StrArr : TevBaseLineArray;
   l_H      : Integer;
  begin//_DrawWordBreak
   if AFl = nil then
     l_FL := Tl3FormattedLines.Create
   else
     l_FL := AFl as Tl3FormattedLines;
   try
    // Пересчитаем в дюймы
    l_R := DR2LR(l3SRect(R));
    // Разобъем на строки
    if (AFl = nil) then
     l_H := l_FL.FormatLine(Self, 0, aSt, l_R.R.Right - l_R.R.Left)
    else
     l_H := 0;
    if (aFormat and DT_VCENTER = DT_VCENTER) then
     l_R.Top := (l_R.Bottom + l_R.Top - l_H) div 2;
    l_StrArr := TevBaseLineArray(l_FL.First);
    // Текст многострочный
    if (l_StrArr <> nil) then
    begin
     for l_Index := 1 to l_StrArr.Count do
     begin
      // Нижняя граница
      l_R.R.Bottom := l_R.R.Top + l_StrArr.LineHeight[l_Index];
      // Покажем
      if (aFormat and DT_RIGHT) > 0 then
       ExtTextOut(l_R.TopLeft, l_R, l_StrArr.GetLine(aSt, l_Index), l3_tffRight)
      else
      if (aFormat and DT_CENTER) > 0 then
       ExtTextOut(l_R.TopLeft, l_R, l_StrArr.GetLine(aSt, l_Index), l3_tffCenter)
      else
       ExtTextOut(l_R.TopLeft, l_R, l_StrArr.GetLine(aSt, l_Index), l3_tffLeft);
      // Следущая строка
      Inc(l_R.R.Top, l_StrArr.LineHeight[l_Index]);
     end//for l_Index
    end//l_StrArr <> nil
    // Текст однострочный, просто выводим
    else
    begin
     if (aFormat and DT_RIGHT) > 0 then
      ExtTextOut(l_R.TopLeft, l_R, aSt, l3_tffRight)
     else
     if (aFormat and DT_CENTER) > 0 then
      ExtTextOut(l_R.TopLeft, l_R, aSt, l3_tffCenter)
     else
      ExtTextOut(l_R.TopLeft, l_R, aSt, l3_tffLeft);
    end;//l_StrArr <> nil
    Result := l_FL;
   finally
    if AFl = nil then
      l3Free(l_FL);
   end;//try..finally
  end;//_DrawWordBreak

 var
  l_S  : Tl3Str;
  l_Pt : Tl3SPoint;
 begin//_DrawText
  // Вычислить область вывода
  if (aFormat and DT_CALCRECT = DT_CALCRECT) then
  begin
   _CalcRect;
   Exit;
  end;//DT_CALCRECT
  // Вывести многострочный
  if (aFormat and DT_WORDBREAK = DT_WORDBREAK) and
   not (aFormat and DT_CALCRECT = DT_CALCRECT) then
  begin
   _DrawWordBreak;
   Exit;
  end;//DT_WORDBREAK
  if not ((aFormat and DT_END_ELLIPSIS = DT_END_ELLIPSIS) OR
     (aFormat and DT_PATH_ELLIPSIS = DT_PATH_ELLIPSIS)) then
   // - не надо рисовать многоточия - обойдемся без помощи Windows
  begin
   l_Pt := l3SPoint0;
   if (aFormat and DT_VCENTER = DT_VCENTER) AND not l3IsNil(aSt) then
   begin
    l_Pt := LP2DP(TextExtent(aSt), true);
    l_Pt.X := R.Left;
    l_Pt.Y := ((R.Bottom + R.Top - l_Pt.Y) div 2); 
   end//DT_CALCRECT
   else
    l_Pt := Tl3SPoint(R.TopLeft);
   if (aFormat and DT_RIGHT) > 0 then
    ExtTextOut(l_Pt, l3SRect(R), aSt, l3_tffRight)
   else
   if (aFormat and DT_CENTER) > 0 then
    ExtTextOut(l_Pt, l3SRect(R), aSt, l3_tffCenter)
   else
    ExtTextOut(l_Pt, l3SRect(R), aSt, l3_tffLeft);
   Exit;
  end;//DT_END_ELLIPSIS..
  if (aSt.SCodePage = CP_ANSI) then
   {Result := }Windows.DrawTextA(DC, aSt.S, aSt.SLen, R, aFormat)
  else
  if (Win32Platform = VER_PLATFORM_WIN32_NT) then
   {Result := }Windows.DrawTextW(DC, PWideChar(aSt.S), aSt.SLen, R, aFormat)
  else
  begin
   l_S.Init(aSt, CP_ANSI);
   try
    {Result := }Windows.DrawTextA(DC, l_S.S, l_S.SLen, R, aFormat);
   finally
    l_S.Clear;
   end;//try..finally
  end;//Win32Platform = VER_PLATFORM_WIN32_NT
 end;//_DrawText

var
 l_Str : Tl3Str;
begin
 if (f_SuffixedFont AND (aSt.SCodePage = CP_ANSI)) OR
    // - закомментировано, т.к. неправильно работало с 'Arial', а не 'Arial CYR'
    (aSt.SCodePage = CP_Unicode) then
  _DrawText(aSt)
 else
 begin
  l_Str.Init(aSt, CP_Unicode, @f_ConvertBuf);
  _DrawText(l_Str);
 end;//f_SuffixedFont
end;

function Tl3Canvas.InvertColor(aColor: TColor): TColor;
  {-}
var
  r, g, b: integer;
begin
 aColor := ColorToRgb(aColor);
 r := GetRValue(aColor);
 g := GetGValue(aColor);
 b := GetBValue(aColor);

 r := (not r) and $000000FF;
 g := ((not g) and $000000FF) shl 8;
 b := ((not b) and $000000FF) shl 16;

 Result := b or g or r;
end;
(*begin
 C := ColorToRGB(C);
 if (f_BmpIC = nil) then
 begin
  f_BmpIC := Tl3Bitmap.Create;
  l3System.AddExitProc(FreeInfoCanvas);
  with f_BmpIC, l3SRect1 do
  begin
   Width := R.Right;
   Height := R.Bottom;
   Monochrome := false;
  end;//with f_BmpIC, l3SRect1
 end;
 with f_BmpIC.Canvas do
 begin
  Pixels[0, 0] := C;
  l3SRect1.Invert(DC);
  Result := Pixels[0, 0];
 end;//with f_BmpIC.Canvas
end;*)

function Tl3Canvas.Get_EffectiveColors: Il3EffectiveColors;
  {-}
begin
 Result := Self;
end;

function Tl3Canvas.Get_FontColor: Tl3Color;
  {-}
begin
 Result := VCLFont.Color;
end;

function Tl3Canvas.Get_PasswordChar: AnsiChar;
     {-}
begin
 Result := f_PasswordChar;
end;

procedure Tl3Canvas.Set_PasswordChar(aValue: AnsiChar);
     {-}
begin
 f_PasswordChar := aValue;
end;

function  Tl3Canvas.pm_GetInvert: Bool;
  {-}
begin
 Result := (f_Invert > 0);
end;

function Tl3Canvas.pm_GetDrawing: Bool;
  {-}
begin
 Result := (f_Drawing > 0);
end;

function Tl3Canvas.pm_GetBackColor: TColor;
  {override;}
  {-}
begin
 Result := f_BackColor;
end;

procedure Tl3Canvas.pm_SetBackColor(Value: TColor);
  {-}
begin
 if (f_BackColor <> Value) AND (Value <> clDefault) then
 begin
  f_BackColor := Value;
  if DrawEnabled AND Drawing then CheckColors;
 end;//f_BackColor <> Value
end;

function Tl3Canvas.pm_GetDC: HDC;
  {-}
begin
 CheckDrawing;
 Result := HDC(f_DC);
end;

procedure Tl3Canvas.pm_SetDC(aValue: HDC);
  {-}
begin
 if (aValue = 0) then
  SetDC(0, ev_dcfGot)
 else
 begin
  f_WindowOrgInited := false;
  SetDC(aValue, ev_dcfLinked);
  f_InitialDCOffset := WindowOrg;
  if (f_InitialDCOffset.X <> 0) or (f_InitialDCOffset.Y <> 0) then
   f_InitialDCOffsetStored := f_InitialDCOffset;
 end;//aValue = 0
 { TODO -oЛюлин А. В. -cНедоделка : Это заточка для WinControl - другие не должны пользоваться этим методом. } 
end;
  
function Tl3Canvas.pm_GetTextColor: TColor;
  {-}
begin
 Result := f_TextColor;
end;

procedure Tl3Canvas.pm_SetTextColor(Value: TColor);
  {-}
begin
 if (f_TextColor = Value) then
 begin
  if DrawEnabled AND Drawing then CheckColors;
 end//f_TextColor = Value
 else
 if (Value <> clDefault) {AND (Value <> clWindowText)} then
 begin
  f_TextColor := Value;
  if DrawEnabled AND Drawing then CheckColors;
 end;//f_TextColor <> Value
end;

function  Tl3Canvas.pm_GetFontIndexSet: Tl3FontIndexes;
  {override;}
  {-}
begin
 Result := f_FontIndexSet;
end;

procedure Tl3Canvas.pm_SetFontIndexSet(Value: Tl3FontIndexes);
  {override;}
  {-}
begin
 f_FontIndexSet := Value;
end;

function Tl3Canvas.Get_Index: Tl3FontIndex;
  {override;}
  {-}
begin
 if (f_Font <> nil) then
  Result := f_Font.Index
 else
  Result := f_FontIndex;
end;

procedure Tl3Canvas.pm_SetFontIndex(Value: Tl3FontIndex);
  {override;}
  {-}
begin
 f_FontIndex := Value;
end;

function Tl3Canvas.pm_GetClipRect: Tl3Rect;
  {-}
begin
 Result := GlobalClipRect.AddPt(WindowOrg);
end;

procedure Tl3Canvas.pm_SetClipRect(const Value: Tl3Rect);
  {override;}
  {-}
var
 Rgn : Tl3Rgn;
begin
 Rgn := CreateRectRgn(WO(Value).SubPt(SWindowOrg));
 try
  SelectClipRgn(DC, Rgn);
  f_ClipRectInited := false;
 finally
  l3FreeRgn(Rgn);
 end;//try..finally
end;

function  Tl3Canvas.pm_GetGlobalClipRect: Tl3Rect;
  {-}
begin
 if DrawRgnOrBlock AND Drawing then
 begin
  if f_ClipRectInited then
   Result := f_ClipRect
  else
  if f_ClipRectS.GetClip(DC) then
  begin
   Result := DR2LR(f_ClipRectS.SubPt(LP2DP(WindowOrg)));
   f_ClipRect := Result;
   f_ClipRectInited := True;
  end//R.GetClip(DC)
  else
  begin
   Result.TopLeft := l3Point0;
   Result.BottomRight := l3Point0;
  end;//R.GetClip(DC)
 end//DrawRgnOrBlock AND Drawing
 else
  Result := GetClientRect;
end;

function Tl3Canvas.GetClientRect: Tl3Rect;
  {-}
begin
 Result := DoGetClientRect;
end;

function Tl3Canvas.DoGetClientRect: Tl3Rect;
 //virtual;
begin
 Result.R.TopLeft := l3Point0;
 Result.R.BottomRight := l3Point0;
end;

function Tl3Canvas.pm_GetDrawSpecial: Bool;
  {-}
begin
 Result := (ev_dfDrawSpecial in Flags);
 Assert(not Result OR not Printing, 'http://mdp.garant.ru/pages/viewpage.action?pageId=174295160&focusedCommentId=266409368#comment-266409368');
end;

procedure Tl3Canvas.pm_SetDrawSpecial(Value: Bool);
  {-}
var
 l_WindowFlags : Il3CaretOwner;
begin
 if (DrawSpecial <> Value) then
 begin
  if Value AND not Printing then
   Flags := Flags + [ev_dfDrawSpecial]
  else
   Flags := Flags - [ev_dfDrawSpecial];
  if Assigned(f_OnDrawSpecialChange) then
   f_OnDrawSpecialChange(Self);
  if Supports(Owner, Il3CaretOwner, l_WindowFlags) then
   try
    l_WindowFlags.RedrawCaret;
   finally
    l_WindowFlags := nil;
   end;//try..finally
  Invalidate;
 end;//DrawSpecial <> Value
end;

procedure Tl3Canvas.Invalidate;
  //virtual;
  {-}
begin
end;
     
function Tl3Canvas.pm_GetPrinted: Bool;
  {override;}
  {-}
begin
 Result := not Printing OR (ev_dfPrinted in Flags);
end;

procedure Tl3Canvas.pm_SetPrinted(Value: Bool);
  {override;}
  {-}
begin
 if Value then
  Flags := Flags + [ev_dfPrinted]
 else
  Flags := Flags - [ev_dfPrinted];
end;

procedure Tl3Canvas.pm_SetNotFocused(Value: Bool);
  {-}
begin
 f_NotFocused := Value;
end;

function Tl3Canvas.pm_GetShowCursor: Bool;
  {override;}
  {-}
begin
 Result := (ev_dfDrawCursor in Flags);
end;

procedure Tl3Canvas.pm_SetShowCursor(Value: Bool);
  {override;}
  {-}
begin
 if Value then
  Flags := Flags + [ev_dfDrawCursor]
 else
  Flags := Flags - [ev_dfDrawCursor];
end;

function Tl3Canvas.pm_GetDrawEnabled: Bool;
  {-}
begin
 Result := DoGetDrawEnabled;
end;

procedure Tl3Canvas.pm_SetDrawEnabled(Value: Bool);
  {-}
begin
 if Value then
  Flags := Flags + [ev_dfDrawRegion]
 else
  Flags := Flags - [ev_dfDrawRegion];
end;

function Tl3Canvas.pm_GetCanvas: TCanvas;
  {-}
begin
 if (f_Canvas = nil) then
 begin
  if (f_Printer <> nil) AND not IsPreview then
   Canvas := f_Printer.Canvas
  else
   SetCanvas(TCanvas.Create, false);
 end;//f_Canvas = nil
 Result := f_Canvas;
 if (f_Printer <> nil) AND f_Printer.Printing AND (Result <> f_Printer.Canvas) then
 begin
  if (Result <> nil) then
   try
    Result.Handle;
   except
    on EInvalidOperation do
     Result := f_Printer.Canvas;
     // так хитро, чтобы починить http://mdp.garant.ru/pages/viewpage.action?pageId=112722934, но не сломать http://mdp.garant.ru/pages/viewpage.action?pageId=109085576
     // видимо по уму надо использовать полиморфизм в TafwCanvasEx
   end;//try..except
 end;//f_Printer <> nil..
end;

procedure Tl3Canvas.pm_SetCanvas(Value: TCanvas);
  {-}
begin
 SetCanvas(Value, true);
end;

procedure Tl3Canvas.pm_SetPainter(const aValue: Il3HAFPainter);
  {-}
begin
 Painter := aValue;
end;

procedure Tl3Canvas.DrawFocusRect(const aRect: Tl3SRect);
{-}
begin
 Canvas.DrawFocusRect(aRect.R.WR);
end;

procedure Tl3Canvas.SetCanvas(Value: TCanvas; Alien: Bool);
var
 l_E : TNotifyEvent;
 l_M : TMethod absolute l_E;
begin
 if (f_Canvas <> Value) then
 begin
  if (f_Canvas <> nil) AND f_AlienCanvas then
  begin
   if (f_Canvas.Font <> nil) then
    f_Canvas.Font.OnChange := f_OldFontChange;
   if (f_Canvas.Brush <> nil) then
    f_Canvas.Brush.OnChange := f_OldBrushChange;
  end;//f_Canvas <> nil
  if Alien then
   FreeDC
  else
  if (f_DCFlag = ev_dcfCanvas) then
  begin
   f_DC := 0;
   FireDCSetToNull;
  end;//f_DCFlag = ev_dcfCanvas
  if not f_AlienCanvas then
   l3Free(f_Canvas);
  f_Canvas := Value;
  f_AlienCanvas := Alien;
  if (f_Canvas = nil) then
  begin
   f_OldBrushChange := nil;
   f_OldFontChange := nil;
  end//f_Canvas = nil
  else
  begin
   if Assigned(f_Canvas.Font.OnChange) then
   begin
    l_E := f_Canvas.Font.OnChange;
    Assert(l_M.Data <> Self);
   end;//Assigned(f_Canvas.Font.OnChange)
   f_OldBrushChange := f_Canvas.Brush.OnChange;
   f_OldFontChange := f_Canvas.Font.OnChange;
   f_Canvas.Brush.OnChange := BrushChanged;
   f_Canvas.Font.OnChange := FontChanged;
  end;//f_Canvas = nil
 end//f_Canvas <> Value
 else
 if (f_AlienCanvas <> Alien) then
  f_AlienCanvas := Alien;
end;

procedure Tl3Canvas.FireDCSetToNull;
  //virtual;
  {-}
begin
end;
  
function Tl3Canvas.pm_GetVCLFont: TFont;
  {-}
begin
 Result := Canvas.Font;
end;

procedure Tl3Canvas.pm_SetVCLFont(Value: TFont);
  {-}
begin
 Canvas.Font := Value;
end;

function  Tl3Canvas.pm_GetBrush: TBrush;
  {-}
begin
 Result := Canvas.Brush;
end;

function Tl3Canvas.pm_GetPen : TPen;
begin
 Result := Canvas.Pen;
end;

procedure Tl3Canvas.pm_SetPen(const aValue : TPen);
begin
 Canvas.Pen := aValue;
end;

procedure Tl3Canvas.pm_SetBrush(Value: TBrush);
  {-}
begin
 Canvas.Brush := Value;
end;

function Tl3Canvas.pm_GetZoom: Long;
  {override;}
  {-}
begin
 Result := f_Zoom;
end;

procedure Tl3Canvas.pm_SetZoom(Value: Long);
  {override;}
  {-}
begin
 if (f_Zoom <> Value) then
  f_Zoom := Value;
end;

function  Tl3Canvas.pm_GetPageSetup: Il3PageSetup;
  {override;}
  {-}
begin
 Result := Self;
end;

function Tl3Canvas.pm_GetPenWidth: Long;
  {-}
begin
 Result := Canvas.Pen.Width;
end;

function Tl3Canvas.pm_GetPageOrientation: Tl3PageOrientation;
  {-}
begin
 Result := f_PageOrientation;
end;

procedure Tl3Canvas.pm_SetPageOrientation(Value: Tl3PageOrientation);
  {-}
begin
 if (f_PageOrientation <> Value) then
 begin
  f_PageOrientation := Value;
  f_DeviceCaps.rIsAssigned := false;
 end;//f_PageOrientation <> Value
end;

function Tl3Canvas.pm_GetSectionExtent: Tl3Point;
  {-}
begin
 Result := f_SectionExtent;
end;

procedure Tl3Canvas.pm_SetSectionExtent(const Value: Tl3Point);
  {-}
begin
 f_SectionExtent := Value;
end;

function Tl3Canvas.pm_GetetoFlags: Word;
  {-}
begin
 Result := f_etoFlags;
 if Printing then
  Result :=  Result AND not eto_Opaque;
end;

function Tl3Canvas.Get_ForeColor: TColor;
  {-}
begin
 Result := TextColor;
end;

procedure Tl3Canvas.Set_ForeColor(Value: TColor);
  {-}
begin
 TextColor := Value;
end;

function Tl3Canvas.Get_BackColor: TColor;
  {-}
begin
 Result := BackColor;
end;

procedure Tl3Canvas.Set_BackColor(Value: TColor);
  {-}
begin
 BackColor := Value;
end;

function Tl3Canvas.Get_Height: Long;
  {-}
begin
 Result := VCLFont.Height;
end;

procedure Tl3Canvas.Set_Height(Value: Long);
  {-}
begin
 VCLFont.Height := Value;
end;

function Tl3Canvas.Get_Name: TFontName;
  {-}
begin
 Result := VCLFont.Name;
end;

procedure Tl3Canvas.Set_Name(const Value: TFontName);
  {-}
var
 l_LogFont : Tl3LogFont;
begin
 if (f_Font <> nil) AND (Value <> l3GlyphFontName) then
  f_Font := nil; 
 l_LogFont := l3FontManager.Fonts.DRByName[Value];
 VCLFont.Name := Value;
 if (l_LogFont = nil) then
  VCLFont.CharSet := CS_Effective
 else
  VCLFont.CharSet := l_LogFont.LogFont.elfLogFont.lfCharSet;
end;

function Tl3Canvas.Get_Pitch: TFontPitch;
  {-}
begin
 Result := VCLFont.Pitch;
end;

procedure Tl3Canvas.Set_Pitch(Value: TFontPitch);
  {-}
begin
 VCLFont.Pitch := Value;
end;

function Tl3Canvas.Get_Size: Long;
  {-}
begin
 Result := VCLFont.Size;
end;

procedure Tl3Canvas.Set_Size(Value: Long);
  {-}
begin
 VCLFont.Size := Value;
end;

function Tl3Canvas.Get_Style: TFontStyles;
  {-}
begin
 Result := VCLFont.Style;
end;

procedure Tl3Canvas.Set_Style(Value: TFontStyles);
  {-}
begin
 VCLFont.Style := Value;
end;

function Tl3Canvas.Get_Bold: Boolean;
  {-}
begin
 Result := fsBold in VCLFont.Style;
end;

procedure Tl3Canvas.Set_Bold(Value: Boolean);
  {-}
begin
 if Value then
  VCLFont.Style := VCLFont.Style + [fsBold]
 else
  VCLFont.Style := VCLFont.Style - [fsBold];
end;

function Tl3Canvas.Get_Italic: Boolean;
  {-}
begin
 Result := fsItalic in VCLFont.Style;
end;

procedure Tl3Canvas.Set_Italic(Value: Boolean);
  {-}
begin
 if Value then
  VCLFont.Style := VCLFont.Style + [fsItalic]
 else
  VCLFont.Style := VCLFont.Style - [fsItalic];
end;

function Tl3Canvas.Get_Underline: Boolean;
  {-}
begin
 Result := fsUnderline in VCLFont.Style;
end;

procedure Tl3Canvas.Set_Underline(Value: Boolean);
  {-}
begin
 if Value then
  VCLFont.Style := VCLFont.Style + [fsUnderline]
 else
  VCLFont.Style := VCLFont.Style - [fsUnderline];
end;

function Tl3Canvas.Get_Strikeout: Boolean;
  {-}
begin
 Result := fsStrikeout in VCLFont.Style;
end;

procedure Tl3Canvas.Set_Strikeout(Value: Boolean);
  {-}
begin
 if Value then
  VCLFont.Style := VCLFont.Style + [fsStrikeout]
 else
  VCLFont.Style := VCLFont.Style - [fsStrikeout];
end;

function Tl3Canvas.AssignFont(aFont: TFont): Bool;
  {-}
var
 l_ForeColor : TColor;
 l_FontColor : TColor;
 l_LogFont   : Tl3LogFont;
 l_Font      : TFont;
begin
 Result := true;
 l_Font := VCLFont;
 f_Font := nil;
 if (l_Font <> nil) AND (aFont <> nil) then
 begin
  l_ForeColor := TextColor;
  l_FontColor := l_Font.Color;
  f_TextColor := aFont.Color;
  l_Font.Assign(aFont);
  {$IfNDef Nemesis}
   f_TextMetricsValid := false;
  {$Else}
   //Assert(not f_TextMetricsValid);
  {$EndIf Nemesis}
  // ^ - http://mdp.garant.ru/pages/viewpage.action?pageId=185830296&focusedCommentId=199591219#comment-199591219
  if (l_Font.Color = clDefault) then
  begin
   Inc(f_CheckingColors);
   try
    l_Font.Color := l_FontColor;
    TextColor := l_ForeColor;
   finally
    Dec(f_CheckingColors);
   end;//try..finally
  end;//l_Font.Color = clDefault
  Inc(f_CheckingColors);
  try
   l_LogFont := l3FontManager.Fonts.DRByName[l_Font.Name];
   if (l_LogFont = nil) then
    l_Font.CharSet := CS_Effective
   else
    l_Font.CharSet := l_LogFont.LogFont.elfLogFont.lfCharSet;
  finally
   Dec(f_CheckingColors);
  end;//try..finally
  if l3IsDefaultCharset(l_Font.Charset) then
   if (l_Font.Charset <> CS_Effective) then
   begin
    Inc(f_CheckingColors);
    try
     l_Font.Charset := CS_Effective;
    finally
     Dec(f_CheckingColors);
    end;//try..finally
   end;//l_Font.Charset <> CS_Effective
 end;//l_Font <> nil
end;

function Tl3Canvas.IsAtomic: Boolean;
  {-}
begin
 Result := (f_Font <> nil) AND f_Font.IsAtomic;
end;

function Tl3Canvas.FM: Il3FontMetrics;
  {-}
begin
 if (f_Font = nil) then
  Result := nil
 else
  Result := f_Font.FM;
end;

procedure Tl3Canvas.Assign2Font(const aFont: Il3Font);
  {-}
var
 l_Font : TFont;
begin
 Lock;
 try
  aFont.Lock;
  try
   l_Font := VCLFont;
   if aFont.AssignFont(l_Font) then
   begin
    aFont.BackColor := BackColor;
    aFont.Index := FontIndex;
   end
   else
    with l_Font do
    begin
     aFont.Name := Name;
     aFont.Size := Size;
     aFont.Style := Style;
     aFont.Pitch := Pitch;
     aFont.ForeColor := Color;
     aFont.BackColor := BackColor;
     aFont.Index := FontIndex;
    end;//with l_Font
  finally
   aFont.Unlock;
  end;//try..finally
 finally
  Unlock;
 end;//try..finally
end;

function Tl3Canvas.HF: hFont;
  {-}
begin
 Result := VCLFont.Handle;
end;

function Tl3Canvas.Get_Font: Il3Font;
  {-}
begin
 Result := Self;
end;

procedure Tl3Canvas.Set_Font(const Value: Il3Font);
  {-}
begin
 Assert(Value <> nil);
 if Value.IsAtomic then
  f_Font := Value
 else
 begin
  f_Font := nil;
  Lock;
  try
   Value.Lock;
   try
    Value.Assign2Font(Self);
   finally
    Value.Unlock;
   end;//try..finally
  finally
   Unlock;
  end;//try..finally
 end;//Value.IsAtomic
end;

////////////////////////////////////////////////////////////////////////////////
// Y - определяет яркость,                                                    //
// I - так называемая синфазная компонента,                                   //
// Q - интегрированная компонента.                                            //
// Синфазная и интегрированная компоненты, так же как и компоненты U и V в    //
// модели YUV,  хранят информацию о цвете. Поэтому, YIQ в некоторм роде       //
// напоминает модель YUV.                                                     //
                                                                              
procedure RGB2YIQ(const RGB : TRGB;
                  out YIQ   : TYIQ);
  {-}
begin
 YIQ.Y := Trunc(0.299*RGB.R + 0.587*RGB.G + 0.114*RGB.B);
 YIQ.I := Trunc(0.596*RGB.R - 0.274*RGB.G - 0.332*RGB.B);
 YIQ.Q := Trunc(0.211*RGB.R - 0.522*RGB.G + 0.311*RGB.B);
end;

procedure YIQ2RGB(out RGB   : TRGB;
                  const YIQ : TYIQ);
  {-}

 function lpByte(aValue : Integer) : Byte;
 begin
  if aValue < 0 then
   Result := 0
  else
   Result := Byte(aValue);
 end;

begin
 RGB.R := lpByte(Trunc(YIQ.Y + 0.956*YIQ.I + 0.623*YIQ.Q));
 RGB.G := lpByte(Trunc(YIQ.Y - 0.272*YIQ.I - 0.648*YIQ.Q));
 RGB.B := lpByte(Trunc(YIQ.Y - 1.105*YIQ.I + 0.705*YIQ.Q));
end;

// HSV to RGB.
//    H = 0 to 359 (corresponding to 0..359 degrees around hexcone)
//    S = 0 (shade of gray) to 99 (pure color)
//    V = 0 (black) to 99 {white)
//
//    Based on C Code in "Computer Graphics -- Principles and Practice,"
//    Foley et al, 1996, p. 594.  Floating point fractions, 0..1, replaced with
//    integer values, 0..99.
procedure HSV2RGB(out px:TRGB; const HSV : THSV);
const
 divisor : INTEGER = 99*60;
var
 f     : INTEGER;
 hTemp : INTEGER;
 p,q,t : INTEGER;
 VS    : INTEGER;
 l_H   : Integer;
 l_S   : Integer;
 l_V   : Integer;
begin
 // check limits (changed at 2.1.1)
 l_H := HSV.H;
 l_S := HSV.S;
 l_V := HSV.V;     
 if (l_H < 0) then
  l_H := 360 + l_H
 else
 if (l_H > 359) then
  l_H := l_H - 360;
 if (l_S < 0) then
  l_S:=0
 else
 if (l_S > 99) then
  l_S := 99;
 if (l_V < 0) then
  l_V := 0
 else
 if (l_V > 99) then
  l_V := 99;
 //
 if (l_S = 0) then
 begin
   px.r := l_v;
   px.g := l_v;
   px.b := l_v;
 end//l_S = 0
 else
 begin
   IF (l_H = 360) then
     hTemp := 0
   else
     hTemp := l_H;
   f := hTemp mod 60;
   hTemp := hTemp div 60;
   VS := l_V * l_S;
   p := l_V - VS div 99;
   q := l_V - (VS*f) div divisor;
   t := l_V - (VS*(60 - f)) div divisor;
   with px do
   begin
     case hTemp of
       0:  begin  R := l_V;  G := t;  B := p  end;
       1:  begin  R := q;  G := l_V;  B := p  end;
       2:  begin  R := p;  G := l_V;  B := t  end;
       3:  begin  R := p;  G := q;  B := l_V  end;
       4:  begin  R := t;  G := p;  B := l_V  end;
       5:  begin  R := l_V;  G := p;  B := q  end;
     end//case hTemp
   end;//with px
 end;//l_S = 0
 px.r:=round(px.r/99*255);
 px.g:=round(px.g/99*255);
 px.b:=round(px.b/99*255);
end;

// RGB, each 0 to 255, to HSV.
//   H = 0 to 359 (corresponding to 0..359 degrees around hexcone)
//   S = 0 (shade of gray) to 99 (pure color)
//   V = 0 (black) to 99 {white)
//
//   Based on C Code in "Computer Graphics -- Principles and Practice,"
//   Foley et al, 1996, p. 592.  Floating point fractions, 0..1, replaced with
//   integer values, 0..99.

procedure RGB2HSV(const RGB:TRGB; out HSV: THSV);

 procedure MinMax3(const i,j,k:integer; var min, max:integer);
 begin//MinMax3
   IF i > j then begin
     IF i > k then max := i else max := k;
     IF j < k then min := j else min := k
   end else begin
     IF j > k then max := j else max := k;
     IF i < k then min := i else min := k
   end
 end;//MinMax3

var
 Delta    : integer;
 MinValue : integer;
 r,g,b    : integer;
begin
 r:=round( RGB.r/255*99 );
 g:=round( RGB.g/255*99 );
 b:=round( RGB.b/255*99 );
 with HSV do
 begin
  MinMax3(R, G, B, MinValue, V);
  Delta := V - MinValue;
  if V = 0 then
   S := 0
  else
   S := (99 * Delta) div V;
  if S = 0 then
   H := 0
  else
  begin
   if R = V then
    h := (60*(G-B)) div Delta
   else
   if G = V then
    h := 120 + (60*(B-R)) div Delta
   else
   if B = V then
    h := 240 + (60*(R-G)) div Delta;
   if H < 0 then H := H + 360;
  end;//S = 0
 end;//with HSV
end;

procedure CheckColorsYIQ(var aFC : TColor;
                         var aBC : TColor;
                         aDeltaY : Byte);
var
 l_F1         : TRGB absolute aFC;
 l_B1         : TRGB absolute aBC;
 l_Fyiq       : TYIQ;
 l_Byiq       : TYIQ;
 l_Delta      : Integer;
begin
 aFC := ColorToRGB(aFC);
 aBC := ColorToRGB(aBC);

 RGB2YIQ(l_F1, l_Fyiq);
 RGB2YIQ(l_B1, l_Byiq);

 l_Delta := Abs(l_Fyiq.y - l_Byiq.y);
 // Расстояние меньше необходимого
 if (l_Delta < aDeltaY) then
 begin
  if l_Byiq.y - aDeltaY > 0 then
   l_Fyiq.y := l_Byiq.y - aDeltaY
  else
   l_Fyiq.y := l_Byiq.y + aDeltaY;
  YIQ2RGB(l_F1, l_Fyiq);
 end;//l_Delta < aDeltaY
end;

{$Define UseHSV}

procedure CheckColorsHSV(var aFore : TColor;
                         var aBack : TColor);
var
 l_F1     : TRGB absolute aFore;
 l_B1     : TRGB absolute aBack;
 l_F      : THSV;
 l_B      : THSV;
 l_Diff   : Integer;
 l_Delta  : Integer;
 l_Border : Integer;
begin
 aBack := ColorToRGB(aBack);
 aFore := ColorToRGB(aFore);
 RGB2HSV(l_F1, l_F);
 RGB2HSV(l_B1, l_B);
 if (Abs(l_F.H - l_B.H) < 30) then
 begin
  l_Border := 50;
  l_Delta := 40;
 end
 else
 begin
  l_Border := 30;
  l_Delta := 30;
 end;//Abs(l_F.H - l_B.H) < 30
 l_Diff := l_F.V - l_B.V;
 if (Abs(l_Diff) < l_Border) then
 begin
  if (l_Diff < 0) then
  begin
   Dec(l_F.V, l_Delta);
   if (l_F.V < 0) then
    Inc(l_F.V, 99);
  end//l_Diff < 0
  else
  begin
   Inc(l_F.V, l_Delta);
   if (l_F.V > 99) then
    Dec(l_F.V, 99);
  end;//l_Diff < 0
  HSV2RGB(l_F1, l_F);
 end;//Abs(l_F.V - l_B.V) > l_Border
end;

procedure CheckColors(var aFore : TColor;
                      var aBack : TColor);
const
 l_Add  = 170;
 l_Gray = 384; // clGray;
var
 l_F1   : TRGB absolute aFore;
 l_B1   : TRGB absolute aBack;
 {$IfNDef UseHSV}
 l_F    : Integer;
 l_B    : Integer;
 {$EndIf UseHSV}
begin//CheckColorsHSV
 {$IfDef UseHSV}
 CheckColorsHSV(aFore, aBack);
 {$Else  UseHSV}
 aBack := ColorToRGB(aBack);
 aFore := ColorToRGB(aFore);
 with l_B1 do
  l_B := b + g + r;
 with l_F1 do
  l_F := b + g + r;

 if (l_B <= l_Gray) and
    (l_B * 1.3 >= l_F) then
 begin //Светлим шрифт
  with l_F1 do
  begin
   b := Min(b + l_Add, 255);
   g := Min(g + l_Add, 255);
   r := Min(r + l_Add, 255);
  end;//with l_F1
 end//l_B <= l_Gray
 else
 if (l_B > l_Gray) and
    (l_F * 1.3 >= l_B) then
 begin  //темним шрифт
  with l_F1 do
  begin
   b := Max(b - l_Add, 0);
   g := Max(g - l_Add, 0);
   r := Max(r - l_Add, 0);
  end;//with l_F1
 end;//l_B > l_Gray..
 {$EndIf UseHSV}
end;//CheckColorsHSV

function l3CharsToInch(aCount : Integer; aFontSize : Integer): Integer;
  {-}
const
 def_FontName = 'Arial CYR';  
var
 l_ICN : Il3InfoCanvas;
begin
 l_ICN := l3CrtIC;
 l_ICN.Font.Name := def_FontName;
 l_ICN.Font.Size := aFontSize;
 l_ICN.Font.Style := [];
 l_ICN.Font.Index := l3_fiNone;
 l_ICN.Font.Pitch := fpDefault;
 Result := l_ICN.TextExtent(l3PCharLen('w')).X * aCount;
 //Result := l_ICN.AverageCharWidth * aCount;
end;
    
procedure Tl3Canvas.CheckColors;
  {-}
var
 l_Back : TColor;
 l_Fore : TColor;
 l_BC   : TColor;
begin
 Inc(f_CheckingColors);
 try
  if (f_CheckingColors = 1) then
  begin
   if Printing then
   begin
    l_BC := BackColor;
    if Invert then
    begin
     VCLFont.Color := TextColor;
     Brush.Color := l_BC;
    end//Invert
    else
    begin
     VCLFont.Color := clWhite;
     Brush.Color := clWhite;
    end;//Invert
   end//Printing
   else
   begin
    l_BC := BackColor;
    if Invert then
    begin
     if NotFocused then
     begin
      l_Fore := TextColor;
      l_Back := clBtnFace
     end//NotFocused
     else
     begin
      l_Fore := InvertColor(TextColor);
      l_Back := clHighlight;
     end;//NotFocused
     if (f_Fore > 0) then
      l_Back := InvertColor(l_BC)
     else
      if f_DarkFore > 0 then
       l_Back := clHighlightText;
     //{$IfDef Nemesis}
     CheckColorsYIQ(l_Fore, l_Back);
     //{$Else Nemesis}
     //evGraph.CheckColors(l_Fore, l_Back);
     //{$EndIf Nemesis}
    end//Invert
    else
    begin
     l_Fore := TextColor;
     l_Back := l_BC;
    end;//Invert
    VCLFont.Color := l_Fore;
    Brush.Color := l_Back;
   end;//Printing
  end;//f_CheckingColors = 1
 finally
  Dec(f_CheckingColors);
 end;//try..finally
end;

procedure Tl3Canvas.BrushChanged(aBrush: TObject);
  {-}
begin
 if Assigned(f_OldBrushChange) then f_OldBrushChange(aBrush);
 if (f_CheckingColors <= 0) then
  BackColor := Brush.Color;
end;

procedure Tl3Canvas.FontChanged(aFont: TObject);
  {-}
var
 l_E : TNotifyEvent;
 l_M : TMethod absolute l_E;
begin
 if Assigned(f_OldFontChange) then
 begin
  l_E := f_OldFontChange;
  Assert(l_M.Data <> Self);
  l_E(aFont);
 end;//Assigned(f_OldFontChange) 
 f_TextMetricsValid := false;
 f_AverageCharHeight := 0;
 f_AverageCharWidth := 0;
 f_pxAverageCharWidth := 0;
 if (Win32Platform = VER_PLATFORM_WIN32_WINDOWS) then
  f_SuffixedFont := ANSIEndsText(fs_Cyr, VCLFont.Name)
 else
 if (Win32Platform = VER_PLATFORM_WIN32_NT) then
 begin
  if (Win32MajorVersion = 5) then
  begin
   if (Win32MinorVersion = 0) then
    f_SuffixedFont := false
   else
    f_SuffixedFont := true;
  end//Win32MajorVersion = 5
  else
  if (Win32MajorVersion > 5) then
   f_SuffixedFont := true
  else
   f_SuffixedFont := ANSIEndsText(fs_Cyr, VCLFont.Name);
 end//Win32Platform = VER_PLATFORM_WIN32_NT
 else
 begin
  Assert(false);
  f_SuffixedFont := ANSIEndsText(fs_Cyr, VCLFont.Name);
 end;//Win32Platform = VER_PLATFORM_WIN32_NT
 if (f_CheckingColors <= 0) then
 begin
  Inc(f_CheckingColors);
  try
   TextColor := VCLFont.Color;
  finally
   Dec(f_CheckingColors);
  end;//try..finally
 end;//
 CheckDrawing;
end;

function Tl3Canvas.xCheckFilled: Tl3Region;
  {-}
begin
 if (f_Filled = nil) then
  f_Filled := Tl3Region.Create;
 Result := f_Filled;
end;

procedure Tl3Canvas.FreeDC;
  {-}
begin
 if (f_DC <> 0) then
 begin
  Case f_DCFlag of
   ev_dcfCanvas: 
    if (Owner Is TMetaFile) then
     Canvas := nil;
   ev_dcfGot: begin
    if (f_Canvas <> nil) then
     f_Canvas.Handle := 0;
    FreeAlienDC(f_DC); 
   end;//ev_dcfGot
   ev_dcfCreated:
   begin
    if (f_Canvas <> nil) then
     f_Canvas.Handle := 0;
    DeleteDC(f_DC);
    f_DCFlag := ev_dcfCanvas;
   end;//ev_dcfCreated
   else
    f_DCFlag := ev_dcfCanvas;
  end;//Case f_DCFlag
  f_DC := 0;
 end;//f_DC <> 0
end;

procedure Tl3Canvas.FreeAlienDC(aDC: hDC);
  //virtual;
  {-}
begin
end;

function Tl3Canvas.AsIl3Canvas: Il3Canvas;
begin
 Result := Self;
end;

function Tl3Canvas.CheckDrawing: Bool;
  {-}
var
 CN      : TCanvas;
 l_OldDC : hDC;
 l_Owner : TObject;
begin
 Inc(f_CheckingDrawing);
 try
  l_OldDC := f_DC;
  Result := Drawing OR (f_DCFlag in [ev_dcfLinked, ev_dcfCreated]) OR Printing;
  if Result AND (f_CheckingDrawing <= 1) then
  begin
   Lock;
   try
    l_Owner := Owner;
    CN := Canvas;
    Case f_DCFlag of
     ev_dcfCanvas:
      if (CN Is TMetaFileCanvas) then
      begin
       f_DC := CN.Handle;
      end//CN Is TMetaFileCanvas
      else
      if (f_Printer <> nil) AND not f_Printer.Printing then
      begin
       f_DC := f_Printer.DC;
       SelectObject(f_DC, VCLFont.Handle);
       {-обновляем шрифт принудительно}
      end//f_Printer <> nil..
      else
      if (l_Owner Is TMetaFile) AND (f_DC = 0) then
      begin
       CN := TMetaFileCanvas.Create(TMetaFile(l_Owner), 0);
       SetCanvas(CN, false);
       f_DC := CN.Handle;
      end//l_Owner Is TMetaFile
      else
       f_DC := CN.Handle;
     ev_dcfGot:
     begin
      if (f_DC = 0) then
       f_DC := GetAlienDC;
      CN.Handle := f_DC;
      f_DC := CN.Handle;
      {-обновляем шрифт, перо, кисть etc}
     end;//ev_dcfGot
     ev_dcfCreated,
     ev_dcfLinked:
     begin
      if (CN <> nil) and (f_DC <> 0) then
       CN.Handle := f_DC;
      if (CN <> nil) then
       f_DC := CN.Handle;
      {-обновляем шрифт, перо, кисть etc}
     end;//ev_dcfCreated..}
    end;//Case f_DCFlag
    if (l_OldDC <> f_DC) then
    begin
     UpdatePixelsPerInch;
     {-обновляем разрешение}
     VCLFont.PixelsPerInch := PixelsPerInchY; {-выставляем разрешение шрифту}
    end;//l_OldDC <> f_DC
    if (Zoom <> 100) then
    begin
     SetMapMode(f_DC, MM_ISOTROPIC);
     SetWindowExtEx(f_DC, 100, 100, nil);
     SetViewPortExtEx(f_DC, Abs(Zoom), Abs(Zoom), nil);
    end;//Zoom <> 100
   finally
    Unlock;
   end;//try..finally
  end;//Result
 finally
  Dec(f_CheckingDrawing);
 end;//try..finally
end;

function Tl3Canvas.GetAlienDC: hDC;
  {-}
begin
 Result := 0;
end;
  
function Tl3Canvas.DrawingIsValid: Bool;
  {* - проверяет возможно ли рисование. }
begin
 Result := not IsVirtual AND DrawEnabled AND CheckDrawing;
end;

function Tl3Canvas.DeviceCaps(anIndex: Integer): Integer;
  {* - возвращает свойства устройства рисования. }
begin
 with f_DeviceCaps do
 begin
  if not rIsAssigned then
   AssignDeviceCaps;
  case anIndex of
   LOGPIXELSX:
    Result := rLOGPIXELSX;
   LOGPIXELSY:
    Result := rLOGPIXELSY;
   HORZRES:
    Result := rHORZRES;
   VERTRES:
    Result := rVERTRES;
   PHYSICALWIDTH:
    if (f_Printer = nil) OR (f_Printer.Orientation = f_PageOrientation) then
     Result := rPHYSICALWIDTH
    else
     Result := rPHYSICALHEIGHT;
   PHYSICALHEIGHT:
    if (f_Printer = nil) OR (f_Printer.Orientation = f_PageOrientation) then
     Result := rPHYSICALHEIGHT
    else
     Result := rPHYSICALWIDTH;
   PHYSICALOFFSETX:
    if (f_Printer = nil) OR (f_Printer.Orientation = f_PageOrientation) {OR
       (f_PageOrientation = l3_poPortrait)} then
     Result := rPHYSICALOFFSETX
    else
     Result := rPHYSICALOFFSETY;
   PHYSICALOFFSETY:
    if (f_Printer = nil) OR (f_Printer.Orientation = f_PageOrientation) {OR
       (f_PageOrientation = l3_poPortrait)} then
     Result := rPHYSICALOFFSETY
    else
     Result := rPHYSICALOFFSETX;
   else
   begin
    Lock;
    try
     Result := Windows.GetDeviceCaps(DC, anIndex);
    finally
     Unlock;
    end;//try..finally
   end;//else
  end;//case anIndex
 end;//with f_DeviceCaps
end;

function Tl3Canvas.DrawRgnOrBlock: Bool;
  {-}
begin
 Result := ([ev_dfDrawregion] * Flags <> []);
end;

function Tl3Canvas.IsVirtual: Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

procedure Tl3Canvas.StretchDraw(const R: Tl3Rect; Graphic: TGraphic);
  {override;}
  {-}
var
 l_R       : Tl3SRect;
 l_OldMode : TCopyMode;
begin
 l_R := WO(R);
 if DrawingIsValid then
 begin
  l_OldMode := Canvas.CopyMode;
  try
   if Invert AND not Printing then
    Canvas.CopyMode := cmNotSrcCopy
   else
    Canvas.CopyMode := cmSrcCopy;
   {$IfDef l3DrawBitmapsTransparent}
   if (Graphic Is TBitmap) then
   begin
    TBitmap(Graphic).IgnorePalette := true;
    //CheckColors;
    //TBitmap(Graphic).TransparentColor := Brush.Color;
    TBitmap(Graphic).TransparentColor := clWhite;
    // - т.к. обычно подложка белая
   end;//Graphic Is TBitmap
   Graphic.Transparent := true;
   {$EndIf l3DrawBitmapsTransparent}
   if Graphic.Transparent then
    FillRect(l_R)
   else
    AddRect(l_R);
   Canvas.StretchDraw(l_R.R.WR, Graphic);
  finally
   Canvas.CopyMode := l_OldMode;
  end;
 end//DrawingIsValid
 else
  AddRect(l_R);
end;

function Tl3Canvas.LP2DP(const P  : Tl3_Point;
                         NeedZoom : Bool = false): Tl3SPoint;
  {-}
begin
 Result.X := l3MulDiv(P.X, PixelsPerInchX, l3Inch);
 Result.Y := l3MulDiv(P.Y, PixelsPerInchY, l3Inch);
 if NeedZoom then
 begin
  BeginPaint;
  try
   LPtoDP(DC, Result, 1);
  finally
   EndPaint;
  end;//try..finally
 end;//NeedZoom
end;

function Tl3Canvas.LR2DR(const R: Tl3Rect): Tl3SRect;
  {-}
begin
 Result.TopLeft := LP2DP(R.TopLeft);
 Result.BottomRight := LP2DP(R.BottomRight);
end;

function Tl3Canvas.DR2LR(const R: Tl3SRect): Tl3Rect;
  {-}
begin
 Result.TopLeft := DP2LP(R.TopLeft);
 Result.BottomRight := DP2LP(R.BottomRight);
end;

function Tl3Canvas.TextExtent(const S : Tl3PCharLenPrim;
                              aNoTabs : Boolean = false): Tl3Point;
  {-возвращает длину строки текста в сантиметрах}

var  
 l_Extent : TSize;

 procedure _TextExtent(const aSt: Tl3PCharLenPrim);
 
 var
  l_DC : hDC;

  function TabbedTextExtent: Bool;
  var
   l_TabLen: Integer;
   l_TabPos: Integer;
   l_S     : Tl3PCharLenPrim; // кусок текста до табуляции
   l_NS    : Tl3PCharLen; // следующий кусок текста
   l_Last  : Bool;
   l_E     : TSize; // размеры кусочка до табуляции
   l_TabStops: Il3TabStops;
   l_CurTab: Integer;
  begin//TabbedTextExtent
   Result := true;
   l_Extent.cX := 0;
   l_Extent.cY := TextMetrics^.tmHeight;
   l_S := aSt;
   l_TabPos := 0;
   if (f_TabStops <> nil) and f_TabStops.NeedCutByTab then
    l_TabStops := f_TabStops.Clone;
   repeat
    l_NS := l3FindChar(cc_Tab, l_S);
    l_Last := Tl3PCharLen(l_S).IsLast(cc_Tab);
    if l_Last then
     Dec(l_S.SLen);

    // "Рисуем" текст:
    if (l_TabStops <> nil) then
    begin
     l_TabLen := LP2DP(l3PointX(l_TabStops.Next.rPosition)).X;
     l_CurTab := l_TabLen - l_TabPos;
     l_TabPos := l_TabLen;
     SystemTextExtent(l_DC, l_S, l_E, f_LineSpacing);
     l_E.cx := Min(l_CurTab, l_E.cx);
    end//l_TabStops <> nil
    else
     SystemTextExtent(l_DC, l_S, l_E, f_LineSpacing);
    Inc(l_Extent.cX, l_E.cX);
    Inc(f_TabOffset, l_E.cX);
    l_Extent.cY := Max(l_Extent.cY, l_E.cY);

    if l_Last then
    begin
     // Рисуем знак табуляции:
     l_E.cX := GetTabWidth;
     Inc(l_Extent.cX, l_E.cX);
     Inc(f_TabOffset, l_E.cX);
    end;//l_Last..

    l_S := l_NS;
   until l3IsNil(l_NS);
  end;//TabbedTextExtent

 begin//_TextExtent
  l_DC := DC;
  if not aNoTabs AND (f_Tabs > 0) AND l3HasChar(cc_Tab, aSt) AND
     TabbedTextExtent then
   Exit;
  SystemTextExtent(l_DC, aSt, l_Extent, f_LineSpacing);
  {$IFDEF Nemesis}
  // ^ - проблема с позиционированием в тексте комментариев в Арчи, в частности [$118982332].
  if Get_Italic AND (aSt.SLen > 0) then
  // - пытаемся учитывать наклон шрифта - чтобы буквы не обрезались
  // http://mdp.garant.ru/pages/viewpage.action?pageId=109904426
   if not l3IsWhiteSpaceS(aSt, Pred(aSt.SLen)) then
    Inc(l_Extent.cX);
  {$ENDIF Nemesis}
 end;//_TextExtent

var
 l_Str : Tl3Str;
 l_Convert  : Tl3Str;
 l_St       : Tl3PCharLenPrim;
begin
 if (f_PasswordChar <> #0) then
 begin
  l_Convert.Init(Tl3WString(S), CP_ANSI);
  l3FillChar(l_Convert.S^, l_Convert.SLen, Ord(f_PasswordChar));
  l_St := l_Convert;
 end//f_PasswordChar <> #0
 else
 begin
  l_Convert.Init;
  l_St := S;
 end;//f_PasswordChar <> #0
 try
  if (f_Font <> nil) then
  begin
   Tl3_Point(Result) := f_Font.FM.TextExtent(l_St);
   Exit;
  end;//f_Font <> nil
  l3FillChar(Result, SizeOf(Result));
  if not l3IsNil(l_St) then
  begin
   if (VCLFont.Pitch = fpFixed) then
   begin
    with TextMetrics^ do
    begin
     f_pxAverageCharWidth := tmAveCharWidth;
     Result := DP2LP(l3SPoint(f_pxAverageCharWidth * l_St.SLen, tmHeight));
    end;//with TextMetrics^
   end//VCLFont.Pitch = fpFixed
   else
   begin
    if (f_SuffixedFont AND (l_St.SCodePage = CP_ANSI)) OR
       // - закомментировано, т.к. неправильно работало с 'Arial', а не 'Arial CYR'
       (S.SCodePage = CP_Unicode) then begin
     _TextExtent(l_St);
     Result := DP2LP(l3SPoint(l_Extent.cX, l_Extent.cY));
    end//f_SuffixedFont..
    else
    begin
     l_Str.Init(l_St, CP_Unicode, @f_ConvertBuf);
     _TextExtent(l_Str);
     Result := DP2LP(l3SPoint(l_Extent.cX, l_Extent.cY));
    end;//f_SuffixedFont..
   end;//VCLFont.Pitch = fpFixed
  end;//S <> nil
 finally
  l_Convert.Clear;
 end;//try..finally
end;

function Tl3Canvas.Pos2Index(W: Long; const S: Tl3PCharLen): Long;
  {-находит индекс символа на рассоянии W точек от начала строки S}
var
 TW    : Long;
 l_S   : Tl3PCharLen;
 l_ACW : Integer;
begin
 if (f_Font <> nil) then
 begin
  Result := f_Font.FM.Pos2Index(W, S);
  Exit;
 end;//f_Font <> nil
 Result := S.SLen;
 l_ACW := AverageCharWidth;
 if (f_Tabs > 0) OR (W < l_ACW * Result * 2) then
 begin
  TW := 0;
  Inc(W, l_ACW div 2);
  l_S := l3PCharLen(S.S, 1, S.SCodePage);
  while (Result > 0) do
  begin
   Inc(TW, TextExtent(l_S).X);
   if (TW < W) then
   begin
    Dec(Result);
    l_S.MoveS;
   end//TW < W
   else
    break;
  end;//Result > 0
  Result := S.SLen - Result;
 end;//f_Tabs > 0.. 
end;

function Tl3Canvas.Pos2IndexQ(W           : Long;
                              const S     : Tl3PCharLen;
                              var aNoTabs : Boolean): Long;
  {-находит индекс символа на рассоянии W точек от начала строки S}
var
 l_Diff          : Long;
 l_S             : Tl3PCharLen;
 l_L             : Long;
 l_H             : Long;
 l_NeedResetTabs : Boolean;
 l_NoTabs        : Boolean;
begin
 if (f_Font <> nil) then
 begin
  Result := f_Font.FM.Pos2Index(W, S);
  Exit;
 end;//f_Font <> nil
 if l3IsNil(S) OR (W <= 0) then
  Result := 0
 else
 begin
  Result := S.SLen;
  if (Result > 1) then
  begin
   l_NoTabs := aNoTabs OR ((f_Tabs <= 0) OR not l3HasChar(cc_Tab, S));
   aNoTabs := l_NoTabs;
   l_L := 0;
   l_H := Result;
   l_S := l3PCharLen(S.S, Result, S.SCodePage);
   {if (TextExtent(l_S, l_NoTabs).X < W) then
    Exit;}
   l_NeedResetTabs := not l_NoTabs AND (f_Tabs > 0) AND (f_TabStops <> nil);
   while (l_L <= l_H) do
   begin
    Result := (l_L + l_H) div 2;
    l_S.SLen := Result;
    l_Diff := W - TextExtent(l_S, l_NoTabs).X;
    if (Abs(l_Diff) < l3Epsilon {* 3}) then
     // - примерно нашли то, что искали
     break
    else
    if (l_Diff < 0) then
    begin
     // - надо уменьшать длину измеряемой строки
     l_H := Pred(Result);
     if (l_L = Succ(l_H)) then
      // - округляем в меньшую сторону
      Result := l_H;
    end//l_Diff < 0
    else
    if (l_Diff > 0) then
    begin
     // - надо увеличивать длину измеряемой строки
(*     if (Result = S.SLen - 1) then
     begin
      // - предыдущий символ нас не удовлетворил, значит искомая позиция - длина строки
      Inc(Result);
      break;
     end//Result = S.SLen - 1
     else*)
      l_L := Succ(Result);
    end;//l_Diff > 0
    if l_NeedResetTabs then
     f_TabStops.Reset;
   end;//while Result > 1
  end;//Result > 1..
 end;//l3IsNil(S)
end;

function Tl3Canvas.pxAverageCharWidth: Long;
  {-средняя ширина символов контекста в пикселях}
begin
 if (f_pxAverageCharWidth = 0) then
  f_pxAverageCharWidth := TextMetrics^.tmAveCharWidth;
 Result := f_pxAverageCharWidth;
end;

function Tl3Canvas.AverageCharWidth: Long;
  {override;}
  {-средняя ширина символов контекста в пикселях}
begin
 if (f_AverageCharWidth = 0) then
  f_AverageCharWidth := DP2LP(l3SPoint(pxAverageCharWidth, 0)).X;
 Result := f_AverageCharWidth;
end;

function Tl3Canvas.AverageCharHeight: Long;
  {override;}
  {-средняя высота символов контекста}
begin
 if (f_AverageCharHeight = 0) then
  f_AverageCharHeight := DP2LP(l3SPoint(0, ApplyLineSpacing(TextMetrics^.tmHeight, f_LineSpacing))).Y;
 Result := f_AverageCharHeight;
end;

procedure Tl3Canvas.MoveTo(const aPt: Tl3Point);
  {-}
begin
 with WO(aPt) do
  Canvas.MoveTo(X, Y);
end;

procedure Tl3Canvas.LineTo(const aPt: Tl3Point);
  {-}
begin
 if DrawEnabled then
  with WO(aPt) do
   DoDrawLineTo(X, Y);
end;

procedure Tl3Canvas.MoveTo(const aPt: Tl3SPoint);
  //overload;
  {-}
begin
 with WO(aPt) do
  Canvas.MoveTo(X, Y);
end;

procedure Tl3Canvas.LineTo(const aPt: Tl3SPoint);
  //overload;
  {-}
begin
 if DrawEnabled then
  with WO(aPt) do
   DoDrawLineTo(X, Y);
end;

procedure Tl3Canvas.Line(const A, B: Tl3Point);
  {-}
begin
 if DrawEnabled then
 begin
  MoveTo(A);
  LineTo(B);
 end;//DrawEnabled
end;

procedure Tl3Canvas.Line(const A, B: Tl3SPoint);
  {-}
begin
 if DrawEnabled then
 begin
  MoveTo(A);
  LineTo(B);
 end;//DrawEnabled
end;

function Tl3Canvas.CaretExtent: Tl3Point;
  {-}
begin
 with TextMetrics^ do
 begin
  f_pxAverageCharWidth := tmAveCharWidth;
  Result := DP2LP(l3SPoint(f_pxAverageCharWidth, tmHeight));
 end;//with TextMetrics^
end;

type
  Tl3TabInfo = class(Tl3CacheableBase, Il3TabInfo)
    private
    // internal fields
      f_TabOffset : Long;
      f_TabStops  : Il3TabStops;
    private
    // interface methods
      // Il3TabInfo
      function TabOffset: Long;
        {-}
      function TabStops: Il3TabStops;
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(aTabOffset      : Long;
                         const aTabStops : Il3TabStops);
        reintroduce;
        {-}
      class function Make(aTabOffset      : Long;
                          const aTabStops : Il3TabStops): Il3TabInfo;
        {-}
  end;//Tl3TabInfo

constructor Tl3TabInfo.Create(aTabOffset      : Long;
                              const aTabStops : Il3TabStops);
  //reintroduce;
  {-}
begin
 inherited Create;
 f_TabOffset := aTabOffset;
 if (aTabStops = nil) then
  f_TabStops := nil
 else
  f_TabStops := aTabStops.Clone;
end;

class function Tl3TabInfo.Make(aTabOffset      : Long;
                               const aTabStops : Il3TabStops): Il3TabInfo;
  {-}
var
 l_TabInfo : Tl3TabInfo;
begin
 l_TabInfo := Tl3TabInfo.Create(aTabOffset, aTabStops);
 try
  Result := l_TabInfo;
 finally
  l3Free(l_TabInfo);
 end;//try..finally
end;

procedure Tl3TabInfo.Cleanup;
  //override;
  {-}
begin
 f_TabStops := nil;
 inherited;
end;

function Tl3TabInfo.TabOffset: Long;
  {-}
begin
 Result := f_TabOffset;
end;

function Tl3TabInfo.TabStops: Il3TabStops;
  {-}
begin
 Result := f_TabStops;
end;

procedure Tl3Canvas.StartTabs(out theTabInfo  : Il3TabInfo;
                              const aTabStops : Il3TabStops;
                              aTabOffset      : Long = 0);
  {-}
begin
 theTabInfo := TabInfo;
 {$IfDef l3NeedTabbedText}
 Inc(f_Tabs);
 {$EndIf l3NeedTabbedText}
 f_TabOffset := LP2DP(l3PointX(aTabOffset)).X;
 f_TabStops := aTabStops;
end;

procedure Tl3Canvas.StartTabs(out theTabInfo : Il3TabInfo;
                              const aTabInfo : Il3TabInfo);
  //overload;
  {-}
begin
 theTabInfo := TabInfo;
 {$IfDef l3NeedTabbedText}
 Inc(f_Tabs);
 {$EndIf l3NeedTabbedText}
 RestoreTabInfo(aTabInfo);
end;

procedure Tl3Canvas.FinishTabs(var aTabInfo: Il3TabInfo);
  {-}
begin
 {$IfDef l3NeedTabbedText}
 Dec(f_Tabs);
 {$EndIf l3NeedTabbedText}
 RestoreTabInfo(aTabInfo);
 aTabInfo := nil; // - чтобы никто больше не воспользовался
end;

procedure Tl3Canvas.RestoreTabInfo(const aTabInfo: Il3TabInfo);
  {-}
begin
 if (aTabInfo <> nil) then
 begin
  f_TabOffset := LP2DP(l3PointX(aTabInfo.TabOffset)).X;
  f_TabStops := aTabInfo.TabStops;
 end//aTabInfo <> nil
 else
 begin
  f_TabOffset := 0;
  f_TabStops := nil;
 end;//aTabInfo <> nil
end;

procedure Tl3Canvas.AssignDeviceCaps;
  {-}
var
 l_DC  : hDC;
 l_DCD : hDC;
begin
 if f_DeviceCaps.rIsAssigned then
  Exit;
 Lock;
 try
  with f_DeviceCaps do
  begin
   l_DCD := 0;
   try
    l_DC := DC;
    rLOGPIXELSX := Windows.GetDeviceCaps(l_DC, LOGPIXELSX);
    rLOGPIXELSY := Windows.GetDeviceCaps(l_DC, LOGPIXELSY);
    if (rLOGPIXELSX = 0) OR (rLOGPIXELSY = 0) then
    begin
     l_DCD := GetDC(0);
     l_DC := l_DCD;
     rLOGPIXELSY := Windows.GetDeviceCaps(l_DC, LOGPIXELSY);
     rLOGPIXELSX := rLOGPIXELSY;
    end;//rLOGPIXELSX = 0..
    rHORZRES := Windows.GetDeviceCaps(l_DC, HORZRES);
    rVERTRES := Windows.GetDeviceCaps(l_DC, VERTRES);
    rPHYSICALWIDTH := Windows.GetDeviceCaps(l_DC, PHYSICALWIDTH);
    if (rPHYSICALWIDTH = 0) then
     rPHYSICALWIDTH := l3MulDiv(def_inchPaperWidth, rLOGPIXELSX, l3Inch); // A4
    rPHYSICALHEIGHT := Windows.GetDeviceCaps(l_DC, PHYSICALHEIGHT);
    if (rPHYSICALHEIGHT = 0) then
     rPHYSICALHEIGHT := l3MulDiv(def_inchPaperHeight, rLOGPIXELSY, l3Inch); // A4
    rPHYSICALOFFSETX := Windows.GetDeviceCaps(l_DC, PHYSICALOFFSETX);
    rPHYSICALOFFSETY := Windows.GetDeviceCaps(l_DC, PHYSICALOFFSETY);
    f_DeviceCaps.rIsAssigned := (l_DCD = 0) AND (rLOGPIXELSY <> 0);
   finally
    if (l_DCD <> 0) then
     ReleaseDC(0, l_DCD);
   end;//try..finally
  end;//l_DC = 0
 finally
  Unlock;
 end;//try..finally
end;

function Tl3Canvas.IsPreview: Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

function Tl3Canvas.TabInfo: Il3TabInfo;
  {-}
begin
 if (f_Tabs > 0) then
  Result := Tl3TabInfo.Make(TabOffset, f_TabStops)
 else
  Result := nil;
end;

function Tl3Canvas.EQ(const aCanvas: Il3InfoCanvas): Bool;
  {-}
const
 cInchPoint : Tl3Point = (P : (X: l3Inch; Y: l3Inch));
begin
 Result := l3IEQ(Self, aCanvas) OR
           ((Zoom = aCanvas.Zoom) AND LP2DP(cInchPoint).EQ(aCanvas.LP2DP(cInchPoint)));
end;

function Tl3Canvas.TabOffset: Long;
  {-}
begin
 Result := DP2LP(PointX(f_TabOffset)).X;
end;

procedure Tl3Canvas.StartPage;
  {-}
begin
 DoStartPage;
end;

procedure Tl3Canvas.DoStartPage;
  //virtual;
  {-}
var
 R    : Tl3Rect;
 l_WO : Tl3Point;
 l_Canvas: Il3Canvas;
 l_BottomHeight: Long;
 l_CR : Tl3Rect;
begin
 WindowOrg := l3Point0;
 ClipRect := l3RectBnd(l3Point0,
                       DP2LP(l3SPoint(DeviceCaps(HORZRES),
                                      DeviceCaps(VERTRES))));
 Printed := true;
 l_WO := WindowOrg;
 if (Painter <> nil) then
 begin
  FreeAndNil(f_Filled);
  BeginInvert;
  try
   CheckDrawing;
   PushBC;
   try
    l_CR := ClipRect;
    if (f_VirtualCanvas <> nil) then
     with f_VirtualCanvas.PageSetup do
      if (Width <> l_CR.Right) OR (Height <> l_CR.Bottom) then
       f_VirtualCanvas := nil;
    if (f_VirtualCanvas = nil) then
     f_VirtualCanvas := Tl3VirtualCanvas.Make(l_CR.BottomRight);
    l_Canvas := f_VirtualCanvas;
    try
     l_Canvas.AbortChecker := Self.f_AbortChecker;
     try
      l_Canvas.PageSetup.Margins := pm_GetMargins{pm_GetPrintableMargins};
      l_BottomHeight := l_Canvas.PageSetup.Margins.Bottom;
      l_Canvas.WindowOrg := l3Point0;
      l_Canvas.MoveWindowOrg(PointX(DeviceCaps(PHYSICALOFFSETX)));
      Painter.StartPage(l_Canvas, false);
      l_BottomHeight := Max(-l_Canvas.WindowOrg.Y, l_BottomHeight);
     finally
      l_Canvas.AbortChecker := nil;
     end;//try..finally
    finally
     l_Canvas := nil;
    end;
    MoveWindowOrg(PointX(DeviceCaps(PHYSICALOFFSETX)));
    Painter.StartPage(Self, true);
    l_WO := WindowOrg;
    WindowOrg := l3Point0;
    WindowOrg := l3PointY(ClipRect.Bottom - l_BottomHeight).Neg;
    MoveWindowOrg(PointX(DeviceCaps(PHYSICALOFFSETX)));
    Painter.StartPage(Self, false);
   finally
    PopBC;
   end;//try..finally
  finally
   EndInvert;
  end;//try..finally
 end//Painter <> nil
 else
  l_BottomHeight := 0{pm_GetPrintableMargins.Bottom};
 WindowOrg := l_WO;
 MoveWindowOrg(l3PointX(-WindowOrg.X));
 MoveWindowOrg(PointX(DeviceCaps(PHYSICALOFFSETX)));
 R := ClipRect;
 if (R.Left < 0) then R.Left := 0;
 if (R.Top < 0) then R.Top := 0;
 R.BottomRight := R.BottomRight.Sub(l3PointY(l_BottomHeight));
 // - здесь уменьшаем размер области вывода на размер нижнего поля -
 //   чтобы текст не рисовал на колонтитуле.
 ClipRect := R;
end;

procedure Tl3Canvas.BeginPaint;
  {virtual;}
  {-}
begin
 Lock;
 Inc(f_Drawing);
 if (f_Drawing = 1) then
 begin
  l3FillChar(f_InitialDCOffset, SizeOf(f_InitialDCOffset));
  f_ClipRectInited := false;
  if Printing AND (f_Printer <> nil) then
  begin
   with LP2DP(f_WindowOrg) do
    SetWindowOrgEx(DC, X, Y, nil);
   if not f_Printer.Printing then
   begin
    f_PageNumber := 1;
    f_OverallPageNumber := 1;
    f_PageWidthNumber := 0;
    CheckOrientation;
    f_SaveOrientation := f_Printer.Orientation;
    f_Printer.Orientation := f_PageOrientation;
    {$IfNDef l3UsePrinterForPreview}
    if not IsPreview then
    {$EndIf  l3UsePrinterForPreview}
     if (NeedOpenRealPage(true) = l3_oprYes) then
      StartPrinterPage(true);
    StartPage;
   end;//not f_Printer.Printing
  end;//Printing..
 end;//f_Drawing = 1..
end;

function Tl3Canvas.NeedOpenRealPage(aDoc : Boolean; ByWidth: Boolean = false): Tl3OpenPageResult;
  //virtual;
  {-}
begin
 Result := l3_oprYes;
end;
  
procedure Tl3Canvas.StartPrinterPage(aDoc : Boolean);
  //virtual;
  {-}
begin
 if (ev_dfSelfStarted in Flags) then
  f_Printer.NewPage
 else
 begin
  Flags := Flags + [ev_dfSelfStarted];
  f_Printer.BeginDoc;
 end;//ev_dfSelfStarted in Flags
end;
  
procedure Tl3Canvas.DoStartObject(anObjectID: Integer);
  //virtual;
  {-}
begin
end;

procedure Tl3Canvas.StartObject(anObjectID: Integer);
  //virtual;
  {-}
begin
 DoStartObject(anObjectID);
end;

procedure Tl3Canvas.DoSetPageTop;
  //virtual;
  {-}
begin
end;

procedure Tl3Canvas.SetPageTop;
  //virtual;
  {-}
begin
 DoSetPageTop;
end;

procedure Tl3Canvas.DoEndPaint;
  //virtual;
  {-}
begin
 Dec(f_Drawing);
 if (f_Drawing = 0) then
 begin
  if (ev_dfSelfStarted in Flags) and f_Printer.Printing then
   f_Printer.EndDoc;
  if Printing AND (f_Printer <> nil) and not f_Printer.Printing then
   f_Printer.Orientation := f_SaveOrientation;
  f_FrameLines := nil;
  FreeDC;
  FreeAndNil(f_Filled);
  f_VirtualCanvas := nil;
  f_PageWidthNumber := 0;
 end;//f_Drawing = 0
 Unlock;
end;

procedure Tl3Canvas.EndPaint;
  {virtual;}
  {-}
begin
 DoEndPaint;
end;

procedure Tl3Canvas.BeginInvert;
  {-}
begin
 Inc(f_Invert);
 if DrawEnabled AND Drawing then CheckColors;
end;

procedure Tl3Canvas.EndInvert;
  {-}
begin
 Dec(f_Invert);
 if DrawEnabled AND Drawing then CheckColors;
end;

function Tl3Canvas.FillRgn(const Region: Il3Region): Bool;
  {-}
begin
 if Drawing AND (Region <> nil) AND not Region.Empty then
 begin
  if DrawEnabled then
  begin
   CheckColors;
   AddRgn(Region);
   Result := Windows.FillRgn(DC, Region.Rgn, Brush.Handle);
  end//DrawEnabled
  else
   Result := false;
 end//Drawing AND not Region.Empty
 else
  Result := false;
end;

function Tl3Canvas.CreateRectRgn(const aRect: Tl3SRect): Tl3Rgn;
  {-}
begin
 Result := aRect.CreateRgn;
end;

function Tl3Canvas.OffsetRgn(const Rgn: Il3Region; const Pt: Tl3Point): Integer;
  {-}
begin
 if (Rgn = nil) then
  Result := Windows.NULLREGION
 else
  Result := Rgn.Offset(LP2DP(Pt));
end;

function  Tl3Canvas.pm_GetWindowOrg: Tl3Point;
  {-}
var
 l_Pt : Tl3SPoint;
 l_DC : hDC;
begin
 if f_WindowOrgInited then
  Result := f_WindowOrg
 else
 begin
  l_DC := DC;
  if (l_DC = 0) then
   Result := f_WindowOrg
  else
  begin
   if GetWindowOrgEx(l_DC, TPoint(l_Pt)) then
   begin
    Result := DP2LP(l_Pt);
    f_WindowOrgInited := true;
    f_WindowOrg := Result;
   end//GetWindowOrgEx
   else
    Result := f_WindowOrg;
  end;//l_DC = 0
 end;//f_WindowOrgInited
end;

procedure Tl3Canvas.pm_SetWindowOrg(const Value: Tl3Point);
  {-}
var
 l_DC : hDC;
begin
 if not f_WindowOrg.EQ(Value) then
 begin
   l_DC := DC;
   f_WindowOrg := Value;
   f_WindowOrgInited := false;
   if (l_DC <> 0) then
    with LP2DP(Value) do
     SetWindowOrgEx(l_DC, X, Y, nil);
  RecordRegionBottomPrim(LP2DP(f_WindowOrg).Neg);
 end;//not f_WindowOrg.EQ(Value)
end;

function Tl3Canvas.pm_GetSWindowOrg: Tl3SPoint;
  {-}
var
 l_Pt : Tl3SPoint;
 l_DC : hDC;
begin
 l_DC := DC;
 if (l_DC = 0) then
  Result := LP2DP(f_WindowOrg)
 else
 begin
  GetWindowOrgEx(l_DC, TPoint(l_Pt));
  Result := l_Pt;
 end;//l_DC
end;

procedure Tl3Canvas.pm_SetSWindowOrg(const Value: Tl3SPoint);
  {-}
var
 l_DC : hDC;
 l_Pt : Tl3SPoint;
begin
 l_DC := DC;
 if (l_DC = 0) then
 begin
  f_WindowOrg := DP2LP(Value);
  f_WindowOrgInited := false;
 end//l_DC = 0
 else
 begin
  GetWindowOrgEx(l_DC, TPoint(l_Pt));
  if not l_Pt.EQ(Value) then
  begin
   SetWindowOrgEx(DC, Value.X, Value.Y, nil);
   f_WindowOrg := DP2LP(Value);
   f_WindowOrgInited := true;
  end;//not l_Pt.EQ(Value)
 end;//l_DC <> 0
 RecordRegionBottomPrim(Value.Neg);
end;

procedure Tl3Canvas.MoveWindowOrg(const aDelta: Tl3Point);
  {-}
var
 l_Pt : Tl3SPoint;
 l_DC : hDC;
begin
 if not aDelta.EQ(l3Point0) then
 begin
  l_DC := DC;
  if (l_DC = 0) then
  begin
   f_WindowOrg := f_WindowOrg.Add(aDelta);
   f_WindowOrgInited := true;
  end//l_DC = 0
  else
  begin
   GetWindowOrgEx(l_DC, TPoint(l_Pt));
   l_Pt.Inc(LP2DP(aDelta));
   SetWindowOrgEx(l_DC, l_Pt.X, l_Pt.Y, nil);
   f_WindowOrg := DP2LP(l_Pt);
   f_WindowOrgInited := true;
  end;//l_DC = 0
  RecordRegionBottomPrim(LP2DP(f_WindowOrg).Neg);
 end;//not aDelta.EQ(l3Point0)
end;

procedure Tl3Canvas.MoveWindowOrg(const aDelta: Tl3SPoint);
  {overload;}
  {-}
var
 l_Pt : Tl3SPoint;
 l_DC : hDC;
begin
 if not aDelta.EQ(l3SPoint0) then
 begin
  l_DC := DC;
  if (l_DC = 0) then
  begin
   f_WindowOrg := f_WindowOrg.Add(DP2LP(aDelta));
   f_WindowOrgInited := true;
   RecordRegionBottomPrim(LP2DP(f_WindowOrg).Neg);
  end//l_DC = 0
  else
  begin
   GetWindowOrgEx(l_DC, TPoint(l_Pt));
   l_Pt.Inc(aDelta);
   SetWindowOrgEx(l_DC, l_Pt.X, l_Pt.Y, nil);
   f_WindowOrg := DP2LP(l_Pt);
   f_WindowOrgInited := true;
   RecordRegionBottomPrim(l_Pt.Neg);
  end;//l_DC = 0
 end;//not aDelta.EQ(l3SPoint0)
end;

function Tl3Canvas.TextMetrics: PTextMetric;
  {-}
begin
 Result := @f_TextMetrics;
 if f_TextMetricsValid then Exit;
 GetTextMetrics(DC, f_TextMetrics);
 f_TextMetricsValid := true;
end;
  
procedure Tl3Canvas.FillEmptyRect(const R: Tl3Rect);
  {-}
var
 Rgn2Fill : Tl3Region;
 l_Filled : Tl3Region;
begin
 if DrawRgnOrBlock then
 begin
  Rgn2Fill := Tl3Region.Create;
  try
   Rgn2Fill.Rect := WO(l3IntersectRect(R, ClipRect));
   l_Filled := Tl3Region.Create;
   try
    l_Filled.Assign(f_Filled);
    OffsetRgn(l_Filled, WindowOrg);
    case Rgn2Fill.Combine(l_Filled, RGN_DIFF) of
     NULLREGION : ;
     SIMPLEREGION : FillRect(Rgn2Fill.Rect);
     else
      FillRgn(Rgn2Fill);
    end;//case Rgn2Fill.Combine(l_Filled, RGN_DIFF)
   finally
    FreeAndNil(l_Filled);
   end;//try..finally
  finally
   FreeAndNil(Rgn2Fill);
  end;//try..finally
 end;//DrawRgnOrBlock
end;

procedure Tl3Canvas.FillEmptyRect(const R: Tl3SRect);
  //overload;
  {-}
var
 Rgn2Fill : Tl3Region;
 l_Filled : Tl3Region;
 l_Clip   : Tl3SRect;
begin
 if DrawRgnOrBlock then
 begin
  if f_ClipRectInited then
   l_Clip := f_ClipRectS
  else
   l_Clip.GetClip(DC);
  Rgn2Fill := Tl3Region.Create;
  try
   Rgn2Fill.Rect := l3IntersectRect(R, l_Clip);
   l_Filled := Tl3Region.Create;
   try
    l_Filled.Assign(f_Filled);
    OffsetRgn(l_Filled, WindowOrg);
    Case Rgn2Fill.Combine(l_Filled, RGN_DIFF) of
     NULLREGION : ;
     SIMPLEREGION : FillRect(Rgn2Fill.Rect);
     else
      FillRgn(Rgn2Fill);
    end;//Case Rgn2Fill.Combine(l_Filled, RGN_DIFF)
   finally
    FreeAndNil(l_Filled);
   end;//try..finally
  finally
   FreeAndNil(Rgn2Fill);
  end;//try..finally
 end;//DrawRgnOrBlock
end;

function Tl3Canvas.GetTabWidth: Long;
  {-}
var
 l_Width : Long;
begin
 if (f_TabStops = nil) then
 begin
  l_Width := LP2DP(l3PointX(l3Inch div 2)).X;
  Result := ((f_TabOffset + l_Width) div l_Width) * l_Width - f_TabOffset;
 end//f_TabStops = nil
 else
 begin
  repeat
   l_Width := LP2DP(l3PointX(f_TabStops.Next.rPosition)).X;
   Result := l_Width - f_TabOffset;
  until (Result > 0);
 end;//f_TabStops = nil
end;

function Tl3Canvas.GetKerning(const aSt : Tl3PCharLenPrim;
                              aKerning  : PLong): Tl3Point;
  {-}
var
 l_DC : hDC;
 theExtent : Tl3Point absolute Result;

 procedure __GetKerning(const aSt: Tl3PCharLenPrim);

  function TabbedKerning: Bool;
  var
   l_TabLen: Integer;
   l_TabPos: Integer;
   I: Integer;
   l_S     : Tl3PCharLenPrim;
   l_NS    : Tl3PCharLen;
   l_Last  : Bool;
   l_Width : Long;
   l_TabStops: Il3TabStops;
   l_CurTab, l_TabField: Integer;
   l_TabKerning : PLong;
  begin//TabbedKerning
   Result := true;
   l_S := aSt;
   l_TabPos := 0;
   l_TabStops := nil;
   if (f_TabStops <> nil) and (f_TabStops.NeedCutByTab) then
    l_TabStops := f_TabStops.Clone;
   repeat
    l_NS := l3FindChar(cc_Tab, l_S);
    l_Last := Tl3PCharLen(l_S).IsLast(cc_Tab);
    if l_Last then
     Dec(l_S.SLen);

    // "Рисуем" текст:
    if (l_S.SCodePage = CP_Unicode) then
     _GetKerningW(l_DC, PWideChar(l_S.S), l_S.SLen, aKerning, @l_Width)
    else
     _GetKerning(l_DC, l_S.S, l_S.SLen, aKerning, @l_Width);
    if l_TabStops <> nil then
    begin
     l_TabLen := LP2DP(l3PointX(l_TabStops.Next.rPosition)).X;
     l_CurTab := l_TabLen - l_TabPos;
     l_TabPos := l_TabLen;
     if l_CurTab < l_Width then
     begin
      l_TabKerning := aKerning;
      l_TabField := l_CurTab;
      for I := 1 to l_S.SLen do
      begin
       if l_TabField > l_TabKerning^ then
        Dec(l_TabField, l_TabKerning^)
       else
       begin
        l_TabKerning^ := l_TabField;
        l_TabField := 0;
       end;
       Inc(l_TabKerning);
      end;
      l_Width := l_CurTab;
     end;
     
    end;
    Inc(theExtent.P.X, l_Width);
    Inc(f_TabOffset, l_Width);
    Inc(aKerning, l_S.SLen);

    if (l_TabStops = nil) and l_Last then
    begin
     // Рисуем знак табуляции:
     l_Width := GetTabWidth;
     aKerning^ := l_Width;
     Inc(theExtent.P.X, l_Width);
     Inc(f_TabOffset, l_Width);
     Inc(aKerning);
    end;//l_Last

    l_S := l_NS;
   until l3IsNil(l_NS);
  end;//TabbedKerning

 begin//__GetKerning
  if l3IsNil(aSt) then
   Exit;
  if (f_Tabs > 0) AND l3HasChar(cc_Tab, aSt) AND
     TabbedKerning then
   Exit;
  if (aSt.SCodePage = CP_ANSI) then
   _GetKerning(l_DC, aSt.S, aSt.SLen, aKerning, @theExtent.X)
  else
   _GetKerningW(l_DC, PWideChar(aSt.S), aSt.SLen, aKerning, @theExtent.X);
  if Get_Italic AND (aSt.SLen > 0) then
  // - пытаемся учитывать наклон шрифта - чтобы буквы не обрезались
  begin
   if not l3IsWhiteSpaceS(aSt, Pred(aSt.SLen)) then
   begin
    if ((Win32Platform <> VER_PLATFORM_WIN32_NT) OR (Win32MajorVersion < 6)) then
     // - для тех кто меньше Vista правим массив кернинга
     Inc(PLong(PAnsiChar(aKerning) + Pred(aSt.SLen) * SizeOf(Long))^);
    Inc(theExtent.P.X);
   end;//not l3IsWhiteSpaceS
  end;//Get_Italic
 end;//__GetKerning

var
 ACW   : Long;
 l_Str : Tl3Str;
 l_St  : Tl3PCharLenPrim;
 l_Convert  : Tl3Str;
 l_Fixed    : Boolean;
begin
 l_St := aSt;
 if (f_PasswordChar <> #0) then
 begin
  l_Convert.Init(Tl3WString(l_St), CP_ANSI);
  l3FillChar(l_Convert.S^, l_Convert.SLen, Ord(f_PasswordChar));
  l_St := l_Convert;
 end//f_PasswordChar <> #0
 else
  l_Convert.Init;
 try
  if (f_Font <> nil) then
  begin
   Tl3_Point(theExtent) := f_Font.FM.TextExtent(l_St);
   ACW := LP2DP(l3PointX(theExtent.X)).X;
   l3FillStruct(aKerning^, l_St.SLen, ACW, SizeOf(ACW));
   Exit;
  end;//f_Font <> nil
  l_DC := DC;
  with TextMetrics^ do
  begin
   f_pxAverageCharWidth := tmAveCharWidth;
   theExtent.X := 0;
   theExtent.Y := tmHeight;
   l_Fixed := not
              // http://mdp.garant.ru/pages/viewpage.action?pageId=296632270&focusedCommentId=296633958#comment-296633958
              Bool(tmPitchAndFamily AND TMPF_FIXED_PITCH) OR
              (VCLFont.Pitch = fpFixed)
              // - оказывается, что "бывает" Arial и Fixed - для Preformatted-параграфов
              // http://mdp.garant.ru/pages/viewpage.action?pageId=296632270
              ;
   if not l_Fixed then
    theExtent.Y := ApplyLineSpacing(theExtent.Y, f_LineSpacing);
   if (f_Tabs > 0) OR not l_Fixed then
   begin
    if (f_SuffixedFont AND (l_St.SCodePage = CP_ANSI)) OR
       // - закомментировано, т.к. неправильно работало с 'Arial', а не 'Arial CYR'
       (l_St.SCodePage = CP_Unicode) then
     __GetKerning(l_St)
    else
    begin
     l_Str.Init(l_St, CP_Unicode, @f_ConvertBuf);
     __GetKerning(l_Str);
    end;//f_SuffixedFont..
   end//f_Tabs > 0
   else
   begin
    ACW := tmAveCharWidth;
    l3FillStruct(aKerning^, l_St.SLen, ACW, SizeOf(ACW));
    theExtent.X := ACW * l_St.SLen;
   end;//f_Tabs > 0
  end;//with TextMetrics^
  theExtent := DP2LP(Tl3SPoint(theExtent));
 finally
  l_Convert.Clear;
 end;//try..finally
end;

function Tl3Canvas.KerningTextExtent(const S : Tl3PCharLenPrim): Tl3Point;
  {-}
var
 l_ICN     : Il3InfoCanvas;
 l_TabInfo : Il3TabInfo;
 l_PC      : AnsiChar;
begin
 if not Printing then
 begin
  l_ICN := l3CrtIC;
  if l_ICN.EQ(Self) then
   Result := GetKerning(S, CheckKerning(S.SLen))
  else
  begin
   l_ICN.Lock;
   try
    l_ICN.PushLineSpacing;
    l_PC := l_ICN.PasswordChar;
    try
     l_ICN.LineSpacing := f_LineSpacing;
     l_ICN.PasswordChar := f_PasswordChar;
     l_ICN.Font := Self;
     if (f_Tabs > 0) then
     begin
      l_ICN.StartTabs(l_TabInfo, TabInfo);
      try
       Result := l_ICN.GetKerning(S, CheckKerning(S.SLen));
       RestoreTabInfo(l_ICN.TabInfo);
      finally
       l_ICN.FinishTabs(l_TabInfo);
      end;//try..finally
     end//f_Tabs > 0
     else
      Result := l_ICN.GetKerning(S, CheckKerning(S.SLen));
     finally
      l_ICN.PopLineSpacing;
      l_ICN.PasswordChar := l_PC;
     end;//try..finally
   finally
    l_ICN.Unlock;
   end;//try..finally
  end;//l3IEQ(l_ICN, Self)
 end//not Printing
 else
  Result := TextExtent(S);
end;

procedure Tl3Canvas.KerningTextOut(const P: Tl3Point;
                                   const R: Tl3Rect;
                                   const S: Tl3PCharLenPrim);
  {-}
begin
 if DrawEnabled AND not Printing AND (f_Kerning <> nil) then
  ExtTextOut(P, R, S, l3_tffLeft, PInteger(f_Kerning.AsPointer))
 else
  ExtTextOut(P, R, S, l3_tffLeft, nil);
end;

procedure Tl3Canvas.KerningTextOut(const P: Tl3SPoint;
                                   const R: Tl3SRect;
                                   const S: Tl3PCharLenPrim);
  //overload;
  {-}
begin
 if DrawEnabled AND not Printing AND (f_Kerning <> nil) then
  ExtTextOut(P, R, S, l3_tffLeft, PInteger(f_Kerning.AsPointer))
 else
  ExtTextOut(P, R, S, l3_tffLeft, nil);
end;

function Tl3Canvas.TextOut(const P : Tl3Point;
                           const S : Tl3PCharLen;
                           FC      : TColor = clDefault;
                           BC      : TColor = clDefault): Tl3Point;
  {-}
begin
 PushFC;
 try
  PushBC;
  try
   if (FC <> clDefault) then
    TextColor := FC;
   if (BC <> clDefault) then
    BackColor := BC;
   Result := KerningTextExtent(S);
   KerningTextOut(P, l3RectBnd(P, Result), S);
  finally
   PopBC;
  end;//try..finally
 finally
  PopFC;
 end;//try..finally
end;

procedure Tl3Canvas.SetDC(DC: HDC; Flag: TevDCFlag);
  {-}
begin
 FreeDC;
 f_DC := DC;
 f_DCFlag := Flag;
 if (Canvas <> nil) then
  Canvas.Handle := f_DC;
end;

function Tl3Canvas.CheckKerning(Size: Long): Pointer;
  {-}
begin
 if (f_Kerning = nil) then
  f_Kerning := Tl3MemoryPool.Create{(Self)};
 Size := Size * SizeOf(Integer);
 if (f_Kerning.Size < Size) then
  f_Kerning.Size := Size;
 Result := f_Kerning.AsPointer;
end;

procedure Tl3Canvas.CheckOrientation;
  {-}

 procedure CorrectDelta(var A, B: Long);
 var
  l_Div : Long;
  l_Mod : Long;
 begin//CorrectDelta
  if (A >= B) then
  begin
   l_Div := A div B;
   l_Mod := A mod B;
   if (l_Mod < l3Epsilon * l_Div) then
    A := l_Div * B
   else
   if (B - l_Mod < l3Epsilon) then
    A := Succ(l_Div) * B;
  end//A >= B
  else
   CorrectDelta(B, A);
 end;//CorrectDelta

var
 l_PaperWidth  : Long;
 l_PaperHeight : Long;
 l_Extent      : Tl3Point;
begin
 if (f_PageWidthNumber <= 0) then
 begin
  // - Здесь подгоняем ориентацию
  with PageSetup do
  begin
   l_PaperWidth := PaperWidth;
   l_PaperHeight := PaperHeight;
  end;//with PageSetup
  l_Extent := f_SectionExtent;
  with l_Extent do
  begin
   CorrectDelta(l_PaperWidth, P.X);
   CorrectDelta(l_PaperWidth, P.Y);
   CorrectDelta(l_PaperHeight, P.X);
   CorrectDelta(l_PaperHeight, P.Y);
   if (X mod l_PaperWidth > X mod l_PaperHeight) {OR
      (Y mod l_PaperHeight > Y mod l_PaperWidth)} then
     PageOrientation := l3PageOrientationInvert[f_PageOrientation];
  end;//with l_Extent
 end;//f_PageWidthNumber <= 0
end;

function Tl3Canvas.NewPage(ByWidth: Bool = false): Boolean;
  {override;}
  {-}
var
 l_PrinterOrientation : Tl3PageOrientation;
begin
 Result := true;
 if (f_Printer <> nil) then
 begin
  Inc(f_OverallPageNumber);
  if ByWidth then
   Inc(f_PageWidthNumber)
  else
  begin
   f_PageWidthNumber := 0;
   Inc(f_PageNumber);
  end;//ByWidth
  l_PrinterOrientation := f_Printer.Orientation;
  CheckOrientation;
  {$IfNDef l3UsePrinterForPreview}
  if IsPreview then
  begin
   if (f_PageWidthNumber > 0) OR (l_PrinterOrientation = f_PageOrientation) then
   begin
   end
   else
   begin
    f_Printer.Orientation := f_PageOrientation;
   end;//f_PageWidthNumber > 0
  end//IsPreview
  else
  {$EndIf  l3UsePrinterForPreview}
  begin
   if not f_Printer.Printing then
    f_Printer.Orientation := f_PageOrientation;
   Case NeedOpenRealPage(false, ByWidth) of
    l3_oprNo: ; 
    l3_oprYes:
    begin
     if (f_PageWidthNumber > 0) OR (l_PrinterOrientation = f_PageOrientation) then
      StartPrinterPage(false)
     else
     begin
      f_Printer.Orientation := f_PageOrientation;
      if not f_Printer.Printing then
       StartPrinterPage(true);
     end;//f_PageWidthNumber > 0
    end;//l3_oprYes
    l3_oprEndDoc:
     Result := false;
   end;//Case NeedOpenRealPage(false)  
  end;//not IsPreview
  AssignDeviceCaps;
  StartPage;
 end//f_Printer <> nil
 else
  AssignDeviceCaps;
end;

function Tl3Canvas.GetCaret: Il3Caret;
  //virtual;
  {-}
begin
 Result := nil;
end;

procedure Tl3Canvas.SetCaret(const Origin, Extent: Tl3Point; aHidden: Bool = false);
  {override;}
  {-}
var
 Pt      : array [0..1] of Tl3SPoint;
 l_Caret : Il3Caret;
begin
 l_Caret := GetCaret;
 if (l_Caret <> nil) then
  try
   l_Caret.Hidden := true;
   if aHidden AND l_Caret.CanHide then
    l_Caret.Position := Point1(MaxInt)
   else
   if l_Caret.Visible then
   begin
    {необходимо учесть Zoom}
    Pt[0] := LP2DP(Extent);
    Pt[1] := WO(Origin);
    Pt[0] := Pt[0].Zoom(Zoom);
    LPtoDP(DC, Pt[1], 1);
    l_Caret.Extent := TPoint(Pt[0]);
    l_Caret.Position := Pt[1];
   end;//l_Caret.Visible
  finally
   l_Caret := nil;
  end;//try..finally
end;

procedure Tl3Canvas.IncCaret(aDeltaX: Long);
  {-}
var
 l_Caret : Il3Caret;
begin
 l_Caret := GetCaret;
 if (l_Caret <> nil) then
  try
   l_Caret.Hidden := true;
   if l_Caret.Visible then
   begin
    {необходимо учесть Zoom?}
    l_Caret.Position := Tl3SPoint(l_Caret.Position).Add(PointX(aDeltaX));
   end;//l_Caret.Visible
  finally
   l_Caret := nil;
  end;//try..finally
end;

function Tl3Canvas.HasToDraw: Bool;
  {override;}
  {-}
begin
 Result := ([ev_dfDrawCursor, ev_dfDrawRegion] * Flags <> []);
end;

function Tl3Canvas.NearestColor(C: TColor): TColor;
  {-}
var
 l_ICN : Il3InfoCanvas;
begin
 l_ICN := l3CrtIC;
 l_ICN.Lock;
 try
  Result := Windows.GetNearestColor(l_ICN.DC, ColorToRGB(C));
 finally
  l_ICN.Unlock;
 end;//try..finally
end;

procedure Tl3Canvas.Lock;
  {override;}
  {-}
begin
(* if (Canvas <> nil) then
  Canvas.Lock;*)
end;

procedure Tl3Canvas.Unlock;
  {override;}
  {-}
begin
(* if (Canvas <> nil) then
  Canvas.Unlock;*)
end;

procedure Tl3Canvas.ExtTextOut(const P   : Tl3SPoint;
                               const R   : Tl3SRect;
                               const S   : Tl3PCharLenPrim;
                               aFl : Tl3TextFormatFlag;
                               aKerning  : PInteger);
  {overload;}
  {-}
begin
 ExtTextOut(DP2LP(P), DR2LR(R), S, aFl, aKerning);
end;

function Tl3Canvas.CaretLineOut(const aSt    : Tl3PCharLenPrim;
                                LineHeight   : Long;
                                aHidden      : Boolean;
                                var CaretPos : Long): Tl3Point;
  {-выводит строку текста высотой LineHeight, со сдвигом курсора отрисовки.
    устанавливает курсор в CaretPos.
    возвращает размеры выведенной строки}
var
 l_YOfs        : Long;
 l_OTabInfo    : Il3TabInfo;
 l_TabInfo     : Il3TabInfo;
 l_CaretOffset : Long;
 l_D           : Integer;
begin
 if (CaretPos >= 0) then
  l_OTabInfo := TabInfo;
 l_D := 0; 
 if l3IsNil(aSt) then
  Result.Init(0, LineHeight)
 else
 begin
  with ClipRect do
   if (Top >= LineHeight) OR (Bottom < 0) then
   begin
    if (CaretPos >= 0) then
     Result := KerningTextExtent(aSt)
    else
     Result.Init(0, LineHeight);
   end//(Top >= LineHeight) OR (Bottom < 0)
   else
   begin
    Result := KerningTextExtent(aSt);
    if (l3_fiObject in f_FontIndexSet) then
     l_D := (LineHeight - Result.Y) div 2
    else
    if (l3_fiBaseLined in f_FontIndexSet) then
     l_D := 0;
    KerningTextOut(l3Point(0, (LineHeight - Result.Y) - l_D),
                   l3Rect(0, 0, Result.X, LineHeight), aSt);
   end;//ClipRect.Bottom < LineHeight
 end;//l3IsNil(aSt)
 MoveWindowOrg(Result.e_X);
 //-сдвигаем курсор отрисовки на ширину текста
 l_YOfs := (LineHeight - Result.Y) - l_D;
 if (CaretPos >= 0) then
 begin
  if (CaretPos <= aSt.SLen) then
  begin
   if (l_YOfs < 0) then
    l_YOfs := 0;
   if (CaretPos = aSt.SLen) then
    SetCaret(l3Point(0, l_YOfs),
             l3Point(AverageCharWidth, Result.Y), aHidden)
   else
   begin
    if (f_Tabs > 0) then
    begin
     Assert(l_OTabInfo <> nil);
     StartTabs(l_TabInfo, l_OTabInfo);
     // - восстанавливаем смещение, которое было до рисования строки текста
     try
      l_CaretOffset := KerningTextExtent(l3PCharLen(aSt.S, CaretPos, aSt.SCodePage)).X;
     finally
      FinishTabs(l_TabInfo);
     end;//try..finally
    end
    else
     l_CaretOffset := KerningTextExtent(l3PCharLen(aSt.S, CaretPos, aSt.SCodePage)).X;
    SetCaret(l3Point(l_CaretOffset - Result.X, l_YOfs),
             l3Point(AverageCharWidth, Result.Y), aHidden);
   end;//CaretPos = aSt.SLen
   CaretPos := -1;
   ShowCursor := false;
  end//CaretPos <= aSt.SLen
  else
   Dec(CaretPos, aSt.SLen);
 end;//CaretPos >= 0
end;

procedure Tl3Canvas.DoDrawLineTo(aX, aY: Integer);
var
 l_PenColor: TColor;
begin
 with Canvas do
 begin
  if Invert AND not Printing then
  begin
   l_PenColor := Pen.Color;
   try
    Pen.Color := InvertColor(l_PenColor);
    LineTo(aX, aY);
   finally
    Pen.Color := l_PenColor;
   end;//try..finally
  end//Invert..
  else
   LineTo(aX, aY);
 end;
end;

function Tl3Canvas.StringOut(const P: Tl3Point; const Text: Tl3WString): Tl3Point;
  {-}
begin
 Result := TextOut(P, Tl3PCharLen(Text));
end;

procedure Tl3Canvas.TabbedTextOut(const P         : Tl3Point;
                                  const R         : Tl3Rect;
                                  const S         : Tl3PCharLenPrim;
                                  const aTabStops : Il3TabStops);
var
 lTempTabInfo : Il3TabInfo;
 St           : string;
 CL           : Tl3PCharLen;
begin
 StartTabs(lTempTabInfo, aTabStops);
 St := l3PCharLen2String(S);
 CL := l3PCharLen(St+cc_Tab, S.SCodePage);
 try
  KerningTextExtent(CL);
  KerningTextOut(P, R, CL);
 finally
  FinishTabs(lTempTabInfo);
 end;
end;

procedure Tl3Canvas.TabbedTextOut(const P         : Tl3SPoint;
                                  const R         : Tl3SRect;
                                  const S         : Tl3PCharLenPrim;
                                  const aTabStops : Il3TabStops);
  //overload;
  {-}
var
 lTempTabInfo : Il3TabInfo;
 St           : string;
 CL           : Tl3PCharLen;
begin
 StartTabs(lTempTabInfo, aTabStops);
 St := l3PCharLen2String(S);
 CL := l3PCharLen(St+cc_Tab, S.SCodePage);
 try
  KerningTextExtent(CL);
  KerningTextOut(P, R, CL);
 finally
  FinishTabs(lTempTabInfo);
 end;
end;

procedure Tl3Canvas.TabbedMultilineTextOut(const aSt    : Tl3PCharLenPrim;
                                           const Tabs   : Il3TabStops;
                                           var Rect     : Tl3Rect;
                                           Precalculate : Boolean;
                                           aGap         : Integer);
var
 l_Right    : Integer;
 l_HalfGap  : Integer;
 l_IsFirst  : Boolean;
 MaxH       : Integer;
 lTabs      : Il3TabStops;
 CR         : Tl3SRect;
 RT         : TRect;
 lFlags     : Cardinal;
 l_NS       : Tl3PCharLen;
 l_S        : Tl3PCharLen;
 l_Last     : Boolean;
 l_FirstPos : Integer;
begin
 CR := WO(Rect);
 RT := CR.R.WR;

 // Это заплатка. Дело в том, что в Rect сюда передается MaxInt, который после
 // преобразований становится совсем не MaxInt, в результате чего он не обнуляется
 // в Tl3Canvas.DP2LP и все с грохотом валится в l3MulDiv с переполнением целого.
 // Наверное, надо это сделать как-нибудь поизящней, но не придумалось как.
 if Rect.BottomRight.Y = MaxInt then
  RT.BottomRight.Y := MaxInt;

 lTabs := Tabs.Clone;
 RT.Right := RT.Left;
 lFlags := DT_LEFT or DT_WORDBREAK or DT_NOPREFIX;
 if Precalculate then
  lFlags := lFlags or DT_CALCRECT;
 MaxH := 0;
 Tl3PCharLenPrim(l_S) := aSt;
 l_IsFirst := True;
 l_FirstPos := RT.Left;
 l_HalfGap := aGap div 2;
 repeat
  l_NS := l3FindChar(cc_Tab, l_S);
  l_Last := l_S.IsLast(cc_Tab);
  if l_Last then
   Dec(l_S.SLen);
  RT.Left := RT.Right;
  if not l_IsFirst then
  begin
   RT.Left := RT.Left + aGap;
   RT.Right := l_FirstPos + LP2DP(l3PointX(lTabs.Next.rPosition)).X - l_HalfGap;
  end
  else
  begin
   l_IsFirst := False;
   RT.Right := RT.Right + LP2DP(l3PointX(lTabs.Next.rPosition)).X - l_HalfGap;
  end;//not l_IsFirst
  if Precalculate then
  begin
   RT.Bottom := MaxInt;
   l_Right := RT.Right;
   DrawText(l_S, RT, lFlags);
   RT.Right := l_Right; // правую сторону при подсчете мы не считаем
  end//Precalculate
  else
   DrawText(l_S, RT, lFlags);
  if MaxH < RT.Bottom-RT.Top then
   MaxH := RT.Bottom-RT.Top;
  l_S := l_NS;
 until l3IsNil(l_NS);
 CR.R.Bottom := CR.R.Top + MaxH;
 Rect := DR2LR(CR);
end;

function Tl3Canvas.pm_GetFrameLines: Il3FrameLines;
begin
 if f_FrameLines = nil then
  f_FrameLines := Tl3FrameLines.Make;
 Result := f_FrameLines;
end;

function Tl3Canvas.AdjustMarginsByPrintableArea(
  const aMargins: Tl3_Rect): Tl3_Rect;
var
 l_PrintableArea: Tl3_Rect;
begin
 if Printing then
 begin
  l_PrintableArea := CalcPrintableArea;
  Result.Left := Max(aMargins.Left, l_PrintableArea.Left);
  Result.Top := Max(aMargins.Top, l_PrintableArea.Top);
  Result.Right := Max(aMargins.Right, l_PrintableArea.Right);
  Result.Bottom := Max(aMargins.Bottom, l_PrintableArea.Bottom);
 end
 else
  Result := aMargins;
end;

function Tl3Canvas.Get_AbortChecker: Il3AbortChecker;
begin
 Result := f_AbortChecker;
end;

procedure Tl3Canvas.Set_AbortChecker(const aValue: Il3AbortChecker);
begin
 f_AbortChecker := aValue;
end;

function Tl3Canvas.CheckConvertString(
  const aStr: Tl3PCharLen): Tl3PCharLen;
var
 l_Index : Integer;   
begin
 {$IfDef l3Requires_m0}
 Result := CheckOutString(aStr);
 case Result.SCodePage of
  CP_Unicode:
  begin
   for l_Index := 0 to Pred(Result.SLen) do
    case PWideChar(Result.S)[l_Index] of
     cc_HardSpace:
      PWideChar(Result.S)[l_Index] := cc_HardSpaceSymbol;
     cc_SoftSpace:
      PWideChar(Result.S)[l_Index] := cc_SoftSpaceSymbol;
    end;//case PWideChar(aStr.S)[l_Index]
  end;//CP_Unicode
  CP_OEM,
  CP_OEMLite,
  CP_TatarOEM,
  CP_RussianDOS:
   m2xltConvertBuffEx(Result.S, aStr.SLen, Pm2XLTTable08(CheckConvertTable(true))^);
  else
   m2xltConvertBuffEx(Result.S, aStr.SLen, Pm2XLTTable08(CheckConvertTable(false))^);
  // - другие кодировки никуда пока не переводим
 end;//Case Result.SCodePage
 {$Else  l3Requires_m0}
 Result := aStr;
 {$EndIf  l3Requires_m0}
end;

function Tl3Canvas.CheckConvertTable(OEM: Bool): PAnsiChar;
var
 i : AnsiChar;
 c : AnsiChar;
begin
 if (f_ConvertTable[OEM] = nil) then
 begin
  f_ConvertTable[OEM] := Tl3MemoryPool.Create{(Self)};
  with f_ConvertTable[OEM] do
  begin
   Size := 256;
   if OEM then
   begin
    for i := #0 to #255 do
    begin
     c := i;
     case i of
      cc_HardSpace:
       c := cc_OEMHardSpaceSymbol;
      cc_OEMSoftSpace:
       c := cc_OEMSoftSpaceSymbol;
      else
       c := i;
     end;//case i
     Write(Ord(i), @c, 1);
    end;//for i
   end
   else
   begin
    for i := #0 to #255 do
    begin
     case i of
      cc_OEMParagraphSign :
       c := cc_ParagraphSign;
      #8 : c := #135;
      //cc_Tab: c := cc_TabSymbol;
      cc_SoftSpace:
       c := cc_SoftSpaceSymbol;
      cc_HardSpace:
       c := cc_HardSpaceSymbol;
      else
       c := i;
     end;//case i
     Write(Ord(i), @c, 1);
    end;//for i
   end;//OEM
  end;//with f_ConvertTable[OEM]..
 end;//f_ConvertTable = nil
 Result := f_ConvertTable[OEM].AsPointer;
end;

function Tl3Canvas.CheckOutString(const aStr: Tl3PCharLen): Tl3PCharLen;
begin
 if (f_OutString = nil) then
  f_OutString := Tl3String.Make(aStr)
 else
  f_OutString.AsPCharLen := aStr;
 Result := f_OutString.AsPCharLen;
end;

function Tl3Canvas.GetGlobalClipRectWithZoom: Tl3Rect;
begin
 Result := GlobalClipRect;
 Result.MakeZoom(f_Zoom);
end;

procedure Tl3Canvas.EndDrawAAC(const R: Tl3Rect);
begin
 DoEndDrawAAC(R);
end;

procedure Tl3Canvas.StartDrawAAC(aType: TspBlockType);
begin
 DoStartDrawAAC(aType);
end;

procedure Tl3Canvas.DoStartDrawAAC(aType: TspBlockType);
begin

end;

procedure Tl3Canvas.DoEndDrawAAC(const R: Tl3Rect);
begin

end;

procedure Tl3Canvas.BeginDarkColor;
begin
 Inc(f_DarkFore);
end;

procedure Tl3Canvas.EndDarkColor;
begin
 Dec(f_DarkFore);
end;

end.

