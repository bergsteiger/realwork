..\..\ComboAccess\caDefine.inc
{$Include htDefine.inc}
..\..\cs\CsDefine.inc
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.12  2015/02/24 11:59:38  lukyanets
// Передаем по новому
//
// Revision 1.11  2015/02/19 09:39:35  lukyanets
// Заготовки для проверки альтернативного подхода
//
// Revision 1.10  2015/01/23 06:12:43  lukyanets
// Накоммител лишнего
//
// Revision 1.9  2015/01/22 14:31:37  lukyanets
// Переносим отсылку задачи в более правильное место
//
// Revision 1.8  2015/01/22 11:34:01  lukyanets
// Переносим директивы
//
// Revision 1.7  2014/12/16 07:57:52  lukyanets
// Логирование
//
// Revision 1.6  2014/09/22 12:54:10  lukyanets
// Вычитывали таск не того класса.
//
// Revision 1.5  2014/08/01 11:31:02  lukyanets
// {Requestlink:558466572}. Переопределяем Define
//
// Revision 1.4  2010/05/20 06:30:29  voba
// - не собиралось со старым редактором
//
// Revision 1.3  2006/03/10 09:29:12  voba
// - enh. убрал CsFree etc.
//
// Revision 1.2  2006/02/08 17:24:29  step
// выполнение запросов перенесено из классов-потомков в процедуры объектов
//

{$Define CsDebug}
{$Define csNewQueueTaskLine}
{.$Define ncsSniffMessage}

{$Include evDefine.inc}

{$A-,B-,F+,K-,U-,V-,W-,X+}

{$WriteableConst On}

{$Define csSendTaskAsEVD}
{$Define csSynchroTransport}

{$If defined(AppServerSide) or defined(ServerAssistantSide)}
  {$DEFINE ServerTasks}
{$IfEnd defined(AppServerSide) or defined(ServerAssistantSide)}

..\..\cs\Example\Client.dpr
program Client;

uses
  Forms,
  MainClient in 'MainClient.pas' {MainClientForm};

{$R *.res}

begin
  Application.Initialize;
  Application.CreateForm(TMainClientForm, MainClientForm);
  Application.Run;
end.
..\..\cs\Example\Server.dpr
program Server;

uses
  Forms,
  MainServer in 'MainServer.pas' {MainServerForm};

{$R *.res}

begin
  Application.Initialize;
  Application.CreateForm(TMainServerForm, MainServerForm);
  Application.Run;
end.
..\..\DA\daDefine.inc
{$Include evDefine.inc}
..\..\dd\ddDefine.inc
//..........................................................................................................................................................................................................................................................
{ Библиотека "DD"      }
{ Автор:  ©            }
{ Модуль: ddDefine.inc - файл переменных условной компиляции библиотеки }
{ Начат: 19.04.2003    }
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.10  2015/04/13 10:25:18  lulin
// - пытаемся собрать библиотеку.
//
// Revision 1.9  2013/05/31 07:20:43  lulin
// - портируем под XE4.
//
// Revision 1.8  2013/05/14 09:46:33  lulin
// - разборки с упавшими тестами.
//
// Revision 1.7  2010/03/10 13:57:24  narry
// - не собиралось
//
// Revision 1.6  2007/11/29 05:26:59  narry
// - отказ от расчета времени процесса от Сереги
//
// Revision 1.5  2005/02/16 17:10:41  narry
// - update: Delphi 2005
//
// Revision 1.4  2004/07/26 11:41:10  law
// - убрана директива J+.
//
// Revision 1.3  2004/04/09 12:17:35  narry
// - new: преобразование форматов картинок, не поддерживаемых MS Word в png
//
// Revision 1.2  2003/07/10 08:15:55  narry
// - update: объединение с основной веткой
//
// Revision 1.1  2003/04/19 12:30:36  law
// - new file: ddDefine.inc.
//

{$I evDefine.inc}

{$IfDef DesignTimeLibrary}
 {$Define NoZIP}
{$EndIf DesignTimeLibrary}

{.$J+}
{$DEFINE IEINCLUDEPNG}
{.$DEFINE usel3TimeEstimation}
{.$DEFINE Win7}

{$IfDef Nemesis}
 {$Define ddUseVTSpin}
{$EndIf Nemesis}

{$IfDef RxLibrary}
 {$Define ddUseVTSpin}
{$EndIf RxLibrary}
..\..\dd\DtDefine.inc
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.5  2010/03/10 13:57:24  narry
// - не собиралось
//
// Revision 1.4  2008/10/24 15:03:12  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.3  2008/10/13 12:39:27  narry
// - промежуточное обновление
//
// Revision 1.2  2008/08/26 06:31:52  narry
// - обновление
//
// Revision 1.1  2008/02/26 12:30:57  lulin
// - боремся за чистоту арийской рассы.
//
// Revision 1.6  2006/10/04 08:40:31  voba
// - merge with b_archi_ht64
//
// Revision 1.5.14.1  2006/09/19 08:37:54  voba
// - переход на HTStub
//
// Revision 1.5  2006/03/20 12:56:10  voba
// no message
//
// Revision 1.4  2005/11/21 13:07:39  step
// убрана неиспользуемая "NOFORMS"
//
// Revision 1.3  2005/11/21 10:11:30  step
// новая директива TestDb
//
// Revision 1.2  2005/03/18 13:05:44  fireton
// - change: переходим на более новую версию WSocket
//
// Revision 1.1  2004/08/03 08:52:51  step
// замена dt_def.pas на DtDefine.inc
//
// Revision 1.5  2002/11/21 17:14:54  law
// - bug fix: неправильно обрабатывалась директива MonoUser.
//
// Revision 1.4  2002/05/15 13:48:23  law
// - new unit: DT_AsyncBroadcast.
//
// Revision 1.3  2000/12/15 15:36:18  law
// - вставлены директивы Log.
//

{$Include HTDefine.inc}
{$Include l3Define.inc }

{$A-,B-,F+,K-,U-,V-,W-,X+}

{$WriteableConst On}

{.$DEFINE TestDb} // разрешает запуск программы только на отладочных БД (т.е. БД с файлом <db_path>\testing)
{$IFDEF UseProjectDefine}
 {$I ProjectDefine.inc}
{$ENDIF}

..\..\dd\HTDefine.inc
{$A-}
{$I l3Define.inc}
{$DEFINE HT_MODE64}
..\..\dd\HT_ERR.inc
//* Эти константы, заносятся в поле nRetCode БДС и возвращаются   */
//* функциями СУБД в качестве кодов завершения, но со знаком '-'  */
//* Эти же коды будет получать пользовательская функция обработки */
//* ошибок (INIT.pfErrMess) в качестве единственного параметра.   */

const
 HT_ERR_SUCCESS			=  0; //* HyTech: нет ошибки */
 HT_ERR_IO			= -1; //* HyTech: ошибка В/В */
 HT_ERR_NO_MEM           	= -2; //* Нет памяти для работы */
 HT_ERR_NOT_OPEN		= -3; //* Доступ к результату не открыт */
 HT_ERR_NOT_PROC		= -4; //* БДС не содержит результатов */
 HT_ERR_INVALID_OPERAND		= -5; //* Неверный операнд (или не задан) */
 HT_ERR_INVALID_OP_TYPE		= -6; //* Неверный тип операнда */
 HT_ERR_INVALID_TAB_HANDLE	= -7; //* Неверный дескриптор таблицы */
 HT_ERR_RESULT_REOPEN		= -8; //* Доступ к результатам уже открыт */
///* htReadResults() может возвратить только коды on -1 до -8 */
 HT_ERR_ACCESS_DENYED		= -9; //* Доступ запрещен (неверный пароль) */
 HT_ERR_ASSO_DAMAGED		= -10; //* Ассоциатор поврежден */
 HT_ERR_BAD_ENVIRON	        = -11; //* Плохая среда (ошибка ДОС) */
 HT_ERR_DATA_CORRUPTED		= -12; //* Файл данных поврежден (короче или длиннее чем надо) */
 HT_ERR_DOMAIN			= -13; //* Недопустимое значение ключа */
 HT_ERR_INCOMPATIBLE_KEY	= -14; //* Несовместимые ключи */
 HT_ERR_INDEX_NOT_SORTED	= -15; //* Нарушен порядок сортировки файла индексов */
 HT_ERR_INVALID_DRIVE		= -16; //* Неверное имя диска */
 HT_ERR_INVALID_ELEM		= -17; //* Неверное описания элемента таблицы */
 HT_ERR_INVALID_FIELD_TYPE	= -18; //* Неверный тип поля */
 HT_ERR_INVALID_GROUP_FUNC	= -19; //* Неверный тип функции для операции GROUP BY */
 HT_ERR_INVALID_KEY_NUMBER	= -20; //* Неверный номер ключа */
 HT_ERR_INVALID_NET_PATH	= -21; //* Неверный каталог сетевых файлов */
 HT_ERR_INVALID_PATH		= -22; //* Неверный путь на файл */
 HT_ERR_INVALID_TMP_PATH	= -23; //* Неверный каталог временных файлов */
 HT_ERR_INVALID_TRT_PATH	= -24; //* Неверный каталог журнала транзакций */
 HT_ERR_KEY_DOUBLET	       	= -25; //* Найден дубликат уникального ключа */
 HT_ERR_LOG_OVERFLOW       	= -26; //* Переполнение журнала изменений */
 HT_ERR_NET_EQU_WORK		= -27; //* Каталог сетевых замков не может совпадать с каталогом таблицы */
 HT_ERR_NO_CONST_PART		= -28; //* Нет постоянной части таблицы */
 HT_ERR_NO_DATA			= -29; //* Нет области данных */
 HT_ERR_NO_DISK_SPACE    	= -30; //* Нет дискового пространства для работы */
 HT_ERR_NO_SYS_FILE		= -31; //* Нет одного из файлов HyTech (данных или ассоциатора, диф.частей) */
 HT_ERR_NO_TAB_HANDLE		= -32; //* Нет доступных обработчиков */
 HT_ERR_NOT_INDEXED		= -33; //* Таблица не проиндексирована */
 HT_ERR_NOT_INITIATED		= -34; //* HyTech не установлен */
 HT_ERR_NOT_LINKED		= -35; //* Группы таблиц не связаны */
 HT_ERR_NOT_KEY	   		= -36; //* Поиск по не ключу */
 HT_ERR_NOT_SAME_TAB		= -37; //* Разные таблицы операндов */
 HT_ERR_NOT_SYMBOLIC_KEY	= -38; //* Не символьный ключ */
 HT_ERR_NOT_SYS_FILE		= -39; //* Не файл HyTech */
 HT_ERR_NOT_UPDATED		= -40; //* Невозможно обновить таблицу */
 HT_ERR_NETWORK_DOUBLET  	= -41; //* В сети имя таблицы должно быть уникальными */
 HT_ERR_OLD_OPERAND		= -42; //* Операнд устарел (сменилось состояние БД) */
 HT_ERR_OPERATION_DENYED	= -43; //* Операция запрещена */
 HT_ERR_RECNO_DOMAIN    	= -44; //* Неверный номер записи */
 HT_ERR_RECORD_DELETED  	= -45; //* Запись(и) удалены */
 HT_ERR_RECORD_LOCKED		= -46; //* Запись(и) захвачены */
 HT_ERR_RECORD_NOT_FOUND	= -47; //* Обрабатываемая запись не найдена */
 HT_ERR_RECORD_NOT_LOCKED	= -48; //* Обрабатываемая запись должна быть захвачена */
 HT_ERR_SEARCH_CONDITION	= -49; //* Неверное условие поиска по ключу */
 HT_ERR_SEARCH_VALUE		= -50; //* Неверное значение ключа для поиска */
 HT_ERR_SYS_FILES_MISMATCH	= -51; //* Рассогласование данных в системных файлах */
 HT_ERR_SYS_FILE_TYPE_MISMATCH	= -52; //* Не тот тип файла HyTech */
 HT_ERR_SYS_FILE_WRONG_VERSION	= -53; //* Неверная версия файла HyTech */
 HT_ERR_TAB_CORRUPTED         	= -54; //* Нарушена структура файла таблицы */
 HT_ERR_TAB_EXIST             	= -55; //* Такая таблица уже имеется */
 HT_ERR_TAB_REOPEN		= -56; //* Таблица уже открыта */
 HT_ERR_TAB_SHARED            	= -57; //* Таблица используется в сети */
 HT_ERR_TABLE_LOCKED		= -58; //* Таблица захвачена целиком */
 HT_ERR_TOO_FEW_CONFIG_FILES	= -59; //* Значение параметра 'FILES=' мало */
 HT_ERR_TOO_FEW_HANDLES		= -60; //* Мало обработчиков для СУБД */
 HT_ERR_TOO_LONG_FIELD		= -61; //* Слишком длинное ключевое поле */
 HT_ERR_TOO_LONG_FILE_NAME	= -62; //* Слишком длинное имя файла */
 HT_ERR_TOO_LONG_RECORD		= -63; //* Слишком длинная запись */
 HT_ERR_TOO_MANY_FIELDS		= -64; //* Слишком много полей в таблице */
 HT_ERR_TOO_MANY_TABS		= -65; //* Слишком много открытых таблиц */
 HT_ERR_TOO_MANY_TABS_LINKED	= -66; //* Превышено число таблиц для компоновки */
 HT_ERR_TOO_OLD_DOS		= -67; //* Старая версия DOS */
 HT_ERR_TMP_EQU_WORK		= -68; //* Каталог временных не может совпадать с каталогом таблицы */
 HT_ERR_TRT_NOT_AVAIL		= -69; //* Механизм транзакций не инициализирован */
 HT_ERR_TRT_OVERFLOW		= -70; //* Переполнен журнал транзакций */
 HT_ERR_TRT_ROLLED		= -71; //* Транзакция прервана необходимо завершение */
 HT_ERR_TRT_USED		= -72; //* Таблица задействована в транзакциях */
 HT_ERR_INVALID_CODER		= -73; //* Неверный обработчик кодификатора */
 HT_ERR_TOO_MANY_CODERS		= -74; //* Загружено слишком много кодификаторов */
 HT_ERR_EMPTY_CODER		= -75; //* Кодификатор пуст */
 HT_ERR_TOO_LARGE_CODER		= -76; //* Слишком большой кодификатор */
 HT_ERR_TOO_LONG_CODER		= -77; //* Слишком длинный ключ кодификатора */
 HT_ERR_TOO_SHORT_VALUE		= -78; //* Слишком короткий толкователь кодификатора */
 HT_ERR_PHYS_NOT_CODED		= -79; //* Физический номер не кодифицируется */
 HT_ERR_LOG_CORRUPTED	        = -80; //* Поврежден журнал изменений */
 HT_ERR_FIELD_DUPS	        = -81; //* Одинаковый имена полей в исходной файле импорта */
 HT_ERR_AUTO_OVERFLOW		= -82; //* Переполнение автоинкрементного ключа */
 HT_ERR_TOO_MANY_TASKS		= -83; //* Слишком много экземпляров СУБД */
 HT_ERR_SPECIAL		        = -84; //* Резерв */
 HT_ERR_TOO_MANY_LINKS	        = -85; //* Слишком много связей таблиц */
 HT_ERR_INVALID_LINK	        = -86; //* Неверная связь таблиц */
 HT_ERR_CONTEXT_NOT_LOCKED	= -87; //* Внутренняя ошибка: контекст задачи не найден */
 HT_ERR_VILE_ZERO		= -88; //* Внутренняя ошибка: нулевая длина элемента */
 HT_ERR_HEAP_NODE	        = -89; //* Неверный адрес блока */
 HT_ERR_HEAP_TWICE              = -90; //* Повторное освобождение */
 HT_ERR_HEAP_CORRUPTED          = -91; //* Повреждение кучи */
 HT_ERR_VRFY_CNST_DOMAIN        = -92; //* Недопустимое значение поля в постоянной части таблицы */
 HT_ERR_VRFY_CNST_NULL          = -93; //* Неканонизированное NULL значение в постоянной части таблицы */
 HT_ERR_VRFY_CNST_SURRGT        = -94; //* Странное значение суррогата в постоянной части таблицы */
 HT_ERR_VRFY_DIFF_DOMAIN        = -95; //* Недопустимое значение поля в журнале таблицы */
 HT_ERR_VRFY_DIFF_NULL          = -96; //* Неканонизированное NULL значение журнале таблицы */
 HT_ERR_VRFY_DIFF_SURRGT        = -97; //* Странное значение суррогата в журнале таблицы */
 HT_ERR_RECORD_LOCKED_TWICE     = -100; //* Записи захватываются повторно */
 HT_ERR_MAX_CODE	        = -101; //* Максимальный код ошибки */

..\..\DT\DtDefine.inc
{$Include w:\common\components\rtl\Garant\DD\DtDefine.inc}
..\..\DT\htProcName.inc
const
{$IFDEF HT_MODE64}
 sHTADDRECORDS             = '_htAddRecords@24'      ;
 sHTANDRESULTS             = '_htAndResults@12'      ;
 sHTAVERAGEOFKEYVALUES     = '_htAverageOfKeyValues@12';
 sHTBUILDINDEXES           = '_htBuildIndexes@20';
 sHTBACKUPTABLE            = '_htBackupTable@12';
 sHTBACKUPTABLEGROUP       = '_htBackupTableGroup@20';
 sHTCHANGECRYPTOKEY        = '_htChangeCryptoKey@24';
 sHTCHANGEKEYTYPE          = '_htChangeKeyType@28';
 sHTCHANGEREADPASSWORD     = '_htChangeReadPassword@16';
 sHTCHANGEWRITEPASSWORD    = '_htChangeWritePassword@16';
 sHTCLOSERESULTS           = '_htCloseResults@4';
 sHTCLUSTERITEMTOLINK      = '_htClusterItemToLink@16';
 sHTCLUSTERRECSTOLINK      = '_htClusterRecsToLink@12';
 sHTCODEDRESULTSTOTABLE    = '_htCodedResultsToTable@36';
 sHTCODERINFO              = '_htCoderInfo@8';
 sHTCOMMITTRANSACTION      = '_htCommitTransaction@4';
 sHTCOMPARETABHANDLES      = '_htCompareTabHandles@8';
 sHTCOPYRESULTS            = '_htCopyResults@8';
 sHTCREATECLUSTERTABLE     = '_htCreateClusterTable@24';
 sHTCREATEEMPTYSAB         = '_htCreateEmptySAB@20';
 sHTCREATEEMPTYJOIN        = '_htCreateEmptyJoin@12';
 sHTDATETOWORD             = '_htDateToWord@4';
 sHTDELETERECORDS          = '_htDeleteRecords@4';
 sHTDISTINCTRESULTS        = '_htDistinctResults@16';
 sHTDISTINCTRESULTSBYCOUNT = '_htDistinctResultsByCount@24';
 sHTDIVISION               = '_htDivision@16';
 sHTDROPINDEXES            = '_htDropIndexes@12';
 sHTDROPTABLE              = '_htDropTable@12';
 sHTDROPTABLECHANGES       = '_htDropTableChanges@12';
 sHTDROPTABLEDATA          = '_htDropTableData@12';
 sHTDUPTABLEHANDLE         = '_htDupTableHandle@8';
 sHTERRORMESSAGE           = '_htErrorMessage@8';
 sHTEXCLUDERESULTSITEM     = '_htExcludeResultsItem@8';
 sHTEXPORT                 = '_htExport@24';
 sHTEXTERROR               = '_htExtError@12';
 sHTFILTERRECORDS          = '_htFilterRecords@24';
 sHTFILTERTABLES           = '_htFilterTables@40';
 sHTFINDCODERKEY           = '_htFindCoderKey@12';
 sHTFINDCODERVALUE         = '_htFindCoderValue@12';
 sHTFLUSHTABLE             = '_htFlushTable@4';
 sHTGETDIFFLENGTH          = '_htGetDiffLength@8';
 sHTGETRESULTSITEM         = '_htGetResultsItem@12';
 sHTGLOBALINIT             = '_htGlobalInit@4';
 sHTGLOBALSHUT             = '_htGlobalShut@0';
 sHTGROUPBYHAVINGTO        = '_htGroupByHavingTo@32';
 sHTGROUPBYUSER            = '_htGroupByUser@40';
 sHTHANDLEADD              = '_htHandleAdd@12';
 sHTHANDLEFROMRECNO        = '_htHandleFromRecNo@16';
 sHTHANDLEMODIFY           = '_htHandleModify@16';
 sHTHISTOGRAMBYCOUNT       = '_htHistogramByCount@20';
 sHTHISTOGRAMOFKEY         = '_htHistogramOfKey@12';
 sHTHOLDFREERECORDS        = '_htHoldFreeRecords@8';
 sHTHOLDREADRECORD         = '_htHoldReadRecord@12';
 sHTHOLDRECORD             = '_htHoldRecord@8';
 sHTHOLDRESULTS            = '_htHoldResults@4';
 sHTHOLDTABLE              = '_htHoldTable@4';
 sHTIMPORT                 = '_htImport@40';
 sHTIMPORTTITLE            = '_htImportTitle@24';
 sHTINCLUDERESULTSBLOCK    = '_htIncludeResultsBlock@16';
 sHTINCLUDERESULTSITEM     = '_htIncludeResultsItem@12';
 sHTINIT                   = '_htInit@8';
 sHTIOMESSAGE              = '_htIOMessage@4';
 sHTISNEEDTOROLL           = '_htIsNeedToRoll@8';
 sHTISRESULTOBSOLETE       = '_htIsResultObsolete@4';
 sHTISRESULTOPEN           = '_htIsResultOpen@4';
 sHTISTRANSACTIONALTABLE   = '_htIsTransactionalTable@4';
 sHTJOINEDRECORDS          = '_htJoinedRecords@16';
 sHTJOINELEMENT            = '_htJoinElement@20';
 sHTKEYMAXIMUM             = '_htKeyMaximum@12';
 sHTKEYMINIMUM             = '_htKeyMinimum@12';
 sHTLOADCODER              = '_htLoadCoder@24';
 sHTLOADRECORDS            = '_htLoadRecords@32';
 sHTLOGCLOSE               = '_htLogClose@4';
 sHTLOGOPEN                = '_htLogOpen@24';
 sHTLOGREAD                = '_htLogRead@16';
 sHTMAKEGROUPPHOTO         = '_htMakeGroupPhoto@12';
 sHTMAKEPHOTO              = '_htMakePhoto@8';
 sHTMARKJOINEDRECORD       = '_htMarkJoinedRecord@12';
 sHTMARKJOINEDRECORDEX     = '_htMarkJoinedRecordEx@8';
 sHTMARKRECORD             = '_htMarkRecord@8';
 sHTMEMOAVAILBYTASK        = '_htMemoAvailByTask@8';
 sHTMESSAGE                = '_htMessage@8';
 sHTMODIFYRECORDS          = '_htModifyRecords@20';
 sHTNOTRESULTS             = '_htNotResults@8';
 sHTNULLFIELD              = '_htNullField@16';
 sHTNULLRECORD             = '_htNullRecord@8';
 sHTOPENCODEDRESULTS       = '_htOpenCodedResults@12';
 sHTOPENRESULTS            = '_htOpenResults@16';
 sHTORRESULTS              = '_htOrResults@12';
 sHTOUTTO                  = '_htOutTo@36';
 sHTPRINTHYTECHHEAP        = '_htPrintHytechHeap@8';
 sHTPUREADDRECORDS         = '_htPureAddRecords@16';
 sHTPUREMODIFYRECORDS      = '_htPureModifyRecords@12';
 sHTREADCODER              = '_htReadCoder@12';
 sHTREADRECORD             = '_htReadRecord@16';
 sHTREADRECORDBYHANDLE     = '_htReadRecordByHandle@12';
 sHTREADRESULTS            = '_htReadResults@12';
 sHTREADSABCHANGES         = '_htReadSABChanges@16';
 sHTREADTABLECHANGES       = '_htReadTableChanges@24';
 sHTRECNOFROMHANDLE        = '_htRecNoFromHandle@8';
 sHTRECORDADD              = '_htRecordAdd@8';
 sHTRECORDBYUNIQ           = '_htRecordByUniq@20';
 sHTRECORDDELETE           = '_htRecordDelete@8';
 sHTRECORDMODIFY           = '_htRecordModify@12';
 sHTRECORDORDINALNUMBER    = '_htRecordOrdinalNumber@8';
 sHTRECORDSBYKEY           = '_htRecordsByKey@8';
 sHTRECORDSFORTWOKEYS      = '_htRecordsForTwoKeys@20';
 sHTRELEASERECORD          = '_htReleaseRecord@8';
 sHTRELEASERESULTS         = '_htReleaseResults@4';
 sHTRELEASETABLE           = '_htReleaseTable@4';
 sHTREPAIRTABLE            = '_htRepairTable@12';
 sHTREPAIRTABLELOG         = '_htRepairTableLog@16';
 sHTREPLACERESULTSITEM     = '_htReplaceResultsItem@12';
 sHTREPLACERESULTSTABLE    = '_htReplaceResultsTable@12';
 sHTRESTORETABLE           = '_htRestoreTable@16';
 sHTRESULTSELEMENT         = '_htResultsElement@8';
 sHTRESULTSITEMCNT         = '_htResultsItemCnt@4';
 sHTRESULTSITEMLEN         = '_htResultsItemLen@8';
 sHTRESULTSITEMPARM        = '_htResultsItemParm@8';
 sHTRESULTSTABLE           = '_htResultsTable@8';
 sHTRESULTSTOHARD          = '_htResultsToHard@4';
 sHTRESULTSTOTABLE         = '_htResultsToTable@36';
 sHTRESULTSTYPE            = '_htResultsType@4';
 sHTROLLBACKTRANSACTION    = '_htRollBackTransaction@4';
 sHTSEARCH                 = '_htSearch@28';
 sHTSEEKMARKEDJOIN         = '_htSeekMarkedJoin@12';
 sHTSEEKMARKEDJOINEX       = '_htSeekMarkedJoinEx@8';
 sHTSEEKMARKEDRECORD       = '_htSeekMarkedRecord@8';
 sHTSEEKRESULTS            = '_htSeekResults@12';
 sHTSORTEDRECORDS          = '_htSortedRecords@8';
 sHTSORTEDRECORDSEX        = '_htSortedRecordsEx@12';
 sHTSORTRESULTS            = '_htSortResults@16';
 sHTSORTRESULTSBYUSER      = '_htSortResultsByUser@24';
 sHTSTARTTIMEDATE          = '_htStartTimeDate@0';
 sHTSTARTTRANSACTION       = '_htStartTransaction@12';
 sHTSUBSEARCH              = '_htSubSearch@28';
 sHTSUMOFKEYVALUES         = '_htSumOfKeyValues@12';
 sHTSYNCRESULTS            = '_htSyncResults@12';
 sHTTABLECLOSE             = '_htTableClose@4';
 sHTTABLECOPY              = '_htTableCopy@16';
 sHTTABLECREATE            = '_htTableCreate@32';
 sHTTABLEELEMENT           = '_htTableElement@16';
 sHTTABLEELEMENTLIST       = '_htTableElementList@8';
 sHTTABLEHANDLEBYNAME      = '_htTableHandleByName@8';
 sHTTABLEINFO              = '_htTableInfo@8';
 sHTTABLEOPEN              = '_htTableOpen@20';
 sHTTABLERENAME            = '_htTableRename@16';
 sHTTABLEVERIFY            = '_htTableVerify@16';
 sHTTELLJOINORDER          = '_htTellJoinOrder@8';
 sHTTOUCHRESULTS           = '_htTouchResults@8';
 sHTTRANSFERTOPHOTO        = '_htTransferToPhoto@12';
 sHTTRANSFERTOTABLE        = '_htTransferToTable@12';
 sHTUPDATETABLE            = '_htUpdateTable@20';
 sHTVALUESBYCOUNT          = '_htValuesByCount@20';
 sHTVALUESFROMGROUP        = '_htValuesFromGroup@16';
 sHTVALUESOFKEY            = '_htValuesOfKey@12';
 sHTXORRESULTS             = '_htXorResults@12';
 sHTBREAK                  = '_htBreak@0';
 sHTCLEARRESULTS           = '_htClearResults@4';
 sHTCLOSEALLTABLES         = '_htCloseAllTables@0';
 sHTNETPATH                = '_htNetPath@4';
 sHTPURGECODER             = '_htPurgeCoder@4';
 sHTPURGEERROR             = '_htPurgeError@0';
 sHTSETLOCKTIMEOUT         = '_htSetLockTimeOut@4';
 sHTSETPOLLDELAY           = '_htSetPollDelay@4';
 sHTSETTRANSTIMEOUT        = '_htSetTransTimeOut@4';
 sHTSHUT                   = '_htShut@0';
 sHTSTRINGTOARRAY          = '_htStringToArray@12';
 sHTSTRINGTOCHARS          = '_htStringToChars@12';
 sHTTABLESABSTAT           = '_htGetSABStat@8';  //????
 sHTTABLEHEADCLOSE         = '_htTableHeadClose@4';
 sHTTABLEHEADOPEN          = '_htTableHeadOpen@24';
 sHTTABLEHEADPSWD          = '_htTableHeadPswd@8';
 sHTTABLEHEADREAD          = '_htTableHeadRead@12';
 sHTTABLEHEADWRITE         = '_htTableHeadWrite@20';
 sHTTABLESJOIN             = '_htTablesJoin@36';
 sHTTABLESLINK             = '_htTablesLink@20';
 sHTTMPPATH                = '_htTmpPath@4';
 sHTWHOLOCKRECORD          = '_htWhoLockRecord@12';
 sHTWHOLOCKSET             = '_htWhoLockSet@8';
 sHTWHOLOCKTABLE           = '_htWhoLockTable@8';
 sHTWILDCMP                = '_htWildCmp@16';
 sHTWORDTODATE             = '_htWordToDate@8';
 sHTTABLESTATE             = '_htTableState@8';
 sHTTABLEAGREGATEAPPEND    = '_htTableAgregateAppend@20';
 sHTTABLEAGREGATEDELETE    = '_htTableAgregateDelete@20';
 sHTTABLEAGREGATEMODIFY    = '_htTableAgregateModify@24';
 sHTISFIELDNULL            = '_htIsFieldNull@12';
 sHTCTRLCTRL               = '_htCtrlCtrl@4';
 sHTCONVERTTABLE           = '_htConvertTable@20';
 shtTableRecordLen         = '_htTableRecordLen@8';
 sHTEXCLUDERESULTS         = '_htExcludeResults@12';
 sHTRECORDSBYVALUES        = '_htRecordsByValues@24';
 sHTLASTERRORTEXT          = '_htLastErrorText@8';
{$ELSE}
 not use!! ///

 sHTADDRECORDS             = 'HTADDRECORDS';
 sHTANDRESULTS             = 'HTANDRESULTS';
 sHTAVERAGEOFKEYVALUES     = 'HTAVERAGEOFKEYVALUES';
 sHTBUILDINDEXES           = 'HTBUILDINDEXES';
 sHTBACKUPTABLE            = 'HTBACKUPTABLE';
 sHTBACKUPTABLEGROUP       = 'HTBACKUPTABLEGROUP';
 sHTCHANGECRYPTOKEY        = 'HTCHANGECRYPTOKEY';
 sHTCHANGEKEYTYPE          = 'HTCHANGEKEYTYPE';
 sHTCHANGEREADPASSWORD     = 'HTCHANGEREADPASSWORD';
 sHTCHANGEWRITEPASSWORD    = 'HTCHANGEWRITEPASSWORD';
 sHTCLOSERESULTS           = 'HTCLOSERESULTS';
 sHTCLUSTERITEMTOLINK      = 'HTCLUSTERITEMTOLINK';
 sHTCLUSTERRECSTOLINK      = 'HTCLUSTERRECSTOLINK';
 sHTCODEDRESULTSTOTABLE    = 'HTCODEDRESULTSTOTABLE';
 sHTCODERINFO              = 'HTCODERINFO';
 sHTCOMMITTRANSACTION      = 'HTCOMMITTRANSACTION';
 sHTCOMPARETABHANDLES      = 'HTCOMPARETABHANDLES';
 sHTCOPYRESULTS            = 'HTCOPYRESULTS';
 sHTCREATECLUSTERTABLE     = 'HTCREATECLUSTERTABLE';
 sHTCREATEEMPTYSAB         = 'HTCREATEEMPTYSAB';
 sHTCREATEEMPTYJOIN        = 'HTCREATEEMPTYJOIN';
 sHTDATETOWORD             = 'HTDATETOWORD';
 sHTDELETERECORDS          = 'HTDELETERECORDS';
 sHTDISTINCTRESULTS        = 'HTDISTINCTRESULTS';
 sHTDISTINCTRESULTSBYCOUNT = 'HTDISTINCTRESULTSBYCOUNT';
 sHTDIVISION               = 'HTDIVISION';
 sHTDROPINDEXES            = 'HTDROPINDEXES';
 sHTDROPTABLE              = 'HTDROPTABLE';
 sHTDROPTABLECHANGES       = 'HTDROPTABLECHANGES';
 sHTDROPTABLEDATA          = 'HTDROPTABLEDATA';
 sHTDUPTABLEHANDLE         = 'HTDUPTABLEHANDLE';
 sHTERRORMESSAGE           = 'HTERRORMESSAGE';
 sHTEXCLUDERESULTSITEM     = 'HTEXCLUDERESULTSITEM';
 sHTEXPORT                 = 'HTEXPORT';
 sHTEXTERROR               = 'HTEXTERROR';
 sHTFILTERRECORDS          = 'HTFILTERRECORDS';
 sHTFILTERTABLES           = 'HTFILTERTABLES';
 sHTFINDCODERKEY           = 'HTFINDCODERKEY';
 sHTFINDCODERVALUE         = 'HTFINDCODERVALUE';
 sHTFLUSHTABLE             = 'HTFLUSHTABLE';
 sHTGETDIFFLENGTH          = 'HTGETDIFFLENGTH';
 sHTGETRESULTSITEM         = 'HTGETRESULTSITEM';
 sHTGLOBALINIT             = 'HTGLOBALINIT';
 sHTGLOBALSHUT             = 'HTGLOBALSHUT';
 sHTGROUPBYHAVINGTO        = 'HTGROUPBYHAVINGTO';
 sHTGROUPBYUSER            = 'HTGROUPBYUSER';
 sHTHANDLEADD              = 'HTHANDLEADD';
 sHTHANDLEFROMRECNO        = 'HTHANDLEFROMRECNO';
 sHTHANDLEMODIFY           = 'HTHANDLEMODIFY';
 sHTHISTOGRAMBYCOUNT       = 'HTHISTOGRAMBYCOUNT';
 sHTHISTOGRAMOFKEY         = 'HTHISTOGRAMOFKEY';
 sHTHOLDFREERECORDS        = 'HTHOLDFREERECORDS';
 sHTHOLDREADRECORD         = 'HTHOLDREADRECORD';
 sHTHOLDRECORD             = 'HTHOLDRECORD';
 sHTHOLDRESULTS            = 'HTHOLDRESULTS';
 sHTHOLDTABLE              = 'HTHOLDTABLE';
 sHTIMPORT                 = 'HTIMPORT';
 sHTIMPORTTITLE            = 'HTIMPORTTITLE';
 sHTINCLUDERESULTSBLOCK    = 'HTINCLUDERESULTSBLOCK';
 sHTINCLUDERESULTSITEM     = 'HTINCLUDERESULTSITEM';
 sHTINIT                   = 'HTINIT';
 sHTIOMESSAGE              = 'HTIOMESSAGE';
 sHTISNEEDTOROLL           = 'HTISNEEDTOROLL';
 sHTISRESULTOBSOLETE       = 'HTISRESULTOBSOLETE';
 sHTISRESULTOPEN           = 'HTISRESULTOPEN';
 sHTISTRANSACTIONALTABLE   = 'HTISTRANSACTIONALTABLE';
 sHTJOINEDRECORDS          = 'HTJOINEDRECORDS';
 sHTJOINELEMENT            = 'HTJOINELEMENT';
 sHTKEYMAXIMUM             = 'HTKEYMAXIMUM';
 sHTKEYMINIMUM             = 'HTKEYMINIMUM';
 sHTLOADCODER              = 'HTLOADCODER';
 sHTLOADRECORDS            = 'HTLOADRECORDS';
 sHTLOGCLOSE               = 'HTLOGCLOSE';
 sHTLOGOPEN                = 'HTLOGOPEN';
 sHTLOGREAD                = 'HTLOGREAD';
 sHTMAKEGROUPPHOTO         = 'HTMAKEGROUPPHOTO';
 sHTMAKEPHOTO              = 'HTMAKEPHOTO';
 sHTMARKJOINEDRECORD       = 'HTMARKJOINEDRECORD';
 sHTMARKJOINEDRECORDEX     = 'HTMARKJOINEDRECORDEX';
 sHTMARKRECORD             = 'HTMARKRECORD';
 sHTMEMOAVAILBYTASK        = 'HTMEMOAVAILBYTASK';
 sHTMESSAGE                = 'HTMESSAGE';
 sHTMODIFYRECORDS          = 'HTMODIFYRECORDS';
 sHTNOTRESULTS             = 'HTNOTRESULTS';
 sHTNULLFIELD              = 'HTNULLFIELD';
 sHTNULLRECORD             = 'HTNULLRECORD';
 sHTOPENCODEDRESULTS       = 'HTOPENCODEDRESULTS';
 sHTOPENRESULTS            = 'HTOPENRESULTS';
 sHTORRESULTS              = 'HTORRESULTS';
 sHTOUTTO                  = 'HTOUTTO';
 sHTPRINTHYTECHHEAP        = 'HTPRINTHYTECHHEAP';
 sHTPUREADDRECORDS         = 'HTPUREADDRECORDS';
 sHTPUREMODIFYRECORDS      = 'HTPUREMODIFYRECORDS';
 sHTREADCODER              = 'HTREADCODER';
 sHTREADRECORD             = 'HTREADRECORD';
 sHTREADRECORDBYHANDLE     = 'HTREADRECORDBYHANDLE';
 sHTREADRESULTS            = 'HTREADRESULTS';
 sHTREADSABCHANGES         = 'HTREADSABCHANGES';
 sHTREADTABLECHANGES       = 'HTREADTABLECHANGES';
 sHTRECNOFROMHANDLE        = 'HTRECNOFROMHANDLE';
 sHTRECORDADD              = 'HTRECORDADD';
 sHTRECORDBYUNIQ           = 'HTRECORDBYUNIQ';
 sHTRECORDDELETE           = 'HTRECORDDELETE';
 sHTRECORDMODIFY           = 'HTRECORDMODIFY';
 sHTRECORDORDINALNUMBER    = 'HTRECORDORDINALNUMBER';
 sHTRECORDSBYKEY           = 'HTRECORDSBYKEY';
 sHTRECORDSFORTWOKEYS      = 'HTRECORDSFORTWOKEYS';
 sHTRELEASERECORD          = 'HTRELEASERECORD';
 sHTRELEASERESULTS         = 'HTRELEASERESULTS';
 sHTRELEASETABLE           = 'HTRELEASETABLE';
 sHTREPAIRTABLE            = 'HTREPAIRTABLE';
 sHTREPAIRTABLELOG         = 'HTREPAIRTABLELOG';
 sHTREPLACERESULTSITEM     = 'HTREPLACERESULTSITEM';
 sHTREPLACERESULTSTABLE    = 'HTREPLACERESULTSTABLE';
 sHTRESTORETABLE           = 'HTRESTORETABLE';
 sHTRESULTSELEMENT         = 'HTRESULTSELEMENT';
 sHTRESULTSITEMCNT         = 'HTRESULTSITEMCNT';
 sHTRESULTSITEMLEN         = 'HTRESULTSITEMLEN';
 sHTRESULTSITEMPARM        = 'HTRESULTSITEMPARM';
 sHTRESULTSTABLE           = 'HTRESULTSTABLE';
 sHTRESULTSTOHARD          = 'HTRESULTSTOHARD';
 sHTRESULTSTOTABLE         = 'HTRESULTSTOTABLE';
 sHTRESULTSTYPE            = 'HTRESULTSTYPE';
 sHTROLLBACKTRANSACTION    = 'HTROLLBACKTRANSACTION';
 sHTSEARCH                 = 'HTSEARCH';
 sHTSEEKMARKEDJOIN         = 'HTSEEKMARKEDJOIN';
 sHTSEEKMARKEDJOINEX       = 'HTSEEKMARKEDJOINEX';
 sHTSEEKMARKEDRECORD       = 'HTSEEKMARKEDRECORD';
 sHTSEEKRESULTS            = 'HTSEEKRESULTS';
 sHTSORTEDRECORDS          = 'HTSORTEDRECORDS';
 sHTSORTEDRECORDSEX        = 'HTSORTEDRECORDSEX';
 sHTSORTRESULTS            = 'HTSORTRESULTS';
 sHTSORTRESULTSBYUSER      = 'HTSORTRESULTSBYUSER';
 sHTSTARTTIMEDATE          = 'HTSTARTTIMEDATE';
 sHTSTARTTRANSACTION       = 'HTSTARTTRANSACTION';
 sHTSUBSEARCH              = 'HTSUBSEARCH';
 sHTSUMOFKEYVALUES         = 'HTSUMOFKEYVALUES';
 sHTSYNCRESULTS            = 'HTSYNCRESULTS';
 sHTTABLECLOSE             = 'HTTABLECLOSE';
 sHTTABLECOPY              = 'HTTABLECOPY';
 sHTTABLECREATE            = 'HTTABLECREATE';
 sHTTABLEELEMENT           = 'HTTABLEELEMENT';
 sHTTABLEELEMENTLIST       = 'HTTABLEELEMENTLIST';
 sHTTABLEHANDLEBYNAME      = 'HTTABLEHANDLEBYNAME';
 sHTTABLEINFO              = 'HTTABLEINFO';
 sHTTABLEOPEN              = 'HTTABLEOPEN';
 sHTTABLERENAME            = 'HTTABLERENAME';
 sHTTABLEVERIFY            = 'HTTABLEVERIFY';
 sHTTELLJOINORDER          = 'HTTELLJOINORDER';
 sHTTOUCHRESULTS           = 'HTTOUCHRESULTS';
 sHTTRANSFERTOPHOTO        = 'HTTRANSFERTOPHOTO';
 sHTTRANSFERTOTABLE        = 'HTTRANSFERTOTABLE';
 sHTUPDATETABLE            = 'HTUPDATETABLE';
 sHTVALUESBYCOUNT          = 'HTVALUESBYCOUNT';
 sHTVALUESFROMGROUP        = 'HTVALUESFROMGROUP';
 sHTVALUESOFKEY            = 'HTVALUESOFKEY';
 sHTXORRESULTS             = 'HTXORRESULTS';
 sHTBREAK                  = 'HTBREAK';
 sHTCLEARRESULTS           = 'HTCLEARRESULTS';
 sHTCLOSEALLTABLES         = 'HTCLOSEALLTABLES';
 sHTNETPATH                = 'HTNETPATH';
 sHTPURGECODER             = 'HTPURGECODER';
 sHTPURGEERROR             = 'HTPURGEERROR';
 sHTSETLOCKTIMEOUT         = 'HTSETLOCKTIMEOUT';
 sHTSETPOLLDELAY           = 'HTSETPOLLDELAY';
 sHTSETTRANSTIMEOUT        = 'HTSETTRANSTIMEOUT';
 sHTSHUT                   = 'HTSHUT';
 sHTSTRINGTOARRAY          = 'HTSTRINGTOARRAY';
 sHTSTRINGTOCHARS          = 'HTSTRINGTOCHARS';
 sHTTABLESABSTAT           = 'HTTABLESABSTAT';
 sHTTABLEHEADCLOSE         = 'HTTABLEHEADCLOSE';
 sHTTABLEHEADOPEN          = 'HTTABLEHEADOPEN';
 sHTTABLEHEADPSWD          = 'HTTABLEHEADPSWD';
 sHTTABLEHEADREAD          = 'HTTABLEHEADREAD';
 sHTTABLEHEADWRITE         = 'HTTABLEHEADWRITE';
 sHTTABLESJOIN             = 'HTTABLESJOIN';
 sHTTABLESLINK             = 'HTTABLESLINK';
 sHTTMPPATH                = 'HTTMPPATH';
 sHTWHOLOCKRECORD          = 'HTWHOLOCKRECORD';
 sHTWHOLOCKSET             = 'HTWHOLOCKSET';
 sHTWHOLOCKTABLE           = 'HTWHOLOCKTABLE';
 sHTWILDCMP                = 'HTWILDCMP';
 sHTWORDTODATE             = 'HTWORDTODATE';
 sHTTABLESTATE             = 'HTTABLESTATE';
 sHTTABLEAGREGATEMODIFY    = 'HTTABLEAGREGATEMODIFY';
 sHTTABLEAGREGATEDELETE    = 'HTTABLEAGREGATEDELETE';
 sHTTABLEAGREGATEAPPEND    = 'HTTABLEAGREGATEAPPEND';
 sHTISFIELDNULL            = 'HTISFIELDNULL';
 sHTCTRLCTRL               = 'AMCTRLCTRL';
{$ENDIF}

(*
_htConvertTable@20

_amGetVersion@0
_amReadSerNo@0
_htAbort@0

_htCanonizeName@8
_htConstRecordByUniq@16
_htConvertTable@20
_htDiffMark@0
_htErrorKey@0
_htGetId@0
_htGetParam@12
_htGetSABStat@8
_htGetSabSize@0
_htKillLckFiles@4
_htLastSurrogate@8
_htModifyHandles@20

_htPureResultsToTable@32
_htSetParam@8
_htSortJoinByPhys@8
_htSqueezeTableList@0
_htStringToArray@12
_htStringToChars@12
_htTableChangesCopy@28
_htTableDiffLength@8
_htTableDiffRead@24
_htTableHeadClose@4
_htTableHeadOpen@24
_htTableHeadPswd@8
_htTableHeadRead@12
_htTableHeadWrite@20
_htTableLogWrite@32
_htTablePack@20
_htTableRecordLen@8
_htTableRecsRead@20
_htTableReplace@12
_htVileLimit@4
_htWhoIam@4

_htAddRecordsSrv@28
_htModifyRecordsSrv@24
_htPureAddRecordsSrv@20
_htPureModifyRecordsSrv@16
_htPureResultsToTableSrv@36
_htResultsToTableSrv@40

*)
..\..\DUnitTuning\readme.txt
В начале:
- разархивировать mdtorb и путь к его dcu %mdtorb%\dcu прописать в Delphi в Library Path;
- путь %mdtorb%\build добавить в переменную окружения PATH.


Порядок работы:
- скомпилировать стабы (прокси на паскале) для нужных серверных интерфейсов из соответствующих idl-файлов:
    idltopas -iW:\ W:\%PATH_TO_SERVER_INTERFACE%.idl;
- все получившиеся в итоге файлы добавить в свой проект.

О получении экземпляра интерфейса:
- получить фабрику, правила именования такие:
	для получения фабрики из NameService: %ИМЯ_РУТОВОГО_ПАКЕТА%::%ИМЯ_ПАКЕТА_СОДЕРЖАЩЕГО_ИНТЕРФЕЙС%::%ИМЯ_ИНТЕРФЕЙСА%
	для интерфейса фабрики: I%%ИМЯ_РУТОВОГО_ПАКЕТА%_%ИМЯ_ПАКЕТА_СОДЕРЖАЩЕГО_ИНТЕРФЕЙС%_%ИМЯ_ИНТЕРФЕЙСА%FactoryManagerSrv
- дернуть фабричный метод, получить интерфейс с именем типа:
	I%%ИМЯ_РУТОВОГО_ПАКЕТА%_%ИМЯ_ПАКЕТА_СОДЕРЖАЩЕГО_ИНТЕРФЕЙС%_%ИМЯ_ИНТЕРФЕЙСА%



..\..\DUnitTuning\tfwDefine.inc
{$Include afwDefine.inc}
..\..\DUnitTuning\KPageTest2\KPageTest2.dpr
program KPageTest2;

uses
  Forms,
  KPagetTest2 in 'KPagetTest2.pas' {Form1},
  Contents in 'Contents.pas',
  Contents_int in 'Contents_int.pas',
  GenerationContents in 'GenerationContents.pas',
  GenerationContents_int in 'GenerationContents_int.pas',
  RootSrv in 'RootSrv.pas',
  RootSrv_int in 'RootSrv_int.pas',
  SecuritySrv in 'SecuritySrv.pas',
  SecuritySrv_int in 'SecuritySrv_int.pas',
  SecuritySrvComm in 'SecuritySrvComm.pas',
  SecuritySrvComm_int in 'SecuritySrvComm_int.pas';

{$R *.res}

begin
  Application.Initialize;
  Application.CreateForm(TForm1, Form1);
  Application.Run;
end.
..\..\DUnit_Script_Support\dsDefine.inc
{$Include evDefine.inc}
..\..\EVD\evdDefine.inc
{$IfNDef evdDefine}
{$Define evdDefine}
{ Библиотека "EVD"      }
{ Автор: Люлин А.В. ©   }
{ Модуль: evdDefine - }
{ Начат: 23.06.2005 14:18 }
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.12  2015/08/17 11:40:57  lulin
// {RequestLink:604929313}.
//
// Revision 1.11  2015/05/19 16:16:36  lulin
// - чистим код.
//
// Revision 1.10  2012/06/05 13:10:39  voba
// no message
//
// Revision 1.9  2010/06/10 11:35:31  lulin
// {RequestLink:159355611}.
//
// Revision 1.8  2009/08/20 11:33:21  dinishev
// Bug fix: в Everest'е записывали в старом формате.
//
// Revision 1.7  2008/09/01 13:25:57  lulin
// - собираем "правильный" Эверест - http://mdp.garant.ru/pages/viewpage.action?pageId=111739807&focusedCommentId=112722262#comment-112722262
//
// Revision 1.6  2007/09/05 11:57:53  lulin
// - сделана возможность определять проектные директивы в специально отведенном файле.
//
// Revision 1.5  2007/09/04 16:12:27  lulin
// - включаем директивы проекта.
//
// Revision 1.4  2007/08/29 14:27:02  lulin
// - пакуем EVD-теги - вместо слова, пишем байт.
//
// Revision 1.3  2007/08/29 13:10:24  lulin
// - cleanup.
//
// Revision 1.2  2005/07/21 13:00:42  lulin
// - писатель формата EVD переехал в папку EVD.
//
// Revision 1.1  2005/06/23 10:26:07  lulin
// - добавлены новые модули.
//

{$Include k2Define.inc }

{$Define evdNeedEverestTxt}
{$Define evdNeedNSRCWriter}

{$IfDef EverestLite}
 {$IfNDef evdNeedNSRCWriter}
  {$Undef evdNeedEverestTxt}
 {$EndIf  evdNeedNSRCWriter} 
{$EndIf EverestLite}

{$IfDef evMyEditor}
 {$Undef evdNeedNSRCWriter}
 {$Undef evdNeedEverestTxt}
{$EndIf evMyEditor}

{.$IfDef Archi}
 {.$I ArchiDefine.inc}
{.$EndIf Archi}

{$IfDef UseProjectDefine}
 {$I ProjectDefine.inc}
{$EndIf UseProjectDefine}

{$EndIf  evdDefine}
..\..\EVD\outSchema\ProjectDefine.inc
{$Define OutEVDSchema}
..\..\EVD\outSchema\OutEvdSchema.dpr
program OutEvdSchema;

{$AppType Console}

uses
  TypInfo,
  
  SysUtils,
  StrUtils,

  Graphics,

  l3Variant,
  l3Chars,
  l3Const,
  l3Types,
  l3Base,
  l3Filer,
  l3KeyWrd,
  l3String,

  k2Interfaces,
  k2Base,
  k2Facade,
  k2Tags,
  k2Const,

  evdSchema,
  evdTypes,

  evTypes,
  evdConst,
  evdStyles,

  LeafPara_Const,
  ParaList_Const,
  Para_Const,
  TextPara_Const,
  StyledLeafPara_Const,
  Style_Const,
  ControlPara_Const,

  evStyleInterface
  ;

procedure DoOut;
const
 c_TypeID = 'TypeID';
 c_DefChild = 'DEF_CHILD';
 c_BaseChild = 'BASE_CHILD';
 c_AttrType = 'ATTR_TYPE';
 c_AttrDefaultValue = 'ATTR_DEFAULT_VALUE';
 c_AttrChild = 'DEF_ATTR_CHILD';
 c_Inherits = 'INHERITS';
 c_Enum = 'enum %s {';
 c_EnumItem = '%s // %d';
 c_EnumEnd = '}; // %s';
var
 l_Out   : Tl3DOSFiler;
 l_Table : Tk2TypeTable;
 l_First : Boolean;

 procedure Put(const aString: String = '');
   overload;
 begin//Put
  l_Out.WriteLn(aString);
 end;//Put

 procedure Put(const aString: String; const Params: array of const);
   overload;
 begin
  Put(Format(aString, Params));
 end;

 procedure PutComma;
 begin//PutComma
  if l_First then
  begin
   l_First := false;
   l_Out.Write('  ');
  end//l_First
  else
   l_Out.Write(', ');
 end;//PutComma

 procedure PutOR;
 begin//PutOR
  if l_First then
  begin
   l_First := false;
   l_Out.Write('     ');
  end//l_First
  else
   l_Out.Write('   ||');
 end;//PutOR

 function mEnum(const aType       : String;
                const aFrom       : String = '';
                const aTo         : String = ''): String; overload;
 begin//mEnum
  Result := AnsiReplaceStr(aType, aFrom, aTo);
 end;//mEnum

 function mEnum(i : Integer;
                aType       : PTypeInfo;
                const aFrom       : String = '';
                const aTo         : String = ''): String; overload;
 begin//mEnum
  Result := mEnum(GetEnumName(aType, i), aFrom, aTo);
 end;//mEnum

 function mTypeX(i : Integer): String;
 var
  l_Type : Tk2Type;
 begin//mTypeX
  l_Type := l_Table.TypeByHandle[i];
  if (l_Type = nil) then
  begin
   Result := 'Empty';
   if (i > 0) then
    Result := Result + IntToStr(i);
  end//l_Type = nil
  else
  begin
   Result := l_Type.AsString;
   Assert(Result <> '');
  end;//l_Type = nil
 end;//mTypeX

 function mType(i : Integer): String;
 begin//mType
  Result := 'id_' + mTypeX(i);
 end;//mType

 function mTagX(i : Integer): String;
 begin//mTagX
  Result := mEnum(Ord(i), TypeInfo(Tk2TagID), '_k2_ti', '');
 end;//mTagX

 procedure PutEnum(const aName : String;
                   aType       : PTypeInfo;
                   aComment    : String;
                   aFrom       : String = '';
                   aTo         : String = '');
 var
  i      : Integer;
  l_TD   : PTypeData;
  l_Name : String;
 begin//PutEnum
  Put('// %s:', [aComment]);
  l_TD := GetTypeData(aType);
  if (aName = '') then
   l_Name := aType.Name
  else
   l_Name := aName;
  l_First := true;
  Put(c_Enum, [l_Name]);
  for i := l_TD.MinValue to l_TD.MaxValue do
  begin
   PutComma;
   Put(c_EnumItem, [mEnum(i, aType, aFrom, aTo), i]);
  end;//for i
  Put(c_EnumEnd, [l_Name]);
  Put;
 end;//PutEnum

 procedure PutVect(const aName : String;
                   aType       : PTypeInfo;
                   aComment    : String;
                   aFrom       : String = '';
                   aTo         : String = '');
 var
  i      : Integer;
  l_TD   : PTypeData;
  l_Name : String;
 begin//PutVect
  Put('// %s:', [aComment]);
  l_TD := GetTypeData(aType);
  if (aName = '') then
   l_Name := aType.Name
  else
   l_Name := aName;
  l_First := true;
  Put('const %s %s[] = {', ['char*', l_Name]);
  for i := l_TD.MinValue to l_TD.MaxValue do
  begin
   PutComma;
   Put('"%s"', [mEnum(i, aType, aFrom, aTo)]);
  end;//for i
  PutComma;
  Put('0');
  Put(c_EnumEnd, [l_Name]);
  Put;
 end;//PutVect

 procedure PutTypeVect(const aName : String;
                       const aComment : String);
 var
  i      : Integer;
 begin//PutVect
  Put('// %s:', [aComment]);
  l_First := true;
  Put('const %s %s[] = {', ['char*', aName]);
  for i := 0 to l_Table.MaxTypeID do
  begin
   PutComma;
   Put('"%s"', [mTypeX(i)]);
  end;//for i
  PutComma;
  Put('0');
  Put(c_EnumEnd, [aName]);
  Put;
 end;//PutVect

 procedure PutTypes;
 var
  i      : Integer;
  l_Type : Tk2Type;
  l_Name : String;
 begin//PutTypes
  Put('// идентификаторы типов:');
  Put(c_Enum, [c_TypeID]);
  l_First := true;
  for i := 0 to l_Table.MaxTypeID do
  begin
   PutComma;
   l_Type := l_Table.TypeByHandle[i];
   if (l_Type = nil) then
    l_Name := 'зарезервированно'
   else
    l_Name := l_Type.AsString{DisplayName};
   Put('%s // %s %d', [mType(i), l_Name, Ord(i)]);
  end;//for i
  Put(c_EnumEnd, [c_TypeID]);
  Put;
 end;//PutTypes

 procedure PutDefaultChildren;

  procedure PutEmpty(const aType: String; i: Integer);
  begin//PutEmpty
   Put('%s // %s %d -> no default %d', [mType(0), aType, i, 0]);
  end;//PutEmpty

 var
  i       : Integer;
  l_Type  : Tk2Type;
  l_CT    : Tk2Type;
  l_Prop  : Tk2ArrayProperty;
 begin//PutDefaultChildren
  Put('// таблица соответствия типа ноды и ее дочерних нод по умолчанию:');
  Put;
  Put('const %s %s[] = {', [c_TypeID, c_DefChild]);
  l_First := true;
  for i := 0 to l_Table.MaxTypeID do
  begin
   PutComma;
   l_Type := l_Table.TypeByHandle[Ord(i)];
   if (l_Type = nil) then
    PutEmpty(mType(i), Ord(i))
   else
   begin
    l_Prop := l_Type.ArrayProp[k2_tiChildren];
    if (l_Prop = nil) OR (l_Prop.DefaultChildType = nil) then
     PutEmpty(l_Type.AsString, Ord(i))
    else
    begin
     l_CT := l_Prop.DefaultChildType;
     Put('%s // %s %d -> %s %d', [mType(l_CT.ID), l_Type.AsString, Ord(i), l_CT.AsString, l_CT.ID]);
    end;//l_Prop = nil..
   end;//l_Type = nil
  end;//for i
  Put(c_EnumEnd, [c_DefChild]);
  Put;
 end;//PutDefaultChildren

 procedure PutInherrits;

  procedure PutEmpty(const aType1, aType2: String);
  begin//PutEmpty
   Put('%s // %s -> %s', ['false', aType1, aType2]);
  end;//PutEmpty

 var
  i   : Integer;
  j   : Integer;
  l_A : Tk2Type;
 begin//PutInherrits
  Put('// таблица отношения наследования типов тегов:');
  Put;
  Put('const %s %s[%d][%d] = {', ['bool', c_Inherits, l_Table.MaxTypeID+1, l_Table.MaxTypeID+1]);
  l_First := true;
  for i := 0 to l_Table.MaxTypeID do
  begin
   PutComma;
   Put('{');
   l_First := true;
   l_A := l_Table.TypeByHandle[Ord(i)];
   for j := 0 to l_Table.MaxTypeID do
   begin
    PutComma;
    if (l_A = nil) then
     PutEmpty(mType(i), mType(j))
    else
    begin
     if l_A.IsKindOf(l_Table.TypeByHandle[Ord(j)]) then
      Put('%s // %s -> %s', ['true', mType(i), mType(j)])
     else
      Put('%s // %s -> %s', ['false', mType(i), mType(j)]);
    end;//l_A = nil
   end;//for j
   Put('}');
  end;//for i
  Put(c_EnumEnd, [c_Inherits]);
  Put;
 end;//PutInherrits

 procedure PutBaseChildren;

  procedure PutEmpty(const aType: String; i: Integer);
  begin//PutEmpty
   Put('%s // %s %d -> no children %d', [mType(0), aType, i, 0]);
  end;//PutEmpty

 var
  i       : Integer;
  l_Type  : Tk2Type;
  l_CT    : Tk2Type;
  l_Prop  : Tk2ArrayProperty;
 begin//PutBaseChildren
  Put('// таблица соответствия типа ноды и ее базовых дочерних нод:');
  Put;
  Put('const %s %s[] = {', [c_TypeID, c_BaseChild]);
  l_First := true;
  for i := 0 to l_Table.MaxTypeID do
  begin
   PutComma;
   l_Type := l_Table.TypeByHandle[Ord(i)];
   if (l_Type = nil) then
    PutEmpty(mType(i), Ord(i))
   else
   begin
    l_Prop := l_Type.ArrayProp[k2_tiChildren];
    if (l_Prop = nil) OR (l_Prop.ChildType = nil) then
     PutEmpty(l_Type.AsString, Ord(i))
    else
    begin
     l_CT := l_Prop.ChildType;
     Put('%s // %s %d -> %s %d', [mType(l_CT.ID), l_Type.AsString, Ord(i), l_CT.AsString, l_CT.ID]);
    end;//l_Prop = nil..
   end;//l_Type = nil
  end;//for i
  Put(c_EnumEnd, [c_BaseChild]);
  Put;
 end;//PutBaseChildren

 procedure PutAttrTypes;

  procedure PutEmpty(const aType: String; i: Integer; j: Integer);
  begin//PutEmpty
   Put('%s // %s %d -> no attr %s %d', [mType(0), aType, i, mTagX(j), Ord(j)]);
  end;//PutEmpty

 var
  i       : Integer;
  j       : Tk2TagID;
  l_Type  : Tk2Type;
  l_Prop  : Tk2Prop;
 begin//PutAttrTypes
  Put('// таблица соответствия ноды и типов ее атрибутов:');
  Put;
  Put('const %s %s[%d][%d] = {', [c_TypeID, c_AttrType, l_Table.MaxTypeID+1, Ord(High(Tk2TagID))+1]);
  l_First := true;
  for i := 0 to l_Table.MaxTypeID do
  begin
   PutComma;
   Put('{');
   l_First := true;
   l_Type := l_Table.TypeByHandle[Ord(i)];
   if (l_Type = nil) then
   begin
    for j := Low(Tk2TagID) to High(Tk2TagID) do
    begin
     PutComma;
     PutEmpty(mTypeX(i), Ord(i), Ord(j));
    end;//for j 
   end//l_Type = nil
   else
   begin
    for j := Low(Tk2TagID) to High(Tk2TagID) do
    begin
     PutComma;
     l_Prop := Tk2Prop(l_Type.Prop[Ord(j)]);
     if (l_Prop = nil) then
      PutEmpty(mTypeX(i), Ord(i), Ord(j))
     else
      Put('%s // %s %d -> %s %d', [mType(l_Prop.AtomType.ID), l_Type.AsString, Ord(i), l_Prop.AsString, l_Prop.TagIndex]);
    end;//for j
   end;//l_Type = nil
   Put('}');
  end;//for i
  Put(c_EnumEnd, [c_AttrType]);
  Put;
 end;//PutAttrTypes

 procedure PutAttrDefaultValues;

 const
  c_EmptyValue = 'EmptyValue';
  c_TransparentValue = 'TransparentValue';

  procedure PutEmpty(const aType: String; i: Integer; j: Integer);
  begin//PutEmpty
   Put('%s // %s %d -> no attr %s %d', [c_EmptyValue, aType, i, mTagX(j), Ord(j)]);
  end;//PutEmpty

  function PropValueName(aProp : Tk2Prop): String;
  begin//PropValueName
   Result := '';
   if (aProp <> nil) then
   begin
    if (aProp.DefaultValue <> k2_TransparentValue) AND
       (aProp.DefaultValue <> l3NilLong) then
    begin
     try
      Result := Tk2Type(aProp.TagType).IntToTag(aProp.DefaultValue).AsObject.AsString;
     except
     end;//try..except
    end;//aProp.DefaultValue <> k2_TransparentValue
    if (Result <> '') then
    begin
     if (Result[1] in cc_Digits + [cc_Minus, cc_DollarSign]) then
      Result := ''
     else
     if l3CharSetPresent(PChar(Result), Length(Result), cc_ANSIRussian) then
      Result := ''
    end;//Result <> ''
   end;//aProp <> nil
  end;//PropValueName

 var
  i       : Integer;
  j       : Tk2TagID;
  k       : Integer;
  l_Type  : Tk2Type;
  l_Prop  : Tk2Prop;
  l_KW    : Tl3KeyWords;
  l_Name  : String;
  l_Index : Integer;
 begin//PutAttrDefaultValues
  Put('const long %s = %d; // - значение не задано', [c_EmptyValue, l3NilLong]);
  Put('const long %s = %d; // - тег имеет "прозрачное" значение', [c_TransparentValue, k2_TransparentValue]);
  Put;

  l_KW := Tl3KeyWords.Create;
  try
   l_KW.Duplicates := l3_dupIgnore;
   for i := 0 to l_Table.MaxTypeID do
   begin
    l_Type := l_Table.TypeByHandle[i];
    if (l_Type <> nil) then
    begin
     for j := Low(Tk2TagID) to High(Tk2TagID) do
     begin
      l_Prop := Tk2Prop(l_Type.Prop[Ord(j)]);
      l_Name := PropValueName(l_Prop);
      if (l_Name <> '') then
       l_KW.AddKeyWord(l_Name, l_Prop.DefaultValue);
     end;//for j
    end;//l_Type <> nil
   end;//for i

   for k := 0 to l_KW.Count - 1 do
    Put('const long %s = %d;', [l_KW[k].AsString, l_KW[k].StringID]);

   Put; 

   Put('// таблица соответствия ноды и значений по-умолчанию ее атрибутов:');
   Put;
   Put('const %s %s[%d][%d] = {', ['long', c_AttrDefaultValue, l_Table.MaxTypeID+1, Ord(High(Tk2TagID))+1]);
   l_First := true;
   for i := 0 to l_Table.MaxTypeID do
   begin
    PutComma;
    Put('{');
    l_First := true;
    l_Type := l_Table.TypeByHandle[Ord(i)];
    if (l_Type = nil) then
    begin
     for j := Low(Tk2TagID) to High(Tk2TagID) do
     begin
      PutComma;
      PutEmpty(mTypeX(i), Ord(i), Ord(j));
     end;//for j
    end//l_Type = nil
    else
    begin
     for j := Low(Tk2TagID) to High(Tk2TagID) do
     begin
      PutComma;
      l_Prop := Tk2Prop(l_Type.Prop[Ord(j)]);
      if (l_Prop = nil) then
       PutEmpty(mTypeX(i), Ord(i), Ord(j))
      else
      if (l_Prop.DefaultValue = k2_TransparentValue) then
       Put('%s // %s %d -> %s %d', [c_TransparentValue, l_Type.AsString, Ord(i), l_Prop.AsString, l_Prop.TagIndex])
      else
      if (l_Prop.DefaultValue = l3NilLong) then
      begin
       if l_Table.TypeByHandle[Ord(i)].IsKindOf(k2_typLeafPara) AND
          l_Prop.AtomType.IsKindOf(k2_typStyle) then
          // http://mdp.garant.ru/pages/viewpage.action?pageId=289276029&focusedCommentId=290954895#comment-290954895
        Put('%d // %s %d -> %s %d', [-1, l_Type.AsString, Ord(i), l_Prop.AsString, l_Prop.TagIndex])
       else
        Put('%s // %s %d -> %s %d', [c_EmptyValue, l_Type.AsString, Ord(i), l_Prop.AsString, l_Prop.TagIndex]);
      end//l_Prop.DefaultValue = l3NilLong
      else
      begin
       l_Name := PropValueName(l_Prop);
       if (l_Name <> '') AND
          l_KW.FindData(l_Name, l_Index) AND
          (l_KW[l_Index].StringID = l_Prop.DefaultValue) then
        Put('%s // %s %d -> %s %d', [l_Name, l_Type.AsString, Ord(i), l_Prop.AsString, l_Prop.TagIndex])
       else
        Put('%d // %s %d -> %s %d', [l_Prop.DefaultValue, l_Type.AsString, Ord(i), l_Prop.AsString, l_Prop.TagIndex]);
      end;//l_Prop.DefaultValue = l3NilLong
     end;//for j
    end;//l_Type = nil
    Put('}');
   end;//for i
   Put(c_EnumEnd, [c_AttrDefaultValue]);
   Put;
  finally
   FreeAndNil(l_KW);
  end;//try..finally
 end;//PutAttrDefaultValues

 procedure PutAttrChilds;

  procedure PutEmpty(const aType: String; i: Integer; j: Integer);
  begin//PutEmpty
   Put('%s // %s %d -> no attr %s %d', [mType(0), aType, i, mTagX(j), Ord(j)]);
  end;//PutEmpty

 var
  i       : Integer;
  j       : Tk2TagID;
  l_Type  : Tk2Type;
  l_Prop  : Tk2Prop;
  l_CProp : Tk2ArrayProperty;
 begin//PutAttrChilds
  Put('// таблица соответствия ноды и типов детей ее атрибутов:');
  Put;
  Put('const %s %s[%d][%d] = {', [c_TypeID, c_AttrChild, l_Table.MaxTypeID+1, Ord(High(Tk2TagID))+1]);
  l_First := true;
  for i := 0 to l_Table.MaxTypeID do
  begin
   PutComma;
   Put('{');
   l_First := true;
   l_Type := l_Table.TypeByHandle[Ord(i)];
   if (l_Type = nil) then
   begin
    for j := Low(Tk2TagID) to High(Tk2TagID) do
    begin
     PutComma;
     PutEmpty(mTypeX(i), Ord(i), Ord(j));
    end;//for j 
   end//l_Type = nil
   else
   begin
    for j := Low(Tk2TagID) to High(Tk2TagID) do
    begin
     PutComma;
     l_Prop := Tk2Prop(l_Type.Prop[Ord(j)]);
     if (l_Prop = nil) then
      PutEmpty(mTypeX(i), Ord(i), Ord(j))
     else
     begin
      l_CProp := Tk2Type(l_Prop.AtomType).ArrayProp[k2_tiChildren];
      if (l_CProp = nil) then
       PutEmpty(mTypeX(i), Ord(i), Ord(j))
      else
       Put('%s // %s %d -> %s %d', [mType(l_CProp.ChildType.ID), l_Type.AsString, Ord(i), l_Prop.AsString, l_Prop.TagIndex]);
     end;//l_Prop = nil
    end;//for j
   end;//l_Type = nil
   Put('}');
  end;//for i
  Put(c_EnumEnd, [c_AttrChild]);
  Put;
 end;//PutAttrChilds

 procedure PutIsType(const aName: String; aType: Tk2Type; aComment: String);
 var
(*  i       : Integer;
  l_Type  : Ik2Type;*)
  l_Name  : String;
 begin//PutIsType
  l_Name := 'is_' + aName;
  Put('inline bool %s (int type) {', [l_Name]);
  Put('// %s', [aComment]);
  Put(' return %s[%s][%s];', [c_Inherits, 'type', mType(aType.ID)]);
(*  Put(' if (');
  l_First := true;
  for i := 0 to l_Table.MaxTypeID do
  begin
   l_Type := l_Table[Ord(i)];
   if (l_Type <> nil) AND l_Type.InheritsFrom(aType) then
   begin
    PutOR;
    Put(' %s == type', [mType(i)]);
   end;//l_Type <> nil
  end;//for i
  Put(' ) {');
  Put('     return true;');
  Put(' }');
  Put(' return false;');*)
  Put('} // %s', [l_Name]);
  Put;
 end;//PutIsType;

 procedure WriteAttrs;
 var
  l_T : Tk2TagID;
 begin//WriteAttrs
  Put('// Идентификаторы атрибутов');
  Put;
  for l_T := Low(l_T) to High(l_T) do
   Put('CONST evd::ti_%s %d', [mTagX(Ord(l_T)), Ord(l_T)]);
 end;//WriteAttrs

 procedure WriteTypes;
 var
  l_T : Integer;
 begin//WriteTypes
  Put('// Идентификаторы типов');
  Put;
  for l_T := 0 to l_Table.MaxTypeID do
   Put('CONST evd::%s %d', [mType(l_T), l_T]);
 end;//WriteTypes

 procedure WriteStyles;
 
  function OutStyle(aStyle: Pl3Variant; Index: Long): Bool;
  var
   l_Tag : Tl3Tag;
   l_H   : Integer;
  begin//OutStyle
   Result := true;
   l_Tag := aStyle^;
   l_H := -l_Tag.IntA[k2_tiHandle];
   if (l_H >= Low(StandardNames)) AND (l_H <= High(StandardNames)) then
   begin
    Put('CONST evd::sa_%s %d', [StandardNames[l_H], -l_H]);
    Put('// %s', [l_Tag.StrA[k2_tiName]]);
   end;//l_H >= Low(StandardNames)
  end;//OutStyle

  function OutStyle1(aStyle: Pl3Variant; Index: Long): Bool;
  var
   l_Tag : Tl3Tag;
   l_H   : Integer;
  begin//OutStyle1
   Result := true;
   l_Tag := astyle^;
   l_H := l_Tag.IntA[k2_tiHandle];
   Put('CONST evd::стиль:"%s" %d', [l_Tag.StrA[k2_tiName], l_H]);
  end;//OutStyle1

 var
  l_SI : TevStyleInterface;
 begin//WriteTypes
  Put('// Идентификаторы стилей');
  Put;
  l_SI := TevStyleInterface.Make;
  try
   l_SI.IterateF(l3L2IA(@OutStyle));
   Put;
   l_SI.IterateF(l3L2IA(@OutStyle1));
  finally
   FreeAndNil(l_SI);
  end;//try..finally
 end;//WriteTypes

 procedure WriteControlParaAttrValues;
 var
  l_CP : Tl3Variant;
  l_CT : TevControlType;
  l_TID : Tk2TagID;
  l_Prop : Tk2CustomProperty;
 begin//WriteControlParaAttrValues
  Put('// Значения предопределённых атрибутов параграфов-контролов');
  Put;
  l_CP := k2_typControlPara.MakeTag.AsObject;
  try
   for l_TID := Low(l_TID) to High(l_TID) do
   begin
    l_Prop := Tk2CustomProperty(Tk2Type(l_CP.TagType).Prop[Ord(l_TID)]);
    if (l_Prop <> nil) then
    begin
     if l_Prop.ReadOnly then
     begin
      l_First := true;
      Put('const long ControlPara_%s_Values [] = {', [l_Prop.AsString]);
      for l_CT := Low(l_CT) to High(l_CT) do
      begin
       PutComma;
       l_CP.IntA[k2_tiType] := Ord(l_CT);
       Put('%s', [l_CP.StrA[Ord(l_TID)]]);
       //Put('%d', [l_CP.IntA[Ord(l_TID)]]);
      end;//for l_CT
      Put(c_EnumEnd, [Format('ControlPara_%s_Values', [l_Prop.AsString])]);
      Put;
     end;//l_Prop
    end;//l_Prop <> nil
   end;//for l_TID
  finally
   l_CP := nil;
  end;//try..finally
 end;//WriteControlParaAttrValues

begin
 l_Out := Tl3DOSFiler.Make('evddata.h', l3_fmWrite, false);
 try
  l_Out.Open;
  try
   l_Table := k2.TypeTable;
   if (l_Table = nil) then
    WriteLn('No tag table defined')
   else
   begin
    Put('#ifndef EVD_H__');
    Put('#define EVD_H__');
    Put;
    Put('// !!! Это автосгенерированный файл. Не добавляйте сюда ничего руками !!!');
    Put;
    Put('// константы для работы с логическим представлением формата evd:');
    Put;
    Put('namespace evd {');
    Put;
    Put('// имена тегов:');
    Put('extern const char* TagName[];');
    Put;
    Put('// имена типов:');
    Put('extern const char* TypeName[];');
    Put;
    //PutVect('TagName', TypeInfo(Tk2TagID), 'имена тегов', '_k2_ti', '');
    PutEnum('TagID', TypeInfo(Tk2TagID), 'Идентификаторы тегов', '_k2_ti', 'ti_');
    PutTypes;
    PutDefaultChildren;
    PutInherrits;
    PutBaseChildren;
    PutAttrTypes;
    PutAttrDefaultValues;
    PutAttrChilds;
    //PutEnum('', TypeInfo(TevIndentType), 'Выравнивание параграфа', 'ev_it', 'jt_');
    //PutEnum('', TypeInfo(TevSubPlace), 'Место отображения метки', 'ev_sp', 'sp_');
    //PutEnum('', TypeInfo(TevVerticalAligment), 'Выравнивание по вертикали', 'ev_val', 'val_');
    Put;
    (*Put('// стили для разметки параграфов:');
    Put;
    Put('const int sa_Empty           = %d; // "Пустое" значение.', [ev_saEmpty]);
    Put('const int sa_TxtNormalANSI   = %d; // Нормальный.', [ev_saTxtNormalANSI]);
    Put('const int sa_TxtNormalOEM    = %d; // Нормальный (OEM).', [ev_saTxtNormalOEM]);
    Put('const int sa_TxtHeader1      = %d; // Заголовок 1.', [ev_saTxtHeader1]);
    Put('const int sa_TxtHeader2      = %d; // Заголовок 2.', [ev_saTxtHeader2]);
    Put('const int sa_TxtHeader3      = %d; // Заголовок 3.', [ev_saTxtHeader3]);
    Put('const int sa_TxtHeader4      = %d; // Заголовок 4.', [ev_saTxtHeader4]);
    Put('const int sa_TxtOutOfDate    = %d; // Утратил силу.', [ev_saTxtOutOfDate]);
    Put('const int sa_HyperLink       = %d; // Гипертекстовая ссылка.', [ev_saHyperLink]);
    Put('const int sa_TxtComment      = %d; // Комментарий.', [ev_saTxtComment]);
    Put('const int sa_ColorSelection  = %d; // Цветовое выделение.', [ev_saColorSelection]);
    Put('const int sa_HyperLinkCont   = %d; // Продолжение ссылки.', [ev_saHyperLinkCont]);
    Put('const int sa_ANSIDOS         = %d; // Моноширинный.', [ev_saANSIDOS]);
    Put('const int sa_FoundWords      = %d; // Найденные слова.', [ev_saFoundWords]);
    Put('const int sa_NormalNote      = %d; // Нормальный (справка).', [ev_saNormalNote]);
    Put('const int sa_ArticleHeader   = %d; // Заголовок статьи.', [ev_saArticleHeader]);
    Put('const int sa_ToLeft          = %d; // Прижатый влево.', [ev_saToLeft]);
    Put('const int sa_NormalTable     = %d; // Нормальный для таблиц.', [ev_saNormalTable]);
    Put('const int sa_NormalSBSLeft   = %d; // Нормальный для левых частей SBS.', [ev_saNormalSBSLeft]);
    Put('const int sa_NormalSBSRight  = %d; // Нормальный для правых частей SBS.', [ev_saNormalSBSRight]);
    Put('const int sa_NormalTableList = %d; // Нормальный для списков в виде таблиц.', [ev_saNormalTableList]);
    Put('const int sa_TechComment     = %d; // Технический комментарий.', [ev_saTechComment]);
    Put('const int sa_VersionInfo     = %d; // Информация о версии.', [ev_saVersionInfo]);
    Put('const int sa_UserComment     = %d; // Комментарий пользователя (для Гаранта 6х).', [ev_saUserComment]);
    Put('const int sa_Contents        = %d; // Оглавление (для Гаранта 6х).', [ev_saContents]);
    Put('const int sa_NotApplied      = %d; // Не вступил в силу.', [ev_saNotApplied]);
    Put('const int sa_DictEntry       = %d; // Словарная статья.', [ev_saDictEntry]);
    Put;*)
    Put('// типы закладок:');
    Put;
    Put('enum BookmarkType {');
    Put('bt_Unknown = -1');
    Put(', bt_Other = 1');
    //Put(', bt_History = 2');
    Put(', bt_Self = 4');
    Put('};');
    Put;
    (*Put('// идентификаторы слоев оформления:');
    Put;
    Put('enum SegmentsLayer {');
    Put('sl_View = %d // %s', [Ord(ev_slView), 'слой оформления']);
    Put(', sl_Hyperlinks = %d // %s', [Ord(ev_slHyperlinks), 'слой гиперссылок']);
    Put(', sl_FoundWords = %d // %s', [Ord(ev_slFoundWords), 'слой слов найденных по контексту']);
    Put(', sl_Found = %d // %s', [Ord(ev_slFound), 'слой найденных слов (зарезервированно)']);
    Put('};');
    Put;*)
    Put('// логическое представление здесь кончается');
    Put;
    Put('// helpers functions');
    Put;
    PutIsType('leaf_para', k2_typLeafPara, 'Определяет, что параграф листьевой');
    PutIsType('para_list', k2_typParaList, 'Определяет, что параграф является списком параграфов');
    PutIsType('para', k2_typPara, 'Определяет, что тег является параграфом');
    PutIsType('text_para', k2_typTextPara, 'Определяет, что параграф является текстовым');
    PutIsType('styled_leaf_para', k2_typStyledLeafPara, 'Определяет, что параграф является листьевым и имеет стиль');
    Put('// helpers functions end');
    Put;
    (*Put('// константы для работы с физическим представлением формата evd:');
    Put;
    Put('typedef unsigned char  uInt8;');
    Put('typedef unsigned short uInt16;');
    Put('typedef unsigned long  uInt32;');
    Put('typedef char  sInt8;');
    Put('typedef short sInt16;');
    Put('typedef long  sInt32;');
    Put;
    PutEnum('', TypeInfo(TevTypeID), 'Типы тегов для записи evd в поток');
    Put('const uInt16 idFinish       = 0x%x; // закрывающая скобка тега', [unpack_idFinish]);
    Put('const uInt16 idMask         = 0x%x; // маска распределения памяти', [unpack_idMask]);
    Put('const uInt16 idChildren     = 0x%x; // признак начала списка дочерних тегов', [unpack_idChildren]);
    Put('const uInt16 idRollback     = 0x%x; // признак отката тега', [unpack_idRollback]);
    Put('const uInt16 idMaskEx       = 0x%x; // расширенная маска распределения памяти', [unpack_idMaskEx]);
    Put('const uInt16 idLink         = 0x%x; // ссылка на объект в другом IStorage', [unpack_idLink]);
    Put('const uInt16 idDefaultChild = 0x%x; // дочерний тег с типом по умолчанию', [unpack_idDefaultChild]);
    Put;
    Put('const uInt16 idKey1 = 0x%x; // {-''%%e''} признак завершения бинарных данных.', [unpack_idKey1]);
    Put('const uInt16 idKey2 = 0x%x; // {-''%%E''} признак завершения бинарных данных.', [unpack_idKey2]);
    Put('const uInt16 idKey3 = 0x%x; // {-''%%b''} признак начала бинарных данных.', [unpack_idKey3]);
    Put('const uInt16 idKey4 = 0x%x; // {-''%%B''} признак начала бинарных данных.', [unpack_idKey4]);
    Put;
    Put('// физическое представление здесь кончается');
    Put;*)
    WriteControlParaAttrValues;
    Put('} // namespace');
    Put;
    Put('#endif // EVD_H__');
   end;//l_TypeTable = nil
  finally
   l_Out.Close;
  end;//try..finally
 finally
  l3Free(l_Out);
 end;//try..finally
 l_Out := Tl3DOSFiler.Make('evddata.cpp', l3_fmWrite, false);
 try
  l_Out.Open;
  try
    Put('// !!! Это автосгенерированный файл. Не добавляйте сюда ничего руками !!!');
    Put;
    Put('#include "ace/ACE.h"');
    Put('#include "common/components/rtl/Garant/EVD/evddata.h"');
    Put('// константы для работы с логическим представлением формата evd:');
    Put;
    Put('namespace evd {');
    Put;
    PutVect('TagName', TypeInfo(Tk2TagID), 'имена тегов', '_k2_ti', '');
    PutTypeVect('TypeName', 'имена типов');
    Put('} // namespace');
    Put;
  finally
   l_Out.Close;
  end;//try..finally
 finally
  l3Free(l_Out);
 end;//try..finally
 l_Out := Tl3DOSFiler.Make('EVDSchema.script', l3_fmWrite, false);
 try
  l_Out.Open;
  try
   Put('// !!! Это автосгенерированный файл. Не добавляйте сюда ничего руками !!!');
   Put;
   WriteAttrs;
   Put;
   WriteTypes;
   Put;
   WriteStyles;
  finally
   l_Out.Close;
  end;//try..finally
 finally
  l3Free(l_Out);
 end;//try..finally
end;

begin
 DoOut;
end.
..\..\GarORB\tfwDefine.inc
{$Include afwDefine.inc}
..\..\HT\htDefineDA.inc
{$Include daDefine.inc}
..\..\K2\k2Define.inc
{$IfNDef k2Define}
{$Define k2Define}
{ Библиотека "Эверест"  }
{ Автор: Люлин А.В. ©   }
{ Модуль: k2Define - }
{ Начат: 12.04.98 11:28 }
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.67  2012/10/26 19:41:55  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.66  2012/10/26 19:12:33  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.65  2012/06/05 13:10:46  voba
// no message
//
// Revision 1.64  2012/02/03 17:09:25  lulin
// {RequestLink:333548940}
// - рисуем изменения Жени на модели.
//
// Revision 1.63  2011/09/19 12:21:24  lulin
// - директива k2GeneratorIsNotComponent.
//
// Revision 1.62  2009/07/23 17:28:54  lulin
// - убираем ненужный запрос интерфейса.
// - правим наследование у SomeDataContainer.
//
// Revision 1.61  2009/03/05 16:20:42  lulin
// - <K>: 137470629. Убрана ненужная ссылка на тип по идентификатору.
//
// Revision 1.60  2009/02/25 12:44:16  lulin
// - <K>: 90441983. Чистка кода для переноса на модель.
//
// Revision 1.59  2009/02/25 12:04:14  lulin
// - <K>: 90441983. Чистка кода для переноса на модель.
//
// Revision 1.58  2008/10/09 13:37:42  lulin
// - <K>: 121145547.
//
// Revision 1.57  2008/09/16 12:19:41  lulin
// - переносим TnevParaList на модель.
//
// Revision 1.56  2008/04/15 09:03:23  lulin
// - правим название директив - чтобы соответствовали смыслу.
//
// Revision 1.55  2008/04/15 08:58:47  lulin
// - восстанавливаем компилируемость Немезиса.
//
// Revision 1.54  2007/12/05 12:35:08  lulin
// - вычищен условный код, составлявший разницу ветки и Head'а.
//
// Revision 1.53  2007/09/14 13:26:19  lulin
// - объединил с веткой B_Tag_Clean.
//
// Revision 1.52.2.1  2007/09/13 10:52:04  lulin
// - bug fix: не собирался Немезис.
//
// Revision 1.52  2007/09/05 11:57:55  lulin
// - сделана возможность определять проектные директивы в специально отведенном файле.
//
// Revision 1.51  2007/09/03 10:46:48  lulin
// - уменьшаем число параметров.
//
// Revision 1.50  2007/08/30 10:09:21  lulin
// - убираем ненужную функцию поиска.
//
// Revision 1.49  2007/08/29 15:33:21  lulin
// - cleanup.
//
// Revision 1.48  2007/08/28 15:27:08  lulin
// - cleanup.
//
// Revision 1.47  2007/08/13 17:41:21  lulin
// - вычищена ненужная функциональность по построению дерева тегов.
//
// Revision 1.46  2007/08/13 17:30:59  lulin
// - cleanup.
//
// Revision 1.45  2007/02/20 13:03:43  lulin
// - выключаем ненужную функциональность.
//
// Revision 1.44  2006/11/25 16:50:32  lulin
// - удалена запись,чтение маски заполненных тегов.
//
// Revision 1.43  2006/11/03 11:00:44  lulin
// - объединил с веткой 6.4.
//
// Revision 1.42.14.1  2006/10/26 09:10:21  lulin
// - используем "родную" директиву.
//
// Revision 1.42  2006/01/18 08:54:36  lulin
// - изыскания на тему прямой установки целочисленных атрибутов, без преобразования их к тегам.
//
// Revision 1.41  2006/01/16 17:05:58  lulin
// - отключил использование безоберточных строк.
//
// Revision 1.40  2006/01/16 16:41:44  lulin
// - сделана возможность работать со строками без теговых оберток (почему-то на производительность не повлияло).
//
// Revision 1.39  2005/06/30 16:38:22  lulin
// - выключено кеширование атрибутов тегов, как вредное и приводящее к лишней нотификации и в силу этого к замедлению при загрузке документа.
//
// Revision 1.38  2005/06/23 13:42:57  lulin
// - буфер документа переехал в папку K2.
//
// Revision 1.37  2005/06/22 17:14:57  lulin
// - cleanup.
//
// Revision 1.36  2005/04/28 15:04:09  lulin
// - переложил ветку B_Tag_Box в HEAD.
//
// Revision 1.35  2005/04/22 12:53:27  vaso
// new define: ARM
//
// Revision 1.34.2.1  2005/04/25 09:03:46  lulin
// - объединил с HEAD.
//
// Revision 1.35  2005/04/22 12:53:27  vaso
// new define: ARM
//
// Revision 1.34  2005/04/19 09:34:17  lulin
// - убираем дерево тегов в релизном варианте.
//
// Revision 1.33  2005/04/15 08:59:57  lulin
// - теперь держим ссылку на тег, а не собственно тег.
//
// Revision 1.32  2005/04/01 14:48:52  lulin
// - доточка напильником - чтобы "парень" скомпилировался.
//
// Revision 1.31  2005/03/31 16:13:15  lulin
// - new methods: InevPara.OwnerTag, OwnerPara.
//
// Revision 1.30  2005/03/31 12:34:15  lulin
// - new unit: nevParaList.
//
// Revision 1.29  2004/08/03 07:52:37  voba
// - add ARCHI define
//
// Revision 1.28  2004/06/22 13:47:27  law
// - для DesignTimeLibrary включил директиву _k2NoTagTree.
//
// Revision 1.27  2004/06/01 08:04:08  law
// - расставлены define'ы для _ALCU.
//
// Revision 1.26  2004/05/31 17:26:31  law
// - new define: _k2CacheTagChildren.
//
// Revision 1.25  2004/05/31 10:14:57  law
// - define перенесен в правильное место (evDefine.inc).
//
// Revision 1.24  2004/05/27 12:13:52  law
// - для Немезиса включил директиву _k2CacheTagObject.
//
// Revision 1.23  2004/03/24 09:26:14  law
// - new behavior: пропускаем единичные ссылки с DocID = 0.
//
// Revision 1.22  2004/03/16 18:13:04  law
// - change: для Немезиса выключена директива _k2GeneratorIsComponent - должно в общем жрать поменьше ресурсов.
//
// Revision 1.21  2003/09/23 11:44:14  law
// - new define: _k2CacheTagObject - пока не работает (эксперименты с кешом).
//
// Revision 1.20  2003/07/04 19:39:56  law
// - оптимизация переформатирования текста в фоновом режиме (до конца не доделано, но светлые мысли есть).
//
// Revision 1.19  2003/04/19 12:48:25  law
// - new directive: _evForEEGen.
//
// Revision 1.18  2003/04/19 12:30:39  law
// - new file: ddDefine.inc.
//
// Revision 1.17  2003/04/19 11:24:48  law
// - new file: vtDefine.inc.
//
// Revision 1.16  2003/03/17 16:17:25  law
// - bug fix: new directive evNotNeedAddMask.
//
// Revision 1.15  2002/12/26 15:11:34  law
// - new dll: собрана более легкая версия dll-печати.
//
// Revision 1.14  2002/12/26 14:35:25  law
// - new dll: собрана более легкая версия dll-печати.
//
// Revision 1.13  2002/03/26 16:31:57  law
// - cleanup.
//
// Revision 1.12  2002/03/18 13:12:52  law
// - new directive: _k2NotForEditor.
//
// Revision 1.11  2002/01/08 13:15:52  law
// - new behavior: сделано отключение _k2TagTree для EverestLite.
//
// Revision 1.10  2001/12/24 13:20:40  law
// - cleanup.
//
// Revision 1.9  2001/09/10 09:51:45  law
// - new define: добавлена опция _k2NoTagTree.
//
// Revision 1.8  2001/05/31 08:06:42  law
// - cleanup: убрана запись компонент.
//
// Revision 1.7  2001/04/02 11:45:52  law
// - сделано выключение директивы _k2TagTree при включенной директиве _EverestRelease.
//
// Revision 1.6  2001/02/28 13:15:02  law
// - расширен интерфейс Ik2PropertyBag.
//
// Revision 1.5  2000/12/15 15:18:58  law
// - вставлены директивы Log.
//

{$Include l3Define.inc }

{$IfDef ALCU}
 {.$Define k2NotForEditor}
{$EndIf ALCU}

{$IfNDef k2NotForEditor}
 {$Define k2ForEditor}
{$EndIf  k2NotForEditor}

{$IfNDef k2GeneratorIsNotComponent}
 {$Define k2GeneratorIsComponent}
{$EndIf k2GeneratorIsNotComponent}

{$IfDef l3ConsoleApp}
 {$Undef k2ForEditor}
 {$Undef k2GeneratorIsComponent}
{$EndIf l3ConsoleApp}

{$IfDef Nemesis}
 {$Undef k2GeneratorIsComponent}
{$EndIf Nemesis}

{.$IfDef Archi}
 {.$I ArchiDefine.inc}
{.$EndIf Archi}

{$IfDef UseProjectDefine}
 {$I ProjectDefine.inc}
{$EndIf UseProjectDefine}

{$EndIf  k2Define}
..\..\L3\l3Define.inc
{$IfNDef l3Define}
{$Define l3Define}
{ Библиотека "Эверест"    }
{ Автор: Люлин А.В. ©     }
{ Модуль: l3Define -      }
{ Начат: 12.04.1998 11:28 }
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.156  2016/03/03 15:14:18  lulin
// - боремся с утечками.
//
// Revision 1.155  2015/09/23 15:46:19  lulin
// - оптимизируем.
//
// Revision 1.154  2015/08/07 12:15:55  lulin
// - делаем консольную запускалку.
//
// Revision 1.153  2015/08/07 11:53:38  lulin
// - делаем консольную запускалку.
//
// Revision 1.152  2015/08/07 11:43:07  lulin
// - делаем консольную запускалку.
//
// Revision 1.151  2015/08/07 11:25:50  lulin
// - делаем консольную запускалку.
//
// Revision 1.150  2015/06/03 12:29:28  lulin
// - пытаемся разрулить зависимости.
//
// Revision 1.149  2015/06/02 17:05:54  lulin
// - рисуем на модели.
//
// Revision 1.148  2015/06/02 16:54:35  lulin
// - рисуем на модели.
//
// Revision 1.147  2015/06/02 12:33:54  lulin
// - bug fix: не собирались утилиты.
//
// Revision 1.146  2015/05/28 09:56:13  lulin
// - чистим код.
//
// Revision 1.145  2015/04/13 10:22:35  lulin
// - перегенерация.
//
// Revision 1.144  2015/02/26 13:35:27  lulin
// - правильнее определяем, что у нас оболочка F1.
//
// Revision 1.143  2014/12/11 09:55:24  morozov
// {RequestLink: 580710291}
//
// Revision 1.142  2014/11/27 13:16:15  morozov
// {RequestLink: 578891817} - убрал l3UseSSE для D+ чтоб не смазывать картину лишними exception'ами
//
// Revision 1.141  2014/11/06 11:53:37  lulin
// - перетряхиваем код.
//
// Revision 1.140  2014/11/05 16:59:29  lulin
// - перетряхиваем код.
//
// Revision 1.139  2014/09/22 14:34:44  lulin
// - аккуратнее работаем с логом.
//
// Revision 1.138  2014/04/08 14:17:07  lulin
// - переходим от интерфейсов к объектам.
//
// Revision 1.137  2013/12/25 15:10:36  lulin
// {RequestLink:509706011}
// - перетрясаем модель.
//
// Revision 1.136  2013/07/10 16:34:22  lulin
// - включаем коробочные битовые массивы для XE.
//
// Revision 1.135  2013/07/01 07:18:02  lulin
// - пытаемся включить кеш объектов (пока неудачно).
//
// Revision 1.134  2013/07/01 06:12:21  lulin
// - чистка кода.
//
// Revision 1.133  2013/05/29 16:13:25  lulin
// - портируем под XE4.
//
// Revision 1.132  2013/05/24 15:59:50  lulin
// - пытаемся портироваться под XE4.
//
// Revision 1.131  2013/04/09 17:40:34  lulin
// - пытаемся отладиться под XE.
//
// Revision 1.130  2013/04/08 18:10:29  lulin
// - пытаемся отладиться под XE.
//
// Revision 1.129  2013/04/08 14:50:41  lulin
// - портируем.
//
// Revision 1.128  2013/04/04 11:22:01  lulin
// - портируем.
//
// Revision 1.127  2013/04/03 15:03:20  lulin
// - портируем.
//
// Revision 1.126  2013/02/26 08:57:32  dinishev
// {Requestlink:431386215}. Не запускались.
//
// Revision 1.125  2012/11/02 07:55:21  lulin
// - оказывается, что это было не лишнее.
//
// Revision 1.124  2012/11/02 07:48:08  lulin
// - не цепляем лишние файлы.
//
// Revision 1.123  2012/10/29 13:29:04  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.122  2012/10/26 19:12:54  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.121  2012/06/05 13:10:49  voba
// no message
//
// Revision 1.120  2012/02/24 12:15:22  dinishev
// Bug fix: не запускался тестовый Архивариус.
//                                              
// Revision 1.119  2012/02/24 07:40:21  lulin
// - кешируем парсер.
//
// Revision 1.118  2011/09/19 10:49:58  lulin
// - делаем Filer'ам возможность быть не компонентами и кешируемыми.
//
// Revision 1.117  2011/09/19 10:12:47  lulin
// - делаем Filer'ам возможность быть не компонентами и кешируемыми.
//
// Revision 1.116  2011/09/19 09:35:07  lulin
// - делаем возможность выключить.
//
// Revision 1.115  2011/05/06 14:28:16  lulin
// - правим IfDef'ы.
//
// Revision 1.114  2011/01/21 15:35:39  dinishev
// [$185830965]
//
// Revision 1.113  2010/12/10 12:31:30  lulin
// - bug fix: не собирались с директивой _nsTool.
//
// Revision 1.112  2010/10/01 09:38:56  lulin
// {RequestLink:235062187}.
// - включаем проверки.
//
// Revision 1.111  2010/01/22 17:39:43  lulin
// - делаем тест для "бубны".
//
// Revision 1.110  2009/12/23 16:13:08  lulin
// - делаем тест загрузкии скроллирования ГК.
//
// Revision 1.109  2009/12/14 14:24:04  lulin
// - чистка кода.
//
// Revision 1.108  2009/07/23 08:15:07  lulin
// - вычищаем ненужное использование процессора операций.
//
// Revision 1.107  2009/02/25 12:04:16  lulin
// - <K>: 90441983. Чистка кода для переноса на модель.
//
// Revision 1.106  2008/08/26 09:34:45  lulin
// - чистка кода.
//
// Revision 1.105  2008/08/11 13:28:30  lulin
// - <K>: 96484293.
//
// Revision 1.104  2008/08/01 14:43:47  dinishev
// <K> : 77235623
//
// Revision 1.103  2008/04/15 09:57:21  lulin
// - из-за дубликатов Архивариус не собирался.
//
// Revision 1.102  2008/04/15 09:03:25  lulin
// - правим название директив - чтобы соответствовали смыслу.
//
// Revision 1.101  2008/04/15 08:58:48  lulin
// - восстанавливаем компилируемость Немезиса.
//
// Revision 1.100  2008/02/13 20:20:15  lulin
// - <TDN>: 73.
//
// Revision 1.99  2007/12/05 12:35:11  lulin
// - вычищен условный код, составлявший разницу ветки и Head'а.
//
// Revision 1.98  2007/09/05 12:28:28  lulin
// - директивы перенесены в файл с директивами.
//
// Revision 1.97  2007/09/05 11:57:57  lulin
// - сделана возможность определять проектные директивы в специально отведенном файле.
//
// Revision 1.96  2007/08/30 18:05:07  lulin
// - избавляемся от лишнего кода по очистке строк.
//
// Revision 1.95  2007/08/30 15:00:45  lulin
// - bug fix: не проверяли конец файла.
//
// Revision 1.94  2007/08/30 10:09:23  lulin
// - убираем ненужную функцию поиска.
//
// Revision 1.93  2007/08/29 16:16:59  lulin
// - cleanup.
//
// Revision 1.92  2007/08/29 15:33:23  lulin
// - cleanup.
//
// Revision 1.91  2007/08/21 13:02:52  lulin
// - избавляемся от предупреждений компилятора.
//
// Revision 1.90  2007/08/21 11:39:52  lulin
// - избавляемся от предупреждений компилятора.
//
// Revision 1.89  2007/08/14 10:48:00  lulin
// - без отладочной информации отключаем трассировку объектов и памяти для всех проектов.
//
// Revision 1.88  2007/08/13 17:23:34  lulin
// - cleanup.
//
// Revision 1.87  2007/07/24 10:23:51  lulin
// - cleanup.
//
// Revision 1.86  2007/01/17 11:28:52  lulin
// - для "парня" не сортиреум кеш объектов.
//
// Revision 1.85  2006/12/18 09:40:27  lulin
// - cleanup.
//
// Revision 1.84  2006/12/11 12:02:49  lulin
// - cleanup.
//
// Revision 1.83  2006/12/07 09:55:38  lulin
// - не выключаем насильно сбор статистики.
//
// Revision 1.82  2006/11/30 14:47:26  lulin
// - cleanup.
//
// Revision 1.81  2006/08/29 11:46:18  lulin
// - bug fix: лог не разделял файл между процессами.
//
// Revision 1.80  2006/06/06 10:38:14  lulin
// - по-другому отключаем нотификацию о смене масштаба - в Design-time.
//
// Revision 1.79  2006/04/19 10:48:32  lulin
// - выключаем всякую трассировку в Design-Time.
//
// Revision 1.78  2006/03/06 12:02:29  oman
// - new behavior: контроль провисания ресурсов при добавлении объектов в кэш
//
// Revision 1.77  2006/02/21 09:13:24  lulin
// - new behavior: рассчитываем новый Top при смене положения курсора, без перепривязывания параграфа к новому View.
//
// Revision 1.76  2006/02/08 15:35:40  lulin
// - делаем в Эвересте "настоящее" выделение.
//
// Revision 1.75  2006/01/18 10:38:23  lulin
// - bug fix: не компилировалось тестовое приложение.
//
// Revision 1.74  2006/01/10 10:22:56  lulin
// - bug fix: отвалилась перерисовка при смене масштаба.
//
// Revision 1.73  2005/11/16 06:52:55  lulin
// - bug fix: не компилировалась библиотека в HEAD.
//
// Revision 1.72  2005/11/09 15:28:41  lulin
// - базовые интерфейсы перенесены в правильный модуль.
//
// Revision 1.71  2005/10/11 10:34:29  lulin
// - bug fix: не собиралась библиотека.
// - панель Preview переехала в библиотеку VT.
//
// Revision 1.70  2005/09/08 08:40:01  narry
// - update: изменение define для _ALCU
//
// Revision 1.69  2005/08/04 09:20:45  migel
// - change: перетащили `DebugStackTrace` из `m0define.inc` в `l3define.inc`.
//
// Revision 1.68  2005/05/27 12:24:41  lulin
// - системные модули, не имеющие отношения к Эвересту переехали в L3.
//
// Revision 1.67  2005/05/26 16:29:57  lulin
// - директивы, настраивающие канву вывода перемещены в библиотеку L3.
//
// Revision 1.66  2005/05/24 09:22:46  lulin
// - удалены ненужные директивы.
//
// Revision 1.65  2005/05/19 11:37:09  lulin
// - для _nsTool включаем l3ConsoleApp.
//
// Revision 1.64  2005/05/18 17:45:36  lulin
// - bug fix: директивы были вне скобок.
//
// Revision 1.63  2005/04/28 15:04:11  lulin
// - переложил ветку B_Tag_Box в HEAD.
//
// Revision 1.62  2005/04/22 12:53:05  vaso
// new define: ARM
//
// Revision 1.61.2.2  2005/04/26 10:51:12  lulin
// - new define: _l3SortedCache.
//
// Revision 1.61.2.1  2005/04/25 09:03:48  lulin
// - объединил с HEAD.
//
// Revision 1.62  2005/04/22 12:53:05  vaso
// new define: ARM
//
// Revision 1.61  2005/04/19 12:51:40  lulin
// - заточки для тестирования.
//
// Revision 1.60  2005/04/19 10:19:40  lulin
// - для тестовых приложений под Define _nsTest добавлены "правильные" директивы компиляции.
//
// Revision 1.59  2005/04/18 15:04:05  lulin
// - учитываем опцию D+ и только для нее включаем "все".
//
// Revision 1.58  2005/04/16 10:41:10  lulin
// - для опции D- выключаем всякую трассировку.
//
// Revision 1.57  2005/04/15 08:59:59  lulin
// - теперь держим ссылку на тег, а не собственно тег.
//
// Revision 1.56  2005/03/15 10:30:31  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.55  2004/11/10 08:02:41  lulin
// - выключены "лишние" директивы.
//
// Revision 1.54  2004/10/08 08:18:46  lulin
// - для Немезиса отключена директива l3TraceMemAllocStat.
//
// Revision 1.53  2004/10/08 08:16:01  lulin
// - new define: l3NotTraceMemAllocStat.
//
// Revision 1.52  2004/10/08 06:36:38  lulin
// - bug fix: для Design-Time не подкладываем свой менеджер памяти.
//
// Revision 1.51  2004/10/07 09:21:21  lulin
// - new directive: l3TraceMemAllocStat.
//
// Revision 1.50  2004/10/07 07:27:43  lulin
// - new: сделана возможность следить за выделением/освобождением памяти стандартными средствами.
//
// Revision 1.49  2004/09/15 09:51:47  lulin
// - перевел реализацию IUnknown на "шаблонную" реализацию.
//
// Revision 1.48  2004/09/08 11:22:55  lulin
// - new define: _l3NoTrace.
// - new define: l3TraceObjects.
//
// Revision 1.47  2004/09/02 11:57:03  law
// - cleanup.
//
// Revision 1.46  2004/08/05 11:31:22  demon
// - fix: показ Warning'ов для проекта Немезис
//
// Revision 1.45  2004/08/03 07:52:40  voba
// - add _ARCHI define
//
// Revision 1.44  2004/06/01 07:48:41  law
// - new defines: l3AssertSimpleMMCanFreeBlocks, _ALCU.
//
// Revision 1.43  2004/05/31 10:02:55  law
// - включен define _l3BoxedBitArray - так вроде с ним все заработало.
//
// Revision 1.42  2004/05/28 18:03:35  law
// - new define: _l3BoxedBitArray - пока выключен.
//
// Revision 1.41  2004/05/28 12:25:46  law
// - new build.
//
// Revision 1.40  2004/05/28 10:51:15  law
// - new behavior: включена директива _l3StoreAllCacheableInPool.
//
// Revision 1.39  2004/05/28 10:42:31  law
// - bug fix: неправильно распеределялись объекты в пуле.
//
// Revision 1.38  2004/05/27 15:48:22  law
// - new behavior: Pool памяти перетащен в класс _Tl3Base.
// - new behavior: память под класс Tl3String теперь распределяется из Pool'а.
//
// Revision 1.37  2004/04/09 12:47:51  law
// - new behavior: для Немезиса в сборке _Debug следим за заглушками локальных процедур.
//
// Revision 1.36  2004/03/17 13:13:18  law
// - change: для Немезиса включена директива l3NotUseW95Meter.
//
// Revision 1.35  2003/12/29 15:49:23  law
// - change: fCountView для удобства отладки теперь property - так что можно ставить breakpoint на pm_SetfContView.
//
// Revision 1.34  2003/12/09 18:03:40  law
// - new directive: l3Alone.
//
// Revision 1.33  2003/04/19 12:58:24  law
// - новая сборка библиотек ee.dll и eeGen.dll.
//
// Revision 1.32  2003/04/19 11:24:50  law
// - new file: vtDefine.inc.
//
// Revision 1.31  2003/04/17 13:20:53  law
// - cleanup.
//
// Revision 1.30  2003/04/15 13:26:49  law
// - new unit: evUnits.
//
// Revision 1.29  2003/02/18 18:05:53  law
// - new directive: l3NotLexUseStdIn.
//
// Revision 1.28  2002/12/26 17:13:56  law
// - optimiztion: в режиме evOnlyForPrinting выключаем директиву evUseOleClipboard.
//
// Revision 1.27  2002/09/23 12:16:47  law
// - new directives: Warn UNSAFE_*.
//
// Revision 1.26  2002/09/11 15:43:03  law
// - change: адаптация к Delphi 7.0.
//
// Revision 1.25  2001/12/24 13:20:41  law
// - cleanup.
//
// Revision 1.24  2001/12/14 16:39:17  law
// - new unit: m4SearchFormula.
//
// Revision 1.23  2001/10/29 13:03:46  law
// - new directive: l3NotTraceClasses.
//
// Revision 1.22  2001/10/12 17:52:01  law
// - new behavior: работа с буфером обмена через _OleSetClipboard.
//
// Revision 1.21  2001/08/29 07:01:10  law
// - split unit: l3Intf -> l3BaseStream, l3BaseDraw, l3InterfacedComponent.
//
// Revision 1.20  2001/04/04 14:26:35  law
// - new: добавлены директивы компиляции.
//
// Revision 1.19  2000/12/15 15:19:00  law
// - вставлены директивы Log.
//

{$Include w:\common\components\rtl\Garant\L3\l3Delphi.inc}

{$IfDef NoVCL}
 {$Define NoVGScene}
 {$Define NoVCM}
 {$Define NoEverest}
 {$Define NoTB97}
 {$Define NoImageEn}
{$EndIf NoVCL}

{$IfDef nsTool}
 {.$Define NoVGScene}
 {$IfNDef NeedsScripts}
  {$Define NoScripts}
 {$EndIf NeedsScripts}
 {.$Define NoVCM}
{$EndIf nsTool}

{$IfDef l3ConsoleApp}
 {$Define NoVCM}
{$EndIf l3ConsoleApp}

{$If Defined(Nemesis) or Defined(NsTool)}
 {$If not Defined(nsTest) OR Defined(InsiderTest)}
  {$Define l3NotUseSSE}
 {$IfEnd} 
{$IfEnd}

{$IfDef ARM}
 {$Define l3Alone}
{$EndIf ARM}

{$IfDef l3Alone}
 {$Define l3NotRequires_m0}
{$EndIf l3Alone}

{$If Defined(nsTest) AND not Defined(InsiderTest)}
 {$IfNDef l3Trace}
  {$Define l3NoTrace}
 {$EndIf  l3Trace}
{$IfEnd}

{$IfDef nsTool}
 {.$Define l3ConsoleApp}
{$EndIf nsTool}

{$IfDef Nemesis}
 {$IfOpt D+}
  {$Define l3TraceAllocStub}
 {$EndIf}
{$EndIf Nemesis}

{$IfDef Everest}
 {$IfOpt D+}
  {$Define l3TraceAllocStub}
 {$EndIf}
 {$Define l3UseQuote4Split}
{$EndIf Everest}

{$IfDef EverestLite}
 {$Define l3UseQuote4Split}
{$Endif EverestLite}

{$IfOpt D-}
 {$Define l3NoTrace}
{$EndIf}

{$IfDef DesignTimeLibrary}
 {$Define l3NoTrace}
 {$Define NoScripts}
{$EndIf DesignTimeLibrary}

// moved from `m0define.inc` by migel {
{$IfDef Nemesis}
 {$IfOpt D+}
  {$Define DebugStackTrace}
 {$EndIf}
{$Else  Nemesis}
 {$Define DebugStackTrace}
{$EndIf Nemesis}

{$IfDef notDebugStackTrace}
 {$Undef DebugStackTrace}
{$EndIf notDebugStackTrace}

{$Define l3TraceSysGetMem}
{$IfNDef XE}
 {$Define l3DirectUseSystemMemManager}
{$EndIf  XE}
{.$Define l3TraceMemAllocStat}

{$IfDef Delphi7}
 {$Warn UNSAFE_Type Off}
 {$Warn UNSAFE_Code Off}
 {$Warn UNSAFE_Cast Off}
 {$Warn SYMBOL_PLATFORM Off}
 {$Warn SYMBOL_LIBRARY Off}
 {$Warn SYMBOL_DEPRECATED Off}
 {$Warn UNIT_DEPRECATED Off}
 {$Warn UNIT_PLATFORM Off}
{$EndIf Delphi7}

{$BoolEval Off}
{$SafeDivide Off}
{$StackFrames Off}
{$TypedAddress Off}
{$WriteableConst Off}
{$LongStrings On}
{$ExtendedSyntax On}
{$VarStringChecks On}

{$IfDef EverestRelease}
 {$Define l3Release}
 {$Define l3UseQuote4Split} 
{$EndIf EverestRelease}

{$IfDef evMyEditor}
 {$Define l3Release}
 {$Define l3NotTraceClasses}
{$EndIf evMyEditor}

{$IfDef l3Release}
 {$OverflowChecks Off}
 {$IOChecks Off}
 {$RangeChecks Off}
 {$DebugInfo Off}
 {$Assertions Off}
 {$DefinitionInfo Off}
 {$LocalSymbols Off}
{$Else  l3Release}
 //{$If not Defined(Nemesis) AND not Defined(nsTest)}
 {$If not Defined(Nemesis) OR Defined(nsTest)}
  {$IfOpt D+}
   {$OverflowChecks On}
   {$IOChecks On}
   {$RangeChecks On}
   {$DebugInfo On}
   {$Assertions On}
   {$DefinitionInfo On}
   {$LocalSymbols On}
  {$Else  D+}
   {$OverflowChecks On}
   {$IOChecks On}
   {$RangeChecks On}
   {.$DebugInfo On}
   {$Assertions Off}
   {.$DefinitionInfo On}
   {.$LocalSymbols On}
  {$EndIf D+}
 {$IfEnd}
{$EndIf l3Release}

{$IfDef ItsLAW}
 {$IfDef Delphi7}
  {$Undef _Warnings_}
  {$Hints Off}
 {$Else  Delphi7}
  {$Define _Warnings_}
  {$Hints On}
 {$EndIf Delphi7}
{$Else  ItsLAW}
 {$Undef _Warnings_}
 {$Hints Off}
{$EndIf ItsLAW}

{$IfDef Console}
 {.$Define l3ConsoleApp}
{$EndIf Console}

{$IfDef l3NoTrace}
 {$Define l3NotTraceClasses}
 {$Define l3NotTraceObjects}
 {$Undef  l3TraceAllocStub}
 {$Undef  l3TraceSysGetMem}
 {$Undef  l3TraceMemAllocStat}
{$EndIf l3NoTrace}

{$IfDef DesignTimeLibrary}
 {$Undef  l3TraceSysGetMem}
 {$Undef  l3TraceMemAllocStat}
{$EndIf DesignTimeLibrary}

{$IfDef l3NotTraceMemAllocStat}
 {$Undef l3TraceMemAllocStat}
{$EndIf l3NotTraceMemAllocStat}

{$IfOpt D+}
 {$IfNDef l3ConsoleApp}
  {$IfNDef l3NotTraceClasses}
   {$Define l3TraceClasses}
  {$EndIf  l3NotTraceClasses}
 {$EndIf  l3ConsoleApp}
 {$IfNDef l3NotTraceObjects}
  {$Define l3TraceObjects}
 {$EndIf  l3NotTraceObjects}
{$EndIf}

{$IfNDef XE}
 {$Define l3BorlandMemoryManager}
{$EndIf  XE}

{$IfDef Win32}
 {$IfNDef Delphi4}
  {$Define l3NotRequires_m0}
 {$EndIf  Delphi4}
{$Else  Win32}
{$EndIf Win32}

{$Define l3Requires_m0}

{$IFDEF l3Release}
 {$Define l3Requires_m0}
{$ELSE  l3Release}
{$ENDIF l3Release}

{$IfDef l3Requires_m0}
 {$IfDef l3NotRequires_m0}
  {$Undef l3Requires_m0}
 {$EndIf l3NotRequires_m0}
{$EndIf l3Requires_m0}

{$IfDef _m0LOGSAV1}
 {$IfNDef l3Requires_m0}
  - невозможно использовать механизм Log-файлов без директивы l3Requires_m0
 {$EndIf l3Requires_m0}
{$EndIf _m0LOGSAV1}

{$IfNDef l3ProgressComponentIsNotComponent}
 {$Define l3ProgressComponentIsComponent}
{$EndIf l3ProgressComponentIsNotComponent}

{$Define l3UseOleClipboard}

{$IfDef l3NotUseOleClipboard}
 {$Undef l3UseOleClipboard}
{$EndIf l3NotUseOleClipboard}

{$IfDef l3ConsoleApp}
 {$Undef l3ProgressComponentIsComponent}
 {$Undef l3UseOleClipboard}
 {$Define l3LexUseStdIn}
 {$Define noGDIPlus}
{$EndIf l3ConsoleApp}

{$If Defined(nsTest) AND not Defined(InsiderTest)}
 {.$Undef l3ProgressComponentIsComponent}
{$IfEnd}

{$IfDef l3NotLexUseStdIn}
 {$Undef l3LexUseStdIn}
{$EndIf l3NotLexUseStdIn}

{$IfNDef DesignTimeLibrary}
 {$IfDef XE}
  {$Define l3BoxedBitArray}
 {$Else  XE}
  {$Define l3BoxedBitArray}
 {$EndIf  XE}
{$EndIf DesignTimeLibrary}

{$IfNDef l3NotAssertSimpleMMCanFreeBlocks}
 {$Define l3AssertSimpleMMCanFreeBlocks}
{$EndIf  l3NotAssertSimpleMMCanFreeBlocks}

{$IfDef ALCU}
 {.$Undef l3AssertSimpleMMCanFreeBlocks}
 {$Undef evNeedClipboardSpy}
{$EndIf ALCU}

{.$Define l3UsePrinterForPreview}
{$Define l3NeedTabbedText}
{$Define l3DrawBitmapsTransparent}

{$IfNDef DesignTimeLibrary}
 {$IfNDef XE}
  {$Define l3HackedVCL}
 {$EndIf} 
{$EndIf  DesignTimeLibrary}

{.$IfDef Archi}
 {.$Include ArchiDefine.inc}
{.$EndIf Archi}

{$IfDef Nemesis}
  {$If Defined(InsiderTest)}
   {$Undef _Warnings_}
   {$Hints Off}
  {$Else}
   {$Define _Warnings_}
   {.$Hints On}
  {$IfEnd}
  {.$Undef l3AssertSimpleMMCanFreeBlocks}
  {.$Undef l3TraceMemAllocStat}
{$EndIf Nemesis}

{$IfDef CheckCode}
 {$Define _Warnings_}
 {.$Hints On}
{$EndIf CheckCode}

{$IfDef _Warnings_}
 {$Warnings On}
{$Else  _Warnings_}
 {$Warnings Off}
{$EndIf _Warnings_}

{$IfDef Nemesis}
 {$Undef l3DrawBitmapsTransparent}
{$EndIf Nemesis}

{$IfDef ARCHI}
 {$Define l3UseQuote4Split}
{$EndIf ARCHI}

{$If Defined(Nemesis) and Defined(Debug)}
 {$IfNDef XE}
  {$Define l3CheckUnfreedResources}
 {$EndIf  XE} 
{$IfEnd}

{$IfDef l3CheckUnfreedResources}
 {$If not (Defined(Delphi7) or Defined(Delphi2006))}
  - Проверка CheckUnfreedResources гарантированно работает только с Delphi7 и Delphi2006
 {$IfEnd}
{$EndIf l3CheckUnfreedResources}

{$Define l3SharedLog}

{.$Define l3TraceFill}

{$IfNDef XE}
 {$Define l3AsmMove}
 {$Define l3UseSSE}
 {$Define l3UseMMX}
 {$Define l3UseFPU}
{$EndIf XE}

{$IfDef Nemesis}
 {$If not Defined(nsTest) OR Defined(InsiderTest)}
  {$IfOpt D+}
   {$Undef l3UseSSE}  
   {.$Undef l3UseMMX}
   {.$Define l3TraceFill}
  {$Else}
   {$Undef l3UseSSE}
  {$EndIf}
 {$IfEnd}
{$EndIf Nemesis}
{$IfDef ARCHI}
 {$Undef l3UseSSE}
{$EndIf ARCHI}

{$IfNDef l3FilerIsNotComponent}
 {$IfDef l3ProgressComponentIsComponent}
  {$Define l3FilerIsComponent}
 {$EndIf l3ProgressComponentIsComponent}
{$EndIf l3FilerIsNotComponent}

{$IfDef Nemesis}
 {$Undef l3FilerIsComponent}
{$EndIf Nemesis}

{$IfDef nsTest}
{$IF not Defined(Archi) and not Defined(EverestLite)}
 {$Undef l3FilerIsComponent}
{$IFEND}
{$EndIf nsTest}

{$IfDef UseProjectDefine}
 {$Include ProjectDefine.inc}
{$Else  UseProjectDefine}
{$EndIf UseProjectDefine}

{$IfDef XE}
 {.$Define l3NoObjectCache}
 {$Align 1}
 {.$OLDTYPELAYOUT ON}
 {$Z1}
{$EndIf XE}

{$IfNDef l3ConsoleApp}
 {$IfNDef notDebugStackTrace}
  {$Define _m0USEFORMS1}
 {$EndIf  notDebugStackTrace}
{$EndIf  l3ConsoleApp}

{$IfOpt D+}
 {$Define _m0LOGSAV1}
{$EndIf D+}

{$Define _m0LANGUAGE_RUS}

{$IfDef l3NotUseSSE}
 {$UnDef l3UseSSE}
{$EndIf}

{$IfNDef Shell}
 {$IfDef Nemesis}
  {$If not Defined(Admin) AND not Defined(Monitorings) AND not Defined(nsTool)}
   {$Define Shell}
  {$IfEnd}
 {$EndIf Nemesis}
{$EndIf Shell}

{$EndIf l3Define}
..\..\L3\l3DefineCleanup.inc
{$IfDef _Unknown_NoImpl}
procedure ClearFields;
  virtual;
  {-}
procedure Cleanup;
  virtual;
  {-}
procedure AfterDestroyCalled;
  virtual;
  {-}
procedure Release;
  virtual;
  {-}
procedure InitFields;
  virtual;
  {-}
public
procedure AfterConstruction;
  override;
  {-}
destructor Destroy;
  override;
  {-}
{$Else  _Unknown_NoImpl}
procedure Cleanup;
  override;
  {-}
{$EndIf _Unknown_NoImpl}
..\..\L3\l3Delphi.inc
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.9  2013/05/24 15:59:50  lulin
// - пытаемся портироваться под XE4.
//
// Revision 1.8  2013/04/03 13:57:34  lulin
// - портируем.
//
// Revision 1.7  2013/03/28 14:03:17  lulin
// - портируем.
//
// Revision 1.6  2006/01/10 07:29:00  voba
// - add VER180
//
// Revision 1.5  2002/09/11 15:43:03  law
// - change: адаптация к Delphi 7.0.
//
// Revision 1.4  2001/08/30 16:34:38  law
// - new version: портировал на Delphi 6.
//
// Revision 1.3  2000/12/15 15:19:00  law
// - вставлены директивы Log.
//

{ Secrets of Delphi 3, by Ray Lischner. (1997, Waite Group Press).
  Copyright © 1996 The Waite Group, Inc.

  Define conditional macros, according to the version of Delphi.
  Delphi defines VER80=Delphi1, VER90=Delphi2, and VER100=Delphi3.
  Usually, features are upwardly compatible, so what is most interesting
  is knowing if the version is at Delphi 2 or later, Delphi 3 or later,
  and so on.

  This file defines Delphi1 for any version of Delphi, Delphi2 for
  version 2.0 or later, and Delphi3 for version 3.0 or later. To test
  for a specific version of Delphi, use the VER... labels. To test for
  a feature that depends on Windows 95 or Windows NT, use WIN32.
}

{$ifdef VER80}
  {$define Delphi1}
{$endif}
{$ifdef VER90}
  {$define Delphi1}
  {$define Delphi2}
{$endif}
{$ifdef VER100}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
{$endif}
{$ifdef VER120}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
  {$define Delphi4}
{$endif}
{$ifdef VER130}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
  {$define Delphi4}
  {$define Delphi5}
{$endif}
{$ifdef VER140}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
  {$define Delphi4}
  {$define Delphi5}
  {$define Delphi6}
{$endif}
{$ifdef VER150}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
  {$define Delphi4}
  {$define Delphi5}
  {$define Delphi6}
  {$define Delphi7}
{$endif}
{$ifdef VER180}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
  {$define Delphi4}
  {$define Delphi5}
  {$define Delphi6}
  {$define Delphi7}
  {$define Delphi2006}
{$endif}
{$IfDef VER230}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
  {$define Delphi4}
  {$define Delphi5}
  {$define Delphi6}
  {$define Delphi7}
  {$define Delphi2006}
  {$define XE}
  {$define XE1}
  {$define XE2}
{$endif}
{$IfDef VER240}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
  {$define Delphi4}
  {$define Delphi5}
  {$define Delphi6}
  {$define Delphi7}
  {$define Delphi2006}
  {$define XE}
  {$define XE1}
  {$define XE2}
  {$define XE3}
{$endif}
{$IfDef VER250}
  {$define Delphi1}
  {$define Delphi2}
  {$define Delphi3}
  {$define Delphi4}
  {$define Delphi5}
  {$define Delphi6}
  {$define Delphi7}
  {$define Delphi2006}
  {$define XE}
  {$define XE1}
  {$define XE2}
  {$define XE3}
  {$define XE4}
{$endif}
..\..\L3\l3ImplCleanup.inc
{$IfDef _Unknown_NoImpl}
procedure _Unknown_Child_.AfterDestroyCalled;
  //virtual;
  {-}
begin
end;

procedure _Unknown_Child_.AfterConstruction;
  //override;
  {-}
begin
 inherited;
 InitFields;
end;

destructor _Unknown_Child_.Destroy;
  //override;
begin
 Release;
 inherited;
 AfterDestroyCalled;
end;

procedure _Unknown_Child_.Release;
  //virtual;
  {-}
begin
 Cleanup;
 ClearFields;
end;

procedure _Unknown_Child_.ClearFields;
  //virtual;
  {-}
begin
end;

procedure _Unknown_Child_.InitFields;
  //virtual;
  {-}
begin
end;
  
{$EndIf _Unknown_NoImpl}
procedure _Unknown_Child_.Cleanup;
  //virtual;
  {-}

..\..\L3\l3IterMode.inc

{ Библиотека "L3 (Low Level Library)" }
{ Автор: Люлин А.В. ©                 }
{ Модуль: l3IterMode.inc -            }
{ Начат: 20.06.2003 17:19 }
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.5  2007/12/26 11:14:21  lulin
// - cleanup.
//
// Revision 1.4  2006/12/22 12:11:16  lulin
// - cleanup.
//
// Revision 1.3  2003/12/27 16:39:05  law
// - new behavior: не прогружаем список при очистке кеша.
//
// Revision 1.2  2003/07/28 08:46:21  demon
// - comment fix.
//
// Revision 1.1  2003/06/20 13:23:51  law
// - new file: l3IterMode.inc.
//

{$Include l3Define.inc }

const
  {IterMode const}
  imExpandOnly    = $01;
   {* - перебирать только открытые узлы }
  imCheckResult   = $02;
   {* - проверять результат, возвращаемый подитеративной функцией (см. Tl3NodeAction) }
  imOneLevel      = $04;
   {* - перебрать только один уровень }
  imParentNeed    = $08;
   {* - включить RootSubNode в список перебираемых }
  imNoSubRoot     = $10;
   {* - RootSubNode - точка начала, но не корень, так же перебираются узлы расположенные на том же уровне, что и RootSubNode и выше него }
  imChildsBefore  = $20;
   {* - перебрать все дочерние узлы перед их родителем, т.е. дети перебираются вперед }
  imNoChilds      = $40;
   {* - не перебирать дочерние узлы, используется во внутренних процедурах}
  imNoHidden      = $80;
   {* - не перебирать невидимые, поддерживается только процедурами Tl3Tree}

..\..\L3\l3XE.inc
{$IfDef VER230}
  {$define XE}
  {$define XE1}
  {$define XE2}
{$endif}
{$IfDef VER240}
  {$define XE}
  {$define XE1}
  {$define XE2}
  {$define XE3}
{$endif}
{$IfDef VER250}
  {$define XE}
  {$define XE1}
  {$define XE2}
  {$define XE3}
  {$define XE4}
{$endif}
{$IfDef VER300}
  {$define XE}
  {$define XE1}
  {$define XE2}
  {$define XE3}
  {$define XE4}

  {$define DelphiX}
{$endif}
..\..\L3\m0define.inc
{$IFNDEF _m0DEFINE_INC}
 {$DEFINE _m0DEFINE_INC}
(*
//
// module:  m0define.inc
// author:  Mickael P. Golovin
//
// Copyright (c) 1997-2000 by Archivarius Team, free for non commercial use.
//
// $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $
//
*)

{$Include l3Define.inc}

 {$IFNDEF _m0LANGUAGE_RUS}
  {$IFNDEF _m0LANGUAGE_ENG}
   {$DEFINE _m0LANGUAGE_RUS}
   {.$DEFINE _m0LANGUAGE_ENG}
  {$ENDIF}
 {$ENDIF}

 {$IFDEF Nemesis}
  {$Define _m0LINGUISTICS_MEDIALINGUA}
 {$Else  Nemesis}
  {$IFNDEF _m0LINGUISTICS_AGAMA}
   {$IFNDEF _m0LINGUISTICS_INFORMATIC}
    {$IFNDEF _m0LINGUISTICS_MEDIALINGUA}
     {$DEFINE _m0LINGUISTICS_AGAMA}
     {.$DEFINE _m0LINGUISTICS_INFORMATIC}
     {.$DEFINE _m0LINGUISTICS_MEDIALINGUA}
    {$ENDIF}
   {$ENDIF}
  {$ENDIF}
 {$ENDIF}

 {$IFNDEF _m0USEFORMS0}
  {$IfDef l3ConsoleApp}
   {$DEFINE _m0USEFORMS0}
  {$EndIf l3ConsoleApp}
 {$ENDIF}

 {$IFNDEF _m0USEFORMS0}
  {$IFNDEF _m0USEFORMS1}
   {$DEFINE _m0USEFORMS1}
  {$ENDIF}
 {$ENDIF}

 {$IFNDEF _m0MSGBOX0}
  {.$DEFINE _m0MSGBOX0}
 {$ENDIF}

 {$IFNDEF _m0MSGBOX0}
  {$IFNDEF _m0MSGBOX1}
   {$DEFINE _m0MSGBOX1}
  {$ENDIF}
 {$ENDIF}

 {$IfDef ALCU}
  {$Define _m0LOGSAV1}
 {$EndIf ALCU}

 {$IfDef Nemesis}
  {$IfOpt D+}
   {$Define _m0LOGSAV1}
  {$EndIf}
 {$EndIf Nemesis}

 {$IFNDEF _m0LOGSAV1}
  {.$DEFINE _m0LOGSAV1}
 {$ENDIF}

 {$IFNDEF _m0LOGSAV1}
  {$IFNDEF _m0LOGSAV0}
   {$DEFINE _m0LOGSAV0}
  {$ENDIF}
 {$ENDIF}

 {$IFNDEF _m0MONOMODE1}
  {.$DEFINE _m0MONOMODE1}
 {$ENDIF}

 {$IFNDEF _m0MONOMODE1}
  {$IFNDEF _m0MONOMODE0}
   {$DEFINE _m0MONOMODE0}
  {$ENDIF}
 {$ENDIF}

{$ENDIF}
..\..\L3\l3.dpr
program l3;

{$AppType Console}

(*
 На корень CVS должен быть смапирован диск W:
*)

(*
 Должна быть определена переменная окружения binout И в ней две директории EXE и Units
*)

uses
  SysUtils,
  
  l3ProtoObject,
  l3ProtoObjectRefList,
  l3ProtoObjectPtrList,

  l3ProtoObjectRefSortableList,

  l3LongintList,
  l3Base,

  IntStack,
  StringStack
  ;

procedure TestList;
const
 cEtalon : array [0..4] of Integer = (1, 2, 3, 4, 5);

 function DoItem(pItem : PInteger; anIndex : Integer) : Boolean;
 begin
  Result := true;
  assert(pItem^ = cEtalon[anIndex]);
 end;

var
 l_L : Tl3LongintList;
 l_I : Integer;
begin
 l_L := Tl3LongintList.Create;
 try
  for l_I := Low(cEtalon) to High(cEtalon) do
   l_L.Add(cEtalon[l_I]);
  for l_I := Low(cEtalon) to High(cEtalon) do
   assert(l_L.Items[l_I] = cEtalon[l_I]);
  l_L.IterateAllF(l3L2IA(@DoItem)); 
  l_L.IterateBackF(l_L.Hi, l_L.Lo, l3L2IA(@DoItem)); 
 finally
  FreeAndNil(l_L);
 end;//try..finally
end;

var
 l_A : Tl3ProtoObject;
 l_B : Tl3ProtoObject;
 l_Refs : Tl3ProtoObjectRefList;
 l_Ptrs : Tl3ProtoObjectRefList;
begin
 TestList;
 l_Refs := Tl3ProtoObjectRefList.Create;
 try
  l_A := Tl3ProtoObject.Create;
  try
   WriteLn(l_A.RefCount);
   l_Refs.Add(l_A);
   WriteLn(l_Refs.First.RefCount);
   WriteLn(l_A.RefCount);
  finally
   FreeAndNil(l_A);
  end;//try..finally
  // - тут с l_A всё в порядке
  WriteLn(l_Refs.First.RefCount);
  l_B := Tl3ProtoObject.Create;
  try
   l_Refs.Add(l_B);
  finally
   FreeAndNil(l_B);
  end;//try..finally
  // - тут с l_B всё в порядке
 finally
  FreeAndNil(l_Refs);
 end;//try..finally
 // - список удалился и за собой всё почистил

 l_Ptrs := Tl3ProtoObjectRefList.Create;
 try
  l_A := Tl3ProtoObject.Create;
  try
   l_Ptrs.Add(l_A);
  finally
   FreeAndNil(l_A);
  end;//try..finally
  // - тут ссылка на l_A в l_Ptrs стала невалидна
  l_B := Tl3ProtoObject.Create;
  try
   l_Ptrs.Add(l_B);
  finally
   FreeAndNil(l_B);
  end;//try..finally
  // - тут ссылка на l_B в l_Ptrs стала невалидна
 finally
  FreeAndNil(l_Ptrs);
 end;//try..finally
end.
..\..\L3\l3.dproj
п»ї<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
        <ProjectGuid>{6C64EE52-761D-4EF2-9E97-7C66CEDCCCBD}</ProjectGuid>
        <MainSource>l3.dpr</MainSource>
        <Base>True</Base>
        <Config Condition="'$(Config)'==''">Debug</Config>
        <TargetedPlatforms>1</TargetedPlatforms>
        <AppType>Console</AppType>
        <FrameworkType>None</FrameworkType>
        <ProjectVersion>14.4</ProjectVersion>
        <Platform Condition="'$(Platform)'==''">Win32</Platform>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Base' or '$(Base)'!=''">
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='OSX32' and '$(Base)'=='true') or '$(Base_OSX32)'!=''">
        <Base_OSX32>true</Base_OSX32>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Base)'=='true') or '$(Base_Win32)'!=''">
        <Base_Win32>true</Base_Win32>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Release' or '$(Cfg_1)'!=''">
        <Cfg_1>true</Cfg_1>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Debug' or '$(Cfg_2)'!=''">
        <Cfg_2>true</Cfg_2>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='OSX32' and '$(Cfg_2)'=='true') or '$(Cfg_2_OSX32)'!=''">
        <Cfg_2_OSX32>true</Cfg_2_OSX32>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win32)'!=''">
        <Cfg_2_Win32>true</Cfg_2_Win32>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base)'!=''">
        <DCC_K>false</DCC_K>
        <DCC_UsePackage>vcl;rtl;vclx;indy;VclSmp;dbexpress;dbrtl;vcldb;dsnap;dbxcds;inet;inetdb;bdertl;vcldbx;vclie;adortl;teeui;teedb;tee;ibxpress;visualclx;visualdbclx;vclactnband;vclshlctrls;IntrawebDB_50_70;Intraweb_50_70;Rave50CLX;Rave50VCL;dclOfficeXP;xmlrtl;inetdbbde;inetdbxpress;soaprtl;AllEverestComponets7;$(DCC_UsePackage)</DCC_UsePackage>
        <DCC_F>false</DCC_F>
        <DCC_E>false</DCC_E>
        <DCC_ExeOutput>$(binout)\exe</DCC_ExeOutput>
        <DCC_DcuOutput>$(binout)\units</DCC_DcuOutput>
        <DCC_Define>OVP;$(DCC_Define)</DCC_Define>
        <DCC_SymbolReferenceInfo>1</DCC_SymbolReferenceInfo>
        <DCC_N>true</DCC_N>
        <DCC_ImageBase>00400000</DCC_ImageBase>
        <DCC_Namespace>System;Xml;Data;Datasnap;Web;Soap;$(DCC_Namespace)</DCC_Namespace>
        <VerInfo_Locale>1049</VerInfo_Locale>
        <DCC_UnitSearchPath>W:\common\components\rtl\external\JEDI\source;W:\common\components\rtl\external\JEDI\source\windows;W:\common\components\rtl\external\JEDI\source\common;W:\common\components\rtl\Garant\L3;W:\common\components\rtl\Garant\L3\ElClone;W:\common\components\rtl\Garant\L3\m2;W:\common\components\gui\Garant\AFW;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <VerInfo_Keys>CompanyName=;FileDescription=;FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProductName=;ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <DCC_S>false</DCC_S>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_OSX32)'!=''">
        <Icns_MainIcns>$(BDS)\bin\delphi_PROJECTICNS.icns</Icns_MainIcns>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win32)'!=''">
        <VerInfo_Keys>CompanyName=;FileDescription=;FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProductName=;ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <VerInfo_Locale>1033</VerInfo_Locale>
        <DCC_Namespace>Winapi;System.Win;Data.Win;Datasnap.Win;Web.Win;Soap.Win;Xml.Win;Bde;$(DCC_Namespace)</DCC_Namespace>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1)'!=''">
        <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
        <DCC_Define>RELEASE;$(DCC_Define)</DCC_Define>
        <DCC_LocalDebugSymbols>false</DCC_LocalDebugSymbols>
        <DCC_DebugInformation>false</DCC_DebugInformation>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2)'!=''">
        <DCC_Define>DEBUG;$(DCC_Define)</DCC_Define>
        <DCC_GenerateStackFrames>true</DCC_GenerateStackFrames>
        <DCC_Optimize>false</DCC_Optimize>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_OSX32)'!=''">
        <Icns_MainIcns>$(BDS)\bin\delphi_PROJECTICNS.icns</Icns_MainIcns>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_Win32)'!=''">
        <DCC_UnitSearchPath>C:\Program Files (x86)\Embarcadero\RAD Studio\10.0\source\vcl;$(in)\SandBox;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <DCC_Define>notDebugStackTrace;l3NoTrace;l3ConsoleApp;$(DCC_Define)</DCC_Define>
        <Manifest_File>None</Manifest_File>
        <VerInfo_Locale>1033</VerInfo_Locale>
        <DCC_UnitAlias>Graphics=VCL.Graphics;Consts=VCL.Consts;Forms=VCL.Forms;Controls=VCL.Controls;ImgList=VCL.ImgList;Dialogs=VCL.Dialogs;$(DCC_UnitAlias)</DCC_UnitAlias>
    </PropertyGroup>
    <ItemGroup>
        <DelphiCompile Include="$(MainSource)">
            <MainSource>MainSource</MainSource>
        </DelphiCompile>
        <BuildConfiguration Include="Debug">
            <Key>Cfg_2</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
        <BuildConfiguration Include="Base">
            <Key>Base</Key>
        </BuildConfiguration>
        <BuildConfiguration Include="Release">
            <Key>Cfg_1</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
    </ItemGroup>
    <ProjectExtensions>
        <Borland.Personality>Delphi.Personality.12</Borland.Personality>
        <Borland.ProjectType/>
        <BorlandProject>
            <Delphi.Personality>
                <Source>
                    <Source Name="MainSource">l3.dpr</Source>
                </Source>
                <VersionInfo>
                    <VersionInfo Name="IncludeVerInfo">False</VersionInfo>
                    <VersionInfo Name="AutoIncBuild">False</VersionInfo>
                    <VersionInfo Name="MajorVer">1</VersionInfo>
                    <VersionInfo Name="MinorVer">0</VersionInfo>
                    <VersionInfo Name="Release">0</VersionInfo>
                    <VersionInfo Name="Build">0</VersionInfo>
                    <VersionInfo Name="Debug">False</VersionInfo>
                    <VersionInfo Name="PreRelease">False</VersionInfo>
                    <VersionInfo Name="Special">False</VersionInfo>
                    <VersionInfo Name="Private">False</VersionInfo>
                    <VersionInfo Name="DLL">False</VersionInfo>
                    <VersionInfo Name="Locale">1049</VersionInfo>
                    <VersionInfo Name="CodePage">1251</VersionInfo>
                </VersionInfo>
                <VersionInfoKeys>
                    <VersionInfoKeys Name="CompanyName"/>
                    <VersionInfoKeys Name="FileDescription"/>
                    <VersionInfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys>
                    <VersionInfoKeys Name="InternalName"/>
                    <VersionInfoKeys Name="LegalCopyright"/>
                    <VersionInfoKeys Name="LegalTrademarks"/>
                    <VersionInfoKeys Name="OriginalFilename"/>
                    <VersionInfoKeys Name="ProductName"/>
                    <VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys>
                    <VersionInfoKeys Name="Comments"/>
                </VersionInfoKeys>
                <Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dcloffice2k170.bpl">Microsoft Office 2000 Sample Automation Server Wrapper Components</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dclofficexp170.bpl">Microsoft Office XP Sample Automation Server Wrapper Components</Excluded_Packages>
                </Excluded_Packages>
            </Delphi.Personality>
            <Platforms>
                <Platform value="OSX32">False</Platform>
                <Platform value="Win32">True</Platform>
                <Platform value="Win64">False</Platform>
            </Platforms>
        </BorlandProject>
        <ProjectFileVersion>12</ProjectFileVersion>
    </ProjectExtensions>
    <Import Project="$(BDS)\Bin\CodeGear.Delphi.Targets" Condition="Exists('$(BDS)\Bin\CodeGear.Delphi.Targets')"/>
    <Import Project="$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj" Condition="Exists('$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj')"/>
</Project>
..\..\L3\ElClone\elpack.inc
(*

These conditional defines turn on or off some rarely used features of
different elpack controls. Turning those features off reduces size of
generatede executable.

To turn the feature off place "." before "$" in the directive

To turn on debugging in ElPack define a compiler variable called DEBUG and
rebuild ElPack.

C++BUILDER 4 note:

Despite the BROKEN_UNICODE define ElPack supports unicode with C++Builder 4.
Please contact EldoS for details about how to enable unicode support.

*)

// comment this to make ElTree and some other controls ANSI
// uncommen tthis to keep ElTree and other controls unicode
{$DEFINE ELPACK_UNICODE}

// comment this if you need to keep your existing code
// or you don't want to migrate to ElPack 3.0 completely
// NOTE: when you comment this, you will need to modify package source files
// and remove all references to inplace editor units
{$DEFINE VER3_EDITORS}

// comment this if you don't use inplace editors at all
// saves about 300K of space (but only if you don't use VER3_EDITORS)
{$DEFINE ELTREE_USE_INPLACE_EDITORS}

// comment this to remove drag'n'drop
{$DEFINE ELTREE_USE_OLE_DRAGDROP}

// comment this to prevent use of extended inplace editors
// (currency editor, boolean editor, date time picker etc.)
{$DEFINE ELTREE_USE_EXT_EDITORS}

{$IfDef VER230}
  {$define XE}
  {$define XE1}
  {$define XE2}
{$endif}
{$IfDef VER240}
  {$define XE}
  {$define XE1}
  {$define XE2}
  {$define XE3}
{$endif}
{$IfDef VER250}
  {$define XE}
  {$define XE1}
  {$define XE2}
  {$define XE3}
  {$define XE4}
{$endif}

// comment this to remove Storage and linkage with ElIniFile
{$DEFINE SUPPORT_STORAGE}

// comment this to disable popup calendar in ElDateTimePicker
{$DEFINE DATETIMEPICKER_SUPPORT_CALENDAR}

// uncomment this to replace ElPack calendar in popup calendar (in ElCalendarDlg)
// and ElDateTimePicker popup calendar
{.$DEFINE CALENDAR_USE_WINDOWS_CALENDAR}

// comment this if you compile the module, that uses ElIniFile, but does not
// use VCL
{$DEFINE ELINI_USE_GRAPHICS}

// comment this to turn off Unicode incremental search

{$define ELPACK_USE_INPUTPROCESSOR}

// comment this to use old ElDBLookup*Box components
{$define ELPACK_4_LOOKUPS}

// comment this to disable native (not system) theme engine
{.$define ELPACK_THEME_ENGINE} // <trash> // LAW

{$ifdef ELPACK_THEME_ENGINE}
{$define ELPACK_EXCLUDE_MANIFEST}
{$endif}

// uncomment this to exclude manifest from linkage (in case you use other controls that include manifest)
{$define ELPACK_EXCLUDE_MANIFEST} // <hack> // LAW

(*

The following overrides will help you turn the features off for particular projects

*)

{$IFDEF NO_ELTREE_USE_INPLACE_EDITORS}
{$UNDEF ELTREE_USE_INPLACE_EDITORS}
{$DEFINE NO_ELTREE_USE_EXT_EDITORS}
{$ENDIF}

{$IFDEF NO_ELINI_USE_GRAPHICS}
{$UNDEF ELINI_USE_GRAPHICS}
{$ENDIF}

{$IFDEF NO_ELTREE_USE_STYLES}
{$UNDEF ELTREE_USE_STYLES}
{$ENDIF}

{$IFDEF NO_ELTREE_USE_OLE_DRAGDROP}
{$UNDEF ELTREE_USE_OLE_DRAGDROP}
{$ENDIF}

{$IFDEF NO_ELTREE_USE_EXT_EDITORS}
{$UNDEF ELTREE_USE_EXT_EDITORS}
{$ENDIF}

{$IFDEF NO_SUPPORT_STORAGE}
{$UNDEF SUPPORT_STORAGE}
{$ENDIF}


{$ifdef NO_ELPACK_USE_IMAGEFORM}
{$undef ELPACK_USE_IMAGEFORM}
{$endif}

{$IfDef Nemesis}
 {$Define NO_ELPACK_USE_THEME_ENGINE}
{$EndIf Nemesis}

{$ifdef NO_ELPACK_USE_THEME_ENGINE}
{$undef ELPACK_THEME_ENGINE}
{$endif}

(*

Different internal directives. Do not modify them.

*)

{$DEFINE ELPACK_COMPLETE}
{$DEFINE ELPACK_PRO}
{.$DEFINE EL_DEMO}
{.$DEFINE LITE}


// this can't be commented out anymore
{$define ELTREE_USE_STYLES}

{$IFNDEF ELPACK_COMPLETE}
  {$UNDEF SUPPORT_STORAGE}
  {$UNDEF ELTREE_USE_EXT_EDITORS}
  {$UNDEF DATETIMEPICKER_SUPPORT_CALENDAR}
  {$UNDEF ELINI_USE_GRAPHICS}
  {$UNDEF ELPACK_USE_IMAGEFORM}
  {$UNDEF ELPACK_THEME_ENGINE}
{$ENDIF}

{$ifndef DATETIMEPICKER_SUPPORT_CALENDAR}
{$undef CALENDAR_USE_WINDOWS_CALENDAR}
{$endif}

{$IFDEF LITE}
  {$UNDEF ELTREE_USE_OLE_DRAGDROP}
{$ENDIF}

{$DEFINE MANUAL_BUTTONS}

{$R-}
{$IFDEF VER90}
  {$DEFINE D_2}
  {$DEFINE D_2_UP}
  {$DEFINE VCL_2_USED}
  {$UNDEF ELPACK_UNICODE}
  {$DEFINE BROKEN_UNICODE}
  {$UNDEF ELPACK_THEME_ENGINE}
  {$DEFINE NO_ELPACK_USE_THEME_ENGINE}
{$ENDIF}

{$IFDEF VER100}
  {$DEFINE D_3}
  {$DEFINE D_3_UP}
  {$DEFINE VCL_3_USED}
  {$UNDEF ELPACK_UNICODE}
  {$DEFINE BROKEN_UNICODE}
  {$UNDEF ELPACK_THEME_ENGINE}
  {$DEFINE NO_ELPACK_USE_THEME_ENGINE}
{$ENDIF}

{$IFDEF VER110}
  {$DEFINE B_3_UP}
  {$DEFINE B_3}
  {$DEFINE VCL_3_USED}
  {$DEFINE BUILDER_USED}
  {$UNDEF ELPACK_UNICODE}
  {$DEFINE BROKEN_UNICODE}
  {$UNDEF ELPACK_THEME_ENGINE}
  {$DEFINE NO_ELPACK_USE_THEME_ENGINE}
{$ENDIF}

{$IFDEF VER120}
  {$DEFINE D_3_UP}
  {$DEFINE D_4_UP}
  {$DEFINE VCL_4_USED}
{$ENDIF}

{$IFDEF VER125}
  {$DEFINE B_3_UP}
  {$DEFINE B_4_UP}
  {$DEFINE B_4}
  {$DEFINE VCL_4_USED}
  {$DEFINE BUILDER_USED}
  {$UNDEF ELPACK_UNICODE}
  {$DEFINE BROKEN_UNICODE}
  {$UNDEF ELPACK_THEME_ENGINE}
  {$DEFINE NO_ELPACK_USE_THEME_ENGINE}
{$ENDIF}

{$IFDEF VER130}
	{$IFDEF BCB}
		{$DEFINE B_3_UP}
		{$DEFINE B_4_UP}
		{$DEFINE B_5_UP}
		{$DEFINE B_5}
		{$DEFINE VCL_4_USED}
		{$DEFINE VCL_5_USED}
		{$DEFINE BUILDER_USED}
    {$ELSE}
		{$DEFINE D_3_UP}
		{$DEFINE D_4_UP}
		{$DEFINE D_5_UP}
		{$DEFINE VCL_4_USED}
		{$DEFINE VCL_5_USED}
		{.DEFINE USEADO}
    {$ENDIF}
{$ENDIF}

{$IFDEF VER140}
	{$IFDEF BCB}
		{$DEFINE B_3_UP}
		{$DEFINE B_4_UP}
		{$DEFINE B_5_UP}
		{$DEFINE B_6_UP}
		{$DEFINE B_6}
		{$DEFINE VCL_4_USED}
		{$DEFINE VCL_5_USED}
		{$DEFINE VCL_6_USED}
		{$DEFINE BUILDER_USED}
    {$ELSE}
		{$DEFINE D_3_UP}
		{$DEFINE D_4_UP}
		{$DEFINE D_5_UP}
		{$DEFINE D_6_UP}
		{$DEFINE D_6}
		{$DEFINE VCL_4_USED}
		{$DEFINE VCL_5_USED}
		{$DEFINE VCL_6_USED}
		{.DEFINE USEADO}
    {$ENDIF}
{$ENDIF}

{$IFDEF VER150}
	{$IFNDEF BCB}
		{$DEFINE D_3_UP}
		{$DEFINE D_4_UP}
		{$DEFINE D_5_UP}
		{$DEFINE D_6_UP}
		{$DEFINE D_7_UP}
		{$DEFINE D_7}
		{$DEFINE VCL_4_USED}
		{$DEFINE VCL_5_USED}
		{$DEFINE VCL_6_USED}
		{$DEFINE VCL_7_USED}
		{.DEFINE USEADO}
    {$ENDIF}
{$ENDIF}

{$IFDEF VER160}
      {$IFNDEF BCB}
            {$DEFINE D_3_UP}
            {$DEFINE D_4_UP}
            {$DEFINE D_5_UP}
            {$DEFINE D_6_UP}
            {$DEFINE D_7_UP}
            {$DEFINE D_7}
            {$DEFINE VCL_4_USED}
            {$DEFINE VCL_5_USED}
            {$DEFINE VCL_6_USED}
            {$DEFINE VCL_7_USED}
            {.DEFINE USEADO}
    {$ENDIF}
            {.$DEFINE USE_NAME_SPACE} // Optional !!!
{$ENDIF}

{$ifdef LINUX}
{$define KYLIX_USED}
{$define ELPACK_UNICODE}
{$define CLX_USED}
{$undef ELTREE_USE_OLE_DRAGDROP}
{$else}
{$define MSWINDOWS}
{$endif}

{$ifdef CLX_USED}
  {$define ELPACK_UNICODE}
  {$define NO_TOOLBAR_SETUP}
  {$define ELSBCTRL_ONLY_TYPE_DEFINITION}
  {$undef ELPACK_USE_INPUTPROCESSOR}
  {$undef ELPACK_USE_IMAGEFORM}
  {$undef ELTREE_USE_OLE_DRAGDROP}
  {$undef DATETIMEPICKER_SUPPORT_CALENDAR}
  {$undef ELPACK_THEME_ENGINE}
{$endif}

{$IFDEF BUILDER_USED}
	{$ObjExportAll On}
{$ENDIF}
{$ifndef ELPACK_UNICODE}
{$undef ELPACK_USE_INPUTPROCESSOR}
{$endif}

{$ifndef ELPACK_UNICODE}
{$undef ELPACK_USE_INPUTPROCESSOR}
  {$undef ELPACK_4_LOOKUPS}
{$endif}


{$ifdef DEBUG}
 {$DEBUGINFO ON}
 {$J+,R-,I-,Q-,O-,D+,L+,Y+,B-,W+,H+}
{$else}
 {$J+,R-,I-,Q-,O-,D-,L-,Y-,B-,W+,H+}
{$endif}


{$IfDef XE}
 {$Define VCL_4_USED}
{$EndIf XE}

{$IfDef DesignTimeLibrary}
 {$Define NoScripts}
{$EndIf DesignTimeLibrary}

..\..\L3\ElClone\elpack2.inc
{.$define ELPACK_SINGLECOMP}
{$undef ELPACK_SINGLECOMP}
{.$define DEBUG}
..\..\L3\m0\build\makedata.dpr
(*
//
// module:  makedata.dpr
// author:  Mickael P. Golovin
//
// Copyright (c) 1997-2000 by Archivarius Team, free for non commercial use.
//
// $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $
//
*)
program MakeData; {$R *.res}


 uses
        Windows,Messages,SysUtils,Consts,Classes{$IFDEF _m0USEFORMS1},Forms{$ENDIF},

        m0Const,m0AddTyp,m0EXCLib;
        

 procedure   _Begin(
                   );
 var
        LHandle:                  Integer;
        LLength:                  LongInt;
        LResultString:            string;
        LStingListIndex:          LongInt;
        LStringList:              TStringList;
        LStringListString:        string;
 begin

  try

   if (ParamCount() <> 1)
    then
     begin
 
      Halt(1);
 
     end
    else
     begin
 
      LStringList:=TStringList.Create();
       try
 
        with LStringList do
         begin
 
          LoadFromFile(ParamStr(1));
 
          LResultString:='';
 
          for LStingListIndex:=0 to Pred(Count) do
           begin
 
            LStringListString:=Strings[LStingListIndex];
 
            if (LResultString = '')
             then
              begin
 
               LResultString:=LStringListString;
 
              end
             else
              begin
 
               LResultString:=LResultString+'|'+LStringListString;
 
              end;
 
           end;
 
          LResultString:='('+LResultString+')\''';
 
          LHandle:=FileCreate(ChangeFileExt(ParamStr(1),'.bin'));
           try
 
            if (LHandle = -1)
             then
              begin
 
               Halt(1);
 
              end
             else
              begin
 
               LLength:=Succ(Length(LResultString));
 
               if (FileWrite(LHandle,PChar(LResultString)^,LLength) <> LLength)
                then
                 begin
 
                  Halt(1);
 
                 end;
 
              end;
 
           finally
 
            FileClose(LHandle);
 
           end;
 
         end;
 
       finally
 
        LStringList.Free();
 
       end;
 
     end;

  except

   m0EXCHandleException();

  end;

 end;


 begin _Begin();


end.

..\..\L3\m2\m2define.inc
(*
//
//
// .Author: Mickael P. Golovin.
// .Copyright: 1997-2001 by Archivarius Team, free for non commercial use.
//
//
*)
{$IFNDEF _m2DEFINE_INC}{$DEFINE _m2DEFINE_INC}

{$I l3Delphi.inc}
 {.$Define m2AllocSize}

{$ENDIF}

..\..\L3\m2\m2dtflib.inc
(*
//
//
// .Author: Mickael P. Golovin.
// .Copyright: 1997-2001 by Archivarius Team, free for non commercial use.
//
//
*)
 type
        TUnitHelper               = class(TObject)
         private


          _Status:                LongWord;


                function          InitProc00000001    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000001    (
                                                      );


         private


         protected


         public


                constructor       Create              (
                                                      );

                destructor        Destroy             (
                                                      ); override;


         end;


 var
        GUnitHelper:              TUnitHelper = nil;


// TUnitHelper.private

 function    TUnitHelper.InitProc00000001(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    InitializeCriticalSection(GRTLCriticalSection);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000001(
                                         );
 begin

  with Self do
   begin

    DeleteCriticalSection(GRTLCriticalSection);

   end;

 end;

// TUnitHelper.protected

// TUnitHelper.public

 constructor TUnitHelper.Create(
                               );
 begin

  inherited Create();

  m2InitOperation(_Status,InitProc00000001($00000001));

 end;

 destructor  TUnitHelper.Destroy(
                                );
 begin

  m2DoneOperation(_Status,$00000001,DoneProc00000001);

  inherited Destroy();

 end;

// TUnitHelper.end


 initialization GUnitHelper:=TUnitHelper.Create();
 finalization   GUnitHelper.Free();
..\..\L3\m2\m2haslib.inc
(*
//
//
// .Author: Mickael P. Golovin.
// .Copyright: 1997-2001 by Archivarius Team, free for non commercial use.
//
//
*)
 type
        TUnitHelper               = class(TObject)
         private


          _Status:                LongWord;


                function          InitProc00000001    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000001    (
                                                      );


                function          InitProc00000002    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000002    (
                                                      );


         private


         protected


         public


                constructor       Create              (
                                                      );

                destructor        Destroy             (
                                                      ); override;


         end;


 var
        GUnitHelper:              TUnitHelper = nil;


// TUnitHelper.private

 function    TUnitHelper.InitProc00000001(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData16(Cm2HASVersionCRC);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000001(
                                         );
 begin

  with Self do
   begin

    _FreeData16(Cm2HASVersionCRC);

   end;

 end;

 function    TUnitHelper.InitProc00000002(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData32(Cm2HASVersionCRC);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000002(
                                         );
 begin

  with Self do
   begin

    _FreeData32(Cm2HASVersionCRC);

   end;

 end;

// TUnitHelper.protected

// TUnitHelper.public

 constructor TUnitHelper.Create(
                               );
 begin

  inherited Create();

  m2InitOperation(_Status,InitProc00000001($00000001));
  m2InitOperation(_Status,InitProc00000002($00000002));

 end;

 destructor  TUnitHelper.Destroy(
                                );
 begin

  m2DoneOperation(_Status,$00000002,DoneProc00000002);
  m2DoneOperation(_Status,$00000001,DoneProc00000001);

  inherited Destroy();

 end;

// TUnitHelper.end


 initialization GUnitHelper:=TUnitHelper.Create();
 finalization   GUnitHelper.Free();
..\..\L3\m2\m2memlib.inc
(*
//
//
// .Author: Mickael P. Golovin.
// .Copyright: 1997-2001 by Archivarius Team, free for non commercial use.
//
//
*)
{$IfDef m2AllocSize}
 type
        TUnitHelper               = class(TObject)
         private


         protected


         public


                procedure         BeforeDestruction   (
                                                      ); override;


         end;


 var
        GUnitHelper:              TUnitHelper = nil;


// TUnitHelper.private

// TUnitHelper.protected

// TUnitHelper.public

 procedure   TUnitHelper.BeforeDestruction(
                                          );
 begin

  inherited BeforeDestruction();

 end;


// TUnitHelper.end


 initialization GUnitHelper:=TUnitHelper.Create();
 finalization   GUnitHelper.Free();
{$EndIf m2AllocSize}
..\..\L3\m2\m2tmplib.inc
(*
//
//
// .Author: Mickael P. Golovin.
// .Copyright: 1997-2001 by Archivarius Team, free for non commercial use.
//
//
*)
 type
        TUnitHelper               = class(TObject)
         private


          _Status:                LongWord;


                function          InitProc00000001    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000001    (
                                                      );


         private


         protected


         public


                constructor       Create              (
                                                      );

                destructor        Destroy             (
                                                      ); override;


                procedure         AfterConstruction   (
                                                      ); override;


         end;


 var
        GUnitHelper:              TUnitHelper = nil;


// TUnitHelper.private

 function    TUnitHelper.InitProc00000001(const ABitMask: LongWord
                                         ): LongWord;
                                         
  function    __GetTempPath(
                           ): WideString;
  const
        CLength=                  2048;
  var
        LString:                  AnsiString;
  begin

   SetLength(Result,CLength);

   if (Win32Platform = VER_PLATFORM_WIN32_NT)
    then
     begin

      SetLength(Result,GetTempPathW(Length(Result),PWideChar(Result)));

     end
    else
     begin

      SetLength(LString,CLength);

      SetLength(LString,Integer(GetTempPathA(Length(LString),PAnsiChar(LString))));
      SetLength(Result,MultiByteToWideChar(0,0,PAnsiChar(LString),Length(LString),PWideChar(Result),Length(Result)));

     end;

   Win32Check(Length(Result) <> 0);

  end;

 begin

  with Self do
   begin

    GFilePath:=__GetTempPath();

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000001(
                                         );
 begin

  with Self do
   begin

    SetLength(GFilePath,0);

   end;

 end;

// TUnitHelper.protected

// TUnitHelper.public

 constructor TUnitHelper.Create(
                               );
 begin

  inherited Create();

  m2InitOperation(_Status,InitProc00000001($00000001));

 end;

 destructor  TUnitHelper.Destroy(
                                );
 begin

  m2DoneOperation(_Status,$00000001,DoneProc00000001);

  inherited Destroy();

 end;

 procedure   TUnitHelper.AfterConstruction(
                                          );
 begin

  inherited AfterConstruction();

  try

   Randomize();

  except

   m2ExcErrHandler();

  end;

 end;

// TUnitHelper.end


 initialization GUnitHelper:=TUnitHelper.Create();
 finalization   GUnitHelper.Free();
..\..\L3\m2\m2xltlib.inc
(*
//
//
// .Author: Mickael P. Golovin.
// .Copyright: 1997-2001 by Archivarius Team, free for non commercial use.
//
//
*)
 type
        TUnitHelper               = class(TObject)
         private


          _Status:                LongWord;


                function          InitProc00000001    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000001    (
                                                      );


                function          InitProc00000002    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000002    (
                                                      );


                function          InitProc00000004    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000004    (
                                                      );


                function          InitProc00000008    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000008    (
                                                      );


                function          InitProc00000010    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000010    (
                                                      );


                function          InitProc00000020    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000020    (
                                                      );


                function          InitProc00000040    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000040    (
                                                      );


                function          InitProc00000080    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000080    (
                                                      );


                function          InitProc00000100    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000100    (
                                                      );


                function          InitProc00000200    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000200    (
                                                      );


                function          InitProc00000400    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000400    (
                                                      );


                function          InitProc00000800    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00000800    (
                                                      );


                function          InitProc00001000    (const ABitMask: LongWord
                                                      ): LongWord;

                procedure         DoneProc00001000    (
                                                      );


         private


         protected


         public


                constructor       Create              (
                                                      );

                destructor        Destroy             (
                                                      ); override;


         end;


 var
        GUnitHelper:              TUnitHelper = nil;


// TUnitHelper.private

 function    TUnitHelper.InitProc00000001(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTOem2Ansi);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000001(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTOem2Ansi);

   end;

 end;

 function    TUnitHelper.InitProc00000002(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTAnsi2Oem);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000002(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTAnsi2Oem);

   end;

 end;

 function    TUnitHelper.InitProc00000004(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTOem2Upper);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000004(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTOem2Upper);

   end;

 end;

 function    TUnitHelper.InitProc00000008(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTOem2Lower);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000008(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTOem2Lower);

   end;

 end;

 function    TUnitHelper.InitProc00000010(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTAnsi2Upper);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000010(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTAnsi2Upper);

   end;

 end;

 function    TUnitHelper.InitProc00000020(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTAnsi2Lower);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000020(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTAnsi2Lower);

   end;

 end;

 function    TUnitHelper.InitProc00000040(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTOemRus2Eng);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000040(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTOemRus2Eng);

   end;

 end;

 function    TUnitHelper.InitProc00000080(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTOemEng2Rus);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000080(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTOemEng2Rus);

   end;

 end;

 function    TUnitHelper.InitProc00000100(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTAnsiRus2Eng);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000100(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTAnsiRus2Eng);

   end;

 end;

 function    TUnitHelper.InitProc00000200(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTAnsiEng2Rus);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000200(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTAnsiEng2Rus);

   end;

 end;

 function    TUnitHelper.InitProc00000400(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTOem2Swap);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000400(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTOem2Swap);

   end;

 end;

 function    TUnitHelper.InitProc00000800(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTAnsi2Swap);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00000800(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTAnsi2Swap);

   end;

 end;

 function    TUnitHelper.InitProc00001000(const ABitMask: LongWord
                                         ): LongWord;
 begin

  with Self do
   begin

    _AllocData08(Cm2XLTOem2Special);

   end;

  Result:=ABitMask;

 end;

 procedure   TUnitHelper.DoneProc00001000(
                                         );
 begin

  with Self do
   begin

    _FreeData08(Cm2XLTOem2Special);

   end;

 end;

// TUnitHelper.protected

// TUnitHelper.public

 constructor TUnitHelper.Create(
                               );
 begin

  inherited Create();

  m2InitOperation(_Status,InitProc00000001($00000001));
  m2InitOperation(_Status,InitProc00000002($00000002));
  m2InitOperation(_Status,InitProc00000004($00000004));
  m2InitOperation(_Status,InitProc00000008($00000008));
  m2InitOperation(_Status,InitProc00000010($00000010));
  m2InitOperation(_Status,InitProc00000020($00000020));
  m2InitOperation(_Status,InitProc00000040($00000040));
  m2InitOperation(_Status,InitProc00000080($00000080));
  m2InitOperation(_Status,InitProc00000100($00000100));
  m2InitOperation(_Status,InitProc00000200($00000200));
  m2InitOperation(_Status,InitProc00000400($00000400));
  m2InitOperation(_Status,InitProc00000800($00000800));
  m2InitOperation(_Status,InitProc00001000($00001000));


 end;

 destructor  TUnitHelper.Destroy(
                                );
 begin

  m2DoneOperation(_Status,$00001000,DoneProc00001000);
  m2DoneOperation(_Status,$00000800,DoneProc00000800);
  m2DoneOperation(_Status,$00000400,DoneProc00000400);
  m2DoneOperation(_Status,$00000200,DoneProc00000200);
  m2DoneOperation(_Status,$00000100,DoneProc00000100);
  m2DoneOperation(_Status,$00000080,DoneProc00000080);
  m2DoneOperation(_Status,$00000040,DoneProc00000040);
  m2DoneOperation(_Status,$00000020,DoneProc00000020);
  m2DoneOperation(_Status,$00000010,DoneProc00000010);
  m2DoneOperation(_Status,$00000008,DoneProc00000008);
  m2DoneOperation(_Status,$00000004,DoneProc00000004);
  m2DoneOperation(_Status,$00000002,DoneProc00000002);
  m2DoneOperation(_Status,$00000001,DoneProc00000001);

  inherited Destroy();

 end;

// TUnitHelper.end


 initialization GUnitHelper:=TUnitHelper.Create();
 finalization   GUnitHelper.Free();
..\..\L3\Prj\l3CheckDepClear.dpr
program l3CheckDepClear;
{* Проект для проверки зависимостей библиотеки L3, с библиотекой m0. }

{ Библиотека "L3 (Low Level Library)" }
{ Автор: Люлин А.В. ©                 }
{ Модуль: l3CheckDepWithout_m0 - проект для проверки зависимостей библиотеки L3, с библиотекой m0. }
{ Начат: 09.12.2003 20:54             }
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.1  2005/05/20 13:16:38  lulin
// - добавлен еще тестовый проект.
//
// Revision 1.1  2003/12/09 17:58:32  law
// - new project: l3CheckDepWith_m0.dpr.
//

uses
  l3Base
  ;

begin
end.
..\..\L3\Prj\l3CheckDepWithout_m0.dpr
program l3CheckDepWithout_m0;
{* Проект для проверки зависимостей библиотеки L3, без библиотеки m0. }

{ Библиотека "L3 (Low Level Library)" }
{ Автор: Люлин А.В. ©                 }
{ Модуль: l3CheckDepWithout_m0 - проект для проверки зависимостей библиотеки L3, без библиотеки m0. }
{ Начат: 09.12.2003 20:44             }
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.1  2003/12/09 17:52:13  law
// - new project: l3CheckDepWithout_m0.dpr.
//

uses
  l3Base
  ;

begin
end.
..\..\L3\Prj\l3CheckDepWith_m0.dpr
program l3CheckDepWith_m0;
{* Проект для проверки зависимостей библиотеки L3, с библиотекой m0. }

{ Библиотека "L3 (Low Level Library)" }
{ Автор: Люлин А.В. ©                 }
{ Модуль: l3CheckDepWithout_m0 - проект для проверки зависимостей библиотеки L3, с библиотекой m0. }
{ Начат: 09.12.2003 20:54             }
{ $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $ }

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.1  2003/12/09 17:58:32  law
// - new project: l3CheckDepWith_m0.dpr.
//

uses
  l3Base
  ;

begin
end.
..\..\m3\m1define.inc
{$IfNDef m1Define}
 {$Define m1Define}
 {$Include l3Define.inc}
{$EndIf}
..\..\m3\m3define.inc
(*
//
//
// .Author: Mickael P. Golovin.
// .Copyright: 1997-2001 by Archivarius Team, _free for non commercial use.
//
//
*)
// $Id: Test109.ms.script.out,v 1.57 2016/03/04 10:38:28 lulin Exp $

// $Log: Test109.ms.script.out,v $
// Revision 1.57  2016/03/04 10:38:28  lulin
// - перегенерация.
//
// Revision 1.34  2014/11/05 12:28:56  lulin
// - перетряхиваем код.
//
// Revision 1.33  2014/10/31 14:14:30  lulin
// - перетряхиваем код.
//
// Revision 1.32  2014/10/16 09:02:51  lulin
// - очередной раз удаляем "совсем старое хранилище".
//
// Revision 1.31  2014/10/14 14:27:32  lulin
// - "возвращаем" старое хранилище.
//
// Revision 1.30  2014/10/13 10:28:53  lulin
// - отключаем "совсем старое хранилище".
//
// Revision 1.29  2014/09/11 13:11:29  lulin
// - отключаем логирование заголовка рутового потока.
//
// Revision 1.28  2014/09/05 13:03:48  lulin
// - восстанавливаем "вилку".
//
// Revision 1.27  2014/09/01 15:48:44  lulin
// - вычищаем мусор.
//
// Revision 1.26  2014/08/29 13:17:41  lulin
// - чистим код.
//
// Revision 1.25  2014/08/29 12:15:51  lulin
// - заменяем условную директиву на переменную.
//
// Revision 1.24  2014/08/29 11:22:08  lulin
// - заменяем условную директиву на переменную.
//
// Revision 1.23  2014/08/26 07:08:05  fireton
// - утилита восстановления хранилища
//
// Revision 1.22  2014/08/21 07:15:08  lulin
// - чистим код.
//
// Revision 1.21  2014/05/12 17:16:19  lulin
// - включаем многопоточность.
//
// Revision 1.20  2012/06/09 13:03:31  voba
// no message
//
// Revision 1.19  2012/06/05 13:10:52  voba
// no message
//
// Revision 1.18  2012/05/30 14:15:27  voba
// no message
//
// Revision 1.17  2012/05/30 14:14:36  voba
// no message
//
// Revision 1.16  2012/05/05 14:43:48  lulin
// {RequestLink:361038156}
//
// Revision 1.15  2012/05/05 12:21:54  lulin
// {RequestLink:361038156}
//
// Revision 1.13  2012/05/05 11:46:51  lulin
// {RequestLink:361038156}
//
// Revision 1.12  2012/05/05 08:32:37  lulin
// {RequestLink:361038156}
//
// Revision 1.11  2012/05/05 08:22:53  dinishev
// Bug fix: не загруажались документы в АрчиТест.
//
// Revision 1.10  2012/05/04 19:42:49  lulin
// {RequestLink:361038156}
//
// Revision 1.9  2012/01/20 13:16:24  dinishev
// {Requestlink:327822716}
//
// Revision 1.8  2011/12/28 09:29:10  lulin
// {RequestLink:325257155}
// - чистим код.
//
// Revision 1.7  2009/03/19 16:28:30  lulin
// [$139443095].
//
// Revision 1.6  2009/03/19 12:39:33  lulin
// - переносим директиву в правильный файл.
//
// Revision 1.5  2009/03/12 19:08:25  lulin
// - <K>: 138969458. Чистка устаревшего кода.
//
// Revision 1.4  2009/03/12 12:28:45  lulin
// - <K>: 138969458. Удаляем ненужные файлы, методы и классы.
//
// Revision 1.3  2009/03/11 19:27:28  lulin
// - <K>: 138969458. Удалены ненужные классы.
//
// Revision 1.2  2007/08/30 10:09:25  lulin
// - убираем ненужную функцию поиска.
//
// Revision 1.1  2004/09/02 08:09:49  law
// - cleanup.
//
// Revision 1.11  2004/08/17 15:19:00  law
// - убрал лишний inc.
//
// Revision 1.10  2004/06/01 08:04:15  law
// - расставлены define'ы для _ALCU.
//
// Revision 1.9  2002/03/18 16:49:14  law
// - new directive: _m3UseSTSorter.
//
// Revision 1.8  2002/03/11 15:09:37  law
// - new directive: m3MultiThreadIndex.
//
// Revision 1.7  2001/12/24 14:44:57  voba
// - bug fix: подключили новый индексатор к Архивариусу.
//
// Revision 1.6  2001/12/20 14:12:11  law
// - new behavior: сделано использование морфологического разбора при поиске и индексации.
//
// Revision 1.5  2001/11/29 17:02:43  law
// - new directive: _m3NeedStorageFixer.
//
// Revision 1.4  2001/11/01 14:57:45  law
// - new directive: m3UseL3StreamAdapter.
//
// Revision 1.3  2001/10/30 13:40:56  law
// - change: вставлены теги CVS.
//

{$IFNDEF _m3DEFINE_INC}{$DEFINE _m3DEFINE_INC}

{$I l3Define.inc}

 {$Define Median}

 {.$Define m3MultiThreadIndex}
 {.$Define m3MultiThreadSorter}
 
 {$IFNDEF _m3AUTOCREATEHEADER0}
  {.$DEFINE _m3AUTOCREATEHEADER0}
 {$ENDIF}

 {$IFNDEF _m3AUTOCREATEHEADER0}
  {$IFNDEF _m3AUTOCREATEHEADER1}
   {$DEFINE _m3AUTOCREATEHEADER1}
  {$ENDIF}
 {$ENDIF}

{$IfDef ALCU}
  {.$Define m3NotMultiThreadStorage}
{$EndIf ALCU}

{$IFDEF nsTest}
 {.$Define m3NotMultiThreadStorage}
{$Else  nsTest}
 {$IfDef Nemesis}
  {$Define m3NotMultiThreadStorage}
 {$EndIf Nemesis}
{$ENDIF nsTest}

{$Define m3DBNeedsFork}

{$IFDEF m3DBDontNeedFork}
 {$UNDEF m3DBNeedsFork}
{$ENDIF}

{$IfNDef m3NotMultiThreadStorage}
 {$Define m3MultiThreadStorage}
{$EndIf  m3NotMultiThreadStorage}

{$Define m3StorageHasGarbage}

{$IfDef Nemesis}
{$IFDEF nsTest}
 {$DEFINE m3StorageHasGarbage}
{$ELSE}
 {$Undef m3StorageHasGarbage}
{$ENDIF nsTest}
{$EndIf Nemesis}

{$IfDef m3StorageHasGarbage}
 {$Define m3ClusterHasCRC}
 {$Define m3StoreHasCRC}
 {$Define m3StoreHas_Body}
 {$Define m3StoreHasGUID}
{$EndIf m3StorageHasGarbage}

{.$Define m3LogRootStreamHeaderLocks}

{$ENDIF}
..\..\m4\m4Define.inc
(*
//
//
// .Author: Mickael P. Golovin.
// .Copyright: 1997-2001 by Archivarius Team, free for non commercial use.
//
//
*)
{$IFNDEF _m4DEFINE_INC}{$DEFINE _m4DEFINE_INC}

{$I m3Define.inc }

{$ENDIF}
..\..\PG\pgDefine.inc
{$Include daDefine.inc}

..\..\RenderEVD\evDefine.inc
{$Include w:\common\components\gui\Garant\Everest\evDefine.inc}
..\..\ScriptEngine\seDefine.inc
{$IfDef NoEverest}
 {$Include l3Define.inc}
{$Else  NoEverest}
 {$Include evDefine.inc}
{$EndIf NoEverest}

{$Define seCacheDict}

{$Define seTypeCheck}

{$IfDef NewGen}
 {.$Undef seCacheDict}
{$EndIf NewGen}
..\..\ScriptEngine\vcmDefine.inc
{$Include W:\common\components\gui\Garant\VCM\vcmDefine.inc}
..\..\ScriptEngine\Examples\Test1.ms.script
1 2 + .
..\..\ScriptEngine\Examples\Test10.ms.script
for [ 1 2 3 4 5 6 7 9 10 ] .
..\..\ScriptEngine\Examples\Test100.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test101.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test102.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test103.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test104.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
   FILE VAR l_File
//   l_File := ( anItem File:OpenRead )
   TRY
   FINALLY
    l_File := nil
   END
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test105.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
   FILE VAR l_File
//   l_File := ( anItem File:OpenRead )
   TRY
   FINALLY
    l_File := nil
   END
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
  @ DoFile '*.fmx' anItem ProcessFilesWithMask
  @ DoFile '*.xml' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test106.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
   FILE VAR l_File
//   l_File := ( anItem File:OpenRead )
   TRY
   FINALLY
    l_File := nil
   END
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
  @ DoFile '*.fmx' anItem ProcessFilesWithMask
  @ DoFile '*.xml' anItem ProcessFilesWithMask
  @ DoFile '*.dpr' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test107.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
   FILE VAR l_File
   l_File := ( anItem File:OpenRead )
   TRY
   FINALLY
    l_File := nil
   END
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
  @ DoFile '*.fmx' anItem ProcessFilesWithMask
  @ DoFile '*.xml' anItem ProcessFilesWithMask
  @ DoFile '*.dpr' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test108.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
   FILE VAR l_File
   anItem File:OpenRead >>> l_File
   TRY
   FINALLY
    l_File := nil
   END
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
  @ DoFile '*.fmx' anItem ProcessFilesWithMask
  @ DoFile '*.xml' anItem ProcessFilesWithMask
  @ DoFile '*.dpr' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test109.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
   FILE VAR l_File
   anItem File:OpenRead >>> l_File
   TRY
    l_File File:ReadLines ( W-STRING IN aString aString . )
   FINALLY
    l_File := nil
   END
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  //@ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
  @ DoFile '*.fmx' anItem ProcessFilesWithMask
  @ DoFile '*.xml' anItem ProcessFilesWithMask
  @ DoFile '*.dpr' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test11.ms.script
Test ForToTest

 ARRAY operator to 
   ^@ IN aFrom
   ^ IN aTo
  @ ( 
   OBJECT IN aLambda
   INTEGER VAR I
   I := ( aFrom DO )
   Dec I
   ( aTo DO I ) - LOOP ( Inc I I aLambda DO ) 
  ) FunctorToIterator >>> Result
 ; // to
 
 for ( 1 to 10 ) .
 // - печатает числа от 1 до 10
 '' .
 for ( 1 to 20 ) .
 // - печатает числа от 1 до 20
 '' .
 for ( 0 to 20 ) .
 // - печатает числа от 0 до 20
 '' .
 for ( -1 to 20 ) .
 // - печатает числа от -1 до 20
 '' .
 for ( -1 to 21 ) .
 // - печатает числа от -1 до 21
 '' .
 0 for ( 1 to 10 ) + .
 // - суммирует числа от 1 до 10 и печатает результат
 '' .
 for ( 1 to 10 Reverted ) .
 // - печатает числа от 10 до 1
 
/*{ 
 ARRAY VAR L
 
 1to 10 >>> L
 
 @ . L ITERATE
 // - печатает числа от 1 до 10
 '' .
 @ . 1to 20 ITERATE
 // - печатает числа от 1 до 20
 '' .
 0 @ + L ITERATE .
 // - суммирует числа от 1 до 10 и печатает результат
 '' .
 @ . L Reverted ITERATE
 // - печатает числа от 10 до 1}*/
; // ForToTest

ForToTest
..\..\ScriptEngine\Examples\Test110.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
  @ DoFile '*.fmx' anItem ProcessFilesWithMask
  @ DoFile '*.xml' anItem ProcessFilesWithMask
  @ DoFile '*.dpr' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test111.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ DoFile '*.ms.dict' anItem ProcessFilesWithMask
  @ DoFile '*.pas' anItem ProcessFilesWithMask
  @ DoFile '*.txt' anItem ProcessFilesWithMask
  @ DoFile '*.inc' anItem ProcessFilesWithMask
  @ DoFile '*.fmx' anItem ProcessFilesWithMask
  @ DoFile '*.xml' anItem ProcessFilesWithMask
  @ DoFile '*.dpr' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test112.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   @ DoFile aMask anItem ProcessFilesWithMask
  )
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test113.ms.script
FORWARD Process

PROCEDURE IterateFilesWithMask
  ^ IN aDir
  ^ IN aMask
  ^ IN aLambda
  aLambda aMask DO aDir DO ProcessFilesWithMask
; // IterateFilesWithMask

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask anItem aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test114.ms.script
USES
 files.ms.dict
;

FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask anItem aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test115.ms.script

FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask anItem aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test116.ms.script
PROCEDURE IterateDirs
 ^ IN aRoot
 ^ IN aLabda
 aLabda aRoot DO ProcessSubDirs
; // IterateDirs

FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask anItem aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  IterateDirs anItem ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test117.ms.script

FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask anItem aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  IterateDirs anItem ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test118.ms.script

FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem Print
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask anItem aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  IterateDirs anItem ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test119.ms.script

FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN aDir

  : DoFile
   STRING IN anFilePath
   anFilePath Print
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN aDir
  aDir DoDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test12.ms.script
USES
 to.ms.dict
;

for ( 1 to 20 ) .
..\..\ScriptEngine\Examples\Test120.ms.script

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN aDir

  : DoFile
   STRING IN anFilePath
   anFilePath Print
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN aDir
  aDir DoDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test121.ms.script
PROCEDURE PrintThis
 ^ IN aValue
 aValue DO Print
; // PrintThis

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN aDir

  : DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN aDir
  aDir DoDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test122.ms.script
: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN aDir

  : DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 : ProcessItem
  STRING IN aDir
  aDir DoDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test123.ms.script
PROCEDURE Process
 STRING IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  STRING IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  aDir DoDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test124.ms.script
PROCEDURE ProcessDirs
 STRING IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  STRING IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  aDir DoDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // ProcessDirs

'..\..\' ProcessDirs
..\..\ScriptEngine\Examples\Test125.ms.script
PROCEDURE ProcessDirs
 STRING IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  ^ IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask ( aDir DO ) aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // ProcessDirs

'..\..\' ProcessDirs
..\..\ScriptEngine\Examples\Test126.ms.script
PROCEDURE ProcessDirs
 STRING IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  ^ IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask ( aDir DO ) aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // ProcessDirs

'..\..\' ProcessDirs
..\..\ScriptEngine\Examples\Test127.ms.script
PROCEDURE ProcessDirs
 STRING IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  ^ IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir ProcessItem
; // ProcessDirs

'..\..\' ProcessDirs
..\..\ScriptEngine\Examples\Test128.ms.script
PROCEDURE ProcessDirs
 ^ IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  ^ IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test129.ms.script
WordAlias RIGHT ^

PROCEDURE ProcessDirs
 RIGHT IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  RIGHT IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test13.ms.script
USES
 to.ms.dict
;

for ( @ ( IN anItem true ) ( 1 to 20 ) FILTER ) .
..\..\ScriptEngine\Examples\Test130.ms.script
USES
 params.ms.dict
;

PROCEDURE ProcessDirs
 RIGHT IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  RIGHT IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test131.ms.script
PROCEDURE ProcessDirs
 RIGHT IN aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  RIGHT IN aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test132.ms.script
VOID IMMEDIATE operator RightParam
 'RIGHT' Ctx:Parser:PushSymbol
 'IN' Ctx:Parser:PushSymbol
; // RightParam

PROCEDURE ProcessDirs
 RightParam aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test133.ms.script
PROCEDURE ProcessDirs
 RightParam aDir

 FORWARD ProcessItem

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test134.ms.script
PROCEDURE ProcessDirs
 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 FORWARD ProcessItem

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test135.ms.script
VOID IMMEDIATE operator RecurseProc
// - процедура, которая умеет вызываться рекурсивно
 ^L IN aName
 'FORWARD' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // RecurseProc

PROCEDURE ProcessDirs
 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 RecurseProc ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // RecurseProc

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test136.ms.script
PROCEDURE ProcessDirs
 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 RecurseProc ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // RecurseProc

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test137.ms.script
for ( 0 to sysutils:ParamCount ) Print
..\..\ScriptEngine\Examples\Test138.ms.script
for ( 0 to sysutils:ParamCount ) ( sysutils:ParamStr Print )
..\..\ScriptEngine\Examples\Test139.ms.script
PROCEDURE ProcessDirs
 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 RecurseProc ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // RecurseProc

 aDir DO ProcessItem
 @SELF DumpElement
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test14.ms.script
USES
 to.ms.dict
;

0 for ( @ ( IN anItem true ) ( 1 to 20 ) FILTER ) + .
..\..\ScriptEngine\Examples\Test140.ms.script
PROCEDURE ProcessDirs
 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 RecurseProc ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // RecurseProc

 aDir DO ProcessItem
 @SELF DumpElement
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test141.ms.script
PROCEDURE ProcessDirs
 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 RecurseProc ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ProcessItem
 ; // RecurseProc

 aDir DO ProcessItem
 @SELF DumpElement
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test142.ms.script
PROCEDURE ProcessDirs

 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 RecurseProc ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // RecurseProc

 aDir DO ProcessItem
 @SELF DumpElement
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test143.ms.script
PROCEDURE ProcessDirs

 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // RecurseProc

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test144.ms.script
PROCEDURE ProcessDirs

 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test145.ms.script
PROCEDURE ProcessDirs
 ARRAY IN aMaskArray
 RightParam aDir

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for aMaskArray (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

[ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] ProcessDirs '..\..\'
..\..\ScriptEngine\Examples\Test146.ms.script
PROCEDURE ProcessDirs
 RightParam aDir
 RightParam aMaskArray

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   PrintThis anFilePath
  ; // DoFile

  for ( aMaskArray |^ ) (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ]
..\..\ScriptEngine\Examples\Test147.ms.script
PROCEDURE ProcessDirs
 FUNCTOR IN aLambda
 RightParam aDir
 RightParam aMaskArray

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   anFilePath aLambda DO
  ; // DoFile

  for ( aMaskArray |^ ) (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

@ Print ProcessDirs '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ]
..\..\ScriptEngine\Examples\Test148.ms.script
PROCEDURE ProcessDirs
 RightParam aDir
 RightParam aMaskArray
 RightParam aLambda

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   anFilePath aLambda pop:Word:GetRef DO
  ; // DoFile

  for ( aMaskArray |^ ) (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] Print
..\..\ScriptEngine\Examples\Test149.ms.script
PROCEDURE ProcessDirs
 RightParam aDir
 RightParam aMaskArray
 RightParam aLambda

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   anFilePath aLambda pop:Word:GetRef DO
  ; // DoFile

  for ( aMaskArray |^ ) (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] Print
..\..\ScriptEngine\Examples\Test15.ms.script
USES
 to.ms.dict
;

for ( @ ( IN anItem anItem 2 MOD 0 == ) ( 1 to 20 ) FILTER ) .
// - печатаем чётные числа
..\..\ScriptEngine\Examples\Test150.ms.script
PROCEDURE ProcessDirs
 RightParam aDir
 RightParam aMaskArray
 RightParam aLambda

 PROCEDURE DoDir
  RightParam aDir

  PROCEDURE DoFile
   STRING IN anFilePath
   anFilePath aLambda |@ DO
  ; // DoFile

  for ( aMaskArray |^ ) (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // ProcessItem

 aDir DO ProcessItem
; // ProcessDirs

ProcessDirs '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] Print
..\..\ScriptEngine\Examples\Test151.ms.script
PROCEDURE ProcessSubDirsWithMasks
 RightParam aRoot
 RightParam aMaskArray
 RightParam aLambda

 PRIVATE PROCEDURE DoDir
  RightParam aDir

  PRIVATE PROCEDURE DoFile
   STRING IN anFilePath
   anFilePath aLambda |@ DO
  ; // DoFile

  for ( aMaskArray |^ ) (
   STRING IN aMask
   IterateFilesWithMask aDir aMask DoFile
  )
 ; // DoDir

 PRIVATE PROCEDURE ProcessItem
  STRING IN aDir
  DoDir aDir
  IterateDirs aDir ( this.do )
 ; // ProcessItem

 aRoot DO ProcessItem
; // ProcessSubDirsWithMasks

ProcessSubDirsWithMasks '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] Print
..\..\ScriptEngine\Examples\Test152.ms.script
ProcessSubDirsWithMasks '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' ] Print
..\..\ScriptEngine\Examples\Test153.ms.script
ProcessSubDirsWithMasks '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print
..\..\ScriptEngine\Examples\Test154.ms.script
PROCEDURE ProcessAnySubDirsWithMasks

 ProcessSubDirsWithMasks '..\..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print
 ProcessSubDirsWithMasks '..\' [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print

; // ProcessAnySubDirsWithMasks

ProcessAnySubDirsWithMasks
..\..\ScriptEngine\Examples\Test155.ms.script
PROCEDURE ProcessAnySubDirsWithMasks

 ARRAY IN aDirMasks

 for aDirMasks ( STRING IN aDirMask ProcessSubDirsWithMasks aDirMask [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print )

; // ProcessAnySubDirsWithMasks

[ '..\..\' '..\' ] ProcessAnySubDirsWithMasks
..\..\ScriptEngine\Examples\Test156.ms.script
PROCEDURE ProcessAnySubDirsWithMasks

 RightParam aDirMasks

 for ( aDirMasks |^ ) ( STRING IN aDirMask ProcessSubDirsWithMasks aDirMask [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print )

; // ProcessAnySubDirsWithMasks

ProcessAnySubDirsWithMasks [ '..\..\' '..\' ]
..\..\ScriptEngine\Examples\Test157.ms.script
PROCEDURE ProcessAnySubDirsWithMasks

 ARRAY IN aFileMasks
 RightParam aDirMasks

 for ( aDirMasks |^ ) ( STRING IN aDirMask ProcessSubDirsWithMasks aDirMask aFileMasks Print )

; // ProcessAnySubDirsWithMasks

[ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] ProcessAnySubDirsWithMasks [ '..\..\' '..\' ]
..\..\ScriptEngine\Examples\Test158.ms.script
PROCEDURE ProcessAnySubDirsWithMasks

 RightParam aDirMasks
 RightParam aFileMasks

 for ( aDirMasks |^ ) ( STRING IN aDirMask ProcessSubDirsWithMasks aDirMask ( aFileMasks |^ ) Print )

; // ProcessAnySubDirsWithMasks

ProcessAnySubDirsWithMasks [ '..\..\' '..\' ] [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ]
..\..\ScriptEngine\Examples\Test159.ms.script
PROCEDURE ProcessAnySubDirsWithMasks

 RightParam aDirMasks
 RightParam aFileMasks
 RightParam aLambda

 for ( aDirMasks |^ ) ( STRING IN aDirMask ProcessSubDirsWithMasks aDirMask ( aFileMasks |^ ) ( STRING IN aFile aFile aLambda |@ DO ) )

; // ProcessAnySubDirsWithMasks

ProcessAnySubDirsWithMasks [ '..\..\' '..\' ] [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print
..\..\ScriptEngine\Examples\Test16.ms.script
USES
 to.ms.dict
;

for ( @ ( IN anItem anItem 2 MOD 0 != ) ( 1 to 20 ) FILTER ) .
// - печатаем нечётные числа
..\..\ScriptEngine\Examples\Test160.ms.script
PROCEDURE ProcessAnySubDirsWithMasks

 RightParam aDirMasks
 RightParam aFileMasks
 RightParam aLambda

 for ( aDirMasks |^ ) ( STRING IN aDirMask ProcessSubDirsWithMasks aDirMask ( aFileMasks |^ ) ( aLambda |@ DO ) )

; // ProcessAnySubDirsWithMasks

ProcessAnySubDirsWithMasks [ '..\..\' '..\' ] [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print
..\..\ScriptEngine\Examples\Test161.ms.script
ProcessAnySubDirsWithMasks [ '..\..\' '..\' ] [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print
..\..\ScriptEngine\Examples\Test162.ms.script
ProcessAnySubDirsWithMasks [ '..\..\' '..\' '.' ] [ '*.ms.script' '*.ms.dict' '*.pas' '*.txt' '*.inc' '*.fmx' '*.xml' '*.dpr' '*.co' ] Print
..\..\ScriptEngine\Examples\Test17.ms.script
USES
 to.ms.dict
;

BOOLEAN FUNCTION IsEven
 INTEGER IN aValue
 aValue 2 MOD 0 == >>> Result
; // IsEven

for ( @ ( IN anItem anItem IsEven ) ( 1 to 20 ) FILTER ) .
// - печатаем чётные числа
..\..\ScriptEngine\Examples\Test18.ms.script
USES
 to.ms.dict
;

BOOLEAN FUNCTION IsEven
 INTEGER IN aValue
 aValue 2 MOD 0 == >>> Result
; // IsEven

BOOLEAN FUNCTION IsOdd
 INTEGER IN aValue
 aValue IsEven ! >>> Result
; // IsOdd

for ( @ ( IN anItem anItem IsOdd ) ( 1 to 20 ) FILTER ) .
// - печатаем нечётные числа
..\..\ScriptEngine\Examples\Test19.ms.script
USES
 to.ms.dict
 math.ms.dict
;

for ( @ ( IN anItem anItem IsOdd ) ( 1 to 20 ) FILTER ) .
// - печатаем нечётные числа
..\..\ScriptEngine\Examples\Test2.ms.script
1 2 + .
//1 2 + Msg
..\..\ScriptEngine\Examples\Test20.ms.script
USES
 to.ms.dict
 math.ms.dict
;

for ( @ IsOdd ( 1 to 20 ) FILTER ) .
// - печатаем нечётные числа
..\..\ScriptEngine\Examples\Test21.ms.script
USES
 to.ms.dict
 math.ms.dict
;

WordAlias filter FILTER

for ( @ IsOdd ( 1 to 20 ) filter ) .
// - печатаем нечётные числа
..\..\ScriptEngine\Examples\Test22.ms.script
USES
 to.ms.dict
 math.ms.dict
;

WordAlias filter FILTER

ARRAY FUNCTION >filter>
 ARRAY IN anArray
 ^ FUNCTOR IN aFunctor
 aFunctor anArray filter >>> Result
; // >filter>

for ( ( 1 to 20 ) >filter> IsOdd ) .
// - печатаем нечётные числа
'-------------------' .
for ( ( 1 to 20 ) >filter> IsEven ) .
// - печатаем чётные числа
..\..\ScriptEngine\Examples\Test23.ms.script
USES
 to.ms.dict
 math.ms.dict
;

WordAlias filter FILTER

ARRAY FUNCTION >filter>
 ^@ FUNCTOR IN anArray
 ^ FUNCTOR IN aFunctor
 aFunctor anArray DO filter >>> Result
; // >filter>

for ( ( 1 to 20 ) >filter> IsOdd ) .
// - печатаем нечётные числа
'-------------------' .
for ( ( 1 to 20 ) >filter> IsEven ) .
// - печатаем чётные числа
..\..\ScriptEngine\Examples\Test24.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
;

for ( ( 1 to 20 ) >filter> IsOdd ) .
// - печатаем нечётные числа
'-------------------' .
for ( ( 1 to 20 ) >filter> IsEven ) .
// - печатаем чётные числа
..\..\ScriptEngine\Examples\Test25.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
;

WordAlias Print .

for ( ( 1 to 20 ) >filter> IsOdd ) Print
// - печатаем нечётные числа
'-------------------' .
for ( ( 1 to 20 ) >filter> IsEven ) Print
// - печатаем чётные числа
..\..\ScriptEngine\Examples\Test26.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
;

for ( ( 1 to 20 ) >filter> IsOdd ) Print
// - печатаем нечётные числа
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven ) Print
// - печатаем чётные числа
..\..\ScriptEngine\Examples\Test27.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
;

for ( @ ( IN anItem anItem 1 + ) ( 1 to 20 ) >filter> IsOdd MAP ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( @ ( IN anItem anItem 1 + ) ( 1 to 20 ) >filter> IsEven MAP ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test28.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
;

for ( @ ( 1 + ) ( 1 to 20 ) >filter> IsOdd MAP ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( @ ( 1 + ) ( 1 to 20 ) >filter> IsEven MAP ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test29.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
;

@ ( 1 + ) ( 1 to 20 ) >filter> IsOdd MAP Print
// - печатаем нечётные числа + 1
'-------------------' Print
@ ( 1 + ) ( 1 to 20 ) >filter> IsEven MAP Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test3.ms.script
[ 1 2 3 4 5 ] .
..\..\ScriptEngine\Examples\Test30.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
;

WordAlias map MAP

for ( @ ( 1 + ) ( 1 to 20 ) >filter> IsOdd map ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( @ ( 1 + ) ( 1 to 20 ) >filter> IsEven map ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test31.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
;

WordAlias map MAP

ARRAY FUNCTION >map>
 ^@ FUNCTOR IN anArray
 ^ FUNCTOR IN aFunctor
 aFunctor anArray DO map >>> Result
; // >map>

for ( ( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> ( 1 + ) ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test32.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
 map.ms.dict
;

for ( ( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> ( 1 + ) ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test33.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
 map.ms.dict
;

( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
( 1 to 20 ) >filter> IsEven >map> ( 1 + ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test34.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
 map.ms.dict
;

for ( ( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) Reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> ( 1 + ) Reverted ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test35.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
 map.ms.dict
;

WordAlias REVERTED Reverted
WordAlias reverted REVERTED

for ( ( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> ( 1 + ) reverted ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test36.ms.script
USES
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
 map.ms.dict
 reverted.ms.dict
;

for ( ( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> ( 1 + ) reverted ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test37.ms.script
WordAlias uses USES

uses
 to.ms.dict
 math.ms.dict
 filter.ms.dict
 io.ms.dict
 map.ms.dict
 reverted.ms.dict
;

for ( ( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> ( 1 + ) reverted ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test38.ms.script
WordAlias uses USES

uses
 math.ms.dict
 io.ms.dict
 arrays.ms.dict
;

for ( ( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> ( 1 + ) reverted ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test39.ms.script
for ( ( 1 to 20 ) >filter> IsOdd >map> ( 1 + ) reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> ( 1 + ) reverted ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test4.ms.script
help
..\..\ScriptEngine\Examples\Test40.ms.script
for ( ( 1 to 20 ) >filter> IsOdd >map> Inc1 reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> Inc1 reverted ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test41.ms.script

for ( ( 1 to 20 ) >filter> IsOdd >map> Inc1 reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> Inc1 reverted ) Print
// - печатаем чётные числа + 1
..\..\ScriptEngine\Examples\Test42.ms.script

for ( ( 1 to 20 ) >filter> IsOdd >map> Inc1 reverted ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> Inc1 reverted ) Print
// - печатаем чётные числа + 1

for ( ( 1 to 20 ) >filter> IsOdd >map> Dec1 reverted ) Print
// - печатаем нечётные числа - 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> Dec1 reverted ) Print
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test43.ms.script

for ( ( 1 to 20 ) >filter> IsOdd >map> Inc1 >reverted> ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> Inc1 >reverted> ) Print
// - печатаем чётные числа + 1

for ( ( 1 to 20 ) >filter> IsOdd >map> Dec1 >reverted> ) Print
// - печатаем нечётные числа - 1
'-------------------' Print
for ( ( 1 to 20 ) >filter> IsEven >map> Dec1 >reverted> ) Print
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test44.ms.script
USES
 Translate.ms.dict
;

перебрать ( ( 1 to 20 ) >filter> IsOdd >map> Inc1 >reverted> ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
перебрать ( ( 1 to 20 ) >filter> IsEven >map> Inc1 >reverted> ) Print
// - печатаем чётные числа + 1

перебрать ( ( 1 to 20 ) >filter> IsOdd >map> Dec1 >reverted> ) Print
// - печатаем нечётные числа - 1
'-------------------' Print
перебрать ( ( 1 to 20 ) >filter> IsEven >map> Dec1 >reverted> ) Print
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test45.ms.script
USES
 Translate.ms.dict
;

перебрать ( ( 1 to 20 ) отобрать IsOdd >map> Inc1 >reverted> ) Print
// - печатаем нечётные числа + 1
'-------------------' Print
перебрать ( ( 1 to 20 ) отобрать IsEven >map> Inc1 >reverted> ) Print
// - печатаем чётные числа + 1

перебрать ( ( 1 to 20 ) отобрать IsOdd >map> Dec1 >reverted> ) Print
// - печатаем нечётные числа - 1
'-------------------' Print
перебрать ( ( 1 to 20 ) отобрать IsEven >map> Dec1 >reverted> ) Print
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test46.ms.script
USES
 Translate.ms.dict
;

перебрать ( ( 1 to 20 ) отобрать IsOdd >map> Inc1 >reverted> ) напечатать
// - печатаем нечётные числа + 1
'-------------------' Print
перебрать ( ( 1 to 20 ) отобрать IsEven >map> Inc1 >reverted> ) напечатать
// - печатаем чётные числа + 1

перебрать ( ( 1 to 20 ) отобрать IsOdd >map> Dec1 >reverted> ) напечатать
// - печатаем нечётные числа - 1
'-------------------' Print
перебрать ( ( 1 to 20 ) отобрать IsEven >map> Dec1 >reverted> ) напечатать
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test47.ms.script
USES
 Translate.ms.dict
;

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Inc1 >reverted> ) напечатать
// - печатаем нечётные числа + 1
'-------------------' Print
перебрать ( ( 1 to 20 ) отобрать IsEven >map> Inc1 >reverted> ) напечатать
// - печатаем чётные числа + 1

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Dec1 >reverted> ) напечатать
// - печатаем нечётные числа - 1
'-------------------' Print
перебрать ( ( 1 to 20 ) отобрать IsEven >map> Dec1 >reverted> ) напечатать
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test48.ms.script
USES
 Translate.ms.dict
;

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Inc1 >reverted> ) напечатать
// - печатаем нечётные числа + 1
'-------------------' Print
перебрать ( ( 1 to 20 ) отобрать чётные >map> Inc1 >reverted> ) напечатать
// - печатаем чётные числа + 1

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Dec1 >reverted> ) напечатать
// - печатаем нечётные числа - 1
'-------------------' Print
перебрать ( ( 1 to 20 ) отобрать чётные >map> Dec1 >reverted> ) напечатать
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test49.ms.script
USES
 Translate.ms.dict
;

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Inc1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1
'-------------------' напечатать
перебрать ( ( 1 to 20 ) отобрать чётные >map> Inc1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1
'-------------------' напечатать
перебрать ( ( 1 to 20 ) отобрать чётные >map> Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test5.ms.script
@ ( IN anItem true ) [ 1 2 3 4 5 ] FILTER .
..\..\ScriptEngine\Examples\Test50.ms.script
USES
 Translate.ms.dict
;

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Inc1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

разделитель

перебрать ( ( 1 to 20 ) отобрать чётные >map> Inc1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

разделитель

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

разделитель

перебрать ( ( 1 to 20 ) отобрать чётные >map> Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1
..\..\ScriptEngine\Examples\Test51.ms.script
USES
 Translate.ms.dict
;

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Inc1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать ( ( 1 to 20 ) отобрать чётные >map> Inc1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать ( ( 1 to 20 ) отобрать нечётные >map> Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать ( ( 1 to 20 ) отобрать чётные >map> Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test52.ms.script
USES
 Translate.ms.dict
;

перебрать числа ( ( 1 to 20 ) отобрать нечётные >map> Inc1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать чётные >map> Inc1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать нечётные >map> Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать чётные >map> Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test53.ms.script
USES
 Translate.ms.dict
;

перебрать числа ( ( 1 to 20 ) отобрать нечётные каждое Inc1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать чётные каждое Inc1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать нечётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать чётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test54.ms.script

перебрать числа ( ( 1 to 20 ) отобрать нечётные каждое Inc1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать чётные каждое Inc1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать нечётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( 1 to 20 ) отобрать чётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test55.ms.script

перебрать числа ( ( 1 по 20 ) отобрать нечётные каждое Inc1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( 1 по 20 ) отобрать чётные каждое Inc1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( 1 по 20 ) отобрать нечётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( 1 по 20 ) отобрать чётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test56.ms.script

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое Inc1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое Inc1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test57.ms.script

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое "увеличить на 1" "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое "увеличить на 1" "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое Dec1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test58.ms.script

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое "увеличить на 1" "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое "увеличить на 1" "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое "уменьшить на 1" "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое "уменьшить на 1" "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test59.ms.script

числа ( ( с 1 по 20 ) отобрать нечётные каждое "увеличить на 1" "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

числа ( ( с 1 по 20 ) отобрать чётные каждое "увеличить на 1" "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

числа ( ( с 1 по 20 ) отобрать нечётные каждое "уменьшить на 1" "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

числа ( ( с 1 по 20 ) отобрать чётные каждое "уменьшить на 1" "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test6.ms.script
@ ( IN anItem true ) [ 1 2 3 4 5 ] FILTER ==> .
..\..\ScriptEngine\Examples\Test60.ms.script

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое "увеличить на" 1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое "увеличить на" 1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое "уменьшить на 1" "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое "уменьшить на 1" "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test61.ms.script

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое "увеличить на" 1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое "увеличить на" 1 "в обратном порядке" ) напечатать
// - печатаем чётные числа + 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать нечётные каждое "уменьшить на" 1 "в обратном порядке" ) напечатать
// - печатаем нечётные числа - 1

"вывести разделитель"

перебрать числа ( ( с 1 по 20 ) отобрать чётные каждое "уменьшить на" 1 "в обратном порядке" ) напечатать
// - печатаем чётные числа - 1

"вывести разделитель"
..\..\ScriptEngine\Examples\Test62.ms.script
'Size: ' 1024 IntToStr Cat Print
..\..\ScriptEngine\Examples\Test63.ms.script
[ 'Size: ' 1024 IntToStr ' bytes' ] strings:Cat Print
..\..\ScriptEngine\Examples\Test64.ms.script
STRING FUNCTION any:Cat
  ARRAY IN anArray
 '' anArray ==> ( ToPrintable Cat ) >>> Result
; // any:Cat

[ 'Size: ' 1024 ' bytes' ] any:Cat Print
..\..\ScriptEngine\Examples\Test65.ms.script
STRING FUNCTION string:CatWihAny
 STRING IN aString
 IN aValue
 aString aValue ToPrintable Cat >>> Result
; // string:CatWihAny

STRING FUNCTION any:Cat
  ARRAY IN anArray
 '' anArray ==> string:CatWihAny >>> Result
; // any:Cat

[ 'Size: ' 1024 ' bytes' ] any:Cat Print
..\..\ScriptEngine\Examples\Test66.ms.script
STRING FUNCTION string:CatWihAny
 STRING IN aString
 IN aValue
 aString aValue ToPrintable Cat >>> Result
; // string:CatWihAny

STRING FUNCTION any:Cat
  ARRAY IN anArray
 '' for anArray string:CatWihAny >>> Result
; // any:Cat

[ 'Size: ' 1024 ' bytes' ] any:Cat Print
..\..\ScriptEngine\Examples\Test67.ms.script
'Size: ' (+) ( 1024 ToPrintable ) (+) ' bytes' Print
..\..\ScriptEngine\Examples\Test68.ms.script
: (string)
 ^ IN aValue
 aValue DO ToPrintable
; // (string)

'Size: ' (+) (string) 1024 (+) ' bytes' Print
..\..\ScriptEngine\Examples\Test69.ms.script
'Size: ' (+) (string) 1024 (+) ' bytes' Print
..\..\ScriptEngine\Examples\Test7.ms.script
USES
 unit1.ms.dict
;

A .
..\..\ScriptEngine\Examples\Test70.ms.script
[ 'Size: ' 1024 ' bytes' ] any:Cat Print
..\..\ScriptEngine\Examples\Test71.ms.script
[ 'Size: ' 1024 ' bytes.' ' And it''s ' true ] any:Cat Print
..\..\ScriptEngine\Examples\Test72.ms.script
 TRY
  'Line too long' RAISE
 EXCEPT
  current:exception:Message Print
 END
..\..\ScriptEngine\Examples\Test73.ms.script
 TRY
  'got here' Print
  EXIT
  'not here' Print
 FINALLY
  'always here' Print
 END
..\..\ScriptEngine\Examples\Test74.ms.script
ORDINAL VAR A
@ A |N Print
@ A %ST |N Print
@ A pop:Word:Directives Print

"вывести разделитель"

COMPARABLE VAR B
@ B |N Print
@ B %ST |N Print
@ B pop:Word:Directives Print

"вывести разделитель"

STRING VAR C
@ C |N Print
@ C %ST |N Print
@ C pop:Word:Directives Print

"вывести разделитель"

INTEGER VAR D
@ D |N Print
@ D %ST |N Print
@ D pop:Word:Directives Print

..\..\ScriptEngine\Examples\Test75.ms.script
[ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] Print
..\..\ScriptEngine\Examples\Test76.ms.script
Test CodeDumpTest
 [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] Print
 @SELF DumpElement
;

CodeDumpTest
..\..\ScriptEngine\Examples\Test77.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
..\..\ScriptEngine\Examples\Test78.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
 @ ( 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ) DumpElement
..\..\ScriptEngine\Examples\Test79.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
 @ ( 1 2 3 ( 4 5 [ 6 7 8 ] 9 ) 10 ) DumpElement
..\..\ScriptEngine\Examples\Test8.ms.script
@ . '*.ms.script' '.' ProcessFilesWithMask
..\..\ScriptEngine\Examples\Test80.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
 @ ( 1 2 3 ( 4 5 [ 6 7 8 ] 9 ) 10 ) DumpElement
 @ ( 1 2 3 ( 4 5 ( 6 7 8 ) 9 ) 10 ) DumpElement
..\..\ScriptEngine\Examples\Test81.ms.script
@ DumpCode '*.ms.script' '.' ProcessFilesWithMask
..\..\ScriptEngine\Examples\Test82.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
 @ ( 1 2 3 ( 4 5 [ 6 7 8 ] 9 ) 10 ) DumpElement
 @ ( 1 2 3 ( 4 5 ( 6 7 8 ) 9 ) 10 ) DumpElement
 @ ( VAR X ) DumpElement
..\..\ScriptEngine\Examples\Test83.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
 @ ( 1 2 3 ( 4 5 [ 6 7 8 ] 9 ) 10 ) DumpElement
 @ ( 1 2 3 ( 4 5 ( 6 7 8 ) 9 ) 10 ) DumpElement
 @ ( VAR X ) DumpElement
 @ ( INTEGER VAR X ) DumpElement
..\..\ScriptEngine\Examples\Test84.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
 @ ( 1 2 3 ( 4 5 [ 6 7 8 ] 9 ) 10 ) DumpElement
 @ ( 1 2 3 ( 4 5 ( 6 7 8 ) 9 ) 10 ) DumpElement
 @ ( VAR X ) DumpElement
 @ ( INTEGER VAR X ) DumpElement
 @ ( STRING VAR X ) DumpElement
 @ ( BOOLEAN VAR X ) DumpElement
..\..\ScriptEngine\Examples\Test85.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
 @ ( 1 2 3 ( 4 5 [ 6 7 8 ] 9 ) 10 ) DumpElement
 @ ( 1 2 3 ( 4 5 ( 6 7 8 ) 9 ) 10 ) DumpElement
 @ ( VAR X ) DumpElement
 @ ( INTEGER VAR X ) DumpElement
 @ ( STRING VAR X ) DumpElement
 @ ( BOOLEAN VAR X ) DumpElement
 @ ( ATOMIC VAR X ) DumpElement
 @ ( ORDINAL VAR X ) DumpElement
 @ ( COMPARABLE VAR X ) DumpElement
..\..\ScriptEngine\Examples\Test86.ms.script
 @ [ 1 2 3 [ 4 5 [ 6 7 8 ] 9 ] 10 ] DumpElement
 @ ( 1 2 3 ( 4 5 [ 6 7 8 ] 9 ) 10 ) DumpElement
 @ ( 1 2 3 ( 4 5 ( 6 7 8 ) 9 ) 10 ) DumpElement
 @ ( VAR X ) DumpElement
 @ ( INTEGER VAR X ) DumpElement
 @ ( STRING VAR X ) DumpElement
 @ ( BOOLEAN VAR X ) DumpElement
 @ ( ATOMIC VAR X ) DumpElement
 @ ( ORDINAL VAR X ) DumpElement
 @ ( COMPARABLE VAR X ) DumpElement
 @ ( OBJECT VAR X ) DumpElement
 @ ( INTERFACE VAR X ) DumpElement
..\..\ScriptEngine\Examples\Test87.ms.script
@ . '.' ProcessSubDirs
..\..\ScriptEngine\Examples\Test88.ms.script
@ . '..' ProcessSubDirs
..\..\ScriptEngine\Examples\Test89.ms.script
: Process
 STRING IN aDir
 aDir ProcessSubDirs
; // Process

@ . '..' Process
..\..\ScriptEngine\Examples\Test9.ms.script
@ . '*.ms.script.co' '.' ProcessFilesWithMask
..\..\ScriptEngine\Examples\Test90.ms.script
: Process
 TtfwWord IN aLambda
 STRING IN aDir
 aLambda aDir ProcessSubDirs
; // Process

@ . '..' Process
..\..\ScriptEngine\Examples\Test91.ms.script
FORWARD Process

: Process
 TtfwWord IN aLambda
 STRING IN aDir
 aLambda aDir ProcessSubDirs
; // Process

@ . '..' Process
..\..\ScriptEngine\Examples\Test92.ms.script
FORWARD Process

: Process
 TtfwWord IN aLambda
 STRING IN aDir

 : ProcessItem
  STRING IN anItem
  anItem aLambda DO
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

@ . '..' Process
..\..\ScriptEngine\Examples\Test93.ms.script
FORWARD Process

: Process
 TtfwWord IN aLambda
 STRING IN aDir

 : ProcessItem
  STRING IN anItem
  anItem aLambda DO
  aLambda anItem Process
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

@ . '..' Process
..\..\ScriptEngine\Examples\Test94.ms.script
FORWARD Process

: Process
 TtfwWord IN aLambda
 STRING IN aDir

 : ProcessItem
  STRING IN anItem
  anItem aLambda DO
  aLambda anItem Process
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

@ . '..\..\' Process
..\..\ScriptEngine\Examples\Test95.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : ProcessItem
  STRING IN anItem
  anItem .
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test96.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : ProcessItem
  STRING IN anItem
  anItem .
  @ . '*.ms.script' anItem ProcessFilesWithMask
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test97.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : ProcessItem
  STRING IN anItem
  //anItem .
  @ . '*.ms.script' anItem ProcessFilesWithMask
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test98.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoFile
  STRING IN anItem
  anItem .
 ; // DoFile

 : ProcessItem
  STRING IN anItem
  //anItem .
  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\Test99.ms.script
FORWARD Process

: Process
 STRING IN aDir

 FORWARD ProcessItem

 : DoDir
  STRING IN anItem

  : DoFile
   STRING IN anItem
   anItem .
  ; // DoFile

  @ DoFile '*.ms.script' anItem ProcessFilesWithMask
 ; // DoDir

 : ProcessItem
  STRING IN anItem
  anItem DoDir
  @ ProcessItem anItem ProcessSubDirs
 ; // ProcessItem

 @ ProcessItem aDir ProcessSubDirs
; // Process

'..\..\' Process
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen0.ms.script
Test CodeGen

// ---------------------------------------------------------------------------

// Тут будем определять аксиоматику мета-модели, а потом вынесем её 
// в отдельный словарь.

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen1.ms.script
Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации'
 ;

// ---------------------------------------------------------------------------

// Тут будем определять аксиоматику мета-модели, а потом вынесем её 
// в отдельный словарь.

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные'
 ; // %SUMMARY 
; // meta

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen10.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

model-begin
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen11.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

model-begin
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

// Могут ли Library вкладываться в Project, а Project в Library
// Или могут ли Programm вкладываться в Class, а Class в Programm
// И прочие отношения между стереотипами - мы определим несколько позже.
// Когда начнём использовать их.

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen12.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

// Могут ли Library вкладываться в Project, а Project в Library
// Или могут ли Programm вкладываться в Class, а Class в Programm
// И прочие отношения между стереотипами - мы определим несколько позже.
// Когда начнём использовать их.

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen13.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

// Могут ли Library вкладываться в Project, а Project в Library
// Или могут ли Programm вкладываться в Class, а Class в Programm
// И прочие отношения между стереотипами - мы определим несколько позже.
// Когда начнём использовать их.

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY
; // Project1

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen14.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

// Могут ли Library вкладываться в Project, а Project в Library
// Или могут ли Programm вкладываться в Class, а Class в Programm
// И прочие отношения между стереотипами - мы определим несколько позже.
// Когда начнём использовать их.

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

; // Project1

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen15.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

// Могут ли Library вкладываться в Project, а Project в Library
// Или могут ли Programm вкладываться в Class, а Class в Programm
// И прочие отношения между стереотипами - мы определим несколько позже.
// Когда начнём использовать их.

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library2

; // Project1

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen16.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

// Могут ли Library вкладываться в Project, а Project в Library
// Или могут ли Programm вкладываться в Class, а Class в Programm
// И прочие отношения между стереотипами - мы определим несколько позже.
// Когда начнём использовать их.

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека
  '
  ; // %SUMMARY
 ; // Library3

; // Project1

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen17.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

// Могут ли Library вкладываться в Project, а Project в Library
// Или могут ли Programm вкладываться в Class, а Class в Programm
// И прочие отношения между стереотипами - мы определим несколько позже.
// Когда начнём использовать их.

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

 ; // Programm1

; // Project1

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen18.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

// Могут ли Library вкладываться в Project, а Project в Library
// Или могут ли Programm вкладываться в Class, а Class в Programm
// И прочие отношения между стереотипами - мы определим несколько позже.
// Когда начнём использовать их.

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

// РЕМАРКА.
// Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
// Но мы про это позже поговорим

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen19.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen2.ms.script
Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации'
 ;

// ---------------------------------------------------------------------------

// Тут будем определять аксиоматику мета-модели, а потом вынесем её 
// в отдельный словарь.

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные'
 ; // %SUMMARY 
; // meta

// Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

// Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

// Вот с них и начнём:

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen20.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Тепрь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его имя на стандартное устройство вывода.
 '

@ Project1 |N Print

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen21.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его имя на стандартное устройство вывода.
 '

@ Project1 |N Print

REMARK
 '
 Теперь выведем на стандартное устройство вывода имена всех его непосредственных детей.
 '

for ( @ Project1 MembersIterator ) ( |N Print )

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen22.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его имя на стандартное устройство вывода.
 '

PROCEDURE DumpModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели
 '
 ; // %SUMMARY
 aWord |N Print
; // DumpModelElement

@ Project1 DumpModelElement

REMARK
 '
 Теперь выведем на стандартное устройство вывода имена всех его непосредственных детей.
 '

for ( @ Project1 MembersIterator ) DumpModelElement

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen23.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его имя на стандартное устройство вывода.
 '

FORWARD DumpModelElement
 
PROCEDURE DumpModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N Print
 for ( aWord MembersIterator ) (
  TtfwWord IN aWord 
  aWord DumpModelElement
 )
; // DumpModelElement

@ Project1 DumpModelElement

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen24.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его имя на стандартное устройство вывода.
 '

FORWARD DumpModelElement
 
PROCEDURE DumpModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N Print
 for ( aWord MembersIterator ) (
  TtfwWord IN aWord 
  aWord DumpModelElement
 )
; // DumpModelElement

@ Project1 DumpModelElement

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen25.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

BOOLEAN FUNCTION IsSummary
 TtfwWord IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 aWord |N == '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

FORWARD DumpModelElement
 
PROCEDURE DumpModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N Print
 for ( aWord MembersIterator ) (
  TtfwWord IN aWord 
  aWord DumpModelElement
 )
; // DumpModelElement

@ Project1 DumpModelElement

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen26.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

BOOLEAN FUNCTION IsSummary
 TtfwWord IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

FORWARD DumpModelElement
 
PROCEDURE DumpModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N Print
 for ( ( aWord MembersIterator ) >filter> IsModelElement ) (
  TtfwWord IN aWord 
  aWord DumpModelElement
 )
; // DumpModelElement

@ Project1 DumpModelElement

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen27.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

BOOLEAN FUNCTION IsSummary
 TtfwWord IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 TtfwWord IN aWord
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

FORWARD DumpModelElement
 
PROCEDURE DumpModelElement
 TtfwWord IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N Print
 for ( aWord Children ) (
  TtfwWord IN aWord 
  aWord DumpModelElement
 )
; // DumpModelElement

@ Project1 DumpModelElement

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen28.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N Print
 REMARK 'Выводим имя элемента'
 for ( aWord Children ) (
  REMARK 'Выводим детей элемента'
  ModelElement IN aWord 
  aWord DumpModelElement
  REMARK 'Вызываем рекурсивно сами себя'
 )
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen29.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N Print
 REMARK 'Выводим имя элемента'
 for ( aWord Children ) (
  REMARK 'Выводим детей элемента'
  ModelElement IN aWord 
  aWord DumpModelElement
  REMARK 'Вызываем рекурсивно сами себя'
 )
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen3.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации'
 ;

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные'
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '

meta-model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen30.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N Print
 TRY
  REMARK 'Выводим имя элемента'
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord 
   aWord DumpModelElement
   REMARK 'Вызываем рекурсивно сами себя'
  )
 FINALLY
  '; // ' (+) ( aWord |N ) Print
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen31.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

PROCEDURE OutToFile
 STRING IN aString 
 aString Print
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |N OutToFile
 TRY
  REMARK 'Выводим имя элемента'
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord 
   aWord DumpModelElement
   REMARK 'Вызываем рекурсивно сами себя'
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen32.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 aString Print
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord 
   aWord DumpModelElement
   REMARK 'Вызываем рекурсивно сами себя'
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen33.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
; // LeaveElement

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 aString Print
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen34.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 aString Print
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen35.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat Print
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen36.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat Print
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

script:FileName sysutils:ExtractFileName (+) '.dump' Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen37.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat Print
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

@ Project1 DumpModelElement
REMARK 'Выводим содержимое элемента'

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen38.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat Print
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen39.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen4.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

meta-model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen40.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen41.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen42.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen43.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует каки-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen44.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen45.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
   ; // %IMPLEMENTS
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen46.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen47.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen48.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у нас даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class4

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen49.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

BOOLEAN FUNCTION IsSummary
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( aWord |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN FUNCTION IsModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 aWord IsSummary ! >>> Result
; // IsModelElement

ARRAY FUNCTION Children
 ModelElement IN aWord
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( aWord MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN FUNCTION IsElementNeedIndent
 ModelElement IN anElement
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen5.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen50.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_func

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 Self IsSummary ! >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

PROCEDURE EnterElement
 ModelElement IN anElement
 %SUMMARY 'Начинает вывод элемента' ;
 anElement IsElementNeedIndent ? INC g_Indent
; // EnterElement

PROCEDURE LeaveElement
 ModelElement IN anElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 anElement IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
PROCEDURE DumpModelElement
 ModelElement IN aWord
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 aWord |S OutToFile
 REMARK 'Выводим стереотип элемента'
 aWord |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( aWord Children ) (
   REMARK 'Выводим детей элемента'
   ModelElement IN aWord
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( aWord |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen51.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_func

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 Ctx:ClearTypeInfo
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol VOID
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 Self IsSummary ! >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

PROCEDURE OutToFile
 STRING IN aString 
 %SUMMARY 
 '
 Выводит строку в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 
 [ g_Indent ' ' char:Dupe aString ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
elem_proc DumpModelElement
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 Self |S OutToFile
 REMARK 'Выводим стереотип элемента'
 Self |N OutToFile
 REMARK 'Выводим имя элемента'
 TRY
  for ( Self Children ) (
   ModelElement IN aWord
   %SUMMARY 'Выводим детей элемента' ;
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  '; // ' (+) ( Self |N ) OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen52.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_func

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 Ctx:ClearTypeInfo
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol VOID
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
elem_proc DumpModelElement
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 [ 
  Self |S 
   REMARK 'Выводим стереотип элемента'
  Self |N 
   REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self Children ) (
   ModelElement IN aWord
   %SUMMARY 'Выводим детей элемента' ;
   aWord EnterElement 
   TRY
    aWord DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord LeaveElement 
   END
  )
 FINALLY
  [ '; // ' Self |N ] OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen53.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Programm1

; // Project1

REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
REMARK 'Элемент модели'

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_func

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 Ctx:ClearTypeInfo
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol VOID
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self .IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FORWARD .DumpModelElement
REMARK 'FORWARD DumpModelElement используем для того, чтобы можно было вызывать DumpModelElement рекурсивно'
 
elem_proc DumpModelElement
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 [ 
  Self |S 
   REMARK 'Выводим стереотип элемента'
  Self |N 
   REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) (
   ModelElement IN aWord
   %SUMMARY 'Выводим детей элемента' ;
   aWord .EnterElement 
   TRY
    aWord .DumpModelElement
    REMARK 'Вызываем рекурсивно сами себя'
   FINALLY
    aWord .LeaveElement 
   END
  )
 FINALLY
  [ '; // ' Self |N ] OutToFile
  REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 .DumpModelElement
 REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen54.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Programm1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
%REMARK 'Элемент модели'

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_func

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 Ctx:ClearTypeInfo
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol VOID
 axiom:PushSymbol :
 aName |N Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // elem_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self .IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

elem_proc CallGen
 FUNCTOR ^ IN aGen
 %SUMMARY 'Вызывает на элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen DO
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // CallGen

elem_proc DumpModelElement
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 [ 
  Self |S 
   %REMARK 'Выводим стереотип элемента'
  Self |N 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .CallGen call.me 
  %REMARK 'Выводим детей элемента'
 FINALLY
  [ '; // ' Self |N ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.' (+) 'dump' >>> Result
; // OutFileName

g_OutFile := ( OutFileName File:OpenWrite )
TRY
 @ Project1 .DumpModelElement
 %REMARK 'Выводим содержимое элемента'
FINALLY
 g_OutFile := nil
END

OutFileName Print
%REMARK 'Выводим имя файла скрипта в тестовых целях'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen55.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Programm1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier <> nil ) then
  ( aModifier |N Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N @SELF nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N @SELF nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N @SELF nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName |N @SELF @ ^@ do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self .IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

elem_generator DumpModelElement
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY
 [ 
  Self |S 
   %REMARK 'Выводим стереотип элемента'
  Self |N 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента'
 FINALLY
  [ '; // ' Self |N ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpModelElement

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.' (+) aGeneratorName >>> Result
; // OutFileName

elem_ref_proc CallGen
 GENERATOR right aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 g_OutFile := ( OutFileName ( Self |N (+) '.' (+) 'dump' ) File:OpenWrite )
 TRY
  Self aGen
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

Project1 .CallGen .DumpModelElement
%REMARK 'Выводим содержимое элемента Project1'

Project2 .CallGen .DumpModelElement
%REMARK 'Выводим содержимое элемента Project2'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen56.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Programm
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Programm это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Programm

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Programm вкладываться в Class, а Class в Programm
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Programm>> Programm1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Programm1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Programm1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Programm1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier <> nil ) then
  ( aModifier |N Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N @SELF nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N @SELF nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N @SELF nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName |N @SELF @ ^@ do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self .IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol ::
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.' (+) aGeneratorName >>> Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_ref_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name >>> g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self |N (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  Self |S 
   %REMARK 'Выводим стереотип элемента'
  Self |N 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента'
 FINALLY
  [ '; // ' Self |N ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'

 Self .DumpAsIs
; // dump

Project1 .CallGen .dump
%REMARK 'Выводим содержимое элемента Project1'

Project2 .CallGen .dump
%REMARK 'Выводим содержимое элемента Project2'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen57.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

TtfwWord TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier <> nil ) then
  ( aModifier |N Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N @SELF nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N @SELF nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N @SELF nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName |N @SELF @ ^@ do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self .IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol ::
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.' (+) aGeneratorName >>> Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_ref_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name >>> g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self |N (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  Self |S 
   %REMARK 'Выводим стереотип элемента'
  Self |N 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента'
 FINALLY
  [ '; // ' Self |N ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'

 Self .DumpAsIs
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'

 Self .DumpAsIs
; // pas

ARRAY VAR Generators
Generators := [ @ .dump @ .pas ]

ARRAY VAR Projects
Projects := [ @ Project1 @ Project2 ]

Project1 .CallGen .dump
%REMARK 'Выводим содержимое элемента Project1'

Project1 .CallGen .pas
%REMARK 'Выводим содержимое элемента Project1'

Project2 .CallGen .dump
%REMARK 'Выводим содержимое элемента Project2'

Project2 .CallGen .pas
%REMARK 'Выводим содержимое элемента Project2'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen58.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

TtfwWord TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier <> nil ) then
  ( aModifier |N Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N @SELF nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N @SELF nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N @SELF nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName |N @SELF @ ^@ do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self .IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol ::
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 script:FileName sysutils:ExtractFileName (+) '.' (+) aGeneratorName >>> Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name >>> g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self |N (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  Self |S 
   %REMARK 'Выводим стереотип элемента'
  Self |N 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента'
 FINALLY
  [ '; // ' Self |N ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'

 Self .DumpAsIs
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'

 Self .DumpAsIs
; // pas

PROCEDURE CallGens
 ARRAY IN anElements
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  anElement .CallGen .dump
  %REMARK 'Вызываем на элементе генератор .dump'
  anElement .CallGen .pas
  %REMARK 'Вызываем на элементе генератор .pas'
 ) 
; // CallGens

ARRAY VAR Generators
Generators := [ @ .dump @ .pas ]

ARRAY VAR Projects
Projects := [ @ Project1 @ Project2 ]

Projects CallGens
%REMARK '- запускаем всё наше хозяйство на списке элементов модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen59.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

TtfwWord TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier <> nil ) then
  ( aModifier |N Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N @SELF nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N @SELF nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N @SELF nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName |N @SELF @ ^@ do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self .IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol ::
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir >>> l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] '\' strings:CatSep >>> l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] '\' strings:CatSep >>> Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name >>> g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self |N (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  Self |S 
   %REMARK 'Выводим стереотип элемента'
  Self |N 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента'
 FINALLY
  [ '; // ' Self |N ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'

 Self .DumpAsIs
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'

 Self .DumpAsIs
; // pas

PROCEDURE CallGens
 ARRAY IN anElements
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  anElement .CallGen .dump
  %REMARK 'Вызываем на элементе генератор .dump'
  anElement .CallGen .pas
  %REMARK 'Вызываем на элементе генератор .pas'
 ) 
; // CallGens

ARRAY VAR Generators
Generators := [ @ .dump @ .pas ]

ARRAY VAR Projects
Projects := [ @ Project1 @ Project2 @ Project3 ]

Projects CallGens
%REMARK '- запускаем всё наше хозяйство на списке элементов модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen6.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen60.ms.script
USES
 arrays.ms.dict
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

TtfwWord TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier <> nil ) then
  ( aModifier |N Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N @SELF nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N @SELF nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N @SELF nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName |N @SELF @ ^@ do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 NOT ( Self .IsSummary )
  >>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

TtfwWord OPERATOR pop:Word:GetRefDeepest
 TtfwWord IN aSelf
 %SUMMARY '
 Метод получения ссылки из aSelf, с учётом того, что могут передавать переменные.
 Аналог pop:Word:GetRefDeep.
 ' ;
 aSelf pop:Word:GetRefDeep @ Result pop:Word:SetValue
 if ( class::TkwCompiledVar Result pop:object:Inherits )
 %REMARK 'Если это переменная, то ...'
  ( 
    Result DO @SELF DO @ Result pop:Word:SetValue 
    %REMARK '... разыменовываем её рекурсивно'
  )
; // pop:Word:GetRefDeepest

TtfwWord OPERATOR |RefDeepest
 ^@ IN aSelf
 %SUMMARY '
 Метод получения ссылки из aSelf, с учётом того, что могут передавать переменные.
 Аналог |^@.
 ' ;
 aSelf pop:Word:GetRefDeepest @ Result pop:Word:SetValue
; // |RefDeepest

^@ operator FieldByNameDeepest
 ^@ IN aSelf
 ^L IN aName
 %SUMMARY 'Метод получения вложенного члена слова по имени. С учётом того, что может быть передана ссылка на переменную' ;

 TtfwWord VAR l_Self
 aSelf |RefDeepest >>> l_Self
 
 STRING VAR l_Name
 aName |N >>> l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name >>> l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==> ( |N '::' ) l_Self |N '::' l_Name ]
 l_Res >>> Result
; // FieldByNameDeepest

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol FieldByNameDeepest
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir >>> l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] '\' strings:CatSep >>> l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] '\' strings:CatSep >>> Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name >>> g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self |N (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen |RefDeepest DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

PROCEDURE CallGens
 ARRAY IN anElements
 ARRAY IN aGenerators
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  for aGenerators ( 
   GENERATOR IN aGen 
   anElement .CallGen aGen
   %REMARK 'Вызываем на элементе anElement генератор aGen' 
  ) // for aGenerators
 ) // for anElements
; // CallGens

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  Self |S 
   %REMARK 'Выводим стереотип элемента'
  Self |N 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента, тем же самым генератором'
 FINALLY
  [ '; // ' Self |N ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // pas

elem_generator c++
 %SUMMARY '
 Генератор выводящий элементы модели в c++. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'cpp'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // c++

ARRAY VAR Generators
Generators := [ @ .dump @ .pas @ .c++ ]
%REMARK 'Список всех наших генераторов'

ARRAY VAR Projects
Projects := [ @ Project1 @ Project2 @ Project3 ]
%REMARK 'Список всех наших корневых элементов (проектов)'

Projects
%REMARK 'Список всех наших корневых элементов (проектов)'
 Generators
 %REMARK 'Список всех наших генераторов' 
  CallGens
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen61.ms.script
USES
 arrays.ms.dict
 metaMACRO.ms.dict
 classRelations.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    @ Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    @ Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    @ Class2
    @ Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

TtfwWord TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier <> nil ) then
  ( aModifier |N Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N @SELF nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 TtfwWord IN aSelf
 TtfwWord IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N @SELF nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N @SELF nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName |N @SELF @ ^@ do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self |N ) = '%SUM' >>> Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 '<<' Self %ST |N StartsStr 
  >>> Result
 //NOT ( Self .IsSummary )
  //>>> Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement >>> Result
; // Children

ARRAY elem_func Parents
 %SUMMARY 
 '
 Возвращает итератор родителей aWord в "терминах определённой модели"
 '
 ;
 ( Self LIST %P ) >filter> .IsModelElement >>> Result
; // Parents

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true >>> Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat >>> l_String )
 else
  ( aValue ToPrintable >>> l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

TtfwWord OPERATOR pop:Word:GetRefDeepest
 TtfwWord IN aSelf
 %SUMMARY '
 Метод получения ссылки из aSelf, с учётом того, что могут передавать переменные.
 Аналог pop:Word:GetRefDeep.
 ' ;
 aSelf pop:Word:GetRefDeep @ Result pop:Word:SetValue
 if ( class::TkwCompiledVar Result pop:object:Inherits )
 %REMARK 'Если это переменная, то ...'
  ( 
    Result DO @SELF DO @ Result pop:Word:SetValue 
    %REMARK '... разыменовываем её рекурсивно'
  )
; // pop:Word:GetRefDeepest

TtfwWord OPERATOR |RefDeepest
 ^@ IN aSelf
 %SUMMARY '
 Метод получения ссылки из aSelf, с учётом того, что могут передавать переменные.
 Аналог |^@.
 ' ;
 aSelf pop:Word:GetRefDeepest @ Result pop:Word:SetValue
; // |RefDeepest

^@ operator FieldByNameDeepest
 ^@ IN aSelf
 ^L IN aName
 %SUMMARY 'Метод получения вложенного члена слова по имени. С учётом того, что может быть передана ссылка на переменную' ;

 TtfwWord VAR l_Self
 aSelf |RefDeepest >>> l_Self
 
 STRING VAR l_Name
 aName |N >>> l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name >>> l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==> ( |N '::' ) l_Self |N '::' l_Name ]
 l_Res >>> Result
; // FieldByNameDeepest

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol FieldByNameDeepest
 GEN_PROPERTY_PREFIX (+) ( aName |N ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir >>> l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] '\' strings:CatSep >>> l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] '\' strings:CatSep >>> Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name >>> g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self |N (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen |RefDeepest DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

PROCEDURE CallGens
 ARRAY IN anElements
 ARRAY IN aGenerators
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  for aGenerators ( 
   GENERATOR IN aGen 
   anElement .CallGen aGen
   %REMARK 'Вызываем на элементе anElement генератор aGen' 
  ) // for aGenerators
 ) // for anElements
; // CallGens

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  for ( Self LIST %ST Reverted ) |N
   %REMARK 'Выводим стереотип элемента, рекурсивно'
  Self |N 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 [
  'Родители элемента '
  for ( Self .Parents >reverted> ) |N
  %REMARK 'Выводим родителей элемента, рекурсивно'
 ] '::' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента, тем же самым генератором'
 FINALLY
  [ '; // ' Self |N ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // pas

elem_generator c++
 %SUMMARY '
 Генератор выводящий элементы модели в c++. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'cpp'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // c++

elem_generator h
 %SUMMARY '
 Генератор выводящий элементы модели в *.h. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'h'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // h

ARRAY VAR Generators
Generators := [ @ .dump @ .pas @ .c++ @ .h ]
%REMARK 'Список всех наших генераторов'

ARRAY VAR Projects
Projects := [ @ Project1 @ Project2 @ Project3 ]
%REMARK 'Список всех наших корневых элементов (проектов)'

Projects
%REMARK 'Список всех наших корневых элементов (проектов)'
 Generators
 %REMARK 'Список всех наших генераторов' 
  CallGens
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen62.ms.script
USES
 arrays.ms.dict
 metaMACRO.ms.dict
 classRelations.ms.dict
 EngineTypes.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    Addr Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    Addr Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class2
    Addr Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

this.method.addr DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

ENGINE_WORD TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier =/= nil ) then
  ( aModifier .Name Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName .Name this.method.addr nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName .Name this.method.addr Addr LVALUE_MOD do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self .Name ) = '%SUM' =: Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 '<<' Self %ST .Name StartsStr 
 AND
 ( '>>' Self %ST .Name EndsStr )
  =: Result
 //NOT ( Self .IsSummary )
  //=: Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement =: Result
; // Children

ARRAY elem_func Parents
 %SUMMARY 
 '
 Возвращает итератор родителей aWord в "терминах определённой модели"
 '
 ;
 ( Self LIST %P ) >filter> .IsModelElement =: Result
; // Parents

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true =: Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat =: l_String )
 else
  ( aValue ToPrintable =: l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 this.method.addr Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

USES
 RefDeepest.ms.dict
;

REF operator FieldByNameDeepest
 LVALUE aSelf
 Literal IN aName
 %SUMMARY 'Метод получения вложенного члена слова по имени. С учётом того, что может быть передана ссылка на переменную' ;

 ENGINE_WORD VAR l_Self
 aSelf GetRefDeepestFromLeft =: l_Self
 
 STRING VAR l_Name
 aName .Name =: l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name =: l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==> ( .Name '::' ) l_Self .Name '::' l_Name ]
 l_Res =: Result
; // FieldByNameDeepest

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol FieldByNameDeepest
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir =: l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] '\' strings:CatSep =: l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] '\' strings:CatSep =: Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name =: g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self .Name (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen GetRefDeepestFromLeft DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

PROCEDURE CallGens
 ARRAY IN anElements
 ARRAY IN aGenerators
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  for aGenerators ( 
   GENERATOR IN aGen 
   anElement .CallGen aGen
   %REMARK 'Вызываем на элементе anElement генератор aGen' 
  ) // for aGenerators
 ) // for anElements
; // CallGens

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  for ( Self LIST %ST Reverted ) .Name
   %REMARK 'Выводим стереотип элемента, рекурсивно'
  Self .Name 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 [
  'Родители элемента '
  for ( Self .Parents >reverted> ) .Name
  %REMARK 'Выводим родителей элемента, рекурсивно'
 ] '::' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента, тем же самым генератором'
 FINALLY
  [ '; // ' Self .Name ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // pas

elem_generator c++
 %SUMMARY '
 Генератор выводящий элементы модели в c++. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'cpp'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // c++

elem_generator h
 %SUMMARY '
 Генератор выводящий элементы модели в *.h. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'h'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // h

ARRAY VAR Generators
Generators := [ Addr .dump Addr .pas Addr .c++ Addr .h ]
%REMARK 'Список всех наших генераторов'

ARRAY VAR Projects
Projects := [ Addr Project1 Addr Project2 Addr Project3 ]
%REMARK 'Список всех наших корневых элементов (проектов)'

Projects
%REMARK 'Список всех наших корневых элементов (проектов)'
 Generators
 %REMARK 'Список всех наших генераторов' 
  CallGens
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen63.ms.script
USES
 arrays.ms.dict
 metaMACRO.ms.dict
 classRelations.ms.dict
 EngineTypes.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    Addr Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    Addr Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class2
    Addr Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

this.method.addr DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

ENGINE_WORD TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier =/= nil ) then
  ( aModifier .Name Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName .Name this.method.addr nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName .Name this.method.addr Addr LVALUE_MOD do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self .Name ) = '%SUM' =: Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 '<<' Self %ST .Name StartsStr 
 AND
 ( '>>' Self %ST .Name EndsStr )
  =: Result
 //NOT ( Self .IsSummary )
  //=: Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement =: Result
; // Children

ARRAY elem_func Parents
 %SUMMARY 
 '
 Возвращает итератор родителей aWord в "терминах определённой модели"
 '
 ;
 ( Self LIST %P ) >filter> .IsModelElement =: Result
; // Parents

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true =: Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat =: l_String )
 else
  ( aValue ToPrintable =: l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 this.method.addr Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

USES
 RefDeepest.ms.dict
;

REF operator FieldByNameDeepest
 LVALUE aSelf
 Literal IN aName
 %SUMMARY 'Метод получения вложенного члена слова по имени. С учётом того, что может быть передана ссылка на переменную' ;

 ENGINE_WORD VAR l_Self
 aSelf GetRefDeepestFromLeft =: l_Self
 
 STRING VAR l_Name
 aName .Name =: l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name =: l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==> ( .Name '::' ) l_Self .Name '::' l_Name ]
 l_Res =: Result
; // FieldByNameDeepest

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol FieldByNameDeepest
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir =: l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] '\' strings:CatSep =: l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] '\' strings:CatSep =: Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name =: g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self .Name (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen GetRefDeepestFromLeft DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

PROCEDURE CallGens
 ARRAY IN anElements
 ARRAY IN aGenerators
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  for aGenerators ( 
   GENERATOR IN aGen 
   anElement .CallGen aGen
   %REMARK 'Вызываем на элементе anElement генератор aGen' 
  ) // for aGenerators
 ) // for anElements
; // CallGens

PROCEDURE CallGensList
 Sequence LVALUE anElements
 Sequence LVALUE aGenerators
 ( anElements CodeIterator )
  ( aGenerators CodeIterator )
   CallGens
; // CallGensList

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  for ( Self LIST %ST Reverted ) .Name
   %REMARK 'Выводим стереотип элемента, рекурсивно'
  Self .Name 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 [
  'Родители элемента '
  for ( Self .Parents >reverted> ) .Name
  %REMARK 'Выводим родителей элемента, рекурсивно'
 ] '::' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента, тем же самым генератором'
 FINALLY
  [ '; // ' Self .Name ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // pas

elem_generator c++
 %SUMMARY '
 Генератор выводящий элементы модели в c++. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'cpp'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // c++

elem_generator h
 %SUMMARY '
 Генератор выводящий элементы модели в *.h. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'h'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // h

( Project1 Project2 Project3 )
%REMARK 'Список всех наших корневых элементов (проектов)'
 ( .dump .pas .c++ .h )
 %REMARK 'Список всех наших генераторов' 
  CallGensList
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen64.ms.script
USES
 arrays.ms.dict
 metaMACRO.ms.dict
 classRelations.ms.dict
 EngineTypes.ms.dict
 Object.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    Addr Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    Addr Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class2
    Addr Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

this.method.addr DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

ENGINE_WORD TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier =/= nil ) then
  ( aModifier .Name Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName .Name this.method.addr nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName .Name this.method.addr Addr LVALUE_MOD do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self .Name ) = '%SUM' =: Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 '<<' Self %ST .Name StartsStr 
 AND
 ( '>>' Self %ST .Name EndsStr )
  =: Result
 //NOT ( Self .IsSummary )
  //=: Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement =: Result
; // Children

ARRAY elem_func Parents
 %SUMMARY 
 '
 Возвращает итератор родителей aWord в "терминах определённой модели"
 '
 ;
 ( Self LIST %P ) >filter> .IsModelElement =: Result
; // Parents

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true =: Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat =: l_String )
 else
  ( aValue ToPrintable =: l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

elem_proc Child.CallGen
 GENERATOR right aGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор aGen с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self aGen
  %REMARK 'Вызываем генератор aGen'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 this.method.addr Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

USES
 RefDeepest.ms.dict
;

REF operator FieldByNameDeepest
 LVALUE aSelf
 Literal IN aName
 %SUMMARY 'Метод получения вложенного члена слова по имени. С учётом того, что может быть передана ссылка на переменную' ;

 ENGINE_WORD VAR l_Self
 aSelf GetRefDeepestFromLeft =: l_Self
 
 STRING VAR l_Name
 aName .Name =: l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name =: l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==> ( .Name '::' ) l_Self .Name '::' l_Name ]
 l_Res =: Result
; // FieldByNameDeepest

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol FieldByNameDeepest
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir =: l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] '\' strings:CatSep =: l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] '\' strings:CatSep =: Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name =: g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self .Name (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  Self ( aGen GetRefDeepestFromLeft DO )
  %REMARK 'Вызываем на элементе генератор aGen'
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

PROCEDURE CallGens
 ARRAY IN anElements
 ARRAY IN aGenerators
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  for aGenerators ( 
   GENERATOR IN aGen 
   anElement .CallGen aGen
   %REMARK 'Вызываем на элементе anElement генератор aGen' 
  ) // for aGenerators
 ) // for anElements
; // CallGens

PROCEDURE CallGensList
 Sequence LVALUE anElements
 Sequence LVALUE aGenerators
 ( anElements CodeIterator )
  ( aGenerators CodeIterator )
   CallGens
; // CallGensList

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  for ( Self LIST %ST Reverted ) .Name
   %REMARK 'Выводим стереотип элемента, рекурсивно'
  Self .Name 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 [
  'Родители элемента '
  for ( Self .Parents >reverted> ) .Name
  %REMARK 'Выводим родителей элемента, рекурсивно'
 ] '::' strings:CatSep OutToFile
 TRY
  for ( Self .Children ) .Child.CallGen call.me 
  %REMARK 'Выводим детей элемента, тем же самым генератором'
 FINALLY
  [ '; // ' Self .Name ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // pas

elem_generator c++
 %SUMMARY '
 Генератор выводящий элементы модели в c++. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'cpp'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // c++

elem_generator h
 %SUMMARY '
 Генератор выводящий элементы модели в *.h. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'h'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // h

( Project1 Project2 Project3 )
%REMARK 'Список всех наших корневых элементов (проектов)'
 ( .dump .pas .c++ .h )
 %REMARK 'Список всех наших генераторов' 
  CallGensList
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen65.ms.script
USES
 arrays.ms.dict
 metaMACRO.ms.dict
 classRelations.ms.dict
 EngineTypes.ms.dict
 Object.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    Addr Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    Addr Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class2
    Addr Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

this.method.addr DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

ENGINE_WORD TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier =/= nil ) then
  ( aModifier .Name Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName .Name this.method.addr nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName .Name this.method.addr Addr LVALUE_MOD do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что aWord является документацией к элементу
 '
 ; // %SUMMARY
 ( Self .Name ) = '%SUM' =: Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что aWord является "элементом модели"
 '
 ; // %SUMMARY
 '<<' Self %ST .Name StartsStr 
 AND
 ( '>>' Self %ST .Name EndsStr )
  =: Result
 //NOT ( Self .IsSummary )
  //=: Result
; // IsModelElement

ARRAY elem_func Children
 %SUMMARY 
 '
 Возвращает итератор детей aWord в "терминах определённой модели"
 '
 ;
 ( Self MembersIterator ) >filter> .IsModelElement =: Result
; // Children

ARRAY elem_func Parents
 %SUMMARY 
 '
 Возвращает итератор родителей aWord в "терминах определённой модели"
 '
 ;
 ( Self LIST %P ) >filter> .IsModelElement =: Result
; // Parents

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true =: Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat =: l_String )
 else
  ( aValue ToPrintable =: l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

GENERATOR VAR g_CurrentGenerator
%REMARK 'Текущий генератор'
g_CurrentGenerator := nil

elem_proc Child.CallCurrentGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор g_CurrentGenerator с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self g_CurrentGenerator DO
  %REMARK 'Вызываем генератор g_CurrentGenerator'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallCurrentGen

elem_proc CallChildrenCurrentGen
 %SUMMARY 'Вызывает текущий генератор для всех детей элемента модели' ;
 for ( Self .Children ) .Child.CallCurrentGen
; // CallChildrenCurrentGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 this.method.addr Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

USES
 RefDeepest.ms.dict
;

REF operator FieldByNameDeepest
 LVALUE aSelf
 Literal IN aName
 %SUMMARY 'Метод получения вложенного члена слова по имени. С учётом того, что может быть передана ссылка на переменную' ;

 ENGINE_WORD VAR l_Self
 aSelf GetRefDeepestFromLeft =: l_Self
 
 STRING VAR l_Name
 aName .Name =: l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name =: l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==> ( .Name '::' ) l_Self .Name '::' l_Name ]
 l_Res =: Result
; // FieldByNameDeepest

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol FieldByNameDeepest
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GP

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir =: l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] '\' strings:CatSep =: l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] '\' strings:CatSep =: Result
; // OutFileName

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen %GP Name =: g_CurrentGeneratorName
 g_OutFile := ( OutFileName ( Self .Name (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
 TRY
  g_CurrentGenerator := ( aGen GetRefDeepestFromLeft )
  TRY
   g_CurrentGenerator .Name Print
   Self ( aGen GetRefDeepestFromLeft DO )
   %REMARK 'Вызываем на элементе генератор aGen'
  FINALLY
   g_CurrentGenerator := nil
  END // TRY..FINALLY
 FINALLY
  g_OutFile := nil
 END // TRY..FINALLY
; // CallGen

PROCEDURE CallGens
 ARRAY IN anElements
 ARRAY IN aGenerators
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  for aGenerators ( 
   GENERATOR IN aGen 
   anElement .CallGen aGen
   %REMARK 'Вызываем на элементе anElement генератор aGen' 
  ) // for aGenerators
 ) // for anElements
; // CallGens

PROCEDURE CallGensList
 Sequence LVALUE anElements
 Sequence LVALUE aGenerators
 ( anElements CodeIterator )
  ( aGenerators CodeIterator )
   CallGens
; // CallGensList

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  for ( Self LIST %ST Reverted ) .Name
   %REMARK 'Выводим стереотип элемента, рекурсивно'
  Self .Name 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 [
  'Родители элемента '
  for ( Self .Parents >reverted> ) .Name
  %REMARK 'Выводим родителей элемента, рекурсивно'
 ] '::' strings:CatSep OutToFile
 TRY
  Self .CallChildrenCurrentGen
  %REMARK 'Выводим детей элемента, тем же самым генератором'
 FINALLY
  [ '; // ' Self .Name ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // pas

elem_generator c++
 %SUMMARY '
 Генератор выводящий элементы модели в c++. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'cpp'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // c++

elem_generator h
 %SUMMARY '
 Генератор выводящий элементы модели в *.h. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'h'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // h

( Project1 Project2 Project3 )
%REMARK 'Список всех наших корневых элементов (проектов)'
 ( .dump .pas .c++ .h )
 %REMARK 'Список всех наших генераторов' 
  CallGensList
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen66.ms.script
USES
 arrays.ms.dict
 metaMACRO.ms.dict
 classRelations.ms.dict
 EngineTypes.ms.dict
 Object.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель шаблонов'
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

<<UMLCategory>> Program
 %SUMMARY '
 Наверное у нас при разработке встречаются программы.
 Так вот Program это стереотип, который описывает наши программы.
 '
 ; // %SUMMARY
; // Program

<<UMLClass>> Class
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные классы.
 Так вот Class это стереотип, который описывает наши проектные классы.
 '
 ; // %SUMMARY
; // Class

<<UMLClass>> Interface
 %SUMMARY '
 Наверное у нас при разработке встречаются интерфейсы.
 Так вот Interface это стереотип, который описывает наши интерфейсы.
 '
 ; // %SUMMARY
; // Interface

%REMARK
 '
 Могут ли Library вкладываться в Project, а Project в Library
 Или могут ли Program вкладываться в Class, а Class в Program
 И прочие отношения между стереотипами - мы определим несколько позже.
 Когда начнём использовать их.
 '

model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    Addr Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    Addr Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class2
    Addr Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

this.method.addr DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

%REMARK
 '
 Теперь, что мы можем сделать с нашим проектом?
 Ну для начала выведем его содержимое на стандартное устройство вывода.
 '

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

ENGINE_WORD TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier =/= nil ) then
  ( aModifier .Name Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName .Name this.method.addr nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName .Name this.method.addr Addr LVALUE_MOD do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что Self является документацией к элементу
 '
 ; // %SUMMARY
 ( Self .Name ) = '%SUM' =: Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что Self является "элементом модели"
 '
 ; // %SUMMARY
 '<<' Self %ST .Name StartsStr 
 AND
 ( '>>' Self %ST .Name EndsStr )
  =: Result
 //NOT ( Self .IsSummary )
  //=: Result
; // IsModelElement

ARRAY elem_func ElementList 
 Literal IN aListName
 %SUMMARY 'Возвращает итератор именованного списка на элементе' ;

 private BOOLEAN FUNCTION FilterElement 
  OBJECT IN aMember

  Result := ( aMember NotValid ! )
 ; // FilterElement
 
 private OBJECT FUNCTION MapElement 
  OBJECT IN aMember

  VAR l_Element
  aMember DO =: l_Element
  // - берём ссылку на элемент модели
  if ( l_Element IsVoid ) then
  // - пропускаем невалидные ссылки
  (
   Result := nil
  )
  else
  (
   Result := l_Element
  ) 
 ; // MapElement

 if ( Self NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( Self %% ( aListName .Name ) )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
    ( Result := ( ( l_List CodeIterator ) >map> MapElement >filter> FilterElement ) )
  )
; // ElementList

ARRAY elem_func Implements
 %SUMMARY 'Возвращает итератор элементов которые реализуют наш элемент' ;
 Result := ( Self .ElementList %R )
;

ARRAY elem_func Inherited
 %SUMMARY 'Возвращает итератор элементов от которого наследуется наш элемент' ;
 Result := ( Self .ElementList %G )
;

ARRAY elem_func Children
 %SUMMARY 'Возвращает итератор детей Self в "терминах определённой модели"' ;
 ( Self MembersIterator ) >filter> .IsModelElement =: Result
; // Children

ARRAY elem_func Parents
 %SUMMARY 'Возвращает итератор родителей Self в "терминах определённой модели"' ;
 ( Self LIST %P ) >filter> .IsModelElement =: Result
; // Parents

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
g_Indent := 0

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true =: Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
g_OutFile := nil

STRING INTEGER ARRAY TYPE PRINTABLE

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat =: l_String )
 else
  ( aValue ToPrintable =: l_String )
 [ g_Indent ' ' char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

GENERATOR VAR g_CurrentGenerator
%REMARK 'Текущий генератор'
g_CurrentGenerator := nil

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
g_CurrentGeneratorName := ''

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir =: l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] '\' strings:CatSep =: l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] '\' strings:CatSep =: Result
; // OutFileName

elem_proc CallCurrentGen
 FILE VAR l_PrevOutFile
 l_PrevOutFile := g_OutFile

 TRY
  g_OutFile := ( OutFileName ( Self .Name (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
  TRY
   g_CurrentGenerator IsNil ! ?ASSURE 'Текущй генератор пустой'
   Self ( g_CurrentGenerator DO )
   %REMARK 'Вызываем на элементе генератор g_CurrentGenerator'
  FINALLY
   g_OutFile := nil
  END // TRY..FINALLY
 FINALLY
  g_OutFile := l_PrevOutFile
  l_PrevOutFile := nil
 END
; // CallCurrentGen

elem_proc Child.CallCurrentGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор g_CurrentGenerator с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self .CallCurrentGen
  //Self g_CurrentGenerator DO
  %REMARK 'Вызываем генератор g_CurrentGenerator'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallCurrentGen

elem_proc CallChildrenCurrentGen
 %SUMMARY 'Вызывает текущий генератор для всех детей элемента модели' ;
 for ( Self .Children ) .Child.CallCurrentGen
; // CallChildrenCurrentGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 this.method.addr Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

USES
 RefDeepest.ms.dict
;

REF operator FieldByNameDeepest
 LVALUE aSelf
 Literal IN aName
 %SUMMARY 'Метод получения вложенного члена слова по имени. С учётом того, что может быть передана ссылка на переменную' ;

 ENGINE_WORD VAR l_Self
 aSelf Dereference =: l_Self
 
 STRING VAR l_Name
 aName .Name =: l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name =: l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==> ( .Name '::' ) l_Self .Name '::' l_Name ]
 l_Res =: Result
; // FieldByNameDeepest

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol FieldByNameDeepest
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GP

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen Dereference =: g_CurrentGenerator
 TRY
  aGen %GP Name =: g_CurrentGeneratorName
  Self .CallCurrentGen
 FINALLY
  g_CurrentGenerator := nil
 END
; // CallGen

PROCEDURE CallGens
 ARRAY IN anElements
 ARRAY IN aGenerators
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  for aGenerators ( 
   GENERATOR IN aGen 
   anElement .CallGen aGen
   %REMARK 'Вызываем на элементе anElement генератор aGen' 
  ) // for aGenerators
 ) // for anElements
; // CallGens

PROCEDURE CallGensList
 Sequence LVALUE anElements
 Sequence LVALUE aGenerators
 ( anElements CodeIterator )
  ( aGenerators CodeIterator )
   CallGens
; // CallGensList

// ---------------------------------------------------------------------------

elem_proc DumpAsIs
 %SUMMARY 
 '
 Процедура печатающая содержимое элемента модели.
 Рекурсивно.
 '
 ; // %SUMMARY

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  for ( Self LIST %ST Reverted ) .Name
   %REMARK 'Выводим стереотип элемента, рекурсивно'
  Self .Name 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 [
  'Родители элемента '
  for ( Self .Parents >reverted> ) .Name
  %REMARK 'Выводим родителей элемента, рекурсивно'
 ] '::' strings:CatSep OutToFile
 for ( Self .Inherited ) ( .Name OutToFile )
 for ( Self .Implements ) ( .Name OutToFile )
 TRY
  Self .CallChildrenCurrentGen
  %REMARK 'Выводим детей элемента, тем же самым генератором'
 FINALLY
  [ '; // ' Self .Name ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // pas

elem_generator c++
 %SUMMARY '
 Генератор выводящий элементы модели в c++. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'cpp'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // c++

elem_generator h
 %SUMMARY '
 Генератор выводящий элементы модели в *.h. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'h'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // h

( Project1 Project2 Project3 )
%REMARK 'Список всех наших корневых элементов (проектов)'
 ( .dump .pas .c++ .h )
 %REMARK 'Список всех наших генераторов' 
  CallGensList
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
 EngineTypes.ms.dict
 Object.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

 %REMARK
  '
  %SUMMARY это мета-информация, которая позволяет привязывать документацию
  к элементам кода. Эта документация доступна потом из скриптовой машины.
  '
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

USES
 Templates.ms.model
;

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    Addr Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    Addr Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class2
    Addr Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

this.method.addr DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

USES
 Generation.ms.dict
;

elem_proc DumpAsIs
 %SUMMARY 'Процедура печатающая содержимое элемента модели. Рекурсивно.' ;

 [
  g_CurrentGeneratorName ':'
   %REMARK 'Выводим имя текущего генератора. Для отладки' 
  for ( Self LIST %ST Reverted ) .Name
   %REMARK 'Выводим стереотип элемента, рекурсивно'
  Self .Name 
   %REMARK 'Выводим имя элемента'
 ] ' ' strings:CatSep OutToFile
 [
  'Родители элемента '
  for ( Self .Parents >reverted> ) .Name
  %REMARK 'Выводим родителей элемента, рекурсивно'
 ] '::' strings:CatSep OutToFile
 for ( Self .Inherited ) ( .Name OutToFile )
 for ( Self .Implements ) ( .Name OutToFile )
 TRY
  Self .CallChildrenCurrentGen
  %REMARK 'Выводим детей элемента, тем же самым генератором'
 FINALLY
  [ '; // ' Self .Name ] OutToFile
  %REMARK 'Выводим закрывающую скобку элемента'
 END
; // DumpAsIs

elem_generator dump
 %SUMMARY 'Генератор выводящий дамп элемента модели.' ;
 %GEN_PROPERTY Name 'dump'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // dump

elem_generator pas
 %SUMMARY 'Генератор выводящий элементы модели в Паскаль.' ;
 %GEN_PROPERTY Name 'pas'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // pas

elem_generator script
 %SUMMARY 'Генератор выводящий элементы модели в ms.script.' ;
 %GEN_PROPERTY Name 'ms.script'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // script

elem_generator c++
 %SUMMARY '
 Генератор выводящий элементы модели в c++. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'cpp'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // c++

elem_generator h
 %SUMMARY '
 Генератор выводящий элементы модели в *.h. 
 Про файлы *.h мы потом поговорим отдельно.
 ' ;
 %GEN_PROPERTY Name 'h'
 %REMARK 'Имя генератора и расширение файла целевого языка. Потом мы сделаем так, чтобы они могли не совпадать'

 Self .DumpAsIs
 %REMARK 'Пока выводим всё "как есть", без трансформации в целевой язык'
; // h

( Project1 Project2 Project3 )
%REMARK 'Список всех наших корневых элементов (проектов)'
 ( .dump .pas .c++ .h .script )
 %REMARK 'Список всех наших генераторов' 
  CallGensList
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68.ms.script
USES
 metaMACRO.ms.dict
 classRelations.ms.dict
 EngineTypes.ms.dict
 Object.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

USES
 Templates.ms.model
;

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project1'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project1
 %SUMMARY '
 Это наш первый проект - Project1
 '
 ; // %SUMMARY

 <<Library>> Library1
  %SUMMARY '
  Наверное наш проект содержит какие-то проектные библиотеки.
  Так вот Library1 - это наша первая проектная библиотека
  '
  ; // %SUMMARY
 ; // Library1

 <<Library>> Library2
  %SUMMARY '
  Наверное наш проект достаточно серьёзен и содержит НЕ ОДНУ библиотеку.
  Так вот Library2 - это наша вторая проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library2

 <<Library>> Library3
  %SUMMARY '
  Наверное наш проект НАСТОЛЬКО серьёзен, что содержит даже НЕ ДВЕ библиотеки.
  Так вот Library3 - это наша третья проектная библиотека.
  '
  ; // %SUMMARY
 ; // Library3

 <<Program>> Program1
  %SUMMARY '
  Наверное наш проект реализует какую-то программу.
  Иначе - зачем бы он нам был бы нужен?
  Так вот Program1 - это программа внутри нашего проекта Project1.
  '
  ; // %SUMMARY

  <<Class>> Class1
   %SUMMARY '
   Наверное наша программа содержит какие-то классы реализации.
   Иначе - кто будет реализовывать наш функционал?
   Так вот Class1 - это наш ПЕРВЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class1

  <<Interface>> Interface1
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует какие-то интерфейсы.
   Так вот Interface1 - это наш ПЕРВЫЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface1

  <<Interface>> Interface2
   %SUMMARY '
   Наверное наша программа настолько серьёзна, что реализует НЕ ОДИН интерфейс, а несколько.
   Так вот Interface2 - это наш ВТОРОЙ интерфейс.
   '
   ; // %SUMMARY
  ; // Interface2

  <<Class>> Class2
   %SUMMARY '
   Наверное наша программа достаточно серьёзна и содержит НЕ ОДИН классы реализации.
   Так вот Class2 - это наш ВТОРОЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class1
    %REMARK 'Возможно наш проектный класс Class2 наследуется от класса Class1'
   ; // %INHERITS
   %IMPLEMENTS
    Addr Interface1
    %REMARK 'Возможно наш проектный класс Class2 реализует интерфейс Interface1'
    Addr Interface2
    %REMARK 'Возможно наш проектный класс Class2 реализует ещё и интерфейс Interface2'
   ; // %IMPLEMENTS
  ; // Class2

  <<Class>> Class3
   %SUMMARY '
   Возможно, что у нас такая непростая программа, что в ней даже больше, чем ДВА класса реализации.
   Так вот Class3 - это наш ТРЕТИЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
  ; // Class3

  <<Class>> Class4
   %SUMMARY '
   Возможно, что мы настолько офигенно круты, что у на даже НЕ ТРИ класса реализации.
   Так вот Class4 - это наш ЧЕТВЁРТЫЙ класс реализации внутри нашей программы Program1.
   '
   ; // %SUMMARY
   %INHERITS
    Addr Class2
    Addr Class3
    %REMARK 
     '
     Возможно, что мы нстолько ОФИГЕННЫЕ перцы, что используем МНОЖЕСТВЕННОЕ наследование.
     И даже ПОНИМАЕМ - ЗАЧЕМ это нужно.
     Так вот Class4 - наследуется от Class2 и Class3.  
     '
   ; // %INHERITS
  ; // Class4

 ; // Program1

; // Project1

%REMARK
 '
  РЕМАРКА.
  Все эти слова "наверное" вообще говоря должны проистекать из требований, ТЗ и UseCase
  Но мы про это позже поговорим.
 '  
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project2'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project2
 %SUMMARY '
 Это наш ВТОРОЙ проект - Project2
 '
 ; // %SUMMARY
; // Project2
model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

concrete-model-begin 'Модель конкретного проекта Project3'
 'Тут будем определять аксиоматику конкретной модели конкретного проекта.
  А потом вынесем её 
  в отдельный словарь.
 '
<<Project>> Project3
 %SUMMARY '
 Это наш ТРЕТИЙ проект - Project3
 '
 ; // %SUMMARY
; // Project3
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

this.method.addr DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

USES
 Generation.ms.dict
 CommonLang.ms.tpl
;

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

( Project1 Project2 Project3 )
%REMARK 'Список всех наших корневых элементов (проектов)'
 ( .dump .pas .c++ .h .script )
 %REMARK 'Список всех наших генераторов' 
  CallGensList
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69.ms.script
USES
 Documentation.ms.dict
 Object.ms.dict
;

Test CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

USES
 Concrete.ms.model
 // - подключаем "конкретную модель"
;

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

this.method.addr DumpElement
%REMARK
 '
 - тут дампим элемент CodeGen и его содержимое
   в стандартное устройство вывода.
   Чисто для отладки того, что мы сейчас написали.
 '

USES
 Generation.ms.dict
 // - это для того, чтобы подключить CallGensList
 CommonLang.ms.tpl
 // - подключаем конкретные шаблоны кодогенерации
;

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

( Project1 Project2 Project3 )
%REMARK 'Список всех наших корневых элементов (проектов)'
 ( .dump .pas .c++ .h .script )
 %REMARK 'Список всех наших генераторов' 
  CallGensList
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen7.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

model-begin
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '
model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen8.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

model-begin
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen9.ms.script
USES
 metaMACRO.ms.dict
;

Test CodeGen
 // %SUMMARY это мета-информация, которая позволяет привязывать документацию
 // к элементам кода. Эта документация доступна потом из скриптовой машины.
 %SUMMARY '
 Тут будем тестировать построение сначала мета-модели, потом модели, а потом и
 кодогенерации
 '
 ; // %SUMMARY

// ---------------------------------------------------------------------------

meta-meta-model-begin
 'Тут будем определять аксиоматику мета-мета-модели, а потом вынесем её 
  в отдельный словарь.
 '

StereotypeStereotypeProducer meta
 %SUMMARY '
 Определяем базовый элемент мета-модели
 Тот самый который позволяет тащить всё остальное "за волосы из болота"
 Через этот примитив выводятся все остальные
 '
 ; // %SUMMARY 
; // meta

meta-meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

meta-model-begin
 'Тут будем определять аксиоматику мета-модели, а потом вынесем её 
  в отдельный словарь.

  Дальше будем определять понятия из UML - https://ru.wikipedia.org/wiki/UML

  Там бывают КАТЕГОРИИ и КЛАССЫ (Category и Class)

  На самом деле разница между ними - "призрачна", но раз умные дяди так решили, 
  то так тому и быть

  Вот с них и начнём:
  '
<<@meta>> UMLCategory
 %SUMMARY '
 Категория в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLCategory

<<@meta>> UMLClass
 %SUMMARY '
 Класс в терминах UML
 ' 
 ; // %SUMMARY 
; // UMLClass

meta-model-end

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

model-begin
 'Тут будем определять аксиоматику конкретной модели.
  Пока - "модели шаблонов". 
  А потом вынесем её 
  в отдельный словарь.
 '

<<UMLCategory>> Project
 %SUMMARY '
 Наверное у нас при разработке встречаются проекты.
 Так вот Project это стереотип, который описывает наши проекты.
 '
 ; // %SUMMARY
; // Project

<<UMLCategory>> Library
 %SUMMARY '
 Наверное у нас при разработке встречаются проектные библиотеки.
 Так вот Library это стереотип, который описывает наши библиотеки.
 '
 ; // %SUMMARY
; // Library

model-end

// ---------------------------------------------------------------------------

USES
 CodeDump.ms.dict
 // - тут подключаем словарь CodeDump.ms.dict, чтобы "увидеть" слово DumpElement
;

@SELF DumpElement
// - тут дампим элемент CodeGen и его содержимое
//   в стандартное устройство вывода.
//   Чисто для отладки того, что мы сейчас написали.

help
// Выводим всю доступную аксиоматику в стандартное устройство вывода.
// Чисто для отладки того, что мы сейчас написали.

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration\Point96.ms.script
USES
 macro.ms.dict
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
 Object.ms.dict
;

Test PointTest

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

Pixel member X
Pixel member Y
members-end

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX aY ] =: Result
; // :

constructor 0
 Point:: 0 0 =: Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] =: Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) =: Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) =: Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) =: Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) =: Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) =: Result
; // -

OVERRIDE STRING method ToPrintable
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat =: Result
; // ToPrintable

void method Print
 Self Point:ToPrintable Print
; // Print

class-end // Point

class Rectangle

Point member TopLeft
Point member BottomRight
members-end

Point readonly TopLeft read TopLeft

Point readonly BottomRight read BottomRight

constructor :
 Point right aTopLeft
 Point right aBottomRight
 new[ aTopLeft aBottomRight ] =: Result
; // :

OVERRIDE STRING method ToPrintable
 [ '( ' 'TopLeft: ' Self Rectangle:TopLeft Point:ToPrintable ', BottomRight: ' Self Rectangle:BottomRight Point:ToPrintable ' )' ] strings:Cat =: Result
; // ToPrintable

void method Print
 Self Rectangle:ToPrintable Print
; // Print

class-end // Rectangle

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10
Point var P11

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )
P11 := Point:XY ( -2 2 )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ] =: l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

Rectangle var R1
Rectangle var R2
R1 := Rectangle:: P1 P4
R2 := Rectangle:: P6 P7

array var l_Rectangles
[ R1 R2 ] =: l_Rectangles

for l_Rectangles Rectangle:Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Class1.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class1
  Родители элемента ::Project1::Program1
  ; // Class1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Class2.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class2
  Родители элемента ::Project1::Program1
  Class1
  Interface1
  Interface2
  ; // Class2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Class3.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class3
  Родители элемента ::Project1::Program1
  ; // Class3
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Class4.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class4
  Родители элемента ::Project1::Program1
  Class2
  Class3
  ; // Class4
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Interface1.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Interface>> Interface1
  Родители элемента ::Project1::Program1
  ; // Interface1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Interface2.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Interface>> Interface2
  Родители элемента ::Project1::Program1
  ; // Interface2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Library1.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library1
 Родители элемента ::Project1
 ; // Library1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Library2.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library2
 Родители элемента ::Project1
 ; // Library2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Library3.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library3
 Родители элемента ::Project1
 ; // Library3
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Program1.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Program>> Program1
 Родители элемента ::Project1
 ; // Program1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Project1.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project1
Родители элемента 
; // Project1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Project2.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project2
Родители элемента 
; // Project2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen67\Project3.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project3
Родители элемента 
; // Project3
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Class1.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class1
  Родители элемента ::Project1::Program1
  ; // Class1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Class2.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class2
  Родители элемента ::Project1::Program1
  Class1
  Interface1
  Interface2
  ; // Class2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Class3.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class3
  Родители элемента ::Project1::Program1
  ; // Class3
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Class4.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class4
  Родители элемента ::Project1::Program1
  Class2
  Class3
  ; // Class4
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Interface1.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Interface>> Interface1
  Родители элемента ::Project1::Program1
  ; // Interface1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Interface2.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Interface>> Interface2
  Родители элемента ::Project1::Program1
  ; // Interface2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Library1.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library1
 Родители элемента ::Project1
 ; // Library1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Library2.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library2
 Родители элемента ::Project1
 ; // Library2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Library3.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library3
 Родители элемента ::Project1
 ; // Library3
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Program1.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Program>> Program1
 Родители элемента ::Project1
 ; // Program1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Project1.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project1
Родители элемента 
; // Project1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Project2.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project2
Родители элемента 
; // Project2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen68\Project3.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project3
Родители элемента 
; // Project3
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Class1.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class1
  Родители элемента ::Project1::Program1
  ; // Class1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Class2.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class2
  Родители элемента ::Project1::Program1
  Class1
  Interface1
  Interface2
  ; // Class2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Class3.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class3
  Родители элемента ::Project1::Program1
  ; // Class3
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Class4.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Class>> Class4
  Родители элемента ::Project1::Program1
  Class2
  Class3
  ; // Class4
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Interface1.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Interface>> Interface1
  Родители элемента ::Project1::Program1
  ; // Interface1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Interface2.ms.script
  ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLClass>> <<Interface>> Interface2
  Родители элемента ::Project1::Program1
  ; // Interface2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Library1.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library1
 Родители элемента ::Project1
 ; // Library1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Library2.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library2
 Родители элемента ::Project1
 ; // Library2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Library3.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Library>> Library3
 Родители элемента ::Project1
 ; // Library3
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Program1.ms.script
 ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Program>> Program1
 Родители элемента ::Project1
 ; // Program1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Project1.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project1
Родители элемента 
; // Project1
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Project2.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project2
Родители элемента 
; // Project2
..\..\ScriptEngine\Examples\CodeGeneration\CodeGen69\Project3.ms.script
ms.script : OPERATOR StereotypeStereotypeProducer <<@meta>> <<UMLCategory>> <<Project>> Project3
Родители элемента 
; // Project3
..\..\ScriptEngine\Examples\CodeGeneration1\CacheFunction.ms.script
PROGRAM CacheFunction.ms.script

USES
 axiom_push.ms.dict
;

USES
 WordsRTTI.ms.dict
;

USES
 Testing.ms.dict
;

Test&Dump CacheFunction.ms.script.test

 : Cache.do
   TtfwWord IN aCacheWhere
    %REMARK 'Где кешировать результат'
   TtfwWord IN aCacheWhat
    %REMARK 'Что кешировать'
   ^ IN aLambda
    %REMARK 'Лямбда, которая вычисляет результат'

  STRING VAR l_CacheWhat
  [ 'cached' 
     aCacheWhat .Parent.Words 
      .filter> ( class::TkwCompiledMain SWAP pop:Object:Inherits ! ) 
      .filter> ( pop:Word:Parent class::TkwCompiledMain SWAP pop:Object:Inherits ! )
       .for> pop:Word:Name 
     aCacheWhat pop:Word:Name 
  ] ':' strings:CatSep >>> l_CacheWhat

  VAR l_FieldVar
  aCacheWhere %% l_CacheWhat >>> l_FieldVar

  if ( l_FieldVar NotValid ) then
  begin
   VAR l_NewVar
   l_CacheWhat false aCacheWhere pop:NewWordDefinitor:CheckVar >>> l_NewVar
   @SELF l_NewVar pop:Word:SetProducer
   aLambda DO 
   l_NewVar pop:Word:SetValue
   l_NewVar DO
  end // l_FieldVar NotValid
  else
  begin
   l_FieldVar DO
  end

 ; // Cache.do

 MACRO Cache
  axiom:PushSymbol @SELF
  axiom:PushSymbol Cache.do
 ; // Cache

 : A

  STRING FUNCTION X
   'A.X' >>> Result
  ; // X

  STRING FUNCTION Y
   'A.Y' >>> Result
  ; // Y

  STRING FUNCTION Z
   'A.Z' >>> Result
  ; // Z

 ; // A
 
 : B

  STRING FUNCTION X
   'B.X' >>> Result
  ; // X

  STRING FUNCTION Y
   'B.Y' >>> Result
  ; // Y

  STRING FUNCTION Z
   'B.Z' >>> Result
  ; // Z

 ; // B
 
 STRING FUNCTION X
   STRING IN aPrefix
   TtfwWord IN aWord
  aPrefix aWord Cache ( aWord %% ( @SELF pop:Word:Name ) DO ) Cat >>> Result
 ; // X

 STRING FUNCTION Y
   STRING IN aPrefix
   TtfwWord IN aWord
  aPrefix aWord Cache ( aWord %% ( @SELF pop:Word:Name ) DO ) Cat >>> Result
 ; // Y

 STRING FUNCTION Z
   STRING IN aPrefix
   TtfwWord IN aWord
  aPrefix aWord Cache ( aWord %% ( @SELF pop:Word:Name ) DO ) Cat >>> Result
 ; // Z

 '1' @ A X .
 '2' @ B X .

 '3' @ A X .
 '4' @ B X .

 '1' @ A Y .
 '2' @ B Y .

 '3' @ A Y .
 '4' @ B Y .

 '1' @ A Z .
 '2' @ B Z .

 '3' @ A Z .
 '4' @ B Z .

 @ A DumpElement
 @ B DumpElement

; // CacheFunction.ms.script.test

CacheFunction.ms.script.test
..\..\ScriptEngine\Examples\CodeGeneration1\CallAncestor.ms.script
PROGRAM CallAncestor.ms.script

USES
 classRelations.ms.dict
;

USES
 CallAncestor.ms.dict
;

USES
 Testing.ms.dict
;

Test&Dump CallAncestorTest

 : A
  : X
    INTEGER IN aValue
   aValue 1 +
  ; // X
 ; // A

 : B Inherits A
  : X
    INTEGER IN aValue
   aValue 2 + .call.ancestor
  ; // X
 ; // B

 : C Inherits B
 ; // C

 : D Inherits C
  : X
    INTEGER IN aValue
   aValue 4 + .call.ancestor
  ; // X
 ; // D

 : E Inherits C
  : X
    INTEGER IN aValue
   aValue 5 + .call.ancestor
  ; // X
 ; // E

 1 A ?-> X .
 2 B ?-> X .
 3 C ?-> X .
 4 D ?-> X .
 5 E ?-> X .

; // CallAncestorTest

CallAncestorTest
..\..\ScriptEngine\Examples\CodeGeneration1\CallInherited.ms.script
PROGRAM CallInherited.ms.script

USES
 classRelations.ms.dict
 CallInherited.ms.dict
 Testing.ms.dict
;

Test&Dump CallInheritedTest

 : A
  INTEGER IN Self
  Self 1 +
 ; // A

 : B
  INTEGER IN Self

  Inherits A

  Self 2 +
  call.inherited +
 ; // B

 : C
  INTEGER IN Self

  Inherits B

  Self 3 +
  call.inherited +
 ; // C

 : D
  INTEGER IN Self

  Inherits C

  Self 4 +
  call.inherited +
 ; // D

 : E
  INTEGER IN Self

  Inherits D

  Self 5 +
  Self .inherited +
  //call.inherited +
 ; // E

 1 A .
 2 B .
 3 C .
 4 D .
 5 E .

; // CallInheritedTest

CallInheritedTest
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69.ms.script
USES
 Documentation.ms.dict
 Object.ms.dict
 Testing.ms.dict
;

Test&Dump CodeGen
 %REMARK
  '
  CodeGen - это функция в которой мы будем тестировать наш функционал
  '

USES
 Concrete.ms.model
 // - подключаем "конкретную модель"
;

USES
 Generation.ms.dict
 // - это для того, чтобы подключить CallGensList
 CommonLang.ms.tpl
 // - подключаем конкретные шаблоны кодогенерации
;

help
%REMARK
 '
 Выводим всю доступную аксиоматику в стандартное устройство вывода.
 Чисто для отладки того, что мы сейчас написали.
 '

( Project1 Project2 Project3 )
%REMARK 'Список всех наших корневых элементов (проектов)'
 ( .dump .pas .c++ .h .script )
 %REMARK 'Список всех наших генераторов' 
  generate
  %REMARK '- запускаем список генераторов на списке "рутовых элементов" модели.'

; // CodeGen

CodeGen
..\..\ScriptEngine\Examples\CodeGeneration1\CompileAndProcess.ms.script
INCLUDE 'CompileAndProcess.ms.dict'
INCLUDE 'core.ms.dict'
INCLUDE 'Debug.ms.dict'

: LW
  STRING IN aWordName
  STRING IN aDictName
 STRING VAR l_FileName
 sysutils:GetCurrentDir >>> l_FileName 
 [ l_FileName '\' aWordName '.' aDictName ] strings:Cat >>> l_FileName

 FILE VAR l_File

 l_FileName File:OpenWrite >>> l_File
 TRY
  [ 'INCLUDE ' '''' aDictName '''' ' @ ' aWordName ] strings:Cat l_File File:WriteLn
 FINALLY
  nil >>> l_File
 END
 l_FileName script:CompileAndProcess DO

 l_FileName DeleteFile DROP
 [ l_FileName '.co' ] strings:Cat DeleteFile DROP
; // LW

'X' 'CompileAndProcess.ms.dict' LW pop:Word:Name .
'Y' 'CompileAndProcess.ms.dict' LW pop:Word:Name .
'NameOf' 'core.ms.dict' LW pop:Word:Name .
'Trace' 'Debug.ms.dict' LW pop:Word:Name .
..\..\ScriptEngine\Examples\CodeGeneration1\CompileTimeVar.ms.script
USES
 CompileTimeVar.ms.dict
;

USES
 Testing.ms.dict
;

Test&Dump CompileTimeVarTest
 STRING CompileTime-VAR A ''
 ARRAY CompileTime-VAR B []
 STRING CompileTime-VAR C 'Hello'
 A .
 B .
 C .
; // CompileTimeVarTest

CompileTimeVarTest
..\..\ScriptEngine\Examples\CodeGeneration1\DelegateToGen.ms.script
PROGRAM DelegateToGen.ms.script

USES
 core.ms.dict
;

USES
 Testing.ms.dict
;

USES
 classRelations.ms.dict
;

USES
 WordsRTTI.ms.dict
;

Test&Dump DelegateToGen

 TtfwWord FUNCTION .FindMemberRecur
   STRING IN aName
   TtfwWord IN aGen

  TtfwKeyWord VAR l_Member
  aName aGen pop:Word:FindMember >>> l_Member

  if ( l_Member IsNil ) then
   ( nil >>> Result )
  else
   ( l_Member pop:KeyWord:Word >>> Result )

  if ( Result IsNil ) then
   ( 
    aGen .Inherited.Words .for> ( 
     IN anItem 
     TtfwWord VAR l_Found 
     aName anItem call.me >>> l_Found
     ( Result IsNil ) 
     OR ( l_Found IsNil ) 
     OR ( Result = l_Found ) 
      ?ASSURE [ 'Множественное наследование не поддерживается. Слово: ' aName ' генератор ' aGen pop:Word:Name ' родительский генератор ' anItem pop:Word:Name ]
     l_Found >>> Result
    ) 
   )

 ; // .FindMemberRecur

 TtfwWord VAR g_Gen

 : .?
   ^ IN aWord

  TtfwWord VAR l_Word
 
  aWord |N g_Gen .FindMemberRecur >>> l_Word
 
  if ( l_Word IsNil ) then
   ( aWord DO )
  else
   ( l_Word DO )
 ; // .?

 : A
  1 +
 ; // A

 : B
  2 +
 ; // B

 : C
  3 +
 ; // C

 : D
  4 +
 ; // D

 : Gen1
  : A
   10 +
  ; // A
 ; // Gen1

 @ Gen1 >>> g_Gen

 1 .? A . 
 1 .? B . 
 1 .? C . 
 1 .? D . 

 '----' .

 : Gen2
  Inherits Gen1
  : B
   20 +
  ; // B
 ; // Gen2

 @ Gen2 >>> g_Gen

 2 .? A . 
 2 .? B . 
 2 .? C . 
 2 .? D . 

 '----' .

 : Gen3
  Inherits ( Gen1 Gen2 )
  : C
   30 +
  ; // C
 ; // Gen3

 @ Gen3 >>> g_Gen

 3 .? A . 
 3 .? B . 
 3 .? C . 
 3 .? D . 

 '----' .

 : Gen4
  Inherits Gen3
  : D
   40 +
  ; // D
 ; // Gen4

 @ Gen4 >>> g_Gen

 4 .? A . 
 4 .? B . 
 4 .? C . 
 4 .? D . 

 '----' .

; // DelegateToGen

DelegateToGen
..\..\ScriptEngine\Examples\CodeGeneration1\DogAndBracket.ms.script
// DogAndBracket.ms.script

USES
 DogAndBracket.ms.dict
 Testing.ms.dict
;

Test&Dump DogAndBracketTest
 RunTests.in.array @[ @( @[ ]
  %REMARK 'Запускаем тесты к указанным скриптовым словам' 
; // DogAndBracketTest

DogAndBracketTest
..\..\ScriptEngine\Examples\CodeGeneration1\Filter.ms.script
USES
 arrays.ms.dict
 Testing.ms.dict
;

Test&Dump FilterTest

BOOLEAN FUNCTION IsEven
 INTEGER IN aValue
 aValue 2 MOD 0 == >>> Result
; // IsEven

[ 1 2 3 4 5 6 7 8 9 10 ] .filter> IsEven ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .filter> IsEven .

[ 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) ==> ( . . '---' . )

 STRING FUNCTION ToPrintableEx
   IN aValue
  if ( aValue IsArray )
   ( 
    [ 
     '[ ' 
     INTEGER VAR l_SL
     l_SL := StackLevel
     for aValue ( 
      INTEGER VAR l_Delta
      l_Delta := ( StackLevel l_SL - )
      if ( l_Delta = 1 ) then
       ( @SELF DO )
      else
       (
        INTEGER VAR l_Index
        l_Index := l_Delta
        '{ '
        l_Delta LOOP ( l_Index ROLL @SELF DO )
        // Премудрость с LOOP и ROLL для того, чтобы обработать slice'ы
        '}' 
       )
      l_SL := StackLevel 
     ) 
     ']' 
    ] ' ' strings:CatSep >>> Result 
   )
  else 
   ( aValue ToPrintable >>> Result )
 ; // ToPrintable
 
[ 1 10 2 9 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) ToPrintableEx .

[ 1 2 ] ToPrintableEx .

[ 1 10 2 9 3 8 4 7 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) ToPrintableEx .

[ 1 10 2 9 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) .

[ 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) ToPrintableEx .

[ 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) .

//[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem anItem IsEven ) ==> .
//[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem anItem IsEven ) .

//[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem if ( anItem IsEven ) ( anItem ) else ( anItem 1 + ) ) ==> .
//[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem if ( anItem IsEven ) ( anItem ) else ( anItem 1 + ) ) .

//[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 .map> + ==> .
//[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 .map> + .

; // FilterTest

FilterTest
..\..\ScriptEngine\Examples\CodeGeneration1\GenerateUnit.ms.script
PROGRAM GenerateUnit.ms.script

CONST cPathSep '\'

STRING FUNCTION OutDir
 sysutils:GetCurrentDir >>> Result
 [ Result
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] cPathSep strings:CatSep >>> Result
; // OutDir

STRING FUNCTION MakeOutPath
 OutDir >>> Result
 Result sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' Result ]
; // MakeOutPath

USES
 CompileTimeVar.ms.dict
;

FILE CompileTime-VAR g_OutFile nil
%REMARK 'Текущий файл'

INTEGER CompileTime-VAR g_Indent 0
%REMARK 'Текущий отступ'

STRING INTEGER ARRAY TYPE OUTABLE

CONST cIndentChar ' '

STRING FUNCTION IndentStr
 g_Indent cIndentChar char:Dupe >>> Result
; // IndentStr

FORWARD ValueToString

STRING FUNCTION ValueToString
  OUTABLE IN aValue

 if ( aValue IsArray ) then
  ( [ aValue .for> ValueToString ] strings:Cat >>> Result )
 else
  ( aValue ToPrintable >>> Result )
; // ValueToString

PROCEDURE OutToFile
  OUTABLE IN aValue 

 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 БЕЗ перевода каретки.
 '
 ; // %SUMMARY 

 [ IndentStr aValue ValueToString ] strings:Cat g_OutFile File:WriteStr
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; // OutToFile

CONST \n #13#10

PROCEDURE OutToFileLn
  OUTABLE IN aValue
 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 aValue OutToFile
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
 \n g_OutFile File:WriteStr
 %REMARK '- выводим перевод каретки'
; // OutToFileLn

PROCEDURE array:OutToFileLn
  ARRAY IN aValue

 %SUMMARY 'Выводит значения элементов массива построчно' ;
 aValue .for> OutToFileLn
; // array:OutToFileLn

USES
 SaveVarAndDo.ms.dict
;

: ExpandLambda
   FUNCTOR IN aLambda

  ARRAY VAR l_LambdaCode
  [ aLambda DO ] >>> l_LambdaCode
  if ( l_LambdaCode Array:Count <> 0 ) then
  begin
   [
   l_LambdaCode .for> (
    IN aValue
    aValue
    \n
   )
   ]
  end
; // ExpandLambda

ARRAY CompileTime-VAR g_OutedUnits []
ARRAY CompileTime-VAR g_OutedClasses []
BOOLEAN CompileTime-VAR g_WasType false

PROCEDURE GenerateUnit
  STRING IN aUnitName
  ^ IN anInterfaceLambda
  ^ IN anImplementationLambda

 aUnitName IsNil ?FAIL 'Имя модуля не может быть пустым'

 aUnitName g_OutedUnits array:Has ?FAIL [ 'Модуль ' aUnitName ' уже генерировался' ]

 aUnitName array:AddTo g_OutedUnits
 
 STRING VAR l_UnitFileName 
 [ aUnitName '.pas' ] strings:Cat >>> l_UnitFileName

 STRING VAR l_UnitPath
 MakeOutPath >>> l_UnitPath
 [ l_UnitPath cPathSep l_UnitFileName ] strings:Cat >>> l_UnitPath
 l_UnitPath Print

 TF g_OutedClasses (
  [] >>> g_OutedClasses
  l_UnitPath File:OpenWrite >>> g_OutFile
  TF g_OutFile (
   [
    [ 'unit' ' ' aUnitName ';' ]
    ''
    'interface'
    ''
    false >>> g_WasType 
    anInterfaceLambda ExpandLambda
    'implementation'
    ''
    false >>> g_WasType
    anImplementationLambda ExpandLambda
    'end.'
   ] array:OutToFileLn
  ) // TF g_OutFile
 ) // TF g_OutedClasses
; // GenerateUnit 

: GenerateClass
  STRING IN aClassName

 aClassName g_OutedClasses array:Has ?FAIL [ 'Класс ' aClassName ' уже генерировался' ]

 aClassName array:AddTo g_OutedClasses
 aClassName IsNil ?FAIL 'Имя класса не может быть пустым'

 if ( g_WasType ! ) then
 begin
  true >>> g_WasType
  'type'
 end
 else
 begin
  ''
 end

 TF g_Indent (
 INC g_Indent
 [ IndentStr aClassName ' = class' ]
 [ IndentStr 'end; // ' aClassName ]
 )
; // GenerateClass

USES
 Testing.ms.dict
;

Test&Dump GenerateUnitTest
 TF g_OutedUnits (
  'Unit1' GenerateUnit ( 
   'TTest1' GenerateClass 
   'TTest2' GenerateClass
   'TTest3' GenerateClass
   'TTest4' GenerateClass 
  ) ()
  g_OutedClasses Print

  'Unit2' GenerateUnit ( 'test' ) ( 'test' )
  g_OutedClasses Print

  'Unit3' GenerateUnit (
   'TTest1' GenerateClass 
   'TTest2' GenerateClass
   'TTest3' GenerateClass
   'TTest4' GenerateClass 
  ) ()
  'Unit4' GenerateUnit () ()

  g_OutedUnits Print
 )
; // GenerateUnitTest

GenerateUnitTest
..\..\ScriptEngine\Examples\CodeGeneration1\Inherits.ms.script
USES
 NoCapsLock.ms.dict
 InheritsAndImplementsNew.ms.dict
 Testing.ms.dict
;

Test&Dump InheritsTest

 : A
 ; // A

 : B
 ; // B

 : C
  Inherits ( A B )
 ; // C
 
 : I1
 ; // I1
 
 : I2
 ; // I2
 
 : D
  Inherits A
  Implements ( I1 I2 )
 ; // D
 
 : E
  Inherits A
  Implements I1
 ; // D
 
; // InheritsTest

InheritsTest
..\..\ScriptEngine\Examples\CodeGeneration1\IT.ms.script
USES
 core.ms.dict
 macro.ms.dict
 arrays.ms.dict
 io.ms.dict
 Testing.ms.dict
;

Test&Dump ITTest

/*{macro IT 
  //ARRAY IN A // - слева должен быть массив
  ^ IN aWhatToDo
 %SUMMARY 'Итерирует массив A вызывая лямбду aWhatToDo' ;
 aWhatToDo CompileRef
 @ SWAP CompileValue
 @ ITERATE CompileValue
 //aWhatToDo A ITERATE
; // IT}*/

/*{operator IT 
  ARRAY IN A
  ^ IN aWhatToDo
 %SUMMARY 'Итерирует массив A вызывая лямбду aWhatToDo' ;
 aWhatToDo A ITERATE
; // IT}*/

/*{WordAlias ==> IT}*/

/*{macro for
  ^ IN aList
  ^ IN aWhatToDo
 %SUMMARY 'Итерирует массив aList вызывая лямбду aWhatToDo' ;
 aWhatToDo CompileRef
 aList CompileRef
 @ DO CompileValue
 @ ITERATE CompileValue
 //aList DO ==> ( aWhatToDo DO )
; // for}*/

/*{operator for
  ^ IN aList
  ^ IN aWhatToDo
 %SUMMARY 'Итерирует массив aList вызывая лямбду aWhatToDo' ;
 aList DO ==> ( aWhatToDo DO )
; // for}*/

 [ 1 2 3 4 5 6 7 8 9 10 ] IT Print

 for [ 1 2 3 4 5 6 7 8 9 10 ] Print

; // ITTest

ITTest
..\..\ScriptEngine\Examples\CodeGeneration1\Join.ms.script
USES
 arrays.ms.dict
 Testing.ms.dict
;

Test&Dump JoinTest

[ 4 5 ] [ 1 2 3 ] JOIN ==> .
[ 4 5 ] [ 1 2 3 ] JOIN .
[ 4 5 ] [ 1 2 3 ] JOIN Reverted ==> .
[ 4 5 ] [ 1 2 3 ] JOIN Reverted .

'------' .

[ 1 2 3 ] .join> [ 4 5 ] ==> .
[ 1 2 3 ] .join> [ 4 5 ]  .
[ 1 2 3 ] .join> [ 4 5 ]  Reverted ==> .
[ 1 2 3 ] .join> [ 4 5 ]  Reverted .

'------' .

[ 1 2 3 ] >join> [ 4 5 ] ==> .
[ 1 2 3 ] >join> [ 4 5 ]  .
[ 1 2 3 ] >join> [ 4 5 ]  Reverted ==> .
[ 1 2 3 ] >join> [ 4 5 ]  Reverted .

'------' .

[ 1 2 3 ] .join> [ 4 5 ] .join> [ 6 7 8 9 10 ] ==> .
[ 1 2 3 ] .join> [ 4 5 ] .join> [ 6 7 8 9 10 ] .
[ 1 2 3 ] .join> [ 4 5 ] .join> [ 6 7 8 9 10 ] Reverted ==> .
[ 1 2 3 ] .join> [ 4 5 ] .join> [ 6 7 8 9 10 ] Reverted .

'------' .

; // JoinTest

JoinTest
..\..\ScriptEngine\Examples\CodeGeneration1\Map.ms.script
USES
 arrays.ms.dict
 Testing.ms.dict
;

Test&Dump MapTest

BOOLEAN FUNCTION IsEven
 INTEGER IN aValue
 aValue 2 MOD 0 == >>> Result
; // IsEven

[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( 1 + ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( 1 + ) .

[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem anItem IsEven ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem anItem IsEven ) .

[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem if ( anItem IsEven ) ( anItem ) else ( anItem 1 + ) ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem if ( anItem IsEven ) ( anItem ) else ( anItem 1 + ) ) .

[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 .map> + ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 .map> + .

; // MapTest

MapTest
..\..\ScriptEngine\Examples\CodeGeneration1\Object.ms.script
USES
 io.ms.dict
 Object.ms.dict
 Testing.ms.dict
;

USES
 axiom:WordInfo
;

Test&Dump ObjectTest

 ClassOf Object DumpElement

 ClassOf Object pop:Word:Name Print

 Object VAR l_Obj
 l_Obj := Object:new

 l_Obj .Print
 l_Obj .ClassName Print

 //@ l_Obj pop:Word:Info pop:WordInfo:ValueTypes Print
 //@ l_Obj pop:Word:Info pop:WordInfo:ValueTypes pop:ValueTypes:Name Print
 l_Obj .ClassName Print
 ClassOf Object pop:Word:Name Print

 '--------' Print

 l_Obj .InstanceSize Print

 ClassOf Object .FieldOffset VMT Print
 ClassOf Object .ClassParent Print
 ClassOf Object .ClassParent .Print
 ClassOf Object .ClassParentName Print

 ClassOf Object pop:Word:Name Print
 ClassOf Object pop:Word:Name Print

 l_Obj .class Print
 l_Obj .class .Print

 class Object1
  //def_constructor_empty
 class-end // Object1

 Object1 VAR l_Obj1
 l_Obj1 := Object1:new

 l_Obj1 .Print
 l_Obj1 .ClassName Print

 '--------' Print

 l_Obj1 .InstanceSize Print
 
 ClassOf Object1 .FieldOffset VMT Print
 ClassOf Object1 .ClassParent Print
 ClassOf Object1 .ClassParent .Print
 ClassOf Object1 .ClassParentName Print

 l_Obj1 .class Print
 l_Obj1 .class .Print

 class Object2
  INTEGER member FakeField
  INTEGER readonly FakeField read FakeField
  def_constructor
   //[EXECUTE] ( g_InstanceSizeDefined Msg )
   new[ 256 ] >>> Result 
   //Self .FieldOffset 'VMT' Msg
  ; // new
 class-end // Object2

 Object2 VAR l_Obj2
 l_Obj2 := Object2:new

 l_Obj2 .Print
 l_Obj2 .ClassName Print

 '--------' Print

 l_Obj2 .InstanceSize Print

 ClassOf Object2 .FieldOffset VMT Print
 ClassOf Object2 .FieldOffset FakeField Print
 ClassOf Object2 .ClassParent Print
 ClassOf Object2 .ClassParent .Print
 ClassOf Object2 .ClassParentName Print
 ClassOf Object2 .FieldOffset FakeField Print

 l_Obj2 .FakeField Print

 l_Obj2 .class Print
 l_Obj2 .class .Print
 //l_Obj2 .member FakeField Print

 Object2 class Object3
  def_constructor
   new[ 257 ] >>> Result 
  ; // new
 class-end // Object3

 '--------' Print

 ClassOf Object3 Print
 ClassOf Object3 ObjectClass:ClassName Print
 ClassOf Object3 ObjectClass:ClassParent Print
 ClassOf Object3 ObjectClass:ClassParentName Print

 '--------' Print

 ClassOf Object3 .Print
 ClassOf Object3 .ClassName Print
 ClassOf Object3 .ClassParent Print
 ClassOf Object3 .ClassParentName Print

 Object3 VAR l_Obj3
 l_Obj3 := Object3:new

 l_Obj3 .Print
 l_Obj3 .ClassName Print

 '--------' Print

 l_Obj3 .InstanceSize Print

 ClassOf Object3 .FieldOffset VMT Print
 ClassOf Object3 .FieldOffset FakeField Print
 ClassOf Object3 .ClassParent Print
 ClassOf Object3 .ClassParent .Print
 ClassOf Object3 .ClassParentName Print
 ClassOf Object3 .FieldOffset FakeField Print

 l_Obj3 .FakeField Print

 l_Obj3 .class Print
 l_Obj3 .class .Print

 class Object4
  //def_constructor_empty
 class-end // Object4

 Object4 VAR l_Obj4
 l_Obj4 := Object4:new

 l_Obj4 .Print
 l_Obj4 .ClassName Print

 '--------' Print

 l_Obj4 .InstanceSize Print
 
 ClassOf Object4 .FieldOffset VMT Print
 ClassOf Object4 .ClassParent Print
 ClassOf Object4 .ClassParent .Print
 ClassOf Object4 .ClassParentName Print

 l_Obj4 .class Print
 l_Obj4 .class .Print

; // ObjectTest

ObjectTest
..\..\ScriptEngine\Examples\CodeGeneration1\Object1.ms.script
USES
 io.ms.dict
 Object.ms.dict
 Testing.ms.dict
;

USES
 axiom:WordInfo
;

Test&Dump ObjectTest

 ClassOf Object DumpElement

 ClassOf Object pop:Word:Name Print

 Object VAR l_Obj
 l_Obj := Object:new

 l_Obj .Print
 l_Obj .ClassName Print

 l_Obj .ClassName Print
 ClassOf Object pop:Word:Name Print

 '--------' Print

 l_Obj .InstanceSize Print

 ClassOf Object .FieldOffset VMT Print
 ClassOf Object .ClassParent Print
 ClassOf Object .ClassParent .Print
 ClassOf Object .ClassParentName Print

 ClassOf Object pop:Word:Name Print
 ClassOf Object pop:Word:Name Print

 l_Obj .class Print
 l_Obj .class .Print

 class Object1
 class-end // Object1

 Object1 VAR l_Obj1
 l_Obj1 := Object1:new

 l_Obj1 .Print
 l_Obj1 .ClassName Print

 '--------' Print

 l_Obj1 .InstanceSize Print
 
 ClassOf Object1 .FieldOffset VMT Print
 ClassOf Object1 .ClassParent Print
 ClassOf Object1 .ClassParent .Print
 ClassOf Object1 .ClassParentName Print

 l_Obj1 .class Print
 l_Obj1 .class .Print

 class Object2
  INTEGER member FakeField
  INTEGER readonly FakeField read FakeField
  def_constructor
   //[EXECUTE] ( g_InstanceSizeDefined Msg )
   new[ 256 ] >>> Result 
   //Self .FieldOffset 'VMT' Msg
  ; // new
 class-end // Object2

 Object2 VAR l_Obj2
 l_Obj2 := Object2:new

 l_Obj2 .Print
 l_Obj2 .ClassName Print

 '--------' Print

 l_Obj2 .InstanceSize Print

 ClassOf Object2 .FieldOffset VMT Print
 ClassOf Object2 .FieldOffset FakeField Print
 ClassOf Object2 .ClassParent Print
 ClassOf Object2 .ClassParent .Print
 ClassOf Object2 .ClassParentName Print
 ClassOf Object2 .FieldOffset FakeField Print

 l_Obj2 .FakeField Print

 l_Obj2 .class Print
 l_Obj2 .class .Print
 //l_Obj2 .member FakeField Print

; // ObjectTest

ObjectTest
..\..\ScriptEngine\Examples\CodeGeneration1\Point96.ms.script
USES
 macro.ms.dict
 core.ms.dict
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
 Object.ms.dict
 Testing.ms.dict
;

Test&Dump PointTest

ClassOf Object DumpElement

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

Pixel member X
Pixel member Y

constructor : ( 
 Pixel in_param aX 
 Pixel in_param aY 
)
 new[ aX aY ] >>> Self
; // :

constructor 0 ()
 Point:: 0 0 >>> Self
; // 0

constructor XY ( 
 //PixelList 
  in_param aPoint
)
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Self
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF ( 
 Point in_param aPoint
)
 Point:: ( aPoint .X ) ( aPoint .Y ) >>> Self
; // OF

Point method + ( Point in_param aPoint )

 Point:: ( Self .X (+) ( aPoint .X ) ) ( Self .Y (+) ( aPoint .Y ) ) >>> Result
; // +

Point readonly Neg
 Point:: Neg ( Self .X ) Neg ( Self .Y ) >>> Result
; // Neg

Point method - ( Point in_param aPoint )

 Point:OF ( Self .+ ( aPoint .Neg ) ) >>> Result
; // -

OVERRIDE STRING readonly ToPrintable
 [ '( ' 'X: ' Self .X ToPrintable ', Y: ' Self .Y ToPrintable ' )' ] strings:Cat >>> Result
; // ToPrintable

OVERRIDE void readonly Print
 Self .ToPrintable Print
; // Print

class-end // Point

class Rectangle

Point member TopLeft
Point member BottomRight

Point readonly TopLeft read TopLeft

Point readonly BottomRight read BottomRight

constructor : ( 
 Point in_param aTopLeft
 Point in_param aBottomRight
)
 new[ aTopLeft aBottomRight ] >>> Self
; // :

OVERRIDE STRING readonly ToPrintable
 [ '( ' 'TopLeft: ' Self .TopLeft .ToPrintable ', BottomRight: ' Self .BottomRight .ToPrintable ' )' ] strings:Cat >>> Result
; // ToPrintable

OVERRIDE void readonly Print
 Self .ToPrintable Print
; // Print

class-end // Rectangle

class Foo
class-end // Foo

class Bar
class-end // Bar

ClassOf Point DumpElement
ClassOf Rectangle DumpElement

ClassOf Object .FieldOffset VMT Print
ClassOf Point .FieldOffset VMT Print
ClassOf Rectangle .FieldOffset VMT Print
ClassOf Foo .FieldOffset VMT Print
ClassOf Bar .FieldOffset VMT Print

ClassOf Object .ClassParentName Print
ClassOf Point .ClassParentName Print
ClassOf Rectangle .ClassParentName Print
ClassOf Foo .ClassParentName Print
ClassOf Bar .ClassParentName Print

ClassOf Object .ClassParent Print
ClassOf Point .ClassParent Print
ClassOf Rectangle .ClassParent Print
ClassOf Foo .ClassParent Print
ClassOf Bar .ClassParent Print

ClassOf Point .FieldOffset X Print
ClassOf Point .FieldOffset Y Print

ClassOf Rectangle .FieldOffset TopLeft Print
ClassOf Rectangle .FieldOffset BottomRight Print

ClassOf Object .InstanceSize Print
ClassOf Point .InstanceSize Print
ClassOf Rectangle .InstanceSize Print
ClassOf Foo .InstanceSize Print
ClassOf Bar .InstanceSize Print

Point:: 0 0 Point:Print
// - так работает

Point:: 0 0 |> Print
// - теперь и ТАК работает

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10
Point var P11

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 .+ P4 )
P7 := ( P3 .- P4 )
P8 := ( P4 .- P3 )
P9 := ( P4 .Neg )
P10 := ( P3 .Neg )
P11 := Point:XY ( -2 2 )

Object var O1
O1 := P1
O1 .Print
// - тут вообще говоря надо звать ВИРТУАЛЬНЫЙ метод, но мы пока так не умеем

O1 .InstanceSize Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ] >>> l_Points

P1 .InstanceSize Print
P1 Point:InstanceSize Print

l_Points ==> (
 Point IN aPt 
 aPt .Print
)
l_Points ==> (
 Point IN aPt 
 aPt .X Print 
)
l_Points ==> ( 
 Point IN aPt 
 aPt .Y Print 
)
l_Points ==> ( 
 Point IN aPt 
 aPt .class Print 
)
l_Points ==> ( 
 Point IN aPt 
 aPt .ClassName Print 
)
l_Points ==> ( 
 Point IN aPt 
 aPt .class %G ==> ( 
  ObjectClass IN aClass
  aClass .ClassName Print 
 ) 
)

Rectangle var R1
Rectangle var R2
R1 := Rectangle:: P1 P4
R2 := Rectangle:: P6 P7

R1 .InstanceSize Print

array var l_Rectangles
[ R1 R2 ] >>> l_Rectangles

l_Rectangles ==> (
 Rectangle IN aRt
 aRt .Print
)
l_Rectangles ==> ( 
 Rectangle IN aRt
 aRt .class Print 
)
l_Rectangles ==> ( 
 Rectangle IN aRt
 aRt .ClassName Print 
)
l_Rectangles ==> ( 
 Rectangle IN aRt 
 aRt .class %G ==> ( 
  ObjectClass IN aClass
  aClass .ClassName Print 
 ) 
)

Point VAR PointFake
PointFake := Point:new
PointFake Print
PointFake .class Print
PointFake .class .Print
PointFake .ClassParent Print
PointFake .ClassParent .Print
PointFake .ClassParentName Print

Rectangle VAR RectangleFake
RectangleFake := Rectangle:new
RectangleFake Print
RectangleFake .class Print
RectangleFake .class .Print
RectangleFake .ClassParent Print
RectangleFake .ClassParent .Print
RectangleFake .ClassParentName Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\CodeGeneration1\Proc.ms.script
PROGRAM Proc.ms.script

USES
 CompileTimeVar.ms.dict
;

STRING CompileTime-VAR g_CurrentProc ''

MACRO proc
  Literal IN aName
  ^ IN aParams

 %SUMMARY 'Определяет процедуру с ПОЛНЫМ контролем типов' ;

 g_CurrentProc '' == ?ASSURE 'Вложенные процедуры пока не поддерживаются'

 aName |N >>> g_CurrentProc
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol VOID
 axiom:PushSymbol :
 g_CurrentProc Ctx:Parser:PushString

 @SELF aParams axiom:Params:Push
; // proc

MACRO proc-end
 %SUMMARY 'Завершает определение процедуры с ПОЛНЫМ контролем типов' ;

 axiom:PushSymbol ;

 axiom:PushSymbol VOID
 axiom:PushSymbol :
 '_' g_CurrentProc Cat Ctx:Parser:PushSymbol
 axiom:PushSymbol ;
 '' >>> g_CurrentProc
; // proc-end

USES
 Testing.ms.dict
;

Test&Dump ProcTest

proc A ( in_param aValue )
 aValue .
proc-end // A

proc B ( STRING in_param aValue )
 aValue .
proc-end // B

proc C ( STRING INTEGER in_param aValue )
 aValue .
proc-end // C

'Hello world' A
'Hello world' B
'Hello world' C
123 C

; // ProcTest

ProcTest
..\..\ScriptEngine\Examples\CodeGeneration1\Proc1.ms.script
PROGRAM Proc1.ms.script

USES
 CompileTimeVar.ms.dict
;

STRING CompileTime-VAR g_CurrentProc ''

MACRO proc
  Literal IN aName
  ^ IN aParams

 %SUMMARY 'Определяет процедуру с ПОЛНЫМ контролем типов' ;

 g_CurrentProc '' == ?ASSURE 'Вложенные процедуры пока не поддерживаются'

 aName |N >>> g_CurrentProc
 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol VOID
 axiom:PushSymbol :
 g_CurrentProc Ctx:Parser:PushString

 @SELF aParams axiom:Params:Push
; // proc

MACRO proc-end
 %SUMMARY 'Завершает определение процедуры с ПОЛНЫМ контролем типов' ;

 axiom:PushSymbol ;

 axiom:PushSymbol VOID
 axiom:PushSymbol :
 '_' g_CurrentProc Cat Ctx:Parser:PushSymbol
 axiom:PushSymbol ;
 '' >>> g_CurrentProc
; // proc-end

USES
 Testing.ms.dict
;

Test&Dump ProcTest

proc A ( in_param aValue )
 aValue .
proc-end // A

proc B ( STRING in_param aValue )
 aValue .
proc-end // B

proc C ( STRING INTEGER in_param aValue )
 aValue .
proc-end // C

proc D ( STRING INTEGER OBJECT in_param aValue )
 aValue .
proc-end // D

proc E ( STRING INTEGER OBJECT INTERFACE in_param aValue )
 aValue .
proc-end // E

'Hello world' A
'Hello world' B
'Hello world' C
123 C
'Hello world' D
123 D
nil D
'Hello world' E
123 E
nil E
INTERFACE VAR F
F := nil
F E

; // ProcTest

ProcTest
..\..\ScriptEngine\Examples\CodeGeneration1\SaveVarAndDo.ms.script
// SaveVarAndDo.ms.script

USES
 types.ms.dict
 core.ms.dict
 params.ms.dict
 macro.ms.dict
 io.ms.dict
 Documentation.ms.dict
 Testing.ms.dict
 Debug.ms.dict
 SaveVarAndDo.ms.dict
;

Test&Dump SaveVarAndDoTest

VAR A
A := '1'
A Trace

SaveVarAndDo A (
 A Trace
 'got it' Trace
 A := 2
 A Trace
)

A Trace

; // SaveVarAndDoTest

SaveVarAndDoTest
..\..\ScriptEngine\Examples\CodeGeneration1\Slice.ms.script
USES
 arrays.ms.dict
 Testing.ms.dict
;

Test&Dump SliceTest

2 [ 1 2 3 4 5 6 7 8 9 10 ] SLICE ==> ( . . '--' . )
2 [ 1 2 3 4 5 6 7 8 9 10 ] SLICE .
3 [ 1 2 3 4 5 6 7 8 9 10 11 12 ] SLICE ==> ( . . . '--' . )
3 [ 1 2 3 4 5 6 7 8 9 10 11 12 ] SLICE .
'------' .

2 [ 1 2 3 4 5 6 7 8 9 10 ] SLICE Reverted ==> ( . . '--' . )
2 [ 1 2 3 4 5 6 7 8 9 10 ] SLICE Reverted .
3 [ 1 2 3 4 5 6 7 8 9 10 11 12 ] SLICE Reverted ==> ( . . . '--' . )
3 [ 1 2 3 4 5 6 7 8 9 10 11 12 ] SLICE Reverted .
'------' .

[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 ==> ( . . '--' . )
[ 1 2 3 4 5 6 7 8 9 10 11 12 ] .slice> 3 ==> ( . . . '--' . )
'------' .

[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 Reverted ==> ( . . '--' . )
[ 1 2 3 4 5 6 7 8 9 10 11 12 ] .slice> 3 Reverted ==> ( . . . '--' . )
'------' .

[ 1 2 3 4 5 6 7 8 9 10 ] >slice> 2 ==> ( . . '--' . )
[ 1 2 3 4 5 6 7 8 9 10 11 12 ] >slice> 3 ==> ( . . . '--' . )
'------' .

[ 1 2 3 4 5 6 7 8 9 10 ] >slice> 2 Reverted ==> ( . . '--' . )
[ 1 2 3 4 5 6 7 8 9 10 11 12 ] >slice> 3 Reverted ==> ( . . . '--' . )
'------' .

; // SliceTest

SliceTest
..\..\ScriptEngine\Examples\CodeGeneration1\String.ms.script
PROGRAM String.ms.script

USES
 string.ms.dict
 Testing.ms.dict
;

Test&Dump StringTest
 RunTests.in.array @[ (+)? ?(+) strings:CatSep> any:Cat string:Split:for> ]
  %REMARK 'Запускаем тесты к указанным скриптовым словам'
; // StringTest

StringTest
..\..\ScriptEngine\Examples\CodeGeneration1\Testing.ms.script
// Testing.ms.script

USES
 Testing.ms.dict
 string.ms.dict
;

Test&Dump TestingTest
 RunTests.in.array @[ (+)? ]
  %REMARK 'Запускаем "стандартные тесты" для слова (+)?'
; // TestingTest

TestingTest
..\..\ScriptEngine\Examples\CodeGeneration1\Trunc.ms.script
USES
 arrays.ms.dict
 Testing.ms.dict
;

Test&Dump TruncTest

@ ( 6 != ) [ 1 2 3 4 5 6 7 8 9 10 ] TRUNC ==> .
@ ( 6 != ) [ 1 2 3 4 5 6 7 8 9 10 ] TRUNC .

'-------' .
[ 1 2 3 4 5 6 7 8 9 10 ] .trunc> ( 6 != ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .trunc> ( 6 != ) .
'-------' .
[ 1 2 3 4 5 6 7 8 9 10 ] >trunc> ( 6 != ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] >trunc> ( 6 != ) .
'-------' .

; // TruncTest

TruncTest
..\..\ScriptEngine\Examples\CodeGeneration1\WasGenerated.ms.script
PROGRAM WasGenerated.ms.script

USES
 axiom_push.ms.dict
 // - в этом словаре описано слово []
;

USES
 io.ms.dict
 // - в этом словаре определено слово Print
;

USES
 DogAndBracket.ms.dict
 // - в этом словаре описано слово @[
;

USES
 CompileTimeVar.ms.dict
 // - в этом словаре описано слово CompileTime-VAR
;

USES
 Testing.ms.dict
 // - в этом словаре описано слово Test&Dump
;

Test&Dump WasGenerated.ms.script.test

 %SUMMARY 'Метод WasGenerated.ms.script.test' ;

 BOOLEAN FUNCTION .WasGenerated
   TtfwWord IN aWord
  %SUMMARY 'Определяет тот факт, что слово aWord уже использовалось для генерации' ;

  ARRAY CompileTime-VAR g_WasGenerated []

  if ( aWord g_WasGenerated array:Has ! )
  begin
   aWord array:AddTo g_WasGenerated
   false >>> Result
  end // aValue l_Array array:Has !
  else
  begin
   true >>> Result
  end // aValue l_Array array:Has !
 ; // .WasGenerated

 : A
  %SUMMARY 'Метод A' ;
 ; // A

 : B
  %SUMMARY 'Метод B' ;
 ; // B

 : C
  %SUMMARY 'Метод C' ;
 ; // C

 @[ 
 // - слово @[ открывает массив ССЫЛОК, а не ЗНАЧЕНИЙ
  A A A B B B C C C A A A B B B C C C 
 ] 
 %REMARK ' - это массив ССЫЛОК на функции (слова)'
 .filter> ( @ B != )
 %REMARK ' - отфильтровываем значения равные ссылке на B
  ВАЖНО: тут сравниваем УКАЗАТЕЛИ на функции'
 .filter> ( |N 'C' != )
 %REMARK ' - отфильтровываем значения равные ''C''
  ВАЖНО: тут сравниваем ИМЕНА функций'
 .filter> ( .WasGenerated ! )
 %REMARK ' - отфильтровываем те слова, которые уже были использованы для генерации
  теперь СПЕЦИАЛЬНО вызываем функцию .WasGenerated ПОСЛЕ всех ОСТАЛЬНЫХ фильтров'
 .map> pop:Word:Name 
 %REMARK ' - мапируем значение на вызов функции pop:Word:Name'
 .for> 
 %REMARK ' - итерируем смапированные значения'
 Print
 %REMARK ' - печатаем каждое итерируемое значение'

; // WasGenerated.ms.script.test

WasGenerated.ms.script.test
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Class1.ms.script
<<UMLClass>> <<Class>> Class1
Родители Project1 Program1
; // Class1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Class2.ms.script
<<UMLClass>> <<Class>> Class2
Родители Project1 Program1
Наследуемые Class1
Реализуемые Interface1 Interface2
; // Class2
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Class3.ms.script
<<UMLClass>> <<Class>> Class3
Родители Project1 Program1
; // Class3
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Class4.ms.script
<<UMLClass>> <<Class>> Class4
Родители Project1 Program1
Наследуемые Class2 Class3
; // Class4
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Class5.ms.script
<<UMLClass>> <<Class>> Class5
Родители Project1 Program1
; // Class5
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\InnerClass1.ms.script
<<UMLClass>> <<Class>> InnerClass1
Родители Project1 Program1 Class5
; // InnerClass1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\InnerClass2.ms.script
<<UMLClass>> <<Class>> InnerClass2
Родители Project1 Program1 Class5
; // InnerClass2
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Interface1.ms.script
<<UMLClass>> <<Interface>> Interface1
Родители Project1 Program1
; // Interface1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Interface2.ms.script
<<UMLClass>> <<Interface>> Interface2
Родители Project1 Program1
; // Interface2
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Library1.ms.script
<<UMLCategory>> <<Library>> Library1
Родители Project1
; // Library1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Library2.ms.script
<<UMLCategory>> <<Library>> Library2
Родители Project1
; // Library2
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Library3.ms.script
<<UMLCategory>> <<Library>> Library3
Родители Project1
; // Library3
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Program1.ms.script
<<UMLCategory>> <<Program>> Program1
Родители Project1
; // Program1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1.ms.script
<<UMLCategory>> <<Project>> Project1
; // Project1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Library1.ms.script
<<UMLCategory>> <<Library>> Library1
Родители Project1
; // Library1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Library2.ms.script
<<UMLCategory>> <<Library>> Library2
Родители Project1
; // Library2
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Library3.ms.script
<<UMLCategory>> <<Library>> Library3
Родители Project1
; // Library3
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Program1.ms.script
<<UMLCategory>> <<Program>> Program1
Родители Project1
; // Program1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Program1_Class1.ms.script
<<UMLClass>> <<Class>> Class1
Родители Project1 Program1
; // Class1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Program1_Class2.ms.script
<<UMLClass>> <<Class>> Class2
Родители Project1 Program1
Наследуемые Class1
Реализуемые Interface1 Interface2
; // Class2
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Program1_Class3.ms.script
<<UMLClass>> <<Class>> Class3
Родители Project1 Program1
; // Class3
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Program1_Class4.ms.script
<<UMLClass>> <<Class>> Class4
Родители Project1 Program1
Наследуемые Class2 Class3
; // Class4
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Program1_Class5.ms.script
<<UMLClass>> <<Class>> Class5
Родители Project1 Program1
 <<UMLClass>> <<Const>> Constant1
 Родители Project1 Program1 Class5
 ; // Constant1
 <<UMLClass>> <<Const>> Constant2
 Родители Project1 Program1 Class5
 ; // Constant2
 <<UMLClass>> <<Class>> InnerClass1
 Родители Project1 Program1 Class5
 ; // InnerClass1
 <<UMLClass>> <<Class>> InnerClass2
 Родители Project1 Program1 Class5
 ; // InnerClass2
; // Class5
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Program1_Interface1.ms.script
<<UMLClass>> <<Interface>> Interface1
Родители Project1 Program1
; // Interface1
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project1_Program1_Interface2.ms.script
<<UMLClass>> <<Interface>> Interface2
Родители Project1 Program1
; // Interface2
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project2.ms.script
<<UMLCategory>> <<Project>> Project2
 <<UMLClass>> <<Const>> Constant1
 Родители Project2
 ; // Constant1
 <<UMLClass>> <<Const>> Constant2
 Родители Project2
 ; // Constant2
; // Project2
..\..\ScriptEngine\Examples\CodeGeneration1\CodeGen69\Project3.ms.script
<<UMLCategory>> <<Project>> Project3
 <<UMLClass>> <<Const>> Constant1
 Родители Project3
 ; // Constant1
 <<UMLClass>> <<Const>> Constant2
 Родители Project3
 ; // Constant2
; // Project3
..\..\ScriptEngine\Examples\Other\2DROP.ms.script
4 3 2 1 2DROP . .
..\..\ScriptEngine\Examples\Other\2DUP.ms.script
4 3 2 1 2DUP . . . . . . 
..\..\ScriptEngine\Examples\Other\2OVER.ms.script
4 3 2 1 2OVER . . . . . .
..\..\ScriptEngine\Examples\Other\2SWAP.ms.script
4 3 2 1 2SWAP . . . .
..\..\ScriptEngine\Examples\Other\Array.ms.script
Тест ArrayTest

 INTEGER VAR I
 I := 0
 ARRAY VAR L 
 L := ( [
  10 LOOP ( ++! I I ) 
 ] )

 @ . L ITERATE
 // - печатает числа от 1 до 10
 '' .
 0 @ + L ITERATE .
 // - суммирует числа от 1 до 10 и печатает результат
 '' .
 @ . L Reverted ITERATE
 // - печатает числа от 10 до 1
;

ArrayTest 
..\..\ScriptEngine\Examples\Other\ArrayPrint.ms.script
Test ArrayPrint
 [ 1 2 3 4 5 ] .
 [ 1 2 3 [ 10 20 ] 4 5 ] .
; // ArrayPrint

ArrayPrint
..\..\ScriptEngine\Examples\Other\AtomicIf.ms.script
: AtomicIf
 1 2 LESS ? ( 'got' . )
 1 2 LESS ! ? ( 'got' . )
;

AtomicIf
..\..\ScriptEngine\Examples\Other\BadInt.ms.script
2222222222222222222222222 .
..\..\ScriptEngine\Examples\Other\Break.ms.script
Тест TestBreak

 VAR l_Index 

 0 >>> l_Index
 10 LOOP 
 BEGIN 
  l_Index .
  Если ( l_Index 6 == ) то
   BREAK
  ++! l_Index
 END

  0 >>> l_Index
 WHILE ( l_Index 10 LESS )
 BEGIN
  l_Index .
  Если ( l_Index 7 == ) то
   BREAK
  ++! l_Index
 END

  0 >>> l_Index
 10 LOOP 
 BEGIN 
  l_Index .
  l_Index 6 == ? BREAK
  ++! l_Index
 END

 0 >>> l_Index
 WHILE ( l_Index 10 LESS )
 BEGIN
  l_Index .
  l_Index 7 == ? BREAK
  ++! l_Index
 END
;

TestBreak
..\..\ScriptEngine\Examples\Other\CallerAndWordWorker.ms.script
: TestCallerAndWordWorker

 VOID CALLER operator DoIt ^ IN aLambda
  Caller -> X aLambda DO
 ;
 
 VOID CALLER operator DoIt1 
   IN aLeft
   ^ IN aLambda
  aLeft . 
  Caller -> X aLambda DO
 ;
 
 : A
  VAR X
  X := 1025
  
  DoIt .
  1024 DoIt1 .
 ;
 
 : B
  VAR X
  X := 'Hello'
  
  DoIt .
 ;
 
 A
 B

;

TestCallerAndWordWorker
..\..\ScriptEngine\Examples\Other\CallerFirstParamWorker.ms.script
USES
 'TemplatesCore.tpl.script'
;

: TestCallerFirstParamWorker

 VOID CALLER operator DoIt
  Caller ->0 .
 ;
 
 PROCEDURE A IN aParam
  VAR X
  1025 =: X
  X .
  
  DoIt
  
 ;
 
 PROCEDURE B IN anIn
  VAR X
  'Hello' =: X
  X .
  
  DoIt
 ;
 
 'Test' A
 'oops' B

;

TestCallerFirstParamWorker
..\..\ScriptEngine\Examples\Other\CallerFirstParamWorker1.ms.script
USES
 'TemplatesCore.tpl.script'
;

: TestCallerFirstParamWorker

 VOID CALLER operator DoIt
  Caller ->0 .
 ;
 
 PROCEDURE A IN aParam
  DoIt
  'Test1' ( 
   IN aParam 
   
   if true 
    DoIt 

   if true then
    DoIt 
     
   if false then
    NOP
   else
    DoIt 
    
   if true then
   (
    DoIt 
   ) 
   
   if false then
    NOP
   else 
   (
    DoIt 
   ) 
  )
 ;
 
 'Test' A

;

TestCallerFirstParamWorker
..\..\ScriptEngine\Examples\Other\CallerFirstParamWorker2.ms.script
USES
 'TemplatesCore.tpl.script'
;

: TestCallerFirstParamWorker

 STRING CALLER operator DoIt
  Result := ( Caller ->0 )
 ;
 
 PROCEDURE A STRING IN aParam
  DoIt .
 ;
 
 'Test' A

;

TestCallerFirstParamWorker
..\..\ScriptEngine\Examples\Other\CallerWorker.ms.script
: TestCallerWorker

 VOID CALLER operator DoIt
  Caller -> X .
 ;
 
 : A
  VAR X
  X := 1025
  
  DoIt
 ;
 
 : B
  VAR X
  X := 'Hello'
  
  DoIt
 ;
 
 A
 B

;

TestCallerWorker
..\..\ScriptEngine\Examples\Other\Cardinal.ms.script
: CardinalTest

 CARDINAL VAR X
 X := 1
 X .
 
 "Выполнить подавив исключение" ( X := INTEGER ( '2' ) )
 X .
 
 @ X pop:Word:Directives .
 @ CARDINAL pop:Word:Directives .
 @ CARDINAL pop:object:ClassName .
;

CardinalTest 
..\..\ScriptEngine\Examples\Other\Cat.ms.script
'a' 'bc' Cat .

'bc' 'a' Cat .
..\..\ScriptEngine\Examples\Other\char_Dupe.ms.script
10 'a' char:Dupe .
10 'ab' char:Dupe .
..\..\ScriptEngine\Examples\Other\char_ToString.ms.script
'a' string:ToChar char:ToString .
..\..\ScriptEngine\Examples\Other\CheckVar.ms.script
/*{VOID IMMEDIATE OPERATOR @SELF
 Ctx:WordDefiningNow CompileWeakRef
; // @SELF}*/

Test CheckVarTest

 IMMEDIATE operator MakeVar
  ^L IN aName
  aName |N true Ctx:NewWordDefinitor pop:NewWordDefinitor:CheckVar
  @SELF SWAP pop:Word:SetProducer
  //DROP // - снимаем переменную со стека
  Ctx:ClearTypeInfo
 ; // MakeVar
 
 : A
  INTEGER MakeVar X
 ; // A
 
 : B
  STRING MakeVar X
  MakeVar Y
  INTEGER MakeVar Z
 ; // B
 
 @SELF __DumpMembers
 
; // CheckVarTest

CheckVarTest
..\..\ScriptEngine\Examples\Other\ClassProducer.ms.script
: ClassProducerTest

/*{ IMMEDIATE operator ClassProducer
  @ operator DO
 ;
 
 IMMEDIATE ClassProducer DefineClass
  @ operator DO
 ;}*/
 
 //WordAlias ClassProducer WordProducer
 
 ClassProducer DefineClass
 
 DefineClass TSomeClass
 
  //INHERITS
  // Tl3Base
  //;

  : "Метод класса"
  ;
  
  INTEGER FUNCTION "Функция класса"
   Result := 0
  ;
  
  operator "Оператор класса"
  ;
  
  'Bang!' .
 ;
 
 TSomeClass
 @ TSomeClass |N .
 @ TSomeClass pop:object:ClassName .
 @ TSomeClass %P pop:object:ClassName .
 @ TSomeClass %P %P pop:object:ClassName .
 @ TSomeClass %ST |N .
 // - тут ожидаем DefineClass
 @ TSomeClass %ST %ST |N .
 // - тут ожидаем ClassProducer
 
 @ TSomeClass __DumpMembers
;

ClassProducerTest
..\..\ScriptEngine\Examples\Other\ClassRef.ms.script
Тест ClassRef

 TClass VAR l_Ref
 //class::TvtCustomOutliner =: l_Ref
 class::Tl3ProtoObject =: l_Ref
 l_Ref .
;

ClassRef
..\..\ScriptEngine\Examples\Other\Clipboard.ms.script
USES
 axiom:clipboard
;

'Привет мир' clipboard:SetText

CF_TEXT clipboard:GetFormattedText .
CF_UNICODETEXT clipboard:GetFormattedText .

'Привет'#8201'мир' clipboard:SetText

CF_TEXT clipboard:GetFormattedText .
CF_UNICODETEXT clipboard:GetFormattedText .

clipboard:Clear
..\..\ScriptEngine\Examples\Other\CompareStr.ms.script
'a' 'a' CompareStr .
'a' 'b' CompareStr .
'b' 'a' CompareStr .

'A' 'a' CompareStr .
'A' 'b' CompareStr .
'B' 'a' CompareStr .
..\..\ScriptEngine\Examples\Other\CompareText.ms.script
'a' 'a' CompareText .
'a' 'b' CompareText .
'b' 'a' CompareText .

'A' 'a' CompareText .
'A' 'b' CompareText .
'B' 'a' CompareText .
..\..\ScriptEngine\Examples\Other\CompileValue.ms.script
USES
 CodeDump.script
;

Test TestCompileValue

 STRING VAR S
 [EXECUTE] ( S := 'Hello' )

 S := 'World'
 
 INTEGER VAR I
 [EXECUTE] ( I := 20 )
 
 I := 30
 
 [EXECUTE] ( I CompileValue ) .
 [EXECUTE] ( S CompileValue ) .

 OBJECT VAR O
 [EXECUTE] ( O := @ . )
 
 [EXECUTE] ( S CompileValue O CompileValue )

 [EXECUTE] ( 'гы гы гы' CompileValue @ . CompileValue )
 
 'гы гы гы 2' [EXECUTE] ( @ . CompileValue )
 
 I .
 S .
 
 @SELF DumpElement
 
; // TestCompileValue

TestCompileValue
..\..\ScriptEngine\Examples\Other\ComputerName.ms.script
: TestComputerName
 EtalonNeedsComputerName
 ComputerName .
;

TestComputerName
..\..\ScriptEngine\Examples\Other\ConditionWithRightParam.ms.script
StereotypeProducer Before ;

<<Before>> Group1
;

VOID <<Group1>> BeforeCond4 ^ IN aParam
 'with right param: ' . aParam DO .
;

'hello' .

@ BeforeCond4 .

@^ BeforeCond4 |^@ .

@ BeforeCond4 pop:Word:Name .

@ BeforeCond4 pop:Word:Producer pop:Word:Name .

@ BeforeCond4 pop:Word:Producer pop:Word:Producer pop:Word:Name .

@ BeforeCond4 pop:Word:Producer pop:Word:Producer pop:Word:Producer pop:Word:Name .

'before' .

BeforeCond4 '456'

BeforeCond4 '456' |^@ .

BeforeCond4 '456' |^@ |N .

BeforeCond4 '456' |^@ %P |N .

'after' .
..\..\ScriptEngine\Examples\Other\Declared.ms.script
/*{USES
 axiom:KeywordFinder
;

VOID IMMEDIATE OPERATOR DECLARED
  ^L IN aName
 BOOLEAN VAR l_Found
 aName |N Ctx:PushFinder pop:KeywordFinder:KeywordByName <> nil >>> l_Found
 l_Found CompileValue
; // DECLARED}*/

 DECLARED + .
 DECLARED XXX .

 : XXX
  2 2 +
 ;

 DECLARED XXX .
 XXX .
 DECLARED 2 .
 DECLARED '2' .
..\..\ScriptEngine\Examples\Other\Dictionary.ms.script
USES
 CodeDump.script
; 

Test TestDictionary
 help
 @SELF DumpElement
; // TestDictionary

TestDictionary
..\..\ScriptEngine\Examples\Other\Division.ms.script
10 5 / .
15 4 / .
20 3 DIV .
15 4 MOD . 
8 2/ .
15 2/ .
..\..\ScriptEngine\Examples\Other\DropN.ms.script
10 1 2 3 4 5 5 DROPN 

WHILE ( StackLevel > 0 ) .
..\..\ScriptEngine\Examples\Other\DupN.ms.script
1 2 3 4 5 5 DUPN 

WHILE ( StackLevel > 0 ) .
..\..\ScriptEngine\Examples\Other\EndsStr.ms.script
'c' 'abc' EndsStr .
'b' 'abc' EndsStr .

'C' 'abc' EndsStr .
'B' 'abc' EndsStr .
..\..\ScriptEngine\Examples\Other\EndsText.ms.script
'c' 'abc' EndsText .
'b' 'abc' EndsText .

'C' 'abc' EndsText .
'B' 'abc' EndsText .
..\..\ScriptEngine\Examples\Other\Equals.ms.script
3 3 == .
true false == .
'строка1' 'строка2' == .

1 РАВНО 1  .
[ 10 20 ] РАВНО ( 10 20 ) .
[ 10 20 ] РАВНО ( [ 10 20 ] ) .
[ 10 ] РАВНО ( [ 10 ] ) .
[ 10 ] РАВНО ( 10 ) .
[ 10 ] РАВНО ( 20 ) .

'a' РАВНО 'a' .
'a' РАВНО 'b' .
[ 'a' 'b' ] РАВНО ( 'a' 'b' ) .
[ 'a' 'b' ] РАВНО ( 'a' 'a' ) .

[ 'a' 'b' ] РАВНО ( [ 'a' 'b' ] ) .

[ 'a' 'b' ] РАВНО [ 'a' 'b' ] .
[ 'a' 'b' ] РАВНО [ 'a' 'a' ] .

[ 'a' 'b' ] РАВНО [ 'a' 'b' 'c' ] .
..\..\ScriptEngine\Examples\Other\error.ms.script
Test TestError
 "Выполнить подавив исключение"
 ( ERROR 'Сообщение' )
; // TestError

TestError
..\..\ScriptEngine\Examples\Other\EtalonNeedsOSName.ms.script
EtalonNeedsOSName
OSName .
..\..\ScriptEngine\Examples\Other\ExceptionStack.ms.script
Тест ExceptionStack

 PROCEDURE P1
  STRING VAR S
  S := STRING ( 1 )
 ;
 
 PROCEDURE P2
  P1
 ;
 
 PROCEDURE P3
  P2
 ;
 
 TRY
  P3
 EXCEPT
  for script:ExceptionStack .
 END 
 
;

//анти-тест ExceptionStack
ExceptionStack
..\..\ScriptEngine\Examples\Other\EXEFileName.ms.script
application:ExeName sysutils:ExtractFileName .
..\..\ScriptEngine\Examples\Other\Exit.ms.script
: TestExit
 'Сюда попали' .
 EXIT
 'Сюда никогда не попадём' .
;

: TestExit1
 'Сюда попали' .
 ( EXIT )
 'Сюда никогда не попадём' .
;

: TestExit2
 'Сюда попали' .
 Если ДА то ( EXIT )
 'Сюда никогда не попадём' .
;

: TestExit3
 'Сюда попали' .
 Если ДА ( EXIT )
 'Сюда никогда не попадём' .
;

: TestExit4
 'Сюда попали' .
 Если НЕТ то
  ( NOP )
 иначе
  ( EXIT ) 
 'Сюда никогда не попадём' .
;


TestExit
TestExit1
TestExit2
TestExit3
TestExit4
..\..\ScriptEngine\Examples\Other\Filter.ms.script
BOOLEAN FUNCTION IsEven
 INTEGER IN aValue
 aValue 2 MOD 0 == >>> Result
; // IsEven

[ 1 2 3 4 5 6 7 8 9 10 ] .filter> IsEven ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .filter> IsEven .

[ 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) ==> ( . . '---' . )

 STRING FUNCTION ToPrintableEx
   IN aValue
  if ( aValue IsArray )
   ( 
    [ 
     '[ ' 
     INTEGER VAR l_SL
     l_SL := StackLevel
     for aValue ( 
      INTEGER VAR l_Delta
      l_Delta := ( StackLevel l_SL - )
      if ( l_Delta = 1 ) then
       ( @SELF DO )
      else
       (
        INTEGER VAR l_Index
        l_Index := l_Delta
        '{ '
        l_Delta LOOP ( l_Index ROLL @SELF DO )
        // Премудрость с LOOP и ROLL для того, чтобы обработать slice'ы
        '}' 
       )
      l_SL := StackLevel 
     ) 
     ']' 
    ] ' ' strings:CatSep >>> Result 
   )
  else 
   ( aValue ToPrintable >>> Result )
 ; // ToPrintable
 
[ 1 10 2 9 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) ToPrintableEx .

[ 1 2 ] ToPrintableEx .

[ 1 10 2 9 3 8 4 7 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) ToPrintableEx .

[ 1 10 2 9 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) .

[ 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) ToPrintableEx .

[ 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1 ] .slice> 2 .filter> ( INTEGER IN A INTEGER IN B A IsEven ) .

//[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem anItem IsEven ) ==> .
//[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem anItem IsEven ) .

//[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem if ( anItem IsEven ) ( anItem ) else ( anItem 1 + ) ) ==> .
//[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem if ( anItem IsEven ) ( anItem ) else ( anItem 1 + ) ) .

//[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 .map> + ==> .
//[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 .map> + .
..\..\ScriptEngine\Examples\Other\FindMember.ms.script
Тест TestFindMember

/*{ OBJECT operator %%
  OBJECT IN aWord
  ^ IN aName
  
  OBJECT VAR l_Member
  aName DO aWord pop:Word:FindMember >>> l_Member
  
  if ( l_Member pop:object:IsNil ) then
   ( Result := nil )
  else
   ( Result := ( l_Member pop:KeyWord:Word ) ) 
 ; // %%}*/
 
 : A
  : B
   100 .
  ; // B
  1024 .
 ; // A

 @ A %% 'B' DO
; // TestFindMember

TestFindMember
..\..\ScriptEngine\Examples\Other\ForTo.ms.script
Test ForToTest

 ARRAY operator to 
   ^@ IN aFrom
   ^ IN aTo
  @ ( 
   OBJECT IN aLambda
   INTEGER VAR I
   I := ( aFrom DO )
   Dec I
   ( aTo DO I ) - LOOP ( Inc I I aLambda DO ) 
  ) FunctorToIterator >>> Result
 ; // 1to
 
 for ( 1 to 10 ) .
 // - печатает числа от 1 до 10
 '' .
 for ( 1 to 20 ) .
 // - печатает числа от 1 до 20
 '' .
 for ( 0 to 20 ) .
 // - печатает числа от 0 до 20
 '' .
 for ( -1 to 20 ) .
 // - печатает числа от -1 до 20
 '' .
 for ( -1 to 21 ) .
 // - печатает числа от -1 до 21
 '' .
 0 for ( 1 to 10 ) + .
 // - суммирует числа от 1 до 10 и печатает результат
 '' .
 for ( 1 to 10 Reverted ) .
 // - печатает числа от 10 до 1
 
/*{ 
 ARRAY VAR L
 
 1to 10 >>> L
 
 @ . L ITERATE
 // - печатает числа от 1 до 10
 '' .
 @ . 1to 20 ITERATE
 // - печатает числа от 1 до 20
 '' .
 0 @ + L ITERATE .
 // - суммирует числа от 1 до 10 и печатает результат
 '' .
 @ . L Reverted ITERATE
 // - печатает числа от 10 до 1}*/
; // ForToTest

ForToTest
..\..\ScriptEngine\Examples\Other\FunctorToIterator.ms.script
Test FunctorToIteratorTest

 ARRAY VAR L
 @ ( 
  OBJECT IN aLambda
  INTEGER VAR I
  I := 0
  10 LOOP ( ++! I I aLambda DO ) 
 ) FunctorToIterator >>> L
 
 @ . L ITERATE
 // - печатает числа от 1 до 10
 '' .
 0 @ + L ITERATE .
 // - суммирует числа от 1 до 10 и печатает результат
 '' .
 @ . L Reverted ITERATE
 // - печатает числа от 10 до 1
; // FunctorToIteratorTest

FunctorToIteratorTest
..\..\ScriptEngine\Examples\Other\Halt.ms.script
Тест TestHalt

 : Inner
  'Сюда попали' .
  HALT
  'Сюда никогда не попадём' .
 ; 
 Inner
 'Сюда тоже никогда не попадём' .
;

TestHalt
'И сюда тоже никогда не попадём' .
..\..\ScriptEngine\Examples\Other\help.ms.script
EtalonNeedsXE
help
..\..\ScriptEngine\Examples\Other\if.ms.script
: SIGN
    Если ( DUP >0 ) то
     ( 'ПОЛОЖИТЕЛЬНОЕ ЧИСЛО' . DROP )
    иначе
     Если ( =0 ) то
      ( 'НОЛЬ' . )
     иначе
      ( 'ОТРИЦАТЕЛЬНОЕ ЧИСЛО' . )
;

: SIGN1 
   Если ( ?DUP =0 ) то
    ( 'НОЛЬ' . )
   иначе 
    Если ( >0 ) то
     ( 'ПОЛОЖИТЕЛЬНОЕ ЧИСЛО' . ) 
    иначе 
     ( 'ОТРИЦАТЕЛЬНОЕ ЧИСЛО' . )
;

-1 SIGN
0 SIGN
1 SIGN

-1 SIGN1
0 SIGN1
1 SIGN1
..\..\ScriptEngine\Examples\Other\IfElse.ms.script
USES
 CodeDump.script
;

Test IfElseTest

/*{INLINE OPERATOR then
  ^ IN aWhatToThen
 aWhatToThen DO
; // then}*/

/*{VOID IMMEDIATE OPERATOR then
  ^ IN aWhatToThen
 aWhatToThen CompileValue
; // then}*/

INTEGER FUNCTION SIGN INTEGER IN aNum
 if ( aNum <0 ) then
  ( Result := -1 )
 else
 if ( aNum >0 ) then
  ( Result := 1 )
 else 
  ( Result := 0 )
;

INTEGER FUNCTION SIGN1 INTEGER IN aNum
 if ( aNum <0 ) then
  ( Result := -1 )
 else
 (
  if ( aNum >0 ) then
   ( Result := 1 )
  else 
   ( Result := 0 )
 ) 
;

INTEGER FUNCTION SIGN2 INTEGER IN aNum
 Если ( aNum <0 ) то
  ( Result := -1 )
 иначе
 если ( aNum >0 ) то
  ( Result := 1 )
 иначе
  ( Result := 0 )
;

-1 SIGN .
0 SIGN .
1 SIGN .

-1 SIGN1 .
0 SIGN1 .
1 SIGN1 .

-1 SIGN2 .
0 SIGN2 .
1 SIGN2 .

@SELF DumpElement

; // IfElseTest

IfElseTest
..\..\ScriptEngine\Examples\Other\IfElse1.ms.script
USES
 CodeDump.script
;

Test IfElseTest

 : A
  1 .
  2 .
 ;

 : B
  3 .
  4 .
 ;
 
 INTEGER VAR aNum
 
 aNum := 0
 
 if ( aNum <0 ) then
  A
 else
  B

 @SELF DumpElement

; // IfElseTest

IfElseTest
..\..\ScriptEngine\Examples\Other\ImmedCallerAndWordWorker.ms.script
: TestImmedWordWorker

 IMMEDIATE VOID CALLER operator Print 
   ^ IN aLambda
  aLambda DO = 123 ?ASSURE 'Не прошла проверка'
  Caller -> %U := ( aLambda DO )
 ;
 
 'Hello' .
 Print 123

 %U := 1024
 %U .
 %U := 100
 %U .
;

TestImmedWordWorker
..\..\ScriptEngine\Examples\Other\Immediate.ms.script
USES
 CodeDump.script
;

Тест Immediate

/*{ IMMEDIATE operator [EXECUTE]
  ^ IN aCode
  aCode DO
 ; // [EXECUTE] }*/
 
 VOID IMMEDIATE operator initialization
  ^ IN aCode
  aCode Ctx:Engine pop:ScriptEngine:AddInitialization
 ; // initialization
 
 VAR A
 
 : TryVarPrint
  A .
  10 >>> A
  A .
 ;
 
 : TryVar1
  initialization ( 1024 >>> A 
   'Попали в инициализацию A' .
  )
  // - этот кусок должен выполняться ОДИН раз при компиляции скрипта
  TryVarPrint
 ;

 : TryVar2
  1024 >>> A
  // - этот кусок должен выполняться КАЖДЫЙ раз при выполнении слова
  TryVarPrint
 ;
 
 TryVar1
 TryVar1
 TryVar2
 TryVar2
 TryVar1
 TryVar1
 
 @SELF DumpElement
 
;

Immediate
..\..\ScriptEngine\Examples\Other\In.ms.script
USES
 CodeDump.script
 ;

Тест TestIn

 OPERATOR __DefineParam
  // - тут стереотип на стеке
  // - тут имя на стеке
  Ctx:NewWordDefinitor pop:NewWordDefinitor:DefineInParameter
  // - тут параметр на стеке
  Ctx:PushCompiler pop:Compiler:CompileInParameterPopCode
  Ctx:ClearTypeInfo
 ; // __DefineParam
 
 IMMEDIATE VOID OPERATOR __DefineNameParam
  @SELF 'aName' __DefineParam
 ; // __DefineNameParam
  
 IMMEDIATE VOID OPERATOR IN
  ^L __DefineNameParam
  @SELF aName DO __DefineParam
 ; // IN

 : A
  IN X
  X .
 ; // A
 
 '1' A
 2 A

 @SELF DumpElement
 
; // TestIn

TestIn
..\..\ScriptEngine\Examples\Other\Include.ms.script
 INCLUDE 'Included.script'
 USES 'Used.script'
 ;

 3 LOOP TestWord

 3 LOOP TestWord1
..\..\ScriptEngine\Examples\Other\Inherits.ms.script
USES
 CodeDump.script
;

Test InheritsTest

IMMEDIATE operator __CompileCodeAndFree
 TtfwWord IN aCode
 if ( aCode IS class::TkwBeginLikeCompiledCode ) then  
  ( aCode CodeIterator ==> CompileRef )
 else
  ( aCode CompileRef ) 
 aCode pop:Word:DecRef 
; // __CompileCodeAndFree

IMMEDIATE VOID operator NamedCodeProducer
  ^L IN aName
  ^L IN aNewName
 
 @SELF Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE axiom:operator'
  aName |N
  
  '^ IN aCode'
  
  '@SELF Ctx:SetWordProducerForCompiledClass'
  aNewName |NS
  'Ctx:SetNewWordName'
  
  '`axiom:operator` Ctx:Parser:PushSymbol'
  
  'aCode pop:Word:IncRef'
  'aCode'
  '`__CompileCodeAndFree` Ctx:Parser:PushSymbol'
  '`;` Ctx:Parser:PushSymbol'
  ';'
 ] Ctx:Parser:PushArray
; // NamedCodeProducer

NamedCodeProducer Inherits %G
NamedCodeProducer Implements %R

 : A
 ; // A

 : B
 ; // B

 : C
  Inherits ( A B )
 ; // C
 
 : I1
 ; // I1
 
 : I2
 ; // I2
 
 : D
  Inherits A
  Implements ( I1 I2 )
 ; // D
 
 : E
  Inherits A
  Implements I1
 ; // D
 
 @SELF DumpElement
; // InheritsTest

InheritsTest
..\..\ScriptEngine\Examples\Other\InitedVarProducer.ms.script
USES
 CodeDump.script
 ;

Тест InitedVarProducer

/*{VOID : __DefineVarWithInit
  STRING IN aName
  OBJECT IN aStereo
  IN aValue
  
  operator ___INIT_VAR
   IN aValue
   IN aVar
   aValue DO >>>^ aVar
  ; // ___INIT_VAR

  VAR l_NewVar
  aName aStereo __DefineVarEx >>> l_NewVar
  aValue CompileRef l_NewVar CompileRef @ ___INIT_VAR CompileValue
  aValue l_NewVar ___INIT_VAR
  // - это может и лишнее, но это чтобы не сломать %DOCUMENTATION и %upv,
  //   который могут ЧИТАТЬСЯ в обход выполнения кода родительского слова
  //   Может быть ПОТОМ это вообще на initialization надо будет переделать
  
; // __DefineVarWithInit

IMMEDIATE VOID operator InitedVarProducer
  ^L IN aName
 
 [
  'IMMEDIATE VOID __operator'
  aName |N
  '^L IN aName'
  '^ IN aValue'
  'aName |N @SELF aValue |^@ __DefineVarWithInit'
  ';'
 ] Ctx:Parser:PushArray
; // InitedVarProducer}*/
 
 InitedVarProducer VarTypeI
  
 STRING VarTypeI A 'Hello'
 
 INTEGER VarTypeI B 23
 
 A .
 B .
 
 @ A __DumpMembers
 
 @ B __DumpMembers
 
 (
  STRING VarTypeI A 'Hello'
  
  INTEGER VarTypeI B 23
  
  A .
  B .
  
  @ A __DumpMembers
  
  @ B __DumpMembers
 )
 
 @SELF DumpElement
 
 @SELF __DumpMembers
 
; // InitedVarProducer

InitedVarProducer
..\..\ScriptEngine\Examples\Other\IntToStr.ms.script
0 IntToStr .
1 IntToStr .
-1 IntToStr .

$a IntToStr .
$10 IntToStr .

"Выполнить подавив исключение" ( '123' IntToStr )
..\..\ScriptEngine\Examples\Other\IsUnder64.ms.script
EtalonNeeds64
IsUnder64 .
..\..\ScriptEngine\Examples\Other\IsXE.ms.script
EtalonNeedsXE
IsXE .
..\..\ScriptEngine\Examples\Other\Join.ms.script
[ 4 5 ] [ 1 2 3 ] JOIN ==> .
[ 4 5 ] [ 1 2 3 ] JOIN .
[ 4 5 ] [ 1 2 3 ] JOIN Reverted ==> .
[ 4 5 ] [ 1 2 3 ] JOIN Reverted .

'------' .

[ 1 2 3 ] .join> [ 4 5 ] ==> .
[ 1 2 3 ] .join> [ 4 5 ]  .
[ 1 2 3 ] .join> [ 4 5 ]  Reverted ==> .
[ 1 2 3 ] .join> [ 4 5 ]  Reverted .

'------' .

[ 1 2 3 ] >join> [ 4 5 ] ==> .
[ 1 2 3 ] >join> [ 4 5 ]  .
[ 1 2 3 ] >join> [ 4 5 ]  Reverted ==> .
[ 1 2 3 ] >join> [ 4 5 ]  Reverted .

'------' .

[ 1 2 3 ] .join> [ 4 5 ] .join> [ 6 7 8 9 10 ] ==> .
[ 1 2 3 ] .join> [ 4 5 ] .join> [ 6 7 8 9 10 ] .
[ 1 2 3 ] .join> [ 4 5 ] .join> [ 6 7 8 9 10 ] Reverted ==> .
[ 1 2 3 ] .join> [ 4 5 ] .join> [ 6 7 8 9 10 ] Reverted .

'------' .
..\..\ScriptEngine\Examples\Other\K269058906.ms.script
1 2 3 4 2SWAP . . . .
..\..\ScriptEngine\Examples\Other\K276546684.ms.script
USES
 axiom:StyleTable
 axiom:Tests
;

: K276546684
 VAR l_File
 script:FileName '.evs' sysutils:ChangeFileExt
 sysutils:ExtractFileName >>> l_File
 l_File StyleTable:SaveToFile
 l_File '%' tests:CheckEtalon
;

K276546684
..\..\ScriptEngine\Examples\Other\Less.ms.script
3 5 LESS .
true false LESS .
..\..\ScriptEngine\Examples\Other\List.ms.script
USES
 CodeDump.script
 ;

Test ListTest

 : A
  : B
   : C
    : D
    ; // D
   ; // C
  ; //B
 ; // A
 
 ARRAY FUNCTION LIST
  OBJECT IN anObject
  ^ IN aFunctor
  
  OBJECT VAR l_Element
  l_Element := anObject
  Result := [
   while true
   begin
    l_Element := ( l_Element aFunctor DO )
    if ( l_Element pop:object:IsNil ) then
     BREAK
    l_Element 
   end
  ]
 ; // LIST
 
 A :: B :: C :: D |^@ LIST %P ==> ( |N . )
 A :: B :: C :: D |^@ LIST %P Reverted ==> ( |N . )
 
 @SELF DumpElement
 
; // ListTest

ListTest
..\..\ScriptEngine\Examples\Other\Map.ms.script
BOOLEAN FUNCTION IsEven
 INTEGER IN aValue
 aValue 2 MOD 0 == >>> Result
; // IsEven

[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( 1 + ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( 1 + ) .

[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem anItem IsEven ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem anItem IsEven ) .

[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem if ( anItem IsEven ) ( anItem ) else ( anItem 1 + ) ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .map> ( INTEGER IN anItem if ( anItem IsEven ) ( anItem ) else ( anItem 1 + ) ) .

[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 .map> + ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 .map> + .
..\..\ScriptEngine\Examples\Other\MemberAccess.ms.script
Test MemberAccessTest

  : XXX
    VAR B
    VAR C
    : E
     6000
    ; // E
  ; // XXX
  
  XXX -> D := 0
  XXX -> D .
  XXX -> D := 1024
  XXX -> D .
  
  XXX -> E .
  
  XXX -> A := 1024
  XXX -> A .
  
  XXX -> B := 2048
  XXX -> B .
  
  XXX :: C |^@ ^:= 5000
  XXX :: C .
  XXX -> C .
  
  VAR A
  A := 5
  @SELF -> A := 6
  @SELF -> A .
  
  @SELF -> A .
  A .
  
  @SELF __DumpMembers
  
; // MemberAccessTest

MemberAccessTest
..\..\ScriptEngine\Examples\Other\MemberRefAccess.ms.script
Test MemberRefAccessTest

  : XXX
    VAR B
    VAR C
  ; // XXX
  
  XXX ->^ 'A' ^:= 1024
  XXX ->^ 'A' DO .
  
  XXX ->^ 'B' ^:= 2048
  XXX ->^ 'B' DO .
  
  XXX :: C |^@ ^:= 5000
  XXX :: C .
  XXX ->^ 'C' DO .
  
  @SELF __DumpMembers
  
; // MemberRefAccessTest

MemberRefAccessTest
..\..\ScriptEngine\Examples\Other\MethodsImplementing.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 CodeDump.script
 ;
 
Test MethodImplementing
 
 StereotypeStereotypeProducer P
 
  : X1
  ;
  
  : m2
  ;
  
 ;
 
 <<@P>> MDAClass
 
  : m1
  ;
  
  : m2
  ;
  
 ;
 
 <<@P>> MDACategory
 
  : m1
  ;
  
  : m2
  ;
  
 ;
 
 <<MDAClass>> SimpleClass
 
  : m1
  ;
  
  : m2
  ;
  
 ;
 
 <<SimpleClass>> Tl3Base
 
  : m1
  ;
  
 ;
 
 <<MDACategory>> Unit
  : x1
   ' World' .
  ;
  
  : x2
  ;
 ;
 
 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ;
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ;
 
 //implementation @^ <<Unit>>
 implementation <<Unit>>
 
  : NewMethod
   'Hello' . x1
  ;
  
 end.
 
 : XXX
  'Bang!' .
 ;
 
 @^ <<Unit>> |^@ .
 @^ <<Unit>> |^@ |N .
 @^ <<Unit>> :: NewMethod
 XXX
 
 @SELF DumpElement
 @SELF __DumpMembers
 
; // MethodImplementing

MethodImplementing
..\..\ScriptEngine\Examples\Other\minus.ms.script
5 3 - .
..\..\ScriptEngine\Examples\Other\MinusMinus.ms.script
5 -- .
..\..\ScriptEngine\Examples\Other\Modifier.ms.script
: ModifierTest
 INTEGER VAR X
 
 X := 1
 
 //INTEGER 
 X .
 
 VAR Y
 
 // - тут Y паразитно становился INTEGER, если раскомментировать INTEGER выше
 //   а теперь это контроллируется при компиляции
 
 INTEGER STRING VAR Z
 
 INTEGER STRING BOOLEAN VAR Q
 
 @ X pop:Word:Directives .
 @ Y pop:Word:Directives .
 @ Z pop:Word:Directives .
 @ Q pop:Word:Directives .
;

ModifierTest
..\..\ScriptEngine\Examples\Other\More.ms.script
3 5 GREATER .
true false GREATER .
..\..\ScriptEngine\Examples\Other\Multyply.ms.script
5 3 * .
4 2* .
3 7 4 */ .      
..\..\ScriptEngine\Examples\Other\NamedAutolinkProducer.ms.script
: UIDS_LIST
;
// - список загруженных элементов

Тест NamedAutolinkProducerTest

/*{ STRING operator |NS
  IN aName
  Result := ( [ '`' aName |N '`' ] strings:Cat )
 ; // |NS
 
 IMMEDIATE operator NamedAutolinkProducer
  ^L IN aOpName
  ^L IN aName
  [
   'IMMEDIATE operator'
   aOpName |N
   '^ IN aCode'
   'aCode '
   aName |NS
   'Define'
   ';' 
  ] Ctx:Parser:PushArray
 ; // NamedAutolinkProducer}*/
 
 NamedAutolinkProducer %TARGET %T
 
/*{ IMMEDIATE operator %TARGET
  ^ IN aCode
  aCode '%T' Define
 ; // %TARGET}*/
 
IMMEDIATE VOID CALLER operator %UID 
  ^L IN anUID
 VAR l_S
 anUID |^@ |N =: l_S
 // - получаем имя (значение) UID
 
 VAR l_VAR
 
 UIDS_LIST ->^ l_S >>> l_VAR
 // - добавляем переменную и снимем её со стека
 
 Caller -> %U := l_VAR
 // - добавляем элементу переменную, указывающую на его UID
 l_VAR ^:= Caller
 // - присваиваем в переменную с UID ссылку на сам элемент
; // %UID 
// - идентификатор элемента

VOID IMMEDIATE operator U$
  ^L IN anUID
 VAR l_S
 anUID |^@ |N =: l_S
 UIDS_LIST ->^ l_S CompileValue
; // U$
// - преобразование идентификатора элемента собственно к элементу
 
 : A
  %UID 2
  %TARGET U$ 2
 
  %T |^@ .
  %T |^@ |N .
  %T .
  @SELF ->^ '%T' DO .
  @SELF ->^ '%T' DO .
  @SELF -> %T .
 ; // A 
 
 : B
  %UID 3
  %TARGET U$ 2
 
  %T .
  %T .
  @SELF ->^ '%T' DO .
  @SELF ->^ '%T' DO .
  @SELF -> %T .
 ; // B
 
 UIDS_LIST -> 2 |N .
 UIDS_LIST -> 3 |N .
 A
 UIDS_LIST -> 2 |N .
 UIDS_LIST -> 3 |N .
 @SELF -> A
 B
 UIDS_LIST -> 2 |N .
 UIDS_LIST -> 3 |N .
 @SELF -> B
 
 @SELF __DumpMembers
 
; // NamedAutolinkProducerTest

NamedAutolinkProducerTest
..\..\ScriptEngine\Examples\Other\NamedInitedVarProducer.ms.script
USES
 CodeDump.script
 ;

Тест NamedInitedVarProducerTest
 
/*{VOID : __DefineVarWithInit
  STRING IN aName
  OBJECT IN aStereo
  OBJECT IN aValue
  
  operator ___INIT_VAR
   IN aValue
   IN aVar
   aValue >>>^ aVar
  ; // ___INIT_VAR

  VAR l_NewVar
  aName aStereo __DefineVarEx >>> l_NewVar
  aValue CompileValue l_NewVar CompileRef @ ___INIT_VAR CompileValue
  aValue DO l_NewVar ___INIT_VAR
  // - это может и лишнее, но это чтобы не сломать %DOCUMENTATION и %upv,
  //   который могут ЧИТАТЬСЯ в обход выполнения кода родительского слова
  //   Может быть ПОТОМ это вообще на initialization надо будет переделать
  
; // __DefineVarWithInit
  
IMMEDIATE VOID operator NamedInitedVarProducer
  ^L IN aName
  ^L IN aNewName
 
 @SELF Ctx:SetWordProducerForCompiledClass 
 [
  'IMMEDIATE VOID __operator'
  aName |N
  '^ IN aValue'
  
  aNewName |NS
  
  '@SELF aValue |^@ __DefineVarWithInit'
  ';'
 ] Ctx:Parser:PushArray
; // NamedInitedVarProducer}*/

 NamedInitedVarProducer %DOCUMENTATION %Doc
  
 %DOCUMENTATION 'Hello'
 
 %Doc .
 
 @ %Doc __DumpMembers
 
 (
  %DOCUMENTATION 'Hello world'
  
  %Doc .
  
  @ %Doc __DumpMembers
 )
 
 @SELF DumpElement
 
 @SELF __DumpMembers
 
; // NamedInitedVarProducerTest

NamedInitedVarProducerTest
..\..\ScriptEngine\Examples\Other\NIP.ms.script
2 1 NIP .
..\..\ScriptEngine\Examples\Other\NotEquals.ms.script
3 3 != .
true false != .
'строка1' 'строка2' != .
..\..\ScriptEngine\Examples\Other\NotIs.ms.script
: TestNotIs
 @ 1 Is class::TkwInteger .
 @ 1 Is class::TkwString .
 
 @ 'A' Is class::TkwInteger .
 @ 'A' Is class::TkwString .

 @ 1 Is 'TkwInteger' .
 @ 1 Is 'TkwString' .
 
 @ 'A' Is 'TkwInteger' .
 @ 'A' Is 'TkwString' .
 
 '-----' .
 
 @ 1 NotIs class::TkwInteger .
 @ 1 NotIs class::TkwString .
 
 @ 'A' NotIs class::TkwInteger .
 @ 'A' NotIs class::TkwString .

 @ 1 NotIs 'TkwInteger' .
 @ 1 NotIs 'TkwString' .
 
 @ 'A' NotIs 'TkwInteger' .
 @ 'A' NotIs 'TkwString' .
 
 '-----' .
 
 class::Tl3SimpleObject Is class::Tl3ProtoObject .
 class::Tl3ProtoObject Is class::Tl3SimpleObject .
 
 class::Tl3SimpleObject Is 'Tl3ProtoObject' .
 class::Tl3ProtoObject Is 'Tl3SimpleObject' .
 
 class::Tl3SimpleObject NotIs class::Tl3ProtoObject .
 class::Tl3ProtoObject NotIs class::Tl3SimpleObject .
 
 class::Tl3SimpleObject NotIs 'Tl3ProtoObject' .
 class::Tl3ProtoObject NotIs 'Tl3SimpleObject' .
; 

TestNotIs
..\..\ScriptEngine\Examples\Other\Operator.ms.script
: OperatorTest

 IMMEDIATE operator P
  @ VOID DO
  @ operator DO
 ;
 
 IMMEDIATE operator V
  @ VAR DO
 ;
 
 P A 
  ^ IN aRight
  1 .
  aRight DO .
 ;
 
 INTEGER V X
 X := 0
 
 @ A %ST |N .
 @ A pop:Word:Directives .
 @ A .
 A 2
 
 @ X %ST |N .
 @ X pop:Word:Directives .
 @ X .
 X .
;

OperatorTest
..\..\ScriptEngine\Examples\Other\OperatorByRef.ms.script
Test OperatorByRefTest

  operator X
   ^ IN aRight
   aRight DO
  ; // X

 TRY
  @SELF -> X 2 . 
 EXCEPT
  //'got' Msg
  for script:ExceptionStack .
 END 
   
; // OperatorByRefTest

OperatorByRefTest
..\..\ScriptEngine\Examples\Other\OperatorParent.ms.script
: OperatorParentTest

 operator A1
 ;
 
 @ A1 |N .
 @ A1 pop:object:ClassName .
 @ A1 %P pop:object:ClassName .
 @ A1 %P %P pop:object:ClassName .
 @ A1 %ST |N .
 
;

OperatorParentTest
..\..\ScriptEngine\Examples\Other\OVER.ms.script
2 1 OVER . . .
..\..\ScriptEngine\Examples\Other\ParserTokens.ms.script
USES
 CodeDump.script
;

: ParserTokensTest

 IMMEDIATE 
  operator X
   ^L IN aName
   ^ IN aValue
  STRING VAR l_Name
  aName |N >>> l_Name
  
  'VAR' Ctx:Parser:PushSymbol
  l_Name Ctx:Parser:PushSymbol
  
  aValue
  '[EXECUTE]' Ctx:Parser:PushSymbol
  'CompileValue' Ctx:Parser:PushSymbol
  
  //0 Ctx:Parser:PushInt
  '>>>' Ctx:Parser:PushSymbol
  l_Name Ctx:Parser:PushSymbol
 ;
 
 STRING X A 'A'
 INTEGER X B 1
 X C 'B'
 INTEGER X D 2
 
 A .
 B .
 C .
 D .
 
 @SELF __DumpMembers
 @SELF DumpElement
;

ParserTokensTest
..\..\ScriptEngine\Examples\Other\PICK.ms.script
4 3 2 1 3 PICK . . . . .
..\..\ScriptEngine\Examples\Other\Plus.ms.script
3 5 + .
//true false + .
'строка1' 'строка2' + .
..\..\ScriptEngine\Examples\Other\Plus_store.ms.script
VAR L
5 >>> L
10 +! L
L .
..\..\ScriptEngine\Examples\Other\PrintDictionaries.ms.script
WordAlias Print .

BOOLEAN FUNCTION array:Has 
  IN aValue 
  ARRAY IN anArray
  
 false >>> Result

 anArray ==> ( IN anItem
  if ( anItem = aValue )
   ( 
     true >>> Result
     BREAK-ITERATOR
   )
 )
; // array:Has

STRING FUNCTION ?(+)
 STRING IN aPrefix
 ^ IN aSuffix
 %SUMMARY 'Если aPrefix не пустой, то возвращает сумму aPrefix и aSuffix, иначе возвращает пустую строку' ;
 '' >>> Result
 if ( aPrefix <> '' ) then
  ( aPrefix aSuffix DO Cat >>> Result )
; // ?(+)

STRING FUNCTION IndentStr
 INTEGER IN anIndent
 anIndent ' ' char:Dupe >>> Result
; // IndentStr

WordAlias .Stereotype %ST

ARRAY FUNCTION .Stereotype.Words
  TtfwWord IN Self
 ( Self LIST .Stereotype ) >>> Result
; // .Stereotype.Words

USES
 axiom:Dictionary
;

FORWARD pop:KeyWord:Print

PROCEDURE pop:Dictionary:Print
 INTEGER IN anIndent
 TtfwDictionary IN aDictionary
 
 if ( aDictionary IsNil ) then
  EXIT

 INC anIndent
 TRY
  aDictionary pop:Dictionary:KeyWordsIterator ==> ( 
    TtfwKeyWord IN aKeyWord 
    anIndent aKeyWord pop:KeyWord:Print
  )
 FINALLY
  DEC anIndent
 END  
; // pop:Dictionary:Print

PROCEDURE pop:Word:Print
  INTEGER IN anIndent
  STRING IN aName
  TtfwWord IN aWord 
  
 if ( aWord pop:Word:Name = '%SUM' ) then
 begin
  INTEGER VAR l_SL
  StackLevel >>> l_SL
  aWord DO
  if ( StackLevel > l_SL ) then
  begin
   [ anIndent IndentStr 'Documentation:' ] strings:Cat Print
   while ( StackLevel > l_SL )
   begin
    IN aValue
    [ anIndent 1 + IndentStr aValue ToPrintable ] strings:Cat Print
   end
  end
  EXIT
 end
  
 [ anIndent IndentStr
  [ 
   aWord pop:Word:Directives 
   aWord .Stereotype.Words .reverted> .map> pop:Word:Name ' :: ' strings:CatSep ?(+) ' : '
   aName 
  ] ' ' strings:CatSep 
 ] strings:Cat Print
  
 TtfwWord VAR l_Redefines 
 aWord pop:Word:Redefines >>> l_Redefines
 if ( l_Redefines IsNil ! ) then
 begin
  [ anIndent IndentStr '==> Redefines' ] strings:Cat Print
  TRY
   INC anIndent
   TRY
    anIndent aWord pop:Word:Name l_Redefines @SELF DO
   FINALLY
    DEC anIndent
   END
  FINALLY
   [ anIndent IndentStr '<== Redefines' ] strings:Cat Print
  END
 end
  
 TtfwDictionary VAR l_InnerDictionary
 aWord pop:Word:InnerDictionary >>> l_InnerDictionary
 
 if ( l_InnerDictionary IsNil ) then
  EXIT
  
 anIndent l_InnerDictionary pop:Dictionary:Print
 
 [ anIndent IndentStr '; // ' aName ] strings:Cat Print
; // pop:Word:Print

PROCEDURE pop:KeyWord:Print
  INTEGER IN anIndent
  TtfwKeyWord IN aKeyWord 
 
 TtfwWord VAR l_Word
 aKeyWord pop:KeyWord:Word >>> l_Word
 
 if ( l_Word IsNil ) then
  EXIT
 
 if ( l_Word pop:Word:IsForHelp ! ) then
  EXIT
  
 if ( l_Word Ctx:DisabledForHelp array:Has ) then
  EXIT
  
 anIndent aKeyWord pop:KeyWord:Name l_Word pop:Word:Print  
; // pop:KeyWord:Print

PROCEDURE pop:DictionaryEx:Print
  INTEGER IN anIndent
  TtfwDictionaryEx IN aDictionary
  
 if ( aDictionary IsNil ) then
  EXIT
   
 [ 'Dictionary: ' aDictionary pop:DictionaryEx:FileName ] strings:Cat Print
 
 BOOLEAN VAR l_NeedHeader
 
 true >>> l_NeedHeader
 aDictionary pop:DictionaryEx:UsedDictionaries ==> ( 
   TtfwDictionaryEx IN aDictionary
  if ( l_NeedHeader ) then
  (
   ' Uses: ' Print
   false >>> l_NeedHeader
  )
  [ '  ' aDictionary pop:DictionaryEx:FileName ] strings:Cat Print 
 )
 if ( l_NeedHeader ! ) then
  ( ' ;' Print )
 
 true >>> l_NeedHeader
 aDictionary pop:DictionaryEx:ExportedDictionaries ==> ( 
   TtfwDictionaryEx IN aDictionary
  if ( l_NeedHeader ) then
  (
   ' Exports: ' Print
   false >>> l_NeedHeader
  )
  [ '  ' aDictionary pop:DictionaryEx:FileName ] strings:Cat Print 
 )
 if ( l_NeedHeader ! ) then
  ( ' ;' Print )
 
 aDictionary pop:Dictionary:KeyWordsIterator ==> ( 
   TtfwKeyWord IN aKeyWord 
  if ( aKeyWord pop:KeyWord:Dictionary = aDictionary ) then 
   ( anIndent aKeyWord pop:KeyWord:Print )
 )
 
; // pop:DictionaryEx:Print

USES
 axiom:MainDictionary
;

PROCEDURE Ctx:PrintDictionaries

 ARRAY VAR l_InitedDictionaries
 Ctx:InitedDictionaries >>> l_InitedDictionaries
 
 Ctx:StandardDictionaries 
  .filter> ( l_InitedDictionaries array:Has ! ) 
   ==> ( TtfwDictionaryEx IN anItem 0 anItem pop:DictionaryEx:Print )
 l_InitedDictionaries ==> ( TtfwDictionaryEx IN anItem 0 anItem pop:DictionaryEx:Print )
 
 TtfwWord VAR l_CompiledCode
 
 Ctx:MainDictionary pop:MainDictionary:CompiledCode >>> l_CompiledCode
 if ( l_CompiledCode IsNil ! ) then
  ( 0 'Main' l_CompiledCode pop:Word:Print )
 
; // Ctx:PrintDictionaries

WordAlias help Ctx:PrintDictionaries

//Ctx:PrintDictionaries

help
..\..\ScriptEngine\Examples\Other\PrintDictionaries1.ms.script
WordAlias Print DROP

BOOLEAN FUNCTION array:Has 
  IN aValue 
  ARRAY IN anArray
  
 false >>> Result

 anArray ==> ( IN anItem
  if ( anItem = aValue )
   ( 
     true >>> Result
     BREAK-ITERATOR
   )
 )
; // array:Has

STRING FUNCTION ?(+)
 STRING IN aPrefix
 ^ IN aSuffix
 %SUMMARY 'Если aPrefix не пустой, то возвращает сумму aPrefix и aSuffix, иначе возвращает пустую строку' ;
 '' >>> Result
 if ( aPrefix <> '' ) then
  ( aPrefix aSuffix DO Cat >>> Result )
; // ?(+)

STRING FUNCTION IndentStr
 INTEGER IN anIndent
 anIndent ' ' char:Dupe >>> Result
; // IndentStr

WordAlias .Stereotype %ST

ARRAY FUNCTION .Stereotype.Words
  /*TtfwWord*/ IN Self
 ( Self LIST .Stereotype ) >>> Result
; // .Stereotype.Words

USES
 axiom:Dictionary
;

FORWARD pop:KeyWord:Print

PROCEDURE pop:Dictionary:Print
 INTEGER IN anIndent
 /*TtfwDictionary*/ IN aDictionary
 
 if ( aDictionary IsNil ) then
  EXIT

 aDictionary pop:Dictionary:KeyWordsIterator ==> ( 
   /*TtfwKeyWord*/ IN aKeyWord 
   anIndent 1 + aKeyWord pop:KeyWord:Print
 )
; // pop:Dictionary:Print

PROCEDURE pop:Word:Print
  INTEGER IN anIndent
  STRING IN aName
  /*TtfwWord*/ IN aWord 
  
 if ( aWord pop:Word:Name = '%SUM' ) then
 begin
  INTEGER VAR l_SL
  StackLevel >>> l_SL
  aWord DO
  if ( StackLevel > l_SL ) then
  begin
   [ anIndent IndentStr 'Documentation:' ] strings:Cat Print
   while ( StackLevel > l_SL )
   begin
    IN aValue
    [ anIndent 1 + IndentStr aValue ToPrintable ] strings:Cat Print
   end
  end
  EXIT
 end
  
 [ anIndent IndentStr
  [ 
   aWord pop:Word:Directives 
   aWord .Stereotype.Words .reverted> .map> pop:Word:Name ' :: ' strings:CatSep ?(+) ' : '
   aName 
  ] ' ' strings:CatSep 
 ] strings:Cat Print
  
 TtfwWord VAR l_Redefines 
 aWord pop:Word:Redefines >>> l_Redefines
 if ( l_Redefines IsNil ! ) then
 begin
  [ anIndent IndentStr '==> Redefines' ] strings:Cat Print
  TRY
   anIndent 1 + aWord pop:Word:Name l_Redefines @SELF DO
  FINALLY
   [ anIndent IndentStr '<== Redefines' ] strings:Cat Print
  END
 end
  
 TtfwDictionary VAR l_InnerDictionary
 aWord pop:Word:InnerDictionary >>> l_InnerDictionary
 
 if ( l_InnerDictionary IsNil ) then
  EXIT
  
 anIndent l_InnerDictionary pop:Dictionary:Print
 
 [ anIndent IndentStr '; // ' aName ] strings:Cat Print
; // pop:Word:Print

PROCEDURE pop:KeyWord:Print
  INTEGER IN anIndent
  /*TtfwKeyWord*/ IN aKeyWord 
 
 TtfwWord VAR l_Word
 aKeyWord pop:KeyWord:Word >>> l_Word
 
 if ( l_Word IsNil ) then
  EXIT
 
 if ( l_Word pop:Word:IsForHelp ! ) then
  EXIT
  
 if ( l_Word Ctx:DisabledForHelp array:Has ) then
  EXIT
  
 anIndent aKeyWord pop:KeyWord:Name l_Word pop:Word:Print  
; // pop:KeyWord:Print

PROCEDURE pop:DictionaryEx:Print
  INTEGER IN anIndent
  /*TtfwDictionaryEx*/ IN aDictionary
  
 if ( aDictionary IsNil ) then
  EXIT
   
 [ 'Dictionary: ' aDictionary pop:DictionaryEx:FileName ] strings:Cat Print
 
 BOOLEAN VAR l_NeedHeader
 
 true >>> l_NeedHeader
 aDictionary pop:DictionaryEx:UsedDictionaries ==> ( 
   /*TtfwDictionaryEx*/ IN aDictionary
  if ( l_NeedHeader ) then
  (
   ' Uses: ' Print
   false >>> l_NeedHeader
  )
  [ '  ' aDictionary pop:DictionaryEx:FileName ] strings:Cat Print 
 )
 if ( l_NeedHeader ! ) then
  ( ' ;' Print )
 
 true >>> l_NeedHeader
 aDictionary pop:DictionaryEx:ExportedDictionaries ==> ( 
   /*TtfwDictionaryEx*/ IN aDictionary
  if ( l_NeedHeader ) then
  (
   ' Exports: ' Print
   false >>> l_NeedHeader
  )
  [ '  ' aDictionary pop:DictionaryEx:FileName ] strings:Cat Print 
 )
 if ( l_NeedHeader ! ) then
  ( ' ;' Print )
 
 aDictionary pop:Dictionary:KeyWordsIterator ==> ( 
   /*TtfwKeyWord*/ IN aKeyWord 
  if ( aKeyWord pop:KeyWord:Dictionary = aDictionary ) then 
   ( anIndent aKeyWord pop:KeyWord:Print )
 )
 
; // pop:DictionaryEx:Print

USES
 axiom:MainDictionary
;

PROCEDURE Ctx:PrintDictionaries

 ARRAY VAR l_InitedDictionaries
 Ctx:InitedDictionaries >>> l_InitedDictionaries
 
 Ctx:StandardDictionaries 
  .filter> ( l_InitedDictionaries array:Has ! ) 
   ==> ( /*TtfwDictionaryEx*/ IN anItem 0 anItem pop:DictionaryEx:Print )
 l_InitedDictionaries ==> ( /*TtfwDictionaryEx*/ IN anItem 0 anItem pop:DictionaryEx:Print )
 
 TtfwWord VAR l_CompiledCode
 
 Ctx:MainDictionary pop:MainDictionary:CompiledCode >>> l_CompiledCode
 if ( l_CompiledCode IsNil ! ) then
  ( 0 'Main' l_CompiledCode pop:Word:Print )
 
; // Ctx:PrintDictionaries

WordAlias help Ctx:PrintDictionaries

//Ctx:PrintDictionaries

help
..\..\ScriptEngine\Examples\Other\Procedure.ms.script
USES
 CodeDump.script
 ;

Тест ProcedureTest

/*{ IMMEDIATE operator PROCEDURE
  @SELF Ctx:SetWordProducerForCompiledClass
  [
   'VOID __operator' 
  ] Ctx:Parser:PushArray
 ; // PROCEDURE}*/
 
 PROCEDURE A
  1 .
 ; // A
 
 PROCEDURE B
  '2' .
 ; // B

 PROCEDURE C
  '3'
 ; // C
 
 A
 B
 TRY
  C
 EXCEPT
  for script:ExceptionStack .
 END 
 
 @SELF DumpElement
 @SELF __DumpMembers
; // ProcedureTest

ProcedureTest
..\..\ScriptEngine\Examples\Other\Procedure1.ms.script
USES
 CodeDump.script
 ;

Тест ProcedureTest

 PROCEDURE "Поиск текста"
  1 .
 ; // "Поиск текста"
 
 "Поиск текста"
 
 @SELF DumpElement
; // ProcedureTest

ProcedureTest
..\..\ScriptEngine\Examples\Other\Recurse.ms.script
USES
 CodeDump.script
;

IMMEDIATE VOID operator Rec
 ^L IN aName
 'FORWARD' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 
 'PROCEDURE' Ctx:Parser:PushSymbol
 //'VOID' Ctx:Parser:PushSymbol
 //'operator' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 //Ctx:ClearTypeInfo
; // Rec

Test RecurseTest

 Rec X
  INTEGER IN aValue
  if ( aValue <> 0 ) then
   ( aValue . aValue -- X )
 ; // X
 
 10 X
 
 @SELF DumpElement
; // RecurseTest

RecurseTest
..\..\ScriptEngine\Examples\Other\Redefinition.ms.script
USES
 CodeDump.script
;

Test RedefinitionTest

/*{IMMEDIATE VOID operator INHERITED
 OBJECT VAR l_Redef
 Ctx:WordDefiningNow pop:Word:Redefines >>> l_Redef
 l_Redef pop:object:IsNil ! ?ASSURE 'Не найдено переопределяемое слово'
 l_Redef CompileValue
; // INHERITED}*/

 : A
  1 .
 ; // A
 
 REDEFINITION
 : A
  INHERITED
  ( INHERITED )
  2 .
 ; // A 
 
 A

 @SELF DumpElement
 @SELF __DumpMembers
 
; // RedefinitionTest

RedefinitionTest
..\..\ScriptEngine\Examples\Other\ROLL.ms.script
4 3 2 1 2 ROLL . . . .
..\..\ScriptEngine\Examples\Other\ROT.ms.script
3 2 1 ROT . . .
..\..\ScriptEngine\Examples\Other\ROT_.ms.script
3 2 1 -ROT . . .
..\..\ScriptEngine\Examples\Other\SameStr.ms.script
'a' 'a' SameStr .
'a' 'b' SameStr .
'b' 'a' SameStr .

'A' 'a' SameStr .
'A' 'b' SameStr .
'B' 'a' SameStr .
..\..\ScriptEngine\Examples\Other\SameText.ms.script
'a' 'a' SameText .
'a' 'b' SameText .
'b' 'a' SameText .

'A' 'a' SameText .
'A' 'b' SameText .
'B' 'a' SameText .
..\..\ScriptEngine\Examples\Other\Slice.ms.script
2 [ 1 2 3 4 5 6 7 8 9 10 ] SLICE ==> ( . . '--' . )
2 [ 1 2 3 4 5 6 7 8 9 10 ] SLICE .
3 [ 1 2 3 4 5 6 7 8 9 10 11 12 ] SLICE ==> ( . . . '--' . )
3 [ 1 2 3 4 5 6 7 8 9 10 11 12 ] SLICE .
'------' .

2 [ 1 2 3 4 5 6 7 8 9 10 ] SLICE Reverted ==> ( . . '--' . )
2 [ 1 2 3 4 5 6 7 8 9 10 ] SLICE Reverted .
3 [ 1 2 3 4 5 6 7 8 9 10 11 12 ] SLICE Reverted ==> ( . . . '--' . )
3 [ 1 2 3 4 5 6 7 8 9 10 11 12 ] SLICE Reverted .
'------' .

[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 ==> ( . . '--' . )
[ 1 2 3 4 5 6 7 8 9 10 11 12 ] .slice> 3 ==> ( . . . '--' . )
'------' .

[ 1 2 3 4 5 6 7 8 9 10 ] .slice> 2 Reverted ==> ( . . '--' . )
[ 1 2 3 4 5 6 7 8 9 10 11 12 ] .slice> 3 Reverted ==> ( . . . '--' . )
'------' .

[ 1 2 3 4 5 6 7 8 9 10 ] >slice> 2 ==> ( . . '--' . )
[ 1 2 3 4 5 6 7 8 9 10 11 12 ] >slice> 3 ==> ( . . . '--' . )
'------' .

[ 1 2 3 4 5 6 7 8 9 10 ] >slice> 2 Reverted ==> ( . . '--' . )
[ 1 2 3 4 5 6 7 8 9 10 11 12 ] >slice> 3 Reverted ==> ( . . . '--' . )
'------' .
..\..\ScriptEngine\Examples\Other\Slice1.ms.script
2 [ 1 '2' 3 4 5 6 7 8 9 10 ] SLICE ==> ( . . '--' . )
3 [ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] SLICE ==> ( . . . '--' . )
'------' .

2 [ 1 '2' 3 4 5 6 7 8 9 10 ] SLICE Reverted ==> ( . . '--' . )
3 [ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] SLICE Reverted ==> ( . . . '--' . )
'------' .

[ 1 '2' 3 4 5 6 7 8 9 10 ] .slice> 2 ==> ( . . '--' . )
[ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] .slice> 3 ==> ( . . . '--' . )
'------' .

[ 1 '2' 3 4 5 6 7 8 9 10 ] .slice> 2 Reverted ==> ( . . '--' . )
[ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] .slice> 3 Reverted ==> ( . . . '--' . )
'------' .

[ 1 '2' 3 4 5 6 7 8 9 10 ] >slice> 2 ==> ( . . '--' . )
[ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] >slice> 3 ==> ( . . . '--' . )
'------' .

[ 1 '2' 3 4 5 6 7 8 9 10 ] >slice> 2 Reverted ==> ( . . '--' . )
[ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] >slice> 3 Reverted ==> ( . . . '--' . )
'------' .
..\..\ScriptEngine\Examples\Other\Slice2.ms.script
2 [ 1 '2' 3 4 5 6 7 8 9 10 ] SLICE ==> ( IN A IN B A . B . '--' . )
3 [ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] SLICE ==> ( . . . '--' . )
'------' .

2 [ 1 '2' 3 4 5 6 7 8 9 10 ] SLICE Reverted ==> ( . . '--' . )
3 [ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] SLICE Reverted ==> ( . . . '--' . )
'------' .

[ 1 '2' 3 4 5 6 7 8 9 10 ] .slice> 2 ==> ( . . '--' . )
[ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] .slice> 3 ==> ( . . . '--' . )
'------' .

[ 1 '2' 3 4 5 6 7 8 9 10 ] .slice> 2 Reverted ==> ( . . '--' . )
[ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] .slice> 3 Reverted ==> ( . . . '--' . )
'------' .

[ 1 '2' 3 4 5 6 7 8 9 10 ] >slice> 2 ==> ( . . '--' . )
[ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] >slice> 3 ==> ( . . . '--' . )
'------' .

[ 1 '2' 3 4 5 6 7 8 9 10 ] >slice> 2 Reverted ==> ( . . '--' . )
[ 1 '2' 3 4 5 6 7 8 9 10 11 12 ] >slice> 3 Reverted ==> ( . . . '--' . )
'------' .
..\..\ScriptEngine\Examples\Other\SourcePoint.ms.script
USES
 CodeDump.script
 ;

Тест TestSourcePoint

 : A
  @SELF pop:Word:SourcePointString .
 ;
 
 A
 
 @SELF pop:Word:SourcePointString .
 @SELF DumpElement
 
; // TestSourcePoint

TestSourcePoint
..\..\ScriptEngine\Examples\Other\SplitToArray.ms.script
: SplitToArrayTest  
 'A BC' ' ' SplitToArray ==> . 
 'A B C D' ' ' SplitToArray ==> .
 'ABC' ' ' SplitToArray ==> .
 '' ' ' SplitToArray ==> .
;

SplitToArrayTest
..\..\ScriptEngine\Examples\Other\StackChecking1.ms.script
PROCEDURE StackChecking1
 1
; // StackChecking1

анти-тест StackChecking1
..\..\ScriptEngine\Examples\Other\StackChecking2.ms.script
PROCEDURE StackChecking2 INTEGER IN aParam
 2
;

анти-тест ( 1 StackChecking2 )
..\..\ScriptEngine\Examples\Other\StackChecking3.ms.script
PROCEDURE StackChecking3 INTEGER IN aParam
 DROP // - снимаем лишний параметр со стека
;

анти-тест ( 3 1 StackChecking3 )
..\..\ScriptEngine\Examples\Other\StackChecking4.ms.script
PROCEDURE StackChecking4
 DROP // - снимаем лишний параметр со стека
;

анти-тест ( 3 StackChecking4 )
..\..\ScriptEngine\Examples\Other\StartsStr.ms.script
'a' 'abc' StartsStr .
'b' 'abc' StartsStr .

'A' 'abc' StartsStr .
'B' 'abc' StartsStr .
..\..\ScriptEngine\Examples\Other\StartsText.ms.script
'a' 'abc' StartsText .
'b' 'abc' StartsText .

'A' 'abc' StartsText .
'B' 'abc' StartsText .
..\..\ScriptEngine\Examples\Other\StereotypeProducer.ms.script
USES
 CodeDump.script
 ;

Тест StereotypeProducerTest

/*{STRING FUNCTION __CheckSpaces
 STRING IN aName
 aName ' ' '%#32' string:Replace >>> Result
; // __CheckSpaces

STRING FUNCTION Add<<>>
 STRING IN aName
 [ '<<' aName '>>' ] strings:Cat >>> Result
 Result __CheckSpaces >>> Result
; // Add<<>>

VOID operator DefineStereo
 IN aName
 IN aSelf
 
 aSelf
 Ctx:SetWordProducerForCompiledClass
 
 [
  'IMMEDIATE OPERATOR' aName Add<<>>
  '^L IN aName'
 
  'aName |N @SELF DefineStereoInstance'
 
  'EXIT'
 ] Ctx:Parser:PushArray
; // DefineStereo
 
VOID operator DefineStereoInstance
 IN aName
 IN aSelf
 
 aSelf
 Ctx:SetWordProducerForCompiledClass
 
 [
  'OPERATOR' aName __CheckSpaces
 ] Ctx:Parser:PushArray
; // DefineStereoInstance

IMMEDIATE operator StereotypeProducer
  ^L IN aName
  
 @SELF Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE OPERATOR' aName |N Add<<>>
  '^L IN aName'
  'aName |N @SELF DefineStereo'
  
  'EXIT'
 ] Ctx:Parser:PushArray
; // StereotypeProducer}*/

/*{ StereotypeStereotypeProducer StereotypeProducer ;
 WordAlias StereotypeProducer <<StereotypeProducer>>}*/

 StereotypeProducer MDAClass ;
 StereotypeProducer MDACategory ;
 
 <<MDAClass>> "X X"
 ;
 
 <<MDAClass>> SimpleClass
  'Hello' .
 ;
 
 <<MDAClass>> Facet
 ;
 
 <<SimpleClass>> A
  : X
  ;
 ;
 
 <<SimpleClass>> B
 ;
 
 <<SimpleClass>> "Y Y"
 ;
 
 <<Facet>> C
 ;
 
 @SELF DumpElement
 @SELF __DumpMembers
; // StereotypeProducerTest

StereotypeProducerTest
..\..\ScriptEngine\Examples\Other\StereotypeStereotypeProducer.ms.script
USES
 CodeDump.script
 ;

Тест StereotypeProducerTest

/*{VOID operator DefineStereo
 IN aName
 IN aSelf
 
 aSelf
 Ctx:SetWordProducerForCompiledClass
 
 [
  'IMMEDIATE OPERATOR' aName Add<<>>
  '^L IN aName'
 
  'aName |N @SELF DefineStereoInstance'
 
  'EXIT'
 ] Ctx:Parser:PushArray
; // DefineStereo
 
VOID operator DefineStereoInstance
 IN aName
 IN aSelf
 
 aSelf
 Ctx:SetWordProducerForCompiledClass
 
 [
  'OPERATOR' aName __CheckSpaces
 ] Ctx:Parser:PushArray
; // DefineStereoInstance

IMMEDIATE operator StereotypeProducer
  ^L IN aName
  
 @SELF Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE OPERATOR' aName |N Add<<>>
  '^L IN aName'
  'aName |N @SELF DefineStereo'
  
  'EXIT'
 ] Ctx:Parser:PushArray
; // StereotypeProducer

VOID operator DefineStereotypeProducer
 IN aName
 IN aSelf
 
 aSelf
 Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE OPERATOR' aName Add<<>>
  '^L IN aName'
  'aName |N @SELF DefineStereo'
  
  'EXIT'
 ] Ctx:Parser:PushArray
; // DefineStereotypeProducer

IMMEDIATE operator StereotypeStereotypeProducer
  ^L IN aName
 @SELF Ctx:SetWordProducerForCompiledClass 
 [
  'IMMEDIATE operator' aName |N Add<<>>
  '^L IN aName'
  
  'aName |N @SELF DefineStereotypeProducer'
  
  'EXIT'
 ] Ctx:Parser:PushArray
; // StereotypeStereotypeProducer}*/

StereotypeStereotypeProducer MDAClass ;
// - базовый стереотип, через который всё выводится

<<@MDAClass>> MDAClass ;
<<@MDAClass>> MDACategory ;

//StereotypeProducer MDAClass ;
//StereotypeProducer MDACategory ;
// - заглушки для начальной раскрутки

 <<MDAClass>> SimpleClass
  'Hello' .
 ;
 
 <<MDAClass>> Facet
 ;
 
 <<SimpleClass>> A
  : X
  ;
 ;
 
 <<SimpleClass>> B
 ;
 
 <<Facet>> C
 ;
 
 @SELF DumpElement
 @SELF __DumpMembers
; // StereotypeProducerTest

StereotypeProducerTest
..\..\ScriptEngine\Examples\Other\StereotypeStereotypeProducerEx.ms.script
USES
 CodeDump.script
 ;

Тест StereotypeProducerTest

/*{VOID operator DefineStereo
 IN aName
 IN aSelf
 
 aSelf
 Ctx:SetWordProducerForCompiledClass
 
 [
  'IMMEDIATE OPERATOR' aName Add<<>>
  '^L IN aName'
 
  'aName |N @SELF DefineStereoInstance'
 
  'EXIT'
 ] Ctx:Parser:PushArray
; // DefineStereo
 
VOID operator DefineStereoInstance
 IN aName
 IN aSelf
 
 aSelf
 Ctx:SetWordProducerForCompiledClass
 
 [
  'OPERATOR' aName __CheckSpaces
 ] Ctx:Parser:PushArray
; // DefineStereoInstance

IMMEDIATE operator StereotypeProducer
  ^L IN aName
  
 @SELF Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE OPERATOR' aName |N Add<<>>
  '^L IN aName'
  'aName |N @SELF DefineStereo'
  
  'EXIT'
 ] Ctx:Parser:PushArray
; // StereotypeProducer

VOID operator DefineStereotypeProducer
 IN aName
 IN aSelf
 
 aSelf
 Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE OPERATOR' aName Add<<>>
  '^L IN aName'
  'aName |N @SELF DefineStereo'
  
  'EXIT'
 ] Ctx:Parser:PushArray
; // DefineStereotypeProducer

IMMEDIATE operator StereotypeStereotypeProducer
  ^L IN aName
 @SELF Ctx:SetWordProducerForCompiledClass 
 [
  'IMMEDIATE operator' aName |N Add<<>>
  '^L IN aName'
  
  'aName |N @SELF DefineStereotypeProducer'
  
  'EXIT'
 ] Ctx:Parser:PushArray
; // StereotypeStereotypeProducer}*/

StereotypeStereotypeProducer MDAClass ;
// - базовый стереотип, через который всё выводится

<<@MDAClass>> MDAClass ;

 <<MDAClass>> SimpleClass
  'Hello' .
 ;
 
 <<SimpleClass>> A
 ;
 
 @SELF DumpElement
 @SELF __DumpMembers
; // StereotypeProducerTest

StereotypeProducerTest
..\..\ScriptEngine\Examples\Other\StringVarDecLen.ms.script
STRING VAR S
S := 'abcd'
S .

string:--Len! S
S .
..\..\ScriptEngine\Examples\Other\StringVarInc.ms.script
STRING VAR S
S := 'abcd'
S .

string:++! S
S .
..\..\ScriptEngine\Examples\Other\StringVarRSplitTo.ms.script
STRING VAR S
S := '123|abc|def'

'|' string:RSplitTo! S
S .
.
..\..\ScriptEngine\Examples\Other\StringVarShift.ms.script
STRING VAR S
S := 'abcd'
S .

2 string:+! S
S .
..\..\ScriptEngine\Examples\Other\StringVarSplitTo.ms.script
STRING VAR S
S := '123|abc|def'

'|' string:SplitTo! S
S .
.

S := '123||abc||def'

'||' string:SplitTo! S
S .
.

..\..\ScriptEngine\Examples\Other\string_Char.ms.script
1 'abcd' string:[i] .
..\..\ScriptEngine\Examples\Other\string_CodePage.ms.script
'abcd' string:CodePage .
..\..\ScriptEngine\Examples\Other\string_ConsistsOf.ms.script
'ab' 'abab' string:ConsistsOf .
'ab' 'abac' string:ConsistsOf .

'ab' '' string:ConsistsOf .
'ab' 'd' string:ConsistsOf .

'' '' string:ConsistsOf .
'' 'a' string:ConsistsOf .

'a' '' string:ConsistsOf .

'abd' 'abab' string:ConsistsOf .
'abd' 'abac' string:ConsistsOf .
..\..\ScriptEngine\Examples\Other\string_HasAnyOf.ms.script
'ab' 'abab' string:HasAnyOf .
'ab' 'abac' string:HasAnyOf .

'ab' '' string:HasAnyOf .
'ab' 'd' string:HasAnyOf .

'' '' string:HasAnyOf .
'' 'a' string:HasAnyOf .

'a' '' string:HasAnyOf .

'abd' 'abab' string:HasAnyOf .
'abd' 'abac' string:HasAnyOf .
..\..\ScriptEngine\Examples\Other\string_Len.ms.script
'abcd' string:Len .
'' string:Len .
..\..\ScriptEngine\Examples\Other\string_Pos.ms.script
'мама рыла яму' 'ры' string:Pos .
..\..\ScriptEngine\Examples\Other\string_PosEx.ms.script
6 'мама рыла рыло' 'ры' string:PosEx .
..\..\ScriptEngine\Examples\Other\string_Replace.ms.script
'abababab' 'b' 'c' string:Replace .
'abababab' 'd' 'c' string:Replace .

'Федеральный закон от 08.03.15 №'#8201'42-ФЗ' #9 #32 string:Replace .

'abababab' 'b' 'bc' string:Replace .
'abababab' 'b' 'cb' string:Replace .
..\..\ScriptEngine\Examples\Other\string_ReplaceFirst.ms.script
'abababab' 'b' 'c' string:ReplaceFirst .
'abababab' 'd' 'c' string:ReplaceFirst .
..\..\ScriptEngine\Examples\Other\string_Split.ms.script
'ABC:DEF' ':' string:Split

WHILE ( StackLevel > 0 ) .

'ABC:DEF' 'D' string:Split

WHILE ( StackLevel > 0 ) .

'ABABABA' 'B' string:Split

WHILE ( StackLevel > 0 ) .
..\..\ScriptEngine\Examples\Other\string_ToChar.ms.script
'a' string:ToChar .
'A' string:ToChar .
..\..\ScriptEngine\Examples\Other\StrToInt.ms.script
'5' StrToInt .
'-6' StrToInt .

'0' StrToInt .

'$A' StrToInt .
'$10' StrToInt .

"Выполнить подавив исключение" ( 'a' StrToInt )

"Выполнить подавив исключение" ( 10 StrToInt )
..\..\ScriptEngine\Examples\Other\Test.ms.script
USES
 CodeDump.script
 ;

Тест TestTest

/*{IMMEDIATE operator Test
 @SELF Ctx:SetWordProducerForCompiledClass
 'VOID' Ctx:Parser:PushSymbol
 '__operator' Ctx:Parser:PushSymbol
; // Test}*/

 Test A
 ; // A

 @SELF DumpElement
 @SELF __DumpMembers
; // TestTest

TestTest
..\..\ScriptEngine\Examples\Other\text_Replace.ms.script
'abababab' 'b' 'c' text:Replace .
'abababab' 'd' 'c' text:Replace .

'abababab' 'B' 'c' text:Replace .
'abababab' 'D' 'c' text:Replace .

'aBababab' 'b' 'c' text:Replace .

'aBababab' 'B' 'c' text:Replace .
..\..\ScriptEngine\Examples\Other\text_ReplaceFirst.ms.script
'abababab' 'b' 'c' text:ReplaceFirst .
'abababab' 'd' 'c' text:ReplaceFirst .

'abababab' 'B' 'c' text:ReplaceFirst .
'abababab' 'D' 'c' text:ReplaceFirst .

'aBababab' 'b' 'c' text:ReplaceFirst .

'aBababab' 'B' 'c' text:ReplaceFirst .
..\..\ScriptEngine\Examples\Other\this.ms.script
Test thisDoTest

VOID IMMEDIATE OPERATOR this.do
 '(' Ctx:Parser:PushSymbol
 '@SELF' Ctx:Parser:PushSymbol
 'DO' Ctx:Parser:PushSymbol
 ')' Ctx:Parser:PushSymbol
; // this.do 

 operator A
  ^ IN aRight
 ; // A
 
 operator B
  A this.do
 ; // B 

; // thisDoTest

thisDoTest
..\..\ScriptEngine\Examples\Other\TK271754328.ms.script
USES
 axiom:Control
 EditorTools.script 
;

: K271754328
 TTextLoadForm VAR l_TextForm
 class::TTextLoadForm .Create >>> l_TextForm
 TRY
  l_TextForm pop:Control:Show
  OBJECT VAR l_Editor
  focused:control:push >>> l_Editor
  "Загрузить документ в {(l_TextForm)}"  
  l_Editor pop:editor:SelectTable
  l_Editor pop:editor:CopyAndPaste2DocumentBottom
  "Сравнить текст с эталоном"
 FINALLY  
  l_TextForm AskWindowToCloseItself
 END
;

K271754328
..\..\ScriptEngine\Examples\Other\TK290951357.ms.script
USES
 axiom:Control
 EditorTools.script 
;

: K290951357
 TF1LikeTextLoadForm VAR l_TextForm
 class::TF1LikeTextLoadForm .Create >>> l_TextForm
 TRY 
  INTEGER VAR l_FontSize
  GetFontSize >>> l_FontSize 
  TRY 
	cnDefaultFontSize SetFontSize
        l_TextForm pop:Control:Width := 1024
        l_TextForm pop:Control:Height := 500
        l_TextForm pop:Control:Show
    OBJECT VAR l_Editor
	focused:control:push >>> l_Editor
	"Загрузить документ в {(l_TextForm)}"   
    12 LOOP ( l_Editor pop:Editor:ScrollLineDown )
	 ProcessMessages
	 2 2 l_Editor pop:editor:SelectCellByMouse
	 ProcessMessages
   FINALLY
    l_FontSize SetFontSize
   END
  FINALLY  
   l_TextForm AskWindowToCloseItself
  END  
;

K290951357
..\..\ScriptEngine\Examples\Other\TreatUnknownAsString.ms.script
: TreatUnknownAsStringTest

/*{ IMMEDIATE operator ^L
  TtfwWordModifier::tfw_wmRightWordRef Ctx:IncludeModifier
  TtfwWordModifier::tfw_wmTreatUnknownAsString Ctx:IncludeModifier
 ;}*/
 
 operator X 
  ^L IN aRight
  aRight |N .
 ;
 
 @ X __DumpMembers
 
 VAR Y
 
 X '123'
 X Y 
 X 123
 X A

;

TreatUnknownAsStringTest
..\..\ScriptEngine\Examples\Other\Trunc.ms.script
@ ( 6 != ) [ 1 2 3 4 5 6 7 8 9 10 ] TRUNC ==> .
@ ( 6 != ) [ 1 2 3 4 5 6 7 8 9 10 ] TRUNC .

'-------' .
[ 1 2 3 4 5 6 7 8 9 10 ] .trunc> ( 6 != ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] .trunc> ( 6 != ) .
'-------' .
[ 1 2 3 4 5 6 7 8 9 10 ] >trunc> ( 6 != ) ==> .
[ 1 2 3 4 5 6 7 8 9 10 ] >trunc> ( 6 != ) .
'-------' .
..\..\ScriptEngine\Examples\Other\TUCK.ms.script
2 1 TUCK . . .
..\..\ScriptEngine\Examples\Other\Type.ms.script
USES
 axiom:ValueTypes
 CodeDump.script
 ;

Тест TypeTest

 VOID IMMEDIATE OPERATOR __CompileType
  TtfwValueTypes IN aValues
  aValues CompileValue @ Ctx:SetValueTypes CompileValue
 ; // __CompileType
 
 IMMEDIATE OPERATOR TYPE
  ^L IN aName
  aName |N
  Ctx:ValueTypes
  pop:ValueTypes:MakeCustomName
  Ctx:ClearTypeInfo
  @SELF Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE VOID axiom:operator'
  aName |N
  '__CompileType'
  ';'
 ] Ctx:Parser:PushArray
 ; // TYPE
 
 INTEGER TYPE X
 STRING INTEGER TYPE Y
 
 X VAR A
 Y VAR B
 
 A := 1
 B := 2
 A .
 B .
 B := 'xxx'
 B .
 
 @SELF DumpElement
 @SELF __DumpMembers
; // TypeTest

TypeTest
..\..\ScriptEngine\Examples\Other\var.ms.script
/*{: __SourceInfo
 Ctx:Parser pop:Parser:FileName ' ' Cat Ctx:Parser pop:Parser:SourceLine IntToStr Cat ' ' Cat
; // __SourceInfo

: __DefineVarEx
  STRING IN aName
  OBJECT IN aStereo
 
 aName Ctx:NewWordDefinitor pop:NewWordDefinitor:CheckWord pop:KeyWord:Word pop:object:IsNil ! ?
 (
  __SourceInfo 'Слово ' Cat aName Cat ' уже существует. Нельзя определить переменную с таким же именем' Cat RAISE
 ) 
 aName true Ctx:NewWordDefinitor pop:NewWordDefinitor:CheckVar
 DUP aStereo SWAP pop:Word:SetProducer
 Ctx:ClearTypeInfo
; // __DefineVarEx

: __DefineVar
 __DefineVarEx DROP
; // __DefineVar

IMMEDIATE VOID OPERATOR VAR
 ^L IN aName
 aName |N @SELF __DefineVar
; // VAR}*/

VAR A
//VAR A
2 >>> A
A .
..\..\ScriptEngine\Examples\Other\VarName.ms.script
VAR XXX
@ XXX pop:Word:Name .
..\..\ScriptEngine\Examples\Other\VarProducer.ms.script
USES
 CodeDump.script
 ;

Тест TestVarProducer

/*{IMMEDIATE operator VarProducer
  ^L IN aName
 STRING VAR l_Name
 aName |N >>> l_Name

 [
  'IMMEDIATE OPERATOR'
  l_Name
  '^L IN aName'
  'aName |N true Ctx:NewWordDefinitor pop:NewWordDefinitor:CheckVar'
  '@SELF SWAP pop:Word:SetProducer'
  'Ctx:ClearTypeInfo'
  ';'
 ] Ctx:Parser:PushArray
; // VarProducer}*/

/*{ IMMEDIATE OPERATOR VarType
  ^L IN aName
  aName |N true Ctx:NewWordDefinitor pop:NewWordDefinitor:CheckVar
  @SELF SWAP pop:Word:SetProducer
  Ctx:ClearTypeInfo
 ; // VarType}*/
 
 VarProducer VarType
  
 STRING VarType A
 'Hello' =: A
 
 INTEGER VarType B
 23 =: B
 
 A .
 B .
 
 @ A __DumpMembers
 
 @ B __DumpMembers

 @SELF DumpElement
 @SELF __DumpMembers
;

TestVarProducer
..\..\ScriptEngine\Examples\Other\With.ms.script
: WithTest

/*{ IMMEDIATE operator WordAliasByRef
  ^L IN aName
  ^ IN aCode
  aCode DO aName |N Define
 ; // WordAliasByRef}*/

 : A
  : B
   : C
    'Hello' .
    VAR Y
   ; // C
   20 .
   VAR Z
  ; // B
  10 .
  VAR X
 ; // A

 A :: X := 10
 A :: X .
 A :: B
 //A :: B := 10
 A :: B :: C
 A :: B :: C :: Y := 1024
 A :: B :: C :: Y .
 
 A :: B :: Z := 2048
 A :: B :: Z .
 A :: B :: Z .
 
 "Выполнить подавив исключение" ( A :: B :: Z :: abs )
 TRY
  A :: B :: Z :: abs
 EXCEPT
  for script:ExceptionStack .
 END 
 
 A :: B
 A :: B :: C
 
 A :: B |^@ DO
 A :: B :: C |^@ DO
 
 A :: B :: Z .
 A :: B :: Z |^@ DO .
 
 WordAliasByRef theB ( A :: B |^@ )
 WordAliasByRef theC ( A :: B :: C |^@ )
 WordAliasByRef theZ ( A :: B :: Z |^@ )
 
 theB
 theC
 theZ .
 
 A :: B :: Z := 2048
 A :: B :: Z .
 
 theZ .
 
 theB
 
 theZ .
 
 @SELF __DumpMembers
;

WithTest
..\..\ScriptEngine\Examples\Other\WordAddr.ms.script
Test WordAddrTest

  : X
   100 .
  ; // X
  
  operator Y
   300 .
  ; // Y
  
  operator Z
   ^ IN aRight
   aRight DO .
  ; // Z
  
  @ 1
  @ '2'
  @ .
  @ ( )
  @ @
  @ X
  @ Y
  @ Z
  
  WHILE ( StackLevel > 0 ) ( IN anItem [ anItem |S anItem |N anItem ToPrintable ] ' ' strings:CatSep . )

; // WordAddrTest

WordAddrTest
..\..\ScriptEngine\Examples\Other\WordAlias.ms.script
Test WordAliasTest

/*{ IMMEDIATE operator WordAlias
  ^L IN aName
  ^ LINK IN aCode
  aCode aName |N Define
 ; // WordAlias}*/
 
  : X
   100 .
  ; // X
  
  operator Y
   300 .
  ; // Y
  
  operator Z
   ^ IN aRight
   aRight DO .
  ; // Z
  
  WordAlias A .
  WordAlias B (
  WordAlias C @
  WordAlias D X
  WordAlias E Y
  WordAlias F Z

  '1' A
  2 A
  
  B 123 . )
  
  @ '1234' DO .
  C '5678' DO .
  D
  E
  F 400
  
; // WordAliasTest

WordAliasTest
..\..\ScriptEngine\Examples\Other\WordAliasForPopToVar.ms.script

: WordAliasForPopToVar

 WordAlias To >>>

 INTEGER VAR I
 1 5 + To I
 I .
 //2 I + .
; // WordAliasForPopToVar

WordAliasForPopToVar
..\..\ScriptEngine\Examples\Other\WordProducer.ms.script
Тест TestWordProducer

/*{IMMEDIATE operator WordProducer
  ^L IN aName
 
 @SELF Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE OPERATOR'
  aName |N
  '@SELF Ctx:SetWordProducerForCompiledClass'
  '@ operator DO'
  ';'
 ] Ctx:Parser:PushArray
; // WordProducer
 
IMMEDIATE operator NamedWordProducer
  ^L IN aName
  ^L IN aNewName
 
 @SELF Ctx:SetWordProducerForCompiledClass
 [
  'IMMEDIATE OPERATOR'
  aName |N
  '@SELF Ctx:SetWordProducerForCompiledClass'
  aNewName |NS
  'Ctx:SetNewWordName'
  '@ operator DO'
  ';'
 ] Ctx:Parser:PushArray
; // NamedWordProducer}*/

 WordProducer <<Facet>>
 WordProducer <<Interface>>

 : N
  @SELF %ST pop:object:ClassName .
 ;
 
 <<Facet>> A
  'A' .
  @SELF pop:object:ClassName .
  @SELF |N .
  @SELF %P pop:object:ClassName .
  @SELF %P |N .
  @SELF %P %P pop:object:ClassName .
  //@SELF %P %P %P pop:object:ClassName .
  @SELF %ST pop:object:ClassName .
  @SELF %ST |N .
  //@SELF %ST %ST pop:object:ClassName .
  VAR XXX
  
  @ XXX pop:object:ClassName .
  @ XXX |N .
  @ XXX %ST pop:object:ClassName .
  @ XXX %ST |N .
 ;
 
 //NamedWordProducer INHERITS %G
 
 <<Facet>> B
 
  %INHERITS
   A
  ;
  
  'B' .
 ;
 
 <<Interface>> C
  'C' .
  @SELF pop:object:ClassName .
  @SELF %P pop:object:ClassName .
  @SELF %P %P pop:object:ClassName .
  @SELF %ST pop:object:ClassName .
  //@SELF %ST %ST pop:object:ClassName .
 ;
 
 N A B C
 
 StereotypeProducer MDAClass ;
 <<MDAClass>> SimpleClass
  'Hello' .
 ;
 
 <<SimpleClass>> TObject
 ; // TObject
 
 <<SimpleClass>> Tl3Base
 
  %INHERITS
   TObject
  ;
  
  'World' .
 ; // Tl3Base
 
 Tl3Base
 @ Tl3Base |N .
 @ Tl3Base pop:object:ClassName .
 @ Tl3Base %P pop:object:ClassName .
 @ Tl3Base %P %P pop:object:ClassName .
 @ Tl3Base %ST |N .
 // - тут ожидаем <<SimpleClass>>, но скорее всего - это не так
 @ Tl3Base %ST %ST |N .
 // - тут ожидаем <<MDAClass>>
 @ Tl3Base %ST %ST %ST |N .
 // - тут ожидаем StereotypeProducer
 // Но ПАДАЕТ, т.к. он не является TkwCompiledWord, надо будет видимо спустить WordProducer на TkwWord
 @ Tl3Base %ST %ST %ST %ST |N .
 // - тут ожидаем ''
 
 ClassProducer DefineClass
 
 DefineClass TSomeClass
 
  %INHERITS
   Tl3Base
  ;

  : "Это метод нашего класса"
  ;
  
  'Bang!' .
 ;
 
 TSomeClass
 @ TSomeClass |N .
 @ TSomeClass pop:object:ClassName .
 @ TSomeClass %P pop:object:ClassName .
 @ TSomeClass %P %P pop:object:ClassName .
 @ TSomeClass %ST |N .
 // - тут ожидаем DefineClass
 @ TSomeClass %ST %ST |N .
 // - тут ожидаем ClassProducer
 // Но ПАДАЕТ, т.к. он не является TkwCompiledWord, надо будет видимо спустить WordProducer на TkwWord
 // Уже - НЕ ПАДАЕМ, а получаем ТО ЧТО НУЖНО :-)
 
 : A1
 ;
 
 @ A1 |N .
 @ A1 pop:object:ClassName .
 @ A1 %P pop:object:ClassName .
 @ A1 %P %P pop:object:ClassName .
 @ A1 %ST |N .
 
 @SELF __DumpMembers
;

TestWordProducer
..\..\ScriptEngine\Examples\Other\WordRedefine.ms.script
Test WordRedefineTest

  : A
   100 .
  ; // A
  
  : B
   A
   
   : A
    200 .
    A
   ; // A
   
   A
  ; // B
  
  : C
   A
   
   operator A
    ^ IN aRight
    aRight DO .
    A
   ; // A
   
   A 300
   A 400
  ; // C
  
  A
  B
  A
  C

; // WordRedefineTest

WordRedefineTest
..\..\ScriptEngine\Examples\Other\WordRef.ms.script
Test WordAddrTest

  : X
   100 .
  ; // X
  
  operator Y
   300 .
  ; // Y
  
  operator Z
   ^ IN aRight
   aRight DO .
  ; // Z
  
  @^ 1 |^@
  @^ '2' |^@
  @^ . |^@
  @^ ( |^@
  @^ @ |^@
  @^ X |^@
  @^ Y |^@
  @^ Z |^@
  
  WHILE ( StackLevel > 0 ) ( IN anItem [ anItem |S anItem |N anItem ToPrintable ] ' ' strings:CatSep . )

; // WordAddrTest

WordAddrTest
..\..\ScriptEngine\Examples\Other\WordWorker.ms.script
Тест TestWordWorker

 operator CountIt INTEGER IN aCount
   ^ IN WordToWork
  aCount LOOP ( WordToWork DO )
 ;
 
 10 CountIt ( 'A' . )
 20 CountIt ( 'BC' . )
 
 operator =+ INTEGER IN anInc
   ^ IN WordToWork
  WordToWork DO anInc + =:^ WordToWork
 ;
 
 operator =- INTEGER IN anInc
   ^ IN WordToWork
  WordToWork DO anInc - =:^ WordToWork
 ;
 
 VAR A
 0 =: A
 2 =+ A
 A .

 0 =: A
 2 =- A
 A .
;

TestWordWorker
..\..\ScriptEngine\Examples\Other\WordWorker2.ms.script
Тест TestWordWorker2

/*{ IMMEDIATE operator WORDWORKER
   ^L IN aName
  STRING VAR l_Name
  aName |N >>> l_Name
  
  [
  'operator'
  l_Name
  '^ IN WordToWork'
  ] Ctx:Parser:PushArray
 ; // WORDWORKER}*/
 
 WORDWORKER Y
   ^ IN aString
  aString DO .
  WordToWork DO .
 ; // Y
 
 WORDWORKER Z
   IN aString
  aString .
  WordToWork DO .
 ; // Z
 
 operator X 
   ^ IN aString
   ^ IN WordToWork
  aString DO .
  WordToWork DO .
 ; // X
  
 X 'A' 1
 Y 'B' 1
 'C' Z 1
 2 . 
;

TestWordWorker2
..\..\ScriptEngine\Examples\Point\help.ms.script
help
..\..\ScriptEngine\Examples\Point\POINT0.ms.script
..\..\ScriptEngine\Examples\Point\POINT1.ms.script
ARRAY TYPE POINT
..\..\ScriptEngine\Examples\Point\POINT10.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT
CONST c:POINT:CoordCount 2

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // POINT:

POINT : POINT:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:XY

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3
POINT VAR P4

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1
P4 := POINT:XY ( 2 2 )

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
P4 POINT:Print
..\..\ScriptEngine\Examples\Point\POINT11.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT
CONST c:POINT:CoordCount 2

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // POINT:

POINT : POINT:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:XY

POINT : POINT:OF
 ^ IN aPoint
 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx ) ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:OF

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3
POINT VAR P4
POINT VAR P5

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1
P4 := POINT:XY ( 2 2 )
P5 := POINT:OF P4

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
P4 POINT:Print
P5 POINT:Print
..\..\ScriptEngine\Examples\Point\POINT12.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT
CONST c:POINT:CoordCount 2

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // POINT:

POINT : POINT:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:XY

POINT : POINT:OF
 ^ IN aPoint
 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx ) ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:OF

POINT : POINT:+
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] + Inc i ) ] >>> Result
; // POINT:+

POINT : POINT:-
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] - Inc i ) ] >>> Result
; // POINT:-

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3
POINT VAR P4
POINT VAR P5
POINT VAR P6

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1
P4 := POINT:XY ( 2 2 )
P5 := POINT:OF P4
P6 := ( P3 POINT:+ P4 )

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
P4 POINT:Print
P5 POINT:Print
P6 POINT:Print
..\..\ScriptEngine\Examples\Point\POINT13.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT
CONST c:POINT:CoordCount 2

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // POINT:

POINT : POINT:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:XY

POINT : POINT:OF
 ^ IN aPoint
 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx ) ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:OF

POINT : POINT:+
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] + Inc i ) ] >>> Result
; // POINT:+

POINT : POINT:-
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] SWAP - Inc i ) ] >>> Result
; // POINT:-

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3
POINT VAR P4
POINT VAR P5
POINT VAR P6
POINT VAR P7
POINT VAR P8

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1
P4 := POINT:XY ( 2 2 )
P5 := POINT:OF P4
P6 := ( P3 POINT:+ P4 )
P7 := ( P3 POINT:- P4 )
P8 := ( P4 POINT:- P3 )

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
P4 POINT:Print
P5 POINT:Print
P6 POINT:Print
P7 POINT:Print
P8 POINT:Print
..\..\ScriptEngine\Examples\Point\POINT14.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT
CONST c:POINT:CoordCount 2

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // POINT:

POINT : POINT:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:XY

POINT : POINT:OF
 ^ IN aPoint
 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx ) ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:OF

POINT : POINT:+
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] + Inc i ) ] >>> Result
; // POINT:+

POINT : POINT:-
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] SWAP - Inc i ) ] >>> Result
; // POINT:-

POINT : POINT:Neg
 POINT IN aLeft

 [ for aLeft ( PIXEL IN aPx aPx 0 SWAP - ) ] >>> Result
; // POINT:Neg

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3
POINT VAR P4
POINT VAR P5
POINT VAR P6
POINT VAR P7
POINT VAR P8
POINT VAR P9
POINT VAR P10

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1
P4 := POINT:XY ( 2 2 )
P5 := POINT:OF P4
P6 := ( P3 POINT:+ P4 )
P7 := ( P3 POINT:- P4 )
P8 := ( P4 POINT:- P3 )
P9 := ( P4 POINT:Neg )
P10 := ( P3 POINT:Neg )

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
P4 POINT:Print
P5 POINT:Print
P6 POINT:Print
P7 POINT:Print
P8 POINT:Print
P9 POINT:Print
P10 POINT:Print
..\..\ScriptEngine\Examples\Point\POINT15.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT
CONST c:POINT:CoordCount 2

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // POINT:

POINT : POINT:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:XY

POINT : POINT:OF
 ^ IN aPoint
 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx ) ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:OF

POINT : POINT:+
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] + Inc i ) ] >>> Result
; // POINT:+

POINT : POINT:-
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] SWAP - Inc i ) ] >>> Result
; // POINT:-

POINT : POINT:Neg
 POINT IN aLeft

 [ for aLeft ( PIXEL IN aPx aPx 0 SWAP - ) ] >>> Result
; // POINT:Neg

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3
POINT VAR P4
POINT VAR P5
POINT VAR P6
POINT VAR P7
POINT VAR P8
POINT VAR P9
POINT VAR P10

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1
P4 := POINT:XY ( 2 2 )
P5 := POINT:OF P4
P6 := ( P3 POINT:+ P4 )
P7 := ( P3 POINT:- P4 )
P8 := ( P4 POINT:- P3 )
P9 := ( P4 POINT:Neg )
P10 := ( P3 POINT:Neg )

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
P4 POINT:Print
P5 POINT:Print
P6 POINT:Print
P7 POINT:Print
P8 POINT:Print
P9 POINT:Print
P10 POINT:Print
..\..\ScriptEngine\Examples\Point\POINT16.ms.script
INTEGER TYPE PIXEL

ARRAY TYPE Object
Object TYPE POINT

PRIVATE CONST c:POINT:CoordCount 2

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // POINT:

POINT : POINT:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:XY

POINT : POINT:OF
 ^ IN aPoint
 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx ) ] >>> Result
 ( Result Array:Count = c:POINT:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // POINT:OF

POINT : POINT:+
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] + Inc i ) ] >>> Result
; // POINT:+

POINT : POINT:-
 POINT IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( PIXEL IN aPx aPx i aLeft [i] SWAP - Inc i ) ] >>> Result
; // POINT:-

POINT : POINT:Neg
 POINT IN aLeft

 [ for aLeft ( PIXEL IN aPx aPx 0 SWAP - ) ] >>> Result
; // POINT:Neg

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3
POINT VAR P4
POINT VAR P5
POINT VAR P6
POINT VAR P7
POINT VAR P8
POINT VAR P9
POINT VAR P10

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1
P4 := POINT:XY ( 2 2 )
P5 := POINT:OF P4
P6 := ( P3 POINT:+ P4 )
P7 := ( P3 POINT:- P4 )
P8 := ( P4 POINT:- P3 )
P9 := ( P4 POINT:Neg )
P10 := ( P3 POINT:Neg )

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
P4 POINT:Print
P5 POINT:Print
P6 POINT:Print
P7 POINT:Print
P8 POINT:Print
P9 POINT:Print
P10 POINT:Print
..\..\ScriptEngine\Examples\Point\Point17.ms.script
ARRAY TYPE Object
WordAlias private PRIVATE
WordAlias Private PRIVATE
WordAlias type TYPE
WordAlias Type TYPE

INTEGER type Pixel

Object type Point

private CONST c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 ^ IN aPoint
 [ for ( aPoint |@ DO ) ( Pixel IN aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?ASSURE 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel IN aPx aPx i aLeft [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point IN aLeft
 ^ IN aPoint

 INTEGER VAR i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel IN aPx aPx i aLeft [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point IN aLeft

 [ for aLeft ( Pixel IN aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point IN aPoint
 aPoint Print
; // Point:Print

Point VAR P1
Point VAR P2
Point VAR P3
Point VAR P4
Point VAR P5
Point VAR P6
Point VAR P7
Point VAR P8
Point VAR P9
Point VAR P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print
..\..\ScriptEngine\Examples\Point\Point18.ms.script
ARRAY TYPE Object
WordAlias private PRIVATE
WordAlias Private PRIVATE
WordAlias type TYPE
WordAlias Type TYPE
WordAlias var VAR
WordAlias in IN
WordAlias ?Assure ?ASSURE
WordAlias Const CONST
WordAlias const CONST

INTEGER type Pixel

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 ^ in aX
 ^ in aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 ^ in aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 ^ in aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in aLeft
 ^ in aPoint

 INTEGER var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i aLeft [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in aLeft
 ^ in aPoint

 INTEGER var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i aLeft [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in aLeft

 [ for aLeft ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print
..\..\ScriptEngine\Examples\Point\Point19.ms.script
ARRAY TYPE Object
WordAlias private PRIVATE
WordAlias Private PRIVATE
WordAlias type TYPE
WordAlias Type TYPE
WordAlias var VAR
WordAlias in IN
WordAlias ?Assure ?ASSURE
WordAlias Const CONST
WordAlias const Const

INTEGER type Pixel

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 ^ in aX
 ^ in aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 ^ in aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 ^ in aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 ^ in aPoint

 INTEGER var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 ^ in aPoint

 INTEGER var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print
..\..\ScriptEngine\Examples\Point\POINT2.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT
..\..\ScriptEngine\Examples\Point\Point20.ms.script
ARRAY TYPE Object
WordAlias private PRIVATE
WordAlias Private PRIVATE
WordAlias type TYPE
WordAlias Type TYPE
WordAlias var VAR
WordAlias in IN
WordAlias ?Assure ?ASSURE
WordAlias Const CONST
WordAlias const Const

INTEGER type Pixel

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 ^ in aX
 ^ in aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 ^ in aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 ^ in aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 ^ in aPoint

 INTEGER var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 ^ in aPoint

 INTEGER var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print
..\..\ScriptEngine\Examples\Point\Point21.ms.script
USES
 params.ms.dict
;

ARRAY TYPE Object
WordAlias private PRIVATE
WordAlias Private PRIVATE
WordAlias type TYPE
WordAlias Type TYPE
WordAlias var VAR
WordAlias in IN
WordAlias ?Assure ?ASSURE
WordAlias Const CONST
WordAlias const Const

INTEGER type Pixel

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 RightParam aX
 RightParam aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 RightParam aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 RightParam aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 RightParam aPoint

 INTEGER var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 RightParam aPoint

 INTEGER var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print
..\..\ScriptEngine\Examples\Point\Point22.ms.script
USES
 params.ms.dict
;

ARRAY TYPE Object
WordAlias private PRIVATE
WordAlias Private PRIVATE
WordAlias type TYPE
WordAlias Type TYPE
WordAlias var VAR
WordAlias in IN
WordAlias ?Assure ?ASSURE
WordAlias Const CONST
WordAlias const Const

INTEGER type Pixel
INTEGER type FieldOffset

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 right aX
 right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print
..\..\ScriptEngine\Examples\Point\Point23.ms.script
USES
 params.ms.dict
;

Test PointTest

ARRAY TYPE Object
WordAlias private PRIVATE
WordAlias Private PRIVATE
WordAlias type TYPE
WordAlias Type TYPE
WordAlias var VAR
WordAlias in IN
WordAlias ?Assure ?ASSURE
WordAlias Const CONST
WordAlias const Const

INTEGER type Pixel
INTEGER type FieldOffset

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 right aX
 right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point24.ms.script
USES
 params.ms.dict
;

Test PointTest

ARRAY TYPE Object
WordAlias private PRIVATE
WordAlias Private PRIVATE
WordAlias type TYPE
WordAlias Type TYPE
WordAlias var VAR
WordAlias ?Assure ?ASSURE
WordAlias Const CONST
WordAlias const Const

INTEGER type Pixel
INTEGER type FieldOffset

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 right aX
 right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point25.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

array type Object

INTEGER type Pixel
INTEGER type FieldOffset

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 right aX
 right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point26.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

array type Object

INTEGER type Pixel
// - пиксель
INTEGER type FieldOffset
// - смещение поля
List type PixelList
// - список пикселей

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

VOID : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point27.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

array type Object

INTEGER type Pixel
// - пиксель
INTEGER type FieldOffset
// - смещение поля
List type PixelList
// - список пикселей

Object type Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point28.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

array type Object

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 'Object' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // class

INTEGER type Pixel
// - пиксель
INTEGER type FieldOffset
// - смещение поля
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point : Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point : Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point : Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point : Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point29.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

array type Object

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 'Object' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point : Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point : Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point : Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void : Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\POINT3.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT

POINT VAR P
..\..\ScriptEngine\Examples\Point\Point30.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

array type Object

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 'Object' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point31.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point32.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point33.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

IMMEDIATE VOID operator _class_
// - имплементация класса, пока "фиктивная"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // _class_

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point34.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point35.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point36.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
;

//REDEFINITION
 : (+)
  IN aLeft
  right aRight
  aLeft (+) ( aRight DO )
  //inherited
 ; // (+)

REDEFINITION
 : (+)
  IN aLeft
  right aRight
  if ( aLeft IsInt ) then
   ( aLeft aRight |^ + )
  else  
   ( aLeft (+) ( aRight DO ) )
  //inherited
 ; // (+)

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

// - поскольку операторы + и - заняты ОПЗ поэтому будем использовать (+) и (-) для "обычной" человеческой записи

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print
1 (+) 2 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point37.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] + Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx i Self [i] SWAP - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx aPx 0 SWAP - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

// - поскольку операторы + и - заняты ОПЗ поэтому будем использовать (+) и (-) для "обычной" человеческой записи

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point38.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx (+) ( i Self [i] ) Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx i Self [i] aPx - Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx 0 aPx - ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point39.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (-) aPx Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx 0 (-) aPx ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\POINT4.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

VOID : POINT:Print
 POINT IN aPoint
; // POINT:Print

POINT VAR P

P := POINT:0

P POINT:Print
..\..\ScriptEngine\Examples\Point\Point40.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (-) aPx Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx 0 (-) aPx ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point41.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Pixel method Point:X
 Point in Self
 c:Point:Offset:X Self [i] >>> Result
; // Point:X

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (-) aPx Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx 0 (-) aPx ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point42.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Pixel readonly Point:X
 Point in Self
 c:Point:Offset:X Self [i] >>> Result
; // Point:X

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (-) aPx Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx 0 (-) aPx ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point43.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

class Object

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Pixel readonly Point:X
 Point in Self
 c:Point:Offset:X Self [i] >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 c:Point:Offset:Y Self [i] >>> Result
; // Point:Y

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( i Self [i] ) (-) aPx Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx 0 (-) aPx ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point44.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( Self FieldByOffset i ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( Self FieldByOffset i ) (-) aPx Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 [ for Self ( Pixel in aPx 0 (-) aPx ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point45.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( Self FieldByOffset i ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( Self FieldByOffset i ) (-) aPx Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 Point: ( 0 (-) ( Self Point:X ) ) ( 0 (-) ( Self Point:Y ) ) >>> Result
 //[ for Self ( Pixel in aPx 0 (-) aPx ) ] >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point46.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( Self FieldByOffset i ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( Self FieldByOffset i ) (-) aPx Inc i ) ] >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point47.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point method Point:+
 Point in Self
 Point right aPoint

 FieldOffset var i
 i := 0

 [ for ( aPoint |@ DO ) ( Pixel in aPx ( Self FieldByOffset i ) (+) aPx Inc i ) ] >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point48.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Point constructor Point:OF
 Point right aPoint
 [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point method Point:+
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point49.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:0
 [ 0 0 ] >>> Result
; // Point:0

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
// [ for ( aPoint |@ DO ) ( Pixel in aPx aPx ) ] >>> Result
// ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\POINT5.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P

P := POINT:0

P POINT:Print
..\..\ScriptEngine\Examples\Point\Point50.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

Point constructor Point:XY
 PixelList right aPoint
 [ aPoint |@ DO ] >>> Result
 ( Result Array:Count = c:Point:CoordCount ) ?Assure 'Точка должна содержать две координаты'
; // Point:XY

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point51.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

Point constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:-
 Point in Self
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point in Self

 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Point in aPoint
 aPoint Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point52.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

Point constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Point in Self
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Point in Self
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:-
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point53.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

Point constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:-
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point54.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' aName |N '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

Point constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

Point constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

Point constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

Point constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:-
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point55.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:-
 Point right aPoint

 Point: ( ( Self Point:X ) (-) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (-) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:-

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point56.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

constructor Point:
 Pixel right aX
 Pixel right aY
 [ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point57.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
; // new[

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point58.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
; // new[

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point59.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 //'@' Ctx:Parser:PushSymbol
; // new[

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 0
private Const c:Point:Offset:Y 1
private Const c:Point:CoordCount 2

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\POINT6.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2

P1 := POINT:0
P2 := POINT:0

P1 POINT:Print
P2 POINT:Print
..\..\ScriptEngine\Examples\Point\Point60.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

private Const c:Point:Offset:X 1
private Const c:Point:Offset:Y 2
private Const c:Point:CoordCount 3

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point61.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
private Const c:Point:VMT:Size 3

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point62.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassVMTSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':VMT:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassVMTSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassVMTSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point63.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly Offset:class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Offset:class

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

for [ P1 ] Point:Print
P1 Point:Print
P2 Point:Print
P3 Point:Print
P4 Point:Print
P5 Point:Print
P6 Point:Print
P7 Point:Print
P8 Point:Print
P9 Point:Print
P10 Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point64.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly Offset:class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Offset:class

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

for [ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] Point:Print

P1 Point:X Print
P2 Point:X Print
P3 Point:X Print
P4 Point:X Print
P5 Point:X Print
P6 Point:X Print
P7 Point:X Print
P8 Point:X Print
P9 Point:X Print
P10 Point:X Print

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point65.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly Offset:class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Offset:class

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

for [ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] Point:Print
for [ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] ( Point:X Print )

P1 Point:Y Print
P2 Point:Y Print
P3 Point:Y Print
P4 Point:Y Print
P5 Point:Y Print
P6 Point:Y Print
P7 Point:Y Print
P8 Point:Y Print
P9 Point:Y Print
P10 Point:Y Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point66.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly Offset:class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Offset:class

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point67.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly Object:class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point68.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly Object:class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly Object:ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point69.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly Object:class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly Object:ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly Point:X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Point:Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\POINT7.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN X
 ^ IN Y
 [ X |^ Y |^ ] >>> Result
; // POINT:0

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1

P1 POINT:Print
P2 POINT:Print
..\..\ScriptEngine\Examples\Point\Point70.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point:
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point:

constructor Point:0
 Point: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // Point:X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Point:Y

constructor Point:OF
 Point right aPoint
 Point: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method Point:+
 Point right aPoint

 Point: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // Point:+

Point method Point:Neg
 Point: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Point:Neg

Point method Point:-
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // Point:-

void method Point:Print
 Self Print
; // Point:Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point71.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 aName |N Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor Point::
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // Point::

constructor Point:0
 Point:: 0 0 >>> Result
; // Point:0

constructor Point:XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // Point:XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Y

constructor Point:OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // Point:OF

Point method +
 Point right aPoint

 Point:: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 Self Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point72.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 Self Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point73.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |@ DO ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point74.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point75.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
g_ClassFieldOffset := 0

IMMEDIATE VOID operator ClassFieldOffset
 Literal IN aName
 INTEGER right anOffset
 anOffset |^ >>> g_ClassFieldOffset
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassFieldOffset

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset ++ Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

ClassFieldOffset VMT 0
ClassInstanceSize

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

ClassFieldOffset X 1
ClassFieldOffset Y 2
ClassInstanceSize

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ |^ aY |^ |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point76.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator ClassInstanceSize
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // ClassInstanceSize

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

member VMT
ClassInstanceSize

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
ClassInstanceSize

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point77.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

member VMT
members-end

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point78.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

member VMT
members-end

TtfwWord readonly class
 Self FieldByOffset c:Object:Offset:VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X
 Self FieldByOffset c:Point:Offset:X >>> Result
; // X

Pixel readonly Y
 Self FieldByOffset c:Point:Offset:Y >>> Result
; // Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( ( Self Point:X ) (+) ( aPoint |^ Point:X ) ) ( ( Self Point:Y ) (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point79.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

VOID IMMEDIATE operator get-member
 Literal IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol 
; // get-member

member VMT
members-end

TtfwWord readonly class
 Self get-member VMT >>> Result
; // Object:class

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X
 Self get-member X >>> Result
; // X

Pixel readonly Y
 Self get-member Y >>> Result
; // Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint |^ Point:X ) ) ( Self Point:Y (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\POINT8.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN X
 ^ IN Y
 [ X |^ Y |^ ] >>> Result
; // POINT:0

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
..\..\ScriptEngine\Examples\Point\Point80.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_' g_CurrentClass '_' ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING readonly ClassName
 Self Object:class |N >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint |^ Point:X ) ) ( Self Point:Y (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point81.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

//REDEFINITION
 : (-)
  IN aLeft
  right aRight
  ( aLeft (-) ( aRight DO ) )
 ; // 

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName |N ] strings:Cat Ctx:Parser:PushSymbol
; // constructor

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName |N ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING readonly ClassName
 Self Object:class |N ':' string:Split >>> Result DROP
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint |^ Point:X ) ) ( Self Point:Y (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\Point82.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset |^ Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING readonly ClassName
 Self Object:class |N ':' string:Split >>> Result DROP
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint |^ ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint |^ Point:X ) ( aPoint |^ Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint |^ Point:X ) ) ( Self Point:Y (+) ( aPoint |^ Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint |^ Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point\POINT9.ms.script
INTEGER TYPE PIXEL
ARRAY TYPE POINT

POINT : POINT:0
 [ 0 0 ] >>> Result
; // POINT:0

POINT : POINT:
 ^ IN aX
 ^ IN aY
 [ aX |^ aY |^ ] >>> Result
; // POINT:

POINT : POINT:XY
 ^ IN aPoint
 [ aPoint |@ DO ] >>> Result
; // POINT:XY

VOID : POINT:Print
 POINT IN aPoint
 aPoint Print
; // POINT:Print

POINT VAR P1
POINT VAR P2
POINT VAR P3
POINT VAR P4

P1 := POINT:0
P2 := POINT:0
P3 := POINT: 1 1
P4 := POINT:XY ( 2 2 )

P1 POINT:Print
P2 POINT:Print
P3 POINT:Print
P4 POINT:Print
..\..\ScriptEngine\Examples\Point\TestRight.ms.script
USES
// params.ms.dict
 CodeDump.ms.dict
; // USES

Test RighTest

VOID IMMEDIATE operator right
 Literal IN aName
 'RIGHT' Ctx:Parser:PushSymbol
 'IN' Ctx:Parser:PushSymbol

 STRING VAR l_Name
 aName |N >>> l_Name 

 STRING VAR l_MangledName
 [ '_' l_Name ] strings:Cat >>> l_MangledName

 l_MangledName Ctx:Parser:PushSymbol
 
  [
   'VOID IMMEDIATE axiom:operator' 
   l_Name 
   [ '`' l_MangledName '`' ] strings:Cat
   'Ctx:Parser:PushSymbol'
   '`|^`'
   'Ctx:Parser:PushSymbol'
   ';'
  ] Ctx:Parser:PushArray

 //'WordAlias' Ctx:Parser:PushSymbol
 //l_Name Ctx:Parser:PushSymbol
 //l_MangledName Ctx:Parser:PushSymbol
; // right

 : X
  right aA
  aA .
 ; // X

 X '10'
 X 20

 @SELF DumpElement

; //RighTest

RighTest
..\..\ScriptEngine\Examples\Point1\help.ms.script
help
..\..\ScriptEngine\Examples\Point1\Point83.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 ':' Ctx:Parser:PushSymbol
 @ class_impl Ctx:SetWordProducerForCompiledClass
 [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol

 'array' Ctx:Parser:PushSymbol
 'type' Ctx:Parser:PushSymbol
 g_CurrentClass Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING readonly ClassName
 Self Object:class |N ':' string:Split >>> Result DROP
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point84.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    ';'
   end
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING readonly ClassName
 Self Object:class |N ':' string:Split >>> Result DROP
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point85.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@ Object'
    ';'
   end
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING readonly ClassName
 Self Object:class |N ':' string:Split >>> Result DROP
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point86.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G IN %S
 Result := ( '%G' %S ELEMLIST )
;

VOID IMMEDIATE OPERATOR class_impl
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING readonly ClassName
 Self Object:class |N ':' string:Split >>> Result DROP
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( |N Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point87.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G IN %S
 Result := ( '%G' %S ELEMLIST )
;

VOID IMMEDIATE OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 // Тут можно копировать поля и методы
; // classExpander

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   '%FIELDS'
   ';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point88.ms.script
USES
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G IN %S
 Result := ( '%G' %S ELEMLIST )
;

VOID IMMEDIATE OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 // Тут можно копировать поля и методы
; // classExpander

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   '%FIELDS'
   ';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point89.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G IN %S
 Result := ( '%G' %S ELEMLIST )
;

VOID IMMEDIATE OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 // Тут можно копировать поля и методы
; // classExpander

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   '%FIELDS'
   ';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point90.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G IN %S
 Result := ( '%G' %S ELEMLIST )
;

VOID OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 // Тут можно копировать поля и методы
; // classExpander

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 g_CurrentClassMembers := [ ]
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   //'%FIELDS'
   //';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

VOID IMMEDIATE operator RunCompileFields
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS'
   for g_CurrentClassMembers ( STRING IN aName [ '`' aName '`' ] strings:Cat )
   ';'
  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileFields

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 'RunCompileFields' Ctx:Parser:PushSymbol
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point91.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G IN %S
 Result := ( '%G' %S ELEMLIST )
;

ARRAY FUNCTION %Fld IN %S
 //Result := ( '%Fld' %S ELEMLIST )
 Result := ( %S %% '%Fld' CodeIterator )
;

VOID OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 ^ IN anImpl
 // Тут можно копировать поля и методы
 for ( ( anImpl |@ ) %G ) ( 
  IN anItem 
  for ( anItem %Fld ) ( 
   IN anItem 
   //anItem |N Msg 
   'member' Ctx:Parser:PushSymbol
   anItem |N Ctx:Parser:PushSymbol
  ) 
 )
; // classExpander

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 g_CurrentClassMembers := [ ]
 g_ClassFieldOffset := 0
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   //'%FIELDS'
   //';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

VOID IMMEDIATE operator RunCompileFields
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS'
   for g_CurrentClassMembers ( STRING IN aName [ '`' aName '`' ] strings:Cat )
   ';'
  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileFields

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 'RunCompileFields' Ctx:Parser:PushSymbol
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point92.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R 
 IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G 
 IN %S
 Result := ( '%G' %S ELEMLIST )
;

ARRAY FUNCTION %Fld 
 IN %S
 //Result := ( '%Fld' %S ELEMLIST )
 VAR l_List
 %S %% '%Fld' >>> l_List
 if ( l_List NotValid ) then
  ( Result := [ ] )
 else 
  ( Result := ( l_List CodeIterator ) )
;

VOID OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 ^ IN anImpl
 // Тут можно копировать поля и методы
 for ( ( anImpl |@ ) %G ) ( 
  IN anItem 
  for ( anItem %Fld ) ( 
   IN anItem 
   'member' Ctx:Parser:PushSymbol
   anItem |N Ctx:Parser:PushSymbol
  ) 
 )
; // classExpander

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 g_CurrentClassMembers := [ ]
 g_ClassFieldOffset := 0
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   //'%FIELDS'
   //';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

VOID IMMEDIATE operator RunCompileFields
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS'
   for g_CurrentClassMembers ( STRING IN aName [ '`' aName '`' ] strings:Cat )
   ';'
  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileFields

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 'RunCompileFields' Ctx:Parser:PushSymbol
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

member X
member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10
Point var P11

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )
P11 := Point:XY ( -2 2 )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point93.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R 
 IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G 
 IN %S
 Result := ( '%G' %S ELEMLIST )
;

ARRAY FUNCTION %Fld 
 IN %S
 //Result := ( '%Fld' %S ELEMLIST )
 VAR l_List
 %S %% '%Fld' >>> l_List
 if ( l_List NotValid ) then
  ( Result := [ ] )
 else 
  ( Result := ( l_List CodeIterator ) )
;

VOID OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 ^ IN anImpl
 // Тут можно копировать поля и методы
 for ( ( anImpl |@ ) %G ) ( 
  IN anItem 
  for ( anItem %Fld ) ( 
   IN anItem 
   'member' Ctx:Parser:PushSymbol
   anItem |N Ctx:Parser:PushSymbol
  ) 
 )
; // classExpander

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 g_CurrentClassMembers := [ ]
 g_ClassFieldOffset := 0
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   //'%FIELDS'
   //';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol

; // class

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 Ctx:ClearTypeInfo
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

VOID IMMEDIATE operator RunCompileFields
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS'
   for g_CurrentClassMembers ( STRING IN aName [ '`' aName '`' ] strings:Cat )
   ';'
  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileFields

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 'RunCompileFields' Ctx:Parser:PushSymbol
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

INTEGER member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

Pixel member X
Pixel member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10
Point var P11

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )
P11 := Point:XY ( -2 2 )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point94.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R 
 IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G 
 IN %S
 Result := ( '%G' %S ELEMLIST )
;

ARRAY FUNCTION %Fld 
 IN %S
 //Result := ( '%Fld' %S ELEMLIST )
 VAR l_List
 %S %% '%Fld' >>> l_List
 if ( l_List NotValid ) then
  ( Result := [ ] )
 else 
  ( Result := ( l_List CodeIterator ) )
;

VOID OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 ^ IN anImpl
 // Тут можно копировать поля и методы
 for ( ( anImpl |@ ) %G ) ( 
  IN anItem 
  for ( anItem %Fld ) ( 
   IN anItem 
   'member' Ctx:Parser:PushSymbol
   anItem |N Ctx:Parser:PushSymbol
  ) 
 )
; // classExpander

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 g_CurrentClassMembers := [ ]
 g_ClassFieldOffset := 0
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   //'%FIELDS'
   //';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol

; // class

VOID IMMEDIATE OPERATOR class-end
; // class-end

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 Ctx:ClearTypeInfo
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

VOID IMMEDIATE operator RunCompileFields
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS'
   for g_CurrentClassMembers ( STRING IN aName [ '`' aName '`' ] strings:Cat )
   ';'
  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileFields

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 'RunCompileFields' Ctx:Parser:PushSymbol
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

INTEGER member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

class-end // Object

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

Pixel member X
Pixel member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

void method Print
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat Print
; // Print

class-end // Point

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10
Point var P11

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )
P11 := Point:XY ( -2 2 )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point95.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R 
 IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G 
 IN %S
 Result := ( '%G' %S ELEMLIST )
;

ARRAY FUNCTION %Fld 
 IN %S
 //Result := ( '%Fld' %S ELEMLIST )
 VAR l_List
 %S %% '%Fld' >>> l_List
 if ( l_List NotValid ) then
  ( Result := [ ] )
 else 
  ( Result := ( l_List CodeIterator ) )
;

VOID OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 ^ IN anImpl
 // Тут можно копировать поля и методы
 for ( ( anImpl |@ ) %G ) ( 
  IN anItem 
  for ( anItem %Fld ) ( 
   IN anItem 
   'member' Ctx:Parser:PushSymbol
   anItem |N Ctx:Parser:PushSymbol
  ) 
 )
; // classExpander

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 g_CurrentClassMembers := [ ]
 g_ClassFieldOffset := 0
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   //'%FIELDS'
   //';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol

; // class

VOID IMMEDIATE OPERATOR class-end
; // class-end

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 Ctx:ClearTypeInfo
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

VOID IMMEDIATE operator RunCompileFields
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS'
   for g_CurrentClassMembers ( STRING IN aName [ '`' aName '`' ] strings:Cat )
   ';'
  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileFields

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 'RunCompileFields' Ctx:Parser:PushSymbol
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

INTEGER member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

class-end // Object

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

Pixel member X
Pixel member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

STRING method ToPrintable
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat >>> Result
; // ToPrintable

void method Print
 Self Point:ToPrintable Print
; // Print

class-end // Point

class Rectangle

Point member TopLeft
Point member BottomRight
members-end

Point readonly TopLeft read TopLeft

Point readonly BottomRight read BottomRight

constructor :
 Point RightParam aTopLeft
 Point RightParam aBottomRight
 new[ aTopLeft |^ aBottomRight |^ ] >>> Result
; // :

STRING method ToPrintable
 [ '( ' 'TopLeft: ' Self Rectangle:TopLeft Point:ToPrintable ', BottomRight: ' Self Rectangle:BottomRight Point:ToPrintable ' )' ] strings:Cat >>> Result
; // ToPrintable

void method Print
 Self Rectangle:ToPrintable Print
; // Print

class-end // Rectangle

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10
Point var P11

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )
P11 := Point:XY ( -2 2 )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

Rectangle var R1
R1 := Rectangle:: P1 P4
R1 Rectangle:Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\Point96.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled >>> l_NewCompiler
/*{   l_NewCompiler CodeIterator ==> ( IN anItem 
    if ( NOT ( anItem %P pop:object:IsNil ) ) then
    begin
     anItem %P >>> l_NewCompiler
     BREAK-ITERATOR
    end 
   )}*/
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R 
 IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G 
 IN %S
 Result := ( '%G' %S ELEMLIST )
;

ARRAY FUNCTION %Fld 
 IN %S
 //Result := ( '%Fld' %S ELEMLIST )
 VAR l_List
 %S %% '%Fld' >>> l_List
 if ( l_List NotValid ) then
  ( Result := [ ] )
 else 
  ( Result := ( l_List CodeIterator ) )
;

VOID OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//VOID IMMEDIATE OPERATOR class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// ':' Ctx:Parser:PushSymbol
// aName |N Ctx:Parser:PushSymbol
// //';' Ctx:Parser:PushSymbol
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

VOID IMMEDIATE OPERATOR classExpander
 ^ IN anImpl
 // Тут можно копировать поля и методы
 for ( ( anImpl |@ ) %G ) ( 
  IN anItem 
  for ( anItem %Fld ) ( 
   IN anItem 
   'member' Ctx:Parser:PushSymbol
   anItem |N Ctx:Parser:PushSymbol
  ) 
 )
; // classExpander

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

VOID IMMEDIATE OPERATOR class
 Literal IN aName
 g_CurrentClassMembers := [ ]
 g_ClassFieldOffset := 0
 aName |N >>> g_CurrentClass
 //'class_impl' Ctx:Parser:PushSymbol
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat >>> g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass <> 'Object' ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' 'Object' ] strings:Cat
    ';'
   end
   //'%FIELDS'
   //';'
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 'classExpander' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol

; // class

VOID IMMEDIATE OPERATOR class-end
; // class-end

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 ':' Ctx:Parser:PushSymbol
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

IMMEDIATE VOID operator constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 'in' Ctx:Parser:PushSymbol
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

IMMEDIATE VOID operator method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

IMMEDIATE VOID operator readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

IMMEDIATE VOID operator new[
 '[' Ctx:Parser:PushSymbol
 '@' Ctx:Parser:PushSymbol
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

IMMEDIATE VOID operator member
 Literal IN aName
 Ctx:ClearTypeInfo
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 aName |N MakeFieldOffsetName Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 Inc g_ClassFieldOffset
 aName |N >>>[] g_CurrentClassMembers
; // member

VOID IMMEDIATE operator RunCompileFields
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS'
   for g_CurrentClassMembers ( STRING IN aName [ '`' aName '`' ] strings:Cat )
   ';'
  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileFields

IMMEDIATE VOID operator members-end
 'private' Ctx:Parser:PushSymbol
 'Const' Ctx:Parser:PushSymbol
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 'RunCompileFields' Ctx:Parser:PushSymbol
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
 STRING IN aName
 'FieldByOffset' Ctx:Parser:PushSymbol
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

VOID IMMEDIATE operator get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

VOID IMMEDIATE operator read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 '>>>' Ctx:Parser:PushSymbol 
 'Result' Ctx:Parser:PushSymbol
 ';' Ctx:Parser:PushSymbol
; // read

INTEGER member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split >>> Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName >>> Result
; // Object:ClassName

class-end // Object

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

Pixel member X
Pixel member Y
members-end

constructor :
 Pixel RightParam aX
 Pixel RightParam aY
 new[ aX |^ aY |^ ] >>> Result
; // :

constructor 0
 Point:: 0 0 >>> Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] >>> Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) >>> Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) >>> Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) >>> Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) >>> Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) >>> Result
; // -

STRING method ToPrintable
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat >>> Result
; // ToPrintable

void method Print
 Self Point:ToPrintable Print
; // Print

class-end // Point

class Rectangle

Point member TopLeft
Point member BottomRight
members-end

Point readonly TopLeft read TopLeft

Point readonly BottomRight read BottomRight

constructor :
 Point RightParam aTopLeft
 Point RightParam aBottomRight
 new[ aTopLeft |^ aBottomRight |^ ] >>> Result
; // :

STRING method ToPrintable
 [ '( ' 'TopLeft: ' Self Rectangle:TopLeft Point:ToPrintable ', BottomRight: ' Self Rectangle:BottomRight Point:ToPrintable ' )' ] strings:Cat >>> Result
; // ToPrintable

void method Print
 Self Rectangle:ToPrintable Print
; // Print

class-end // Rectangle

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10
Point var P11

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )
P11 := Point:XY ( -2 2 )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ] >>> l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

Rectangle var R1
Rectangle var R2
R1 := Rectangle:: P1 P4
R2 := Rectangle:: P6 P7

array var l_Rectangles
[ R1 R2 ] >>> l_Rectangles

for l_Rectangles Rectangle:Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
..\..\ScriptEngine\Examples\Point1\TestRight.ms.script
USES
 params.ms.dict
 CodeDump.ms.dict
; // USES

Test RighTest

VOID operator Pusher
 STRING IN aName
 '(' Ctx:Parser:PushSymbol
 aName Ctx:Parser:PushSymbol
 '|^' Ctx:Parser:PushSymbol
 ')' Ctx:Parser:PushSymbol
; // Pusher

VOID IMMEDIATE operator right
 Literal IN aName
 'RIGHT' Ctx:Parser:PushSymbol
 'IN' Ctx:Parser:PushSymbol

 STRING VAR l_Name
 aName |N >>> l_Name 

 STRING VAR l_MangledName
 [ '_' l_Name ] strings:Cat >>> l_MangledName

 l_MangledName Ctx:Parser:PushSymbol
 
  [
   'VOID IMMEDIATE axiom:operator' 
   l_Name 
   [ '`' l_MangledName '`' ] strings:Cat
   'Pusher'
   ';'
  ] Ctx:Parser:PushArray

 //'WordAlias' Ctx:Parser:PushSymbol
 //l_Name Ctx:Parser:PushSymbol
 //l_MangledName Ctx:Parser:PushSymbol
; // right

 : X
  right aA
  aA .
 ; // X

 X '10'
 X 20

 @SELF DumpElement

; //RighTest

RighTest
..\..\ScriptEngine\Examples\Point2\help.ms.script
help
..\..\ScriptEngine\Examples\Point2\Point96.ms.script
USES
 axiom:CompiledWordWorkerWord
 axiom:Finder
 axiom:Compiler
 macro.ms.dict
 NoCapsLock.ms.dict
 params.ms.dict
 integer.ms.dict
;

Test PointTest

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

 IMMEDIATE operator implementation
   ^ LINK IN aWordToWork
  Ctx:PushCompiler
  Ctx:PushFinder
  OBJECT VAR l_NewCompiler
  aWordToWork |^@ =: l_NewCompiler
  
  if ( l_NewCompiler Is class::TkwCompiledWordWorkerWord ) then
  begin
   l_NewCompiler pop:CompiledWordWorkerWord:Compiled =: l_NewCompiler
  end
  
  l_NewCompiler pop:Compiler:SetToCtx
  l_NewCompiler pop:Finder:SetToCtx
 ; // implementation
 
 IMMEDIATE operator end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // end.

NamedWordProducer %FIELDS %Fld

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO =: Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
ARRAY FUNCTION ELEMLIST STRING IN aListName IN %S
 if ( %S NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( %S %% aListName )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
//    ( Result := ( [ l_List DO ] ) )
    ( Result := ( @ FilterMember ( @ DoMember ( l_List CodeIterator ) MAP ) FILTER ) ) 
  )
; // ELEMLIST

ARRAY FUNCTION %R 
 IN %S
 Result := ( '%R' %S ELEMLIST )
;

ARRAY FUNCTION %G 
 IN %S
 Result := ( '%G' %S ELEMLIST )
;

ARRAY FUNCTION %Fld 
 IN %S
 //Result := ( '%Fld' %S ELEMLIST )
 VAR l_List
 %S %% '%Fld' =: l_List
 if ( l_List NotValid ) then
  ( Result := [ ] )
 else 
  ( Result := ( l_List CodeIterator ) )
;

VOID OPERATOR class_impl
// - имплементация класса, пока "фиктивная"
// Тут мы будем хранить всю информацию о классе - предки, поля, методы
; // class_impl

//MACRO class_impl
//// - имплементация класса, пока "фиктивная"
// Literal IN aName
// @SELF Ctx:SetWordProducerForCompiledClass
// axiom:PushSymbol : 
// aName |N Ctx:Parser:PushSymbol
// // axiom:PushSymbol ;
//; // class_imp

STRING var g_CurrentClass
g_CurrentClass := ''
STRING var g_CurrentClassImpl
g_CurrentClassImpl := ''

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ 'c:' g_CurrentClass ':Offset:' aName ] strings:Cat =: Result
; // MakeFieldOffsetName

VOID operator define_member
 STRING IN aName
 INTEGER IN aOffset
 axiom:PushSymbol private
 axiom:PushSymbol Const
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol
 aOffset Ctx:Parser:PushInt
; // define_member

INTEGER VAR g_ClassFieldOffset
[EXECUTE]
( g_ClassFieldOffset := 0 )
g_ClassFieldOffset := 0

ARRAY VAR g_CurrentClassMembers
[EXECUTE]
( g_CurrentClassMembers := [ ] )
( g_CurrentClassMembers := [ ] )

MACRO member
 Literal IN aName
 Ctx:ClearTypeInfo
 aName |N g_ClassFieldOffset define_member
 Inc g_ClassFieldOffset
 aName |N array:AddTo g_CurrentClassMembers
; // member

MACRO classExpander
 ^ IN anImpl
 // Тут можно копировать поля и методы
 for ( ( anImpl |@ ) %G ) ( 
  IN anItem 
  for ( anItem %Fld ) ( 
   IN anItem 
   axiom:PushSymbol member
   anItem |N Ctx:Parser:PushSymbol
  ) 
 )
; // classExpander

CONST cObjectName 'Object'

MACRO class
 Literal IN aName
 g_CurrentClassMembers := [ ]
 g_ClassFieldOffset := 0
 aName |N =: g_CurrentClass
 // axiom:PushSymbol class_impl
 // - вообще должно быть так, почему не работает - надо разбираться
 [
  ':' 

  @ class_impl Ctx:SetWordProducerForCompiledClass
  [ '_:' g_CurrentClass ] strings:Cat =: g_CurrentClassImpl

  g_CurrentClassImpl
   if ( g_CurrentClass !== cObjectName ) then
   begin
    '%INHERITS'
    '@' 
    [ '_:' cObjectName ] strings:Cat
    ';'
   end
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 axiom:PushSymbol classExpander
 g_CurrentClassImpl Ctx:Parser:PushSymbol

; // class

MACRO class-end
; // class-end

INTEGER type FieldOffset
// - смещение поля

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 axiom:PushSymbol :
 [ g_CurrentClass ':' aName ] strings:Cat Ctx:Parser:PushSymbol
; // MakeMethodSignature

MACRO constructor
// - конструктор объектов, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 aName |N MakeMethodSignature
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // MakeSelfParam

MACRO method
// - метод объекта, пока "фиктивный"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // method

MACRO readonly
// - read-only свойство объекта, пока "фиктивное"
 Literal IN aName
 @SELF Ctx:SetWordProducerForCompiledClass
 aName |N MakeMethodSignature
 MakeSelfParam
; // readonly

MACRO new[
 axiom:PushSymbol [
 axiom:PushSymbol @
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

MACRO RunCompileFields
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS'
   for g_CurrentClassMembers ( STRING IN aName [ '`' aName '`' ] strings:Cat )
   ';'
  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileFields

MACRO members-end
 axiom:PushSymbol private
 axiom:PushSymbol Const
 [ 'c:' g_CurrentClass ':Instance:Size' ] strings:Cat Ctx:Parser:PushSymbol
 g_ClassFieldOffset Ctx:Parser:PushInt
 axiom:PushSymbol RunCompileFields
; // members-end

class Object

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

VIRTUAL STRING method ToPrintable
 Self ToPrintable =: Result
; // ToPrintable

PRIVATE operator do-get-member
 STRING IN aName
 axiom:PushSymbol FieldByOffset
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
; // do-get-member

MACRO get-member
 Literal IN aName
 aName |N do-get-member
; // get-member

MACRO read
 Literal IN aName
 'Self' Ctx:Parser:PushSymbol 
 aName |N do-get-member
 axiom:PushSymbol =:
 'Result' Ctx:Parser:PushSymbol
 axiom:PushSymbol ;
; // read

INTEGER member VMT
members-end

TtfwWord readonly class read VMT

STRING : getClassName
 IN Self
 Self |N ':' string:Split =: Result DROP
; // getClassName

STRING readonly ClassName
 Self Object:class getClassName =: Result
; // Object:ClassName

class-end // Object

INTEGER type Pixel
// - пиксель
List type PixelList
// - список пикселей

class Point

Pixel member X
Pixel member Y
members-end

constructor :
 Pixel right aX
 Pixel right aY
 new[ aX aY ] =: Result
; // :

constructor 0
 Point:: 0 0 =: Result
; // 0

constructor XY
 PixelList right aPoint
 array var Points
 [ aPoint ] =: Points
 Point:: ( Points FieldByOffset 0 ) ( Points FieldByOffset 1 ) =: Result
; // XY

Pixel readonly X read X

Pixel readonly Y read Y

constructor OF
 Point right aPoint
 Point:: ( aPoint Point:X ) ( aPoint Point:Y ) =: Result
; // OF

Point method +
 Point right aPoint

 Point:: ( Self Point:X (+) ( aPoint Point:X ) ) ( Self Point:Y (+) ( aPoint Point:Y ) ) =: Result
; // +

Point method Neg
 Point:: Neg ( Self Point:X ) Neg ( Self Point:Y ) =: Result
; // Neg

Point method -
 Point right aPoint

 Point:OF ( Self Point:+ ( aPoint Point:Neg ) ) =: Result
; // -

OVERRIDE STRING method ToPrintable
 [ '( ' 'X: ' Self Point:X ToPrintable ', Y: ' Self Point:Y ToPrintable ' )' ] strings:Cat =: Result
; // ToPrintable

void method Print
 Self Point:ToPrintable Print
; // Print

class-end // Point

class Rectangle

Point member TopLeft
Point member BottomRight
members-end

Point readonly TopLeft read TopLeft

Point readonly BottomRight read BottomRight

constructor :
 Point right aTopLeft
 Point right aBottomRight
 new[ aTopLeft aBottomRight ] =: Result
; // :

OVERRIDE STRING method ToPrintable
 [ '( ' 'TopLeft: ' Self Rectangle:TopLeft Point:ToPrintable ', BottomRight: ' Self Rectangle:BottomRight Point:ToPrintable ' )' ] strings:Cat =: Result
; // ToPrintable

void method Print
 Self Rectangle:ToPrintable Print
; // Print

class-end // Rectangle

USES
 CodeDump.ms.dict
;

@SELF DumpElement

Point var P1
Point var P2
Point var P3
Point var P4
Point var P5
Point var P6
Point var P7
Point var P8
Point var P9
Point var P10
Point var P11

P1 := Point:0
P2 := Point:0
P3 := Point:: 1 1
P4 := Point:XY ( 2 2 )
P5 := Point:OF P4
P6 := ( P3 Point:+ P4 )
P7 := ( P3 Point:- P4 )
P8 := ( P4 Point:- P3 )
P9 := ( P4 Point:Neg )
P10 := ( P3 Point:Neg )
P11 := Point:XY ( -2 2 )

Object var O1
O1 := P1
O1 Point:Print

array var l_Points

[ P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 ] =: l_Points

for l_Points Point:Print
for l_Points ( Point:X Print )
for l_Points ( Point:Y Print )
for l_Points ( Object:class Print )
for l_Points ( Object:ClassName Print )
for l_Points ( for ( Object:class %G ) ( getClassName Print ) )

Rectangle var R1
Rectangle var R2
R1 := Rectangle:: P1 P4
R2 := Rectangle:: P6 P7

array var l_Rectangles
[ R1 R2 ] =: l_Rectangles

for l_Rectangles Rectangle:Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

'Hello ' (+) 'world' Print

1 (+) 2 Print
10 (+) 20 Print
0 (-) 10 Print
Neg 10 Print
Neg -10 Print

; // PointTest

PointTest
