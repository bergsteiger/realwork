(*
   Constants for

   DLL HyTech для Win95/NT

   HyTech 2.56  Copyright (c) 1993, 99 by SKAZ_M Ltd
*)

// $Id: HT_Const.pas,v 1.24 2016/10/31 12:51:27 voba Exp $

// $Log: HT_Const.pas,v $
// Revision 1.24  2016/10/31 12:51:27  voba
// no message
//
// Revision 1.23  2016/09/30 13:53:23  voba
// no message
//
// Revision 1.22  2015/08/13 11:36:08  voba
// - new dll
//
// Revision 1.21  2015/03/13 11:55:47  voba
// - локальное автосохранение документов
//
// Revision 1.20  2014/05/21 14:34:30  voba
// - cc
//
// Revision 1.19  2013/04/19 13:10:10  lulin
// - портируем.
//
// Revision 1.18  2013/04/11 16:46:26  lulin
// - отлаживаем под XE3.
//
// Revision 1.17  2012/11/19 11:39:35  voba
// no message
//
// Revision 1.16  2012/11/07 09:42:02  voba
// - убрал поддержку старых библиотек HT
//
// Revision 1.15  2012/09/18 08:15:58  voba
// no message
//
// Revision 1.14  2012/09/13 13:12:17  voba
// no message
//
// Revision 1.13  2012/09/07 14:20:44  voba
// no message
//
// Revision 1.12  2012/05/30 14:13:24  voba
// no message
//
// Revision 1.11  2012/05/11 10:33:32  voba
// - откат
//
// Revision 1.10  2012/05/05 07:48:21  voba
// no message
//
// Revision 1.9  2012/02/01 12:03:46  voba
// no message
//
// Revision 1.8  2011/06/01 07:33:36  voba
// - k : 236721575
//
// Revision 1.7  2009/09/11 08:27:24  voba
// - поменял невзрачное название типа ELEMENT на клевое ThtElementInfo
//
// Revision 1.6  2009/06/23 07:33:59  voba
// - стандартизация доступа к атрибутам
//
// Revision 1.5  2009/04/02 14:05:52  voba
// - bug fix HtErr= -42
//
// Revision 1.4  2008/12/25 10:17:20  fireton
// - перевод спецпоисков на TdtQuery
//
// Revision 1.3  2008/11/21 12:36:41  voba
// no message
//
// Revision 1.2  2008/09/23 08:47:12  voba
// no message
//
// Revision 1.1  2008/02/26 12:30:57  lulin
// - боремся за чистоту арийской рассы.
//
// Revision 1.20  2007/09/19 07:56:27  voba
// no message
//
// Revision 1.19  2007/08/14 14:30:09  lulin
// - оптимизируем перемещение блоков памяти.
//
// Revision 1.18  2007/06/18 07:25:37  voba
// no message
//
// Revision 1.17  2007/04/13 06:51:51  voba
// - bug fix
//
// Revision 1.16  2007/04/10 09:02:53  voba
// - add  ht_MaxBufLen  = MAX_BUF_LEN;
//
// Revision 1.15  2007/03/23 08:49:53  voba
// - merge with b_archi_BigDictID (повторно)
//
// Revision 1.14.2.1  2007/03/22 14:28:49  voba
// - сс
//
// Revision 1.14  2007/03/02 09:49:59  voba
// - bug fix htSubSearch Bug
//
// Revision 1.13  2007/02/22 09:26:37  voba
// - add  ThtField
//
// Revision 1.12  2007/02/16 16:06:36  voba
// - rename type Condition ->ThtCondition
//
// Revision 1.11  2006/12/08 15:23:48  voba
// - rename type Format->htFormat
//
// Revision 1.10  2006/11/07 11:19:40  voba
// - bug fix
//
// Revision 1.9  2006/10/27 07:47:19  voba
// - _move HTDLL
//
// Revision 1.8  2006/10/04 08:40:54  voba
// - merge with b_archi_ht64
//
// Revision 1.7.2.1  2006/09/19 08:38:24  voba
// - переход на HT64
//
// Revision 1.7  2006/09/07 16:08:55  voba
// - add ht_err.inc
//
// Revision 1.6  2006/09/07 10:33:58  voba
// - mode64 support
//
// Revision 1.5  2006/08/23 10:17:25  voba
// - merge with b_archi_ifltr_opt
//
// Revision 1.4.92.1  2006/08/23 07:02:22  voba
// - add const  ht_SizeOfSurrogateKey = 3;(* Длина суррогатного ключа (нулевой элемент записи)в байтах *)
//
// Revision 1.4  2004/01/14 13:53:56  step
// bug fix: устранено дублирование типа
//
// Revision 1.3  2002/01/16 10:42:22  demon
// - some new functions added
//
// Revision 1.2  2000/12/15 15:36:17  law
// - вставлены директивы Log.
//

Unit HT_Const;

Interface

{$I HTDefine.inc}

{$I HT_ERR.inc}

{$Z4}

const
{$IFDEF HT_NEWDLL}
 HTDLL = 'ht32db.dll';
 htDllVersion = '2.7.20.297';
{$ELSE}
 HTDLL = 'hsht64.dll';
 htDllVersion = '2.7.12.226';
{$ENDIF}

(* Эти переменные носят только информационный характер, менять их нельзя *)

 FNAME_LEN      = 10;     (* Длина имени поля в таблице               *)
 TFULL_LEN      = 140;    (* Длина буфера для полного имени таблицы   *)
 TNAME_LEN      = 8;      (* Длина имени таблицы                      *)
 TPATH_LEN      = 128;    (* Длина полного пути на таблицу            *)
 MAX_BUF_LEN    = $FFF0;  (* Максимальная длина буфера для чтения     *)
 ht_MaxBufLen  = MAX_BUF_LEN;
 MAX_REC_LEN    = $FFED;  (* Максимальная длина записи в таблице      *)
 MAX_REC_NUM    = $FFFFFE;(* Максимальное число записей в таблице     *)
 ht_SizeOfSurrogateKey =4;(* Длина суррогатного ключа (нулевой элемент записи)в байтах *)
 MAX_SORT_LEN   = $FFED;  (* Максимальная длина элемента сортировки   *)
 MAX_SORT_ORDER = 63;     (* Максимальное число полей сортировки      *)
 MAX_TAB_ELEM   = 4095;   (* Максимальное число элементов в таблице   *)
 MAX_TAB_LINK   = 64;     (* Максимальное число связанных таблиц      *)
 MAX_TAB_NUM    = 96;     (* Максимальное число обрабатываемых таблиц *)
 CODE_LEN       = 8;      (* Максимальная длина ключа в кодификаторе  *)
 MAX_CODER_CNT  = 255;    (* Максимальное число кодификаторов *)

(* Возможные значения класса элементов *)

 EC_FIELD  = 0; (* Элемент - поле      *)
 EC_GROUP  = 1; (* Элемент - группа    *)
 EC_SUBSTR = 2; (* Элемент - подстрока *)

(* Возможные значения типов ключа для элементов *)

 EK_NOTKEY = 0; (* Элемент не ключ  *)
 EK_COMMON = 1; (* Обычный ключ     *)
 EK_UNIQUE = 2; (* Уникальный ключ  *)
 EK_SURRGT = 3; (* Суррогатный ключ *)

(* Модификаторы атрибутов ключа (допустимы только для полей) *)

 EK_MASK = $C0; (* Маска для отделения модификаторов ключа от типа *)
 EK_AUTO = $40; (* Уникальный ключ является автоинкрементным *)
 EK_NULL = $80; (* Поле (не только ключ) допускает NULL значения *)

(* Возможные значения типа элементов *)

 ET_CHAR = 0;   (* Массив символов длиной не более заданной *)
 ET_ARRA = 1;   (* Массив байтов заданной длины *)
 ET_BYTE = 2;   (* Элемент - короткое целое (1 байт) без знака *)
 ET_INTR = 3;   (* Элемент - целое со знаком *)
 ET_WORD = 4;   (* Элемент - целое без знака *)
 ET_DATE = 5;   (* Дата    - целое без знака *)
 ET_NMBR = 6;   (* Номер   - 3-х байтовое целое без знака *)
 ET_LONG = 7;   (* Элемент - длинное целое со знаком *)
 ET_DWRD = 8;   (* Элемент - длинное целое без знака *)
 ET_FLOA = 9;   (* Элемент - single *)
 ET_CURR =10;   (* Деньги  - double *)
 ET_DFLT =11;   (* Элемент - double *)

(* Константы, используемые при задании режима доступа к таблице *)

 TAB_PRIVATE =  0;    (* Таблица используется в монопольном режиме *)
 TAB_SHARE   =  1;    (* Таблица используется в совместном режиме  *)
 TAB_READ    =  2;    (* Таблица не допускает операций модификации *)
 TAB_CONST   =  4;    (* Работа только с постоянной частью таблицы *)
 TAB_FLUSH   =  8;    (* Немедленная запись данных на диск         *)
 TAB_WRITE   = 16;    (* Спец.режим записи (не допускает поисков)  *)
 TAB_APPEND  = 32;    (* Таблица допускает только добавление       *)
 TAB_ANSI    = 64;    (* Таблица в ANSI-кодировке (при создании)   *)
 TAB_CREATE  =128;    (* Безусловное создание новой таблицы        *)

(* Режимы проверки таблицы *)

 HTVF_INDEX = 1;      (* Проверка целостности индексов ключей *)
 HTVF_DUPS  = 2;      (* Анализ дублей для уникальных ключей  *)
 HTVF_NULL  = 4;      (* Анализ корректности NULL-значений *)

(* Константы, определяющие функции для полей, вычисляемых *)
(* для каждого экземпляра сгруппированных полей.          *)
(* Длина функционала указана в скобках                    *)

 GROUP_AVERAGE =0; (* Среднее значение (LongInt/Double)       *)
 GROUP_COUNT   =1; (* Подсчет числа значений (всегда LongInt) *)
 GROUP_MAX     =2; (* Максимальное значение (по типу поля)    *)
 GROUP_MIN     =3; (* Минимальное значение (по типу поля)     *)
 GROUP_SUM     =4; (* Сумма значений (LongInt/Double)         *)
 GROUP_DISTINCT=5; (* Подсчет числа уникальных значений (всегда LongInt) *)
 GROUP_FIRST   =6; (* Первое значение (по типу поля)    *)
 GROUP_LAST    =7; (* Последнее значение (по типу поля) *)

(* Константы, определяющие режимы обработки неполных пар или групп таблиц *)

 DRAFT_ZERO = 0;  (* Сбор несопадающих групп запрещен *)
 DRAFT_LEFT = 1;  (* Сбор несопадающих групп из левого операнда *)
 DRAFT_RIGHT= 2;  (* Сбор несопадающих групп из правого операнда *)
 DRAFT_ALL  = 3;  (* Сбор несопадающих групп обеих операндов *)

 LINK_AUTO = 0;  (* Автоматическое определение типа связи *)
 LINK_MULT = 4;  (* Всегда "декартовое" произведение *)

(* Режимы выполнения операции *)

 FLT_AUTO = 0; (* Автоматическое определение типа связки *)
 FLT_MULT = 1; (* Всегда "декартовое" произведение таблиц *)
 FLT_DRAFT= 2; (* Допустимо "черновое" связывание таблиц *)

(* Константы, определяющие режим открытия       *)
(* доступа к результатам поиска htOpenResults   *)
(* Могут комбинироваться операцией OR           *)

 ROPEN_READ = 0;    (* Чтение результатов *)
 ROPEN_BODY = 2;    (* Чтение тела записи (без номера) *)
 ROPEN_HNDL = 4;    (* Чтение обработчика вместо физ.номера *)

(* Константы, определяющие тип результатов, хранимых в БДС *)
(* Возвращаются функцией htResultsType                     *)

 RES_PHOTO   = -2;  (* БДС содержит "фотографию" таблицы           *)
 RES_NPROC   = -1;  (* БДС не обработан, или результаты удалены    *)
 RES_RECORD   = 0;  (* БДС содержит список записей                 *)
 RES_VALUE    = 1;  (* БДС содержит список значений ключа          *)
 RES_HISTO    = 2;  (* БДС содержит гистограмму                    *)
 RES_JOIN     = 3;  (* БДС содержит результат слияния таблиц       *)
 RES_SORTED   = 4;  (* БДС содержит отсортированный список записей *)
 RES_GROUP    = 5;  (* БДС содержит результаты операции GROUP_BY   *)
 RES_SORTJOIN = 6;  (* БДС содержит сортированное слияние таблиц   *)

(* Флаги задания режимов системы транзакций *)
(* Устанавливаются в переменной HTCOD1.htTrsMode *)
(* Могут комбинироваться операцией OR *)

 TRS_OFF   =0;  (* Выключить систему транзакций *)
 TRS_ON    =1;  (* Включить систему транзакций *)
 TRS_PREP  =2;  (* Предварительное распределение ресурсов *)
 TRS_FLUSH =4;  (* Немедленная запись журнала транзакции на диск *)
 TRS_ALONE =8;  (* Транзакции на одной локальной машине *)
 TRS_EASY  =1;  (* "Облегченный" режим работы системы транзакций *)
 TRS_HARD  =7;  (* "Полный" режим работы системы транзакций *)

(* Типы регистрируемых в журнале операций *)

 LOG_ADD = 0;   (* Добавление записи  *)
 LOG_DEL = 1;   (* Удаление записи    *)
 LOG_MDF = 2;   (* Модификация записи *)

(*======================== Новые типы ====================*)

Type
 ThtField = SmallInt;           (* номер поля таблицы *)

 CHandle  = SmallInt;           (* Обработчик кодификатора *)
 RHandle  = LongInt;            (* Обработчик для записи   *)
 pRHandle = ^RHandle;           (* Указатель на обработчик *)
 lpRHandle = pRHandle;

 ThtTblHandle = type SmallInt;           (* Обработчик для таблицы  *)
 THandle  = ThtTblHandle;
 pTHandle = ^THandle;            (* Указатель на обработчик *)
 lpTHandle = pTHandle;

// PSmallInt=^SmallInt;           (* Указатель на SmallInt   *) // дублирует System.PSmallInt
 NameStr  = Array[0..TNAME_LEN] of AnsiChar;(* Для хранения имени файла или станции *)
 PathStr  = Array[0..TPATH_LEN] of AnsiChar;(* Для хранения пути на файлы *)

(* Блок Доступа к Сервису (БДС) *)

 SAB=Record
      gFoundCnt:LongInt;               (* Число элементов в результате *)
      nRetCode :SmallInt;              (* Код завершения операции *)
      mPrivate :Array[1..113] of AnsiChar; (* Системные пеpеменные *)
     end;
 pSAB = ^SAB;                         (* Ссылка на БДС *)
 lpSAB = pSAB;                        (* Ссылка на БДС *)
 lppSAB = ^lpSAB;                     (* Адрес ссылки на БДС *)

(* Описатель атрибута таблицы (поля, группы или подстроки *)
(* Эта структура заполняется функцией htTableElement *)

 ThtElementInfo = record
  wLength: Word;              (* Длина элемента *)
  wOffset: Word;              (* Смещение элемента в записи *)
  cClass : Byte;              (* Класс элемента *)
  cType  : Byte;              (* Тип элемента   *)
  cKey   : Byte;              (* Пpизнак ключа  *)
  mName  : Array[0..FNAME_LEN] of AnsiChar; (* Имя элемента (ASCIIZ строка) *)
 end;

 LPELEMENT = ^ ThtElementInfo;

 ThtElementInfoArray = array of ThtElementInfo;

(* Далее следует описание call-back процедур, адреса которых *)
(* могут быть заданы при инициализации СУБД в качестве последних *)
(* членов структуры INIT. Коды сообщений для функций описаны в HTERRS.PAS *)

(* Сообщение об ошибке при выполнении операции *)

 UFERM=Procedure(
                 nMessID:SmallInt  (* Номер сообщения (код завершения) *)
                );
 LPUFERM=^UFERM;

(* Информационное сообщение об ошибке или завершении операции *)

 UFINF=Procedure(
                 nInfoID: SmallInt;  (* Номер информационного сообщения *)
                 gParm1:  LongInt;   (* Первый числовой параметр *)
                 gParm2:  LongInt;   (* Второй числовой параметр *)
                 fpStr:   PAnsiChar      (* Символьный параметр (ASCIIZ строка) *)
                );
 LPUFINF=^UFINF;

(* Сообщение об ошибке В/В *)

 UFIOM=Procedure(
                 fpFileName: PAnsiChar;   (* Имя файла (ASCIIZ строка), вызвавшего ошибку *)
                 nIoCode:    SmallInt;(* Код операции В/В, вызвавшей ошибку *)
                 nDosError:  SmallInt (* Код ошибки, сообщенный DOS *)
                );
 LPUFIOM=^UFIOM;

(* Пользовательские процедуры работы с прогресс-индикатором *)
(* Будут вызываться СУБД при выполнении длительных операций *)

(* Инициализация прогресс-индикатора *)

 UFPIS=Procedure(
                 nPindID: SmallInt;(* Номер сообщения прогресс-индикатора *)
                 dwLimit: Cardinal;(* Предельное число элементов индикатора *)
                 fpName:  PAnsiChar    (* Строковый (ASCIIZ) параметр *)
                );
 LPUFPIS=^UFPIS;

(* Продвижение прогресс-индикатора *)

 UFPID=Procedure(
                 wDelta: Word      (* Очередное число обработанных элементов *)
                );
 LPUFPID=^UFPID;

(* Снятие прогресс-индикатора *)

 UFPIP=Procedure;
 LPUFPIP=^UFPIP;

(* Активизация других процессов *)

 UFYLD=Procedure;
 LPUFYLD=^UFYLD;

(* Call-back функции инициализации по умолчанию *)
(* Для вызова встроенных call-back функций следует *)
(* Задать вместо адресов Nil *)

(* Игнорирование соответствующих call-back функций инициализации *)
(* Для полного запрещения вызова call-back функций следует *)
(* задать вместо адресов Pointer(LongInt(-1)) *)

(* Описатель параметров функции инициализации *)
(* Заполняется до вызова htInit *)

 INIT=Record
       nTableCnt:SmallInt;     (* Число таблиц, с которыми будут работать (1-64) *)
       nTaskCnt:SmallInt;      (* Число файлов, которые может открыть задача *)
       nHtCnt:SmallInt;        (* Число файлов, которые может открыть СУБД *)
       nLockTimeOut:SmallInt;  (* Таймаут разделения ресурсов сети *)
       nPollDelay:SmallInt;    (* Задержка опроса сети (тиков) *)
       nTransTimeOut:SmallInt; (* Таймаут выполнения транзакций *)
       nTrsMode:SmallInt;      (* Режимы механизма транзакций *)
       fpTmpPath: PAnsiChar;       (* Каталог для создания временных файлов *)
       fpNetPath: PAnsiChar;       (* Каталог для сетевых замков *)
       fpNetName: PAnsiChar;       (* Имя станции в сети (до 8 символов) *)
       fpTrtPath: PAnsiChar;       (* Каталог журнала транзакций *)
       fpfInfo:   LPUFINF;     (* Функция информационного сообщения *)
       fpfIoMess: LPUFIOM;     (* Функция сообщения об ошибке В/В *)
       fpfErrMess:LPUFERM;     (* Функция сообщения об ошибке *)
       fpfPiStart:LPUFPIS;     (* Функция инициализации прогресс-индикатора *)
       fpfPiDraw: LPUFPID;     (* Функция продвижения прогресс-индикатора *)
       fpfPiStop: LPUFPIP;     (* Функция снятия прогресс-индикатора *)
       fpfYield:  LPUFYLD;     (* Функция активации других процессов *)
       gHeapCtrl: LongInt;     (* <0 - размер кучи пользователя (остальное - СУБД) *)
          (* =0 - обе кучи по умолчанию *)
          (* >0 - размер кучи СУБД (остальное - пользователю) *)
       gHeapTask: LongInt;     (* Куча экземпляра СУБД для внутреннего использования *)
      end;
 LPINIT = ^INIT;

(* Описатель основных характеристик открытой таблицы *)
(* Эта структура заполняется функцией htTableInfo    *)

 ThtTableInfoRec = Record
        mPath      : PathStr;   (* Полный путь на таблицу *)
        mName      : NameStr;   (* Имя таблицы (без расширения) *)
        nFieldCnt  : SmallInt;  (* Число полей    *)
        nGroupCnt  : SmallInt;  (* Число групп    *)
        nSubstrCnt : SmallInt;  (* Число подстрок *)
        wRecordLen : Cardinal;  (* Длина записи таблицы *)
        nFlags     : Integer;   (* Флаги таблицы (см.константы TAB_????) *)
 end;

 TABLE = ThtTableInfoRec;
 LPTABLE=^TABLE;

(* Состояние открытой таблицы *)
(* Эта структура заполняется функцией htTableState() *)

 STATT=Record
        gConstCnt  : LongInt;   (* Число записей в постоянной части таблицы *)
        gAddedCnt  : LongInt;   (* Число добавленных записей  *)
        gChangedCnt: LongInt;   (* Число измененных записей   *)
        gDeletedCnt: LongInt;   (* Число удаленных записей    *)
       end;
 LPSTATT=^STATT;

(* Описатель открытого заголовка таблицы (.HTB) *)
 THEAD=Record
        wRecordLen: Word;		(* Длина записи *)
        nElemCnt:   SmallInt;		(* Общее число элементов *)
        nFieldCnt:  SmallInt;		(* Число полей *)
        nKeyCnt:    SmallInt;		(* Число ключей *)
        bAnsi:      SmallInt;		(* Таблица в ANSI-кодировке *)
        nCnstState: SmallInt;		(* Состояние области данных *)
        nDiffState: SmallInt;		(* Состояние журнала изменений *)
        bIndexed:   SmallInt;		(* Имеются индексы *)
        nRights:    SmallInt;		(* Разрешенные действия *)
        mSystem: Array [1..2] of AnsiChar; (* Будет использоваться СУБД *)
       end;

(* Константы, определяющие реакцию на ошибку *)
(* при пакетных операциях. *)

 ERROR_MODE=(
             ERROR_ABORT,     (* Прервать операцию *)
             ERROR_REPEAT,    (* Повторить обработку *)
             ERROR_DELETE     (* Удалить запись *)
            );

(* Прототип пользовательской функции, вызываемой при     *)
(* обнаружении ошибки в процессе обработки пачки записей *)
(* (добавление, модификация, вывод в таблицу).           *)

 EFUNC=Function(
                nErrCode: SmallInt;    (* Код ошибки *)
                fpRecord: Pointer;     (* Тело "плохой" записи для анализа *)
                fpUser  : Pointer      (* Доп.параметр пользователя *)
               ):ERROR_MODE;
 LPEFUNC=^EFUNC;

 ADD_MODE=(
           ADD_FIRST,         (* Первый вызов (сигнал к инициализации) *)
           ADD_NEXT,          (* Очередной вызов *)
           ADD_LAST           (* Последний вызов (завершение обработки) *)
          );

(* Описатель автоинекрементного ключа *)
(* для доступа к данным в сборке значений *)

 AUTO=Record
       nType:   SmallInt;    (* Тип данных *)
       nLength: SmallInt;    (* Длина ключа *)
       nKeyNum: SmallInt;    (* Номер ключа (от 1) *)
       wOffset: Cardinal;    (* Смещение в сборке значений *)
       acResrvd: Array[1..12] of Byte;
      end;
 LPAUTO=^AUTO;

(* Описатель, используемый при добавлении пачки записей *)
(* Эта структура передается как параметр при вызове     *)
(* пользовательской функции из функции htAddRecords     *)
 APARM=Record
        fpBuf     : Pointer;      (* Буфер для записей *)
        wBufLen   : Cardinal;     (* Длина буфера *)
        wRecordLen: Cardinal;     (* Длина записи *)
       (* Следующие члены заполняются для первой записи пачки *)
        gFirstRecNum: LongInt;    (* Номер для первой записи пачки *)
        dFirstSurrogate:Cardinal; (* Значение суррогатного ключа для первой записи *)
        nAutoCnt: SmallInt;       (* Число автоинкрементных ключей *)
        fpAuto: LPAUTO;     (* Описатели автоинкрементных ключей *)
        pFirstAuto: Pointer;      (* Сборка значений автоинкрементных ключей *)
       end;
 LPAPARM = ^APARM;

(* Прототип пользовательской функции, вызываемой для *)
(* подготовки очередной пачки добавляемых записей.   *)
(* Функция должна заполнить предоставленный буфер    *)
(* добавляемыми записями. Длина буфера задана.       *)
(* Функция должна возвращать:                        *)
(*   длину заполненной части буфера (в байтах);      *)
(*   0 при необходимости прервать процесс обработки. *)

 AFUNC=Function(
                nOrder: ADD_MODE;  (* Порядок вызова *)
                fpParm: LPAPARM;   (* Параметры пачки записей *)
                fpUser: Pointer    (* Доп.параметр пользователя *)
               ):Cardinal; stdcall;
 LPAFUNC = ^AFUNC;


 MFUNC_RET = (
              MFUNC_ABORT,        //* Прервать процесс модификации */
              MFUNC_SUCCESS       //* Запись модифицирована */
            );
const
 BoolToMFUNC_RET : array[Boolean] of MFUNC_RET = (MFUNC_ABORT, MFUNC_SUCCESS);

type
(* Прототип пользовательской функции, вызываемой для каждой *)
(* записи. Функция должна выполнить требуемые действия по   *)
(* модификации записи. Функция возвращает значения:         *)
(*  false - прервать процесс модификации                    *)
(*  true  - запись модифицирована                           *)

 MFUNC=Function(
                gRecNo  : LongInt;     (* Номер модифицируемой записи *)
                fpRecord: Pointer;     (* Тело модифицируемой записи *)
                fpUser  : Pointer      (* Доп.параметр пользователя *)
               ) : MFUNC_RET; stdcall;
 LPMFUNC = ^MFUNC;

 CFUNC_RET = (
              CFUNC_FALSE,        //* Элемент не подходит */
              CFUNC_TRUE          //* Элемент подходит */
             );
const
 BoolToCFUNC_RET : array[Boolean] of CFUNC_RET = (CFUNC_FALSE, CFUNC_TRUE);

type
(* Прототип пользовательской функции, вызываемой для каждого       *)
(* значения искомого элемента записи. Функция возвращает значения: *)
(*  1 - элемент подходит *)
(*  0 - элемент не подходит *)

 CFUNC=Function(
                fpItem: Pointer;   (* Тело проверяемого элемента записи *)
                fpUser: Pointer    (* Доп.параметр пользователя *)
               ) : CFUNC_RET; stdcall;
 LPCFUNC = ^CFUNC;

(* Константы, определяющие условие поиска по одному элементу записи *)
(* (2) - требуется два пороговых значения                           *)

 ThtCondition=(
            EMPTY_COND,   (* Такого условия нет - незначащий код *)
            BETWEEN,      (* (2) Значения элемента лежат в диапазоне (исключающее)  *)
            EQUAL,        (* Значения элемента равны заданному                      *)
            GREAT,        (* Значения элемента больше заданного                     *)
            GREAT_EQUAL,  (* Значения элемента больше или равны заданному           *)
            IN_RANGE,     (* (2) Значения элемента лежат в диапазоне (включающее)   *)
            LESS,         (* Значения элемента меньше заданного                     *)
            LESS_EQUAL,   (* Значения элемента меньше или равны заданному           *)
            NOT_BETWEEN,  (* (2) Значения элемента лежат вне диапазона (включающее) *)
            NOT_EQUAL,    (* Значения элемента не равны заданному                   *)
            NOT_GREAT,    (*  Значения элемента не больше заданного                 *)
            NOT_IN_RANGE, (* (2) Значения элемента лежат вне диапазона (исключающее)*)
            NOT_LESS,     (* Значения элемента не меньше заданного                  *)
            WILDCARD,     (* Значения символьного элемента совпадают с шаблоном     *)
            WILDCASE,     (* Значения элемента совпадают с шаблоном без учета регистра *)
            USER_DEF      (* Значения элемента удовлетворяют критерию пользователя *)
           );

(* Прототип пользовательской функции-фильтра   *)
(* для реализации HAVING_TO групповой операции *)
(* Возвращает:                                 *)
(*     true  - элемент подходит                *)
(*     false - элемент не подходит             *)

 HAVING = Function(
                   fpGroupBody: Pointer; (* Тело группы и функционалов *)
                   fpUser     : Pointer (* Доп.параметр пользователя  *)
                  ):Boolean;
 LPHAVING = ^HAVING;

(* Описатель поля для групповой операции               *)
(* Используется при вызове функции htGroupByHavingTo   *)

 GROUP=Record
        nField : SmallInt;              (* Номер поля                *)
        nType  : SmallInt;              (* Тип функции для поля GROUP_??? *)
        mSystem: Array [1..36] of AnsiChar; (* Будет использоваться СУБД *)
       end;
 LPGROUP = ^GROUP;

(* Прототип пользовательской функции, вызываемой для сравнения *)
(* пары элементов. Функция возвращает значения:                *)
(*  <0 - первый элемент меньше второго *)
(*  =0 - элементы равны                *)
(*  >0 - первый элемент больше второго *)

 OFUNC=Function(
                fpFirst : Pointer;     (* Адрес первого элемента *)
                fpSecond: Pointer;     (* Адрес второго элемента *)
                fpUser  : Pointer      (* Доп.параметр пользователя *)
               ):Integer; stdcall;
               // было SmallInt, но так не работает, если код в функции портит верхнюю половину EAX
 LPOFUNC = ^OFUNC;

(* Прототип пользовательской функции, вызываемой   *)
(* при фильтрации подмножества записей.            *)
(* Функция должна возвращать:                      *)
(*  1 - запись удовлетовряет условию фильтрации    *)
(*  0 - запись не удовлетворяет условию фильтрации *)
(* -1 - прекратить фильтрацию на текущем элементе  *)

 SFUNC = Function(
                  gRecNo : LongInt;  (* Номер анализируемой записи или элемента *)
                  fpField: Pointer;  (* Значения отобранных полей для анализа *)
                  fpUser : Pointer   (* Доп.параметр пользователя *)
                 ): SmallInt;
 LPSFUNC = ^SFUNC;

 LINK=Record
       nFiTab :SmallInt; (* Индекс первой таблицы в группе (от 0) *)
       nFiKey :SmallInt; (* Номер элемента-связки в первой таблице *)
       nScTab :SmallInt; (* Индекс второй таблицы в группе (от 0) *)
       nScKey :SmallInt; (* Номер элемента-связки во второй таблице *)
      end;
 LPLINK = ^LINK;

(* Описатель поля отбора в открытом результате *)

 OPEL=Record
       nType:  SmallInt; (* Тип поля *)
       nNum:   SmallInt; (* Номер поля *)
       wLen:   Cardinal; (* Длина поля *)
       wOff:   Cardinal; (* Место вывода среди других полей *)
       hCoder: CHANDLE;  (* Кодификатор поля *)
      end;
 LPOPEL=^OPEL;

(* Константы, определяющие режим перемещения логического *)
(* указателя по результатам поиска htSeekResults         *)

 RSEEK_MODE=(
             RSEEK_SET,     (* От начала                                    *)
             RSEEK_CUR,     (* От текущей позиции                           *)
             RSEEK_END,     (* От конца                                     *)
             RSEEK_REC      (* Установиться на запись, заданную физ.номеpом *)
            );

(* Описатель маркера записи в открытом результате *)

 MARKER=Record
         hTable: THANDLE;  (* Таблица, которой принадлежит запись *)
         hRecord:RHANDLE;  (* Обработчик помеченной записи *)
        end;
 LPMARK=^MARKER;

 ThtMarker = MARKER;

(* Описатель, используемый при обработке записей        *)
(* Эта структура передается как параметр при вызове     *)
(* пользовательской функции из функции htResultsToTable *)

 RPARM=Record
        gDstRecNum : LongInt; (* Номер текущей образуемой записи   *)
        gSrcItemNum: LongInt; (* Номер текущего исходного элемента *)
        wDstRecLen : Cardinal;(* Длина образуемой записи  *)
        wSrcItemLen: Cardinal;(* Длина исходного элемента *)
        fpSrcItem  : Pointer; (* Тело исходного элемента  *)
        fpDstRec   : Pointer; (* Буфер для приема образуемой записи *)
       end;

(* Прототип пользовательской функции, вызываемой   *)
(* при обработке результатов для каждой записи.    *)
(* Функция должна возвращать:     *)
(* >0 - преобразование выполнено  *)
(* =0 - прекратить процесс вывода *)
(* <0 - пропустить данную запись  *)

 RFUNC=Function(
                Var fpParm: RPARM;  (* Параметры вывода *)
                fpUser    : Pointer (* Доп.параметр пользователя *)
               ):SmallInt;
 LPRFUNC=^RFUNC;

(* Описатель идентифкатора транзакции *)
(* Эта запись используется функциями управления транзакциями *)

 TRID=Record
       mTrID: Array [1..6] of Byte;  (* Идентификатор транзакции *)
      end;

(* Описатель поля чтения *)
(* Используется при открытии доступа к кодированным записям *)
(* для указания отбираемых полей и порядка их расположения. *)

 CDF=Record
      nFieldNum :SmallInt;     (* Номер поля *)
      hCoder    :CHANDLE;    (* Кодификатор для поля (0 - нет кодификатора) *)
     end;
 LPCDF=^CDF;           (* Длинная ссылка на описатель *)

(* Информация о кодификаторе *)

 CODINF=Record
         wItemCnt :Cardinal; (* Число элементов в кодификаторе *)
         nItemLen :SmallInt; (* Длина элемента в кодификаторе *)
         nKeyType :SmallInt; (* Тип ключа кодификатора *)
         nKeyLen  :SmallInt; (* Длина ключа кодификатора *)
         nNameLen :SmallInt; (* Длина толкования *)
         pArray   :Pointer;    (* Массив ключ-толкование *)
        end;

(* Варианты отображения даты в символьном виде *)
(* Используются в описателе формата при операциях импорта/экспорта *)

 DATES=(
        DATE1,  (* дд мм гг - Израиль *)
        DATE2,  (* дд-мм-гг - Великобритания *)
        DATE3,  (* дд.мм.гг - Германия *)
        DATE4,  (* дд/мм/гг - Россия *)
        DATE5,  (* мм-дд-гг - Америка *)
        DATE6,  (* гг-мм-дд - Азия *)
        DATE7 (* ггггммдд - dBase *)
       );

(* Варианты выходных файлов экспорта *)
 EXPMODE=(
          EXP_ASCII,  (* Выходный файл - текстовый файл *)
          EXP_DBASE   (* Выходный файл - файл dBaseIII  *)
         );

(* Варианты исходных файлов импорта *)

 IMPMODE=(
          IMP_ASCII,  (* Исходный файл - регулярный текстовый файл *)
          IMP_DBASE,  (* Исходный файл - файл dBaseIII   *)
          IMP_HYTECH  (* Исходный файл - файл HyTech 1.6 *)
         );

(* Формат вывода FLOAT (например '%- 10.2f') *)
(* '%' - признак форматирования *)
(* '-' - выравнивание вправо (иначе - влево)      *)
(* ' ' - заполнитель при выравнивании (можно '0') *)
(* '10' - общая ширина вывода числа - 10 символов *)
(* '.2' - точность (число десятичных разрядов)    *)
(* 'f'  - вывод с фиксированной точкой *)

 FLOAT_FMT = Array [0..8] Of AnsiChar;

(* Формат вывода DOUBLE (например '%- 12.6lE') *)
(* '%' - признак форматирования *)
(* '-' - выравнивание вправо (иначе - влево)      *)
(* ' ' - заполнитель при выравнивании (можно '0') *)
(* '12' - общая ширина вывода числа - 12 символов *)
(* '.6' - точность (число десятичных разрядов)    *)
(* 'l'  - числой двойной точности (double)        *)
(* 'E'  - число будет иметь десятичный порядок (можно 'e') *)

 DOUBLE_FMT = Array [0..9] Of AnsiChar;

(* Описатель параметров преобразования символьных и цифровых *)
(* данных при импорте/экспорте *)

 htFormat = Record
             nDateType : SmallInt; (* Тип даты (DATES) *)
             bCentury  : SmallInt; (* Полный год, если TRUE *)
             mFloatFormat:FLOAT_FMT;     (* Формат вывода float *)
             mDoubleFormat:DOUBLE_FMT;   (* Формат вывода double *)
             mCurrencyFormat:DOUBLE_FMT; (* Формат вывода currency *)
            end;
 PhtFORMAT = ^htFORMAT;

(* Описатель доступа к журналу изменений *)

 LOGON=Record
        wItemLen: Cardinal;        (* Длина читаемого элемента журнала *)
        gItemCnt: LongInt;       (* Число элементов в журнале *)
        mSystem: Array [1..143] of AnsiChar; (* Будет использоваться СУБД *)
       end;

(* Режимы капитализации регистра симоволов строки *)

 CASE_MODE = (
              CASE_NATIVE,  (* Сохранить исходный регистр символов *)
              CASE_ANSI_UP,   (* Капитализировать в ANSI *)
              CASE_OEM_UP   (* Капитализировать в OEM *)
             );

(* Для преобразования даты в/из внутреннего представления.     *)
(* Дата хранится в записи в виде целого числа без знака,       *)
(* определяющего номер дня, считая от 01.01.1900 (понедельник).*)
(* Для получения дня недели - взять остаток от деления даты на *)
(* 7 (0-воскресенье, 1 - понедельник и т.п.).                  *)

 DATE=Record
       Day  : Byte;      (* День  - отсчет от 1 *)
       Month: Byte;      (* Месяц - отсчет от 1 *)
       Year : SmallInt;  (* Год   - в виде 1993 *)
      end;

(* Одно изменение таблицы *)

 CHANGER=Record
          gNumber:LongInt;  (* Физ.номер *)
          hRecord:RHANDLE;  (* Обработчик записи *)
         end;
 LPCHANGER=^CHANGER;

(* Описатель хозяина таблицы или ее части *)

 OWNER=Record
        nOrdinal:SmallInt;   (* Порядковый номер экземпляра *)
        szUser:  NameStr;   (* Имя станции в сети *)
       end;
 ThtLockOwner = OWNER;
Implementation
End.
