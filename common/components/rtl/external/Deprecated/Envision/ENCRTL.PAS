{----------------------------------------------------------------------------
|
| Library: Envision
|
| Module: EnCRtl
|
| Description: C language run-time library routines required by external
|              OBJ files.
|
| History: Oct 18, 1998. Michel Brazeau, first version
|
|---------------------------------------------------------------------------}
unit EnCRtl;

{$I Envision.Inc}

interface

uses
    Windows,  { for DWord, MessageBox }
    SysUtils; { for IntToStr, PByteArray  }


function _malloc(Size : Integer): Pointer; cdecl;
procedure _free(Ptr : Pointer); cdecl;
function _calloc(NItems : Integer; Size : Integer) : Pointer; cdecl;
function _realloc(block : Pointer; Size : Integer) : Pointer; cdecl;

function _strcat(Dest, Source: PChar): PChar; cdecl;
function _strlen(P1: PChar): Integer; cdecl;
function _strcpy(Dest, Source: PChar): PChar; cdecl;
function _strncmp( const s1 : Pchar;
                   const s2 : Pchar; maxlen : Integer) : Integer; cdecl;
function _strncpy( dest : Pchar;
                   const src : Pchar; maxlen : Integer) : PChar; cdecl;
function _strtok(const s1 : PChar; const s2 : PChar) : PChar; cdecl;

function _tolower( ch : Integer ) : Integer; cdecl;

procedure _memset(P: Pointer; Value: Integer; Count: Cardinal); cdecl;

function _memcpy(Dest, Source: Pointer; Len: Integer): Pointer; cdecl;
function _memcmp( const s1   : PByteArray;
                  const s2   : PByteArray;
                  const Size : Integer  ): Integer; cdecl;

function _ltoa(Value : LongInt; Str : PChar; Radix : Integer) : PChar; cdecl;
function _exp( value : double ) : double; cdecl;
function _floor( value : double ) : double; cdecl;
function _log( value : double ) : double; cdecl;
function _sqrt( value : double ) : double; cdecl;
function _fabs( value : double) : double; cdecl;
function _pow( x : double; y : double ) : double; cdecl;

procedure __turboFloat; cdecl;
procedure __streams; cdecl;

{--------------------------------------------------------------------------}

function _sprintf( buffer : PChar; const format : PChar ) : Integer; cdecl;
function _wsprintfA( buffer : PChar; const format : PChar ) : Integer; cdecl;
{ printf simply shows a message box for format }
function _printf(const format : PChar) : Integer; cdecl;

procedure _exit( status : integer ); cdecl;
procedure __assert( test : integer ); cdecl;

{ not really a C function but added to replace _ftol which is a mysterious
  function generated by the C compiler with implicit float to long
  type casts ie, longValue = float(floatValue). The C source code must
  be adapted to replace all typecasts with round(). }
function _round( value : double ) : Longint; cdecl;

function  _setjmp( jmpb : Byte ) : Integer; cdecl;
procedure _longjmp( jmpb : Byte; RetVal : Integer); cdecl;

{ standard I/O with TStream ! A FILE* type in C is passed a
  Pointer(Stream). }

function _fread( Ptr    : Pointer;
                 Size   : Cardinal;
                 Count  : Cardinal;
                 Stream : Pointer ) : Cardinal; cdecl;

function _fwrite( Ptr    : Pointer;
                  Size   : Cardinal;
                  Count  : Cardinal;
                  Stream : Pointer ) : Cardinal; cdecl;

function _fflush(Stream : Pointer ) : Integer; cdecl;

function _ferror(Stream : Pointer ) : Integer; cdecl;

(*
function __fgetc( Stream : Pointer ) : Integer; cdecl;

function __fputc( C      : Integer;
                  Stream : Pointer ) : Integer; cdecl;
*)

function _fclose( Stream : Pointer ) : Integer; cdecl;

{ fdopen is passed a TStream typecasted to an integer, and simply
  returns the TStream as a pointer. }
function _fdopen(handle : Integer; mode : PChar) : Pointer; cdecl;


{ file access using C io functions. handle is a TStream casted to an
  integer }
function _open(const path : PChar; access : Integer ) : Integer; cdecl;
function _close(handle : Integer) : Integer; cdecl;
function _lseek(handle : Integer; offset : LongInt; fromwhere : Integer) : LongInt; cdecl;
function _read(handle : Integer; buf : Pointer; Len : Cardinal) : Integer; cdecl;
function _write(handle : Integer; buf : Pointer; Len : Cardinal) : Integer; cdecl;


procedure _RaiseDelphiException( Msg : PChar ); cdecl;

{ for debugging }
procedure _ShowIntValue( Msg   : PChar;
                         Value : Integer ); cdecl;


implementation

uses
    Dialogs,  { for ShowMessage }
    Classes,  { for TStream }
    EnMisc;   { for AreFlagsSet }

{--------------------------------------------------------------------------}

procedure _exit( status : integer );
begin
    raise Exception.Create( 'C RTL exit called');
end;

{--------------------------------------------------------------------------}

function _malloc(Size : Integer): Pointer;
begin
    GetMem(Result, Size);
end;

{--------------------------------------------------------------------------}

function _calloc(NItems : Integer; Size : Integer) : Pointer;
var
    Total : LongInt;
begin
    if Size = 0 then
        Result := nil
    else
    begin
        Total := NItems*Size;
        GetMem(Result, Total);
        FillChar( Result^, Total, 0);
    end;
end;

{--------------------------------------------------------------------------}

function _realloc(block : Pointer; Size : Integer) : Pointer;
begin
    if Size = 0 then
    begin
        FreeMem(Block);
        Result := nil;
    end
    else
    begin
        Result := block;
        ReallocMem(Result, Size);
    end;
end;

{--------------------------------------------------------------------------}

procedure _free(Ptr : Pointer);
begin
    FreeMem(Ptr);
end;

{--------------------------------------------------------------------------}

function _strcat(Dest, Source: PChar): PChar;
begin
  Result := SysUtils.strcat(Dest, Source);
end;

{--------------------------------------------------------------------------}

function _strlen(P1: PChar): Integer;
begin
  Result := SysUtils.StrLen(P1);
end;

{--------------------------------------------------------------------------}

function _memcpy(Dest, Source: Pointer; Len: Integer): Pointer;
begin
  Move(Source^, Dest^, Len);
  Result := Dest;
end;

{--------------------------------------------------------------------------}

function _memcmp( const s1   : PByteArray;
                  const s2   : PByteArray;
                  const Size : Integer  ): Integer;
var
    Index : Integer;
begin
    Result := 0;

    for Index := 0 to (Size-1) do
    begin
        if s1^[Index] < s2^[Index] then
        begin
            Result := -1;
            Exit;
        end;

        if s1^[Index] > s2^[Index] then
        begin
            Result := 1;
            Exit;
        end;
    end;
end;

{--------------------------------------------------------------------------}

procedure _memset(P: Pointer; Value: Integer; Count: Cardinal);
begin
    FillChar(P^, Count, Value);
end;

{--------------------------------------------------------------------------}

function _strcpy(Dest, Source: PChar): PChar;
begin
  Result := StrCopy(Dest, Source);
end;

{--------------------------------------------------------------------------}

function _strncmp( const s1 : Pchar;
                   const s2 : Pchar; maxlen : Integer) : Integer;
begin
    Result := StrLComp(S1, S2, MaxLen);
end;

{--------------------------------------------------------------------------}

function _strncpy( dest : Pchar;
                   const src : Pchar; maxlen : Integer) : PChar;
begin
    Result := StrLCopy(Dest, Src, MaxLen);
end;

{ Pascal implementation of strtok.

Newsgroups: comp.lang.pascal.delphi.misc
Subject: Re: String Tokenizer for Delphi...
From: Dave Cameron <davec@mstone.demon.co.uk>
Date: Tue, 29 Aug 95 09:35:58 GMT

 Separate tokens in NULL-terminated ANSI string
 This is an untested version of the 'C' 'StrTok' function for the
 Windows ANSI character set (should work with 2-byte character codes)
}

{ strtok may be affected by the previous call to strtok when s1 is nil.
  This is why a file level variable is used. }
var
    AnsiTokPtr: PChar;

function _strtok(const s1 : PChar; const s2 : PChar) : PChar;

var
    TokStart : PChar;
    P        : PChar;

    function IsDelim( C: char ) : Bool;
    var
      D   : PChar;
      res : Bool;
    begin
      D   := s2;
      res := FALSE;
      repeat
          if( C = D^ ) then
              res := TRUE;
          D := AnsiNext( D );
      until( ( D^ = Char(0) ) or res );

      IsDelim := res;
    end;

begin
    if( s1 <> nil ) then
        AnsiTokPtr := s1;

    { Initialise running pointer }
    P := AnsiTokPtr;

    { Scan for start of token }
    while( IsDelim( P^ ) ) do
        P := AnsiNext( P );
    if( P^ = Char(0) ) then
        TokStart := nil
    else
        TokStart := P;

    { Scan for end of token }
    while( ( P^ <> Char(0) ) and not IsDelim( P^ ) ) do
        P := AnsiNext( P );

    { Update the token string pointer and terminate the token string }
    AnsiTokPtr := AnsiNext( P );
    P^ := #0;

    { Return pointer to token }
    _strtok := TokStart;
end;

{--------------------------------------------------------------------------}

function _tolower( ch : Integer ) : Integer;
var
    Str1 : String[1];
begin
    Str1[0] := #1;
    Str1[1] := Char(Ch);
    Result  := Integer(LowerCase(Str1)[1]);
end;

{--------------------------------------------------------------------------}

function _sprintf( buffer : PChar; const format : PChar ) : Integer;
begin
    { in C, this function has a variable number of parameters, which are
      not accessible in pascal }
    StrCopy( buffer, format );
    Result := StrLen(format);
end;

{--------------------------------------------------------------------------}

function _wsprintfA( buffer : PChar; const format : PChar ) : Integer;
begin
    { in C, this function has a variable number of parameters, which are
      not accessible in pascal }
    Result := _sprintf( buffer, format );
end;

{--------------------------------------------------------------------------}

function _printf(const format : PChar) : Integer;
begin
    Windows.MessageBox( 0, format, nil, MB_OK );
    Result := StrLen(format);
end;

{--------------------------------------------------------------------------}

procedure __turboFloat;
begin
    { I'm really not sure what this function does but the C obj files make a
      call to it. It does not seem to have any effect. From the BC3.1 RTL:


    Description   The functions described above are essentially used by scanf
                  functions family. As for  _realcvt, these functions are not
                  called  directly, but  via a  pointer to  function. This is
                  done  in  order  to  include  the  real  conversion only if
                  needed.

                  Each  time the  compiler needs  to build  a reference  to a
                  double or  float value, it generates  an external reference
                  to __turboFloat which forces this module to be linked in.

    }
end;

{--------------------------------------------------------------------------}

procedure __streams;
begin
    { I'm really not sure what this function does but the C obj files make a
      call to it. }
end;

{--------------------------------------------------------------------------}

procedure __assert( test : integer );
begin
    raise Exception.Create( 'C RTL assert failed: ' + IntToStr(test));
end;

{--------------------------------------------------------------------------}

function _round( value : double ) : Longint;
begin
    { the function _ftol generated implcitely by the C compiler is really
      a Trunc rather than a Round. This was discovered with the gamma
      correction not properly working with the PngLib. }
    Result := Trunc(Value);
end;

{--------------------------------------------------------------------------}

function _exp( value : double ) : double;
begin
    Result := Exp(Value);
end;

{--------------------------------------------------------------------------}

function _floor( value : double ) : double;
begin
    Result := Trunc( value );
end;

{--------------------------------------------------------------------------}

function _log( value : double ) : double;
begin
    Result := Ln(Value);
end;

{--------------------------------------------------------------------------}

function _sqrt( value : double ) : double;
begin
    Result := Sqrt(value);
end;

{--------------------------------------------------------------------------}

function _fabs( value : double) : double;
begin
    Result := System.Abs(value);
end;

{--------------------------------------------------------------------------}

function _pow( x : double; y : double ) : double;
begin
    if X <= 0 then
        Result := 0
    else
        Result := Exp(Y * Ln(X))
end;

{--------------------------------------------------------------------------}

function _ltoa(Value : LongInt; Str : PChar; Radix : Integer) : PChar;
var
    PStr : String[20];
begin
    { only base 10 supported }
    PStr   := IntToStr(Value);
    Result := StrPCopy(Str, PStr);
end;

{--------------------------------------------------------------------------}

function _setjmp( jmpb : Byte ) : Integer;
begin
    Result := 0;
end;

{--------------------------------------------------------------------------}

procedure _longjmp( jmpb : Byte; RetVal : Integer);
begin
    raise Exception.Create('Error: C RTL longjmp called');
end;

{--------------------------------------------------------------------------}

function _fread( Ptr    : Pointer;
                 Size   : Cardinal;
                 Count  : Cardinal;
                 Stream : Pointer ) : Cardinal;
begin
    { MB Aug 09, 1999. Continue using Read instead of ReadBuffer, because
      with the JPEG library it is a normal condition to attempt to read
      beyond the end of the stream }
    Result := TStream(Stream).Read(Ptr^, Size*Count);
end;

{--------------------------------------------------------------------------}

function _fwrite( Ptr    : Pointer;
                  Size   : Cardinal;
                  Count  : Cardinal;
                  Stream : Pointer ) : Cardinal; cdecl;
begin
    { MB Aug 9, 1999. Use WriteBuffer instead of Write which will raise
      an exception if out of disk space. }
    TStream(Stream).WriteBuffer(Ptr^, Size*Count);

    Result := Size*Count;
end;

{--------------------------------------------------------------------------}

(*
function __fgetc( Stream : Pointer ) : Integer;
var
    TempByte : Byte;
begin
    TStream(Stream).Read(TempByte, SizeOf(TempByte));
    Result := TempByte;
end;

{--------------------------------------------------------------------------}

function __fputc( C       : Integer;
                 Stream  : Pointer ) : Integer;
var
    TempByte : Byte;
begin                      
    TempByte := C;
    TStream(Stream).Write(TempByte, SizeOf(TempByte));
    Result := C;
end;
*)

{--------------------------------------------------------------------------}

function _fflush(Stream : Pointer ) : Integer;
begin
    Result := 0;
end;

{--------------------------------------------------------------------------}

function _ferror(Stream : Pointer ) : Integer;
begin
    Result := 0;
end;

{--------------------------------------------------------------------------}

function _fclose( Stream : Pointer ) : Integer;
begin
    Result := 0;
end;

{--------------------------------------------------------------------------}

function _fdopen(handle : Integer; mode : PChar) : Pointer;
begin
    Result := Pointer(Handle);
end;

{--------------------------------------------------------------------------}

function _open(const path : PChar; access : Integer ) : Integer;
const
    O_RDONLY    =     0;
    O_WRONLY    =     1;
    O_RDWR      =     2;
    O_CREAT     = $0100;
    O_TRUNC     = $0200;
    O_EXCL      = $0400;
    O_APPEND    = $0800;

var
    Stream : TFileStream;
    Mode   : Word;
begin
    Mode := 0;

    if AreFlagsSet(O_CREAT or O_TRUNC, access) then
        Mode := Mode or fmCreate;

    if AreFlagsSet(O_EXCL, access) then
        Mode := Mode or fmShareExclusive;

    if AreFlagsSet( O_RDONLY, access ) then
        Mode := Mode or fmOpenRead;

    if AreFlagsSet( O_WRONLY, access ) then
        Mode := Mode or fmOpenWrite;

    if AreFlagsSet( O_RDWR, access ) then
        Mode := Mode or fmOpenReadWrite;

    Stream := TFileStream.Create(StrPas(path), Mode);

    if AreFlagsSet(O_APPEND, access) then
        Stream.Seek( 0, soFromEnd);

    Result := Integer(Stream);
end;

{--------------------------------------------------------------------------}

function _close(handle : Integer) : Integer;
begin
    try
        TStream(Handle).Free;
        Result := 0;
    except
        Result := -1;
    end;
end;

{--------------------------------------------------------------------------}

function _lseek(handle : Integer; offset : LongInt; fromwhere : Integer) : LongInt;
const
    SEEK_CUR   =  1;
    SEEK_END   =  2;
    SEEK_SET   =  0;
var
    Origin : Word;
begin
    case fromwhere of
        SEEK_END : Origin := soFromEnd;
        SEEK_SET : Origin := soFromBeginning;
        else
            Origin := soFromCurrent;
    end;

    Result := TStream(Handle).Seek(Offset, Origin);
end;

{--------------------------------------------------------------------------}

function _read(handle : Integer; buf : Pointer; Len : Cardinal) : Integer;
begin
    Result := TStream(Handle).Read(Buf^, Len);
end;

{--------------------------------------------------------------------------}

function _write(handle : Integer; buf : Pointer; Len : Cardinal) : Integer;
begin
    Result := TStream(Handle).Write(Buf^, Len);
end;

{--------------------------------------------------------------------------}

procedure _RaiseDelphiException( Msg : PChar );
begin
    raise Exception.Create(Msg);
end;

{--------------------------------------------------------------------------}

procedure _ShowIntValue( Msg   : PChar;
                         Value : Integer );
begin
    ShowMessage(Msg + ' = ' + IntToStr(Value));
end;

{--------------------------------------------------------------------------}

end.
