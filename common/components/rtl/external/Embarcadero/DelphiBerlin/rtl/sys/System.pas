{*******************************************************}
{                                                       }
{           CodeGear Delphi Runtime Library             }
{                                                       }
{ Copyright(c) 2016 Embarcadero Technologies, Inc.      }
{              All rights reserved                      }
{                                                       }
{   Copyright and license exceptions noted in source    }
{                                                       }
{*******************************************************}

unit System; { Predefined constants, types, procedures, }
             { and functions (such as True, Integer, or }
             { Writeln) do not have actual declarations.}
             { Instead they are built into the compiler }
             { and are treated as if they were declared }
             { at the beginning of the System unit.     }

{$H+,I-,R-,O+,W-}
{$WARN SYMBOL_PLATFORM OFF}
{$WARN SYMBOL_DEPRECATED OFF}
{$WARN UNSAFE_TYPE OFF}
{$WARN IMMUTABLE_STRINGS OFF}
{$WARN UNSAFE_VOID_POINTER OFF}


{ L- should never be specified.

  The IDE needs to find DebugHook (through the C++
  compiler sometimes) for integrated debugging to
  function properly.

  ILINK will generate debug info for DebugHook if
  the object module has not been compiled with debug info.

  ILINK will not generate debug info for DebugHook if
  the object module has been compiled with debug info.

  Thus, the Pascal compiler must be responsible for
  generating the debug information for that symbol
  when a debug-enabled object file is produced.
}

interface

// PUREPASCAL
// X86ASMRTL
{$IF defined(CPUX86) and defined(ASSEMBLER)}
  {$DEFINE X86ASMRTL}
{$ELSE}
  {$DEFINE PUREPASCAL}
{$ENDIF}

// STACK_BASED_EXCEPTIONS
// PC_MAPPED_EXCEPTIONS
// TABLE_BASED_EXCEPTIONS
// SJLJ_BASED_EXCEPTIONS
// ZCX_BASED_EXCEPTIONS
// ZCX_BASED_EXCEPTIONS_MACOS
{$IFNDEF PC_MAPPED_EXCEPTIONS}
  {$IF defined(ANDROID)}
    {$DEFINE ZCX_BASED_EXCEPTIONS}
  {$ELSEIF defined(MACOS)}
    {$IF defined(CPUARM32)}
      {$DEFINE SJLJ_BASED_EXCEPTIONS}
    {$ELSEIF defined(CPUARM64)}
      {$DEFINE ZCX_BASED_EXCEPTIONS_MACOS}
    {$ELSEIF defined(CPUX64)}
      {$DEFINE ZCX_BASED_EXCEPTIONS_MACOS}
    {$ENDIF}
  {$ELSEIF defined(MSWINDOWS)}
    {$IFDEF EXTERNALLINKER}
      {$DEFINE ZCX_BASED_EXCEPTIONS}
    {$ELSE}
      {$IF defined(CPUX86)}
        {$DEFINE STACK_BASED_EXCEPTIONS}
      {$ELSEIF defined(CPUX64)}
        {$DEFINE TABLE_BASED_EXCEPTIONS}
      {$ELSE}
        {$MESSAGE ERROR 'Unknown platform'}
      {$ENDIF}
    {$ENDIF !EXTERNALLINKER}
  {$ELSEIF defined(LINUX)}
    {$IFDEF EXTERNALLINKER}
      {$DEFINE ZCX_BASED_EXCEPTIONS}
    {$ELSE}
      {$DEFINE PC_MAPPED_EXCEPTIONS}
    {$ENDIF}
  {$ELSE}
    {$MESSAGE ERROR 'Unknown platform'}
  {$ENDIF}
{$ENDIF !PC_MAPPED_EXCEPTIONS}

// USE_LIBICU
{$IFDEF ANDROID}
  {$DEFINE USE_LIBICU}
{$ENDIF ANDROID}


// EXTENDEDHAS10BYTES
// EXTENDEDIS16BYTES
// EXTENDEDIS12BYTES
// EXTENDEDIS10BYTES
// EXTENDEDIS8BYTES
{$IF SizeOf(Extended) >= 10} // 10,12,16
  {$DEFINE  EXTENDEDHAS10BYTES}
{$ENDIF}
{$IF SizeOf(Extended) = 16}
  {$DEFINE EXTENDEDIS16BYTES}
{$ELSEIF SizeOf(Extended) = 12}
  {$DEFINE EXTENDEDIS12BYTES}
{$ELSEIF SizeOf(Extended) = 10}
  {$DEFINE EXTENDEDIS10BYTES}
{$ELSEIF SizeOf(Extended) = 8}
  {$DEFINE EXTENDEDIS8BYTES}
{$ELSE}
  {$MESSAGE ERROR 'Unknown condition'}
{$ENDIF}

{$IFDEF ARITH_PUREPASCAL}
  {$IFDEF CPUX86}
        {$DEFINE ARITH_PUREPASCAL_EXT80}
  {$ENDIF CPUX86}
  {$IFDEF CPUX64}
    {$IFDEF MSWINDOWS}
        {$DEFINE ARITH_PUREPASCAL_EXT64}
    {$ENDIF MSWINDOWS}
    {$IFDEF LINUX}
        {$DEFINE ARITH_USE_LIBM}
    {$ENDIF LINUX}
  {$ENDIF CPUX64}
  {$IFDEF CPUARM32}
    {$IF defined(IOS) or defined(ANDROID)}
        {$DEFINE ARITH_USE_LIBM}
    {$ENDIF IOS}
  {$ENDIF CPUARM32}
{$ELSE !ARITH_PUREPASCAL}
  {$IFDEF CPUX86}
    {$IFDEF ASSEMBLER}
        {$DEFINE ARITH_X32_FPU}
    {$ELSE !ASSEMBLER}
      {$IFDEF EXTENDEDHAS10BYTES}
        {$DEFINE ARITH_PUREPASCAL_EXT80}
      {$ELSE !EXTENDEDHAS10BYTES}
        {$DEFINE ARITH_USE_LIBM}
      {$ENDIF !EXTENDEDHAS10BYTES}
    {$ENDIF !ASSEMBLER}
  {$ENDIF CPUX86}
  {$IFDEF CPUX64}
    {$IF defined(ASSEMBLER) and defined(MSWINDOWS)}
      {$DEFINE ARITH_X64_SSE}
    {$ELSEIF defined(OSX)}
      {$DEFINE ARITH_PUREPASCAL_EXT80}
      {$DEFINE ARITH_USE_LIBM}
    {$ELSE}
      {$IFDEF EXTENDEDHAS10BYTES}
        {$DEFINE ARITH_PUREPASCAL_EXT80}
      {$ELSE !EXTENDEDHAS10BYTES}
        {$DEFINE ARITH_PUREPASCAL_EXT64}
      {$ENDIF !EXTENDEDHAS10BYTES}
    {$ENDIF}
    {$IFDEF LINUX}
        {$DEFINE ARITH_USE_LIBM}
    {$ENDIF LINUX}
  {$ENDIF CPUX64}
  {$IFDEF CPUARM}
    {$IF defined(IOS) or defined(ANDROID) or defined(LINUX)}
      {$DEFINE ARITH_USE_LIBM}
    {$ELSE}
      {$MESSAGE ERROR 'Unknown Architecture'}
    {$ELSE}
      {$MESSAGE ERROR 'Unknown Architecture'}
    {$ENDIF IOS}
  {$ENDIF CPUARM}
{$ENDIF !ARITH_PUREPASCAL}



(* You can use RTLVersion in $IF expressions to test the runtime library
  version level independently of the compiler version level.
  Example:  {$IF RTLVersion >= 16.2} ... {$ENDIF}                  *)

const
  RTLVersion = 31.00;
 {$HPPEMIT '#define RTLVersionC 3100'}

{$IF Defined(NEXTGEN) and Defined(EMBEDDED)}
  Embedded = True;
{$ENDIF}

{$EXTERNALSYM CompilerVersion}

(*
const
  CompilerVersion = 0.0;

  CompilerVersion is assigned a value by the compiler when
  the system unit is compiled.  It indicates the revision level of the
  compiler features / language syntax, which may advance independently of
  the RTLVersion.  CompilerVersion can be tested in $IF expressions and
  should be used instead of testing for the VERxxx conditional define.
  Always test for greater than or less than a known revision level.
  It's a bad idea to test for a specific revision level.
*)

{$IFDEF DECLARE_GPL}
(* The existence of the GPL symbol indicates that the System unit
  and the rest of the Delphi runtime library were compiled for use
  and distribution under the terms of the GNU General Public License (GPL).
  Under the terms of the GPL, all applications compiled with the
  GPL version of the Delphi runtime library must also be distributed
  under the terms of the GPL.
  For more information about the GNU GPL, see
  http://www.gnu.org/copyleft/gpl.html

  The GPL symbol does not exist in the Delphi runtime library
  purchased for commercial/proprietary software development.

  If your source code needs to know which licensing model it is being
  compiled into, you can use {$IF DECLARED(GPL)}...{$ENDIF} to
  test for the existence of the GPL symbol.  The value of the
  symbol itself is not significant.   *)

const
  GPL = True;
{$ENDIF}

//{$IF (DEFINED(WIN32) or DEFINED(MACOS32)) and DEFINED(CPUX86)}
{$IF NOT (DEFINED(WIN64) or DEFINED(EXTERNALLINKER))}
{$DEFINE MANGLE_BCC32}
{$ENDIF}

//{$IF not ((DEFINED(WIN32) or DEFINED(MACOS32) or DEFINED(ANDROID)))}
{$IF DEFINED(WIN64) or DEFINED(EXTERNALLINKER)}
{
 C++ ABI support a'la the Itanium C++ ABI.
}
{$DEFINE CPP_ABI_SUPPORT}
{$ENDIF}

{$IF SizeOf(LongInt) = 8}
  {$DEFINE LONGINT64}
  {$DEFINE LONGINTISCPPLONG}
{$ENDIF}

{ Delphi built-in types for .hpp/.obj support }
{   Most of built-in types are defined in sysmac.h }
{   Pointer types should be mangled by the compiler for constness}
{$EXTERNALSYM Boolean     'bool'             } {$OBJTYPENAME Boolean    'Bo'  'Gb'}
{$NODEFINE    ShortInt    'Int8'             } {$OBJTYPENAME ShortInt   'Bzc' 'Ga'} { signed char }
{-EXTERNALSYM ShortInt    'signed char'      } {-OBJTYPENAME ShortInt   'Bzc' 'Ga'}
{$EXTERNALSYM SmallInt    'short'            } {$OBJTYPENAME SmallInt   'Bs'  'Gs'}
{$EXTERNALSYM Integer     'int'              } {$OBJTYPENAME Integer    'Bi'  'Gi'}
{$NODEFINE    Byte        'Byte'             } {$OBJTYPENAME Byte       'Buc' 'Gh'} { unsigned char }
{$NODEFINE    Word        'Word'             } {$OBJTYPENAME Word       'Bus' 'Gt'} { unsigned short }
{$EXTERNALSYM Cardinal    'unsigned'         } {$OBJTYPENAME Cardinal   'Bui' 'Gj'}
{$EXTERNALSYM Int64       '__int64'          } {$OBJTYPENAME Int64      'Bj'  'Gx'}
{$EXTERNALSYM UInt64      'unsigned __int64' } {$OBJTYPENAME UInt64     'Buj' 'Gy'}
{$IF defined(EXTERNALLINKER)}
{$EXTERNALSYM NativeInt   'NativeInt'        }
{$EXTERNALSYM NativeUInt  'NativeUInt'       }
{$ELSE}
{$IFDEF WIN64}
{$EXTERNALSYM NativeInt   'NativeInt'        } {$OBJTYPENAME NativeInt  'Bj'  'Gx'}
{$EXTERNALSYM NativeUInt  'NativeUInt'       } {$OBJTYPENAME NativeUInt 'Buj' 'Gy'}
{$ELSE}
{$EXTERNALSYM NativeInt   'NativeInt'        } {$OBJTYPENAME NativeInt  'Bi'  'Gi'}
{$EXTERNALSYM NativeUInt  'NativeUInt'       } {$OBJTYPENAME NativeUInt 'Bui' 'Gj'}
{$ENDIF}
{$ENDIF}
{$EXTERNALSYM Single      'float'            } {$OBJTYPENAME Single     'Bf'  'Gf'}
{$EXTERNALSYM Double      'double'           } {$OBJTYPENAME Double     'Bd'  'Gd'}
{$NODEFINE    Extended    'Extended'         } {$OBJTYPENAME Extended   'Bg'  'Ge'} { long double }
{$NODEFINE    Currency    'Currency'    'CurrencyBase'    } {$OBJTYPENAME Currency    'NCurrency'}
{$NODEFINE    Comp        'Comp'        'CompBase'        } {$OBJTYPENAME Comp        'NComp'}
{$EXTERNALSYM Real        'double'                        } {$OBJTYPENAME Real        'Bd' 'Gd'}
{$IFDEF NEXTGEN}
{$NODEFINE    _ShortString 'ShortString' 'ShortStringBase' }
{$NODEFINE    _OpenString}
{$ELSE}
{$NODEFINE    ShortString 'ShortString' 'ShortStringBase' } {$IFDEF MANGLE_BCC32}{$OBJTYPENAME ShortString 'N%SmallString$uc$i255$%'}{$ELSE}{$OBJTYPENAME ShortString 'NSmallString:GILh255EE'}{$ENDIF}
{$NODEFINE    OpenString  'OpenString'       } {$OBJTYPENAME OpenString 'Bxpc' 'GPc'} { char * const }
{$ENDIF}
{$NODEFINE    File        'file'             } {$OBJTYPENAME File       'Nfile'}
{$NODEFINE    Text        'TextFile'         } {$OBJTYPENAME Text       'NTextfile'}
{$NODEFINE    ByteBool    'ByteBool'         } {$OBJTYPENAME ByteBool   'Buc' 'Gh'} { unsigned char }
{$NODEFINE    WordBool    'WordBool'         } {$OBJTYPENAME WordBool   'Bus' 'Gt'} { unsigned short }
{$NODEFINE    LongBool    'LongBool'         } {$OBJTYPENAME LongBool   'Bi'  'Gi'} { int } { from windef.h }
{$NODEFINE    Real48      } { not supported in C++ }
{$NODEFINE    Extended80  } { not supported in C++ }
{$EXTERNALSYM Pointer     'void *'    }
{$NODEFINE    PWideChar   'WideChar *'}
{$IFDEF NEXTGEN}
{$EXTERNALSYM _PAnsiChar  'char *'    }
{$ELSE}
{$EXTERNALSYM PAnsiChar   'char *'    }
{$ENDIF}
{$NODEFINE    Variant     } { defined in sysvari.h }
{$NODEFINE    OleVariant  } { defined in sysvari.h }
{$IFDEF LONGINTISCPPLONG}
{$EXTERNALSYM LongInt     'long'             } {$OBJTYPENAME LongInt    'Bl'  'Gl'}
{$EXTERNALSYM LongWord    'unsigned long'    } {$OBJTYPENAME LongWord   'Bul' 'Gm'}
{$ELSE}
{$NODEFINE    LongInt     } { alias of Integer if 32-bit or LP64  }
{$NODEFINE    LongWord    } { alias of Cardinal if 32-bit or LP64 }
{$ENDIF}
{$NODEFINE    TextFile    } { alias of Text        }
{$IFDEF NEXTGEN}
{$EXTERNALSYM _AnsiChar    'char'          } {$OBJTYPENAME _AnsiChar 'Bc'  'Gc'}
{$ELSE}
{$EXTERNALSYM AnsiChar     'char'          } {$OBJTYPENAME AnsiChar 'Bc'  'Gc'}
{$ENDIF}
{$IFDEF MSWINDOWS}
  {$NODEFINE  Char         'WideChar'      } {$OBJTYPENAME Char     'Bb'  'Gw'}  { wchar_t }
{$ELSE}
  {$NODEFINE  Char         'WideChar'      } {$OBJTYPENAME Char     'BCs' 'Ds'} { char16_t }
{$ENDIF}
{$NODEFINE    string       'UnicodeString' } {$OBJTYPENAME string   'NUnicodeString'} { defined in ustring.h }
{-NODEFINE    string       'String'        } {$OBJTYPENAME string   'NUnicodeString'} { defined in ustring.h }
{$IFDEF NEXTGEN}
{$NODEFINE    _AnsiString '_AnsiString'  } { defined in dstring.h }
{$NODEFINE    _WideString '_WideString'  } { defined in wstring.h }
{$ELSE}
{$NODEFINE    AnsiString   } { defined in dstring.h }
{$NODEFINE    WideString   } {$OBJTYPENAME WideString 'NWideString'} { defined in wstring.h }
{$ENDIF}
{$NODEFINE    PChar        } { alias of PWideChar  }
{$NODEFINE    WideChar     } { alias of Char       }
{$NODEFINE    UnicodeString} { alias of string     }

(*$HPPEMIT 'namespace System' *)
(*$HPPEMIT '{' *)
(*$HPPEMIT '  // Shortint is a source of confusion in C++' *)
(*$HPPEMIT '  // typedef Shortint ShortInt;' *)
(*$HPPEMIT '  typedef Smallint SmallInt;' *)
(*$HPPEMIT '  typedef Longint LongInt;' *)
(*$HPPEMIT '}' *)

type
  CppLongInt  = type LongInt;  {$EXTERNALSYM CppLongInt  'long'         } {$OBJTYPENAME CppLongInt  'Bl'  'Gl'}
  CppULongInt = type LongWord; {$EXTERNALSYM CppULongInt 'unsigned long'} {$OBJTYPENAME CppULongInt 'Bul' 'Gm'}
{$IFDEF MSWINDOWS}
  FixedInt = LongInt;
  FixedUInt = LongWord;
{$ENDIF}
{$IFDEF POSIX}
  FixedInt = Integer;
  FixedUInt = Cardinal;
{$ENDIF}
  PFixedInt = ^FixedInt;
  PFixedUInt = ^FixedUInt;
  {$EXTERNALSYM FixedInt}
  {$EXTERNALSYM FixedUInt}

{ Useful alias types }
type
  {$NODEFINE Int8} // We map 'Shortint' to 'Int8' for C++ above
  Int8    = ShortInt;
  Int16   = SmallInt;
  Int32   = Integer;
  IntPtr  = NativeInt;
  UInt8   = Byte;
  UInt16  = Word;
  UInt32  = Cardinal;
  UIntPtr = NativeUInt;
{$IFDEF MACOS} {mactypes.h}
  {$EXTERNALSYM UInt8}
  {$EXTERNALSYM UInt16}
  {$EXTERNALSYM UInt32}
{$ENDIF}

  { Internal Aliases }
  {$IFDEF NEXTGEN}
  _ShortStr = _ShortString;
  _AnsiStr = _AnsiString;
  _AnsiChr = _AnsiChar;
  _WideStr = _WideString;
  _PAnsiChr = _PAnsiChar;
  UTF8Char = _AnsiChar;
  PUTF8Char = _PAnsiChar;
  {$ELSE}
  _ShortStr = ShortString;
  _AnsiStr = AnsiString;
  _AnsiChr = AnsiChar;
  _WideStr = WideString;
  _PAnsiChr = PAnsiChar;
  UTF8Char = AnsiChar;
  PUTF8Char = PAnsiChar;
  {$ENDIF}
  MarshaledString = PWideChar;
  MarshaledAString = _PAnsiChr;
{$NODEFINE    MarshaledString  }
{$NODEFINE    MarshaledAString }
{$NODEFINE    _ShortStr    }
{$NODEFINE    _WideStr     }
{$NODEFINE    _AnsiStr     }
{$NODEFINE    _AnsiChr     }
{$NODEFINE    _PAnsiChr    }

const
{ Variant type codes (wtypes.h) }

  varEmpty    = $0000; { vt_empty        0 }
  varNull     = $0001; { vt_null         1 }
  varSmallint = $0002; { vt_i2           2 }
  varInteger  = $0003; { vt_i4           3 }
  varSingle   = $0004; { vt_r4           4 }
  varDouble   = $0005; { vt_r8           5 }
  varCurrency = $0006; { vt_cy           6 }
  varDate     = $0007; { vt_date         7 }
  varOleStr   = $0008; { vt_bstr         8 }
  varDispatch = $0009; { vt_dispatch     9 }
  varError    = $000A; { vt_error       10 }
  varBoolean  = $000B; { vt_bool        11 }
  varVariant  = $000C; { vt_variant     12 }
  varUnknown  = $000D; { vt_unknown     13 }
//varDecimal  = $000E; { vt_decimal     14 } {UNSUPPORTED as of v6.x code base}
//varUndef0F  = $000F; { undefined      15 } {UNSUPPORTED per Microsoft}
  varShortInt = $0010; { vt_i1          16 }
  varByte     = $0011; { vt_ui1         17 }
  varWord     = $0012; { vt_ui2         18 }
  varLongWord = $0013; { vt_ui4         19 }
  varInt64    = $0014; { vt_i8          20 }
  varUInt64   = $0015; { vt_ui8         21 }
  varRecord   = $0024; { VT_RECORD      36 }
{  if adding new items, update Variants' varLast, BaseTypeMap and OpTypeMap }

  varStrArg   = $0048; { vt_clsid        72 }
  varObject   = $0049; {                 73 }
  varUStrArg  = $004A; {                 74 }
  varString   = $0100; { Pascal string  256 } {not OLE compatible }
  varAny      = $0101; { Corba any      257 } {not OLE compatible }
  varUString  = $0102; { Unicode string 258 } {not OLE compatible }
  // custom types range from $110 (272) to $7FF (2047)

  varTypeMask = $0FFF;
  varArray    = $2000;
  varByRef    = $4000;

{ TVarRec.VType values }

  vtInteger       = 0;
  vtBoolean       = 1;
  vtChar          = 2;
  vtExtended      = 3;
  vtString        = 4{$IFDEF NEXTGEN} deprecated 'Type not supported' {$ENDIF NEXTGEN};
  vtPointer       = 5;
  vtPChar         = 6;
  vtObject        = 7;
  vtClass         = 8;
  vtWideChar      = 9;
  vtPWideChar     = 10;
  vtAnsiString    = 11;
  vtCurrency      = 12;
  vtVariant       = 13;
  vtInterface     = 14;
  vtWideString    = 15;
  vtInt64         = 16;
  vtUnicodeString = 17;

{$IFDEF AUTOREFCOUNT}
  vmtArcOffset    = 2 * SizeOf(Pointer);
{$ELSE}
  vmtArcOffset    = 0;
{$ENDIF}

{$IFDEF CPP_ABI_SUPPORT}
  CPP_ABI_ADJUST = 3 * SizeOf(Pointer);
{$ELSE !CPP_ABI_SUPPORT}
  CPP_ABI_ADJUST = 0;
{$ENDIF !CPP_ABI_SUPPORT}

{ Virtual method table entries }
{$IF defined(CPU64BITS)}
  vmtSelfPtr           = -176 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtIntfTable         = -168 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtAutoTable         = -160 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtInitTable         = -152 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtTypeInfo          = -144 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtFieldTable        = -136 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtMethodTable       = -128 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtDynamicTable      = -120 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtClassName         = -112 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtInstanceSize      = -104 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtParent            = -96 - vmtArcOffset - CPP_ABI_ADJUST;
{$IFDEF AUTOREFCOUNT}
  vmtObjAddRef         = -104 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtObjRelease        = -96 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
{$ENDIF}
  vmtEquals            = -88 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtGetHashCode       = -80 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtToString          = -72 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtSafeCallException = -64 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtAfterConstruction = -56 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtBeforeDestruction = -48 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtDispatch          = -40 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtDefaultHandler    = -32 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtNewInstance       = -24 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtFreeInstance      = -16 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtDestroy           =  -8 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtQueryInterface    =  0 deprecated 'Use VMTOFFSET in asm code';
  vmtAddRef            =  8 deprecated 'Use VMTOFFSET in asm code';
  vmtRelease           = 16 deprecated 'Use VMTOFFSET in asm code';
  vmtCreateObject      = 24 deprecated 'Use VMTOFFSET in asm code';
{$ELSE !CPU64BITS}
  vmtSelfPtr           = -88 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtIntfTable         = -84 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtAutoTable         = -80 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtInitTable         = -76 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtTypeInfo          = -72 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtFieldTable        = -68 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtMethodTable       = -64 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtDynamicTable      = -60 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtClassName         = -56 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtInstanceSize      = -52 - vmtArcOffset - CPP_ABI_ADJUST;
  vmtParent            = -48 - vmtArcOffset - CPP_ABI_ADJUST;
{$IFDEF AUTOREFCOUNT}
  vmtObjAddRef         = -52 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtObjRelease        = -48 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
{$ENDIF}
  vmtEquals            = -44 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtGetHashCode       = -40 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtToString          = -36 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtSafeCallException = -32 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtAfterConstruction = -28 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtBeforeDestruction = -24 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtDispatch          = -20 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtDefaultHandler    = -16 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtNewInstance       = -12 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtFreeInstance      = -8 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';
  vmtDestroy           = -4 - CPP_ABI_ADJUST deprecated 'Use VMTOFFSET in asm code';

  vmtQueryInterface    = 0 deprecated 'Use VMTOFFSET in asm code';
  vmtAddRef            = 4 deprecated 'Use VMTOFFSET in asm code';
  vmtRelease           = 8 deprecated 'Use VMTOFFSET in asm code';
  vmtCreateObject      = 12 deprecated 'Use VMTOFFSET in asm code';
{$ENDIF !CPU64BITS}

  { Hidden TObject field info }
  hfFieldSize          = SizeOf(Pointer);
  hfMonitorOffset      = 0;

{ RTTI Visibility }
type
  TVisibilityClasses = set of (vcPrivate, vcProtected, vcPublic, vcPublished);

const
  { These constants represent the default settings built into the compiler.
    For classes, these settings are normally inherited from TObject. }
  DefaultMethodRttiVisibility = [vcPublic, vcPublished];
  DefaultFieldRttiVisibility = [vcPrivate..vcPublished];
  DefaultPropertyRttiVisibility = [vcPublic, vcPublished];

type
  { Default RTTI settings }
  {$RTTI INHERIT
      METHODS(DefaultMethodRttiVisibility)
      FIELDS(DefaultFieldRttiVisibility)
      PROPERTIES(DefaultPropertyRttiVisibility)}

  { Minimal RTTI generation henceforth in this file }
  {.$RTTI EXPLICIT METHODS([]) FIELDS([]) PROPERTIES([])}

  TArray<T> = array of T;

  {.$DEFINE SYSTEM_HPP_DEFINES_OBJECTS}

  TObject = class;
  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}
  {$NODEFINE TObject}   { defined in systobj.h }
  {$ENDIF}

  TClass = class of TObject;
  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}
  {$NODEFINE TClass}    { defined in systobj.h }
  {$ENDIF}

  {$IFDEF LONGINT64}
  HRESULT = type Int32;
  {$EXTERNALSYM HRESULT}
  {$ELSEIF defined(EXTERNALLINKER)}
  HRESULT = type CppLongInt;
  {$EXTERNALSYM HRESULT} { long }
  {$ELSE}
  HRESULT = type LongInt;  { from wtypes.h }
  {$EXTERNALSYM HRESULT} {$OBJTYPENAME HRESULT 'Bl' 'Gl'} { long }
  {$ENDIF}

  PGUID = ^TGUID;
  TGUID = record
    D1: Cardinal;
    D2: Word;
    D3: Word;
    D4: array[0..7] of Byte;
    class operator Equal(const Left, Right: TGUID): Boolean;
    class operator NotEqual(const Left, Right: TGUID): Boolean;
    class function Empty: TGUID; static;
    class function Create(const Data; BigEndian: Boolean = False): TGUID; overload; static;
    class function Create(const Data: array of Byte; AStartIndex: Cardinal; BigEndian: Boolean = False): TGUID; overload; static;
  end;
  {$NODEFINE PGUID}             { defined in sysmac.h }
  {$EXTERNALSYM TGUID 'GUID' }  { defined in sysmac.h }
  {$OBJTYPENAME TGUID 'N_GUID'}
  { Type 'GUID' in C++ is alias of '_GUID' and defined in guiddef.h (wtypes.h) }

  PInterfaceEntry = ^TInterfaceEntry;
  TInterfaceEntry = packed record
    IID: TGUID;
    VTable: Pointer;
    IOffset: Integer;
    {$IF defined(CPU64BITS)}
    _Filler: UInt32;
    {$ENDIF}
    ImplGetter: NativeUInt;
  end;

  PInterfaceTable = ^TInterfaceTable;
  TInterfaceTable = packed record
    EntryCount: Integer;
    {$IF defined(CPU64BITS)}
    _Filler: UInt32;
    {$ENDIF}
    Entries: array[0..9999{EntryCount - 1}] of TInterfaceEntry;
   {Intfs: array[0..EntryCount - 1] of PPTypeInfo;}
  end;

  PMethod = ^TMethod;
  TMethod = record
    Code, Data: Pointer;
  public
    class operator Equal(const Left, Right: TMethod): Boolean; inline;
    class operator NotEqual(const Left, Right: TMethod): Boolean; inline;
    class operator GreaterThan(const Left, Right: TMethod): Boolean; inline;
    class operator GreaterThanOrEqual(const Left, Right: TMethod): Boolean; inline;
    class operator LessThan(const Left, Right: TMethod): Boolean; inline;
    class operator LessThanOrEqual(const Left, Right: TMethod): Boolean; inline;
  end;

{ TObject.Dispatch accepts any data type as its Message parameter.  The
  first 2 bytes of the data are taken as the message id to search for
  in the object's message methods.  TDispatchMessage is an example of
  such a structure with a word field for the message id.
}
  TDispatchMessage = record
    MsgID: Word;
  end;

  TObject = class
  public
    constructor Create;
    procedure Free;
    procedure DisposeOf; {$IFNDEF AUTOREFCOUNT} inline; {$ENDIF}
    class function InitInstance(Instance: Pointer): TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};
    procedure CleanupInstance;
    function ClassType: TClass; inline;
    class function ClassName: string;
    class function ClassNameIs(const Name: string): Boolean;
    class function ClassParent: TClass;
    class function ClassInfo: Pointer; inline;
    class function InstanceSize: Integer; inline;
    class function InheritsFrom(AClass: TClass): Boolean;
    class function MethodAddress(const Name: _ShortStr): Pointer; overload;
    class function MethodAddress(const Name: string): Pointer; overload;
    class function MethodName(Address: Pointer): string;
    class function QualifiedClassName: string;
    function FieldAddress(const Name: _ShortStr): Pointer; overload;
    function FieldAddress(const Name: string): Pointer; overload;
    function GetInterface(const IID: TGUID; out Obj): Boolean;
    class function GetInterfaceEntry(const IID: TGUID): PInterfaceEntry;
    class function GetInterfaceTable: PInterfaceTable;
    class function UnitName: string;
    class function UnitScope: string;
{$IFDEF AUTOREFCOUNT}
    function __ObjAddRef: Integer; virtual;
    function __ObjRelease: Integer; virtual;
{$ENDIF}
    function Equals(Obj: TObject): Boolean; virtual;
    function GetHashCode: Integer; virtual;
    function ToString: string; virtual;
    function SafeCallException(ExceptObject: TObject;
      ExceptAddr: Pointer): HResult; virtual;
    procedure AfterConstruction; virtual;
    procedure BeforeDestruction; virtual;
    procedure Dispatch(var Message); virtual;
    procedure DefaultHandler(var Message); virtual;
    class function NewInstance: TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF}; virtual;
    procedure FreeInstance; virtual;
{$IFDEF AUTOREFCOUNT}
  protected
{$ENDIF}
    destructor Destroy; virtual;

{$IFDEF CPP_ABI_SUPPORT}
    procedure CPP_ABI_1; virtual;
    procedure CPP_ABI_2; virtual;
    procedure CPP_ABI_3; virtual;
{$ENDIF !CPP_ABI_SUPPORT}

  protected
    function GetDisposed: Boolean; inline;
    procedure CheckDisposed; {$IFNDEF AUTOREFCOUNT} inline; {$ENDIF}

{$IFDEF AUTOREFCOUNT}
  private const
    objDestroyingFlag = Integer($80000000);
    objDisposedFlag = Integer($40000000);
  protected
    [Volatile] FRefCount: Integer;
    class procedure __MarkDestroying(const Obj); static; inline;
    class function __SetDisposed(const Obj): Boolean; static; inline;
  public
    property RefCount: Integer read FRefCount;
{$ENDIF}
    property Disposed: Boolean read GetDisposed;
  end;

  { The base class for all custom attributes. Attribute
    instances created by the RTTI unit are owned by those
    members to which they apply. }
  TCustomAttribute = class(TObject)
  end;
  WeakAttribute = class(TCustomAttribute);
  UnsafeAttribute = class(TCustomAttribute);
  RefAttribute = class(TCustomAttribute);
  VolatileAttribute = class(TCustomAttribute);
  StoredAttribute = class(TCustomAttribute)
  strict protected
    FFlag: Boolean;
    _FName: String;
  public
    constructor Create; overload;
    constructor Create(const StorageHandlerFlag: Boolean); overload;
    constructor Create(const StorageHandlerName: string); overload;
    property Flag: Boolean read FFlag;
    property Name: String read _FName;
  end;
  HPPGENAttribute = class(TCustomAttribute)
  const
    mkNoDefine = 1;
    mkAccessible = 2;
    mkFriend = 4;
    mkNonPackage = 8;
  public
    constructor Create(const AData : string); overload;
    constructor Create(const AFlag: Integer; const AData : string = ''); overload;
  end;
  /// <summary>For internal use only.</summary>
  HFAAttribute = class(TCustomAttribute)
  strict protected
    /// <summary>Internal use only</summary>
    FElementType: Pointer;
    /// <summary>Internal use only</summary>
    FElementCount: Integer;
  public
    constructor Create(const ElementType: Pointer; const ElementCount: Integer); overload;
    /// <summary>TypeInfo of element type</summary>
    property ElementType: Pointer read FElementType;
    /// <summary>Number of element type </summary>
    property ElementCount: Integer read FElementCount;
  end;
  /// <summary>Internal use only.</summary>
  AlignAttribute = class(TCustomAttribute)
  strict protected
    /// <summary>Internal use only</summary>
    FAlign: Integer;
  public
    constructor Create(Align: Integer);
    /// <summary>Alignment in bytes</summary>
    property Align: Integer read FAlign;
  end;
  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}
  {$NODEFINE TCustomAttribute}
  {$NODEFINE WeakAttribute}
  {$NODEFINE UnsafeAttribute}
  {$NODEFINE RefAttribute}
  {$NODEFINE VolatileAttribute}
  {$NODEFINE StoredAttribute}
  {$NODEFINE HPPGENAttribute}
  {$NODEFINE HFAAttribute}
  {$NODEFINE AlignAttribute}
  {$ENDIF}


{$IFDEF NEXTGEN}
  CheckForCyclesProc = procedure (const Obj: TObject);
{$ENDIF NEXTGEN}

{$IF Defined(MSWINDOWS)}
  TThreadID = LongWord;
{$ENDIF}
{$IFDEF POSIX}
  TThreadID = NativeUInt;
{$ENDIF}
  { TMonitor is an implementation of the concept invented by C.A.R Hoare and Per Brinch Hansen.
    See http://en.wikipedia.org/wiki/Monitor_%28synchronization%29 for more information.

    Every TObject derived instance can be used as a monitor. However, it is recommended that privately
    constructed objects be used rather than the publicly available instance itself. This will allow the
    developer to better control access to the lock and to ensure that the locking rules are adhered to.
    If a publicly available instance were to be used a the lock, such as a TComponent derivative, then
    deadlocks are more likely when external code is locking and unlocking the monitor in addition to
    the code internal to the class. In many cases, a mutex/critical section/condition variable can be
    created by simply constructing a variable of type TObject and calling the TMonitor.XXXX(ObjInstance)
    methods. }

  PPMonitor = ^PMonitor;
  PMonitor = ^TMonitor;
  TMonitor = record
  strict private
    type
      PWaitingThread = ^TWaitingThread;
      TWaitingThread = record
        Next: PWaitingThread;
        Thread: TThreadID;
        WaitEvent: Pointer;
      end;
      { TSpinWait implements an exponential backoff algorithm for TSpinLock. The algorithm is as follows:
        If the CPUCount > 1, then the first 10 (YieldThreshold) spin cycles (calls to SpinCycle) will use a base 2
        exponentially increasing spin count starting at 4. After 10 cycles, then the behavior reverts to the same
        behavior as when CPUCount = 1.
        If the CPUCount = 1, then it will sleep 1ms every modulus 20 cycles and sleep 0ms every modulus 5 cycles.
        All other cycles simply yield (SwitchToThread - Windows, sched_yield - POSIX). }
      TSpinWait = record
      private const
        YieldThreshold = 10;
        Sleep1Threshold = 20;
        Sleep0Threshold = 5;
      private
        FCount: Integer;
      public
        procedure Reset; inline;
        procedure SpinCycle;
      end;
      { TSpinLock implements a very simple non-reentrant lock. This lock does not block the calling thread using a
        synchronization object. Instead it opts to burn a few extra CPU cycles using the above TSpinWait type. This
        is typically far faster than fully blocking since the length of time the lock is held is relatively few
        cycles and the thread switching overhead will usually far outpace the few cycles burned by simply spin
        waiting. }
      TSpinLock = record
      private
        FLock: Integer;
      public
        procedure Enter;
        procedure Exit;
      end;
    var
      [Volatile] FLockCount: Integer;
      FRecursionCount: Integer;
      FOwningThread: TThreadID;
      FLockEvent: Pointer;
      FSpinCount: Integer;
      FWaitQueue: PWaitingThread;
      FQueueLock: TSpinLock;
    class var CacheLineSize: Integer;
    class var FDefaultSpinCount: Integer;
    class procedure Spin(Iterations: Integer); static;
    class function GetCacheLineSize: Integer; static;
    procedure QueueWaiter(var WaitingThread: TWaitingThread);
    procedure RemoveWaiter(var WaitingThread: TWaitingThread);
    function DequeueWaiter: PWaitingThread;
    function GetEvent: Pointer;
    function CheckOwningThread: TThreadID;
    class procedure CheckMonitorSupport; static; inline;
  private
    class function Create: PMonitor; static;
    // Make sure the following Destroy overload is always
    // listed first since it is called from an asm block
    // and there is no overload-resolution done from a
    // basm symbol reference
    class procedure Destroy(const AObject: TObject); overload; static;
    procedure Destroy; overload;
  strict private
    class function GetFieldAddress(const AObject: TObject): PPMonitor; inline; static;
    class function GetMonitor(const AObject: TObject): PMonitor; static;
    class procedure SetDefaultSpinCount(AValue: Integer); static;
    function TryEnter: Boolean; overload;
    function Wait(ALock: PMonitor; Timeout: Cardinal): Boolean; overload;
    procedure Pulse; overload;
    procedure PulseAll; overload;
  private
    function Enter(Timeout: Cardinal): Boolean; overload;
    procedure Exit; overload;
  public
    { In multi-core/multi-processor systems, it is sometimes desirable to spin for a few cycles instead of blocking
      the current thread when attempting to Enter the monitor. Use SetSpinCount to set a reasonable number of times to
      spin before fully blocking the thread. This value usually obtained through empirical study of the particular
      situation.  }
    class procedure SetSpinCount(const AObject: TObject; ASpinCount: Integer); static;
    { Enter locks the monitor object with an optional timeout (in ms) value. Enter without a timeout will wait until
      the lock is obtained. If the procedure returns it can be assumed that the lock was acquired. Enter with a
      timeout will return a boolean status indicating whether or not the lock was obtained (True) or the attempt timed
      out prior to acquire the lock (False). Calling Enter with an INFINITE timeout is the same as calling Enter
      without a timeout.
      TryEnter will simply attempt to obtain the lock and return immediately whether or not the lock was acuired.
      Enter with a 0ms timeout is functionally equivalent to TryEnter.
      Exit will potentially release the lock acquired by a call to Enter or TryEnter. Since Enter/TryEnter are
      rentrant, you must balance each of those calls with a corresponding call to Exit. Only the last call to Exit will
      release the lock and allow other threads to obtain it. Runtime error, reMonitorNotLocked, is generated if Exit is
      called and the calling thread does not own the lock. }
    class procedure Enter(const AObject: TObject); overload; static; inline;
    class function Enter(const AObject: TObject; Timeout: Cardinal): Boolean; overload; static;
    class procedure Exit(const AObject: TObject); overload; static;
    class function TryEnter(const AObject: TObject): Boolean; overload; static;
    { Wait will atomically fully release the lock (regardless of the recursion count) and block the calling thread
      until another thread calls Pulse or PulseAll. The first overloaded Wait function will assume the locked object
      and wait object are the same and thus the calling thread must own the lock. The second Wait allows the given
      monitor to atomically unlock the separate monitor lock object and block with the calling thread on the first
      given wait object. Wait will not return (even if it times out) until the monitor lock can be acquired again. It
      is possible for wait to return False (the timeout expired) after a much longer period of time has elapsed if
      the locking object was being held by another thread for an extended period. When Wait returns the recursion
      level of the lock has been restored.
      Pulse must be called on the exact same instance passed to Wait in order to properly release one waiting thread.
      PulseAll works the same as Pulse except that it will release all currently waiting threads.
      Wait/Pulse/PulseAll are the same as a traditional condition variable.
    }
    class function Wait(const AObject: TObject; Timeout: Cardinal): Boolean; overload; static;
    class function Wait(const AObject, ALock: TObject; Timeout: Cardinal): Boolean; overload; static;
    class procedure Pulse(const AObject: TObject); overload; static;
    class procedure PulseAll(const AObject: TObject); overload; static;
    class property DefaultSpinCount: Integer read FDefaultSpinCount write SetDefaultSpinCount;
  end;

const
  INFINITE = Cardinal($FFFFFFFF);       {$EXTERNALSYM INFINITE}

function MonitorEnter(const AObject: TObject; Timeout: Cardinal = INFINITE): Boolean; inline;
function MonitorTryEnter(const AObject: TObject): Boolean; inline;
procedure MonitorExit(const AObject: TObject); inline;
function MonitorWait(const AObject: TObject; Timeout: Cardinal): Boolean; inline; overload;
function MonitorWait(const AObject, ALock: TObject; Timeout: Cardinal): Boolean; inline; overload;
procedure MonitorPulse(const AObject: TObject); inline;
procedure MonitorPulseAll(const AObject: TObject); inline;
// Note: MemoryBarrier is now standard function.
//procedure MemoryBarrier;

procedure YieldProcessor; {$EXTERNALSYM YieldProcessor }

const
  S_OK = 0;
{$IF Defined(MSWINDOWS) or Defined(NEXTGEN)}
  {$EXTERNALSYM S_OK}
{$ENDIF}
  S_FALSE = $00000001;
{$IF Defined(MSWINDOWS) or Defined(NEXTGEN)}
  {$EXTERNALSYM S_FALSE}
{$ENDIF}
  E_NOINTERFACE = HRESULT($80004002);
{$IFDEF MSWINDOWS}
  {$EXTERNALSYM E_NOINTERFACE}
{$ENDIF}
  E_UNEXPECTED = HRESULT($8000FFFF);
{$IFDEF MSWINDOWS}
  {$EXTERNALSYM E_UNEXPECTED}
{$ENDIF}
  E_NOTIMPL = HRESULT($80004001);
{$IFDEF MSWINDOWS}
  {$EXTERNALSYM E_NOTIMPL}
{$ENDIF}

type
  IInterface = interface
    ['{00000000-0000-0000-C000-000000000046}']
    function QueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
    function _AddRef: Integer; stdcall;
    function _Release: Integer; stdcall;
  end;
  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}
  {$NODEFINE IInterface}        { defined in sysmac.h }
  {$ENDIF}

  IUnknown = IInterface;
  {$EXTERNALSYM IUnknown}       { from unknwn.h or sysmac.h }
{$M+}
  IInvokable = interface(IInterface)
  end;
{$M-}
  {$NODEFINE IInvokable}        { defined in sysmac.h }

  IEnumerator = interface(IInterface)
    function GetCurrent: TObject;
    function MoveNext: Boolean;
    procedure Reset;
    property Current: TObject read GetCurrent;
  end;

  IEnumerable = interface(IInterface)
    function GetEnumerator: IEnumerator;
  end;

  IEnumerator<T> = interface(IEnumerator)
    [HPPGEN('virtual T __fastcall GetCurrentT(void) = 0')]
    function GetCurrent: T;
    [HPPGEN('__property T Current = {read=GetCurrentT}')]
    property Current: T read GetCurrent;
  end;

  IEnumerable<T> = interface(IEnumerable)
    [HPPGEN('virtual System::DelphiInterface<IEnumerator__1<T> > __fastcall GetEnumeratorT(void) = 0')]
    function GetEnumerator: IEnumerator<T>;
  end;

  IComparable = interface(IInterface)
    function CompareTo(Obj: TObject): Integer;
  end;

  IComparable<T> = interface(IComparable)
    function CompareTo(Value: T): Integer;
  end;

  IEquatable<T> = interface(IInterface)
    function Equals(Value: T): Boolean;
  end;

  IDispatch = interface(IUnknown)
    ['{00020400-0000-0000-C000-000000000046}']
    function GetTypeInfoCount(out Count: Integer): HResult; stdcall;
    function GetTypeInfo(Index, LocaleID: Integer; out TypeInfo): HResult; stdcall;
    function GetIDsOfNames(const IID: TGUID; Names: Pointer;
      NameCount, LocaleID: Integer; DispIDs: Pointer): HResult; stdcall;
    function Invoke(DispID: Integer; const IID: TGUID; LocaleID: Integer;
      Flags: Word; var Params; VarResult, ExcepInfo, ArgErr: Pointer): HResult; stdcall;
  end;
{$IFDEF MSWINDOWS}
  {$EXTERNALSYM IDispatch}      { from oaidl.h (oleauto.h) }
{$ENDIF}

{ TInterfacedObject provides a threadsafe default implementation
  of IInterface.  You should use TInterfaceObject as the base class
  of objects implementing interfaces.  }

  TInterfacedObject = class(TObject, IInterface)
{$IFNDEF AUTOREFCOUNT}
  private const
    objDestroyingFlag = Integer($80000000);
    function GetRefCount: Integer; inline;
{$ENDIF}
  protected
{$IFNDEF AUTOREFCOUNT}
    [Volatile] FRefCount: Integer;
    class procedure __MarkDestroying(const Obj); static; inline;
{$ENDIF}
    function QueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
    function _AddRef: Integer; stdcall;
    function _Release: Integer; stdcall;
  public
{$IFNDEF AUTOREFCOUNT}
    procedure AfterConstruction; override;
    procedure BeforeDestruction; override;
    class function NewInstance: TObject; override;
    property RefCount: Integer read GetRefCount;
{$ENDIF}
  end;
  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}
  {$NODEFINE TInterfacedObject}         { defined in systobj.h }
  {$ENDIF}

  TInterfacedClass = class of TInterfacedObject;

{ TAggregatedObject and TContainedObject are suitable base
  classes for interfaced objects intended to be aggregated
  or contained in an outer controlling object.  When using
  the "implements" syntax on an interface property in
  an outer object class declaration, use these types
  to implement the inner object.

  Interfaces implemented by aggregated objects on behalf of
  the controller should not be distinguishable from other
  interfaces provided by the controller.  Aggregated objects
  must not maintain their own reference count - they must
  have the same lifetime as their controller.  To achieve this,
  aggregated objects reflect the reference count methods
  to the controller.

  TAggregatedObject simply reflects QueryInterface calls to
  its controller.  From such an aggregated object, one can
  obtain any interface that the controller supports, and
  only interfaces that the controller supports.  This is
  useful for implementing a controller class that uses one
  or more internal objects to implement the interfaces declared
  on the controller class.  Aggregation promotes implementation
  sharing across the object hierarchy.

  TAggregatedObject is what most aggregate objects should
  inherit from, especially when used in conjunction with
  the "implements" syntax.  }

  TAggregatedObject = class(TObject)
  private
    [Unsafe] FController: IInterface;  // unsafe/weak reference to controller
  protected
    { IInterface }
    function QueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
    function _AddRef: Integer; stdcall;
    function _Release: Integer; stdcall;
  public
    constructor Create(const Controller: IInterface);
    property Controller: IInterface read FController;
  end;
  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}
  {$NODEFINE TAggregatedObject} { defined in systobj.h }
  {$ENDIF}

  { TContainedObject is an aggregated object that isolates
    QueryInterface on the aggregate from the controller.
    TContainedObject will return only interfaces that the
    contained object itself implements, not interfaces
    that the controller implements.  This is useful for
    implementing nodes that are attached to a controller and
    have the same lifetime as the controller, but whose
    interface identity is separate from the controller.
    You might do this if you don't want the consumers of
    an aggregated interface to have access to other interfaces
    implemented by the controller - forced encapsulation.
    This is a less common case than TAggregatedObject.  }

  TContainedObject = class(TAggregatedObject, IInterface)
  protected
    { IInterface }
    function QueryInterface(const IID: TGUID; out Obj): HResult; virtual; stdcall;
  end;
  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}
  {$NODEFINE TContainedObject}  { defined in systobj.h }
  {$ENDIF}

  TClassHelperBase = class(TInterfacedObject, IInterface)
  protected
    FInstance: TObject;
    constructor _Create(Instance: TObject);
  end;

  TClassHelperBaseClass = class of TClassHelperBase;
  {$NODEFINE TClassHelperBaseClass}
  {$NODEFINE TClassHelperBase}

{$IFDEF NEXTGEN}
  _PShortString = ^_ShortString;
  _PAnsiString = ^_AnsiString;
  _PWideString = ^_WideString;
  PUnicodeString = ^UnicodeString;
  PString = PUnicodeString;
  _PShortStr = _PShortString;
  _PAnsiStr = _PAnsiString;
  _PWideStr = _PWideString;
  {$NODEFINE _PShortString}
  {$NODEFINE _PAnsiString 'PAnsiString'}
  {$NODEFINE _PWideString}
  {$NODEFINE PUnicodeString}
  {$NODEFINE PString}
  {$NODEFINE _PShortStr}
  {$NODEFINE _PAnsiStr}
  {$NODEFINE _PWideStr}
{$ELSE}
  PShortString = ^ShortString;
  PAnsiString = ^AnsiString;
  PWideString = ^WideString;
  PUnicodeString = ^UnicodeString;
  PString = PUnicodeString;
  _PShortStr = PShortString;
  _PAnsiStr = PAnsiString;
  _PWideStr = PWideString;
  {$NODEFINE PShortString}      { defined in sysmac.h }
  {$NODEFINE PAnsiString}       { defined in sysmac.h }
  {$NODEFINE PWideString}       { defined in sysmac.h }
  {$NODEFINE PUnicodeString}    { defined in sysmac.h }
  {$NODEFINE PString}           { defined in sysmac.h }
{$ENDIF}
  {$NODEFINE _PShortStr }       { defined in sysmac.h }
  {$NODEFINE _PAnsiStr  }       { defined in sysmac.h }
  {$NODEFINE _PWideStr  }       { defined in sysmac.h }

  UCS2Char = WideChar;
  PUCS2Char = PWideChar;
  UCS4Char = type Cardinal;
  {$NODEFINE UCS4Char}          { defined in sysmac.h }
  {-OBJTYPENAME UCS4Char 'BCi' 'GDi'}{char32_t}
  PUCS4Char = ^UCS4Char;
  {$NODEFINE PUCS4Char}         { defined in sysmac.h }

  TUCS4CharArray = array [0..$effffff] of UCS4Char;
  PUCS4CharArray = ^TUCS4CharArray;
  {$NODEFINE TUCS4CharArray}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '  typedef UCS4Char* TUCS4CharArray;' *)
  (*$HPPEMIT '}' *)

  UCS4String = array of UCS4Char;
  {$NODEFINE UCS4String}        { defined in sysmac.h }

{$IFDEF NEXTGEN}
  UTF8String = type _AnsiString(65001);
  RawByteString = type _AnsiString($ffff);
  {$NODEFINE UTF8String}
  {$NODEFINE RawByteString}
{$ELSE}
  UTF8String = type AnsiString(65001);
  RawByteString = type AnsiString($ffff);
{$ENDIF}
  PUTF8String = ^UTF8String;
  PRawByteString = ^RawByteString;
{$IFDEF NEXTGEN}
  {$NODEFINE PUTF8String}
  {$NODEFINE PRawByteString}
{$ENDIF}
  _RawByteStr = RawByteString;
  {$NODEFINE _RawByteStr}
  _PRawByteStr = PRawByteString;
  {$NODEFINE _PRawByteStr}
  _UTF8Str = UTF8String;
  {$NODEFINE _UTF8Str}
  _PUTF8Str = PUTF8String;
  {$NODEFINE _PUTF8Str}

  IntegerArray  = array[0..$effffff] of Integer;
  PIntegerArray = ^IntegerArray;
  {$NODEFINE IntegerArray}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '  typedef int* IntegerArray;' *)
  (*$HPPEMIT '}' *)

  Int64Array  = array[0..$0ffffffe] of Int64;
  PInt64Array = ^Int64Array;
  {$NODEFINE Int64Array}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '  typedef __int64* Int64Array;' *)
  (*$HPPEMIT '}' *)

  {$IFDEF CPU64BITS}
  PointerArray = array [0..256*1024*1024 - 2] of Pointer;
  {$ELSE !CPU64BITS}
  PointerArray = array [0..512*1024*1024 - 2] of Pointer;
  {$ENDIF !CPU64BITS}
  PPointerArray = ^PointerArray;
  {$NODEFINE PointerArray}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '  typedef void *PointerArray;' *)
  (*$HPPEMIT '}' *)

  TBoundArray = array of NativeInt;

  {$IFDEF CPU64BITS}
  TPCharArray = packed array[0..(MaxInt div SizeOf(PChar))-1] of PChar;
  {$ELSE !CPU64BITS}
  TPCharArray = packed array[0..(MaxLongInt div SizeOf(PChar))-1] of PChar;
  {$ENDIF !CPU64BITS}
  PPCharArray = ^TPCharArray;
  {$NODEFINE TPCharArray}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '  typedef PChar TPCharArray;' *)
  (*$HPPEMIT '}' *)

  PLongInt      = ^LongInt;
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  {$IFDEF LONGINTISCPPLONG}
  (*$HPPEMIT '  typedef long *PLongInt;' *)
  {$ELSE}
  (*$HPPEMIT '  typedef int *PLongInt;' *)
  {$ENDIF}
  (*$HPPEMIT '  typedef PLongInt PLongint;' *)
  (*$HPPEMIT '}' *)
  {$NODEFINE PLongInt}

  PInteger      = ^Integer;     {$NODEFINE PInteger}    { defined in sysmac.h }
  PCardinal     = ^Cardinal;
  PWord         = ^Word;
  PSmallInt     = ^SmallInt;    {$NODEFINE PSmallInt}   { defined in sysmac.h }
  {$POINTERMATH ON}
  PByte         = ^Byte;        {$NODEFINE PByte}       { defined in sysmac.h }
  {$POINTERMATH OFF}
  PShortInt     = ^ShortInt;    {$NODEFINE PShortInt}   { defined in sysmac.h }
  PInt64        = ^Int64;       {$NODEFINE PInt64}      { defined in sysmac.h }
  PUInt64       = ^UInt64;
  PLongWord     = ^LongWord;    {$NODEFINE PLongWord}   { defined in sysmac.h }
  PSingle       = ^Single;      {$NODEFINE PSingle}     { defined in sysmac.h }
  PDouble       = ^Double;      {$NODEFINE PDouble}     { defined in sysmac.h }
  PDate         = ^Double;
  PDispatch     = ^IDispatch;
  PPDispatch    = ^PDispatch;
  {$NODEFINE PDispatch}  // due to avoid compile error
  {$NODEFINE PPDispatch} // due to avoid compile error
  PError        = ^LongWord;
  PWordBool     = ^WordBool;
  PUnknown      = ^IUnknown;
  PPUnknown     = ^PUnknown;
  PPWideChar    = ^PWideChar;
{$IFDEF NEXTGEN}
  _PPAnsiChar   = ^_PAnsiChar;
  _PPAnsiChr    = _PPAnsiChar;
  {$NODEFINE _PPAnsiChar}
{$ELSE}
  PPAnsiChar    = ^PAnsiChar;
  _PPAnsiChr    = PPAnsiChar;
{$ENDIF}
  {$NODEFINE    _PPAnsiChr}
  PPChar        = PPWideChar;   {$NODEFINE PPChar}      { defined in sysmac.h }
  PExtended     = ^Extended;    {$NODEFINE PExtended}   { defined in sysmac.h }
  PComp         = ^Comp;
  PCurrency     = ^Currency;    {$NODEFINE PCurrency}   { defined in sysmac.h }
  PVariant      = ^Variant;     {$NODEFINE PVariant}    { defined in sysmac.h }
  POleVariant   = ^OleVariant;  {$NODEFINE POleVariant} { defined in sysmac.h }
  PPointer      = ^Pointer;     {$NODEFINE PPointer}    { defined in sysmac.h }
  PBoolean      = ^Boolean;     {$NODEFINE PBoolean}    { defined in sysmac.h }
  PNativeInt    = ^NativeInt;
  PNativeUInt   = ^NativeUInt;
  PMarshaledString = PPWideChar;  {$NODEFINE PMarshaledString}
  PMarshaledAString = _PPAnsiChr; {$NODEFINE PMarshaledAString}

  TDateTime = type Double;
  PDateTime = ^TDateTime;
  {$NODEFINE TDateTime 'TDateTime' 'TDateTimeBase'}     { defined in systdate.h }
  {$OBJTYPENAME TDateTime 'NTDateTime' }

  TDate = type TDateTime;
  TTime = type TDateTime;
  {$NODEFINE TDate 'TDate' 'TDateTimeBase'}
  {$NODEFINE TTime 'TTime' 'TDateTimeBase'}
{$IF defined(EXTERNALLINKER)}
  {$OBJTYPENAME TDate 'NTDate' }
  {$OBJTYPENAME TTime 'NTTime' }
{$ELSE}
  {$OBJTYPENAME TDate 'NTDateTime' }
  {$OBJTYPENAME TTime 'NTDateTime' }
{$ENDIF}
{$IF not defined(NEXTGEN) or defined(MSWINDOWS)}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '    typedef System::TDateTime TDate;' *)
  (*$HPPEMIT '    typedef System::TDateTime TTime;' *)
  (*$HPPEMIT '}' *)
{$ENDIF}

  THandle = NativeUInt;
  {$NODEFINE THandle}

  PVarArrayBound = ^TVarArrayBound;
  TVarArrayBound = record
    ElementCount: Integer;
    LowBound: Integer;
  end;
  TVarArrayBoundArray = array [0..0] of TVarArrayBound;
  PVarArrayBoundArray = ^TVarArrayBoundArray;
  TVarArrayCoorArray = array [0..0] of Integer;
  PVarArrayCoorArray = ^TVarArrayCoorArray;

  PVarArray = ^TVarArray;
  TVarArray = record
    DimCount: Word;
    Flags: Word;
    ElementSize: Integer;
    LockCount: Integer;
    Data: Pointer;
    Bounds: TVarArrayBoundArray;
  end;

  PVarRecord = ^TVarRecord;
  TVarRecord = record
    PRecord: Pointer;
    RecInfo: Pointer;
  end;

  TLargestVarData = record
    _Reserved1: Pointer;
    _Reserved2: Pointer;
  end;

  TVarType = Word;
  PVarData = ^TVarData;
  TVarData = packed record
    case Integer of
      0: (VType: TVarType;
          case Integer of
            0: (Reserved1: Word;
                case Integer of
                  0: (Reserved2, Reserved3: Word;
                      case Integer of
                        varSmallInt: (VSmallInt: SmallInt);
                        varInteger:  (VInteger: Integer);
                        varSingle:   (VSingle: Single);
                        varDouble:   (VDouble: Double);
                        varCurrency: (VCurrency: Currency);
                        varDate:     (VDate: TDateTime);
                        varOleStr:   (VOleStr: PWideChar);
                        varDispatch: (VDispatch: Pointer);
                        varError:    (VError: HRESULT);
                        varBoolean:  (VBoolean: WordBool);
                        varUnknown:  (VUnknown: Pointer);
                        varShortInt: (VShortInt: ShortInt);
                        varByte:     (VByte: Byte);
                        varWord:     (VWord: Word);
                        varLongWord: (VLongWord: Cardinal);
                        varInt64:    (VInt64: Int64);
                        varUInt64:   (VUInt64: UInt64);
                        varString:   (VString: Pointer);
                        varAny:      (VAny: Pointer);
                        varArray:    (VArray: PVarArray);
                        varByRef:    (VPointer: Pointer);
                        varUString:  (VUString: Pointer);
                        varRecord:   (VRecord: TVarRecord);
                        //$ffff:     (VLargest: TLargestVarData);
                     );
                  1: (VLongs: array[0..{$IFDEF CPU64BITS}4{$ELSE}2{$ENDIF}] of Integer);
               );
            2: (VWords: array [0..{$IFDEF CPU64BITS}10{$ELSE}6{$ENDIF}] of Word);
            3: (VBytes: array [0..{$IFDEF CPU64BITS}21{$ELSE}13{$ENDIF}] of Byte);
          );
      1: (RawData: array [0..{$IFDEF CPU64BITS}5{$ELSE}3{$ENDIF}] of Integer);
  end;
  {$EXTERNALSYM TVarData}
  {$EXTERNALSYM PVarData}

  // Sync with compiler internals
  TTypeKind = (tkUnknown, tkInteger, tkChar, tkEnumeration, tkFloat,
    tkString, tkSet, tkClass, tkMethod, tkWChar, tkLString, tkWString,
    tkVariant, tkArray, tkRecord, tkInterface, tkInt64, tkDynArray, tkUString,
    tkClassRef, tkPointer, tkProcedure {, tkMRecord});

type
  TVarOp = Integer;

const
  opAdd =        0;
  opSubtract =   1;
  opMultiply =   2;
  opDivide =     3;
  opIntDivide =  4;
  opModulus =    5;
  opShiftLeft =  6;
  opShiftRight = 7;
  opAnd =        8;
  opOr =         9;
  opXor =        10;
  opCompare =    11;
  opNegate =     12;
  opNot =        13;

  opCmpEQ =      14;
  opCmpNE =      15;
  opCmpLT =      16;
  opCmpLE =      17;
  opCmpGT =      18;
  opCmpGE =      19;

  tkAnsiChar =   TTypeKind.tkChar;
  tkWideChar =   TTypeKind.tkWChar;
  tkUnicodeString = TTypeKind.tkUString;
  tkAnsiString = TTypeKind.tkLString;
  tkWideString = TTypeKind.tkWString;
  tkShortString = TTypeKind.tkString;

  {The number of small block types employed by the default memory manager}
{$ifdef CPU386}
   NumSmallBlockTypes = 55;
{$else}
   NumSmallBlockTypes = 46;
{$endif}

type
  { Dispatch call descriptor }
  PCallDesc = ^TCallDesc;
  TCallDesc = packed record
    CallType: Byte;
    ArgCount: Byte;
    NamedArgCount: Byte;
    ArgTypes: array[0..255] of Byte;
  end;

  PDispDesc = ^TDispDesc;
  TDispDesc = packed record
    DispID: Integer;
    ResType: Byte;
    CallDesc: TCallDesc;
  end;

  PVariantManager = ^TVariantManager;
  TVariantManager = record
    VarClear: procedure(var V : Variant);
    VarCopy: procedure(var Dest: Variant; const Source: Variant);
    VarCopyNoInd: procedure; // ARGS PLEASE!
    VarCast: procedure(var Dest: Variant; const Source: Variant; VarType: Integer);
    VarCastOle: procedure(var Dest: Variant; const Source: Variant; VarType: Integer);

    VarToInt: function(const V: Variant): Integer;
    VarToInt64: function(const V: Variant): Int64;
    VarToBool: function(const V: Variant): Boolean;
    VarToReal: function(const V: Variant): Extended;
    VarToCurr: function(const V: Variant): Currency;
    VarToPStr: procedure(var S; const V: Variant);
    VarToLStr: procedure(var S: string; const V: Variant);
    VarToWStr: procedure(var S: _WideStr; const V: Variant);
    VarToIntf: procedure(var Unknown: IInterface; const V: Variant);
    VarToDisp: procedure(var Dispatch: IDispatch; const V: Variant);
    VarToDynArray: procedure(var DynArray: Pointer; const V: Variant; TypeInfo: Pointer);

    VarFromInt: procedure(var V: Variant; const Value: Integer; const Range: ShortInt);
    VarFromInt64: procedure(var V: Variant; const Value: Int64);
    VarFromBool: procedure(var V: Variant; const Value: Boolean);
    VarFromReal: procedure; // var V: Variant; const Value: Real
    VarFromTDateTime: procedure; // var V: Variant; const Value: TDateTime
    VarFromCurr: procedure; // var V: Variant; const Value: Currency
    VarFromPStr: procedure(var V: Variant; const Value: _ShortStr);
    VarFromLStr: procedure(var V: Variant; const Value: string);
    VarFromWStr: procedure(var V: Variant; const Value: _WideStr);
    VarFromIntf: procedure(var V: Variant; const Value: IInterface);
    VarFromDisp: procedure(var V: Variant; const Value: IDispatch);
    VarFromDynArray: procedure(var V: Variant; const DynArray: Pointer; TypeInfo: Pointer);
    OleVarFromPStr: procedure(var V: OleVariant; const Value: _ShortStr);
    OleVarFromLStr: procedure(var V: OleVariant; const Value: string);
    OleVarFromVar: procedure(var V: OleVariant; const Value: Variant);
    OleVarFromInt: procedure(var V: OleVariant; const Value: Integer; const Range: ShortInt);
    OleVarFromInt64: procedure(var V: OleVariant; const Value: Int64);

    VarOp: procedure(var Left: Variant; const Right: Variant; OpCode: TVarOp);
    VarCmp: procedure(const Left, Right: TVarData; const OpCode: TVarOp); { result is set in the flags }
    VarNeg: procedure(var V: Variant);
    VarNot: procedure(var V: Variant);

    DispInvoke: procedure(Dest: PVarData; const Source: TVarData;
      CallDesc: PCallDesc; Params: Pointer); cdecl;
    VarAddRef: procedure(var V: Variant);

    VarArrayRedim: procedure(var A : Variant; HighBound: Integer);
    VarArrayGet: function(var A: Variant; IndexCount: Integer;
      Indices: Integer): Variant; cdecl;
    VarArrayPut: procedure(var A: Variant; const Value: Variant;
      IndexCount: Integer; Indices: Integer); cdecl;

    WriteVariant: function(var T: Text; const V: Variant; Width: Integer): Pointer;
    Write0Variant: function(var T: Text; const V: Variant): Pointer;
  end deprecated;

  { Dynamic array support }
  PDynArrayTypeInfo = ^TDynArrayTypeInfo;
  {$EXTERNALSYM PDynArrayTypeInfo}
  TDynArrayTypeInfo = packed record
    kind: TTypeKind;
    name: Byte; {string[0];}
    elSize: Integer;
    elType: ^PDynArrayTypeInfo;
    varType: Integer;
  end;
  {$EXTERNALSYM TDynArrayTypeInfo}

  PVarRec = ^TVarRec;
  TVarRec = record { do not pack this record; it is compiler-generated }
    case Integer of
      0: (case Byte of
            vtInteger:       (VInteger: Integer);
            vtBoolean:       (VBoolean: Boolean);
            vtChar:          (VChar: _AnsiChr);
            vtExtended:      (VExtended: PExtended);
{$IFNDEF NEXTGEN}
            vtString:        (VString: _PShortStr);
{$ENDIF !NEXTGEN}
            vtPointer:       (VPointer: Pointer);
            vtPChar:         (VPChar: _PAnsiChr);
{$IFDEF AUTOREFCOUNT}
            vtObject:        (VObject: Pointer);
{$ELSE}
            vtObject:        (VObject: TObject);
{$ENDIF}
            vtClass:         (VClass: TClass);
            vtWideChar:      (VWideChar: WideChar);
            vtPWideChar:     (VPWideChar: PWideChar);
            vtAnsiString:    (VAnsiString: Pointer);
            vtCurrency:      (VCurrency: PCurrency);
            vtVariant:       (VVariant: PVariant);
            vtInterface:     (VInterface: Pointer);
            vtWideString:    (VWideString: Pointer);
            vtInt64:         (VInt64: PInt64);
            vtUnicodeString: (VUnicodeString: Pointer);
         );
      1: (_Reserved1: NativeInt;
          VType:      Byte;
         );
  end;
  {$NODEFINE PVarRec}   { defined in systvar.h }
  {$NODEFINE TVarRec}   { defined in systvar.h }

  {$IF defined(PUREPASCAL)}
  {$IF defined(CPUX64) and not defined(MSWINDOWS)}
                                         
  /// <summary>Used to get values of varargs argument.</summary>
  TVarArgList = record
    /// <summary>Internal use only</summary>
    __F1: Int32;
    /// <summary>Internal use only</summary>
    __F2: Int32;
    /// <summary>Internal use only</summary>
    __F3: Pointer;
    /// <summary>Internal use only</summary>
    __F4: Pointer;
  end;
  {$DEFINE RECORD_TVARARGLIST}
  {$ELSE CPUX86 or CPUARM or (CPUX64 and MSWINDOWS)}
  /// <summary>Used to get values of varargs argument.</summary>
  TVarArgList = Pointer;
  {$ENDIF}
  // procedure VarArgStart(var ArgList: TVarArgList);
  // function  VarArgGetValue(var ArgList: TVarArgList; ArgType: Type): ArgType;
  // procedure VarArgCopy(var DestArgList, SrcArgList: TVarArgList);
  // procedure VarArgEnd(var ArgList: TVarArgList);
  {$ENDIF}

  {The old memory manager structure (for backward compatibility)}
  PMemoryManager = ^TMemoryManager;
  TMemoryManager = record
    GetMem: function(Size: NativeInt): Pointer;
    FreeMem: function(P: Pointer): Integer;
    ReallocMem: function(P: Pointer; Size: NativeInt): Pointer;
  end deprecated 'Use TMemoryManagerEx';

  {The new memory manager structure with expanded functionality}
  PMemoryManagerEx = ^TMemoryManagerEx;
  TMemoryManagerEx = record
    {The basic (required) memory manager functionality}
    GetMem: function(Size: NativeInt): Pointer;
    FreeMem: function(P: Pointer): Integer;
    ReallocMem: function(P: Pointer; Size: NativeInt): Pointer;
    {Extended (optional) functionality.}
    AllocMem: function(Size: NativeInt): Pointer;
    RegisterExpectedMemoryLeak: function(P: Pointer): Boolean;
    UnregisterExpectedMemoryLeak: function(P: Pointer): Boolean;
  end;

  THeapStatus = record
    TotalAddrSpace: NativeUInt;
    TotalUncommitted: NativeUInt;
    TotalCommitted: NativeUInt;
    TotalAllocated: NativeUInt;
    TotalFree: NativeUInt;
    FreeSmall: NativeUInt;
    FreeBig: NativeUInt;
    Unused: NativeUInt;
    Overhead: NativeUInt;
    HeapErrorCode: Cardinal;
  end deprecated;

  TSmallBlockTypeState = packed record
    {The internal size of the block type}
    InternalBlockSize: Cardinal;
    {Useable block size: The number of non-reserved bytes inside the block.}
    UseableBlockSize: Cardinal;
    {The number of allocated blocks}
    AllocatedBlockCount: NativeUInt;
    {The total address space reserved for this block type (both allocated and
     free blocks)}
    ReservedAddressSpace: NativeUInt;
  end;
  TSmallBlockTypeStates = array[0..NumSmallBlockTypes - 1] of TSmallBlockTypeState;

  TMemoryManagerState = packed record
    {Small block type states}
    SmallBlockTypeStates: TSmallBlockTypeStates;
    {Medium block stats}
    AllocatedMediumBlockCount: Cardinal;
    TotalAllocatedMediumBlockSize: NativeUInt;
    ReservedMediumBlockAddressSpace: NativeUInt;
    {Large block stats}
    AllocatedLargeBlockCount: Cardinal;
    TotalAllocatedLargeBlockSize: NativeUInt;
    ReservedLargeBlockAddressSpace: NativeUInt;
  end;

  PMonitorSupport = ^TMonitorSupport;
  TMonitorSupport = record
    // Obtain a synchronization object - usually an auto-reset event or semaphore
    NewSyncObject: function: Pointer;
    // Free the synchronization object obtained from NewSyncObject
    FreeSyncObject: procedure (SyncObject: Pointer);
    // Obtain a wait object - usually an auto-reset event or semaphore - these should be cached
    NewWaitObject: function: Pointer;
    // Return the wait object from NewWaitObject back to the cache
    FreeWaitObject: procedure (WaitObject: Pointer);
    // Wait for either a SyncObject or WaitObject or signal an object
    // o WaitOrSignalObject(nil, Obj, Timeout); - Wait for <Timeout> time or until <Obj> is signaled
    // o WaitOrSignalObject(Obj, nil, 0); - Signal <Obj> and return. Timeout and WaitObject params ignored.
    WaitOrSignalObject: function (SignalObject, WaitObject: Pointer; Timeout: Cardinal): Cardinal;
  end;

  { Opaque pointer wrapper }
  TPtrWrapper = record
  private
    Value: PByte;
    class function GetNilValue: TPtrWrapper; inline; static;
  public
    constructor Create(AValue: NativeInt); overload;
    constructor Create(AValue: Pointer); overload;

    function ToPointer: Pointer;
    function ToInteger: NativeInt;

    class property NilValue: TPtrWrapper read GetNilValue;

    class operator Equal(Left, Right: TPtrWrapper): Boolean;
    class operator NotEqual(Left, Right: TPtrWrapper): Boolean;
  end;

  { Low level marshalling }
  TMarshal = class(TObject)
    constructor Create;

    // Internal legacy: uses should probably be rewritten using TMarshaller.
    class function InString(const S: string): MarshaledString; overload; inline; static;
    class function OutString(const S: string): MarshaledString; overload; inline; static;
    class function InOutString(const S: string): MarshaledString; overload; inline; static;
    class function AsAnsi(const S: string): _AnsiStr; overload; inline; static;
    class function AsAnsi(S: PWideChar): _AnsiStr; overload; inline; static;

    // Memory allocation
    class function AllocMem(Size: NativeInt): TPtrWrapper;
    class function ReallocMem(OldPtr: TPtrWrapper; NewSize: NativeInt): TPtrWrapper;
    class procedure FreeMem(Ptr: TPtrWrapper);

    // Plain data in and out, via arrays
    class procedure Copy(Src: TArray<Byte>; StartIndex: Integer; Dest: TPtrWrapper; Count: Integer); overload;
    class procedure Copy(Src: TPtrWrapper; Dest: TArray<Byte>; StartIndex: Integer; Count: Integer); overload;
    class procedure Copy(Src: TArray<Char>; StartIndex: Integer; Dest: TPtrWrapper; Count: Integer); overload;
    class procedure Copy(Src: TPtrWrapper; Dest: TArray<Char>; StartIndex: Integer; Count: Integer); overload;
    class procedure Copy(Src: TArray<Word>; StartIndex: Integer; Dest: TPtrWrapper; Count: Integer); overload;
    class procedure Copy(Src: TPtrWrapper; Dest: TArray<Word>; StartIndex: Integer; Count: Integer); overload;
    class procedure Copy(Src: TArray<Shortint>; StartIndex: Integer; Dest: TPtrWrapper; Count: Integer); overload;
    class procedure Copy(Src: TPtrWrapper; Dest: TArray<Shortint>; StartIndex: Integer; Count: Integer); overload;
    class procedure Copy(Src: TArray<Smallint>; StartIndex: Integer; Dest: TPtrWrapper; Count: Integer); overload;
    class procedure Copy(Src: TPtrWrapper; Dest: TArray<Smallint>; StartIndex: Integer; Count: Integer); overload;
    class procedure Copy(Src: TArray<Integer>; StartIndex: Integer; Dest: TPtrWrapper; Count: Integer); overload;
    class procedure Copy(Src: TPtrWrapper; Dest: TArray<Integer>; StartIndex: Integer; Count: Integer); overload;
    class procedure Copy(Src: TArray<Int64>; StartIndex: Integer; Dest: TPtrWrapper; Count: Integer); overload;
    class procedure Copy(Src: TPtrWrapper; Dest: TArray<Int64>; StartIndex: Integer; Count: Integer); overload;
    class procedure Copy(Src: TArray<TPtrWrapper>; StartIndex: Integer; Dest: TPtrWrapper; Count: Integer); overload;
    class procedure Copy(Src: TPtrWrapper; Dest: TArray<TPtrWrapper>; StartIndex: Integer; Count: Integer); overload;

    // Plain data in and out, via singular elements, to avoid needing arrays
    class function ReadByte(Ptr: TPtrWrapper; Ofs: NativeInt = 0): Byte;
    class function ReadInt16(Ptr: TPtrWrapper; Ofs: NativeInt = 0): Smallint;
    class function ReadInt32(Ptr: TPtrWrapper; Ofs: NativeInt = 0): Integer;
    class function ReadInt64(Ptr: TPtrWrapper; Ofs: NativeInt = 0): Int64;
    class function ReadPtr(Ptr: TPtrWrapper; Ofs: NativeInt = 0): TPtrWrapper;

    class procedure WriteByte(Ptr: TPtrWrapper; Ofs: NativeInt; Value: Byte); overload;
    class procedure WriteInt16(Ptr: TPtrWrapper; Ofs: NativeInt; Value: Smallint); overload;
    class procedure WriteInt32(Ptr: TPtrWrapper; Ofs: NativeInt; Value: Integer); overload;
    class procedure WriteInt64(Ptr: TPtrWrapper; Ofs: NativeInt; Value: Int64); overload;
    class procedure WritePtr(Ptr: TPtrWrapper; Ofs: NativeInt; Value: TPtrWrapper); overload;

    class procedure WriteByte(Ptr: TPtrWrapper; Value: Byte); overload;
    class procedure WriteInt16(Ptr: TPtrWrapper; Value: Smallint); overload;
    class procedure WriteInt32(Ptr: TPtrWrapper; Value: Integer); overload;
    class procedure WriteInt64(Ptr: TPtrWrapper; Value: Int64); overload;
    class procedure WritePtr(Ptr, Value: TPtrWrapper); overload;

    // A moderately wrapped version of System.Move, to discourage use.
    class procedure Move(Src, Dest: TPtrWrapper; Count: NativeInt); inline;

    // Direct referencing of array data
    class function FixArray<T>(const Arr: TArray<T>): TPtrWrapper; overload;
    class procedure UnfixArray<T>(ArrPtr: TPtrWrapper); overload;

    // Direct referencing of Unicode string data
    class function FixString(var Str: string): TPtrWrapper; overload;
    class procedure UnfixString(Ptr: TPtrWrapper); overload;
    // Direct reference to string that may be shared; returned value still needs disposal with UnfixString.
    class function UnsafeFixString(const Str: string): TPtrWrapper; overload;

    // Direct and unsafe referencing of random data.
    class function UnsafeAddrOf(var Value): TPtrWrapper; inline;

    // Copy string to newly allocated buffer (needs to be freed with .FreeMem)
    class function AllocStringAsAnsi(const Str: string): TPtrWrapper; overload;
    class function AllocStringAsAnsi(const Str: string; CodePage: Word): TPtrWrapper; overload;
    class function AllocStringAsUnicode(const Str: string): TPtrWrapper;
    class function AllocStringAsAnsi(S: PWideChar): TPtrWrapper; overload;
    class function AllocStringAsAnsi(S: PWideChar; CodePage: Word): TPtrWrapper; overload;
    class function AllocStringAsUtf8(const Str: string): TPtrWrapper; overload;
    class function AllocStringAsUtf8(S: PWideChar): TPtrWrapper; overload;

    // Copy string from buffer; Len = number of characters to read from Ptr, or -1 to read until null terminator.
    class function ReadStringAsAnsi(Ptr: TPtrWrapper; Len: Integer = -1): string; overload;
    class function ReadStringAsAnsi(CodePage: Word; Ptr: TPtrWrapper; Len: Integer = -1): string; overload;
    class function ReadStringAsUnicode(Ptr: TPtrWrapper; Len: Integer = -1): string;
    class function ReadStringAsUtf8(Ptr: TPtrWrapper; Len: Integer = -1): string;

    // Copy string from buffer; MaxLen = maximum number of characters to read from Ptr before null terminator.
    class function ReadStringAsAnsiUpTo(CodePage: Word; Ptr: TPtrWrapper; MaxLen: Integer): string;
    class function ReadStringAsUnicodeUpTo(Ptr: TPtrWrapper; MaxLen: Integer): string;
    class function ReadStringAsUtf8UpTo(Ptr: TPtrWrapper; MaxLen: Integer): string;

    // Copy string to buffer
    // Specify -1 for MaxCharsIncNull and the entire string will be written.
    class procedure WriteStringAsAnsi(Ptr: TPtrWrapper; const Value: string; MaxCharsIncNull: Integer); overload;
    class procedure WriteStringAsAnsi(Ptr: TPtrWrapper; const Value: string; MaxCharsIncNull: Integer; CodePage: Word); overload;
    class procedure WriteStringAsAnsi(Ptr: TPtrWrapper; Ofs: NativeInt; const Value: string; MaxCharsIncNull: Integer); overload;
    class procedure WriteStringAsAnsi(Ptr: TPtrWrapper; Ofs: NativeInt; const Value: string; MaxCharsIncNull: Integer; CodePage: Word); overload;
    class procedure WriteStringAsUnicode(Ptr: TPtrWrapper; const Value: string; MaxCharsIncNull: Integer); overload;
    class procedure WriteStringAsUnicode(Ptr: TPtrWrapper; Ofs: NativeInt; const Value: string; MaxCharsIncNull: Integer); overload;
    class procedure WriteStringAsUtf8(Ptr: TPtrWrapper; const Value: string; MaxCharsIncNull: Integer); overload;
    class procedure WriteStringAsUtf8(Ptr: TPtrWrapper; Ofs: NativeInt; const Value: string; MaxCharsIncNull: Integer); overload;
  end;
  {$NODEFINE TMarshal}

  {Memory map}
  TChunkStatus = (csUnallocated, csAllocated, csReserved,
    csSysAllocated, csSysReserved);
  TMemoryMap = array[0..65535] of TChunkStatus;

  {Block alignment options}
  TMinimumBlockAlignment = (mba8Byte, mba16Byte);

{$IFDEF PC_MAPPED_EXCEPTIONS}
                                                                                     
  PUnwinder = ^TUnwinder;
  TUnwinder = record
    RaiseException: function(Exc: Pointer): LongBool; cdecl;
    RegisterIPLookup: function(fn: Pointer; StartAddr, EndAddr: NativeUInt; Context: Pointer; GOT: NativeUInt): LongBool; cdecl;
    UnregisterIPLookup: procedure(StartAddr: NativeUInt) cdecl;
    DelphiLookup: function(Addr: NativeUInt; Context: Pointer): Pointer; cdecl;
    ClosestHandler: function(Context: Pointer): NativeUInt; cdecl;
  end;
  TFrameUnwinder = Pointer;
                                                                                           
  TUnwinderLookup = function(Addr: NativeUInt; Context: Pointer): TFrameUnwinder; cdecl;
{$ENDIF PC_MAPPED_EXCEPTIONS}

  PackageUnitEntry = packed record
    Init, FInit : Pointer;
  end;

  { Compiler generated table to be processed sequentially to init & finit all package units }
  { Init: 0..Max-1; Final: Last Initialized..0                                              }
  UnitEntryTable = array [0..9999999] of PackageUnitEntry;
  PUnitEntryTable = ^UnitEntryTable;
  { Pointer in this table is PPTypeInfo, except when it's not; if the value is 1,
    then it's a "unit boundary" marker, indicating that following types are in
    the next unit along in the TPackageTypeInfo.UnitNames unit name list sequence. }
  TTypeTable = array[0..MaxInt div SizeOf(Pointer) - 1] of Pointer;
  PTypeTable = ^TTypeTable;

  {$NODEFINE UnitEntryTable}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '    typedef struct PackageUnitEntry UnitEntryTable;' *)
  (*$HPPEMIT '}' *)

  PPackageTypeInfo = ^TPackageTypeInfo;
  TPackageTypeInfo = record
    TypeCount: Integer;
    TypeTable: PTypeTable;
    UnitCount: Integer;
    UnitNames: _PShortStr; { concatenation of Pascal strings, one for each unit }
  end;

  PackageInfoTable = record
    UnitCount: Integer;      { number of entries in UnitInfo array; always > 0 }
    UnitInfo: PUnitEntryTable;
    TypeInfo: TPackageTypeInfo;
  end;

  PackageInfo = ^PackageInfoTable;

  { Each package exports a '@GetPackageInfoTable' which can be used to retrieve }
  { the table which contains compiler generated information about the package DLL }
  GetPackageInfoTable = function : PackageInfo;

{$IFDEF DEBUG_FUNCTIONS}
{ Inspector Query; implementation in GETMEM.INC; no need to conditionalize that }
  THeapBlock = record
    Start: Pointer;
    Size: Cardinal;
  end;

  THeapBlockArray = array of THeapBlock;
  TObjectArray = array of TObject;

function GetHeapBlocks: THeapBlockArray;
function FindObjects(AClass: TClass; FindDerived: Boolean): TObjectArray;
{ Inspector Query }
{$ENDIF}

{
  When an exception is thrown, the exception object that is thrown is destroyed
  automatically when the except clause which handles the exception is exited.
  There are some cases in which an application may wish to acquire the thrown
  object and keep it alive after the except clause is exited.  For this purpose,
  we have added the AcquireExceptionObject and ReleaseExceptionObject functions.
  These functions maintain a reference count on the most current exception object,
  allowing applications to legitimately obtain references.  If the reference count
  for an exception that is being thrown is positive when the except clause is exited,
  then the thrown object is not destroyed by the RTL, but assumed to be in control
  of the application.  It is then the application's responsibility to destroy the
  thrown object.  If the reference count is zero, then the RTL will destroy the
  thrown object when the except clause is exited.
}
function AcquireExceptionObject: Pointer;
procedure ReleaseExceptionObject;

{$IFDEF PC_MAPPED_EXCEPTIONS}
procedure GetUnwinder(var Dest: TUnwinder);
procedure SetUnwinder(const NewUnwinder: TUnwinder);
function IsUnwinderSet: Boolean;

//function SysRegisterIPLookup(ModuleHandle, StartAddr, EndAddr: LongInt; Context: Pointer; GOT: LongInt): LongBool;
{
  Do NOT call these functions.  They are for internal use only:
    SysRegisterIPLookup
    SysUnregisterIPLookup
    BlockOSExceptions
    UnblockOSExceptions
    AreOSExceptionsBlocked
}
                                                                                     
function SysRegisterIPLookup(StartAddr, EndAddr: NativeUInt; Context: Pointer; GOT: NativeUInt): LongBool;
function SysRegisterIPLookupFunc(StartAddr, EndAddr: NativeUInt; Context: Pointer; GOT: NativeUInt;
                            UnwinderLookup: TUnwinderLookup): LongBool;
procedure SysUnregisterIPLookup(StartAddr: NativeUInt);
//function SysAddressIsInPCMap(Addr: NativeUInt): Boolean;
function SysClosestDelphiHandler(Context: Pointer): NativeUInt;
procedure BlockOSExceptions;
procedure UnblockOSExceptions;
function AreOSExceptionsBlocked: Boolean;

{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF STACK_BASED_EXCEPTIONS}
// These functions are not portable.  Use AcquireExceptionObject above instead
function RaiseList: Pointer; deprecated 'Use AcquireExceptionObject';  { Stack of current exception objects }
function SetRaiseList(NewPtr: Pointer): Pointer; deprecated 'Use AcquireExceptionObject';  { returns previous value }
{$ENDIF STACK_BASED_EXCEPTIONS}

function ExceptObject: TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};
function ExceptAddr: Pointer;

{$IFDEF MSWINDOWS}
{
  Coverage support.  These are internal use structures referenced by compiler
  helper functions for QA coverage support.
}
type
    TCVModInfo = packed record
        ModName: _PAnsiChr;
        LibName: _PAnsiChr;
        UserData: Pointer;
        end;
    PCVModInfo = ^TCVModInfo;

{$EXTERNALSYM _CVR_PROBE}
procedure _CVR_PROBE(mi: PCVModInfo; probeNum: Cardinal); cdecl;
{$EXTERNALSYM _CVR_STMTPROBE}
function _CVR_STMTPROBE(mi: PCVModInfo; probeNum: Cardinal; TrueFalse: Cardinal): Boolean; cdecl;
{$ENDIF MSWINDOWS}

type
  TAssertErrorProc = procedure (const Message, Filename: string;
    LineNumber: Integer; ErrorAddr: Pointer);
  TSafeCallErrorProc = procedure (ErrorCode: HResult; ErrorAddr: Pointer);
  TRaiseExceptionProc = procedure (ExceptionCode, ExceptionFlags: UInt32;
    NumberOfArguments: UInt32; Args: Pointer); stdcall;

{$IFDEF DEBUG}
{
  This variable is just for debugging the exception handling system.  See
  _DbgExcNotify for the usage.
}
var
  ExcNotificationProc : procedure(NotificationKind: Integer;
                                  ExceptionObject: Pointer;
                                  ExceptionName: _PShortStr;
                                  ExceptionLocation: Pointer;
                                  HandlerAddr: Pointer) = nil;
{$ENDIF DEBUG}

var
  DispCallByIDProc: Pointer;
  ExceptProc: Pointer;    { Unhandled exception handler }
  ErrorProc: procedure (ErrorCode: Byte; ErrorAddr: Pointer);     { Error handler procedure }
{$IFDEF MSWINDOWS}
  ExceptClsProc: Pointer; { Map an OS Exception to a Delphi class reference }
  ExceptObjProc: Pointer; { Map an OS Exception to a Delphi class instance }
{$IF defined(CPU386)}
  RaiseExceptionProc: Pointer;
{$ELSE}
  RaiseExceptionProc: TRaiseExceptionProc;
{$ENDIF}
  RTLUnwindProc: Pointer;
{$ENDIF MSWINDOWS}
  RaiseExceptObjProc: Pointer; { notify of the raise of an exception object }
  ExceptionAcquired: Pointer; { notification that a given exception object has been "acquired" (C++)}
  ExceptionClass: TClass; { Exception base class (must be Exception) }
  SafeCallErrorProc: TSafeCallErrorProc; { Safecall error handler }
  AssertErrorProc: TAssertErrorProc; { Assertion error handler }
  ExitProcessProc: procedure; { Hook to be called just before the process actually exits }
  AbstractErrorProc: procedure; { Abstract method error handler }
{$IFDEF MSWINDOWS}
  HPrevInst: LongWord deprecated;    { Handle of previous instance - HPrevInst cannot be tested for multiple instances in Win32}
{$ENDIF}
  MainInstance: THandle;    { Handle of the main(.EXE) HInstance }
{$IFDEF MSWINDOWS}
  {$NODEFINE MainInstance}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '    extern DELPHI_PACKAGE HINSTANCE MainInstance;' *)
  (*$HPPEMIT '}' *)
{$ENDIF}
  MainThreadID: TThreadID;  { ThreadID of thread that module was initialized in }
  IsLibrary: Boolean;       { True if module is a DLL }
{$IFDEF MSWINDOWS}
  CmdShow: Integer platform;{ CmdShow parameter for CreateWindow }
  CmdLine: PChar platform;  { Command line pointer }
{$ENDIF MSWINDOWS}
  InitProc: Pointer;        { Last installed initialization procedure }
  ExitCode: Integer = 0;    { Program result }
  ExitProc: Pointer;        { Last installed exit procedure }
  ErrorAddr: Pointer = nil; { Address of run-time error }
  RandSeed: Integer = 0;    { Base for random number generator }
  IsConsole: Boolean;       { True if compiled as console app }
  IsMultiThread: Boolean;   { True if more than one thread }
  FileMode: Byte = 2;       { Standard mode for opening files }
{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
  FileAccessRights: Integer platform; { Default access rights for opening files }
  ArgCount: Integer platform;
  ArgValues: _PPAnsiChr platform;
  envp: PPChar platform;
{$ENDIF LINUX or MACOS or ANDROID}
{$IF defined(CPUX86) or defined(CPUX64)}
  Test8086: Byte;           { CPU family (minus one) See consts below }
  Test8087: Byte = 3;       { assume 80387 FPU or OS supplied FPU emulation }
  TestFDIV: Shortint;       { -1: Flawed Pentium, 0: Not determined, 1: Ok }
  TestSSE: Cardinal;        { 0: no SSE, 1st bit: SSE available, 2nd bit: SSE2 available }
{$ENDIF defined(CPUX86) or defined(CPUX64)}
  CPUCount: Integer;        { Number of CPU Cores detected }
  Input: Text;              { Standard input }
  Output: Text;             { Standard output }
  ErrOutput: Text;          { Standard error output }

  VarClearProc:  procedure (var v: TVarData) = nil; // for internal use only
  VarAddRefProc: procedure (var v: TVarData) = nil; // for internal use only
  VarCopyProc:   procedure (var Dest: TVarData; const Source: TVarData) = nil; // for internal use only
  VarToLStrProc: procedure (var Dest: _AnsiStr; const Source: TVarData) = nil;   // for internal use only
{$IFNDEF NEXTGEN}
  VarToWStrProc: procedure (var Dest: _WideStr; const Source: TVarData) = nil;   // for internal use only
{$ENDIF !NEXTGEN}
  VarToUStrProc: procedure (var Dest: UnicodeString; const Source: TVarData) = nil;// for internal use only

  MonitorSupport: PMonitorSupport;
  {$EXTERNALSYM MonitorSupport}

{$IF Defined(CPUX86) or Defined(CPUX64)}
const
  CPUi386     = 2;
  CPUi486     = 3;
  CPUPentium  = 4;
{$ENDIF }

{$IF Defined(CPUARM)}
var
  DefaultFPSCR: UInt32 platform = $00000700; { Default FPSCR register setting.
                                 Disable Flush to Zero, RN and Enable Invalid, Zero-div
                                 and overflow exception. }
{$ELSEIF Defined(CPUX86) or Defined(CPUX64)}
var
  Default8087CW: Word platform = $1332;  { Default 8087 control word.  FPU control
                                register is set to this value.
                                CAUTION:  Setting this to an invalid value
                                could cause unpredictable behavior. }
  DefaultMXCSR: UInt32 platform = $1900; { Default MXCSR control word.  SSE control
                                register is set to this value.
                                CAUTION:  Setting this to an invalid value
                                could cause unpredictable behavior. }
{$ENDIF CPUARM or CPUX86 or CPUX64}
  HeapAllocFlags: Word platform = 2;   { Heap allocation flags, gmem_Moveable }
  DebugHook: Byte platform = 0;        { 1 to notify debugger of non-Delphi exceptions
                                >1 to notify debugger of exception unwinding }
  JITEnable: Byte platform = 0;        { 1 to call UnhandledExceptionFilter if the exception
                                is not a Pascal exception.
                                >1 to call UnhandledExceptionFilter for all exceptions }
  NoErrMsg: Boolean platform = False;  { True causes the base RTL to not display the message box
                                when a run-time error occurs }
{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
                              { CoreDumpEnabled = True will cause unhandled
                                exceptions and runtime errors to raise a
                                SIGABRT signal, which will cause the OS to
                                coredump the process address space.  This can
                                be useful for postmortem debugging. }
  CoreDumpEnabled: Boolean platform = False;
{$ENDIF LINUX or MACOS or ANDROID}
  DefaultSystemCodePage: Integer;
  DefaultUnicodeCodePage: Integer; { Used by _NewUnicodeString to set the codePage field of strRec }
{$IFDEF MSWINDOWS}
  UTF8CompareLocale: Cardinal;
{$ENDIF MSWINDOWS}

{$IFDEF POSIX}
{$IF defined(USE_LIBICU)}
  function UTF8CompareCollator: Pointer;
  function UTF8CompareLocale: MarshaledAString;
{$ELSE}
  function UTF8CompareLocale: Pointer;
  function UTF8CompareLocaleName: MarshaledAString;
{$ENDIF defined(USE_LIBICU)}
  function SetUTF8CompareLocale(const LocaleName: string): Boolean; platform;
{$ELSE}
  procedure SetUTF8CompareLocale; platform;
{$ENDIF}

type
  TTextLineBreakStyle = (tlbsLF, tlbsCRLF);

var   { Text output line break handling.  Default value for all text files }
  DefaultTextLineBreakStyle: TTextLineBreakStyle = {$IFDEF POSIX} tlbsLF {$ENDIF}
                                                 {$IFDEF MSWINDOWS} tlbsCRLF {$ENDIF};
const
   sLineBreak = {$IFDEF POSIX} _AnsiChr(#10) {$ENDIF}
       {$IFDEF MSWINDOWS} _AnsiStr(#13#10) {$ENDIF};


type
  HRSRC = THandle;              { from windef.h / winnt.h }
  TResourceHandle = HRSRC;   // make an opaque handle type
  HINST = THandle;              { HINSTANCE from widnef.h }
  HMODULE = HINST;              { from windef.h }
  HGLOBAL = THandle;            { from windef.h }
{$IFDEF MSWINDOWS}
  {$EXTERNALSYM HRSRC}
  {$NODEFINE HINST}
  {$EXTERNALSYM HMODULE}
  {$EXTERNALSYM HGLOBAL}
{$ENDIF}

{$HPPEMIT '#if defined(FindResource)'}
{$HPPEMIT '#define Save_FindResource'}
{$HPPEMIT '#undef FindResource'}
{$HPPEMIT '#endif'}
{$HPPEMIT END '#if defined(Save_FindResource)'}
{$HPPEMIT END '#ifdef UNICODE'}
{$HPPEMIT END '#define FindResource FindResourceW'}
{$HPPEMIT END '#else'}
{$HPPEMIT END '#define FindResource FindResourceA'}
{$HPPEMIT END '#endif'}
{$HPPEMIT END '#undef Save_FindResource'}
{$HPPEMIT END '#endif'}
{$HPPEMIT '#if defined(UnlockResource)'}
{$HPPEMIT '#define Save_UnlockResource'}
{$HPPEMIT '#undef UnlockResource'}
{$HPPEMIT '#endif'}
{$HPPEMIT END '#if defined(Save_UnlockResource)'}
{$HPPEMIT END '#define UnlockResource(hResData) ((hResData), 0)'}
{$HPPEMIT END '#undef Save_UnlockResource'}
{$HPPEMIT END '#endif'}
function FindResource(ModuleHandle: HMODULE; ResourceName, ResourceType: PChar): TResourceHandle; {$IFDEF MSWINDOWS} stdcall; {$ENDIF}
function LoadResource(ModuleHandle: HMODULE; ResHandle: TResourceHandle): HGLOBAL; {$IFDEF MSWINDOWS} stdcall; {$ENDIF}
function SizeofResource(ModuleHandle: HMODULE; ResHandle: TResourceHandle): Integer; {$IFDEF MSWINDOWS} stdcall; {$ENDIF}
function LockResource(ResData: HGLOBAL): Pointer; {$IFDEF MSWINDOWS} stdcall; {$ENDIF}
function UnlockResource(ResData: HGLOBAL): LongBool; inline;
function FreeResource(ResData: HGLOBAL): LongBool; {$IFDEF MSWINDOWS} stdcall; {$ENDIF}

{ Memory manager support }

procedure GetMemoryManager(var MemMgr: TMemoryManager); overload; deprecated;
procedure SetMemoryManager(const MemMgr: TMemoryManager); overload; deprecated;
procedure GetMemoryManager(var MemMgrEx: TMemoryManagerEx); overload;
procedure SetMemoryManager(const MemMgrEx: TMemoryManagerEx); overload;
function IsMemoryManagerSet: Boolean;

function SysGetMem(Size: NativeInt): Pointer;
function SysFreeMem(P: Pointer): Integer;
function SysReallocMem(P: Pointer; Size: NativeInt): Pointer;
function SysAllocMem(Size: NativeInt): Pointer;
function SysRegisterExpectedMemoryLeak(P: Pointer): Boolean;
function SysUnregisterExpectedMemoryLeak(P: Pointer): Boolean;

{ AllocMem allocates a block of the given size on the heap. Each byte in
  the allocated buffer is set to zero. To dispose the buffer, use the
  FreeMem standard procedure. }

function AllocMem(Size: NativeInt): Pointer;

var

  AllocMemCount: Integer deprecated; {Unsupported}
  AllocMemSize: Integer deprecated; {Unsupported}

{Set this variable to true to report memory leaks on shutdown. This setting
 has no effect if this module is sharing a memory manager owned by another
 module.}
  ReportMemoryLeaksOnShutdown: Boolean;

{Set this variable to true to employ a "busy waiting" loop instead of putting
 the thread to sleep if a thread contention occurs inside the memory manager.
 This may improve performance on multi-CPU systems with a relatively low thread
 count, but will hurt performance otherwise.}
  NeverSleepOnMMThreadContention: Boolean;

{$IFDEF MSWINDOWS}
function GetHeapStatus: THeapStatus; platform; deprecated; {Unsupported}

{Returns information about the current state of the memory manager}
procedure GetMemoryManagerState(var AMemoryManagerState: TMemoryManagerState);

{Gets the state of every 64K block in the 4GB address space}
procedure GetMemoryMap(var AMemoryMap: TMemoryMap);

{Registers expected memory leaks. Returns true on success. The list of leaked
 blocks is limited in size, so failure is possible if the list is full.}
function RegisterExpectedMemoryLeak(P: Pointer): Boolean;

{Removes expected memory leaks. Returns true if the previously registered leak
 was found and removed.}
function UnregisterExpectedMemoryLeak(P: Pointer): Boolean;

{Set the minimum block alignment. In the current implementation blocks >=160
 bytes will always be at least 16 byte aligned, even if only 8-byte alignment
 (the default) is required.}
function GetMinimumBlockAlignment: TMinimumBlockAlignment;
procedure SetMinimumBlockAlignment(AMinimumBlockAlignment: TMinimumBlockAlignment);

{Searches the current process for a shared memory manager. If no memory has
 been allocated using this memory manager it will switch to using the shared
 memory manager instead. Returns true if another memory manager was found and
 this module is now sharing it.}
function AttemptToUseSharedMemoryManager: Boolean;

{Makes this memory manager available for sharing to other modules in the
 current process. Only one memory manager may be shared per process, so this
 function may fail.}
function ShareMemoryManager: Boolean;

{$ENDIF}

{ Thread support }
type
  TThreadFunc = function(Parameter: Pointer): Integer;

{$IFDEF POSIX}

{$IFDEF LINUX}
type
  TSize_T = Cardinal;

  TSchedParam = record
    sched_priority: Integer;
  end;
  {$DEFINE _PTHREAD_ATTR_T_DEFINED}
  pthread_attr_t = record
    __detachstate,
    __schedpolicy: Integer;
    __schedparam: TSchedParam;
    __inheritsched,
    __scope: Integer;
    __guardsize: TSize_T;
    __stackaddr_set: Integer;
    __stackaddr: Pointer;
    __stacksize: TSize_T;
  end;
  {$EXTERNALSYM pthread_attr_t}
{$ENDIF LINUX}
{$IFDEF MACOS}
const
   PTHREAD_ATTR_SIZE = 36;
   SCHED_PARAM_SIZE = 4;
type
  TSchedParam = record
    sched_priority: Integer;
    opaque: array [0..SCHED_PARAM_SIZE] of Byte;
  end;
  {$DEFINE _PTHREAD_ATTR_T_DEFINED}
   pthread_attr_t = record
      __sig: LongInt;
      opaque: array [0..PTHREAD_ATTR_SIZE] of Byte;
   end;
  {$EXTERNALSYM pthread_attr_t}  // Defined in signal.h
{$ENDIF MACOS}

{$IFDEF ANDROID}
type
  TSize_T = Cardinal;
  {$DEFINE _PTHREAD_ATTR_T_DEFINED}
  pthread_attr_t = record
    flags: UInt32;
    stack_base: Pointer;
    stack_size: TSize_T;
    guard_size: TSize_T;
    sched_policy: Int32;
    sched_priority: Int32;
  end;
  {$EXTERNALSYM pthread_attr_t}
{$ENDIF ANDROID}

type
  TThreadAttr = pthread_attr_t;
  PThreadAttr = ^TThreadAttr;

  TBeginThreadProc = function (Attribute: PThreadAttr;
    ThreadFunc: TThreadFunc; Parameter: Pointer;
    var ThreadId: TThreadID): Integer;
  TEndThreadProc = procedure(ExitCode: Integer);

var
  BeginThreadProc: TBeginThreadProc = nil;
  EndThreadProc: TEndThreadProc = nil;
{$ENDIF POSIX}

{$IFDEF MSWINDOWS}

type
  TSystemThreadFuncProc = function(ThreadFunc: TThreadFunc; Parameter: Pointer): Pointer;
  TSystemThreadEndProc = procedure(ExitCode: Integer);
  {$NODEFINE TSystemThreadFuncProc}
  {$NODEFINE TSystemThreadEndProc}

  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '  typedef void * (__fastcall * TSystemThreadFuncProc)(void *, void * );' *)
  (*$HPPEMIT '  typedef void (__fastcall * TSystemThreadEndProc)(int);' *)
  (*$HPPEMIT '}' *)

var
  // SystemThreadFuncProc and SystemThreadEndProc are set during the startup
  // code by the C++ RTL when running in a C++Builder VCL application.
  SystemThreadFuncProc: TSystemThreadFuncProc = nil;
  SystemThreadEndProc: TSystemThreadEndProc = nil;

function BeginThread(SecurityAttributes: Pointer; StackSize: LongWord;
  ThreadFunc: TThreadFunc; Parameter: Pointer; CreationFlags: LongWord;
  var ThreadId: TThreadID): THandle;
{$ENDIF}
{$IFDEF POSIX}
function BeginThread(Attribute: PThreadAttr; ThreadFunc: TThreadFunc;
                     Parameter: Pointer; var ThreadId: TThreadID): Integer;

{$ENDIF}
procedure EndThread(ExitCode: Integer);

{ Standard procedures and functions }

const
{ File mode magic numbers }

  fmClosed = $D7B0;
  fmInput  = $D7B1;
  fmOutput = $D7B2;
  fmInOut  = $D7B3;

{ Text file flags         }
  tfCRLF   = $1;    // Dos compatibility flag, for CR+LF line breaks and EOF checks

type
{ Typed-file and untyped-file record }

  TFileRec = packed record (* must match the size the compiler generates: 592 bytes (616 bytes for x64) *)
    Handle: NativeInt;
    Mode: Word;
    Flags: Word;
    case Byte of
      0: (RecSize: Cardinal);   //  files of record
      1: (BufSize: Cardinal;    //  text files
          BufPos: Cardinal;
          BufEnd: Cardinal;
          BufPtr: _PAnsiChr;
          OpenFunc: Pointer;
          InOutFunc: Pointer;
          FlushFunc: Pointer;
          CloseFunc: Pointer;
          UserData: array[1..32] of Byte;
          Name: array[0..259] of WideChar;
      );
  end;

{ Text file record structure used for Text files }
  PTextBuf = ^TTextBuf;
  TTextBuf = array[0..127] of _AnsiChr;
  TTextRec = packed record (* must match the size the compiler generates: 730 bytes (754 bytes for x64) *)
    Handle: NativeInt;       (* must overlay with TFileRec *)
    Mode: Word;
    Flags: Word;
    BufSize: Cardinal;
    BufPos: Cardinal;
    BufEnd: Cardinal;
    BufPtr: _PAnsiChr;
    OpenFunc: Pointer;
    InOutFunc: Pointer;
    FlushFunc: Pointer;
    CloseFunc: Pointer;
    UserData: array[1..32] of Byte;
    Name: array[0..259] of WideChar;
    Buffer: TTextBuf;
    CodePage: Word;
    MBCSLength: ShortInt;
    MBCSBufPos: Byte;
    case Integer of
      0: (MBCSBuffer: array[0..5] of _AnsiChr);
      1: (UTF16Buffer: array[0..2] of WideChar);
  end;

  TTextIOFunc = function (var F: TTextRec): Integer;
  TFileIOFunc = function (var F: TFileRec): Integer;

procedure SetLineBreakStyle(var T: Text; Style: TTextLineBreakStyle);
function GetTextCodePage(const T: Text): Word;
procedure SetTextCodePage(var T: Text; CodePage: Word);
procedure __IOTest;
procedure SetInOutRes(NewValue: Integer);
procedure ChDir(const S: string); overload;
procedure ChDir(P: PChar); overload;
function Flush(var t: Text): Integer;
procedure _UGetDir(D: Byte; var S: UnicodeString);
procedure _LGetDir(D: Byte; var S: _AnsiStr);
procedure _WGetDir(D: Byte; var S: _WideStr);
procedure _SGetDir(D: Byte; var S: _ShortStr);
function IOResult: Integer;
procedure MkDir(const S: string); overload;
procedure MkDir(P: PChar); overload;
procedure Move(const Source; var Dest; Count: NativeInt);
procedure MoveChars(const Source; var Dest; Length: Integer); inline;
function ParamCount: Integer;
function ParamStr(Index: Integer): string;
procedure RmDir(const S: string); overload;
procedure RmDir(P: PChar); overload;
function UpCase(Ch: _AnsiChr): _AnsiChr; overload; inline;
function UpCase(Ch: WideChar): WideChar; overload; inline;

{ random functions }
procedure Randomize;

function Random(const ARange: Integer): Integer; overload;
function Random: Extended; overload;

const
{$IFDEF CPUX86}
  feeINEXACT    = $0020;
  feeUNDERFLOW  = $0010;
  feeOVERFLOW   = $0008;
  feeDIVBYZERO  = $0004;
  feeINVALID    = $0001;
  feeALLEXCEPT  = $003F;
  feeDENORMALOPERAND = $0002 platform; // An Intel-specific flag

  femINEXACT   = $0020;
  femUNDERFLOW = $0010;
  femOVERFLOW  = $0008;
  femDIVBYZERO = $0004;
  femINVALID   = $0001;
  femALLEXCEPT = $003F;
  femDENORMALOPERAND = $0002 platform; // An Intel-specific flag

  ferTONEAREST  = $0000;
  ferUPWARD     = $0800;
  ferDOWNWARD   = $0400;
  ferTOWARDZERO = $0C00;
  ferALLROUND   = $0C00;
{$ENDIF CPUX86}
{$IFDEF CPUX64}
  feeINEXACT    = $0020;
  feeUNDERFLOW  = $0010;
  feeOVERFLOW   = $0008;
  feeDIVBYZERO  = $0004;
  feeINVALID    = $0001;
  feeALLEXCEPT  = $003F;

  femINEXACT   = $1000;
  femUNDERFLOW = $0800;
  femOVERFLOW  = $0400;
  femDIVBYZERO = $0200;
  femINVALID   = $0080;
  femALLEXCEPT = $1F80;

{$IFDEF ARITH_USE_LIBM}
  ferTONEAREST  = $0000;
  ferUPWARD     = $0800;
  ferDOWNWARD   = $0400;
  ferTOWARDZERO = $0C00;
  ferALLROUND   = $0C00;
{$ELSE}
  feeDENORMALOPERAND = $0002 platform; // An Intel-specific flag
  femDENORMALOPERAND = $0100 platform; // An Intel-specific flag

  ferTONEAREST  = $0000;
  ferUPWARD     = $4000;
  ferDOWNWARD   = $2000;
  ferTOWARDZERO = $6000;
  ferALLROUND   = $6000;
{$ENDIF ARITH_USE_LIBM}
{$ENDIF CPUX64}

{$IFDEF CPUARM}
  feeINEXACT    = $0010;
  feeUNDERFLOW  = $0008;
  feeOVERFLOW   = $0004;
  feeDIVBYZERO  = $0002;
  feeINVALID    = $0001;
  feeFLUSHTOZERO = $0080 platform; // An ARM-specific flag that is raised when a denormal is flushed to zero.
  feeALLEXCEPT  = $009F;

  femINEXACT   = $1000;
  femUNDERFLOW = $0800;
  femOVERFLOW  = $0400;
  femDIVBYZERO = $0200;
  femINVALID   = $0100;
  femFLUSHTOZERO = $8000 platform; // An ARM-specific flag that is raised when a denormal is flushed to zero.
  femALLEXCEPT = $9F00;

  ferTONEAREST  = $00000000;
  ferUPWARD     = $00400000;
  ferDOWNWARD   = $00800000;
  ferTOWARDZERO = $00C00000;
  ferALLROUND   = $00C00000;
{$ENDIF CPUARM}
{$IF not(defined(CPUX86) or defined(CPUX64) or defined(CPUARM))}
{$MESSAGE ERROR 'Unknown Architecture'}
{$ENDIF}


{$IF defined(IOS) or defined(ANDROID)}
procedure FClearExcept;
procedure FCheckExcept;
{$ELSE}
procedure FClearExcept; inline;
procedure FCheckExcept; inline;
{$ENDIF Defined(IOS) or Defined(ANDROID)}

procedure FRaiseExcept(excepts: UInt32; CheckExceptionMask: Boolean = True);

function FGetRound: UInt32;
function FSetRound(NewRound: UInt32): UInt32;

function FSetExceptFlag(NewFlags: UInt32; Excepts: UInt32 = feeALLEXCEPT): UInt32;
function FGetExceptFlag(Excepts: UInt32 = feeALLEXCEPT): UInt32;

function FSetExceptMask(NewMasks: UInt32; ExceptMasks: UInt32 = femALLEXCEPT): UInt32;
function FGetExceptMask(ExceptMasks: UInt32 = femALLEXCEPT): UInt32;

{$IF defined(CPUX86) or defined(CPUX64)}

{ Control 8087 control word }
procedure Reset8087CW; {$IFDEF NEXTGEN}platform;{$ENDIF} // Resets to Default8087CW
procedure Set8087CW(NewCW: Word); {$IFDEF NEXTGEN}platform;{$ENDIF}
function Get8087CW: Word; {$IFDEF NEXTGEN}platform;{$ENDIF}

{ Control MXCSR control word }

procedure ResetMXCSR; platform; // Resets to DefaultMXCSR
procedure SetMXCSR(NewMXCSR: UInt32); platform;
procedure SetMXCSRExceptionFlag(NewExceptionFlag: UInt32);

function GetMXCSR: UInt32; platform;

{$ELSEIF defined(CPUARM)}

{ Control ARM FPSCR control word }
procedure SetFPSCR(NewFlag: UInt32); platform;
function GetFPSCR: UInt32; platform;

{$ENDIF defined(CPUX86) or defined(CPUX64)}

{ Wide character support procedures and functions for C++ }
{ These functions should not be used in Delphi code!
 (conversion is implicit in Delphi code)      }

function WideCharToString(Source: PWideChar): UnicodeString;
function WideCharLenToString(Source: PWideChar; SourceLen: Integer): UnicodeString;
procedure WideCharToStrVar(Source: PWideChar; var Dest: UnicodeString);
procedure WideCharLenToStrVar(Source: PWideChar; SourceLen: Integer;
  var Dest: UnicodeString); overload;
procedure WideCharLenToStrVar(Source: PWideChar; SourceLen: Integer;
  var Dest: _AnsiStr); overload;
function StringToWideChar(const Source: UnicodeString; Dest: PWideChar;
  DestSize: Integer): PWideChar;

{ PUCS4Chars returns a pointer to the UCS4 char data in the
  UCS4String array, or a pointer to a null char if UCS4String is empty }

function PUCS4Chars(const S: UCS4String): PUCS4Char;

{ Widestring <-> UCS4 conversion }

function WideStringToUCS4String(const S: _WideStr): UCS4String;
function UCS4StringToWideString(const S: UCS4String): _WideStr;

{ PAnsiChar/PWideChar Unicode <-> UTF8 conversion }

// UnicodeToUTF8(3):
// UTF8ToUnicode(3):
// Scans the source data to find the null terminator, up to MaxBytes
// Dest must have MaxBytes available in Dest.
// MaxDestBytes includes the null terminator (last char in the buffer will be set to null)
// Function result includes the null terminator.

function UnicodeToUtf8(Dest: _PAnsiChr; Source: PWideChar; MaxBytes: Integer): Integer; overload; deprecated;
function Utf8ToUnicode(Dest: PWideChar; Source: _PAnsiChr; MaxChars: Integer): Integer; overload; deprecated;

// UnicodeToUtf8(4):
// UTF8ToUnicode(4):
// MaxDestBytes includes the null terminator (last char in the buffer will be set to null)
// Function result includes the null terminator.
// Nulls in the source data are not considered terminators - SourceChars must be accurate

function UnicodeToUtf8(Dest: _PAnsiChr; MaxDestBytes: Cardinal; Source: PWideChar; SourceChars: Cardinal): Cardinal; overload;
function Utf8ToUnicode(Dest: PWideChar; MaxDestChars: Cardinal; Source: _PAnsiChr; SourceBytes: Cardinal): Cardinal; overload;

{ WideString <-> UTF8 conversion }

function UTF8Encode(const WS: _WideStr): _RawByteStr; overload;
function UTF8Encode(const US: UnicodeString): _RawByteStr; overload;
procedure UTF8Encode(const US: UnicodeString; var B: array of Byte); overload;
function UTF8Encode(const A: _RawByteStr): _RawByteStr; overload;
function UTF8EncodeToShortString(const WS: _WideStr): _ShortStr; overload;
function UTF8EncodeToShortString(const US: UnicodeString): _ShortStr; overload;
function UTF8EncodeToShortString(const A: _RawByteStr): _ShortStr; overload;
function UTF8Decode(const S: _RawByteStr): _WideStr; deprecated 'Use UTF8ToWideString or UTF8ToString';
function UTF8ToWideString(const S: _RawByteStr): _WideStr; inline;
function UTF8ToUnicodeString(const S: _RawByteStr): UnicodeString; overload;
function UTF8ToUnicodeString(const S: _ShortStr): UnicodeString; overload;
function UTF8ToUnicodeString(const S: _PAnsiChr): UnicodeString; overload;
function UTF8ToString(const S: _RawByteStr): string; inline; overload;
function UTF8ToString(const S: _ShortStr): string; inline; overload;
function UTF8ToString(const S: _PAnsiChr): string; inline; overload;
function UTF8ToString(const S: array of _AnsiChr): string; overload;
function UTF8ToString(const S: array of Byte): string; overload;
//function UTF8ToUnicodeString(const S: _ShortStr): UnicodeString; overload;

{ Ansi <-> UTF8 conversion }

                                                                  
function AnsiToUtf8(const S: string): _RawByteStr;
function Utf8ToAnsi(const S: _RawByteStr): string;

{ OLE string support procedures and functions }

function OleStrToString(Source: PWideChar): UnicodeString;
procedure OleStrToStrVar(Source: PWideChar; var Dest: _AnsiStr); overload;
procedure OleStrToStrVar(Source: PWideChar; var Dest: UnicodeString); overload;
function StringToOleStr(const Source: _AnsiStr): PWideChar; overload;
function StringToOleStr(const Source: UnicodeString): PWideChar; overload;

{ Variant manager support procedures and functions (obsolete - see Variants.pas) }

procedure GetVariantManager(var VarMgr: TVariantManager); deprecated;
procedure SetVariantManager(const VarMgr: TVariantManager); deprecated;
function IsVariantManagerSet: Boolean; deprecated;

{ Interface dispatch support }

{$IF not defined(X86ASMRTL)}
procedure _IntfDispCall(Result: Pointer; const Dispatch: IDispatch;
  DispDesc: PDispDesc); cdecl; varargs;
procedure _IntfVarCall(Dest: PVarData; const Source: TVarData;
  CallDesc: PCallDesc); cdecl; varargs;
{$ELSE}
// these functions are actually varargs, which dcc32 cannot handle, so these
// functions cannot be invoked from pure pascal code with parameters
procedure _IntfDispCall{Result: Pointer; const Dispatch: IDispatch;
  DispDesc: PDispDesc; Params: Pointer}; cdecl;
procedure _IntfVarCall{Dest: PVarData; const Source: TVarData;
  CallDesc: PCallDesc; Params: Pointer}; cdecl;
{$ENDIF}

{ Dynamic method dispatch support }

function GetDynaMethod(vmt: TClass; selector: SmallInt): Pointer;

{ Package/Module registration and unregistration }

type
  PLibModule = ^TLibModule;
  TLibModule = record
    Next: PLibModule;
    Instance: HINST;
    CodeInstance: HINST;
    DataInstance: HINST;
    ResInstance: HINST;
    TypeInfo: PPackageTypeInfo;
    Reserved: NativeInt;
{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
    InstanceVar: Pointer platform;
    InitTable: Pointer platform;
    GOT: NativeUInt platform;
{$ENDIF LINUX or MACOS or ANDROID}
{$IFDEF PC_MAPPED_EXCEPTIONS}
    CodeSegStart: NativeUInt platform;
    CodeSegEnd: NativeUInt platform;
{$ENDIF PC_MAPPED_EXCEPTIONS}
  end;

  TEnumModuleFunc = function (HInstance: NativeInt; Data: Pointer): Boolean;
  TEnumModuleFuncLW = function (HInstance: THandle; Data: Pointer): Boolean;
  TModuleUnloadProc = procedure (HInstance: NativeInt);
  TModuleUnloadProcLW = procedure (HInstance: THandle);

  PModuleUnloadRec = ^TModuleUnloadRec;
  TModuleUnloadRec = record
    Next: PModuleUnloadRec;
    Proc: TModuleUnloadProcLW;
  end;

var
  LibModuleList: PLibModule = nil;
  ModuleUnloadList: PModuleUnloadRec = nil;

procedure RegisterModule(LibModule: PLibModule);
procedure UnregisterModule(LibModule: PLibModule);
function FindHInstance(Address: Pointer): HINST;
function FindClassHInstance(ClassType: TClass): HINST;
function FindResourceHInstance(Instance: HINST): HINST;
{$IFDEF MSWINDOWS}
function GetResourceModuleName(HostAppName, ModuleName: string): string;
{$ENDIF}
function LoadResourceModule(ModuleName: PChar; CheckOwner: Boolean = True): THandle;
procedure EnumModules(Func: TEnumModuleFunc; Data: Pointer); overload;
procedure EnumResourceModules(Func: TEnumModuleFunc; Data: Pointer); overload;
procedure EnumModules(Func: TEnumModuleFuncLW; Data: Pointer); overload;
procedure EnumResourceModules(Func: TEnumModuleFuncLW; Data: Pointer); overload;
procedure AddModuleUnloadProc(Proc: TModuleUnloadProc); overload;
procedure RemoveModuleUnloadProc(Proc: TModuleUnloadProc); overload;
procedure AddModuleUnloadProc(Proc: TModuleUnloadProcLW); overload;
procedure RemoveModuleUnloadProc(Proc: TModuleUnloadProcLW); overload;
{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
{ Given an HMODULE, this function will return its fully qualified name.  There is
  no direct equivalent in Linux so this function provides that capability. }
function GetModuleFileName(Module: HMODULE; Buffer: PChar; BufLen: Integer): Integer;
{$ENDIF LINUX or MACOS or ANDROID}

{ ResString support function/record }

type
  PResStringRec = ^TResStringRec;
  {$IF defined(EXTERNALLINKER)}
  TResStringRec = record
    Key: MarshaledAString;
  end;
  {$ELSE}
  TResStringRec = packed record
    // 32bit = 8 bytes
    // 64bit = 16 bytes
    Module: ^HMODULE;
    Identifier: NativeUint;
  end;
  {$ENDIF}

function LoadResString(ResStringRec: PResStringRec): string;

{ floating number support }
type
  TFloatSpecial = ( fsZero, fsNZero, fsDenormal, fsNDenormal,
    fsPositive, fsNegative, fsInf, fsNInf, fsNaN );

  PSingleRec = ^TSingleRec;
  TSingleRec = packed record
  private
    aSingle: Single;

    function InternalGetBytes(Index: Cardinal): UInt8; inline;
    function InternalGetWords(Index: Cardinal): UInt16; inline;
    procedure InternalSetBytes(Index: Cardinal; const Value: UInt8); inline;
    procedure InternalSetWords(Index: Cardinal; const Value: UInt16); inline;
    function GetBytes(Index: Cardinal): UInt8; inline;
    function GetWords(Index: Cardinal): UInt16; inline;
    procedure SetBytes(Index: Cardinal; const Value: UInt8); inline;
    procedure SetWords(Index: Cardinal; const Value: UInt16); inline;
    function GetExp: UInt64; inline;
    function GetFrac: UInt64; inline;
    function GetSign: Boolean; inline;
    procedure SetExp(NewExp: UInt64);
    procedure SetFrac(NewFrac: UInt64);
    procedure SetSign(NewSign: Boolean);
  public

    function Exponent: Integer;
    function Fraction: Extended;
    function Mantissa: UInt64;

    property Sign: Boolean read GetSign write SetSign;
    property Exp: UInt64 read GetExp write SetExp;
    property Frac: UInt64 read GetFrac write SetFrac;

    function SpecialType: TFloatSpecial;
    procedure BuildUp(const SignFlag: Boolean; const Mantissa: UInt64; const Exponent: Integer);
    class operator Explicit(a: Extended): TSingleRec; inline;
    class operator Explicit(a: TSingleRec): Extended; inline;

    property Bytes[Index: Cardinal]: UInt8 read GetBytes write SetBytes;  // 0..3
    property Words[Index: Cardinal]: UInt16 read GetWords write SetWords; // 0..1
  end deprecated 'Use TSingleHelper';

  PDoubleRec = ^TDoubleRec;
  TDoubleRec = packed record
  private
    aDouble: Double;

    function InternalGetBytes(Index: Cardinal): UInt8; inline;
    function InternalGetWords(Index: Cardinal): UInt16; inline;
    procedure InternalSetBytes(Index: Cardinal; const Value: UInt8); inline;
    procedure InternalSetWords(Index: Cardinal; const Value: UInt16); inline;
    function GetBytes(Index: Cardinal): UInt8; inline;
    function GetWords(Index: Cardinal): UInt16; inline;
    procedure SetBytes(Index: Cardinal; const Value: UInt8); inline;
    procedure SetWords(Index: Cardinal; const Value: UInt16); inline;
    function GetExp: UInt64; inline;
    function GetFrac: UInt64; inline;
    function GetSign: Boolean; inline;
    procedure SetExp(NewExp: UInt64);
    procedure SetFrac(NewFrac: UInt64);
    procedure SetSign(NewSign: Boolean);
  public
    function Exponent: Integer;
    function Fraction: Extended;
    function Mantissa: UInt64;

    property Sign: Boolean read GetSign write SetSign;
    property Exp: UInt64 read GetExp write SetExp;
    property Frac: UInt64 read GetFrac write SetFrac;

    function SpecialType: TFloatSpecial;
    procedure BuildUp(const SignFlag: Boolean; const Mantissa: UInt64; const Exponent: Integer);
    class operator Explicit(a: Extended): TDoubleRec; inline;
    class operator Explicit(a: TDoubleRec): Extended; inline;

    property Bytes[Index: Cardinal]: UInt8 read GetBytes write SetBytes;  // 0..7
    property Words[Index: Cardinal]: UInt16 read GetWords write SetWords; // 0..3
  end deprecated 'Use TDoubleHelper';

  PExtended80Rec = ^TExtended80Rec;
  TExtended80Rec = packed record
  private
{$IFDEF EXTENDEDIS10BYTES}
    aExtended80: Extended;
{$ELSE  !EXTENDEDIS10BYTES}
    aExtended80Frac: UInt64;
    aExtended80Exp:  UInt16;
{$ENDIF !EXTENDEDIS10BYTES}
    function InternalGetBytes(Index: Cardinal): UInt8; inline;
    function InternalGetWords(Index: Cardinal): UInt16; inline;
    procedure InternalSetBytes(Index: Cardinal; const Value: UInt8); inline;
    procedure InternalSetWords(Index: Cardinal; const Value: UInt16); inline;
    function GetBytes(Index: Cardinal): UInt8;
    function GetWords(Index: Cardinal): UInt16;
    function Get_Exp: UInt64; inline;
    function GetExp: UInt64; inline;
    function GetFrac: UInt64; inline;
    function GetSign: Boolean; inline;
    procedure SetBytes(Index: Cardinal; const Value: UInt8);
    procedure SetWords(Index: Cardinal; const Value: UInt16);
    procedure Set_Exp(NewExp: UInt64); inline;
    procedure SetExp(NewExp: UInt64);
    procedure SetFrac(NewFrac: UInt64); inline;
    procedure SetSign(NewSign: Boolean);
  public
    function Exponent: Integer;
    function Fraction: Extended;
    function Mantissa: UInt64; inline;

    property Sign: Boolean read GetSign write SetSign;
    property Exp: UInt64 read GetExp write SetExp;
    property _Exp: UInt64 read Get_Exp write Set_Exp;
    property Frac: UInt64 read GetFrac write SetFrac;

    function SpecialType: TFloatSpecial;
    procedure BuildUp(const SignFlag: Boolean; const Mantissa: UInt64; const Exponent: Integer);
    class operator Explicit(a: Extended): TExtended80Rec;
    class operator Explicit(a: TExtended80Rec): Extended;

    property Bytes[Index: Cardinal]: UInt8 read GetBytes write SetBytes;  // 0..9
    property Words[Index: Cardinal]: UInt16 read GetWords write SetWords; // 0..4
  end;
  TExtended80RecW = record
    Words: array[0..4] of UInt16;
  end;

  PExtendedRec = {$IFDEF EXTENDEDHAS10BYTES} PExtended80Rec {$ELSE} PDoubleRec {$ENDIF};
  TExtendedRec = {$IFDEF EXTENDEDHAS10BYTES} TExtended80Rec {$ELSE} TDoubleRec {$ENDIF};

{$IFNDEF EXTENDEDHAS10BYTES}
function Int(const X: Double): Double; overload;
function Frac(const X: Double): Double; overload;
function Exp(const X: Double): Double; overload;
function Cos(const X: Double): Double; overload;
function Sin(const X: Double): Double; overload;
function Ln(const X: Double): Double; overload;
function ArcTan(const X: Double): Double; overload;
function Sqrt(const X: Double): Double; overload;

function Tangent(const X: Double): Double; overload;
procedure SineCosine(const X: Double; var Sin, Cos: Double); overload;
function ExpMinus1(const X: Double): Double; overload;
function LnXPlus1(const X: Double): Double; overload;
{$ELSE EXTENDEDHAS10BYTES}
function Int(const X: Extended): Extended;
function Frac(const X: Extended): Extended;
function Exp(const X: Extended): Extended;
function Cos(const X: Extended): Extended;
function Sin(const X: Extended): Extended;
function Ln(const X: Extended): Extended;
function ArcTan(const X: Extended): Extended;
function Sqrt(const X: Extended): Extended;

function Tangent(const X: Extended): Extended;
procedure SineCosine(const X: Extended; var Sin, Cos: Extended);
function ExpMinus1(const X: Extended): Extended;
function LnXPlus1(const X: Extended): Extended;
{$ENDIF EXTENDEDHAS10BYTES}

{ Procedures and functions that need compiler magic }

{$IF defined(X86ASMRTL)}
procedure _ROUND;
procedure _TRUNC;
{$ELSE}
function _Round(Val: Extended): Int64;
{$IF defined(CPUARM)}
function _RoundU(Val: Extended): UInt64;
{$ENDIF}
function _RoundCurrency(Val: Currency): Int64;
function _Trunc(Val: Extended): Int64;
function _Abs(Val: Extended): Extended;
{$ENDIF}
{$IF defined(CPUX86) or defined(CPUARM) or defined(EXTERNALLINKER)}
function _MulDivModInt64(AValue, AMul, ADiv: Int64; Remainder: PInt64): Int64;
function _MulDivInt64(AValue, AMul, ADiv: Int64): Int64;
{$ENDIF}
{$IF defined(CPUX64) or defined(CPUARM)}
function _MulDivComp(AValue, AMul, ADiv: Int64): Int64;
{$ENDIF}

procedure _AbstractError;
procedure _Assert(const Message, Filename: string; LineNumber: Integer);
function _Append(var t: TTextRec): Integer;
function _AssignFile(var t: TFileRec; const s: PChar): Integer;
function _AssignText(var t: TTextRec; const s: PChar; const CP: word): Integer;
function _BlockRead(var F: TFileRec; Buffer: Pointer; RecCnt: Integer; RecsRead: PInteger): Integer;
function _BlockWrite(var F: TFileRec; Buffer: Pointer; RecCnt: Integer; RecsWritten: PInteger): Integer;
function _Close(var t: TTextRec): Integer;
function _EofFile(var f: TFileRec): Boolean;
function _EofText(var t: TTextRec): Boolean;
function _Eoln(var t: TTextRec): Boolean;
procedure _Erase(var f: TFileRec);
{$IFDEF TRIAL_EDITION}
procedure _Expired;
{$ENDIF}
function _FilePos(var f: TFileRec): Integer;
function _FileSize(var f: TFileRec): Integer;
function _Flush(var t: TTextRec): Integer;
procedure _FillChar(var Dest; Count: NativeInt; Value: _AnsiChr);
function _FreeMem(P: Pointer): Integer;
function _GetMem(Size: NativeInt): Pointer;
function _ReallocMem(var P: Pointer; NewSize: NativeInt): Pointer;
procedure _Halt(Code: Integer);
procedure _Halt0;
{$IFDEF TRIAL_EDITION}
{$IFDEF MSWINDOWS}
function _InitUnitPrep: Int64;
{$ENDIF}
{$IFDEF LINUX}
function _InitUnitPrep: Integer;
{$ENDIF}
{$ENDIF}
procedure Mark; deprecated;
function _ReadRec(var f: TFileRec; Buffer: Pointer): Integer;
function _ReadChar(var t: TTextRec): _AnsiChr;
function _ReadLong(var t: TTextRec): Integer;
procedure _ReadString(var t: TTextRec; s: _PShortStr; maxLen: Integer);
procedure _ReadCString(var t: TTextRec; s: _PAnsiChr; maxLen: Integer);
procedure _ReadLString(var t: TTextRec; var s: _AnsiStr; CodePage: Word);
procedure _ReadUString(var t: TTextRec; var s: UnicodeString);
procedure _ReadWString(var t: TTextRec; var s: _WideStr);
procedure _ReadWCString(var t: TTextRec; s: PWideChar; maxBytes: Integer);
function _ReadWChar(var t: TTextRec): WideChar;
function _ReadExt(var t: TTextRec): Extended;
procedure _ReadLn(var t: TTextRec);
procedure _Rename(var f: TFileRec; newName: PChar);
procedure Release; deprecated;
function _ResetText(var t: TTextRec): Integer;
function _ResetFile(var f: TFileRec; recSize: Integer): Integer;
function _RewritText(var t: TTextRec): Integer;
function _RewritFile(var f: TFileRec; recSize: Integer): Integer;
procedure _RunError(errorCode: Byte);
procedure _Run0Error;
procedure _Seek(var f: TFileRec; recNum: Cardinal);
function _SeekEof(var t: TTextRec): Boolean;
function _SeekEoln(var t: TTextRec): Boolean;
procedure _SetTextBuf(var t: TTextRec; p: Pointer; size: Integer);
function _StrLong(val, width: Integer): _ShortStr;
function _Str0Long(val: Integer): _ShortStr;

procedure _Truncate(var f: TFileRec);
function _ValLong(const S: string; var Code: Integer): Integer;
function _WriteRec(var f: TFileRec; buffer: Pointer): Pointer;
function _WriteChar(var t: TTextRec; c: _AnsiChr; width: Integer): Pointer;
function _Write0Char(var t: TTextRec; c: _AnsiChr): Pointer;
function _WriteBool(var t: TTextRec; val: Boolean; width: Integer): Pointer;
function _Write0Bool(var t: TTextRec; val: Boolean): Pointer;
function _WriteLong(var t: TTextRec; val, width: Integer): Pointer;
function _Write0Long(var t: TTextRec; val: Integer): Pointer;
function _WriteString(var t: TTextRec; const s: _ShortStr; width: Integer): Pointer;
function _Write0String(var t: TTextRec; const s: _ShortStr): Pointer;
function _WriteCString(var t: TTextRec; s: _PAnsiChr; width: Integer): Pointer;
function _Write0CString(var t: TTextRec; s: _PAnsiChr): Pointer;
function _WriteLString(var t: TTextRec; const s: _AnsiStr; width: Integer): Pointer;
function _Write0LString(var t: TTextRec; const s: _AnsiStr): Pointer;
function _WriteWString(var t: TTextRec; const s: _WideStr; width: Integer): Pointer;
function _Write0WString(var t: TTextRec; const s: _WideStr): Pointer;
function _WriteWCString(var t: TTextRec; s: PWideChar; width: Integer): Pointer;
function _Write0WCString(var t: TTextRec; s: PWideChar): Pointer;
function _WriteWChar(var t: TTextRec; c: WideChar; width: Integer): Pointer;
function _Write0WChar(var t: TTextRec; c: WideChar): Pointer;
function _WriteVariant(var T: TTextRec; const V: TVarData; Width: Integer): Pointer;
function _Write0Variant(var T: TTextRec; const V: TVarData): Pointer;
{$IF not DEFined(X86ASMRTL)}
function _Write2Ext(var T: TTextRec; val: Extended; Width, Prec: Integer): Pointer;
function _Write1Ext(var T: TTextRec; val: Extended; Width: Integer): Pointer;
function _Write0Ext(var T: TTextRec; val: Extended): Pointer;
{$ELSE}
// On x86, val is passed on the FPU stack. dcc32 passes floating point
// parameters by reference, so the parameters cannot be added. These
// methods cannot be invoked from pure pascal code
procedure _Write2Ext{(var T: TTextRec; val: Extended; Width, Prec: Integer): Pointer};
procedure _Write1Ext{(var T: TTextRec; val: Extended; Width: Integer): Pointer};
procedure _Write0Ext{(var T: TTextRec; val: Extended): Pointer};
{$ENDIF}
{$IF not defined(X86ASMRTL)}
function _Write2Comp(var T: TTextRec; Val: Comp; Width, Prec: Integer): Pointer;
function _Write1Comp(var T: TTextRec; Val: Comp; Width: Integer): Pointer;
function _Write0Comp(var T: TTextRec; Val: Comp): Pointer;
function _Write2Currency(var T: TTextRec; Val: Currency; Width, Prec: Integer): Pointer;
function _Write1Currency(var T: TTextRec; Val: Currency; Width: Integer): Pointer;
function _Write0Currency(var T: TTextRec; Val: Currency): Pointer;
{$ENDIF}
function _WriteLn(var t: TTextRec): Pointer;

var
  AlternateWriteUnicodeStringProc: function(var t: TTextRec; s: UnicodeString): Pointer = nil;

procedure __CToPasStr(Dest: _PShortStr; const Source: _PAnsiChr);
procedure _WCharToString(Dest: _PShortStr; const Source: WideChar; MaxLen: Integer);
procedure __CLenToPasStr(Dest: _PShortStr; const Source: _PAnsiChr; MaxLen: NativeInt);
procedure __ArrayToPasStr(Dest: _PShortStr; const Source: _PAnsiChr; Len: NativeInt);
procedure __PasToCStr(const Source: _PShortStr; const Dest: _PAnsiChr);
procedure __PasToWCStr(const Source: _PShortStr; const Dest: PWideChar);

{ Compiler helper for set type support }
{$IF not defined(X86ASMRTL)}
procedure _SetElem(var Dest {:Set}; Elem, Size: Integer);
procedure _SetRange(Lo, Hi, Size: Integer; var Dest {:Set});
function _SetEq(L, R: Pointer{PSet}; Size: Integer): Boolean;
function _SetLe(L, R: Pointer{PSet}; Size: Integer): Boolean;
procedure _SetIntersect(var Dest {:Set}; Src: Pointer{PSet}; Size: Integer);
procedure _SetIntersect3(var Dest {:Set}; L, R: Pointer{PSet}; Size: Integer);
procedure _SetUnion(var Dest {:Set}; Src: Pointer{PSet}; Size: Integer);
procedure _SetUnion3(var Dest {:Set}; L, R: Pointer{PSet}; Size: Integer);
procedure _SetSub(var Dest {:Set}; Src: Pointer{PSet}; Size: Integer);
procedure _SetSub3(var Dest {:Set}; L, R: Pointer{PSet}; Size: Integer);
procedure _SetExpand(Src: Pointer{PSet}; var Dest {:Set}; Lo, Hi: Integer);
{$ELSE}
// On x86, these functions have special calling conventions that can't be
// invoked from pure pascal code.
procedure _SetElem;
procedure _SetRange;
procedure _SetEq;
procedure _SetLe;
procedure _SetIntersect;
procedure _SetIntersect3; { BEG only }
procedure _SetUnion;
procedure _SetUnion3; { BEG only }
procedure _SetSub;
procedure _SetSub3; { BEG only }
procedure _SetExpand;
{$ENDIF}

{ Helper routines for standard procedure }
function _Str2Ext(val: Extended; Width, Precision: Integer): _ShortStr;
function _Str1Ext(val: Extended; Width: Integer): _ShortStr;
function _Str0Ext(val: Extended): _ShortStr;
{$IF not defined(X86ASMRTL)}
function _Str2Comp(Val: Comp; Width, Precision: Integer): _ShortStr;
function _Str1Comp(Val: Comp; Width: Integer): _ShortStr;
function _Str0Comp(Val: Comp): _ShortStr;
function _Str2Currency(Val: Currency; Width, Precision: Integer): _ShortStr;
function _Str1Currency(Val: Currency; Width: Integer): _ShortStr;
function _Str0Currency(Val: Currency): _ShortStr;
{$ENDIF}
{$IFNDEF EXTENDEDHAS10BYTES}
function _Ext80ToDouble(Val: Pointer {PExtended80}): Double;
procedure _DoubleToExt80(Dest: Pointer {PExtended80}; Val: Double);
{$ENDIF}
{$IF not defined(X86ASMRTL)}
function _CompDiv(Dividend, Divisor: Comp): Double;
{$ENDIF}

{$IF not defined(X86ASMRTL)}
function _ValExt(s: string; var code: Integer): Extended;
function _Pow10(val: Extended; Power: Integer): Extended;
function _Real2Ext(val: Pointer {PReal48}): Extended;
procedure _Ext2Real(Dest: Pointer {PReal48}; Val: Extended);
{$ELSE}
// Floating point values are passed on the FPU stack here.
// dcc32 expects them to be by reference arguments as normal
// parameters. These cannot be invoked from pure pascal code.
procedure _ValExt;
procedure _Pow10;
procedure _Real2Ext;
procedure _Ext2Real;
{$ENDIF}

{ Compiler helpers for object type support }
{$IF not defined(X86ASMRTL)}
function _ObjSetup(Self: Pointer; var VmtPtrAndAllocFlag: Pointer): Pointer;
procedure _ObjCopy(Dest, Source: Pointer; VmtPtrOffs: NativeInt);
{$ELSE}
// On x86, it is expected that ZF is set upon failure for these methods
// which cannot be implemented in pure pascal
procedure _ObjSetup;
procedure _ObjCopy;
{$ENDIF}
function _Fail(Self: Pointer; AllocFlag: NativeInt): Pointer;
procedure _BoundErr;
procedure _IntOver;
procedure _IntDivByZero;

{$IF defined(CPUX86) and (not defined(EXTERNALLINKER))}
{ Compiler helpers for Int64 atomic operations }
function _AtomicIncInt64(var Target: Int64; Increment: Int64): Int64; inline;
function _AtomicXchgInt64(var Target: Int64; Exchange: Int64): Int64; inline;
{$ENDIF}


{$IFDEF TABLE_BASED_EXCEPTIONS}
{$IFDEF CPUX64}
type
  __m128 = record
    Lo, Hi: UInt64;
  end align 16;
  __TExitDllJumpBuf = record
    {$IF DEFINED(MSWINDOWS)}
      _RIP, _RSP, _RBX, _RBP, _RSI, _RDI: Int64;
      _R12, _R13, _R14, _R15: Int64;
      XmmBuf: array [6..15] of __m128;
    {$NODEFINE __m128}
    {$NODEFINE __TExitDllJumpBuf}
    {$NODEFINE TInitContext}
    {$NODEFINE PInitContext}
    {$ELSEIF DEFINED(LINNUX)}
      _RIP, _RSP, _RBX, _RBP: Int64;
      _R12, _R13, _R14, _R15: Int64;
      //_FS, _X87CW: Word;
      XmmBuf: array [8..15] of __m128;
    {$ELSE}
       {$MESSAGE ERROR 'Unknown condition'}
    {$ENDIF}
  end align 16;
{$ENDIF}
{$ENDIF}


{ Module initialization context.  For internal use only. }

type
  PInitContext = ^TInitContext;
  TInitContext = record
    OuterContext:   PInitContext;     { saved InitContext   }
{$IFNDEF PC_MAPPED_EXCEPTIONS}
    ExcFrame:       Pointer;          { bottom exc handler  }
{$ENDIF}
    InitTable:      PackageInfo;      { unit init info      }
    InitCount:      Integer;          { how far we got      }
    Module:         PLibModule;       { ptr to module desc  }
{$IFDEF CPUX86}
    DLLSaveEBP:     Pointer;          { saved regs for DLLs }
    DLLSaveEBX:     Pointer;          { saved regs for DLLs }
    DLLSaveESI:     Pointer;          { saved regs for DLLs }
    DLLSaveEDI:     Pointer;          { saved regs for DLLs }
{$ENDIF}
{$IFDEF MSWINDOWS}
    ExitProcessTLS: procedure;        { Shutdown for TLS    }
{$ENDIF}
    DLLInitState:   Byte;             { 0 = package, 1 = DLL shutdown, 2 = DLL startup }
    ThreadID:       TThreadID;        { Initializing Thread }
{$IFDEF TABLE_BASED_EXCEPTIONS}
{$IFDEF CPUX64}
    ExitDllJmpBuf:  __TExitDllJumpBuf;
{$ENDIF}
{$ENDIF}
  end platform;

type
  TDLLProc = procedure (Reason: Integer);
  // TDLLProcEx provides the reserved param returned by WinNT
  TDLLProcEx = procedure (Reason: Integer; Reserved: Pointer);

{$IFDEF POSIX}
procedure _StartExe(InitTable: PackageInfo; Module: PLibModule; Argc: Integer; Argv: Pointer);
procedure _StartLib(Context: PInitContext; Module: PLibModule; DLLProc: TDLLProcEx);
{$IF defined(EXTERNALLINKER)}
function _DllMain(Context: PInitContext): Integer;
{$ENDIF EXTERNALLINKER}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
procedure _StartExe(InitTable: PackageInfo; Module: PLibModule);
{$IFDEF CPUX86}
procedure _StartLib;
{$ENDIF CPUX86}
{$IFDEF CPUX64} // Int64 Types
function _DllMain(Context: PInitContext): Integer;
procedure _StartLib(ContextBuf: PInitContext; InitTable: PackageInfo; Module: PLibModule; TlsProc: Pointer; DllProc: TDllProcEx; AHInst: HINST; Reason: LongWord; Reserved: Pointer);
{$ENDIF}
{$ENDIF MSWINDOWS}
procedure _PackageLoad(const Table : PackageInfo; Module: PLibModule);
procedure _PackageUnload(const Table : PackageInfo; Module: PLibModule);

{$IFDEF MSWINDOWS}
type
  PExceptionRecord = ^TExceptionRecord;
  TExceptionRecord = record
    ExceptionCode: Cardinal;
    ExceptionFlags: Cardinal;
    ExceptionRecord: PExceptionRecord;
    ExceptionAddress: Pointer;
    NumberParameters: Cardinal;
    case {IsOsException:} Boolean of
      True:  (ExceptionInformation : array [0..14] of NativeUInt);
      False: (ExceptAddr: Pointer; ExceptObject: Pointer);
  end;
  TExceptClsProc = function(P: PExceptionRecord): Pointer{ExceptClass};
  TExceptObjProc = function(P: PExceptionRecord): Pointer{Exception};
  TRaiseExceptObjProc = procedure(P: PExceptionRecord);

{$IFDEF TABLE_BASED_EXCEPTIONS}
  _PContext = Pointer{^TContext};
  {$EXTERNALSYM _PContext}
  PExceptionPointers = ^TExceptionPointers;
  {$EXTERNALSYM PExceptionPointers}
  TExceptionPointers = record
    ExceptionRecord: PExceptionRecord;
    ContextRecord: _PContext;
  end;
  {$EXTERNALSYM TExceptionPointers}
  _TDelphiFinallyHandlerProc = function(ExceptionPointers: PExceptionPointers;
                                        EstablisherFrame: NativeUInt): Integer;
  {$EXTERNALSYM _TDelphiFinallyHandlerProc}
  _TExceptionHandlerProc = function(ExceptionPointers: PExceptionPointers;
                                    EstablisherFrame: NativeUInt): Integer;
  {$EXTERNALSYM _TExceptionHandlerProc}
  _TDelphiSafeCallCatchHandlerProc =
    function(ExceptionPointers: PExceptionPointers;
             EstablisherFrame: NativeUInt; ExceptionObject: Pointer;
             ExceptionAddress: Pointer): NativeUInt;
  {$EXTERNALSYM _TDelphiSafeCallCatchHandlerProc}
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$ENDIF MSWINDOWS}

{$IFDEF PC_MAPPED_EXCEPTIONS}
type
  PRaisedException = ^TRaisedException;
  TRaisedException = packed record
    RefCount: Integer;
    ExceptObject: TObject;
    ExceptionAddr: Pointer;
    HandlerEBP: LongWord;
    Flags: LongWord;
    Cleanup: Pointer;
    Prev: PRaisedException;
    ReleaseProc: Pointer;
  end;
  PExceptionRecord = PRaisedException;
  TExceptionRecord = TRaisedException;
{$ENDIF}
{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
type
  _Unwind_Action = Integer;
  {$EXTERNALSYM _Unwind_Action}
  _Unwind_State = Integer;
  {$EXTERNALSYM _Unwind_State}

{$MINENUMSIZE 4}
  _Unwind_Reason_Code = (
    _URC_NO_REASON, { = 0}
    _URC_FOREIGN_EXCEPTION_CAUGHT, { = 1}
    _URC_FATAL_PHASE2_ERROR, { = 2}
    _URC_FATAL_PHASE1_ERROR, { = 3}
    _URC_NORMAL_STOP, { = 4}
    _URC_END_OF_STACK, { = 5}
    _URC_HANDLER_FOUND, { = 6}
    _URC_INSTALL_CONTEXT, { = 7}
    _URC_CONTINUE_UNWIND, { = 8}
    _URC_FAILURE { = 9}
  );
{$MINENUMSIZE 1}
  {$EXTERNALSYM _Unwind_Reason_Code}
  TUnwindReasonCode = _Unwind_Reason_Code;
  {$EXTERNALSYM TUnwindReasonCode}
  PUnwind_Exception = ^_Unwind_Exception;
  {$EXTERNALSYM PUnwind_Exception}
  _Unwind_Exception_Cleanup_Fn = procedure (reason: _Unwind_Reason_Code; exc: PUnwind_Exception) cdecl;
  {$EXTERNALSYM _Unwind_Exception_Cleanup_Fn}
  _Unwind_Exception = record
    exception_class: UInt64;
    exception_cleanup: _Unwind_Exception_Cleanup_Fn;
    private_1: UIntPtr;        // non-zero means forced unwind
    private_2: UIntPtr;        // holds sp that phase1 found for phase2 to use
{$IF Defined(ZCX_BASED_EXCEPTIONS_MACOS) or Defined(SJLJ_BASED_EXCEPTIONS)}
  {$IF Defined(CPU32BITS)}
    reserved: array[0..2] of UInt32;
  {$ENDIF CPU32BITS}
{$ENDIF ZCX_BASED_EXCEPTIONS_MACOS or SJLJ_BASED_EXCEPTIONS}
{$IF Defined(ZCX_BASED_EXCEPTIONS)}
  {$IF not Defined(LONGINT64)}
    reserved: array[0..2] of UInt32;
  {$ENDIF !LONGINT64}
  {$IF Defined(CPUARM)}
    barrier_cache_sp: UInt32;
    barrier_cache_bitpattern: array[0..4] of UInt32;
    cleanup_cache_bitpattern: array[0..3] of UInt32;
    fnstart: UInt32;
    ehtp: NativeUInt;  // _Unwind_EHT_Header
    additional: UInt32;
    reserved1: UInt32;
  {$ENDIF CPUARM}
{$ENDIF ZCX_BASED_EXCEPTIONS}
  end;
  {$EXTERNALSYM _Unwind_Exception}
  TUnwindException = _Unwind_Exception;
  {$EXTERNALSYM TUnwindException}
  PUnwindException = PUnwind_Exception;
  {$EXTERNALSYM PUnwindException}
  _Unwind_Context = record
  end;
  {$EXTERNALSYM _Unwind_Context}
  PUnwind_Context = ^_Unwind_Context;
  {$EXTERNALSYM PUnwind_Context}
  _Unwind_Control_Block = type _Unwind_Exception;
  {$EXTERNALSYM _Unwind_Control_Block}
  _Unwind_Stop_Fn = function (Version: Integer; actions: _Unwind_Action; exceptionClass: UInt64;
    var exceptionObject: _Unwind_Exception; var context: _Unwind_Context; stop_parameter: Pointer): _Unwind_Reason_Code; cdecl;
  {$EXTERNALSYM _Unwind_Stop_Fn}

const
  _UA_SEARCH_PHASE = _Unwind_Action(1);
  {$EXTERNALSYM _UA_SEARCH_PHASE}
  _UA_CLEANUP_PHASE = _Unwind_Action(2);
  {$EXTERNALSYM _UA_CLEANUP_PHASE}
  _UA_HANDLER_FRAME = _Unwind_Action(4);
  {$EXTERNALSYM _UA_HANDLER_FRAME}
  _UA_FORCE_UNWIND = _Unwind_Action(8);
  {$EXTERNALSYM _UA_FORCE_UNWIND}

  _US_VIRTUAL_UNWIND_FRAME = _Unwind_State(0);
  {$EXTERNALSYM _US_VIRTUAL_UNWIND_FRAME}
  _US_UNWIND_FRAME_STARTING = _Unwind_State(1);
  {$EXTERNALSYM _US_UNWIND_FRAME_STARTING}
  _US_UNWIND_FRAME_RESUME = _Unwind_State(2);
  {$EXTERNALSYM _US_UNWIND_FRAME_RESUME}
  _US_ACTION_MASK = _Unwind_State(3);
  {$EXTERNALSYM _US_ACTION_MASK}
  _US_FORCE_UNWIND = _Unwind_State(8);
  {$EXTERNALSYM _US_FORCE_UNWIND}
  _US_END_OF_STACK = _Unwind_State(16);
  {$EXTERNALSYM _US_END_OF_STACK}

{$IF Defined(ZCX_BASED_EXCEPTIONS_MACOS) or Defined(SJLJ_BASED_EXCEPTIONS)}
  CPPExceptionPersonality  =   UInt64($434C4E47432B2B00); // 'CLNGC++\0' kOurExceptionClass
  CPPExceptionPersonality1 =   UInt64($434C4E47432B2B01); // 'CLNGC++\1' kOurDependentExceptionClass
{$ELSEIF Defined(ZCX_BASED_EXCEPTIONS)}
  CPPExceptionPersonality =    UInt64($474E5543432B2B00); // 'GNUCC++\0'
{$ENDIF}
  DelphiExceptionPersonality = UInt64($454D4254444C5048); // 'EMBTDLPH'

// FIXME: System.SysUtils.pas needs to update. It uses PExceptionRecord
type
  PExceptionRecord = ^TExceptionRecord;
  TExceptionRecord = record
    ExceptionCode: Cardinal;
    ExceptionFlags: Cardinal;
    ExceptionRecord: PExceptionRecord;
    ExceptionAddress: Pointer;
    NumberParameters: Cardinal;
    ExceptAddr: Pointer;
    ExceptObject: TObject;
  end;
  {$NODEFINE TExceptionRecord}
  (*$HPPEMIT 'namespace System' *)
  (*$HPPEMIT '{' *)
  (*$HPPEMIT '  struct DECLSPEC_DRECORD TExceptionRecord;' *)
  (*$HPPEMIT '}' *)
  TRaiseExceptObjProc = procedure(P: PExceptionRecord);
  TGetExceptionObject = function(ExceptionClass: UInt64): TObject;

var
  ExceptObjProc: TGetExceptionObject;
{$ENDIF SJLJ_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}

procedure _InitResStrings(InitTable: Pointer);
procedure _InitResStringImports(InitTable: Pointer);
procedure _InitImports(InitTable: Pointer);
{$IFDEF MSWINDOWS}
procedure _InitWideStrings(InitTable: Pointer);
{$ENDIF}
procedure _FinalizeResStrings(InitTable: Pointer);
procedure _FinalizeResStringImports(InitTable: Pointer);
{$IFDEF MSWINDOWS}
procedure _FinalizeWideStrings(InitTable: Pointer);
{$ENDIF}

function _ClassCreate(InstanceOrVMT: Pointer; Alloc: ShortInt): Pointer;
{$IF not defined(X86ASMRTL)}
procedure _BeforeDestruction(const Instance: TObject; OuterMost: ShortInt);
{$ELSE X86ASMRTL}
{ dcc32 generated code depends on DL being preserved through the chain of
  calls up the inherited dtor chain.  Thus a PUREPASCAL implementation
  leads to non-deterministic results at destruction time with the current
  code generator.}
function _BeforeDestruction(const Instance: TObject; OuterMost: ShortInt): TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};
{$ENDIF X86ASMRTL}
procedure _ClassDestroy(const Instance: TObject);
function _AfterConstruction(const Instance: TObject): TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};
function _IsClass(const Child: TObject; Parent: TClass): Boolean;
function _AsClass(const Child: TObject; Parent: TClass): TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};
function _GetHelperIntf(const Instance: TObject; HelperClass: TClass): IInterface;
function _IntfAsClass(const Intf: IInterface; Parent: TClass): TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};
function _SafeIntfAsClass(const Intf: IInterface; Parent: TClass): TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};
function _IntfIsClass(const Intf: IInterface; Parent: TClass): Boolean;

{ Exception Support }

{$IFDEF PC_MAPPED_EXCEPTIONS}
procedure _RaiseAtExcept;
procedure _RaiseExcept;
procedure _RaiseAgain;
procedure _DestroyException;
procedure _DoneExcept;
procedure _HandleAnyException;
procedure _HandleAutoException;
procedure _HandleOnException;
procedure _HandleFinally;
procedure _HandleOnExceptionPIC;
procedure _ClassHandleException;
procedure _UnhandledException;
{$ENDIF PC_MAPPED_EXCEPTIONS}

{$IFDEF STACK_BASED_EXCEPTIONS}
procedure _RaiseExcept;
procedure _RaiseAgain;
procedure _DoneExcept;
procedure _TryFinallyExit;
procedure _HandleAnyException;
procedure _HandleAutoException;
procedure _HandleOnException;
procedure _HandleFinally;
procedure _UnhandledException;
{$ENDIF STACK_BASED_EXCEPTIONS}

{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure _RaiseExcept(Obj: TObject);
procedure _RaiseAtExcept(Obj: TObject; Address: Pointer);
procedure _RaiseAgain;
procedure _DestroyException(ExceptionPointers: PExceptionPointers; EstablisherFrame: NativeUInt);
procedure _DoneExcept;
procedure _TryFinallyExit(EstablisherFrame: NativeUInt; TargetAddr: NativeUInt);
procedure _UnhandledException;
function _DelphiExceptionHandler(ExceptionRecord: PExceptionRecord;
  EstablisherFrame: NativeUInt; ContextRecord: _PContext;
  DispatcherContext: Pointer{PDispatcherContext}):
  LongInt{TExceptionDisposition}; stdcall;
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS) }
function _HandleAutoException(const Self: TObject; var UnwindException: _Unwind_Exception): HResult;
procedure _RaiseAtExcept(const Obj: TObject; Address: Pointer);
procedure _RaiseExcept(const Obj: TObject);
procedure _RaiseAgain;
procedure _DestroyException(var UnwindException: _Unwind_Exception);
procedure _DoneExcept(var UnwindException: _Unwind_Exception);
procedure _UnhandledException;
{$IF Defined(ZCX_BASED_EXCEPTIONS)}
procedure _DoneExceptUCB(var UnwindException: _Unwind_Control_Block);
{$ENDIF ZCX_BASED_EXCEPTIONS}
{$IF (not Defined(MACOS)) and Defined(CPUARM) and (not Defined(SJLJ_BASED_EXCEPTIONS))} // LIBCXXABI_ARM_EHABI
function _DelphiPersonalityRoutine(status: _Unwind_State;
  var exceptionObject: _Unwind_Exception; context: PUnwind_Context): _Unwind_Reason_Code; cdecl;
{$ELSE !LIBCXXABI_ARM_EHABI}
function _DelphiPersonalityRoutine(Version: Integer; actions: _Unwind_Action; exceptionClass: UInt64;
  var exceptionObject: _Unwind_Exception; context: PUnwind_Context): _Unwind_Reason_Code; cdecl;
{$ENDIF LIBCXXABI_ARM_EHABI}
{$ENDIF}

{ Class Support }
function _FindDynaInst(const Self: TObject; Selector: SmallInt): Pointer;
function _FindDynaClass(Vmt: TClass; Selector: SmallInt): Pointer;
{$IF defined(X86ASMRTL)}
// These functions use ESI as the Selector, which doesn't map to any
// of dcc32's known calling conventions. These cannot be called from
// pure pascal code.
procedure _CallDynaInst;
procedure _CallDynaClass;
{$ENDIF X86ASMRTL}

{ String Support }

{ Compiler helper for string allocation and release }
function _NewUnicodeString(CharLength: Integer): Pointer;
function _NewAnsiString(CharLength: Integer; CodePage: Word): Pointer;
function _NewWideString(CharLength: Integer): Pointer;
{$IF not defined(X86ASMRTL)}
function _UStrClr(var S): Pointer;
function _LStrClr(var S): Pointer;
function _WStrClr(var S): Pointer;
{$ELSE}
// dcc32 generated code expects the result to remain in EAX,
// so we have to return S
procedure _UStrClr(var S);
procedure _LStrClr(var S);
procedure _WStrClr(var S);
{$ENDIF}
procedure _UStrArrayClr(var StrArray; Count: Integer);
procedure _LStrArrayClr(var StrArray; Count: Integer);
procedure _WStrArrayClr(var StrArray; Count: Integer);
function _UStrAddRef(Str: Pointer): Pointer;
function _LStrAddRef(Str: Pointer): Pointer;
{$IFDEF MSWINDOWS}
function _WStrAddRef(var Str: _WideStr): Pointer;
{$ELSE}
function _WStrAddRef(Str: Pointer): Pointer;
{$ENDIF}

{ Compiler helper for basic string constructors }
procedure _UStrFromPWCharLen(var Dest: UnicodeString; Source: PWideChar; CharLength: Integer);
procedure _WStrFromPWCharLen(var Dest: _WideStr; Source: PWideChar; CharLength: Integer);
procedure _LStrFromPCharLen(var Dest: _AnsiStr; Source: _PAnsiChr; Length: Integer; CodePage: Word);
//procedure InternalUStrFromPCharLen(var Dest: UnicodeString; Source: _PAnsiChr; Length: Integer; CodePage: Integer);
procedure _UStrFromPCharLen(var Dest: UnicodeString; Source: _PAnsiChr; Length: Integer);
//procedure InternalWStrFromPCharLen(var Dest: _WideStr; Source: _PAnsiChr; Length: Integer; CodePage: Integer);
procedure _WStrFromPCharLen(var Dest: _WideStr; Source: _PAnsiChr; Length: Integer);
procedure _LStrFromPWCharLen(var Dest: _AnsiStr; Source: PWideChar; Length: Integer; CodePage: Word);

{ Compiler helper for string assignment }
procedure _UStrAsg(var Dest: UnicodeString; const Source: UnicodeString);
procedure _UStrLAsg(var Dest: UnicodeString; const Source: UnicodeString);
procedure _WStrAsg(var Dest: _WideStr; const Source: _WideStr);
procedure _WStrLAsg(var Dest: _WideStr; const Source: _WideStr);
procedure _LStrAsg(var Dest: _AnsiStr; const Source: _AnsiStr);
procedure _LStrLAsg(var Dest: _AnsiStr; const Source: _AnsiStr);

{ string info utilities }
function StringElementSize(const S: UnicodeString): Word; overload; inline;
function StringElementSize(const S: _RawByteStr): Word; overload; inline;
function StringCodePage(const S: UnicodeString): Word; overload; inline;
function StringCodePage(const S: _RawByteStr): Word; overload; inline;
function StringRefCount(const S: UnicodeString): Integer; overload; inline;
function StringRefCount(const S: _RawByteStr): Integer; overload; inline;
{$IFNDEF MSWINDOWS}
function StringElementSize(const S: _WideStr): Word; overload; inline;
function StringCodePage(const S: _WideStr): Word; overload; inline;
function StringRefCount(const S: _WideStr): Integer; overload; inline;
{$ENDIF}

{ Compiler helper for string length }
function _UStrLen(const S: UnicodeString): Integer; inline;
function _WStrLen(const S: _WideStr): Integer; inline;
// Note: VCLE.LIB|dstring.cpp refers mangled names of _LStrLen
function _LStrLen(const S: _RawByteStr): Integer; inline;
//function _PStrLen(const S: _ShortStr): Integer; inline;
function _PCharLen(P: _PAnsiChr): Integer;
function _PWCharLen(P: PWideChar): Integer;

{ Compiler helper for _UniqueString* functions }
function _UniqueStringU(var Str: UnicodeString): Pointer;
{$IFNDEF MSWINDOWS}
function _UniqueStringW(var Str: _WideStr): Pointer;
{$ENDIF}
function _UniqueStringA(var Str: _AnsiStr): Pointer;

{ UniqueString* functions }
procedure UniqueString(var Str: UnicodeString); overload;
procedure UniqueString(var Str: _WideStr); overload;
procedure UniqueString(var Str: _AnsiStr); overload;

{ Compiler helper for comparing array of characters }
{$IF not defined(X86ASMRTL)}
function _PStrCmp(const Left, Right: _ShortStr): Integer;
function _AStrCmp(const Left, Right: _PAnsiChr; Len: NativeInt): Integer;
function _WStrLCmp(const Left, Right: PWideChar; Len: NativeInt): Integer;
{$ELSE X86ASMRTL}
// On dcc32, these return their result in the flag register rather
// than a typical return value.
// They cannot be invoked from pure pascal code.
procedure _PStrCmp;
procedure _AStrCmp;
procedure _WStrLCmp;
{$ENDIF X86ASMRTL}

{ Compiler helper for _ShortStr support }
procedure _PStrCpy(Dest: _PShortStr; Source: _PShortStr);
procedure _PStrNCpy(Dest: _PShortStr; Source: _PShortStr; MaxLen: Byte);
procedure _PStrCat(Dest: _PShortStr; const Src: _ShortStr);
procedure _PStrNCat(Dest: _PShortStr; const Src: _ShortStr; Size:Integer);

function _Copy(const S: _ShortStr; Index, Count: Integer): _ShortStr;
{$IF not defined(X86ASMRTL)}
// var _ShortStr is actually two parameters, Pointer to the string and size of the string.
procedure _Delete(var s: _ShortStr; Index, Count: Integer);
{$ELSE}
procedure _Delete(s: _PShortStr; Index, Count: Integer);
{$ENDIF}
{$IFDEF NEXTGEN}
procedure _Insert(const Source: _ShortStr; var S: _OpenString; Index: Integer);
{$ELSE}
procedure _Insert(const Source: _ShortStr; var S: OpenString; Index: Integer);
{$ENDIF}
procedure _SetLength(s: _PShortStr; newLength: Byte);
procedure _SetString(s: _PShortStr; buffer: _PAnsiChr; len: Byte);

{ Compiler helper for _AnsiStr support }
// Note: VCLE.LIB|dstring.cpp refers mangled names of _LStrFromArray, _LStrFromWStr, _LStrFromUStr, _LStrFromPChar and _LStrFromPWChar
function _LStrToPChar(const S: _AnsiStr): _PAnsiChr;
procedure _LStrToString(Dest: _PShortStr; const Source: _AnsiStr; MaxLen: Integer);
procedure _LStrFromChar(var Dest: _AnsiStr; Source: _AnsiChr; CodePage: Word);
procedure _LStrFromWChar(var Dest: _AnsiStr; Source: WideChar; CodePage: Word);
procedure _LStrFromPChar(var Dest: _AnsiStr; Source: _PAnsiChr; CodePage: Word);
procedure _LStrFromPWChar(var Dest: _AnsiStr; Source: PWideChar; CodePage: Word);
procedure _LStrFromArray(var Dest: _AnsiStr; Source: _PAnsiChr; Length: Integer; CodePage: Word);
procedure _LStrFromWArray(var Dest: _AnsiStr; Source: PWideChar; Length: Integer; CodePage: Word);
procedure _LStrFromUStr(var Dest: _AnsiStr; const Source: UnicodeString; CodePage: Word);
procedure _LStrFromWStr(var Dest: _AnsiStr; const Source: _WideStr; CodePage: Word);
procedure _LStrFromString(var Dest: _AnsiStr; const Source: _ShortStr; CodePage: Word);
procedure _LStrCat(var Dest: _AnsiStr; const Source: _AnsiStr);
procedure _LStrCat3(var Dest: _AnsiStr; const Source1, Source2: _AnsiStr);

{$IF not defined(X86ASMRTL)}
procedure _LStrCatN(var Dest: _AnsiStr; ArgCnt: Integer); cdecl; varargs;
function _LStrCmp(const Left, Right: _AnsiStr): Integer;
function _LStrEqual(const Left, Right: _AnsiStr): Integer;
{$ELSE X86ASMRTL}
// dcc32 cannot handle varargs. This function cannot be invoked
// from pure pascal code.
procedure _LStrCatN{var dest:_AnsiStr; argCnt: Integer; ...};
// These functions return their result in the flags register. They
// cannot be invoked from pure pascal code.
procedure _LStrCmp{left: _AnsiStr; right: _AnsiStr};
procedure _LStrEqual{const Left, Right: _AnsiStr};
{$ENDIF X86ASMRTL}
function _LStrCopy(const S: _AnsiStr; Index, Count: Integer): _AnsiStr;
procedure _LStrDelete(var S: _AnsiStr; Index, Count: Integer);
procedure _LStrInsert(const Source: _AnsiStr; var S: _AnsiStr; Index: Integer);
procedure _LStrSetLength(var Str: _AnsiStr; NewLength: Integer; CodePage: Word);

{ Compiler helper for _WideStr support }
function _WStrToPWChar(const S: _WideStr): PWideChar;
procedure _WStrToString(Dest: _PShortStr; const Source: _WideStr; MaxLen: Integer);
procedure _WStrFromChar(var Dest: _WideStr; Source: _AnsiChr);
procedure _WStrFromWChar(var Dest: _WideStr; Source: WideChar);
procedure _WStrFromPChar(var Dest: _WideStr; Source: _PAnsiChr);
procedure _WStrFromPWChar(var Dest: _WideStr; Source: PWideChar);
procedure _WStrFromArray(var Dest: _WideStr; Source: _PAnsiChr; Length: Integer);
procedure _WStrFromWArray(var Dest: _WideStr; Source: PWideChar; Length: Integer);
procedure _WStrFromLStr(var Dest: _WideStr; const Source: _AnsiStr);
procedure _WStrFromUStr(var Dest: _WideStr; const Source: UnicodeString);
procedure _WStrFromString(var Dest: _WideStr; const Source: _ShortStr);
procedure _WStrCat(var Dest: _WideStr; const Source: _WideStr);
procedure _WStrCat3(var Dest: _WideStr; const Source1, Source2: _WideStr);

{$IF not defined(X86ASMRTL)}
procedure _WStrCatN(var Dest: _WideStr; ArgCnt: Integer); cdecl; varargs;
function _WStrCmp(const Left, Right: _WideStr): Integer;
function _WStrEqual(const Left, Right: _WideStr): Integer;
{$ELSE X86ASMRTL}
// dcc32 cannot handle varargs. This function cannot be invoked
// from pure pascal code.
procedure _WStrCatN{var dest:_WideStr; argCnt: Integer; ...};
// These functions return their result in the flags register. They
// cannot be invoked from pure pascal code.
procedure _WStrCmp{left: _WideStr; right: _WideStr};
procedure _WStrEqual{const Left, Right: _WideStr};
{$ENDIF X86ASMRTL}
function _WStrCopy(const S: _WideStr; Index, Count: Integer): _WideStr;
procedure _WStrDelete(var S: _WideStr; Index, Count: Integer);
procedure _WStrInsert(const Source: _WideStr; var Dest: _WideStr; Index: Integer);
procedure _WStrSetLength(var S: _WideStr; NewLength: Integer);

{ Compiler helper for UnicodeString support }
function _UStrToPWChar(const S: UnicodeString): PWideChar;
procedure _UStrToString(Dest: _PShortStr; const Source: UnicodeString; MaxLen: Integer);
procedure _UStrFromChar(var Dest: UnicodeString; Source: _AnsiChr);
procedure _UStrFromWChar(var Dest: UnicodeString; Source: WideChar);
procedure _UStrFromPChar(var Dest: UnicodeString; Source: _PAnsiChr);
procedure _UStrFromPWChar(var Dest: UnicodeString; Source: PWideChar);
procedure _UStrFromArray(var Dest: UnicodeString; Source: _PAnsiChr; Length: Integer);
procedure _UStrFromWArray(var Dest: UnicodeString; Source: PWideChar; Length: Integer);
procedure _UStrFromLStr(var Dest: UnicodeString; const Source: _AnsiStr);
procedure _UStrFromWStr(var Dest: UnicodeString; const Source: _WideStr);
procedure _UStrFromString(var Dest: UnicodeString; const Source: _ShortStr);
procedure _UStrCat(var Dest: UnicodeString; const Source: UnicodeString);
procedure _UStrCat3(var Dest: UnicodeString; const Source1, Source2: UnicodeString);

{$IF not defined(X86ASMRTL)}
procedure _UStrCatN(var Dest: UnicodeString; ArgCnt: Integer); cdecl; varargs;
function _UStrCmp(const Left, Right: UnicodeString): Integer;
function _UStrEqual(const Left, Right: UnicodeString): Integer;
{$ELSE X86ASMRTL}
// dcc32 cannot handle varargs. This function cannot be invoked
// from pure pascal code.
procedure _UStrCatN{var dest:UnicodeString; argCnt: Integer; ...};
// These functions return their result in the flags register. They
// cannot be invoked from pure pascal code.
procedure _UStrCmp{const Left, Right: UnicodeString};
procedure _UStrEqual{const Left, Right: UnicodeString};
{$ENDIF X86ASMRTL}
function _UStrCopy(const S: UnicodeString; Index, Count: Integer): UnicodeString;
procedure _UStrDelete(var S: UnicodeString; Index, Count: Integer);
procedure _UStrInsert(const Source: UnicodeString; var Dest: UnicodeString; Index: Integer);
procedure _UStrSetLength(var Str: UnicodeString; NewLength: Integer);

{ string utilities }
function Pos(const SubStr, Str: _ShortStr; Offset: Integer = 1): Integer; overload;
function Pos(const SubStr, Str: UnicodeString; Offset: Integer = 1): Integer; overload;
function Pos(const SubStr, Str: _WideStr; Offset: Integer = 1): Integer; overload;
function Pos(const SubStr, Str: _RawByteStr; Offset: Integer = 1): Integer; overload;
function StringOfChar(Ch: WideChar; Count: Integer): UnicodeString; overload;
function StringOfChar(Ch: _AnsiChr; Count: Integer): _AnsiStr; overload;
procedure SetAnsiString(Dest: _PAnsiStr; Source: PWideChar; Length: Integer; CodePage: Word);
procedure SetCodePage(var S: _RawByteStr; CodePage: Word; Convert: Boolean = True);
function UnicodeStringToUCS4String(const S: UnicodeString): UCS4String;
function UCS4StringToUnicodeString(const S: UCS4String): UnicodeString;
function WideCharToUCS4String(S: PWideChar; Len: Integer = MaxInt): UCS4String;
//function UTF8Encode(const WS: UnicodeString): UTF8String;
//function UTF8Decode(const S: UTF8String): UnicodeString;

function _Write0UString(var t: TTextRec; const s: UnicodeString): Pointer;
function _WriteUString(var t: TTextRec; const s: UnicodeString; width: Integer): Pointer;


{ Compiler helper for initializing/finalizing variable }
procedure InitializeArray(p: Pointer; typeInfo: Pointer; elemCount: NativeUInt);
procedure _Initialize(p: Pointer; typeInfo: Pointer);
procedure _InitializeArray(p: Pointer; typeInfo: Pointer; elemCount: NativeUInt);
procedure _InitializeRecord(p: Pointer; typeInfo: Pointer);
{$IF not defined(X86ASMRTL)}
// dcc64 generated code expects P to remain in RAX on exit from this function.
function _Finalize(P: Pointer; TypeInfo: Pointer): Pointer;
function _FinalizeArray(P: Pointer; TypeInfo: Pointer; ElemCount: NativeUInt): Pointer;
function _FinalizeRecord(P: Pointer; TypeInfo: Pointer): Pointer;
{$ELSE}
procedure _Finalize(p: Pointer; typeInfo: Pointer);
procedure _FinalizeArray(P: Pointer; TypeInfo: Pointer; ElemCount: NativeUInt);
procedure _FinalizeRecord(P: Pointer; TypeInfo: Pointer);
{$ENDIF}
{$IF not defined(X86ASMRTL)}
procedure _CopyRecord(Dest, Source, TypeInfo: Pointer);
procedure _CopyObject(Dest, Source: Pointer; vmtPtrOffs: NativeInt; TypeInfo: Pointer);
procedure _CopyArray(Dest, Source, TypeInfo: Pointer; Count: NativeUInt);
{$ELSE}
// The asm implementation of these functions uses EBP as a general
// purpose register, and assumes a frame is not added. Adding parameters
// adds the frame, so in order to define the parameters for these functions,
// the ASM needs to be updated.
procedure _CopyRecord;
procedure _CopyObject;
procedure _CopyArray;
{$ENDIF}
procedure _AddRef(P: Pointer; TypeInfo: Pointer);
procedure _AddRefArray(P: Pointer; TypeInfo: Pointer; ElemCount: NativeUInt);
procedure _AddRefRecord(P: Pointer; TypeInfo: Pointer);

function _New(Size: NativeInt; TypeInfo: Pointer): Pointer;
procedure _Dispose(P: Pointer; TypeInfo: Pointer);

/// <summary>Copy Count items in Array. </summary>
procedure CopyArray(Dest, Source, TypeInfo: Pointer; Count: NativeInt);
/// <summary>Move Count items in Array. </summary>
/// <remarks>MoveArray is equivalent to calling CopyArray(Dest, Souce, TypeInfo, Count)
/// then FinalizeArray(Source, TypeInfo, count)</remarks>
procedure MoveArray(Dest, Source, TypeInfo: Pointer; Count: NativeInt);
/// <summary>Finalize Count items in Array. </summary>
procedure FinalizeArray(P: Pointer; TypeInfo: Pointer; Count: NativeUInt);

/// <summary>Copy fields in Record. </summary>
procedure CopyRecord(Dest, Source, TypeInfo: Pointer);
/// <summary>Move fields in Record. </summary>
/// <remarks>MoveRecord is equivalent to calling CopyRecord(Dest, Souce, TypeInfo)
/// then FinalizeRecord(Source, TypeInfo)</remarks>
procedure MoveRecord(Dest, Source, TypeInfo: Pointer);
/// <summary>Finalize fields in Record. </summary>
procedure FinalizeRecord(P: Pointer; TypeInfo: Pointer);


{ 64-bit Integer helper routines }
{$IF defined(CPU386) and defined(ASSEMBLER)}
procedure __llmul;
procedure __lldiv;
procedure __lludiv;
procedure __llmod;
procedure __llmulo;
procedure __lldivo;
procedure __llmodo;
procedure __llumod;
procedure __llshl;
procedure __llushr;
{$ENDIF}
function _WriteInt64(var t: TTextRec; val: Int64; width: Integer): Pointer;
function _Write0Int64(var t: TTextRec; val: Int64): Pointer;
function _WriteUInt64(var t: TTextRec; val: UInt64; width: Integer): Pointer;
function _Write0UInt64(var t: TTextRec; val: UInt64): Pointer;
function _ReadInt64(var t: TTextRec): Int64;
function _ReadUInt64(var t: TTextRec): UInt64;
function _StrInt64(val: Int64; width: Integer): _ShortStr;
function _Str0Int64(val: Int64): _ShortStr;
function _ValInt64(const S: string; var Code: Integer): Int64;
function _ValUInt64(const s: string; var code: Integer): UInt64;
function _StrUInt64(val: UInt64; width: Integer): _ShortStr;
function _Str0UInt64(val: Int64): _ShortStr;


{ Compiler helper for Dynamic array support }

function _DynArrayLength(const A: Pointer): NativeInt; inline;
function _DynArrayHigh(const A: Pointer): NativeInt; inline;

procedure DynArrayClear(var A: Pointer; TypeInfo: Pointer); inline;

procedure DynArraySetLength(var a: Pointer; typeInfo: Pointer; dimCnt: NativeInt; lengthVec: PNativeInt);

{$IF not defined(X86ASMRTL)}
procedure _DynArraySetLength(var A: Pointer; TypeInfo: Pointer; DimCnt: NativeInt); cdecl; varargs;
{$ELSE}
// dcc32 does not support varargs params. This cannot be called from
// pure pascal code
procedure _DynArraySetLength;
{$ENDIF}

{$IF defined(X86ASMRTL)}
procedure _DynArrayCopy(a: Pointer; typeInfo: Pointer; var Result: Pointer);
procedure _DynArrayCopyRange(A: Pointer; TypeInfo: Pointer; Index, Count : Integer; var Result: Pointer);
{$ELSE}
procedure _DynArrayCopy(var Result: Pointer; a: Pointer; typeInfo: Pointer);
procedure _DynArrayCopyRange(var Result: Pointer; A: Pointer; TypeInfo: Pointer; Index, Count: NativeInt);
{$ENDIF}

procedure DynArrayCopy(var Result: Pointer; a: Pointer; typeInfo: Pointer); inline;
procedure DynArrayCopyRange(var Result: Pointer; A: Pointer; TypeInfo: Pointer; Index, Count: NativeInt); inline;
procedure DynArrayUnique(var A: Pointer; typeInfo: Pointer);

{$IF not defined(X86ASMRTL)}
// dcc64 expects RAX to maintain a pointer to A on return, so we must return it
function _DynArrayClear(var A: Pointer; TypeInfo: Pointer): Pointer;
{$ELSE}
// dcc32 expects EAX to maintain a pointer to A on return implemented by asm.
procedure _DynArrayClear(var a: Pointer; typeInfo: Pointer);
{$ENDIF}
procedure _DynArrayAsg(var Dest: Pointer; Src: Pointer; TypeInfo: Pointer);
procedure _DynArrayAddRef(P: Pointer);
function  _DynArrayRelease(P: Pointer): Integer;

procedure _DynArrayCat(var Dest: Pointer; Source: Pointer; typeInfo: Pointer);
procedure _DynArrayCat3(var Dest: Pointer; Source1, Source2: Pointer; typeInfo: Pointer);
procedure _DynArrayCatN(var Dest: Pointer; ArgCnt: Integer; typeInfo: Pointer; Arrays: PPointer);
procedure _DynArrayDelete(var Dest: Pointer; Index, Count: NativeInt; typeInfo: Pointer);
procedure _DynArrayInsert(Source: Pointer; var Dest: Pointer; Index: NativeInt; typeInfo: Pointer);
procedure _DynArrayInsertElem(const Source; var Dest: Pointer; Index: NativeInt; typeInfo: Pointer);

function DynArrayIndex(P: Pointer; const Indices: array of NativeInt; TypInfo: Pointer): Pointer; overload;
function DynArrayIndex(P: Pointer; const Indices: array of Integer; TypInfo: Pointer): Pointer; overload;

function DynArrayDim(typeInfo: Pointer): Integer;

function DynArraySize(A: Pointer): NativeInt; inline;
procedure DynArrayAssign(var Dest: Pointer; Source: Pointer; typeInfo: Pointer); inline;

function IsDynArrayRectangular(const DynArray: Pointer; typeInfo: Pointer): Boolean;
function DynArrayBounds(const DynArray: Pointer; typeInfo: Pointer): TBoundArray;

function _IntfClear(var Dest: IInterface): Pointer;
procedure _IntfCopy(var Dest: IInterface; const Source: IInterface);
procedure _IntfCast(var Dest: IInterface; const Source: IInterface; const IID: TGUID);
procedure _IntfOfsCast(var Dest: IInterface; const Source: TObject; const Offset: Integer);
procedure _IntfAddRef(const Dest: IInterface);

{$IFDEF AUTOREFCOUNT}
function _InstClear(var Dest: TObject): Pointer;
procedure _InstCopy(var Dest: TObject; const Source: TObject);
procedure _InstAddRef(const Dest: TObject);

procedure _ClosureAddWeakRef(var Closure: TMethod);
function _ClosureRemoveWeakRef(var Closure: TMethod): Pointer;
procedure _ClosureArrayRemoveWeakRef(var Closure: TMethod; Count: Integer);
procedure _CopyClosure(var Dest: TMethod; const [Ref] Source: TMethod);
function _AsgClosureObj(var Dest: TMethod; const Obj: Pointer; const MethodAddr: Pointer): Pointer;
{$ENDIF}

{$IFDEF WEAKINSTREF}
// Helpers for managing weak references
function _InstWeakClear(var Dest: TObject): Pointer;
procedure _InstWeakArrayClear(var Dest; Count: Integer);
procedure _InstWeakCopy(var Dest: TObject; Source: TObject);
{$ENDIF}

{$IFDEF WEAKINTFREF}
function _IntfWeakClear(var Dest: IInterface): Pointer;
procedure _IntfWeakArrayClear(var Dest; Count: Integer);
procedure _IntfWeakCopy(var Dest: IInterface; Source: IInterface);
{$ENDIF}

{$IFDEF WEAKREF}
procedure _CleanupInstance(Instance: Pointer);
{$ENDIF}

{$IFDEF WIN32}
procedure _FSafeDivide;
procedure _FSafeDivideR;
{$ENDIF}

function _CheckAutoResult(ResultCode: HResult): HResult;

{$IF not defined(X86ASMRTL)}
function FPower10(val: Extended; power: Integer): Extended; deprecated 'Use Power10';
{$ELSE X86ASMRTL}
// Publically accessable function that cannot be called propperly
// from pure pascal code deprecated.
procedure FPower10; deprecated 'Use Power10';
{$ENDIF X86ASMRTL}
function Power10(val: Extended; power: Integer): Extended;

procedure TextStart; deprecated;

// Conversion utility routines for C++ convenience.  Not for Delphi code.
function  CompToDouble(Value: Comp): Double; cdecl;
procedure DoubleToComp(Value: Double; var Result: Comp); cdecl;
function  CompToCurrency(Value: Comp): Currency; cdecl;
procedure CurrencyToComp(Value: Currency; var Result: Comp); cdecl;

function GetMemory(Size: NativeInt): Pointer; cdecl;
function FreeMemory(P: Pointer): Integer; cdecl;
function ReallocMemory(P: Pointer; Size: NativeInt): Pointer; cdecl;


{ Internal runtime error codes }

type
  TRuntimeError = (reNone, reOutOfMemory, reInvalidPtr, reDivByZero,
    reRangeError, reIntOverflow, reInvalidOp, reZeroDivide, reOverflow,
    reUnderflow, reInvalidCast, reAccessViolation, rePrivInstruction,
    reControlBreak, reStackOverflow,
    { reVar* used in Variants.pas }
    reVarTypeCast, reVarInvalidOp,
    reVarDispatch, reVarArrayCreate, reVarNotArray, reVarArrayBounds,
    reAssertionFailed,
    reExternalException, { not used here; in SysUtils }
    reIntfCastError, reSafeCallError,
    reMonitorNotLocked, reNoMonitorSupport,
{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
    reQuit,
{$ENDIF LINUX or MACOS or ANDROID}
{$IFDEF POSIX}
    reCodesetConversion,
{$ENDIF POSIX}
    rePlatformNotImplemented, reObjectDisposed
  );
{$NODEFINE TRuntimeError}

procedure Error(errorCode: TRuntimeError);
{$NODEFINE Error}

{ GetLastError returns the last error reported by an OS API call.  Calling
  this function usually resets the OS error state.
}

function GetLastError: Integer; {$IFDEF MSWINDOWS} stdcall; {$ENDIF}
{$EXTERNALSYM GetLastError}

{ SetLastError writes to the thread local storage area read by GetLastError. }

procedure SetLastError(ErrorCode: Integer); {$IFDEF MSWINDOWS} stdcall; {$ENDIF}

{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
{  To improve performance, some RTL routines cache module handles and data
   derived from modules.  If an application dynamically loads and unloads
   shared object libraries, packages, or resource packages, it is possible for
   the handle of the newly loaded module to match the handle of a recently
   unloaded module.  The resource caches have no way to detect when this happens.

   To address this issue, the RTL maintains an internal counter that is
   incremented every time a module is loaded or unloaded using RTL functions
   (like LoadPackage).  This provides a cache version level signature that
   can detect when modules have been cycled but have the same handle.

   If you load or unload modules "by hand" using dlopen or dlclose, you must call
   InvalidateModuleCache after each load or unload so that the RTL module handle
   caches will refresh themselves properly the next time they are used.  This is
   especially important if you manually tinker with the LibModuleList list of
   loaded modules, or manually add or remove resource modules in the nodes
   of that list.

   ModuleCacheID returns the "current generation" or version number kept by
   the RTL.  You can use this to implement your own refresh-on-next-use
   (passive) module handle caches as the RTL does.  The value changes each
   time InvalidateModuleCache is called.
}

function ModuleCacheID: Cardinal;
procedure InvalidateModuleCache;
{$ENDIF LINUX or MACOS or ANDROID}

procedure SetMultiByteConversionCodePage(CodePage: Integer);

function GetUILanguages(const LANGID: WORD): string;
function GetLocaleOverride(const AppName: string): string;
procedure SetLocaleOverride(const NewPreferredLanguages: string);

type
  PLongBool = ^LongBool;

{ LocaleCharsFromUnicode is a cross-platform wrapper for WideCharToMultiByte
  with an emulated implemention on non-Windows platforms. The Flags parameter
  isn't supported on non-Windows platforms }

function LocaleCharsFromUnicode(CodePage, Flags: Cardinal;
  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAnsiChr;
  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar: PLongBool): Integer; overload;

{$IFDEF POSIX}
function LocaleCharsFromUnicode(const LocaleName: _AnsiStr; Flags: Cardinal;
  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAnsiChr;
  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar: PLongBool): Integer; overload;
{$ENDIF}

{ UnicodeFromLocaleChars is a cross-platform wrapper for MultiByteToWideChar
  with an emulated implemention on non-Windows platforms. The Flags parameter
  only supports MB_ERR_INVALID_CHARS on non-Windows platforms }

function UnicodeFromLocaleChars(CodePage, Flags: Cardinal; LocaleStr: _PAnsiChr;
  LocaleStrLen: Integer; UnicodeStr: PWideChar; UnicodeStrLen: Integer): Integer; overload;

{$IFDEF POSIX}
function UnicodeFromLocaleChars(const LocaleName: _AnsiStr; Flags: Cardinal;
  LocaleStr: _PAnsiChr; LocaleStrLen: Integer; UnicodeStr: PWideChar;
  UnicodeStrLen: Integer): Integer; overload;
{$ENDIF}

{$IFDEF POSIX}
{ GetACP returns the equivalent Windows codepage identifier based on the
  current LANG environment variable (Linux) or CFLocaleGetIdentifier (Mac OS) }

function GetACP: Cardinal;
{$ENDIF}

{ Compatibility consts for LocaleCharsFromUnicode/UnicodeFromLocaleChars }

(*$HPPEMIT '#if !defined(CP_ACP)' *)
(*$HPPEMIT 'static const System::Word CP_ACP = System::Word(0);' *)
(*$HPPEMIT '#endif' *)
(*$HPPEMIT '#if !defined(CP_UTF7)' *)
(*$HPPEMIT 'static const System::Word CP_UTF7 = System::Word(65000);' *)
(*$HPPEMIT '#endif' *)
(*$HPPEMIT '#if !defined(CP_UTF8)' *)
(*$HPPEMIT 'static const System::Word CP_UTF8 = System::Word(65001);' *)
(*$HPPEMIT '#endif' *)
const
  CP_ACP  = 0;
  CP_UTF7 = 65000;
  CP_UTF8 = 65001;
{$NODEFINE CP_ACP}
{$NODEFINE CP_UTF7}
{$NODEFINE CP_UTF8}

{$IFDEF ANDROID}
var
/// <summary>The ponter to the android native activity</summary>
/// <remarks>In a service this pointer will be nil</remarks>
  DelphiActivity: Pointer;
/// <summary>The ponter to the android java machine</summary>
  JavaMachine: Pointer;
/// <summary>The ponter to the android context</summary>
/// <remarks>In an application this pointer will be the context of the activity
/// In a service this pointer will be the context of the service</remarks>
  JavaContext: Pointer;
{$ENDIF}

{$IFDEF USE_LIBICU}
var
  HICUUC: NativeUInt;
  HICUI18N: NativeUInt;
  LibICUSuffix: string;
{$ENDIF}

{$IFNDEF MSWINDOWS}
const
{$IFDEF CPUARM}
   LibCPP = {$IFDEF IOS}'c++'{$ELSE}'gnustl_static'{$ENDIF};
{$ELSE}
   LibCPP = 'stdc++';
{$ENDIF CPUARM}
{$ENDIF MSWINDOWS}

implementation

uses
  SysInit;

const
{$IFDEF UNDERSCOREIMPORTNAME}
  _PU = '_';
{$ELSE}
  _PU = '';
{$ENDIF}

{$IFDEF POSIX}
{$I PosixAPIs.inc}
{$ENDIF POSIX}

{$IFDEF MACOS}
{$I CoreServicesAPIs.inc}
{$I CoreFoundationAPIs.inc}
{$ENDIF MACOS}

{$IFDEF ANDROID}
{$I Android.inc}
{$ENDIF ANDROID}

{$IFDEF USE_LIBICU}
{$I ICU.inc}
{$ENDIF USE_LIBICU}

{$IFDEF POSIX}
const
  MAX_PATH = 1024;
{$ENDIF}


type
  // For System.pas internal use only.
  // Note, this type is duplicated in getmem.inc for diagnostic purposes. Keep in sync.
  PStrRec = ^StrRec;
  StrRec = packed record
  {$IF defined(CPU64BITS)}
    _Padding: Integer; // Make 16 byte align for payload..
  {$ENDIF}
    codePage: Word;
    elemSize: Word;
    refCnt: Integer;
    length: Integer;
  end;

type
  PMethRec = ^MethRec;
  MethRec = packed record
    recSize: Word;
    methAddr: Pointer;
    nameLen: Byte;
    { nameChars[nameLen]: _AnsiChr }
  end;

const
  skew = SizeOf(StrRec);
  rOff = SizeOf(StrRec); { codePage offset }
  overHead = SizeOf(StrRec) + SizeOf(Char);
  CP_UTF16 = 1200;

type
  PDynArrayRec = ^TDynArrayRec;
  TDynArrayRec = packed record
  {$IFDEF CPU64BITS}
    _Padding: Integer; // Make 16 byte align for payload..
  {$ENDIF}
    RefCnt: Integer;
    Length: NativeInt;
  end;

const
  STATUS_WAIT_0 = Cardinal($00000000);
  WAIT_OBJECT_0 = (STATUS_WAIT_0 + 0);
  ObjCastGUID: TGUID = '{CEDF24DE-80A4-447D-8C75-EB871DC121FD}';

{ This procedure should be at the very beginning of the }
{ text segment. It used to be used by _RunError to find    }
{ start address of the text segment, but is not used anymore.  }

procedure TextStart;
begin
end;

{$IFNDEF PUREPASCAL}
{$IFDEF PIC}
function GetGOT: Pointer;
begin
  asm
        MOV Result,EBX
  end;
end;
{$ENDIF}
{$ENDIF PUREPASCAL}

{$IFDEF PC_MAPPED_EXCEPTIONS}
var
  Unwinder: TUnwinder;

const
  UNWINDFI_TOPOFSTACK =   $BE00EF00;

type
  UNWINDPROC = Pointer;

const
{$IFDEF MSWINDOWS}
  unwind = 'unwind.dll';
{$ENDIF MSWINDOWS}
{$IFDEF LINUX}
  unwind = 'libcgunwind.so.1';
{$ENDIF LINUX}
{$IFDEF MACOS}
  unwind = 'libcgunwind.1.0.dylib';
{$ENDIF MACOS}

                                                                                     
function _BorUnwind_RegisterIPLookup(fn: Pointer; StartAddr, EndAddr: NativeUInt;
  Context: Pointer; GOT: NativeUInt): LongBool; cdecl; external
  {$IFNDEF STATIC_UNWIND} unwind name _PU + '_BorUnwind_RegisterIPLookup'{$ENDIF STATIC_UNWIND};

                                                                                       
procedure _BorUnwind_UnregisterIPLookup(StartAddr: NativeUInt); cdecl; external
  {$IFNDEF STATIC_UNWIND} unwind name _PU + '_BorUnwind_UnregisterIPLookup'{$ENDIF STATIC_UNWIND};

                                                                                 
function _BorUnwind_DelphiLookup(Addr: NativeUInt; Context: Pointer): UNWINDPROC; cdecl; external
  {$IFNDEF STATIC_UNWIND} unwind name _PU + '_BorUnwind_DelphiLookup'{$ENDIF STATIC_UNWIND};

function _BorUnwind_RaiseException(Exc: Pointer): LongBool; cdecl; external
  {$IFNDEF STATIC_UNWIND} unwind name _PU + '_BorUnwind_RaiseException'{$ENDIF STATIC_UNWIND};

                                                                                          
function _BorUnwind_ClosestDelphiHandler(Context: Pointer): NativeUInt; cdecl; external
  {$IFNDEF STATIC_UNWIND} unwind name _PU + '_BorUnwind_ClosestDelphiHandler'{$ENDIF STATIC_UNWIND};

{$IFDEF STATIC_UNWIND}
{$IFDEF PIC}
{$L 'objs/arith.pic.o'}
{$L 'objs/diag.pic.o'}
{$L 'objs/delphiuw.pic.o'}
{$L 'objs/unwind.pic.o'}
{$ELSE !PIC}
{$L 'objs/arith.o'}
{$L 'objs/diag.o'}
{$L 'objs/delphiuw.o'}
{$L 'objs/unwind.o'}
{$ENDIF}
{$ENDIF STATIC_UNWIND}
{$ENDIF PC_MAPPED_EXCEPTIONS}

const { copied from xx.h }
  cContinuable        = 0;
  cNonContinuable     = 1;
  cUnwinding          = 2;
  cUnwindingForExit   = 4;
  cUnwindInProgress   = cUnwinding or cUnwindingForExit;
  cDelphiException    = $0EEDFADE;
  cDelphiReRaise      = $0EEDFADF;
  cDelphiExcept       = $0EEDFAE0;
  cDelphiFinally      = $0EEDFAE1;
  cDelphiTerminate    = $0EEDFAE2;
  cDelphiUnhandled    = $0EEDFAE3;
  cNonDelphiException = $0EEDFAE4;
  cDelphiExitFinally  = $0EEDFAE5;
{$IFDEF WIN64}
  cCppExceptionMask   = $FFFFFFFE;
  cCppException       = $E36C6700;
{$ELSE !WIN64}
  cCppException       = $0EEFFACE; { used by BCB }
{$ENDIF WIN64}
  EXCEPTION_CONTINUE_SEARCH    = 0;
  EXCEPTION_EXECUTE_HANDLER    = 1;
  EXCEPTION_CONTINUE_EXECUTION = -1;

{$IFDEF PC_MAPPED_EXCEPTIONS}
const
  excIsBeingHandled     = $00000001;
  excIsBeingReRaised    = $00000002;
{$ENDIF}

{$IF defined(CPU386) and not defined(PC_MAPPED_EXCEPTIONS)}
type
  JmpInstruction =
  packed record
    opCode:   Byte;
    distance: Longint;
  end;
{$ENDIF CPU386 and !PC_MAPPED_EXCEPTIONS}

{$IFDEF CPU386}
type
  PExcDescEntry = ^TExcDescEntry;
  TExcDescEntry = record
    vTable:  Pointer;
    handler: Pointer;
  end;
  PExcDesc = ^TExcDesc;
  TExcDesc = packed record
{$IFNDEF PC_MAPPED_EXCEPTIONS}
    jmp: JmpInstruction;
{$ENDIF}
    case Integer of
    0:      (instructions: array [0..0] of Byte);
    1{...}: (cnt: Integer; excTab: array [0..0{cnt-1}] of TExcDescEntry);
  end;
{$ENDIF}

{$IFDEF TABLE_BASED_EXCEPTIONS}
// Language specific exception data
type
  PExcDescEntry = ^TExcDescEntry;
  TExcDescEntry = record
    VTable:  LongWord; // 32 bit RVA
    Handler: LongWord; // 32 bit RVA
  end;
  PExcDesc = ^TExcDesc;
  TExcDesc = record
    DescCount: Integer;
    DescTable: array [0..0{DescCount-1}] of TExcDescEntry;
  end;
  PExcScope = ^TExcScope;
  TExcScope = record
    BeginOffset:  LongWord;  // 32 bit RVA
    EndOffset:    LongWord;  // 32 bit RVA
    TableOffset:  LongWord;  // 32 bit RVA. 0:TargetOffset=finally block
                             //             1:TargetOffset=safecall catch block
                             //             2:TargetOffset=catch block
                             //             other:TableOffset=TExcDesc
    TargetOffset: LongWord;  // 32 bit RVA. start of finally/catch block.
                             //   TableOffset=0: signature is _TDelphiFinallyHandlerProc
                             //   TableOffset=1: signature is _TDelphiSafeCallCatchHandlerProc
                             //   TableOffset=2: Location to the catch block
                             //   other: TargetOffset=0
  end;
  PExcData = ^TExcData;
  TExcData = record
    ScopeCount: Integer;
    ScopeTable: array [0..0{ScopeCount-1}] of TExcScope;
  end;
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IFDEF PC_MAPPED_EXCEPTIONS}
const
  UW_EXC_CLASS_BORLANDCPP = $FBEE0001;
  UW_EXC_CLASS_BORLANDDELPHI = $FBEE0101;

type
  // The following _Unwind_* types represent unwind.h
  _Unwind_Word = NativeUInt;
  _Unwind_Exception_Cleanup_Fn = Pointer;
  _Unwind_Exception = packed record
    exception_class: _Unwind_Word;
    exception_cleanup: _Unwind_Exception_Cleanup_Fn;
    private_1: _Unwind_Word;
    private_2: _Unwind_Word;
  end;
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF STACK_BASED_EXCEPTIONS}
type
  PExcFrame = ^TExcFrame;
  TExcFrame = record
    next: PExcFrame;
    desc: PExcDesc;
    hEBP: Pointer;
    case Integer of
    0:  ( );
    1:  ( ConstructedObject: Pointer );
    2:  ( SelfOfMethod: Pointer );
  end;

  PRaiseFrame = ^TRaiseFrame;
  TRaiseFrame = packed record
    NextRaise: PRaiseFrame;
    ExceptAddr: Pointer;
    ExceptObject: TObject;
    ExceptionRecord: PExceptionRecord;
  end;
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
type
  PRaiseFrame = ^TRaiseFrame;
  TRaiseFrame = record
    NextRaise: PRaiseFrame;
    ExceptAddr: Pointer;
    ExceptObject: TObject;
    Allocated: Boolean;
{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
    PrevRaise: PRaiseFrame;
    HandlerSwitchValue: Integer;
    ActionRecord: PByte;
    LanguageSpecificData: PByte;
    CatchTemp: Pointer;
    AdjustedPtr: Pointer;
    UnwindException: _Unwind_Exception;
{$ENDIF SJLJ_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
  end;
  PPRaiseFrame = ^PRaiseFrame;
{$ENDIF TABLE_BASED_EXCEPTIONS or SJLJ_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}

const
  cCR = $0D;
  cLF = $0A;
  cEOF = $1A;

{$IFDEF POSIX}
function GetLastError: Integer;
begin
  Result := __error^;
end;

procedure SetLastError(ErrorCode: Integer);
begin
  __error^ := ErrorCode;
end;
{$ENDIF POSIX}

{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
var
  ModuleCacheVersion: Cardinal = 0;

function ModuleCacheID: Cardinal;
begin
  Result := ModuleCacheVersion;
end;

procedure InvalidateModuleCache;
begin
  AtomicIncrement(Integer(ModuleCacheVersion));
end;
{$ENDIF LINUX or MACOS or ANDROID}

{$IFDEF MSWINDOWS}
{$I WindowsAPIs.INC}

function GetCmdShow: Integer;
var
  SI: TStartupInfo;
begin
  Result := 10;                  { SW_SHOWDEFAULT }
  SI.cb := SizeOf(TStartupInfo);
  GetStartupInfo(SI);
  if SI.dwFlags and 1 <> 0 then  { STARTF_USESHOWWINDOW }
    Result := SI.wShowWindow;
end;
{$ENDIF MSWINDOWS}

{$IF defined(CPUX86) and (not defined(EXTERNALLINKER))}
function _AtomicIncInt64(var Target: Int64; Increment: Int64): Int64;
var
  Tmp: Int64;
begin
  repeat
    Tmp := Target;
    Result := AtomicCmpExchange(Target, Tmp + Increment, Tmp);
  until Result = Tmp;
  Inc(Result, Increment);
end;

function _AtomicXchgInt64(var Target: Int64; Exchange: Int64): Int64;
var
  Tmp: Int64;
begin
  repeat
    Tmp := Target;
    Result := AtomicCmpExchange(Target, Exchange, Tmp);
  until Result = Tmp;
end;
{$ENDIF}

function WCharFromChar(WCharDest: PWideChar; DestChars: Integer; const CharSource: _PAnsiChr; SrcBytes: Integer; CodePage: Integer): Integer; forward;
function CharFromWChar(CharDest: _PAnsiChr; DestBytes: Integer; const WCharSource: PWideChar; SrcChars: Integer; CodePage: Integer): Integer; overload; forward;
function CharFromWChar(CharDest: _PAnsiChr; DestBytes: Integer; const WCharSource: PWideChar; SrcChars: Integer): Integer; overload; forward;

{ ----------------------------------------------------- }
{       Memory manager                                  }
{ ----------------------------------------------------- }

{$IFDEF MSWINDOWS}
{$IFDEF SIMPLEHEAP}
{$I SimpleHeap.inc}
{$ELSE}
{$I GETMEM.INC}
{$ENDIF}
{$ENDIF}

{$IFDEF POSIX}
function SysGetMem(Size: NativeInt): Pointer;
begin
  Result := __malloc(size);
end;

function SysFreeMem(P: Pointer): Integer;
begin
  __free(P);
  Result := 0;
end;

function SysReallocMem(P: Pointer; Size: NativeInt): Pointer;
begin
  Result := realloc(P, Size);
end;

function SysAllocMem(Size: NativeInt): Pointer;
begin
  // Alocate and zero memory for 1 item of Size bytes
  Result := calloc(1, Size);
end;

function SysRegisterExpectedMemoryLeak(P: Pointer): Boolean;
begin
  // not implemented for POSIX
  Result := False;
end;

function SysUnregisterExpectedMemoryLeak(P: Pointer): Boolean;
begin
  // not implemented for POSIX
  Result := False;
end;
{$ENDIF POSIX}

var
  MemoryManager: TMemoryManagerEx = (
    GetMem: SysGetMem;
    FreeMem: SysFreeMem;
    ReallocMem: SysReallocMem;
    AllocMem: SysAllocMem;
    RegisterExpectedmemoryLeak: SysRegisterExpectedMemoryLeak;
    UnregisterExpectedmemoryLeak: SysUnregisterExpectedMemoryLeak);

function AllocMem(Size: NativeInt): Pointer;
{$IFDEF PUREPASCAL}
begin
  if Size > 0 then
  begin
    Result := MemoryManager.AllocMem(Size);
    if Result = nil then
      Error(reOutOfMemory);
  end
  else
    Result := nil;
end;
{$ELSE}
asm
        TEST    EAX,EAX
        JZ      @@allocmemdone
{$IFDEF PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EBX
        PUSH    EAX
        CALL    GetGOT
        MOV     EBX, [EAX].OFFSET MemoryManager.AllocMem
        POP     EAX
        CALL    EBX
        POP     EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
{$ELSE !PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    MemoryManager.AllocMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
{$ENDIF !PIC}
        TEST    EAX,EAX
        JZ      @@allocmemerror
@@allocmemdone:
        REP     RET  // Optimization for branch prediction
@@allocmemerror:
        MOV     AL,reOutOfMemory
        JMP     Error
end;
{$ENDIF}

function RegisterExpectedMemoryLeak(P: Pointer): Boolean;
begin
  Result := (P <> nil) and MemoryManager.RegisterExpectedMemoryLeak(P);
end;

function UnregisterExpectedMemoryLeak(P: Pointer): Boolean;
begin
  Result := (P <> nil) and MemoryManager.UnregisterExpectedMemoryLeak(P);
end;

                                                                                                                                                             
function _GetMem(Size: NativeInt): Pointer;
{$IFDEF PUREPASCAL}
begin
  if Size <= 0 then
    Exit(nil);
  Result := MemoryManager.GetMem(Size);
  if Result = nil then
    Error(reOutOfMemory);
end;
{$ELSE !PUREPASCAL}
asm //StackAlignSafe
        TEST    EAX,EAX
        JLE     @@negativeorzerosize
{$IFDEF PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EBX
        PUSH    EAX
        CALL    GetGOT
        MOV     EBX, [EAX].OFFSET MemoryManager.GetMem
        POP     EAX
        CALL    EBX
        POP     EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
{$ELSE !PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    MemoryManager.GetMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
{$ENDIF !PIC}
        TEST    EAX,EAX
        JZ      @@getmemerror
        REP     RET // Optimization for branch prediction
@@getmemerror:
        MOV     AL, reOutOfMemory
        JMP     Error
@@negativeorzerosize:
        XOR     EAX, EAX
        DB      $F3 // REP RET
end;
{$ENDIF !PUREPASCAL}

function _FreeMem(P: Pointer): Integer;
{$IFDEF PUREPASCAL}
begin
  if P = nil then
    Exit(0);
  Result := MemoryManager.FreeMem(P);
  if Result <> 0 then
    Error(reInvalidPtr);
end;
{$ELSE !PUREPASCAL}
asm //StackAlignSafe
        TEST    EAX,EAX
        JZ      @@freememdone
{$IFDEF PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EBX
        PUSH    EAX
        CALL    GetGOT
        MOV     EBX, [EAX].OFFSET MemoryManager.FreeMem
        POP     EAX
        CALL    EBX
        POP     EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
{$ELSE !PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    MemoryManager.FreeMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
{$ENDIF !PIC}
        TEST    EAX,EAX
        JNZ     @@freememerror
@@freememdone:
        REP     RET // Optimization for branch prediction
@@freememerror:
        MOV     AL,reInvalidPtr
        JMP     ERROR
end;
{$ENDIF !PUREPASCAL}

function _ReallocMem(var P: Pointer; NewSize: NativeInt): Pointer;
{$IFDEF PUREPASCAL}
begin
  if P <> nil then
  begin
    if NewSize > 0 then
    begin
      Result := MemoryManager.ReallocMem(P, NewSize);
      if Result = nil then
        Error(reOutOfMemory);
    end
    else
    begin
      if MemoryManager.FreeMem(P) <> 0 then
        Error(reInvalidPtr);
      Result := nil;
    end;
    P := Result;
  end else
  begin
    if NewSize <= 0 then
      Exit(nil);
    Result := MemoryManager.GetMem(NewSize);
    if Result = nil then
      Error(reOutOfMemory);
    P := Result;
  end;
end;
{$ELSE !PUREPASCAL}

asm
{$IFDEF PIC}
        PUSH    EBX
        PUSH    EAX
        CALL    GetGOT
        MOV     EBX, EAX
        POP     EAX
{$ENDIF PIC}
        MOV     ECX, [EAX]
        TEST    ECX, ECX
        JE      @@alloc
        TEST    EDX, EDX
        JE      @@free
@@resize:
        PUSH    EAX
        MOV     EAX, ECX
{$IFDEF PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        MOV     EBX, [EBX].OFFSET MemoryManager.ReallocMem
        CALL    EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
{$ELSE !PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        CALL    MemoryManager.ReallocMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
{$ENDIF PIC}
        POP     ECX
        OR      EAX, EAX
        JE      @@allocError
        MOV     [ECX], EAX
{$IFDEF PIC}
        POP     EBX
{$ENDIF PIC}
        RET
@@freeError:
        MOV     AL, reInvalidPtr
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        JMP     Error
@@free:
        MOV     [EAX], EDX
        MOV     EAX, ECX
{$IFDEF PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        MOV     EBX, [EBX].OFFSET MemoryManager.FreeMem
        CALL    EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
{$ELSE !PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    MemoryManager.FreeMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
{$ENDIF !PIC}
        OR      EAX, EAX
        JNE     @@freeError
{$IFDEF PIC}
        POP     EBX
{$ENDIF PIC}
        RET
@@allocError:
        MOV     AL, reOutOfMemory
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        JMP     Error
@@alloc:
        TEST    EDX, EDX
        JE      @@exit
        PUSH    EAX
        MOV     EAX, EDX
{$IFDEF PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        MOV     EBX, [EBX].OFFSET MemoryManager.GetMem
        CALL    EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
{$ELSE !PIC}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        CALL    MemoryManager.GetMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
{$ENDIF !PIC}
        POP     ECX
        OR      EAX, EAX
        JE      @@allocError
        MOV     [ECX], EAX
@@exit:
{$IFDEF PIC}
        POP     EBX
{$ENDIF PIC}
end;
{$ENDIF !PUREPASCAL}

{ The default AllocMem implementation - for older memory managers that do not
  implement this themselves. }
function DefaultAllocMem(Size: NativeInt): Pointer;
begin
  Result := _GetMem(Size);
  if (Result <> nil) then
    FillChar(Result^, Size, 0)
end;

{ The default (do nothing) leak registration function for backward compatibility
  with older memory managers. }
function DefaultRegisterAndUnregisterExpectedMemoryLeak(P: Pointer): Boolean;
begin
  Result := False;
end;

{ Backward compatible GetMemoryManager implementation }
procedure GetMemoryManager(var MemMgr: TMemoryManager);
begin
  MemMgr.GetMem := MemoryManager.GetMem;
  MemMgr.FreeMem := MemoryManager.FreeMem;
  MemMgr.ReallocMem := MemoryManager.ReallocMem;
end;

{ Backward compatible SetMemoryManager implementation }
procedure SetMemoryManager(const MemMgr: TMemoryManager);
begin
  MemoryManager.GetMem := MemMgr.GetMem;
  MemoryManager.FreeMem := MemMgr.FreeMem;
  MemoryManager.ReallocMem := MemMgr.ReallocMem;
  MemoryManager.AllocMem := DefaultAllocMem;
  MemoryManager.RegisterExpectedMemoryLeak :=
    DefaultRegisterAndUnregisterExpectedMemoryLeak;
  MemoryManager.UnregisterExpectedMemoryLeak :=
    DefaultRegisterAndUnregisterExpectedMemoryLeak;
end;

procedure GetMemoryManager(var MemMgrEx: TMemoryManagerEx);
begin
  MemMgrEx := MemoryManager;
end;

procedure SetMemoryManager(const MemMgrEx: TMemoryManagerEx);
begin
  MemoryManager := MemMgrEx;
end;

function IsMemoryManagerSet: Boolean;
begin
  with MemoryManager do
    Result := (@GetMem <> @SysGetMem) or (@FreeMem <> @SysFreeMem) or
      (@ReallocMem <> @SysReallocMem) or (@AllocMem <> @SysAllocMem) or
      (@RegisterExpectedMemoryLeak <> @SysRegisterExpectedMemoryLeak) or
      (@UnregisterExpectedMemoryLeak <> @SysUnregisterExpectedMemoryLeak);
end;

procedure RunErrorAt(ErrCode: Integer; ErrorAtAddr: Pointer); forward;

{$IFDEF PC_MAPPED_EXCEPTIONS}
procedure GetUnwinder(var Dest: TUnwinder);
begin
  Dest := Unwinder;
end;

procedure SetUnwinder(const NewUnwinder: TUnwinder);
begin
  Unwinder := NewUnwinder;
end;

function IsUnwinderSet: Boolean;
begin
  with Unwinder do
    Result := (@RaiseException <> @_BorUnwind_RaiseException) or
      (@RegisterIPLookup <> @_BorUnwind_RegisterIPLookup) or
      (@UnregisterIPLookup <> @_BorUnwind_UnregisterIPLookup) or
      (@DelphiLookup <> @_BorUnwind_DelphiLookup);
end;

procedure InitUnwinder;
var
  Addr: Pointer;
begin
  { We look to see if we can find a dynamic version of the unwinder.  This
    will be the case if the application used ShareExcept.pas.  If it is
    present, then we fire it up.  Otherwise, we use our static copy. }
  Addr := dlsym(RTLD_DEFAULT, '_BorUnwind_RegisterIPLookup');
  if Addr <> nil then
  begin
    Unwinder.RegisterIPLookup := Addr;
    Addr := dlsym(RTLD_DEFAULT, '_BorUnwind_UnregisterIPLookup');
    Unwinder.UnregisterIPLookup := Addr;
    Addr := dlsym(RTLD_DEFAULT, '_BorUnwind_RaiseException');
    Unwinder.RaiseException := Addr;
    Addr := dlsym(RTLD_DEFAULT, '_BorUnwind_DelphiLookup');
    Unwinder.DelphiLookup := Addr;
    Addr := dlsym(RTLD_DEFAULT, '_BorUnwind_ClosestDelphiHandler');
    Unwinder.ClosestHandler := Addr;
  end
  else
  begin
    dlerror;   // clear error state;  dlsym doesn't
    Unwinder.RegisterIPLookup := _BorUnwind_RegisterIPLookup;
    Unwinder.DelphiLookup := _BorUnwind_DelphiLookup;
    Unwinder.UnregisterIPLookup := _BorUnwind_UnregisterIPLookup;
    Unwinder.RaiseException := _BorUnwind_RaiseException;
    Unwinder.ClosestHandler := _BorUnwind_ClosestDelphiHandler;
  end;
end;

                                                                                  
function SysClosestDelphiHandler(Context: Pointer): NativeUInt;
begin
  if not Assigned(Unwinder.ClosestHandler) then
    InitUnwinder;
  Result := Unwinder.ClosestHandler(Context);
end;

                                                                             
function SysRegisterIPLookup(StartAddr, EndAddr: NativeUInt; Context: Pointer; GOT: NativeUInt): LongBool;
begin
//  xxx
  if not Assigned(Unwinder.RegisterIPLookup) then
  begin
    InitUnwinder;
  end;
  Result := Unwinder.RegisterIPLookup(@Unwinder.DelphiLookup, StartAddr, EndAddr, Context, GOT);
end;

                                                                                 
function SysRegisterIPLookupFunc(StartAddr, EndAddr: NativeUInt; Context: Pointer; GOT: NativeUInt;
                            UnwinderLookup: TUnwinderLookup): LongBool;
begin
  if not Assigned(Unwinder.RegisterIPLookup) then
  begin
    InitUnwinder;
  end;
  Result := Unwinder.RegisterIPLookup(@UnwinderLookup, StartAddr, EndAddr, Context, GOT);
end;

                                                                               
procedure SysUnregisterIPLookup(StartAddr: NativeUInt);
begin
  Unwinder.UnregisterIPLookup(StartAddr);
end;

function SysRaiseException(Exc: Pointer): LongBool;
var
  uexc: _Unwind_Exception;
begin
  uexc.exception_class := UW_EXC_CLASS_BORLANDDELPHI;
  uexc.private_1 := _Unwind_Word(Exc);
  uexc.private_2 := 0;
  Result := Unwinder.RaiseException(@uexc);
end;

//  SysRaiseCPPException
//    Called to reraise a C++ exception that is unwinding through pascal code.
                                                                               
function SysRaiseCPPException(Exc: Pointer; priv2: Pointer; cls: NativeUInt): LongBool;
var
  uexc: _Unwind_Exception;
begin
  uexc.exception_class := cls;
  uexc.private_1 := _Unwind_Word(Exc);
  uexc.private_2 := _Unwind_Word(priv2);
  Result := Unwinder.RaiseException(@uexc);
end;

const
  MAX_NESTED_EXCEPTIONS = 16;
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
const
  MAX_NESTED_EXCEPTIONS = 16;
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IFDEF PC_MAPPED_EXCEPTIONS}
threadvar
  ExceptionObjects: array[0..MAX_NESTED_EXCEPTIONS-1] of TRaisedException;
  ExceptionObjectCount: Integer;
  OSExceptionsBlocked: Integer;
  ExceptionList: PRaisedException;
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF STACK_BASED_EXCEPTIONS}
threadvar
  RaiseListPtr: Pointer;
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
threadvar
  ExceptionObjects: array[0..MAX_NESTED_EXCEPTIONS-1] of TRaiseFrame;
  ExceptionObjectCount: Integer;
  RaiseListPtr: PRaiseFrame;
{$ENDIF TABLE_BASED_EXCEPTIONS}

threadvar
  InOutRes: Integer;

{$IFDEF PC_MAPPED_EXCEPTIONS}

procedure BlockOSExceptions;
asm  //StackAlignSafe
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        CALL    SysInit.@GetTLS
        MOV     [EAX].OSExceptionsBlocked, 1
        POP     EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
end;

procedure UnblockOSExceptions;
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    SysInit.@GetTLS
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        MOV     [EAX].OSExceptionsBlocked, 0
end;

// Access to a TLS variable.  Note the comment in BeginThread before
// you change the implementation of this function.
function AreOSExceptionsBlocked: Boolean;
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    SysInit.@GetTLS
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        MOV     EAX, [EAX].OSExceptionsBlocked
end;

const
  TRAISEDEXCEPTION_SIZE = SizeOf(TRaisedException);

                                                                   
function CurrentException: PRaisedException;
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    SysInit.@GetTLS
        LEA     EDX, [EAX].ExceptionObjects
        MOV     EAX, [EAX].ExceptionObjectCount
        OR      EAX, EAX
        JE      @@Done
        DEC     EAX
        IMUL    EAX, TRAISEDEXCEPTION_SIZE
        ADD     EAX, EDX
        JMP     @@Exit
@@Done:
        CALL    SysInit.@GetTLS
        MOV     EAX,[EAX].ExceptionList
@@Exit:
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
end;

                                                                          
function CurrentPrivateException: PRaisedException;
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    SysInit.@GetTLS
        LEA     EDX, [EAX].ExceptionObjects
        MOV     EAX, [EAX].ExceptionObjectCount
        OR      EAX, EAX
        JE      @@Done
        DEC     EAX
        IMUL    EAX, TRAISEDEXCEPTION_SIZE
        ADD     EAX, EDX
@@Done:
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
end;

{ In the interests of code size here, this function is slightly overloaded.
  It is responsible for freeing up the current exception record on the
  exception stack, and it conditionally returns the thrown object to the
  caller.  If the object has been acquired through AcquireExceptionObject,
  we don't return the thrown object. }
                                                                
function FreeException: Pointer;
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    CurrentPrivateException
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        OR      EAX, EAX
        JE      @@Error
        { EAX -> the TRaisedException }
        XOR     ECX, ECX
        { If the exception object has been referenced, we don't return it. }
        CMP     [EAX].TRaisedException.RefCount, 0
        JA      @@GotObject
        MOV     ECX, [EAX].TRaisedException.ExceptObject
@@GotObject:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    ECX
        CALL    SysInit.@GetTLS
        POP     ECX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
        DEC     [EAX].ExceptionObjectCount
        MOV     EAX, ECX
        RET
@@Error:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    SysInit.@GetTLS
        MOV     EAX, [EAX].ExceptionList
        CALL    [EAX].TRaisedException.Cleanup
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        RET
end;

procedure ReleaseDelphiException;
begin
  FreeException;
end;

                                                                          
function AllocateException(Exception: Pointer; ExceptionAddr: Pointer): PRaisedException;
asm
        PUSH    EBX // This is to simplify stack aligment for PIC and non PIC.
        PUSH    EAX
        PUSH    EDX
{$IFDEF PIC}
        CALL    GetGOT
        MOV     EBX, EAX
{$ELSE !PIC}
        XOR     EBX, EBX
{$ENDIF !PIC}
        CALL    SysInit.@GetTLS
        CMP     [EAX].ExceptionObjectCount, MAX_NESTED_EXCEPTIONS
        JE      @@TooManyNestedExceptions
        INC     [EAX].ExceptionObjectCount
        CALL    CurrentException
        POP     EDX
        POP     ECX
        MOV     [EAX].TRaisedException.ExceptObject, ECX
        MOV     [EAX].TRaisedException.ExceptionAddr, EDX
        MOV     [EAX].TRaisedException.RefCount, 0
        MOV     [EAX].TRaisedException.HandlerEBP, $FFFFFFFF
        MOV     [EAX].TRaisedException.Flags, 0
        MOV     [EAX].TRaisedException.Prev, 0
        LEA     EDX, [EBX].OFFSET FreeException
        MOV     [EAX].TRaisedException.Cleanup, EDX
        LEA     EDX, [EBX].OFFSET ReleaseDelphiException
        MOV     [EAX].TRaisedException.ReleaseProc, EDX
{$IFDEF AUTOREFCOUNT}
        MOV     EBX,EAX  // GOT no longer needed here
        MOV     EAX,ECX
        MOV     ECX,[EAX]
        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjAddRef
        MOV     EAX,EBX  // Restore EAX - PRaisedException
{$ENDIF}
        POP     EBX
        RET
@@TooManyNestedExceptions:
        ADD     ESP, 12  // Throw away EDX, EBX and EAX.
        MOV     EAX, 231
        JMP     _RunError
end;

{$IFDEF AUTOREFCOUNT}
function AcquireExceptionObject: Pointer;
var
  E: PRaisedException;
begin
  E := CurrentException;
  if E = nil then
    Exit (nil);
  Inc(E.RefCount);
  Result := E.ExceptObject;
  TObject(Result).__ObjAddRef;
end;
{$ELSE  AUTOREFCOUNT}
function AcquireExceptionObject: Pointer;
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    CurrentException
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        OR      EAX, EAX
        JE      @@Error
        INC     [EAX].TRaisedException.RefCount
        MOV     EAX, [EAX].TRaisedException.ExceptObject
        RET
@@Error:
   RET // windows version doesn't generate an error, and Halt0 calls this always
        { This happens if there is no exception pending }
//        JMP     _Run0Error
end;
{$ENDIF AUTOREFCOUNT}

procedure ReleaseExceptionObject;
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    CurrentException
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        OR      EAX, EAX
        JE      @@Error
        CMP     [EAX].TRaisedException.RefCount, 0
        JE      @@Error
        DEC     [EAX].TRaisedException.RefCount
        RET
@@Error:
{ This happens if there is no exception pending, or
  if the reference count on a pending exception is
  zero. }
        JMP   _Run0Error
end;

function ExceptObject: TObject;
var
  Exc: PRaisedException;
begin
  Exc := CurrentException;
  if Exc <> nil then
    Result := TObject(Exc^.ExceptObject)
  else
    Result := nil;
end;

{ Return current exception address }
function ExceptAddr: Pointer;
var
  Exc: PRaisedException;
begin
  Exc := CurrentException;
  if Exc <> nil then
    Result := Exc^.ExceptionAddr
  else
    Result := nil;
end;

{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF STACK_BASED_EXCEPTIONS}

function ExceptObject: TObject;
begin
  if RaiseListPtr <> nil then
    Result := PRaiseFrame(RaiseListPtr)^.ExceptObject
  else
    Result := nil;
end;

{ Return current exception address }
function ExceptAddr: Pointer;
begin
  if RaiseListPtr <> nil then
    Result := PRaiseFrame(RaiseListPtr)^.ExceptAddr
  else
    Result := nil;
end;

function AcquireExceptionObject: Pointer;
type
  ExceptionAcquiredProc = procedure (Obj: {$IFDEF AUTOREFCOUNT}TObject{$ELSE}Pointer{$ENDIF});
var
  RaiseFrame: PRaiseFrame;
begin
  RaiseFrame := RaiseListPtr;
  if RaiseFrame <> nil then
  begin
    Result := Pointer(RaiseFrame^.ExceptObject);
{$IFDEF AUTOREFCOUNT}
    TObject(Result).__ObjAddRef;
{$ENDIF AUTOREFCOUNT}
    RaiseFrame^.ExceptObject := nil;
    if Assigned(ExceptionAcquired) then
      ExceptionAcquiredProc(ExceptionAcquired)(Result);
  end
  else
    Result := nil;
end;

procedure ReleaseExceptionObject;
begin
end;

function RaiseList: Pointer;
begin
  Result := RaiseListPtr;
end;

                                                                                        
function SetRaiseList(NewPtr: Pointer): Pointer;
begin
  Result := RaiseListPtr;
  RaiseListPtr := NewPtr;
end;

procedure _UnhandledException;
type
  TExceptProc = procedure (Obj: TObject; Addr: Pointer);
begin
  if Assigned(ExceptProc) then
    TExceptProc(ExceptProc)(ExceptObject, ExceptAddr)
  else
    RunErrorAt(230, ExceptAddr);
end;
{$ENDIF STACK_BASED_EXCEPTIONS}

{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
function AllocateRaiseFrame: PRaiseFrame;
var
  Index: Integer;
  RaiseFrame: PRaiseFrame;
begin
  RaiseFrame := nil;
  for Index := 0 to MAX_NESTED_EXCEPTIONS-1 do
  begin
    if not ExceptionObjects[Index].Allocated then
    begin
      RaiseFrame := @ExceptionObjects[Index];
      break;
    end;
  end;
  if RaiseFrame = nil then
    RunErrorAt(231, ReturnAddress);

  RaiseFrame.Allocated := True;
  Inc(ExceptionObjectCount);
  RaiseFrame^.NextRaise := nil;
  RaiseFrame^.ExceptObject := nil;
  RaiseFrame^.ExceptAddr := nil;
{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
  RaiseFrame^.PrevRaise := nil;
{$ENDIF}
  Result := RaiseFrame;
end;

procedure ReleaseRaiseFrame(RaiseFrame: PRaiseFrame);
begin
  if (UIntPtr(RaiseFrame) >= UIntPtr(@ExceptionObjects)) and
     (UIntPtr(RaiseFrame) <= UIntPtr(@ExceptionObjects[MAX_NESTED_EXCEPTIONS-1])) then
  begin
    RaiseFrame.Allocated := False;
    ExceptionObjectCount := ExceptionObjectCount - 1;
  end;
end;

procedure LinkRaiseFrame(RaiseFrame: PRaiseFrame); inline;
var
  List: PPRaiseFrame;
begin
  // Note: Taking an address of RaiseListPtr may not be allowed if
  //       per-thread memory space is allocated in another space.
  //       It depends on threadvar implementation. However,
  //       current implementation can take an address of RaiseListPtr.
  List := @RaiseListPtr;
  RaiseFrame^.NextRaise := List^;
  List^ := RaiseFrame;
end;

function PopRaiseFrame: PRaiseFrame; inline;
var
  List: PPRaiseFrame;
begin
  List := @RaiseListPtr;
  Result := List^;
  if Result = nil then
    _RunError(216); // reAccessViolation
  List^ := Result^.NextRaise;
end;

{ Return current exception object }
function ExceptObject: TObject;
var
  RaiseFrame: PRaiseFrame;
begin
  RaiseFrame := RaiseListPtr;
  if RaiseFrame <> nil then
    Result := RaiseFrame^.ExceptObject
  else
    Result := nil;
end;

{ Return current exception address }
function ExceptAddr: Pointer;
var
  RaiseFrame: PRaiseFrame;
begin
  RaiseFrame := RaiseListPtr;
  if RaiseFrame <> nil then
    Result := Pointer(RaiseFrame^.ExceptAddr)
  else
    Result := nil;
end;

function AcquireExceptionObject: Pointer;
type
  ExceptionAcquiredProc = procedure (Obj: Pointer);
var
  RaiseFrame: PRaiseFrame;
begin
  RaiseFrame := RaiseListPtr;
  if RaiseFrame <> nil then
  begin
    Result := RaiseFrame^.ExceptObject;
{$IFDEF AUTOREFCOUNT}
    if Result <> nil then
      TObject(Result).__ObjAddRef;
{$ENDIF AUTOREFCOUNT}
    RaiseFrame^.ExceptObject := nil;
    if Assigned(ExceptionAcquired) then
      ExceptionAcquiredProc(ExceptionAcquired)(Result);
  end
  else
    Result := nil;
end;

procedure ReleaseExceptionObject;
begin
end;
{$ENDIF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}

{$IFDEF MSWINDOWS}
{
  Coverage helper glue - just go directly to the external coverage
  library.  NEVER put code in here, because we sometimes want to run
  coverage analysis on the System unit.
}
                                                                                          
procedure _CVR_PROBE; external 'coverage.dll' name '__CVR_PROBE';
function _CVR_STMTPROBE; external 'coverage.dll' name '__CVR_STMTPROBE';
{$ENDIF MSWINDOWS}
{ ----------------------------------------------------- }
{    local functions & procedures of the system unit    }
{ ----------------------------------------------------- }

procedure RunErrorAt(ErrCode: Integer; ErrorAtAddr: Pointer);
begin
  ErrorAddr := ErrorAtAddr;
  _Halt(ErrCode);
end;

procedure ErrorAt(ErrorCode: Byte; ErrorAddr: Pointer);

const
  reMap: array [TRunTimeError] of Byte = (
    0,   { reNone }
    203, { reOutOfMemory }
    204, { reInvalidPtr }
    200, { reDivByZero }
    201, { reRangeError }
{   210    Abstract error }
    215, { reIntOverflow }
    207, { reInvalidOp }
    200, { reZeroDivide }
    205, { reOverflow }
    206, { reUnderflow }
    219, { reInvalidCast }
    216, { reAccessViolation }
    218, { rePrivInstruction }
    217, { reControlBreak }
    202, { reStackOverflow }
    220, { reVarTypeCast }
    221, { reVarInvalidOp }
    222, { reVarDispatch }
    223, { reVarArrayCreate }
    224, { reVarNotArray }
    225, { reVarArrayBounds }
{   226    Thread init failure }
    227, { reAssertionFailed }
    0,   { reExternalException not used here; in SysUtils }
    228, { reIntfCastError }
    229, { reSafeCallError }
    235, { reMonitorNotLocked }
    236, { reNoMonitorSupport }
{$IFDEF PC_MAPPED_EXCEPTIONS}
{   230   Reserved by the compiler for unhandled exceptions }
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IF defined(PC_MAPPED_EXCEPTIONS) or defined(STACK_BASED_EXCEPTIONS)}
{   231   Too many nested exceptions }
{$ENDIF}
{$IF Defined(LINUX) or Defined(MACOS) or Defined(ANDROID)}
{   232   Fatal signal raised on a non-Delphi thread }
    233, { reQuit }
{$ENDIF LINUX or MACOS or ANDROID}
{$IFDEF POSIX}
    234,  { reCodesetConversion }
{$ENDIF POSIX}
    237, { rePlatformNotImplemented }
    238  { reObjectDisposed }
);

begin
  errorCode := errorCode and 127;
  if Assigned(ErrorProc) then
    ErrorProc(errorCode, ErrorAddr);
  if errorCode = 0 then
    errorCode := InOutRes
  else if errorCode <= Byte(High(TRuntimeError)) then
    errorCode := reMap[TRunTimeError(errorCode)];
  RunErrorAt(errorCode, ErrorAddr);
end;

                                                                                  
procedure Error(errorCode: TRuntimeError);
begin
  ErrorAt(Byte(errorCode), ReturnAddress);
end;

procedure SetLineBreakStyle(var T: Text; Style: TTextLineBreakStyle);
begin
  if TTextRec(T).Mode = fmClosed then
    TTextRec(T).Flags := (TTextRec(T).Flags and not tfCRLF) or (tfCRLF * Byte(Style))
  else
    SetInOutRes(107);  // can't change mode of open file
end;

function GetTextCodePage(const T: Text): Word;
begin
  Result := TTextRec(T).CodePage;
end;

procedure SetTextCodePage(var T: Text; CodePage: Word);
begin
  TTextRec(T).CodePage := CodePage;
end;

procedure __IOTest;
{$IFDEF PUREPASCAL}
begin
  if InOutRes <> 0 then
    ErrorAt(byte(reNone), ReturnAddress);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
// __IOTest must preserve EAX, EDX, ECX on exit with the current dcc32 codegen
asm
        PUSH    EAX
        PUSH    EDX
        PUSH    ECX
        CALL    SysInit.@GetTLS
        CMP     [EAX].InOutRes,0
        POP     ECX
        POP     EDX
        POP     EAX
        JNE     @error
        RET
@error:
        XOR     EAX,EAX
        JMP     Error
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure SetInOutRes(NewValue: Integer);
begin
  InOutRes := NewValue;
end;

procedure InOutError;
begin
  SetInOutRes(GetLastError);
end;

procedure ChDir(const S: string);
begin
  // U-OK
  ChDir(PChar(S));
end;

procedure ChDir(P: PChar);
{$IFDEF MSWINDOWS}
begin
  // U-OK
  if not SetCurrentDirectory(P) then
    InOutError;
end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
var
   us: _UTF8Str;
begin
  // U-OK
  us := _UTF8Str(P);
  if __chdir(_PAnsiChr(us)) <> 0 then
    InOutError;
end;
{$ENDIF POSIX}

procedure _UGetDir(D: Byte; var S: UnicodeString);
{$IFDEF MSWINDOWS}
var
  Drive: array[0..3] of WideChar;
  DirBuf, SaveBuf: array[0..MAX_PATH] of WideChar;
begin
  if D <> 0 then
  begin
    Drive[0] := WideChar(D + Ord('A') - 1);
    Drive[1] := ':';
    Drive[2] := #0;
    GetCurrentDirectoryW(SizeOf(SaveBuf) div SizeOf(WideChar), SaveBuf);
    SetCurrentDirectoryW(Drive);
  end;
  GetCurrentDirectoryW(SizeOf(DirBuf) div SizeOf(WideChar), DirBuf);
  if D <> 0 then SetCurrentDirectoryW(SaveBuf);
  S := DirBuf;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
var
  DirBuf: array[0..MAX_PATH] of _AnsiChr;
begin
  fchdir(__chdir('.'));
  getcwd(DirBuf, sizeof(DirBuf));
  S := UTF8ToString(DirBuf);
{$ENDIF POSIX}
end;

procedure _LGetDir(D: Byte; var S: _AnsiStr);
{$IFDEF MSWINDOWS}
var
  Drive: array[0..3] of _AnsiChr;
  DirBuf, SaveBuf: array[0..MAX_PATH] of _AnsiChr;
begin
  if D <> 0 then
  begin
    Drive[0] := _AnsiChr(Chr(D + Ord('A') - 1));
    Drive[1] := ':';
    Drive[2] := #0;
    GetCurrentDirectoryA(SizeOf(SaveBuf), SaveBuf);
    SetCurrentDirectoryA(Drive);
  end;
  GetCurrentDirectoryA(SizeOf(DirBuf), DirBuf);
  if D <> 0 then SetCurrentDirectoryA(SaveBuf);
  S := DirBuf;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
var
  DirBuf: array[0..MAX_PATH] of _AnsiChr;
begin
  getcwd(DirBuf, sizeof(DirBuf));
  S := _AnsiStr(UTF8ToString(DirBuf));
{$ENDIF POSIX}
end;

procedure _WGetDir(D: Byte; var S: _WideStr);
{$IFDEF MSWINDOWS}
var
  Drive: array[0..3] of WideChar;
  DirBuf, SaveBuf: array[0..MAX_PATH] of WideChar;
begin
  if D <> 0 then
  begin
    Drive[0] := WideChar(Chr(D + Ord('A') - 1));
    Drive[1] := ':';
    Drive[2] := #0;
    GetCurrentDirectoryW(Length(SaveBuf), SaveBuf);
    SetCurrentDirectoryW(Drive);
  end;
  GetCurrentDirectoryW(Length(DirBuf), DirBuf);
  if D <> 0 then SetCurrentDirectoryW(SaveBuf);
  S := DirBuf;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
var
   U: UnicodeString;
begin
   _UGetDir(D, U);
   S := U;
{$ENDIF POSIX}
end;

procedure _SGetDir(D: Byte; var S: _ShortStr);
var
  L: _AnsiStr;
begin
  _LGetDir(D, L);
  S := L;
end;

function IOResult: Integer;
begin
  Result := InOutRes;
  InOutRes := 0;
end;

procedure MkDir(const S: string);
begin
  MkDir(PChar(s));
end;

procedure MkDir(P: PChar);
begin
{$IFDEF MSWINDOWS}
  if not CreateDirectory(P, nil) then
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
  if __mkdir(_PAnsiChr(UTF8Encode(P)), mode_t(S_IRWXU or S_IRWXG or S_IRWXO)) <> 0 then
{$ENDIF POSIX}
    InOutError;
end;

                                                                              
(* ***** BEGIN LICENSE BLOCK *****
 *
 * The assembly function Move is licensed under the CodeGear license terms.
 *
 * The initial developer of the original code is Fastcode
 *
 * Portions created by the initial developer are Copyright (C) 2002-2004
 * the initial developer. All Rights Reserved.
 *
 * Contributor(s): John O'Harrow
 *
 * ***** END LICENSE BLOCK ***** *)
procedure Move(const Source; var Dest; Count: NativeInt);
{$IF defined(POSIX)}
begin
  if Count > 0 then
    memmove(Dest, Source, Count);
end;
{$ELSEIF defined(PUREPASCAL)}
{$POINTERMATH ON}
var
  S, D, I: PByte;
  Temp: NativeInt;
  C: NativeUInt;
  L: PNativeInt;
begin
  S := PByte(@Source);
  D := PByte(@Dest);
  if S = D then
    Exit;
  if Count <= SizeOf(NativeInt) then
    case Count of
      1: D[0] := S[0];
      2: PWord(D)[0] := PWord(S)[0];
      3: if D > S then
         begin
           D[2] := S[2];
           PWord(D)[0] := PWord(S)[0];
         end
         else
         begin
           PWord(D)[0] := PWord(S)[0];
           D[2] := S[2];
         end;
      4: PInteger(D)[0] := PInteger(S)[0];
      5: if D > S then
         begin
           D[4] := S[4];
           PInteger(D)[0] := PInteger(S)[0];
         end
         else
         begin
           PInteger(D)[0] := PInteger(S)[0];
           D[4] := S[4];
         end;
      6: if D > S then
         begin
           PWord(D)[2] := PWord(S)[2];
           PInteger(D)[0] := PInteger(S)[0];
         end
         else
         begin
           PInteger(D)[0] := PInteger(S)[0];
           PWord(D)[2] := PWord(S)[2];
         end;
      7: if D > S then
         begin
           D[6] := S[6];
           PWord(D)[2] := PWord(S)[2];
           PInteger(D)[0] := PInteger(S)[0];
         end
         else
         begin
           PInteger(D)[0] := PInteger(S)[0];
           PWord(D)[2] := PWord(S)[2];
           D[6] := S[6];
         end;
      8: PInt64(D)[0] := PInt64(S)[0];
    else
      Exit; {Count <= 0}
    end
  else
    if D > S then
    begin
      Temp := PNativeInt(S)^;
      I := D;
      C := Count - SizeOf(NativeInt);
      L := PNativeInt(D + C);
      Inc(S, C);
      repeat
        L^ := PNativeInt(S)^;
        if Count <= 2 * Sizeof(NativeInt) then
          Break;
        Dec(Count, Sizeof(NativeInt));
        Dec(S, Sizeof(NativeInt));
        Dec(L);
      until False;
      PNativeInt(I)^ := Temp;
    end
    else
    begin
      C := Count - Sizeof(NativeInt);
      Temp := PNativeInt(S + C)^;
      I := D + C;
      L := PNativeInt(D);
      repeat
        L^ := PNativeInt(S)^;
        if Count <= 2 * Sizeof(NativeInt) then
          Break;
        Dec(Count, Sizeof(NativeInt));
        Inc(S, Sizeof(NativeInt));
        Inc(L);
      until False;
      PNativeInt(I)^ := Temp;
    end;
end;
{$POINTERMATH OFF}
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        CMP     EAX, EDX
        JE      @@Exit {Source = Dest}
        CMP     ECX, 32
        JA      @@LargeMove {Count > 32 or Count < 0}
        SUB     ECX, 8
        JG      @@SmallMove
@@TinyMove: {0..8 Byte Move}
{$IFDEF PIC}
        PUSH    EBX
        PUSH    EAX
        PUSH    ECX
        CALL    GetGOT
        POP     ECX
        MOV     EBX, EAX
        ADD     EBX, offset @@JumpTable+32
        MOV     ECX, [EBX+ECX*4]
        ADD     ECX, EAX
        POP     EAX
        POP     EBX
        JMP     ECX
{$ELSE}
        JMP     DWORD PTR [@@JumpTable+32+ECX*4]
{$ENDIF}
@@SmallMove: {9..32 Byte Move}
        FILD    QWORD PTR [EAX+ECX] {Load Last 8}
        FILD    QWORD PTR [EAX] {Load First 8}
        CMP     ECX, 8
        JLE     @@Small16
        FILD    QWORD PTR [EAX+8] {Load Second 8}
        CMP     ECX, 16
        JLE     @@Small24
        FILD    QWORD PTR [EAX+16] {Load Third 8}
        FISTP   QWORD PTR [EDX+16] {Save Third 8}
@@Small24:
        FISTP   QWORD PTR [EDX+8] {Save Second 8}
@@Small16:
        FISTP   QWORD PTR [EDX] {Save First 8}
        FISTP   QWORD PTR [EDX+ECX] {Save Last 8}
@@Exit:
        RET
        NOP {4-Byte Align JumpTable}
        NOP
@@JumpTable: {4-Byte Aligned}
        DD      @@Exit, @@M01, @@M02, @@M03, @@M04, @@M05, @@M06, @@M07, @@M08
@@LargeForwardMove: {4-Byte Aligned}
        PUSH    EDX
        FILD    QWORD PTR [EAX] {First 8}
        LEA     EAX, [EAX+ECX-8]
        LEA     ECX, [ECX+EDX-8]
        FILD    QWORD PTR [EAX] {Last 8}
        PUSH    ECX
        NEG     ECX
        AND     EDX, -8 {8-Byte Align Writes}
        LEA     ECX, [ECX+EDX+8]
        POP     EDX
@FwdLoop:
        FILD    QWORD PTR [EAX+ECX]
        FISTP   QWORD PTR [EDX+ECX]
        ADD     ECX, 8
        JL      @FwdLoop
        FISTP   QWORD PTR [EDX] {Last 8}
        POP     EDX
        FISTP   QWORD PTR [EDX] {First 8}
        RET
@@LargeMove:
        JNG     @@LargeDone {Count < 0}
        CMP     EAX, EDX
        JA      @@LargeForwardMove
        SUB     EDX, ECX
        CMP     EAX, EDX
        LEA     EDX, [EDX+ECX]
        JNA     @@LargeForwardMove
        SUB     ECX, 8 {Backward Move}
        PUSH    ECX
        FILD    QWORD PTR [EAX+ECX] {Last 8}
        FILD    QWORD PTR [EAX] {First 8}
        ADD     ECX, EDX
        AND     ECX, -8 {8-Byte Align Writes}
        SUB     ECX, EDX
@BwdLoop:
        FILD    QWORD PTR [EAX+ECX]
        FISTP   QWORD PTR [EDX+ECX]
        SUB     ECX, 8
        JG      @BwdLoop
        POP     ECX
        FISTP   QWORD PTR [EDX] {First 8}
        FISTP   QWORD PTR [EDX+ECX] {Last 8}
@@LargeDone:
        RET
@@M01:
        MOVZX   ECX, [EAX]
        MOV     [EDX], CL
        RET
@@M02:
        MOVZX   ECX, WORD PTR [EAX]
        MOV     [EDX], CX
        RET
@@M03:
        MOV     CX, [EAX]
        MOV     AL, [EAX+2]
        MOV     [EDX], CX
        MOV     [EDX+2], AL
        RET
@@M04:
        MOV     ECX, [EAX]
        MOV     [EDX], ECX
        RET
@@M05:
        MOV     ECX, [EAX]
        MOV     AL, [EAX+4]
        MOV     [EDX], ECX
        MOV     [EDX+4], AL
        RET
@@M06:
        MOV     ECX, [EAX]
        MOV     AX, [EAX+4]
        MOV     [EDX], ECX
        MOV     [EDX+4], AX
        RET
@@M07:
        MOV     ECX, [EAX]
        MOV     EAX, [EAX+3]
        MOV     [EDX], ECX
        MOV     [EDX+3], EAX
        RET
@@M08:
        FILD    QWORD PTR [EAX]
        FISTP   QWORD PTR [EDX]
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure MoveChars(const Source; var Dest; Length: Integer);
begin
  Move(Source, Dest, Length * SizeOf(Char));
end;

{$IFDEF MSWINDOWS}
function GetParamStr(P: PChar; var Param: string): PChar;
var
  i, Len: Integer;
  Start, S: PChar;
begin
  // U-OK
  while True do
  begin
    while (P[0] <> #0) and (P[0] <= ' ') do
      Inc(P);
    if (P[0] = '"') and (P[1] = '"') then Inc(P, 2) else Break;
  end;
  Len := 0;
  Start := P;
  while P[0] > ' ' do
  begin
    if P[0] = '"' then
    begin
      Inc(P);
      while (P[0] <> #0) and (P[0] <> '"') do
      begin
        Inc(Len);
        Inc(P);
      end;
      if P[0] <> #0 then
        Inc(P);
    end
    else
    begin
      Inc(Len);
      Inc(P);
    end;
  end;

  SetLength(Param, Len);

  P := Start;
  S := Pointer(Param);
  i := 0;
  while P[0] > ' ' do
  begin
    if P[0] = '"' then
    begin
      Inc(P);
      while (P[0] <> #0) and (P[0] <> '"') do
      begin
        S[i] := P^;
        Inc(P);
        Inc(i);
      end;
      if P[0] <> #0 then Inc(P);
    end
    else
    begin
      S[i] := P^;
      Inc(P);
      Inc(i);
    end;
  end;

  Result := P;
end;
{$ENDIF}

function ParamCount: Integer;
{$IFDEF MSWINDOWS}
var
  P: PChar;
  S: string;
begin
  // U-OK
  Result := 0;
  P := GetParamStr(GetCommandLine, S);
  while True do
  begin
    P := GetParamStr(P, S);
    if S = '' then Break;
    Inc(Result);
  end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  if ArgCount > 1 then
    Result := ArgCount - 1
  else Result := 0;
{$ENDIF LINUX or MACOS or ANDROID}
end;

type
  PAnsiCharArray = array[0..0] of _PAnsiChr;

function ParamStr(Index: Integer): string;
{$IFDEF MSWINDOWS}
var
  P: PChar;
  Buffer: array[0..260] of Char;
begin
  Result := '';
  if Index = 0 then
    SetString(Result, Buffer, GetModuleFileName(0, Buffer, Length(Buffer)))
  else
  begin
    P := GetCommandLine;
    while True do
    begin
      P := GetParamStr(P, Result);
      if (Index = 0) or (Result = '') then Break;
      Dec(Index);
    end;
  end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  if Index < ArgCount then
    Result := UTF8ToString(PAnsiCharArray(ArgValues^)[Index])
  else
    Result := '';
{$ENDIF POSIX}
end;

procedure Randomize;
{$IFDEF MSWINDOWS}
var
  Counter: Int64;
begin
  if QueryPerformanceCounter(Counter) then
    RandSeed := Counter
  else
    RandSeed := GetTickCount;
end;
{$ENDIF MSWINDOWS}
{$IF defined(LINUX) or defined(ANDROID)}
var
  TimeOfDay: timeval;
begin
  if gettimeofday(TimeOfDay, nil) = 0 then
    RandSeed := TimeOfDay.tv_sec * 1000000 + TimeOfDay.tv_usec
  else
    RandSeed := time(nil);
end;
{$ENDIF LINUX or ANDROID}
{$IFDEF MACOS}
begin
  RandSeed := AbsoluteToNanoseconds(MachAbsoluteTime);
end;
{$ENDIF MACOS}

// Random integer, implemented as a deterministic linear congruential generator
// with 134775813 as a and 1 as c.
function Random(const ARange: Integer): Integer;
{$IFDEF PUREPASCAL}
var
  Temp: Integer;
begin
  Temp := RandSeed * $08088405 + 1;
  RandSeed := Temp;
  Result := (UInt64(Cardinal(ARange)) * UInt64(Cardinal(Temp))) shr 32;
end;
{$ELSE !PUREPASCAL}
asm
{     ->EAX     Range   }
{     <-EAX     Result  }
        PUSH    EBX
{$IFDEF PIC}
        PUSH    EAX
        CALL    GetGOT
        MOV     EBX,EAX
        POP     EAX
        MOV     ECX,[EBX].RandSeed
        IMUL    EDX,[ECX],08088405H
        INC     EDX
        MOV     [ECX],EDX
{$ELSE !PIC}
        XOR     EBX, EBX
        IMUL    EDX,[EBX].RandSeed,08088405H
        INC     EDX
        MOV     [EBX].RandSeed,EDX
{$ENDIF !PIC}

        MUL     EDX
        MOV     EAX,EDX
        POP     EBX
end;
{$ENDIF !PUREPASCAL}

function Random: Extended;
const
  two2neg32: double = ((1.0/$10000) / $10000);  // 2^-32
{$IFDEF PUREPASCAL}
var
  Temp: Integer;
  F: Extended;
begin
  Temp := RandSeed * $08088405 + 1;
  RandSeed := Temp;
  F  := Int64(Cardinal(Temp));
  Result := F * two2neg32;
end;
{$ELSE !PUREPASCAL}
asm
{       FUNCTION _RandExt: Extended;    }

        PUSH    EBX
{$IFDEF PIC}
        CALL    GetGOT
        MOV     EBX,EAX
        MOV     ECX,[EBX].OFFSET RandSeed
        IMUL    EDX,[ECX],08088405H
        INC     EDX
        MOV     [ECX],EDX
{$ELSE !PIC}
        XOR     EBX, EBX
        IMUL    EDX,[EBX].RandSeed,08088405H
        INC     EDX
        MOV     [EBX].RandSeed,EDX
{$ENDIF !PIC}

        FLD     [EBX].two2neg32
        PUSH    0
        PUSH    EDX
        FILD    qword ptr [ESP]
        ADD     ESP,8
        FMULP   ST(1), ST(0)
        POP     EBX
end;
{$ENDIF !PUREPASCAL}

procedure RmDir(const S: string);
begin
  // U-OK
  RmDir(PChar(s));
end;

procedure RmDir(P: PChar);
{$IFDEF POSIX}
var
   us: _UTF8Str;
{$ENDIF POSIX}
begin
  // U-OK
{$IFDEF MSWINDOWS}
  if not RemoveDirectory(P) then
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
  us := _UTF8Str(P);
  if __rmdir(_PAnsiChr(us)) <> 0 then
{$ENDIF POSIX}
    InOutError;
end;

function UpCase(ch: _AnsiChr): _AnsiChr;
begin
  Result := Ch;
  if Result in ['a'..'z'] then
    Dec(Result, Ord('a')-Ord('A'));
end;

function UpCase(Ch: WideChar): WideChar;
begin
  Result := Ch;
  case Ch of
    'a'..'z':
      Result := WideChar(Word(Ch) and $FFDF);
  end;
end;

const
  cInfinity   =  1.0 / 0.0;
  cNInfinity  = -1.0 / 0.0;
  cNaN        =  0.0 / 0.0;

function ExceptionFlagToMask(exceptionFlag: UInt32) : UInt32; inline;
begin
{$IF     defined(CPUX86)}
  Result := exceptionFlag and femALLEXCEPT;
{$ELSEIF defined(CPUX64)}
  Result := (exceptionFlag shl 7) and femALLEXCEPT;
{$ELSEIF defined(CPUARM)}
  Result := (exceptionFlag shl 8) and femALLEXCEPT;
{$ELSE  !defined(CPUX86) or !defined(CPUX64) or !defined(CPUARM)}
  Result := 0;
  if exceptionFlag and feeINEXACT <> 0   then Result := Result or femINEXACT;
  if exceptionFlag and feeUNDERFLOW <> 0 then Result := Result or femUNDERFLOW;
  if exceptionFlag and feeOVERFLOW <> 0  then Result := Result or femOVERFLOW;
  if exceptionFlag and feeDIVBYZERO <> 0 then Result := Result or femDIVBYZERO;
  if exceptionFlag and feeINVALID <> 0   then Result := Result or femINVALID;
{$ENDIF}
end;

function ExceptionMaskToFlag( exceptionMask: UInt32) : UInt32; inline;
begin
{$IF     defined(CPUX86)}
  Result := exceptionMask and feeALLEXCEPT;
{$ELSEIF defined(CPUX64)}
  Result := (exceptionMask shr 7) and feeALLEXCEPT;
{$ELSEIF defined(CPUARM)}
  Result := (exceptionMask shr 8) and feeALLEXCEPT;
{$ELSE  !defined(CPUX86) or !defined(CPUX64) or !defined(CPUARM)}
  Result := 0;
  if exceptionMask and femINEXACT <> 0   then Result := Result or feeINEXACT;
  if exceptionMask and femUNDERFLOW <> 0 then Result := Result or feeUNDERFLOW;
  if exceptionMask and femOVERFLOW <> 0  then Result := Result or feeOVERFLOW;
  if exceptionMask and femDIVBYZERO <> 0 then Result := Result or feeDIVBYZERO;
  if exceptionMask and femINVALID <> 0   then Result := Result or feeINVALID;
{$ENDIF}
end;

{$IFDEF NEXTGEN}
{$IF defined(IOS) or defined(ANDROID) or defined(LINUX) or (defined(OSX) and defined(EXTERNALLINKER))}
type
  fexcept_t = Word;
  TExceptionFlags = fexcept_t;
  PExceptionFlags = ^TExceptionFlags;

{$IF defined(IOS) or (defined(OSX) and defined(EXTERNALLINKER))}
const
  libmmodulename = '/usr/lib/libSystem.dylib'; // iOS device
  librtlhelpername = 'librtlhelper.a';

{$IF not (defined(CPUX86) and defined(ASSEMBLER))}
//These functions do not exist in iOSSimulator math library. We use two local functions.
function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UInt32): UInt32; cdecl;
  external libmmodulename name _PU + 'fegetexceptflag';
{$EXTERNALSYM fegetexceptflag}
function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UInt32): UInt32; cdecl;
  external libmmodulename name _PU + 'fesetexceptflag';
{$EXTERNALSYM fesetexceptflag}
{$ENDIF not (CPUX86 and ASSEMBLER)}

function fegetround(): UInt32; cdecl;
  external libmmodulename name _PU + 'fegetround';
{$EXTERNALSYM fegetround}
function fesetround(__rounding_direction: UInt32): UInt32; cdecl;
  external libmmodulename name _PU + 'fesetround';
{$EXTERNALSYM fesetround}
function fegetenv(__envp: pointer): UInt32; cdecl;
  external libmmodulename name _PU + 'fegetenv';
{$EXTERNALSYM fegetenv}
function fesetenv(__envp: pointer): UInt32; cdecl;
  external libmmodulename name _PU + 'fesetenv';
{$EXTERNALSYM fesetenv}
{$ENDIF IOS or (OSX and EXTERNALLINKER)}

{$IFDEF ANDROID}
const
  libmmodulename = '/system/lib/libm.so'; // Android
  librtlhelpername = 'librtlhelper.a';

function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UInt32): UInt32; cdecl;
  external librtlhelpername name 'math_fegetexceptflag';
{$EXTERNALSYM fegetexceptflag}
function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UInt32): UInt32; cdecl;
  external librtlhelpername name 'math_fesetexceptflag';
{$EXTERNALSYM fesetexceptflag}
function fegetround(): UInt32; cdecl;
  external librtlhelpername name 'math_fegetround';
{$EXTERNALSYM fegetround}
function fesetround(__rounding_direction: UInt32): UInt32; cdecl;
  external librtlhelpername name 'math_fesetround';
{$EXTERNALSYM fesetround}
function fegetenv(__envp: pointer): UInt32; cdecl;
  external librtlhelpername name 'math_fegetenv';
{$EXTERNALSYM fegetenv}
function fesetenv(__envp: pointer): UInt32; cdecl;
  external librtlhelpername name 'math_fesetenv';
{$EXTERNALSYM fesetenv}
{$ENDIF ANDROID}

{$IF Defined(LINUX)}
const
  libmmodulename = 'libm.so'; // Linux 64. Ubuntu
  librtlhelpername = 'librtlhelper.a';

function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UInt32): UInt32; cdecl;
  external libmmodulename name 'fegetexceptflag';
{$EXTERNALSYM fegetexceptflag}
function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UInt32): UInt32; cdecl;
  external libmmodulename name 'fesetexceptflag';
{$EXTERNALSYM fesetexceptflag}
function fegetround(): UInt32; cdecl;
  external libmmodulename name 'fegetround';
{$EXTERNALSYM fegetround}
function fesetround(__rounding_direction: UInt32): UInt32; cdecl;
  external libmmodulename name 'fesetround';
{$EXTERNALSYM fesetround}
function fegetenv(__envp: pointer): UInt32; cdecl;
  external libmmodulename name 'fegetenv';
{$EXTERNALSYM fegetenv}
function fesetenv(__envp: pointer): UInt32; cdecl;
  external libmmodulename name 'fesetenv';
{$EXTERNALSYM fesetenv}
{$ENDIF LINUX}

procedure FCheckExcept;
begin
  FRaiseExcept(FGetExceptFlag);
end;

procedure FRaiseExcept(excepts: UInt32; CheckExceptionMask: Boolean = True);
var
  flags, masks: UInt32;
begin
  if excepts = 0 then Exit;

  if CheckExceptionMask then
  begin
    masks := FGetExceptMask(ExceptionFlagToMask(excepts));
    if masks <> 0 then
    begin
      flags := ExceptionMaskToFlag(masks);
      excepts := excepts and not flags;
      FSetExceptFlag(0, flags);
    end;
  end;

  if excepts <> 0 then
  begin
    if excepts and feeINEXACT <> 0 then
    begin
      FSetExceptFlag(0, feeINEXACT);
      Error(reInvalidOp);
    end;
    if excepts and feeUNDERFLOW <> 0 then
    begin
      FSetExceptFlag(0, feeUNDERFLOW);
      Error(reUnderflow);
    end;
    if excepts and feeOVERFLOW <> 0 then
    begin
      FSetExceptFlag(0, feeOVERFLOW);
      Error(reOverflow);
    end;
    if excepts and feeDIVBYZERO <> 0 then
    begin
      FSetExceptFlag(0, feeDIVBYZERO);
      Error(reZeroDivide);
    end;
    if excepts and feeINVALID <> 0 then
    begin
      FSetExceptFlag(0, feeINVALID);
      Error(reInvalidOp);
    end;
  end;
end;

{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)}
// iOS/Sim
// These are the replacements for: fegetexceptflag and fesetexceptflag
function InternalGetFPUStatusWord: UInt16;
var
  SW: UInt16;
begin
  asm
    FSTSW SW
  end;
  Result := SW;
end;

procedure InternalSetFPUStatusWord(NewFlags: TExceptionFlags);
var
  FEnv: array[0..27] of byte;
begin
  asm
    FNSTENV FEnv
  end;
  FEnv[4] := (FEnv[4] and $C0) or (NewFlags and $3F);
  asm
    FLDENV FEnv
  end;
end;
{$ENDIF !(IOS and CPUX86 and ASSEMBLER)}

procedure FClearExcept;
var
  Flags: UInt32;
begin
  Flags := not ExceptionMaskToFlag(FGetExceptMask) and feeALLEXCEPT;
  if Flags <> 0 then
    FSetExceptFlag(0, Flags);
end;

function FSetExceptFlag(NewFlags: UInt32; Excepts: UInt32): UInt32;
var
  flags: TExceptionFlags;
begin
  Excepts := Excepts and feeALLEXCEPT;
  flags := FGetExceptFlag(feeALLEXCEPT);
  Result := flags and Excepts;
  flags := (flags and (not Excepts)) or (NewFlags and Excepts);
{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)}
// iOS simulator.
  InternalSetFPUStatusWord(flags);
  SetMXCSRExceptionFlag(flags);
{$ELSE }
  feSetExceptFlag(@flags, Excepts);
{$ENDIF !(IOS and CPUX86 and ASSEMBLER)}
end;

function FGetExceptFlag(Excepts: UInt32): UInt32;
{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)}
// iOS simulator.
begin
  Excepts := Excepts and feeALLEXCEPT;
  Result := (InternalGetFPUStatusWord or GetMXCSR) and Excepts;
end;
{$ELSE}
var
  flags: TExceptionFlags;
begin
  feGetExceptFlag(@flags, Excepts and feeALLEXCEPT);
  Result := flags and feeALLEXCEPT;
end;
{$ENDIF !(IOS and CPUX86 and ASSEMBLER)}

function FGetRound: UInt32;
begin
  Result := feGetRound;
end;

function FSetRound(NewRound: UInt32): UInt32;
begin
  Result:= feGetRound;
  feSetRound(NewRound);
end;

{$IFDEF CPUARM}
threadvar
  FPSCRExceptionEnableBits: UInt32;
{$ENDIF CPUARM}
{$IF defined(CPUX86) or defined(CPUX64)}
threadvar
  FPUExceptionMaskBits: UInt32; // for x87 FPU Control word and SSE MXCSR
{$ENDIF defined(CPUX86) or defined(CPUX64)}

function FSetExceptMask(NewMasks: UInt32; ExceptMasks: UInt32 = femALLEXCEPT): UInt32;
{$IF defined(CPUARM)}
// FPSCR of ARM architecture has "Exception Enable" flag. Cortex-A series CPUs
// don't have hardware exception capability, but we use same flags on RTL's thread-local storage.
// flag. Although, Get/SetFEnvExceptMask use "MASK" flags like Math.TArithmeticExceptionMask.
var
  CurrentEnableBits: UInt32;
begin
  ExceptMasks := ExceptMasks and femALLEXCEPT;
  CurrentEnableBits := FPSCRExceptionEnableBits and femALLEXCEPT;
  Result := (not CurrentEnableBits) and ExceptMasks;
  FPSCRExceptionEnableBits := (CurrentEnableBits and (not ExceptMasks)) or ((not NewMasks) and ExceptMasks);
end;
{$ELSEIF defined(CPUX86)}
var
  CurrentMask: UInt32;
begin
  ExceptMasks := ExceptMasks and femALLEXCEPT;
  CurrentMask := FPUExceptionMaskBits and femALLEXCEPT;
  Result := CurrentMask and ExceptMasks;
  FPUExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or (NewMasks and ExceptMasks)or $8000;
end;
{$ELSEIF defined(CPUX64)}
var
  CurrentMask: UInt32;
begin
                                                                      
  ExceptMasks := ExceptMasks and femALLEXCEPT;
  CurrentMask := FPUExceptionMaskBits and femALLEXCEPT;
  Result := CurrentMask and ExceptMasks;
  FPUExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or (NewMasks and ExceptMasks)or $8000;
end;
{$ELSE  !CPUARM and !CPUX86 and !CPUX64}
begin
end;
{$MESSAGE ERROR 'Unknown Architecture'}
{$ENDIF !CPUARM and !CPUX86 and !CPUX64}

function FGetExceptMask(ExceptMasks: UInt32 = femALLEXCEPT): UInt32;
{$IF     defined(CPUARM)}
begin
  Result := (not FPSCRExceptionEnableBits) and (ExceptMasks and femALLEXCEPT);
end;
{$ELSEIF defined(CPUX86)}
begin
  if FPUExceptionMaskBits = 0 then
    FPUExceptionMaskBits := (Default8087CW and $003F) or ((DefaultMXCSR and $1F80) shr 7) or $8000;
  Result := FPUExceptionMaskBits and (ExceptMasks and femALLEXCEPT);
end;
{$ELSEIF defined(CPUX64)}
begin
                                                   
  if FPUExceptionMaskBits = 0 then
    FPUExceptionMaskBits := ((Default8087CW and $003F) shl 7) or (DefaultMXCSR and $1F80) or $8000;
  Result := FPUExceptionMaskBits and (ExceptMasks and femALLEXCEPT);
end;
{$ELSE  !CPUARM and !CPUX86 and !CPUX64}
{$MESSAGE ERROR 'Unknown Architecture'}
{$ENDIF !CPUARM and !CPUX86 and !CPUX64}

{$ENDIF IOS or ANDROID or (OSX and EXTERNALLINKER)}
{$IF defined(WIN32) }
// condition is NEXTGEN and Windows (not iOS/ANDROID/OSX/LINUX)

procedure FClearExcept;
begin
end;

procedure FCheckExcept;
begin
end;

procedure FRaiseExcept(excepts: UInt32; CheckExceptionMask: Boolean = True);
begin
end;

function FSetExceptFlag(NewFlags: UInt32; Excepts: UInt32): UInt32;
begin
  Result := 0;
end;

function FGetExceptFlag(Excepts: UInt32): UInt32;
begin
  Result := 0;
end;

function FGetRound: UInt32;
begin
  Result := 0;
end;

function FSetRound(NewRound: UInt32): UInt32;
begin
  Result := 0;
end;

function FSetExceptMask(NewMasks: UInt32; ExceptMasks: UInt32 = femALLEXCEPT): UInt32;
begin
  Result := 0;
end;

function FGetExceptMask(ExceptMasks: UInt32 = femALLEXCEPT): UInt32;
begin
  Result := 0;
end;

{$ENDIF WIN32}
{$ELSE  !NEXTGEN}

procedure FClearExcept;
begin
end;

procedure FCheckExcept;
begin
end;

function FSetExceptFlag(NewFlags: UInt32; Excepts: UInt32): UInt32;
{$IF  defined(CPUX86)}
var
  flags: UInt32;
  FEnv: array[0..27] of byte;
begin
  Excepts := Excepts and feeALLEXCEPT;
  asm
    FNSTENV FEnv
  end;
  flags := FEnv[4] and $3F;
  Result := flags and Excepts;

  flags := (flags and (not Excepts)) or (NewFlags and Excepts);
  FEnv[4] := flags and $3F;
  asm
    FLDENV FEnv
  end;
end;
{$ELSEIF defined(CPUX64)}
var
  flags: UInt32;
begin
  Excepts := Excepts and feeALLEXCEPT;

  flags := GetMXCSR and feeALLEXCEPT;
  Result := flags and Excepts;

  flags := (flags and (not Excepts)) or (NewFlags and Excepts);
  SetMXCSRExceptionFlag(flags);
end;
{$ENDIF !defined(CPUX86) or !defined(CPUX64)}

function FGetExceptFlag(Excepts: UInt32): UInt32;
{$IF  Defined(CPUX86)}
var
  SW: Word;
begin
  asm
    FSTSW SW
  end;
  Result := SW and Excepts and feeALLEXCEPT;
end;
{$ELSEIF defined(CPUX64)}
begin
  Result := GetMXCSR and Excepts and feeALLEXCEPT;
end;
{$ENDIF !defined(CPUX86) or !Defined(CPUX64)}

procedure FRaiseExcept(excepts: UInt32; CheckExceptionMask: Boolean = True);
var
  flags, masks: UInt32;
begin
  if excepts = 0 then Exit;

  if CheckExceptionMask then
  begin
    masks := FGetExceptMask(ExceptionFlagToMask(excepts));
    if masks <> 0 then
    begin
      flags := ExceptionMaskToFlag(masks);
{$IF Defined(CPUX64)}
      excepts := excepts and not flags;
{$ENDIF}
      FSetExceptFlag(0, flags);
    end;
  end;

{$IF  Defined(CPUX86)}
  asm
    FWAIT
  end;
{$ELSEIF defined(CPUX64)}
  if excepts <> 0 then
  begin
    if excepts and feeINEXACT <> 0 then
    begin
      FSetExceptFlag(0, feeINEXACT);
      Error(reInvalidOp);
    end;
    if excepts and feeUNDERFLOW <> 0 then
    begin
      FSetExceptFlag(0, feeUNDERFLOW);
      Error(reUnderflow);
    end;
    if excepts and feeOVERFLOW <> 0 then
    begin
      FSetExceptFlag(0, feeOVERFLOW);
      Error(reOverflow);
    end;
    if excepts and feeDIVBYZERO <> 0 then
    begin
      FSetExceptFlag(0, feeDIVBYZERO);
      Error(reZeroDivide);
    end;
    if excepts and feeINVALID <> 0 then
    begin
      FSetExceptFlag(0, feeINVALID);
      Error(reInvalidOp);
    end;
  end;
{$ENDIF !defined(CPUX86) or !Defined(CPUX64)}
end;

function FGetRound: UInt32;
{$IF  defined(CPUX86)}
begin
  Result := Get8087CW and ferALLROUND;
end;
{$ELSEIF defined(CPUX64)}
begin
  Result := GetMXCSR and ferALLROUND;
end;
{$ENDIF !defined(CPUX86) or !defined(CPUX64)}

function FSetRound(NewRound: UInt32): UInt32;
{$IF  defined(CPUX86)}
var
  CtlWord: Word;
begin
  CtlWord := Get8087CW;
  Set8087CW((CtlWord and (not ferALLROUND)) or Word(NewRound));
  Result := UInt32(CtlWord and ferALLROUND);
end;
{$ELSEIF defined(CPUX64)}
var
  MXCSR: UInt32;
begin
  MXCSR := GetMXCSR;
  SetMXCSR((MXCSR and (not ferALLROUND)) or NewRound);
  Result := MXCSR and ferALLROUND;
end;
{$ENDIF !defined(CPUX86) or !defined(CPUX64)}

function FSetExceptMask(NewMasks: UInt32; ExceptMasks: UInt32): UInt32;
{$IF  defined(CPUX86)}
var
  CW: Word;
begin
  ExceptMasks := ExceptMasks and femALLEXCEPT;
  CW := Get8087CW;
  Set8087CW((CW and (not ExceptMasks)) or Word(NewMasks and ExceptMasks));
  Result := CW and ExceptMasks;
end;
{$ELSEIF defined(CPUX64)}
var
  MXCSR: UInt32;
begin
  ExceptMasks := ExceptMasks and femALLEXCEPT;
  MXCSR := GetMXCSR;
  SetMXCSR((MXCSR and (not ExceptMasks)) or (NewMasks and ExceptMasks));
  Result := MXCSR and ExceptMasks;
end;
{$ENDIF !defined(CPUX86) or !defined(CPUX64)}

function FGetExceptMask(ExceptMasks: UInt32): UInt32;
{$IF  defined(CPUX86)}
begin
  Result := Get8087CW and ExceptMasks;
end;
{$ELSEIF defined(CPUX64)}
begin
  Result := GetMXCSR and ExceptMasks;
end;
{$ENDIF !defined(CPUX86) or !defined(CPUX64)}
{$ENDIF !NEXTGEN}

{$IF defined(CPUX86) or defined(CPUX64)}

procedure Reset8087CW;
begin
  Set8087CW(Default8087CW);
end;

procedure Set8087CW(NewCW: Word);
{$IF defined(CPUX86) and defined(IOS) and defined(ASSEMBLER)} // iOS/Simulator
var
  M: Word;
begin
  Default8087CW := NewCW;
  M := NewCW or $3F; // mask all exceptions
  asm
        FNCLEX  // don't raise pending exceptions enabled by the new flags
        FLDCW  M
  end;
end;
{$ELSEIF defined(CPUX86) and defined(ASSEMBLER)} // Win32 or OSX
begin
  Default8087CW := NewCW;
  asm
        FNCLEX  // don't raise pending exceptions enabled by the new flags
{$IFDEF PIC}
        MOV     EAX,[EBX].OFFSET Default8087CW
        FLDCW   [EAX]
{$ELSE !PIC}
        FLDCW  Default8087CW
{$ENDIF !PIC}
  end;
end;
{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)} // Win64
asm
        MOV     Default8087CW, CX
        FNCLEX  // don't raise pending exceptions enabled by the new flags
        FLDCW   Default8087CW
end;
{$ELSE}
begin
                                                                  
  //Error(rePlatformNotImplemented);
end;
{$ENDIF}


function Get8087CW: Word;
{$IF defined(CPUX86) and defined(ASSEMBLER)}
asm
        PUSH    0
        FNSTCW  [ESP].Word
        POP     EAX
end;
{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}
asm
        PUSH    0
        FNSTCW  [RSP].Word
        POP     RAX
end;
{$ELSE }
begin
                                                          
  //Error(rePlatformNotImplemented);
  Result := Default8087CW;
end;
{$ENDIF}

procedure ResetMXCSR;
begin
  if TestSSE <> 0 then
    SetMXCSR(DefaultMXCSR);
end;

procedure SetMXCSR(NewMXCSR: UInt32);
{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)} // iOS Simulator
var
  M: UInt32;
begin
  DefaultMXCSR := NewMXCSR and $FFC0;  // Remove status flag bits
  M := NewMXCSR or $01F80; // mask all exceptions
  asm
        LDMXCSR M
  end;
end;
{$ELSEIF defined(CPUX86) and defined(ASSEMBLER)}
begin
  if TestSSE = 0 then exit;
  DefaultMXCSR := NewMXCSR and $FFC0;  // Remove status flag bits
  asm
{$IFDEF PIC}
        MOV     EAX,[EBX].OFFSET DefaultMXCSR
        LDMXCSR [EAX]
{$ELSE !PIC}
        LDMXCSR DefaultMXCSR
{$ENDIF !PIC}
  end;
end;
{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}
asm
        AND     ECX, $FFC0 // Remove flag bits
        MOV     DefaultMXCSR, ECX
        LDMXCSR DefaultMXCSR
end;
{$ELSE}
begin
                                                                      
  //Error(rePlatformNotImplemented);
end;
{$ENDIF}

procedure SetMXCSRExceptionFlag(NewExceptionFlag: UInt32);
{$IF defined(CPUX86) and defined(ASSEMBLER)}
var
  MXCSR: UInt32;
asm
{$IFDEF PIC}
        PUSH    EAX
        CALL    GetGOT
        MOV     EAX, [EAX].OFFSET TestSSE
        CMP     [EAX], 0
        POP     EAX
{$ELSE !PIC}
        CMP     TestSSE, 0
{$ENDIF !PIC}
        JE      @@NOSSE
        STMXCSR MXCSR
        AND     EAX, $003F
        AND     MXCSR, $FFC0
        OR      MXCSR, EAX
        LDMXCSR MXCSR
@@NOSSE:
end;
{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}
var
  MXCSR: UInt32;
asm
        STMXCSR MXCSR
        AND     ECX, $003F
        MOV     EDX, MXCSR
        AND     EDX, $FFC0
        OR      EDX, ECX
        MOV     MXCSR, EDX
        LDMXCSR MXCSR
end;
{$ELSE}
begin
                                                                                           
  //Error(rePlatformNotImplemented);
end;
{$ENDIF}

procedure ClearMXCSRStatus(ExceptionFlag: UInt32);
{$IF defined(CPUX86) and defined(ASSEMBLER)}
var
  MXCSR: UInt32;
asm
{$IFDEF PIC}
        PUSH    EAX
        CALL    GetGOT
        MOV     EAX, [EAX].OFFSET TestSSE
        CMP     [EAX], 0
        POP     EAX
{$ELSE !PIC}
        CMP     TestSSE, 0
{$ENDIF !PIC}
        JE      @@NOSSE
        STMXCSR MXCSR
        AND     EAX, $003F
        NOT     EAX
        AND     MXCSR, EAX
        LDMXCSR MXCSR
@@NOSSE:
end;
{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}
var
  MXCSR: UInt32;
asm
        STMXCSR MXCSR
        AND     ECX, $003F
        NOT     ECX
        AND     MXCSR, ECX
        LDMXCSR MXCSR
end;
{$ELSE}
begin
                                                                                   
  //Error(rePlatformNotImplemented);
end;
{$ENDIF}

function GetMXCSR: UInt32;
{$IF defined(CPUX86) and defined(ASSEMBLER)}
asm
{$IFDEF PIC}
        XOR     EAX, EAX
        PUSH    EAX
        CALL    GetGOT
        MOV     EAX, [EAX].OFFSET TestSSE
        CMP     [EAX], 0
        POP     EAX
        JE      @@NOSSE
{$ELSE !PIC}
        XOR     EAX, EAX
        CMP     TestSSE, EAX
        JE      @@NOSSE
{$ENDIF !PIC}
        PUSH    EAX
        STMXCSR [ESP].DWord
        POP     EAX
@@NOSSE:
end;
{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}
asm
        PUSH    0
        STMXCSR [RSP].DWord
        POP     RAX
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
begin
                                                           
  //Error(rePlatformNotImplemented);
  Result := FGetExceptFlag(feeALLEXCEPT);
end;
{$ELSE}
begin
                                                           
  Error(rePlatformNotImplemented);
  Result := 0;
end;
{$ENDIF}

{$ENDIF defined(CPUX86) or defined(CPUX64)}


{$IFDEF CPUARM32}
type
  FENV_ARM32 = record
    fpscr, r0, r1, r3: UInt32;
  end;

const
  ARM32_FPSCR_MASK     = $FFFF00FF;
  ARM32_EXCEPTION_MASK = $00009F00;

procedure SetFPSCR(NewFlag: UInt32);
var
  fenv: FENV_ARM32;
begin
  fegetenv(@fenv);
  fenv.fpscr := NewFLag and ARM32_FPSCR_MASK;
  fesetenv(@fenv);
  FPSCRExceptionEnableBits := NewFlag and ARM32_EXCEPTION_MASK;
end;

function GetFPSCR: UInt32;
var
  fenv: FENV_ARM32;
begin
  fegetenv(@fenv);
  Result := fenv.fpscr and ARM32_FPSCR_MASK or FPSCRExceptionEnableBits;
end;
{$ENDIF CPUARM32}

{$IFDEF CPUARM64}
type
  FENV_ARM64 = record
    fpsr, fpcr: UInt64;
  end;

const
  ARM64_FPSR_MASK      = $F100009F;
  ARM64_FPCR_MASK      = $07C00000;
  ARM64_EXCEPTION_MASK = $00009F00;

procedure SetFPSCR(NewFlag: UInt32);
var
  fenv: FENV_ARM64;
begin
  fegetenv(@fenv);
  fenv.fpsr := NewFLag and ARM64_FPSR_MASK;
  fenv.fpcr := NewFLag and ARM64_FPCR_MASK;
  fesetenv(@fenv);
  FPSCRExceptionEnableBits := NewFlag and ARM64_EXCEPTION_MASK;
end;

function GetFPSCR: UInt32;
var
  fenv: FENV_ARM64;
begin
  fegetenv(@fenv);
  Result := (fenv.fpsr and ARM64_FPSR_MASK) or
            (fenv.fpcr and ARM64_FPCR_MASK) or
            FPSCRExceptionEnableBits;
end;
{$ENDIF CPUARM64}

{ TSingleRec }

function TSingleRec.InternalGetBytes(Index: Cardinal): UInt8;
type
  PByteArray = ^TByteArray;
  TByteArray = array[0..32767] of Byte;
begin
  Result := PByteArray(@Self)[Index];
end;

function TSingleRec.InternalGetWords(Index: Cardinal): UInt16;
type
  PWordArray = ^TWordArray;
  TWordArray = array[0..16383] of Word;
begin
  Result := PWordArray(@Self)[Index];
end;

procedure TSingleRec.InternalSetBytes(Index: Cardinal; const Value: UInt8);
type
  PByteArray = ^TByteArray;
  TByteArray = array[0..32767] of Byte;
begin
  PByteArray(@Self)[Index] := Value;
end;

procedure TSingleRec.InternalSetWords(Index: Cardinal; const Value: UInt16);
type
  PWordArray = ^TWordArray;
  TWordArray = array[0..16383] of Word;
begin
  PWordArray(@Self)[Index] := Value;
end;

function TSingleRec.GetBytes(Index: Cardinal): UInt8;
begin
  if Index >= 4 then Error(reRangeError);
  Result := InternalGetBytes(Index);
end;

function TSingleRec.GetWords(Index: Cardinal): UInt16;
begin
  if Index >= 2 then Error(reRangeError);
  Result := InternalGetWords(Index);
end;

procedure TSingleRec.SetBytes(Index: Cardinal; const Value: UInt8);
begin
  if Index >= 4 then Error(reRangeError);
  InternalSetBytes(Index, Value);
end;

procedure TSingleRec.SetWords(Index: Cardinal; const Value: UInt16);
begin
  if Index >= 2 then Error(reRangeError);
  InternalSetWords(Index, Value);
end;

function TSingleRec.GetSign: Boolean;
begin
  Result := InternalGetBytes(3) >= $80;
end;

procedure TSingleRec.SetSign(NewSign: Boolean);
var
  B: Byte;
begin
  B := InternalGetBytes(3);
  if NewSign then B := B or $80
  else            B := B and $7F;
  InternalSetBytes(3, B);
end;

function TSingleRec.GetExp: UInt64;
begin
  Result := (InternalGetWords(1) shr 7) and $FF;
end;

procedure TSingleRec.SetExp(NewExp: UInt64);
var
  W: Word;
begin
  W := InternalGetWords(1);
  W := (W and $807F) or ((NewExp and $FF) shl 7);
  InternalSetWords(1, W);
end;

function TSingleRec.GetFrac: UInt64;
type
  PUInt32 = ^UInt32;
begin
  Result := PUInt32(@Self)^ and $007FFFFF;
end;

procedure TSingleRec.SetFrac(NewFrac: UInt64);
type
  PUInt32 = ^UInt32;
var
  LW: UInt32;
begin
  LW := PUInt32(@Self)^;
  LW := (LW and $FF800000) or (NewFrac and $007FFFFF);
  PUInt32(@Self)^ := LW;
end;

function TSingleRec.Fraction: Extended;
var
  E, F: UInt64;
begin
  E := GetExp;
  F := GetFrac;
  if E = $FF then
  begin
    if F = 0 then // +/- INF.
      Result := cInfinity
    else // NaN
      Result := cNan;
  end
  else if E = 0 then
    Result := (F / $00800000)
  else
    Result := 1.0 + (F / $00800000);
end;

function TSingleRec.Mantissa: UInt64;
var
  E, F: UInt64;
begin
  E := GetExp;
  F := GetFrac;
  Result := F;
  if (0 < E) and (E < $FF) then
    Result := Result or (UInt64(1) shl 23);
end;

function TSingleRec.Exponent: Integer;
var
  E, F: UInt64;
begin
  E := GetExp;
  F := GetFrac;
  if (0 < E) and (E < $FF) then
    Result := E - $7F
  else if (E = 0) and (F <> 0) then
    Result := -126 // Denormal
  else if (E = 0) and (F = 0) then
    Result := 0 // +/-Zero
  else
    Result := 0; // +/-INF, NaN
end;

function TSingleRec.SpecialType: TFloatSpecial;
type
  PUInt32 = ^UInt32;
var
  I: UInt32;
  W: Word;
begin
  I := PUInt32(@Self)^;
  W := InternalGetWords(1);

  if ($0080 <= W) and (W <= $7F7F) then
    Result := TFloatSpecial.fsPositive
  else if ($8080 <= W) and (W <= $FF7F) then
    Result := TFloatSpecial.fsNegative
  else if I = 0 then
    Result := TFloatSpecial.fsZero
  else if I = $80000000 then
    Result := TFloatSpecial.fsNZero
  else if w <= $007F then
    Result := TFloatSpecial.fsDenormal
  else if ($8000 <= w) and (w <= $807F) then
    Result := TFloatSpecial.fsNDenormal
  else if I = $7F800000 then
    Result := TFloatSpecial.fsInf
  else if I = $FF800000 then
    Result := TFloatSpecial.fsNInf
  else
    Result := TFloatSpecial.fsNan;
end;

procedure TSingleRec.BuildUp(const SignFlag: Boolean; const Mantissa: UInt64; const Exponent: Integer);
begin
  aSingle := 0.0;
  Sign := SignFlag;
  Exp := Exponent + $7F;
  Frac := Mantissa and $007FFFFF;
end;

class operator TSingleRec.Explicit(a: Extended): TSingleRec;
begin
  Result.aSingle := a;
end;

class operator TSingleRec.Explicit(a: TSingleRec): Extended;
begin
  Result := a.aSingle;
end;

{ TDoubleRec }

function TDoubleRec.InternalGetBytes(Index: Cardinal): UInt8;
type
  PByteArray = ^TByteArray;
  TByteArray = array[0..32767] of Byte;
begin
  Result := PByteArray(@Self)[Index];
end;

function TDoubleRec.InternalGetWords(Index: Cardinal): UInt16;
type
  PWordArray = ^TWordArray;
  TWordArray = array[0..16383] of Word;
begin
  Result := PWordArray(@Self)[Index];
end;

procedure TDoubleRec.InternalSetBytes(Index: Cardinal; const Value: UInt8);
type
  PByteArray = ^TByteArray;
  TByteArray = array[0..32767] of Byte;
begin
  PByteArray(@Self)[Index] := Value;
end;

procedure TDoubleRec.InternalSetWords(Index: Cardinal; const Value: UInt16);
type
  PWordArray = ^TWordArray;
  TWordArray = array[0..16383] of Word;
begin
  PWordArray(@Self)[Index] := Value;
end;

function TDoubleRec.GetBytes(Index: Cardinal): UInt8;
begin
  if Index >= 8 then System.Error(reRangeError);
  Result := InternalGetBytes(Index);
end;

function TDoubleRec.GetWords(Index: Cardinal): UInt16;
begin
  if Index >= 4 then System.Error(reRangeError);
  Result := InternalGetWords(Index);
end;

procedure TDoubleRec.SetBytes(Index: Cardinal; const Value: UInt8);
begin
  if Index >= 8 then Error(reRangeError);
  InternalSetBytes(Index, Value);
end;

procedure TDoubleRec.SetWords(Index: Cardinal; const Value: UInt16);
begin
  if Index >= 4 then Error(reRangeError);
  InternalSetWords(Index, Value);
end;

function TDoubleRec.GetSign: Boolean;
begin
  Result := InternalGetBytes(7) >= $80;
end;

procedure TDoubleRec.SetSign(NewSign: Boolean);
var
  B: Byte;
begin
  B := InternalGetBytes(7);
  if NewSign then B := B or $80
  else            B := B and $7F;
  InternalSetBytes(7, B);
end;

function TDoubleRec.GetExp: UInt64;
begin
  Result := (InternalGetWords(3) shr 4) and $7FF;
end;

procedure TDoubleRec.SetExp(NewExp: UInt64);
var
  W: Word;
begin
  W := InternalGetWords(3);
  W := (W and $800F) or ((NewExp and $7FF) shl 4);
  InternalSetWords(3, W);
end;

function TDoubleRec.GetFrac: UInt64;
begin
  Result := PUInt64(@Self)^ and $000FFFFFFFFFFFFF;
end;

procedure TDoubleRec.SetFrac(NewFrac: UInt64);
var
  U64: UInt64;
begin
  U64 := PUInt64(@Self)^;
  U64 := (U64 and $FFF0000000000000) or (NewFrac and $000FFFFFFFFFFFFF);
  PUInt64(@aDouble)^ := U64;
end;

function TDoubleRec.Fraction: Extended;
var
  E, F: UInt64;
begin
  E := GetExp;
  F := GetFrac;
  if E = $7FF then
  begin
    if F = 0 then // +/- INF.
      Result := cInfinity
    else // NaN
      Result := cNan;
  end
  else if E = 0 then
    Result := (F / $0010000000000000)
  else
    Result := 1.0 + (F / $0010000000000000);
end;

function TDoubleRec.Mantissa: UInt64;
var
  E, F: UInt64;
begin
  E := GetExp;
  F := GetFrac;
  Result := F;
  if (0 < E) and (E < $7FF) then
    Result := Result or (UInt64(1) shl 52);
end;

function TDoubleRec.Exponent: Integer;
var
  E, F: UInt64;
begin
  E := GetExp;
  F := GetFrac;
  if (0 < E) and (E < $7FF) then
    Result := E - $3FF
  else if (E = 0) and (F <> 0) then
    Result := -1022 // Denormal
  else if (E = 0) and (F = 0) then
    Result := 0 // +/-Zero
  else
    Result := 0; // +/-INF, NaN
end;

function TDoubleRec.SpecialType: TFloatSpecial;
var
  U64: UInt64;
  W: Word;
begin
  U64 := PUInt64(@Self)^;
  W := InternalGetWOrds(3);

  if ($0010 <= W) and (W <= $7FEF) then
    Result := TFloatSpecial.fsPositive
  else if ($8010 <= W) and (W <= $FFEF) then
    Result := TFloatSpecial.fsNegative
  else if U64 = 0 then
    Result := TFloatSpecial.fsZero
  else if U64 = $8000000000000000 then
    Result := TFloatSpecial.fsNZero
  else if w <= $000F then
    Result := TFloatSpecial.fsDenormal
  else if ($8000 <= w) and (w <= $800F) then
    Result := TFloatSpecial.fsNDenormal
  else if U64 = $7FF0000000000000 then
    Result := TFloatSpecial.fsInf
  else if U64 = $FFF0000000000000 then
    Result := TFloatSpecial.fsNInf
  else
    Result := TFloatSpecial.fsNan;
end;

procedure TDoubleRec.BuildUp(const SignFlag: Boolean; const Mantissa: UInt64; const Exponent: Integer);
begin
  aDouble := 0.0;
  SetSign(SignFlag);
  SetExp(Exponent + $3FF);
  SetFrac(Mantissa and $000FFFFFFFFFFFFF);
end;

class operator TDoubleRec.Explicit(a: Extended): TDoubleRec;
begin
  Result.aDouble := a;
end;

class operator TDoubleRec.Explicit(a: TDoubleRec): Extended;
begin
  Result := a.aDouble;
end;

{ TExtended80Rec }

function TExtended80Rec.InternalGetBytes(Index: Cardinal): UInt8;
type
  PByteArray = ^TByteArray;
  TByteArray = array[0..32767] of Byte;
begin
  Result := PByteArray(@Self)[Index];
end;

function TExtended80Rec.InternalGetWords(Index: Cardinal): UInt16;
type
  PWordArray = ^TWordArray;
  TWordArray = array[0..16383] of Word;
begin
  Result := PWordArray(@Self)[Index];
end;

procedure TExtended80Rec.InternalSetBytes(Index: Cardinal; const Value: UInt8);
type
  PByteArray = ^TByteArray;
  TByteArray = array[0..32767] of Byte;
begin
  PByteArray(@Self)[Index] := Value;
end;

procedure TExtended80Rec.InternalSetWords(Index: Cardinal; const Value: UInt16);
type
  PWordArray = ^TWordArray;
  TWordArray = array[0..16383] of Word;
begin
  PWordArray(@Self)[Index] := Value;
end;

function TExtended80Rec.GetBytes(Index: Cardinal): UInt8;
begin
  if Index >= 10 then System.Error(reRangeError);
  Result := InternalGetBytes(Index);
end;

function TExtended80Rec.GetWords(Index: Cardinal): UInt16;
begin
  if Index >= 5 then System.Error(reRangeError);
  Result := InternalGetWords(Index);
end;

procedure TExtended80Rec.SetBytes(Index: Cardinal; const Value: UInt8);
begin
  if Index >= 10 then System.Error(reRangeError);
  InternalSetBytes(Index, Value);
end;

procedure TExtended80Rec.SetWords(Index: Cardinal; const Value: UInt16);
begin
  if Index >= 5 then System.Error(reRangeError);
  InternalSetWords(Index, Value);
end;

function TExtended80Rec.GetSign: Boolean;
begin
  Result := InternalGetBytes(9) >= $80;
end;

procedure TExtended80Rec.SetSign(NewSign: Boolean);
var
  B: Byte;
begin
  B := InternalGetBytes(9);
  if NewSign then B := B or $80
  else            B := B and $7F;
  InternalSetBytes(9, B);
end;

function TExtended80Rec.Get_Exp: UInt64;
begin
  Result := InternalGetWords(4);
end;

function TExtended80Rec.GetExp: UInt64;
begin
  Result := InternalGetWords(4) and $7FFF;
end;

procedure TExtended80Rec.Set_Exp(NewExp: UInt64);
begin
  InternalSetWords(4, NewExp);
end;

procedure TExtended80Rec.SetExp(NewExp: UInt64);
var
  W: Word;
begin
  W := InternalGetWords(4);
  W := (W and $8000) or (NewExp and $7FFF);
  InternalSetWords(4, W);
end;

function TExtended80Rec.GetFrac: UInt64;
begin
{$IFDEF EXTENDEDIS10BYTES}
  Result := PUInt64(@Self)^; // first 4 bytes are fraction part.
{$ELSE  EXTENDEDIS10BYTES}
  Result := aExtended80Frac;
{$ENDIF EXTENDEDIS10BYTES}
end;

procedure TExtended80Rec.SetFrac(NewFrac: UInt64);
begin
{$IFDEF EXTENDEDIS10BYTES}
  PUInt64(@Self)^ := NewFrac;
{$ELSE  EXTENDEDIS10BYTES}
  aExtended80Frac := NewFrac;
{$ENDIF EXTENDEDIS10BYTES}
end;

function TExtended80Rec.Fraction: Extended;
var
  E, F: UInt64;
begin
  E := GetExp;
  F := GetFrac;
  if E = $7FFF then
  begin
    if F = $8000000000000000 then // +/- INF.
      Result := cInfinity
    else // NaN
      Result := cNan;
  end
  else
    Result := F / 9223372036854775808.0; // 2^63
end;

function TExtended80Rec.Mantissa: UInt64;
begin
  Result := GetFrac;
end;

function TExtended80Rec.Exponent: Integer;
var
  E, F: UInt64;
begin
  E := GetExp;
  F := GetFrac;
  if (0 < E) and (E < $7FFF) then
    Result := E - $3FFF
  else if (E = 0) and (F <> 0) then
    Result := -16382 // Denormal
  else if (E = 0) and (F = 0) then
    Result := 0 // +/-Zero
  else
    Result := 0; // +/-INF, NaN
end;

function TExtended80Rec.SpecialType: TFloatSpecial;
var
  I: UInt64;
  W: Word;
begin
  I := Frac;
  W := InternalGetWords(4);

  if ($0001 <= W) and (W <= $7FFE) then
    Result := TFloatSpecial.fsPositive
  else if ($8001 <= W) and (W <= $FFFE) then
    Result := TFloatSpecial.fsNegative
  else if (I = 0) and (W = 0) then
    Result := TFloatSpecial.fsZero
  else if (I = 0) and (W = $8000) then
    Result := TFloatSpecial.fsNZero
  else if w = $0000 then
    Result := TFloatSpecial.fsDenormal
  else if w = $8000 then
    Result := TFloatSpecial.fsNDenormal
  else if (I = $8000000000000000) and (W = $7FFF) then
    Result := TFloatSpecial.fsInf
  else if (I = $8000000000000000) and (W = $FFFF)then
    Result := TFloatSpecial.fsNInf
  else
    Result := TFloatSpecial.fsNan;
end;

procedure TExtended80Rec.BuildUp(const SignFlag: Boolean; const Mantissa: UInt64; const Exponent: Integer);
begin
{$IFDEF EXTENDEDIS10BYTES}
  aExtended80 := 0.0;
{$ELSE  EXTENDEDIS10BYTES}
  aExtended80Frac := 0;
  aExtended80Exp :=  0;
{$ENDIF EXTENDEDIS10BYTES}
  Sign := SignFlag;
  Exp := Exponent + $3FFF;
  Frac := Mantissa;
end;

class operator TExtended80Rec.Explicit(a: Extended): TExtended80Rec;
{$IFDEF EXTENDEDIS10BYTES}
begin
  Result.aExtended80 := a;
end;
{$ELSEIF defined(EXTENDEDHAS10BYTES)}
begin
  Result := PExtended80Rec(@a)^; // value is stored in first 80 bits
end;
{$ELSE  !EXTENDEDIS10BYTES and !EXTENDEDHAS10BYTES}
var
  U: UInt64;
  E: Integer;
begin
  case PDoubleRec(@a).SpecialType of
    fsNInf,
    fsInf:
      Result.BuildUp( PDoubleRec(@a).Sign, $8000000000000000, $4000);
    fsNZero,
    fsZero:
      Result.BuildUp( PDoubleRec(@a).Sign, 0, -16383);
    fsNDenormal,
    fsDenormal:
      begin
        U := PDoubleRec(@a).Frac; // 52bits fraction
        U := U shl (64-53);
        E := -1022;
        while (U and $8000000000000000) = 0 do
        begin
          U := U * 2;
          Dec(E);
        end;
        PExtended80Rec(@Result).BuildUp( PDoubleRec(@a).Sign, U, E);
      end;
    fsNegative,
    fsPositive:
      Result.BuildUp( TDoubleRec(a).Sign, TDoubleRec(a).Mantissa shl (64-53), TDoubleRec(a).Exponent);
    fsNaN:
      Result.BuildUp( True, $C000000000000000, $4000);
  end;
end;
{$ENDIF !EXTENDEDIS10BYTES and !EXTENDEDHAS10BYTES}

class operator TExtended80Rec.Explicit(a: TExtended80Rec): Extended;
{$IFDEF EXTENDEDIS10BYTES}
begin
  Result := a.aExtended80;
end;
{$ELSEIF defined(EXTENDEDHAS10BYTES)}
begin
  Result := PExtended(@a)^; // value is stored in first 80 bits
end;
{$ELSE  !EXTENDEDIS10BYTES and !EXTENDEDHAS10BYTES}
var
  T: Double;
begin
  case a.SpecialType of
    fsNInf,
    fsInf:
      PDoubleRec(@Result).BuildUp( a.Sign, 0, $400);
    fsNZero,
    fsZero:
      PDoubleRec(@Result).BuildUp( a.Sign, 0, -1023);
    fsNDenormal,
    fsDenormal:
      PDoubleRec(@Result).BuildUp( a.Sign, 0, -1023);
    fsNegative,
    fsPositive:
      begin
        if a.Exponent > 1023 then
        begin
          FRaiseExcept(feeOVERFLOW);
          if a.Sign then Result := cNInfinity
          else Result := cInfinity;
        end
        else if a.Exponent < -(1023 + 52) then
          PDoubleRec(@Result).BuildUp( a.Sign, 0, -1023)
        else if a.Exponent < -1022 then
        begin
          // Result := Minimum normalized Double number.
          PDoubleRec(@Result).BuildUp( a.Sign, $10000000000000, -1022);
          // Exteneded80Rec.Mantissa has 64bit integer.
          Result := Result * (a.Mantissa / 9223372036854775808.0); // 2 ^ 63;
          PDoubleRec(@T).BuildUp( False, $10000000000000, a.Exponent + 1022);
          Result := Result * T;
        end
        else
        begin
          PDoubleRec(@Result).BuildUp( a.Sign, $10000000000000, a.Exponent);
          Result := Result * (a.Mantissa / 9223372036854775808.0); // 2 ^ 63;
        end;
      end;
    fsNaN:
      PDoubleRec(@Result).BuildUp( True, $8000000000000, $400);
  end;
end;
{$ENDIF !EXTENDEDIS10BYTES and !EXTENDEDHAS10BYTES}

{ StoredAttribute }

constructor StoredAttribute.Create;
begin
  inherited Create;
  FFlag := True;
  _FName := '';
end;

constructor StoredAttribute.Create(const StorageHandlerFlag: Boolean);
begin
  inherited Create;
  FFlag := StorageHandlerFlag;
  _FName := '';
end;

constructor StoredAttribute.Create(const StorageHandlerName: string);
begin
  inherited Create;
  FFlag := True;
  _FName := StorageHandlerName;
end;

{ HPPGENAttribute }

constructor HPPGENAttribute.Create(const AData : string);
begin
end;

constructor HPPGENAttribute.Create(const AFlag: Integer; const AData : string);
begin
end;

{ HFAAttribute }

constructor HFAAttribute.Create(const ElementType: Pointer; const ElementCount: Integer);
begin
  inherited Create;
  FElementType := ElementType;
  FElementCount := ElementCount;
end;

{ AlignAttribute }
constructor AlignAttribute.Create(Align: Integer);
begin
  inherited Create;
  FAlign := Align;
end;

{$IF     defined(ARITH_PUREPASCAL_EXT80)}
function Int(const X: Extended): Extended;
begin
  FClearExcept;
  Result := Trunc(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64)}
function Int(const X: Double): Double;
const
  aTruncationLimit : Double =  4503599627370496; // $4330000000000000
begin
  if (X >= aTruncationLimit) or (X <= -aTruncationLimit) then
    Result := X
  else
  begin
    FClearExcept;
    Result := Trunc(X);
    FCheckExcept;
  end;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
function Int(const X: Double): Double;
type
  PWordArray = ^TWordArray;
  TWordArray = array[0..16383] of Word;
begin
  // 2^52 = $4330000000000000. The number larger than 2^52 has no fraction part.
  if (PWordArray(@X)[3] and $7FF0) >= $4330 then
    Result := X
  else
  begin
    FClearExcept;
    Result := Trunc(X);
    FCheckExcept;
  end;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

function Int(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        SUB     ESP,4
        FNSTCW  [ESP].Word     // save
        FNSTCW  [ESP+2].Word   // scratch
        FWAIT
        OR      [ESP+2].Word, $0F00  // trunc toward zero, full precision
        FLDCW   [ESP+2].Word
        FRNDINT
        FWAIT
        FLDCW   [ESP].Word
        ADD     ESP,4
        FSTP    tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        SUB     ESP,4
        FNSTCW  [ESP].Word     // save
        FNSTCW  [ESP+2].Word   // scratch
        FWAIT
        OR      [ESP+2].Word, $0F00  // trunc toward zero, full precision
        FLDCW   [ESP+2].Word
        FRNDINT
        FWAIT
        FLDCW   [ESP].Word
        ADD     ESP,4
end;
{$ENDIF}
{$ELSEIF defined(ARITH_X64_SSE)}
function Int(const X: Double): Double;
asm
        .NOFRAME
        MOVSD     [RSP+$08], XMM0
        MOV       EAX, [RSP+$0C]
        AND       EAX, $7FF00000
        CMP       EAX, $43300000
        JGE       @@EXIT
        CMP       EAX, $3FE00000
        JBE       @@LOW
        CVTTSD2SI RAX, XMM0
        CVTSI2SD  XMM0, RAX
        JMP       @@EXIT
@@LOW:
        XORPD     XMM0, XMM0
@@EXIT:
end;
{$ENDIF }

{$IF     defined(ARITH_PUREPASCAL_EXT80)}
function Frac(const X: Extended): Extended;
begin
  Result := X - Int(X);
end;
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or
         defined(ARITH_USE_LIBM)}
function Frac(const X: Double): Double;
begin
  FClearExcept;
  Result := X - Int(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

function Frac(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        FLD     ST(0)
        SUB     ESP,4
        FNSTCW  [ESP].Word     // save
        FNSTCW  [ESP+2].Word   // scratch
        FWAIT
        OR      [ESP+2].Word, $0F00  // trunc toward zero, full precision
        FLDCW   [ESP+2].Word
        FRNDINT
        FWAIT
        FLDCW   [ESP].Word
        ADD     ESP,4
        FSUB
        FSTP    tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        FLD     ST(0)
        SUB     ESP,4
        FNSTCW  [ESP].Word     // save
        FNSTCW  [ESP+2].Word   // scratch
        FWAIT
        OR      [ESP+2].Word, $0F00  // trunc toward zero, full precision
        FLDCW   [ESP+2].Word
        FRNDINT
        FWAIT
        FLDCW   [ESP].Word
        ADD     ESP,4
        FSUB
end;
{$ENDIF}
{$ELSEIF defined(ARITH_X64_SSE)}
function Frac(const X: Double): Double;
asm
        .NOFRAME
        MOVSD     [RSP+$08], XMM0
        MOV       EAX, [RSP+$0C]
        AND       EAX, $7FF00000
        CMP       EAX, $43300000
        JGE       @@HIGH
        CMP       EAX, $3FE00000
        JBE       @@EXIT
        CVTTSD2SI RAX, XMM0
        CVTSI2SD  XMM4, RAX
        SUBSD     XMM0, XMM4
        JMP       @@EXIT
@@HIGH:
        XORPD     XMM0, XMM0
@@EXIT:
end;
{$ENDIF }

{$IF defined(CPUX64) or defined(PUREPASCAL) }
type
  coeffType = (cHi, cLo);
const
  ExpM1Iof64 : array[-64 .. 64, coeffType] of UInt64 = (
    ($bfe43a54e4e98864, $bc6ca8a4270fadf5), ($bfe40adf8d149383, $3c7bbea189925bac),
    ($bfe3daaae2395759, $bc57e46d4e1d1416), ($bfe3a9b3e10921cd, $bc8b67124284ea97),
    ($bfe377f77a0fcb45, $3c4c14c2e7d1c9a4), ($bfe345729182bf1f, $bc8eb70d83f2dfd5),
    ($bfe31221ff0f3ecc, $3c69a4cddcf699b7), ($bfe2de028da7dc59, $bc5edef1c1e9d2e5),
    ($bfe2a910fb51295a, $bc87fb56248af1d0), ($bfe27349f8ed96eb, $bc8c3e2eeddb6e92),
    ($bfe23caa2a088391, $3c8eccb4dac0c150), ($bfe2052e24a073a5, $3c8161c3e082442f),
    ($bfe1ccd270f070f9, $bc8f7cca01c669f0), ($bfe1939389388e3d, $bc74fb4ada0efe97),
    ($bfe1596dd9858ab1, $bc5ad6ddc4792f50), ($bfe11e5dbf7792a9, $bc561c5f183ad4be),
    ($bfe0e25f8a081941, $3c74bbf0f4cffc58), ($bfe0a56f794ec7a4, $bc895d31f71cd295),
    ($bfe06789be457e3b, $3c8f0422c59b7d45), ($bfe028aa7a8b63f2, $3c896b8384f1d3ee),
    ($bfdfd19b804dffbf, $bc63dcfaabcf5d2c), ($bfdf4fdf228eb2ad, $3c437f6cecd799a3),
    ($bfdecc17c0083500, $3c7be9229f8beebe), ($bfde463d1c396301, $bc43f3d38f393576),
    ($bfddbe46d96cd831, $3c75958a5d1795c7), ($bfdd342c7833133a, $bc6333023ef6f763),
    ($bfdca7e556da7e48, $bc7229736e5c8d3a), ($bfdc1968b0e55333, $bc7a21677c651b54),
    ($bfdb88ad9e7d52ea, $bbfb61343fc21a3b), ($bfdaf5ab13e5474f, $3c703c6e249a5882),
    ($bfda6057e0e846a4, $bc655b1912202da3), ($bfd9c8aab046af7a, $bc050456628532f0),
    ($bfd92e9a0720d3ec, $bc285314b9559e64), ($bfd8921c445f4add, $3c618bc865c78e3b),
    ($bfd7f327a018ddb2, $bc61a901b1ee2bd6), ($bfd751b22af608f0, $bc70a0249fec9629),
    ($bfd6adb1cd9205ee, $bc74edd8a92eb584), ($bfd6071c47d953b2, $bc7a771b057709c4),
    ($bfd55de73065b4df, $3c6572ec15fec83d), ($bfd4b207f3d79870, $bc6759d4ac130208),
    ($bfd40373d42ce2e3, $3c753d8db804c224), ($bfd3521fe8150d2b, $bc6b0648a5e34bb6),
    ($bfd29e011a428ec6, $bc6dabf5975c0c02), ($bfd1e70c28b987f3, $3c74e91dbb1734bd),
    ($bfd12d35a41ba104, $3c63445f7544e0ef), ($bfd07071eef11388, $bc309aa682553231),
    ($bfcf616a79dda3a8, $bc66b2eab63020c1), ($bfcddbe7247382af, $bc431eb13933e894),
    ($bfcc5041854df7d4, $bc6797d4686c5393), ($bfcabe60e1f21836, $bc36f8b82e653e2d),
    ($bfc9262c1c3430a1, $bc646ff6ec4a4251), ($bfc78789b0a5e0c0, $3c5e3a6bdaece8f9),
    ($bfc5e25fb4fde211, $3c064eec82915df3), ($bfc43693d679612d, $bc69da94a869862a),
    ($bfc2840b5836cf67, $bc685405051eb425), ($bfc0caab118a1278, $3c26ad4c353465b0),
    ($bfbe14aed893eef4, $3c4e1f58934f97af), ($bfba85e8c62d9c13, $bc5adf7745e77188),
    ($bfb6e8caff341fea, $bc59573ded7888b2), ($bfb33d1bb17df2e7, $bc4e19c873b1d6a8),
    ($bfaf0540438fd5c3, $bc2a1ce01f9f6ca7), ($bfa7723950130405, $3c2c677ad8fa478d),
    ($bf9f8152aee9450e, $3c24b00abf977627), ($bf8fc055004416db, $bc282ef422ab152a),
    ($0000000000000000, $0000000000000000),
    ($3f90202ad5778e46, $bc151e6d305beec6), ($3fa040ac0224fd93, $3c2c17a107575019),
    ($3fa89246d053d178, $3c44967f31eb2595), ($3fb082b577d34ed8, $bc45272ff30eed1b),
    ($3fb4cd4fc989cd64, $3c5557a8671b89e7), ($3fb92937074e0cd7, $bc5db0b9cc915fc5),
    ($3fbd96b0eff0e794, $bc475385b2cdf93d), ($3fc10b022db7ae68, $bc58c4a5df1ec7e5),
    ($3fc353bc9fb00b21, $3c66bae618011342), ($3fc5a5ac59b963cb, $bc6fd91307e74c50),
    ($3fc800f67b00d7b8, $3c27ab912c69ffeb), ($3fca65c0b85ac1a9, $3c6a9c189196f8cd),
    ($3fccd4315e9e0833, $bc2172c31a1781f1), ($3fcf4c6f5508ee5d, $3c646ef7b808180a),
    ($3fd0e7510fd7c564, $bc71c5b2e8735a43), ($3fd22d78f0fa061a, $bc789843c4964554),
    ($3fd378c3b0847980, $3c73b5223eca1712), ($3fd4c946033eb3de, $bc735d267d66dc96),
    ($3fd61f14f169ebc1, $bc789e2d87fd0d92), ($3fd77a45d8117fd5, $bc52bb36e6b3a2af),
    ($3fd8daee6a60c961, $3c6a4e618fb92468), ($3fda4124b2fe50cb, $3c6fb5f3020a46f5),
    ($3fdbacff156c79d7, $bc66c5366444681a), ($3fdd1e944f6fbdaa, $bc7dcb8749a64f6e),
    ($3fde95fb7a7a88f8, $bc7cc04a2491ed0a), ($3fe009a6068f6a8c, $bc8a29a322473bb6),
    ($3fe0cb4eee42c98b, $bc8f511ef22f5ad5), ($3fe190048ef60020, $bc81ed925f893d67),
    ($3fe257d334137dff, $3c8b99bfe7ce9f9e), ($3fe322c75a963b98, $3c73718f70534e8a),
    ($3fe3f0edb1d18acd, $bc87d3f40a146f34), ($3fe4c2531c3c0d38, $bc8b4690082a4906),
    ($3fe59704b03ddca9, $bc867241360f5dc1), ($3fe66f0fb901f2bd, $3c8176670eb83154),
    ($3fe74a81b74adcac, $bc7690fec61c7ca4), ($3fe82968624ac88d, $bc8de6aad7622def),
    ($3fe90bd1a87ef9a1, $bc5175cf7e67dfff), ($3fe9f1cbb08eb151, $3c8bf66c74a26ecd),
    ($3feadb64da2d9acf, $bc3c71005d68edd6), ($3febc8abbf01c781, $bc81abb427c68493),
    ($3fecb9af338d4a9c, $3c8912542fa88dd4), ($3fedae7e481b8284, $bc5e2a138ec80097),
    ($3feea72849b21ebd, $bc7a892e30b5188f), ($3fefa3bcc305f191, $3c7d2c3b6d08c659),
    ($3ff05225beb9ce55, $bc9d02df8ccf4707), ($3ff0d47240fe1412, $3c95ff940cd08c4d),
    ($3ff158cc0d22ca02, $bc94a9212ef0b185), ($3ff1df3b68cfb9ef, $3c9ea61ab771f73c),
    ($3ff267c8bb05d2a3, $3c5a3d1e659a0ad8), ($3ff2f27c8ca598a0, $3c7d4fe81eb0becb),
    ($3ff37f5f88f7b4e5, $3c9adcd8bb9947d9), ($3ff40e7a7e37aa30, $bc2bb8b0f3c94f34),
    ($3ff49fd65e20b96f, $3c93a5153fb80a4a), ($3ff5337c3e7cfe38, $3c7708e2df602f1d),
    ($3ff5c97559b6cc28, $bc78aecd517b37d5), ($3ff661cb0f6c564f, $3c8c221ff57b390a),
    ($3ff6fc86e505a9dd, $bc9a7d609b716bf6), ($3ff799b2864d0569, $bc9ba2fe6f7de08c),
    ($3ff83957c6099668, $bc54d703cb17b345), ($3ff8db809e9ca670, $3c92896ff654d054),
    ($3ff9803732a14221, $3c76a828a835e066), ($3ffa2785cd8e63ad, $3c787f474dbeb603),
    ($3ffad176e45bab25, $3c9af15018e5e729), ($3ffb7e151628aed3, $bc9655023a9dfd8c) );
{$ENDIF defined(CPUX64) or defined(PUREPASCAL) }

{$IF defined(ARITH_PUREPASCAL_EXT80)}
{$IF defined(ARITH_USE_LIBM)}
function libm_expl(x: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'expl';

function Exp(const X: Extended): Extended;
                                                                  
const
  ExpUpperLimit = 709.78271289338397; //$40862E42FEFA39EF; // ln( Double-MAX );
  ExpLowerLimit = -745.1332191019411; //$C0874910D52D3051; // ln( Double-DeNormal-Min );
begin
  FClearExcept;
  if X > ExpUpperLimit then
  begin
    FRaiseExcept(feeOVERFLOW);
    Exit( cInfinity );
  end
  else if X < ExpLowerLimit then
  begin
    FRaiseExcept(feeUNDERFLOW);
    Exit( 0 );
  end;
  Result := libm_expl(X);
  FCheckExcept;
end;
{$ENDIF defined(ARITH_USE_LIBM)}
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64)}
function Exp(const X: Double): Double;
const
  C64      : Double =  64.0;
  C1of2    : Double =  1/2;
  C1of64   : Double =  1/64;
  CExp : array[3..6] of UInt64 =
  ( $3fc5555555554855, $3fa5555555553b54,
    $3f811112b12b282f, $3f56c16e86e89028 );
  ExpUpperLimit = 709.78271289338397; //$40862E42FEFA39EF; // ln( Double-MAX );
  ExpLowerLimit = -745.1332191019411; //$C0874910D52D3051; // ln( Double-DeNormal-Min );
  Log2ofE   : UInt64 = $3ff71547652b82fe;
  Log2ofEHi : UInt64 = $3ff71547652b0000;
  Log2ofELo : UInt64 = $3da05fc2eefa1ffb;
  LogEof2Hi : UInt64 = $3FE62E42FEFA4000;
  LogEof2Lo : UInt64 = $3D48432A1B0E2634;
  C2pow1023p5 : UInt64 = $7fe6a09e667f3bcd; // 2^(1023.5)
  C2powM1074p5 : UInt64 = $00000000000000001; // 2^(-1074.5)
type
  TWords = Array[0..3] of Word;
  PWords = ^TWords;
var
  q: Integer;
  qd, X0, X1, X2, X3, f: Double;
  I, Ind: UInt64;
  W: Word;
  yHi, yLo, y, Y2,
  q0, q1, q2, qHi, qLo, pLo, pHi : Double;
  t, u, v, r: Double;
begin
  W := PWords(@X)^[3] and $7FF0;
  if (W = $0000) then Exit(1.0); // +/-Zero and +/-Denormal
  if (W = $7FF0) then
  begin
    I := PUInt64(@X)^;
    if I = $7FF0000000000000 then
    begin
      FRaiseExcept(feeOVERFLOW);
      Exit( cInfinity );
    end
    else if I = $FFF0000000000000 then
      Exit(0.0)
    else
      Exit(X);
  end;

  if X >= 0 then
  begin
    if X > ExpUpperLimit then
    begin
      FRaiseExcept(feeOVERFLOW);
      Exit( cInfinity );
    end;
    X0 := X * PDouble(@Log2ofE)^;
    q := Trunc(X0 + 0.5); qd := q;
    if q <= 1023 then
    begin
      PUInt64(@f)^ := (UInt64(q + 1023)) shl 52; //    f := 2 ^ q;
    end
    else
    begin
      if X0 >= 1024.0 then
      begin
        FRaiseExcept(feeOVERFLOW);
        Exit( cInfinity ); // +Inf
      end;
      qd := 1023.5;
      f := PDouble(@C2pow1023p5)^;
    end;
  end
  else
  begin
    if X < ExpLowerLimit then
      Exit( 0.0 );
    X0 := X * PDouble(@Log2ofE)^;
    q := Trunc(X0 - 0.5); qd := q;
    if q >= -1022 then
    begin
      PUInt64(@f)^ := (UInt64(q + 1023)) shl 52; //    f := 2 ^ q;
    end
    else
    begin
      if X0 <= -1075.0 then
        Exit( 0.0 )
      else if X0 <= -1074.5 then
      begin
        f := PDouble(@C2powM1074p5)^;
        qd := -1074.5;
      end
      else
        PUInt64(@f)^ := UInt64($10000000000000) shr (-1022 -  q);
    end;
  end;

  x1 := X - qd * PDouble(@LogEof2Hi)^;
  x2 := qd * PDouble(@LogEof2Lo)^;
  X3 := x1 + x2;
  if X3 >= 0 then
    Ind := Trunc(X3 * C64 + C1of2)
  else
    Ind := Trunc(X3 * C64 - C1of2);
  yHi := x1 - Ind * C1of64;
  yLo := x2;

  y :=  yHi + yLo;
  y2 := y * y;

  q1 :=           PDouble(@CExp[6])^;
  q2 :=           PDouble(@CExp[5])^;
  q1 := q1 * y2 + PDouble(@CExp[4])^;
  q2 := q2 * y2 + PDouble(@CExp[3])^;
  q0 := (q1 * y + q2) * y + c1of2;

  qLo := q0 * y2 + yLo;
  qHi := yHi;

  pHi :=  PDouble(@ExpM1Iof64[Ind, cHi])^;
  pLo :=  PDouble(@ExpM1Iof64[Ind, cLo])^;

  t := pHi + 1.0; v := t - 1.0; r := pHi - v; u := r + pLo;
  pHi := t + u; v := pHi - t;
  pLo := u - v;

  Result := 0;
  Result := Result + qLo * pLo;
  Result := Result + qHi * pLo;
  Result := Result + pLo;
  Result := Result + qLo * pHi;
  Result := Result + qHi * pHi;
  Result := Result + pHi;
  Result := f * Result;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
function libm_exp(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'exp';

function Exp(const X: Double): Double;
const
  ExpUpperLimit = 709.78271289338397; //$40862E42FEFA39EF; // ln( Double-MAX );
  ExpLowerLimit = -745.1332191019411; //$C0874910D52D3051; // ln( Double-DeNormal-Min );
begin
  FClearExcept;
  if X > ExpUpperLimit then
  begin
    FRaiseExcept(feeOVERFLOW);
    Exit( cInfinity );
  end
  else if X < ExpLowerLimit then
  begin
    FRaiseExcept(feeUNDERFLOW);
    Exit( 0 );
  end;
  Result := libm_exp(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}
function Exp(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
var
  D: Double;
begin
  FClearExcept;
  asm
        {       e**x = 2**(x*log2(e))   }
        FLD     tbyte ptr X
        FLDL2E              { y := x*log2e;      }
        FMUL
        FLD     ST(0)       { i := round(y);     }
        FRNDINT
        FSUB    ST(1), ST   { f := y - i;        }
        FXCH    ST(1)       { z := 2**f          }
        F2XM1
        FLD1
        FADD
        FSCALE              { result := z * 2**i }
        FSTP    ST(1)
        FSTP    qword ptr D { Force save to Double to detect overflow. }
  end;
  Result := D;
  FCheckExcept;
end;
{$ELSE}
asm
        {       e**x = 2**(x*log2(e))   }
        FLD     tbyte ptr X
        FLDL2E              { y := x*log2e;      }
        FMUL
        FLD     ST(0)       { i := round(y);     }
        FRNDINT
        FSUB    ST(1), ST   { f := y - i;        }
        FXCH    ST(1)       { z := 2**f          }
        F2XM1
        FLD1
        FADD
        FSCALE              { result := z * 2**i }
        FSTP    ST(1)
end;
{$ENDIF}
{$ELSEIF defined(ARITH_X64_SSE)}
function Exp(const X: Double): Double;
type
  m128 = record
    Hi, Lo : UInt64
  end align 16;
const
  ExpUpperLimit = $40862E42FEFA39EF; // ln( Double-MAX );
  ExpLowerLimit = $C0874910D52D3051; // ln( Double-DeNormal-Min );
  C64      : Double =  64.0;
  C1of2    : Double =  1/2;
  C1of64   : Double =  1/64;
  CExp : array[3..6] of UInt64 =
  ( $3fc5555555554855, $3fa5555555553b54,
    $3f811112b12b282f, $3f56c16e86e89028 );
  CLog2ofE   : UInt64 = $3ff71547652b82fe;
  CLogEof2Hi : UInt64 = $3FE62E42FEFA4000;
  CLogEof2Lo : UInt64 = $3D48432A1B0E2634;
  C2powM1074p5 = $00000000000000001; // 2^(-1074.5)
  C2pow1023p5 = $7FE6A09E667F3BCD;

  C1024    : Double =  1024.0;
  C1023p5  : Double =  1023.5;
  CM1075   : Double = -1075;
  CM1074p5 : Double = -1074.5;
  CM1of2   : Double = -1/2;
  C1       : Double =  1.0;
  CInf     : Double = cInfinity;
  CSignBit : UInt64 = $8000000000000000;
  CSignBitPD: m128 = (Hi:$8000000000000000; Lo:$8000000000000000);
asm
        .PARAMS 6
        .SAVENV XMM6
        .SAVENV XMM7

        MOVSD   [RBP+060H], XMM0
        MOV     RCX, [RBP+060H]
        MOVAPS  XMM5, XMM0
        MOVSD   XMM4, CLog2ofE
        MOVSD   XMM3, C1of2
        MOVZX   EAX, WORD PTR [RBP+066H]
        XOR     EDX, EDX
        TEST    AX, 07FF0H
        JZ      @@One
        CMP     AX, DX
        JL      @@X_IS_NEGATIVE

@@X_IS_POSITIVE:
        MOV     RDX, ExpUpperLimit
        CMP     AX, 07FF0h
        JAE     @@X_IS_INF_OR_NAN
        CMP     AX, 04087H  // Top word of ExpUpperLimit is $4086
        JAE     @@Overflow

        CMP     RCX, RDX // if (X > ExpUpperLimit)
        JA      @@Overflow

        MULSD   XMM0, XMM4 // CLog2ofE
        ADDSD   XMM0, XMM3 // C1of2

        CVTTSD2SI EAX, XMM0
        CVTSI2SD  XMM6, EAX
        CMP     EAX, 03FFh
        JNG     @@REDUCTION0

@@X_IS_LARGE:
        MOVSD   XMM6, C1023p5
        MOV     RAX, C2pow1023p5
        MOV     [rbp+028h], RAX
        JMP     @@REDUCTION

@@X_IS_NEGATIVE:
        MOV     RDX, ExpLowerLimit
        CMP     AX, 0FFF0H
        JAE     @@X_IS_INF_OR_NAN
        CMP     AX,0C090H
        JAE     @@Zero

        CMP     RCX, RDX // if (X < ExpLowerLimit) - (Doulbe is sign-flag and absolute value)
        JA      @@Zero

        MULSD   XMM0, XMM4 // CLog2ofE
        MOVAPS  XMM7, XMM0
        SUBSD   XMM0, XMM3 // C1of2

        CVTTSD2SI EAX, XMM0
        CVTSI2SD  XMM6, EAX
        CMP     EAX, -0000003FEh
        JNL     @@REDUCTION0

@@X_IS_SMALL:
        MOVSD   XMM0, CM1075
        COMISD  XMM0, XMM7
        JNC     @@Zero
        MOVSD   XMM0, CM1074p5
        COMISD  XMM0, XMM7
        JC      @@X_IS_TOO_SMALL

        MOV     RAX,C2powM1074p5
        MOV     [RBP+028h], RAX
        MOVSD   XMM6, CM1074p5
        JMP     @@REDUCTION

@@X_IS_TOO_SMALL:
        MOV     ECX, -1022
        MOV     R9, 010000000000000h
        SUB     ECX, EAX
        SHR     R9, CL
        MOV     [RBP+028h], R9
        JMP     @@REDUCTION

@@One:  MOVSD   xmm0,C1
        JMP     @@exit

@@X_IS_INF_OR_NAN:
        MOV     RAX, [RBP+060h]
        MOV     RCX, 07FF0000000000000h
        CMP     RAX, RCX
        JZ      @@Overflow
        MOV     RCX, 0FFF0000000000000h
        CMP     RAX, RCX
        JNZ     @@Self

@@Zero: XORPD   XMM0, XMM0
        JMP     @@exit

@@Self: MOVAPS  XMM0, XMM5
        JMP     @@exit

@@Overflow:
        MOV     ECX, feeOVERFLOW
        MOV     DL, 1
        CALL    FRaiseExcept
        MOVSD   XMM0, CInf
        JMP     @@exit

@@REDUCTION0:
        ADD     EAX, 03FFh
        MOVSXD  RAX, EAX
        SHL     RAX, 034H
        MOV     [RBP+028h], RAX

@@REDUCTION:
        LEA     RDX, [CExp]

        MOVAPS  XMM7, XMM6
        MULSD   XMM7, CLogEof2Hi
        MOVAPS  XMM2, XMM5
        SUBSD   XMM2, XMM7
        MULSD   XMM6, CLogEof2Lo
        MOVAPS  XMM0, XMM2
        ADDSD   XMM0, XMM6
        MOVAPD  XMM1, CSignBitPD
        MOVAPS  XMM4, XMM0
        MULSD   XMM0, C64
        ANDPD   XMM4, XMM1
        ORPD    XMM3, XMM4
        ADDSD   XMM0, XMM3

        MOVSD   XMM1, C1of64
        CVTTSD2SI EAX, XMM0

        MOVAPS  XMM3, XMM6
        MOVSD   XMM4, QWORD PTR [RDX]
        MOVSD   XMM5, QWORD PTR [RDX+08H]
        MOVSD   XMM6, QWORD PTR [RDX+10H]
        MOVSD   XMM7, QWORD PTR [RDX+18H]

        CVTSI2SD XMM0, EAX
        MOVSXD  RDX, EAX
        ADD     RDX, RDX
        LEA     RCX, [ExpM1Iof64 + 400H]
        LEA     RCX, [RCX + RDX * 8]

        MULSD   XMM0, XMM1
        SUBSD   XMM2, XMM0
        MOVAPS  XMM0, XMM2
        ADDSD   XMM0, XMM3
        MOVAPS  XMM1, XMM0
        MULSD   XMM1, XMM0
        MULSD   XMM6, XMM1
        MULSD   XMM7, XMM1
        ADDSD   XMM4, XMM6
        MOVSD   XMM6, C1of2
        ADDSD   XMM5, XMM7
        MULSD   XMM5, XMM0
        ADDSD   XMM4, XMM5
        MULSD   XMM0, XMM4
        MOVSD   XMM4, [RCX]
        MOVSD   XMM5, [RCX + 08h]
        ADDSD   XMM6, XMM0
        MOVSD   XMM0, c1
        MULSD   XMM1, XMM6
        ADDSD   XMM3, XMM1


        MOVAPS  XMM1, XMM4
        ADDSD   XMM4, XMM0
        MOVAPS  XMM6, XMM4
        SUBSD   XMM4, XMM0
        SUBSD   XMM1, XMM4
        ADDSD   XMM1, XMM5
        MOVAPS  XMM7, XMM6
        ADDSD   XMM7, XMM1
        MOVAPS  XMM4, XMM7
        SUBSD   XMM7, XMM6
        SUBSD   XMM1, XMM7

        MOVSD   XMM0, [RBP+028H]
        MOVAPS  XMM7, XMM3
        MULSD   XMM3, XMM1
        MOVAPS  XMM6, XMM2
        MULSD   XMM6, XMM1
        ADDSD   XMM3, XMM6
        ADDSD   XMM3, XMM1
        MULSD   XMM7, XMM4
        ADDSD   XMM3, XMM7
        MULSD   XMM2, XMM4
        ADDSD   XMM3, XMM2
        ADDSD   XMM3, XMM4
        MULSD   XMM0, XMM3
@@Exit:
end;
{$ENDIF }

{$IF defined(ARITH_PUREPASCAL_EXT80)}
{$IF defined(ARITH_USE_LIBM)}
function libm_expm1l(x: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'expm1l';

function ExpMinus1(const X: Extended): Extended;
begin
                                        
  FClearExcept;
  Result := libm_expm1l(X);
  FCheckExcept;
end;
{$ENDIF defined(ARITH_USE_LIBM)}
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64)}
function ExpMinus1(const X: Double): Double;
var
  y, Y2,
  q0, q1,
  q, qHi, qLo,
  pLo, pHi  : Double;
  I : Integer;
  W: Word;
type
  TWords = Array[0..3] of Word;
  PWords = ^TWords;
const
  CExp : array[3..6] of UInt64 =
  ( $3fc5555555554855, $3fa5555555553b54,
    $3f811112b12b282f, $3f56c16e86e89028 );
  C64 : Double = 64.0;
  C1of2  : Double= 1/2;
  C1of64 : Double = 1/64;
  CLogEof2 : UInt64= $3fe62e42fefa39ef; // Ln(2);
  CZero : Double = 0.0;
  C1 : Double = 1.0;
begin
  if (Abs(x) = 0.0) then Exit(0.0); // +/-Zero
  W := PWords(@X)^[3] and $7FF0;
  if W = 0 then Exit(X) // Denormal
  else if (W = $7FF0) or (Abs(X) >= PDouble(@CLogEof2)^) then
    Result := Exp(X) - 1
  else
  begin
    if X >= 0 then        // ABs(X) * 64 <= 22.18..
      I := Trunc(X * C64 + C1of2)
    else
      I := Trunc(X * C64 - C1of2);

    y := X - I * C1of64; // abs(y) <= 1/128
    y2 := y * y;

    q0 :=           PDouble(@CExp[6])^;
    q1 :=           PDouble(@CExp[5])^;
    q0 := q0 * y2 + PDouble(@CExp[4])^;
    q1 := q1 * y2 + PDouble(@CExp[3])^;

    q0 := q0 * y2;
    q1 := q1 * y;
    q := q0 + q1;
    q := q + c1of2;

    qLo := q * y2;
    qHi := y;

    pHi :=  PDouble(@ExpM1Iof64[I, cHi])^;
    pLo :=  PDouble(@ExpM1Iof64[I, cLo])^;

    Result := 0;
    Result := Result + pLo;
    Result := Result + qLo;
    Result := Result + pHi * (qHi + qLo);
    Result := Result + qHi;
    Result := Result + pHi;
  end;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
function libm_expm1(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'expm1';

function ExpMinus1(const X: Double): Double;
begin
  FClearExcept;
  Result := libm_expm1(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}
function ExpMinus1(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
var
  D: Double;
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        FLDL2E              { y := x*log2e;      }
        FMUL
        FLD     ST(0)
        FABS
        FLD1
        FCOMPP
        FSTSW   AX
        SAHF
        JAE     @@1

        FLD     ST(0)       { i := round(y);     }
        FRNDINT
        FSUB    ST(1), ST   { f := y - i;        }
        FXCH    ST(1)       { z := 2**f          }
        F2XM1
        FLD1
        FADD
        FSCALE              { result := z * 2**i }
        FSTP    ST(1)
        FLD1
        FSUBP
        JMP     @@EXIT
@@1:    F2XM1
@@EXIT:
        FSTP    qword ptr D { Force save to Double to detect overflow. }
  end;
  Result := D;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        FLDL2E              { y := x*log2e;      }
        FMUL
        FLD     ST(0)
        FABS
        FLD1
        FCOMPP
        FSTSW   AX
        SAHF
        JAE     @@1

        FLD     ST(0)       { i := round(y);     }
        FRNDINT
        FSUB    ST(1), ST   { f := y - i;        }
        FXCH    ST(1)       { z := 2**f          }
        F2XM1
        FLD1
        FADD
        FSCALE              { result := z * 2**i }
        FSTP    ST(1)
        FLD1
        FSUBP
        JMP     @@EXIT
@@1:    F2XM1
@@EXIT:
end;
{$ENDIF}
{$ELSEIF defined(ARITH_X64_SSE)}
function ExpMinus1(const X: Double): Double;
type
  m128 = record
    Hi, Lo : UInt64
  end align 16;
const
  CExp : array[3..6] of UInt64 =
  ( $3fc5555555554855, $3fa5555555553b54,
    $3f811112b12b282f, $3f56c16e86e89028 );
  C64 : Double = 64.0;
  C1of2  : Double= 1/2;
  C1of64 : Double = 1/64;
  CLogEof2 : UInt64= $3fe62e42fefa39ef; // Ln(2);
  CZero : Double = 0.0;
  C1 : Double = 1.0;
  CSignBitPD: m128 = (Hi:$8000000000000000; Lo:$8000000000000000);
asm
        .PARAMS 1
        .SAVENV XMM6
        .SAVENV XMM7

        MOVSD   [RBP+050H],XMM0
        MOVZX   EAX, WORD PTR [RBP+056H]

        MOVAPD  XMM2, CSignBitPD
        MOVAPS  XMM4, XMM2
        XORPD   XMM5, XMM5 // Zero
        MOVAPS  XMM6, XMM0
        ANDNPD  XMM2, XMM0 // Abs(X) : XMM2 := (Not XMM2) and XMM0

        UCOMISD xmm0, xmm5 // 0.0
        JPE     @@01
        JZ      @@Zero

@@01:
        AND     EAX, 07FF0H // Is X Denormal ?
        JZ      @@Exit
        CMP     AX, 07FF0H
        JE      @@UseEXP
        COMISD  XMM2, CLogEof2
        JC      @@ExpMinusOne

@@UseEXP:
        MOVSD   XMM7, C1
        CALL    Exp
        SUBSD   XMM0, XMM7
        JMP     @@Exit

@@Zero:
        MOVAPS  XMM0, XMM5 // 0.0
        JMP     @@Exit

@@ExpMinusOne:
        ANDPD   XMM4, XMM6 // XMM4 has sign bit.

        MOVSD   XMM7, C1of2
        ORPD    XMM7, XMM4

        MULSD   XMM6, C64
        ADDSD   XMM6, XMM7
        CVTTSD2SI EAX, XMM6

        LEA     RDX, [CExp]
        CVTSI2SD XMM7, EAX
        MOVSXD  RAX, EAX
        ADD     RAX, RAX
        LEA     RCX, [ExpM1Iof64 + 400H]
        LEA     RCX, [RCX + RAX * 8]

        MULSD   XMM7, C1of64
        MOVSD   XMM4, QWORD PTR [rdx]
        MOVSD   XMM5, QWORD PTR [rdx + 08H]
        SUBSD   XMM0, XMM7
        MOVAPS  XMM1, XMM0
        MULSD   XMM0, XMM0
        MOVSD   XMM6, QWORD PTR [rdx + 10H]
        MOVSD   XMM7, QWORD PTR [rdx + 18H]
        MOVSD   XMM2,[C1of2]

        MULSD   XMM7, XMM0
        MULSD   XMM6, XMM0
        ADDSD   XMM7, XMM5
        ADDSD   XMM6, XMM4

        MOVSD   XMM3, [RCX]
        MOVSD   xmm5, [RCX+08h]

        MULSD   XMM7, XMM0
        MULSD   XMM6, XMM1
        ADDSD   XMM7, XMM6
        ADDSD   XMM7, XMM2
        MULSD   XMM7, XMM0

        ADDSD   XMM5, XMM7
        MOVAPS  XMM2, XMM1
        ADDSD   XMM2, XMM7
        MOVAPS  XMM0, XMM3
        MULSD   XMM0, XMM2
        ADDSD   XMM0, XMM5
        ADDSD   XMM0, XMM1
        ADDSD   XMM0, XMM3
@@Exit:
end;
{$ENDIF }

{$IF    defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function pRemDouble(D: Double; var X, Y: Double): integer;
var
  PiOf2H, PiOf2M, PiOf2L : Double;
  lowestPart: double;
const
  PiOf2Hi  : UInt64 = $3FF921FB54442D18; // Pi/2 : first 53bits
  PiOf2Mi  : UInt64 = $3C91A62633145C04; // Pi/2 : Middle 53bits
  PiOf2Lo  : UInt64 = $396707344A409382; // Pi/2 : Lowest 53bits
  ExpOffset1 =  54; // $3FF - $3C9
  ExpOffset2 = 105; // $3FF - $396

  procedure adddouble(const x: double; var rh, rl : double); inline;
  var
    hh, hl: double;
    temp : double;
  begin
    hh := x + rh;
    temp := hh - x;
    hl := (x - (hh - temp)) + (rh - temp);
    hl := hl + rl;
    rh := hh + hl;
    rl := hl - (rh - hh);
  end;

  procedure AddDouble2(const xh, xl: Double; var rh, rl : Double); inline;
  var
    hh, hl: Double;
    temp : double;
  begin
    hh := xh + rh;
    temp := hh - xh;
    hl := (xh - (hh - temp)) + (rh - temp);
    hl := hl + xl + rl;
    rh := hh + hl;
    rl := hl - (rh - hh);
  end;

  // 3*Double precision reduction
  procedure ReductionPi2n(n: integer);
  var
    X0,
    T0, T1, T2, T3: Double;
  begin
    PDoubleRec(@PiOf2H).Exp := n + $3FF;
    PDoubleRec(@PiOf2M).Exp := n + $3FF - ExpOffset1;
    PDoubleRec(@PiOf2L).Exp := n + $3FF - ExpOffset2;

    T0 := -PiOf2L;
    T1 := 0;
    AddDouble( lowestPart, T0, T1);
    AddDouble(-PiOf2M,     T0, T1);
    AddDouble( Y,          T0, T1); // T0&1 - partial sum

    T2 := T0;
    T3 := T1;
    AddDouble(-PiOf2H, T0, T1);
    AddDouble( X,      T0, T1); // T0&1 - X&Y

    X0 := X;
    X := T0;
    Y := T1;

    T0 := -T0;
    T1 := -T1;
    AddDouble( X0,     T0, T1);
    AddDouble(-PiOf2H, T0, T1);
    AddDouble2(T2,T3,  T0, T1);

    lowestPart := T0;
  end;

const
  nPi2High  : UInt64 = $BFF921FB54400000; // Pi/2 : Upper 32bit.
  nPi2Low   : UInt64 = $BDD0B4611A600000; // Pi/2 : Lower 32bit
  nPi2Small : UInt64 = $BBA3198A2E037073; // Pi - Pi2High - Pi2Low
  TwoOfPi  : UInt64 = $3FE45F306DC9C883; // 2 / Pi
  TwoPow22 : UInt64 = $4150000000000000; // 2 ^ 22
  TwoPow54 : UInt64 = $4350000000000000; // 2 ^ 54
var
  D2 : Double;
  Q: Int64;
  n: integer;
  hh, hl,
  pHi, pLow, pSmall,
  X2, Y2,
  temp : double;
begin
  Result := 0;
  X := D;
  Y := 0;

  D2 := Abs(D);
  if D2 <= Pi / 4 then Exit
  else if D2 <= 5 * Pi/4 then
  begin
    if D2 <= 3 * Pi/4 then Q := 1
    else Q := 2;
    if D < 0 then Q := -Q;

    pHi := Q * PDouble(@PiOf2Hi)^;
    pLow := Q * PDouble(@PiOf2Mi)^;
    pSmall := Q * PDouble(@PiOf2Lo)^;

    X2 := D - pHi;
    X := X2 - pLow;
    Y := - pLow - (X - X2);
    Y := Y - pSmall;
  end
  else if D2 < PDouble(@TwoPow22)^ then
  begin
    // Reduction for small/mid number (up to 2^22)
    Q := Trunc((D2 - Pi/4) * PDouble(@TwoOfPi)^) + 1;

    if D < 0 then Q := -Q;
    pHi := Q * PDouble(@nPi2High)^;
    pLow := Q * PDouble(@nPi2Low)^;
    pSmall := Q * PDouble(@nPi2Small)^;

    X2 := D + pHi;

    hh := pLow + X2;
    temp := hh - pLow;
    hl := (pLow - (hh - temp)) + (X2 - temp);
    X2 := hh + hl;
    Y2 := hl - (X2 - hh);

    hh := pSmall + X2;
    temp := hh - pSmall;
    hl := (pSmall - (hh - temp)) + (X2 - temp);
    hl := hl + Y2;
    X2 := hh + hl;
    Y2 := hl - (X2 - hh);

    X := X2;
    Y := Y2;
  end
  else
  begin
    // Reduction for large numbber between 2^22 to 2^53
    n := PDoubleRec(@D2).Exp - $3FF;
    PUInt64(@PiOf2H)^ := PiOf2Hi;
    PUInt64(@PiOf2M)^ := PiOf2Mi;
    PUInt64(@PiOf2L)^ := PiOf2Lo;

    X := D2;
    Y := 0;
    lowestPart := 0;

    while n >= 3 do
    begin
      PDoubleRec(@PiOf2H).Exp := n + $3FF;
      if PiOf2H < X then
        ReductionPi2n(n);
      Dec(n);
    end;

    Q := 0;
    while n >= 0 do
    begin
      PDoubleRec(@PiOf2H).Exp := n + $3FF;
      if PiOf2H < X then
      begin
        Q := Q or (1 shl n);
        ReductionPi2n(n);
      end;
      Dec(n);
    end;

    if X > Pi/4 then
    begin
      Q := Q + 1;
      ReductionPi2n(0);
    end;
    if D < 0 then
    begin
      X := -X;
      Y := -Y;
      Q := -Q;
    end;
  end;
  Result := Q and 3;
end;
{$ENDIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}

{$IFDEF ARITH_PUREPASCAL_EXT80}
function pRemExtended(D: Extended; var R: Extended): integer;
const
  Pi2High = 1.5707963267341256;    // 3FF921FB54400000
  Pi2Low  = 6.077100506303966e-11; // 3DD0B4611A600000
  TwoOfPi = 0.636619772367581343;   // $3FE45F306DC9C883
var
  T : Double;
begin
  Result := 0;
  R := D;

  if Abs(D) <= Pi / 4 then
    Exit

  else if Abs(D) <= 3 * Pi/4 then Result := 1
  else if Abs(D) <= 5 * Pi/4 then Result := 2
  else
    Result := Trunc((Abs(D) - Pi/4) * TwoOfPi) + 1;

  if D < 0 then Result  := -Result;

  T := D - Pi2High * Result;
  R := T - Pi2Low * Result;
end;
{$ENDIF ARITH_PUREPASCAL_EXT80}

{$IF    defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function pCosDouble(const x, y: Double) : Double;
const
  CCos : ARRAY[0..5] OF UINT64 =
  ( $BDA8FA6A8A7D84DF,
    $3E21EE9DC12C88AC,
    $BE927E4F7F1EE922,
    $3EFA01A019C8F945,
    $BF56C16C16C15018,
    $3FA555555555554B );
var
  r1, r2, s, t, u, v,
  L, L1, L2,
  D2, D4 : Double;
begin
  D2 := x * x;
  D4 := D2 * D2;

  L1 :=           PDouble(@CCos[0])^;
  L2 :=           PDouble(@CCos[1])^;
  L1 := L1 * D4 + PDouble(@CCos[2])^;
  L2 := L2 * D4 + PDouble(@CCos[3])^;
  L1 := L1 * D4 + PDouble(@CCos[4])^;
  L2 := L2 * D4 + PDouble(@CCos[5])^;

  L := L2 + L1 * D2;
  L := L * D4;

  s := 1.0;
  t := D2 * 0.5;
  u := s - t;
  v := u - s;
  r1 := t + v;

  r2 := x * y;
  r2 := L - r2;
  r2 := r2 - r1;
  Result := u + r2;
end;
{$ENDIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}

{$IF    defined(ARITH_PUREPASCAL_EXT80)}
function pCosExtended(const D: extended) : extended;
const
  CCos : array[0..7] of TExtended80RecW =
  ( (Words:($0000, $0000, $0000, $0000, $0000)),
    (Words:($FF10, $FFFF, $FFFF, $FFFF, $BFFD)),
    (Words:($AA60, $AAA9, $AAAA, $AAAA, $3FFA)),
    (Words:($FE00, $09CC, $60B6, $B60B, $BFF5)),
    (Words:($8000, $9377, $00CD, $D00D, $3FEF)),
    (Words:($0000, $C3A0, $7B99, $93F2, $BFE9)),
    (Words:($0000, $F000, $BB10, $8F74, $3FE2)),
    (Words:($0000, $0000, $8030, $C7BD, $BFDA)) );
var
  I: Integer;
  D2 : extended;
begin
  D2 := D * D;
  Result := PExtended(@CCos[High(CCos)])^;
  for I := High(CCos)-1 downto 0 do Result := Result * D2 + PExtended(@CCos[I])^;
end;
{$ENDIF defined(ARITH_PUREPASCAL_EXT80)}

{$IF    defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function pSinDouble(const x,y: Double) : Double;
const
  CSin : array[0..7] of UInt64 =
  ( $3DE5E0A28E7FA626,
    $BE5AE60081AA5E86,
    $3EC71DE37936614A,
    $BF2A01A019E80E58,
    $BC29D73D633765DD, $3F81111111110BA5,
    $3C6A74A934AD37D5, $BFC5555555555555 );
var
  D2, D3, D4,
  L, L1, L2: Double;
begin
  D2 := x * x;
  D4 := D2 * D2;
  D3 := D2 * x;

  L1 :=           PDouble(@CSin[0])^;
  L2 :=           PDouble(@CSin[1])^;
  L1 := L1 * D4 + PDouble(@CSin[2])^;
  L2 := L2 * D4 + PDouble(@CSin[3])^;

  L1 := L1 * D4 + PDouble(@CSin[4])^; // C1_Low
  L1 := L1      + PDouble(@CSin[5])^; // C1_Hi
  L2 := L2 * D4 + PDouble(@CSin[6])^; // C0_Low
  L  := L1 * D2 + L2;
  L  := L       + PDouble(@CSin[7])^; // C0_Hi

  L := L * D3;
  L := L + (1 - D2 *0.5) * y;

  Result := x + L;
end;
{$ENDIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}

{$IF    defined(ARITH_PUREPASCAL_EXT80) and not defined(ARITH_USE_LIBM)}
function pSinExtended(const D: extended) : extended;
const
  CSin : array[0..7] of TExtended80RecW =
  ( (Words:($0000, $0000, $0000, $0000, $0000)),
    (Words:($AAD8, $AAAA, $AAAA, $AAAA, $BFFC)),
    (Words:($00C0, $8889, $8888, $8888, $3FF8)),
    (Words:($3000, $0E4B, $00D0, $D00D, $BFF2)),
    (Words:($0000, $21B8, $1D2C, $B8EF, $3FEC)),
    (Words:($0000, $8C00, $2C81, $D732, $BFE5)),
    (Words:($0000, $0000, $450C, $B092, $3FDE)),
    (Words:($0000, $0000, $D500, $D645, $BFD6)) );
var
  I: Integer;
  D2 : extended;
begin
  D2 := D * D;
  Result := PExtended(@CSin[High(CSin)])^;
  for I := High(CSin)-1 downto 0 do Result := Result * D2 + PExtended(@CSin[I])^;
  Result := D * Result;
end;
{$ENDIF defined(ARITH_PUREPASCAL_EXT80)}

{$IF defined(ARITH_PUREPASCAL_EXT80)}
{$IF defined(ARITH_USE_LIBM)}
function libm_cosl(const X: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'cosl';

function Cos(const X: Extended): Extended;
begin
  FClearExcept;
  Result := libm_cosl(X);
  FCheckExcept;
end;
{$ELSE !defined(ARITH_USE_LIBM)}
function Cos(const X: Extended): Extended;
var
  Q: integer;
  R: Extended;
begin
  if Abs(x) < Pi/4 then
    Result := pCosExtended(X)
  else
  begin
    Q := pRemExtended(X, R);
    case Q and $3 of
      0: Result :=  pCosExtended(R);
      1: Result := -pSinExtended(R);
      2: Result := -pCosExtended(R);
      3: Result :=  pSinExtended(R);
      else Result := 0; // avoid warning W1035 Return value of function '%s' might be undefined
    end;
  end;
end;
{$ENDIF defined(ARITH_USE_LIBM)}
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function Cos(const X: Double): Double;
var
  Q: integer;
  Y,Z: Double;
begin
  if Abs(x) < Pi/4 then
    Result := pCosDouble(X, 0)
  else
  begin
    Q := pRemDouble(X, Y, Z);
    case Q of
      0: Result :=  pCosDouble(Y, Z);
      1: Result := -pSinDouble(Y, Z);
      2: Result := -pCosDouble(Y, Z);
      3: Result :=  pSinDouble(Y, Z);
      else Result := 0; // avoid warning W1035 Return value of function '%s' might be undefined
    end;
  end;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
// double  cos( double );
function libm_cos(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'cos';

function Cos(const X: Double): Double;
begin
  FClearExcept;
  Result := libm_cos(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

function Cos(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        FCOS
        FSTP    tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        FCOS
        FWAIT
end;
{$ENDIF}
{$ENDIF }

{$IF     defined(ARITH_PUREPASCAL_EXT80)}
{$IF defined(ARITH_USE_LIBM)}
function libm_sinl(x: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'sinl';

function Sin(const X: Extended): Extended;
begin
  FClearExcept;
  Result := libm_sinl(X);
  FCheckExcept;
end;
{$ELSE}
function Sin(const X: Extended): Extended;
var
  Q: integer;
  R: Extended;
begin
  if Abs(x) < Pi/4 then
    Result := pSinExtended(X)
  else
  begin
    Q := pRemExtended(X, R);
    case Q and $3 of
      0: Result :=  pSinExtended(R);
      1: Result :=  pCosExtended(R);
      2: Result := -pSinExtended(R);
      3: Result := -pCosExtended(R);
      else Result := 0; // avoid warning W1035 Return value of function '%s' might be undefined
    end;
  end;
end;
{$ENDIF}
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function Sin(const X: Double): Double;
var
  Q: integer;
  Y,Z: Double;
begin
  if Abs(x) < Pi/4 then
    Result := pSinDouble(X, 0)
  else
  begin
    Q := pRemDouble(X, Y, Z);
    case Q of
      0: Result :=  pSinDouble(Y, Z);
      1: Result :=  pCosDouble(Y, Z);
      2: Result := -pSinDouble(Y, Z);
      3: Result := -pCosDouble(Y, Z);
      else Result := 0; // avoid warning W1035 Return value of function '%s' might be undefined
    end;
  end;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
function libm_sin(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'sin';

function Sin(const X: Double): Double;
begin
  FClearExcept;
  Result := libm_sin(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

function Sin(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        FSIN
        FSTP    tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        FSIN
        FWAIT
end;
{$ENDIF}
{$ENDIF }

{$IF defined(ARITH_PUREPASCAL_EXT80)}
{$IF defined(ARITH_USE_LIBM)}
function libm_tanl(x: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'tanl';

function Tangent(const X: Extended): Extended;
begin
  FClearExcept;
  Result := libm_tanl(X);
  FCheckExcept;
end;
{$ELSE !defined(ARITH_USE_LIBM)}
function Tangent(const X: Extended): Extended;
var
  Q: integer;
  R: Extended;
begin
  if Abs(x) < Pi/4 then
    Result := pSinExtended(X) / pCosExtended(X)
  else
  begin
    Q := pRemExtended(X, R);
    case Q and $3 of
      0: Result :=  pSinExtended(R) /  pCosExtended(R);
      1: Result :=  pCosExtended(R) / -pSinExtended(R);
      2: Result := -pSinExtended(R) / -pCosExtended(R);
      3: Result := -pCosExtended(R) /  pSinExtended(R);
      else Result := 0; // avoid warning W1035 Return value of function '%s' might be undefined
    end;
  end;
end;
{$ENDIF defined(ARITH_USE_LIBM)}
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function Tangent(const X: Double): Double;
var
  Q: integer;
  Y,Z: Double;
begin
  if Abs(x) < Pi/4 then
    Result := pSinDouble(X,0) / pCosDouble(X,0)
  else
  begin
    Q := pRemDouble(X, Y, Z);
    case Q of
      0: Result :=  pSinDouble(Y, Z) /  pCosDouble(Y, Z);
      1: Result :=  pCosDouble(Y, Z) / -pSinDouble(Y, Z);
      2: Result := -pSinDouble(Y, Z) / -pCosDouble(Y, Z);
      3: Result := -pCosDouble(Y, Z) /  pSinDouble(Y, Z);
      else Result := 0; // avoid warning W1035 Return value of function '%s' might be undefined
    end;
  end;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
function libm_tan(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'tan';

function Tangent(const X: Double): Double;
begin
  FClearExcept;
  Result := libm_tan(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

function Tangent(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD    tbyte ptr X
        FPTAN
        FSTP   ST(0)      { FPTAN pushes 1.0 after result }
        FSTP   tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD    tbyte ptr X
        FPTAN
        FSTP   ST(0)      { FPTAN pushes 1.0 after result }
        FWAIT
end;
{$ENDIF}
{$ENDIF }

{$IF     defined(ARITH_PUREPASCAL_EXT80)}
procedure SineCosine(const X: Extended; var Sin, Cos: Extended);
begin
  Sin := System.Sin(X);
  Cos := System.Cos(X);
end;
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
procedure SineCosine(const X: Double; var Sin, Cos: Double);
var
  Q: integer;
  Y,Z: Double;
begin
  if Abs(x) < Pi/4 then
  begin
    Sin := pSinDouble(X, 0);
    Cos := pCosDouble(X, 0);
  end
  else
  begin
    Q := pRemDouble(X, Y, Z);
    case Q of
      0:
        begin
          Sin :=  pSinDouble(Y, Z);
          Cos :=  pCosDouble(Y, Z);
        end;
      1:
        begin
          Sin :=  pCosDouble(Y, Z);
          Cos := -pSinDouble(Y, Z);
        end;
      2:
        begin
          Sin := -pSinDouble(Y, Z);
          Cos := -pCosDouble(Y, Z);
        end;
      3:
        begin
          Sin := -pCosDouble(Y, Z);
          Cos :=  pSinDouble(Y, Z);
        end;
    end;
  end;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
procedure SineCosine(const X: Double; var Sin, Cos: Double);
begin
  FClearExcept;
  Sin := System.Sin(X);
  Cos := System.Cos(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

procedure SineCosine(const X: Extended; var Sin, Cos: Extended);
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        MOV     EDX, Cos
        MOV     EAX, Sin
        FSINCOS
        FSTP    tbyte ptr [edx]    // Cos
        FSTP    tbyte ptr [eax]    // Sin
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        FSINCOS
        FSTP    tbyte ptr [edx]    // Cos
        FSTP    tbyte ptr [eax]    // Sin
        FWAIT
end;
{$ENDIF}
{$ENDIF }

{$IF     defined(ARITH_PUREPASCAL_EXT80)}
function pLnXP1(frac: Extended) : Extended;
type
  TExtRec = packed record
    F: UInt64;
    E: UInt16;
  end;
const
  CLn : array[0..8] of TExtRec =
  ( (F: $0000000000000000; E: $0000),
    (F: $AAAAAAAAAAAAAD00; E: $3FF9),
    (F: $CCCCCCCCCCD2E800; E: $3FF4),
    (F: $9249249230E9C000; E: $3FF0),
    (F: $E38E3912EA680000; E: $3FEB),
    (F: $BA2E75AB12000000; E: $3FE7),
    (F: $9D8F6569C8000000; E: $3FE3),
    (F: $87C06B7E80000000; E: $3FDF),
    (F: $8723D5A800000000; E: $3FDB) );
var
  y, y2 : extended;
  I : integer;
begin
  y := frac /(frac + 2);
  y2 := y*y;
  Result := PExtended(@CLn[High(CLn)])^;
  for I := High(CLn)-1 downto 0 do
    Result := Result * y2 + PExtended(@CLn[I])^;
  Result := (Result * 2 * y) + 2 * y;
end;
{$ENDIF }

{$IF     defined(ARITH_PUREPASCAL_EXT64)}
function pLnXP1Double(frac: Double) : Double;
const
  CLn : array[0..11] of UInt64 =
  ( $3fb0c835bd538f8c,
    $3fa988ab1ef94f29,
    $3fae3c098f53b5ee,
    $3fb11053fca919d4,
    $3fb3b140d1e4050f,
    $3fb745d159460dd7,
    $3fbc71c71cbb0290,
    $3fc249249248f262,
    $3c602e384367005f, $3fc99999999999b4,
    $3c750aaac32dac90, $3fd5555555555555 );
var
  Y, Y2, Y4: Double;
  R1, R2, F1, F2, F3: Double;
begin
  Y := frac /(frac + 2.0);
  Y2 := Y * Y;
  Y4 := Y2 * Y2;

  R1 :=         + PDouble(@CLn[0])^;
  R2 :=         + PDouble(@CLn[1])^;
  R1 := R1 * Y4 + PDouble(@CLn[2])^;
  R2 := R2 * Y4 + PDouble(@CLn[3])^;
  R1 := R1 * Y4 + PDouble(@CLn[4])^;
  R2 := R2 * Y4 + PDouble(@CLn[5])^;
  R1 := R1 * Y4 + PDouble(@CLn[6])^;
  R2 := R2 * Y4 + PDouble(@CLn[7])^;
  R1 := R1 * Y4 + PDouble(@CLn[8])^;
  R1 := R1      + PDouble(@CLn[9])^;
  R2 := R2 * Y4 + PDouble(@CLn[10])^;
  R2 := R2 + R1 * Y2;
  R2 := R2      + PDouble(@CLn[11])^;

  F1 := frac * 0.5;
  F2 := frac * F1;
  F3 := F2 * F1;
  Result := ((((R2 * 2 * Y2 * Y) + F3)- F2) - Y * F3)+ frac;
end;
{$ELSEIF defined(ARITH_X64_SSE)}
function pLnXP1Double(frac: Double) : Double;
const
  CLn : array[0..11] of UInt64 =
  ( $3fb0c835bd538f8c,
    $3fa988ab1ef94f29,
    $3fae3c098f53b5ee,
    $3fb11053fca919d4,
    $3fb3b140d1e4050f,
    $3fb745d159460dd7,
    $3fbc71c71cbb0290,
    $3fc249249248f262,
    $3c602e384367005f, $3fc99999999999b4,
    $3c750aaac32dac90, $3fd5555555555555 );
const
  C2 : Double= 2.0;
  C1of2 : Double = 0.5;
asm
        .SAVENV XMM6
        .SAVENV XMM7

        LEA     RCX,  [C2]
        MOVAPD  XMM1, XMM0
        ADDSD   XMM0, [RCX]
        LEA     RDX,  [C1of2]
        MOVAPD  XMM2, XMM1
        DIVSD   XMM2, XMM0
        LEA     RAX,  [CLn]
        MOVAPD  XMM0, XMM1
        MULSD   XMM0, [RDX]
        MOVAPD  XMM4, XMM1
        MULSD   XMM4, XMM0
        MOVAPD  XMM3, XMM4
        MULSD   XMM3, XMM0
        MOVSD   XMM6, [RAX]
        MOVSD   XMM0, [RAX + 008H]
        MOVAPD  XMM5, XMM2
        MULSD   XMM5, XMM2
        MOVAPD  XMM7, XMM5
        MULSD   XMM7, XMM5
        MULSD   XMM6, XMM7
        MULSD   XMM0, XMM7
        ADDSD   XMM6, [RAX + 010H]
        ADDSD   XMM0, [RAX + 018H]
        MULSD   XMM6, XMM7
        MULSD   XMM0, XMM7
        ADDSD   XMM6, [RAX + 020H]
        ADDSD   XMM0, [RAX + 028H]
        MULSD   XMM6, XMM7
        MULSD   XMM0, XMM7
        ADDSD   XMM6, [RAX + 030H]
        ADDSD   XMM0, [RAX + 038H]
        MULSD   XMM6, XMM7
        ADDSD   XMM6, [RAX + 040H]
        ADDSD   XMM6, [RAX + 048H]
        MULSD   XMM0, XMM7
        ADDSD   XMM0, [RAX + 050H]
        MULSD   XMM6, XMM5
        ADDSD   XMM0, XMM6
        ADDSD   XMM0, [RAX + 058H]
        MULSD   XMM0, [RCX]
        MULSD   XMM0, XMM5
        MULSD   XMM0, XMM2
        MULSD   XMM2, XMM3
        ADDSD   XMM0, XMM3
        SUBSD   XMM0, XMM4
        SUBSD   XMM0, XMM2
        ADDSD   XMM0, XMM1
end;
{$ENDIF }

{$IF defined(ARITH_USE_LIBM) and defined(ARITH_PUREPASCAL_EXT80)}
function libm_logl(x: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'logl';

function Ln(const X: Extended): Extended;
begin
  Result := X; // supress warning
  case PExtendedRec(@X).SpecialType of
    TFloatSpecial.fsNInf, TFloatSpecial.fsNegative, TFloatSpecial.fsNDenormal:
      Error(reInvalidOp);
    TFloatSpecial.fsZero, TFloatSpecial.fsNZero:
      Error(reZeroDivide);
    TFloatSpecial.fsInf,
    TFloatSpecial.fsNaN:
      Exit(X);
    else
    begin
      FClearExcept;

      Result := libm_logl(X);

      FCheckExcept;
    end;
  end;
end;
{$ELSEIF     defined(ARITH_PUREPASCAL_EXT80)}
function Ln(const X: Extended): Extended;
const
  Ln2 = 0.69314718055994530941723212145818; // Ln(2)
var
  frac : UInt64;
  exponent : integer;
  E : Extended;
begin
  Result := X; // supress warning
  case PExtendedRec(@X).SpecialType of
    TFloatSpecial.fsNInf, TFloatSpecial.fsNegative, TFloatSpecial.fsNDenormal:
      Error(reInvalidOp);
    TFloatSpecial.fsZero, TFloatSpecial.fsNZero:
      Error(reZeroDivide);
    TFloatSpecial.fsInf,
    TFloatSpecial.fsNaN:
      Exit(X);
    TFloatSpecial.fsDenormal, TFloatSpecial.fsPositive:
    begin
      frac := PExtendedRec(@X).Mantissa; // (0.5 * 2^64)<= frac < (1 * 2^64)
      exponent := PExtendedRec(@X).Exponent + 1;

      if frac <= $B504F333F9DE6480 then // sqrt(0.5) * 2^64
      begin
        // (0.5 .. 0.7 (sqrt(2)/2)) * 2 - 1 => (0.0 .. 0.4 (SQRT(2) - 1))
        PExtendedRec(@E).BuildUp(False, frac, 0);
        exponent := exponent - 1;
      end
      else
      begin
        // (0.7 (sqrt(2)/2) .. 1.0) - 1 => ( 0.3 .. 0.0)
        PExtendedRec(@E).BuildUp(False, frac, -1);
      end;

      E := E - 1;
      Result := pLnXP1(E) + exponent * Ln2;
    end;
  end;
end;
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function Ln(const X: Double): Double;
const
  Ln2Hi: UInt64  = $3FE62E42FC000000; // High 27bits of Ln(2)
  Ln2Lo: UInt64  = $3E37D1CF79ABC9E4; // rest of Ln(2)
var
  X2: Double;
  frac : UInt64;
  exponent : integer;
  E: Double;
  U: UInt64;
  W: Word;
begin
  X2 := X;
  U := PUInt64(@X2)^;
  W := PDoubleRec(@X2)^.Words[3];
  if W >= $8000 then
  begin
    if U = $8000000000000000 then
    begin
      FRaiseExcept(feeDIVBYZERO);
      Exit(cNInfinity);
    end
    else if U <= $FFF0000000000000 then
      FRaiseExcept(feeINVALID);
    Exit(cNaN);
  end
  else
  begin
    if U = $0000000000000000 then
    begin
      FRaiseExcept(feeDIVBYZERO);
      Exit(cNInfinity);
    end
    else if U < $7FF0000000000000 then
    begin
      W := (W and $7FF0) shr 4;
      if W = 0 then // Denormal
      begin
        frac := U and $000FFFFFFFFFFFFF;
        exponent := -1022;
        if frac and (UInt64($FFFFFFFF) shl 21) = 0 then
        begin
          frac := frac shl 32;
          Dec(exponent, 32);
        end;
        if frac and (UInt64($FFFF) shl 37) = 0 then
        begin
          frac := frac shl 16;
          Dec(exponent, 16);
        end;
        if frac and (UInt64($FF) shl 45) = 0 then
        begin
          frac := frac shl 8;
          Dec(exponent, 8);
        end;
        if frac and (UInt64($F) shl 49)= 0 then
        begin
          frac := frac shl 4;
          Dec(exponent, 4);
        end;
        if frac and (UInt64($3) shl 51) = 0 then
        begin
          frac := frac shl 2;
          Dec(exponent, 2);
        end;
        if frac and (UInt64(1) shl 52) = 0 then
        begin
          frac := frac shl 1;
          Dec(exponent, 1);
        end;
        frac := frac and $000FFFFFFFFFFFFF;
      end
      else
      begin
        frac := U and $000FFFFFFFFFFFFF;
        exponent := W - $3FF;
      end;

      if frac <= $6A09E667F3BCC then // sqrt(0.5) * 2^53
      begin
        // (0.5 .. 0.7 (sqrt(2)/2)) * 2 - 1 => (0.0 .. 0.4 (SQRT(2) - 1))
        PUInt64(@E)^ := $3FF0000000000000 + frac;
      end
      else
      begin
        // (0.7 (sqrt(2)/2) .. 1.0) - 1 => (-0.3 .. 0.0)
        PUInt64(@E)^ := $3FE0000000000000 + frac;
        Inc(exponent);
      end;
      Result := pLnXP1Double(E-1) + exponent * PDouble(@Ln2Lo)^;
      Result := Result + exponent * PDouble(@Ln2Hi)^;
    end
    else if U = $7FF0000000000000 then
    begin
      Exit(cInfinity);
    end
    else
      Exit(cNaN);
  end;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
// double log ( double );
function libm_log(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'log';

function Ln(const X: Double): Double;
const
  DEXP  = $7FF0000000000000; // Exponential part
  DSIGN = $8000000000000000; // Sign bit.
  DNINF = $FFF0000000000000; // -Inf
var
  I: Int64;
  fType: TFloatSpecial;
begin
  FClearExcept;
  I := PInt64(@X)^;

  if (I and DEXP) = DEXP then
  begin    if I = DEXP then // X is +Inf
      Exit( cInfinity )
    else if I <> DNINF then
      Exit( X ); // X is NaN
  end;

  if I and (not DSIGN) = 0 then
  begin
    FRaiseExcept(feeDIVBYZERO);
    Exit(cNInfinity);
  end
  else if I < 0 then
  begin
    FRaiseExcept(feeINVALID);
    Exit(cNaN);
  end;

  Result := libm_log(X);

  fType := PDoubleRec(@Result).SpecialType;

  if fType = fsNINf then
    FRaiseExcept(feeDIVBYZERO)
  else if fType = fsNaN then
    FRaiseExcept(feeINVALID);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

function Ln(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS) } // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        FLDLN2
        FXCH
        FYL2X
        FSTP    tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        FLDLN2
        FXCH
        FYL2X
        FWAIT
end;
{$ENDIF}
{$ENDIF }

{$IF     defined(ARITH_PUREPASCAL_EXT80)}
{$IF defined(ARITH_USE_LIBM)}
function libm_log1pl(x: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'log1pl';

function LnXPlus1(const X: Extended): Extended;
begin
  FClearExcept;
  Result := libm_log1pl(X);
  FCheckExcept;
end;
{$ELSE}
function LnXPlus1(const X: Extended): Extended;
begin
  if Abs(X) < (sqrt(2.0) - 1) then
    Result := pLnXP1(X)
  else
    Result := Ln(1 + X);
end;
{$ENDIF}
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function LnXPlus1(const X: Double): Double;
begin
  if Abs(X) < (sqrt(2.0) - 1) then
    Result := pLnXP1Double(X)
  else
    Result := Ln(1 + X);
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
//  double log1p ( double );
function libm_log1p(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'log1p';

function LnXPlus1(const X: Double): Double;
begin
  FClearExcept;
  Result := libm_log1p(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

function LnXPlus1(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        FLD1
        FADD
        FLDLN2
        FXCH
        FYL2X
        FSTP    tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        FLD1
        FADD
        FLDLN2
        FXCH
        FYL2X
        FWAIT
end;
{$ENDIF}
{$ENDIF}

{$IF defined(ARITH_PUREPASCAL_EXT80)}
{$IF defined(ARITH_USE_LIBM)}
function libm_atanl(x: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'atanl';

function ArcTan(const X: Extended): Extended;
begin
  FClearExcept;
  Result := libm_atanl(X);
  FCheckExcept;
end;
{$ELSE !defined(ARITH_USE_LIBM)}
function internalArcTan(E : Extended ): Extended;
const
  CArcTan: array[0..7] of TExtended80RecW =
  ( (Words:($0000, $0000, $0000, $8000, $3FFF)),
    (Words:($AB80, $AAAA, $AAAA, $AAAA, $BFF7)),
    (Words:($8000, $CCAF, $CCCC, $CCCC, $3FF0)),
    (Words:($0000, $E7D0, $2491, $9249, $BFEA)),
    (Words:($0000, $E000, $37F5, $E38E, $3FE3)),
    (Words:($0000, $0000, $FEB8, $BA2D, $BFDD)),
    (Words:($0000, $0000, $EC00, $9D5D, $3FD7)),
    (Words:($0000, $0000, $4000, $8181, $BFD1)) );
var
  I: Integer;
  E2 : EXtended;
begin
  E2 := E * 8;
  E2 := E2 * E2;
  Result := PExtended(@CArcTan[High(CArcTan)])^;
  for I := High(CArcTan)-1 downto 0 do Result := Result * E2 + PExtended(@CArcTan[I])^;

  Result := E * Result;
end;

function emu_PAtan( z: Extended): Extended;
const
  topsOf: array[0..3] of TExtended80RecW =
  ( (Words:($0000, $0000, $0000, $E700, $3FFB)),
    (Words:($A4BD, $7BD6, $64EE, $B35C, $3FFD)),
    (Words:($85B5, $FC47, $3074, $A111, $3FFE)),
    (Words:($0000, $0000, $0000, $8000, $3FFF)) );
  middles: array[0..2] of TExtended80RecW =
  ( (Words:($6EE6, $1FD9, $09BD, $E9FA, $3FFC)),
    (Words:($7B8D, $BD35, $845B, $F6DD, $3FFD)),
    (Words:($D57F, $0235, $80DB, $CC73, $3FFE)) );
  ArcTans: array[0..2] of TExtended80RecW =
  ( (Words:($FA9C, $B064, $1DB2, $E607, $3FFC)),
    (Words:($FA9C, $B064, $1DB2, $E607, $3FFD)),
    (Words:($BBF5, $044B, $5646, $AC85, $3FFE)) );
var
  theta : integer;
begin
  theta := 0;
  while (theta < High(topsOf)) and (z > PExtended(@topsOf[theta])^) do
    Inc(theta);
  if theta = 0 then
    Result := internalArcTan(z)
  else
  begin
    theta := theta - 1;
    z := (z - PExtended(@middles[theta])^) / ( 1 + z * PExtended(@middles[theta])^);
    Result := internalArcTan(z) + PExtended(@ArcTans[theta])^;
  end;
end;

function ArcTan(const X: Extended): Extended;
var
  A: Extended;
begin
  Result := X;
  case PExtendedRec(@X).SpecialType of
    TFloatSpecial.fsInf:
      Result := Pi / 2;
    TFloatSpecial.fsNInf:
      Result := - Pi / 2;
    TFloatSpecial.fsNZero,
    TFloatSpecial.fsZero,
    TFloatSpecial.fsNAN:
      ;
  else
    if X = 0 then Exit;
    A := Abs(X);
    if A > 1 then
      Result := Pi / 2 - emu_PAtan( 1 / A )
    else
      Result := emu_PAtan( A );
    if X < 0 then Result := -Result;
  end;
end;
{$ENDIF defined(ARITH_USE_LIBM)}
{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE)}
function internalArcTan(D : Double ): Double;
const
  CArcTan: array[0..7] of UINT64 =
  (  $3FB2F5A7353A1B01,
     $BFB7429E98FF380E,
     $3FBC71C037153954,
     $BFC249248E85912A,
     $BC53C41AEC2E7942, $3FC999999997B5A2,
     $3C635CC7570C5D0A, $BFD555555555552D );
var
  L1, L2, D2, D4 : Double;
begin
  D2 := D *D ;
  D4 := D2 * D2;

  L1 :=           PDouble(@CArcTan[0])^;
  L2 :=           PDouble(@CArcTan[1])^;
  L1 := L1 * D4 + PDouble(@CArcTan[2])^;
  L2 := L2 * D4 + PDouble(@CArcTan[3])^;
  L1 := L1 * D4 + PDouble(@CArcTan[4])^;
  L1 := L1      + PDouble(@CArcTan[5])^;
  L2 := L2 * D4 + PDouble(@CArcTan[6])^;
  Result := L2 + L1 * D2;
  Result := Result + PDouble(@CArcTan[7])^;
  Result := Result * D2 * D + D;
end;

function emu_PAtan( z: Double): Double;
const
  topsOf: array[0..3] of UInt64 =
  ( $3FBCE00000000000,
    $3FD66B8C9DCF7AD5,
    $3FE422260E9F88F1,
    $3FF0000000000000 );
  middles: array[0..2] of UInt64 =
  ( $3FCD3F4137A3FB2E,
    $3FDEDBB08B77A6AF,
    $3FE98E701B6046BB );
  ArcTans: array[0..2, coeffType] of UInt64 =
  (($3FCCC0E3B6560C9F, $3C6D41911026EB34),
   ($3FDCC0E3B6560C9F, $BC4158A052703F90),
   ($3FE590AAC8C08978, $BC841E1865A76537) );
var
  theta : integer;
begin
  theta := 0;
  while (theta < High(topsOf)) and (z > PDouble(@topsOf[theta])^) do
    Inc(theta);

  if theta = 0 then
    Result := internalArcTan(z)
  else
  begin
    theta := theta - 1;
    z := (z - PDouble(@middles[theta])^) / ( 1 + z * PDouble(@middles[theta])^);
    Result := internalArcTan(z) + PDouble(@ArcTans[theta, cLo])^;
    Result := Result + PDouble(@ArcTans[theta, cHi])^;
  end;
end;

function ArcTan(const X: Double): Double;
var
  A: Double;
begin
  Result := X;
  case PDoubleRec(@X).SpecialType of
    TFloatSpecial.fsInf:
      Result := Pi / 2;
    TFloatSpecial.fsNInf:
      Result := - Pi / 2;
    TFloatSpecial.fsNZero,
    TFloatSpecial.fsZero,
    TFloatSpecial.fsNAN:
      ;
  else
    if X = 0 then Exit;
    A := Abs(X);
    if A > 1 then
      Result := Pi / 2 - emu_PAtan( 1 / A )
    else
      Result := emu_PAtan( A );
    if X < 0 then Result := -Result;
  end;
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
function libm_atan(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'atan';

function ArcTan(const X: Double): Double;
begin
  FClearExcept;
  Result := libm_atan(X);
  FCheckExcept;
end;
{$ELSEIF defined(ARITH_X32_FPU)}

function ArcTan(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD    tbyte ptr X
        FLD1
        FPATAN
        FSTP   tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD    tbyte ptr X
        FLD1
        FPATAN
        FWAIT
end;
{$ENDIF}
{$ENDIF }

{$IF defined(CPUX86) and defined(ASSEMBLER)}

function Sqrt(const X: Extended): Extended;
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
        FLD     tbyte ptr X
        FSQRT
        FSTP    tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
        FLD     tbyte ptr X
        FSQRT
        FWAIT
end;
{$ENDIF}
{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}
function Sqrt(const X: Double): Double;
asm
        .NOFRAME
        SQRTSD  XMM0, XMM0
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
{$IF defined(EXTENDEDHAS10BYTES)}
function libm_sqrtl(x: Extended): Extended; cdecl;
  external libmmodulename name _PU + 'sqrtl';

function Sqrt(const X: Extended): Extended;
begin
  FClearExcept;
  if X < 0 then FRaiseExcept(feeINVALID);
  Result := libm_sqrtl(X);
  FCheckExcept;
end;
{$ELSE}
function libm_sqrt(x: Double): Double; cdecl;
  external libmmodulename name _PU + 'sqrt';

function Sqrt(const X: Double): Double;
begin
  FClearExcept;
  if X < 0 then FRaiseExcept(feeINVALID);
  Result := libm_sqrt(X);
  FCheckExcept;
end;
{$ENDIF}
{$ELSE }
{$IF defined(EXTENDEDHAS10BYTES)}
function Sqrt(const X: Extended): Extended;
{$ELSE}
function Sqrt(const X: Double): Double;
{$ENDIF}
begin
  Error(rePlatformNotImplemented);
  Result := 0;
end;
{$ENDIF }


{ ----------------------------------------------------- }
{       functions & procedures that need compiler magic }
{ ----------------------------------------------------- }

{$IF defined(CPUX64) and defined(ASSEMBLER)}
function _Round(Val: Extended): Int64;
asm
        .NOFRAME
        CVTSD2SI        RAX, XMM0
end;
{$ELSEIF defined(X86ASMRTL)}
procedure _ROUND;
asm
        { ->    FST(0)  Extended argument       }
        { <-    EDX:EAX Result                  }

        SUB     ESP,12
{$IFDEF IOS} // iOS/Simulator
        CALL    FClearExcept
{$ENDIF IOS}
        FISTP   qword ptr [ESP+4]
        FWAIT
{$IFDEF IOS} // iOS/Simulator
        CALL    FCheckExcept
{$ENDIF IOS}
        POP     ECX
        POP     EAX
        POP     EDX
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
{$IFDEF EXTENDEDHAS10BYTES}
function llrintl(x: Extended): Int64; cdecl;
  external libmmodulename name _PU + 'llrintl';

function _Round(Val: Extended): Int64;
type
  TWords = Array[0..4] of Word;
  PWords = ^TWords;
begin
  if (PWords(@Val)^[4] and $7FFF) >= $403F then
    FRaiseExcept(feeINVALID);
  Result := llrintl(Val);
end;
{$ELSE}
function llrint(x: Double): Int64; cdecl;
  external libmmodulename name _PU + 'llrint';

function _Round(Val: Extended): Int64;
type
  TWords = array[0..3] of Word;
  PWords = ^TWords;
begin
  if (PWords(@Val)^[3] and $7FFF) >= $43E0 then
    FRaiseExcept(feeINVALID);
  Result := llrint(Val);
end;
{$ENDIF}
{$ELSE}
function _Round(Val: Extended): Int64;
begin
  Error(rePlatformNotImplemented);
  Result := 0;
end;
{$ENDIF}

                                                                              
{$IF defined(CPUARM)}
function _RoundU(Val: Extended): UInt64;
const
  C: Extended = $8000000000000000;
begin
  Result := 0;
  if Val >= C then
  begin
    Val := Val - C;
    Result := $8000000000000000;
  end;
  Result := Result + Round(Val);
end;
{$ENDIF}

{$IF not defined(X86ASMRTL)}
function _RoundCurrency(Val: Currency): Int64;
var
  I, R: Int64;
  RoundingMode : UInt32;
begin
  I := PInt64(@Val)^;
  Result := I div 10000;
  R := I mod 10000;

  RoundingMode := FGetRound;

  if Result > 0 then
  begin
    case RoundingMode of
      ferTONEAREST:
        if (R > 5000) or ((R = 5000) and odd(Result)) then
          Result := Result + 1;
      ferUPWARD:
        if R > 0 then Result := Result + 1;
    end;
  end
  else
  begin
    case RoundingMode of
      ferTONEAREST:
        if (R < -5000) or ((R = -5000) and odd(Result)) then
          Result := Result - 1;
      ferDOWNWARD:
        if R < 0 then Result := Result - 1;
    end;
  end
end;
{$ENDIF}

{$IF defined(CPUX64) and defined(ASSEMBLER)}
function _Trunc(Val: Extended): Int64;
asm
        .NOFRAME
        CVTTSD2SI RAX, XMM0
end;
{$ELSEIF defined(X86ASMRTL)}
procedure _TRUNC;
asm
        { ->    FST(0)  Extended argument       }
        { <-    EDX:EAX Result                  }

        SUB     ESP,12
{$IFDEF IOS} // iOS/Simulator
        CALL    FClearExcept
{$ENDIF IOS}
        FNSTCW  [ESP].Word          // save
        FNSTCW  [ESP+2].Word        // scratch
        FWAIT
        OR      [ESP+2].Word, $0F00  // trunc toward zero, full precision
        FLDCW   [ESP+2].Word
        FISTP   qword ptr [ESP+4]
        FWAIT
        FLDCW   [ESP].Word
{$IFDEF IOS} // iOS/Simulator
        CALL    FCheckExcept
{$ENDIF IOS}
        POP     ECX
        POP     EAX
        POP     EDX
end;
{$ELSEIF defined(ARITH_USE_LIBM)}
{$IFDEF EXTENDEDHAS10BYTES}
function _Trunc(Val: Extended): Int64;
var
  SavedRoundMode: Int32;
type
  TWords = Array[0..4] of Word;
  PWords = ^TWords;
begin
  if (PWords(@Val)^[4] and $7FFF) >= $403F then
    FRaiseExcept(feeINVALID);
  SavedRoundMode := FSetRound(ferTOWARDZERO);
  Result := llrintl(Val);
  FSetRound(SavedRoundMode);
end;
{$ELSE}
function _Trunc(Val: Extended): Int64;
var
  SavedRoundMode: Int32;
type
  TWords = Array[0..3] of Word;
  PWords = ^TWords;
begin
  if (PWords(@Val)^[3] and $7FFF) >= $43E0 then
    FRaiseExcept(feeINVALID);
  SavedRoundMode := FSetRound(ferTOWARDZERO);
  Result := llrint(Val);
  FSetRound(SavedRoundMode);
end;
{$ENDIF}
{$ELSE}
function _Trunc(Val: Extended): Int64;
begin
  Error(rePlatformNotImplemented);
  Result := 0;
end;
{$ENDIF}

{$IF defined(CPUX64) and defined(ASSEMBLER)}
function _Abs(Val: Extended): Extended;
const
  ABSMASK : UInt64 = $7FFFFFFFFFFFFFFF;
asm
        .NOFRAME
        MOVSD   XMM1, ABSMASK
        PAND    XMM0, XMM1
end;
{$ELSEIF defined(CPUARM)}
function _Abs(Val: Extended): Extended;
begin
  if Val < 0 then
    Result := -Val
  else
    Result := Val;
end;
{$ELSE}
function _Abs(Val: Extended): Extended;
begin
  if Val < 0 then
    Result := -Val
  else
    Result := Val;
end;
{$ENDIF}

                                                                                                                     
{$IF defined(CPUARM) or defined(CPUX86) or defined(EXTERNALLINKER)}
function _MulDivModInt64(AValue, AMul, ADiv: Int64; Remainder: PInt64): Int64;
var
  HVal, Temp, LVal, HRes, LRes: UInt64;
  Sign: Byte;
begin
  // This function is used by division or multiply operator
  // for scaling 'Comp' value
  // eq. Result := Int64((Int128(AValue) * Int128(AMul)) div ADiv);
  // or  Result := Int64((Extended80(AValue) * Extended80(AMul)) / Extended80(ADiv));
  Sign := 0;
  if AValue < 0 then
  begin
    AValue := - AValue;
    Sign := Sign xor 3;
  end;
  if AMul < 0 then
  begin
    AMul := - AMul;
    Sign := Sign xor 1;
  end;
  if ADiv < 0 then
  begin
    ADiv := - ADiv;
    Sign := Sign xor 1;
  end;
  //
  // Int128(HVal:LVal) := Int128(AValue) * Int128(AMul);
  //
  HVal := UInt64(UInt32(AValue shr 32)) * UInt64(UInt32(AMul shr 32));
  Temp := UInt64(UInt32(AValue shr 32)) * UInt64(UInt32(AMul))
        + UInt64(UInt32(AValue)) * UInt64(UInt32(AMul shr 32));
  LVal := UInt64(UInt32(AValue)) * UInt64(UInt32(AMul));
  Temp := Temp + (LVal shr 32);
  LVal := (Temp shl 32) + UInt64(UInt32(LVal));
  HVal := HVal + (Temp shr 32);
  //
  // Result := Int128(HVal:LVal) div ADiv;
  //
  //URes := HVal div UInt64(ADiv);
  Temp := HVal mod UInt64(ADiv);
  Temp := (Temp shl 32) + (LVal shr 32);
  HRes := Temp div UInt64(ADiv);
  Temp := Temp mod UInt64(ADiv);
  Temp := (Temp shl 32) + UInt64(UInt32(LVal));
  LRes := Temp div UInt64(ADiv);
  Result := (HRes shl 32) + LRes;
  if (Sign and 1) <> 0  then
    Result := - Result;
  if Assigned(Remainder) then
  begin
    Remainder^ := Temp mod UInt64(ADiv);
    if (Sign and 2) <> 0  then
      Remainder^ := - Remainder^;
  end;
end;
{$ENDIF CPUARM or CPUX86}

                                                                                               
{$IF defined(CPUARM) or defined(CPUX86) or defined(EXTERNALLINKER)}
function _MulDivInt64(AValue, AMul, ADiv: Int64): Int64;
begin
  Result := _MulDivModInt64(AValue, AMul, ADiv, nil);
end;
{$ENDIF CPUARM or CPUX86 or EXTERNALLINKER}

{$IF defined(CPUX64) or defined(CPUARM)}
function _MulDivComp(AValue, AMul, ADiv: Int64): Int64;
var
  Reaminder: Int64;
  Temp: UInt64;
  RoundingMode : UInt32;
  IncDec: Int64;
const
  Half = UInt64(1) shl 31;
begin
  Result := MulDivInt64(AValue, AMul, ADiv, Reaminder);
  if Reaminder < 0 then
    Reaminder := - Reaminder;
  IncDec := 1;
  if Result < 0 then
    IncDec := -1;
  RoundingMode := FGetRound;
  if RoundingMode <> ferTOWARDZERO then
  begin
    Temp := UInt64(Reaminder shl 32);
    Temp := Temp div UInt64(ADiv);
    case RoundingMode of
      ferTONEAREST:
        if (Temp > Half) or ((Temp = Half) and Odd(Result)) then
          Inc(Result, IncDec);
      ferUPWARD:
        if (Temp > 0) and (IncDec > 0) then
          Inc(Result, IncDec);
      ferDOWNWARD:
        if (Temp > 0) and (IncDec < 0) then
          Inc(Result, IncDec);
    end;
  end;
end;
{$ENDIF CPUX64 or CPUARM}

procedure _AbstractError;
begin
  if Assigned(AbstractErrorProc) then
    AbstractErrorProc;
  RunErrorAt(210, ReturnAddress);
end;

function TextOpen(var t: TTextRec): Integer; forward;

procedure __FlushMBCSBuffer(var t: TTextRec);
begin
  t.MBCSLength := 0;
  t.MBCSBufPos := 0;
end;

function OpenText(var t: TTextRec; Mode: Word): Integer;
begin
  if (t.Mode < fmClosed) or (t.Mode > fmInOut) then
    Result := 102
  else
  begin
    __FlushMBCSBuffer(t);
    if t.Mode <> fmClosed then _Close(t);
    t.Mode := Mode;
    if (t.Name[0] = #0) and (t.OpenFunc = nil) then  // stdio
      t.OpenFunc := @TextOpen;
    Result := TTextIOFunc(t.OpenFunc)(t);
  end;
  if Result <> 0 then SetInOutRes(Result);
end;

function _ResetText(var t: TTextRec): Integer;
begin
  Result := OpenText(t, fmInput);
end;

function _RewritText(var t: TTextRec): Integer;
begin
  Result := OpenText(t, fmOutput);
end;

function _Append(var t: TTextRec): Integer;
begin
  Result := OpenText(t, fmInOut);
end;

function TextIn(var t: TTextRec): Integer;
const
  ERROR_BROKEN_PIPE = 109;
begin
  t.BufEnd := 0;
  t.BufPos := 0;
{$IFDEF MSWINDOWS}
  if not ReadFile(t.Handle, t.BufPtr, t.BufSize, t.BufEnd, nil) then
  begin
    Result := GetLastError;
    if Result = ERROR_BROKEN_PIPE then
      Result := 0; // NT quirk: got "broken pipe"? it's really eof
  end
  else
    Result := 0;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
  t.BufEnd := __read(t.Handle, t.BufPtr, t.BufSize);
  if Integer(t.BufEnd) = -1 then
  begin
    t.BufEnd := 0;
    Result := GetLastError;
  end
  else
    Result := 0;
{$ENDIF POSIX}
end;

function FileNOPProc(var t): Integer;
begin
  Result := 0;
end;

function TextOut(var t: TTextRec): Integer;
{$IFDEF MSWINDOWS}
var
  Dummy: Cardinal;
{$ENDIF}
begin
  if t.BufPos = 0 then
    Result := 0
  else
  begin
{$IFDEF MSWINDOWS}
    if not WriteFile(t.Handle, t.BufPtr, t.BufPos, Dummy, nil) then
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
    if __write(t.Handle, t.BufPtr, t.BufPos) = ssize_t(-1) then
{$ENDIF POSIX}
      Result := GetLastError
    else
      Result := 0;
    t.BufPos := 0;
  end;
end;

function InternalClose(Handle: THandle): Boolean;
begin
{$IFDEF MSWINDOWS}
  Result := CloseHandle(Handle);
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
  Result := __close(Handle) = 0;
{$ENDIF POSIX}
end;

function TextClose(var t: TTextRec): Integer;
begin
  t.Mode := fmClosed;
  if not InternalClose(t.Handle) then
    Result := GetLastError
  else
    Result := 0;
end;

function TextOpenCleanup(var t: TTextRec): Integer;
begin
  InternalClose(t.Handle);
  t.Mode := fmClosed;
  Result := GetLastError;
end;

function TextOpen(var t: TTextRec): Integer;
{$IFDEF MSWINDOWS}
var
  OpenMode: DWORD;
  Flags: Integer;
  Std: DWORD;
  Temp: THandle;
  TempSize: Integer;
  I, BytesRead: Cardinal;
begin
  Result := 0;
  t.BufPos := 0;
  t.BufEnd := 0;
  case t.Mode of
    fmInput: // called by Reset
      begin
        OpenMode := GENERIC_READ;
        Flags := OPEN_EXISTING;
        t.InOutFunc := @TextIn;
      end;
    fmOutput: // called by Rewrite
      begin
        OpenMode := GENERIC_WRITE;
        Flags := CREATE_ALWAYS;
        t.InOutFunc := @TextOut;
      end;
    fmInOut:  // called by Append
      begin
        OpenMode := GENERIC_READ or GENERIC_WRITE;
        Flags := OPEN_EXISTING;
        t.InOutFunc := @TextOut;
      end;
  else
    Exit;
  end;

  t.FlushFunc := @FileNOPProc;

  if t.Name[0] = #0 then  // stdin or stdout
  begin
    if t.BufPtr = nil then  // don't overwrite bufptr provided by SetTextBuf
    begin
      t.BufPtr := @t.Buffer;
      t.BufSize := SizeOf(t.Buffer);
    end;
    t.CloseFunc := @FileNOPProc;
    if t.Mode = fmOutput then
    begin
      if @t = @ErrOutput then
        Std := STD_ERROR_HANDLE
      else
        Std := STD_OUTPUT_HANDLE;
      t.Handle := GetStdHandle(Std);
    end
    else
      t.Handle := GetStdHandle(STD_INPUT_HANDLE);
    if t.CodePage = 0 then
    begin
      if GetFileType(t.Handle) = 2 then
      begin
        if t.Mode = fmOutput then
          t.CodePage := GetConsoleOutputCP
        else
          t.CodePage := GetConsoleCP;
      end
      else
        t.CodePage := DefaultSystemCodePage;
    end
  end
  else
  begin
    t.CloseFunc := @TextClose;
    Temp := CreateFile(t.Name, OpenMode, FILE_SHARE_READ, nil, Flags, FILE_ATTRIBUTE_NORMAL, 0);
    if Temp = THandle(-1) then
    begin
      t.Mode := fmClosed;
      Result := GetLastError;
      Exit;
    end;
    t.Handle := Temp;
    if t.Mode = fmInOut then      // Append mode
    begin
      t.Mode := fmOutput;

      TempSize := GetFileSize(t.Handle, nil);
      if TempSize = -1 then
      begin
        Result := TextOpenCleanup(t);
        Exit;
      end;

      Dec(TempSize, 128);
      if TempSize < 0 then TempSize := 0;

      if (Integer(SetFilePointer(t.Handle, TempSize, nil, FILE_BEGIN)) = -1) or
         (not ReadFile(t.Handle, @(t.Buffer), 128, BytesRead, nil)) then
      begin
        Result := TextOpenCleanup(t);
        Exit;
      end;

      if (t.Flags and tfCRLF) <> 0 then  // DOS mode, EOF significant
      begin  // scan for EOF char in last 128 byte sector.
        if BytesRead > 0 then
          for I := 0 to BytesRead - 1 do
          begin
            if t.Buffer[I] = _AnsiChr(cEOF) then
            begin  // truncate the file here
              if (Integer(SetFilePointer(t.Handle, I - BytesRead, nil, FILE_END)) = -1) or
                (not SetEndOfFile(t.Handle)) then
              begin
                Result := TextOpenCleanup(t);
                Exit;
              end;
              Break;
            end;
          end;
      end;
    end;
    if t.CodePage = 0 then
      t.CodePage := DefaultSystemCodePage;
  end;
  if t.Mode <> fmInput then
  begin
    case GetFileType(t.Handle) of
      0: begin  // bad file type
           TextOpenCleanup(t);
           Result := 105;
           Exit;
         end;
      2: t.FlushFunc := @TextOut;
    end;
  end;
end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
var
  Flags: Integer;
  Temp, I: Integer;
  BytesRead: Integer;
  us: _UTF8Str;
begin
  Result := 0;
  t.BufPos := 0;
  t.BufEnd := 0;
  case t.Mode of
    fmInput: // called by Reset
      begin
        Flags := O_RDONLY;
        t.InOutFunc := @TextIn;
      end;
    fmOutput: // called by Rewrite
      begin
        Flags := O_CREAT or O_TRUNC or O_WRONLY;
        t.InOutFunc := @TextOut;
      end;
    fmInOut:  // called by Append
      begin
        Flags := O_APPEND or O_RDWR;
        t.InOutFunc := @TextOut;
      end;
  else
    Exit;
    Flags := 0;
  end;

  t.FlushFunc := @FileNOPProc;

  if t.Name[0] = #0 then  // stdin or stdout
  begin
    if t.BufPtr = nil then  // don't overwrite bufptr provided by SetTextBuf
    begin
      t.BufPtr := @t.Buffer;
      t.BufSize := sizeof(t.Buffer);
    end;
    t.CloseFunc := @FileNOPProc;
    if t.Mode = fmOutput then
    begin
      if @t = @ErrOutput then
        t.Handle := STDERR_FILENO
      else
        t.Handle := STDOUT_FILENO;
      t.FlushFunc := @TextOut;
    end
    else
      t.Handle := STDIN_FILENO;
    t.CodePage := CP_UTF8;
  end
  else
  begin
    t.CloseFunc := @TextClose;

    us := _UTF8Str(t.Name);
    Temp := open(_PAnsiChr(us), Flags, FileAccessRights);
    if Temp = -1 then
    begin
      t.Mode := fmClosed;
      Result := GetLastError;
      Exit;
    end;

    t.Handle := Temp;

    if t.Mode = fmInOut then      // Append mode
    begin
      t.Mode := fmOutput;

      if (t.Flags and tfCRLF) <> 0 then  // DOS mode, EOF significant
      begin  // scan for EOF char in last 128 byte sector.
        Temp := lseek(t.Handle, 0, SEEK_END);
        if Temp = -1 then
        begin
          Result := TextOpenCleanup(t);
          Exit;
        end;

        Dec(Temp, 128);
        if Temp < 0 then Temp := 0;

        if lseek(t.Handle, Temp, SEEK_SET) = -1 then
        begin
          Result := TextOpenCleanup(t);
          Exit;
        end;

        BytesRead := __read(t.Handle, t.BufPtr, 128);
        if BytesRead = -1 then
        begin
          Result := TextOpenCleanup(t);
          Exit;
        end;

        for I := 0 to BytesRead - 1 do
        begin
          if t.Buffer[I] = _AnsiChr(cEOF) then
          begin  // truncate the file here
            if ftruncate(t.Handle, lseek(t.Handle, I - BytesRead, SEEK_END)) = -1 then
            begin
              Result := TextOpenCleanup(t);
              Exit;
            end;
            Break;
          end;
        end;
      end;
    end;
    if t.CodePage = 0 then
      t.CodePage := DefaultSystemCodePage;
  end;
end;
{$ENDIF POSIX}

const
  fNameLen = 259;

function _AssignFile(var t: TFileRec; const s: PChar): Integer;
var
  Len: Integer;
begin
  FillChar(t, SizeOf(TFileRec), 0);
  t.BufPtr := NIL;
  t.Mode := fmClosed;
  t.Flags := tfCRLF * Byte(DefaultTextLineBreakStyle);
  t.BufSize := 0;
  t.OpenFunc := @TextOpen;
  Len := _PWCharLen(s);
  if Len >  fNameLen then
  begin
    SetInOutRes(3);
    Len :=  fNameLen;
  end;
  MoveChars(s^, t.Name, Len);
  t.Name[Len] := #0;
  Result := 0;
end;

function _AssignText(var t: TTextRec; const s: PChar; const CP: word): Integer;
var
  Len: Integer;
begin
  FillChar(t, SizeOf(TTextRec), 0);
  t.BufPtr := @t.Buffer;
  t.Mode := fmClosed;
  t.Flags := tfCRLF * Byte(DefaultTextLineBreakStyle);
  if CP = 0 then
    t.CodePage := DefaultSystemCodePage
  else
    t.CodePage := CP;
  t.BufSize := SizeOf(t.Buffer);
  t.OpenFunc := @TextOpen;
  Len := _PWCharLen(s);
  if Len > fNameLen then
  begin
    SetInOutRes(3);
    Len := fNameLen;
  end;
  MoveChars(s^, t.Name, Len);
  t.Name[Len] := #0;
  t.MBCSLength := 0;
  Result := 0;
end;

function InternalFlush(var t: TTextRec; Func: TTextIOFunc): Integer;
begin
  case t.Mode of
    fmOutput,
    fmInOut  : Result := Func(t);
    fmInput  : Result := 0;
  else
    if (@t = @Output) or (@t = @ErrOutput) then
      Result := 0
    else
      Result := 103;
  end;
  if Result <> 0 then SetInOutRes(Result);
end;

function Flush(var t: Text): Integer;
begin
  Result := InternalFlush(TTextRec(t), TTextRec(t).InOutFunc);
end;

function _Flush(var t: TTextRec): Integer;
begin
  Result := InternalFlush(t, t.FlushFunc);
end;

type
{$IFDEF MSWINDOWS}
  TIOProc = function (hFile: THandle; Buffer: Pointer; nNumberOfBytesToWrite: DWORD;
  var lpNumberOfBytesWritten: DWORD; lpOverlapped: Pointer): BOOL; stdcall;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
  TIOProc = function (Handle: Integer; Buffer: Pointer; Count: size_t): ssize_t; cdecl;
{$ENDIF POSIX}

function BlockIO(var f: TFileRec; buffer: Pointer; recCnt: Integer; RecsDone: PInteger;
  ModeMask: Integer; IOProc: TIOProc; ErrorNo: Integer): Integer;
// Note:  RecsDone ptr can be nil!
{$IFDEF MSWINDOWS}
var
  Res: DWORD;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
var
  Res: ssize_t;
{$ENDIF POSIX}
begin
  if (f.Mode and ModeMask) = ModeMask then  // fmOutput or fmInOut / fmInput or fmInOut
  begin
{$IFDEF POSIX}
    Res := IOProc(F.Handle, Buffer, ssize_t(RecCnt) * ssize_t(F.RecSize));
    if Res = -1 then
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
    if not IOProc(F.Handle, Buffer, Cardinal(RecCnt) * F.RecSize, Res, nil) then
{$ENDIF MSWINDOWS}
    begin
      SetInOutRes(GetLastError);
      Result := 0;
    end
    else
    begin
{$IFDEF POSIX}
      Result := Integer(Res div ssize_t(f.RecSize));
{$ELSE}
      Result := Integer(Res div f.RecSize);
{$ENDIF}
      if RecsDone <> nil then
        RecsDone^ := Result
      else if Result <> RecCnt then
      begin
        SetInOutRes(ErrorNo);
        Result := 0;
      end
    end;
  end
  else
  begin
    SetInOutRes(103);  // file not open
    Result := 0;
  end;
end;

function _BlockRead(var F: TFileRec; Buffer: Pointer; RecCnt: Integer; RecsRead: PInteger): Integer;
begin
  Result := BlockIO(F, Buffer, RecCnt, RecsRead, fmInput,
    {$IFDEF MSWINDOWS} ReadFile, {$ENDIF}
    {$IFDEF POSIX} __read, {$ENDIF}
    100);
end;

function _BlockWrite(var F: TFileRec; Buffer: Pointer; RecCnt: Integer; RecsWritten: PInteger): Integer;
begin
  Result := BlockIO(F, Buffer, RecCnt, RecsWritten, fmOutput,
  {$IFDEF MSWINDOWS} WriteFile, {$ENDIF}
  {$IFDEF POSIX} __write, {$ENDIF}
  101);
end;

function _Close(var t: TTextRec): Integer;
begin
  Result := 0;
  if (t.Mode >= fmInput) and (t.Mode <= fmInOut) then
  begin
    if (t.Mode and fmOutput) = fmOutput then  // fmOutput or fmInOut
      Result := TTextIOFunc(t.InOutFunc)(t);
    if Result = 0 then
      Result := TTextIOFunc(t.CloseFunc)(t);
    if Result <> 0 then
      SetInOutRes(Result);
  end
  else
  if @t <> @Input then
    SetInOutRes(103);
end;

function _EofFile(var f: TFileRec): Boolean;
begin
  Result := _FilePos(f) >= _FileSize(f);
end;

function _GetAnsiChar(var t: TTextRec; var IsEof: Boolean; codepage: word): Byte; forward;
function _GetWideChar(var t: TTextRec; var IsEof: Boolean): Word; forward;
procedure _SkipAnsiChar(var t: TTextRec); forward;
procedure _SkipWideChar(var t: TTextRec); forward;

function _ReadByte(var t: TTextRec; var IsEof: Boolean): Byte; forward;

function _EofText(var t: TTextRec): Boolean;
begin
  if t.MBCSLength <> 0 then Exit(False)
  else
  begin
    _ReadByte(t, Result);
    if Not Result then
      Dec(t.BufPos);
  end;
end;

function _Eoln(var t: TTextRec): Boolean;
var
  c: Word;
  eof: Boolean;
begin
  if t.MBCSLength <> 0 then
  begin
    if t.MBCSLength > 0 then
      c := Word(_GetAnsiChar(t, eof, DefaultSystemCodePage))
    else
      c := _GetWideChar(t, eof);
    if eof then Exit(True);
  end
  else
  begin
    c := word(_ReadByte(t, eof));
    if eof then Exit(True)
    else Dec(t.BufPos);
  end;

  if (t.Flags and tfCRLF) <> 0 then
    Result := (c = cCR) or (c = cEOF)
  else
    Result := (c = cLF) or (c = cEOF);
end;

procedure _Erase(var f: TFileRec);
begin
  if (f.Mode < fmClosed) or (f.Mode > fmInOut) then
    SetInOutRes(102)  // file not assigned
  else begin
{$IFDEF MSWINDOWS}
    if not DeleteFile(f.Name) then
      SetInOutRes(GetLastError);
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
    if remove(_PAnsiChr(UTF8Encode(f.Name))) < 0 then
       SetInOutRes(GetLastError);
{$ENDIF POSIX}
  end;
end;

{$IFDEF WIN32}
// Floating-point divide reverse routine
// ST(1) = ST(0) / ST(1), pop ST

procedure _FSafeDivideR;
asm
  FXCH
  JMP _FSafeDivide
end;

// Floating-point divide routine
// ST(1) = ST(1) / ST(0), pop ST

procedure _FSafeDivide;
type
  Z = packed record  // helper type to make parameter references more readable
    Dividend: Extended;   // (TBYTE PTR [ESP])
    Pad: Word;
    Divisor: Extended;    // (TBYTE PTR [ESP+12])
  end;
asm
        CMP       TestFDIV,0        //Check FDIV indicator
        JLE       @@FDivideChecked  //Jump if flawed or don't know
        FDIV                        //Known to be ok, so just do FDIV
        RET

// FDIV constants
@@FDIVRiscTable: DB 0,1,0,0,4,0,0,7,0,0,10,0,0,13,0,0;

@@FDIVScale1:    DD $3F700000             // 0.9375
@@FDIVScale2:    DD $3F880000             // 1.0625
@@FDIV1SHL63:    DD $5F000000             // 1 SHL 63

@@TestDividend:  DD $C0000000,$4150017E   // 4195835.0
@@TestDivisor:   DD $80000000,$4147FFFF   // 3145727.0
@@TestOne:       DD $00000000,$3FF00000   // 1.0

// Flawed FDIV detection
@@FDivideDetect:
        MOV     TestFDIV,1                //Indicate correct FDIV
        PUSH    EAX
        SUB     ESP,12
        FSTP    TBYTE PTR [ESP]           //Save off ST
        FLD     QWORD PTR @@TestDividend  //Ok if x - (x / y) * y < 1.0
        FDIV    QWORD PTR @@TestDivisor
        FMUL    QWORD PTR @@TestDivisor
        FSUBR   QWORD PTR @@TestDividend
        FCOMP   QWORD PTR @@TestOne
        FSTSW   AX
        SHR     EAX,7
        AND     EAX,002H          //Zero if FDIV is flawed
        DEC     EAX
        MOV     TestFDIV,AL       //1 means Ok, -1 means flawed
        FLD     TBYTE PTR [ESP]   //Restore ST
        ADD     ESP,12
        POP     EAX
        JMP     _FSafeDivide

@@FDivideChecked:
        JE      @@FDivideDetect   //Do detection if TestFDIV = 0
@@1:
        PUSH    EAX
        SUB     ESP,24
        FSTP    [ESP].Z.Divisor     //Store Divisor and Dividend
        FSTP    [ESP].Z.Dividend
        FLD     [ESP].Z.Dividend
        FLD     [ESP].Z.Divisor
@@2:
        MOV     EAX,DWORD PTR [ESP+4].Z.Divisor   //Is Divisor a denormal?
        ADD     EAX,EAX
        JNC     @@20            //Yes, @@20
        XOR     EAX,0E000000H   //If these three bits are not all
        TEST    EAX,0E000000H   //ones, FDIV will work
        JZ      @@10            //Jump if all ones
@@3:
        FDIV                    //Do FDIV and exit
        ADD     ESP,24
        POP     EAX
        RET
@@10:
        SHR     EAX,28      //If the four bits following the MSB
                            //of the mantissa have a decimal
                            //of 1, 4, 7, 10, or 13, FDIV may
        CMP     byte ptr @@FDIVRiscTable[EAX],0 //not work correctly
        JZ      @@3     //Do FDIV if not 1, 4, 7, 10, or 13
        MOV     EAX,DWORD PTR [ESP+8].Z.Divisor //Get Divisor exponent
        AND     EAX,7FFFH
        JZ      @@3     //Ok to FDIV if denormal
        CMP     EAX,7FFFH
        JE      @@3     //Ok to FDIV if NAN or INF
        MOV     EAX,DWORD PTR [ESP+8].Z.Dividend //Get Dividend exponent
        AND     EAX,7FFFH
        CMP     EAX,1     //Small number?
        JE      @@11      //Yes, @@11
        FMUL    DWORD PTR @@FDIVScale1  //Scale by 15/16
        FXCH
        FMUL    DWORD PTR @@FDIVScale1
        FXCH
        JMP     @@3     //FDIV is now safe
@@11:
        FMUL    DWORD PTR @@FDIVScale2    //Scale by 17/16
        FXCH
        FMUL    DWORD PTR @@FDIVScale2
        FXCH
        JMP     @@3     //FDIV is now safe

@@20:
        MOV     EAX,DWORD PTR [ESP].Z.Divisor     //Is entire Divisor zero?
        OR      EAX,DWORD PTR [ESP+4].Z.Divisor
        JZ      @@3               //Yes, ok to FDIV
        MOV     EAX,DWORD PTR [ESP+8].Z.Divisor   //Get Divisor exponent
        AND     EAX,7FFFH         //Non-zero exponent is invalid
        JNZ     @@3               //Ok to FDIV if invalid
        MOV     EAX,DWORD PTR [ESP+8].Z.Dividend  //Get Dividend exponent
        AND     EAX,7FFFH         //Denormal?
        JZ      @@21              //Yes, @@21
        CMP     EAX,7FFFH         //NAN or INF?
        JE      @@3               //Yes, ok to FDIV
        MOV     EAX,DWORD PTR [ESP+4].Z.Dividend  //If MSB of mantissa is zero,
        ADD     EAX,EAX           //the number is invalid
        JNC     @@3               //Ok to FDIV if invalid
        JMP     @@22
@@21:
        MOV     EAX,DWORD PTR [ESP+4].Z.Dividend  //If MSB of mantissa is zero,
        ADD     EAX,EAX                           //the number is invalid
        JC      @@3                               //Ok to FDIV if invalid
@@22:
        FXCH                  //Scale stored Divisor image by
        FSTP    ST(0)         //1 SHL 63 and restart
        FLD     ST(0)
        FMUL    DWORD PTR @@FDIV1SHL63
        FSTP    [ESP].Z.Divisor
        FLD     [ESP].Z.Dividend
        FXCH
        JMP     @@2
end;
{$ENDIF WIN32}

function _FilePos(var f: TFileRec): Integer;
{$IFDEF MSWINDOWS}
var
  Res: DWORD;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
var
  Res: off_t;
{$ENDIF POSIX}
begin
  Result := -1;
  if (f.Mode > fmClosed) and (f.Mode <= fmInOut) then
  begin
{$IFDEF MSWINDOWS}
    Res := SetFilePointer(f.Handle, 0, nil, FILE_CURRENT);
    if Res = $FFFFFFFF then
      InOutError
    else
      Result := Integer(Res div f.RecSize);
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
    Res := lseek(f.Handle, 0, SEEK_CUR);
    if Res = -1 then
      InOutError
    else
      Result := Integer(Res div off_t(f.RecSize));
{$ENDIF POSIX}
  end
  else
    SetInOutRes(103);
end;

function _FileSize(var f: TFileRec): Integer;
{$IFDEF MSWINDOWS}
begin
  Result := -1;
  if (f.Mode > fmClosed) and (f.Mode <= fmInOut) then
  begin
    Result := Integer(GetFileSize(f.Handle, nil));
    if Result = -1 then
      InOutError
    else
      Result := Cardinal(Result) div f.RecSize;
  end
  else
    SetInOutRes(103);
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
{$IFDEF IOS}
var
  SavedPos: off_t;
  Pos: off_t;
{$ELSE !IOS}
var
  stat: _stat;
{$ENDIF !IOS}
begin
  Result := -1;
  if (f.Mode > fmClosed) and (f.Mode <= fmInOut) then
  begin
{$IFDEF IOS}
    { Calling fstat to retrieve the st_size is not reliable on iOS }
    SavedPos := lseek(f.Handle, 0, SEEK_CUR);
    if SavedPos = -1 then
      InOutError
    else
    begin
      Pos := lseek(f.Handle, 0, SEEK_END);
      lseek(f.Handle, SavedPos, SEEK_SET);
      if Pos = -1  then
        InOutError
      else
        Result := Integer(Pos div f.RecSize);
    end;
{$ELSE !IOS}
//    if _fxstat(STAT_VER_LINUX, f.Handle, stat) <> 0 then
    if fstat(f.Handle, stat) <> 0 then
      InOutError
    else
      {$IF defined(ANDROID)} // cast to st_size type
      Result := Integer(stat.st_size div Int64(f.RecSize));
      {$ELSE}
      Result := Integer(stat.st_size div off_t(f.RecSize));
      {$ENDIF}
{$ENDIF !IOS}
  end
  else
    SetInOutRes(103);
{$ENDIF POSIX}
end;

(* ***** BEGIN LICENSE BLOCK *****
 *
 * The assembly procedure FillChar is licensed under the CodeGear license terms.
 *
 * The initial developer of the original code is Fastcode
 *
 * Portions created by the initial developer are Copyright (C) 2002-2004
 * the initial developer. All Rights Reserved.
 *
 * Contributor(s): John O'Harrow
 *
 * ***** END LICENSE BLOCK ***** *)
procedure _FillChar(var Dest; Count: NativeInt; Value: _AnsiChr);
{$IF defined(POSIX)}
begin
  if Count > 0 then
    memset(Dest, Byte(Value), Count)
end;
{$ELSEIF defined(PUREPASCAL)}
var
  Index: NativeInt;
  V: UInt64;
  PB: PByte;
  Total: NativeInt;
begin
  PB := PByte(@Dest);

  if Count >= 8 then
  begin
    V := Byte(Value) or (Byte(Value) shl 8) or
      (Byte(value) shl 16) or (Byte(value) shl 24);
    V := V or (V shl 32);
    Total := Count shr 3;

    for Index := 0 to Total - 1 do
    begin
      PUInt64(PB)^ := V;
      Inc(PB, 8);
    end;
    { Get the remainder (mod 8) }
    Count := Count and $7;
  end;

  // Fill remain.
  for Index := 0 to Count - 1 do
  begin
    PB^ := Byte(Value);
    Inc(PB);
  end;
end;
{$ELSE !PUREPASCAL}
asm                                  // Size = 153 Bytes
        CMP   EDX, 32
        MOV   CH, CL                 // Copy Value into both Bytes of CX
        JL    @@Small
        MOV   [EAX  ], CX            // Fill First 8 Bytes
        MOV   [EAX+2], CX
        MOV   [EAX+4], CX
        MOV   [EAX+6], CX
        SUB   EDX, 16
        FLD   QWORD PTR [EAX]
        FST   QWORD PTR [EAX+EDX]    // Fill Last 16 Bytes
        FST   QWORD PTR [EAX+EDX+8]
        MOV   ECX, EAX
        AND   ECX, 7                 // 8-Byte Align Writes
        SUB   ECX, 8
        SUB   EAX, ECX
        ADD   EDX, ECX
        ADD   EAX, EDX
        NEG   EDX
@@Loop:
        FST   QWORD PTR [EAX+EDX]    // Fill 16 Bytes per Loop
        FST   QWORD PTR [EAX+EDX+8]
        ADD   EDX, 16
        JL    @@Loop
        FFREE ST(0)
        FINCSTP
        RET
        NOP
        NOP
        NOP
@@Small:
        TEST  EDX, EDX
        JLE   @@Done
        MOV   [EAX+EDX-1], CL        // Fill Last Byte
        AND   EDX, -2                // No. of Words to Fill
        NEG   EDX
{$IFDEF PIC}
        PUSH  EAX
        PUSH  EBX
        PUSH  ECX
        CALL  GetGOT
        ADD   EAX, offset @@SmallFill + 60
        LEA   EDX, [EAX + EDX * 2]
        POP   ECX
        POP   EBX
        POP   EAX
{$ELSE !PIC}
        LEA   EDX, [@@SmallFill + 60 + EDX * 2]
{$ENDIF !PIC}
        JMP   EDX
{$IFNDEF PIC}
        NOP                          // Align Jump Destinations
        NOP
{$ENDIF !PIC}
@@SmallFill:
        MOV   [EAX+28], CX
        MOV   [EAX+26], CX
        MOV   [EAX+24], CX
        MOV   [EAX+22], CX
        MOV   [EAX+20], CX
        MOV   [EAX+18], CX
        MOV   [EAX+16], CX
        MOV   [EAX+14], CX
        MOV   [EAX+12], CX
        MOV   [EAX+10], CX
        MOV   [EAX+ 8], CX
        MOV   [EAX+ 6], CX
        MOV   [EAX+ 4], CX
        MOV   [EAX+ 2], CX
        MOV   [EAX   ], CX
        RET                          // DO NOT REMOVE - This is for Alignment
@@Done:
end;
{$ENDIF !PUREPASCAL}

procedure       Mark;
begin
  Error(reInvalidPtr);
end;

function _ReadRec(var f: TFileRec; Buffer: Pointer): Integer;
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
begin
  if (f.Mode = fmInput) or (f.Mode = fmInOut) then
  begin
    if not ReadFile(f.Handle, Buffer, f.RecSize, Cardinal(Result), nil) then
      SetInOutRes(GetLastError)
    else if Cardinal(Result) <> f.RecSize then
      SetInOutRes(100);
  end
  else
  begin
    SetInOutRes(103);  // file not open for input
    Result := 0;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
// -> EAX Pointer to file variable
//    EDX Pointer to buffer

        PUSH    EBX
        XOR     ECX,ECX
        MOV     EBX,EAX
        MOV     CX,[EAX].TFileRec.Mode   // File must be open
        SUB     ECX,fmInput
        JE      @@skip
        SUB     ECX,fmInOut-fmInput
        JNE     @@fileNotOpen
@@skip:

//  ReadFile(f.Handle, buffer, f.RecSize, @result, Nil);

        PUSH    0     // space for OS result
        MOV     EAX,ESP

        PUSH    0     // pass lpOverlapped
        PUSH    EAX     // pass @result

        PUSH    [EBX].TFileRec.RecSize    // pass nNumberOfBytesToRead

        PUSH    EDX     // pass lpBuffer
        PUSH    [EBX].TFileRec.Handle   // pass hFile
        CALL    ReadFile
        POP     EDX     // pop result
        DEC     EAX     // check EAX = TRUE
        JNZ     @@error

        CMP     EDX,[EBX].TFileRec.RecSize  // result = f.RecSize ?
        JE      @@exit

@@readError:
        MOV EAX,100
        JMP @@errExit

@@fileNotOpen:
        MOV EAX,103
        JMP @@errExit

@@error:
        CALL  GetLastError
@@errExit:
        CALL  SetInOutRes
@@exit:
        POP EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  if (f.Mode and fmInput) = fmInput then  // fmInput or fmInOut
  begin
    Result := __read(f.Handle, Buffer, f.RecSize);
    if Result = -1 then
      InOutError
    else if Cardinal(Result) <> f.RecSize then
      SetInOutRes(100);
  end
  else
  begin
    SetInOutRes(103);  // file not open for input
    Result := 0;
  end;
end;
{$ENDIF POSIX}

// If the file is Input std variable, try to open it
// Otherwise, runtime error.
function TryOpenForInput(var t: TTextRec): Boolean;
begin
  if @t = @Input then
  begin
    t.Flags := tfCRLF * Byte(DefaultTextLineBreakStyle);
    _ResetText(t);
  end;

  Result := t.Mode = fmInput;
  if not Result then
    SetInOutRes(104);
end;

// For eof, #$1A is returned.
// For errors, InOutRes is set and #$1A is returned.
function _ReadByte(var t: TTextRec; var IsEof: Boolean): Byte;
var
  Res: Integer;
begin
  Result := cEof;
  IsEof := True;

  if t.Mode <> fmInput then
    if not TryOpenForInput(t) then
      exit;

  if t.BufPos >= t.BufEnd then
  begin
    Res := TTextIOFunc(t.InOutFunc)(t);
    if Res <> 0 then
    begin
      SetInOutRes(Res);
      exit;
    end;
    if t.BufPos >= t.BufEnd then
    begin
      //  We didn't get characters. Must be eof then.
      if (t.Flags and tfCRLF) <> 0 then
      begin
        //  In DOS CRLF compatibility mode, synthesize an EOF char
        //  Store one eof in the buffer and increment BufEnd
        t.BufPtr[t.BufPos] := _AnsiChr(cEof);
        inc(t.BufEnd);
      end;
      exit;
    end;
  end;

  Result := Byte(t.BufPtr[t.BufPos]);
  // Check for EOF char in DOS mode
  if ((t.Flags and tfCRLF) <> 0) and (Result = cEof) then
    Exit;

  Inc(t.BufPos);
  IsEof := False;
end;

// For eof, #$1A is returned.
// For errors, InOutRes is set and #$1A is returned.
function _ReadWord(var t: TTextRec; var IsEof: Boolean): Word;
var
  Res: Integer;
begin
  Result := cEof;
  IsEof := True;

  if t.Mode <> fmInput then
    if not TryOpenForInput(t) then
      exit;

  if t.BufPos >= t.BufEnd then
  begin
    Res := TTextIOFunc(t.InOutFunc)(t);
    if Res <> 0 then
    begin
      SetInOutRes(Res);
      Exit;
    end;
    if t.BufPos >= t.BufEnd then
    begin
      //  We didn't get characters. Must be eof then.
      if (t.Flags and tfCRLF) <> 0 then
      begin
        //  In DOS CRLF compatibility mode, synthesize an EOF char
        //  Store one eof in the buffer and increment BufEnd
        t.BufPtr[t.BufPos] := _AnsiChr(cEof);
        inc(t.BufEnd);
      end;
      Exit;
    end;
  end;

  Result := PWord(t.BufPtr + t.BufPos)^;
  // Check for EOF char in DOS mode
  if ((t.Flags and tfCRLF) <> 0) and (Result = cEof) then
    Exit;

  Inc(t.BufPos, 2);
  IsEof := False;
end;

//    For eof, #$1A is returned in both lower and upper 8 bits.
//    For errors, InOutRes is set and #$1A is returned.
function _GetAnsiChar(var t: TTextRec; var IsEof: Boolean; codepage: word): Byte;
var
  len : integer;
  W : array[0..2] of WideChar;
  A : _AnsiStr;
  aBuf : array[0..6] of _AnsiChr;
begin
  IsEof := False;

  if t.MBCSLength < 0 then
  begin
    // Wide -> A
    if t.MBCSBufPos <> 0 then
    begin
      // Remove partial character.
      t.MBCSLength := 0;
    end
    else
    begin
      // Wide -> A
      len := CharFromWChar(_PAnsiChr(@abuf[0]), 6, PWideChar(@t.UTF16Buffer[0]), -t.MBCSLength, codepage);
      t.MBCSLength := len;
      move(aBuf[0], t.MBCSBuffer[0], len);
    end;
  end;

  if t.MBCSLength > 0 then
  begin
    Result := Byte(t.MBCSBuffer[t.MBCSBufPos]);
    Exit;
  end;
  if (t.CodePage = codepage) then
  begin
    Result := _ReadByte(t, IsEof);
    if Not IsEof then
      Dec(t.BufPos);
  end
  else
  begin
    len := 1;
    W[0] := Char(_GetWideChar(t, IsEof));
    if Not IsEof then
    begin
      if (W[0] >= #$D800) and (W[0] < #$DC00) then
      begin
        Inc(Len);
        _SkipWideChar(t);
        W[1] := Char(_GetWideChar(t, IsEof));
        if IsEof then
        begin
          Result := cEOF;
          Exit;
        end;
      end;
      _SkipWideChar(t);
      _LStrFromPWCharLen(A, PWideChar(@W[0]), Len, CodePage);
      len := Length(A);
      if len = 0 then
        Result := 0
      else
      begin
        Move(A[Low(string)], t.MBCSBuffer[0], Len);
        t.MBCSBufPos := 0;
        t.MBCSLength := Len;
        Result := Byte(A[Low(string)]);
      end
    end
    else
      Result := cEOF;
  end;
end;

procedure _SkipAnsiChar(var t: TTextRec);
begin
  if t.MBCSLength > 0 then
  begin
    Inc(t.MBCSBufPos);
    if byte(t.MBCSLength) = t.MBCSBufPos then
      t.MBCSLength := 0;
  end
  else
    Inc(t.BufPos)
end;

{$IFDEF POSIX}
function LocaleNameFromCodePage(CodePage: Integer): _AnsiStr;
begin
  if CodePage = CP_ACP then
    CodePage := GetACP;
  case CodePage of
    // Special cases
{$IFDEF USE_LIBICU}
    949:     Result := 'windows-949-2000';
    950:     Result := 'windows-950-2000';
{$ENDIF}
    10000:   Result := 'MACROMAN';         // do not localize
    10004:   Result := 'MACARABIC';        // do not localize
    10005:   Result := 'MACHEBREW';        // do not localize
    10006:   Result := 'MACGREEK';         // do not localize
    10007:   Result := 'MACCYRILLIC';      // do not localize
    10010:   Result := 'MACROMANIA';       // do not localize
    10017:   Result := 'MACUKRAINE';       // do not localize
    10021:   Result := 'MACTHAI';          // do not localize
    10029:   Result := 'MACCENTRALEUROPE'; // do not localize
    10079:   Result := 'MACICELAND';       // do not localize
    10081:   Result := 'MACTURKISH';       // do not localize
    10082:   Result := 'MACCROATIAN';      // do not localize
    12000:   Result := 'UTF-32LE';         // do not localize
    12001:   Result := 'UTF-32BE';         // do not localize
    20127:   Result := 'ASCII';            // do not localize
    20866:   Result := 'KOI8-R';           // do not localize
    20932:   Result := 'EUC-JP';           // do not localize
    20936:   Result := 'GB2312';           // do not localize
    21866:   Result := 'KOI8-U';           // do not localize
    28591:   Result := 'ISO-8859-1';       // do not localize
    28592:   Result := 'ISO-8859-2';       // do not localize
    28593:   Result := 'ISO-8859-3';       // do not localize
    28594:   Result := 'ISO-8859-4';       // do not localize
    28595:   Result := 'ISO-8859-5';       // do not localize
    28596:   Result := 'ISO-8859-6';       // do not localize
    28597:   Result := 'ISO-8859-7';       // do not localize
    28598:   Result := 'ISO-8859-8';       // do not localize
    28599:   Result := 'ISO-8859-9';       // do not localize
    28600:   Result := 'ISO-8859-10';      // do not localize
    28601:   Result := 'ISO-8859-11';      // do not localize
    28603:   Result := 'ISO-8859-13';      // do not localize
    28604:   Result := 'ISO-8859-14';      // do not localize
    28605:   Result := 'ISO-8859-15';      // do not localize
    28606:   Result := 'ISO-8859-16';      // do not localize
    50221:   Result := 'ISO-2022-JP';      // do not localize
    50225:   Result := 'ISO-2022-KR';      // do not localize
    50227:   Result := 'ISO-2022-CN';      // do not localize
    51932:   Result := 'EUC-JP';           // do not localize
    51936:   Result := 'GB2312';           // do not localize
    51949:   Result := 'EUC-KR';           // do not localize
    51950:   Result := 'EUC-TW';           // do not localize
    52936:   Result := 'HZ-GB-2312';       // do not localize
    54936:   Result := 'GB18030';          // do not localize
    CP_UTF7: Result := 'UTF-7';            // do not localize
    CP_UTF8: Result := 'UTF-8';            // do not localize
  else
    Str(CodePage, Result);
    Result := 'cp' + Result;  // do not localize
  end;
end;

{$IFDEF USE_LIBICU}
threadvar
  LastLeadCodePage: Cardinal;
  LastLeadStarters: TStarterArray;
{$ENDIF USE_LIBICU}

function IsDBCSLeadByteEx(CodePage: cardinal; TestChar: Byte): LongBool;
{$IFDEF USE_LIBICU}
var
  Err: UErrorCode;
  Conv: PUConverter;
begin
  Result := False;
  Err := 0;
  if CodePage <> LastLeadCodePage then
  begin
    Conv := ucnv_open(_PAnsiChr(LocaleNameFromCodePage(CodePage)), Err);
    if Err > 0 then Exit;
    try
      Err := 0;
      if assigned(ucnv_getStarters) then
        ucnv_getStarters(Conv, LastLeadStarters, Err)
      else
        Err := 1;
      if Err = 0 then
        LastLeadCodePage := CodePage;
    finally
      ucnv_close(Conv);
    end;
  end;
  if (Err = 0) and (LastLeadStarters[TestChar] = 1) then Result := True;
end;
{$ELSE}
const
  MB_ERR_INVALID_CHARS = 8;
var
  Dest: WideChar;
begin
  Result := False;
  if (TestChar > $7F) and
     (UnicodeFromLocaleChars(CodePage, MB_ERR_INVALID_CHARS,
         @TestChar, 1, @Dest, 1) = 0) then
    Result := True
end;
{$ENDIF}
{$ENDIF POSIX}

//    For eof, #$1A is returned in both lower and upper 8 bits.
//    For errors, InOutRes is set and #$1A is returned.
function _GetWideChar(var t: TTextRec; var IsEof: Boolean): Word;
var
  c: byte;
  ind, len: integer;
  wBuf : array[0..1] of WideChar;
  buf: _RawByteStr;
  U : UnicodeString;
begin
  IsEof := False;

  if t.MBCSLength > 0 then
  begin
    // A -> Wide
    if t.MBCSBufPos <> 0 then
    begin
      // Remove partial character.
      t.MBCSLength := 0;
    end
    else
    begin
      len := WCharFromChar(PWideChar(@wBuf[0]), 2, _PAnsiChr(@t.MBCSBuffer[0]), t.MBCSLength, DefaultSystemCodePage);
      t.MBCSLength := -len;
      move(wBuf[0], t.UTF16Buffer[0], len*2);
    end;
  end;


  if t.MBCSLength < 0 then
  begin
    Result := Word(t.UTF16Buffer[t.MBCSBufPos]);
    Exit;
  end
  else if (t.CodePage = CP_UTF16) then
  begin
    Result := _ReadWord(t, IsEof);
    if Not IsEof then
      Dec(t.BufPos, 2);
  end
  else
  begin
    c := _ReadByte(t, IsEof);
    if IsEof then
    begin
      Result := cEOF;
      Exit;
    end;

    if t.CodePage = CP_UTF8 then
    begin
      if byte(c) in [$C2..$DF] then
        Len := 2
      else if byte(c) in [$E0..$EF] then
        Len := 3
      else if byte(c) in [$F0..$F4] then
        Len := 4
      else
        Len := 1;
    end
    else if IsDBCSLeadByteEx(Cardinal(DefaultSystemCodePage), c) then
      Len := 2
    else
      Len := 1;

    SetLength(buf, len);
    SetCodePage(buf, t.CodePage, False);

    buf[Low(string)] := _AnsiChr(c);
    ind := Low(string) + 1;
    dec(Len);
    while len > 0 do
    begin
      c := _ReadByte(t, IsEof);
      buf[ind] := _AnsiChr(c);
      Inc(Ind);
      Dec(Len);
    end;

    U := UnicodeString(buf);
    len := Length(U);
    if Len > 0 then
    begin
      Move(U[Low(string)], t.UTF16Buffer[0], Len*2);

      t.MBCSBufPos := 0;
      t.MBCSLength := -Length(U);
      Result := Word(U[Low(string)]);
    end
    else
      Result := 0;
  end;
end;

function _GetWideChar2(var t: TTextRec; var IsEof: Boolean): Word;
begin
  if t.MBCSLength <> 0 then
    Exit(_GetWideChar(t, IsEof));

  Result := _ReadWord(t, IsEof);
  if Not IsEof then
    Dec(t.BufPos, 2);
end;

procedure _SkipWideChar(var t: TTextRec);
begin
  if t.MBCSLength < 0 then
  begin
    Inc(t.MBCSBufPos);
    if -t.MBCSLength = t.MBCSBufPos then
      t.MBCSLength := 0;
  end
  else
    Inc(t.BufPos, 2)
end;

function _ReadChar(var t: TTextRec): _AnsiChr;
var
  eof: Boolean;
begin
  Result := _AnsiChr(_GetAnsiChar(t, eof, DefaultSystemCodePage));
  _SkipAnsiChar(t);
end;

function _ValLongL(const s: _AnsiStr; var code: Integer): Integer;
begin
  Result := _ValLong(string(s), code);
end;

function _ReadLong(var t: TTextRec): Integer;
type
  TStrRec32 = packed record
    hdr: StrRec;
    data: array[0..35] of Byte;
  end;
var
  s: TStrRec32;
  c: Byte;
  p: PByte;
  eof: Boolean;
  count: Integer;
  code: Integer;
begin
  if _SeekEof(t) then
    Result := 0
  else
  begin
    p := @s.data[0];
    for count := 1 to 32 do
    begin
      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
      if c <= $20 then Break;
      p^ := c;
      _SkipAnsiChar(t);
      Inc(p);
    end;
    p^ := 0;
    s.hdr.codePage := CP_ACP;
    s.hdr.elemSize := 1;
    s.hdr.refCnt := -1;
    s.hdr.length := p - PByte(@s.data[0]);
    Result := _ValLongL(_PAnsiChr(@s.data), code);
    if code <> 0 then
      SetInOutRes(106);
  end;
end;

procedure _PushCRLF(var t: TTextRec);
begin
  t.MBCSBuffer[0] := _AnsiChr(cCR);
  t.MBCSBuffer[1] := _AnsiChr(cLF);
  t.MBCSLength := 2; //Ansi 2 byets.
  t.MBCSBufPos := 0;
end;

function ReadAnsiLineEx(var t: TTextRec; buf: Pointer; maxLen: Integer; var Count: Integer; CodePage: Word): Pointer;
var
  c : Byte;
  eof: Boolean;
  p : PByte;
begin
  Result := @t;
  Count := 0;

  if t.Mode <> fmInput then
    if not TryOpenForInput(t) then
      exit;

  if maxLen <= 0 then Exit;
  if CodePage = 0 then
    CodePage := DefaultSystemCodePage;

  p := PByte(buf);
  while (maxLen > 0) do
  begin
    c := _GetAnsiChar(t, eof, CodePage);
    if eof then Exit;
    if c = cLF then
    begin
      Exit;
    end
    else if c = cCR then
    begin
      _SkipAnsiChar(t);
      c := _GetAnsiChar(t, eof, CodePage);
      if c = cLF then
      begin
        _SkipAnsiChar(t);
        _PushCRLF(t);
        Exit;
      end
      else
      continue;
    end
    else
    begin
      p^ := c;
      _SkipAnsiChar(t);
      Inc(p);
      Dec(maxLen);
      inc(Count);
    end;
  end;
end;

function ReadAnsiLineEx2(var t: TTextRec; buf: Pointer; maxLen: Integer; var Count: Integer): Pointer;
var
  c : Byte;
  eof: Boolean;
  p : PByte;
begin
  if t.MBCSLength <> 0 then
    Exit(ReadAnsiLineEx(t, buf, maxLen, Count, t.CodePage));

  Result := @t;
  Count := 0;

  if t.Mode <> fmInput then
    if not TryOpenForInput(t) then
      exit;

  if maxLen <= 0 then Exit;

  p := PByte(buf);
  while (maxLen > 0) do
  begin
    c := _ReadByte(t, eof);
    if eof then Exit;
    if c = cLF then
    begin
      Dec(t.BufPos);
      Exit;
    end
    else if c = cCR then
    begin
      c := _ReadByte(t, eof);
      if (c = cEOF) then Exit;
      if c = cLF then
      begin
        _PushCRLF(t);
        Exit;
      end
      else
      Dec(t.BufPos);
      continue;
    end
    else
    begin
      p^ := c;
      Inc(p);
      Dec(maxLen);
      inc(Count);
    end;
  end;
end;

// maxLen and Count are the number of (wide)char.
function ReadWideLineEx(var t: TTextRec; buf: Pointer; maxLen: Integer; var Count: Integer): Pointer;
var
  w : Word;
  eof: Boolean;
  p : PWord;
begin
  Result := @t;
  Count := 0;

  if t.Mode <> fmInput then
    if not TryOpenForInput(t) then
      exit;

  if maxLen <= 0 then Exit;

  p := PWord(buf);
  while (maxLen > 0) do
  begin
    w := _GetWideChar(t, eof);
    if eof then Exit;
    if w = cLF then
    begin
      Exit;
    end
    else if w = cCR then
    begin
      _SkipWideChar(t);
      w := _GetWideChar(t, eof);
      if w = cLF then
      begin
        _SkipWideChar(t);
        _PushCRLF(t);
        Exit;
      end
      else
      continue;
    end
    else
    begin
      p^ := w;
      _SkipWideChar(t);
      Inc(p);
      Dec(maxLen);
      inc(Count);
    end;
  end;
end;

function ReadWideLineEx2(var t: TTextRec; buf: Pointer; maxLen: Integer; var Count: Integer): Pointer;
var
  w : Word;
  eof: Boolean;
  p : PWord;
begin
  if t.MBCSLength <> 0 then
    Exit(ReadAnsiLineEx(t, buf, maxLen, Count, t.CodePage));

  Result := @t;
  Count := 0;

  if t.Mode <> fmInput then
    if not TryOpenForInput(t) then
      exit;

  if maxLen <= 0 then Exit;

  p := PWord(buf);
  while (maxLen > 0) do
  begin
    w := _ReadWord(t, eof);
    if eof then Exit;
    if w = cLF then
    begin
      Dec(t.BufPos, 2);
      Exit;
    end
    else if w = cCR then
    begin
      w := _ReadWord(t, eof);
      if w = cLF then
      begin
        _PushCRLF(t);
        Exit;
      end
      else
      Dec(t.BufPos, 2);
      continue;
    end
    else
    begin
      p^ := w;
      Inc(p);
      Dec(maxLen);
      inc(Count);
    end;
  end;
end;

procedure _ReadString(var t: TTextRec; s: _PShortStr; maxLen: Integer);
var
  Count: Integer;
begin
  ReadAnsiLineEx(t, @s^[1], maxLen, Count, DefaultSystemCodePage);
  Byte(s^[0]) := Count;
end;

procedure _ReadCString(var t: TTextRec; s: _PAnsiChr; maxLen: Integer);
var
  Count: Integer;
begin
  ReadAnsiLineEx(t, s, maxLen, Count, DefaultSystemCodePage);
  s[Count] := #0;
end;

procedure _ReadLString(var t: TTextRec; var s: _AnsiStr; CodePage: Word);
var
  Count: Integer;
  Temp, Buf: _RawByteStr;
  U: UnicodeString;
begin
  s := '';

  if t.CodePage = CP_UTF16 then
  begin
    _ReadUString(t, U);
    _LStrFromUStr(s, U, CodePage);
  end
  else
  begin
    SetLength(Buf, 255);
    SetCodePage(Buf, t.CodePage, False);

    ReadAnsiLineEx2(t, @buf[Low(string)], 255, Count);
    SetLength(Buf, Count);
    Temp := buf;
    while Count = 255 do
    begin
      SetLength(Buf, 255);
      SetCodePage(Buf, t.CodePage, False);
      ReadAnsiLineEx2(t, @buf[Low(string)], 255, Count);
      SetLength(Buf, Count);
      Temp := Temp + Buf;
    end;
    if CodePage <> t.CodePage then
    begin
      if Temp <> '' then
      begin
        _UStrFromLStr(U, Temp);
        _LStrFromUStr(s, U, CodePage);
      end;
    end
    else
      s := Temp;
  end;
end;

procedure _ReadUString(var t: TTextRec; var s: UnicodeString);
var
  Count: Integer;
  Buf: UnicodeString;
  a: _AnsiStr;
begin
  s := '';

  if t.CodePage = CP_UTF16 then
  begin
    SetLength(Buf, 255);
    ReadWideLineEx2(t, Pointer(Buf), 255, Count);
    SetLength(Buf, Count);
    s := Buf;

    while Count = 255 do
    begin
      SetLength(Buf, 255);
      ReadWideLineEx2(t, PWideChar(Buf), 255, Count);
      SetLength(Buf, Count);
      s := s + Buf;
      Buf := '';
    end;
  end
  else
  begin
    _ReadLString(t, a, t.CodePage);
    if a <> '' then
      _UStrFromLStr(s, a);
  end;
end;

function _ReadWChar(var t: TTextRec): WideChar;
var
  eof: Boolean;
begin
  Result := WideChar(_GetWideChar(t, eof));
  _SkipWideChar(t);
end;

procedure _ReadWCString(var t: TTextRec; s: PWideChar; maxBytes: Integer);
var
  Count: Integer;
begin
  ReadWideLineEx(t, s, maxBytes div 2, Count);
  s[Count] := #0;
end;

procedure _ReadWString(var t: TTextRec; var s: _WideStr);
var
  Temp: UnicodeString;
begin
  _ReadUString(t, Temp);
  s := _WideStr(Temp);
end;

function _ValExtL(const s: _AnsiStr; var code: Integer): Extended;
begin
  Val(string(s), Result, code);
end;

function _ReadExt(var t: TTextRec): Extended;
var
  p: PWord;
  count: Integer;
  c: Byte;
  eof: Boolean;
  code: Integer;
  u: UnicodeString;
begin
  if _SeekEof(t) then
    Result := 0
  else
  begin
    SetLength(U, 64);
    p := PWord(U);
    for count := 1 to 64 do
    begin
      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
      if c <= $20 then break;
      p^ := c;
      _SkipAnsiChar(t);
      Inc(p);
    end;
    SetLength(U, (PByte(p) - PByte(U)) div sizeof(word));
    Val(u, Result, code);
    if code <> 0 then
      SetInOutRes(106);
  end;
end;

procedure _ReadLn(var t: TTextRec);
var
  c: Byte;
  eof: Boolean;
begin
  c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
  _SkipAnsiChar(t);
  while True do
  begin
    if c = cLF then break; // accept LF as end of line
    if eof then break;
    if c = cCR then
    begin
      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
      _SkipAnsiChar(t);
      if c = cLF then break; // accept CR+LF as end of line
      if eof then break; // accept CR+EOF as end of line
      // else CR+ anything else is not a line break.
    end
    else
    begin
      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
      _SkipAnsiChar(t);
    end;
  end;
end;

procedure _Rename(var f: TFileRec; newName: PChar);
var
  I: Integer;
  oldName: string;
{$IFDEF POSIX}
  usOldName: _UTF8Str;
  usNewName: _UTF8Str;
{$ENDIF POSIX}
begin
  if f.Mode = fmClosed then
  begin
    if newName = nil then newName := '';
    oldName := f.Name;
{$IFDEF POSIX}
    usNewName := _UTF8Str(newName);
    usOldName := _UTF8Str(oldName);
    if __rename(_PAnsiChr(usOldName), _PAnsiChr(usNewName)) = 0 then
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
    if MoveFile(PChar(oldName), newName) then
{$ENDIF MSWINDOWS}
    begin
      I := 0;
      while (newName[I] <> #0) and (I < High(f.Name)) do
      begin
        f.Name[I] := newName[I];
        Inc(I);
      end
    end
    else
      SetInOutRes(GetLastError);
  end
  else
    SetInOutRes(102);
end;

procedure Release;
begin
  Error(reInvalidPtr);
end;

function _CloseFile(var f: TFileRec): Integer;
begin
  f.Mode := fmClosed;
  Result := 0;
  if not InternalClose(f.Handle) then
  begin
    InOutError;
    Result := 1;
  end;
end;

function OpenFile(var f: TFileRec; recSiz: Integer; mode: Integer): Integer;
{$IFDEF POSIX}
var
   Flags: Integer;
   uName: _UTF8Str;
begin
  Result := 0;
  if (f.Mode >= fmClosed) and (f.Mode <= fmInOut) then
  begin
    if f.Mode <> fmClosed then // not yet closed: close it
    begin
      Result := TFileIOFunc(f.CloseFunc)(f);
      if Result <> 0 then
      begin
        SetInOutRes(Result);
        Exit;
      end
    end;

    if recSiz <= 0 then
    begin
      SetInOutRes(106);
      Exit;
    end;

    f.RecSize := recSiz;
    f.InOutFunc := @FileNopProc;

    if f.Name[0] <> #0 then
    begin
      f.CloseFunc := @_CloseFile;
      case mode of
        1: begin
             Flags := O_APPEND or O_WRONLY;
             f.Mode := fmOutput;
           end;
        2: begin
             Flags := O_RDWR;
             f.Mode := fmInOut;
           end;
        3: begin
             Flags := O_CREAT or O_TRUNC or O_RDWR;
             f.Mode := fmInOut;
           end;
      else
        Flags := O_RDONLY;
        f.Mode := fmInput;
      end;

      uName := _UTF8Str(f.Name);
      f.Handle := __open(_PAnsiChr(uName), Flags, FileAccessRights);
    end
    else  // stdin or stdout
    begin
      f.CloseFunc := @FileNopProc;
      if mode = 3 then
        f.Handle := STDOUT_FILENO
      else
        f.Handle := STDIN_FILENO;
    end;

    if f.Handle = -1 then
    begin
      f.Mode := fmClosed;
      InOutError;
    end;
  end
  else
    SetInOutRes(102);
end;
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
const
  ShareTab: array [0..7] of Integer =
    (FILE_SHARE_READ OR FILE_SHARE_WRITE,  // OF_SHARE_COMPAT     0x00000000
     0,                                    // OF_SHARE_EXCLUSIVE  0x00000010
     FILE_SHARE_READ,                      // OF_SHARE_DENY_WRITE 0x00000020
     FILE_SHARE_WRITE,                     // OF_SHARE_DENY_READ  0x00000030
     FILE_SHARE_READ OR FILE_SHARE_WRITE,  // OF_SHARE_DENY_NONE  0x00000040
     0,0,0);
{$IFDEF PUREPASCAL}
var
   DesiredAccess: DWORD;
   SharedMode: Integer;
   CreationDisposition: Integer;
begin
  Result := 0;
  if (f.Mode >= fmClosed) and (f.Mode <= fmInOut) then
  begin
    if f.Mode <> fmClosed then // not yet closed: close it
    begin
      Result := TFileIOFunc(f.CloseFunc)(f);
      if Result <> 0 then
      begin
        SetInOutRes(Result);
        Exit;
      end
    end;

    if recSiz <= 0 then
    begin
      SetInOutRes(106);
      Exit;
    end;

    f.RecSize := recSiz;
    f.InOutFunc := @FileNopProc;

    if f.Name[0] <> #0 then
    begin
      f.CloseFunc := @_CloseFile;
      SharedMode := shareTab[(FileMode and $70) shr 4];
      case mode of
        1: begin
             CreationDisposition := OPEN_EXISTING;
             DesiredAccess := GENERIC_WRITE;
             f.Mode := fmOutput;
           end;
        2: begin
             CreationDisposition := OPEN_EXISTING;
             DesiredAccess := GENERIC_READ OR GENERIC_WRITE;
             f.Mode := fmInOut;
           end;
        3: begin
             DesiredAccess := GENERIC_READ OR GENERIC_WRITE;
             CreationDisposition := CREATE_ALWAYS;
             f.Mode := fmInOut;
           end;
      else
        CreationDisposition := OPEN_EXISTING;
        DesiredAccess := GENERIC_READ;
        f.Mode := fmInput;
      end;
      f.Handle := CreateFile(f.Name, DesiredAccess, SharedMode, nil,
                             CreationDisposition, FILE_ATTRIBUTE_NORMAL, 0);
    end
    else  // stdin or stdout
    begin
      f.CloseFunc := @FileNopProc;
      if mode = 3 then
        f.Handle := GetStdHandle(STD_OUTPUT_HANDLE)
      else
        f.Handle := GetStdHandle(STD_INPUT_HANDLE);;
    end;
    if f.Handle = -1 then
    begin
      f.Mode := fmClosed;
      InOutError;
    end;
  end
  else
    SetInOutRes(102);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
//->  EAX Pointer to file record
//    EDX Record size
//    ECX File mode

        PUSH     EBX
        PUSH     ESI
        PUSH     EDI

        MOV      ESI,EDX
        MOV      EDI,ECX
        XOR      EDX,EDX
        MOV      EBX,EAX

        MOV      DX,[EAX].TFileRec.Mode
        SUB      EDX,fmClosed
        JE       @@alreadyClosed
        CMP      EDX,fmInOut-fmClosed
        JA       @@notAssignedError

//  not yet closed: close it. File parameter is still in EAX

        CALL     [EBX].TFileRec.CloseFunc
        TEST     EAX,EAX
        JNE      @@errExit

@@alreadyClosed:

        CMP     ESI,0
        JLE     @@invalidRecSize
        MOV     [EBX].TFileRec.Mode,fmInOut
        MOV     [EBX].TFileRec.RecSize,ESI
        MOV     [EBX].TFileRec.CloseFunc,offset _CloseFile
        MOV     [EBX].TFileRec.InOutFunc,offset FileNopProc

        CMP     word ptr [EBX].TFileRec.Name,0
        JE      @@isCon

        MOV     EAX,GENERIC_READ OR GENERIC_WRITE
        MOV     DL,FileMode
        AND     EDX,070H
        SHR     EDX,4-2
        MOV     EDX,dword ptr [shareTab+EDX]
        MOV     ECX,CREATE_ALWAYS

        SUB     EDI,3
        JE      @@calledByRewrite

        MOV     ECX,OPEN_EXISTING
        INC     EDI
        JE      @@skip

        MOV     EAX,GENERIC_WRITE
        INC     EDI
        MOV     [EBX].TFileRec.Mode,fmOutput
        JE      @@skip

        MOV     EAX,GENERIC_READ
        MOV     [EBX].TFileRec.Mode,fmInput

@@skip:
@@calledByRewrite:

//  CreateFile(t.FileName, EAX, EDX, Nil, ECX, FILE_ATTRIBUTE_NORMAL, 0);

        PUSH     0
        PUSH     FILE_ATTRIBUTE_NORMAL
        PUSH     ECX
        PUSH     0
        PUSH     EDX
        PUSH     EAX
        LEA      EAX,[EBX].TFileRec.Name
        PUSH     EAX
        CALL     CreateFile
@@checkHandle:
        CMP      EAX,-1
        JZ       @@error

        MOV      [EBX].TFileRec.Handle,EAX
        JMP      @@exit

@@isCon:
        MOV      [EBX].TFileRec.CloseFunc,offset FileNopProc
        CMP      EDI,3
        JE       @@output
        PUSH     STD_INPUT_HANDLE
        JMP      @@1
@@output:
        PUSH     STD_OUTPUT_HANDLE
@@1:
        CALL     GetStdHandle
        JMP      @@checkHandle

@@notAssignedError:
        MOV      EAX,102
        JMP      @@errExit

@@invalidRecSize:
        MOV      EAX,106
        JMP      @@errExit

@@error:
        MOV      [EBX].TFileRec.Mode,fmClosed
        CALL     GetLastError

@@errExit:
        CALL     SetInOutRes

@@exit:
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}

function _ResetFile(var f: TFileRec; recSize: Integer): Integer;
var
  m: Byte;
begin
  m := FileMode and 3;
  if m > 2 then m := 2;
  Result := OpenFile(f, recSize, m);
end;

function _RewritFile(var f: TFileRec; recSize: Integer): Integer;
begin
  Result := OpenFile(f, recSize, 3);
end;

procedure _Seek(var f: TFileRec; recNum: Cardinal);
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
var
  Val64: UInt64;
  Val32Low: UInt32;
  Val32High: UInt32;
  Res: Integer;
begin
  if (f.Mode >= fmInput) and (f.Mode <= fmInOut) then
  begin
    Val64 := UInt64(recNum) * f.RecSize;
    Val32High := UInt32(Val64 shr 32);
    Val32Low := UInt32(Val64);

    Res := Integer(SetFilePointer(f.Handle, Val32Low, @Val32High, FILE_BEGIN));
    if (Res = -1) and (GetLastError <> 0{NO_ERROR}) then
      InOutError
    else
    begin
      if Res < 0 then
        SetInOutRes(131);
    end
  end else
    SetInOutRes(103);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
// -> EAX Pointer to file variable
//    EDX Record number

        MOV      ECX,EAX
        MOVZX    EAX,[EAX].TFileRec.Mode // check whether file is open
        SUB      EAX,fmInput
        CMP      EAX,fmInOut-fmInput
        JA       @@fileNotOpen

//  SetFilePointer(f.Handle, recNum*f.RecSize, FILE_BEGIN)
        PUSH     FILE_BEGIN    // pass dwMoveMethod
        MOV      EAX,[ECX].TFileRec.RecSize
        MUL      EDX
        PUSH     0           // pass lpDistanceToMoveHigh
        PUSH     EAX           // pass lDistanceToMove
        PUSH     [ECX].TFileRec.Handle   // pass hFile
        CALL     SetFilePointer          // get current position
        INC      EAX
        JZ       InOutError
        JMP      @@exit

@@fileNotOpen:
        MOV      EAX,103
        JMP      SetInOutRes

@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  if (f.Mode >= fmInput) and (f.Mode <= fmInOut) then
  begin
    if Integer(recNum) < 0 then  // Match windows behaviour. Only 0 .. MaxInt sizes are allowed.
      SetInOutRes(131)           // Negative seeks are dissablowed.
    else
                                                 
      if lseek(f.Handle, f.RecSize * recNum, SEEK_SET) = -1 then
        InOutError;
  end
  else
    SetInOutRes(103);
end;
{$ENDIF POSIX}

function _SeekEof(var t: TTextRec): Boolean;
var
  c: Byte;
  eof: Boolean;
begin
  Result := False;
  while True do
  begin
    c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
    if c > $20 then break;
    if eof then
    begin
      Result := True;
      break;
    end;
    _SkipAnsiChar(t);
  end;
end;

function _SeekEoln(var t: TTextRec): Boolean;
var
  c: Byte;
  eof: Boolean;
begin
  Result := False;
  while True do
  begin
    c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
    if c > $20 then break;
    if eof then
    begin
      Result := True;
      break;
    end;
    if (c = cLF) or (c = cCR) then
    begin
      Result := True;
      break;
    end;
    _SkipAnsiChar(t);
  end;
end;

procedure _SetTextBuf(var t: TTextRec; p: Pointer; size: Integer);
begin
  if size < 0 then
    Error(reRangeError);
  t.BufPtr := P;
  t.BufSize := size;
  t.BufPos := 0;
  t.BufEnd := 0;
end;

function _StrLong(val, width: Integer): _ShortStr;
{$IFDEF PUREPASCAL}
var
  I: Integer;
  sign: Integer;
  a: array [0..19] of _AnsiChr;
  P: _PAnsiChr;
begin
  // U-OK
  sign := val;
  val := Abs(val);
  I := 0;
  repeat
    a[I] := _AnsiChr((Cardinal(val) mod 10) + Ord('0'));
    Inc(I);
    val := Cardinal(val) div 10;
  until val = 0;

  if sign < 0 then
  begin
    a[I] := '-';
    Inc(I);
  end;

  if width < I then
    width := I;
  if width > 255 then
    width := 255;
  Result[0] := _AnsiChr(width);
  P := @Result[1];
  while width > I do
  begin
    P^ := ' ';
    Inc(P);
    Dec(width);
  end;
  repeat
    Dec(I);
    P^ := a[I];
    Inc(P);
  until I <= 0;
end;
{$ELSE}
asm
{       PROCEDURE _StrLong( val: Integer; width: Integer; VAR s: _ShortStr );
      ->EAX     Value
        EDX     Width
        ECX     Pointer to string       }

        PUSH    EBX             { VAR i: Integer;               }
        PUSH    ESI             { VAR sign : Integer;           }
        PUSH    EDI
        PUSH    EDX             { store width on the stack      }
        SUB     ESP,20          { VAR a: array [0..19] of Char; }

        MOV     EDI,ECX

        MOV     ESI,EAX         { sign := val                   }

        CDQ                     { val := Abs(val);  canned sequence }
        XOR     EAX,EDX
        SUB     EAX,EDX

        MOV     ECX,10
        XOR     EBX,EBX         { i := 0;                       }

@@repeat1:                      { repeat                        }
        XOR     EDX,EDX         {   a[i] := Chr( val MOD 10 + Ord('0') );}

        DIV     ECX             {   val := val DIV 10;          }

        ADD     EDX,'0'
        MOV     [ESP+EBX],DL
        INC     EBX             {   i := i + 1;                 }
        TEST    EAX,EAX         { until val = 0;                }
        JNZ     @@repeat1

        TEST    ESI,ESI
        JGE     @@2
        MOV     byte ptr [ESP+EBX],'-'
        INC     EBX
@@2:
        MOV     [EDI],BL        { s^++ := Chr(i);               }
        INC     EDI

        MOV     ECX,[ESP+20]    { spaceCnt := width - i;        }
        CMP     ECX,255
        JLE     @@3
        MOV     ECX,255
@@3:
        SUB     ECX,EBX
        JLE     @@repeat2       { for k := 1 to spaceCnt do s^++ := ' ';        }
        ADD     [EDI-1],CL
        MOV     AL,' '
        REP     STOSB

@@repeat2:                      { repeat                        }
        MOV     AL,[ESP+EBX-1]  {   s^ := a[i-1];               }
        MOV     [EDI],AL
        INC     EDI             {   s := s + 1                  }
        DEC     EBX             {   i := i - 1;                 }
        JNZ     @@repeat2       { until i = 0;                  }

        ADD     ESP,20+4
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF}

function _Str0Long(val: Integer): _ShortStr;
begin
  Result := _StrLong(val, 0);
end;

procedure _Truncate(var f: TFileRec);
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
begin
  if (f.Mode = fmOutput) or (f.Mode = fmInOut) then
  begin
    if not SetEndOfFile(f.Handle) then
      InOutError;
  end else
    SetInOutRes(103);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
// -> EAX Pointer to text or file variable

       MOVZX   EDX,[EAX].TFileRec.Mode   // check whether file is open
       SUB     EDX,fmInput
       CMP     EDX,fmInOut-fmInput
       JA      @@fileNotOpen

       PUSH    [EAX].TFileRec.Handle
       CALL    SetEndOfFile
       DEC     EAX
       JZ      @@exit
       JMP     InOutError

@@fileNotOpen:
       MOV     EAX,103
       JMP     SetInOutRes

@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  if (f.Mode and fmOutput) = fmOutput then  // fmOutput or fmInOut
  begin
    if ftruncate(f.Handle, lseek(f.Handle, 0, SEEK_CUR)) = -1 then
      InOutError;
  end
  else
    SetInOutRes(103);
end;
{$ENDIF POSIX}

// Hex : ( '$' | 'X' | 'x' | '0X' | '0x' ) [0-9A-Fa-f]*
// Dec : ( '+' | '-' )? [0-9]*
function _ValLong(const S: string; var Code: Integer): Integer;
{$IFDEF PUREPASCAL}
const
  FirstIndex = Low(string);
var
  I: Integer;
  Dig: Integer;
  Sign: Boolean;
  Empty: Boolean;
begin
  I := FirstIndex;
  Sign := False;
  Result := 0;
  {$IF not (defined(CPUX64) and not defined(EXTERNALLINKER))}
  Dig := 0;
  {$ENDIF}
  Empty := True;

  if S = '' then
  begin
    Code := 1;
    Exit;
  end;
  while S[I] = ' ' do
    Inc(I);

  if S[I] = '-' then
  begin
    Sign := True;
    Inc(I);
  end
  else if S[I] = '+' then
    Inc(I);
  // Hex
  if ((S[I] = '0') and (I < High(S)) and ((S[I+1] = 'X') or (S[I+1] = 'x'))) or
      (S[I] = '$') or
      (S[I] = 'X') or
      (S[I] = 'x') then
  begin
    if S[I] = '0' then
      Inc(I);
    Inc(I);
    while True do
    begin
      case S[I] of
       '0'..'9': Dig := Ord(S[I]) - Ord('0');
       'A'..'F': Dig := Ord(S[I]) - Ord('A') + 10;
       'a'..'f': Dig := Ord(S[I]) - Ord('a') + 10;
      else
        Break;
      end;
      if (Result < 0) or (Result > (High(Integer) shr 3)) then
        Break;
      Result := Result shl 4 + Dig;
      Inc(I);
      Empty := False;
    end;

    if Sign then
      Result := - Result;
  end
  // Decimal
  else
  begin
    while True do
    begin
      case S[I] of
        '0'..'9': Dig := Ord(S[I]) - Ord('0');
      else
        Break;
      end;
      if (Result < 0) or (Result > (High(Integer) div 10)) then
        Break;
      Result := Result*10 + Dig;
      Inc(I);
      Empty := False;
    end;

    if Sign then
      Result := - Result;
    if (Result <> 0) and (Sign <> (Result < 0)) then
      Dec(I);
  end;

  if ((S[I] <> Char(#0)) or Empty) then
    Code := I + 1 - FirstIndex
  else
    Code := 0;
end;
{$ELSE !PUREPASCAL}
asm
{       FUNCTION _ValLong( s: string; VAR code: Integer ) : Integer;    }
{     ->EAX     Pointer to string       }
{       EDX     Pointer to code result  }
{     <-EAX     Result                  }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV     ESI,EAX
        PUSH    EAX             { save for the error case       }

        TEST    EAX,EAX
        JE      @@empty

        XOR     EAX,EAX
        XOR     EBX,EBX
        MOV     EDI,07FFFFFFFH / 10     { limit }

@@blankLoop:
        MOV     BX,[ESI]
        ADD     ESI, 2
        CMP     BX,' '
        JE      @@blankLoop

@@endBlanks:
        MOV     CH,0
        CMP     BX,'-'
        JE      @@minus
        CMP     BX,'+'
        JE      @@plus

@@checkDollar:
        CMP     BX,'$'
        JE      @@dollar

        CMP     BX, 'x'
        JE      @@dollar
        CMP     BX, 'X'
        JE      @@dollar
        CMP     BX, '0'
        JNE     @@firstDigit
        MOV     BX, [ESI]
        ADD     ESI, 2
        CMP     BX, 'x'
        JE      @@dollar
        CMP     BX, 'X'
        JE      @@dollar
        TEST    BX, BX
        JE      @@endDigits
        JMP     @@digLoop

@@firstDigit:
        TEST    BX,BX
        JE      @@error

@@digLoop:
        SUB     BX,'0'
        CMP     BX,9
        JA      @@error
        CMP     EAX,EDI         { value > limit ?       }
        JA      @@overFlow
        LEA     EAX,[EAX+EAX*4]
        ADD     EAX,EAX
        ADD     EAX,EBX         { fortunately, we can't have a carry    }
        MOV     BX,[ESI]
        ADD     ESI, 2
        TEST    BX,BX
        JNE     @@digLoop

@@endDigits:
        DEC     CH
        JE      @@negate
        TEST    EAX,EAX
        JGE     @@successExit
        JMP     @@overFlow

@@empty:
        ADD     ESI, 2
        JMP     @@error

@@negate:
        NEG     EAX
        JLE     @@successExit
        JS      @@successExit           { to handle 2**31 correctly, where the negate overflows }

@@error:
@@overFlow:
        POP     EBX
        SUB     ESI,EBX
        JMP     @@exit

@@minus:
        INC     CH
@@plus:
        MOV     BX,[ESI]
        ADD     ESI, 2
        JMP     @@checkDollar

@@dollar:
        MOV     EDI,0FFFFFFFH
        MOV     BX,[ESI]
        ADD     ESI, 2
        TEST    BX,BX
        JZ      @@empty

@@hDigLoop:
        CMP     BX,'a'
        JB      @@upper
        SUB     BX,'a' - 'A'
@@upper:
        SUB     BX,'0'
        CMP     BX,9
        JBE     @@digOk
        SUB     BX,'A' - '0'
        CMP     BX,5
        JA      @@error
        ADD     BX,10
@@digOk:
        CMP     EAX,EDI
        JA      @@overFlow
        SHL     EAX,4
        ADD     EAX,EBX
        MOV     BX,[ESI]
        ADD     ESI, 2
        TEST    BX,BX
        JNE     @@hDigLoop

        DEC     CH
        JNE     @@successExit
        NEG     EAX

@@successExit:
        POP     ECX                     { saved copy of string pointer  }
        XOR     ESI,ESI         { signal no error to caller     }

@@exit:
        SHR     ESI, 1
        MOV     [EDX],ESI
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF}

function _WriteRec(var f: TFileRec; buffer: Pointer): Pointer;
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
var
  NumWritten: Cardinal;
begin
  if (f.Mode = fmOutput) or (f.Mode = fmInOut) then
  begin
    if not WriteFile(f.Handle, Buffer, f.RecSize, NumWritten, nil) then
      SetInOutRes(GetLastError)
    else
    begin
      if f.RecSize <> NumWritten then
        SetInOutRes(101);
    end;
  end
  else
    SetInOutRes(5);
  Result := @F;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
// -> EAX Pointer to file variable
//    EDX Pointer to buffer
// <- EAX Pointer to file variable
        PUSH    EBX

        MOV     EBX,EAX

        MOVZX   EAX,[EAX].TFileRec.Mode
        SUB     EAX,fmOutput
        CMP     EAX,fmInOut-fmOutput  // File must be fmInOut or fmOutput
        JA      @@fileNotOpen

//  WriteFile(f.Handle, buffer^, f.RecSize, @result, Nil);

        PUSH    0                       // space for OS result
        MOV     EAX,ESP

        PUSH    0                       // pass lpOverlapped
        PUSH    EAX                     // pass @result
        PUSH    [EBX].TFileRec.RecSize  // pass nNumberOfBytesToRead
        PUSH    EDX                     // pass lpBuffer
        PUSH    [EBX].TFileRec.Handle   // pass hFile
        CALL    WriteFile
        POP     EDX                     // pop result
        DEC     EAX                     // check EAX = TRUE
        JNZ     @@error

        CMP     EDX,[EBX].TFileRec.RecSize  // result = f.RecSize ?
        JE      @@exit

@@writeError:
        MOV     EAX,101
        JMP     @@errExit

@@fileNotOpen:
        MOV     EAX,5
        JMP     @@errExit

@@error:
        CALL    GetLastError
@@errExit:
        CALL    SetInOutRes
@@exit:
        MOV     EAX,EBX
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
var
  Dummy: Integer;
begin
  _BlockWrite(f, Buffer, 1, @Dummy);
  Result := @F;
end;
{$ENDIF POSIX}

// If the file is Output or ErrOutput std variable, try to open it
// Otherwise, runtime error.
function TryOpenForOutput(var t: TTextRec): Boolean;
begin
  if (@t = @Output) or (@t = @ErrOutput) then
  begin
    t.Flags := tfCRLF * Byte(DefaultTextLineBreakStyle);
    _RewritText(t);
  end;

  Result := t.Mode = fmOutput;
  if not Result then
    SetInOutRes(105);
end;

function _WriteBytes(var t: TTextRec; const b; cnt: Integer): Pointer;
{$IFDEF PUREPASCAL}
var
  Dest, Source: _PAnsiChr;
  RemainingBytes: Integer;
  Temp: Integer;
begin
  // U-OK
  Result := @t;
  if (t.Mode <> fmOutput) and not TryOpenForOutput(t) then Exit;

  Source := Pointer(@b);
  Dest := t.BufPtr + t.BufPos;
  RemainingBytes := t.BufSize - t.BufPos;
  while RemainingBytes <= cnt do
  begin
    Inc(t.BufPos, RemainingBytes);
    Dec(cnt, RemainingBytes);
    Move(Source^, Dest^, RemainingBytes);
    Inc(Source, RemainingBytes);
    Temp := TTextIOFunc(t.InOutFunc)(t);
    if Temp <> 0 then
    begin
      SetInOutRes(Temp);
      Exit;
    end;
    Dest := t.BufPtr + t.BufPos;
    RemainingBytes := t.BufSize - t.BufPos;
  end;
  Inc(t.BufPos, cnt);
  Move(Source^, Dest^, cnt);
end;
{$ELSE !PUREPASCAL}
asm //StackAlignSafe
// -> EAX Pointer to file record
//    EDX Pointer to buffer
//    ECX Number of bytes to write
// <- EAX Pointer to file record

        PUSH    ESI
        PUSH    EDI

        MOV     ESI,EDX

        CMP     [EAX].TTextRec.Mode,fmOutput
        JE      @@loop
        PUSH    EAX
        PUSH    EDX
        PUSH    ECX
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        CALL    TryOpenForOutput
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
        TEST    AL,AL
        POP     ECX
        POP     EDX
        POP     EAX
        JE      @@exit

@@loop:
        MOV     EDI,[EAX].TTextRec.BufPtr
        ADD     EDI,[EAX].TTextRec.BufPos

//  remainingBytes = t.bufSize - t.bufPos

        MOV     EDX,[EAX].TTextRec.BufSize
        SUB     EDX,[EAX].TTextRec.BufPos

//  if (remainingBytes <= cnt)

        CMP     EDX,ECX
        JG      @@1

//  t.BufPos += remainingBytes, cnt -= remainingBytes

        ADD     [EAX].TTextRec.BufPos,EDX
        SUB     ECX,EDX

//  copy remainingBytes, advancing ESI

        PUSH    EAX
        PUSH    ECX
        MOV     ECX,EDX
        REP     MOVSB

{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    [EAX].TTextRec.InOutFunc
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        TEST    EAX,EAX
        JNZ     @@error

        POP     ECX
        POP     EAX
        JMP     @@loop

@@error:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    SetInOutRes
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        POP     ECX
        POP     EAX
        JMP     @@exit
@@1:
        ADD     [EAX].TTextRec.BufPos,ECX
        REP     MOVSB

@@exit:
        POP     EDI
        POP     ESI
end;
{$ENDIF}

function _WriteSpaces(var t: TTextRec; cnt: Integer): Pointer;
var
  A: _AnsiStr;
begin
  Result := @t;
  if cnt > 64 then
  begin
    SetLength(A, 64);
    FillChar(A[Low(A)], 64, #$20);
    while cnt > 64 do
    begin
      _Write0LString(t, A);
      if InOutRes <> 0 then Exit;
      Dec(cnt, 64);
    end;
  end;
  if cnt > 0 then
  begin
    SetLength(A, cnt);
    FillChar(A[Low(A)], cnt, #$20);
    _Write0LString(t, A);
    if InOutRes <> 0 then Exit;
  end;
end;

procedure InternalUStrFromPCharLen(var Dest: UnicodeString; Source: _PAnsiChr; Length: Integer; CodePage: Integer); forward;


function _Write0Char(var t: TTextRec; c: _AnsiChr): Pointer;

  procedure WriteUnicodeFromMBCSBuffer;
  var
    U : UnicodeString;
  begin
    InternalUStrFromPCharLen(U, t.MBCSBuffer, t.MBCSLength, DefaultSystemCodePage);
    _Write0UString(t, U);
    t.MBCSLength := 0;
    t.MBCSBufPos := 0;
  end;

begin
  if t.CodePage = 0 then TryOpenForOutput(t);
  if (t.CodePage = DefaultSystemCodePage) then
  begin
    Result := _WriteBytes(t, c, 1);
    exit;
  end;

  if t.MBCSLength = 0 then
  begin
    t.MBCSLength := 1;
    if DefaultSystemCodePage = CP_UTF8 then
    begin
      if byte(c) in [$C2..$DF] then
        t.MBCSLength := 2
      else if byte(c) in [$E0..$EF] then
        t.MBCSLength := 3
      else if byte(c) in [$F0..$F4] then
        t.MBCSLength := 4;
    end
{$IFDEF MSWINDOWS}
    else if IsDBCSLeadByteEx(UINT(DefaultSystemCodePage), Byte(c)) then
      t.MBCSLength := 2;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
                                                     
    else
      t.MBCSLength := 1;
{$ENDIF POSIX}
    t.MBCSBufPos := 0;
  end;

  if t.MBCSLength > 0 then
  begin
    t.MBCSBuffer[t.MBCSBufPos] := c;
    Inc(t.MBCSBufPos);
    if t.MBCSBufPos = byte(t.MBCSLength) then
      WriteUnicodeFromMBCSBuffer;
  end;
  Result := @t;
end;

function _WriteChar(var t: TTextRec; c: _AnsiChr; width: Integer): Pointer;
var
  A: _AnsiStr;
begin
  if width <= 1 then
    Result := _Write0Char(t, c)
  else
  begin
    __FlushMBCSBuffer(t);
    if t.CodePage = 0 then TryOpenForOutput(t);
    if t.CodePage = DefaultSystemCodePage then
    begin
      _WriteSpaces(t, width-1);
      Result := _WriteBytes(t, c, 1);
    end
    else
    begin
      _LStrFromChar(A, c, DefaultSystemCodePage);
      Result := _WriteLString(t, A, width);
    end;
  end;
end;

function _WriteBool(var t: TTextRec; val: Boolean; width: Integer): Pointer;
const
  BoolStrs: array [Boolean] of _ShortStr = ('FALSE', 'TRUE');
begin
  Result := _WriteString(t, BoolStrs[val<>false], width);
end;

function _Write0Bool(var t: TTextRec; val: Boolean): Pointer;
begin
  Result := _WriteBool(t, val, 0);
end;

function _WriteLong(var t: TTextRec; val, width: Integer): Pointer;
var
{$IFNDEF NEXTGEN}
  S: string[31];
{$ELSE}
  S: _ShortStr;
{$ENDIF}
begin
  Str(val:0, S);
  Result := _WriteString(t, S, width);
end;

function _Write0Long(var t: TTextRec; val: Integer): Pointer;
begin
  Result := _WriteLong(t, val, 0);
end;

function _Write0String(var t: TTextRec; const s: _ShortStr): Pointer;
begin
  result := _WriteString(t, s, 0);
end;

function _WriteString(var t: TTextRec; const s: _ShortStr; width: Integer): Pointer;
begin
  Result := _WriteLString(t, s, width);
end;

function _Write0CString(var t: TTextRec; s: _PAnsiChr): Pointer;
begin
  Result := _WriteCString(t, s, 0);
end;

function _WriteCString(var t: TTextRec; s: _PAnsiChr; width: Integer): Pointer;
var
  A: _AnsiStr;
begin
  _LStrFromPChar(A, s, DefaultSystemCodePage);
  Result := _WriteLString(t, A, width);
end;

function _Write0LString(var t: TTextRec; const s: _AnsiStr): Pointer;
begin
  __FlushMBCSBuffer(t);
  Result := @t;
  if s <> '' then
  begin
    if t.CodePage = 0 then TryOpenForOutput(t);
    if t.CodePage = PWord(PByte(s) - 12)^ then
      Result := _WriteBytes(t, s[Low(string)], Length(s))
    else
      Result := _Write0UString(t, UnicodeString(s));
  end;
end;

function _WriteLString(var t: TTextRec; const s: _AnsiStr; width: Integer): Pointer;
var
  i: Integer;
begin
  __FlushMBCSBuffer(t);
  if s = '' then
    Result := _WriteSpaces(t, width)
  else
  begin
    if t.CodePage = 0 then TryOpenForOutput(t);
    if t.CodePage = PWord(PByte(s) - 12)^ then
    begin
      i := Length(s);
      _WriteSpaces(t, width - i);
      Result := _WriteBytes(t, s[Low(string)], i);
    end
    else
      Result := _WriteUString(t, UnicodeString(s), width);
  end;
end;

function _Write0UString(var t: TTextRec; const s: UnicodeString): Pointer;
begin
  Result := _WriteUString(t, s, 0);
end;

function _WriteUString(var t: TTextRec; const s: UnicodeString; width: Integer): Pointer;
var
  i: Integer;
  A: _AnsiStr;
begin
  if s = '' then
    Result := _WriteSpaces(t, width )
  else
  begin
    if t.CodePage = 0 then TryOpenForOutput(t);
    if t.CodePage = CP_UTF16 then // Output is UTF16
    begin
      i := Length(s);
      _WriteSpaces(t, width - i);
      Result := _WriteBytes(t, s[Low(string)], i*sizeof(WideChar));
    end
    else
    begin
      if assigned(AlternateWriteUnicodeStringProc) then
        Result := AlternateWriteUnicodeStringProc(t, s)
      else
      begin
        _LStrFromUStr(A, s, t.CodePage);
        i := Length(A);
        _WriteSpaces(t, width - i);
        Result := _WriteBytes(t, A[Low(string)], i);
      end;
    end;
  end;
end;

function _Write0WString(var t: TTextRec; const s: _WideStr): Pointer;
begin
  Result := _WriteUString(t, s, 0);
end;

function _WriteWString(var t: TTextRec; const s: _WideStr; width: Integer): Pointer;
begin
  Result := _WriteUString(t, UnicodeString(s), width);
end;

function _Write0WCString(var t: TTextRec; s: PWideChar): Pointer;
begin
  Result := _WriteUString(t, UnicodeString(s), 0);
end;

function _WriteWCString(var t: TTextRec; s: PWideChar; width: Integer): Pointer;
begin
  Result := _WriteUString(t, UnicodeString(s), width);
end;

function _Write0WChar(var t: TTextRec; c: WideChar): Pointer;
begin
  Result := @t;
  if t.CodePage = 0 then TryOpenForOutput(t);
  if t.CodePage = CP_UTF16 then
  begin
    _WriteBytes(t, c, sizeof(WideChar));
    exit;
  end;

  if t.MBCSLength > 0 then
  begin
    if (Word(c) >= $DC00) and (Word(c) < $E000) then
    begin
      t.UTF16Buffer[1] := c;
      t.UTF16Buffer[2] := #0;

      _WriteUString(t, UnicodeString(t.UTF16Buffer), 0);
    end;
    t.MBCSLength := 0;
    exit;
  end;

  if (Word(c) >= $D800) and (Word(c) < $DC00) then
  begin
    t.MBCSLength := 2;
    t.UTF16Buffer[0] := c;
  end
  else
    _WriteUString(t, UnicodeString(c), 0);
end;

function _WriteWChar(var t: TTextRec; c: WideChar; width: Integer): Pointer;
begin
  if width <= 1 then
    result := _Write0WChar(t, c)
  else
  begin
    if t.MBCSLength < 0 then
    begin
      _Write0WChar(t, '?');
      t.UTF16Buffer[0] := #0;
    end;

    _WriteSpaces(t, width - 1);
    Result := _Write0WChar(t, c);
  end;
end;

function _Write0Variant(var T: TTextRec; const V: TVarData): Pointer;
begin
  Result := _WriteVariant(T, V, 0);
end;

function _WriteVariant(var T: TTextRec; const V: TVarData; Width: Integer): Pointer;
var
  S: _AnsiStr;
  U: UnicodeString;
begin
  if (V.VType = varString) and Assigned(VarToLStrProc) then
  begin
    VarToLStrProc(S, V);
    _WriteLString(T, S, Width);
  end
  else if Assigned(VarToUStrProc) then
  begin
    VarToUStrProc(U, V);
    _WriteUString(T, U, Width);
  end
  else
    Error(reVarInvalidOp);
  Result := @T;
end;

{$IF not DEFined(X86ASMRTL)}
function _Write2Ext(var T: TTextRec; Val: Extended; Width, Prec: Integer): Pointer;
var
 S : _ShortStr;
begin
  S := _Str2Ext(Val, Width, Prec);
  Result := _WriteString(T, S, Width);
end;
{$ELSE X86ASMRTL}
procedure _Write2Ext;
const
{$IFDEF MACOS}
  SizeOfExtendedOnStack = 16;
{$ELSE}
  SizeOfExtendedOnStack = 12;
{$ENDIF}
asm
{       PROCEDURE _Write2Ext( VAR t: Text; val: Extended; width, prec: Integer);
      ->EAX     Pointer to file record
        [ESP+4] Extended value
        EDX     Field width
        ECX     precision (<0: scientific, >= 0: fixed point)   }

        FLD     tbyte ptr [ESP+4]       { load value            }
{$IFDEF ALIGN_STACK}
{$IFDEF MACOS}
        SUB     ESP, 4
{$ELSE}
        SUB     ESP, 8
{$ENDIF}
{$ENDIF}
        SUB     ESP,256                 { VAR s: String;        }

        PUSH    EAX
        PUSH    EDX

{       Str( val, width, prec, s );     }

        SUB     ESP, SizeOfExtendedOnStack
        FSTP    tbyte ptr [ESP]         { pass value                    }
        MOV     EAX,EDX                 { pass field width              }
        MOV     EDX,ECX                 { pass precision                }
                                        { pass destination string    }
        LEA     ECX,[ESP+8+SizeOfExtendedOnStack]
        CALL    _Str2Ext

{       Write( t, s, width );   }

        POP     ECX                     { pass width    }
        POP     EAX                     { pass text     }
        MOV     EDX,ESP                 { pass string   }
{$IFDEF ALIGN_STACK}
{$IFDEF MACOS}
        SUB     ESP, 8
{$ELSE}
        SUB     ESP, 4
{$ENDIF}
{$ENDIF}
        CALL    _WriteString

        ADD     ESP,256
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF}
        RET     SizeOfExtendedOnStack
end;
{$ENDIF X86ASMRTL}

{$IF not DEFined(X86ASMRTL)}
function _Write1Ext(var T: TTextRec; Val: Extended; Width: Integer): Pointer;
begin
  Result := _Write2Ext(T, Val, Width, -1);
end;
{$ELSE X86ASMRTL}
procedure _Write1Ext;
asm
{       PROCEDURE _Write1Ext( VAR t: Text; val: Extended; width: Integer);
  ->    EAX     Pointer to file record
        [ESP+4] Extended value
        EDX     Field width             }

        OR      ECX,-1
        JMP     _Write2Ext
end;
{$ENDIF X86ASMRTL}

{$IF not DEFined(X86ASMRTL)}
function _Write0Ext(var T: TTextRec; Val: Extended): Pointer;
begin
  Result := _Write2Ext(T, Val, 23, -1);
end;
{$ELSE X86ASMRTL}
procedure _Write0Ext;
asm
{       PROCEDURE _Write0Ext( VAR t: Text; val: Extended);
      ->EAX     Pointer to file record
        [ESP+4] Extended value  }

        MOV     EDX,23  { field width   }
        OR      ECX,-1
        JMP     _Write2Ext
end;
{$ENDIF X86ASMRTL}


{$IF not defined(X86ASMRTL)}
function _Write2Comp(var T: TTextRec; Val: Comp; Width, Prec: Integer): Pointer;
var
 S : _ShortStr;
begin
  S := _Str2Comp(Val, Width, Prec);
  Result := _WriteString(T, S, Width);
end;

function _Write1Comp(var T: TTextRec; Val: Comp; Width: Integer): Pointer;
begin
  Result := _Write2Comp(T, Val, Width, -1);
end;

function _Write0Comp(var T: TTextRec; Val: Comp): Pointer;
begin
  Result := _Write2Comp(T, Val, 23, -1);
end;

function _Write2Currency(var T: TTextRec; Val: Currency; Width, Prec: Integer): Pointer;
var
 S : _ShortStr;
begin
  S := _Str2Currency(Val, Width, Prec);
  Result := _WriteString(T, S, Width);
end;

function _Write1Currency(var T: TTextRec; Val: Currency; Width: Integer): Pointer;
begin
  Result := _Write2Currency(T, Val, Width, -1);
end;

function _Write0Currency(var T: TTextRec; Val: Currency): Pointer;
begin
  Result := _Write2Currency(T, Val, 23, -1);
end;
{$ENDIF !CPUX86}


function _WriteLn(var t: TTextRec): Pointer;
begin
  if (t.Flags and tfCRLF) <> 0 then
    _Write0Char(t, _AnsiChr(cCR));
  Result := _Write0Char(t, _AnsiChr(cLF));
  _Flush(t);
end;

procedure __CToPasStr(Dest: _PShortStr; const Source: _PAnsiChr);
begin
  __CLenToPasStr(Dest, Source, 255);
end;

procedure __CLenToPasStr(Dest: _PShortStr; const Source: _PAnsiChr; MaxLen: NativeInt);
{$IFDEF PUREPASCAL}
var
  I: NativeInt;
begin
  I := 0;
  if Source <> nil then
  begin
    if MaxLen > 255 then MaxLen := 255;
    while (Source[I] <> #0) and (I < MaxLen) do
    begin
      Dest^[I+1] := Source[I];
      Inc(I);
    end;
  end;
  Byte(Dest^[0]) := I;
end;
{$ELSE !PUREPASCAL}
asm
{     ->EAX     Pointer to destination  }
{       EDX     Pointer to source       }
{       ECX     cnt                     }

        PUSH    EBX
        PUSH    EAX             { save destination      }

        TEST    EDX,EDX
        JZ      @@nilStr
        CMP     ECX,255
        JBE     @@loop
        MOV     ECX,255
@@loop:
        MOV     BL,[EDX]        { ch = *src++;          }
        INC     EDX
        TEST    BL,BL           { if (ch == 0) break    }
        JE      @@endLoop
        INC     EAX             { *++dest = ch;         }
        MOV     [EAX],BL
        DEC     ECX             { while (--cnt != 0)    }
        JNZ     @@loop

@@endLoop:
        POP     EDX
        SUB     EAX,EDX

@@setLength:
        MOV     [EDX],AL
        POP     EBX
        RET

@@nilStr:
        POP     EDX
        XOR     EAX,EAX
        JMP     @@setLength
end;
{$ENDIF !PUREPASCAL}

procedure __ArrayToPasStr(Dest: _PShortStr; const Source: _PAnsiChr; Len: NativeInt);
begin
  if Len > 255 then Len := 255;
  Byte(Dest^[0]) := Len;
  Move(Source^, Dest^[1], Len);
end;

procedure __PasToCStr(const Source: _PShortStr; const Dest: _PAnsiChr);
begin
  Move(Source^[1], Dest^, Byte(Source^[0]));
  Dest[Byte(Source^[0])] := #0;
end;

// __PasToWCStr is called from Str() standard procedure if 2nd parameter
// is zero based WideChar array. In this case, character code is restricted
// to ASCII. So, conversion is simple.
procedure __PasToWCStr(const Source: _PShortStr; const Dest: PWideChar);
var
  I, N: NativeInt;
begin
  N := Byte(Source^[0]);
  for I := 1 to N do
    Dest[I - 1] := WideChar(Ord(Source^[I]));
  Dest[N] := #0;
end;


{ ----------------------------------------------------- }
{       Compiler helper for set type support            }
{ ----------------------------------------------------- }

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetElem(var Dest {:Set}; Elem, Size: Integer);
var
  P: PByte;
  I: Integer;
begin
  P := @Dest;
  for I := 0 to Size - 1 do
    P[I] := 0;
  if (Elem >= 0) and ((Elem div 8) < Size) then
    P[Elem div 8] := 1 shl (Elem mod 8);
end;
{$ELSE X86ASMRTL}
procedure       _SetElem;
asm
        {       PROCEDURE _SetElem( VAR d: SET; elem, size: Byte);      }
        {       EAX     =       dest address                            }
        {       DL      =       element number                          }
        {       CL      =       size of set                             }

        PUSH    EBX
        PUSH    EDI

        MOV     EDI,EAX

        XOR     EBX,EBX { zero extend set size into ebx }
        MOV     BL,CL
        MOV     ECX,EBX { and use it for the fill       }

        XOR     EAX,EAX { for zero fill                 }
        REP     STOSB

        SUB     EDI,EBX { point edi at beginning of set again   }

        INC     EAX             { eax is still zero - make it 1 }
        MOV     CL,DL
        ROL     AL,CL   { generate a mask               }
        SHR     ECX,3   { generate the index            }
        CMP     ECX,EBX { if index >= siz then exit     }
        JAE     @@exit
        OR      [EDI+ECX],AL{ set bit                   }

@@exit:
        POP     EDI
        POP     EBX
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetRange(Lo, Hi, Size: Integer; var Dest {:Set});
var
  P: PByte;
  I: Integer;
  LoIndex, HiIndex: Integer;
  LoMask, HiMask: Byte;
begin
  P := @dest;
  for I := 0 to Size - 1 do
    P[I] := 0;
  if Hi >= Size * 8 then
    Hi := Size * 8 - 1;
  if Lo < 0 then
    Lo := 0;
  if Lo <= Hi then
  begin
    LoMask := $ff shl (Lo mod 8);
    LoIndex := Lo div 8;
    HiMask := UInt32($FF) shr (7 - (Hi mod 8));
    HiIndex := Hi div 8;
    P[LoIndex] := LoMask;
    for I := LoIndex+1 to HiIndex do
      P[I] := $ff;
    P[HiIndex] := P[HiIndex] and HiMask;
  end;
end;
{$ELSE X86ASMRTL}
procedure _SetRange;
asm
{       PROCEDURE _SetRange( lo, hi, size: Byte; VAR d: SET );  }
{ ->    AL      low limit of range      }
{       DL      high limit of range     }
{       ECX     Pointer to set          }
{       AH      size of set             }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        XOR     EBX,EBX { EBX = set size                }
        MOV     BL,AH
        MOVZX   ESI,AL  { ESI = low zero extended       }
        MOVZX   EDX,DL  { EDX = high zero extended      }
        MOV     EDI,ECX

{       clear the set                                   }

        MOV     ECX,EBX
        XOR     EAX,EAX
        REP     STOSB

{       prepare for setting the bits                    }

        SUB     EDI,EBX { point EDI at start of set     }
        SHL     EBX,3   { EBX = highest bit in set + 1  }
        CMP     EDX,EBX
        JB      @@inrange
        LEA     EDX,[EBX-1]     { ECX = highest bit in set      }

@@inrange:
        CMP     ESI,EDX { if lo > hi then exit;         }
        JA      @@exit

        DEC     EAX     { loMask = 0xff << (lo & 7)             }
        MOV     ECX,ESI
        AND     CL,07H
        SHL     AL,CL

        SHR     ESI,3   { loIndex = lo >> 3;            }

        MOV     CL,DL   { hiMask = 0xff >> (7 - (hi & 7));      }
        NOT     CL
        AND     CL,07
        SHR     AH,CL

        SHR     EDX,3   { hiIndex = hi >> 3;            }

        ADD     EDI,ESI { point EDI to set[loIndex]     }
        MOV     ECX,EDX
        SUB     ECX,ESI { if ((inxDiff = (hiIndex - loIndex)) == 0)     }
        JNE     @@else

        AND     AL,AH   { set[loIndex] = hiMask & loMask;       }
        MOV     [EDI],AL
        JMP     @@exit

@@else:
        STOSB           { set[loIndex++] = loMask;      }
        DEC     ECX
        MOV     AL,0FFH { while (loIndex < hiIndex)     }
        REP     STOSB   {   set[loIndex++] = 0xff;      }
        MOV     [EDI],AH        { set[hiIndex] = hiMask;        }

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
function _SetEq(L, R: Pointer; Size: Integer): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to Size - 1 do
    if PByte(L)[I] <> PByte(R)[I] then Exit;
  Result := True;
end;
{$ELSE X86ASMRTL}
procedure _SetEq;
asm
{       FUNCTION _SetEq( CONST l, r: Set; size: Byte): ConditionCode;   }
{       EAX     =       left operand    }
{       EDX     =       right operand   }
{       CL      =       size of set     }

        PUSH    ESI
        PUSH    EDI

        MOV     ESI,EAX
        MOV     EDI,EDX

        AND     ECX,0FFH

@@Loop:
        DEC     ECX
        JZ      @@ByteCheck
        MOVZX   EAX,WORD PTR [ESI+ECX-1]
        MOVZX   EDX,WORD PTR [EDI+ECX-1]
        CMP     EAX,EDX
        JNE     @@Leave
        DEC     ECX
        JNZ     @@Loop
@@Leave:

        POP     EDI
        POP     ESI
        RET

@@ByteCheck:
        MOV     AL,[ESI+ECX]
        MOV     DL,[EDI+ECX]
        CMP     AL,DL
        JNE     @@Leave
        OR      ECX,ECX // set zero flag

        POP     EDI
        POP     ESI
        RET
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
function _SetLe(L, R: Pointer; Size: Integer): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to Size - 1 do
    if (PByte(L)[I] and not PByte(R)[I]) <> 0 then Exit;
  Result := True;
end;
{$ELSE X86ASMRTL}
procedure _SetLe;
asm
{       FUNCTION _SetLe( CONST l, r: Set; size: Byte): ConditionCode;   }
{       EAX     =       left operand            }
{       EDX     =       right operand           }
{       CL      =       size of set (>0 && <= 32)       }

@@loop:
        MOV     CH,[EDX]
        NOT     CH
        AND     CH,[EAX]
        JNE     @@exit
        INC     EDX
        INC     EAX
        DEC     CL
        JNZ     @@loop
@@exit:
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetIntersect(var Dest {:Set}; Src: Pointer{PSet}; Size: Integer);
var
  I: Integer;
  PD, PS: PByte;
begin
  PD := PByte(@Dest);
  PS := PByte(Src);
  for I := 0 to Size - 1 do
    PD[I] := PD[I] and PS[I];
end;
{$ELSE X86ASMRTL}
procedure _SetIntersect;
asm
{       PROCEDURE _SetIntersect( VAR dest: Set; CONST src: Set; size: Byte);}
{       EAX     =       destination operand             }
{       EDX     =       source operand                  }
{       CL      =       size of set (0 < size <= 32)    }

@@loop:
        MOV     CH,[EDX]
        INC     EDX
        AND     [EAX],CH
        INC     EAX
        DEC     CL
        JNZ     @@loop
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetIntersect3(var Dest {:Set}; L, R: Pointer{PSet}; Size: Integer);
var
  I: Integer;
  PD, PL, PR: PByte;
begin
  PD := PByte(@Dest);
  PL := PByte(L);
  PR := PByte(R);
  for I := 0 to Size - 1 do
    PD[I] := PL[I] and PR[I];
end;
{$ELSE X86ASMRTL}
procedure _SetIntersect3;
asm
{       PROCEDURE _SetIntersect3( VAR dest: Set; CONST src: Set; size: Integer; src2: Set);}
{       EAX     =       destination operand             }
{       EDX     =       source operand                  }
{       ECX     =       size of set (0 < size <= 32)    }
{       [ESP+4] = 2nd source operand                    }

        PUSH    EBX
        PUSH    ESI
        MOV     ESI,[ESP+8+4]
@@loop:
        MOV     BL,[EDX+ECX-1]
        AND     BL,[ESI+ECX-1]
        MOV     [EAX+ECX-1],BL
        DEC     ECX
        JNZ     @@loop

        POP     ESI
        POP     EBX
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetUnion(var Dest {:Set}; Src: Pointer{PSet}; Size: Integer);
var
  I: Integer;
  PD, PS: PByte;
begin
  PD := PByte(@Dest);
  PS := PByte(Src);
  for I := 0 to Size - 1 do
    PD[I] := PD[I] or PS[I];
end;
{$ELSE X86ASMRTL}
procedure _SetUnion;
asm
{       PROCEDURE _SetUnion( VAR dest: Set; CONST src: Set; size: Byte);        }
{       EAX     =       destination operand             }
{       EDX     =       source operand                  }
{       CL      =       size of set (0 < size <= 32)    }

@@loop:
        MOV     CH,[EDX]
        INC     EDX
        OR      [EAX],CH
        INC     EAX
        DEC     CL
        JNZ     @@loop
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetUnion3(var Dest {:Set}; L, R: Pointer{PSet}; Size: Integer);
var
  I: Integer;
  PD, PL, PR: PByte;
begin
  PD := PByte(@Dest);
  PL := PByte(L);
  PR := PByte(R);
  for I := 0 to Size - 1 do
    PD[I] := PL[I] or PR[I];
end;
{$ELSE X86ASMRTL}
procedure _SetUnion3;
asm
{       PROCEDURE _SetUnion3( VAR dest: Set; CONST src: Set; size: Integer; src2: Set);}
{       EAX     =       destination operand             }
{       EDX     =       source operand                  }
{       ECX     =       size of set (0 < size <= 32)    }
{ [ESP+4] = 2nd source operand    }

      PUSH  EBX
      PUSH  ESI
      MOV   ESI,[ESP+8+4]
@@loop:
      MOV   BL,[EDX+ECX-1]
      OR    BL,[ESI+ECX-1]
      MOV   [EAX+ECX-1],BL
      DEC   ECX
      JNZ   @@loop

      POP   ESI
      POP   EBX
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetSub(var Dest {:Set}; Src: Pointer{PSet}; Size: Integer);
var
  I: Integer;
  PD, PS: PByte;
begin
  PD := PByte(@Dest);
  PS := PByte(Src);
  for I := 0 to Size - 1 do
    PD[I] := PD[I] and not PS[I];
end;
{$ELSE X86ASMRTL}
procedure _SetSub;
asm
{       PROCEDURE _SetSub( VAR dest: Set; CONST src: Set; size: Byte);  }
{       EAX     =       destination operand             }
{       EDX     =       source operand                  }
{       CL      =       size of set (0 < size <= 32)    }

@@loop:
        MOV     CH,[EDX]
        NOT     CH
        INC     EDX
        AND     [EAX],CH
        INC     EAX
        DEC     CL
        JNZ     @@loop
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetSub3(var Dest {:set}; L, R: Pointer{PSet}; Size: Integer);
var
  I: Integer;
  PD, PL, PR: PByte;
begin
  PD := PByte(@Dest);
  PL := PByte(L);
  PR := PByte(R);
  for I := 0 to Size - 1 do
    PD[I] := PL[I] and not PR[I];
end;
{$ELSE X86ASMRTL}
procedure _SetSub3;
asm
{       PROCEDURE _SetSub3( VAR dest: Set; CONST src: Set; size: Integer; src2: Set);}
{       EAX     =       destination operand             }
{       EDX     =       source operand                  }
{       ECX     =       size of set (0 < size <= 32)    }
{       [ESP+4] = 2nd source operand                    }

        PUSH    EBX
        PUSH    ESI
        MOV     ESI,[ESP+8+4]
@@loop:
        MOV     BL,[ESI+ECX-1]
        NOT     BL
        AND     BL,[EDX+ECX-1]
        MOV     [EAX+ECX-1],BL
        DEC     ECX
        JNZ     @@loop

        POP     ESI
        POP     EBX
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _SetExpand(Src: Pointer{PSet}; var Dest {:Set}; Lo, Hi: Integer);
var
  I: Integer;
  PD, PS: PByte;
begin
  PD := PByte(@Dest);
  PS := PByte(Src);
  for I := 0 to Lo - 1 do
    PD[I] := 0;
  for I := Lo to Hi - 1 do
    PD[I] := PS[I - Lo];
  for I := Hi to 31 do
    PD[I] := 0;
end;
{$ELSE X86ASMRTL}
procedure _SetExpand;
asm
{       PROCEDURE _SetExpand( CONST src: Set; VAR dest: Set; lo, hi: Byte);     }
{     ->EAX     Pointer to source (packed set)          }
{       EDX     Pointer to destination (expanded set)   }
{       CH      high byte of source                     }
{       CL      low byte of source                      }

{       algorithm:              }
{       clear low bytes         }
{       copy high-low+1 bytes   }
{       clear 31-high bytes     }

        PUSH    ESI
        PUSH    EDI

        MOV     ESI,EAX
        MOV     EDI,EDX

        MOV     EDX,ECX { save low, high in dl, dh      }
        XOR     ECX,ECX
        XOR     EAX,EAX

        MOV     CL,DL   { clear low bytes               }
        REP     STOSB

        MOV     CL,DH   { copy high - low bytes }
        SUB     CL,DL
        REP     MOVSB

        MOV     CL,32   { copy 32 - high bytes  }
        SUB     CL,DH
        REP     STOSB

        POP     EDI
        POP     ESI
end;
{$ENDIF X86ASMRTL}

function ScaleExt(var val: Extended): Integer;
var
  expBase10: Integer;
  ExpBase2: Int16;
begin
  Result := 0;
  while (val <> 0) do
  begin
    ExpBase2 := PExtendedRec(@val)^.Exponent;
    // exp10 * 2 ** 16 = exp2 * log10(2) * 2**16. Log10(2) * 2 ** 16 ~= 19728
    expBase10 := ExpBase2 * 19728;
    // Temp = High 16 bits of result, sign extended
    expBase10 := PSmallInt(PByte(@expBase10)+2)^;
    if expBase10 = 0 then break;
    Inc(Result, expBase10);
    val := Power10(val, -expBase10);
  end;
end;

// Rounding at next of position.
// digBuf[-1] keeps '0'
// If rounding overflow, return True.
// Otherwise, return False.
function RoundDigits(digBuf: PByte; position: Integer): Boolean;
var
  I: Integer;
begin
  Result := False;
  if (digBuf[position+1] >= Byte('5')) then
  begin
    I := position;
    while True do
    begin
      if digBuf[I] = Byte('9') then
      begin
        digBuf[I] := Byte('0');
        dec(I);
      end
      else
      begin
        Inc(digBuf[I]);
        Result := (I = -1);
        break;
      end;
    end;
  end;
end;

procedure EmitDigits(val: Extended; digCnt: Integer; digBuf: PByte; var Exponent: Integer);
type
    TBCDBytes = array [0..9] of Byte;

  function GetBcdBytes(val:Extended): TBcdBytes;
{$IF defined(CPUX86) and defined(ASSEMBLER)}
  asm
      FLD       tbyte ptr Val
      FBSTP     [Result]
      FWAIT
  end;
{$ELSE}
  var
    I: Int64;
    Ind, D: Integer;
  begin
    FillChar(Result, SizeOf(Result), 0);
    if val < 0 then Result[9] := $80;
    I := Round(Abs(val));
    Ind := 0;
    while (I > 0) and (Ind < 9) do
    begin
      D := I mod 100;
      Result[Ind] := (D mod 10) + ((D div 10) shl 4);
      I := I div 100;
      Inc(Ind);
    end;
  end;
{$ENDIF}

var
  bcdBytes: TBcdBytes;
  I: Integer;
begin
  Exponent := ScaleExt(val);
  digBuf[0] := Byte('0');
  val := Round(abs(val) * 1E17);
  if val >= 1E18 then
  begin
    val := val - 1E18;
    digBuf[0] := Byte('1');
    Dec(digCnt);
  end;
  bcdBytes := GetBcdBytes(val);
  for I := 8 downto 0 do
    PWord(@digBuf[17-I*2])^ := $3030 +
      ((bcdBytes[I] and $0F) SHL 8) +
      ((bcdBytes[I] and $F0) SHR 4);
  digBuf[19] := $0;
  if (digCnt <= 18) then
    RoundDigits(digBuf, digCnt);
end;

function _Str2Ext(val: Extended; Width, Precision: Integer): _ShortStr;
var
  digBuf : array[0..19] of Byte;
  PBuf: PByte;
  PResult: _PAnsiChr;
  exp: Integer;
  I: Integer;
  MinWidth: Integer;
  tmpVal: Extended;
begin
  if Width > 255 then Width := 255;

  case PExtendedRec(@val).SpecialType of
    TFloatSpecial.fsNAN:  Exit(_ShortStr(StringOfChar(' ', Width - 3) + 'Nan'));
    TFloatSpecial.fsInf:  Exit(_ShortStr(StringOfChar(' ', Width - 4) + '+Inf'));
    TFloatSpecial.fsNInf: Exit(_ShortStr(StringOfChar(' ', Width - 4) + '-Inf'));
  end;
  tmpVal := val;
  exp := ScaleExt(tmpVal);
  // 6.64613997892457936E35 ~= 2**119, which is the cutof for displaying scientific notation
  if (precision < 0) or (Abs(val) > 6.64613997892457936E35) or (Abs(exp)>35) then
  begin
    if Width < 10 then  // Emit digits generates between 2 and 18 characters
      Width := 10;      // 8 characters for sign, decimal, and exponent parts.
    EmitDigits(val, Width - 8, @digBuf, exp);
    SetLength(Result, Width);
    PResult := @Result[1];
    if Width > 18+8 then  // Pad with whitespace if wider than 18+8 characters
    begin
      FillChar(Result[1], Width-(18 + 8), ' ');
      PResult := @result[Width - (18 + 8)+1];
    end;
    if val < 0 then // Emit sign
      PResult[0] := '-'
    else
      PResult[0] := ' ';
    PBuf := @digBuf[1];
    if digBuf[0] = Byte('1') then  // Special case for when ScaleExt overflowed.
    begin
      PBuf := @digBuf[0];
      inc(exp);
    end;
    PResult[1] := _AnsiChr(PBuf^); // Emit decimal
    PResult[2] := '.';
    if Width - 9 < 17 then // Digits from EmitDigits
      Move(PBuf[1], PResult[3], Width - 9)
    else
      Move(PBuf[1], PResult[3], 17);

    Result[width-5] := 'E'; // Exponent part
    if exp < 0 then
    begin
      Result[width-4] := '-';
      exp := -exp;
    end
    else
      Result[Width-4] := '+';
    for I := 3 downto 0 do
    begin
      Result[Width-3+I] := _AnsiChr(Ord('0') + (exp mod 10));
      exp := exp div 10;
    end;
  end
  else // fixed notation.
  begin
    EmitDigits(val, 18, @digBuf, exp);
    PBuf := @digBuf[0];
    if digBuf[0] = Byte('1') then // It's possbile the log 2 -> log 10 exponent overflows
      inc(exp)
    else
      Inc(PBuf);

    if precision > 256 - 40 then
      precision := 256 - 40;

    // Check if emitted digits are in decimal and round if they are.
    if (18 > precision + exp) and (-1 <= precision + exp) then
    begin
      if RoundDigits(PBuf, exp + precision) then
      begin //Rounding could overflow
        // The rounding overflow will happen
        // if PBuf point to digBuf[1]
        Dec(PBuf);
        inc(exp);
      end;
    end;

    MinWidth := 0;
    if precision > 0 then
      Inc(MinWidth, 1 + precision);
    if exp <= 0 then
      Inc(MinWidth)
    else
      Inc(MinWidth, exp+1);
    if val < 0 then
      inc(MinWidth);

    if MinWidth > width then
    begin
      SetLength(Result, MinWidth);
      PResult := @Result[1];
    end
    else
    begin
      SetLength(Result, width);
      FillChar(Result[1], width - MinWidth, ' '); // Fill with leading whitespace
      PResult := @Result[Width - MinWidth+1];
    end;

    if val < 0 then // Emit Sign
    begin
      PResult^ := '-';
      Inc(PResult);
    end;

    if exp < 0 then  //Emit Integer part
      PResult^ := '0'
    else
    begin
      if exp < 18 then // Up to 18 digits were emitted
        Move(pbuf^, PResult^, exp+1)
      else
      begin // If larger than 10**18, need to emit extra 0s.
        Move(pbuf^, PResult^, 18);
        FillChar(PResult[18], exp-17, '0');
      end;
      Inc(PResult, exp);
    end;

    if precision > 0 then  // Emit decimal part
    begin
      PResult[1] := '.';
      Inc(PResult, 2);
      FillChar(PResult^, -exp-1, '0'); // emit leading 0s.
      if -exp - 1 >0 then
        inc(PResult, - exp - 1);
      if exp < 0 then
        I := 18
      else if (exp < 18) then
      begin
        Inc(PBuf, exp + 1);
        I := 17 - exp;
      end
      else
        I := 0;
      if I >= precision then
        Move(PBuf^, PResult^, Precision) // all digits from EmitDigits
      else
      begin
        Move(PBuf^, PResult^, I); //remainder of digits from EmitDigits
        FillChar(PResult[I], precision - I, '0'); // trailing 0s.
      end;
    end;
  end;
end;

function _Str1Ext(val: Extended; width: Integer): _ShortStr;
begin
  Result := _Str2Ext(val, width, -1);
end;

function _Str0Ext(val: Extended): _ShortStr;
begin
  Result := _Str2Ext(val, 23, -1);
end;

{$IF not defined(X86ASMRTL)}
function _StrC64Digits(Val: UInt64; Width, Precision: Integer; scale: Integer; sign: Boolean): _ShortStr;

  procedure AppendChar(var P: _PAnsiChr; const ch : _AnsiChr); inline;
  begin
    P^ := ch;
    Inc(P);
  end;

  procedure AppendString(var P: _PAnsiChr; const S: _PAnsiChr; const Count: integer); inline;
  begin
    Move(S^, P^, Count);
    Inc(P, Count);
  end;

var
  Ind,
  IntInd, E, w : Integer;
  P: _PAnsiChr;
  IntPart: array[0..18] of _AnsiChr; // 9223372036854775807 - 19 digits.
  IntLen: Integer;
  ExpPart: array[0..5] of _AnsiChr;

  function CheckNR: Boolean;
  var
    Ind2: Integer;
  begin
    Ind2 := Ind + 1;
    while (Ind2 <= High(intPart)) and (IntPart[Ind2] = '0') do Inc(Ind2);
    Result := (Ind2 <= High(intPart)) or Odd(Ord(IntPart[Ind-1]));
  end;

begin
  if sign then Val := not Val + 1;

  if Val = 0 then
  begin
    IntInd := High(IntPart);
    IntPart[IntInd] := '0';
  end
  else
  begin
    IntInd := High(IntPart) + 1;
    while Val <> 0 do
    begin
      Dec(IntInd);
      IntPart[IntInd] := _AnsiChr($30 + Val mod 10);
      Val := Val div 10;
    end;
  end;

  if Precision < 0 then
  begin // scientific notation
    IntLen := High(IntPart) - IntInd + 1;
    P := @Result[1];

    if sign then AppendChar(P, '-')
    else AppendChar(P, ' ');

    if Width < 10 then Width := 10;
    Ind := 2 + (Width - 10);
    if 2 + (Width - 10) < IntLen then
    begin
      Ind := IntInd + 2 + (Width - 10);
      if (IntPart[Ind] > '5') or ((IntPart[Ind] = '5') and CheckNR) then
      begin
        Dec(Ind);
        while Ind >= IntInd do
        begin
          if IntPart[Ind] = '9' then
          begin
            IntPart[Ind] := '0';
            Dec(Ind);
          end
          else
          begin
            IntPart[Ind] := Succ(IntPart[Ind]);
            Break;
          end;
        end;
        if Ind < IntInd then
        begin
          IntPart[Ind] := '1';
          Dec(IntInd);
          Inc(IntLen);
        end;
      end;
    end;

    AppendChar(P, IntPart[IntInd]); Inc(IntInd);
    AppendChar(P, '.');
    if IntLen = 1 then AppendChar(P, '0')
    else               AppendChar(P, IntPart[IntInd]);
    Inc(IntInd);

    Ind := 1;
    while (Ind <= Width -10) and (IntInd <= High(IntPart)) do
    begin
      AppendChar(P, IntPart[IntInd]);
      Inc(Ind);
      Inc(IntInd);
    end;
    while (Ind <= Width -10) do
    begin
      AppendChar(P, '0');
      Inc(Ind);
    end;

    E := IntLen - 1 - Scale;
    ExpPart := 'E+0000';
    if E < 0 then
    begin
      ExpPart[1] := '-';
      E := -E;
    end;
    ExpPart[5] := _AnsiChr($30 + (E mod 10));
    E := E div 10;
    ExpPart[4] := _AnsiChr($30 + (E mod 10));
    AppendString(P, ExpPart, Length(ExpPart));
  end
  else
  begin // fixed notation
    if High(IntPart) - Scale < IntInd then
    begin
      for Ind := IntInd - 1 downto High(IntPart) - Scale do
        IntPart[Ind] := '0';
      IntInd := High(IntPart) - Scale;
    end;

    IntLen := High(IntPart) - IntInd + 1;

    P := @Result[1];

    if IntLen > Scale then
      w := IntLen - Scale // 123
    else
      w := 1; // 0
    if Precision > 0 then
      w := w + Precision + 1; // 0.123
    if sign then Inc(w);

    for Ind := 1 to Width - w do AppendChar(P, ' '); // fill leading space
    if sign then AppendChar(P, '-');

    for Ind := IntInd to High(IntPart) - Scale do AppendChar(P, IntPart[Ind]);
    if Precision > 0 then
    begin
      AppendChar(P, '.');

      if Precision > Scale then
        for Ind := High(IntPart) - Scale + 1 to High(IntPart) do AppendChar(P, IntPart[Ind])
      else
        for Ind := High(IntPart) - Scale + 1 to High(IntPart) - Scale + Precision do AppendChar(P, IntPart[Ind]);

      for Ind := 1 to Precision - Scale do AppendChar(P, '0');
    end;
  end;
  SetLength(Result, P - @Result[1]);
end;

function _Str2Comp(Val: Comp; Width, Precision: Integer): _ShortStr;
begin
  Result := _StrC64Digits(PUInt64(@Val)^, Width, Precision, 0, Val < 0);
end;

function _Str1Comp(Val: Comp; Width: Integer): _ShortStr;
begin
  Result := _Str2Comp(Val, Width, -1);
end;

function _Str0Comp(Val: Comp): _ShortStr;
begin
  Result := _Str2Comp(Val, 23, -1);
end;


function _Str2Currency(Val: Currency; Width, Precision: Integer): _ShortStr;
begin
  if Val = 0 then
    Result := _StrC64Digits(PUInt64(@Val)^, Width, Precision, 0, False)
  else
    Result := _StrC64Digits(PUInt64(@Val)^, Width, Precision, 4, Val < 0);
end;

function _Str1Currency(Val: Currency; Width: Integer): _ShortStr;
begin
  Result := _Str2Currency(Val, Width, -1);
end;

function _Str0Currency(Val: Currency): _ShortStr;
begin
  Result := _Str2Currency(Val, 23, -1);
end;

{$ENDIF !X86ASMRTL}


                                                                                             
{$IF (Not DEFined(X86ASMRTL))}
function _ValExt(s: string; var code: Integer): Extended;
var
  Ch: Char;
  Digits, ExpValue: Integer;
  Neg, NegExp, Valid: Boolean;
begin
  Result := 0.0;
  Code := 0;
  if S = '' then
  begin
    Inc(Code);
    Exit;
  end;
  Neg := False;
  NegExp := False;
  Valid := False;
  while S[Code + Low(string)] = ' ' do
    Inc(Code);
  Ch := S[Code + Low(string)];
  if (Ch = '+') or (Ch = '-') then
  begin
    Inc(Code);
    Neg := (Ch = '-');
  end;
  while True do
  begin
    Ch := S[Code + Low(string)];
    Inc(Code);
    if not ((Ord(Ch) >= Ord('0')) and (Ord(Ch) <= Ord('9'))) then
      Break;
    Result := (Result * 10) + Ord(Ch) - Ord('0');
    Valid := True;
  end;
  Digits := 0;
  if Ch = '.' then
  begin
    while True do
    begin
      Ch := S[Code + Low(string)];
      Inc(Code);
      if not ((Ord(Ch) >= Ord('0')) and (Ord(Ch) <= Ord('9'))) then
      begin
        if not Valid then {Starts with '.'}
        begin
          if Ch = #0 then
          begin
            Dec(Code); {S = '.'}
            Valid := True; // SB: Added for compatibility with x86 asm version
          end;
        end;
        Break;
      end;
      Result := (Result * 10) + Ord(Ch) - Ord('0');
      Dec(Digits);
      Valid := True;
    end;
  end;
  ExpValue := 0;
  if (Ord(Ch) or $20) = Ord('e') then
    begin {Ch in ['E','e']}
      Valid := False;
      Ch := S[Code + Low(string)];
      if (Ch = '+') or (Ch = '-') then
      begin
        Inc(Code);
        NegExp := (Ch = '-');
      end;
      while True do
      begin
        Ch := S[Code + Low(string)];
        Inc(Code);
        if not ((Ord(Ch) >= Ord('0')) and (Ord(Ch) <= Ord('9'))) then
          Break;
        ExpValue := (ExpValue * 10) + Ord(Ch) - Ord('0');
        Valid := True;
      end;
     if NegExp then
       ExpValue := -ExpValue;
    end;
  Digits := Digits + ExpValue;
  if Digits <> 0 then
    Result := Power10(Result, Digits);
  if Neg then
    Result := -Result;
  if Valid and (Ch = #0) then
    Code := 0;
end;
{$ELSE X86ASMRTL}
procedure _ValExt;
const
  Ten: Double = 10.0;
asm
// -> EAX Pointer to string
//  EDX Pointer to code result
// <- FST(0)  Result

      PUSH    EBX
{$IFDEF PIC}
      PUSH    EAX
      CALL    GetGOT
      MOV     EBX,EAX
      POP     EAX
{$ELSE}
      XOR     EBX,EBX
{$ENDIF}
      PUSH    ESI
      PUSH    EDI

      PUSH    EBX     // SaveGOT = ESP+8
      MOV     ESI,EAX
      PUSH    EAX     // save for the error case

      FLDZ
      XOR     EAX,EAX
      XOR     EBX,EBX
      XOR     EDI,EDI

      PUSH    EBX     // temp to get digs to fpu

      TEST    ESI,ESI
      JE      @@empty

@@blankLoop:
      MOV     BX,[ESI]
      ADD     ESI, 2
      CMP     BX,' '
      JE      @@blankLoop

@@endBlanks:
      MOV     CH,0
      CMP     BX,'-'
      JE      @@minus
      CMP     BX,'+'
      JE      @@plus
      JMP     @@firstDigit

@@minus:
      INC     CH
@@plus:
      MOV     BX,[ESI]
      ADD     ESI, 2

@@firstDigit:
      TEST    BX,BX
      JE      @@error

      MOV     EDI,[ESP+8]     // SaveGOT

@@digLoop:
      SUB     BX,'0'
      CMP     BX,9
      JA      @@dotExp
      FMUL    qword ptr [EDI] + offset Ten
      MOV     dword ptr [ESP],EBX
      FIADD   dword ptr [ESP]
      MOV     BX,[ESI]
      ADD     ESI, 2
      TEST    BX,BX
      JNE     @@digLoop
      JMP     @@prefinish

@@dotExp:
      CMP     BX,'.' - '0'
      JNE     @@exp
      MOV     BX,[ESI]
      ADD     ESI, 2
      TEST    BX,BX
      JE      @@prefinish

//  EDI = SaveGot
@@fracDigLoop:
      SUB     BX,'0'
      CMP     BX,9
      JA      @@exp
      FMUL    qword ptr [EDI] + offset Ten
      MOV     dword ptr [ESP],EBX
      FIADD   dword ptr [ESP]
      DEC     EAX
      MOV     BX,[ESI]
      ADD     ESI, 2
      TEST    BX,BX
      JNE     @@fracDigLoop

@@prefinish:
      XOR     EDI,EDI
      JMP     @@finish

@@exp:
      CMP     BX,'E' - '0'
      JE      @@foundExp
      CMP     BX,'e' - '0'
      JNE     @@error
@@foundExp:
      MOV     BX,[ESI]
      ADD     ESI, 2
      MOV     AH,0
      CMP     BX,'-'
      JE      @@minusExp
      CMP     BX,'+'
      JE      @@plusExp
      JMP     @@firstExpDigit
@@minusExp:
      INC     AH
@@plusExp:
      MOV     BX,[ESI]
      ADD     ESI, 2
@@firstExpDigit:
      SUB     BX,'0'
      CMP     BX,9
      JA      @@error
      MOV     EDI,EBX
      MOV     BX,[ESI]
      ADD     ESI, 2
      TEST    BX,BX
      JZ      @@endExp
@@expDigLoop:
      SUB     BX,'0'
      CMP     BX,9
      JA      @@error
      LEA     EDI,[EDI+EDI*4]
      ADD     EDI,EDI
      ADD     EDI,EBX
      MOV     BX,[ESI]
      ADD     ESI, 2
      TEST    BX,BX
      JNZ     @@expDigLoop
@@endExp:
      DEC     AH
      JNZ     @@expPositive
      NEG     EDI
@@expPositive:
      MOVSX   EAX,AL

@@finish:
      ADD     EAX,EDI
      PUSH    EDX
      PUSH    ECX
      CALL    _Pow10
      POP     ECX
      POP     EDX

      DEC     CH
      JE      @@negate

@@successExit:
      ADD     ESP,12   // pop temp and saved copy of string pointer

      XOR     ESI,ESI   // signal no error to caller

@@exit:
      SHR     ESI,1
      MOV     [EDX],ESI
      POP     EDI
      POP     ESI
      POP     EBX
      RET

@@negate:
      FCHS
      JMP     @@successExit

@@empty:
      ADD     ESI,2

@@error:
      POP     EAX
      POP     EBX
      SUB     ESI,EBX
      ADD     ESP,4
      JMP     @@exit
end;
{$ENDIF X86ASMRTL}

{$IF not DEFined(X86ASMRTL)}
function FPower10(val: Extended; power: Integer): Extended;
begin
  Result := Power10(val, power);
end;
{$ELSE X86ASMRTL}
procedure FPower10;
asm
  JMP  _Pow10
end;
{$ENDIF X86ASMRTL}

const
{$IFDEF EXTENDEDHAS10BYTES}
  Pow10Tab0: array[0..31] of Extended = (
    1e0,  1e1,  1e2,  1e3,  1e4,  1e5,  1e6,  1e7,  1e8,  1e9,
    1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
    1e20, 1e21, 1e22, 1e23, 1e24, 1e25, 1e26, 1e27, 1e28, 1e29,
    1e30, 1e31);
  Pow10Tab1: array[0..14] of Extended = (
    1e32,  1e64,  1e96,  1e128, 1e160, 1e192, 1e224, 1e256, 1e288, 1e320,
    1e352, 1e384, 1e416, 1e448, 1e480);
  Pow10Tab2: array[0..8] of Extended = (
    1e512, 1e1024, 1e1536, 1e2048, 1e2560, 1e3072, 1e3584, 1e4096, 1e4608);
{$ELSE !EXTENDEDHAS10BYTES}
  Pow10Tab0: array[0..31] of Double = (
    1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
    1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
    1e20, 1e21, 1e22, 1e23, 1e24, 1e25, 1e26, 1e27, 1e28, 1e29,
    1e30, 1e31);
  Pow10Tab1: array[0..7] of Double = (
    1e0, 1e32, 1e64, 1e96, 1e128, 1e160, 1e192, 1e224);
{$ENDIF !EXTENDEDHAS10BYTES}
function Power10(val: Extended; power: Integer): Extended;
{$IFDEF PUREPASCAL}
{$IFDEF EXTENDEDHAS10BYTES}
  var
  I, P: Integer;
begin
  FClearExcept;
  Result := Val;
  if Power > 0 then
  begin
    if Power >= 5120 then
      Exit(cInfinity);
    Result := Result * Pow10Tab0[Power and $1F];
    P := Power shr 5;
    if P <> 0 then
    begin
      I := P and $F;
      if I <> 0 then
        Result := Result * Pow10Tab1[I - 1];
      I := P shr 4;
      if I <> 0 then
        Result := Result * Pow10Tab2[I - 1];
    end;
  end
  else if Power < 0 then
  begin
    P := -Power;
    if P >= 5120 then
      Exit(0);
    Result := Result / Pow10Tab0[P and $1F];
    P := P shr 5;
    if P <> 0 then
    begin
      I := P and $F;
      if I <> 0 then
        Result := Result / Pow10Tab1[I - 1];
      I := P shr 4;
      if I <> 0 then
        Result := Result / Pow10Tab2[I - 1];
    end;
  end;
  FCheckExcept;
end;
{$ELSE !EXTENDEDHAS10BYTES}
var
  I, P: Integer;
begin
  FClearExcept;
  Result := Val;
  if Power > 0 then
  begin
    if Power >= 632 then // +308 - (-324) (Exp of  MinDouble)
    begin
      FRaiseExcept(feeOVERFLOW);
      Exit(cInfinity);
    end;
    Result := Result * Pow10Tab0[Power and $1F];
    P := Power shr 5;
    if P <> 0 then
    begin
      I := P and $7;
      if I <> 0 then
        Result := Result * Pow10Tab1[I];
      I := P shr 3;
      if I >= 1 then // 256 - 511
        Result := Result * 1E256;
      if I = 2 then // 512 - 631 (767)
        Result := Result * 1E256;
    end;
  end
  else if Power < 0 then
  begin
    P := -Power;
    if P >= 632 then
    begin
      FRaiseExcept(feeUNDERFLOW);
      Exit(0);
    end;
    Result := Result / Pow10Tab0[P and $1F];
    P := P shr 5;
    if P <> 0 then
    begin
      I := P and $7;
      if I <> 0 then
        Result := Result / Pow10Tab1[I];
      I := P shr 3;
      if I >= 1 then // 256 - 511
        Result := Result * 1E-256;
      if I = 2 then // 512 - 631 (767)
        Result := Result * 1E-256;
    end;
  end;
  FCheckExcept;
end;
{$ENDIF !EXTENDEDHAS10BYTES}
{$ELSE !PUREPASCAL}
{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator
begin
  FClearExcept;
  asm
    FLD   tbyte ptr val
    MOV   EAX, power
    CALL  _Pow10
    FSTP  tbyte ptr Result
  end;
  FCheckExcept;
end;
{$ELSE}
asm
    FLD   tbyte ptr val
    MOV   EAX, power
    CALL  _Pow10
    FSTP  tbyte ptr Result
end;
{$ENDIF}
{$ENDIF !PUREPASCAL}


{$IF (Not DEFined(X86ASMRTL))}
function _Pow10(val: Extended; Power: Integer): Extended;
begin
  Result := Power10(val, Power);
end;
{$ELSE X86ASMRTL}
//function _Pow10(val: Extended; Power: Integer): Extended;
procedure _Pow10;
asm
// -> FST(0)  val
// -> EAX Power
// <- FST(0)  val * 10**Power

//  This routine generates 10**power with no more than two
//  floating point multiplications. Up to 10**31, no multiplications
//  are needed.

      PUSH   EBX
{$IFDEF PIC}
      PUSH   EAX
      CALL   GetGOT
      MOV    EBX, EAX
      POP    EAX
{$ELSE}
      XOR    EBX, EBX
{$ENDIF}
      TEST   EAX, EAX
      JL     @@neg
      JE     @@exit
      CMP    EAX, 5120
      JGE    @@inf
      MOV    EDX, EAX
      AND    EDX, 01FH
      {$IF defined(EXTENDEDIS16BYTES)}
      LEA    EDX, [EDX*8]
      FLD    tbyte ptr Pow10Tab0[EBX+EDX*2]
      {$ELSEIF defined(EXTENDEDIS12BYTES)}
      LEA    EDX, [EDX+EDX*2]
      FLD    tbyte ptr Pow10Tab0[EBX+EDX*4]
      {$ELSEIF defined(EXTENDEDIS10BYTES)}
      LEA    EDX, [EDX+EDX*4]
      FLD    tbyte ptr Pow10Tab0[EBX+EDX*2]
      {$ELSE}
      {$MESSAGE ERROR 'Unknown condition'}
      {$ENDIF}

      FMULP

      SHR    EAX,5
      JE     @@exit

      MOV    EDX, EAX
      AND    EDX, 0FH
      JE     @@skip2ndMul
      {$IF defined(EXTENDEDIS16BYTES)}
      LEA    EDX, [EDX*8]
      FLD    tbyte ptr (Pow10Tab1-16)[EBX+EDX*2]
      {$ELSEIF defined(EXTENDEDIS12BYTES)}
      LEA    EDX, [EDX+EDX*2]
      FLD    tbyte ptr (Pow10Tab1-12)[EBX+EDX*4]
      {$ELSEIF defined(EXTENDEDIS10BYTES)}
      LEA    EDX, [EDX+EDX*4]
      FLD    tbyte ptr (Pow10Tab1-10)[EBX+EDX*2]
      {$ELSE}
      {$MESSAGE ERROR 'Unknown condition'}
      {$ENDIF}
      FMULP

@@skip2ndMul:
      SHR    EAX, 4
      JE     @@exit
      {$IF defined(EXTENDEDIS16BYTES)}
      LEA    EAX, [EAX*8]
      FLD    tbyte ptr (Pow10Tab2-16)[EBX+EAX*2]
      {$ELSEIF defined(EXTENDEDIS12BYTES)}
      LEA    EAX, [EAX+EAX*2]
      FLD    tbyte ptr (Pow10Tab2-12)[EBX+EAX*4]
      {$ELSEIF defined(EXTENDEDIS10BYTES)}
      LEA    EAX, [EAX+EAX*4]
      FLD    tbyte ptr (Pow10Tab2-10)[EBX+EAX*2]
      {$ELSE}
      {$MESSAGE ERROR 'Unknown condition'}
      {$ENDIF}
      FMULP
      JMP    @@exit

@@neg:
      NEG    EAX
      CMP    EAX, 5120
      JGE    @@zero
      MOV    EDX, EAX
      AND    EDX, 01FH
      {$IF defined(EXTENDEDIS16BYTES)}
      LEA    EDX, [EDX*8]
      FLD    tbyte ptr Pow10Tab0[EBX+EDX*2]
      {$ELSEIF defined(EXTENDEDIS12BYTES)}
      LEA    EDX, [EDX+EDX*2]
      FLD    tbyte ptr Pow10Tab0[EBX+EDX*4]
      {$ELSEIF defined(EXTENDEDIS10BYTES)}
      LEA    EDX, [EDX+EDX*4]
      FLD    tbyte ptr Pow10Tab0[EBX+EDX*2]
      {$ELSE}
      {$MESSAGE ERROR 'Unknown condition'}
      {$ENDIF}
      FDIVP

      SHR    EAX, 5
      JE     @@exit

      MOV    EDX, EAX
      AND    EDX, 0FH
      JE     @@skip2ndDiv
      {$IF defined(EXTENDEDIS16BYTES)}
      LEA    EDX, [EDX*8]
      FLD    tbyte ptr (Pow10Tab1-16)[EBX+EDX*2]
      {$ELSEIF defined(EXTENDEDIS12BYTES)}
      LEA    EDX, [EDX+EDX*2]
      FLD    tbyte ptr (Pow10Tab1-12)[EBX+EDX*4]
      {$ELSEIF defined(EXTENDEDIS10BYTES)}
      LEA    EDX, [EDX+EDX*4]
      FLD    tbyte ptr (Pow10Tab1-10)[EBX+EDX*2]
      {$ELSE}
      {$MESSAGE ERROR 'Unknown condition'}
      {$ENDIF}
      FDIVP

@@skip2ndDiv:
      SHR    EAX, 4
      JE     @@exit
      {$IF defined(EXTENDEDIS16BYTES)}
      LEA    EAX, [EAX*8]
      FLD    tbyte ptr (Pow10Tab2-16)[EBX+EAX*2]
      {$ELSEIF defined(EXTENDEDIS12BYTES)}
      LEA    EAX, [EAX+EAX*2]
      FLD    tbyte ptr (Pow10Tab2-12)[EBX+EAX*4]
      {$ELSEIF defined(EXTENDEDIS10BYTES)}
      LEA    EAX, [EAX+EAX*4]
      FLD    tbyte ptr (Pow10Tab2-10)[EBX+EAX*2]
      {$ELSE}
      {$MESSAGE ERROR 'Unknown condition'}
      {$ENDIF}
      FDIVP

      JMP    @@exit

@@inf:
      FSTP   ST(0)
      FLD    tbyte ptr @@infval[EBX]
      JMP    @@exit

@@zero:
      FSTP   ST(0)
      FLDZ

@@exit:
      POP    EBX
      RET

@@infval:  DW  $0000,$0000,$0000,$8000,$7FFF
end;
{$ENDIF X86ASMRTL}

const
  RealBias = $81;
  DoubleBias = $3FF;
  ExtBias  = $3FFF;

{$IF (Not DEFined(X86ASMRTL))}
function _Real2Ext(val: Pointer {PReal48}): Extended;
var
  LBytes: PByte;
  LDouble: Double;
begin
  LBytes := val; { [0 .. 5] }

  { Decompose the Real48. Check if the exponent is non-zero. }
  if LBytes[0] <> 0 then
  begin
    PUInt64(@LDouble)^ :=
      ((UInt64(LBytes[5]) and $80) shl 56) or                 { Sign Bit }
      ((UInt64(LBytes[0]) + DoubleBias - RealBias) shl 52) or { Exponent }
      (
        ((UInt64(LBytes[5]) and $7F) shl 32) or
        (UInt64(LBytes[4]) shl 24) or
        (UInt64(LBytes[3]) shl 16) or
        (UInt64(LBytes[2]) shl 8) or
        (UInt64(LBytes[1]) shl 0)
      ) shl 13;                                               { Mantissa }
  end else
    LDouble := 0;

  { On 386, this will convert the Double to Extended, on x64 Extended = Double. }
  Result := LDouble;
end;
{$ELSE X86ASMRTL}
procedure _Real2Ext;//( val : Real ) : Extended;
asm
// -> EAX Pointer to value
// <- FST(0)  Result

//  the REAL data type has the following format:
//  8 bit exponent (bias 129), 39 bit fraction, 1 bit sign

        MOV    DH, [EAX+5]  // isolate the sign bit
        AND    DH, 80H
        MOV    DL, [EAX]  // fetch exponent
        TEST   DL, DL   // exponent zero means number is zero
        JE     @@zero

        ADD    DX, ExtBias - RealBias // adjust exponent bias

        PUSH   EDX   // the exponent is at the highest address

        MOV    EDX, [EAX+2] // load high fraction part, set hidden bit
        OR     EDX, 80000000H
        PUSH   EDX   // push high fraction part

        MOV    DL, [EAX+1]  // load remaining low byte of fraction
        SHL    EDX, 24    // clear low 24 bits
        PUSH   EDX

        FLD    tbyte ptr [ESP] // pop result onto chip
        ADD    ESP, 12

        RET

@@zero:
        FLDZ
        RET
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _Ext2Real(Dest: Pointer {PReal48}; Val: Extended);
type
  PReal48Rec = ^TReal48Rec;
  TReal48Rec = packed record
    Exp: Byte;
    MLo: Byte;
    MHi: UInt32;
  end;
  {$IFDEF EXTENDEDHAS10BYTES}
  PExt80Rec = ^TExt80Rec;
  TExt80Rec = packed record
    MLo: UInt32;
    MHi: UInt32;
    SignExp: UInt16;
  end;
  {$ELSE  !EXTENDEDHAS10BYTES}
  PExt64Rec = ^TExt64Rec;
  TExt64Rec = packed record
  case Integer of
  0: (Bytes: array[0..7] of Byte;);
  1: (Words: array[0..3] of UInt16;);
  2: (DWords: array[0..1] of UInt32;);
  3: (QWordVal: UInt64;);
  end;
  {$ENDIF !EXTENDEDHAS10BYTES}
var
  MHi: UInt32;
  MLo: Byte;
  Exp: Integer;
  {$IFDEF EXTENDEDHAS10BYTES}
  ExtVal : PExt80Rec;
  {$ELSE  !EXTENDEDHAS10BYTES}
  ExtVal : PExt64Rec;
  {$ENDIF !EXTENDEDHAS10BYTES}
begin
  {$IFDEF EXTENDEDHAS10BYTES}

  ExtVal := PExt80Rec(@Val);
  Exp := Integer(ExtVal^.SignExp and $7fff) - ExtBias + RealBias;
  MHi := ExtVal^.MHi and $7fffffff;
  MLo := Byte(ExtVal^.MLo shr 24);
  if (ExtVal^.MLo and $ffffff) > $7fffff then
  begin
    Inc(MLo);
    if MLo = 0 then
    begin
      Inc(MHi);
      if MHi = $80000000 then
      begin
        MHi := 0;
        Inc(Exp);
      end;
    end;
  end;
  if (ExtVal^.SignExp and $8000) <> 0 then
    MHi := MHi or $80000000;

  {$ELSE  !EXTENDEDHAS10BYTES}

  ExtVal := PExt64Rec(@Val);
  Exp := Integer((ExtVal^.Words[3] shr 4) and $7ff) - DoubleBias + RealBias;
  MHi := UInt32(ExtVal^.QWordVal shr 21) and $7fffffff;
  MLo := Byte(ExtVal^.DWords[0] shr 13);
  if (ExtVal^.DWords[0] and $1fff) > $fff then
  begin
    Inc(MLo);
    if MLo = 0 then
    begin
      Inc(MHi);
      if MHi = $80000000 then
      begin
        MHi := 0;
        Inc(Exp);
      end;
    end;
  end;
  if (ExtVal^.Bytes[7] and $80) <> 0 then
    MHi := MHi or $80000000;

  {$ENDIF !EXTENDEDHAS10BYTES}

  if Exp < 0 then
    Exp := 0
  else if Exp > 255 then
    Error(reOverflow);
  PReal48Rec(Dest)^.Exp := Exp;
  PReal48Rec(Dest)^.MLo :=  MLo;
  PReal48Rec(Dest)^.MHi :=  MHi;
end;
{$ELSE X86ASMRTL}
procedure _Ext2Real;//( val : Extended ) : Real;
asm
// -> FST(0)  Value
//  EAX Pointer to result

        PUSH  EBX

        SUB   ESP,12
        FSTP  tbyte ptr [ESP]

        POP   EBX     // EBX is low half of fraction
        POP   EDX     // EDX is high half of fraction
        POP   ECX     // CX is exponent and sign

        SHR   EBX,24  // set carry to last bit shifted out
        ADC   BL,0    // if bit was 1, round up
        ADC   EDX,0
        ADC   CX,0
        JO    @@overflow

        ADD   EDX,EDX // shift fraction 1 bit left
        ADD   CX,CX   // shift sign bit into carry
        RCR   EDX,1   // attach sign bit to fraction
        SHR   CX,1    // restore exponent, deleting sign

        SUB   CX,ExtBias-RealBias // adjust exponent
        JLE   @@underflow
        TEST  CH,CH     // CX must be in 1..255
        JG    @@overflow

        MOV   [EAX],CL
        MOV   [EAX+1],BL
        MOV   [EAX+2],EDX

        POP   EBX
        RET

@@underflow:
        XOR   ECX,ECX
        MOV   [EAX],ECX
        MOV   [EAX+4],CX
        POP   EBX
        RET

@@overflow:
        POP   EBX
        MOV   AL,8
        JMP   Error
end;
{$ENDIF X86ASMRTL}

{$IFNDEF EXTENDEDHAS10BYTES}
function _Ext80ToDouble(Val: Pointer {PExtended80}): Double;
begin
  Result := Double(PExtended80Rec(Val)^);
end;

procedure _DoubleToExt80(Dest: Pointer {PExtended80}; Val: Double);
begin
  PExtended80Rec(Dest)^ := TExtended80Rec(Val);
end;
{$ENDIF EXTENDEDHAS10BYTES}

{$IF not defined(X86ASMRTL)}
// Result := Double(Ext80(Dividend) / Ext80(Divisor));
function _CompDiv(Dividend, Divisor: Comp): Double;
var
  Sign: Boolean;
  Exp: Integer;
  A, B, R: UInt64;
  T, D: Int64;
  J: Integer;
  procedure RoundToDoubleRN;
  var
    HalfBit: UInt64;
    MaskBits: UInt64;
  begin
    HalfBit  := $0000000000000400;
    MaskBits := $fffffffffffff800;
    if (Exp < -$3fe) and (Exp > $3fe - 53) then // for Denormal values
    begin
      //  $3BCE exp = -$3FE - 52 => MaskBits = 0x80000000_00000000
      //  $3C00 exp = -$3FE -  1 => MaskBits = 0xffffffff_fffff000
      HalfBit  := HalfBit  shl (-$3FE - Exp);
      MaskBits := MaskBits shl (-$3FE - Exp);
    end;
    if (R and HalfBit) <> 0 then
    begin
      if ((R and not MaskBits) <> HalfBit) or ((R and (HalfBit shl 1)) <> 0) then
        Inc(R, HalfBit);
      R := R and MaskBits;
      if R = 0 then
      begin
        R := $8000000000000000;
        Inc(Exp);
        // if (Exp > $3FFF) ... // exp=$4000, R=$80..00; infinite
      end;
    end
    else
      R := R and MaskBits;
  end;
begin
  Sign := Dividend < 0;
  if Sign then
    A := UInt64(- PInt64(@Dividend)^)
  else
    A := PUInt64(@Dividend)^;
  if Divisor < 0 then
  begin
    B := UInt64(- PInt64(@Divisor)^);
    Sign := not Sign;
  end
  else
    B := PUInt64(@Divisor)^;
  Exp := 0;
  //
  // Exceptions
  if B = 0 then
  begin
    ErrorAt(Byte(reZeroDivide), ReturnAddress);
    R := $7FF0000000000000;
    if Sign then
      R := $FFF0000000000000;
    PUInt64(@Result)^ := R;
    Exit;
  end;
  if A = 0 then
    Exit(0);
  //
  // Normalize A
  if (A and $FFFFFFFF00000000) = 0 then
  begin
    A := A shl 32;
    Dec(Exp, 32);
  end;
  if (A and $FFFF000000000000) = 0 then
  begin
    A := A shl 16;
    Dec(Exp, 16);
  end;
  if (A and $FF00000000000000) = 0 then
  begin
    A := A shl 8;
    Dec(Exp, 8);
  end;
  while (A and $8000000000000000) = 0 do
  begin
    A := A shl 1;
    Dec(Exp);
  end;
  //
  // Normalize B
  if (B and $FFFFFFFF00000000) = 0 then
  begin
    B := B shl 32;
    Inc(Exp, 32);
  end;
  if (B and $FFFF000000000000) = 0 then
  begin
    B := B shl 16;
    Inc(Exp, 16);
  end;
  if (B and $FF00000000000000) = 0 then
  begin
    B := B shl 8;
    Inc(Exp, 8);
  end;
  while (B and $8000000000000000) = 0 do
  begin
    B := B shl 1;
    Inc(Exp);
  end;
  //
  // short cut for A=B case
  if A = B then
  begin
    R := $8000000000000000;
    Inc(Exp);
  end
  else
  begin
    // make 0 <= A < B
    if A >= B then
    begin
      A := A shr 1;
      Inc(Exp);
    end;
    //
    // A = 0. a0 a1 a2 ... a63
    // B = 0. b0 b1 b2 ... b63
    // R = 0. r0 r1 r2 ... r63
    // 0 <= A < B
    // R := A div B;
    // 0 <= R < 1
    //
    D := Int64(B shr 1);
    T := A - D;
    R := 0;
    for J := 1 to 64 do
    begin
      R := R shl 1;
      D := D shr 1;
      if T < 0 then
        Inc(T, D)
      else
      begin
        Inc(R);
        Dec(T, D);
      end;
    end;
  end;
  //
  // Special result case
  if R = 0 then
  begin
    if Sign then
      R := $8000000000000000;
  end
  else
  begin
    // Normalize result in R
    while (R and $8000000000000000) = 0 do
    begin
      R := R shl 1;
      Dec(Exp);
    end;
    // -62 <= Exp <= +32
    //
    // Round 64 bit fraction to 1+52 bit
    RoundToDoubleRN;
    // Build floating point value
    R := (R shr 11) and $000FFFFFFFFFFFFF; // exclude msb=1 for economized form
    Inc(Exp, $3ff - 1); // $3ff is bias for 2^0, -1 for 0.1xxxxx to 1.xxxxx
    if Sign then
      Inc(Exp, $800);
    R := R or (UInt64(Exp) shl 52);
  end;
  PUInt64(@Result)^ := R;
end;
{$ENDIF !X86ASMRTL}

const
  ovtInstanceSize = -2 * SizeOf(Pointer); {Offset of instance size in OBJECTs}
  ovtVmtPtrOffs   = -1 * SizeOf(Pointer);

{$IF (Not DEFined(X86ASMRTL))}
// Returning Pointer(NativeInt(-1)) indicates failure.
// Otherwise, successful and Return Self.
// AllocFlag indicates an object which was allocated.
function _ObjSetup(Self: Pointer; var VmtPtrAndAllocFlag: Pointer): Pointer;
var
  Size: NativeInt;
  VmtPtrOffs: NativeInt;
  VmtPtr: Pointer;
begin
  Result := Self;
  VmtPtr := VmtPtrAndAllocFlag;
  if VmtPtr = nil then
    Exit; // Successful, not allocated
  if Result = nil then
  begin
    Size := PNativeInt(PByte(VmtPtr) + ovtInstanceSize)^;
    if Size = 0 then
    begin
      VmtPtrAndAllocFlag := nil;
      Exit; // Successful, not allocated
    end;
    Result := _GetMem(Size);
    if Result = nil then
    begin
      Result := Pointer(PByte(-1));
      VmtPtrAndAllocFlag := nil;
      Exit; // Failure, not allocated
    end;
    FillChar(Result^, Size, 0);
    // VmtPtrAndAllocFlag is already non-zero = allocated
  end
  else
    VmtPtrAndAllocFlag := nil; // not allocated
  VmtPtrOffs := PNativeInt(PByte(VmtPtr) + ovtVmtPtrOffs)^;
  if VmtPtrOffs >= 0 then
  begin
    // store vmt in object at this offset
    PPointer(PByte(Result) + VmtPtrOffs)^ := VmtPtr;
  end;
  // Successful, VmtPtrAndAllocFlag is non-zero if allocated
end;
{$ELSE X86ASMRTL}
procedure       _ObjSetup;
asm //StackAlignSafe
{       FUNCTION _ObjSetup( self: ^OBJECT; vmt: ^VMT): ^OBJECT; }
{     ->EAX     Pointer to self (possibly nil)  }
{       EDX     Pointer to vmt  (possibly nil)  }
{     <-EAX     Pointer to self                 }
{       EDX     <> 0: an object was allocated   }
{       Z-Flag  Set: failure, Cleared: Success  }

        CMP     EDX,1           { is vmt = 0, indicating a call         }
        JAE     @@skip1         { from a constructor?                   }
        RET                     { return immediately with Z-flag cleared}

@@skip1:
        PUSH    ECX
        TEST    EAX,EAX         { is self already allocated?            }
        JNE     @@noAlloc
        MOV     EAX,[EDX].ovtInstanceSize
        TEST    EAX,EAX
        JE      @@zeroSize
        PUSH    EDX
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        CALL    _GetMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
        POP     EDX
        TEST    EAX,EAX
        JZ      @@fail

        {       Zero fill the memory }

        PUSH    EDI
        MOV     ECX,[EDX].ovtInstanceSize
        MOV     EDI,EAX
        PUSH    EAX
        XOR     EAX,EAX
        SHR     ECX,2
        REP     STOSD
        MOV     ECX,[EDX].ovtInstanceSize
        AND     ECX,3
        REP     STOSB
        POP     EAX
        POP     EDI

        MOV     ECX,[EDX].ovtVmtPtrOffs
        TEST    ECX,ECX
        JL      @@skip
        MOV     [EAX+ECX],EDX   { store vmt in object at this offset    }
@@skip:
        TEST    EAX,EAX         { clear zero flag                       }
        POP     ECX
        RET

@@fail:
        XOR     EDX,EDX
        POP     ECX
        RET

@@zeroSize:
        XOR     EDX,EDX
        CMP     EAX,1   { clear zero flag - we were successful (kind of)}
        POP     ECX
        RET

@@noAlloc:
        MOV     ECX,[EDX].ovtVmtPtrOffs
        TEST    ECX,ECX
        JL      @@exit
        MOV     [EAX+ECX],EDX   { store vmt in object at this offset    }
@@exit:
        XOR     EDX,EDX         { clear allocated flag                  }
        TEST    EAX,EAX         { clear zero flag                       }
        POP     ECX
end;
{$ENDIF X86ASMRTL}

{$IF (Not DEFined(X86ASMRTL))}
procedure _ObjCopy(Dest, Source: Pointer; VmtPtrOffs: NativeInt);
var
  VmtPtr: Pointer;
  Size: NativeInt;
begin
  VmtPtr := PPointer(PByte(Dest) + VmtPtrOffs)^;
  Size := PNativeInt(PByte(VmtPtr) + ovtInstanceSize)^;
  Move(Source^, Dest^, Size);
  PPointer(PByte(Dest) + VmtPtrOffs)^ := VmtPtr;
end;
{$ELSE X86ASMRTL}
procedure _ObjCopy;
asm
{       PROCEDURE _ObjCopy( dest, src: ^OBJECT; vmtPtrOff: NativeInt);  }
{     ->EAX     Pointer to destination          }
{       EDX     Pointer to source               }
{       ECX     Offset of vmt in those objects. }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV     ESI,EDX
        MOV     EDI,EAX

        LEA     EAX,[EDI+ECX]   { remember pointer to dest vmt pointer  }
        MOV     EDX,[EAX]       { fetch dest vmt pointer        }

        MOV     EBX,[EDX].ovtInstanceSize

        MOV     ECX,EBX { copy size DIV 4 dwords        }
        SHR     ECX,2
        REP     MOVSD

        MOV     ECX,EBX { copy size MOD 4 bytes }
        AND     ECX,3
        REP     MOVSB

        MOV     [EAX],EDX       { restore dest vmt              }

        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF X86ASMRTL}

// _Fail is a helper function used by Fail standard procedure.
// It can be used in old style object constructor.
// -> Self = Pointer to self. (possibly nil or invlaid pointer if AllocFlag=0)
//    AllocFlag <> 0: Object must be deallocated
// <- Returns nil
function _Fail(Self: Pointer; AllocFlag: NativeInt): Pointer;
begin
  if AllocFlag <> 0 then
    FreeMem(Self);
  Result := nil;
end;

// GetBrifSSEType checks only SSE and SSE2 availability.
// To check full SSE information, use Math unit.
// $00000000: No SSE
// $00000001: SSE supported
// $00000002: SSE2 supported
{$IF defined(CPUX86) and defined(ASSEMBLER)}
function GetBriefSSEType: Cardinal;
asm
        PUSH    EBX
        PUSHFD
        POP     EAX
        MOV     ECX, EAX
        XOR     EAX, $200000    // flip CPUID bit in EFLAGS
        PUSH    EAX
        POPFD
        PUSHFD
        POP     EAX
        XOR     EAX, ECX    // zero = NO CPUID instruction.
        JZ      @@Exit

        // Use CPUID instruction to get SSE/SSE2 extension flags
        MOV     EAX, 1
        CPUID
        XOR     EAX, EAX
        TEST    EDX, $02000000  // EDX 25 bits - SSE bit
        JZ      @@CheckSSE2
        OR      EAX, 1          // Set SSE flag
@@CheckSSE2:
        TEST    EDX, $04000000  // EDX 26 bits - SSE2 bit
        JZ      @@Exit
        OR      EAX, 2          // Set SSE2 flag
@@Exit:
        POP     EBX
end;
{$ENDIF CPUX86 and ASSEMBLER}

procedure _InitializeControlWord;
begin
{$IF defined(IOS) and defined(CPUX86)} // iOS Simulator
  FPUExceptionMaskBits := (Default8087CW and $003F) or ((DefaultMXCSR and $1F80) shr 7) or $8000;
  TestSSE := $3; // All Intel Mac supports SSE2.
{$ELSEIF defined(CPUX86) and defined(ASSEMBLER)} // Win32 or OSX
  TestSSE := GetBriefSSEType;
  DefaultMXCSR := GetMXCSR and $FFC0;  // Remove flag bits;
{$ELSEIF defined(CPUX64)} // Win64
  TestSSE := $3; // SSE & SSE2 are available on X64
  Default8087CW := Get8087CW and $1F3F; // Remove reserved bits.
{$ENDIF}
end;

procedure _FpuInit;
{$IF ((defined(LINUX) or defined(IOS)) and defined(CPUARM)) or defined(ANDROID)} // iOS Device or Android
const
  ValidMask = $07C0009F; // AHP, DefaultNan, Flush-to-Zero, RoundMode, All exception events
begin
  SetFPSCR(DefaultFPSCR and ValidMask);
  FPSCRExceptionEnableBits := DefaultFPSCR and femALLEXCEPT;
end;
{$ELSEIF defined(IOS) and defined(CPUX86)} // iOS/32 Simulator
begin
  FPUExceptionMaskBits := (Default8087CW and $003F) or ((DefaultMXCSR and $1F80) shr 7) or $8000;
  Set8087CW(Default8087CW);
  SetMXCSR(DefaultMXCSR);
end;
{$ELSEIF defined(CPUX86)} // Win32 and OSX
asm
        FNINIT
        FWAIT
{$IFDEF PIC}
        CALL    GetGOT
        MOV     EAX,[EAX].OFFSET Default8087CW
        FLDCW   [EAX]
{$IFDEF IOS}
        CALL    GetGOT
        MOV     EAX,[EAX].OFFSET DefaultMXCSR
        LDMXCSR   [EAX]
{$ENDIF}
{$ELSE}
        FLDCW   Default8087CW
{$ENDIF}
end;
{$ELSEIF defined(CPUX64) and defined(MSWINDOWS)} // Windows/64
asm
        LDMXCSR DefaultMXCSR
end;
{$ELSEIF defined(CPUX64) and defined(MACOS)} // OSX/64
begin
                                     
end;
{$ELSEIF defined(CPUX64) and defined(LINUX)} // Linux/64
begin
                                       
  FPUExceptionMaskBits := ((Default8087CW and $003F) shl 7) or (DefaultMXCSR and $1F80) or $8000;
end;
{$ELSE}
begin
  Error(rePlatformNotImplemented);
end;
{$ENDIF}

procedure _BoundErr;
{$IFDEF PUREPASCAL}
begin
  ErrorAt(Byte(reRangeError), ReturnAddress);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        MOV     AL,reRangeError
        JMP     Error
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _IntOver;
{$IFDEF PUREPASCAL}
begin
  ErrorAt(Byte(reIntOverflow), ReturnAddress);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        MOV     AL,reIntOverflow
        JMP     Error
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _IntDivByZero;
{$IFDEF PUREPASCAL}
begin
  ErrorAt(Byte(reDivByZero), ReturnAddress);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        MOV     AL,reDivByZero
        JMP     Error
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


{$IFDEF USE_LIBICU}
function InternalCompareText(const S1, S2: string): Boolean;
begin
  Result := u_strcasecmp(PUChar(S1), PUChar(S2), 0) = 0;
end;
{$ELSE}
{$IF defined(MACOS)}
function InternalCompareText(const S1, S2: string): Boolean;
var
  StringRef1: CFStringRef;
  StringRef2: CFStringRef;
  Range: CFRange;
begin
  Result := False;
  StringRef1 := CFStringCreateWithCharacters(nil, @S1[Low(string)], Length(S1));
  if StringRef1 <> nil then
  try
    StringRef2 := CFStringCreateWithCharacters(nil, @S2[Low(string)], Length(S2));
    if StringRef2 <> nil then
    try
      Range.location := 0;
      Range.length := Length(S1);
      Result := CFStringCompareWithOptionsAndLocale(StringRef1, StringRef2,
                  Range, kCFCompareCaseInsensitive, UTF8CompareLocale) = 0;
    finally
      CFRelease(StringRef2);
    end;
  finally
    CFRelease(StringRef1);
  end;
end;
{$ELSEIF defined(POSIX)}
function InternalCompareText(const S1, S2: string): Boolean;
var
  I: Integer;
  US1, US2: UCS4String;
  LCompareLocale: Pointer;
begin
  if Length(S1) <> Length(S2) then
    Exit(False);

  // Convert to UCS4
  US1 := UnicodeStringToUCS4String(S1);
  US2 := UnicodeStringToUCS4String(S2);

  // Convert to upper case for case insensitivity
  LCompareLocale := UTF8CompareLocale;
  for I := 0 to Length(US1) - 1 do
    US1[I] := UCS4Char(towupper_l(wint_t(US1[I]), LCompareLocale));
  for I := 0 to Length(US2) - 1 do
    US2[I] := UCS4Char(towupper_l(wint_t(US2[I]), LCompareLocale));

  // Clear error info and compare strings
  SetLastError(0);
  Result := (wcscoll_l(pwchar_t(@US1[0]), pwchar_t(@US2[0]), LCompareLocale) = 0) and
            (GetLastError = 0);
end;
{$ENDIF POSIX}
{$ENDIF USE_LIBICU}

function TObject.ClassType: TClass;
begin
  Pointer(Result) := PPointer(Self)^;
end;

class function TObject.ClassName: string;
begin
  Result := UTF8ToString(_PShortStr(PPointer(PByte(Self) + vmtClassName)^)^);
end;

class function TObject.QualifiedClassName: string;
var
  LScope: string;
begin
  LScope := UnitScope;
  if LScope = '' then
    Result := ClassName
  else
    Result := LScope + '.' + ClassName;
end;

class function TObject.ClassNameIs(const Name: string): Boolean;
{$IFDEF MSWINDOWS}
var
  LClassName: string;
begin
  LClassName := ClassName;
  Result := CompareString(UTF8CompareLocale, NORM_IGNORECASE, PChar(LClassName),
    Length(LClassName), PChar(Name), Length(Name)) = CSTR_EQUAL;
end;
{$ENDIF}
{$IFDEF POSIX}
begin
  Result := InternalCompareText(ClassName, Name);
end;
{$ENDIF}

class function TObject.ClassParent: TClass;
{$IFDEF PUREPASCAL}
begin
  Pointer(Result) := PPointer(PByte(Self) + vmtParent)^;
  if Result <> nil then
    Pointer(Result) := PPointer(Result)^;
end;
{$ELSE !PUREPASCAL}
asm
        MOV     EAX,[EAX].vmtParent
        TEST    EAX,EAX
        JE      @@exit
        MOV     EAX,[EAX]
@@exit:
end;
{$ENDIF !PUREPASCAL}

class function TObject.NewInstance: TObject;
begin
  Result := InitInstance(_GetMem(InstanceSize));
{$IFDEF AUTOREFCOUNT}
  Result.FRefCount := 1;
{$ENDIF}
end;

procedure TObject.FreeInstance;
begin
  CleanupInstance;
  _FreeMem(Pointer(Self));
end;

{$IFDEF CPP_ABI_SUPPORT}
procedure TObject.CPP_ABI_1;
begin
end;

procedure TObject.CPP_ABI_2;
begin
end;

procedure TObject.CPP_ABI_3;
begin
end;
{$ENDIF CPP_ABI_SUPPORT}

class operator TMethod.Equal(const Left, Right: TMethod): Boolean;
begin
  Result := (Left.Data = Right.Data) and (Left.Code = Right.Code);
end;

class operator TMethod.NotEqual(const Left, Right: TMethod): Boolean;
begin
  Result := not (Left = Right);
end;

class operator TMethod.GreaterThan(const Left, Right: TMethod): Boolean;
begin
  Result := (UIntPtr(Left.Data) > UIntPtr(Right.Data)) or
    ((Left.Data = Right.Data) and (UIntPtr(Left.Code) > UIntPtr(Right.Code)));
end;

class operator TMethod.GreaterThanOrEqual(const Left, Right: TMethod): Boolean;
begin
  Result := (Left > Right) or (Left = Right);
end;

class operator TMethod.LessThan(const Left, Right: TMethod): Boolean;
begin
  Result := (UIntPtr(Left.Data) < UIntPtr(Right.Data)) or
    ((Left.Data = Right.Data) and (UIntPtr(Left.Code) < UIntPtr(Right.Code)));
end;

class operator TMethod.LessThanOrEqual(const Left, Right: TMethod): Boolean;
begin
  Result := (Left < Right) or (Left = Right);
end;

class function TObject.InstanceSize: Integer;
begin
  Result := PInteger(PByte(Self) + vmtInstanceSize)^;
end;

constructor TObject.Create;
begin
end;

destructor TObject.Destroy;
begin
end;

procedure TObject.Free;
begin
// under ARC, this method isn't actually called since the compiler translates
// the call to be a mere nil assignment to the instance variable, which then calls _InstClear
{$IFNDEF AUTOREFCOUNT}
  if Self <> nil then
    Destroy;
{$ENDIF}
end;

procedure TObject.DisposeOf;
type
  TDestructorProc = procedure (Instance: Pointer; OuterMost: ShortInt);
begin
{$IFDEF AUTOREFCOUNT}
  if Self <> nil then
  begin
    Self.__ObjAddRef; // Ensure the instance remains alive throughout the disposal process
    try
      if __SetDisposed(Self) then
      begin
        _BeforeDestruction(Self, 1);
        TDestructorProc(PPointer(PByte(PPointer(Self)^) + vmtDestroy)^)(Self, 0);
      end;
    finally
      Self.__ObjRelease; // This will deallocate the instance if the above process cleared all other references.
    end;
  end;
{$ELSE}
  Free;
{$ENDIF}
end;

class function TObject.InitInstance(Instance: Pointer): TObject;
{$IFDEF PUREPASCAL}
var
  IntfTable: PInterfaceTable;
  ClassPtr: TClass;
  I: Integer;
begin
  FillChar(Instance^, InstanceSize, 0);
  PPointer(Instance)^ := Pointer(Self);
  ClassPtr := Self;
  while ClassPtr <> nil do
  begin
    IntfTable := ClassPtr.GetInterfaceTable;
    if IntfTable <> nil then
      for I := 0 to IntfTable.EntryCount-1 do
        with IntfTable.Entries[I] do
        begin
          if VTable <> nil then
            PPointer(@PByte(Instance)[IOffset])^ := VTable;
        end;
    ClassPtr := ClassPtr.ClassParent;
  end;
  Result := Instance;
end;
{$ELSE !PUREPASCAL}
asm
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EBX,EAX
        MOV     EDI,EDX
        STOSD
        MOV     ECX,[EBX].vmtInstanceSize
        XOR     EAX,EAX
        PUSH    ECX
        SHR     ECX,2
        DEC     ECX
        REP     STOSD
        POP     ECX
        AND     ECX,3
        REP     STOSB
        MOV     EAX,EDX
        MOV     EDX,ESP
@@0:    MOV     ECX,[EBX].vmtIntfTable
        TEST    ECX,ECX
        JE      @@1
        PUSH    ECX
@@1:    MOV     EBX,[EBX].vmtParent
        TEST    EBX,EBX
        JE      @@2
        MOV     EBX,[EBX]
        JMP     @@0
@@2:    CMP     ESP,EDX
        JE      @@5
@@3:    POP     EBX
        MOV     ECX,[EBX].TInterfaceTable.EntryCount
        ADD     EBX,4
@@4:    MOV     ESI,[EBX].TInterfaceEntry.VTable
        TEST    ESI,ESI
        JE      @@4a
        MOV     EDI,[EBX].TInterfaceEntry.IOffset
        MOV     [EAX+EDI],ESI
@@4a:   ADD     EBX,TYPE TInterfaceEntry
        DEC     ECX
        JNE     @@4
        CMP     ESP,EDX
        JNE     @@3
@@5:    POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF}

procedure TObject.CleanupInstance;
{$IFDEF PUREPASCAL}
var
  ClassPtr: TClass;
  InitTable: Pointer;
begin
{$IFDEF WEAKREF}
{$IFDEF WEAKINSTREF}
  _CleanupInstance(Self);
{$ELSE !WEAKINSTREF}
  ClassPtr := ClassType;
  repeat
    if ClassPtr.GetInterfaceTable <> nil then
    begin
      _CleanupInstance(Self);
      break
    end;
    ClassPtr := ClassPtr.ClassParent;
  until ClassPtr = nil;
{$ENDIF WEAKINSTREF}
{$ENDIF WEAKREF}
  ClassPtr := ClassType;
  repeat
    InitTable := PPointer(PByte(ClassPtr) + vmtInitTable)^;
    if InitTable <> nil then
      _FinalizeRecord(Self, InitTable);
    ClassPtr := ClassPtr.ClassParent;
  until ClassPtr = nil;
  TMonitor.Destroy(Self);
end;
{$ELSE !PUREPASCAL}
asm
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EBX,EAX
        MOV     ESI,EAX
        MOV     EDI,EAX
{$IFDEF WEAKREF}
{$IFDEF WEAKINSTREF}
        CALL    _CleanupInstance
{$ELSE !WEAKINSTREF}
@@loop1:
        TEST    EDI,EDI
        JE      @@done1
@@entry1:
        MOV     EDI,[EDI]
        MOV     EDX,[EDI].vmtIntfTable
        MOV     EDI,[EDI].vmtParent
        TEST    EDX,EDX
        JE      @@loop1
        CALL    _CleanupInstance
@@done1:
{$ENDIF WEAKINSTREF}
{$ENDIF}
        MOV     EAX,ESI
@@loop2:
        MOV     ESI,[ESI]
        MOV     EDX,[ESI].vmtInitTable
        MOV     ESI,[ESI].vmtParent
        TEST    EDX,EDX
        JE      @@skip2
        CALL    _FinalizeRecord
        MOV     EAX,EBX
@@skip2:
        TEST    ESI,ESI
        JNE     @@loop2

        MOV     EAX,EBX
        CALL    TMonitor.Destroy;

        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF !PUREPASCAL}

function InvokeImplGetter(const Self: TObject; ImplGetter: NativeUInt): IInterface;
{$IFDEF PUREPASCAL}
var
  M: function: IInterface of object;
begin
  TMethod(M).Data := Self;
  {$IF SizeOf(NativeUInt) = 8}
  if (ImplGetter and $FF00000000000000) = $FF00000000000000 then // Field
    Result := IInterface(PPointer(PByte(Self) + (ImplGetter and $00FFFFFFFFFFFFFF))^)
  else if (ImplGetter and $FF00000000000000) = $FE00000000000000 then // virtual method
  begin
    // sign extend vmt slot offset = smallint cast
    TMethod(M).Code := PPointer(PNativeInt(Self)^ + SmallInt(ImplGetter))^;
    Result := M;
  end
  else // static method
  begin
    TMethod(M).Code := Pointer(ImplGetter);
    Result := M;
  end;
  {$ELSE SizeOf(NativeUInt) <> 8}
  case LongWord(ImplGetter) of
    $FF000000..$FFFFFFFF:  // Field
        Result := IInterface(PPointer(PByte(Self) + (ImplGetter and $00FFFFFF))^);
    $FE000000..$FEFFFFFF:  // virtual method
      begin
        // sign extend vmt slot offset = smallint cast
        TMethod(M).Code := PPointer(PNativeInt(Self)^ + SmallInt(ImplGetter))^;
        Result := M;
      end;
  else // static method
    TMethod(M).Code := Pointer(ImplGetter);
    Result := M;
  end;
  {$ENDIF}
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        XCHG    EDX,ECX
        CMP     ECX,$FF000000
        JAE     @@isField
        CMP     ECX,$FE000000
        JB      @@isStaticMethod

        {       the GetProc is a virtual method }
        MOVSX   ECX,CX                  { sign extend slot offs }
        ADD     ECX,[EAX]               { vmt   + slotoffs      }
        JMP     dword ptr [ECX]         { call vmt[slot]        }

@@isStaticMethod:
        JMP     ECX

@@isField:
        AND     ECX,$00FFFFFF
        ADD     ECX,EAX
        MOV     EAX,EDX
        MOV     EDX,[ECX]
        JMP     _IntfCopy
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function TObject.GetDisposed: Boolean;
begin
{$IFDEF AUTOREFCOUNT}
  Result := FRefCount and objDisposedFlag <> 0;
{$ELSE}
  Result := False;
{$ENDIF}
end;

procedure TObject.CheckDisposed;
begin
{$IFDEF AUTOREFCOUNT}
  if Disposed then
    ErrorAt(Byte(reObjectDisposed), ReturnAddress);
{$ENDIF}
end;

{$IFDEF AUTOREFCOUNT}
class procedure TObject.__MarkDestroying(const Obj);
var
  LRef: Integer;
begin
  repeat
    LRef := TObject(Obj).FRefCount;
  until AtomicCmpExchange(TObject(Obj).FRefCount, LRef or objDestroyingFlag, LRef) = LRef;
end;

class function TObject.__SetDisposed(const Obj): Boolean;
var
  LRef: Integer;
begin
  repeat
    LRef := TObject(Obj).FRefCount;
  until AtomicCmpExchange(TObject(Obj).FRefCount, LRef or objDisposedFlag, LRef) = LRef;
  Result := LRef and objDisposedFlag = 0;
end;

function TObject.__ObjAddRef: Integer;
begin
  Result := AtomicIncrement(FRefCount);
end;

function TObject.__ObjRelease: Integer;
begin
  Result := AtomicDecrement(FRefCount) and not objDisposedFlag;
  if Result = 0 then
  begin
    __MarkDestroying(Self);
    if __SetDisposed(Self) then
      Destroy
    else
      FreeInstance;
  end;
end;
{$ENDIF}

function TObject.Equals(Obj: TObject): Boolean;
begin
  Result := Obj = Self;
end;

function TObject.GetHashCode: Integer;
begin
{$IFDEF CPUX64}
  Result := Integer(IntPtr(Self)) xor Integer(IntPtr(Self) shr 32);
{$ELSE !CPUX64}
  Result := Integer(IntPtr(Self));
{$ENDIF !CPUX64}
end;

function TObject.GetInterface(const IID: TGUID; out Obj): Boolean;
var
  InterfaceEntry: PInterfaceEntry;
begin
  Pointer(Obj) := nil;
  InterfaceEntry := GetInterfaceEntry(IID);
  if InterfaceEntry <> nil then
  begin
    if InterfaceEntry^.IOffset <> 0 then
    begin
      Pointer(Obj) := Pointer(PByte(Self) + InterfaceEntry^.IOffset);
      if Pointer(Obj) <> nil then IInterface(Obj)._AddRef;
    end
    else
      IInterface(Obj) := InvokeImplGetter(Self, InterfaceEntry^.ImplGetter);
  end else if ObjCastGUID = IID then
    Pointer(Obj) := Pointer(Self);
  Result := Pointer(Obj) <> nil;
end;

class function TObject.GetInterfaceEntry(const IID: TGUID): PInterfaceEntry;
{$IFDEF PUREPASCAL}
var
  ClassPtr: TClass;
  IntfTable: PInterfaceTable;
  I: Integer;
begin
  ClassPtr := Self;
  repeat
    IntfTable := ClassPtr.GetInterfaceTable;
    if IntfTable <> nil then
      for I := 0 to IntfTable.EntryCount-1 do
      begin
        Result := @IntfTable.Entries[I];
        if Result^.IID = IID then Exit;
      end;
    ClassPtr := ClassPtr.ClassParent;
  until ClassPtr = nil;
  Result := nil;
end;
{$ELSE}
asm
        PUSH    EBX
        PUSH    ESI
        MOV     EBX,EAX
@@1:    MOV     EAX,[EBX].vmtIntfTable
        TEST    EAX,EAX
        JE      @@4
        MOV     ECX,[EAX].TInterfaceTable.EntryCount
        ADD     EAX,4
@@2:    MOV     ESI,[EDX].Integer[0]
        CMP     ESI,[EAX].TInterfaceEntry.IID.Integer[0]
        JNE     @@3
        MOV     ESI,[EDX].Integer[4]
        CMP     ESI,[EAX].TInterfaceEntry.IID.Integer[4]
        JNE     @@3
        MOV     ESI,[EDX].Integer[8]
        CMP     ESI,[EAX].TInterfaceEntry.IID.Integer[8]
        JNE     @@3
        MOV     ESI,[EDX].Integer[12]
        CMP     ESI,[EAX].TInterfaceEntry.IID.Integer[12]
        JE      @@5
@@3:    ADD     EAX,type TInterfaceEntry
        DEC     ECX
        JNE     @@2
@@4:    MOV     EBX,[EBX].vmtParent
        TEST    EBX,EBX
        JE      @@4a
        MOV     EBX,[EBX]
        JMP     @@1
@@4a:   XOR     EAX,EAX
@@5:    POP     ESI
        POP     EBX
end;
{$ENDIF}

class function TObject.GetInterfaceTable: PInterfaceTable;
begin
  Result := PPointer(PByte(Self) + vmtIntfTable)^;
end;

type
  PClassData = ^TClassData;
  TClassData = record
    ClassType: TClass;
    ParentInfo: Pointer;
    PropCount: SmallInt;
    UnitName: _ShortStr;
  end;

class function TObject.UnitName: string;
var
  LClassInfo: Pointer;
  S: _PShortStr;
begin
  LClassInfo := ClassInfo;
  if LClassInfo <> nil then
  begin
    S := @PClassData(PByte(LClassInfo) + 2 + PByte(PByte(LClassInfo) + 1)^).UnitName;
    if S^[1] <> '@' then
      Result := UTF8ToString(S^)
    else
      Result := UTF8ToString(Copy(S^, Pos(_ShortStr(':'), S^) + 1, MaxInt));
  end else
    Result := '';
end;

class function TObject.UnitScope: string;
var
  LClassInfo: Pointer;
  S: _PShortStr;
begin
  LClassInfo := ClassInfo;
  if LClassInfo <> nil then
  begin
    S := @PClassData(PByte(LClassInfo) + 2 + PByte(PByte(LClassInfo) + 1)^).UnitName;
    if S^[1] <> '@' then
      Result := UTF8ToString(S^)
    else
      Result := UTF8ToString(Copy(S^, 2, Pos(_ShortStr(':'), S^) - 2));
  end else
    Result := '';
end;

function _IsClass(const Child: TObject; Parent: TClass): Boolean;
begin
  Result := (Child <> nil) and Child.InheritsFrom(Parent);
end;

function _AsClass(const Child: TObject; Parent: TClass): TObject;
begin
  Result := Child;
  if (Child <> nil) and not (Child is Parent) then
    ErrorAt(Byte(reInvalidCast), ReturnAddress);
end;

                                                        
function _IntfAsClass(const Intf: IInterface; Parent: TClass): TObject;
{$IF DEFINED(PUREPASCAL) or DEFINED(PIC)}
var
  Temp: Pointer;
begin
  Temp := nil;
  _IntfCast(IInterface(Temp), Intf, ObjCastGUID);
  Result := _AsClass(TObject(Temp), Parent);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDX
        PUSH    0
        MOV     EDX, EAX
        LEA     ECX, ObjCastGUID
        MOV     EAX, ESP
        CALL    _IntfCast
        POP     EAX
        POP     EDX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
        JMP    _AsClass
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL or !PIC}

function _SafeIntfAsClass(const Intf: IInterface; Parent: TClass): TObject;
begin
  if (Intf <> nil) and (Intf.QueryInterface(ObjCastGUID, Pointer(Result)) = S_OK) and (Result is Parent) then
    Exit;
  Result := nil;
end;

function _IntfIsClass(const Intf: IInterface; Parent: TClass): Boolean;
begin
  Result := _SafeIntfAsClass(Intf, Parent) <> nil;
end;

function _GetHelperDelegate(const Instance: TObject; HelperClass: TClass): TObject;
begin
  Result := TClassHelperBaseClass(HelperClass)._Create(Instance);
end;

function _GetHelperIntf(const Instance: TObject; HelperClass: TClass): IInterface;
var
  IntfTable: PInterfaceTable;
  P: PInterfaceEntry;
begin
  IntfTable := HelperClass.GetInterfaceTable;
  if IntfTable <> nil then
  begin
    if IntfTable.EntryCount > 0 then
    begin
      P := @IntfTable.Entries[0];
      if Instance.GetInterfaceEntry(P.IID) <> nil then
      begin
        Result := TClassHelperBase(Instance);
        Exit;
      end;
    end;
  end;
  Result := TClassHelperBase(_GetHelperDelegate(Instance, HelperClass));
end;

function GetDynaMethod(vmt: TClass; selector: SmallInt): Pointer;
{$IFDEF PUREPASCAL}
type
  TDynaMethodTable = record
    Count: Word;
    Selectors: array[0..9999999] of SmallInt;
    {Addrs: array[0..0] of Pointer;}
  end;
  PDynaMethodTable = ^TDynaMethodTable;
var
  dynaTab: PDynaMethodTable;
  Parent: Pointer;
  Addrs: PPointer;
  I: Cardinal;
begin
  while True do
  begin
    dynaTab := PPointer(PByte(vmt) + vmtDynamicTable)^;
    if dynaTab <> nil then
    begin
      for I := 0 to dynaTab.Count - 1 do
        if dynaTab.Selectors[I] = selector then
        begin
          Addrs := PPointer(PByte(@dynaTab.Selectors) + dynaTab.Count * SizeOf(dynaTab.Selectors[0]));
          Result := PPointer(PByte(Addrs) + I * SizeOf(Pointer))^;
          Exit;
        end;
    end;
    Parent := PPointer(PByte(vmt) + vmtParent)^;
    if Parent = nil then Break;
    vmt := PPointer(Parent)^;
  end;
  Result := nil;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
{       function        GetDynaMethod(vmt: TClass; selector: Smallint) : Pointer;       }
        { ->    EAX     vmt of class            }
        {       EDX     dynamic method index    }
        { <-    EAX     pointer to routine      }
        {       trashes ECX, EDX                }
        PUSH    EDI

        XCHG    EAX, EDX
        JMP     @@haveVMT
@@outerLoop:
        MOV     EDX,[EDX]
@@haveVMT:
        MOV     EDI,[EDX].vmtDynamicTable
        TEST    EDI,EDI
        JE      @@parent
        MOVZX   ECX,word ptr [EDI]
        PUSH    ECX
        ADD     EDI,2
        REPNE   SCASW
        JE      @@found
        POP     ECX
@@parent:
        MOV     EDX,[EDX].vmtParent
        TEST    EDX,EDX
        JNE     @@outerLoop
        XOR     EAX, EAX
        JMP     @@exit

@@found:
        POP     EAX
        ADD     EAX,EAX
        SUB     EAX,ECX
        MOV     EAX,[EDI+EAX*2-4]

@@exit:
        POP     EDI
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

{$IF defined(X86ASMRTL)}
procedure _CallDynaInst;
asm
        { ->    EAX     vmt of class                 }
        {       ESI     dynamic method index         }
        {       trashes: ESI but compiler knows that }

        PUSH    EAX
        PUSH    ECX
        XCHG    ESI, EDX
        MOV     EAX,[EAX]
        CALL    GetDynaMethod { Safe to call unaligned }
        MOV     EDX, EAX
        XCHG    ESI, EDX
        POP     ECX
        POP     EAX
        TEST    ESI, ESI
        JE      @@Abstract
        JMP     ESI

@@Abstract:
{$IFNDEF ALIGN_STACK}
        POP     ECX
{$ENDIF}
        JMP     _AbstractError
end;
{$ENDIF X86ASMRTL}

{$IF defined(X86ASMRTL)}
procedure _CallDynaClass;
asm
        { ->    EAX     vmt of class                 }
        {       ESI     dynamic method index         }
        {       trashes: ESI but compiler knows that }

        PUSH    EAX
        PUSH    ECX
        XCHG    ESI, EDX
        CALL    GetDynaMethod { Safe to call unaligned }
        MOV     EDX, EAX
        XCHG    ESI, EDX
        POP     ECX
        POP     EAX
        TEST    ESI, ESI
        JE      @@Abstract
        JMP     ESI

@@Abstract:
{$IFNDEF ALIGN_STACK}
        POP     ECX
{$ENDIF}
        JMP     _AbstractError
end;
{$ENDIF X86ASMRTL}

function _FindDynaInst(const Self: TObject; Selector: SmallInt): Pointer;
{$IFDEF PUREPASCAL}
begin
  Result := GetDynaMethod(PPointer(Self)^, Selector);
  if Result = nil then
    _AbstractError;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     vmt of class                 }
        {       EDX     dynamic method index         }
        { <-    EAX     pointer to method            }

        MOV     EAX,[EAX]
        CALL    GetDynaMethod { Safe to call unaligned }
        TEST    EAX, EAX
        JNE     @@exit
{$IFNDEF ALIGN_STACK}
        POP     ECX
{$ENDIF}
        JMP     _AbstractError
@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function _FindDynaClass(Vmt: TClass; Selector: SmallInt): Pointer;
{$IFDEF PUREPASCAL}
begin
  Result := GetDynaMethod(Pointer(Vmt), Selector);
  if Result = nil then
    _AbstractError;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     vmt of class                 }
        {       EDX     dynamic method index         }
        { <-    EAX     pointer to method            }

        CALL    GetDynaMethod { Safe to call unaligned }
        TEST    EAX, EAX
        JNE     @@exit
{$IFNDEF ALIGN_STACK}
        POP     ECX
{$ENDIF}
        JMP     _AbstractError
@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

class function TObject.InheritsFrom(AClass: TClass): Boolean;
{$IFDEF PUREPASCAL}
var
  ClassPtr: Pointer;
  P: Pointer;
begin
  Result := False;
  ClassPtr := Pointer(Self);
  while True do
  begin
    if ClassPtr = Pointer(AClass) then
    begin
      Result := True;
      break;
    end;
    P := PPointer(PByte(ClassPtr) + vmtParent)^;
    if P = nil then break;
    ClassPtr := PPointer(P)^;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to our class    }
        {       EDX     Pointer to AClass       }
        { <-    AL      Boolean result          }
        JMP     @@haveVMT
@@loop:
        MOV     EAX,[EAX]
@@haveVMT:
        CMP     EAX,EDX
        JE      @@success
        MOV     EAX,[EAX].vmtParent
        TEST    EAX,EAX
        JNE     @@loop
        JMP     @@exit
@@success:
        MOV     AL,1
@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


class function TObject.ClassInfo: Pointer;
begin
  Result := PPointer(PByte(Self) + vmtTypeInfo)^;
end;

function TObject.SafeCallException(ExceptObject: TObject;
  ExceptAddr: Pointer): HResult;
begin
  Result := HResult($8000FFFF); { E_UNEXPECTED }
end;

function TObject.ToString: string;
begin
  Result := ClassName;
end;

procedure TObject.DefaultHandler(var Message);
begin
end;

procedure TObject.AfterConstruction;
begin
end;

procedure TObject.BeforeDestruction;
begin
{$IFDEF AUTOREFCOUNT}
  if ((RefCount and objDestroyingFlag) = 0) and (RefCount = 0) then
    Error(reInvalidPtr);
{$ENDIF}
end;

procedure TObject.Dispatch(var Message);
{$IFDEF PUREPASCAL}
type
  //THandlerProc = procedure(Self: Pointer; var Message) { of object };
  THandlerProc = procedure(var Message) of object;
var
  MsgID: Word;
  Addr: Pointer;
  M: THandlerProc;
begin
  MsgID := TDispatchMessage(Message).MsgID;
  if (MsgID <> 0) and (MsgID < $C000) then
  begin
    Addr := GetDynaMethod(PPointer(Self)^, MsgID);
    if Addr <> nil then
    begin
      //THandlerProc(Addr)(Self, Message)
      TMethod(M).Data := Self;
      TMethod(M).Code := Addr;
      M(Message);
    end
    else
      Self.DefaultHandler(Message);
  end
  else
    Self.DefaultHandler(Message);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        PUSH    EDX
        MOV     DX,[EDX]
        OR      DX,DX
        JE      @@default
        CMP     DX,0C000H
        JAE     @@default
        PUSH    EAX
{$IFDEF ALIGN_STACK}
        PUSH    EAX
{$ENDIF ALIGN_STACK}
        MOV     EAX,[EAX]
        CALL    GetDynaMethod
        MOV     ECX, EAX
{$IFDEF ALIGN_STACK}
        POP     EAX
{$ENDIF ALIGN_STACK}
        POP     EAX
        TEST    ECX, ECX
        JE      @@default
        POP     EDX
        JMP     ECX

@@default:
        POP     EDX
        MOV     ECX,[EAX]
        JMP     DWORD PTR [ECX] + VMTOFFSET TObject.DefaultHandler
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function UTF8Compare(const Str1, Str2: _ShortStr): Boolean;
{$IF defined(MSWINDOWS)}
var
  Len1, Len2: Integer;
  LStr1, LStr2: array[0..255] of WideChar;
begin
  Len1 := MultiByteToWideChar(CP_UTF8, 0, @Str1[1], Length(Str1), LStr1, Length(LStr1));
  Len2 := MultiByteToWideChar(CP_UTF8, 0, @Str2[1], Length(Str2), LStr2, Length(LStr2));
  Result := CompareString(UTF8CompareLocale, NORM_IGNORECASE, LStr1, Len1, LStr2, Len2) = CSTR_EQUAL;
end;
{$ELSEIF defined(POSIX)}
begin
  Result := InternalCompareText(UTF8ToUnicodeString(Str1), UTF8ToUnicodeString(Str2));
end;
{$ELSE}
begin
  Error(rePlatformNotImplemented);
end;
{$ENDIF}

class function TObject.MethodAddress(const Name: _ShortStr): Pointer;
{$IFDEF PUREPASCAL}
var
  LMethTablePtr: Pointer;
  LMethCount: Word;
  LMethEntry: PMethRec;
  LSelf: TClass;
begin
  Result := nil;

  LSelf := Pointer(Self);
  while True do
  begin
    { Obtain the method table and count }
    LMethTablePtr := PPointer(PByte(LSelf) + vmtMethodTable)^;
    if LMethTablePtr <> nil then
    begin
      LMethCount := PWord(LMethTablePtr)^;
      Inc(PWord(LMethTablePtr), 1);
    end else
      LMethCount := 0;

    { Search for the method if we have more than one. Also tested for a correct table ptr }
    if LMethCount > 0 then
    begin
      LMethEntry := LMethTablePtr;

      while LMethCount > 0 do
      begin
        if (LMethEntry^.nameLen = Byte(Name[0])) and
           (UTF8Compare(_PShortStr(@LMethEntry^.nameLen)^, Name)) then
        begin
          Result := LMethEntry.methAddr;
          Exit;
        end else
        begin
          Dec(LMethCount);
          LMethEntry := Pointer(PByte(LMethEntry) + LMethEntry.recSize);
        end;
      end;
    end;

    { Go to the parent class }
    LSelf := LSelf.ClassParent;
    if LSelf = nil then
      Exit;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
        { ->    EAX     Pointer to class        }
        {       EDX     Pointer to name         }
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        { STACK ALIGN = 16 }
        XOR     ECX,ECX
        XOR     EDI,EDI
        MOV     BL,[EDX]
        JMP     @@haveVMT
@@outer:                                { upper 16 bits of ECX are 0 !  }
        MOV     EAX,[EAX]
@@haveVMT:
        MOV     ESI,[EAX].vmtMethodTable
        TEST    ESI,ESI
        JE      @@parent
        MOV     DI,[ESI]                { EDI := method count           }
        TEST    EDI,EDI
        JZ      @@parent
        ADD     ESI,2
@@inner:                                { upper 16 bits of ECX are 0 !  }
        MOV     CL,[ESI+6]              { compare length of strings     }
        CMP     CL,BL
        JE      @@cmpChar
@@cont:                                 { upper 16 bits of ECX are 0 !  }
        MOV     CX,[ESI]                { fetch length of method desc   }
        ADD     ESI,ECX                 { point ESI to next method      }
        DEC     EDI
        JNZ     @@inner
@@parent:
        MOV     EAX,[EAX].vmtParent     { fetch parent vmt              }
        TEST    EAX,EAX
        JNE     @@outer
        JMP     @@exit                  { return NIL                    }

@@notEqual:
        MOV     BL,[EDX]                { restore BL to length of name  }
        JMP     @@cont

@@utf8Cmp:
        { STACK ALIGN = 16 }
        PUSH    EAX
        PUSH    EDX
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF}
        LEA     EAX,[ESI+6]
        CALL    UTF8Compare
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF}
        XOR     ECX,ECX
        TEST    AL,AL
        POP     EDX
        POP     EAX
        JZ      @@notEqual
        JMP     @@foundIt

@@cmpChar:                              { upper 16 bits of ECX are 0 !  }
        MOV     CH,0                    { upper 24 bits of ECX are 0 !  }
@@cmpCharLoop:
        MOV     BL,[ESI+ECX+6]          { case insensitive string cmp   }
        TEST    BL,$80
        JNZ     @@utf8Cmp
        XOR     BL,[EDX+ECX+0]          { last char is compared first   }
        TEST    BL,$80
        JNZ     @@utf8Cmp
        AND     BL,$DF
        JNE     @@notEqual
        DEC     ECX                     { ECX serves as counter         }
        JNZ     @@cmpCharLoop

@@foundIt:
        { found it }
        MOV     EAX,[ESI+2]

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function UTF8ShortStringToString(const Str: _ShortStr): string;
begin
  Result := UTF8ToString(Str);
end;

class function TObject.MethodAddress(const Name: string): Pointer;
begin
  Result := MethodAddress(UTF8EncodeToShortString(Name));
end;

class function TObject.MethodName(Address: Pointer): string;
{$IFDEF PUREPASCAL}
var
  LMethTablePtr: Pointer;
  LMethCount: Word;
  LMethEntry: PMethRec;
  LSelf: TClass;
begin
  Result := '';

  LSelf := Pointer(Self);
  while True do
  begin
    { Obtain the method table and count }
    LMethTablePtr := PPointer(PByte(LSelf) + vmtMethodTable)^;
    if LMethTablePtr <> nil then
    begin
      LMethCount := PWord(LMethTablePtr)^;
      Inc(PWord(LMethTablePtr), 1);
    end else
      LMethCount := 0;

    { Search for the method if we have more than one. Also tested for a correct table ptr }
    if LMethCount > 0 then
    begin
      LMethEntry := LMethTablePtr;

      while LMethCount > 0 do
      begin
        if LMethEntry^.methAddr = Address then
        begin
          Result := UTF8ShortStringToString(_PShortStr(@LMethEntry.nameLen)^);
          Exit;
        end else
        begin
          Dec(LMethCount);
          LMethEntry := Pointer(PByte(LMethEntry) + LMethEntry.recSize);
        end;
      end;
    end;

    { Go to the parent class }
    LSelf := LSelf.ClassParent;
    if LSelf = nil then
      Exit;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm     //StackAlignSafe
        { ->    EAX     Pointer to class        }
        {       EDX     Address                 }
        {       ECX     Pointer to result       }
        PUSH    ESI
        PUSH    EDI
        PUSH    EBX
        MOV     EDI,ECX
        XOR     EBX,EBX
        XOR     ECX,ECX
        JMP     @@haveVMT
@@outer:
        MOV     EAX,[EAX]
@@haveVMT:
        MOV     ESI,[EAX].vmtMethodTable { fetch pointer to method table }
        TEST    ESI,ESI
        JE      @@parent
        MOV     CX,[ESI]
        TEST    ECX,ECX
        JZ      @@parent
        ADD     ESI,2
@@inner:
        CMP     EDX,[ESI+2]
        JE      @@found
        MOV     BX,[ESI]
        ADD     ESI,EBX
        DEC     ECX
        JNZ     @@inner
@@parent:
        MOV     EAX,[EAX].vmtParent
        TEST    EAX,EAX
        JNE     @@outer
        LEA     ESI,@@emptyStr
{$IFDEF PIC}
        CALL    GetGOT
        ADD     ESI, EAX
{$ENDIF PIC}
        JMP     @@exit

@@emptyStr:
        DB      0

@@found:
        ADD     ESI,6
@@exit:
        MOV     EAX,ESI
        MOV     EDX,EDI
        POP     EBX
        POP     EDI
        POP     ESI
        JMP     UTF8ShortStringToString
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function TObject.FieldAddress(const Name: _ShortStr): Pointer;
{$IFDEF PUREPASCAL}
type
  PUInt32 = ^UInt32;
var
  LFieldTablePtr: Pointer;
  LFldCount: Word;
  LName: _PShortStr;
  LClass: TClass;
begin
  Result := nil;

  LClass := PPointer(Self)^;
  while True do
  begin
    { Obtain the field table and count }
    LFieldTablePtr := PPointer(PByte(LClass) + vmtFieldTable)^;
    if LFieldTablePtr <> nil then
    begin
      LFldCount := PWord(LFieldTablePtr)^;
      Inc(PWord(LFieldTablePtr), 1);  { Count: Word }
      Inc(PPointer(LFieldTablePtr), 1); { ClassTab: Pointer }
    end else
      LFldCount := 0;

    { Search for the field if we have more than one. Also tested for a correct table ptr }
    if LFldCount > 0 then
    begin
      while LFldCount > 0 do
      begin
        LName := _PShortStr(PByte(LFieldTablePtr) + SizeOf(Word) + SizeOf(UInt32));

        if (LName^[0] = Name[0]) and
           (UTF8Compare(LName^, Name)) then
        begin
          Result := Pointer(PByte(Self) + PUInt32(LFieldTablePtr)^);
          Exit;
        end else
        begin
          Dec(LFldCount);
          { Skip 1 word, 1 Pointer, the length of the name (1 Byte) and the characters of the name }
          Inc(PByte(LFieldTablePtr), SizeOf(Word) + SizeOf(UInt32) + Byte(LName^[0]) + 1);
        end;
      end;
    end;

    { Go to the parent class }
    LClass := LClass.ClassParent;
    if LClass = nil then
      Exit;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to instance     }
        {       EDX     Pointer to name         }
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        XOR     ECX,ECX
        XOR     EDI,EDI
        MOV     BL,[EDX]
        PUSH    EAX                     { save instance pointer         }

@@outer:
        MOV     EAX,[EAX]               { fetch class pointer           }
        MOV     ESI,[EAX].vmtFieldTable
        TEST    ESI,ESI
        JE      @@parent
        MOV     DI,[ESI]                { fetch count of fields         }
        TEST    EDI,EDI
        JZ      @@parent                { fieldExTab ref only           }
        ADD     ESI,6                   { count:U2 + classTab:P         }
@@inner:
        MOV     CL,[ESI+6]              { compare string lengths        }
        CMP     CL,BL
        JE      @@cmpChar
@@cont:
        LEA     ESI,[ESI+ECX+7]         { point ESI to next field       }
        DEC     EDI
        JNZ     @@inner
@@parent:
        MOV     EAX,[EAX].vmtParent     { fetch parent VMT              }
        TEST    EAX,EAX
        JNE     @@outer
        POP     EDX                     { forget instance, return Nil   }
        JMP     @@exit

@@notEqual:
        MOV     BL,[EDX]                { restore BL to length of name  }
        MOV     CL,[ESI+6]              { ECX := length of field name   }
        JMP     @@cont

@@utf8Cmp:
        PUSH    EAX
        PUSH    EDX
        LEA     EAX,[ESI+6]
        CALL    UTF8Compare
        XOR     ECX,ECX
        TEST    AL,AL
        POP     EDX
        POP     EAX
        JZ      @@notEqual
        JMP     @@foundIt

@@cmpChar:
        MOV     BL,[ESI+ECX+6]         { case insensitive string cmp    }
        TEST    BL,$80
        JNZ     @@utf8Cmp
        XOR     BL,[EDX+ECX+0]         { starting with last char        }
        TEST    BL,$80
        JNZ     @@utf8Cmp
        AND     BL,$DF
        JNE     @@notEqual
        DEC     ECX                     { ECX serves as counter         }
        JNZ     @@cmpChar

@@foundIt:
        { found it }
        MOV     EAX,[ESI]               { result is field offset plus ...   }
        POP     EDX
        ADD     EAX,EDX                 { instance pointer              }

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX

end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function TObject.FieldAddress(const Name: string): Pointer;
begin
  Result := FieldAddress(UTF8EncodeToShortString(Name));
end;

function _ClassCreate(InstanceOrVMT: Pointer; Alloc: ShortInt): Pointer;
{$IF defined(PUREPASCAL)}
begin
  if Alloc >= 0 then
    InstanceOrVMT := Pointer(TClass(InstanceOrVMT).NewInstance);
  Result := TObject(InstanceOrVMT);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX = pointer to VMT      }
        { <-    EAX = pointer to instance }
        PUSH    EDX
        PUSH    ECX
        PUSH    EBX
        TEST    DL,DL
        JL      @@noAlloc
        CALL    DWORD PTR [EAX] + VMTOFFSET TObject.NewInstance
@@noAlloc:
{$IFDEF STACK_BASED_EXCEPTIONS}
        XOR     EDX,EDX
        LEA     ECX,[ESP+16]
        MOV     EBX,FS:[EDX]
        MOV     [ECX].TExcFrame.next,EBX
        MOV     [ECX].TExcFrame.hEBP,EBP
        MOV     [ECX].TExcFrame.desc,offset @desc
        MOV     [ECX].TexcFrame.ConstructedObject,EAX   { trick: remember copy to instance }
        MOV     FS:[EDX],ECX
{$ENDIF STACK_BASED_EXCEPTIONS}
        POP     EBX
        POP     ECX
        POP     EDX
        RET

{$IFDEF STACK_BASED_EXCEPTIONS}
@desc:
        JMP     _HandleAnyException

  {       destroy the object                                                      }

        MOV     EAX,[ESP+8+9*4]
        MOV     EAX,[EAX].TExcFrame.ConstructedObject
        TEST    EAX,EAX
        JE      @@skip
        MOV     ECX,[EAX]
        MOV     DL,$81
        PUSH    EAX
        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.Destroy
        POP     EAX
        CALL    _ClassDestroy
@@skip:
  {       reraise the exception   }
        CALL    _RaiseAgain
{$ENDIF STACK_BASED_EXCEPTIONS}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _ClassDestroy(const Instance: TObject);
begin
  Instance.FreeInstance;
end;

function _AfterConstruction(const Instance: TObject): TObject;
begin
  try
    Instance.AfterConstruction;
    Result := Instance;
{$IFDEF AUTOREFCOUNT}
    AtomicDecrement(Instance.FRefCount);
{$ENDIF}
  except
    _BeforeDestruction(Instance, 1);
    raise;
  end;
end;

{$IF not defined(X86ASMRTL)}
procedure _BeforeDestruction(const Instance: TObject; OuterMost: ShortInt);
begin
  if OuterMost > 0 then
    Instance.BeforeDestruction;
end;
{$ELSE !X86ASMRTL}
function _BeforeDestruction(const Instance: TObject; OuterMost: ShortInt): TObject;
// Must preserve DL on return!
asm //StackAlignSafe
       { ->  EAX  = pointer to instance }
       {      DL  = dealloc flag        }
       { <-  EAX  = pointer to instance }  //  Result := Instance;
        TEST    DL,DL
        JG      @@outerMost                //  if OuterMost > 0 then Exit;
        RET
@@outerMost:
{$IFDEF ALIGN_STACK}
        PUSH    ECX     // 4 byte adjustment, and ECX is convenient
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        MOV     EDX,[EAX]                  //  Instance.BeforeDestruction;
        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.BeforeDestruction
        POP     EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        POP     ECX     // 4 byte adjustment, and ECX is convenient
{$ENDIF ALIGN_STACK}
end;
{$ENDIF X86ASMRTL}

{ TMonitor }

{$IFDEF POSIX}
procedure Sleep(Timeout: Integer); inline;
begin
  usleep(Timeout * 1000);
end;

function GetTickCount: Cardinal; inline;
{$IFDEF ANDROID}
var
  res: timespec;
begin
  clock_gettime(CLOCK_MONOTONIC, @res);
  Result := (Int64(1000000000) * res.tv_sec + res.tv_nsec) div 1000000;
end;
{$ELSEIF defined(LINUX)}
var
  t: tms;
begin
  Result := Cardinal(Int64(Cardinal(times(t)) * 1000) div sysconf(_SC_CLK_TCK));
end;
{$ELSEIF defined(MACOS)}
begin
  Result := AbsoluteToNanoseconds(MachAbsoluteTime) div 1000000;
end;
{$ELSE}
begin
  Error(rePlatformNotImplemented);
{$MESSAGE ERROR 'Unknown Platform'}
end;
{$ENDIF}

{$ENDIF POSIX}

{ TMonitor.TSpinWait }

procedure TMonitor.TSpinWait.Reset;
begin
  FCount := 0;
end;

procedure TMonitor.TSpinWait.SpinCycle;
var
  SpinCount: Integer;
begin
  if (FCount > YieldThreshold) or (CPUCount <= 1) then
  begin
    if FCount >= YieldThreshold then
      SpinCount := FCount - 10
    else
      SpinCount := FCount;
    if SpinCount mod Sleep1Threshold = Sleep1Threshold - 1 then
      Sleep(1)
    else if SpinCount mod Sleep0Threshold = Sleep0Threshold - 1 then
      Sleep(0)
    else
      Yield;
  end else
    Spin(4 shl FCount);
  Inc(FCount);
  if FCount < 0 then
    FCount := 10;
end;

{ TMonitor.TSpinLock }

procedure TMonitor.TSpinLock.Enter;
var
  LLock: Integer;
  Wait: TSpinWait;
begin
  Wait.Reset;
  while True do
  begin
    LLock := FLock;
    if LLock = 0 then
    begin
      if AtomicCmpExchange(FLock, 1, LLock) = LLock then
        System.Exit;
    end;
    Wait.SpinCycle;
  end;
end;

procedure TMonitor.TSpinLock.Exit;
begin
  AtomicExchange(FLock, 0);
end;

class procedure TMonitor.Spin(Iterations: Integer);
{$IF (defined(CPUX86) or defined(CPUX64)) and defined(ASSEMBLER)}
asm
    CMP  Iterations, 0
    JNG  @Done
@Loop:
    PAUSE
    DEC  Iterations
    CMP  Iterations, 0
    JG   @LOOP
@Done:
end;
{$ELSE}
begin
  while Iterations > 0 do
  begin
    YieldProcessor;
    Dec(Iterations);
  end;
end;
{$ENDIF}

class function TMonitor.GetCacheLineSize: Integer;
{$IFDEF MSWINDOWS}
{$POINTERMATH ON}
var
  ProcInfo, CurInfo: PSystemLogicalProcessorInformation;
  Len: DWORD;
begin
  Len := 0;
  if (GetProcAddress(GetModuleHandle(kernel), 'GetLogicalProcessorInformation') <> nil) and
    not GetLogicalProcessorInformation(nil, Len) and (GetLastError = ERROR_INSUFFICIENT_BUFFER) then
  begin
    GetMem(ProcInfo, Len);
    try
      GetLogicalProcessorInformation(ProcInfo, Len);
      CurInfo := ProcInfo;
      while Len > 0 do
      begin
        if (CurInfo.Relationship = RelationCache) and (CurInfo.Cache.Level = 1) then
          System.Exit(CurInfo.Cache.LineSize);
        Inc(CurInfo);
        Dec(Len, SizeOf(CurInfo^));
      end;
    finally
      FreeMem(ProcInfo);
    end;
  end;
  Result := 64; // Use a reasonable default cache line size.
end;
{$POINTERMATH OFF}
{$ELSEIF defined(ANDROID)}
begin
  Result := 64;
end;
{$ELSEIF defined(MACOS)}
var
  LineSize: UInt64;
  Size: Integer;
begin
  Size := SizeOf(LineSize);
  if sysctlbyname('hw.cachelinesize', @LineSize, @Size, nil, 0) = 0 then
    Result := LineSize
  else
    Result := 64;
end;
{$ELSEIF defined(POSIX)}
                                                       
begin
  Result := 64;
end;
{$ELSE}
{$MESSAGE ERROR 'Unknown Platform'}
{$ENDIF}

class procedure TMonitor.CheckMonitorSupport;
begin
  if MonitorSupport = nil then
    Error(reNoMonitorSupport);
end;

function TMonitor.CheckOwningThread: TThreadID;
begin
  Result := FOwningThread;
  if Result <> GetCurrentThreadId then
    Error(reMonitorNotLocked)
end;

class function TMonitor.Create: PMonitor;
begin
  if CacheLineSize = 0 then
    AtomicExchange(CacheLineSize, GetCacheLineSize);
  if (CPUCount > 1) and (FDefaultSpinCount = 0) then
    AtomicExchange(FDefaultSpinCount, 1000);
  if CacheLineSize > SizeOf(Result^) then
    Result := AllocMem(CacheLineSize)
  else
    Result := AllocMem(SizeOf(Result^));
  Result.FSpinCount := FDefaultSpinCount;
end;

class procedure TMonitor.Destroy(const AObject: TObject);
var
  MonitorFld: PPMonitor;
  Monitor: PMonitor;
begin
  MonitorFld := GetFieldAddress(AObject);
  if MonitorFld^ <> nil then
  begin
    Monitor := MonitorFld^;
    MonitorFld^ := nil;
    Monitor.Destroy;
  end;
end;

procedure TMonitor.Destroy;
begin
  if (MonitorSupport <> nil) and (FLockEvent <> nil) then
    MonitorSupport.FreeSyncObject(FLockEvent);
  FreeMem(@Self);
end;

class procedure TMonitor.Enter(const AObject: TObject);
begin
  CheckMonitorSupport;
  GetMonitor(AObject).Enter(INFINITE);
end;

class function TMonitor.Enter(const AObject: TObject; Timeout: Cardinal): Boolean;
begin
  CheckMonitorSupport;
  Result := GetMonitor(AObject).Enter(Timeout);
end;

function TMonitor.DequeueWaiter: PWaitingThread;
begin
  FQueueLock.Enter;
  try
    Result := FWaitQueue;
    if (Result = nil) or (Result.Next = Result) then
    begin
      FWaitQueue := nil;
      System.Exit;
    end else
    begin
      Result := FWaitQueue.Next;
      FWaitQueue.Next := FWaitQueue.Next.Next;
    end;
  finally
    FQueueLock.Exit;
  end;
end;

function TMonitor.Enter(Timeout: Cardinal): Boolean;
label
  TryAgain;
var
  Done: Boolean;
  LockCount: Integer;
  StartCount, EndCount: Cardinal;
  SpinCount: Integer;
  SpinWait: TSpinWait;
begin
  SpinCount := FSpinCount;
// Return here if signaled and lock wasn't acquired
TryAgain:
  Result := TryEnter;
  if not Result and (Timeout <> 0) then
  begin
    Done := False;
    // Get the spin count
    if SpinCount > 0 then
    begin
      StartCount := GetTickCount;
      SpinWait.Reset;
      while SpinCount > 0 do
      begin
        if (Timeout <> INFINITE) and ((GetTickCount - StartCount) >= Timeout) then
        begin
          Result := False;
          System.Exit;
        end;
        // if there are already waiters, don't bother spinning
        if FLockCount > 1 then
          Break;
        // Try to get the lock
        if FLockCount = 0 then
          if AtomicCmpExchange(FLockCount, 1, 0) = 0 then
          begin
            FOwningThread := GetCurrentThreadId;
            FRecursionCount := 1;
            Result := True;
            System.Exit;
          end;
        SpinWait.SpinCycle;
        Dec(SpinCount);
        // Keep trying until the spin count expires
      end;
      // Adjust the timeout in case the spin-lock expired above.
      if Timeout <> INFINITE then
      begin
        EndCount := GetTickCount;
        if EndCount - StartCount >= Timeout then
        begin
          Result := False;
          System.Exit;
        end;
        Dec(Timeout, EndCount - StartCount);
      end;
    end;
    // Before we can block, we add our count to the lock
    while True do
    begin
      LockCount := FLockCount;
      if LockCount = 0 then
        goto TryAgain;
      if AtomicCmpExchange(FLockCount, LockCount + 2, LockCount) = LockCount then
        Break;
    end;
    while True do
    begin
      StartCount := GetTickCount;
      // We're not the owner, so blocking is needed
      // GetEvent does a "safe" allocation of the Event
      Result := MonitorSupport.WaitOrSignalObject(nil, GetEvent, Timeout) = WAIT_OBJECT_0;
      if Timeout <> INFINITE then
      begin
        EndCount := GetTickCount;
        if EndCount - StartCount < Timeout then
          Dec(Timeout, EndCount - StartCount)
        else
          Timeout := 0;
      end;
      if Result then
      begin
        // Event was signaled, so try to acquire the lock since this could be a spurious condition
        while True do
        begin
          LockCount := FLockCount;
          if LockCount and 1 <> 0 then
            Break;
          if AtomicCmpExchange(FLockCount, (LockCount - 2) or 1, LockCount) = LockCount then
          begin
            Done := True;
            Break;
          end;
        end;
      end else
      begin
        // We timed out, remove our presence from the lock count
        repeat
          LockCount := FLockCount;
        until AtomicCmpExchange(FLockCount, LockCount - 2, LockCount) = LockCount;
        Done := True;
      end;
      if Done then
        Break;
    end;
    if Result then
    begin
      FOwningThread := GetCurrentThreadId;
      FRecursionCount := 1;
    end;
  end;
end;

procedure TMonitor.Exit;
var
  LockCount: Integer;
begin
  CheckOwningThread;
  Dec(FRecursionCount);
  if FRecursionCount = 0 then
  begin
    FOwningThread := 0;
    while True do
    begin
      LockCount := FLockCount;
      if AtomicCmpExchange(FLockCount, LockCount - 1, LockCount) = LockCount then
      begin
        // if LockCount is <> 0 after we dropped our lock, there were waiters, so signal them
        if LockCount and not 1 <> 0 then
          MonitorSupport.WaitOrSignalObject(GetEvent, nil, 0);
        Break;
      end;
    end;
  end;
end;

class procedure TMonitor.Exit(const AObject: TObject);
begin
  CheckMonitorSupport;
  GetMonitor(AObject).Exit;
end;

function TMonitor.GetEvent: Pointer;
var
  SleepTime: Integer;
  Event: Pointer;
begin
  SleepTime := 1;
  Result := FLockEvent;
  if Result = nil then
    while True do
    begin
      Event := MonitorSupport.NewSyncObject;
      Result := AtomicCmpExchange(FLockEvent, Event, nil);
      if Result = nil then
        // We won!  Nobody else was trying to allocate the Event.
        Result := Event
      else if Event <> nil then
        // Oh Well. We tried. Close the handle if someone got to it first.
        MonitorSupport.FreeSyncObject(Event);
      // Check if we actually were able to allocate the event without fail
      if Result <> nil then
        System.Exit;
      // We failed to allocate the event, so wait a bit to see if one becomes available
      Sleep(SleepTime);
      // Don't let it run-away, so return to a reasonable value and keep trying
      if SleepTime > 512 then
        SleepTime := 1
      else
        // Next time wait a little longer
        SleepTime := SleepTime shl 1;
    end;
end;

class function TMonitor.GetFieldAddress(const AObject: TObject): PPMonitor;
begin
  Result := PPMonitor(PByte(AObject) + AObject.InstanceSize - hfFieldSize + hfMonitorOffset);
end;

class function TMonitor.GetMonitor(const AObject: TObject): PMonitor;
var
  MonitorFld: PPMonitor;
  Monitor: PMonitor;
begin
  MonitorFld := GetFieldAddress(AObject);
  Result := MonitorFld^;
  if Result = nil then
  begin
    Monitor := TMonitor.Create;
    Result := AtomicCmpExchange(Pointer(MonitorFld^), Monitor, nil);
    if Result = nil then
      Result := Monitor
    else
      FreeMem(Monitor);
  end;
end;

procedure TMonitor.Pulse;
var
  WaitingThread: PWaitingThread;
begin
  WaitingThread := DequeueWaiter;
  if WaitingThread <> nil then
    MonitorSupport.WaitOrSignalObject(WaitingThread.WaitEvent, nil, 0);
end;

class procedure TMonitor.Pulse(const AObject: TObject);
begin
  CheckMonitorSupport;
  GetMonitor(AObject).Pulse;
end;

procedure TMonitor.PulseAll;
var
  WaitingThread: PWaitingThread;
begin
  WaitingThread := DequeueWaiter;
  while WaitingThread <> nil do
  begin
    MonitorSupport.WaitOrSignalObject(WaitingThread.WaitEvent, nil, 0);
    WaitingThread := DequeueWaiter;
  end;
end;

class procedure TMonitor.PulseAll(const AObject: TObject);
begin
  CheckMonitorSupport;
  GetMonitor(AObject).PulseAll;
end;

procedure TMonitor.QueueWaiter(var WaitingThread: TWaitingThread);
begin
  FQueueLock.Enter;
  try
    if FWaitQueue = nil then
    begin
      FWaitQueue := @WaitingThread;
      WaitingThread.Next := @WaitingThread;
    end else
    begin
      WaitingThread.Next := FWaitQueue.Next;
      FWaitQueue.Next := @WaitingThread;
      FWaitQueue := @WaitingThread;
    end;
  finally
    FQueueLock.Exit;
  end;
end;

procedure TMonitor.RemoveWaiter(var WaitingThread: TWaitingThread);
var
  Last, Walker: PWaitingThread;
begin
  // Perform a check, lock, check
  if FWaitQueue <> nil then
  begin
    FQueueLock.Enter;
    try
      if FWaitQueue <> nil then
      begin
        Last := FWaitQueue;
        Walker := Last.Next;
        while Walker <> FWaitQueue do
        begin
          if Walker = @WaitingThread then
          begin
            Last.Next := Walker.Next;
            Break;
          end;
          Last := Walker;
          Walker := Walker.Next;
        end;
        if (Walker = FWaitQueue) and (Walker = @WaitingThread) then
          if Walker.Next = Walker then
            FWaitQueue := nil
          else
          begin
            FWaitQueue := Walker.Next;
            Last.Next := FWaitQueue;
          end;
      end;
    finally
      FQueueLock.Exit;
    end;
  end;
end;

class procedure TMonitor.SetDefaultSpinCount(AValue: Integer);
begin
  AtomicExchange(FDefaultSpinCount, AValue);
end;

class procedure TMonitor.SetSpinCount(const AObject: TObject; ASpinCount: Integer);
var
  Monitor: PMonitor;
begin
  if CPUCount > 1 then
  begin
    Monitor := GetMonitor(AObject);
    AtomicExchange(Monitor.FSpinCount, ASpinCount);
  end;
end;

class function TMonitor.TryEnter(const AObject: TObject): Boolean;
begin
  CheckMonitorSupport;
  Result := GetMonitor(AObject).TryEnter;
end;

function TMonitor.TryEnter: Boolean;
begin
  if FOwningThread = GetCurrentThreadId then  // check for recursion
  begin
    // Only the owning thread can increment this value so no need to guard it
    Inc(FRecursionCount);
    Result := True;
  // check to see if we can gain ownership
  end else if (FLockCount = 0) and (AtomicCmpExchange(FLockCount, 1, 0) = 0) then
  begin
    //  Yep, got it.  Now claim ownership
    FOwningThread := GetCurrentThreadId;
    FRecursionCount := 1;
    Result := True;
  end else
    Result := False;
end;

function TMonitor.Wait(ALock: PMonitor; Timeout: Cardinal): Boolean;
var
  RecursionCount: Integer;
  WaitingThread: TWaitingThread;
begin
  WaitingThread.Next := nil;
  WaitingThread.Thread := ALock.CheckOwningThread;
  // This event should probably be cached someplace.
  // Probably not on the instance since this is a per-thread-per-instance resource
  WaitingThread.WaitEvent := MonitorSupport.NewWaitObject;
  try
    // Save the current recursion count for later
    RecursionCount := ALock.FRecursionCount;
    // Add the current thread to the waiting queue
    QueueWaiter(WaitingThread);
    // Set it back to almost released so the next Exit call actually drops the lock
    ALock.FRecursionCount := 1;
    // Now complete the exit and signal any waiters
    ALock.Exit;
    // Get in line for someone to do a Pulse or PulseAll
    Result := MonitorSupport.WaitOrSignalObject(nil, WaitingThread.WaitEvent, Timeout) = WAIT_OBJECT_0;
    // Got to get the lock back and block waiting for it.
    ALock.Enter(INFINITE);
    // Remove any dangling waiters from the list
    RemoveWaiter(WaitingThread);
    // Lets restore the recursion to return to the proper nesting level
    ALock.FRecursionCount := RecursionCount;
  finally
    MonitorSupport.FreeWaitObject(WaitingThread.WaitEvent);
  end;
end;

class function TMonitor.Wait(const AObject: TObject; Timeout: Cardinal): Boolean;
var
  Monitor: PMonitor;
begin
  CheckMonitorSupport;
  Monitor := GetMonitor(AObject);
  Result := Monitor.Wait(Monitor, Timeout);
end;

class function TMonitor.Wait(const AObject, ALock: TObject; Timeout: Cardinal): Boolean;
begin
  CheckMonitorSupport;
  Result := GetMonitor(AObject).Wait(GetMonitor(ALock), Timeout);
end;

function MonitorEnter(const AObject: TObject; Timeout: Cardinal = INFINITE): Boolean;
begin
  Result := TMonitor.Enter(AObject, Timeout);
end;

function MonitorTryEnter(const AObject: TObject): Boolean;
begin
  Result := TMonitor.TryEnter(AObject);
end;

procedure MonitorExit(const AObject: TObject);
begin
  TMonitor.Exit(AObject);
end;

function MonitorWait(const AObject: TObject; Timeout: Cardinal): Boolean;
begin
  Result := TMonitor.Wait(AObject, AObject, Timeout);
end;

function MonitorWait(const AObject: TObject; const ALock: TObject; Timeout: Cardinal): Boolean;
begin
  Result := TMonitor.Wait(AObject, ALock, Timeout);
end;

procedure MonitorPulse(const AObject: TObject);
begin
  TMonitor.Pulse(AObject);
end;

procedure MonitorPulseAll(const AObject: TObject);
begin
  TMonitor.PulseAll(AObject);
end;

// Note: MemoryBarrier is now standard procedure.
                                                             
(*
procedure MemoryBarrier;
{$IF defined(CPUX64)}
asm
      MFENCE
end;
{$ELSEIF defined(CPUX86)}
asm
      PUSH EAX
      XCHG [ESP],EAX
      POP  EAX
end;
{$ELSE}
begin
  Error(rePlatformNotImplemented);
end;
{$ENDIF}
*)

                                                              
procedure YieldProcessor;
{$IF (defined(CPUX86) or defined(CPUX64)) and defined(ASSEMBLER)}
asm
  PAUSE
end;
{$ELSE}
begin
end;
{$ENDIF}

{
  The following NotifyXXXX routines are used to "raise" special exceptions
  as a signaling mechanism to an interested debugger.  If the debugger sets
  the DebugHook flag to 1 or 2, then all exception processing is tracked by
  raising these special exceptions.  The debugger *MUST* respond to the
  debug event with DBG_CONTINUE so that normal processing will occur.
}
{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
const
  excRaise      = 0; { an exception is being raised by the user (could be a reraise) }
  excCatch      = 1; { an exception is about to be caught }
  excFinally    = 2; { a finally block is about to be executed because of an exception }
  excUnhandled  = 3; { no user exception handler was found (the app will die) }

procedure _DbgExcNotify(
  NotificationKind: Integer;
  ExceptionObject: Pointer;
  ExceptionName: _PShortStr;
  ExceptionLocation: Pointer;
  HandlerAddr: Pointer); cdecl;
begin
{$IF Defined(DEBUG) and Defined(ASSEMBLER)}
  {
    This code is just for debugging the exception handling system.  The debugger
    needs _DbgExcNotify, however to place breakpoints in, so the function itself
    cannot be removed.
  }
  asm
{$IFDEF ALIGN_STACK}
    SUB  ESP, 8
{$ENDIF ALIGN_STACK}
    PUSH EAX
    PUSH EDX
  end;
  if Assigned(ExcNotificationProc) then
    ExcNotificationProc(NotificationKind, ExceptionObject, ExceptionName, ExceptionLocation, HandlerAddr);
  asm
    POP EDX
    POP EAX
{$IFDEF ALIGN_STACK}
    ADD  ESP, 8
{$ENDIF ALIGN_STACK}
  end;
{$ENDIF DEBUG}
end;

{
  The following functions are used by the debugger for the evaluator.  If you
  change them IN ANY WAY, the debugger will cease to function correctly.
}
procedure _DbgEvalMarker;
begin
end;

procedure _DbgEvalExcept(E: TObject);
begin
end;

procedure _DbgEvalEnd;
begin
end;

{
  This function is used by the debugger to provide a soft landing spot
  when evaluating a function call that may raise an unhandled exception.
  The return address of _DbgEvalMarker is pushed onto the stack so that
  the unwinder will transfer control to the except block.
}
procedure _DbgEvalFrame;
begin
  try
    _DbgEvalMarker;
  except on E: TObject do
    _DbgEvalExcept(E);
  end;
  _DbgEvalEnd;
end;

{
  These export names need to match the names that will be generated into
  the .symtab section, so that the debugger can find them if stabs
  debug information is being generated.
}
{$IF defined(ANDROID) or defined(LINUX)}    // We can not use mangles with @ in android
exports
  _DbgExcNotify   name  '_DbgExcNotify';
{$ELSE !(ANDROID or LINUX)}
exports
  _DbgExcNotify   name  '@DbgExcNotify';
{$ENDIF !(ANDROID or LINUX)}
{$ENDIF LINUX or MACOS or ANDROID}

{ tell the debugger that the next raise is a re-raise of the current non-Delphi
  exception }
                                                                 
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure       NotifyReRaise;
asm
{$IFDEF PC_MAPPED_EXCEPTIONS}
{     ->EAX     Pointer to exception object }
{       EDX     location of exception       }
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    0                   { handler addr }
        PUSH    EDX                 { location of exception }
        MOV     ECX, [EAX]
        PUSH    [ECX].vmtClassName  { exception name }
        PUSH    EAX                 { exception object }
        PUSH    excRaise            { notification kind }
        CALL    _DbgExcNotify
{$IFDEF ALIGN_STACK}
        ADD     ESP, 28
{$ELSE !ALIGN_STACK}
        ADD     ESP, 20
{$ENDIF ALIGN_STACK}
{$ELSE !PC_MAPPED_EXCEPTIONS}
        CMP     BYTE PTR DebugHook,1
        JBE     @@1
        PUSH    0
        PUSH    0
        PUSH    cContinuable
        PUSH    cDelphiReRaise
        CALL    RaiseExceptionProc
@@1:
{$ENDIF !PC_MAPPED_EXCEPTIONS}
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$IF defined(TABLE_BASED_EXCEPTIONS)}
procedure NotifyReRaise(Obj: TObject; Address: Pointer);
begin
{$IFDEF MSWINDOWS}
  if DebugHook > 1 then
    RaiseExceptionProc(cDelphiReRaise, cContinuable, 0, nil);
{$ENDIF MSWINDOWS}
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$IF defined(SJLJ_BASED_EXCEPTIONS) or defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
procedure NotifyReRaise(const Obj: TObject; Address: Pointer);
begin
  _DbgExcNotify(excRaise, Obj,
     _PShortStr(PPointer(PNativeInt(Obj)^ + vmtClassName)^),
     Address, nil);
end;
{$ENDIF SJLJ_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}

{ tell the debugger about the raise of a non-Delphi exception }
{$IFDEF MSWINDOWS}
                                                                            
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure       NotifyNonDelphiException;
asm
{     ->EAX     Pointer to exception object }
{       EDX     Context record              }
        CMP     BYTE PTR DebugHook,0
        JE      @@1
        PUSH    EAX
        PUSH    EAX
        PUSH    EDX
        PUSH    ESP
        PUSH    2
        PUSH    cContinuable
        PUSH    cNonDelphiException
        CALL    RaiseExceptionProc
        ADD     ESP,8
        POP     EAX
@@1:
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure NotifyNonDelphiException(ExceptionObject: Pointer; ContextRecord: PContext);
var
  Params: array[0..1] of Pointer;
begin
  if DebugHook <> 0 then
  begin
    Params[0] := ContextRecord;
    Params[1] := ExceptionObject;
    RaiseExceptionProc(cNonDelphiException, cContinuable, 2, @Params);
  end;
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$ENDIF MSWINDOWS}

{ Tell the debugger where the handler for the current exception is located }
                                                                
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure NotifyExcept;
asm
{$IFDEF POSIX}
{     ->EAX     Pointer to exception object }
{       EDX     handler addr                }
        PUSH    EAX
        MOV     EAX, [EAX].TRaisedException.ExceptObject

{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDX                 { handler addr }
        PUSH    0                   { location of exception }
        MOV     ECX, [EAX]
        PUSH    [ECX].vmtClassName  { exception name }
        PUSH    EAX                 { exception object }
        PUSH    excCatch            { notification kind }
        CALL    _DbgExcNotify
{$IFDEF ALIGN_STACK}
        ADD     ESP, 24
{$ELSE !ALIGN_STACK}
        ADD     ESP, 20
{$ENDIF ALIGN_STACK}

        POP     EAX
{$ELSE !POSIX}
        PUSH    ESP
        PUSH    1
        PUSH    cContinuable
        PUSH    cDelphiExcept           { our magic exception code }
        CALL    RaiseExceptionProc
        ADD     ESP,4
        POP     EAX
{$ENDIF !POSIX}
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure NotifyExcept(HandlerAddress: NativeUInt);
begin
  RaiseExceptionProc(cDelphiExcept, cContinuable, 1, @HandlerAddress);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}

                                                                  
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure NotifyOnExcept;
asm
{     ->EAX     Pointer to exception object }
{       EDX     handler addr                }
{$IFDEF PC_MAPPED_EXCEPTIONS}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EDX                 { handler addr }
        PUSH    0                   { location of exception }
        MOV     ECX, [EAX]
        PUSH    [ECX].vmtClassName  { exception name }
        PUSH    EAX                 { exception object }
        PUSH    excCatch            { notification kind }
        CALL    _DbgExcNotify
{$IFDEF ALIGN_STACK}
        ADD     ESP, 28
{$ELSE !ALIGN_STACK}
        ADD     ESP, 20
{$ENDIF ALIGN_STACK}
{$ELSE !PC_MAPPED_EXCEPTIONS}
{     ->EAX     Pointer to exception object             }
{       EBX     exception descriptor table entry        }
{       preserves EAX                                   }
        CMP     BYTE PTR DebugHook,1
        JBE     @@1
        PUSH    EAX
        PUSH    [EBX].TExcDescEntry.handler
        JMP     NotifyExcept
@@1:
{$ENDIF !PC_MAPPED_EXCEPTIONS}
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure NotifyOnExcept(HandlerAddress: NativeUInt);
begin
  if DebugHook > 1 then
    NotifyExcept(HandlerAddress);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IFDEF MSWINDOWS}
                                                                   
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure NotifyAnyExcept;
asm
        CMP     BYTE PTR DebugHook,1
        JBE     @@1
        PUSH    EAX
        PUSH    EBX
        JMP     NotifyExcept
@@1:
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure NotifyAnyExcept(HandlerAddress: NativeUInt);
begin
  if DebugHook > 1 then
    NotifyExcept(HandlerAddress);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$ENDIF}

                                                            
{$IFDEF MSWINDOWS}
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure       CheckJmp;
asm
        TEST    ECX,ECX
        JE      @@3
        MOV     EAX,[ECX + 1]
        CMP     BYTE PTR [ECX],0E9H { near jmp }
        JE      @@1
        CMP     BYTE PTR [ECX],0EBH { short jmp }
        JNE     @@3
        MOVSX   EAX,AL
        INC     ECX
        INC     ECX
        JMP     @@2
@@1:
        ADD     ECX,5
@@2:
        ADD     ECX,EAX
@@3:
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$ENDIF MSWINDOWS}

{ Notify debugger of a finally during an exception unwind }
                                                                       
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure NotifyExceptFinally;
asm
{     ->EAX     Pointer to exception object }
{       EDX     handler addr                }
{$IFDEF PC_MAPPED_EXCEPTIONS}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EDX                 { handler addr }
        PUSH    0                   { location of exception }
        PUSH    0                   { exception name }
        PUSH    0                   { exception object }
        PUSH    excFinally          { notification kind }
        CALL    _DbgExcNotify
{$IFDEF ALIGN_STACK}
        ADD     ESP, 28
{$ELSE !ALIGN_STACK}
        ADD     ESP, 20
{$ENDIF ALIGN_STACK}
{$ELSE !PC_MAPPED_EXCEPTIONS}
{     ->ECX     Pointer to exception object }
{       preserves: EAX, ECX and EDX.        }
        CMP     BYTE PTR DebugHook,1
        JBE     @@1
        PUSH    EAX
        PUSH    EDX
        PUSH    ECX
        CALL    CheckJmp
        PUSH    ECX
        PUSH    ESP                     { pass pointer to arguments }
        PUSH    1                       { there is 1 argument }
        PUSH    cContinuable            { continuable execution }
        PUSH    cDelphiFinally          { our magic exception code }
        CALL    RaiseExceptionProc
        POP     ECX
        POP     ECX
        POP     EDX
        POP     EAX
@@1:
{$ENDIF !PC_MAPPED_EXCEPTIONS}
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
                                                       
procedure NotifyExceptFinally(TargetIp: NativeUInt);
begin
  if DebugHook > 1 then
    RaiseExceptionProc(cDelphiFinally, cContinuable, 1, @TargetIp);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}


{ Tell the debugger that the current exception is handled and cleaned up.
  Also indicate where execution is about to resume. }
{$IFDEF MSWINDOWS}
                                                                   
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure       NotifyTerminate;
asm
        CMP     BYTE PTR DebugHook,1
        JBE     @@1
        PUSH    EDX
        PUSH    ESP
        PUSH    1
        PUSH    cContinuable
        PUSH    cDelphiTerminate        { our magic exception code }
        CALL    RaiseExceptionProc
        POP     EDX
@@1:
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure NotifyTerminate(TargetIp: NativeUInt);
begin
  if DebugHook > 1 then
    RaiseExceptionProc(cDelphiTerminate, cContinuable, 1, @TargetIp);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$ENDIF MSWINDOWS}

{ Tell the debugger that there was no handler found for the current exception
  and we are about to go to the default handler }
                                                                   
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure       NotifyUnhandled;
asm
{     ->EAX     Pointer to exception object }
{       EDX     location of exception       }
{$IFDEF MSWINDOWS}
        PUSH    EAX
        PUSH    EDX
        CMP     BYTE PTR DebugHook,1
        JBE     @@1
        PUSH    ESP
        PUSH    2
        PUSH    cContinuable
        PUSH    cDelphiUnhandled
        CALL    RaiseExceptionProc
@@1:
        POP     EDX
        POP     EAX
{$ELSE !MSWINDOWS}
        PUSH    EAX
        MOV     EAX, [EAX].TRaisedException.ExceptObject

{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    0                   { handler addr }
        PUSH    EDX                 { location of exception }
        MOV     ECX, [EAX]
        PUSH    [ECX].vmtClassName  { exception name }
        PUSH    EAX                 { exception object }
        PUSH    excUnhandled        { notification kind }
        CALL    _DbgExcNotify
{$IFDEF ALIGN_STACK}
        ADD     ESP, 24
{$ELSE !ALIGN_STACK}
        ADD     ESP, 20
{$ENDIF ALIGN_STACK}

        POP     EAX
{$ENDIF !MSWINDOWS}
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure NotifyUnhandled(ExceptObject, ExceptAddr: Pointer);
{$IFDEF MSWINDOWS}
var
  Params: array[0..1] of Pointer;
begin
  if DebugHook <> 0 then
  begin
    Params[0] := ExceptAddr;
    Params[1] := ExceptObject;
    RaiseExceptionProc(cDelphiUnhandled, cContinuable, 2, @Params);
  end;
end;
{$ELSE !MSWINDOWS}
var
  Obj: Pointer;
begin
  Obj := Pointer(TRaisedException(ExceptObject).ExceptObject);
  _DbgExcNotify(excUnhandled, Obj,
                _PShortStr(PPointer(PNativeInt(Obj)^ + vmtClassName)^),
                ExceptAddr, nil);
end;
{$ENDIF !MSWINDOWS}
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IF Defined(SJLJ_BASED_EXCEPTIONS) or defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
procedure NotifyUnhandled(ExceptObject, ExceptAddr: Pointer);
begin
end;
{$ENDIF}

{$IFDEF PC_MAPPED_EXCEPTIONS}
//  MaybeCooptException
//    If a Delphi exception is thrown from C++, a TRaisedException object
//    will not be allocated yet on this side.  We need to keep things sane,
//    so we have to intercept such exceptions from the C++ side, and convert
//    them so that they appear to have been thrown from this RTL.  If we
//    throw a Delphi exception, then we set the private_2 member of
//    _Unwind_Exception to 0.  If C++ throws it, it sets it to the address
//    of the throw point.  We use this to distinguish the two cases, and
//    adjust data structures as appropriate.  On entry to this function,
//    EDX is the private_2 member, as set from SysRaiseException, and
//    EAX is the exception object in question.
//
procedure MaybeCooptException;
asm
        // If this exception is from C++, then private_2 will be a
        // throw address.  If not, then it will be zero.  private_1
        // will be either the exception object itself, or a TRaisedException.
        OR      EDX, EDX            // From C++?
        JZ      @@ExcAllocated

        // We've decided that the exception is from C++, but it is a
        // Delphi exception object.  We will coopt the exception now
        // by installing a TRaisedException into the unwinder exception,
        // and setting private_2 to 0.  Then the exception will look
        // like it was truly thrown from this RTL.
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    AllocateException
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
@@ExcAllocated:
end;

function LinkException(Exc: PRaisedException): PRaisedException;
asm //StackAlignSafe
        PUSH    EDX     // preserve EDX because of HandleOnException
        PUSH    EAX
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        CALL    SysInit.@GetTLS
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
        POP     EDX
        MOV     ECX, [EAX].ExceptionList
        MOV     [EDX].TRaisedException.Prev, ECX
        MOV     [EAX].ExceptionList, EDX
        MOV     EAX, EDX
        POP     EDX
end;

function UnlinkException: PRaisedException;
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    SysInit.@GetTLS
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        MOV     EDX, [EAX].ExceptionList
        MOV     EDX, [EDX].TRaisedException.Prev
        MOV     [EAX].ExceptionList, EDX
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}

{$IFDEF TABLE_BASED_EXCEPTIONS}
const // for TExceptionRecord.ExceptionFlags
  EXCEPTION_NONCONTINUABLE  = $0001; // Noncontinuable exception
  EXCEPTION_UNWINDING       = $0002; // Unwind is in progress
  EXCEPTION_EXIT_UNWIND     = $0004; // Exit unwind is in progress
  EXCEPTION_STACK_INVALID   = $0008; // Stack out of limits or unaligned
  EXCEPTION_NESTED_CALL     = $0010; // Nested exception handler call
  EXCEPTION_TARGET_UNWIND   = $0020; // Execute termination handler for it
  EXCEPTION_COLLIDED_UNWIND = $0040; // unwind through unwind dispatcher
  EXCEPTION_UNWIND          = ( EXCEPTION_UNWINDING or
                                EXCEPTION_EXIT_UNWIND or
                                EXCEPTION_TARGET_UNWIND or
                                EXCEPTION_COLLIDED_UNWIND);

function FindOnExceptionDescEntry(DispatcherContext: PDispatcherContext;
  ExceptionClass: Pointer; ExcDesc: PExcDesc): PExcDescEntry;
var
  ExcDescEntry: PExcDescEntry;
  DescIndex: Integer;
  ClassPtr1, TabClassPtr: Pointer;
  Name1, Name2: _PAnsiChr;
begin
  for DescIndex := 0 to ExcDesc^.DescCount - 1 do
  begin
    ExcDescEntry := @ExcDesc.DescTable[DescIndex];
    Result := ExcDescEntry;
    if ExcDescEntry^.VTable = 0 then
      Exit;
    if ExceptionClass <> nil then
    begin
      ClassPtr1 := ExceptionClass;
      while True do
      begin
        TabClassPtr := PPointer(DispatcherContext.ImageBase + UIntPtr(ExcDescEntry^.VTable))^;
        if TabClassPtr = ClassPtr1 then
          Exit;
        if PInteger(PByte(TabClassPtr) + vmtInstanceSize)^ =
           PInteger(PByte(ClassPtr1) + vmtInstanceSize)^ then
        begin
          Name1 := PPAnsiChar(PByte(TabClassPtr) + vmtClassName)^;
          Name2 := PPAnsiChar(PByte(ClassPtr1) + vmtClassName)^;
          if (Name1^ = Name2^) and
             (_AStrCmp(_PAnsiChr(PByte(Name1) + 1),
                       _PAnsiChr(PByte(Name2) + 1), PByte(Name1)^) = 0) then
            Exit;
        end;
        ClassPtr1 := PPointer(PByte(ClassPtr1) + vmtParent)^;
        if ClassPtr1 = nil then
          Break;
        ClassPtr1 := PPointer(ClassPtr1)^;
      end;
    end;
  end;
  Result := nil;
end;

function _DelphiExceptionHandler(
  ExceptionRecord: PExceptionRecord;
  EstablisherFrame: NativeUInt;
  ContextRecord: _PContext;
  DispatcherContext: Pointer{PDispatcherContext}): LongInt{TExceptionDisposition};
var
  ImageBase: NativeUInt;
  ControlPcRVA: NativeUInt;
  ExceptionPointers: TExceptionPointers;
  ScopeIndex: Integer;
  TargetIpRVA: NativeUInt;
  ExceptionObject: Pointer;
  ExceptionClass: Pointer;
  ExceptionAddress: Pointer;
  ExcDescEntry: PExcDescEntry;
  ExcDesc: PExcDesc;
  ExcScope: PExcScope;
  ExcData: PExcData;
  TargetIp: NativeUInt;
  FilterRes: LongWord;
  JITCheckVal: Byte;
  LocalRaiseFrame: TRaiseFrame;
  PrevRaiseFramePtr: PRaiseFrame;
  ThisRaiseFramePtr: PRaiseFrame;
  RaiseFramePtr: PRaiseFrame;
begin
  Result := DISPOSITION_CONTINUE_SEARCH;
  ExcData := PExcData(PDispatcherContext(DispatcherContext).HandlerData);
  ImageBase := PDispatcherContext(DispatcherContext).ImageBase;
  ControlPcRVA := PDispatcherContext(DispatcherContext).ControlPc - ImageBase;
  if (ExceptionRecord.ExceptionFlags and EXCEPTION_UNWIND) = 0 then
  begin
    for ScopeIndex := 0 to ExcData^.ScopeCount - 1 do
    begin
      ExcScope := @ExcData^.ScopeTable[ScopeIndex];
      if (ControlPcRVA >= UIntPtr(ExcScope^.BeginOffset)) and
         (ControlPcRVA < UIntPtr(ExcScope^.EndOffset)) and
         (ExcScope^.TableOffset <> 0) then // safecall, catch_any or catch_table
      begin
        _FpuInit;
        ExcDescEntry := nil;
        if ExcScope^.TableOffset > 2 then
        begin
          // catch_table
          if ExceptionRecord.ExceptionCode = cDelphiException then
            ExceptionClass := PPointer(ExceptionRecord.ExceptObject)^
          else
          begin
            if not Assigned(ExceptClsProc) then
              Continue;
            ExceptionClass := TExceptClsProc(ExceptClsProc)(ExceptionRecord);
            if ExceptionClass = nil then
              Continue;
          end;
          ExcDesc := PExcDesc(ImageBase + UIntPtr(ExcScope^.TableOffset));
          ExcDescEntry := FindOnExceptionDescEntry(
                            PDispatcherContext(DispatcherContext),
                            ExceptionClass, ExcDesc);
          if ExcDescEntry = nil then
            Continue;
          TargetIp := ImageBase + UIntPtr(ExcDescEntry^.Handler);
        end
        else if ExcScope^.TableOffset = 1 then
          // safecall
          TargetIp := ImageBase  + NativeUInt(ExcScope^.EndOffset)
        else
          // ExcScope^.TableOffset = 2 // catch_any
          TargetIp := ImageBase  + NativeUInt(ExcScope^.TargetOffset);

        if ExceptionRecord.ExceptionCode = cDelphiException then
        begin
          ExceptionObject := ExceptionRecord.ExceptObject;
          ExceptionAddress := ExceptionRecord.ExceptAddr;
          JITCheckVal := 1;
        end
        else
        begin
          if not Assigned(ExceptObjProc) then
            Continue;
          ExceptionObject := TExceptObjProc(ExceptObjProc)(ExceptionRecord);
          if ExceptionObject = nil then
            Continue;
          ExceptionAddress := ExceptionRecord.ExceptionAddress;
          JITCheckVal := 1;
{$IFDEF WIN64}
          if (ExceptionRecord.ExceptionCode and cCppExceptionMask) = cCppException then
{$ELSE !WIN64}
          if ExceptionRecord.ExceptionCode <> cCppException then
{$ENDIF WIN64}
          begin
            NotifyNonDelphiException(ExceptionObject, ContextRecord);
            JITCheckVal := 0;
          end;
        end;
        if (JITEnable > JITCheckVal) and (DebugHook <= 0) then
        begin
          ExceptionPointers.ExceptionRecord := ExceptionRecord;
          ExceptionPointers.ContextRecord := ContextRecord;
          FilterRes := UnhandledExceptionFilter(@ExceptionPointers);
          if FilterRes = EXCEPTION_CONTINUE_SEARCH then
            Continue;
        end;
        ExceptionRecord.ExceptionFlags :=
          ExceptionRecord.ExceptionFlags or EXCEPTION_UNWINDING;
        if ExcScope^.TableOffset >= 2 then // catch_any or catch_table
          RaiseFramePtr := AllocateRaiseFrame
        else
          // Make the RaiseList entry on the stack
          RaiseFramePtr := @LocalRaiseFrame;
        RaiseFramePtr^.ExceptAddr := ExceptionAddress;
        RaiseFramePtr^.ExceptObject := ExceptionObject;
        LinkRaiseFrame(RaiseFramePtr);
        RtlUnwindEx(EstablisherFrame, TargetIp,
                    ExceptionRecord,
                    IntPtr(ExceptionObject),
                    PDispatcherContext(DispatcherContext).ContextRecord,
                    PDispatcherContext(DispatcherContext).HistoryTable);
      end;
    end;
  end
  else
  begin
    TargetIpRVA := PDispatcherContext(DispatcherContext).TargetIp - ImageBase;
    for ScopeIndex := 0 to ExcData^.ScopeCount - 1 do
    begin
      ExcScope := @ExcData^.ScopeTable[ScopeIndex];
      if (ControlPcRVA >= NativeUInt(ExcScope^.BeginOffset)) and
         (ControlPcRVA < NativeUInt(ExcScope^.EndOffset)) then
      begin
        if (TargetIpRVA >= NativeUInt(ExcScope^.BeginOffset)) and
           (TargetIpRVA < NativeUInt(ExcScope^.EndOffset)) and
           ((ExceptionRecord.ExceptionFlags and EXCEPTION_TARGET_UNWIND) <> 0) then
          Exit;
        if ExcScope^.TableOffset < 2 then
        begin // finally or safecall
          ThisRaiseFramePtr := RaiseListPtr;
          try
            case ExcScope^.TableOffset of
            0: // finally block
              begin
                //if TargetIpRVA = NativeUInt(ExcScope^.TargetOffset) then
                //  Exit; // DISPOSITION_CONTINUE_SEARCH
                PDispatcherContext(DispatcherContext).ControlPc := ImageBase + NativeUInt(ExcScope^.EndOffset);
                TargetIp := ImageBase + NativeUInt(ExcScope^.TargetOffset);
                NotifyExceptFinally(TargetIp);
                ExceptionPointers.ExceptionRecord := ExceptionRecord;
                ExceptionPointers.ContextRecord := ContextRecord;
                _TDelphiFinallyHandlerProc(TargetIp)(@ExceptionPointers, EstablisherFrame);
                PDispatcherContext(DispatcherContext).ContextRecord.MxCsr := GetMXCSR;
                PDispatcherContext(DispatcherContext).ContextRecord.FltSave.ControlWord := Get8087CW;
              end;
            1: // safecall / handle auto exception
              begin
                TargetIp := ImageBase + NativeUInt(ExcScope^.TargetOffset);
                PDispatcherContext(DispatcherContext).ControlPc :=
                  ImageBase + NativeUInt(ExcScope^.EndOffset);
                ExceptionPointers.ExceptionRecord := ExceptionRecord;
                ExceptionPointers.ContextRecord := ContextRecord;
                ExceptionObject := ThisRaiseFramePtr^.ExceptObject;
                ExceptionAddress := ThisRaiseFramePtr^.ExceptAddr;
                TargetIp := _TDelphiSafeCallCatchHandlerProc(TargetIp)(
                              @ExceptionPointers, EstablisherFrame,
                              ExceptionObject, ExceptionAddress);
                PDispatcherContext(DispatcherContext).ControlPc := TargetIp;
                // safecall handler doesn't need to call _DoneExcept.
                if ThisRaiseFramePtr^.ExceptObject <> nil then
                begin
                  ThisRaiseFramePtr^.ExceptObject.Free;
                  ThisRaiseFramePtr^.ExceptObject := nil;
                end;
              end;
            end;
          finally
            PrevRaiseFramePtr := nil;
            RaiseFramePtr := RaiseListPtr;
            while RaiseFramePtr <> nil do
            begin
              if RaiseFramePtr = ThisRaiseFramePtr then
              begin
                if (PrevRaiseFramePtr <> nil) or
                   (ExcScope^.TableOffset = 1) then // 1=safecall
                begin
                  // We come here if an finalization handler has thrown yet
                  // another exception we need to destroy the exception
                  // object and unlink the raise list.
                  if PrevRaiseFramePtr = nil then
                    RaiseListPtr := nil
                  else
                    PrevRaiseFramePtr^.NextRaise := RaiseFramePtr^.NextRaise;
                  if RaiseFramePtr^.ExceptObject <> nil then
                  begin
                    RaiseFramePtr^.ExceptObject.Free;
                    RaiseFramePtr^.ExceptObject := nil;
                  end;
                  ReleaseRaiseFrame(RaiseFramePtr);
                end;
                Break;
              end;
              PrevRaiseFramePtr := RaiseFramePtr;
              RaiseFramePtr := RaiseFramePtr^.NextRaise;
            end; // while RaiseFramePtr...
          end; // try-finally...
        end // ExcScope^.TableOffset < 2
        else
        begin // ExcScope^.TableOffset >= 2
          // If current handler is target(termination) catch handler,
          // Invoke NotifyAnyExcept or NotifyOnExcept, and exit loop.
          if ((ExceptionRecord.ExceptionFlags and EXCEPTION_TARGET_UNWIND) <> 0) then
          begin
            TargetIp := 0;
            if ExcScope^.TableOffset = 2 then // catch_any
              TargetIp := ImageBase + NativeUInt(ExcScope^.TargetOffset)
            else // catch_table
            begin
              if ExceptionRecord.ExceptionCode = cDelphiException then
                ExceptionClass := PPointer(ExceptionRecord.ExceptObject)^
              else
              begin
                if Assigned(ExceptClsProc) then
                  ExceptionClass := TExceptClsProc(ExceptClsProc)(ExceptionRecord)
                else
                  ExceptionClass := nil;
              end;
              if ExceptionClass <> nil then
              begin
                ExcDesc := PExcDesc(ImageBase + NativeUInt(ExcScope^.TableOffset));
                ExcDescEntry := FindOnExceptionDescEntry(
                                  PDispatcherContext(DispatcherContext),
                                  ExceptionClass, ExcDesc);
                if ExcDescEntry <> nil then
                  TargetIp := ImageBase + UIntPtr(ExcDescEntry^.Handler);
              end;
            end; // if ExcScope^.TableOffset
            if (TargetIp <> 0) and
               (TargetIp = PDispatcherContext(DispatcherContext).TargetIp) then
            begin
              if ExcScope^.TableOffset = 2 then // catch_any
                NotifyAnyExcept(TargetIp)
              else
                NotifyOnExcept(TargetIp);
              Break;
            end;
          end; // if ExceptionRecord.ExceptionFlags
        end; // if ExcScope^.TableOffset
      end; // if ControlPcRVA...
    end; // for ScopeIndex...
  end;
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IFDEF STACK_BASED_EXCEPTIONS}
procedure _HandleFinallyInternal; forward;
{$ENDIF STACK_BASED_EXCEPTIONS}

{
 When an exception is to be handled unconditionally by some bit of user code,
 there is still some book-keeping that needs to be done.  There is special
 handling that needs to be done if the exception is from C++, either a Delphi
 exception, or a pure C++ exception.  We have to restore some internal state
 as well, and we have to notify the debugger.  Once we've done those things,
 we return to the exception handling fragment in the user code that called us.
}
                                                                       
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure _HandleAnyException;
asm //StackAlignSafe
{$IFDEF PC_MAPPED_EXCEPTIONS}
        CMP     ECX, UW_EXC_CLASS_BORLANDCPP    // C++ exception?
        JNE     @@handleIt                      // nope, handle it
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        // C++ exceptions aren't wanted here.  Retoss them as is
        // We won't return from this.
        CALL    SysRaiseCPPException

@@handleIt:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        CALL    UnblockOSExceptions
        POP     EDX
        POP     EAX

{$IFDEF ALIGN_STACK}
        // We'll just increase our alignment adjustment from above
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        // If the exception is a Delphi exception thrown from C++, coopt it.
        CALL    MaybeCooptException

        OR      [EAX].TRaisedException.Flags, excIsBeingHandled
        CALL    LinkException
        MOV     ESI, EBX
        MOV     EDX, [ESP] // EDX = return address
        CALL    NotifyExcept
        MOV     EBX, ESI
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
        {
         When _HandleAnyException was called, the stack was adjusted to align
         it per the Mach ABI.  The unwinder will have reset the stack pointer
         to the prologue result, and the generated code in the caller will
         have further adjusted for dynamic arrays.  Thus the alignment adjustment
         made by the compiler will always have been 12 bytes.  The code generator
         could dispose of that in the user code, on return, but it saves a little
         space, and it's easy to do from here.
        }
//        RET   12
{$ENDIF ALIGN_STACK}
        // End of routine - we return to user code now.
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFNDEF  PC_MAPPED_EXCEPTIONS}
        { ->    [ESP+ 4] excPtr: PExceptionRecord       }
        {       [ESP+ 8] errPtr: PExcFrame              }
        {       [ESP+12] ctxPtr: Pointer                }
        {       [ESP+16] dspPtr: Pointer                }
        { <-    EAX return value - always one           }

        MOV     EAX,[ESP+4]
        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInProgress
        JNE     @@exit

        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiException
        MOV     EDX,[EAX].TExceptionRecord.ExceptObject
        MOV     ECX,[EAX].TExceptionRecord.ExceptAddr
        JE      @@DelphiException
        CLD
        CALL    _FpuInit
        MOV     EDX,ExceptObjProc
        TEST    EDX,EDX
        JE      @@exit
        CALL    EDX
        TEST    EAX,EAX
        JE      @@exit
        MOV     EDX,[ESP+12]
        MOV     ECX,[ESP+4]
        CMP     [ECX].TExceptionRecord.ExceptionCode,cCppException
        JE      @@CppException
        CALL    NotifyNonDelphiException
        CMP     BYTE PTR JITEnable,0
        JBE     @@CppException
        CMP     BYTE PTR DebugHook,0
        JA      @@CppException                     // Do not JIT if debugging
        LEA     ECX,[ESP+4]
        PUSH    EAX
        PUSH    ECX
        CALL    UnhandledExceptionFilter
        CMP     EAX,EXCEPTION_CONTINUE_SEARCH
        POP     EAX
        JE      @@exit
        MOV     EDX,EAX
        MOV     EAX,[ESP+4]
        MOV     ECX,[EAX].TExceptionRecord.ExceptionAddress
        JMP     @@GoUnwind

@@CppException:
        MOV     EDX,EAX
        MOV     EAX,[ESP+4]
        MOV     ECX,[EAX].TExceptionRecord.ExceptionAddress

@@DelphiException:
        CMP     BYTE PTR JITEnable,1
        JBE     @@GoUnwind
        CMP     BYTE PTR DebugHook,0                { Do not JIT if debugging }
        JA      @@GoUnwind
        PUSH    EAX
        LEA     EAX,[ESP+8]
        PUSH    EDX
        PUSH    ECX
        PUSH    EAX
        CALL    UnhandledExceptionFilter
        CMP     EAX,EXCEPTION_CONTINUE_SEARCH
        POP     ECX
        POP     EDX
        POP     EAX
        JE      @@exit

@@GoUnwind:
        OR      [EAX].TExceptionRecord.ExceptionFlags,cUnwinding

        PUSH    EBX
        XOR     EBX,EBX
        PUSH    ESI
        PUSH    EDI
        PUSH    EBP

        MOV     EBX,FS:[EBX]
        PUSH    EBX                     { Save pointer to topmost frame }
        PUSH    EAX                     { Save OS exception pointer     }
        PUSH    EDX                     { Save exception object         }
        PUSH    ECX                     { Save exception address        }

        MOV     EDX,[ESP+8+8*4]

        PUSH    0
        PUSH    EAX
        PUSH    offset @@returnAddress
        PUSH    EDX
        CALL    RtlUnwindProc
@@returnAddress:

        MOV     EDI,[ESP+8+8*4]

        {       Make the RaiseList entry on the stack }

        CALL    SysInit.@GetTLS
        PUSH    [EAX].RaiseListPtr
        MOV     [EAX].RaiseListPtr,ESP

        MOV     EBP,[EDI].TExcFrame.hEBP
        MOV     EBX,[EDI].TExcFrame.desc
        MOV     [EDI].TExcFrame.desc,offset @@exceptFinally

        ADD     EBX,TExcDesc.instructions
        CALL    NotifyAnyExcept
        JMP     EBX

@@exceptFinally:
        JMP     _HandleFinallyInternal

@@destroyExcept:
        {       we come here if an exception handler has thrown yet another exception }
        {       we need to destroy the exception object and pop the raise list. }

        CALL    SysInit.@GetTLS
        MOV     ECX,[EAX].RaiseListPtr
        MOV     EDX,[ECX].TRaiseFrame.NextRaise
        MOV     [EAX].RaiseListPtr,EDX

        MOV     EAX,[ECX].TRaiseFrame.ExceptObject
        JMP     TObject.Free

@@exit:
        MOV     EAX,1
{$ENDIF !PC_MAPPED_EXCEPTIONS}  { not PC_MAPPED_EXCEPTIONS }
end;
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}

{$IFDEF PC_MAPPED_EXCEPTIONS}
{
  Common code between the Win32 and PC mapped exception handling
  scheme.  This function takes a pointer to an object, and an exception
  'on' descriptor table and finds the matching handler descriptor.

  For support of Linux, we assume that EBX has been loaded with the GOT
  that pertains to the code which is handling the exception currently.
  If this function is being called from code which is not PIC, then
  EBX should be zero on entry.

  N.B. For the Mac, it is critical that this code never calls out of
  the System unit, as we do not align the stack around calls to it.
}
procedure FindOnExceptionDescEntry;
asm
{ ->    EAX raised object: Pointer                }
{       EDX descriptor table: ^TExcDesc           }
{       EBX GOT of user code, or 0 if not an SO   }
{ <-    EAX matching descriptor: ^TExcDescEntry   }
        PUSH    EBP
        MOV     EBP, ESP
        SUB     ESP, 8                          { Room for vtable temp, and adjustor }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV [EBP - 8], EBX      { Store the potential GOT }
        MOV EAX, [EAX]          { load vtable of exception object }
        MOV     EBX,[EDX].TExcDesc.cnt
        LEA     ESI,[EDX].TExcDesc.excTab       { point ECX to exc descriptor table }
        MOV     [EBP - 4], EAX                  { temp for vtable of exception object }

@@innerLoop:
        MOV     EAX,[ESI].TExcDescEntry.vTable
        TEST    EAX,EAX                         { catch all clause?                     }
        JE      @@found                         { yes: This is the handler              }
        ADD     EAX, [EBP - 8]                  { add in the adjustor (could be 0) }
        MOV     EDI,[EBP - 4]                   { load vtable of exception object       }
        JMP     @@haveVMT

@@vtLoop:
        MOV     EDI,[EDI]
@@haveVMT:
        MOV     EAX,[EAX]
        CMP     EAX,EDI
        JE      @@found

        MOV     ECX,[EAX].vmtInstanceSize
        CMP     ECX,[EDI].vmtInstanceSize
        JNE     @@parent

        MOV     EAX,[EAX].vmtClassName
        MOV     EDX,[EDI].vmtClassName

        XOR     ECX,ECX
        MOV     CL,[EAX]
        CMP     CL,[EDX]
        JNE     @@parent

        INC     EAX
        INC     EDX
{$IFDEF ALIGN_STACK}
        SUB      ESP, 4
{$ENDIF ALIGN_STACK}
        CALL    _AStrCmp
{$IFDEF ALIGN_STACK}
        ADD      ESP, 4
{$ENDIF ALIGN_STACK}
        JE      @@found

@@parent:
        MOV     EDI,[EDI].vmtParent             { load vtable of parent         }
        MOV     EAX,[ESI].TExcDescEntry.vTable
        ADD     EAX, [EBP - 8]                  { add in the adjustor (could be 0) }
        TEST    EDI,EDI
        JNE     @@vtLoop

        ADD     ESI,8
        DEC     EBX
        JNZ     @@innerLoop

        { Didn't find a handler. }
        XOR     ESI, ESI

@@found:
        MOV     EAX, ESI
@@done:
        POP     EDI
        POP     ESI
        POP     EBX
        MOV     ESP, EBP
        POP     EBP
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}

{$IFDEF PC_MAPPED_EXCEPTIONS}
procedure       _HandleOnExceptionPIC;
asm
        { ->    EAX obj : Exception object }
        {       [RA]  desc: ^TExcDesc }
        { <-    Doesn't return }

        // Mark the exception as being handled
        OR      [EAX].TRaisedException.Flags, excIsBeingHandled

        MOV     ESI, EBX                      // Save the GOT
        MOV     EDX, [ESP]                    // Get the addr of the TExcDesc
        PUSH    EAX                           // Save the object
        MOV     EAX, [EAX].TRaisedException.ExceptObject
        CALL    FindOnExceptionDescEntry
        OR      EAX, EAX
        JE      @@NotForMe

        MOV     EBX, ESI                      // Set back to user's GOT
        MOV     EDX, EAX
        POP     EAX                           // Get the object back
        POP     ECX                           // Ditch the return addr

        CALL    LinkException

        // Get the Pascal object itself.
        MOV     EAX, [EAX].TRaisedException.ExceptObject

        MOV     EDX, [EDX].TExcDescEntry.handler
        ADD     EDX, EBX                      // adjust for GOT
        CALL    NotifyOnExcept

        MOV     EBX, ESI                      // Make sure of user's GOT
{$IFDEF ALIGN_STACK}
        {
         When _HandleOnExceptionPIC was called, the stack was adjusted to align
         it per the Mach ABI.  The unwinder will have reset the stack pointer
         to the prologue result, and the generated code in the caller will
         have further adjusted for dynamic arrays.  Thus the alignment adjustment
         made by the compiler will always have been 12 bytes.  We have to
         discard that alignment here.
        }
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        JMP     EDX                           // Back to the user code
        // never returns
@@NotForMe:
        POP     EAX                           // Get the exception object

        // Mark that we're reraising this exception, so that the
        // compiler generated exception handler for the 'except on' clause
        // will not get confused
        OR      [EAX].TRaisedException.Flags, excIsBeingReRaised

        JMP     SysRaiseException             // Should be using resume here
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}

{
 N.B.  On the Mac, the stack alignment code in _HandleOnException is fine tuned.
 On first read, it may seem incorrect.
}
                                                                      
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure       _HandleOnException;
{$IFDEF PC_MAPPED_EXCEPTIONS}
asm //StackAlignSafe
        { ->    EAX obj : Exception object }
        {       [RA]  desc: ^TExcDesc }
        { <-    Doesn't return }

        CMP     ECX, UW_EXC_CLASS_BORLANDCPP    // C++ exception?
        JNE     @@handleIt                      // nope, handle it
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        // C++ exceptions aren't wanted here.  Retoss them as is.
        // We won't return from this.
        CALL    SysRaiseCPPException

@@handleIt:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        // If the exception is a Delphi exception thrown from C++, coopt it.
        CALL    MaybeCooptException

        // Mark the exception as being handled
        OR      [EAX].TRaisedException.Flags, excIsBeingHandled

{$IFDEF ALIGN_STACK}
        MOV     EDX, [ESP + 12]               // Get the addr of the TExcDesc
{$ELSE !ALIGN_STACK}
        MOV     EDX, [ESP]                    // Get the addr of the TExcDesc
{$ENDIF !ALIGN_STACK}
        // STACK: 16 - no alignment required by FindOnExceptionDescEntry
        // N.B.  We have to make sure that FindOnExceptionDescEntry
        // never calls out of System.pas.
        PUSH    EAX                           // Save the object
        PUSH    EBX                           // Save EBX
        XOR     EBX, EBX                      // No GOT
        MOV     EAX, [EAX].TRaisedException.ExceptObject
        CALL    FindOnExceptionDescEntry
        POP     EBX                           // Restore EBX
        OR      EAX, EAX                      // Is the exception for me?
        JE      @@NotForMe

        MOV     EDX, EAX
        POP     EAX                           // Get the object back
{$IFDEF ALIGN_STACK}
        ADD     ESP, 16                       // Ditch the alignment _and_ return addr
        // STACK ALIGNMENT: 16, since we ditched the return addr as well
{$ELSE !ALIGN_STACK}
        POP     ECX                           // Ditch the return addr
{$ENDIF !ALIGN_STACK}

        CALL    LinkException

        // Get the Pascal object itself.
        MOV     EAX, [EAX].TRaisedException.ExceptObject

        MOV     EDX, [EDX].TExcDescEntry.handler
        CALL    NotifyOnExcept                // Tell the debugger about it

{$IFDEF ALIGN_STACK}
        {
         When _HandleOnException was called, the stack was adjusted to align
         it per the Mach ABI.  The unwinder will have reset the stack pointer
         to the prologue result, and the generated code in the caller will
         have further adjusted for dynamic arrays.  Thus the alignment adjustment
         made by the compiler will always have been 12 bytes.  We have to
         discard that alignment here.
        }
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        JMP     EDX                           // Back to the user code
        // never returns
@@NotForMe:
        POP     EAX                           // Get the exception object
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}

        // Mark that we're reraising this exception, so that the
        // compiler generated exception handler for the 'except on' clause
        // will not get confused
        OR      [EAX].TRaisedException.Flags, excIsBeingReRaised
        JMP     SysRaiseException             // Should be using resume here
end;
{$ELSE !PC_MAPPED_EXCEPTIONS}
                                                                      
asm
        { ->    [ESP+ 4] excPtr: PExceptionRecord       }
        {       [ESP+ 8] errPtr: PExcFrame              }
        {       [ESP+12] ctxPtr: Pointer                }
        {       [ESP+16] dspPtr: Pointer                }
        { <-    EAX return value - always one           }

        MOV     EAX,[ESP+4]
        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInProgress
        JNE     @@exit

        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiException
        JE      @@DelphiException
        CLD
        CALL    _FpuInit
        MOV     EDX,ExceptClsProc
        TEST    EDX,EDX
        JE      @@exit
        CALL    EDX
        TEST    EAX,EAX
        JNE     @@common
        JMP     @@exit

@@DelphiException:
        MOV     EAX,[EAX].TExceptionRecord.ExceptObject
        MOV     EAX,[EAX]                       { load vtable of exception object       }

@@common:
        MOV     EDX,[ESP+8]

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        PUSH    EBP

        MOV     ECX,[EDX].TExcFrame.desc
        MOV     EBX,[ECX].TExcDesc.cnt
        LEA     ESI,[ECX].TExcDesc.excTab       { point ECX to exc descriptor table }
        MOV     EBP,EAX                         { load vtable of exception object }

@@innerLoop:
        MOV     EAX,[ESI].TExcDescEntry.vTable
        TEST    EAX,EAX                         { catch all clause?                     }
        JE      @@doHandler                     { yes: go execute handler               }
        MOV     EDI,EBP                         { load vtable of exception object       }
        JMP     @@haveVMT

@@vtLoop:
        MOV     EDI,[EDI]
@@haveVMT:
        MOV     EAX,[EAX]
        CMP     EAX,EDI
        JE      @@doHandler

        MOV     ECX,[EAX].vmtInstanceSize
        CMP     ECX,[EDI].vmtInstanceSize
        JNE     @@parent

        MOV     EAX,[EAX].vmtClassName
        MOV     EDX,[EDI].vmtClassName

        XOR     ECX,ECX
        MOV     CL,[EAX]
        CMP     CL,[EDX]
        JNE     @@parent

        INC     EAX
        INC     EDX
        CALL    _AStrCmp
        JE      @@doHandler

@@parent:
        MOV     EDI,[EDI].vmtParent             { load vtable of parent         }
        MOV     EAX,[ESI].TExcDescEntry.vTable
        TEST    EDI,EDI
        JNE     @@vtLoop

        ADD     ESI,8
        DEC     EBX
        JNZ     @@innerLoop

        POP     EBP
        POP     EDI
        POP     ESI
        POP     EBX
        JMP     @@exit

@@doHandler:
        MOV     EAX,[ESP+4+4*4]
        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiException
        MOV     EDX,[EAX].TExceptionRecord.ExceptObject
        MOV     ECX,[EAX].TExceptionRecord.ExceptAddr
        JE      @@haveObject
        CALL    ExceptObjProc
        MOV     EDX,[ESP+12+4*4]
        CALL    NotifyNonDelphiException
        CMP     BYTE PTR JITEnable,0
        JBE     @@NoJIT
        CMP     BYTE PTR DebugHook,0
        JA      @@noJIT                 { Do not JIT if debugging }
        LEA     ECX,[ESP+4+4*4]
        PUSH    EAX
        PUSH    ECX
        CALL    UnhandledExceptionFilter
        CMP     EAX,EXCEPTION_CONTINUE_SEARCH
        POP     EAX
        JE      @@exit

@@noJIT:
        MOV     EDX,EAX
        MOV     EAX,[ESP+4+4*4]
        MOV     ECX,[EAX].TExceptionRecord.ExceptionAddress
        JMP     @@GoUnwind

@@haveObject:
        CMP     BYTE PTR JITEnable,1
        JBE     @@GoUnwind
        CMP     BYTE PTR DebugHook,0
        JA      @@GoUnwind
        PUSH    EAX
        LEA     EAX,[ESP+4+5*4]
        PUSH    EDX
        PUSH    ECX
        PUSH    EAX
        CALL    UnhandledExceptionFilter
        CMP     EAX,EXCEPTION_CONTINUE_SEARCH
        POP     ECX
        POP     EDX
        POP     EAX
        JE      @@exit

@@GoUnwind:
        XOR     EBX,EBX
        MOV     EBX,FS:[EBX]
        PUSH    EBX                     { Save topmost frame     }
        PUSH    EAX                     { Save exception record  }
        PUSH    EDX                     { Save exception object  }
        PUSH    ECX                     { Save exception address }

        MOV     EDX,[ESP+8+8*4]
        OR      [EAX].TExceptionRecord.ExceptionFlags,cUnwinding

        PUSH    ESI                     { Save handler entry     }

        PUSH    0
        PUSH    EAX
        PUSH    offset @@returnAddress
        PUSH    EDX
        CALL    RtlUnwindProc
@@returnAddress:

        POP     EBX                     { Restore handler entry  }

        MOV     EDI,[ESP+8+8*4]

        {       Make the RaiseList entry on the stack }

        CALL    SysInit.@GetTLS
        PUSH    [EAX].RaiseListPtr
        MOV     [EAX].RaiseListPtr,ESP

        MOV     EBP,[EDI].TExcFrame.hEBP
        MOV     [EDI].TExcFrame.desc,offset @@exceptFinally
        MOV     EAX,[ESP].TRaiseFrame.ExceptObject
        CALL    NotifyOnExcept
        JMP     [EBX].TExcDescEntry.handler

@@exceptFinally:
        JMP     _HandleFinallyInternal

@@destroyExcept:
        {       we come here if an exception handler has thrown yet another exception }
        {       we need to destroy the exception object and pop the raise list. }

        CALL    SysInit.@GetTLS
        MOV     ECX,[EAX].RaiseListPtr
        MOV     EDX,[ECX].TRaiseFrame.NextRaise
        MOV     [EAX].RaiseListPtr,EDX

        MOV     EAX,[ECX].TRaiseFrame.ExceptObject
        JMP     TObject.Free

@@exit:
        MOV     EAX,1
end;
{$ENDIF !PC_MAPPED_EXCEPTIONS}
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}

                                                                  
{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPTIONS)}
procedure _HandleFinally;
{$IFDEF PC_MAPPED_EXCEPTIONS}
asm //StackAlignSafe
{$IFDEF PIC}
        MOV     ESI, EBX
{$ENDIF PIC}
        CMP     ECX, UW_EXC_CLASS_BORLANDCPP    // C++ exception?
        JNE     @@handleIt                      // nope, handle it
        // unwinding a C++ exception.  We handle that specially.
        PUSH    EAX
        PUSH    EDX
        PUSH    ECX
        MOV     EDX, [ESP+12]
        CALL    EDX
        POP     ECX
        POP     EDX
        POP     EAX
        CALL    SysRaiseCPPException

@@handleIt:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4 { RA, XX, and 2 PUSHes to come = 16}
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        CALL    UnblockOSExceptions
        POP     EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8 { RA, prev XX, XX XX = 16 }
{$ENDIF ALIGN_STACK}

        // If the exception is a Delphi exception thrown from C++, coopt it.
        CALL    MaybeCooptException

{$IFDEF ALIGN_STACK}
        MOV     EDX, [ESP + 12] { get the return address; stack still aligned }
{$ELSE !ALIGN_STACK}
        MOV     EDX, [ESP]
{$ENDIF !ALIGN_STACK}
        CALL    NotifyExceptFinally
        PUSH    EAX
{$IFDEF PIC}
        MOV     EBX, ESI
{$ENDIF PIC}
        {
          Mark the current exception with the EBP of the handler.  If
          an exception is raised from the finally block, then this
          exception will be orphaned.  We will catch this later, when
          we clean up the next except block to complete execution.
          See DoneExcept.
        }
        MOV [EAX].TRaisedException.HandlerEBP, EBP
        { Note: This call appears misalligned when ALIGN_STACK is
          defined, but the finally handler fixes up the stack upon
          entry.  This is due to the fact that the code generated for
          the finally block deals with both the normal flow, and the
          exception case.  In the normal flow, we push the address of
          a label to simulate a return address, prior to entering the
          finally block.  This push mis-aligns the stack, and the
          finally block compensates.  We'll be skipping that push,
          so the return address that we pushed above mirrors the effect. }
        CALL    EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        { We have to make it look like we've arrived here and setup
          a basic EBP frame, in order for the unwind that we will now
          cause to succeed properly.  We popped the saved EAX, now
          we have to get rid of stuff up to the original return address. }
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        {
          We executed the finally handler without adverse reactions.
          It's safe to clear the marker now.
        }
        MOV [EAX].TRaisedException.HandlerEBP, $FFFFFFFF
        PUSH    EBP
        MOV     EBP, ESP
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        CALL    SysRaiseException             // Should be using resume here
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF MSWINDOWS}
asm
        { ->    [ESP+ 4] excPtr: PExceptionRecord       }
        {       [ESP+ 8] errPtr: PExcFrame              }
        {       [ESP+12] ctxPtr: Pointer                }
        {       [ESP+16] dspPtr: Pointer                }
        { <-    EAX return value - always one           }

        MOV     EAX,[ESP+4]
        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInProgress
        JE      @@exit

        PUSH    EBX
        XOR     EBX,EBX
        PUSH    ESI
        PUSH    EDI
        PUSH    EBP

        {       Make exception frame    }

        PUSH    EBP
        PUSH    offset @@exceptFinally
        PUSH    dword ptr FS:[EBX]
        MOV     FS:[EBX],ESP

        MOV     EBX,FS:[EBX]
        MOV     EDX,[EAX].TExceptionRecord.ExceptObject
        MOV     ECX,[EAX].TExceptionRecord.ExceptAddr
        PUSH    EBX                     { Save pointer to topmost frame }
        PUSH    EAX                     { Save OS exception pointer     }
        PUSH    EDX                     { Save exception object         }
        PUSH    ECX                     { Save exception address        }

        MOV     EDI,[ESP+8+11*4]        { Load errPtr:PExcFrame         }

        {       Make the RaiseList entry on the stack   }

        CALL    SysInit.@GetTLS
        PUSH    [EAX].RaiseListPtr
        MOV     [EAX].RaiseListPtr,ESP

        MOV     ECX,[EDI].TExcFrame.desc
        MOV     EBP,[EDI].TExcFrame.hEBP
        MOV     [EDI].TExcFrame.desc,offset @@exceptFinally
        ADD     ECX,TExcDesc.instructions
        CALL    NotifyExceptFinally
        CALL    ECX

        CALL    SysInit.@GetTLS
        MOV     ECX,[EAX].RaiseListPtr
        MOV     EDX,[ECX].TRaiseFrame.NextRaise
        MOV     [EAX].RaiseListPtr,EDX
        ADD     ESP,5*4                 { Remove local RaiseList        }

        {       Remove exception frame  }

        XOR     EAX,EAX
        POP     EDX
        POP     ECX
        POP     ECX
        MOV     FS:[EAX],EDX

        POP     EBP
        POP     EDI
        POP     ESI
        POP     EBX
        JMP     @@exit

@@exceptFinally:
        JMP     _HandleFinallyInternal

@@destroyExcept:
        {       we come here if an finalization handler has thrown yet  }
        {       another exception we need to destroy the exception      }
        {       object and pop the raise list.                          }

        CALL    SysInit.@GetTLS
        MOV     ECX,[EAX].RaiseListPtr
        MOV     EDX,[ECX].TRaiseFrame.NextRaise
        MOV     [EAX].RaiseListPtr,EDX

        MOV     EAX,[ECX].TRaiseFrame.ExceptObject
        JMP     TObject.Free

@@exit:
        MOV     EAX,1
end;
{$ENDIF MSWINDOWS}
{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}

                                                                          
{$IFDEF STACK_BASED_EXCEPTIONS}
procedure       _HandleFinallyInternal;
asm
        { ->    [ESP+ 4] excPtr: PExceptionRecord       }
        {       [ESP+ 8] errPtr: PExcFrame              }
        {       [ESP+12] ctxPtr: Pointer                }
        {       [ESP+16] dspPtr: Pointer                }
        { <-    EAX return value - always one           }

        MOV     EAX,[ESP+4]
        MOV     EDX,[ESP+8]
        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInProgress
        JE      @@exit
        MOV     ECX,[EDX].TExcFrame.desc
        MOV     [EDX].TExcFrame.desc,offset @@exit

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        PUSH    EBP

        MOV     EBP,[EDX].TExcFrame.hEBP
        ADD     ECX,TExcDesc.instructions
        CALL    NotifyExceptFinally
        CALL    ECX

        POP     EBP
        POP     EDI
        POP     ESI
        POP     EBX

@@exit:
        MOV     EAX,1
end;
{$ENDIF STACK_BASED_EXCEPTIONS}

                                                                        
{$IFDEF STACK_BASED_EXCEPTIONS}
procedure _HandleAutoException;
asm
        { ->    [ESP+ 4] excPtr: PExceptionRecord       }
        {       [ESP+ 8] errPtr: PExcFrame              }
        {       [ESP+12] ctxPtr: Pointer                }
        {       [ESP+16] dspPtr: Pointer                }
        { <-    EAX return value - always one           }

        MOV     EAX,[ESP+4]
        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInProgress
        JNE     @@exit

        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiException
        CLD
        CALL    _FpuInit
        JE      @@DelphiException
        CMP     BYTE PTR JITEnable,0
        JBE     @@DelphiException
        CMP     BYTE PTR DebugHook,0
        JA      @@DelphiException

@@DoUnhandled:
        LEA     EAX,[ESP+4]
        PUSH    EAX
        CALL    UnhandledExceptionFilter
        CMP     EAX,EXCEPTION_CONTINUE_SEARCH
        JE      @@exit
        MOV     EAX,[ESP+4]
        JMP     @@GoUnwind

@@DelphiException:
        CMP     BYTE PTR JITEnable,1
        JBE     @@GoUnwind
        CMP     BYTE PTR DebugHook,0
        JA      @@GoUnwind
        JMP     @@DoUnhandled

@@GoUnwind:
        OR      [EAX].TExceptionRecord.ExceptionFlags,cUnwinding

        PUSH    ESI
        PUSH    EDI
        PUSH    EBP

        MOV     EDX,[ESP+8+3*4]

        PUSH    0
        PUSH    EAX
        PUSH    offset @@returnAddress
        PUSH    EDX
        CALL    RtlUnwindProc

@@returnAddress:
        POP     EBP
        POP     EDI
        POP     ESI
        MOV     EAX,[ESP+4]
        MOV     EBX,8000FFFFH
        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiException
        JNE     @@done

        MOV     EDX,[EAX].TExceptionRecord.ExceptObject
        MOV     ECX,[EAX].TExceptionRecord.ExceptAddr
        MOV     EAX,[ESP+8]
        MOV     EAX,[EAX].TExcFrame.SelfOfMethod
        TEST    EAX,EAX
        JZ      @@freeException
        MOV     EBX,[EAX]
        CALL    DWORD PTR [EBX] + VMTOFFSET TObject.SafeCallException
        MOV     EBX,EAX
@@freeException:
        MOV     EAX,[ESP+4]
        MOV     EAX,[EAX].TExceptionRecord.ExceptObject
        CALL    TObject.Free

@@done:
        XOR     EAX,EAX
        MOV     ESP,[ESP+8]
        POP     ECX
        MOV     FS:[EAX],ECX
        POP     EDX
        POP     EBP
        LEA     EDX,[EDX].TExcDesc.instructions
        POP     ECX
        JMP     EDX
@@exit:
        MOV     EAX,1
end;
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IFDEF PC_MAPPED_EXCEPTIONS}
procedure _HandleAutoException;
asm
        // EAX = TObject reference, or nil
        // [ESP] = ret addr

{$IFDEF ALIGN_STACK}
         SUB      ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        CALL    UnblockOSExceptions

        CALL    CurrentException
        MOV     EDX, [ESP]
        // If the exception is a Delphi exception thrown from C++, coopt it.
        CALL    MaybeCooptException
        CALL    LinkException
        POP     EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD      ESP, 4
{$ENDIF ALIGN_STACK}

//  The compiler wants the stack to look like this:
//  ESP+4->  HRESULT
//  ESP+0->  ret addr
//
//  Make it so.
//
        POP     EDX
        PUSH    8000FFFFH
        PUSH    EDX

        PUSH    ESI
        PUSH    EAX
        OR      EAX, EAX    // Was this a method call?
        JE      @@Done

        CALL    CurrentException
        MOV     EDX, [EAX].TRaisedException.ExceptObject
        MOV     ECX, [EAX].TRaisedException.ExceptionAddr;
        MOV     EAX, [ESP]
        MOV     ESI, [EAX]
        CALL    DWORD PTR [ESI] + VMTOFFSET TObject.SafeCallException;
        MOV     [ESP+12], EAX
@@Done:
        CALL    _DoneExcept
        POP     EAX
        POP     ESI
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IF Defined(SJLJ_BASED_EXCEPTIONS) or defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
function GetRaiseFrame(var UnwindException: _Unwind_Exception): PRaiseFrame; inline;
begin
  Result := PRaiseFrame((PByte(@UnwindException) + SizeOf(_Unwind_Exception)) - SizeOf(TRaiseFrame));
end;

function GetThrownObject(var UnwindException: _Unwind_Exception): Pointer; inline;
begin
  Result := Pointer(GetRaiseFrame(UnwindException).ExceptObject);
end;

function _HandleAutoException(const Self: TObject; var UnwindException: _Unwind_Exception): HResult;
var
  CurRaiseFrame: PRaiseFrame;
  ExceptObject: Pointer;
  ExceptAddr: Pointer;
begin
  Result := HResult($8000FFFF); { E_UNEXPECTED }
  CurRaiseFrame := GetRaiseFrame(UnwindException);
  ExceptObject := CurRaiseFrame^.ExceptObject;
  ExceptAddr := CurRaiseFrame^.ExceptAddr;
  if Assigned(Self) then
    Result := Self.SafeCallException(ExceptObject, ExceptAddr);
  _DoneExcept(UnwindException);
end;
{$ENDIF}

{$IFDEF PC_MAPPED_EXCEPTIONS}
                                                        
                                                                 
procedure       _RaiseAtExcept;
asm //StackAlignSafe
        { ->    EAX     Pointer to exception object     }
        { ->    EDX     Purported addr of exception     }
        { Be careful: EBX is not set up in PIC mode. }
        { Outward bound calls must go through an exported fn, like SysRaiseException }
        OR      EAX, EAX
        JNE     @@GoAhead
        MOV     EAX, 216
        JMP     _RunError

@@GoAhead:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    BlockOSExceptions
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        PUSH    EBP
        MOV     EBP, ESP
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        CALL    NotifyReRaise
        CALL    AllocateException
{$IFDEF PIC}
        PUSH    EAX
        CALL    GetGOT
        MOV     EBX, EAX
        POP     EAX
        MOV     EDX, [EBX].RaiseExceptObjProc
        MOV     EDX, [EDX]
{$ELSE !PIC}
        MOV     EDX,RaiseExceptObjProc
{$ENDIF !PIC}
        TEST    EDX,EDX
        JZ      @@DoRaise
{$IFDEF ALIGN_STACK}
        MOV     [ESP],EAX
        CALL    EDX
        MOV     EAX,[ESP]
{$ELSE}
        PUSH    EAX
        CALL    EDX
        POP     EAX
{$ENDIF ALIGN_STACK}
@@DoRaise:
        CALL    SysRaiseException
        {
          This can only return if there was a terrible error.  In this event,
          we have to bail out.
        }
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
        POP     EBP
{$ENDIF ALIGN_STACK}
        JMP     _Run0Error
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}

                                                 
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure _RaiseAtExcept(Obj: TObject; Address: Pointer);
var
  Params: Array[0..6] of NativeUInt;
  ExceptionRecord: TExceptionRecord;
  //CurRaiseFrame: PRaiseFrame;
begin
  if Obj = nil then
    _RunError(216); // reAccessViolation

  Params[0] := UIntPtr(Address);
  Params[1] := UIntPtr(Pointer(Obj));
  Params[2] := 0 {EBX};
  Params[3] := 0 {ESI};
  Params[4] := 0 {EDI};
  Params[5] := 0 {EBP};
  Params[6] := 0 {ESP};

  if RaiseExceptObjProc <> nil then
  begin
    //CurRaiseFrame := RaiseListPtr;
    ExceptionRecord.ExceptionCode := cDelphiException;
    ExceptionRecord.ExceptionFlags := cNonContinuable;
    ExceptionRecord.ExceptionRecord := nil;
//  if CurRaiseFrame <> nil then
//    ExceptionRecord.ExceptionRecord := CurRaiseFrame^.ExceptionRecord;
    ExceptionRecord.ExceptionAddress := Address;
    ExceptionRecord.NumberParameters := 7;
    ExceptionRecord.ExceptionInformation[0] := Params[0];
    ExceptionRecord.ExceptionInformation[1] := Params[1];
    ExceptionRecord.ExceptionInformation[2] := Params[2];
    ExceptionRecord.ExceptionInformation[3] := Params[3];
    ExceptionRecord.ExceptionInformation[4] := Params[4];
    ExceptionRecord.ExceptionInformation[5] := Params[5];
    ExceptionRecord.ExceptionInformation[6] := Params[6];
    TRaiseExceptObjProc(RaiseExceptObjProc)(@ExceptionRecord);
  end;
  RaiseExceptionProc(cDelphiException, cNonContinuable, 7, @Params);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}

                                                                
{$IFDEF PC_MAPPED_EXCEPTIONS}
procedure       _RaiseExcept;
asm
        { ->    EAX     Pointer to exception object     }
        MOV     EDX, [ESP]
        JMP     _RaiseAtExcept
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}

{$IFDEF STACK_BASED_EXCEPTIONS}
procedure       _RaiseExcept;
asm
  { When making changes to the way Delphi Exceptions are raised, }
  { please realize that the C++ Exception handling code reraises }
  { some exceptions as Delphi Exceptions.  Of course we want to  }
  { keep exception raising compatible between Delphi and C++, so }
  { when you make changes here, consult with the relevant C++    }
  { exception handling engineer. The C++ code is in xx.cpp, in   }
  { the RTL sources, in function tossAnException.                }

  { ->    EAX     Pointer to exception object     }
  {       [ESP]   Error address           }

        OR      EAX, EAX
        JNE     @@GoAhead
        MOV     EAX, 216
        CALL    _RunError
@@GoAhead:
        POP     EDX

        PUSH    ESP
        PUSH    EBP
        PUSH    EDI
        PUSH    ESI
        PUSH    EBX
        PUSH    EAX                             { pass class argument           }
        PUSH    EDX                             { pass address argument         }

{$IFDEF AUTOREFCOUNT}
        CALL    _InstAddRef                     { EAX still contains the exception object reference }
{$ENDIF}

        MOV     EAX,ESP                         { Need these values later }
        PUSH    ESP                             { pass pointer to arguments             }
        PUSH    7                               { there are seven arguments               }
        PUSH    cNonContinuable                 { we can't continue execution   }
        PUSH    cDelphiException                { our magic exception code              }
        PUSH    EDX                             { pass the user's return address        }
        MOV     EDX,RaiseExceptObjProc          { has this been hooked? }
        TEST    EDX,EDX
        JZ      @@2

        PUSH    [EAX + 6 * 4]
        PUSH    [EAX + 5 * 4]
        PUSH    [EAX + 4 * 4]
        PUSH    [EAX + 3 * 4]
        PUSH    [EAX + 2 * 4]
        PUSH    [EAX + 1 * 4]                   { object }
        PUSH    [EAX + 0 * 4]                   { address }
        PUSH    7                               { how many of the above }
        PUSH    [EAX + 0 * 4]                   { the address goes here again }
        PUSH    EAX
        PUSH    EDX
        CALL    RaiseList
        MOV     ECX,EAX
        POP     EDX
        POP     EAX
        TEST    ECX,ECX
        JZ      @@1
        MOV     ECX,[ECX].TRaiseFrame.ExceptionRecord
@@1:    PUSH    ECX
        PUSH    cNonContinuable
        PUSH    cDelphiException
        MOV     EAX,ESP
        CALL    EDX
        ADD     ESP,12 * 4                      { Cleanup 12 DWORDS from the stack }
@@2:
        JMP     RaiseExceptionProc
end;
{$ENDIF STACK_BASED_EXCEPTIONS}

{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure _RaiseExcept(Obj: TObject);
begin
  _RaiseAtExcept(Obj, ReturnAddress);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}

{$I Unwind.inc}

procedure _RaiseAtExcept(const Obj: TObject; Address: Pointer);
var
  RaiseFramePtr: PRaiseFrame;
  ExceptionRecord: TExceptionRecord;
begin
  NotifyReRaise(Obj, Address);
  if RaiseExceptObjProc <> nil then
  begin
    ExceptionRecord.ExceptObject := Obj;
    TRaiseExceptObjProc(RaiseExceptObjProc)(@ExceptionRecord);
  end;
  RaiseFramePtr := AllocateRaiseFrame;
  RaiseFramePtr.ExceptObject := Obj;
  RaiseFramePtr.ExceptAddr := Address;
  RaiseFramePtr.UnwindException.exception_class := DelphiExceptionPersonality;
{$IFDEF SJLJ_BASED_EXCEPTIONS}
  RaiseFramePtr.UnwindException.private_1 := UIntPtr(Obj);
  RaiseFramePtr.UnwindException.private_2 := 0;
{$ENDIF SJLJ_BASED_EXCEPTIONS}
{$IFDEF ZCX_BASED_EXCEPTIONS}
  RaiseFramePtr.UnwindException.private_1 := 0; // UIntPtr(Obj);
  RaiseFramePtr.UnwindException.private_2 := 0;
{$ENDIF ZCX_BASED_EXCEPTIONS}
{$IFDEF LINUX64}
  RaiseFramePtr.UnwindException.exception_cleanup := nil;
{$ENDIF LINUX64}
  LinkRaiseFrame(RaiseFramePtr);
  _Unwind_RaiseException(RaiseFramePtr.UnwindException);
  _UnhandledException;
end;

procedure _RaiseExcept(const Obj: TObject);
begin
  _RaiseAtExcept(Obj, ReturnAddress);
end;

const
  // Heavily borrowed from llvm/examples/ExceptionDemo/ExceptionDemo.cpp
  // DWARF Constants
  DW_EH_PE_absptr   = $00;
  DW_EH_PE_uleb128  = $01;
  DW_EH_PE_udata2   = $02;
  DW_EH_PE_udata4   = $03;
  DW_EH_PE_udata8   = $04;
  DW_EH_PE_sleb128  = $09;
  DW_EH_PE_sdata2   = $0A;
  DW_EH_PE_sdata4   = $0B;
  DW_EH_PE_sdata8   = $0C;
  DW_EH_PE_pcrel    = $10;
  DW_EH_PE_textrel  = $20;
  DW_EH_PE_datarel  = $30;
  DW_EH_PE_funcrel  = $40;
  DW_EH_PE_aligned  = $50;
  DW_EH_PE_indirect = $80;
  DW_EH_PE_omit     = $FF;

type
  PUIntPtr = ^UIntPtr;
  PIntPtr = ^IntPtr;
  PInt16 = ^Int16;
  PUInt16 = ^UInt16;
  PInt32 = ^Int32;
  PUInt32 = ^UInt32;
  TScanResults = record
    FTypeIndex: Int64;
    FActionRecord: PByte;
    FLanguageSpecificData: PByte;
    FLandingPad: UIntPtr;
    FAdjustedPtr: Pointer;
    FReason: _Unwind_Reason_Code;
  end;

/// Read a uleb128 encoded value and advance pointer
/// See Variable Length Data Appendix C in:
/// @link http://dwarfstd.org/Dwarf4.pdf @unlink
/// @param data reference variable holding memory pointer to decode from
/// @returns decoded value
function ReadULEB128(var Data: PByte): UIntPtr;
var
  Shift: UIntPtr;
  B: Byte;
begin
  Result := 0;
  Shift := 0;
  repeat
    B := Data^; Inc(Data);
    Result := Result or UIntPtr(B and $7F) shl Shift;
    Inc(Shift, 7);
  until B and $80 = 0;
end;

/// Read a sleb128 encoded value and advance pointer
/// See Variable Length Data Applendix C in:
/// @link http://dwarfstd.org/Dwarf4.pdf @unlink
/// @param data reference variable holding memory pointer to decode from
/// @returns decoded value
function ReadSLEB128(var Data: PByte): IntPtr;
var
  Shift: UIntPtr;
  B: Byte;
  Res: UIntPtr;
begin
  Res := 0;
  Shift := 0;
  repeat
    B := Data^; Inc(Data);
    Res := Res or UIntPtr(B and $7F) shl Shift;
    Inc(Shift, 7);
  until B and $80 = 0;
  if (B and $40 <> 0) and (Shift < (SizeOf(Res) shl 3)) then
    Res := Res or UIntPtr(-1) shl Shift;
  Result := IntPtr(Res);
end;

/// Read a pointer encoded value and advance pointer
/// See Variable Length Data in:
/// @link http://dwarfstd.org/Dwarf3.pdf @unlink
/// @param data reference variable holding memory pointer to decode from
/// @param encoding dwarf encoding type
/// @returns decoded value
function ReadEncodedPointer(var Data: PByte; Encoding: UInt8): UIntPtr;
var
  P: PByte;
begin
  Result := 0;
  if Encoding = DW_EH_PE_omit then
    Exit;
  P := Data;
  // first get value
  case Encoding and $0F of
    DW_EH_PE_absptr:
      begin
        Result := PUIntPtr(P)^;
        Inc(P, SizeOf(UIntPtr));
      end;
    DW_EH_PE_uleb128:
      Result := ReadULEB128(P);
    DW_EH_PE_sleb128:
      Result := UIntPtr(ReadSLEB128(P));
    DW_EH_PE_udata2:
      begin
        Result := PUInt16(P)^;
        Inc(P, SizeOf(UInt16));
      end;
    DW_EH_PE_udata4:
      begin
        Result := PUInt32(P)^;
        Inc(P, SizeOf(UInt32));
      end;
    DW_EH_PE_udata8:
      begin
        Result := UIntPtr(PUInt64(P)^);
        Inc(P, SizeOf(UInt64));
      end;
    DW_EH_PE_sdata2:
      begin
        Result := UIntPtr(PInt16(P)^);
        Inc(P, SizeOf(Int16));
      end;
    DW_EH_PE_sdata4:
      begin
        Result := UIntPtr(PInt32(P)^);
        Inc(P, SizeOf(Int32));
      end;
    DW_EH_PE_sdata8:
      begin
        Result := UIntPtr(PInt64(P)^);
        Inc(P, SizeOf(Int64));
      end;
    else
      Halt;
  end;
  // then add relative offset
  case Encoding and $70 of
    DW_EH_PE_absptr: begin end;
    DW_EH_PE_pcrel:
      if Result <> 0 then
        Result := Result + UIntPtr(Data);
    DW_EH_PE_textrel,
    DW_EH_PE_datarel,
    DW_EH_PE_funcrel,
    DW_EH_PE_aligned: begin end;
  else
    Halt;
  end;
  // then apply indirection
  if (Result <> 0) and (Encoding and DW_EH_PE_indirect <> 0) then
    Result := PUIntPtr(Result)^;
  Data := P;
end;

{$IF Defined(CPUARM) and not Defined(LINUX32)}
{$IF (Defined(ZCX_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS))}
function GetCXXClassName(const P: UIntPtr): _PAnsiChar; cdecl;
  external librtlhelpername name 'get_cxx_class_name';
{$ENDIF ZCX_BASED_EXCEPTIONS or SJLJ_BASED_EXCEPTIONS}
{$ENDIF CPUARM}

{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
function isDelphiType(TypeID: UIntPtr): Boolean;
var
  P, Q: PByte;
begin
  if TypeID = 0 then
    Exit(False);
  P := PByte(TypeID);
  Q := P - sizeof(UIntPtr);
  Result := (UIntPtr(P) = PUIntPtr(Q)^) and (TTypeKind(PByte(P)^) = tkClass);
end;
{$ENDIF}

function GetShimTypeInfo(TypeIndex: UInt64; ClassInfo: PByte; TypeEncoding: UInt8;
  out OnClass: TClass; out cxxName: _PAnsiChar): Boolean;
type
  PClass = ^TClass;
  {$POINTERMATH ON}
  PCardinal = ^Cardinal;
  {$POINTERMATH OFF}
var
  P: UIntPtr;
begin
  OnClass := nil;
  cxxName := nil;
  Result := False;
  if ClassInfo = nil then
    Halt;
  case TypeEncoding and $0F of
    DW_EH_PE_absptr: TypeIndex := TypeIndex * SizeOf(Pointer);
    DW_EH_PE_udata2,
    DW_EH_PE_sdata2: TypeIndex := TypeIndex * 2;
    DW_EH_PE_udata4,
    DW_EH_PE_sdata4: TypeIndex := TypeIndex * 4;
    DW_EH_PE_udata8,
    DW_EH_PE_sdata8: TypeIndex := TypeIndex * 8;
  else
    // this should not happen.   Indicates corrupted eh_table.
    Halt;
  end;
  Dec(ClassInfo, TypeIndex);
{$IF Defined(CPUARM32) and (Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS))}
  P := UintPtr(ClassInfo);
  if PCardinal(P)^ <> 0 then
  begin
    P := PCardinal((P + PCardinal(P)^) )^;
{$ELSE}
  P := ReadEncodedPointer(ClassInfo, TypeEncoding);
  if P <> 0 then
  begin
{$ENDIF}
    Result := True;
    if isDelphiType(PUIntPtr(P + (vmtTypeInfo - vmtSelfPtr))^) then
      OnClass := PClass(P)^ //Delphi native way
    else
    begin
      {$IF Defined(CPUARM) and (Defined(ZCX_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)) and not Defined(LINUX32)}
      cxxName := GetCXXClassName(P);
      {$ENDIF}
      if cxxName = nil then
        OnClass := PClass(P)^; //Delphi native way
    end;
  end;
end;

{$IF Defined(ZCX_BASED_EXCEPTIONS)}
{$IF Defined(LINUX)}
// Use libgcc_s
{$ELSEIF Defined(ANDROID)}
function _Unwind_GetLanguageSpecificData(context: PUnwind_Context): Pointer;
type
  {$POINTERMATH ON}
  PUInt32     = ^UInt32;
  {$POINTERMATH OFF}
var
  ucbp: PUnwind_Exception;
  ptr: PUInt32;
begin
  ucbp := PUnwind_Exception(_Unwind_GetGR (context, UNWIND_POINTER_REG));
  ptr := PUInt32(ucbp.ehtp);
  Inc(ptr, 1); // Skip personality
  Inc(ptr, ((ptr^ shr 24) and $FF + 1));                                                    
  Result := Pointer(ptr);
end;
exports _Unwind_GetLanguageSpecificData;

function _Unwind_GetRegionStart(context: PUnwind_Context): UIntPtr;
var
  ucbp: PUnwind_Exception;
begin
  ucbp := PUnwind_Exception(_Unwind_GetGR (context, UNWIND_POINTER_REG));
  Result := ucbp.fnstart;
end;
exports _Unwind_GetRegionStart;
{$ELSE }
{$MESSAGE ERROR 'Unknown Platform'}
{$ENDIF}
{$ENDIF Defined(ZCX_BASED_EXCEPTIONS)}

function CanHandleException(const Exception: TObject; HandlerType: TClass): Boolean; overload;
var
  InstClass: TClass;
  HandlerSize: Integer;
  HandlerName: _PShortStr;
begin
  InstClass := Exception.ClassType;
  HandlerSize := HandlerType.InstanceSize;
  HandlerName := _PShortStr(PPointer(PByte(HandlerType) + vmtClassName)^);
  repeat
    if (InstClass.InstanceSize = HandlerSize) and
      (PByte(PPointer(PByte(InstClass) + vmtClassName)^)^ = PByte(HandlerName)^) and
      (_AStrCmp(@_PShortStr(PPointer(PByte(InstClass) + vmtClassName)^)^[1], @HandlerName^[1], PByte(HandlerName)^) = 0) then
        Exit(True);
    InstClass := InstClass.ClassParent;
  until InstClass = nil;
  Result := False;
end;

function GetMangledClassName(C: TClass) : _ShortStr;
var
  LClassInfo: Pointer;
  S, RR: _ShortStr;
  Count, Start: Integer;

begin
  Result := 'N';

  LClassInfo := C.ClassInfo;
  if LClassInfo <> nil then
  begin
    S := PClassData(PByte(LClassInfo) + 2 + PByte(PByte(LClassInfo) + 1)^).UnitName;
    if S[1] = '@' then
      S := Copy(S, 2, Pos(_ShortStr(':'), S) - 2);
    // 1 based string system use
    Count := 1;
    Start := Count;
    while (Count <= Length(S)) do
    begin
      if S[Count] = '.' then
      begin
        RR := Copy(S, Start, Count - Start);
        Result := Result + _Str0Long(Length(RR)) + RR;
        Inc(Count);
        Start := Count;
      end
      else
        Inc(Count);
    end;
    if Start < Length(S) then
    begin
      RR := Copy(S, Start, MAXINT);
      Result := Result + _Str0Long(Length(RR)) + RR;
    end;
  end;

  S := _PShortStr(PPointer(PByte(C) + vmtClassName)^)^;
  Result := Result + _Str0Long(Length(S)) + S + 'E';
end;

function CanHandleException(const Exception: TObject; cxxName: _PAnsiChar): Boolean; overload;

  function _AStrIEqual(const Left, Right: _PAnsiChr; Len: NativeInt): Boolean;
  var
    L, R: PByte;
  begin
    L := PByte(Left);
    R := PByte(Right);

    while len > 0 do
    begin
      if L^ <> R^ then
      begin
        if ((L^ or $20) <> (R^ or $20)) or (L^ > $80) then
          Exit(False);
      end;
      Inc(L);
      Inc(R);
      Dec(len);
    end;
    Result := True;
  end;

var
  InstClass: TClass;
  InstMangledName: _ShortStr;
  cxxNameLength: Integer;
begin
  Result := False;
  if cxxName = nil then
    exit;
  // Delphi object has "N6System8Sysutils6EAbortE"
  if cxxName^ <> 'N' then
    exit;

  cxxNameLength := _PCharLen(cxxName);
  InstClass := Exception.ClassType;

  repeat
    InstMangledName := GetMangledClassName(InstClass);
    if (Length(InstMangledName) = cxxNameLength) and
      _AStrIEqual(@InstMangledName[1], cxxName, cxxNameLength) then
        Exit(True);
    InstClass := InstClass.ClassParent;
  until InstClass = nil;
end;

function ScanEHTable(Actions: _Unwind_Action; DelphiException: Boolean; var UnwindException: _Unwind_Exception;
  Context: PUnwind_Context): TScanResults;
var
  LSDA, ClassInfo, CallSiteTableStart,
  CallSiteTableEnd, ActionTableStart, CallSitePtr,
  Action, ActionRecord: PByte;
  OnClass: TClass;
  IP, ClassInfoOffset: UIntPtr;
  Temp: PByte;
{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
  lpStart: PByte;
  FuncStart,
  Start, Length: UIntPtr;
  IpOffset: UIntPtr;
  CallSiteEncoding: UInt8;
{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
  LandingPad, ActionEntry: UIntPtr;
  lpStartEncoding, ttypeEncoding: UInt8;
  ttypeIndex, ActionOffset: Int64;
  CallSiteTableLength: UInt32;
  RaiseFrame: PRaiseFrame;
  cxxName: _PAnsiChar;
  HasFilter: Boolean;
begin
  FillChar(Result, SizeOf(Result), 0);
  Result.FReason := _URC_FATAL_PHASE1_ERROR;
  // Do some consistency checking
  if Actions and _UA_SEARCH_PHASE <> 0 then
  begin
    // Check for phase 1 errors
    if Actions and (_UA_CLEANUP_PHASE or _UA_HANDLER_FRAME or _UA_FORCE_UNWIND) <> 0 then
      Exit;
  end else if Actions and _UA_CLEANUP_PHASE <> 0 then
  begin
    if Actions and (_UA_HANDLER_FRAME or _UA_FORCE_UNWIND) = (_UA_HANDLER_FRAME or _UA_FORCE_UNWIND) then
    begin
      Result.FReason := _URC_FATAL_PHASE2_ERROR;
      Exit;
    end
  end else
    Exit;
  LSDA := PByte(_Unwind_GetLanguageSpecificData(Context));
  if LSDA = nil then
  begin
    Result.FReason := _URC_CONTINUE_UNWIND;
    Exit;
  end;
  Result.FLanguageSpecificData := LSDA;
  // Get the current instruction pointer and offset it before next
  // instruction in the current frame which threw the exception.
  IP := _Unwind_GetIP(Context) - 1;
{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
  // Get beginning current frame's code (as defined by the
  // emitted dwarf code)
  FuncStart := _Unwind_GetRegionStart(Context);
  IpOffset := IP - FuncStart;
{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
{$IFDEF SJLJ_BASED_EXCEPTIONS}
  // Under SjLj, _Unwind_GetRegionStart returns 0 always.
  // FuncStart is 0 always
//  FuncStart := 0; // Not used in ARM
  if IP = UIntPtr(-1) then
  begin
    Result.FReason := _URC_CONTINUE_UNWIND;
    Exit;
  end else if IP = 0 then
    Halt(1);
{$ENDIF SJLJ_BASED_EXCEPTIONS}
  ClassInfo := nil;
  lpStartEncoding := LSDA^; Inc(LSDA);
{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
  lpStart := PByte(ReadEncodedPointer(LSDA, lpStartEncoding));
  if lpStart = nil then
    lpStart := PByte(FuncStart);
{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
{$IFDEF SJLJ_BASED_EXCEPTIONS}
  ReadEncodedPointer(LSDA, lpStartEncoding); //  Discard lpStart for ARM
{$ENDIF SJLJ_BASED_EXCEPTIONS}
  ttypeEncoding := LSDA^; Inc(LSDA);
  if ttypeEncoding <> DW_EH_PE_omit then
  begin
    ClassInfoOffset := ReadULEB128(LSDA);
    ClassInfo := LSDA + ClassInfoOffset;
  end;
{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
  CallSiteEncoding := LSDA^;
{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
  Inc(LSDA);
  CallSiteTableLength := UInt32(ReadULEB128(LSDA));
  CallSiteTableStart := LSDA;
  CallSiteTableEnd := CallSiteTableStart + CallSiteTableLength;
  ActionTableStart := CallSiteTableEnd;
  CallSitePtr := CallSiteTableStart;
  while True do
  begin
{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
    Start := ReadEncodedPointer(CallSitePtr, CallSiteEncoding);
    Length := ReadEncodedPointer(CallSitePtr, CallSiteEncoding);
    LandingPad := ReadEncodedPointer(CallSitePtr, CallSiteEncoding);
{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
{$IFDEF SJLJ_BASED_EXCEPTIONS}
    LandingPad := ReadULEB128(CallSitePtr);
{$ENDIF SJLJ_BASED_EXCEPTIONS}
    ActionEntry := ReadULEB128(CallSitePtr);
{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
    if (Start <= IpOffset) and (IpOffset < (Start + Length)) then
{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
{$IFDEF SJLJ_BASED_EXCEPTIONS}
    Dec(IP);
    if IP = 0 then
{$ENDIF SJLJ_BASED_EXCEPTIONS}
    begin
{$IFDEF SJLJ_BASED_EXCEPTIONS}
      Inc(LandingPad);
{$ENDIF SJLJ_BASED_EXCEPTIONS}
      if LandingPad = 0 then
      begin
        Result.FReason := _URC_CONTINUE_UNWIND;
        Exit;
      end;
{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
      LandingPad := UIntPtr(lpStart) + LandingPad;
{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
      if ActionEntry = 0 then
      begin
        if (Actions and _UA_CLEANUP_PHASE <> 0) and (Actions and _UA_HANDLER_FRAME = 0) then
        begin
          Result.FTypeIndex := 0;
          Result.FLandingPad := LandingPad;
          Result.FReason := _URC_HANDLER_FOUND;
          Exit;
        end;
        Result.FReason := _URC_CONTINUE_UNWIND;
        Exit;
      end;
      Action := ActionTableStart + (ActionEntry - 1);
      while True do
      begin
        ActionRecord := Action;
        ttypeIndex := ReadSLEB128(Action);
        if ttypeIndex <> 0 then
        begin
          HasFilter := GetShimTypeInfo(UInt64(ttypeIndex), ClassInfo, ttypeEncoding, OnClass, cxxName);
          if (not HasFilter) or (not DelphiException) then
          begin
            // Found except (no "on" clause) catches everything, including foreign exceptions
            // If this is a type 1 search save state and return _URC_HANDLER_FOUND
            // If this is a type 2 search save state and return _URC_HANDLER_FOUND
            // If this is a type 3 search !_UA_FORCE_UNWIND, we should have found this in phase 1!
            // If this is a type 3 search _UA_FORCE_UNWIND, ignore handler and continue scan
            if (Actions and _UA_SEARCH_PHASE <> 0) or (Actions and _UA_HANDLER_FRAME <> 0) then
            begin
              Result.FTypeIndex := ttypeIndex;
              Result.FActionRecord := ActionRecord;
              Result.FLandingPad := LandingPad;
              Result.FAdjustedPtr := GetThrownObject(UnwindException);
              Result.FReason := _URC_HANDLER_FOUND;
              Exit;
            end else if (Actions and _UA_FORCE_UNWIND = 0) then
              Halt;
          end else if DelphiException then
          begin
            RaiseFrame := GetRaiseFrame(UnwindException);
            if (RaiseFrame = nil) or (RaiseFrame.ExceptObject = nil) then
              Halt;
            if ((OnClass <> nil) and CanHandleException(RaiseFrame.ExceptObject, OnClass)) or
               ((cxxName <> nil) and CanHandleException(RaiseFrame.ExceptObject, cxxName)) then
            begin
              // Found a matching handler
              // If this is a type 1 search save state and return _URC_HANDLER_FOUND
              // If this is a type 3 search and !_UA_FORCE_UNWIND, we should have found this in phase 1!
              // If this is a type 3 search and _UA_FORCE_UNWIND, ignore handler and continue scan
              if Actions and _UA_SEARCH_PHASE <> 0 then
              begin
                // Save state and return _URC_HANDLER_FOUND
                Result.FTypeIndex := ttypeIndex;
                Result.FActionRecord := ActionRecord;
                Result.FLandingPad := LandingPad;
                Result.FAdjustedPtr := GetThrownObject(UnwindException);
                Result.FReason := _URC_HANDLER_FOUND;
                Exit;
              end else if Actions and _UA_FORCE_UNWIND = 0 then
                // It looks like the exception table has changed
                //    on us.  Likely stack corruption!
                Halt;
            end;
          end else
          begin
            // For not-Delphi exception (C++ exception maybe) with no "on" clause.
            // TBD.
          end
        end else
        begin
          // Found a cleanup
          // If this is a type 1 search, ignore it and continue scan
          // If this is a type 2 search, ignore it and continue scan
          // If this is a type 3 search, save state and return _URC_HANDLER_FOUND
          if (Actions and _UA_CLEANUP_PHASE <> 0) and (Actions and _UA_HANDLER_FRAME = 0) then
          begin
            // Save state and return _URC_HANDLER_FOUND
            Result.FTypeIndex := ttypeIndex;
            Result.FActionRecord := ActionRecord;
            Result.FLandingPad := LandingPad;
            Result.FAdjustedPtr := GetThrownObject(UnwindException);
            Result.FReason := _URC_HANDLER_FOUND;
            Exit;
          end;
        end;
        Temp := Action;
        ActionOffset := ReadSLEB128(Temp);
        if ActionOffset = 0 then
        begin
          Result.FReason := _URC_CONTINUE_UNWIND;
          Exit;
        end;
        Inc(Action, ActionOffset);
      end;
{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
    end else if IpOffset < Start then
    begin
      Result.FReason := _URC_CONTINUE_UNWIND;
      Exit;
{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}
    end;
  end;
end;

procedure SetRegisters(var UnwindException: _Unwind_Exception; Context: PUnwind_Context; var Results: TScanResults);
begin
  _Unwind_SetGR(Context, 0, UIntPtr(@UnwindException));
{$IF Defined(CPUARM) or Defined(CPUX64)}
  _Unwind_SetGR(Context, 1, UIntPtr(Results.FTypeIndex));
{$ELSEIF Defined(CPUX86_LLVM) or Defined(CPUX86)}
  _Unwind_SetGR(Context, 2, UIntPtr(Results.FTypeIndex));
{$ELSE}
  {$MESSAGE ERROR 'Unknown Architecture'}
{$ENDIF}
  _Unwind_SetIP(Context, Results.FLandingPad);
end;

// The personality routine for DWARF exception information is based on the code from libc++abi

type
  TCPPExceptionDestructor = procedure(obj: UIntPtr);
  _CXA_EXCEPTION = packed record
{$IF Defined(LONGINT64) or ((not Defined(MACOS)) and Defined(CPUARM32) and (not Defined(SJLJ_BASED_EXCEPTIONS))) }
    referenceCount: NativeUInt;
{$ENDIF}
    exceptionType: UIntPtr;
    exceptionDestructor: TCPPExceptionDestructor;
    unexpectedHandler: UIntPtr;
    terminateHandler: UIntPtr;
    nextException: UIntPtr;
    handlerCount: Int32;

{$IF (not Defined(MACOS)) and Defined(CPUARM32) and (not Defined(SJLJ_BASED_EXCEPTIONS)) }
    nextPropagatingException: UIntPtr;
    propagationCount: Integer;
{$ELSE}
    handlerSwitchValue: Int32;
    actionRecord: UIntPtr;
    languageSpecificData: UIntPtr;
    catchTemp: UIntPtr;
    adjustedPtr: UIntPtr;
{$ENDIF}
{$IF not (Defined(LONGINT64) or ((not Defined(MACOS)) and Defined(CPUARM32) and (not Defined(SJLJ_BASED_EXCEPTIONS))))}
    referenceCount: NativeUInt;
{$ENDIF}
    unwindHeader: _Unwind_Exception;
  end;
  TCXA_EXCEPTION = _CXA_EXCEPTION;
  PCXA_EXCEPTION = ^TCXA_EXCEPTION;

{$IF Defined(MACOS) or (Defined(LINUX) and (Defined(CPUX86) or Defined(CPUX64)))}
{$I ex.inc}
{$ENDIF MACOS}

{$IF Defined(ANDROID) and Defined(CPUARM)}
// ZCX_BASED_EXCEPTIONS
{$I ex.android.arm.inc}
{$ELSEIF Defined(LINUX) and Defined(CPUARM)}
{$I ex.linux.arm.inc}
{$ENDIF ANDROID}

{$ENDIF !PC_MAPPED_EXCEPTIONS & !STACK_BASED_EXCEPTIONS & !TABLE_BASED_EXCEPTIONS & !SJLJ_BASED_EXCEPTIONS} // ZCX_BASED_EXCEPTIONS


{$IFDEF ZCX_BASED_EXCEPTIONS}
procedure _DestroyException(var UnwindException: _Unwind_Exception);
var
  CurRaiseFrame: PRaiseFrame;
  ExceptObject: TObject;
  ExceptAddr: Pointer;
  RaiseFramePtr: PRaiseFrame;
  OriginalFramePtr: PRaiseFrame;
begin
  // CurRaiseFrame^.ExceptObject is
  //     nil -> re-raised exception was thrown by another domain.
  //            Pop and destroy old frame on the top.
  // not nil -> re-raised exception was thrown by same domain.
  //            Pop and Destroy old frame on the 2nd.
  // CurRaiseFrame^.NextRaise is
  //     nil -> re-raised exception will be catched in another domain.
  //            Pop and destroy old frame on the top.
  // not nil -> re-raised exception will be catched in the same domain.
  //            Pop and Destroy old frame on the 2nd.
  // Pop and save top of exception object list
  CurRaiseFrame := PopRaiseFrame;
  ExceptObject := CurRaiseFrame^.ExceptObject;
  ExceptAddr := CurRaiseFrame^.ExceptAddr;
                                                       
//  CurRaiseFrame^.ExceptObject := nil;
  OriginalFramePtr := CurRaiseFrame;
  ReleaseRaiseFrame(CurRaiseFrame);

  if Assigned(RaiseListPtr) and Assigned(ExceptObject) then
  begin
    // Pop and release top of exception object list
    CurRaiseFrame := PopRaiseFrame;
    // Destroy exception object
    if CurRaiseFrame^.ExceptObject <> nil then
    begin
      CurRaiseFrame^.ExceptObject.Free;
      CurRaiseFrame^.ExceptObject := nil;
    end;
    ReleaseRaiseFrame(CurRaiseFrame);

    // Restore saved exception object list
    RaiseFramePtr := AllocateRaiseFrame;
    RaiseFramePtr.ExceptAddr := ExceptAddr;
    RaiseFramePtr.ExceptObject := ExceptObject;
                                                                              
    RaiseFramePtr.PrevRaise := OriginalFramePtr;
    LinkRaiseFrame(RaiseFramePtr);
  end;
end;

procedure _DoneExcept(var UnwindException: _Unwind_Exception);
var
  CurRaiseFrame: PRaiseFrame;
begin
  CurRaiseFrame := PopRaiseFrame;
  // Destroy exception object
  if CurRaiseFrame^.ExceptObject <> nil then
  begin
     CurRaiseFrame^.ExceptObject.Free;
     CurRaiseFrame^.ExceptObject := nil;
  end;
  if (CurRaiseFrame^.PrevRaise <> nil) and
     ((CurRaiseFrame^.PrevRaise)^.NextRaise = CurRaiseFrame) then
  begin
    (CurRaiseFrame^.PrevRaise)^.ExceptObject := nil;
    CurRaiseFrame^.PrevRaise := nil;
  end;
  ReleaseRaiseFrame(CurRaiseFrame);
end;

procedure _DoneExceptUCB(var UnwindException: _Unwind_Control_Block);
var
  Dummy: _Unwind_Exception;
begin
  _DoneExcept(Dummy);
end;

procedure _UnhandledException;
type
  TExceptProc = procedure (const Obj: TObject; Addr: Pointer);
var
  ExceptionObject: TObject;
  ExceptionAddress: Pointer;
begin
  ExceptionObject := ExceptObject;
  ExceptionAddress := ExceptAddr;
  NotifyUnhandled(ExceptionObject, ExceptionAddress);
  if Assigned(ExceptProc) then
    TExceptProc(ExceptProc)(ExceptionObject, ExceptionAddress);
  RunErrorAt(217, ExceptionAddress); // reControlBreak
end;
{$ENDIF ZCX_BASED_EXCEPTIONS}

{$IFDEF PC_MAPPED_EXCEPTIONS}
{
  Used in the PC mapping exception implementation to handle exceptions in constructors.
}
procedure       _ClassHandleException;
asm
  {
  EAX = Ptr to TRaisedException
  EDX = self
  ECX = top flag
  }
        PUSH     ECX
{$IFDEF ALIGN_STACK}
        SUB      ESP, 8
{$ENDIF ALIGN_STACK}
        CALL     LinkException
{$IFDEF ALIGN_STACK}
        ADD      ESP, 8
{$ENDIF ALIGN_STACK}
        MOV      EAX,EDX
        POP      EDX
        TEST     DL, DL
        JE       _RaiseAgain
        MOV      ECX,[EAX]
        MOV      DL,$81
{$IFDEF ALIGN_STACK}
        SUB      ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH     EAX
        CALL     DWORD PTR [ECX] + VMTOFFSET TObject.Destroy
        POP      EAX
{$IFDEF ALIGN_STACK}
        SUB      ESP, 4
{$ENDIF ALIGN_STACK}
        CALL     _ClassDestroy
{$IFDEF ALIGN_STACK}
        ADD      ESP, 12
{$ENDIF ALIGN_STACK}
        JMP      _RaiseAgain
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}

                                                               
procedure       _RaiseAgain;
{$IFDEF PC_MAPPED_EXCEPTIONS}
asm
{$IFDEF ALIGN_STACK}
        SUB      ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    CurrentException
{$IFDEF ALIGN_STACK}
        ADD      ESP, 12
{$ENDIF ALIGN_STACK}
// The following notifies the debugger of a reraise of exceptions.  This will
// be supported in a later release, but is disabled for now.
//        PUSH    EAX
//        MOV     EDX, [EAX].TRaisedException.ExceptionAddr
//        MOV     EAX, [EAX].TRaisedException.ExceptObject
//        CALL    NotifyReRaise                   { Tell the debugger }
//        POP     EAX
        TEST    [EAX].TRaisedException.Flags, excIsBeingHandled
        JZ      @@DoIt
        OR      [EAX].TRaisedException.Flags, excIsBeingReRaised
@@DoIt:
        PUSH    EAX
{$IFDEF ALIGN_STACK}
        SUB      ESP, 8
{$ENDIF ALIGN_STACK}
        CALL    UnlinkException
{$IFDEF ALIGN_STACK}
        ADD      ESP, 8
{$ENDIF ALIGN_STACK}
        POP     EAX
        MOV     EDX, [ESP]                      { Get the user's addr }
        JMP     SysRaiseException
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF STACK_BASED_EXCEPTIONS}
asm
        { ->    [ESP        ] return address to user program }
        {       [ESP+ 4     ] raise list entry (4 dwords)    }
        {       [ESP+ 4+ 4*4] saved topmost frame            }
        {       [ESP+ 4+ 5*4] saved registers (4 dwords)     }
        {       [ESP+ 4+ 9*4] return address to OS           }
        { ->    [ESP+ 4+10*4] excPtr: PExceptionRecord       }
        {       [ESP+ 8+10*4] errPtr: PExcFrame              }

        { Point the error handler of the exception frame to something harmless }

        MOV     EAX,[ESP+8+10*4]
        MOV     [EAX].TExcFrame.desc,offset @@exit

        { Pop the RaiseList }

        CALL    SysInit.@GetTLS
        MOV     EDX,[EAX].RaiseListPtr
        MOV     ECX,[EDX].TRaiseFrame.NextRaise
        MOV     [EAX].RaiseListPtr,ECX

        { Destroy any objects created for non-delphi exceptions }

        MOV     EAX,[EDX].TRaiseFrame.ExceptionRecord
        AND     [EAX].TExceptionRecord.ExceptionFlags,NOT cUnwinding
        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiException
        JE      @@delphiException
        MOV     EAX,[EDX].TRaiseFrame.ExceptObject
{$IFDEF AUTOREFCOUNT}
        OR      EAX,EAX
        JE      @@Notify
        MOV     ECX,[EAX]
        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjRelease
{$ELSE}
        CALL    TObject.Free
{$ENDIF}
@@Notify:
        CALL    NotifyReRaise

@@delphiException:

        XOR     EAX,EAX
        ADD     ESP,5*4
        MOV     EDX,FS:[EAX]
        POP     ECX
        MOV     EDX,[EDX].TExcFrame.next
        MOV     [ECX].TExcFrame.next,EDX

        POP     EBP
        POP     EDI
        POP     ESI
        POP     EBX
@@exit:
        MOV     EAX,1
end;
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IF defined(TABLE_BASED_EXCEPTIONS) or
     defined(SJLJ_BASED_EXCEPTIONS)  or
     defined(ZCX_BASED_EXCEPTIONS) or
     defined(ZCX_BASED_EXCEPTIONS_MACOS) }
var
  CurRaiseFrame: PRaiseFrame;
  ExceptObject: TObject;
  ExceptAddr: Pointer;
begin
  CurRaiseFrame := RaiseListPtr;
  ExceptObject := CurRaiseFrame^.ExceptObject;
  ExceptAddr := CurRaiseFrame^.ExceptAddr;
  CurRaiseFrame^.ExceptObject := nil;
{$IFDEF TABLE_BASED_EXCEPTIONS}
  NotifyReRaise(ExceptObject, ExceptAddr);
{$ENDIF }
  _RaiseAtExcept(ExceptObject, ExceptAddr);
end;
{$ENDIF !PC_MAPPED_EXCEPTIONS & !STACK_BASED_EXCEPTIONS & !TABLE_BASED_EXCEPTIONS & !SJLJ_BASED_EXCEPTIONS}

{$IFDEF PC_MAPPED_EXCEPTIONS}
{
  This is implemented slow and dumb.  The theory is that it is rare
  to throw an exception past an except handler, and that the penalty
  can be particularly high here.  Partly it's done the dumb way for
  the sake of maintainability.  It could be inlined.
}
procedure       _DestroyException;
var
  Exc: PRaisedException;
  RefCount: Integer;
  ExcObj: Pointer;
  ExcAddr: Pointer;
begin
  asm
        CMP     ECX, UW_EXC_CLASS_BORLANDCPP
        JNE     @@notCPP
{$IFDEF ALIGN_STACK}
        SUB      ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    SysRaiseCPPException
{$IFDEF ALIGN_STACK}
        ADD      ESP, 12
{$ENDIF ALIGN_STACK}
@@notCPP:
    MOV     Exc, EAX
  end;

  if (Exc^.Flags and excIsBeingReRaised) = 0 then
  begin
    RefCount := Exc^.RefCount;
    ExcObj := Pointer(Exc^.ExceptObject);
    ExcAddr := Exc^.ExceptionAddr;
    Exc^.RefCount := 1;
    FreeException;
    _DoneExcept;
    Exc := AllocateException(ExcObj, ExcAddr);
    Exc^.RefCount := RefCount;
  end;

  Exc^.Flags := Exc^.Flags and not (excIsBeingReRaised or excIsBeingHandled);

  SysRaiseException(Exc);
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure _DestroyException(ExceptionPointers: PExceptionPointers; EstablisherFrame: NativeUInt);
var
  CurRaiseFrame: PRaiseFrame;
  ExceptObject: Pointer;
  ExceptAddr: Pointer;
  RaiseFramePtr: PRaiseFrame;
begin
  // CurRaiseFrame^.ExceptObject is
  //     nil -> re-raised exception was thrown by another
  //            domain (DLL / EXE). Pop and destroy old frame on the top.
  // not nil -> re-raised exception was thrown by same
  //            domain. Pop and Destroy old frame on the 2nd.
  // CurRaiseFrame^.NextRaise is
  //     nil -> re-raised exception will be catched in another
  //            domain (DLL / EXE). Pop and destroy old frame on the top.
  // not nil -> re-raised exception will be catched in the same
  //            domain. Pop and Destroy old frame on the 2nd.
  // Pop and save top of exception object list
  CurRaiseFrame := PopRaiseFrame;
  ExceptObject := CurRaiseFrame^.ExceptObject;
  ExceptAddr := CurRaiseFrame^.ExceptAddr;
  CurRaiseFrame^.ExceptObject := nil;
  ReleaseRaiseFrame(CurRaiseFrame);

  if Assigned(RaiseListPtr) and Assigned(ExceptObject) then
  begin
    // Pop and release top of exception object list
    CurRaiseFrame := PopRaiseFrame;
    // Destroy exception object
    if CurRaiseFrame^.ExceptObject <> nil then
       TObject(CurRaiseFrame^.ExceptObject).Free;
    ReleaseRaiseFrame(CurRaiseFrame);

    // Restore saved exception object list
    RaiseFramePtr := AllocateRaiseFrame;
    RaiseFramePtr.ExceptAddr := ExceptAddr;
    RaiseFramePtr.ExceptObject := ExceptObject;
    LinkRaiseFrame(RaiseFramePtr);
  end;
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$IF Defined(SJLJ_BASED_EXCEPTIONS)}
procedure _DestroyException(var UnwindException: _Unwind_Exception);
var
  CurRaiseFrame: PRaiseFrame;
  ExceptObject: TObject;
  ExceptAddr: Pointer;
  RaiseFramePtr: PRaiseFrame;
  OriginalFramePtr: PRaiseFrame;
begin
  // CurRaiseFrame^.ExceptObject is
  //     nil -> re-raised exception was thrown by another domain.
  //            Pop and destroy old frame on the top.
  // not nil -> re-raised exception was thrown by same domain.
  //            Pop and Destroy old frame on the 2nd.
  // CurRaiseFrame^.NextRaise is
  //     nil -> re-raised exception will be catched in another domain.
  //            Pop and destroy old frame on the top.
  // not nil -> re-raised exception will be catched in the same domain.
  //            Pop and Destroy old frame on the 2nd.
  // Pop and save top of exception object list
  CurRaiseFrame := PopRaiseFrame;
  ExceptObject := CurRaiseFrame^.ExceptObject;
  ExceptAddr := CurRaiseFrame^.ExceptAddr;
                                                       
//  CurRaiseFrame^.ExceptObject := nil;
  OriginalFramePtr := CurRaiseFrame;
  ReleaseRaiseFrame(CurRaiseFrame);

  if Assigned(RaiseListPtr) and Assigned(ExceptObject) then
  begin
    // Pop and release top of exception object list
    CurRaiseFrame := PopRaiseFrame;
    // Destroy exception object
    if CurRaiseFrame^.ExceptObject <> nil then
    begin
      CurRaiseFrame^.ExceptObject.Free;
      CurRaiseFrame^.ExceptObject := nil;
    end;
    ReleaseRaiseFrame(CurRaiseFrame);

    // Restore saved exception object list
    RaiseFramePtr := AllocateRaiseFrame;
    RaiseFramePtr.ExceptAddr := ExceptAddr;
    RaiseFramePtr.ExceptObject := ExceptObject;
                                                                              
    RaiseFramePtr.PrevRaise := OriginalFramePtr;
    LinkRaiseFrame(RaiseFramePtr);
  end;
end;
{$ENDIF SJLJ_BASED_EXCEPTIONS}
{$IF Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
procedure _DestroyException(var UnwindException: _Unwind_Exception);
var
  CurRaiseFrame: PRaiseFrame;
  ExceptObject: TObject;
  ExceptAddr: Pointer;
  RaiseFramePtr: PRaiseFrame;
  OriginalFramePtr: PRaiseFrame;
begin
  // CurRaiseFrame^.ExceptObject is
  //     nil -> re-raised exception was thrown by another domain.
  //            Pop and destroy old frame on the top.
  // not nil -> re-raised exception was thrown by same domain.
  //            Pop and Destroy old frame on the 2nd.
  // CurRaiseFrame^.NextRaise is
  //     nil -> re-raised exception will be catched in another domain.
  //            Pop and destroy old frame on the top.
  // not nil -> re-raised exception will be catched in the same domain.
  //            Pop and Destroy old frame on the 2nd.
  // Pop and save top of exception object list
  CurRaiseFrame := PopRaiseFrame;
  ExceptObject := CurRaiseFrame^.ExceptObject;
  ExceptAddr := CurRaiseFrame^.ExceptAddr;
                                                       
//  CurRaiseFrame^.ExceptObject := nil;
  OriginalFramePtr := CurRaiseFrame;
  ReleaseRaiseFrame(CurRaiseFrame);

  if Assigned(RaiseListPtr) and Assigned(ExceptObject) then
  begin
    // Pop and release top of exception object list
    CurRaiseFrame := PopRaiseFrame;
    // Destroy exception object
    if CurRaiseFrame^.ExceptObject <> nil then
    begin
      CurRaiseFrame^.ExceptObject.Free;
      CurRaiseFrame^.ExceptObject := nil;
    end;
    ReleaseRaiseFrame(CurRaiseFrame);

    // Restore saved exception object list
    RaiseFramePtr := AllocateRaiseFrame;
    RaiseFramePtr.ExceptAddr := ExceptAddr;
    RaiseFramePtr.ExceptObject := ExceptObject;
                                                                              
    RaiseFramePtr.PrevRaise := OriginalFramePtr;
    LinkRaiseFrame(RaiseFramePtr);
  end;
end;
{$ENDIF ZCX_BASED_EXCEPTIONS_MACOS}

                                                               
{$IFDEF PC_MAPPED_EXCEPTIONS}
procedure _DoneExcept;
asm //StackAlignSafe
{$IFDEF ALIGN_STACK}
        {
          We do one alignment call for the entire function as there are no
          other stack adjustments made in the function body.
        }
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    FreeException
        OR      EAX, EAX
        JE      @@Done
{$IFDEF AUTOREFCOUNT}
        MOV     ECX,[EAX]
        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjRelease
{$ELSE}
        CALL    TObject.Free
{$ENDIF}
@@Done:
        CALL    UnlinkException
        {
          Take a peek at the next exception object on the stack.
          If its EBP marker is at an address lower than our current
          EBP, then we know that it was orphaned when an exception was
          thrown from within the execution of a finally block.  We clean
          it up now, so that we won't leak exception records/objects.
        }
        CALL    CurrentException
        OR      EAX, EAX
        JE      @@Done2
        CMP     [EAX].TRaisedException.HandlerEBP, EBP
        JA      @@Done2
        CALL    FreeException
        OR      EAX, EAX
        JE      @@Done2
{$IFDEF AUTOREFCOUNT}
        MOV     ECX,[EAX]
        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjRelease
{$ELSE}
        CALL    TObject.Free
{$ENDIF}
@@Done2:
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF STACK_BASED_EXCEPTIONS}
procedure _DoneExcept;
asm
        { ->    [ESP+ 4+10*4] excPtr: PExceptionRecord       }
        {       [ESP+ 8+10*4] errPtr: PExcFrame              }

        { Pop the RaiseList }

        CALL    SysInit.@GetTLS
        MOV     EDX,[EAX].RaiseListPtr
        MOV     ECX,[EDX].TRaiseFrame.NextRaise
        MOV     [EAX].RaiseListPtr,ECX

        { Destroy exception object }

        MOV     EAX,[EDX].TRaiseFrame.ExceptObject
{$IFDEF AUTOREFCOUNT}
        OR      EAX,EAX
        JE      @@Done
        MOV     ECX,[EAX]
        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjRelease
{$ELSE}
        CALL    TObject.Free
{$ENDIF}
@@Done:

        POP     EDX
        MOV     ESP,[ESP+8+9*4]
        XOR     EAX,EAX
        POP     ECX
        MOV     FS:[EAX],ECX
        POP     EAX
        POP     EBP
        CALL    NotifyTerminate
        JMP     EDX
end;
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IF Defined(TABLE_BASED_EXCEPTIONS)}
procedure _DoneExcept;
var
  TargetIp: NativeUInt;
  CurRaiseFrame: PRaiseFrame;
begin
  CurRaiseFrame := PopRaiseFrame;
  // Destroy exception object
  if CurRaiseFrame^.ExceptObject <> nil then
     CurRaiseFrame^.ExceptObject.Free;
  ReleaseRaiseFrame(CurRaiseFrame);
  TargetIp := UIntPtr(ReturnAddress);
  NotifyTerminate(TargetIp);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$IF Defined(SJLJ_BASED_EXCEPTIONS)}
procedure _DoneExcept(var UnwindException: _Unwind_Exception);
var
  CurRaiseFrame: PRaiseFrame;
begin
  CurRaiseFrame := PopRaiseFrame;
  // Destroy exception object
  if CurRaiseFrame^.ExceptObject <> nil then
  begin
     CurRaiseFrame^.ExceptObject.Free;
     CurRaiseFrame^.ExceptObject := nil;
  end;
  if (CurRaiseFrame^.PrevRaise <> nil) and
     ((CurRaiseFrame^.PrevRaise)^.NextRaise = CurRaiseFrame) then
  begin
    (CurRaiseFrame^.PrevRaise)^.ExceptObject := nil;
    CurRaiseFrame^.PrevRaise := nil;
  end;
  ReleaseRaiseFrame(CurRaiseFrame);
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$IF Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
procedure _DoneExcept(var UnwindException: _Unwind_Exception);
var
  CurRaiseFrame: PRaiseFrame;
begin
  CurRaiseFrame := PopRaiseFrame;
  // Destroy exception object
  if CurRaiseFrame^.ExceptObject <> nil then
  begin
    CurRaiseFrame^.ExceptObject.Free;
    CurRaiseFrame^.ExceptObject := nil;
  end;
  if (CurRaiseFrame^.PrevRaise <> nil) and
     ((CurRaiseFrame^.PrevRaise)^.NextRaise = CurRaiseFrame) then
  begin
    (CurRaiseFrame^.PrevRaise)^.ExceptObject := nil;
    CurRaiseFrame^.PrevRaise := nil;
  end;
  ReleaseRaiseFrame(CurRaiseFrame);
end;
{$ENDIF ZCX_BASED_EXCEPTIONS_MACOS}

                                                                   
{$IFDEF STACK_BASED_EXCEPTIONS}
procedure _TryFinallyExit;
asm
        XOR     EDX,EDX
        MOV     ECX,[ESP+4].TExcFrame.desc
        MOV     EAX,[ESP+4].TExcFrame.next
        ADD     ECX,TExcDesc.instructions
        MOV     FS:[EDX],EAX
{$IFDEF ALIGN_STACK}
        SUB      ESP, 12
{$ENDIF ALIGN_STACK}
        CALL    ECX
{$IFDEF ALIGN_STACK}
        ADD      ESP, 12
{$ENDIF ALIGN_STACK}
@@1:    RET     12
end;
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
procedure _TryFinallyExit(EstablisherFrame: NativeUInt; TargetAddr: NativeUInt);
var
  Context: TContext;
begin
  RtlUnwindEx(EstablisherFrame, TargetAddr,
              nil, 0,         // PExceptionRecord, ReturnValue
              @Context, nil); // PContext, PUnwindHistoryTable
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IFDEF STACK_BASED_EXCEPTIONS}
procedure       MapToRunError(P: PExceptionRecord); stdcall;
const
  STATUS_ACCESS_VIOLATION         = $C0000005;
  STATUS_ARRAY_BOUNDS_EXCEEDED    = $C000008C;
  STATUS_FLOAT_DENORMAL_OPERAND   = $C000008D;
  STATUS_FLOAT_DIVIDE_BY_ZERO     = $C000008E;
  STATUS_FLOAT_INEXACT_RESULT     = $C000008F;
  STATUS_FLOAT_INVALID_OPERATION  = $C0000090;
  STATUS_FLOAT_OVERFLOW           = $C0000091;
  STATUS_FLOAT_STACK_CHECK        = $C0000092;
  STATUS_FLOAT_UNDERFLOW          = $C0000093;
  STATUS_INTEGER_DIVIDE_BY_ZERO   = $C0000094;
  STATUS_INTEGER_OVERFLOW         = $C0000095;
  STATUS_PRIVILEGED_INSTRUCTION   = $C0000096;
  STATUS_STACK_OVERFLOW           = $C00000FD;
  STATUS_CONTROL_C_EXIT           = $C000013A;
var
  ErrCode: Byte;
begin
  case P.ExceptionCode of
    STATUS_INTEGER_DIVIDE_BY_ZERO:  ErrCode := 200; { reDivByZero }
    STATUS_ARRAY_BOUNDS_EXCEEDED:   ErrCode := 201; { reRangeError }
    STATUS_FLOAT_OVERFLOW:          ErrCode := 205; { reOverflow }
    STATUS_FLOAT_INEXACT_RESULT,
    STATUS_FLOAT_INVALID_OPERATION,
    STATUS_FLOAT_STACK_CHECK:       ErrCode := 207; { reInvalidOp }
    STATUS_FLOAT_DIVIDE_BY_ZERO:    ErrCode := 200; { reZeroDivide }
    STATUS_INTEGER_OVERFLOW:        ErrCode := 215; { reIntOverflow}
    STATUS_FLOAT_UNDERFLOW,
    STATUS_FLOAT_DENORMAL_OPERAND:  ErrCode := 206; { reUnderflow }
    STATUS_ACCESS_VIOLATION:        ErrCode := 216; { reAccessViolation }
    STATUS_PRIVILEGED_INSTRUCTION:  ErrCode := 218; { rePrivInstruction }
    STATUS_CONTROL_C_EXIT:          ErrCode := 217; { reControlBreak }
    STATUS_STACK_OVERFLOW:          ErrCode := 202; { reStackOverflow }
  else                              ErrCode := 255;
  end;
  RunErrorAt(ErrCode, P.ExceptionAddress);
end;
{$ENDIF STACK_BASED_EXCEPTIONS}

                                                                     
{$IFDEF STACK_BASED_EXCEPTIONS}
procedure       _ExceptionHandler;
asm
        MOV     EAX,[ESP+4]

        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInProgress
        JNE     @@exit
{$IFDEF MSWINDOWS}
        CMP     BYTE PTR DebugHook,0
        JA      @@ExecuteHandler
        LEA     EAX,[ESP+4]
        PUSH    EAX
        CALL    UnhandledExceptionFilter
        CMP     EAX,EXCEPTION_CONTINUE_SEARCH
        //JNE     @@ExecuteHandler
        //JMP     @@exit
        JE      @@exit
{$ENDIF MSWINDOWS}

@@ExecuteHandler:
        MOV     EAX,[ESP+4]
        CLD
        CALL    _FpuInit
        MOV     EDX,[ESP+8]

        PUSH    0
        PUSH    EAX
        PUSH    offset @@returnAddress
        PUSH    EDX
        CALL    RtlUnwindProc

@@returnAddress:
        MOV     EBX,[ESP+4]
        CMP     [EBX].TExceptionRecord.ExceptionCode,cDelphiException
        MOV     EDX,[EBX].TExceptionRecord.ExceptAddr
        MOV     EAX,[EBX].TExceptionRecord.ExceptObject
        JE      @@DelphiException2

        MOV     EDX,ExceptObjProc
        TEST    EDX,EDX
        JE      MapToRunError
        MOV     EAX,EBX
        CALL    EDX
        TEST    EAX,EAX
        JE      MapToRunError
        MOV     EDX,[EBX].TExceptionRecord.ExceptionAddress

@@DelphiException2:

        CALL    NotifyUnhandled
        MOV     ECX,ExceptProc
        TEST    ECX,ECX
        JE      @@noExceptProc
        CALL    ECX             { call ExceptProc(ExceptObject, ExceptAddr) }

@@noExceptProc:
        MOV     ECX,[ESP+4]
        MOV     EAX,217
        MOV     EDX,[ECX].TExceptionRecord.ExceptAddr
        MOV     [ESP],EDX
        JMP     _RunError

@@exit:
        XOR     EAX,EAX
end;
{$ENDIF STACK_BASED_EXCEPTIONS}

                                                                                              
{$IFDEF STACK_BASED_EXCEPTIONS}
procedure  SetExceptionHandler(Context: PInitContext);
asm
        { ->    EAX   PInitContext
        { ->    [EBP-type(TExcFrame)] TExcFrame local (returned in EAX) }

        PUSH    EAX               { Save off Context pointer }
        XOR     EDX,EDX           { using [EDX] saves some space over [0] }
        LEA     EAX,[EBP-type(TExcFrame)]
        MOV     ECX,FS:[EDX]      { ECX := head of chain                  }
        MOV     FS:[EDX],EAX      { head of chain := @exRegRec            }

        MOV     [EAX].TExcFrame.next,ECX
{$IFDEF PIC}
        LEA     EDX,[EBX]._ExceptionHandler
        MOV     [EAX].TExcFrame.desc,EDX
{$ELSE}
        MOV     [EAX].TExcFrame.desc,offset _ExceptionHandler
{$ENDIF}
        MOV     [EAX].TExcFrame.hEBP,EBP
        POP     ECX               { Restore Context pointer }
        MOV     [ECX].TInitContext.ExcFrame,EAX
end;
{$ENDIF STACK_BASED_EXCEPTIONS}

                                                                                                
{$IFDEF STACK_BASED_EXCEPTIONS}
procedure       UnsetExceptionHandler(Context: PInitContext);
asm
        { ->    EAX   PInitContext }

        MOV     EAX,[EAX].TInitContext.ExcFrame
        XOR     EDX,EDX
        TEST    EAX,EAX
        JZ      @@exit

        MOV     ECX,FS:[EDX]    { ECX := head of chain          }
        CMP     EAX,ECX         { simple case: our record is first      }
        JNE     @@search
        MOV     EAX,[EAX]       { head of chain := exRegRec.next        }
        MOV     FS:[EDX],EAX
        JMP     @@exit

@@loop:
        MOV     ECX,[ECX]
@@search:
        CMP     ECX,-1          { at end of list?                       }
        JE      @@exit          { yes - didn't find it          }
        CMP     [ECX],EAX       { is it the next one on the list?       }
        JNE     @@loop          { no - look at next one on list }
@@unlink:                       { yes - unlink our record               }
        MOV     EAX,[EAX]       { get next record on list               }
        MOV     [ECX],EAX       { unlink our record                     }
@@exit:
end;
{$ENDIF STACK_BASED_EXCEPTIONS}


{ ----------------------------------------------------- }
{       Program Initialization and Finalization         }
{ ----------------------------------------------------- }

var
  InitContext: TInitContext;
{$IFDEF MSWINDOWS}
  DLLThreadContext: TInitContext;
{$ENDIF}

type
  TProc = procedure;

{$IF (defined(POSIX) and defined(CPUX86)) and defined(ASSEMBLER)}
procedure CallProc(Proc: Pointer; GOT: Cardinal);
asm
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EBX
        MOV     EBX,EDX
{$IFDEF LINUX}
        ADD     EAX,EBX
{$ENDIF LINUX}
        CALL    EAX
        POP     EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
end;
{$ENDIF POSIX and CPUX86 and ASSEMBLER}

procedure FinalizeUnits;
var
  Count: Integer;
  Table: PUnitEntryTable;
  P: Pointer;
begin
  if InitContext.InitTable = nil then
    exit;
  Count := InitContext.InitCount;
  Table := InitContext.InitTable^.UnitInfo;
{$IFDEF LINUX}
  Inc(PByte(Table), InitContext.Module^.GOT);
{$ENDIF}
  try
    while Count > 0 do
    begin
      Dec(Count);
      InitContext.InitCount := Count;
      P := Table^[Count].FInit;
      if Assigned(P) and Assigned(Pointer(P^)) then
      begin
{$IF defined(MSWINDOWS)}
        TProc(P)();
{$ELSEIF (defined(POSIX) and defined(CPUX86)) and defined(ASSEMBLER)}
        CallProc(P, InitContext.Module^.GOT);
{$ELSE}
        TProc(P)();
{$ENDIF}
      end;
    end;
  except
    FinalizeUnits;  { try to finalize the others }
    raise;
  end;
end;

{$IFDEF MSWINDOWS}
const
  errCaption: array[0..5] of _AnsiChr = ('E', 'r', 'r', 'o', 'r', #0);
{$ENDIF MSWINDOWS}

{***********************************************************}
{$IFDEF TRIAL_EDITION}
{
    This code is used as part of the timeout test for
    applications built with trial editions of the product.  It provides
    the current local time in a format native to the platform in question.

    The linker will generate a checksum of _InitUnitPrep that it will
    place into linked units.  The code generated for _InitUnitPrep must
    not contain fixups actually in the image, as this could alter the
    code at load time, invalidating the checksum.  Take great care to
    make sure that this code is entirely position independent on all
    platforms and circumstances to avoid a serious problem!
}
{$IFDEF MSWINDOWS}

function _InitUnitPrep: Int64;
var
  SystemTime: TSystemTime;
  FileTime: TFileTime;
  Days: Int64;
begin
  GetLocalTime(SystemTime);
  SystemTimeToFileTime(SystemTime, FileTime);

    // used to hack the result to force a failure for testing:
  Days := 1000000000 div 100;
  Days := Days * 3600;
  Days := Days * 24;
  Days := Days * 31;
  Days := 0;

  Result := Int64(FileTime) + Days;
//  Dec(InitContext.InitTable^.UnitCount);
end;
{$ENDIF}
{$IFDEF LINUX}

function _InitUnitPrep: Integer;
var
  Days: Integer;
begin
  Days := 0;    // used to hack the result to force a failure for testing
    Result := _time(nil) + Days;
end;
{$ENDIF}

resourcestring
{$IFDEF POSIX}
  SExpiredMsg =
  'This module was compiled with a trial version of Delphi.'+#10+
  'The trial period has expired.'+#10;
{$ENDIF}
{$IFDEF MSWINDOWS}
  SExpiredMsg =
  'This module was compiled with a trial version of Delphi.'+#13+#10+
  'The trial period has expired.'+#13+#10;
{$ENDIF}
var
  ExpiredMsg: _AnsiStr;

function LoadResStringA(ResStringRec: PResStringRec): _AnsiStr; forward;

procedure _Expired;
{$IFDEF MSWINDOWS}
var
  Dummy: Cardinal;
begin
  ExpiredMsg := LoadResStringA(@SExpiredMsg);
  if IsConsole then
    WriteFile(GetStdHandle(STD_ERROR_HANDLE), _PAnsiChr(ExpiredMsg), Length(ExpiredMsg), Dummy, nil)
  else
    MessageBoxA(0, _PAnsiChr(ExpiredMsg), errCaption, 0);
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  ExpiredMsg := LoadResStringA(@SExpiredMsg);
  __write(2, _PAnsiChr(ExpiredMsg), Length(ExpiredMsg));
{$ENDIF POSIX}
  ExpiredMsg := '';
  Halt(232);
end;

{$ENDIF} // TRIAL_EDITION

procedure InitUnits;
var
  Count, I: Integer;
  Table: PUnitEntryTable;
  P: Pointer;
begin
  if InitContext.InitTable = nil then
    exit;
  Count := InitContext.InitTable^.UnitCount;
  I := 0;
  Table := InitContext.InitTable^.UnitInfo;
{$IFDEF LINUX}
  Inc(PByte(Table), InitContext.Module^.GOT);
{$ENDIF}
  try
    while I < Count do
    begin
      P := Table^[I].Init;
      Inc(I);
      InitContext.InitCount := I;
      if Assigned(P) and Assigned(Pointer(P^)) then
      begin
{$IF defined(MSWINDOWS)}
        TProc(P)();
{$ELSEIF (defined(POSIX) and defined(CPUX86)) and defined(ASSEMBLER)}
        CallProc(P, InitContext.Module^.GOT);
{$ELSE}
        TProc(P)();
{$ENDIF}
      end;
    end;
  except
    FinalizeUnits;
    raise;
  end;
end;

procedure _PackageLoad(const Table : PackageInfo; Module: PLibModule);
var
  SavedContext: TInitContext;
begin
  SavedContext := InitContext;
  InitContext.DLLInitState := 0;
  InitContext.InitTable := Table;
  InitContext.InitCount := 0;
  InitContext.Module := Module;
  InitContext.OuterContext := @SavedContext;
  try
    InitUnits;
  finally
    InitContext := SavedContext;
  end;
end;


procedure _PackageUnload(const Table : PackageInfo; Module: PLibModule);
var
  SavedContext: TInitContext;
begin
  SavedContext := InitContext;
  InitContext.DLLInitState := 0;
  InitContext.InitTable := Table;
  InitContext.InitCount := Table^.UnitCount;
  InitContext.Module := Module;
  InitContext.OuterContext := @SavedContext;
  try
    FinalizeUnits;
  finally
    InitContext := SavedContext;
  end;
end;

{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}
procedure       _StartExe(InitTable: PackageInfo; Module: PLibModule; Argc: Integer; Argv: Pointer);
begin
  ArgCount := Argc;
  ArgValues := Argv;
{$ENDIF LINUX or MACOS or ANDROID}
{$IFDEF MSWINDOWS}
procedure       _StartExe(InitTable: PackageInfo; Module: PLibModule);
begin
  RaiseExceptionProc := @RaiseException;
  RTLUnwindProc := @RTLUnwind;
{$ENDIF MSWINDOWS}
  InitContext.InitTable := InitTable;
  InitContext.InitCount := 0;
  InitContext.Module := Module;
  MainInstance := Module.Instance;
{$IFDEF STACK_BASED_EXCEPTIONS}
  SetExceptionHandler(@InitContext);
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
  InitContext.ExcFrame := Pointer(1);
{$ENDIF TABLE_BASED_EXCEPTIONS}
  IsLibrary := False;
  InitUnits;
end;

{$IFDEF MSWINDOWS}
{$IFDEF CPUX86}
                                                             
procedure       _StartLib;
asm
        { ->    EAX InitTable   }
        {       EDX Module      }
        {       ECX InitTLS     }
        {       [ESP+4] DllProc }
        {       [EBP+8] HInst   }
        {       [EBP+12] Reason }
        {       [EBP-(type TExcFrame)] TExcFrame local }
        {       [EBP-(type TExcFrame)-(type TInitContext)] TInitContext local }

        { Push some desperately needed registers }

        PUSH    ECX
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        { Setup EBX to point to InitContext or DLLThreadContext based on Reason }

        MOV     EBX,offset InitContext
        CMP     DWORD PTR [EBP+12],2    // DLL_THEAD_ATTACH
        JL      @@notDLLThread
        MOV     EBX,offset DLLThreadContext

        { Save the current init context into the stackframe of our caller }

@@notDLLThread:
        MOV     ESI,EBX
        LEA     EDI,[EBP - (type TExcFrame) - (type TInitContext)]
        MOV     ECX,(type TInitContext)/4
        REP     MOVSD

        { Setup the current InitContext }

        POP     [EBX].TInitContext.DLLSaveEDI
        POP     [EBX].TInitContext.DLLSaveESI
        POP     [EBX].TInitContext.DLLSaveEBX
        MOV     [EBX].TInitContext.DLLSaveEBP,EBP
        MOV     [EBX].TInitContext.InitTable,EAX
        MOV     [EBX].TInitContext.Module,EDX
        LEA     ECX,[EBP - (type TExcFrame) - (type TInitContext)]
        MOV     [EBX].TInitContext.OuterContext,ECX

        { Get and save the current thread ID }

        CALL    GetCurrentThreadID
        MOV     [EBX].TInitContext.ThreadID,EAX
        MOV     EAX,[EBX].TInitContext.InitTable

        { Setup InitCount for FinalizeUnits call }

        XOR     ECX,ECX
        CMP     DWORD PTR [EBP+12],0    // Reason = DLL_PROCESS_DETACH?
        JNE     @@notShutDown
        MOV     ECX,[EAX].PackageInfoTable.UnitCount
@@notShutDown:
        MOV     [EBX].TInitContext.InitCount,ECX

        { Setup exception handler }

        MOV     EAX, offset RaiseException
        MOV     RaiseExceptionProc, EAX
        MOV     EAX, offset RTLUnwind
        MOV     RTLUnwindProc, EAX

        MOV     EAX,EBX                 // Pass address of current context
        CALL    SetExceptionHandler

        MOV     EAX,[EBP+12]
        INC     EAX
        MOV     [EBX].TInitContext.DLLInitState,AL
        DEC     EAX

        { Init any needed TLS }

        POP     ECX
        MOV     EDX,[ECX]
        MOV     [EBX].TInitContext.ExitProcessTLS,EDX
        JE      @@skipTLSproc
        CMP     AL,3                    // DLL_THREAD_DETACH
        JGE     @@skipTLSproc           // call ExitThreadTLS proc after DLLProc
        CALL    dword ptr [ECX+EAX*4]   // Call TlsProc[Reason]

@@skipTLSproc:

        { Call any DllProc }

        PUSH    ECX                     // TlsProc
        MOV     ECX,[ESP+8]             // DLLProc
        TEST    ECX,ECX
        JE      @@noDllProc
        MOV     EAX,[EBP+12]            // Reason
        MOV     EDX,[EBP+16]            // Reserved
        CALL    ECX

@@noDllProc:

        POP     ECX
        MOV     EAX, [EBP+12]
        CMP     AL,3                    // DLL_THREAD_DETACH
        JL      @@afterDLLproc          // don't free TLS on process shutdown
        CALL    dword ptr [ECX+EAX*4]   // Call TlsProc[Reason]

@@afterDLLProc:

        { Set IsLibrary if there was no exe yet }

        CMP     MainInstance,0
        JNE     @@haveExe
        MOV     IsLibrary,1
        FNSTCW  Default8087CW           // save host exe's FPU preferences

@@haveExe:

        MOV     EAX,[EBP+12]
        DEC     EAX
        JNE     _Halt0
        CALL    InitUnits
        RET     4
end;
{$ENDIF CPUX86}
{$ENDIF MSWINDOWS}

{$IFDEF MSWINDOWS}
{$IFDEF CPUX64}
                                                     
procedure _StartLib(ContextBuf: PInitContext; InitTable: PackageInfo; Module: PLibModule; TlsProc: Pointer; DllProc: TDllProcEx; AHInst: HINST; Reason: LongWord; Reserved: Pointer);
type
  TlsProcType = array[0..3] of procedure;
  PTlsProcType = ^TlsProcType;
const
  DLL_PROCESS_DETACH = 0;
  DLL_PROCESS_ATTACH = 1;
  DLL_THREAD_ATTACH  = 2;
  DLL_THREAD_DETACH  = 3;
var
  Context: PInitContext;
  TmpExitDllJmpBuf: __TExitDllJumpBuf;
begin
  Context := @InitContext;
  if Reason >= DLL_THREAD_ATTACH then
    Context := @DllThreadContext;
  TmpExitDllJmpBuf := ContextBuf.ExitDllJmpBuf;
  ContextBuf^ := Context^;
  Context.ExitDllJmpBuf := TmpExitDllJmpBuf;

  // Setup the current InitContext
  Context.InitTable := InitTable;
  Context.Module := Module;
  Context.OuterContext := ContextBuf;

  // Get and save the current thread ID
  Context.ThreadID := GetCurrentThreadID;

  // Setup InitCount for FinalizeUnits call
  if Reason = DLL_PROCESS_DETACH then
    Context.InitCount := Context.InitTable.UnitCount
  else
    Context.InitCount := 0;

  // Setup exception handler
  RaiseExceptionProc := @RaiseException;
  RTLUnwindProc := @RTLUnwind;
{$IFDEF STACK_BASED_EXCEPTIONS}
  SetExceptionHandler(@Context);
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
  Context^.ExcFrame := Pointer(1);
{$ENDIF TABLE_BASED_EXCEPTIONS}
  Context.DLLInitState := Reason + 1;

  // Init any needed TLS
  Context.ExitProcessTLS := PTlsProcType(TlsProc)^[DLL_PROCESS_DETACH];

  if (Reason = DLL_PROCESS_ATTACH) or (Reason = DLL_THREAD_ATTACH) then
    PTlsProcType(TlsProc)^[Reason]();

  // Call any DllProc
  if Assigned(DllProc) then
    DllProc(Reason, Reserved);

  // don't free TLS on process shutdown
  if Reason = DLL_THREAD_DETACH then
    PTlsProcType(TlsProc)^[Reason]();

  // Set IsLibrary if there was no exe yet
  if MainInstance = 0 then
  begin
    IsLibrary := True;
    DefaultMXCSR := GetMXCSR;
  end;
  if Reason = DLL_PROCESS_ATTACH then
    InitUnits
  else
    _Halt0;
end;
{$ENDIF CPUX64}
{$ENDIF MSWINDOWS}

{$IFDEF POSIX}
procedure _StartLib(Context: PInitContext; Module: PLibModule; DLLProc: TDLLProcEx);
var
  TempSwap: TInitContext;
begin
  // Context's register save fields are already initialized.
  // Save the current InitContext and activate the new Context by swapping them
  TempSwap := InitContext;
  InitContext := PInitContext(Context)^;
  PInitContext(Context)^ := TempSwap;

  InitContext.Module := Module;
  InitContext.OuterContext := Context;

  // DLLInitState is initialized by SysInit to 0 for shutdown, 1 for startup
  // Inc DLLInitState to distinguish from package init:
  // 0 for package, 1 for DLL shutdown, 2 for DLL startup

  Inc(InitContext.DLLInitState);

  if InitContext.DLLInitState = 1 then
  begin
    InitContext.InitTable := Module.InitTable;
    if Assigned(InitContext.InitTable) then
      InitContext.InitCount := InitContext.InitTable.UnitCount  // shutdown
  end
  else
  begin
    Module.InitTable := InitContext.InitTable;  // save for shutdown
    InitContext.InitCount := 0;  // startup
  end;

  if Assigned(DLLProc) then
    DLLProc(InitContext.DLLInitState-1,nil);

  if MainInstance = 0 then        { Set IsLibrary if there was no exe yet }
  begin
    IsLibrary := True;
{$IF defined(CPUX86) or defined(CPUX64)}
    Default8087CW := Get8087CW;
    DefaultMXCSR := GetMXCSR;
{$ENDIF CPUX86 or CPUX64}
  end;

  if InitContext.DLLInitState = 1 then
    _Halt0
  else
    InitUnits;
end;
{$ENDIF POSIX}


{ --------------------------------------------------------------------- }
{       Compiler helper for resource string and indirect pointers       }
{ --------------------------------------------------------------------- }

function LoadResStringA(ResStringRec: PResStringRec): _AnsiStr;
begin
  Result := _AnsiStr(LoadResString(ResStringRec));
end;

function LoadResStringW(ResStringRec: PResStringRec): _WideStr;
begin
  Result := _WideStr(LoadResString(ResStringRec));
end;

function LoadResStringU(ResStringRec: PResStringRec): UnicodeString;
begin
  Result := UnicodeString(LoadResString(ResStringRec));
end;

type
  _PResStringInitTableElem = ^_TResStringInitTableElem;
  _TResStringInitTableElem = record
    const // stringKind
      LString = 0;
      WString = 1;
      UString = 2;
    var
      variableAddress: Pointer;
      resStringAddress: PResStringRec;
      stringKind: NativeInt;
  end;
  _PResStringInitTable = ^_TResStringInitTable;
  _TResStringInitTable = record
    Count: NativeInt;
    Table: array[1..(MaxInt div SizeOf(_TResStringInitTableElem) - 2)] of _TResStringInitTableElem;
  end;
  {$NODEFINE _PResStringInitTableElem}
  {$NODEFINE _TResStringInitTableElem}
  {$NODEFINE _PResStringInitTable}
  {$NODEFINE _TResStringInitTable}

type
  _PResStringImportInitTableElem = ^_TResStringImportInitTableElem;
  _TResStringImportInitTableElem = record
    const // stringKind
      LString = 0;
      WString = 1;
      UString = 2;
    var
      variableAddress: Pointer;
      resStringIndirAddress: ^PResStringRec;
      stringKind: NativeInt;
  end;
  _PResStringImportInitTable = ^_TResStringImportInitTable;
  _TResStringImportInitTable = record
    Count: NativeInt;
    Table: array[1..(MaxInt div SizeOf(_TResStringImportInitTableElem) - 2)] of _TResStringImportInitTableElem;
  end;
  {$NODEFINE _PResStringImportInitTableElem}
  {$NODEFINE _TResStringImportInitTableElem}
  {$NODEFINE _PResStringImportInitTable}
  {$NODEFINE _TResStringImportInitTable}

{$IFDEF PUREPASCAL}
type
  _PImportInitTableElem = ^_TImportInitTableElem;
  _TImportInitTableElem = record
    variableAddress: Pointer;
    sourceIndirAddress: PPointer;
    soruceOffset: NativeInt;
  end;
  _PImportInitTable = ^_TImportInitTable;
  _TImportInitTable = record
    Count: NativeInt;
    Table: array[1..(MaxInt div SizeOf(_TImportInitTableElem) - 2)] of _TImportInitTableElem;
  end;
  {$NODEFINE _PImportInitTableElem}
  {$NODEFINE _TImportInitTableElem}
  {$NODEFINE _PImportInitTable}
  {$NODEFINE _TImportInitTable}
{$ENDIF}

type
  _PWideStringInitTableElem = ^_TWideStringInitTableElem;
  _TWideStringInitTableElem = record
    variableAddress: Pointer;
    stringAddress: Pointer;
  end;
  _PWideStringInitTable = ^_TWideStringInitTable;
  _TWideStringInitTable = record
    Count: NativeInt;
    Table: array[1..(MaxInt div SizeOf(_TWideStringInitTableElem) - 2)] of _TWideStringInitTableElem;
  end;
  {$NODEFINE _PWideStringInitTableElem}
  {$NODEFINE _TWideStringInitTableElem}
  {$NODEFINE _PWideStringInitTable}
  {$NODEFINE _TWideStringInitTable}

                                                                   
                                                   
//procedure _InitResStrings(InitTable: _PResStringInitTable);
procedure _InitResStrings(InitTable: Pointer);
{$IFDEF PUREPASCAL}
var
  I: Integer;
  P: _PResStringInitTableElem;
begin
  for I := 1 to _PResStringInitTable(InitTable)^.Count do
  begin
    P := @_PResStringInitTable(InitTable)^.Table[I];
    case P^.stringKind of
      _TResStringInitTableElem.LString:
        _PAnsiStr(P^.variableAddress)^ := LoadResStringA(P^.resStringAddress);
      _TResStringInitTableElem.WString:
        _PWideStr(P^.variableAddress)^ := LoadResStringW(P^.resStringAddress);
      _TResStringInitTableElem.UString:
        PUnicodeString(P^.variableAddress)^ := LoadResStringU(P^.resStringAddress);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to init table               }
        {                 record                            }
        {                   cnt: Integer;                   }
        {                   tab: array [1..cnt] record      }
        {                      variableAddress: Pointer;    }
        {                      resStringAddress: Pointer;   }
        {                      stringKind: (LString, WString, UString) as Int32; }
        {                   end;                            }
        {                 end;                              }
        { EBX = caller's GOT for PIC callers, 0 for non-PIC }

{$IFDEF MSWINDOWS}
        PUSH    EBX
        XOR     EBX,EBX
{$ENDIF}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDI
        PUSH    ESI
        MOV     EDI,[EBX+EAX]     // EDI := initTable.cnt
        LEA     ESI,[EBX+EAX+4]   // ESI := @initTable.tab
@@loop:
        MOV     EAX,[ESI+4]       // EAX := initTable.tab[i].resStringAddress
        ADD     EAX,EBX
        MOV     EDX,[ESI]         // EDX := initTable.tab[i].variableAddress
        ADD     EDX,EBX
        MOV     ECX,[ESI+8]       // ECX := initTable.tab[i].stringKind

        // Handle appropriate string kind.
        TEST    ECX,ECX
        JZ      @@lstring
        DEC     ECX
        JZ      @@wstring
        DEC     ECX
        JZ      @@ustring
        INT     3

@@lstring:
        CALL    LoadResStringA
        JMP     @@doneLoad

@@wstring:
        CALL    LoadResStringW
        JMP     @@doneLoad

@@ustring:
        CALL    LoadResStringU

@@doneLoad:
        ADD     ESI,12
        DEC     EDI
        JNZ     @@loop

        POP     ESI
        POP     EDI
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
{$IFDEF MSWINDOWS}
        POP     EBX
{$ENDIF}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

                                                                         
                                                         
//procedure _InitResStringImports(InitTable: _PResStringImportInitTable);
procedure _InitResStringImports(InitTable: Pointer);
{$IFDEF PUREPASCAL}
var
  I: Integer;
  P: _PResStringImportInitTableElem;
begin
  for I := 1 to _PResStringImportInitTable(InitTable)^.Count do
  begin
    P := @_PResStringImportInitTable(InitTable)^.Table[I];
    case P^.stringKind of
      _TResStringImportInitTableElem.LString:
        _PAnsiStr(P^.variableAddress)^ := LoadResStringA(P^.resStringIndirAddress^);
      _TResStringImportInitTableElem.WString:
        _PWideStr(P^.variableAddress)^ := LoadResStringW(P^.resStringIndirAddress^);
      _TResStringImportInitTableElem.UString:
        PUnicodeString(P^.variableAddress)^ := LoadResStringU(P^.resStringIndirAddress^);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to init table               }
        {                 record                            }
        {                   cnt: Integer;                   }
        {                   tab: array [1..cnt] record      }
        {                      variableAddress: Pointer;    }
        {                      resStringAddress: ^Pointer; *** note indirection  }
        {                      stringKind: (LString, WString, UString) as Int32; }
        {                   end;                            }
        {                 end;                              }
        { EBX = caller's GOT for PIC callers, 0 for non-PIC }

{$IFDEF MSWINDOWS}
        PUSH    EBX
        XOR     EBX,EBX
{$ENDIF}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDI
        PUSH    ESI
        MOV     EDI,[EBX+EAX]     // EDI := initTable.cnt
        LEA     ESI,[EBX+EAX+4]   // ESI := @initTable.tab
@@loop:
        MOV     EAX,[ESI+4]       // EAX := initTable.tab[i].resStringAddress
        MOV     EAX,[EBX+EAX]     // EAX := EAX^ (to do indirection)
        MOV     EDX,[ESI]         // EDX := initTable.tab[i].variableAddress
{$IFNDEF MACOS}
        ADD     EDX,EBX
{$ENDIF MACOS}
        MOV     ECX,[ESI+8]       // ECX := initTable.tab[i].stringKind

        // Handle appropriate string kind.
        TEST    ECX,ECX
        JZ      @@lstring
        DEC     ECX
        JZ      @@wstring
        DEC     ECX
        JZ      @@ustring
        INT     3

@@lstring:
        CALL    LoadResStringA
        JMP     @@doneLoad

@@wstring:
        CALL    LoadResStringW
        JMP     @@doneLoad

@@ustring:
        CALL    LoadResStringU

@@doneLoad:
        ADD     ESI,12
        DEC     EDI
        JNZ     @@loop

        POP     ESI
        POP     EDI
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
{$IFDEF MSWINDOWS}
        POP     EBX
{$ENDIF}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

                                                                
                                                
//procedure _InitImports(InitTable: _PImportInitTable);
procedure _InitImports(InitTable: Pointer);
{$IFDEF PUREPASCAL}
var
  I: Integer;
  P: _PImportInitTableElem;
begin
  for I := 1 to _PImportInitTable(InitTable)^.Count do
  begin
    P := @_PImportInitTable(InitTable)^.Table[I];
    PPointer(P^.variableAddress)^ := Pointer(PByte(P^.sourceIndirAddress^) + P^.soruceOffset);
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to init table               }
        {                 record                            }
        {                   cnt: Integer;                   }
        {                   tab: array [1..cnt] record      }
        {                      variableAddress: Pointer;    }
        {                      sourceAddress: ^Pointer;     }
        {                      sourceOffset: Integer;       }
        {                   end;                            }
        {                 end;                              }
        { ->    EDX     Linux only, this points to          }
        {               SysInit.ModuleIsCpp                 }
        { EBX = caller's GOT for PIC callers, 0 for non-PIC }
{$IFDEF MACOS}
                                                                
        RET
{$ENDIF MACOS}
{$IFDEF MSWINDOWS}
        PUSH    EBX
        XOR     EBX,EBX
{$ENDIF MSWINDOWS}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDI
        PUSH    ESI
        MOV     EDI,[EBX+EAX]
        LEA     ESI,[EBX+EAX+4]
{$IFDEF LINUX}
        {
            The C++ linker may have already fixed these things up to valid
            addresses.  In this case, we don't want to do this pass.  If this
            module's init tab was linked with ilink, then SysInit.ModuleIsCpp
            will be set, and we'll bail out.
        }
        CMP     BYTE PTR[EDX+EBX], 0  { SysInit.ModuleIsCpp }
        JNE     @@exit
{$ENDIF LINUX}
@@loop:
        MOV     EAX,[ESI+4]     { load address of import    }
        MOV     EDX,[ESI]       { load address of variable  }
        MOV     EAX,[EBX+EAX]   { load contents of import   }
        ADD     EAX,[ESI+8]     { calc address of variable  }
        MOV     [EBX+EDX],EAX   { store result              }
        ADD     ESI,12
        DEC     EDI
        JNZ     @@loop

@@exit:

        POP     ESI
        POP     EDI
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
{$IFDEF MSWINDOWS}
        POP     EBX
{$ENDIF MSWINDOWS}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

                                                                    
{$IFDEF MSWINDOWS}
//procedure _InitWideStrings(InitTable: _PWideStringInitTable);
procedure _InitWideStrings(InitTable: Pointer);
{$IFDEF PUREPASCAL}
var
  I: Integer;
  P: _PWideStringInitTableElem;
begin
  for I := 1 to _PWideStringInitTable(InitTable)^.Count do
  begin
    P := @_PWideStringInitTable(InitTable)^.Table[I];
    _WStrAsg(_PWideStr(P^.variableAddress)^, _WideStr(P^.stringAddress));
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
     { ->    EAX     Pointer to init table               }
     {                 record                            }
     {                   cnt: Integer;                   }
     {                   tab: array [1..cnt] record      }
     {                      variableAddress: Pointer;    }
     {                      stringAddress: ^Pointer;     }
     {                   end;                            }
     {                 end;                              }

    PUSH    EBX
    PUSH    ESI
    MOV     EBX,[EAX]
    LEA     ESI,[EAX+4]
@@loop:
    MOV     EDX,[ESI+4]     { load address of string    }
    MOV     EAX,[ESI]       { load address of variable  }
    CALL    _WStrAsg
    ADD     ESI,8
    DEC     EBX
    JNZ     @@loop

    POP     ESI
    POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}

procedure _FinalizeResStrings(InitTable: Pointer);
{$IFDEF PUREPASCAL}
var
  I: Integer;
  P: _PResStringInitTableElem;
begin
  for I := 1 to _PResStringInitTable(InitTable)^.Count do
  begin
    P := @_PResStringInitTable(InitTable)^.Table[I];
    case P^.stringKind of
      _TResStringInitTableElem.LString:
        _LStrClr(_PAnsiStr(P^.variableAddress)^);
      _TResStringInitTableElem.WString:
        _WStrClr(_PWideStr(P^.variableAddress)^);
      _TResStringInitTableElem.UString:
        _UStrClr(PUnicodeString(P^.variableAddress)^);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to init table               }
        {                 record                            }
        {                   cnt: Integer;                   }
        {                   tab: array [1..cnt] record      }
        {                      variableAddress: Pointer;    }
        {                      resStringAddress: Pointer;   }
        {                      stringKind: (LString, WString, UString) as Int32; }
        {                   end;                            }
        {                 end;                              }
        { EBX = caller's GOT for PIC callers, 0 for non-PIC }
{$IFDEF MSWINDOWS}
        PUSH    EBX
        XOR     EBX,EBX
{$ENDIF}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDI
        PUSH    ESI
        MOV     EDI,[EBX+EAX]     // EDI := initTable.cnt
        LEA     ESI,[EBX+EAX+4]   // ESI := @initTable.tab
@@loop:
        MOV     EAX,[ESI]         // EAX := initTable.tab[i].variableAddress
{$IFNDEF MACOS}
        ADD     EDX,EBX
{$ENDIF MACOS}
        MOV     ECX,[ESI+8]       // ECX := initTable.tab[i].stringKind
        // Handle appropriate string kind.
        TEST    ECX,ECX
        JZ      @@lstring
        DEC     ECX
        JZ      @@wstring
        DEC     ECX
        JZ      @@ustring
        INT     3
@@lstring:
        CALL    _LStrClr
        JMP     @@doneClr
@@wstring:
        CALL    _WStrClr
        JMP     @@doneClr
@@ustring:
        CALL    _UStrClr
@@doneClr:
        ADD     ESI,12
        DEC     EDI
        JNZ     @@loop

        POP     ESI
        POP     EDI
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
{$IFDEF MSWINDOWS}
        POP     EBX
{$ENDIF}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _FinalizeResStringImports(InitTable: Pointer);
{$IFDEF PUREPASCAL}
var
  I: Integer;
  P: _PResStringImportInitTableElem;
begin
  for I := 1 to _PResStringImportInitTable(InitTable)^.Count do
  begin
    P := @_PResStringImportInitTable(InitTable)^.Table[I];
    case P^.stringKind of
      _TResStringImportInitTableElem.LString:
        _LStrClr(_PAnsiStr(P^.variableAddress)^);
      _TResStringImportInitTableElem.WString:
        _WStrClr(_PWideStr(P^.variableAddress)^);
      _TResStringImportInitTableElem.UString:
        _UStrClr(PUnicodeString(P^.variableAddress)^);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to init table               }
        {                 record                            }
        {                   cnt: Integer;                   }
        {                   tab: array [1..cnt] record      }
        {                      variableAddress: Pointer;    }
        {                      resStringAddress: ^Pointer; *** note indirection  }
        {                      stringKind: (LString, WString, UString) as Int32; }
        {                   end;                            }
        {                 end;                              }
        { EBX = caller's GOT for PIC callers, 0 for non-PIC }
{$IFDEF MSWINDOWS}
        PUSH    EBX
        XOR     EBX,EBX
{$ENDIF}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDI
        PUSH    ESI
        MOV     EDI,[EBX+EAX]     // EDI := initTable.cnt
        LEA     ESI,[EBX+EAX+4]   // ESI := @initTable.tab
@@loop:
        MOV     EAX,[ESI]         // EAX := initTable.tab[i].variableAddress
{$IFNDEF MACOS}
        ADD     EDX,EBX
{$ENDIF MACOS}
        MOV     ECX,[ESI+8]       // ECX := initTable.tab[i].stringKind
        // Handle appropriate string kind.
        TEST    ECX,ECX
        JZ      @@lstring
        DEC     ECX
        JZ      @@wstring
        DEC     ECX
        JZ      @@ustring
        INT     3
@@lstring:
        CALL    _LStrClr
        JMP     @@doneClr
@@wstring:
        CALL    _WStrClr
        JMP     @@doneClr
@@ustring:
        CALL    _UStrClr
@@doneClr:
        ADD     ESI,12
        DEC     EDI
        JNZ     @@loop
        POP     ESI
        POP     EDI
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
{$IFDEF MSWINDOWS}
        POP     EBX
{$ENDIF}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

{$IFDEF MSWINDOWS}
procedure _FinalizeWideStrings(InitTable: Pointer);
var
  I: Integer;
  P: _PWideStringInitTableElem;
begin
  for I := 1 to _PWideStringInitTable(InitTable)^.Count do
  begin
    P := @_PWideStringInitTable(InitTable)^.Table[I];
    _WStrClr(_PWideStr(P^.variableAddress)^);
  end;
end;
{$ENDIF}

{$IFDEF CPU64BITS}
var
  runErrMsg: array[0..37] of _AnsiChr = (
    'R', 'u', 'n', 't', 'i', 'm', 'e', ' ', // 0..7
    'e', 'r', 'r', 'o', 'r', ' ', ' ', ' ', // 8..15
    ' ', ' ', 'a', 't', ' ', '0', '0', '0', // 16..23
    '0', '0', '0', '0', '0', '0', '0', '0', // 24..31
    '0', '0', '0', '0', '0', #0);           // 32..37
{$ELSE !CPU64BITS}
var
  runErrMsg: array[0..29] of _AnsiChr = (
    'R', 'u', 'n', 't', 'i', 'm', 'e', ' ', // 0..7
    'e', 'r', 'r', 'o', 'r', ' ', ' ', ' ', // 8..15
    ' ', ' ', 'a', 't', ' ', '0', '0', '0', // 16..23
    '0', '0', '0', '0', '0', #0);           // 24..29
{$ENDIF !CPU64BITS}

const
  hexDigits: array[0..15] of _AnsiChr = (
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F');

procedure MakeErrorMessage;
var
  digit: Byte;
  Temp: Integer;
  Addr: NativeUInt;
begin
  digit := 16;
  Temp := ExitCode;
  repeat
    runErrMsg[digit] := _AnsiChr(Ord('0') + (Temp mod 10));
    Temp := Temp div 10;
    Dec(digit);
  until Temp = 0;
{$IFDEF CPU64BITS}
  digit := 36;
{$ELSE !CPU64BITS}
  digit := 28;
{$ENDIF !CPU64BITS}
  Addr := UIntPtr(ErrorAddr);
  repeat
    runErrMsg[digit] := hexDigits[Addr and $F];
    Addr := Addr div 16;
    Dec(digit);
  until Addr = 0;
end;


{$IFDEF TABLE_BASED_EXCEPTIONS}
{$IFDEF CPUX64}
function _ExitDllSetJump(var Buf: __TExitDllJumpBuf): Integer;
asm
        // <- RCX = Context (16 bytes aligned)
        // -> EAX = 0
        .NOFRAME
        MOV     RAX, [RSP]
        LEA     RDX, [RSP+8]
        MOV     [RCX].__TExitDllJumpBuf._RIP, RAX
        MOV     [RCX].__TExitDllJumpBuf._RSP, RDX
        MOV     [RCX].__TExitDllJumpBuf._RBX, RBX
        MOV     [RCX].__TExitDllJumpBuf._RBP, RBP
        {$IF DEFINED(MSWINDOWS)}
        MOV     [RCX].__TExitDllJumpBuf._RSI, RSI
        MOV     [RCX].__TExitDllJumpBuf._RDI, RDI
        {$ENDIF}
        MOV     [RCX].__TExitDllJumpBuf._R12, R12
        MOV     [RCX].__TExitDllJumpBuf._R13, R13
        MOV     [RCX].__TExitDllJumpBuf._R14, R14
        MOV     [RCX].__TExitDllJumpBuf._R15, R15
        {$IF DEFINED(MSWINDOWS)}
        LEA     RAX, [RCX].__TExitDllJumpBuf.XmmBuf+$20
        MOVAPD  [RAX-$20], XMM6
        MOVAPD  [RAX-$10], XMM7
        {$ELSE}
        LEA     RAX, [RCX].__TExitDllJumpBuf.XmmBuf
        {$ENDIF}
        MOVAPD  [RAX], XMM8
        MOVAPD  [RAX+$10], XMM9
        MOVAPD  [RAX+$20], XMM10
        MOVAPD  [RAX+$30], XMM11
        MOVAPD  [RAX+$40], XMM12
        MOVAPD  [RAX+$50], XMM13
        MOVAPD  [RAX+$60], XMM14
        MOVAPD  [RAX+$70], XMM15
        XOR     EAX,EAX
end;
{$ENDIF CPUX64}
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IFDEF TABLE_BASED_EXCEPTIONS}
{$IFDEF CPUX64}
procedure _ExitDllLongJump(var Buf: __TExitDllJumpBuf; Val: Integer);
asm
        // <- RCX = Buf (16 bytes aligned)
        // <- EDX = Val
        // -> EAX = Val
        .NOFRAME
        XCHG    EAX, EDX
        {$IF DEFINED(MSWINDOWS)}
        LEA     RDX, [RCX].__TExitDllJumpBuf.XmmBuf+$20
        MOVAPD  XMM6,  [RDX-$20]
        MOVAPD  XMM7,  [RDX-$10]
        {$ELSE}
        LEA     RDX, [RCX].__TExitDllJumpBuf.XmmBuf
        {$ENDIF}
        MOVAPD  XMM8,  [RDX]
        MOVAPD  XMM9,  [RDX+$10]
        MOVAPD  XMM10, [RDX+$20]
        MOVAPD  XMM11, [RDX+$30]
        MOVAPD  XMM12, [RDX+$40]
        MOVAPD  XMM13, [RDX+$50]
        MOVAPD  XMM14, [RDX+$60]
        MOVAPD  XMM15, [RDX+$70]
        MOV     RBX, [RCX].__TExitDllJumpBuf._RBX
        MOV     RBP, [RCX].__TExitDllJumpBuf._RBP
        {$IF DEFINED(MSWINDOWS)}
        MOV     RSI, [RCX].__TExitDllJumpBuf._RSI
        MOV     RDI, [RCX].__TExitDllJumpBuf._RDI
        {$ENDIF}
        MOV     R12, [RCX].__TExitDllJumpBuf._R12
        MOV     R13, [RCX].__TExitDllJumpBuf._R13
        MOV     R14, [RCX].__TExitDllJumpBuf._R14
        MOV     R15, [RCX].__TExitDllJumpBuf._R15
        MOV     RSP, [RCX].__TExitDllJumpBuf._RSP
        JMP     [RCX].__TExitDllJumpBuf._RIP
end;
{$ENDIF CPUX64}
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IFDEF TABLE_BASED_EXCEPTIONS}
{$IFDEF CPUX64}
function _DllMain(Context: PInitContext): Integer;
asm
        .NOFRAME
        LEA     RCX,[RCX].TInitContext.ExitDllJmpBuf
        JMP     _ExitDllSetJump
end;
{$ENDIF CPUX64}
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IF defined(POSIX) and defined(EXTERNALLINKER)}
function _DllMain(Context: PInitContext): Integer;
begin
  // 0 = do initialization and execute user code
  // 1 = successful return
  // 2 = failure return
                                                                     
                                                                                 
                                                                        
                                                                             
  Result := 0;
end;
{$ENDIF POSIX and EXTERNALLINKER}

                                                                                  
                                                                             
                                                                               
procedure ExitDll(Context: PInitContext);
{$IFDEF TABLE_BASED_EXCEPTIONS}
// Note: ExitDll must not use any thread variables because TlsFree
// has been called already at DLL_PROCESS_DETACH
var
  ResultCode: Integer;
  ExitDllJmpBuf: __TExitDllJumpBuf;
begin
  ExitDllJmpBuf := Context.ExitDllJmpBuf;
  Context^ := Context.OuterContext^;
  ResultCode := Ord(ExitCode <> 0) + 1; // ResultCode=0 for _ExitDllSetJump
  ExitCode := 0;
  _ExitDllLongJump(ExitDllJmpBuf, ResultCode);
end;
{$ELSE !TABLE_BASED_EXCEPTIONS}
{$IF defined(CPUX86) and defined(ASSEMBLER)}
asm
        { ->    EAX  PInitContext }

        { Restore the InitContext }
        MOV     EDI,EAX
        MOV     EBX,[EDI].TInitContext.DLLSaveEBX
        MOV     EBP,[EDI].TInitContext.DLLSaveEBP
        PUSH    [EDI].TInitContext.DLLSaveESI
        PUSH    [EDI].TInitContext.DLLSaveEDI

        MOV     ESI,[EDI].TInitContext.OuterContext
        MOV     ECX,(type TInitContext)/4
        REP     MOVSD
        POP     EDI
        POP     ESI

{$IFDEF MSWINDOWS}
        // Linux: See notes in legacy versions of this file.
        { Return False if ExitCode <> 0, and set ExitCode to 0 }
        XOR     EAX,EAX
        XCHG    EAX, ExitCode
        NEG     EAX
        SBB     EAX,EAX
        INC     EAX
{$ENDIF MSWINDOWS}

        LEAVE
{$IFDEF MSWINDOWS}
        RET     12
{$ENDIF MSWINDOWS}
{$IFDEF LINUX}
        RET
{$ENDIF LINUX}
end;
{$ELSE !CPUX86 or !ASSEMBLER}
begin
  Error(rePlatformNotImplemented);
end;
{$ENDIF !CPUX86 or !ASSEMBLER}
{$ENDIF !TABLE_BASED_EXCEPTIONS}

                                                                  
procedure WriteErrorMessage;
{$IFDEF MSWINDOWS}
var
  Dummy: Cardinal;
begin
  if IsConsole then
  begin
    with TTextRec(Output) do
    begin
      if (Mode = fmOutput) and (BufPos > 0) then
        TTextIOFunc(InOutFunc)(TTextRec(Output));  // flush out text buffer
    end;
    // Leave #0 off end of runErrMsg
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), @runErrMsg, Sizeof(runErrMsg) - 1, Dummy, nil);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), @sLineBreak[1], 2, Dummy, nil);
  end
  else if not NoErrMsg then
    MessageBoxA(0, runErrMsg, errCaption, 0);
end;
{$ELSEIF defined(POSIX)}
var
  c: _AnsiChr;
begin
  with TTextRec(Output) do
  begin
    if (Mode = fmOutput) and (BufPos > 0) then
      TTextIOFunc(InOutFunc)(TTextRec(Output));  // flush out text buffer
  end;
   __write(STDERR_FILENO, @runErrMsg, Sizeof(runErrMsg)-1);
   c := sLineBreak;
   __write(STDERR_FILENO, @c, 1);
end;
{$ELSE}
begin
   Error(rePlatformNotImplemented);
end;
{$ENDIF}

var
  RTLInitFailed: Boolean = False;

procedure _Halt0;
var
  P: procedure;
                                                                                           
{$IF not (defined(PC_MAPPED_EXCEPTIONS) or defined(SJLJ_BASED_EXCEPTIONS)) }
  ExceptObject: TObject;
{$ENDIF !(PC_MAPPED_EXCEPTIONS or SJLJ_BASED_EXCEPTIONS)}
begin
{$IFDEF ANDROID}
  if System.DelphiActivity = nil then
    Exit;
{$ENDIF ANDROID}
{$IF defined(LINUX) or defined(MACOS) or Defined(ANDROID)}
  if (ExitCode <> 0) and CoreDumpEnabled then
    __raise(SIGABRT);

  if (InitContext.DLLInitState = 2) and (ExitCode <> 0) then
    RTLInitFailed := True;

  if (InitContext.DLLInitState = 1) and RTLInitFailed then
    // RTL failed to initialized in library startup.  Units have already been
    // finalized, don't finalize them again.
    ExitDll(@InitContext);
{$ENDIF LINUX or MACOS or ANDROID}

  { If there was some kind of runtime error, alert the user }

  if ErrorAddr <> nil then
  begin
    MakeErrorMessage;
    WriteErrorMessage;
    ErrorAddr := nil;
  end;

  { For DLL_THREAD_ATTACH or DLL_THREAD_DETACH, just cleanup and exit }
                                                             
{$IFDEF MSWINDOWS}
  if Assigned(DLLThreadContext.ExcFrame) and
    (GetCurrentThreadId = DLLThreadContext.ThreadID) then
  begin
{$IFDEF STACK_BASED_EXCEPTIONS}
    UnsetExceptionHandler(@DLLThreadContext);
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
    DLLThreadContext.ExcFrame := nil;
{$ENDIF TABLE_BASED_EXCEPTIONS}
    ExitDll(@DLLThreadContext);
  end;
{$ENDIF MSWINDOWS}

  if InitContext.DLLInitState = 0 then
    while ExitProc <> nil do
    begin
      @P := ExitProc;
      ExitProc := nil;
      P;
    end;

  { This loop exists because we might be nested in PackageLoad calls when }
  { Halt got called. We need to unwind these contexts.                    }

  while True do
  begin

    { If we are a library, and we are starting up fine, there are no units to finalize }

    if (InitContext.DLLInitState = 2) and (ExitCode = 0) then
      InitContext.InitCount := 0;

    { Clear the exception stack to prevent handled exceptions from being shown to the user }
{$IF not (defined(PC_MAPPED_EXCEPTIONS) or defined(SJLJ_BASED_EXCEPTIONS)) or defined(ZCX_BASED_EXCEPTIONS)) }
                                             
                                                                                                        
                                                                                             
                                                                                       
                                                                                      
                                                                                           
                                                             

                                                                                 

    if InitContext.DLLInitState = 0 then
    begin
      ExceptObject := TObject(AcquireExceptionObject);
      while ExceptObject <> nil do
      begin
        ExceptObject.Free;
        ExceptObject := TObject(AcquireExceptionObject);
      end;
    end;
{$ENDIF PC_MAPPED_EXCEPTIONS}

    { Undo any unit initializations accomplished so far }

    FinalizeUnits;

    if (InitContext.DLLInitState <= 1) or (ExitCode <> 0) then
    begin
      if InitContext.Module <> nil then
        with InitContext do
        begin
          UnregisterModule(Module);
{$IFDEF PC_MAPPED_EXCEPTIONS}
          SysUnregisterIPLookup(Module.CodeSegStart);
{$ENDIF PC_MAPPED_EXCEPTIONS}
          if (Module.ResInstance <> Module.Instance) and (Module.ResInstance <> 0) then
{$IFDEF MSWINDOWS}
            FreeLibrary(Module.ResInstance);
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
            dlclose(Module.ResInstance);
{$ENDIF POSIX}
        end;
    end;

{$IFDEF STACK_BASED_EXCEPTIONS}
    UnsetExceptionHandler(@InitContext);
{$ENDIF STACK_BASED_EXCEPTIONS}
{$IFDEF TABLE_BASED_EXCEPTIONS}
    InitContext.ExcFrame := nil;
{$ENDIF TABLE_BASED_EXCEPTIONS}

{$IFDEF MSWINDOWS}
    if InitContext.DllInitState = 1 then
      InitContext.ExitProcessTLS;
{$ENDIF MSWINDOWS}

    if InitContext.DllInitState <> 0 then
      ExitDll(@InitContext);

    if InitContext.OuterContext = nil then
    begin
      {
        If an ExitProcessProc is set, we call it.  Note that at this
        point the RTL is completely shutdown.  The only thing this is used
        for right now is the proper semantic handling of signals under Linux.
      }
      if Assigned(ExitProcessProc) then
        ExitProcessProc;
{$IF Defined(MSWINDOWS)}
      ExitProcess(ExitCode);
{$ELSEIF Defined(POSIX)}
      __exit(ExitCode);
{$ELSE}
{$MESSAGE ERROR 'Unknown platform'}
{$ENDIF}
      // never arrive hear.
    end;

    InitContext := InitContext.OuterContext^
  end;
end;

procedure _Halt;
begin
  ExitCode := Code;
  _Halt0;
end;

                                                              
procedure _Run0Error;
begin
  ErrorAddr := ReturnAddress;
  Halt(0);
end;

                                                                              
procedure _RunError(errorCode: Byte);
begin
  ErrorAddr := ReturnAddress;
  Halt(errorCode);
end;

{$IFDEF PC_MAPPED_EXCEPTIONS}
procedure _UnhandledException;
type
  TExceptProc = procedure (Obj: TObject; Addr: Pointer);
begin
  if Assigned(ExceptProc) then
    TExceptProc(ExceptProc)(ExceptObject, ExceptAddr)
  else
    RunErrorAt(230, ExceptAddr);
end;
{$ENDIF PC_MAPPED_EXCEPTIONS}

{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEPTIONS)}
                                                                                                
procedure _UnhandledException;
type
  TExceptProc = procedure (const Obj: TObject; Addr: Pointer);
var
  ExceptionObject: TObject;
  ExceptionAddress: Pointer;
begin
  ExceptionObject := ExceptObject;
  ExceptionAddress := ExceptAddr;
  NotifyUnhandled(ExceptionObject, ExceptionAddress);
  if Assigned(ExceptProc) then
    TExceptProc(ExceptProc)(ExceptionObject, ExceptionAddress);
  RunErrorAt(217, ExceptionAddress); // reControlBreak
end;
{$ENDIF TABLE_BASED_EXCEPTIONS}
{$IF Defined(ZCX_BASED_EXCEPTIONS_MACOS)}
                                                                                                
procedure _UnhandledException;
type
  TExceptProc = procedure (const Obj: TObject; Addr: Pointer);
var
  ExceptionObject: TObject;
  ExceptionAddress: Pointer;
begin
  ExceptionObject := ExceptObject;
  ExceptionAddress := ExceptAddr;
  NotifyUnhandled(ExceptionObject, ExceptionAddress);
  if Assigned(ExceptProc) then
    TExceptProc(ExceptProc)(ExceptionObject, ExceptionAddress);
  RunErrorAt(217, ExceptionAddress); // reControlBreak
end;
{$ENDIF ZCX_BASED_EXCEPTIONS_MACOS}

                                                                    
{$IF Defined(SJLJ_BASED_EXCEPTIONS)}
//procedure _UnhandledException;
//begin
//end;
{$ENDIF !PC_MAPPED_EXCEPTIONS & !TABLE_BASED_EXCEPTIONS & (PUREPASCAL or !CPUX86)}



procedure _Assert(const Message, Filename: string; LineNumber: Integer);
begin
  if Assigned(AssertErrorProc) then
    AssertErrorProc(Message, Filename, LineNumber, ReturnAddress)
  else
    ErrorAt(Byte(reAssertionFailed), ReturnAddress);
end;

type
  PThreadRec = ^TThreadRec;
  TThreadRec = record
    {
      WARNING: Don't change these fields without also changing them in
      the C++ RTL : winrtl/source/vcl/crtlvcl.cpp
    }
    Func: TThreadFunc;
    Parameter: Pointer;
  end;

                                                                                             
{$IFDEF MSWINDOWS}
function ThreadWrapper(Parameter: Pointer): Integer; stdcall;
{$ELSE}
function ThreadWrapper(Parameter: Pointer): NativeInt; cdecl;
{$ENDIF}
{$IFDEF PUREPASCAL}
var
  ThreadRec: TThreadRec;
begin
  Result := 0; // supress warning
  try
    _FpuInit;
    ThreadRec := PThreadRec(Parameter)^;
    FreeMem(PThreadRec(Parameter));
    Result := ThreadRec.Func(ThreadRec.Parameter);
  except
    _UnhandledException;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
{$IFDEF PC_MAPPED_EXCEPTIONS}
        { Mark the top of the stack with a signature }
        PUSH    UNWINDFI_TOPOFSTACK
{$ENDIF PC_MAPPED_EXCEPTIONS}
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        CALL    _FpuInit
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EBP
{$IFNDEF PC_MAPPED_EXCEPTIONS}
        XOR     ECX,ECX
        PUSH    offset _ExceptionHandler
        MOV     EDX,FS:[ECX]
        PUSH    EDX
        MOV     FS:[ECX],ESP
{$ENDIF !PC_MAPPED_EXCEPTIONS}
{$IFDEF PC_MAPPED_EXCEPTIONS}
    // The signal handling code in SysUtils depends on being able to
    // discriminate between Delphi threads and foreign threads in order
    // to choose the disposition of certain signals.  It does this by
    // testing a TLS index.  However, we allocate TLS in a lazy fashion,
    // so this test can fail unless we've already allocated the TLS segment.
    // So we force the allocation of the TLS index value by touching a TLS
    // value here.  So don't remove this silly call to AreOSExceptionsBlocked.
        CALL    AreOSExceptionsBlocked
{$ENDIF PC_MAPPED_EXCEPTIONS}
        MOV     EAX,Parameter

        MOV     ECX,[EAX].TThreadRec.Parameter
        MOV     EDX,[EAX].TThreadRec.Func
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    ECX
        PUSH    EDX
        CALL    _FreeMem
        POP     EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
        CALL    EDX

{$IFNDEF PC_MAPPED_EXCEPTIONS}
        XOR     EDX,EDX
        POP     ECX
        MOV     FS:[EDX],ECX
        POP     ECX
{$ENDIF !PC_MAPPED_EXCEPTIONS}
        POP     EBP
{$IFDEF PC_MAPPED_EXCEPTIONS}
        { Ditch our TOS marker }
        ADD     ESP, 4
{$ENDIF PC_MAPPED_EXCEPTIONS}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


{$IFDEF MSWINDOWS}
function BeginThread(SecurityAttributes: Pointer; StackSize: LongWord;
  ThreadFunc: TThreadFunc; Parameter: Pointer; CreationFlags: LongWord;
  var ThreadId: TThreadID): THandle;
var
  P: PThreadRec;
begin
  if Assigned(SystemThreadFuncProc) then
    P := PThreadRec(SystemThreadFuncProc(ThreadFunc, Parameter))
  else
  begin
    New(P);
    P.Func := ThreadFunc;
    P.Parameter := Parameter;
  end;

  IsMultiThread := TRUE;

  Result := CreateThread(SecurityAttributes, StackSize, @ThreadWrapper, P,
    CreationFlags, ThreadID);

  { P variable is supposed to be freed by the ThreadWrapper routine.
    If the call to CreateThread fails, then ThreadWrapper will not be called
    and P will not get freed. Check for failure now and free P if required.
  }
  if Result = 0 then
    Dispose(P);
end;


procedure EndThread(ExitCode: Integer);
begin
  if Assigned(SystemThreadEndProc) then
    SystemThreadEndProc(ExitCode);
  ExitThread(ExitCode);
end;
{$ENDIF}

{$IFDEF POSIX}
function BeginThread(Attribute: PThreadAttr;
                     ThreadFunc: TThreadFunc;
                     Parameter: Pointer;
                     var ThreadId: TThreadID): Integer;
var
  P: PThreadRec;
  Thread: pthread_t;
begin
  if Assigned(BeginThreadProc) then
    Result := BeginThreadProc(Attribute, ThreadFunc, Parameter, ThreadId)
  else
  begin
    New(P);
    P.Func := ThreadFunc;
    P.Parameter := Parameter;
    IsMultiThread := True;

    Result := pthread_create(Thread, Ppthread_attr_t(Attribute), @ThreadWrapper, P);
    if Result = 0 then
      ThreadID := TThreadID(Thread);

    { P variable is supposed to be freed by the ThreadWrapper routine.
      If the call to CreateThread fails, then ThreadWrapper will not be called
      and P will not get freed. Check for failure now and free P if required.
    }
    if Result <> 0 then
      Dispose(P);
  end;
end;

procedure EndThread(ExitCode: Integer);
begin
  if Assigned(EndThreadProc) then
    EndThreadProc(ExitCode);
  // No "else" required since EndThreadProc does not (!!should not!!) return.
  pthread_detach(pthread_t(GetCurrentThreadID));
  pthread_exit(ExitCode);
end;
{$ENDIF POSIX}


{ STRING SUPPORT }

{ ----------------------------------------------------- }
{       internal functions & procedures for strings     }
{ ----------------------------------------------------- }

// S must be non-nil.
function __StringLength(const S: UnicodeString): Integer; overload; inline;
begin
  Result := PInteger(PByte(S) - 4)^;                // StrRec.length
end;

// S must be non-nil.
// Returns number of characters.
// Note: On Windows, length field contains number of bytes and not number
//       of characters.
function __StringLength(const S: _WideStr): Integer; overload; inline;
begin
{$IFDEF MSWINDOWS}
  Result := PInteger(PByte(S) - 4)^ div 2;          // size field of BSTR
{$ELSE}
  Result := PInteger(PByte(S) - 4)^;                // StrRec.length
{$ENDIF}
end;

// S must be non-nil
function __StringLength(const S: _RawByteStr): Integer; overload; inline;
begin
  Result := PInteger(PByte(S) - 4)^;                // StrRec.length
end;

// S must be non-nil
function __StringLength(const S: Pointer): Integer; overload; inline;
begin
  Result := PInteger(PByte(S) - 4)^;                // StrRec.length
end;

// S must be non-nil
function __StringRefCnt(const S: UnicodeString): Integer; overload; inline;
begin
  Result := PInteger(PByte(S) - 8)^;                // StrRec.refCnt
end;

{$IFNDEF MSWINDOWS}
// S must be non-nil
// Note: On Windows, _WideStr doesn't contain refCount field.
function __StringRefCnt(const S: _WideStr): Integer; overload; inline;
begin
  Result := PInteger(PByte(S) - 8)^;                // StrRec.refCnt
end;
{$ENDIF}

// S must be non-nil
function __StringRefCnt(const S: _RawByteStr): Integer; overload; inline;
begin
  Result := PInteger(PByte(S) - 8)^;                // StrRec.refCnt
end;

// S must be non-nil. Don't use for Windows _WideStr.
function __StringRefCnt(const S: Pointer): Integer; overload; inline;
begin
  Result := PInteger(PByte(S) - 8)^;                // StrRec.refCnt
end;

// S must be non-nil
function __StringCodePage(const S: UnicodeString): Word; overload; inline;
begin
  Result := PWord(PByte(S) - 12)^;                  // StrRec.codePage
end;

{$IFNDEF MSWINDOWS}
// S must be non-nil
// Note: On Windows, _WideStr doesn't contain codePage field.
function __StringCodePage(const S: _WideStr): Word; overload; inline;
begin
  Result := PWord(PByte(S) - 12)^;                  // StrRec.codePage
end;
{$ENDIF}

// S must be non-nil
function __StringCodePage(const S: _RawByteStr): Word; overload; inline;
begin
  Result := PWord(PByte(S) - 12)^;                  // StrRec.codePage
end;

// S must be non-nil. Don't use for Windows _WideStr.
function __StringCodePage(const S: Pointer): Word; overload; inline;
begin
  Result := PWord(PByte(S) - 12)^;                  // StrRec.codePage
end;


{ ------------------------------------------------------------- }
{       Compiler helper for string allocation and release       }
{ ------------------------------------------------------------- }

function _NewUnicodeString(CharLength: Integer): Pointer;
{$IFDEF PUREPASCAL}
var
  P: PStrRec;
begin
  Result := nil;
  if CharLength > 0 then
  begin
    // Allocate a memory with record and extra wide-null terminator.
    if CharLength >= (MaxInt - SizeOf(StrRec)) div SizeOf(WideChar) then _IntOver;
    GetMem(P, SizeOf(StrRec) + (CharLength + 1) * SizeOf(WideChar));
    Result := Pointer(PByte(P) + SizeOf(StrRec));
    P.length := CharLength;
    P.refCnt := 1;
    P.elemSize := SizeOf(WideChar);
    P.codePage := Word(DefaultUnicodeCodePage);
    PWideChar(Result)[CharLength] := #0;
  end;
end;
{$ELSE}
asm
        { ->    EAX     length                  }
        { <-    EAX     pointer to new string   }
        TEST    EAX,EAX
        JLE     @@lengthLEZero  // length <= 0?
        PUSH    EAX             // save length
        ADD     EAX,EAX         // convert to bytes
        JO      @@overflow
        ADD     EAX,rOff+2      // + record + terminator
        JO      @@overflow
        {$IFDEF ALIGN_STACK}
        SUB     ESP,8
        {$ENDIF ALIGN_STACK}
        CALL    _GetMem
        {$IFDEF ALIGN_STACK}
        ADD     ESP,8
        {$ENDIF ALIGN_STACK}
        ADD     EAX,rOff
        POP     EDX                              // requested string length
        MOV     [EAX-skew].StrRec.refCnt,1
        MOV     [EAX-skew].StrRec.length,EDX
        MOV     word ptr [EAX+EDX*2],0           // wide null terminator
        MOV     word ptr [EAX-skew].StrRec.elemSize,2
{$IFDEF PIC}
        PUSH    EBX
        PUSH    EAX
        PUSH    ECX
        CALL    GetGOT
        MOV     EDX, [EAX].OFFSET DefaultUnicodeCodePage
        MOV     EDX, [EDX]
        POP     ECX
        POP     EAX
        POP     EBX
{$ELSE !PIC}
        MOV     EDX, DefaultUnicodeCodePage
{$ENDIF}
        MOV     word ptr [EAX-skew].StrRec.codePage,DX
        RET
@@overflow:
        {$IFDEF ALIGN_STACK}
        POP     EAX
        {$ENDIF ALIGN_STACK}
        JMP     _IntOver
@@lengthLEZero:
        XOR     EAX,EAX
end;
{$ENDIF !PUREPASCAL}


function _NewAnsiString(CharLength: Integer; CodePage: Word): Pointer;
{$IFDEF PUREPASCAL}
var
  P: PStrRec;
begin
  Result := nil;
  if CharLength > 0 then
  begin
    // Alloc an extra null for strings with even length.  This has no actual
    // cost since the allocator will round up the request to an even size
    // anyway. All _WideStr allocations have even length, and need a double
    // null terminator.
    if CharLength >= MaxInt - SizeOf(StrRec) then _IntOver;
    GetMem(P, CharLength + SizeOf(StrRec) + 1 + ((CharLength + 1) and 1));
    Result := Pointer(PByte(P) + SizeOf(StrRec));
    P.length := CharLength;
    P.refcnt := 1;
    if CodePage = 0 then
{$IFDEF NEXTGEN}
      CodePage := Word(CP_UTF8);
{$ELSE  NEXTGEN}
      CodePage := Word(DefaultSystemCodePage);
{$ENDIF NEXTGEN}
    P.codePage := CodePage;
    P.elemSize := 1;
    PWideChar(Result)[CharLength div 2] := #0;  // length guaranteed >= 2
  end;
end;
{$ELSE}
asm
        { ->    EAX     length                  }
        { <-    EAX pointer to new string       }

        TEST    EAX,EAX
        JLE     @@lengthLEZero
        PUSH    EAX
        ADD     EAX,rOff+2                      // one or two nulls (Ansi/Wide)
        JO      @@overflow
        AND     EAX, not 1                      // round up to even length
        PUSH    EDX
        PUSH    EAX
        CALL    _GetMem
        POP     EDX                             // actual allocated length (>= 2)
        POP     ECX
        MOV     word ptr [EAX+EDX-2],0          // double null terminator
        ADD     EAX,rOff
        POP     EDX                             // requested string length
        MOV     [EAX-skew].StrRec.length,EDX
        MOV     [EAX-skew].StrRec.refCnt,1
        TEST    ECX,ECX
        JNE     @@NotDefault
{$IFDEF PIC}
        PUSH    EBX
        PUSH    EAX
        CALL    GetGOT
        MOV     ECX,[EAX].OFFSET DefaultSystemCodePage
        MOV     ECX, [ECX]
        POP     EAX
        POP     EBX
{$ELSE !PIC}
        MOV     ECX,DefaultSystemCodePage
{$ENDIF !PIC}
@@NotDefault:
        MOV     EDX,ECX
        MOV     word ptr [EAX-skew].StrRec.codePage,DX
        MOV     word ptr [EAX-skew].StrRec.elemSize,1
        RET
@@overflow:
        {$IFDEF ALIGN_STACK}
        POP     EAX
        {$ENDIF ALIGN_STACK}
        JMP     _IntOver
@@lengthLEZero:
        XOR     EAX,EAX
end;
{$ENDIF !PUREPASCAL}

{$IFDEF MSWINDOWS}
procedure WStrError;
{$IFDEF PUREPASCAL}
begin
  ErrorAt(byte(reOutOfMemory), ReturnAddress);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        MOV     AL,reOutOfMemory
        JMP     Error
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}

function _NewWideString(CharLength: Integer): Pointer;
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
   Result := _NewUnicodeString(CharLength);
end;
{$ELSE}
asm
        JMP     _NewUnicodeString
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
begin
  Result := nil;
  if CharLength <> 0 then
  begin
    Result := SysAllocStringLen(nil, CharLength);
    if Result = nil then
      WStrError;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     length                  }
        { <-    EAX     pointer to new string   }

        TEST    EAX,EAX
        JE      @@1
        {$IFDEF ALIGN_STACK}
        SUB     ESP,4
        {$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    0
        CALL    SysAllocStringLen
        {$IFDEF ALIGN_STACK}
        ADD     ESP,4
        {$ENDIF ALIGN_STACK}
        TEST    EAX,EAX
        JE      WStrError
@@1:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
   Result := _NewUnicodeString(CharLength);
end;
{$ENDIF !MSWINDOWS and !POSIX}

{$IF not defined(X86ASMRTL)}
function _UStrClr(var S): Pointer;
var
  P: PStrRec;
begin
  if Pointer(S) <> nil then
  begin
    P := Pointer(PByte(S) - SizeOf(StrRec));
    Pointer(S) := nil;
    if P.refCnt > 0 then
    begin
      if AtomicDecrement(P.refCnt) = 0 then
        FreeMem(P);
    end;
  end;
  Result := @S;
end;
{$ELSE X86ASMRTL}
procedure _UStrClr(var S);
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to str  }
        { <-    EAX     pointer to str  }

        MOV     EDX,[EAX]                       { fetch str                     }
        TEST    EDX,EDX                         { if nil, nothing to do         }
        JE      @@done
        MOV     dword ptr [EAX],0               { clear str                     }
        MOV     ECX,[EDX-skew].StrRec.refCnt    { fetch refCnt                  }
        DEC     ECX                             { if < 0: literal str           }
        JL      @@done
   LOCK DEC     [EDX-skew].StrRec.refCnt        { threadsafe dec refCount       }
        JNE     @@done
        {$IFDEF ALIGN_STACK}
        SUB     ESP,8
        {$ENDIF ALIGN_STACK}
        PUSH    EAX
        LEA     EAX,[EDX-skew]                  { if refCnt now zero, deallocate}
        CALL    _FreeMem
        POP     EAX
        {$IFDEF ALIGN_STACK}
        ADD     ESP,8
        {$ENDIF ALIGN_STACK}
@@done:
end;
{$ENDIF CPUX86}
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
function _LStrClr(var S): Pointer;
var
  P: PStrRec;
begin
  if Pointer(S) <> nil then
  begin
    P := Pointer(PByte(S) - SizeOf(StrRec));
    Pointer(S) := nil;
    if P.refCnt > 0 then
    begin
      if AtomicDecrement(P.refCnt) = 0 then
        FreeMem(P);
    end;
  end;
  Result := @S;
end;
{$ELSE X86ASMRTL}
{$IFDEF CPUX86}
procedure _LStrClr(var S);
asm
        { ->    EAX     pointer to str  }
        { <-    EAX     pointer to str  }

        MOV     EDX,[EAX]                       { fetch str                     }
        TEST    EDX,EDX                         { if nil, nothing to do         }
        JE      @@done
        MOV     dword ptr [EAX],0               { clear str                     }
        MOV     ECX,[EDX-skew].StrRec.refCnt    { fetch refCnt                  }
        DEC     ECX                             { if < 0: literal str           }
        JL      @@done
   LOCK DEC     [EDX-skew].StrRec.refCnt        { threadsafe dec refCount       }
        JNE     @@done
        {$IFDEF ALIGN_STACK}
        SUB     ESP,8
        {$ENDIF ALIGN_STACK}
        PUSH    EAX
        LEA     EAX,[EDX-skew]                  { if refCnt now zero, deallocate}
        CALL    _FreeMem
        POP     EAX
        {$IFDEF ALIGN_STACK}
        ADD     ESP,8
        {$ENDIF ALIGN_STACK}
@@done:
end;
{$ENDIF CPUX86}
{$ENDIF X86ASMRTL}

{$IFDEF POSIX}
{$IF not defined(X86ASMRTL)}
function _WStrClr(var S): Pointer;
begin
  Result := _UStrClr(S);
end;
{$ELSE X86ASMRTL}
procedure _WStrClr(var S);
asm
        JMP     _UStrClr;
end;
{$ENDIF X86ASMRTL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IF not defined(X86ASMRTL)}
function _WStrClr(var S): Pointer;
var
  P: Pointer;
begin
  if Pointer(S) <> nil then
  begin
    P := Pointer(S);
    Pointer(S) := nil;
    SysFreeString(_WideStr(P));
  end;
  Result := @S;
end;
{$ELSE X86ASMRTL}
procedure _WStrClr(var S);
asm
        { ->    EAX     pointer to str  }
        { <-    EAX     pointer to Str  }

        MOV     EDX,[EAX]
        TEST    EDX,EDX
        JE      @@1
        MOV     DWORD PTR [EAX],0
        {$IFDEF ALIGN_STACK}
        SUB     ESP,4
        {$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        CALL    SysFreeString
        POP     EAX
        {$IFDEF ALIGN_STACK}
        ADD     ESP,4
        {$ENDIF ALIGN_STACK}
@@1:
end;
{$ENDIF X86ASMRTL}
{$ENDIF MSWINDOWS}


procedure _UStrArrayClr(var StrArray; Count: Integer);
{$IFDEF PUREPASCAL}
var
  P: Pointer;
begin
  P := @StrArray;
  while Count > 0 do
  begin
    _UStrClr(P^);
    Dec(Count);
    Inc(PByte(P), SizeOf(Pointer));
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to str      }
        {       EDX Count               }

        {$IFDEF ALIGN_STACK}
        SUB     ESP,4
        {$ENDIF ALIGN_STACK}
        PUSH    EBX
        PUSH    ESI
        MOV     EBX,EAX
        MOV     ESI,EDX

@@loop:
        MOV     EDX,[EBX]                       { fetch str                     }
        TEST    EDX,EDX                         { if nil, nothing to do         }
        JE      @@doneEntry
        MOV     dword ptr [EBX],0               { clear str                     }
        MOV     ECX,[EDX-skew].StrRec.refCnt    { fetch refCnt                  }
        DEC     ECX                             { if < 0: literal str           }
        JL      @@doneEntry
   LOCK DEC     [EDX-skew].StrRec.refCnt        { threadsafe dec refCount       }
        JNE     @@doneEntry
        LEA     EAX,[EDX-skew]                  { if refCnt now zero, deallocate}
        CALL    _FreeMem
@@doneEntry:
        ADD     EBX,4
        DEC     ESI
        JNE     @@loop

        POP     ESI
        POP     EBX
        {$IFDEF ALIGN_STACK}
        ADD     ESP,4
        {$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


procedure _LStrArrayClr(var StrArray; Count: Integer);
{$IFDEF PUREPASCAL}
var
  P: Pointer;
begin
  P := @StrArray;
  while Count > 0 do
  begin
    _LStrClr(P^);
    Dec(Count);
    Inc(PByte(P), SizeOf(Pointer));
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to str      }
        {       EDX Count               }

        {$IFDEF ALIGN_STACK}
        SUB     ESP,4
        {$ENDIF ALIGN_STACK}
        PUSH    EBX
        PUSH    ESI
        MOV     EBX,EAX
        MOV     ESI,EDX

@@loop:
        MOV     EDX,[EBX]                       { fetch str                     }
        TEST    EDX,EDX                         { if nil, nothing to do         }
        JE      @@doneEntry
        MOV     dword ptr [EBX],0               { clear str                     }
        MOV     ECX,[EDX-skew].StrRec.refCnt    { fetch refCnt                  }
        DEC     ECX                             { if < 0: literal str           }
        JL      @@doneEntry
   LOCK DEC     [EDX-skew].StrRec.refCnt        { threadsafe dec refCount       }
        JNE     @@doneEntry
        LEA     EAX,[EDX-skew].StrRec.codePage  { if refCnt now zero, deallocate}
        CALL    _FreeMem
@@doneEntry:
        ADD     EBX,4
        DEC     ESI
        JNE     @@loop

        POP     ESI
        POP     EBX
        {$IFDEF ALIGN_STACK}
        ADD     ESP,4
        {$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


procedure _WStrArrayClr(var StrArray; Count: Integer);
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
  _UStrArrayClr(StrArray, Count);
end;
{$ELSE !PUREPASCAL}
asm
        JMP     _UStrArrayClr
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
var
  S: PPointer;
  P: Pointer;
begin
  S := PPointer(@StrArray);
  while Count > 0 do
  begin
    P := S^;
    if P <> nil then
    begin
      S^ := nil;
      SysFreeString(_WideStr(P));
    end;
    Inc(S);
    Dec(Count);
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to str      }
        {       EDX cnt                 }

        PUSH    EBX
        PUSH    ESI
        MOV     EBX,EAX
        MOV     ESI,EDX
@@1:    MOV     EAX,[EBX]
        TEST    EAX,EAX
        JE      @@2
        MOV     DWORD PTR [EBX],0
        PUSH    EAX
        CALL    SysFreeString
@@2:    ADD     EBX,4
        DEC     ESI
        JNE     @@1
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}


function _UStrAddRef(Str: Pointer): Pointer;
{$IFDEF PUREPASCAL}
var
  P: PStrRec;
begin
  Result := Str;
  if Str <> nil then
  begin
    P := Pointer(PByte(Str) - SizeOf(StrRec));
    if P.refcnt >= 0 then
      AtomicIncrement(P.refcnt);
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     str     }
        TEST    EAX,EAX
        JE      @@exit
        MOV     EDX,[EAX-skew].StrRec.refCnt
        INC     EDX
        JLE     @@exit
   LOCK INC     [EAX-skew].StrRec.refCnt
@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function _LStrAddRef(Str: Pointer): Pointer;
{$IFDEF PUREPASCAL}
var
  P: PStrRec;
begin
  Result := Str;
  if Str <> nil then
  begin
    P := Pointer(PByte(Str) - SizeOf(StrRec));
    if P.refcnt >= 0 then
      AtomicIncrement(P.refcnt);
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     str     }
        TEST    EAX,EAX
        JE      @@exit
        MOV     EDX,[EAX-skew].StrRec.refCnt
        INC     EDX
        JLE     @@exit
   LOCK INC     [EAX-skew].StrRec.refCnt
@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


// Note: Windows version of _WideStr is single reference.
//       Only _WStrAddRef for Windows of *StrAddRef versions has
//       'var' parameter.
{$IFDEF POSIX}
function _WStrAddRef(Str: Pointer): Pointer;
{$IFDEF PUREPASCAL}
begin
  Result := _UStrAddRef(Str);
end;
{$ELSE !PUREPASCAL}
asm
        JMP     _UStrAddRef
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
function _WStrAddRef(var Str: _WideStr): Pointer;
{$IFDEF PUREPASCAL}
var
  Len: Integer;
begin
  Result := Pointer(Str);
  if Pointer(Str) <> nil then
  begin
    Len := __StringLength(Str);
    Result := Pointer(SysAllocStringLen(PWideChar(Pointer(Str)), Len));
    if Result = nil then
      WStrError;
    Pointer(Str) := Result;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to _WideStr     }
        { <-    EAX     str                     }
        MOV     EDX,[EAX]
        TEST    EDX,EDX
        JE      @@1
        PUSH    EAX
        MOV     ECX,[EDX-4]
        SHR     ECX,1
        PUSH    ECX
        PUSH    EDX
        CALL    SysAllocStringLen
        POP     EDX
        TEST    EAX,EAX
        JE      WStrError
        MOV     [EDX],EAX
@@1:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}


{ ----------------------------------------------------- }
{       internal string conversion                      }
{ ----------------------------------------------------- }


function CharFromWChar(CharDest: _PAnsiChr; DestBytes: Integer; const WCharSource: PWideChar; SrcChars: Integer; CodePage: Integer): Integer;
begin
  if CodePage = 0 then
{$IFDEF NEXTGEN}
    CodePage := CP_UTF8;
{$ELSE  NEXTGEN}
    CodePage := DefaultSystemCodePage;
{$ENDIF NEXTGEN}
  Result := LocaleCharsFromUnicode(CodePage, 0, WCharSource, SrcChars, CharDest,
    DestBytes, nil, nil);
end;

function CharFromWChar(CharDest: _PAnsiChr; DestBytes: Integer; const WCharSource: PWideChar; SrcChars: Integer): Integer;
begin
  Result := CharFromWChar(CharDest, DestBytes, WCharSource, SrcChars, DefaultSystemCodePage);
end;

function WCharFromChar(WCharDest: PWideChar; DestChars: Integer; const CharSource: _PAnsiChr; SrcBytes: Integer; CodePage: Integer): Integer;
begin
  Result := UnicodeFromLocaleChars(CodePage, 0, CharSource, SrcBytes, WCharDest,
    DestChars);
end;


{ ----------------------------------------------------- }
{       basic string constructors                       }
{ ----------------------------------------------------- }

procedure _UStrFromPWCharLen(var Dest: UnicodeString; Source: PWideChar; CharLength: Integer);
{$IFDEF PUREPASCAL}
var
  Temp: Pointer;
begin
  Temp := Pointer(Dest);
  if CharLength > 0 then
  begin
    Pointer(Dest) := _NewUnicodeString(CharLength);
    if Source <> nil then
      Move(Source^, Pointer(Dest)^, CharLength * SizeOf(WideChar));
  end
  else
    Pointer(Dest) := nil;
  _UStrClr(Temp);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest         }
        {       EDX     source                  }
        {       ECX     length in characters    }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV     EBX,EAX // EBX := addr of Dest (result) in EBX
        MOV     ESI,EDX // ESI := source
        MOV     EDI,ECX // EDI := length

        { allocate new string }

        MOV     EAX,EDI // EAX := length

        CALL    _NewUnicodeString // EAX := new string (result)
        MOV     ECX,EDI // ECX := length
        MOV     EDI,EAX // EDI := result

        TEST    ESI,ESI // nil source?
        JE      @@noMove

        MOV     EDX,EAX // EDX := result (dest for Move)
        MOV     EAX,ESI // EAX := source (source for Move)
        SHL     ECX,1   // ECX := ECX * 2 (turn length into characters)
        CALL    Move

        { assign the result to dest }

@@noMove:
        MOV     EAX,EBX
        CALL    _LStrClr
        MOV     [EBX],EDI

        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _WStrFromPWCharLen(var Dest: _WideStr; Source: PWideChar; CharLength: Integer);
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
  _UStrFromPWCharLen(UnicodeString(Pointer(Dest)), Source, CharLength);
end;
{$ELSE !PUREPASCAL}
asm
        JMP     _UStrFromPWCharLen
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
var
  Temp: Pointer;
begin
  if CharLength <= 0 then
    _WStrClr(Dest)
  else
  begin
    Temp := SysAllocStringLen(Source, CharLength);
    if Temp = nil then
      WStrError;
  //  Temp := InterlockedExchangePointer(Pointer(Dest), Temp);
  //  if Temp <> nil then
  //    SysFreeString(_WideStr(Temp));
    if Pointer(Dest) <> nil then
      SysFreeString(Dest);
    Pointer(Dest) := Temp;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to _WideStr (dest)      }
        {       EDX     Pointer to characters (source)    }
        {       ECX     number of characters  (not bytes) }
        TEST    ECX,ECX
        JE      _WStrClr

        PUSH    EAX

        PUSH    ECX
        PUSH    EDX
        CALL    SysAllocStringLen
        TEST    EAX,EAX
        POP     EDX
        JE      WStrError

        {$IFDEF ALIGN_STACK}
        SUB     ESP,8
        {$ENDIF ALIGN_STACK}
        PUSH    [EDX].PWideChar
        MOV     [EDX],EAX

        CALL    SysFreeString
        {$IFDEF ALIGN_STACK}
        ADD     ESP,8
        {$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
  _UStrFromPWCharLen(UnicodeString(Pointer(Dest)), Source, CharLength);
end;
{$ENDIF !MSWINDOWS and !POSIX}

                                                                                                                                           
procedure _LStrFromPCharLen(var Dest: _AnsiStr; Source: _PAnsiChr; Length: Integer; CodePage: Word);
{$IFDEF PUREPASCAL}
var
  P: _PAnsiChr;
begin
  P := _NewAnsiString(Length, CodePage);
  if Source <> nil then
    Move(Source^, P^, Length);
  _LStrClr(Dest);
  Pointer(Dest) := P;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
        { ->    EAX     pointer to dest }
        {       EDX     source          }
        {       ECX     length          }
        {       [ESP+0] caller EBP      }
        {       [ESP+4] return address  }
        {       [ESP+8] CodePage        }
{$IFDEF ALIGN_STACK}
        // EBP is already pushed on the stack
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EDI,ECX

        { allocate new string }

        MOV     EAX,EDI
        MOVZX   EDX,CodePage

        CALL    _NewAnsiString
        MOV     ECX,EDI
        MOV     EDI,EAX

        TEST    ESI,ESI
        JE      @@noMove

        MOV     EDX,EAX
        MOV     EAX,ESI
        CALL    Move

        { assign the result to dest }

@@noMove:
        MOV     EAX,EBX
        CALL    _LStrClr
        MOV     [EBX],EDI

        POP     EDI
        POP     ESI
        POP     EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure InternalUStrFromPCharLen(var Dest: UnicodeString; Source: _PAnsiChr; Length: Integer; CodePage: Integer);
var
  DestLen: Integer;
  Buffer: array[0..2047] of WideChar;
begin
  if Length <= 0 then
  begin
    _UStrClr(Dest);
    Exit;
  end;
  if Length+1 < High(Buffer) then
  begin
    DestLen := WCharFromChar(Buffer, High(Buffer), Source, Length, CodePage);
    if DestLen > 0 then
    begin
      _UStrFromPWCharLen(Dest, @Buffer, DestLen);
      Exit;
    end;
  end;

  DestLen := (Length + 1);
  _UStrSetLength(Dest, DestLen);  // overallocate, trim later
  DestLen := WCharFromChar(Pointer(Dest), DestLen, Source, Length, CodePage);
  if DestLen < 0 then
    DestLen := 0;
  _UStrSetLength(Dest, DestLen);
                                                                   
end;

procedure _UStrFromPCharLen(var Dest: UnicodeString; Source: _PAnsiChr; Length: Integer);
begin
  InternalUStrFromPCharLen(Dest, Source, Length, DefaultSystemCodePage);
end;

procedure InternalWStrFromPCharLen(var Dest: _WideStr; Source: _PAnsiChr; Length: Integer; CodePage: Integer);
var
  DestLen: Integer;
  Buffer: array[0..2047] of WideChar;
begin
  if Length <= 0 then
  begin
    _WStrClr(Dest);
    Exit;
  end;
  if Length+1 < High(Buffer) then
  begin
    DestLen := WCharFromChar(Buffer, High(Buffer), Source, Length, CodePage);
    if DestLen > 0 then
    begin
      _WStrFromPWCharLen(Dest, @Buffer, DestLen);
      Exit;
    end;
  end;

  DestLen := (Length + 1);
  _WStrSetLength(Dest, DestLen);  // overallocate, trim later
  DestLen := WCharFromChar(PWideChar(Pointer(Dest)), DestLen, Source, Length, CodePage);
  if DestLen < 0 then DestLen := 0;
  _WStrSetLength(Dest, DestLen);
                                                                   
end;

procedure _WStrFromPCharLen(var Dest: _WideStr; Source: _PAnsiChr; Length: Integer);
begin
  InternalWStrFromPCharLen(Dest, Source, Length, DefaultSystemCodePage);
end;

procedure _LStrFromPWCharLen(var Dest: _AnsiStr; Source: PWideChar; Length: Integer; CodePage: Word);
var
  DestLen: Integer;
begin
  if Length <= 0 then
  begin
    _LStrClr(Dest);
    Exit;
  end;

  if CodePage = 0 then
{$IFDEF NEXTGEN}
    CodePage := CP_UTF8;
{$ELSE  NEXTGEN}
    CodePage := DefaultSystemCodePage;
{$ENDIF NEXTGEN}

  DestLen := CharFromWChar(nil, 0, Source, Length, CodePage);
  SetLength(Dest, DestLen);
  if DestLen > 0 then
  begin
    CharFromWChar(Pointer(Dest), DestLen, Source, Length, CodePage);
    PStrRec(PByte(Dest) - SizeOf(StrRec)).codePage := CodePage;
  end
  else
    _LStrClr(Dest);
end;


{ ----------------------------------------------------- }
{       Compiler helper for string assignment           }
{ ----------------------------------------------------- }

procedure _UStrAsg(var Dest: UnicodeString; const Source: UnicodeString); // globals (need copy)
{$IFDEF PUREPASCAL}
var
  S, D: Pointer;
  P: PStrRec;
  Len: Integer;
begin
  S := Pointer(Source);
  if S <> nil then
  begin
    if __StringRefCnt(Source) < 0 then   // make copy of string literal
    begin
      Len := __StringLength(Source);
      S := _NewUnicodeString(Len);
      Move(Pointer(Source)^, S^, Len * SizeOf(WideChar));
    end else
    begin
      P := PStrRec(PByte(S) - SizeOf(StrRec));
      AtomicIncrement(P.refCnt);
    end;
  end;
  D := Pointer(Dest);
  Pointer(Dest) := S;
  _UStrClr(D);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to dest   str       }
        { ->    EDX pointer to source str       }

        TEST    EDX,EDX                         { have a source? }
        JE      @@2                             { no -> jump     }

        MOV     ECX,[EDX-skew].StrRec.refCnt
        INC     ECX
        JG      @@1                             { literal string -> jump not taken }

        {$IFDEF ALIGN_STACK}
        SUB     ESP,4
        {$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        MOV     EAX,[EDX-skew].StrRec.length
        CALL    _NewUnicodeString
        MOV     EDX,EAX
        POP     EAX
        PUSH    EDX
        MOV     ECX,[EAX-skew].StrRec.length
        SHL     ECX,1                           { length to bytes for move }
        CALL    Move
        POP     EDX
        POP     EAX
        {$IFDEF ALIGN_STACK}
        ADD     ESP,4
        {$ENDIF ALIGN_STACK}
        JMP     @@2

@@1:
   LOCK INC     [EDX-skew].StrRec.refCnt

@@2:    XCHG    EDX,[EAX]
        TEST    EDX,EDX
        JE      @@3
        MOV     ECX,[EDX-skew].StrRec.refCnt
        DEC     ECX
        JL      @@3
   LOCK DEC     [EDX-skew].StrRec.refCnt
        JNE     @@3
        LEA     EAX,[EDX-skew].StrRec.codePage
        {$IFDEF ALIGN_STACK}
        SUB     ESP,12
        {$ENDIF ALIGN_STACK}
        CALL    _FreeMem
        {$IFDEF ALIGN_STACK}
        ADD     ESP,12
        {$ENDIF ALIGN_STACK}
@@3:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrLAsg(var Dest: UnicodeString; const Source: UnicodeString); // locals
{$IFDEF PUREPASCAL}
var
  P: Pointer;
begin
  if Pointer(Source) <> nil then
    _UStrAddRef(Pointer(Source));
  P := Pointer(Dest);
  Pointer(Dest) := Pointer(Source);
  _UStrClr(P);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest }
        {       EDX     source          }

        TEST    EDX,EDX
        JE      @@sourceDone

        { bump up the ref count of the source }

        MOV     ECX,[EDX-skew].StrRec.refCnt
        INC     ECX
        JLE     @@sourceDone                    { literal assignment -> jump taken }
   LOCK INC     [EDX-skew].StrRec.refCnt
@@sourceDone:

        { we need to release whatever the dest is pointing to   }

        XCHG    EDX,[EAX]                       { fetch str                    }
        TEST    EDX,EDX                         { if nil, nothing to do        }
        JE      @@done
        MOV     ECX,[EDX-skew].StrRec.refCnt    { fetch refCnt                 }
        DEC     ECX                             { if < 0: literal str          }
        JL      @@done
   LOCK DEC     [EDX-skew].StrRec.refCnt        { threadsafe dec refCount      }
        JNE     @@done
        LEA     EAX,[EDX-skew].StrRec.codePage  { if refCnt now zero, deallocate}
        {$IFDEF ALIGN_STACK}
        SUB     ESP,12
        {$ENDIF ALIGN_STACK}
        CALL    _FreeMem
        {$IFDEF ALIGN_STACK}
        ADD     ESP,12
        {$ENDIF ALIGN_STACK}
@@done:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


procedure _WStrAsg(var Dest: _WideStr; const Source: _WideStr);
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
  _UStrAsg(UnicodeString(Pointer(Dest)), UnicodeString(Pointer(Source)));
end;
{$ELSE}
asm
        { ->    EAX     Pointer to _WideStr }
        {       EDX     Pointer to data       }

        JMP     _UStrAsg
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
var
  Len: Integer;
begin
  if Pointer(Dest) <> Pointer(Source) then
  begin
    if Pointer(Source) = nil then
      _WStrClr(Dest)
    else
    begin
      Len := __StringLength(Source);
      if Len = 0 then
        _WStrClr(Dest)
      else
      begin
        if not SysReAllocStringLen(Dest, PWideChar(Pointer(Source)), Len) then
          WStrError;
      end;
    end;
  end;
end;
{$ELSE}
asm
        { ->    EAX     Pointer to _WideStr }
        {       EDX     Pointer to data       }
        CMP     [EAX],EDX
        JE      @@1
        TEST    EDX,EDX
        JE      _WStrClr
        MOV     ECX,[EDX-4]
        SHR     ECX,1
        JE      _WStrClr
        PUSH    ECX
        PUSH    EDX
        PUSH    EAX
        CALL    SysReAllocStringLen
        TEST    EAX,EAX
        JE      WStrError
@@1:
end;
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
  _UStrAsg(UnicodeString(Pointer(Dest)), UnicodeString(Pointer(Source)));
end;
{$ENDIF !MSWINDOWS and !POSIX}

procedure _WStrLAsg(var Dest: _WideStr; const Source: _WideStr);
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
  _UStrLAsg(UnicodeString(Pointer(Dest)), UnicodeString(Pointer(Source)));
end;
{$ELSE}
asm
        JMP     _UStrLAsg
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
begin
  _WStrAsg(Dest, Source);
end;
{$ELSE}
asm
        JMP   _WStrAsg
end;
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
  _UStrLAsg(UnicodeString(Pointer(Dest)), UnicodeString(Pointer(Source)));
end;
{$ENDIF !MSWINDOWS and !POSIX}


{ 99.03.11
  This function is used when assigning to global variables.

  Literals are copied to prevent a situation where a dynamically
  allocated DLL or package assigns a literal to a variable and then
  is unloaded -- thereby causing the string memory (in the code
  segment of the DLL) to be removed -- and therefore leaving the
  global variable pointing to invalid memory.
}
procedure _LStrAsg(var Dest: _AnsiStr; const Source: _AnsiStr);
{$IFDEF PUREPASCAL}
var
  S, D: Pointer;
  P: PStrRec;
  Len: Integer;
begin
  S := Pointer(Source);
  if S <> nil then
  begin
    if __StringRefCnt(S) < 0 then   // make copy of string literal
    begin
      Len := __StringLength(S);
      S := _NewAnsiString(Len, __StringCodePage(S));
      Move(_PAnsiChr(Source)^, S^, Len);
    end else
    begin
      P := PStrRec(PByte(S) - SizeOf(StrRec));
      AtomicIncrement(P.refCnt);
    end;
  end;
  D := Pointer(Dest);
  Pointer(Dest) := S;
  _LStrClr(D);
end;
{$ELSE}
asm
        { ->    EAX pointer to dest   str       }
        { ->    EDX pointer to source str       }

        TEST    EDX,EDX                         { have a source? }
        JE      @@2                             { no -> jump     }

        MOV     ECX,[EDX-skew].StrRec.refCnt
        INC     ECX
        JG      @@1                             { literal string -> jump not taken }

{$IFDEF ALIGN_STACK}
        SUB     ESP,4
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        MOV     EAX,[EDX-skew].StrRec.length
        MOVZX   EDX,[EDX-skew].StrRec.codePage
        CALL    _NewAnsiString
        MOV     EDX,EAX
        POP     EAX
        PUSH    EDX
        MOV     ECX,[EAX-skew].StrRec.length
        CALL    Move
        POP     EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP,4
{$ENDIF ALIGN_STACK}
        JMP     @@2

@@1:
   LOCK INC     [EDX-skew].StrRec.refCnt

@@2:    XCHG    EDX,[EAX]
        TEST    EDX,EDX
        JE      @@3
        MOV     ECX,[EDX-skew].StrRec.refCnt
        DEC     ECX
        JL      @@3
   LOCK DEC     [EDX-skew].StrRec.refCnt
        JNE     @@3
        LEA     EAX,[EDX-skew].StrRec.codePage // Beginning of StrRec
{$IFDEF ALIGN_STACK}
        SUB     ESP,12
{$ENDIF ALIGN_STACK}
        CALL    _FreeMem
{$IFDEF ALIGN_STACK}
        ADD     ESP,12
{$ENDIF ALIGN_STACK}
@@3:
end;
{$ENDIF !PUREPASCAL}

procedure _LStrLAsg(var Dest: _AnsiStr; const Source: _AnsiStr);
{$IFDEF PUREPASCAL}
var
  P: Pointer;
begin
  P := Pointer(Source);
  if P <> nil then
    _LStrAddRef(P);
  P := Pointer(Dest);
  Pointer(Dest) := Pointer(Source);
  _LStrClr(P);
end;
{$ELSE}
asm
        { ->    EAX     pointer to dest }
        {       EDX     source          }

        TEST    EDX,EDX
        JE      @@sourceDone

        { bump up the ref count of the source }

        MOV     ECX,[EDX-skew].StrRec.refCnt
        INC     ECX
        JLE     @@sourceDone                    { literal assignment -> jump taken }
   LOCK INC     [EDX-skew].StrRec.refCnt
@@sourceDone:

        { we need to release whatever the dest is pointing to   }

        XCHG    EDX,[EAX]                       { fetch str                    }
        TEST    EDX,EDX                         { if nil, nothing to do        }
        JE      @@done
        MOV     ECX,[EDX-skew].StrRec.refCnt    { fetch refCnt                 }
        DEC     ECX                             { if < 0: literal str          }
        JL      @@done
   LOCK DEC     [EDX-skew].StrRec.refCnt        { threadsafe dec refCount      }
        JNE     @@done
        LEA     EAX,[EDX-skew].StrRec.codePage  { if refCnt now zero, deallocate}
{$IFDEF ALIGN_STACK}
        SUB     ESP,12
{$ENDIF ALIGN_STACK}
        CALL    _FreeMem
{$IFDEF ALIGN_STACK}
        ADD     ESP,12
{$ENDIF ALIGN_STACK}
@@done:
end;
{$ENDIF !PUREPASCAL}


{ ----------------------------------------------------- }
{       string info utilities                           }
{ ----------------------------------------------------- }

function StringElementSize(const S: UnicodeString): Word; overload;
begin
  if S <> '' then
    Result := PWord(PByte(S) - 10)^                          // StrRec.elemSize
  else
    Result := SizeOf(WideChar);
end;

function StringElementSize(const S: _RawByteStr): Word; overload;
begin
  if S <> '' then
    Result := PWord(PByte(S) - 10)^                          // StrRec.elemSize
  else
    Result := SizeOf(_AnsiChr);
end;

{$IFNDEF MSWINDOWS}
function StringElementSize(const S: _WideStr): Word; overload;
begin
  if S <> '' then
    Result := PWord(PByte(S) - 10)^                          // StrRec.elemSize
  else
    Result := SizeOf(WideChar);
end;
{$ENDIF !MSWINDOWS}

function StringCodePage(const S: UnicodeString): Word; overload;
begin
  if S <> '' then
    Result := PWord(PByte(S) - 12)^                          // StrRec.codePage
  else
    Result := Word(DefaultUnicodeCodePage);
end;

function StringCodePage(const S: _RawByteStr): Word; overload;
begin
  if S <> '' then
    Result := PWord(PByte(S) - 12)^                          // StrRec.codePage
  else
{$IFDEF NEXTGEN}
    Result := Word(CP_UTF8);
{$ELSE  NEXTGEN}
    Result := Word(DefaultSystemCodePage);
{$ENDIF NEXTGEN}
end;

{$IFNDEF MSWINDOWS}
function StringCodePage(const S: _WideStr): Word; overload;
begin
  if S <> '' then
    Result := PWord(PByte(S) - 12)^                          // StrRec.codePage
  else
    Result := Word(DefaultUnicodeCodePage);
end;
{$ENDIF !MSWINDOWS}

function StringRefCount(const S: UnicodeString): Integer;
begin
  if Pointer(S) <> nil then           // PStrRec should be used here, but
    Result := PInteger(PByte(S) - 8)^ // a private symbol can't be inlined
  else
    Result := 0;
end;

function StringRefCount(const S: _RawByteStr): Integer;
begin
  if Pointer(S) <> nil then           // PStrRec should be used here, but
    Result := PInteger(PByte(S) - 8)^ // a private symbol can't be inlined
  else
    Result := 0;
end;

{$IFNDEF MSWINDOWS}
function StringRefCount(const S: _WideStr): Integer;
begin
  if Pointer(S) <> nil then           // PStrRec should be used here, but
    Result := PInteger(PByte(S) - 8)^ // a private symbol can't be inlined
  else
    Result := 0;
end;
{$ENDIF !MSWINDOWS}


{ ----------------------------------------------------- }
{       Compiler helper for string length               }
{ ----------------------------------------------------- }

function _UStrLen(const S: UnicodeString): Integer;
{$IFDEF CPU64BITS}
begin
  Result := 0;
  if Pointer(S) <> nil then            // PStrRec should be used here, but
    Result := PInteger(PByte(S) - 4)^; // a private symbol can't be inlined
end;
{$ELSE !CPU64BITS}
begin
  Result := IntPtr(S);
  if Result <> 0 then                       // PStrRec should be used here, but
    Result := PInteger(PByte(Result - 4))^; // a private symbol can't be inlined
end;
{$ENDIF !CPU64BITS}

function _WStrLen(const S: _WideStr): Integer; inline;
{$IFDEF CPU64BITS}
begin
  Result := 0;
  if Pointer(S) <> nil then
    {$IFDEF MSWINDOWS}
    Result := PInteger(PByte(S) - 4)^ shr 1;
    {$ELSE}
    Result := PInteger(PByte(S) - 4)^;
    {$ENDIF}
end;
{$ELSE !CPU64BITS}
begin
  Result := IntPtr(S);
  if Result <> 0 then
    {$IFDEF MSWINDOWS}
    Result := PInteger(PByte(Result - 4))^ shr 1;
    {$ELSE}
    Result := PInteger(PByte(Result - 4))^;
    {$ENDIF}
end;
{$ENDIF !CPU64BITS}

function _LStrLen(const S: _RawByteStr): Integer;
{$IFDEF CPU64BITS}
begin
  Result := 0;
  if Pointer(S) <> nil then            // PStrRec should be used here, but
    Result := PInteger(PByte(S) - 4)^; // a private symbol can't be inlined
end;
{$ELSE !CPU64BITS}
begin
  Result := IntPtr(S);
  if Result <> 0 then                       // PStrRec should be used here, but
    Result := PInteger(PByte(Result - 4))^; // a private symbol can't be inlined
end;
{$ENDIF !CPU64BITS}

{$IFDEF PUREPASCAL}
function _PStrLen(const str: _ShortStr): Integer; inline;
begin
  Result := Byte(str[0]);
end;
{$ENDIF PUREPASCAL}

function _PCharLen(P: _PAnsiChr): Integer;
{$IFNDEF LEGACY_PCHARLEN}
begin
  Result := 0;
  if P <> nil then
    while P[Result] <> #0 do
      Inc(Result);
end;
{$ELSE !LEGACY_PCHARLEN}
{$IFDEF CPUX86}
asm
        TEST    EAX,EAX
        JE      @@5
        PUSH    EAX
        XOR     ECX,ECX
@@0:    CMP     CL,[EAX+0]
        JE      @@4
        CMP     CL,[EAX+1]
        JE      @@3
        CMP     CL,[EAX+2]
        JE      @@2
        CMP     CL,[EAX+3]
        JE      @@1
        ADD     EAX,4
        JMP     @@0
@@1:    INC     EAX
@@2:    INC     EAX
@@3:    INC     EAX
@@4:    POP     ECX
        SUB     EAX,ECX
@@5:
end;
{$ENDIF CPUX86}
{$ENDIF !LEGACY_PCHARLEN}

function _PWCharLen(P: PWideChar): Integer;
{$IFNDEF LEGACY_PWCHARLEN}
begin
  Result := 0;
  if P <> nil then
    while P[Result] <> #0 do
      Inc(Result);
end;
{$ELSE !LEGACY_PWCHARLEN}
{$IFDEF CPUX86}
asm
        TEST    EAX,EAX
        JE      @@5
        PUSH    EAX
        XOR     ECX,ECX
@@0:    CMP     CX,[EAX+0]
        JE      @@4
        CMP     CX,[EAX+2]
        JE      @@3
        CMP     CX,[EAX+4]
        JE      @@2
        CMP     CX,[EAX+6]
        JE      @@1
        ADD     EAX,8
        JMP     @@0
@@1:    ADD     EAX,2
@@2:    ADD     EAX,2
@@3:    ADD     EAX,2
@@4:    POP     ECX
        SUB     EAX,ECX
        SHR     EAX,1
@@5:
end;
{$ENDIF CPUX86}
{$ENDIF !LEGACY_PWCHARLEN}


{ ----------------------------------------------------- }
{       internal UniqueString* support functions        }
{ ----------------------------------------------------- }

function InternalUniqueStringU(var Str: UnicodeString): Pointer;
{$IFDEF PUREPASCAL}
var
  P: PStrRec;
begin
  Result := Pointer(Str);
  if Result <> nil then
  begin
    Result := Pointer(Str);
    P := Pointer(PByte(Str) - SizeOf(StrRec));
    if P.refCnt <> 1 then
    begin
      Result := _NewUnicodeString(P.length);
      Move(PWideChar(Str)^, PWideChar(Result)^, P.length * SizeOf(WideChar));
      _UStrClr(Str);
      Pointer(Str) := Result;
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to str              }
        { <-    EAX pointer to unique copy      }
        MOV     EDX,[EAX]       // EDX := str
        TEST    EDX,EDX         // nil?
        JE      @@exit
        MOV     ECX,[EDX-skew].StrRec.refCnt // ECX := str.refCnt
        DEC     ECX             // refCnt = 1?
        JE      @@exit

        PUSH    EBX
        {$IFDEF ALIGN_STACK}
        SUB     ESP, 8
        {$ENDIF ALIGN_STACK}
        MOV     EBX,EAX         // EBX := @str
        MOV     EAX,[EDX-skew].StrRec.length
        CALL    _NewUnicodeString
        MOV     EDX,EAX         // EDX := newStr
        XCHG    EAX,[EBX]       // EAX := str ; @str^ := newStr
        {$IFDEF ALIGN_STACK}
        MOV     [ESP],EAX       // save str
        {$ELSE !ALIGN_STACK}
        PUSH    EAX             // save str
        {$ENDIF !ALIGN_STACK}
        MOV     ECX,[EAX-skew].StrRec.length
        SHL     ECX,1           // ECX := Length(str) * 2
        CALL    Move            // Move(str, newStr, Length(str) * 2)
        {$IFDEF ALIGN_STACK}
        MOV    EAX,[ESP]        // EAX := str
        {$ELSE !ALIGN_STACK}
        POP     EAX             // EAX := str
        {$ENDIF !ALIGN_STACK}
        MOV     ECX,[EAX-skew].StrRec.refCnt // ECX := str.refCnt
        DEC     ECX
        JL      @@skip          // Was already zero?
   LOCK DEC     [EAX-skew].StrRec.refCnt
        JNZ     @@skip
        LEA     EAX,[EAX-skew].StrRec.codePage  { if refCnt now zero, deallocate}
        CALL    _FreeMem
@@skip:
        MOV     EDX,[EBX]       // EDX := @str^ (= newStr)
        {$IFDEF ALIGN_STACK}
        ADD     ESP, 8
        {$ENDIF ALIGN_STACK}
        POP     EBX
@@exit:
        MOV     EAX,EDX         // EAX := newStr
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function InternalUniqueStringA(var Str: _AnsiStr): Pointer;
{$IFDEF PUREPASCAL}
var
  P: PStrRec;
begin
  Result := Pointer(Str);
  if Result <> nil then
  begin
    Result := Pointer(Str);
    P := Pointer(PByte(Str) - sizeof(StrRec));
    if P.refCnt <> 1 then
    begin
      Result := _NewAnsiString(P.length, P.codePage);
      Move(_PAnsiChr(Str)^, _PAnsiChr(Result)^, P.length);
      _LStrClr(Str);
      Pointer(Str) := Result;
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to str              }
        { <-    EAX pointer to unique copy      }
        MOV     EDX,[EAX]
        TEST    EDX,EDX
        JE      @@exit
        MOV     ECX,[EDX-skew].StrRec.refCnt
        DEC     ECX
        JE      @@exit

        PUSH    EBX
        {$IFDEF ALIGN_STACK}
        SUB     ESP, 8
        {$ENDIF ALIGN_STACK}
        MOV     EBX,EAX
        MOV     EAX,[EDX-skew].StrRec.length
        MOVZX   EDX,[EDX-skew].StrRec.codePage
        CALL    _NewAnsiString
        MOV     EDX,EAX
        XCHG    EAX,[EBX]       // EAX := str ; @str^ := newStr
        {$IFDEF ALIGN_STACK}
        MOV     [ESP],EAX       // save str
        {$ELSE !ALIGN_STACK}
        PUSH    EAX
        {$ENDIF !ALIGN_STACK}
        MOV     ECX,[EAX-skew].StrRec.length
        CALL    Move
        {$IFDEF ALIGN_STACK}
        MOV     EAX,[ESP]       // EAX := str
        {$ELSE !ALIGN_STACK}
        POP     EAX
        {$ENDIF !ALIGN_STACK}
        MOV     ECX,[EAX-skew].StrRec.refCnt
        DEC     ECX
        JL      @@skip
   LOCK DEC     [EAX-skew].StrRec.refCnt
        JNZ     @@skip
        LEA     EAX,[EAX-skew].StrRec.codePage  { if refCnt now zero, deallocate}
        CALL    _FreeMem
@@skip:
        MOV     EDX,[EBX]
        {$IFDEF ALIGN_STACK}
        ADD     ESP, 8
        {$ENDIF ALIGN_STACK}
        POP     EBX
@@exit:
        MOV     EAX,EDX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


{ ----------------------------------------------------- }
{       Compiler helper for _UniqueString* functions    }
{ ----------------------------------------------------- }

function _UniqueStringU(var Str: UnicodeString): Pointer;
{$IFDEF PUREPASCAL}
begin
  Result := InternalUniqueStringU(Str);
end;
{$ELSE}
asm
        JMP     InternalUniqueStringU
end;
{$ENDIF !PUREPASCAL}

{$IFNDEF MSWINDOWS}
function _UniqueStringW(var Str: _WideStr): Pointer;
{$IFDEF PUREPASCAL}
begin
  Result := InternalUniqueStringU(UnicodeString(Pointer(Str)));
end;
{$ELSE}
asm
        JMP     InternalUniqueStringU
end;
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}

function _UniqueStringA(var Str: _AnsiStr): Pointer;
{$IFDEF PUREPASCAL}
begin
  Result := InternalUniqueStringA(Str);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        JMP     InternalUniqueStringA
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


{ ----------------------------------------------------- }
{       UniqueString* functions                         }
{ ----------------------------------------------------- }

procedure UniqueString(var str: UnicodeString); overload;
{$IFDEF PUREPASCAL}
begin
  InternalUniqueStringU(str);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        JMP     InternalUniqueStringU
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure UniqueString(var str: _WideStr);
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
  InternalUniqueStringU(UnicodeString(Pointer(str)));
end;
{$ELSE}
asm
        JMP     InternalUniqueStringU
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
begin
  // nothing to do - Windows WideStrings are always single reference
end;
{$ENDIF}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
  InternalUniqueStringU(UnicodeString(Pointer(str)));
end;
{$ENDIF !MSWINDOWS and !POSIX}

procedure UniqueString(var str: _AnsiStr);
{$IFDEF PUREPASCAL}
begin
  InternalUniqueStringA(str);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        JMP     InternalUniqueStringA
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


{ ------------------------------------------------------------- }
{       Compiler helper for comparing array of characters       }
{ ------------------------------------------------------------- }

{$IFDEF PUREPASCAL}
function _PStrCmp(const Left, Right: _ShortStr): Integer;
type
  PUInt32 = ^Uint32;
var
  Len, LLen, RLen: Cardinal;
  PLeft, PRight: PByte;
begin
  PLeft := PByte(@Left[0]);
  PRight := PByte(@Right[0]);
  LLen := PLeft^;
  RLen := PRight^;
  Inc(PLeft);
  Inc(PRight);
  if LLen > RLen then
    Len := RLen
  else
    Len := LLen;
  while Len >= SizeOf(UInt32) do
  begin
    if PUInt32(PLeft)^ <> PUInt32(PRight)^ then
      Break;
    if (Len < SizeOf(UInt32) * 2) or
       (PUInt32(PByte(PLeft) + SizeOf(UInt32))^ <>
       PUInt32(PByte(PRight) + SizeOf(UInt32))^) then
    begin
      Inc(PLeft, SizeOf(UInt32));
      Inc(PRight, SizeOf(UInt32));
      Dec(Len, SizeOf(UInt32));
      Break;
    end;
    Inc(PLeft, SizeOf(UInt32) * 2);
    Inc(PRight, SizeOf(UInt32) * 2);
    Dec(Len, SizeOf(UInt32) * 2);
  end;
  if Len = 0 then
    Exit(LLen - RLen);
  Result := PByte(PLeft)^ - PByte(PRight)^;
  if Result <> 0 then
    Exit;
  if Len = 1 then
    Exit(LLen - RLen);
  Result := PByte(PByte(PLeft) + 1)^ - PByte(PByte(PRight) + 1)^;
  if Result <> 0 then
    Exit;
  if Len = 2 then
    Exit(LLen - RLen);
  Result := PByte(PByte(PLeft) + 2)^ - PByte(PByte(PRight) + 2)^;
  if Result <> 0 then
    Exit;
  if Len = 3 then
    Exit(LLen - RLen);
  Result := PByte(PByte(PLeft) + 3)^ - PByte(PByte(PRight) + 3)^;
  if Result <> 0 then
    Exit;
  Exit(LLen - RLen);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
procedure       _PStrCmp;
asm
        {     ->EAX = Pointer to left string    }
        {       EDX = Pointer to right string   }
        {     <-ZF,CF = Result                  }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV     ESI,EAX
        MOV     EDI,EDX

        XOR     EAX,EAX
        XOR     EDX,EDX
        MOV     AL,[ESI]
        MOV     DL,[EDI]
        INC     ESI
        INC     EDI

        SUB     EAX,EDX { eax = len1 - len2 }
        JA      @@skip1
        ADD     EDX,EAX { edx = len2 + (len1 - len2) = len1     }

@@skip1:
        PUSH    EDX
        SHR     EDX,2
        JE      @@cmpRest
@@longLoop:
        MOV     ECX,[ESI]
        MOV     EBX,[EDI]
        CMP     ECX,EBX
        JNE     @@misMatch
        DEC     EDX
        JE      @@cmpRestP4
        MOV     ECX,[ESI+4]
        MOV     EBX,[EDI+4]
        CMP     ECX,EBX
        JNE     @@misMatch
        ADD     ESI,8
        ADD     EDI,8
        DEC     EDX
        JNE     @@longLoop
        JMP     @@cmpRest
@@cmpRestP4:
        ADD     ESI,4
        ADD     EDI,4
@@cmpRest:
        POP     EDX
        AND     EDX,3
        JE      @@equal

        MOV     CL,[ESI]
        CMP     CL,[EDI]
        JNE     @@exit
        DEC     EDX
        JE      @@equal
        MOV     CL,[ESI+1]
        CMP     CL,[EDI+1]
        JNE     @@exit
        DEC     EDX
        JE      @@equal
        MOV     CL,[ESI+2]
        CMP     CL,[EDI+2]
        JNE     @@exit

@@equal:
        ADD     EAX,EAX
        JMP     @@exit

@@misMatch:
        POP     EDX
        CMP     CL,BL
        JNE     @@exit
        CMP     CH,BH
        JNE     @@exit
        SHR     ECX,16
        SHR     EBX,16
        CMP     CL,BL
        JNE     @@exit
        CMP     CH,BH

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

{$IF not defined(X86ASMRTL)}
function _AStrCmp(const Left, Right: _PAnsiChr; Len: NativeInt): Integer;
type
  PUInt32 = ^UInt32;
var
  P1, P2: PByte;
begin
  P1 := PByte(Left);
  P2 := PByte(Right);
  Result := 0;
  while Len >= SizeOf(UInt32) do begin
    if PUInt32(P1)^ <> PUInt32(P2)^ then break;
    if (Len < SizeOf(UInt32) * 2) or
       (PUInt32(PByte(P1) + SizeOf(UInt32))^ <>
        PUInt32(PByte(P2) + SizeOf(UInt32))^) then
    begin
      Inc(P1, SizeOf(UInt32));
      Inc(P2, SizeOf(UInt32));
      Dec(Len, SizeOf(UInt32));
      break;
    end;
    Inc(P1, SizeOf(UInt32) * 2);
    Inc(P2, SizeOf(UInt32) * 2);
    Dec(Len, SizeOf(UInt32) * 2);
  end;
  if Len = 0 then Exit;
  Result := PByte(P1)^ - PByte(P2)^;
  if Result <> 0 then Exit;
  if Len = 1 then Exit;
  Result := PByte(PByte(P1) + 1)^ - PByte(PByte(P2) + 1)^;
  if Result <> 0 then Exit;
  if Len = 2 then Exit;
  Result := PByte(PByte(P1) + 2)^ - PByte(PByte(P2) + 2)^;
  if Result <> 0 then Exit;
  if Len = 3 then Exit;
  Result := PByte(PByte(P1) + 3)^ - PByte(PByte(P2) + 3)^;
end;
{$ELSE X86ASMRTL}
procedure       _AStrCmp;
asm
        {     ->EAX = Pointer to left string            }
        {       EDX = Pointer to right string           }
        {       ECX = Number of chars to compare        }
        {     <-ZF,CF = Result                          }

        PUSH    EBX
        PUSH    ESI
        PUSH    ECX
        MOV     ESI,ECX
        SHR     ESI,2
        JE      @@cmpRest

@@longLoop:
        MOV     ECX,[EAX]
        MOV     EBX,[EDX]
        CMP     ECX,EBX
        JNE     @@misMatch
        DEC     ESI
        JE      @@cmpRestP4
        MOV     ECX,[EAX+4]
        MOV     EBX,[EDX+4]
        CMP     ECX,EBX
        JNE     @@misMatch
        ADD     EAX,8
        ADD     EDX,8
        DEC     ESI
        JNE     @@longLoop
        JMP     @@cmpRest
@@cmpRestp4:
        ADD     EAX,4
        ADD     EDX,4
@@cmpRest:
        POP     ESI
        AND     ESI,3
        JE      @@exit

        MOV     CL,[EAX]
        CMP     CL,[EDX]
        JNE     @@exit
        DEC     ESI
        JE      @@equal
        MOV     CL,[EAX+1]
        CMP     CL,[EDX+1]
        JNE     @@exit
        DEC     ESI
        JE      @@equal
        MOV     CL,[EAX+2]
        CMP     CL,[EDX+2]
        JNE     @@exit

@@equal:
        XOR     EAX,EAX
        JMP     @@exit

@@misMatch:
        POP     ESI
        CMP     CL,BL
        JNE     @@exit
        CMP     CH,BH
        JNE     @@exit
        SHR     ECX,16
        SHR     EBX,16
        CMP     CL,BL
        JNE     @@exit
        CMP     CH,BH

@@exit:
        POP     ESI
        POP     EBX
end;
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
function _WStrLCmp(const Left, Right: PWideChar; Len: NativeInt): Integer;
type
  PUInt32 = ^UInt32;
var
  P1, P2: PWord;
begin
  P1 := PWord(Left);
  P2 := PWord(Right);
  Result := 0;
  while Len >= SizeOf(UInt32) div SizeOf(Word) do begin
    if PUInt32(P1)^ <> PUInt32(P2)^ then break;
    if (Len < SizeOf(UInt32) * 2 div SizeOf(Word)) or
       (PUInt32(PByte(P1) + SizeOf(UInt32))^ <>
        PUInt32(PByte(P2) + SizeOf(UInt32))^)
    then
    begin
      P1 := PWord(PByte(P1) + SizeOf(UInt32));
      P2 := PWord(PByte(P2) + SizeOf(UInt32));
      Dec(Len, SizeOf(UInt32) div SizeOf(Word));
      break;
    end;
    P1 := PWord(PByte(P1) + SizeOf(UInt32) * 2);
    P2 := PWord(PByte(P2) + SizeOf(UInt32) * 2);
    Dec(Len, SizeOf(UInt32) * 2 div SizeOf(Word));
  end;
  if Len = 0 then Exit;
  Result := PWord(P1)^ - PWord(P2)^;
  if Result <> 0 then Exit;
  if Len = 1 then Exit;
  Result := PWord(PByte(P1) + 2)^ - PWord(PByte(P2) + 2)^;
end;
{$ELSE X86ASMRTL}
procedure       _WStrLCmp;
asm
        {     ->EAX = Pointer to left wide string       }
        {       EDX = Pointer to right wide string      }
        {       ECX = Number of chars to compare        }
        {     <-ZF,CF = Result                          }

        PUSH    EBX
        PUSH    ESI
        PUSH    ECX
        MOV     ESI,ECX
        SHR     ESI,1
        JE      @@cmpRest

@@longLoop:
        MOV     ECX,[EAX]
        MOV     EBX,[EDX]
        CMP     ECX,EBX
        JNE     @@misMatch
        DEC     ESI
        JE      @@cmpRestP4
        MOV     ECX,[EAX+4]
        MOV     EBX,[EDX+4]
        CMP     ECX,EBX
        JNE     @@misMatch
        ADD     EAX,8
        ADD     EDX,8
        DEC     ESI
        JNE     @@longLoop
        JMP     @@cmpRest
@@cmpRestp4:
        ADD     EAX,4
        ADD     EDX,4
@@cmpRest:
        POP     ESI
        AND     ESI,1
        JE      @@exit

        MOV     CX,[EAX]
        CMP     CX,[EDX]
        JNE     @@exit

@@equal:
        XOR     EAX,EAX
        JMP     @@exit

@@misMatch:
        POP     ESI
        CMP     CX,BX
        JNE     @@exit
        SHR     ECX,16
        SHR     EBX,16
        CMP     CX,BX

@@exit:
        POP     ESI
        POP     EBX
end;
{$ENDIF X86ASMRTL}

{ ----------------------------------------------------- }
{       Compiler helper for _ShortStr support           }
{ ----------------------------------------------------- }

procedure       _PStrCpy(Dest: _PShortStr; Source: _PShortStr);
begin
  Move(Source^, Dest^, Byte(Source^[0])+1);
end;

procedure       _PStrNCpy(Dest: _PShortStr; Source: _PShortStr; MaxLen: Byte);
begin
  if MaxLen > Byte(Source^[0]) then
    MaxLen := Byte(Source^[0]);
  Byte(Dest^[0]) := MaxLen;
  Move(Source^[1], Dest^[1], MaxLen);
end;

procedure _PStrCat(Dest: _PShortStr; const Src: _ShortStr);
{$IFDEF PUREPASCAL}
var
  DestLen, SrcLen, I: Integer;
begin
  DestLen := _PStrLen(Dest^);
  SrcLen := _PStrLen(Src);
  if DestLen + SrcLen > 255 then
    SrcLen := 255 - DestLen;
  Byte(Dest^[0]) := DestLen + SrcLen;
  for I := 1 to SrcLen do
    Dest^[DestLen + I] := Src[I];
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
{     ->EAX = Pointer to destination string     }
{       EDX = Pointer to source string  }

        PUSH    ESI
        PUSH    EDI

{       load dest len into EAX  }

        MOV     EDI,EAX
        XOR     EAX,EAX
        MOV     AL,[EDI]

{       load source address in ESI, source len in ECX   }

        MOV     ESI,EDX
        XOR     ECX,ECX
        MOV     CL,[ESI]
        INC     ESI

{       calculate final length in DL and store it in the destination    }

        MOV     DL,AL
        ADD     DL,CL
        JC      @@trunc

@@cont:
        MOV     [EDI],DL

{       calculate final dest address    }

        INC     EDI
        ADD     EDI,EAX

{       do the copy     }

        REP     MOVSB

                 

        POP     EDI
        POP     ESI
        RET

@@trunc:
        INC     DL      {       DL = #chars to truncate                 }
        SUB     CL,DL   {       CL = source len - #chars to truncate    }
        MOV     DL,255  {       DL = maximum length                     }
        JMP     @@cont
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _PStrNCat(Dest: _PShortStr; const Src: _ShortStr; Size:Integer);
{$IFDEF PUREPASCAL}
var
  DestLen, SrcLen, I: Integer;
begin
  DestLen := _PStrLen(Dest^);
  SrcLen := _PStrLen(Src);
  if DestLen + SrcLen > Size then
    SrcLen := Size - DestLen;
  Byte(Dest^[0]) := DestLen + SrcLen;
  for I := 1 to SrcLen do
    Dest^[DestLen + I] := Src[I];
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
{     ->EAX = Pointer to destination string                     }
{       EDX = Pointer to source string                          }
{       CL  = max length of result (allocated size of dest - 1) }

        PUSH    ESI
        PUSH    EDI

{       load dest len into EAX  }

        MOV     EDI,EAX
        XOR     EAX,EAX
        MOV     AL,[EDI]

{       load source address in ESI, source len in EDX   }

        MOV     ESI,EDX
        XOR     EDX,EDX
        MOV     DL,[ESI]
        INC     ESI

{       calculate final length in AL and store it in the destination    }

        ADD     AL,DL
        JC      @@trunc
        CMP     AL,CL
        JA      @@trunc

@@cont:
        MOV     ECX,EDX
        MOV     DL,[EDI]
        MOV     [EDI],AL

{       calculate final dest address    }

        INC     EDI
        ADD     EDI,EDX

{       do the copy     }

        REP     MOVSB

@@done:
        POP     EDI
        POP     ESI
        RET

@@trunc:
{       CL = maxlen     }

        MOV     AL,CL           { AL = final length = maxlen                    }
        SUB     CL,[EDI]        { CL = length to copy = maxlen - destlen        }
        JBE     @@done
        MOV     DL,CL
        JMP     @@cont
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function _Copy(const S: _ShortStr; Index, Count: Integer): _ShortStr;
{$IFDEF PUREPASCAL}
var
  Len, I: Integer;
begin
  Len := Byte(S[0]);
  if Len = 0 then
    Byte(Result[0]) := 0
  else
  begin
    if Index <= 0 then Index := 1
    else if Index > Len then Count := 0;
    Len := Len - Index + 1;
    if Count < 0 then Count := 0
    else if Count > Len then Count := Len;
    Byte(Result[0]) := Count;
    for I := 1 to Count do
      Result[I] := S[Index + I - 1];
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
{     ->EAX     Source string                   }
{       EDX     index                           }
{       ECX     count                           }
{       [ESP+4] Pointer to result string        }
{       PUSH    EBP              }
{       MOV     EBP, ESP         }
        PUSH    ESI
        PUSH    EDI

        MOV     ESI,EAX
        MOV     EDI,[Result]

        XOR     EAX,EAX
        OR      AL,[ESI]
        JZ      @@srcEmpty

{       limit index to satisfy 1 <= index <= Length(src) }

        TEST    EDX,EDX
        JLE     @@smallInx
        CMP     EDX,EAX
        JG      @@bigInx
@@cont1:

{       limit count to satisfy 0 <= count <= Length(src) - index + 1    }

        SUB     EAX,EDX { calculate Length(src) - index + 1     }
        INC     EAX
        TEST    ECX,ECX
        JL      @@smallCount
        CMP     ECX,EAX
        JG      @@bigCount
@@cont2:

        ADD     ESI,EDX

        MOV     [EDI],CL
        INC     EDI
        REP     MOVSB
        JMP     @@exit

@@smallInx:
        MOV     EDX,1
        JMP     @@cont1
@@bigInx:
{       MOV     EDX,EAX
        JMP     @@cont1 }
@@smallCount:
        XOR     ECX,ECX
        JMP     @@cont2
@@bigCount:
        MOV     ECX,EAX
        JMP     @@cont2
@@srcEmpty:
        MOV     [EDI],AL
@@exit:
        POP     EDI
        POP     ESI
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

{$IF not defined(X86ASMRTL)}
procedure _Delete(var s: _ShortStr; Index, Count: Integer);
var
  Len, TailLen: Integer;
begin
  Len := Byte(S[0]);
  if (Index >= 1) and (Index <= Len) then
  begin
    if Count > 0 then
    begin
      TailLen := Len - Index + 1;
      if Count > TailLen then Count := TailLen;
      Byte(S[0]) := Len - Count;
      Move(S[Index+Count], S[Index], TailLen - Count);
    end;
  end;
end;
{$ELSE X86ASMRTL}
procedure _Delete(S: _PShortStr; Index, Count: Integer);
asm
{     ->EAX     Pointer to s    }
{       EDX     index           }
{       ECX     count           }

        PUSH    ESI
        PUSH    EDI

        MOV     EDI,EAX

        XOR     EAX,EAX
        MOV     AL,[EDI]

{       if index not in [1 .. Length(s)] do nothing     }

        TEST    EDX,EDX
        JLE     @@exit
        CMP     EDX,EAX
        JG      @@exit

{       limit count to [0 .. Length(s) - index + 1]     }

        TEST    ECX,ECX
        JLE     @@exit
        SUB     EAX,EDX         { calculate Length(s) - index + 1       }
        INC     EAX
        CMP     ECX,EAX
        JLE     @@1
        MOV     ECX,EAX
@@1:
        SUB     [EDI],CL        { reduce Length(s) by count                     }
        ADD     EDI,EDX         { point EDI to first char to be deleted }
        LEA     ESI,[EDI+ECX]   { point ESI to first char to be preserved       }
        SUB     EAX,ECX         { #chars = Length(s) - index + 1 - count        }
        MOV     ECX,EAX

        REP     MOVSB

@@exit:
        POP     EDI
        POP     ESI
end;
{$ENDIF X86ASMRTL}

{$IFDEF NEXTGEN}
procedure _Insert(const Source: _ShortStr; var S: _OpenString; Index: Integer);
{$ELSE}
procedure _Insert(const Source: _ShortStr; var S: OpenString; Index: Integer);
{$ENDIF}
{$IFDEF PUREPASCAL}
var
  Len: Integer;
  I: Integer;
  Len1, Len2, Len3: Integer;
begin
  Len := Byte(S[0]);
  if Index <= 0 then Index := 1
  else if Index > Len + 1 then Index := Len + 1;

  Len1 := Index - 1;
  Len2 := Byte(Source[0]);
  Len3 := Len - Len1;

  if Len1 + Len2 + Len3 > High(S) then
  begin
    if Len1 + Len2 > High(S) then
    begin
      Len3 := 0;
      Len2 := High(S) - Len1;
    end
    else
      Len3 := High(S) - Len1 - Len2;
  end;

  Byte(S[0]) := Len1 + Len2 + Len3;

  if Len2 > 0 then
  begin
    for I := Len3 downto 1 do
      S[Len1 + Len2 + I] := S[Len1 + I];
    for I := 1 to Len2 do
      S[Len1 + I] := Source[I];
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        {     ->EAX     Pointer to source string        }
        {       EDX     Pointer to destination string   }
        {       ECX     Length of destination string    }
        {       [ESP+4] Index                           }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        PUSH    ECX
        MOV     ECX,Index
        SUB     ESP,512         { VAR buf: ARRAY [0..511] of Char       }

        MOV     EBX,EDX         { save pointer to s for later   }
        MOV     ESI,EDX

        XOR     EDX,EDX
        MOV     DL,[ESI]
        INC     ESI

{       limit index to [1 .. Length(s)+1]       }

        INC     EDX
        TEST    ECX,ECX
        JLE     @@smallInx
        CMP     ECX,EDX
        JG      @@bigInx
@@cont1:
        DEC     EDX             { EDX = Length(s)               }
                                { EAX = Pointer to src          }
                                { ESI = EBX = Pointer to s      }
                                { ECX = Index                   }

{       copy index-1 chars from s to buf        }

        MOV     EDI,ESP
        DEC     ECX
        SUB     EDX,ECX         { EDX = remaining length of s   }
        REP     MOVSB

{       copy Length(src) chars from src to buf  }

        XCHG    EAX,ESI         { save pointer into s, point ESI to src         }
        MOV     CL,[ESI]        { ECX = Length(src) (ECX was zero after rep)    }
        INC     ESI
        REP     MOVSB

{       copy remaining chars of s to buf        }

        MOV     ESI,EAX         { restore pointer into s                }
        MOV     ECX,EDX         { copy remaining bytes of s             }
        REP     MOVSB

{       calculate total chars in buf    }

        SUB     EDI,ESP         { length = bufPtr - buf         }
        MOV     ECX,[ESP+512]   { ECX = Min(length, destLength) }
{       MOV     ECX,[EBP-16]   }{ ECX = Min(length, destLength) }
        CMP     ECX,EDI
        JB      @@1
        MOV     ECX,EDI
@@1:
        MOV     EDI,EBX         { Point EDI to s                }
        MOV     ESI,ESP         { Point ESI to buf              }
        MOV     [EDI],CL        { Store length in s             }
        INC     EDI
        REP     MOVSB           { Copy length chars to s        }
        JMP     @@exit

@@smallInx:
        MOV     ECX,1
        JMP     @@cont1
@@bigInx:
        MOV     ECX,EDX
        JMP     @@cont1

@@exit:
        ADD     ESP,512+4
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

// Don't use var param here - var _ShortStr is an open string param, which
// passes the ptr in EAX and the string's declared buffer length in EDX.
// Compiler codegen expects only two params for this call - ptr and newlength
procedure       _SetLength(s: _PShortStr; newLength: Byte);
begin
  Byte(s^[0]) := newLength;   // should also fill new space
end;

procedure       _SetString(s: _PShortStr; buffer: _PAnsiChr; len: Byte);
begin
  Byte(s^[0]) := len;
  if buffer <> nil then
    Move(buffer^, s^[1], len);
end;


{ ----------------------------------------------------- }
{       Compiler helper for _AnsiStr support          }
{ ----------------------------------------------------- }

procedure _LStrFromChar(var Dest: _AnsiStr; Source: _AnsiChr; CodePage: Word);
{$IFDEF PUREPASCAL}
begin
  _LStrFromPCharLen(Dest, @Source, 1, CodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest         }
        {       DL      source ANSI character   }
        {       ECX     CodePage                }
{$IFDEF ALIGN_STACK}
        SUB     ESP,4
{$ENDIF ALIGN_STACK}
        PUSH    EDX
        MOV     EDX,ESP
        PUSH    ECX
        MOV     ECX,1
        CALL    _LStrFromPCharLen
{$IFDEF ALIGN_STACK}
        ADD     ESP,8
{$ELSE !ALIGN_STACK}
        POP     EDX
{$ENDIF !ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrFromWChar(var Dest: _AnsiStr; Source: WideChar; CodePage: Word);
{$IFDEF PUREPASCAL}
begin
  _LStrFromPWCharLen(Dest, @Source, 1, CodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest         }
        {       DX      source wide character   }
        {       ECX     CodePage                }
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDX
        MOV     EDX,ESP
        PUSH    ECX
        MOV     ECX,1
        CALL    _LStrFromPWCharLen
        POP     EDX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrFromPChar(var Dest: _AnsiStr; Source: _PAnsiChr; CodePage: Word);
{$IFDEF PUREPASCAL}
var
  Len: Integer;
  P: _PAnsiChr;
begin
  Len := 0;
  if Source <> nil then
  begin
    P := Source;
    while P^ <> #0 do Inc(P);
    Len := P - Source;
  end;
  _LStrFromPCharLen(Dest, Source, Len, CodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest                 }
        {       EDX     pointer to ANSI characters      }
        {       ECX     CodePage                        }
{$IFDEF ALIGN_STACK}
        SUB     ESP,8
        PUSH    ECX
{$ELSE ALIGN_STACK}
        PUSH    [ESP]
        MOV     [ESP+4],ECX
{$ENDIF ALIGN_STACK}
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@5
        PUSH    EDX
@@0:    CMP     CL,[EDX+0]
        JE      @@4
        CMP     CL,[EDX+1]
        JE      @@3
        CMP     CL,[EDX+2]
        JE      @@2
        CMP     CL,[EDX+3]
        JE      @@1
        ADD     EDX,4
        JMP     @@0
@@1:    INC     EDX
@@2:    INC     EDX
@@3:    INC     EDX
@@4:    MOV     ECX,EDX
        POP     EDX
        SUB     ECX,EDX
@@5:
{$IFDEF ALIGN_STACK}
        CALL    _LStrFromPCharLen
        ADD     ESP,8
{$ELSE ALIGN_STACK}
        JMP     _LStrFromPCharLen
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrFromPWChar(var Dest: _AnsiStr; Source: PWideChar; CodePage: Word);
{$IFDEF PUREPASCAL}
var
  Len: Integer;
  P: PWideChar;
begin
  Len := 0;
  if Source <> nil then
  begin
    P := Source;
    while P^ <> #0 do Inc(P);
    Len := P - Source;
  end;
  _LStrFromPWCharLen(Dest, Source, Len, CodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest                 }
        {       EDX     pointer to wide characters      }
        {       ECX     CodePage                        }
{$IFDEF ALIGN_STACK}
        SUB     ESP,8
        PUSH    ECX
{$ELSE ALIGN_STACK}
        PUSH    [ESP]
        MOV     [ESP+4],ECX
{$ENDIF ALIGN_STACK}
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@5
        PUSH    EDX
@@0:    CMP     CX,[EDX+0]
        JE      @@4
        CMP     CX,[EDX+2]
        JE      @@3
        CMP     CX,[EDX+4]
        JE      @@2
        CMP     CX,[EDX+6]
        JE      @@1
        ADD     EDX,8
        JMP     @@0
@@1:    ADD     EDX,2
@@2:    ADD     EDX,2
@@3:    ADD     EDX,2
@@4:    MOV     ECX,EDX
        POP     EDX
        SUB     ECX,EDX
        SHR     ECX,1
@@5:
{$IFDEF ALIGN_STACK}
        CALL    _LStrFromPWCharLen
        ADD     ESP,8
{$ELSE ALIGN_STACK}
        JMP     _LStrFromPWCharLen
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrFromString(var Dest: _AnsiStr; const Source: _ShortStr; CodePage: Word);
{$IFDEF PUREPASCAL}
begin
  _LStrFromPCharLen(Dest, @Source[1], Byte(Source[0]), CodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest         }
        {       EDX     pointer to _ShortStr  }
        {       ECX     CodePage                }
{$IFDEF ALIGN_STACK}
        SUB     ESP,8
        PUSH    ECX
{$ELSE ALIGN_STACK}
        PUSH    [ESP]
        MOV     [ESP+4],ECX
{$ENDIF ALIGN_STACK}
        XOR     ECX,ECX
        MOV     CL,[EDX]
        INC     EDX
{$IFDEF ALIGN_STACK}
        CALL    _LStrFromPCharLen
        ADD     ESP,8
{$ELSE ALIGN_STACK}
        JMP     _LStrFromPCharLen
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrFromArray(var Dest: _AnsiStr; Source: _PAnsiChr; Length: Integer; CodePage: Word);
{$IFDEF PUREPASCAL}
var
  P: _PAnsiChr;
begin
  P := Source;
  while (Length > 0) and (P^ <> #0) do
  begin
    Dec(Length);
    Inc(P);
  end;
  Length := P - Source;
  _LStrFromPCharLen(Dest, Source, Length, CodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest                     }
        {       EDX     pointer to source ANSI characters   }
        {       ECX     number of characters of src         }
        {       [ESP+0] caller EBP                          }
        {       [ESP+4] return address                      }
        {       [ESP+8] CodePage                            }
        PUSH    EDI
        PUSH    EAX
        PUSH    ECX
        MOV     EDI,EDX
        XOR     EAX,EAX
        REPNE   SCASB
        JNE     @@1
        NOT     ECX
@@1:    POP     EAX
        ADD     ECX,EAX
        POP     EAX
        POP     EDI
        POP     EBP
        JMP     _LStrFromPCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrFromWArray(var Dest: _AnsiStr; Source: PWideChar; Length: Integer; CodePage: Word);
{$IFDEF PUREPASCAL}
var
  P: PWideChar;
begin
  P := Source;
  while (Length > 0) and (P^ <> #0) do
  begin
    Dec(Length);
    Inc(P);
  end;
  Length := P - Source;
  _LStrFromPWCharLen(Dest, Source, Length, CodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest                     }
        {       EDX     pointer to source wide characters   }
        {       ECX     number of characters of src         }
        {       [ESP+0] caller EBP                          }
        {       [ESP+4] return address                      }
        {       [ESP+8] CodePage                            }
        PUSH    EDI
        PUSH    EAX
        PUSH    ECX
        MOV     EDI,EDX
        XOR     EAX,EAX
        REPNE   SCASW
        JNE     @@1
        NOT     ECX
@@1:    POP     EAX
        ADD     ECX,EAX
        POP     EAX
        POP     EDI
        POP     EBP
        JMP     _LStrFromPWCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrFromWStr(var Dest: _AnsiStr; const Source: _WideStr; CodePage: Word);
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
  _LStrFromUStr(Dest, UnicodeString(Pointer(Source)), CodePage);
end;
{$ELSE}
asm
        JMP     _LStrFromUStr
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
var
  Len: Integer;
begin
  Len := 0;
  if Pointer(Source) <> nil then
    Len := __StringLength(Source);
  _LStrFromPWCharLen(Dest, PWideChar(Pointer(Source)), Len, CodePage);
end;
{$ELSE}
asm
        { ->    EAX     pointer to dest                 }
        {       EDX     pointer to _WideStr data      }
        {       ECX     CodePage                        }
        PUSH    [ESP]
        MOV     [ESP+4],ECX
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@1
        MOV     ECX,[EDX-4]
        SHR     ECX,1
@@1:
        JMP     _LStrFromPWCharLen
end;
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
  _LStrFromUStr(Dest, UnicodeString(Pointer(Source)), CodePage);
end;
{$ENDIF !MSWINDOWS and !POSIX}

procedure _LStrToString(Dest: _PShortStr; const Source: _AnsiStr; MaxLen: Integer);
{$IFDEF PUREPASCAL}
var
  Len: Integer;
begin
  if (Pointer(Source) = nil) or (__StringLength(Source) = 0) then
    Byte(Dest^[0]) := 0
  else
  begin
    Len := __StringLength(Source);
    if Len > MaxLen then Len := MaxLen;
    Byte(Dest^[0]) := Len;
    Move(Source[Low(string)], Dest^[1], Len);
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to result   }
        {       EDX _AnsiStr s        }
        {       ECX length of result    }

        PUSH    EBX
        TEST    EDX,EDX
        JE      @@empty
        MOV     EBX,[EDX-skew].StrRec.length
        TEST    EBX,EBX
        JE      @@empty

        CMP     ECX,EBX
        JL      @@truncate
        MOV     ECX,EBX
@@truncate:
        MOV     [EAX],CL
        INC     EAX

        XCHG    EAX,EDX
{$IFDEF ALIGN_STACK}
        SUB     ESP,8
{$ENDIF ALIGN_STACK}
        CALL    Move
{$IFDEF ALIGN_STACK}
        ADD     ESP,8
{$ENDIF ALIGN_STACK}

        JMP     @@exit

@@empty:
        MOV     byte ptr [EAX],0

@@exit:
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

                                                         
procedure _LStrCat(var Dest: _AnsiStr; const Source: _AnsiStr);
{$IFDEF PUREPASCAL}
const
  First: Cardinal = Low(string);
var
  L1, L2, Len: Cardinal;
  Temp: _PAnsiChr;
begin
  if Pointer(Source) <> nil then
  begin
    if Pointer(Dest) = nil then
      _LStrAsg(Dest, Source)
    else
    begin
      L1 := __StringLength(Dest);
      L2 := __StringLength(Source);
      Len := L1 + L2;
      if (((L1 and L2) or ((not Len) and (L1 or L2))) and $80000000) <> 0 then _IntOver;
      Temp := @Dest[First];
      _LStrSetLength(Dest, Len, __StringCodePage(Dest));
      if Temp = @Source[First] then
        Temp := @Dest[First]
      else
        Temp := @Source[First];
      Move(Temp^, Dest[L1+First], L2);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to dest }
        {       EDX     source          }

        TEST    EDX,EDX
        JE      @@exit

        MOV     ECX,[EAX]
        TEST    ECX,ECX
        JE      _LStrAsg

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EDI,ECX
        CMP     ESI,ECX
        MOV     EDI,[ECX-skew].StrRec.length

        MOV     EDX,[ESI-skew].StrRec.length
        ADD     EDX,EDI
        JO      @@lengthOverflow
        CMP     ESI,ECX
        JE      @@appendSelf

        MOVZX   ECX,[ECX-skew].StrRec.codePage
        CALL    _LStrSetLength
        MOV     EAX,ESI
        MOV     ECX,[ESI-skew].StrRec.length

@@appendStr:
        MOV     EDX,[EBX]
        ADD     EDX,EDI
        CALL    Move
        POP     EDI
        POP     ESI
        POP     EBX
        RET

@@appendSelf:
        MOVZX   ECX,[ECX-skew].StrRec.codePage
        CALL    _LStrSetLength
        MOV     EAX,[EBX]
        MOV     ECX,EDI
        JMP     @@appendStr

@@lengthOverflow:
{$IFDEF ALIGN_STACK}
        POP     EDI
        POP     ESI
        POP     EBX
{$ENDIF ALIGN_STACK}
        JMP     _IntOver

@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrCat3(var Dest:_AnsiStr; const Source1, Source2: _AnsiStr);
{$IFDEF PUREPASCAL}
var
  CodePage: Word;
  Temp: Pointer;
  L1, L2, Len: Cardinal;
begin
  if Pointer(Source1) = nil then
    _LStrAsg(Dest, Source2)
  else if Pointer(Source2) = nil then
    _LStrAsg(Dest, Source1)
  else
  begin
    if Pointer(Dest) = Pointer(Source1) then
      _LStrCat(Dest, Source2)
    else if Pointer(Dest) = Pointer(Source2) then
    begin
      L1 := __StringLength(Source1);
      L2 := __StringLength(Source2);
      Len := L1 + L2;
      if (((L1 and L2) or ((not Len) and (L1 or L2))) and $80000000) <> 0 then _IntOver;
      CodePage := __StringCodePage(Source2);
      Temp := _NewAnsiString(Len, CodePage);
      Move(_PAnsiChr(Source1)^, _PAnsiChr(Temp)[0], L1);
      Move(_PAnsiChr(Source2)^, _PAnsiChr(Temp)[L1], L2);
      _LStrClr(Dest);
      Pointer(Dest) := Temp;
    end
    else
    begin
      _LStrAsg(Dest, Source1);
      _LStrCat(Dest, Source2);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        {     ->EAX = Pointer to dest   }
        {       EDX = source1           }
        {       ECX = source2           }

        TEST    EDX,EDX
        JE      @@assignSource2

        TEST    ECX,ECX
        JE      _LStrAsg

        CMP     EDX,[EAX]
        JE      @@appendToDest

        CMP     ECX,[EAX]
        JE      @@theHardWay

{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    ECX
        CALL    _LStrAsg

        POP     EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
        JMP     _LStrCat

@@theHardWay: // s(*EAX,ECX) := source1(EDX) + s(ECX)

        PUSH    EDI

        MOV     EDI,[EDX-skew].StrRec.length  // EDI := Length(source1) + Length(source2)
        ADD     EDI,[ECX-skew].StrRec.length
        JO      @@overflow

        PUSH    EBX
        PUSH    ESI
        PUSH    EAX
        MOV     EBX,EDX   // EBX : source1
        MOV     ESI,ECX   // ESI : source2

{$IFDEF ALIGN_STACK}
        SUB     ESP,12
{$ENDIF ALIGN_STACK}
        MOV     EAX,EDI   // EAX := Final length
        MOVZX   EDX,[ESI-skew].StrRec.codePage // use source2's codepage
        CALL    _NewAnsiString
        MOV     EDI,EAX

        MOV     EDX,EDI  //Move(source1, temp[0], len(source1))
        MOV     EAX,EBX
        MOV     ECX,[EBX-skew].StrRec.length
        CALL    Move

        MOV     EDX,EDI  //Move(source2, temp[len(source1)], len(source2))
        MOV     EAX,ESI
        MOV     ECX,[ESI-skew].StrRec.length
        ADD     EDX,[EBX-skew].StrRec.length
        CALL    Move
{$IFDEF ALIGN_STACK}
        ADD     ESP,12
{$ENDIF ALIGN_STACK}

        POP     EAX
        MOV     EDX,EDI
        TEST    EDI,EDI
        JE      @@skip
        DEC     [EDI-skew].StrRec.refCnt    // EDI = local temp str - pass this reference to the caller
@@skip:
        CALL    _LStrAsg

        POP     ESI
        POP     EBX
        POP     EDI

        JMP     @@exit

@@assignSource2:
        MOV     EDX,ECX
        JMP     _LStrAsg

@@appendToDest:
        MOV     EDX,ECX
        JMP     _LStrCat

@@overflow:
        POP     EDI
        JMP     _IntOver

@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

{$IFDEF PUREPASCAL}
procedure InternalLStrCatN(var Dest: _AnsiStr; ArgCnt: Integer; Strs: _PAnsiStr);
var
  CodePage: Word;
  I, Start: Integer;
  Len, L: Integer;
  P: Pointer;
  NewDest: Pointer;
  Appending: Boolean;
begin
  CodePage := 0;
  for I := 0 to ArgCnt - 1 do
  begin
    P := PPointerArray(Strs)[I];
    if P <> nil then
    begin
      CodePage := __StringCodePage(P);
      if CodePage <> 0 then
        Break;
    end;
  end;
  Appending := False;
  Len := 0;
  for I := 0 to ArgCnt - 1 do
  begin
    P := PPointerArray(Strs)[I];
    if P <> nil then
    begin
      if P = Pointer(Dest) then
        Appending := (I = 0);
      Inc(Len, __StringLength(P));
      if Len < 0 then _IntOver;
    end;
  end;
  if Appending then
  begin
    // Dest is non-nil
    L := __StringLength(Dest);
    _LStrSetLength(Dest, Len, CodePage);
    NewDest := Pointer(Dest);
    Start := 1;
  end
  else
  begin
    NewDest := _NewAnsiString(Len, CodePage);
    Start := 0;
    L := 0;
  end;
  for I := Start to ArgCnt - 1 do
  begin
    P := PPointerArray(Strs)[I];
    if P <> nil then
    begin
      Move(P^, _PAnsiChr(NewDest)[L], __StringLength(P));
      Inc(L, __StringLength(P));
    end;
  end;
  if not Appending then
  begin
    if Pointer(Dest) <> nil then
      _LStrClr(Dest);
    Pointer(Dest) := NewDest;
  end;
end;
{$ENDIF PUREPASCAL}

{$IF not defined(X86ASMRTL)}
procedure _LStrCatN(var Dest: _AnsiStr; ArgCnt: Integer); cdecl; varargs;
var
  VAList: TVarArgList;
  {$IFDEF RECORD_TVARARGLIST}
  Buf: PPointerArray;
  ArgIndex: Integer;
  {$ENDIF}
begin
  VarArgStart(VAList);
  {$IFDEF RECORD_TVARARGLIST}
  GetMem(Buf, ArgCnt * SizeOf(Pointer));
  for ArgIndex := 0 to ArgCnt - 1 do
    Buf[ArgIndex] := VarArgGetValue(VAList, Pointer);
  InternalLStrCatN(Dest, ArgCnt, _PAnsiStr(Buf));
  FreeMem(Buf);
  {$ELSE}
  InternalLStrCatN(Dest, ArgCnt, _PAnsiStr(VAList));
  {$ENDIF}
  VarArgEnd(VAList);
end;
{$ELSE X86ASMRTL}
procedure       _LStrCatN{var dest:_AnsiStr; argCnt: Integer; ...};
asm //StackAligned
        {     ->EAX = Pointer to dest           }
        {       EDX = number of args (>= 3)     }
        {       [EBP+8], [EBP+12], ... crgCnt _AnsiStr arguments, reverse order }

        PUSH    0                   // Stack - xxxxxxx8 - Save CodePage
        PUSH    EBX                 // Stack - xxxxxxx4
        PUSH    ESI                 // Stack - xxxxxxx0
        PUSH    EDI                 // Stack - xxxxxxxc
        PUSH    EDX                 // Stack - xxxxxxx8
        PUSH    EAX                 // Stack - xxxxxxx4
        PUSH    0                   // Stack - xxxxxxx0 - Local Temp
        MOV     EBX,EDX

        XOR     EDI,EDI
        MOV     ECX,[ESP+EDX*4+7*4] // first arg is furthest out
        TEST    ECX,ECX
        JZ      @@0
        MOVZX   ESI,[ECX-skew].StrRec.codePage
        MOV     [ESP+6*4],ESI      // Save the first arg's code page in case we need to copy
        CMP     [EAX],ECX          // is dest = first arg?
        JNE     @@0
        MOV     EDI,ECX            // EDI nonzero -> potential appendstr case
        MOV     EAX,[ECX-skew].StrRec.length
        DEC     EDX
        JMP     @@loop1
@@0:
        XOR     EAX,EAX
@@loop1:
        MOV     ECX,[ESP+EDX*4+7*4]
        TEST    ECX,ECX
        JE      @@1
        ADD     EAX,[ECX-skew].StrRec.length
        JO      @@overflow

        CMP     [ESP+6*4],0        // Have we already found a valid codepage?
        JNZ     @@hascodepage
        MOVZX   ESI,[ECX-skew].StrRec.codePage // Save the first non-blank arg we find's codepage
        MOV     [ESP+6*4],ESI
@@hascodepage:

        CMP     EDI,ECX          // is dest an arg besides arg1?
        JNE     @@1
        XOR     EDI,EDI          // can't appendstr - dest is multiple args
@@1:
        DEC     EDX
        JNE     @@loop1

@@append:
        TEST    EDI,EDI          // dest is 1st and only 1st arg?
        JZ      @@copy
        MOV     EDX,EAX          // length into EDX
        MOV     EAX,[ESP + 4]    // ptr to str into EAX
        MOV     ESI,[EDI-skew].StrRec.Length  // save old size before realloc
        MOVZX   ECX,[EDI-Skew].StrRec.codePage
        CALL    _LStrSetLength
        MOV     EDI,[ESP + 4]        // append other strs to dest
        MOV     EAX,[EDI]        // Stack - xxxxxxx0
        MOV     [ESP],EAX
        ADD     ESI,[EDI]        // ESI = end of old string
        DEC     EBX
        JMP     @@loop2

@@copy:
        MOV     EDX,[ESP+6*4]
        CALL    _NewAnsiString
        MOV     [ESP],EAX       // Stack - xxxxxxx0
        MOV     ESI,EAX

@@loop2:
        MOV     EAX,[ESP+EBX*4+7*4]
        MOV     EDX,ESI
        TEST    EAX,EAX
        JE      @@2
        MOV     ECX,[EAX-skew].StrRec.length
        ADD     ESI,ECX
        CALL    Move
@@2:
        DEC     EBX
        JNE     @@loop2

        MOV     EDX,[ESP]
        MOV     EAX,[ESP+4]         // Stack - xxxxxxx0
        TEST    EDI,EDI
        JNZ     @@exit

        TEST    EDX,EDX
        JE      @@skip
        DEC     [EDX-skew].StrRec.refCnt   // EDX = local temp str
@@skip:
        CALL    _LStrAsg

@@exit:
        ADD     ESP,8           // Stack - xxxxxxx8 - Clean Local Temp & Saved EAX
        POP     EDX             // Stack - xxxxxxxc
        POP     EDI             // Stack - xxxxxxx0
        POP     ESI             // Stack - xxxxxxx4
        POP     EBX             // Stack - xxxxxxx8
        POP     EAX             // Stack - xxxxxxxc - Codepage Temp
        POP     EAX             // Stack - xxxxxxx0 - Return Address
        LEA     ESP,[ESP+EDX*4]
        JMP     EAX // Unbalanced CALL/RET means clobbered branch prediction.
                    // Should fix codegen and have caller pop arguments, like cdecl.

@@overflow:
        JMP     _IntOver
end;
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
// Returns 0 : Left = Right
//     minus : Left < Right
//      plus : Left > Right
function _LStrCmp(const Left, Right: _AnsiStr): Integer;
var
  Len, LLen, RLen: Integer;
  LPtr, RPtr: _PAnsiChr;
begin
  if Pointer(Left) = Pointer(Right) then
    Result := 0
  else if Pointer(Left) = nil then
    Result := 0 - __StringLength(Right)
  else if Pointer(Right) = nil then
    Result := __StringLength(Left)
  else
  begin
    LLen := __StringLength(Left);
    RLen := __StringLength(Right);
    Len := LLen;
    if Len > RLen then Len := RLen;
    LPtr := _PAnsiChr(Left);
    RPtr := _PAnsiChr(Right);
    while Len > 0 do
    begin
      Result := Ord(LPtr^) - Ord(RPtr^);
      if Result <> 0 then
        Exit;
      if Len = 1 then break;
      Result := Ord(LPtr[1]) - Ord(RPtr[1]);
      if Result <> 0 then
        Exit;
      Inc(LPtr, 2);
      Inc(RPtr, 2);
      Dec(Len, 2);
    end;
    Result := LLen - RLen;
  end;
end;
{$ELSE X86ASMRTL}
{Original code by Pierre le Riche. Licensed under the CodeGear license terms.}
procedure _LStrCmp{left: _AnsiStr; right: _AnsiStr};
asm
  {On entry:
     eax = @Left[1]
     edx = @Right[1]
   On exit:
     Result in flags:
       CF = 1 if Left < Right, CF = 0 otherwise
       ZF = 1 if Left = Right, ZF = 0 otherwise}

  CMP   EAX, EDX   // Do S1 and S2 point to the same string data?
  JE    @DoneNoPop

  TEST  EAX, EDX   // Is one of the two string pointers perhaps nil?
  JZ    @PossibleNilString
@BothStringsNonNil:
  {Compare the first character. (There has to be a trailing #0, so this
   comparison is safe). In "random" string compares this can save significant
   CPU time.}
  MOVZX ECX, BYTE PTR [EAX]
  SUB   CL, [EDX]
  JNE   @DoneNoPop

  PUSH  EBX             // Save ebx
  MOV   EBX, [EAX - 4]  // Set ebx = length(S1)
  SUB   EBX, [EDX - 4]  // Set ebx = length(S1) - length(S2)
  PUSH  EBX             // Save the length difference on the stack

  ADC   ECX, -1 // Set ecx = 0 if length(S1) <= length(S2), $ffffffff otherwise
  AND   ECX, EBX        // Set ecx = - min(length(S1), length(S2))

  SUB   ECX, [EAX - 4]
  {Adjust the pointers to be negative offset based}
  SUB   EAX, ECX
  SUB   EDX, ECX
@CompareLoop:
  {Compare four bytes per cycle. (The start of string data is at least DWord
   aligned, so this is safe.)}
  MOV   EBX, [EAX + ECX]
  XOR   EBX, [EDX + ECX]
  JNZ   @Mismatch

  ADD   ECX, 4   // Next four bytes
  JS    @CompareLoop

@MatchUpToLength: // All characters match up to the compare length
  POP   EAX       // Restore the string length difference to eax
  ADD   EAX, EAX  // Set the flags according to the length difference
  POP   EBX       // Restore ebx and return
@DoneNoPop:
  RET

@Mismatch:
  BSF   EBX, EBX // Find the byte index that mismatched
  SHR   EBX, 3

  ADD   ECX, EBX //   Is the mismatch beyond the compare length?
  JNS   @MatchUpToLength

  MOV   AL, [EAX + ECX] // Compare the mismatched byte, setting the flags
  CMP   AL, [EDX + ECX]

  POP   EBX      // Pop the length difference, restore ebx and return
  POP   EBX
  RET
@PossibleNilString:
  {There is a good probability that one of the strings are nil (but not both)}
  TEST  EAX, EAX
  JZ    @FirstStringNil
  TEST  EDX, EDX
  JNZ   @BothStringsNonNil

  CMP   [EAX - 4], EDX // S2 is nil - compare lengths of the strings
  RET
@FirstStringNil:
  CMP   EAX, [EDX - 4] // S1 is nil - compare lengths of the strings
end;
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
function _LStrEqual(const Left, Right: _AnsiStr): Integer;
begin
  Result := _LStrCmp(Left, Right);
end;
{$ELSE X86ASMRTL}
{Original code by Pierre le Riche. Licensed under the CodeGear license terms.}
procedure _LStrEqual{const Left, Right: _AnsiStr};
asm
  {On entry:
     eax = @Left[1]
     edx = @Right[1]
   On exit:
     Result in flags:
       ZF = 1 if Left = Right, ZF = 0 otherwise}

        CMP   EAX, EDX  //Do Left and Right point to the same string data?
        JE    @CompareDoneNoPop

        TEST  EAX, EDX  //Is one of the two string pointers perhaps nil?
        JZ    @PossibleNilString
@BothStringsNonNil:
        MOV   ECX, [EAX - 4] //Compare lengths
        CMP   ECX, [EDX - 4]
        JNE   @CompareDoneNoPop

        PUSH  EBX       // Save ebx
        {Get pointers to the 4th last bytes in the strings}
        LEA   EDX, [EDX + ECX - 4]
        LEA   EBX, [EAX + ECX - 4]
        NEG   ECX       // Negate the loop counter
        {Compare the last four bytes. If the string length is less
         than four bytes then part of the length field is compared
         again - no harm done.}
        MOV   EAX, [EBX]
        CMP   EAX, [EDX]
        JNE   @CompareDonePop
@CompareLoop:
        ADD   ECX, 4 // Next four bytes
        JNS   @Match
        {Compare four bytes per iteration}
        MOV   EAX, [EBX + ECX]
        CMP   EAX, [EDX + ECX]
        JE    @CompareLoop
@CompareDonePop:
        POP   EBX
@CompareDoneNoPop:
        RET
@Match:
        XOR   EAX, EAX // Strings match - set the zero flag
        POP   EBX
        RET
@PossibleNilString:
        {There is a good probability that one of the strings are nil
         (but not both)}
        TEST  EAX, EAX
        JZ    @FirstStringNil
        TEST  EDX, EDX
        JNZ   @BothStringsNonNil
        {Right is nil - compare lengths of the strings}
        CMP   [EAX - 4], EDX
        RET
@FirstStringNil:
        {Left is nil - compare lengths of the strings}
        CMP   EAX, [EDX - 4]
        RET
end;
{$ENDIF X86ASMRTL}

type
  PEmptyString = ^TEmptyString;
  TEmptyString = packed record
    Rec: StrRec;
    Nul: Word;
  end;

const
  // Using an initialized _AnsiStr to be sure of alignement
  // and so that it is read only.
  // Note: This const assumes a little endian machine.
  EmptyStringA: _AnsiStr =
{$IFDEF CPU64BITS}
  #$00#$00#$00#$00 +  // Padding, data is 16 byte aligned
{$ENDIF}
  #$FF#$FF +          // codePage := FFFF;
  #$01#$00 +          // elemSize := 1;
  #$FF#$FF#$FF#$FF +  // refCnt := -1;
  #$00#$00#$00#$00 +  // length := 0;
  #$00#$00;           // Data   := nil;

  EmptyStringW: _AnsiStr =
{$IFDEF CPU64BITS}
  #$00#$00#$00#$00 +  // Padding, data is 16 byte aligned
{$ENDIF}
  #$FF#$FF +          // codePage := FFFF;
  #$02#$00 +          // elemSize := 2;
  #$FF#$FF#$FF#$FF +  // refCnt := -1;
  #$00#$00#$00#$00 +  // length := 0;
  #$00#$00;           // Data   := nil;

function _LStrToPChar(const S: _AnsiStr): _PAnsiChr;
begin
  if Pointer(s) = nil then
    Result := @(PEmptyString(@EmptyStringA[1])^.Nul)
  else
    Result := Pointer(s);
end;

function _LStrCopy(const S: _AnsiStr; Index, Count: Integer): _AnsiStr;
var
  L, N: Integer;
begin
  L := Length(S);
  if Index < 1 then
    Index := 0
  else
  begin
    Dec(Index);
    if Index > L then
      Index := L;
  end;
  if Count < 0 then
    N := 0
  else
  begin
    N := L - Index;
    if N > Count then
      N := Count;
  end;
  if Pointer(S) = nil then
    _LStrClr(Result)
  else
    _LStrFromPCharLen(Result, _PAnsiChr(Pointer(S)) + Index, N, __StringCodePage(S))
end;

procedure _LStrDelete(var S: _AnsiStr; Index, Count: Integer);
{$IFDEF PUREPASCAL}
var
  Len, TailLen: Integer;
begin
  InternalUniqueStringA(S);
  if Pointer(S) <> nil then
  begin
    Len := __StringLength(S);
    if (Index >= 1) and (Index <= Len) then
    begin
      if Count > 0 then
      begin
        TailLen := Len - Index + 1;
        if Count > TailLen then Count := TailLen;
        Move(S[Index + Count], S[Index], TailLen - Count);
        _LStrSetLength(S, Len - Count, __StringCodePage(S));
      end;
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        {     ->EAX     Pointer to s    }
        {       EDX     index           }
        {       ECX     count           }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EDI,ECX

        CALL    InternalUniqueStringA

        MOV     EDX,[EBX]
        TEST    EDX,EDX         { source already empty: nothing to do   }
        JE      @@exit

        MOV     ECX,[EDX-skew].StrRec.length

{       make index 0-based, if not in [0 .. Length(s)-1] do nothing     }

        DEC     ESI
        JL      @@exit
        CMP     ESI,ECX
        JGE     @@exit

{       limit count to [0 .. Length(s) - index] }

        TEST    EDI,EDI
        JLE     @@exit
        SUB     ECX,ESI         { ECX = Length(s) - index       }
        CMP     EDI,ECX
        JLE     @@1
        MOV     EDI,ECX
@@1:

{       move length - index - count characters from s+index+count to s+index }

        SUB     ECX,EDI         { ECX = Length(s) - index - count       }
        ADD     EDX,ESI         { EDX = s+index                 }
        LEA     EAX,[EDX+EDI]   { EAX = s+index+count           }
        CALL    Move

{       set length(s) to length(s) - count      }

        MOV     EDX,[EBX]
        MOV     EAX,EBX
        MOVZX   ECX,[EDX-skew].StrRec.codePage
        MOV     EDX,[EDX-skew].StrRec.length
        SUB     EDX,EDI
        CALL    _LStrSetLength

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrInsert(const Source: _AnsiStr; var S: _AnsiStr; Index: Integer);
{$IFDEF PUREPASCAL}
var
  CodePage: Word;
  Len: Integer;
  Len1, Len2, Len3: Integer;
begin
  if Pointer(Source) <> nil then
  begin
    CodePage := 0;
    Len := 0;
    if Pointer(S) <> nil then
    begin
      Len := __StringLength(S);
      CodePage := __StringCodePage(S);
    end;
    if Index <= 0 then Index := 1
    else if Index > Len + 1 then Index := Len + 1;
    Len1 := Index - 1;
    Len2 := __StringLength(Source);
    Len3 := Len - Len1;
    _LStrSetLength(S, Len + Len2, CodePage);
    if Len2 > 0 then
    begin
      Move(S[Index], S[Index + Len2], Len3);
      Move(Source[Low(string)], S[Index], Len2);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     source string                   }
        {       EDX     pointer to destination string   }
        {       ECX     index                           }

        TEST    EAX,EAX
        JE      @@nothingToDo

{$IFDEF ALIGN_STACK}
        SUB     ESP,12
{$ENDIF}
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        PUSH    EBP

        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EDI,ECX

{       make index 0-based and limit to 0 <= index <= Length(s) }

        MOV     EDX,[EDX]
        PUSH    EDX
        TEST    EDX,EDX
        JE      @@sIsNull
        MOV     EDX,[EDX-skew].StrRec.length
@@sIsNull:
        DEC     EDI
        JGE     @@indexNotLow
        XOR     EDI,EDI
@@indexNotLow:
        CMP     EDI,EDX
        JLE     @@indexNotHigh
        MOV     EDI,EDX
@@indexNotHigh:

        MOV     EBP,[EBX-skew].StrRec.length

{       set length of result to length(source) + length(s)      }

        MOV     EAX,[ESI]
        TEST    EAX,EAX
        JNE     @@DestNotNull
        MOV     EAX,EBX
@@DestNotNull:
        MOVZX   ECX,[EAX-skew].StrRec.codePage
        MOV     EAX,ESI
        ADD     EDX,EBP
        JO      @@overflow
        CALL    _LStrSetLength
        POP     EAX

        CMP     EAX,EBX
        JNE     @@notInsertSelf
        MOV     EBX,[ESI]

@@notInsertSelf:

{       move length(s) - length(source) - index chars from s+index to s+index+length(source) }

        MOV     EAX,[ESI]                       { EAX = s       }
        LEA     EDX,[EDI+EBP]                   { EDX = index + length(source)  }
        MOV     ECX,[EAX-skew].StrRec.length
        SUB     ECX,EDX                         { ECX = length(s) - length(source) - index }
        ADD     EDX,EAX                         { EDX = s + index + length(source)      }
        ADD     EAX,EDI                         { EAX = s + index       }
        CALL    Move

{       copy length(source) chars from source to s+index        }

        MOV     EAX,EBX
        MOV     EDX,[ESI]
        MOV     ECX,EBP
        ADD     EDX,EDI
        CALL    Move

@@exit:
        POP     EBP
        POP     EDI
        POP     ESI
        POP     EBX
{$IFDEF ALIGN_STACK}
        ADD     ESP,12
{$ENDIF}
@@nothingToDo:
        RET

@@overflow:
{$IFDEF ALIGN_STACK}
        SUB     ESP,4
{$ENDIF}
        JMP     _IntOver
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _LStrSetLength(var Str: _AnsiStr; NewLength: Integer; CodePage: Word);
{$IFDEF PUREPASCAL}
var
  P: PStrRec;
  Temp: Pointer;
  CopyCount: Integer;
begin
  if newLength <= 0 then
  begin
    _LStrClr(Str);
    Exit;
  end
  else
  begin
    if Pointer(Str) <> nil then
    begin
      if __StringRefCnt(Str) = 1 then
      begin
        P := Pointer(PByte(Str) - Sizeof(StrRec));
        _ReallocMem(Pointer(P), NewLength + 1 + SizeOf(StrRec));
        P.length := NewLength;
        Pointer(Str) := Pointer(PByte(P) + SizeOf(StrRec));
        _PAnsiChr(Str)[NewLength] := #0;
        Exit;
      end;
    end;
    Temp := _NewAnsiString(NewLength, CodePage);
    if Pointer(Str) = nil then
    begin
      Pointer(Str) := Temp;
      Exit;
    end;
    CopyCount := __StringLength(Str);
    if CopyCount > NewLength then
      CopyCount := NewLength;
    Move(_PAnsiChr(str)^, _PAnsiChr(Temp)^, CopyCount);
    _LStrClr(Str);
    Pointer(Str) := Temp;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to str  }
        {       EDX     new length      }
        {       ECX     codePage        }

{$IFDEF ALIGN_STACK}
        SUB     ESP, 8                       // Stack - xxxxxxx4
{$ENDIF ALIGN_STACK}
        PUSH    EBX                          // Stack - xxxxxxx0
        PUSH    ESI                          // Stack - xxxxxxxc
        PUSH    EDI                          // Stack - xxxxxxx8
        PUSH    EBP                          // Stack - xxxxxxx4
        PUSH    0                            // Stack - xxxxxxx0 - Local Temp
        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EBP,ECX
        XOR     EDI,EDI

        TEST    EDX,EDX
        JLE     @@setString

        MOV     EAX,[EBX]
        TEST    EAX,EAX
        JE      @@copyString

        CMP     [EAX-skew].StrRec.refCnt,1
        JNE     @@copyString

        SUB     EAX,rOff
        ADD     EDX,rOff+1
        JO      @@overflow
        MOV     [ESP],EAX                    // Stack - xxxxxxx0
        MOV     EAX,ESP
        CALL    _ReallocMem
        MOV     EAX,[ESP]                    // Stack - xxxxxxx0
        ADD     EAX,rOff
        MOV     [EBX],EAX
        MOV     [EAX-skew].StrRec.length,ESI
        MOV     BYTE PTR [EAX+ESI],0
        JMP     @@exit

@@overflow:
        JMP     _IntOver

@@copyString:
        MOV     EAX,EDX
        MOV     EDX,EBP
        CALL    _NewAnsiString
        MOV     EDI,EAX

        MOV     EAX,[EBX]
        TEST    EAX,EAX
        JE      @@setString

        MOV     EDX,EDI
        MOV     ECX,[EAX-skew].StrRec.length
        CMP     ECX,ESI
        JL      @@moveString
        MOV     ECX,ESI

@@moveString:
        CALL    Move

@@setString:
        MOV     EAX,EBX
        CALL    _LStrClr
        MOV     [EBX],EDI

@@exit:
        POP     EDX                          // Stack - xxxxxxx4 - Local Temp
        POP     EBP                          // Stack - xxxxxxx8
        POP     EDI                          // Stack - xxxxxxxc
        POP     ESI                          // Stack - xxxxxxx0
        POP     EBX                          // Stack - xxxxxxx4
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8                       // Stack - xxxxxxxc
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


procedure _LStrFromUStr(var Dest: _AnsiStr; const Source: UnicodeString; CodePage: Word);
{$IFDEF PUREPASCAL}
begin
  if Pointer(Source) = nil then
    _LStrClr(Dest)
  else
    _LStrFromPWCharLen(Dest, PWideChar(Pointer(Source)), __StringLength(Source), CodePage)
end;
{$ELSE}
asm
        { ->    EAX pointer to dest                 }
        {       EDX pointer to UnicodeString data   }
        {       ECX destination codepage            }

{$IFDEF ALIGN_STACK}
        SUB     ESP,8
        PUSH    ECX
{$ELSE !ALIGN_STACK}
        PUSH    [ESP]
        MOV     [ESP+4],ECX
{$ENDIF !ALIGN_STACK}
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@1
        MOV     ECX,[EDX-Skew].StrRec.length     // length in UnicodeString is widechar count
@@1:
{$IFDEF ALIGN_STACK}
        CALL    _LStrFromPWCharLen
        ADD     ESP,8
        RET
{$ELSE !ALIGN_STACK}
        JMP     _LStrFromPWCharLen
{$ENDIF !ALIGN_STACK}
end;
{$ENDIF !PUREPASCAL}


{ ----------------------------------------------------- }
{       Compiler helper for _WideStr support          }
{ ----------------------------------------------------- }

procedure UStrSet(var S: UnicodeString; P: PWideChar); forward;
procedure WStrSet(var S: _WideStr; P: PWideChar);
{$IFDEF PUREPASCAL}
var
  Temp: Pointer;
begin
  Temp := AtomicExchange(Pointer(S), Pointer(P));
  if Temp <> nil then
    _WStrClr(Temp);
end;
{$ELSE}
{$IFDEF POSIX}
asm
        JMP     UStrSet
end;
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
asm
        XCHG    [EAX],EDX
        TEST    EDX,EDX
        JZ      @@1
        PUSH    EDX
        CALL    SysFreeString
@@1:
end;
{$ENDIF MSWINDOWS}
{$ENDIF !PUREPASCAL}

procedure _WStrFromChar(var Dest: _WideStr; Source: _AnsiChr);
{$IFDEF PUREPASCAL}
begin
  InternalWStrFromPCharLen(Dest, @Source, 1, DefaultSystemCodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
{$IFDEF MSWINDOWS}
asm
        PUSH    EDX
        MOV     EDX,ESP
        MOV     ECX,1
        PUSH    DefaultSystemCodePage
        CALL    InternalWStrFromPCharLen
        POP     EDX
end;
{$ENDIF}
{$IFDEF POSIX}
asm
        JMP     _UStrFromChar
end;
{$ENDIF}
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _WStrFromWChar(var Dest: _WideStr; Source: WideChar);
{$IFDEF PUREPASCAL}
begin
  _WStrFromPWCharLen(Dest, @Source, 1);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
{$IFDEF MSWINDOWS}
asm
        { ->    EAX     Pointer to _WideStr (dest)   }
        {       EDX     character             (source) }
        PUSH    EDX
        MOV     EDX,ESP
        MOV     ECX,1
        CALL    _WStrFromPWCharLen
        POP     EDX
end;
{$ENDIF}
{$IFDEF POSIX}
asm
        JMP _UStrFromWChar
end;
{$ENDIF}
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _WStrFromPChar(var Dest: _WideStr; Source: _PAnsiChr);
{$IFDEF PUREPASCAL}
begin
  InternalWStrFromPCharLen(Dest, Source, _PCharLen(Source), DefaultSystemCodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
{$IFDEF MSWINDOWS}
asm
        { ->    EAX     Pointer to _WideStr (dest)    }
        {       EDX     Pointer to character  (source)  }
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@5
        PUSH    EDX
@@0:    CMP     CL,[EDX+0]
        JE      @@4
        CMP     CL,[EDX+1]
        JE      @@3
        CMP     CL,[EDX+2]
        JE      @@2
        CMP     CL,[EDX+3]
        JE      @@1
        ADD     EDX,4
        JMP     @@0
@@1:    INC     EDX
@@2:    INC     EDX
@@3:    INC     EDX
@@4:    MOV     ECX,EDX
        POP     EDX
        SUB     ECX,EDX
@@5:    JMP     _WStrFromPCharLen
end;
{$ENDIF}
{$IFDEF POSIX}
asm
        JMP     _UStrFromPChar
end;
{$ENDIF}
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _WStrFromPWChar(var Dest: _WideStr; Source: PWideChar);
{$IFDEF PUREPASCAL}
begin
  if Pointer(Source) = nil then
    _WStrClr(Dest)
  else
    _WStrFromPWCharLen(Dest, Source, _PWCharLen(Source));
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
{$IFDEF MSWINDOWS}
asm
        { ->    EAX     Pointer to _WideStr (dest)   }
        {       EDX     Pointer to character  (source) }
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@5
        PUSH    EDX
@@0:    CMP     CX,[EDX+0]
        JE      @@4
        CMP     CX,[EDX+2]
        JE      @@3
        CMP     CX,[EDX+4]
        JE      @@2
        CMP     CX,[EDX+6]
        JE      @@1
        ADD     EDX,8
        JMP     @@0
@@1:    ADD     EDX,2
@@2:    ADD     EDX,2
@@3:    ADD     EDX,2
@@4:    MOV     ECX,EDX
        POP     EDX
        SUB     ECX,EDX
        SHR     ECX,1
@@5:    JMP     _WStrFromPWCharLen
end;
{$ENDIF}
{$IFDEF POSIX}
asm
        JMP     _UStrFromPWChar
end;
{$ENDIF}
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _WStrFromString(var Dest: _WideStr; const Source: _ShortStr);
{$IFDEF PUREPASCAL}
begin
  InternalWStrFromPCharLen(Dest, @Source[1], Byte(Source[0]), DefaultSystemCodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
{$IFDEF MSWINDOWS}
asm
        XOR     ECX,ECX
        MOV     CL,[EDX]
        INC     EDX
        JMP     _WStrFromPCharLen
end;
{$ENDIF}
{$IFDEF POSIX}
asm
        JMP    _UStrFromString
end;
{$ENDIF}
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _WStrFromArray(var Dest: _WideStr; Source: _PAnsiChr; Length: Integer);
{$IFDEF PUREPASCAL}
var
  P: _PAnsiChr;
begin
  P := Source;
  while (Length > 0) and (P^ <> #0) do
  begin
    Dec(Length);
    Inc(P);
  end;
  Length := P - Source;
  InternalWStrFromPCharLen(Dest, Source, Length, DefaultSystemCodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
{$IFDEF MSWINDOWS}
asm
        { ->    EAX     Pointer to _WideStr (dest)   }
        {       EDX     Pointer to character  (source) }
        {       ECX     Length of source characters    }
        PUSH    EDI
        PUSH    EAX
        PUSH    ECX
        MOV     EDI,EDX
        XOR     EAX,EAX
        REPNE   SCASB
        JNE     @@1
        NOT     ECX
@@1:    POP     EAX
        ADD     ECX,EAX
        POP     EAX
        POP     EDI
        JMP     _WStrFromPCharLen
end;
{$ENDIF}
{$IFDEF POSIX}
asm
        JMP     _UStrFromArray
end;
{$ENDIF}
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _WStrFromWArray(var Dest: _WideStr; Source: PWideChar; Length: Integer);
{$IFDEF PUREPASCAL}
var
  P: PWideChar;
begin
  P := Source;
  while (Length > 0) and (P^ <> #0) do
  begin
    Dec(Length);
    Inc(P);
  end;
  Length := P - Source;
  _WStrFromPWCharLen(Dest, Source, Length);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
{$IFDEF MSWINDOWS}
asm
        { ->    EAX     Pointer to _WideStr (dest)   }
        {       EDX     Pointer to character  (source) }
        {       ECX     Length of source characters    }
        PUSH    EDI
        PUSH    EAX
        PUSH    ECX
        MOV     EDI,EDX
        XOR     EAX,EAX
        REPNE   SCASW
        JNE     @@1
        NOT     ECX
@@1:    POP     EAX
        ADD     ECX,EAX
        POP     EAX
        POP     EDI
        JMP     _WStrFromPWCharLen
end;
{$ENDIF}
{$IFDEF POSIX}
asm
        JMP     _UStrFromWArray
end;
{$ENDIF}
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _WStrFromLStr(var Dest: _WideStr; const Source: _AnsiStr);
{$IFDEF PUREPASCAL}
var
  Len: Integer;
begin
  if Pointer(Source) = nil then
    _WStrClr(Dest)
  else
  begin
    Len := __StringLength(Source);
    InternalWStrFromPCharLen(Dest, _PAnsiChr(Pointer(Source)), Len, __StringCodePage(Source))
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
{$IFDEF MSWINDOWS}
asm
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@1
// Inject the CodePage parameter onto the stack ahead of the return address
        MOVZX   ECX,[EDX-Skew].StrRec.codePage
        PUSH    [ESP]
        MOV     [ESP+4],ECX

        MOV     ECX,[EDX-Skew].StrRec.length
        JMP     InternalWStrFromPCharLen
@@1:    JMP     _WStrClr
end;
{$ENDIF}
{$IFDEF POSIX}
asm
        JMP     _UStrFromLStr
end;
{$ENDIF}
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


procedure _WStrToString(Dest: _PShortStr; const Source: _WideStr; MaxLen: Integer);
var
  SourceLen, DestLen: Integer;
  Buffer: array[0..511] of _AnsiChr;
begin
  if MaxLen > 255 then MaxLen := 255;
  SourceLen := Length(Source);
  if SourceLen >= MaxLen then SourceLen := MaxLen;
  if SourceLen = 0 then
    DestLen := 0
  else
  begin
    DestLen := CharFromWChar(Buffer, High(Buffer), PWideChar(Pointer(Source)), SourceLen);
    if DestLen < 0 then
      DestLen := 0
    else if DestLen > MaxLen then
      DestLen := MaxLen;
  end;
  Byte(Dest^[0]) := DestLen;
  if DestLen > 0 then Move(Buffer, Dest^[1], DestLen);
end;

function _WStrToPWChar(const S: _WideStr): PWideChar;
const
  EmptyString = '';
begin
  if Pointer(S) = nil then
    Result := EmptyString
  else
    Result := Pointer(S);
end;

procedure _WStrCat(var Dest: _WideStr; const Source: _WideStr);
var
  DestLen, SourceLen: Integer;
  NewStr: PWideChar;
begin
  SourceLen := Length(Source);
  if SourceLen <> 0 then
  begin
    DestLen := Length(Dest);
    NewStr := _NewWideString(DestLen + SourceLen);
    if DestLen > 0 then
      Move(Pointer(Dest)^, NewStr^, DestLen * sizeof(WideChar));
    Move(Pointer(Source)^, NewStr[DestLen], SourceLen * sizeof(WideChar));
    WStrSet(Dest, NewStr);
  end;
end;

procedure _WStrCat3(var Dest: _WideStr; const Source1, Source2: _WideStr);
var
  Source1Len, Source2Len: Integer;
  NewStr: PWideChar;
begin
  Source1Len := Length(Source1);
  Source2Len := Length(Source2);
  if (Source1Len <> 0) or (Source2Len <> 0) then
  begin
    NewStr := _NewWideString(Source1Len + Source2Len);
    Move(Pointer(Source1)^, Pointer(NewStr)^, Source1Len * sizeof(WideChar));
    Move(Pointer(Source2)^, NewStr[Source1Len], Source2Len * sizeof(WideChar));
    WStrSet(Dest, NewStr);
  end
  else
    _WStrClr(Dest);
end;

{$IF (not defined(X86ASMRTL))}
{$IFDEF MSWINDOWS}
procedure InternalWStrCatN(var Dest: _WideStr; ArgCnt: Integer; Strs: PWideString);
var
  I: Integer;
  Len, L: Integer;
  P: Pointer;
  NewDest: Pointer;
begin
  Len := 0;
  for I := 0 to ArgCnt - 1 do
  begin
    P := PPointerArray(Strs)[I];
    if P <> nil then
    begin
      Inc(Len, __StringLength(_WideStr(P)));
      if Len < 0 then _IntOver;
    end;
  end;
  NewDest := _NewWideString(Len);
  L := 0;
  for I := 0 to ArgCnt - 1 do
  begin
    P := PPointerArray(Strs)[I];
    if P <> nil then
    begin
      Move(P^, PWideChar(NewDest)[L], __StringLength(_WideStr(P)) * SizeOf(WideChar));
      Inc(L, __StringLength(_WideStr(P)));
    end;
  end;
  WStrSet(Dest, NewDest);
end;
{$ENDIF MSWINDOWS}

procedure InternalUStrCatN(var Dest: UnicodeString; ArgCnt: Integer; Strs: PUnicodeString);
var
  I, Start: Integer;
  Len, L: Integer;
  P: Pointer;
  NewDest: Pointer;
  Appending: Boolean;
begin
  Appending := False;
  Len := 0;
  for I := 0 to ArgCnt - 1 do
  begin
    P := PPointerArray(Strs)[I];
    if P <> nil then
    begin
      if P = Pointer(Dest) then
        Appending := (I = 0);
      Inc(Len, __StringLength(P));
      if Len < 0 then _IntOver;
    end;
  end;
  if Appending then
  begin
    // Dest is non-nil
    L := __StringLength(Dest);
    _UStrSetLength(Dest, Len);
    NewDest := Pointer(Dest);
    Start := 1;
  end
  else
  begin
    NewDest := _NewUnicodeString(Len);
    Start := 0;
    L := 0;
  end;
  for I := Start to ArgCnt - 1 do
  begin
    P := PPointerArray(Strs)[I];
    if P <> nil then
    begin
      Move(P^, PWideChar(NewDest)[L], __StringLength(P) * SizeOf(WideChar));
      Inc(L, __StringLength(P));
    end;
  end;
  if not Appending then
  begin
    if Pointer(Dest) <> nil then
      _UStrClr(Dest);
    Pointer(Dest) := NewDest;
  end;
end;

procedure _WStrCatN(var Dest: _WideStr; ArgCnt: Integer); cdecl; varargs;
var
  VAList: TVarArgList;
  {$IFDEF RECORD_TVARARGLIST}
  Buf: PPointerArray;
  ArgIndex: Integer;
  {$ENDIF}
begin
  VarArgStart(VAList);
  {$IFDEF MSWINDOWS}
  InternalWStrCatN(Dest, ArgCnt, _PWideStr(VAList));
  {$ELSE !MSWINDOWS}
  {$IFDEF RECORD_TVARARGLIST}
  GetMem(Buf, ArgCnt * SizeOf(Pointer));
  for ArgIndex := 0 to ArgCnt - 1 do
    Buf[ArgIndex] := VarArgGetValue(VAList, Pointer);
  InternalUStrCatN(UnicodeString(Pointer(Dest)), ArgCnt, PUnicodeString(Buf));
  FreeMem(Buf);
  {$ELSE}
  InternalUStrCatN(UnicodeString(Pointer(Dest)), ArgCnt, PUnicodeString(VAList));
  {$ENDIF}
  {$ENDIF !MSWINDOWS}
  VarArgEnd(VAList);
end;
{$ELSE X86ASMRTL}
procedure _WStrCatN{var Dest: _WideStr; ArgCnt: Integer; ...};
{$IFDEF MSWINDOWS}
asm
        {     ->EAX = Pointer to dest }
        {       EDX = number of args (>= 3) }
        {       [ESP+4], [ESP+8], ... crgCnt _WideStr arguments }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDX
        PUSH    EAX
        MOV     EBX,EDX

        XOR     EAX,EAX
@@loop1:
        MOV     ECX,[ESP+EDX*4+4*4]
        TEST    ECX,ECX
        JE      @@1
        ADD     EAX,[ECX-4]
@@1:
        DEC     EDX
        JNE     @@loop1

        SHR     EAX,1
        CALL    _NewWideString
        PUSH    EAX
        MOV     ESI,EAX

@@loop2:
        MOV     EAX,[ESP+EBX*4+5*4]
        MOV     EDX,ESI
        TEST    EAX,EAX
        JE      @@2
        MOV     ECX,[EAX-4]
        ADD     ESI,ECX
        CALL    Move
@@2:
        DEC     EBX
        JNE     @@loop2

        POP     EDX
        POP     EAX
        CALL    WStrSet

        POP     EDX
        POP     ESI
        POP     EBX
        POP     EAX
        LEA     ESP,[ESP+EDX*4]
        JMP     EAX
end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
asm
        {     ->EAX = Pointer to dest }
        {       EDX = number of args (>= 3) }
        {       [ESP+4], [ESP+8], ... crgCnt _WideStr arguments }

        JMP    _UStrCatN
end;
{$ENDIF POSIX}
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
// Returns 0 : Left = Right
//     minus : Left < Right
//      plus : Left > Right
function _WStrCmp(const Left, Right: _WideStr): Integer;
var
  Len, LLen, RLen: Integer;
  LPtr, RPtr: PWideChar;
begin
  if Pointer(Left) = Pointer(Right) then
    Result := 0
  else if Pointer(Left) = nil then
    Result := 0 - __StringLength(Right)
  else if Pointer(Right) = nil then
    Result := __StringLength(Left)
  else
  begin
    LLen := __StringLength(Left);
    RLen := __StringLength(Right);
    Len := LLen;
    if Len > RLen then Len := RLen;
    LPtr := PWideChar(Left);
    RPtr := PWideChar(Right);
    while Len > 0 do
    begin
      Result := Ord(LPtr^) - Ord(RPtr^);
      if Result <> 0 then
        Exit;
      if Len = 1 then break;
      Result := Ord(LPtr[1]) - Ord(RPtr[1]);
      if Result <> 0 then
        Exit;
      Inc(LPtr, 2);
      Inc(RPtr, 2);
      Dec(Len, 2);
    end;
    Result := LLen - RLen;
  end;
end;
{$ELSE X86ASMRTL}
procedure _WStrCmp{Left, Right: _WideStr};
{$IFDEF MSWINDOWS}
asm //StackAlignSafe
        {     ->EAX = Pointer to left string    }
        {       EDX = Pointer to right string   }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV     ESI,EAX
        MOV     EDI,EDX

        CMP     EAX,EDX
        JE      @@exit

        TEST    ESI,ESI
        JE      @@str1null

        TEST    EDI,EDI
        JE      @@str2null

        MOV     EAX,[ESI-4]
        MOV     EDX,[EDI-4]

        SUB     EAX,EDX { eax = len1 - len2 }
        JA      @@skip1 { len1 > len2 (unsigned)? }
        ADD     EDX,EAX { edx = len2 + (len1 - len2) = len1     }
                        // edx := Min(len1, len2)
@@skip1:
        PUSH    EDX
        SHR     EDX,2
        JE      @@cmpRest
@@longLoop:
        MOV     ECX,[ESI]
        MOV     EBX,[EDI]
        CMP     ECX,EBX
        JNE     @@misMatch
        DEC     EDX
        JE      @@cmpRestP4
        MOV     ECX,[ESI+4]
        MOV     EBX,[EDI+4]
        CMP     ECX,EBX
        JNE     @@misMatch
        ADD     ESI,8
        ADD     EDI,8
        DEC     EDX
        JNE     @@longLoop
        JMP     @@cmpRest
@@cmpRestP4:
        ADD     ESI,4
        ADD     EDI,4
@@cmpRest:
        POP     EDX
        AND     EDX,2
        JE      @@equal

        MOV     CX,[ESI]
        MOV     BX,[EDI]
        CMP     CX,BX
        JNE     @@exit

@@equal:
        ADD     EAX,EAX
        JMP     @@exit

@@str1null:
        MOV     EDX,[EDI-4]
        SUB     EAX,EDX
        JMP     @@exit

@@str2null:
        MOV     EAX,[ESI-4]
        SUB     EAX,EDX
        JMP     @@exit

@@misMatch:
        POP     EDX
        CMP     CX,BX
        JNE     @@exit
        SHR     ECX,16
        SHR     EBX,16
        CMP     CX,BX

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
asm
        {     ->EAX = Pointer to left string    }
        {       EDX = Pointer to right string   }

        JMP     _UStrCmp
end;
{$ENDIF POSIX}
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
function _WStrEqual(const Left, Right: _WideStr): Integer;
begin
  Result := _WStrCmp(Left, Right);
end;
{$ELSE X86ASMRTL}
procedure _WStrEqual{const Left, Right: _WideStr};
{$IFDEF MSWINDOWS}
asm
        JMP     _WStrCmp
end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
asm
        JMP     _UStrCmp
end;
{$ENDIF POSIX}
{$ENDIF X86ASMRTL}

function _WStrCopy(const S: _WideStr; Index, Count: Integer): _WideStr;
var
  L, N: Integer;
begin
  L := Length(S);
  if Index < 1 then
    Index := 0
  else
  begin
    Dec(Index);
    if Index > L then
      Index := L;
  end;
  if Count < 0 then
    N := 0
  else
  begin
    N := L - Index;
    if N > Count then
      N := Count;
  end;
  _WStrFromPWCharLen(Result, PWideChar(Pointer(S)) + Index, N);
end;

procedure _WStrDelete(var S: _WideStr; Index, Count: Integer);
var
  L, N: Integer;
  NewStr: PWideChar;
begin
  L := Length(S);
  if (L > 0) and (Index >= 1) and (Index <= L) and (Count > 0) then
  begin
    Dec(Index);
    N := L - Index - Count;
    if N < 0 then N := 0;
    if (Index = 0) and (N = 0) then NewStr := nil else
    begin
      NewStr := _NewWideString(Index + N);
      if Index > 0 then
        Move(Pointer(S)^, NewStr^, Index * 2);
      if N > 0 then
        Move(PWideChar(Pointer(S))[L - N], NewStr[Index], N * 2);
    end;
    WStrSet(S, NewStr);
  end;
end;

procedure _WStrInsert(const Source: _WideStr; var Dest: _WideStr; Index: Integer);
var
  SourceLen, DestLen: Integer;
  NewStr: PWideChar;
begin
  SourceLen := Length(Source);
  if SourceLen > 0 then
  begin
    DestLen := Length(Dest);
    if Index < 1 then Index := 0 else
    begin
      Dec(Index);
      if Index > DestLen then Index := DestLen;
    end;
    NewStr := _NewWideString(DestLen + SourceLen);
    if Index > 0 then
      Move(Pointer(Dest)^, NewStr^, Index * 2);
    Move(Pointer(Source)^, NewStr[Index], SourceLen * 2);
    if Index < DestLen then
      Move(PWideChar(Pointer(Dest))[Index], NewStr[Index + SourceLen],
        (DestLen - Index) * 2);
    WStrSet(Dest, NewStr);
  end;
end;

procedure _WStrSetLength(var S: _WideStr; NewLength: Integer);
var
  NewStr: PWideChar;
  Count: Integer;
begin
  NewStr := nil;
  if NewLength > 0 then
  begin
    NewStr := _NewWideString(NewLength);
    Count := Length(S);
    if Count > 0 then
    begin
      if Count > NewLength then Count := NewLength;
      Move(Pointer(S)^, NewStr^, Count * SizeOf(WideChar));
    end;
  end;
  WStrSet(S, NewStr);
end;

procedure _WCharToString(Dest: _PShortStr; const Source: WideChar; MaxLen: Integer);
var
  DestLen: Integer;
  Buffer: array[0..255] of _AnsiChr;
begin
  if MaxLen > 255 then MaxLen := 255;
  DestLen := CharFromWChar(Buffer, High(Buffer), @Source, 1);
  if DestLen < 0 then
    DestLen := 0
  else if DestLen > MaxLen then
    DestLen := MaxLen;
  Byte(Dest^[0]) := DestLen;
  if DestLen > 0 then Move(Buffer, Dest^[1], DestLen);
end;


{ ----------------------------------------------------- }
{       Compiler helper for UnicodeString support       }
{ ----------------------------------------------------- }

{ UnicodeString helper functions }


function _UStrToPWChar(const S: UnicodeString): PWideChar;
begin
  if Pointer(S) = nil then
    Result := @(PEmptyString(@EmptyStringW[1])^.Nul)
  else
    Result := Pointer(S);
end;

procedure _UStrFromChar(var Dest: UnicodeString; Source: _AnsiChr);
{$IFDEF PUREPASCAL}
begin
  _UStrFromPCharLen(Dest, @Source, 1);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EDX      // char on stack
        MOV     EDX,ESP  // addr of char on stack in EDX
        MOV     ECX,1
        CALL    _UStrFromPCharLen
        POP     EDX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrFromWChar(var Dest: UnicodeString; Source: WideChar);
{$IFDEF PUREPASCAL}
begin
  _UStrFromPWCharLen(Dest, @Source, 1);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EDX
        MOV     EDX,ESP
        MOV     ECX,1
        CALL    _UStrFromPWCharLen
        POP     EDX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrFromPChar(var Dest: UnicodeString; Source: _PAnsiChr);
{$IFDEF PUREPASCAL}
begin
  _UStrFromPCharLen(Dest, Source, _PCharLen(Source));
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to _WideStr (dest)   }
        {       EDX     Pointer to character  (source) }
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@5
        PUSH    EDX
@@0:    CMP     CL,[EDX+0]
        JE      @@4
        CMP     CL,[EDX+1]
        JE      @@3
        CMP     CL,[EDX+2]
        JE      @@2
        CMP     CL,[EDX+3]
        JE      @@1
        ADD     EDX,4
        JMP     @@0
@@1:    INC     EDX
@@2:    INC     EDX
@@3:    INC     EDX
@@4:    MOV     ECX,EDX
        POP     EDX
        SUB     ECX,EDX
@@5:    JMP     _UStrFromPCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrFromPWChar(var Dest: UnicodeString; Source: PWideChar);
{$IFDEF PUREPASCAL}
begin
  _UStrFromPWCharLen(Dest, Source, _PWCharLen(Source));
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     Pointer to _WideStr (dest)   }
        {       EDX     Pointer to character  (source) }
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@5
        PUSH    EDX
@@0:    CMP     CX,[EDX+0]
        JE      @@4
        CMP     CX,[EDX+2]
        JE      @@3
        CMP     CX,[EDX+4]
        JE      @@2
        CMP     CX,[EDX+6]
        JE      @@1
        ADD     EDX,8
        JMP     @@0
@@1:    ADD     EDX,2
@@2:    ADD     EDX,2
@@3:    ADD     EDX,2
@@4:    MOV     ECX,EDX
        POP     EDX
        SUB     ECX,EDX
        SHR     ECX,1
@@5:    JMP     _UStrFromPWCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrFromArray(var Dest: UnicodeString; Source: _PAnsiChr; Length: Integer);
{$IFDEF PUREPASCAL}
var
  P: _PAnsiChr;
begin
  P := Source;
  while (Length > 0) and (P^ <> #0) do
  begin
    Dec(Length);
    Inc(P);
  end;
  Length := P - Source;
  _UStrFromPCharLen(Dest, Source, Length);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        PUSH    EDI
        PUSH    EAX
        PUSH    ECX
        MOV     EDI,EDX
        XOR     EAX,EAX
        REPNE   SCASB      // find #0
        JNE     @@1
        NOT     ECX
@@1:    POP     EAX
        ADD     ECX,EAX
        POP     EAX
        POP     EDI
        JMP     _UStrFromPCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrFromWArray(var Dest: UnicodeString; Source: PWideChar; Length: Integer);
{$IFDEF PUREPASCAL}
var
  P: PWideChar;
begin
  P := Source;
  while (Length > 0) and (P^ <> #0) do
  begin
    Dec(Length);
    Inc(P);
  end;
  Length := P - Source;
  _UStrFromPWCharLen(Dest, Source, Length);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        PUSH    EDI
        PUSH    EAX
        PUSH    ECX
        MOV     EDI,EDX
        XOR     EAX,EAX
        REPNE   SCASW     // find #$0000
        JNE     @@1
        NOT     ECX
@@1:    POP     EAX
        ADD     ECX,EAX
        POP     EAX
        POP     EDI
        JMP     _UStrFromPWCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrFromLStr(var Dest: UnicodeString; const Source: _AnsiStr);
{$IFDEF PUREPASCAL}
begin
  if Pointer(Source) = nil then
    _UStrClr(Dest)
  else
    InternalUStrFromPCharLen(Dest, _PAnsiChr(Pointer(Source)), __StringLength(Source), __StringCodePage(Source));
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
        XOR     ECX,ECX
        TEST    EDX,EDX
        JE      @@1
        MOVZX   ECX,WORD PTR [EDX-Skew].StrRec.codePage
{$IFDEF ALIGN_STACK}
        PUSH    EBP         // Need a stack frame setup for the
        MOV     EBP, ESP    // unwinder in case there's an Exception
        SUB     ESP, 4
        PUSH    ECX
        MOV     ECX,[EDX-Skew].StrRec.length
        CALL    InternalUStrFromPCharLen
        ADD     ESP, 4
        POP     EBP
        RET
{$ELSE}
        PUSH    [ESP]
        MOV     [ESP+4],ECX
        MOV     ECX,[EDX-Skew].StrRec.length
        JMP     InternalUStrFromPCharLen
{$ENDIF ALIGN_STACK}
@@1:    JMP     _UStrFromPCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrFromWStr(var Dest: UnicodeString; const Source: _WideStr);
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
  _UStrAsg(Dest, UnicodeString(Pointer(Source)));
end;
{$ELSE}
asm
        JMP     _UStrAsg
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
var
  Len: Integer;
begin
  Len := 0;
  if Pointer(Source) <> nil then
    Len := __StringLength(Source);
  _UStrFromPWCharLen(Dest, PWideChar(Pointer(Source)), Len);
end;
{$ELSE}
asm
        { ->    EAX pointer to dest                 }
        {       EDX pointer to _WideStr data      }

        XOR     ECX,ECX
        TEST    EDX,EDX
        JZ      @@1            // nil source => zero length
        MOV     ECX,[EDX-4]
        SHR     ECX,1          // length in _WideStr is byte count
@@1:    JMP     _UStrFromPWCharLen
end;
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
  _UStrAsg(Dest, UnicodeString(Pointer(Source)));
end;
{$ENDIF !MSWINDOWS and !POSIX}

procedure _WStrFromUStr(var Dest: _WideStr; const Source: UnicodeString);
{$IFDEF POSIX}
{$IFDEF PUREPASCAL}
begin
  _WStrAsg(Dest, _WideStr(Pointer(Source)));
end;
{$ELSE}
asm
        JMP     _WStrAsg
end;
{$ENDIF !PUREPASCAL}
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
begin
  if Pointer(Source) = nil then
    _WStrClr(Dest)
  else
    _WStrFromPWCharLen(Dest, PWideChar(Pointer(Source)), __StringLength(Source))
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to dest                 }
        {       EDX pointer to UnicodeString data   }

        XOR     ECX,ECX
        TEST    EDX,EDX
        JZ      @@1            // nil source => zero length
        MOV     ECX,[EDX-Skew].StrRec.length    // length in UnicodeString is widechar count
@@1:    JMP     _WStrFromPWCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
  _WStrAsg(Dest, _WideStr(Pointer(Source)));
end;
{$ENDIF !MSWINDOWS and !POSIX}

procedure _UStrToString(Dest: _PShortStr; const Source: UnicodeString; MaxLen: Integer);
var
  SourceLen, DestLen: Integer;
  Buffer: array[0..511] of _AnsiChr;
begin
  if MaxLen > 255 then MaxLen := 255;
  SourceLen := Length(Source);
  if SourceLen >= MaxLen then SourceLen := MaxLen;
  if SourceLen = 0 then
    DestLen := 0
  else
  begin
    DestLen := CharFromWChar(Buffer, High(Buffer), PWideChar(Pointer(Source)), SourceLen);
    if DestLen < 0 then
      DestLen := 0
    else if DestLen > MaxLen then
      DestLen := MaxLen;
  end;
  Byte(Dest^[0]) := DestLen;
  if DestLen > 0 then Move(Buffer, Dest^[1], DestLen);
end;

procedure _UStrFromString(var Dest: UnicodeString; const Source: _ShortStr);
{$IFDEF PUREPASCAL}
begin
  InternalUStrFromPCharLen(Dest, @Source[1], Byte(Source[0]), DefaultSystemCodePage);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        XOR     ECX,ECX
        MOV     CL,[EDX]
        INC     EDX
        JMP     _UStrFromPCharLen
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrSetLength(var Str: UnicodeString; NewLength: Integer);
{$IFDEF PUREPASCAL}
var
  P: PStrRec;
  Temp: Pointer;
  CopyCount: Integer;
begin
  if NewLength <= 0 then
    _UStrClr(Str)
  else
  begin
    if Pointer(Str) <> nil then
    begin
      if __StringRefCnt(Str) = 1 then
      begin
        P := Pointer(PByte(Str) - Sizeof(StrRec));
        if Cardinal(NewLength) >= Cardinal(- SizeOf(StrRec) - SizeOf(WideChar)) div 2 then
          _IntOver;
        _ReallocMem(Pointer(P), (NewLength + 1) * SizeOf(WideChar) + SizeOf(StrRec));
        P.length := NewLength;
        Pointer(Str) := Pointer(PByte(P) + SizeOf(StrRec));
        PWideChar(Str)[NewLength] := #0;
        Exit;
      end;
    end;
    Temp := _NewUnicodeString(NewLength);
    if Pointer(Str) <> nil then
    begin
      CopyCount := __StringLength(Str);
      if CopyCount > NewLength then
        CopyCount := NewLength;
      Move(PWideChar(Str)^, PWideChar(Temp)^, CopyCount * SizeOf(WideChar));
      _UStrClr(Str);
    end;
    Pointer(Str) := Temp;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
        { ->    EAX     Pointer to S  }
        {       EDX     new length    }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EBX,EAX       // EBX saves @S
        MOV     ESI,EDX       // ESI saves NewLength (chars)
        XOR     EDI,EDI       // EDI := 0; EDI is Temp (result)

        TEST    EDX,EDX       // NewLength <= 0?
        JLE     @@setString   // Assign S := Temp

        MOV     EAX,[EBX]     // EAX := S
        TEST    EAX,EAX       // nil?
        JE      @@copyString  // cannot reallocate (it's nil), so copy

        CMP     [EAX-skew].StrRec.refCnt,1 // !!! MT safety
        JNE     @@copyString  // not unique, so copy

        SUB     EAX,rOff      // Offset EAX "S" to start of memory block
        ADD     EDX,EDX       // Double length to get size
        JO      @@overflow
        ADD     EDX,rOff+2    // Add string rec size
        JO      @@overflow
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        PUSH    EAX           // Put S on stack
        MOV     EAX,ESP       // to pass by reference
        CALL    _ReallocMem
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        ADD     EAX,rOff      // Readjust
        MOV     [EBX],EAX     // Store
        MOV     [EAX-skew].StrRec.length,ESI
        MOV     WORD PTR [EAX+ESI*2],0 // Null terminate
        TEST    EDI,EDI       // Was a temp created?
        JZ      @@exit
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        PUSH    EDI
        MOV     EAX,ESP
        CALL    _LStrClr
        POP     EDI
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        JMP     @@exit

@@overflow:
        JMP     _IntOver

@@copyString:
        MOV     EAX,EDX       // EAX := NewLength
        CALL    _NewUnicodeString
        MOV     EDI,EAX       // EDI "Temp" := new string

        MOV     EAX,[EBX]     // EAX := S, also Source of Move
        TEST    EAX,EAX       // nil?
        JE      @@setString   // Assign straight away

        MOV     EDX,EDI       // EDX := EDI "Temp", also Dest of Move
        MOV     ECX,[EAX-skew].StrRec.length  // ECX := Length(S), also Count of Move
        CMP     ECX,ESI       // ECX "Length(S)" <> NewLength
        JL      @@moveString  // ECX smaller => jump
        MOV     ECX,ESI       // ECX := ESI

@@moveString:
        SHL     ECX,1         // Length widechars to bytes translation
        CALL    Move          // Move ECX chars from EAX to EDX

@@setString:
        MOV     EAX,EBX       // EAX := @S
        CALL    _LStrClr      // clear S
        MOV     [EBX],EDI     // S := Temp

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrCat(var Dest: UnicodeString; const Source: UnicodeString);
{$IFDEF PUREPASCAL}
const
  First = Cardinal(Low(string));
var
  L1, L2, Len: Cardinal;
  Temp: PWideChar;
begin
  if Pointer(Source) <> nil then
  begin
    if Pointer(Dest) = nil then
      _UStrAsg(Dest, Source)
    else
    begin
      L1 := __StringLength(Dest);
      L2 := __StringLength(Source);
      Len := L1 + L2;
      if (Len and $C0000000) <> 0 then _IntOver;
      Temp := @Dest[First];
      _UStrSetLength(Dest, Len);
      if Temp = @Source[First] then
        Temp := @Dest[First]
      else
        Temp := @Source[First];
      Move(Temp^, Dest[L1+First], L2 * SizeOf(WideChar));
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
        { ->    EAX     pointer to dest }
        {       EDX     source          }

        TEST    EDX,EDX       // Source empty, nop.
        JE      @@exit

        MOV     ECX,[EAX]     // ECX := Dest
        TEST    ECX,ECX       // Nil source => assignment
        JE      _UStrAsg

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EBX,EAX         // EBX := @Dest
        MOV     ESI,EDX         // ESI := Source
        MOV     EDI,[ECX-skew].StrRec.length  // EDI := Length(Dest)

        MOV     EDX,[ESI-skew].StrRec.length  // EDX := Length(Source)
        ADD     EDX,EDI         // EDX := (Length(Source) + Length(Dest)) * 2
        TEST    EDX,$C0000000
        JNZ     @@lengthOverflow
        CMP     ESI,ECX
        JE      @@appendSelf

        CALL    _UStrSetLength  // Set length of Dest
        MOV     EAX,ESI         // EAX := Source
        MOV     ECX,[ESI-skew].StrRec.length // ECX := Length(Source)

@@appendStr:
        MOV     EDX,[EBX]       // EDX := Dest
        SHL     EDI,1           // EDI to bytes (Length(Dest) * 2)
        ADD     EDX,EDI         // Offset EDX for destination of move
        SHL     ECX,1           // convert Length(Source) to bytes
        CALL    Move            // Move(Source, Dest + Length(Dest)*2, Length(Source)*2)
        POP     EDI
        POP     ESI
        POP     EBX
        RET

@@appendSelf:
        CALL    _UStrSetLength
        MOV     EAX,[EBX]
        MOV     ECX,EDI
        JMP     @@appendStr

@@lengthOverflow:
        JMP     _IntOver

@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrCat3(var Dest: UnicodeString; const Source1, Source2: UnicodeString);
{$IFDEF PUREPASCAL}
var
  Temp: Pointer;
  L1, L2, Len: Cardinal;
begin
  if Pointer(Source1) = nil then
    _UStrAsg(Dest, Source2)
  else if Pointer(Source2) = nil then
    _UStrAsg(Dest, Source1)
  else
  begin
    if Pointer(Dest) = Pointer(Source1) then
      _UStrCat(Dest, Source2)
    else if Pointer(Dest) = Pointer(Source2) then
    begin
      L1 := __StringLength(Source1);
      L2 := __StringLength(Source2);
      Len := L1 + L2;
      if (((L1 and L2) or ((not Len) and (L1 or L2))) and $80000000) <> 0 then _IntOver;
      Temp := _NewUnicodeString(Len);
      Move(PWideChar(Source1)^, PWideChar(Temp)[0], L1 * SizeOf(WideChar));
      Move(PWideChar(Source2)^, PWideChar(Temp)[L1], L2 * SizeOf(WideChar));
      _UStrClr(Dest);
      Pointer(Dest) := Temp;
    end
    else
    begin
      _UStrAsg(Dest, Source1);
      _UStrCat(Dest, Source2);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
        {     ->EAX = Pointer to dest   }
        {       EDX = source1           }
        {       ECX = source2           }

        TEST    EDX,EDX
        JE      @@assignSource2

        TEST    ECX,ECX
        JE      _UStrAsg

        CMP     EDX,[EAX]
        JE      @@appendToDest

        CMP     ECX,[EAX]
        JE      @@theHardWay

{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    ECX
        CALL    _UStrAsg

        POP     EDX
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
        JMP     _UStrCat

@@theHardWay: // s(*EAX,ECX) := source1(EDX) + s(ECX)

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

{$IFDEF ALIGN_STACK}
        SUB     ESP,12
{$ENDIF ALIGN_STACK}
        MOV     EBX,EDX         // EBX := source1
        MOV     ESI,ECX         // ESI := source2
        PUSH    EAX             // Push(@s)

        MOV     EAX,[EBX-skew].StrRec.length
        ADD     EAX,[ESI-skew].StrRec.length

        TEST    EAX,$C0000000   // either of top two bits set => overflow for size
        JNZ     @@overflow
        CALL    _NewUnicodeString   // EAX := new string ("result")

        MOV     EDI,EAX         // EDI := result

        MOV     EDX,EDI         // EDX := result
        MOV     EAX,EBX         // EAX := source1
        MOV     ECX,[EBX-skew].StrRec.length // ECX := Length(source1)
        SHL     ECX,1           // double ECX for bytes
        CALL    Move            // Move(source1, result, Length(source1)*2)

        MOV     EAX,ESI         // EAX := source2
        MOV     ECX,[ESI-skew].StrRec.length // ECX := Length(source2)
        SHL     ECX,1           // ECX => to bytes
        MOV     EDX,[EBX-skew].StrRec.length // EDX := Length(source1)
        SHL     EDX,1           // EDX => to bytes
        ADD     EDX,EDI         // EDX := result + (num bytes in source1)
        CALL    Move            // Move(source2, result+offset, Length(source2)*2)

        POP     EAX             // EAX := Pop() // @s
{$IFDEF ALIGN_STACK}
        ADD     ESP,12
{$ENDIF ALIGN_STACK}
        MOV     EDX,EDI         // EDX := result
        TEST    EDI,EDI
        JE      @@skip          // result is nil? => don't decrement
        DEC     [EDI-skew].StrRec.refCnt    // EDI = local temp str; _UStrAsg will addref, so ensure final refCnt = 1
@@skip:
        CALL    _UStrAsg

        POP     EDI
        POP     ESI
        POP     EBX

        JMP     @@exit

@@assignSource2:
        MOV     EDX,ECX
        JMP     _UStrAsg

@@appendToDest:
        MOV     EDX,ECX
        JMP     _UStrCat

@@overflow:
        JMP     _IntOver

@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

{$IF not defined(X86ASMRTL)}
procedure _UStrCatN(var Dest: UnicodeString; ArgCnt: Integer); cdecl; varargs;
var
  VAList: TVarArgList;
  {$IFDEF RECORD_TVARARGLIST}
  Buf: PPointerArray;
  ArgIndex: Integer;
  {$ENDIF}
begin
  VarArgStart(VAList);
  {$IFDEF RECORD_TVARARGLIST}
  GetMem(Buf, ArgCnt * SizeOf(Pointer));
  for ArgIndex := 0 to ArgCnt - 1 do
    Buf[ArgIndex] := VarArgGetValue(VAList, Pointer);
  InternalUStrCatN(Dest, ArgCnt, PUnicodeString(Buf));
  FreeMem(Buf);
  {$ELSE}
  InternalUStrCatN(Dest, ArgCnt, PUnicodeString(VAList));
  {$ENDIF}
  VarArgEnd(VAList);
end;
{$ELSE X86ASMRTL}
procedure _UStrCatN{var dest:UnicodeString; argCnt: Integer; ...};
asm //StackAlignSafe
        {     ->EAX = Pointer to dest           }
        {       EDX = number of args (>= 3)     }
        {       [ESP+4], [ESP+8], ... argCnt UnicodeString arguments, reverse order }

        SUB     ESP,4                       // Stack - xxxxxxx8
        PUSH    EBX                         // Stack - xxxxxxx4
        PUSH    ESI                         // Stack - xxxxxxx0
        PUSH    EDI                         // Stack - xxxxxxxc
        PUSH    EDX                         // Stack - xxxxxxx8
        PUSH    EAX                         // Stack - xxxxxxx4
        PUSH    0                           // Stack - xxxxxxx0 - Local Temp
        MOV     EBX,EDX

        XOR     EDI,EDI
        MOV     ECX,[ESP+EDX*4+7*4] // first arg is furthest out
        TEST    ECX,ECX
        JZ      @@0
        CMP     [EAX],ECX          // is dest = first arg?
        JNE     @@0
        MOV     EDI,ECX            // EDI nonzero -> potential appendstr case
        MOV     EAX,[ECX-skew].StrRec.length  // EAX accumulates final length during @@loop1
        DEC     EDX
        JMP     @@loop1
@@0:
        XOR     EAX,EAX
@@loop1:
        MOV     ECX,[ESP+EDX*4+7*4]
        TEST    ECX,ECX
        JE      @@1
        ADD     EAX,[ECX-skew].StrRec.length
        TEST    EAX,$C0000000
        JNZ     @@overflow
        CMP     EDI,ECX          // is dest an arg besides arg1?
        JNE     @@1
        XOR     EDI,EDI          // can't appendstr - dest is multiple args
@@1:
        DEC     EDX
        JNE     @@loop1

@@append:
        TEST    EDI,EDI          // dest is 1st and only 1st arg?
        JZ      @@copy
        MOV     EDX,EAX          // length into EDX
        MOV     EAX,[ESP + 4]    // ptr to str into EAX
        MOV     ESI,[EDI-skew].StrRec.Length  // save old size before realloc
        CALL    _UStrSetLength
        MOV     EDI,[ESP + 4]    // append other strs to dest
        MOV     EAX,[EDI]
        MOV     [ESP],EAX
        SHL     ESI,1            // Length to bytes for offset into string
        ADD     ESI,[EDI]        // ESI = end of old string
        DEC     EBX
        JMP     @@loop2

@@copy:
        CALL    _NewUnicodeString
        MOV     [ESP],EAX
        MOV     ESI,EAX

@@loop2:
        // Loop invariants:
        // - ESI is target of move, going through final dest
        // - EBX is arg index in stack to get arguments;
        //   last argument pushed last => lowest address => addresses decrease from first to last
        MOV     EAX,[ESP+EBX*4+7*4]     // EAX := argN
        MOV     EDX,ESI                 // EDX := dest
        TEST    EAX,EAX                 // argN nil?
        JE      @@2                     // => skip
        MOV     ECX,[EAX-skew].StrRec.length    // ECX := Length(argN)
        SHL     ECX,1                   // ECX to bytes
        ADD     ESI,ECX                 // ESI (running target of move) += ECX
        CALL    Move                    // Move(argN, dest, Length(argN) * 2)
@@2:
        DEC     EBX
        JNE     @@loop2

        MOV     EDX,[ESP]
        MOV     EAX,[ESP + 4]
        TEST    EDI,EDI
        JNZ     @@exit

        TEST    EDX,EDX
        JE      @@skip
        DEC     [EDX-skew].StrRec.refCnt   // EDX = local temp str
@@skip:
        CALL    _UStrAsg

@@exit:
        ADD     ESP,8                     // Stack - xxxxxxx8 - Clean Local Temp & Saved EAX
        POP     EDX                       // Stack - xxxxxxxc
        POP     EDI                       // Stack - xxxxxxx0
        POP     ESI                       // Stack - xxxxxxx4
        POP     EBX                       // Stack - xxxxxxx8
        POP     EAX                       // Stack - xxxxxxxc
        POP     EAX // ret address from CALL Stack - xxxxxxx0
        LEA     ESP,[ESP+EDX*4]
        JMP     EAX // Unbalanced CALL/RET means clobbered branch prediction.
                    // Should fix codegen and have caller pop arguments, like cdecl.

@@overflow:
        JMP     _IntOver
end;
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
function _UStrCmp(const Left, Right: UnicodeString): Integer;
var
  Len, LLen, RLen: Integer;
  LPtr, RPtr: PWideChar;
begin
  if Pointer(Left) = Pointer(Right) then
    Result := 0
  else if Pointer(Left) = nil then
    Result := 0 - __StringLength(Right)
  else if Pointer(Right) = nil then
    Result := __StringLength(Left)
  else
  begin
    LLen := __StringLength(Left);
    RLen := __StringLength(Right);
    Len := LLen;
    if Len > RLen then Len := RLen;
    LPtr := PWideChar(Left);
    RPtr := PWideChar(Right);
    while Len > 0 do
    begin
      Result := Ord(LPtr^) - Ord(RPtr^);
      if Result <> 0 then
        Exit;
      if Len = 1 then break;
      Result := Ord(LPtr[1]) - Ord(RPtr[1]);
      if Result <> 0 then
        Exit;
      Inc(LPtr, 2);
      Inc(RPtr, 2);
      Dec(Len, 2);
    end;
    Result := LLen - RLen;
  end;
end;
{$ELSE X86ASMRTL}
{Original code by Pierre le Riche. Licensed under the CodeGear license terms.}
procedure _UStrCmp{const Left, Right: UnicodeString};
asm
  {On entry:
     eax = @Left[1]
     edx = @Right[1]
   On exit:
     Result in flags:
       CF = 1 if Left < Right, CF = 0 otherwise
       ZF = 1 if Left = Right, ZF = 0 otherwise}

        CMP     EAX, EDX // Do Left and Right point to the same string data?
        JE      @DoneNoPop

        TEST    EAX, EDX // Is one of the two string pointers perhaps nil?
        JZ      @PossibleNilString
@BothStringsNonNil:
  {Compare the first two characters. (There has to be a trailing #0, and non-nil
   UnicodeStrings must contain at least one other character so this comparison
   is safe). In "random" string compares this can save significant CPU time.}
        MOV     ECX, [EAX]
        CMP     ECX, [EDX]
        JNE @InitialMismatch

        PUSH    EBX             // Save ebx
        MOV     EBX, [EAX - 4]  // set ebx = Length(Left)
        XOR     ECX, ECX
        SUB     EBX, [EDX - 4]  // set ebx = Length(Left) - Length(Right)
        PUSH    EBX             // Save the length difference on the stack

        ADC     ECX, -1  // set ecx = 0 if Length(Left) < Length(Right), $ffffffff otherwise
        AND     ECX, EBX // set ecx = - min(length(Left), Length(Right))
        SUB     ECX, [EAX - 4]

        ADD     ECX, ECX        // Two bytes per character

        SUB     EAX, ECX        // Adjust the pointers to be
        SUB     EDX, ECX        // negative offset based

@CompareLoop:
        ADD     ECX, 4          // Next four bytes
        JNS     @MatchUpToLength
        {Compare four bytes (two characters) per cycle. This compare may include the
         trailing #0 for uneven string lengths, in which case no harm is done.}
        MOV     EBX, [EAX + ECX]
        CMP     EBX, [EDX + ECX]
        JE      @CompareLoop
        {Found a mismatch: Swap the two characters into the correct order}
        MOV     EDX, [EDX + ECX]
        ROR     EBX, 16
        ROR     EDX, 16

        CMP     EBX, EDX  // Compare the characters again, setting the flags
        POP     EBX       // Pop the length difference, restore ebx and return
        POP     EBX
        RET
        {All characters match up to the compare length}
@MatchUpToLength:
        POP     EAX       // Restore the string length difference to eax

        ADD     EAX, EAX  // Set the flags according to the length difference
        POP     EBX       // Restore ebx and return
@DoneNoPop:
        RET
@InitialMismatch:
        MOV     EDX, [EDX]  // Swap the two characters into the correct order
        ROR     ECX, 16
        ROR     EDX, 16
        CMP     ECX, EDX    // Compare them again so the flags are set correctly
        RET
@PossibleNilString:
        {There is a good probability that one of the strings are nil (but not both)}
        TEST    EAX, EAX
        JZ      @StringNil
        TEST    EDX, EDX
        JNZ     @BothStringsNonNil
@StringNil:
        CMP     EAX, EDX  // One of the strings are nil, so compare pointers
        RET
end;
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
function _UStrEqual(const Left, Right: UnicodeString): Integer;
begin
  Result := _UStrCmp(Left, Right);
end;
{$ELSE X86ASMRTL}
{Original code by Pierre le Riche. Licensed under the CodeGear license terms.}
procedure _UStrEqual{const Left, Right: UnicodeString};
asm
  {On entry:
     eax = @Left[1]
     edx = @Right[1],
   On exit:
     ZF = 1 if Left = Right
     ZF = 0 if Left <> Right}

        CMP     EAX, EDX  // Same string?
        JE      @DoneNoPop

        TEST    EAX, EDX  // Any of the two possibly nil?
        JZ      @PossibleNilString
@BothStringsNonNil:

        MOV     ECX, [EAX - skew].StrRec.length // Get the string length
        CMP     ECX, [EDX - skew].StrRec.length // Are the string lengths the same?
        JNE     @DoneNoPop
        ADD     ECX, ECX    // Two bytes per character
        ADD     EAX, ECX    // Point eax and edx to just past the last character
        ADD     EDX, ECX
        NEG     ECX         // Make the counter negative based

        PUSH    EBX         // Save ebx
@CompareLoop:
        MOV     EBX, [EAX + ECX] // Compare four bytes per iteration
        CMP     EBX, [EDX + ECX]
        JNE     @Mismatch

        ADD     ECX, 4      // Next two characters
        JS      @CompareLoop
        XOR     EAX, EAX    // Match: Set the ZF
@Mismatch:
        POP     EBX         // Restore ebx

        RET
@PossibleNilString:
        {There is a good probability that one of the strings are nil (but not both)}
        TEST    EAX, EAX
        JZ      @StringNil
        TEST    EDX, EDX
        JNZ     @BothStringsNonNil
@StringNil:
        {One of the strings are nil. Clear the ZF.}
        CMP     EAX, EDX
@DoneNoPop:
end;
{$ENDIF X86ASMRTL}

function _UStrCopy(const S: UnicodeString; Index, Count: Integer): UnicodeString;
var
  L, N: Integer;
begin
  L := Length(S);
  if Index < 1 then
    Index := 0
  else
  begin
    Dec(Index);
    if Index > L then
      Index := L;
  end;
  if Count < 0 then
    N := 0
  else
  begin
    N := L - Index;
    if N > Count then
      N := Count;
  end;
    _UStrFromPWCharLen(Result, PWideChar(Pointer(S)) + Index, N)
end;

                                                 
procedure UStrSet(var S: UnicodeString; P: PWideChar);
{$IFDEF PUREPASCAL}
var
  Temp: Pointer;
begin
  Temp := AtomicExchange(Pointer(S), Pointer(P));
  if Temp <> nil then
    _UStrClr(Temp);
end;
{$ELSE}
{$IFDEF CPUX86}
asm
        XCHG    [EAX],EDX
        TEST    EDX,EDX
        JZ      @@1
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EDX
        MOV     EAX,ESP
        CALL    _UStrClr
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
@@1:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _UStrDelete(var S: UnicodeString; Index, Count: Integer);
var
  L, N: Integer;
begin
  InternalUniqueStringU(S);
  L := Length(S);
  if (Index >= 1) and (Index <= L) and (Count > 0) then
  begin
    Dec(Index);
    N := L - Index - Count;
    if N < 0 then
      N := 0;
    Move(PWideChar(Pointer(S))[L - N], PWideChar(Pointer(S))[Index], N * 2);
    SetLength(S, Index + N);
  end;
end;

procedure _UStrInsert(const Source: UnicodeString; var Dest: UnicodeString; Index: Integer);
var
  SourceLen, DestLen, NewLen: Integer;
  SelfInsert: Boolean;
begin
  SourceLen := Length(Source);
  if SourceLen > 0 then
  begin
    DestLen := Length(Dest);
    if Index < 1 then Index := 0 else
    begin
      Dec(Index);
      if Index > DestLen then Index := DestLen;
    end;
    SelfInsert := (Pointer(Source) = Pointer(Dest));
    NewLen := DestLen + SourceLen;
    if NewLen < 0 then   // overflow check
      _IntOver;
    SetLength(Dest, NewLen);
    if Index < DestLen then
      Move(PWideChar(Pointer(Dest))[Index], PWideChar(Pointer(Dest))[Index + SourceLen],
        (DestLen - Index) * 2);
    if SelfInsert then
      Move(Pointer(Dest)^, PWideChar(Pointer(Dest))[Index], SourceLen * 2)
    else
      Move(Pointer(Source)^, PWideChar(Pointer(Dest))[Index], SourceLen * 2);
  end;
end;

{ ----------------------------------------------------- }
{       string utilities                                }
{ ----------------------------------------------------- }

function Pos(const SubStr, Str: _ShortStr; Offset: Integer): Integer;
{$IFDEF PUREPASCAL}
var
  I, LIterCnt, L, J: Integer;
  PSubStr, PS: _PAnsiChr;
begin
  L := _PStrLen(SubStr);
  { Calculate the number of possible iterations. Not valid if Offset < 1. }
  LIterCnt := _PStrLen(Str) - Offset - L + 1;

  { Only continue if the number of iterations is positive or zero (there is space to check) }
  if (Offset > 0) and (LIterCnt >= 0) and (L > 0) then
  begin
    PSubStr := @SubStr[1];
    PS := @Str[1];
    Inc(PS, Offset - 1);

    for I := 0 to LIterCnt do
    begin
      J := 0;
      while (J >= 0) and (J < L) do
      begin
        if PS[I + J] = PSubStr[J] then
          Inc(J)
        else
          J := -1;
      end;
      if J >= L then
        Exit(I + Offset);
    end;
  end;

  Result := 0;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
(* ***** BEGIN LICENSE BLOCK *****
 *
 * The function PosEx is licensed under the CodeGear license terms.
 *
 * The initial developer of the original code is Fastcode
 *
 * Portions created by the initial developer are Copyright (C) 2002-2004
 * the initial developer. All Rights Reserved.
 *
 * Contributor(s): Aleksandr Sharahov
 *
 * ***** END LICENSE BLOCK ***** *)
asm
       test  eax, eax
       jz    @Nil
       test  edx, edx
       jz    @Nil
       dec   ecx
       jl    @Nil

       push  esi
       push  ebx

       movzx   esi, byte ptr [edx]  //Length(Str)
       movzx   ebx, byte ptr [eax]  //Length(Substr)
       inc   edx
       inc   eax
       sub   esi, ecx      //effective length of Str
       add   edx, ecx      //addr of the first AnsiChar at starting position
       cmp   esi, ebx
       jl    @Past         //jump if EffectiveLength(Str)<Length(Substr)
       test  ebx, ebx
       jle   @Past         //jump if Length(Substr)<=0

       add   esp, -12
       add   ebx, -1       //Length(Substr)-1
       add   esi, edx      //addr of the terminator
       add   edx, ebx      //addr of the last AnsiChar at starting position
       mov   [esp+8], esi  //save addr of the terminator
       add   eax, ebx      //addr of the last AnsiChar of Substr
       sub   ecx, edx      //-@Str[Length(Substr)]
       neg   ebx           //-(Length(Substr)-1)
       mov   [esp+4], ecx  //save -@Str[Length(Substr)]
       mov   [esp], ebx    //save -(Length(Substr)-1)
       movzx ecx, byte ptr [eax] //the last AnsiChar of Substr

@Loop:
       cmp   cl, [edx]
       jz    @Test0
@AfterTest0:
       cmp   cl, [edx+1]
       jz    @TestT
@AfterTestT:
       add   edx, 4
       cmp   edx, [esp+8]
       jb   @Continue
@EndLoop:
       add   edx, -2
       cmp   edx, [esp+8]
       jb    @Loop
@Exit:
       add   esp, 12
@Past:
       pop   ebx
       pop   esi
@Nil:
       xor   eax, eax
       ret
@Continue:
       cmp   cl, [edx-2]
       jz    @Test2
       cmp   cl, [edx-1]
       jnz   @Loop
@Test1:
       add   edx,  1
@Test2:
       add   edx, -2
@Test0:
       add   edx, -1
@TestT:
       mov   esi, [esp]
       test  esi, esi
       jz    @Found
@AnsiString:
       movzx ebx, word ptr [esi+eax]
       cmp   bx, word ptr [esi+edx+1]
       jnz   @AfterTestT
       cmp   esi, -2
       jge   @Found
       movzx ebx, word ptr [esi+eax+2]
       cmp   bx, word ptr [esi+edx+3]
       jnz   @AfterTestT
       add   esi, 4
       jl    @AnsiString
@Found:
       mov   eax, [esp+4]
       add   edx, 2

       cmp   edx, [esp+8]
       ja    @Exit

       add   esp, 12
       add   eax, edx
       pop   ebx
       pop   esi
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function Pos(const SubStr, Str: UnicodeString; Offset: Integer): Integer; overload;
{$IFDEF PUREPASCAL}
var
  I, LIterCnt, L, J: Integer;
  PSubStr, PS: PChar;
  LCh: Char;
begin
  PSubStr := Pointer(SubStr);
  PS := Pointer(Str);
  if (PSubStr = nil) or (PS = nil) or (Offset < 1) then
    Exit(0);
  L := __StringLength(SubStr);
  { Calculate the number of possible iterations. }
  LIterCnt := __StringLength(Str) - Offset - L + 2;
  if (L > 0) and (LIterCnt > 0) then
  begin
    Inc(PS, Offset - 1);
    I := 0;
    LCh := PSubStr[0];
    if L = 1 then   // Special case when Substring length is 1
      repeat
        if PS[I] = LCh then
          Exit(I + Offset);
        Inc(I);
      until I = LIterCnt
    else
      repeat
        if PS[I] = LCh then
        begin
          J := 1;
          repeat
            if PS[I + J] = PSubStr[J] then
            begin
              Inc(J);
              if J = L then
                Exit(I + Offset);
            end
            else
              Break;
          until False;
        end;
        Inc(I);
      until I = LIterCnt;
  end;

  Result := 0;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
(* ***** BEGIN LICENSE BLOCK *****
 *
 * The function PosEx is licensed under the CodeGear license terms.
 *
 * The initial developer of the original code is Fastcode
 *
 * Portions created by the initial developer are Copyright (C) 2002-2004
 * the initial developer. All Rights Reserved.
 *
 * Contributor(s): Aleksandr Sharahov
 *
 * ***** END LICENSE BLOCK ***** *)
asm
       test  eax, eax
       jz    @Nil
       test  edx, edx
       jz    @Nil
       dec   ecx
       jl    @Nil

       push  esi
       push  ebx
       mov   esi, [edx-4]  //Length(Str)
       mov   ebx, [eax-4]  //Length(Substr)
       sub   esi, ecx      //effective length of Str
       shl   ecx, 1        //double count of offset due to being wide char
       add   edx, ecx      //addr of the first char at starting position
       cmp   esi, ebx
       jl    @Past         //jump if EffectiveLength(Str)<Length(Substr)
       test  ebx, ebx
       jle   @Past         //jump if Length(Substr)<=0

       add   esp, -12
       add   ebx, -1       //Length(Substr)-1
       shl   esi,1         //double it due to being wide char
       add   esi, edx      //addr of the terminator
       shl   ebx,1         //double it due to being wide char
       add   edx, ebx      //addr of the last char at starting position
       mov   [esp+8], esi  //save addr of the terminator
       add   eax, ebx      //addr of the last char of Substr
       sub   ecx, edx      //-@Str[Length(Substr)]
       neg   ebx           //-(Length(Substr)-1)
       mov   [esp+4], ecx  //save -@Str[Length(Substr)]
       mov   [esp], ebx    //save -(Length(Substr)-1)
       movzx ecx, word ptr [eax] //the last char of Substr

@Loop:
       cmp   cx, [edx]
       jz    @Test0
@AfterTest0:
       cmp   cx, [edx+2]
       jz    @TestT
@AfterTestT:
       add   edx, 8
       cmp   edx, [esp+8]
       jb   @Continue
@EndLoop:
       add   edx, -4
       cmp   edx, [esp+8]
       jb    @Loop
@Exit:
       add   esp, 12
@Past:
       mov   eax, [esp]
       or    eax, [esp+4]
       jz    @PastNoClear
@PastNoClear:
       pop   ebx
       pop   esi
@Nil:
       xor   eax, eax
       ret
@Continue:
       cmp   cx, [edx-4]
       jz    @Test2
       cmp   cx, [edx-2]
       jnz   @Loop
@Test1:
       add   edx,  2
@Test2:
       add   edx, -4
@Test0:
       add   edx, -2
@TestT:
       mov   esi, [esp]
       test  esi, esi
       jz    @Found
@String:
       mov   ebx, [esi+eax]
       cmp   ebx, [esi+edx+2]
       jnz   @AfterTestT
       cmp   esi, -4
       jge   @Found
       mov   ebx, [esi+eax+4]
       cmp   ebx, [esi+edx+6]
       jnz   @AfterTestT
       add   esi, 8
       jl    @String
@Found:
       mov   eax, [esp+4]
       add   edx, 4

       cmp   edx, [esp+8]
       ja    @Exit

       add   esp, 12
       mov   ecx, [esp]
       or    ecx, [esp+4]
       jz    @NoClear

       mov   ebx, eax
       mov   esi, edx
       mov   eax, ebx
       mov   edx, esi

@NoClear:
       add   eax, edx
       shr   eax, 1  // divide by 2 to make an index
       pop   ebx
       pop   esi
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function Pos(const SubStr, Str: _WideStr; Offset: Integer): Integer; overload;
{$IFDEF MSWINDOWS}
{$IFDEF PUREPASCAL}
var
  I, LIterCnt, L, J: Integer;
  PSubStr, PS: PWideChar;
begin
  L := Length(SubStr);
  { Calculate the number of possible iterations. Not valid if Offset < 1. }
  LIterCnt := Length(Str) - Offset - L + 1;

  { Only continue if the number of iterations is positive or zero (there is space to check) }
  if (Offset > 0) and (LIterCnt >= 0) and (L > 0) then
  begin
    PSubStr := PWideChar(SubStr);
    PS := PWideChar(Str);
    Inc(PS, Offset - 1);

    for I := 0 to LIterCnt do
    begin
      J := 0;
      while (J >= 0) and (J < L) do
      begin
        if PS[I + J] = PSubStr[J] then
          Inc(J)
        else
          J := -1;
      end;
      if J >= L then
        Exit(I + Offset);
    end;
  end;

  Result := 0;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
(* ***** BEGIN LICENSE BLOCK *****
 *
 * The function PosEx is licensed under the CodeGear license terms.
 *
 * The initial developer of the original code is Fastcode
 *
 * Portions created by the initial developer are Copyright (C) 2002-2004
 * the initial developer. All Rights Reserved.
 *
 * Contributor(s): Aleksandr Sharahov
 *
 * ***** END LICENSE BLOCK ***** *)
asm
       test  eax, eax
       jz    @Nil
       test  edx, edx
       jz    @Nil
       dec   ecx
       jl    @Nil

       push  esi
       push  ebx
       mov   esi, [edx-4]  //Length(Str)
       mov   ebx, [eax-4]  //Length(Substr)
       shr   esi, 1
       shr   ebx, 1
       sub   esi, ecx      //effective length of Str
       shl   ecx, 1        //double count of offset due to being wide char
       add   edx, ecx      //addr of the first char at starting position
       cmp   esi, ebx
       jl    @Past         //jump if EffectiveLength(Str)<Length(Substr)
       test  ebx, ebx
       jle   @Past         //jump if Length(Substr)<=0

       add   esp, -12
       add   ebx, -1       //Length(Substr)-1
       shl   esi,1         //double it due to being wide char
       add   esi, edx      //addr of the terminator
       shl   ebx,1         //double it due to being wide char
       add   edx, ebx      //addr of the last char at starting position
       mov   [esp+8], esi  //save addr of the terminator
       add   eax, ebx      //addr of the last char of Substr
       sub   ecx, edx      //-@Str[Length(Substr)]
       neg   ebx           //-(Length(Substr)-1)
       mov   [esp+4], ecx  //save -@Str[Length(Substr)]
       mov   [esp], ebx    //save -(Length(Substr)-1)
       movzx ecx, word ptr [eax] //the last char of Substr

@Loop:
       cmp   cx, [edx]
       jz    @Test0
@AfterTest0:
       cmp   cx, [edx+2]
       jz    @TestT
@AfterTestT:
       add   edx, 8
       cmp   edx, [esp+8]
       jb   @Continue
@EndLoop:
       add   edx, -4
       cmp   edx, [esp+8]
       jb    @Loop
@Exit:
       add   esp, 12
@Past:
       mov   eax, [esp]
       or    eax, [esp+4]
       jz    @PastNoClear
@PastNoClear:
       pop   ebx
       pop   esi
@Nil:
       xor   eax, eax
       ret
@Continue:
       cmp   cx, [edx-4]
       jz    @Test2
       cmp   cx, [edx-2]
       jnz   @Loop
@Test1:
       add   edx,  2
@Test2:
       add   edx, -4
@Test0:
       add   edx, -2
@TestT:
       mov   esi, [esp]
       test  esi, esi
       jz    @Found
@String:
       mov   ebx, [esi+eax]
       cmp   ebx, [esi+edx+2]
       jnz   @AfterTestT
       cmp   esi, -4
       jge   @Found
       mov   ebx, [esi+eax+4]
       cmp   ebx, [esi+edx+6]
       jnz   @AfterTestT
       add   esi, 8
       jl    @String
@Found:
       mov   eax, [esp+4]
       add   edx, 4

       cmp   edx, [esp+8]
       ja    @Exit

       add   esp, 12
       mov   ecx, [esp]
       or    ecx, [esp+4]
       jz    @NoClear

       mov   ebx, eax
       mov   esi, edx
       mov   eax, ebx
       mov   edx, esi

@NoClear:
       add   eax, edx
       shr   eax, 1  // divide by 2 to make an index
       pop   ebx
       pop   esi
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  Result := Pos(UnicodeString(Pointer(SubStr)), UnicodeString(Pointer(Str)), Offset);
end;
{$ENDIF}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
  Result := Pos(UnicodeString(Pointer(SubStr)), UnicodeString(Pointer(Str)), Offset);
end;
{$ENDIF !MSWINDOWS and !POSIX}

function Pos(const SubStr, Str: _RawByteStr; Offset: Integer): Integer;
{$IFDEF PUREPASCAL}
var
  I, LIterCnt, L, J: Integer;
  PSubStr, PS: _PAnsiChr;
begin
  L := Length(SubStr);
  { Calculate the number of possible iterations. Not valid if Offset < 1. }
  LIterCnt := Length(Str) - Offset - L + 1;

  { Only continue if the number of iterations is positive or zero (there is space to check) }
  if (Offset > 0) and (LIterCnt >= 0) and (L > 0) then
  begin
    PSubStr := _PAnsiChr(SubStr);
    PS := _PAnsiChr(Str);
    Inc(PS, Offset - 1);

    for I := 0 to LIterCnt do
    begin
      J := 0;
      while (J >= 0) and (J < L) do
      begin
        if PS[I + J] = PSubStr[J] then
          Inc(J)
        else
          J := -1;
      end;
      if J >= L then
        Exit(I + Offset);
    end;
  end;

  Result := 0;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
(* ***** BEGIN LICENSE BLOCK *****
 *
 * The function PosEx is licensed under the CodeGear license terms.
 *
 * The initial developer of the original code is Fastcode
 *
 * Portions created by the initial developer are Copyright (C) 2002-2004
 * the initial developer. All Rights Reserved.
 *
 * Contributor(s): Aleksandr Sharahov
 *
 * ***** END LICENSE BLOCK ***** *)
asm
       test  eax, eax
       jz    @Nil
       test  edx, edx
       jz    @Nil
       dec   ecx
       jl    @Nil

       push  esi
       push  ebx

       mov   esi, [edx-4]  //Length(Str)
       mov   ebx, [eax-4]  //Length(Substr)
       sub   esi, ecx      //effective length of Str
       add   edx, ecx      //addr of the first AnsiChar at starting position
       cmp   esi, ebx
       jl    @Past         //jump if EffectiveLength(Str)<Length(Substr)
       test  ebx, ebx
       jle   @Past         //jump if Length(Substr)<=0

       add   esp, -12
       add   ebx, -1       //Length(Substr)-1
       add   esi, edx      //addr of the terminator
       add   edx, ebx      //addr of the last AnsiChar at starting position
       mov   [esp+8], esi  //save addr of the terminator
       add   eax, ebx      //addr of the last AnsiChar of Substr
       sub   ecx, edx      //-@Str[Length(Substr)]
       neg   ebx           //-(Length(Substr)-1)
       mov   [esp+4], ecx  //save -@Str[Length(Substr)]
       mov   [esp], ebx    //save -(Length(Substr)-1)
       movzx ecx, byte ptr [eax] //the last AnsiChar of Substr

@Loop:
       cmp   cl, [edx]
       jz    @Test0
@AfterTest0:
       cmp   cl, [edx+1]
       jz    @TestT
@AfterTestT:
       add   edx, 4
       cmp   edx, [esp+8]
       jb   @Continue
@EndLoop:
       add   edx, -2
       cmp   edx, [esp+8]
       jb    @Loop
@Exit:
       add   esp, 12
@Past:
       pop   ebx
       pop   esi
@Nil:
       xor   eax, eax
       ret
@Continue:
       cmp   cl, [edx-2]
       jz    @Test2
       cmp   cl, [edx-1]
       jnz   @Loop
@Test1:
       add   edx,  1
@Test2:
       add   edx, -2
@Test0:
       add   edx, -1
@TestT:
       mov   esi, [esp]
       test  esi, esi
       jz    @Found
@AnsiString:
       movzx ebx, word ptr [esi+eax]
       cmp   bx, word ptr [esi+edx+1]
       jnz   @AfterTestT
       cmp   esi, -2
       jge   @Found
       movzx ebx, word ptr [esi+eax+2]
       cmp   bx, word ptr [esi+edx+3]
       jnz   @AfterTestT
       add   esi, 4
       jl    @AnsiString
@Found:
       mov   eax, [esp+4]
       add   edx, 2

       cmp   edx, [esp+8]
       ja    @Exit

       add   esp, 12
       add   eax, edx
       pop   ebx
       pop   esi
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

function StringOfChar(Ch: WideChar; Count: Integer): UnicodeString; overload;
var
  P: PWideChar;
begin
  _UStrFromPWCharLen(Result, nil, Count);
  P := Pointer(Result);
  while Count > 0 do
  begin
    Dec(Count);
    P[Count] := Ch;
  end;
end;

function StringOfChar(Ch: _AnsiChr; Count: Integer): _AnsiStr; overload;
{$IFDEF PUREPASCAL}
begin
  _LStrClr(Result);
  if Count > 0 then
  begin
    Pointer(Result) := _NewAnsiString(Count, DefaultSystemCodePage);
    _FillChar(Pointer(Result)^, Count, Ch);
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAligned
        { ->    AL      c               }
        {       EDX     count           }
        {       ECX     result          }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EDI,ECX

        MOV     EAX,ECX
        CALL    _LStrClr

        TEST    ESI,ESI
        JLE     @@exit

        MOV     EAX,ESI
{$IFDEF PIC}
        PUSH    EAX
        PUSH    EBX
        PUSH    ECX
        CALL    GetGOT
        MOV     EDX, [EAX].OFFSET DefaultSystemCodePage
        MOV     EDX, [EDX]
        POP     ECX
        POP     EBX
        POP     EAX
{$ELSE}
        MOV     EDX,DefaultSystemCodePage
{$ENDIF}
        CALL    _NewAnsiString

        MOV     [EDI],EAX

        MOV     EDX,ESI
        MOV     CL,BL

        CALL    _FillChar

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX

end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure SetAnsiString(Dest: _PAnsiStr; Source: PWideChar; Length: Integer; CodePage: Word);
begin
  _LStrFromPWCharLen(Dest^, Source, Length, CodePage);
end;

procedure SetCodePage(var S: _RawByteStr; CodePage: Word; Convert: Boolean);
var
  W: UnicodeString;
  NewLen: Integer;
begin
  if (StringCodePage(S) = CodePage) or (Length(S) = 0) then
    Exit;
  if Convert then
  begin
    if StringElementSize(S) = 1 then
      W := UnicodeString(S)  // This up-converts to Unicode utf-16 using the existing codepage in the payload
    else
      W := UnicodeString(Pointer(S));  // Payload is already utf-16 so just reference it
    // now find out how large the resulting string will be
    NewLen := CharFromWChar(nil, 0, PWideChar(W), Length(W), CodePage);
    SetLength(S, NewLen);
    // finally actually convert the payload based on the new CodePage
    if NewLen > 0 then
      CharFromWChar(_PAnsiChr(S), Length(S), PWideChar(W), Length(W), CodePage);
  end
  else
    InternalUniqueStringA(_AnsiStr(S));
  if Length(S) > 0 then
    PWord(PByte(S) - 12)^ := CodePage;
end;

function UnicodeStringToUCS4String(const S: UnicodeString): UCS4String;
var
  I: Integer;
  CharCount: Integer;
begin
  CharCount := 0;
  SetLength(Result, Length(S) + 1);
  I := Low(string) - 1;
  while I < High(S) do
  begin

    if ((S[I + 1] >= #$D800) and (S[I + 1] <= #$DFFF)) and (I + 1 < Length(S)) then
    begin
      Result[CharCount] := UCS4Char((Cardinal(S[I + 1]) and $000003FF) shl 10 or (Cardinal(S[I + 2]) and $000003FF) + $00010000);
      Inc(I);
    end
    else
      Result[CharCount] := UCS4Char(S[I + 1]);

    Inc(CharCount);
    Inc(I);
  end;
  Result[CharCount] := 0;
  SetLength(Result, CharCount + 1);
end;

function UCS4StringToUnicodeString(const S: UCS4String): UnicodeString;
var
  I: Integer;
  CharCount: Integer;
  Tmp: array of Char;
begin
  SetLength(Tmp, Length(S) * 2 - 1); //Maximum possible number of characters
  CharCount := -1;

  I := 0;
  while I < Length(S) - 1 do
  begin
    if S[I] >= $10000 then
    begin
      Inc(CharCount);
      Tmp[CharCount] := WideChar((((S[I] - $00010000) shr 10) and $000003FF) or $D800);
      Inc(CharCount);
      Tmp[CharCount] := WideChar(((S[I] - $00010000) and $000003FF)or $DC00);
    end
    else
    begin
      Inc(CharCount);
      Tmp[CharCount] := WideChar(S[I]);
    end;

    Inc(I);
  end;

  SetString(Result, PChar(Tmp), CharCount + 1);
end;

function WideCharToUCS4String(S: PWideChar; Len: Integer = MaxInt): UCS4String;
var
  Buffer: array[0..255] of UCS4Char;
  Index: Integer;

  procedure FlushBuffer(var Result: UCS4String; AddNull: Integer);
  begin
    SetLength(Result, Length(Result) + Index + AddNull);
    Move(Buffer, Result[Length(Result) - Index - AddNull], Index * SizeOf(UCS4Char));
    if AddNull > 0 then
      Result[Length(Result) - 1] := 0;
    Index := 0;
  end;

begin
  Index := 0;
  while (S[0] <> #0) and (Len > 0) do
  begin
    if ((S[0] >= #$D800) and (S[0] <= #$DFFF)) and (Len > 0) and (S[1] <> #0) then
    begin
      Buffer[Index] := UCS4Char((Cardinal(S[0]) and $000003FF) shl 10 or (Cardinal(S[1]) and $000003FF) + $00010000);
      Inc(S);
    end
    else
      Buffer[Index] := UCS4Char(S[0]);
    Inc(Index);
    Inc(S);
    Dec(Len);
    if Index >= Length(Buffer) then
      FlushBuffer(Result, 0);
  end;
  FlushBuffer(Result, 1);
end;

                                                                                                         
//function UTF8Encode(const WS: UnicodeString): _UTF8Str;
//function UTF8Decode(const S: _UTF8Str): UnicodeString;


{ ------------------------------------------------------------- }
{       Compiler helper for initializing/finalizing variable    }
{ ------------------------------------------------------------- }

type
  PPTypeInfo = ^PTypeInfo;
  PTypeInfo = ^TTypeInfo;
  TTypeInfo = packed record
    Kind: TTypeKind;
    Name: _ShortStr;
   {TypeData: TTypeData}
  end;

  // 32 bit = 8 bytes, 64bit = 16 bytes
  TFieldInfo = packed record
    TypeInfo: PPTypeInfo;
    case Integer of
    0: ( Offset: Cardinal );
    1: ( _Dummy: NativeUInt );
  end;

  PFieldTable = ^TFieldTable;
  TFieldTable = packed record
    X: Word;
    Size: Cardinal;
    Count: Cardinal;
    Fields: array [0..0] of TFieldInfo;
  end;

{ ===========================================================================
  InitializeRecord, InitializeArray, and Initialize are PIC safe even though
  they alter EBX because they only call each other.  They never call out to
  other functions and they don't access global data.

  FinalizeRecord, Finalize, and FinalizeArray are PIC safe because they call
  Pascal routines which will have EBX fixup prologs.
  ===========================================================================}
procedure _InitializeRecord(p: Pointer; typeInfo: Pointer);
{$IFDEF PUREPASCAL}
var
  FT: PFieldTable;
  I: Cardinal;
begin
  FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeInfo).Name[0]));
  if FT.Count > 0 then
  begin
    for I := FT.Count - 1 downto 0 do
{$IFDEF WEAKREF}
      if FT.Fields[I].TypeInfo <> nil then
{$ENDIF}
        _InitializeArray(Pointer(PByte(P) + UIntPtr(FT.Fields[I].Offset)), FT.Fields[I].TypeInfo^, 1);
  end;
end;
{$ELSE}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to record to be initialized }
        {       EDX pointer to type info                }

        XOR     ECX,ECX

        PUSH    EBX
        MOV     CL,[EDX+1]                  { type name length }

        PUSH    ESI
        PUSH    EDI

        MOV     EBX,EAX                     // PIC safe. See comment above
        LEA     ESI,[EDX+ECX+2+8]           { address of destructable fields }
        MOV     EDI,[EDX+ECX+2+4]           { number of destructable fields }
        TEST    EDI,EDI
        JZ      @@exit

@@loop:

        MOV     EDX,[ESI]
{$IFDEF WEAKREF}
        TEST    EDX,EDX
        JE      @@skip
{$ENDIF}
        MOV     EAX,[ESI+4]
        ADD     EAX,EBX
        MOV     EDX,[EDX]
        MOV     ECX,1
        CALL    _InitializeArray
{$IFDEF WEAKREF}
@@skip:
{$ENDIF}
        ADD     ESI,8
        DEC     EDI
        JG      @@loop

@@exit:
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure InitializeArray(p: Pointer; typeInfo: Pointer; elemCount: NativeUInt);
{$IFDEF PUREPASCAL}
begin
  _InitializeArray(p, typeInfo, elemCount);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
  JMP _InitializeArray
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _InitializeArray(p: Pointer; typeInfo: Pointer; elemCount: NativeUInt);
{$IFDEF PUREPASCAL}
var
  FT: PFieldTable;
  I: Cardinal;
begin
  if elemCount = 0 then Exit;
  case PTypeInfo(typeInfo).Kind of
{$IFDEF WEAKINSTREF}
    tkMethod:
      while elemCount > 0 do
      begin
        TMethod(P^).Data := nil;
        TMethod(P^).Code := nil;
        Inc(PByte(P), SizeOf(TMethod));
        Dec(elemCount);
      end;
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
    tkClass,
{$ENDIF}
    tkLString, tkWString, tkInterface, tkDynArray, tkUString:
      while elemCount > 0 do
      begin
        PPointer(P)^ := nil;
        Inc(PByte(P), SizeOf(Pointer));
        Dec(elemCount);
      end;
    tkVariant:
      while elemCount > 0 do
      begin
        with PVarData(P)^ do
          for I := Low(RawData) to High(RawData) do RawData[I] := 0;
        Inc(PByte(P), SizeOf(TVarData));
        Dec(elemCount);
      end;
    tkArray:
      begin
        FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeInfo).Name[0]));
        while elemCount > 0 do
        begin
          _InitializeArray(P, FT.Fields[0].TypeInfo^, FT.Count);
          Inc(PByte(P), FT.Size);
          Dec(elemCount);
        end;
      end;
    tkRecord:
      begin
        FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeInfo).Name[0]));
        while elemCount > 0 do
        begin
          _InitializeRecord(P, typeInfo);
          Inc(PByte(P), FT.Size);
          Dec(elemCount);
        end;
      end;
  else
    Error(reInvalidPtr);
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX     pointer to data to be initialized       }
        {       EDX     pointer to type info describing data    }
        {       ECX     number of elements of that type         }

        TEST    ECX, ECX
        JZ      @@zerolength

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EBX,EAX             // PIC safe.  See comment above
        MOV     ESI,EDX
        MOV     EDI,ECX

        XOR     EDX,EDX
        MOV     AL,[ESI]
        MOV     DL,[ESI+1]
        XOR     ECX,ECX

{$IFDEF WEAKINSTREF}
        CMP     AL,tkMethod
        JE      @@Method
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
        CMP     AL,tkClass
        JE      @@Class
{$ENDIF}
        CMP     AL,tkLString
        JE      @@LString
        CMP     AL,tkWString
        JE      @@WString
        CMP     AL,tkVariant
        JE      @@Variant
        CMP     AL,tkArray
        JE      @@Array
        CMP     AL,tkRecord
        JE      @@Record
        CMP     AL,tkInterface
        JE      @@Interface
        CMP     AL,tkDynArray
        JE      @@DynArray
        CMP     AL,tkUString
        JE      @@UString
        MOV     AL,reInvalidPtr
        POP     EDI
        POP     ESI
        POP     EBX
        JMP     Error

@@Class:
@@LString:
@@WString:
@@Interface:
@@DynArray:
@@UString:
        MOV     [EBX],ECX
        ADD     EBX,4
        DEC     EDI
        JG      @@LString
        JMP     @@exit

@@Variant:
        MOV     [EBX   ],ECX
        MOV     [EBX+ 4],ECX
        MOV     [EBX+ 8],ECX
        MOV     [EBX+12],ECX
        ADD     EBX,16
        DEC     EDI
        JG      @@Variant
        JMP     @@exit

{$IFDEF WEAKINSTREF}
@@Method:
        MOV     [EBX   ],ECX
        MOV     [EBX+ 4],ECX
        ADD     EBX,8
        DEC     EDI
        JG      @@Method
        JMP     @@exit
{$ENDIF}

@@Array:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        PUSH    EBP
        MOV     EBP,EDX
@@ArrayLoop:
        MOV     EDX,[ESI+EBP+2+8]    // address of destructable fields typeinfo
        MOV     EAX,EBX
        ADD     EBX,[ESI+EBP+2]      // size in bytes of the array data
        MOV     ECX,[ESI+EBP+2+4]    // number of destructable fields
        MOV     EDX,[EDX]
        CALL    _InitializeArray
        DEC     EDI
        JG      @@ArrayLoop
        POP     EBP
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        JMP     @@exit

@@Record:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        PUSH    EBP
        MOV     EBP,EDX
@@RecordLoop:
        MOV     EAX,EBX
        ADD     EBX,[ESI+EBP+2]
        MOV     EDX,ESI
        CALL    _InitializeRecord
        DEC     EDI
        JG      @@RecordLoop
        POP     EBP
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}

@@exit:

        POP     EDI
        POP     ESI
        POP     EBX
@@zerolength:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _Initialize(p: Pointer; typeInfo: Pointer);
{$IFDEF PUREPASCAL}
begin
  _InitializeArray(p, typeInfo, 1);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        MOV     ECX,1
        JMP     _InitializeArray
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

{$IF not defined(X86ASMRTL)}
function _FinalizeRecord(P: Pointer; TypeInfo: Pointer): Pointer;
var
  FT: PFieldTable;
  I: Cardinal;
{$IFDEF WEAKREF}
  Weak: Boolean;
{$ENDIF}
begin
  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
  if FT.Count > 0 then
  begin
{$IFDEF WEAKREF}
    Weak := False;
{$ENDIF}
    for I := 0 to FT.Count - 1 do
    begin
{$IFDEF WEAKREF}
      if FT.Fields[I].TypeInfo = nil then
      begin
        Weak := True;
        Continue;
      end;
      if not Weak then
      begin
{$ENDIF}
        _FinalizeArray(Pointer(PByte(P) + IntPtr(FT.Fields[I].Offset)), FT.Fields[I].TypeInfo^, 1);
{$IFDEF WEAKREF}
      end else
      begin
        case FT.Fields[I].TypeInfo^.Kind of
{$IFDEF WEAKINTFREF}
          tkInterface: _IntfWeakClear(IInterface(Pointer(PByte(P) + IntPtr(FT.Fields[I].Offset))^));
{$ENDIF}
{$IFDEF WEAKINSTREF}
          tkClass: _InstWeakClear(TObject(Pointer(PByte(P) + IntPtr(FT.Fields[I].Offset))^));
          tkMethod: _ClosureRemoveWeakRef(TMethod(Pointer(PByte(P) + IntPtr(FT.Fields[I].Offset))^));
{$ENDIF}
        else
          Error(reInvalidPtr);
        end;
      end;
{$ENDIF}
    end;
  end;
  Result := P;
end;
{$ELSE X86ASMRTL}
procedure _FinalizeRecord(p: Pointer; typeInfo: Pointer);
asm
        { ->    EAX pointer to record to be finalized   }
        {       EDX pointer to type info                }

        XOR     ECX,ECX

        PUSH    EBX
        MOV     CL,[EDX+1]

        PUSH    ESI
        PUSH    EDI

        MOV     EBX,EAX
        LEA     ESI,[EDX+ECX+2+8]
        MOV     EDI,[EDX+ECX+2+4]
        TEST    EDI,EDI
        JZ      @@exit

@@loop:

        MOV     EDX,[ESI]
{$IFDEF WEAKREF}
        TEST    EDX,EDX
        JE      @@weak
{$ENDIF}
        MOV     EAX,[ESI+4]
        ADD     EAX,EBX
        MOV     EDX,[EDX]
        MOV     ECX,1
        CALL    _FinalizeArray
        ADD     ESI,8
        DEC     EDI
        JG      @@loop
{$IFDEF WEAKREF}
        JMP     @@exit

@@weak:
        ADD     ESI,8
        DEC     EDI

@@weakLoop:
        MOV     EDX,[ESI]
        MOV     EAX,[ESI+4]
        ADD     EAX,EBX
        MOV     EDX,[EDX]
{$IFDEF WEAKINTFREF}
        CMP     BYTE PTR [EDX].TTypeInfo.Kind,tkInterface
        JE      @@clrWeakIntf
{$ENDIF}
{$IFDEF WEAKINSTREF}
        CMP     BYTE PTR [EDX].TTypeInfo.Kind,tkClass
        JE      @@clrWeakInst
        CMP     BYTE PTR [EDX].TTypeInfo.Kind,tkMethod
        JE      @@clrWeakMethod
{$ENDIF}
        MOV     AL,reInvalidPtr
        JMP     Error

{$IFDEF WEAKINTFREF}
@@clrWeakIntf:
        CALL    _IntfWeakClear
        JMP     @@next
{$ENDIF}
{$IFDEF WEAKINSTREF}
@@clrWeakInst:
        CALL    _InstWeakClear
        JMP     @@next
@@clrWeakMethod:
        CALL    _ClosureRemoveWeakRef
{$ENDIF}
@@next:
        ADD     ESI,8
        DEC     EDI
        JG      @@weakLoop
{$ENDIF}
@@exit:
        MOV     EAX,EBX

        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF X86ASMRTL}

procedure _VarClr(var v: TVarData);
begin
  if Assigned(VarClearProc) then
    VarClearProc(v)
  else
    Error(reVarInvalidOp);
end;

{$IF not defined(X86ASMRTL)}
function _FinalizeArray(P: Pointer; TypeInfo: Pointer; ElemCount: NativeUInt): Pointer;
var
  FT: PFieldTable;
begin
  Result := P;
  if ElemCount = 0 then Exit;
  case PTypeInfo(TypeInfo).Kind of
{$IFDEF WEAKINSTREF}
    tkMethod:
      while ElemCount > 0 do
      begin
        _ClosureRemoveWeakRef(TMethod(P^));
        Inc(PByte(P), SizeOf(TMethod));
        Dec(ElemCount);
      end;
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
    tkClass:
      while ElemCount > 0 do
      begin
        _InstClear(TObject(P^));
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
{$ENDIF}
    tkLString: _LStrArrayClr(P^, ElemCount);
    tkWString: _WStrArrayClr(P^, ElemCount);
    tkUString: _UStrArrayClr(P^, ElemCount);
    tkVariant:
      while ElemCount > 0 do
      begin
        _VarClr(PVarData(P)^);
        Inc(PByte(P), SizeOf(TVarData));
        Dec(ElemCount);
      end;
    tkArray:
      begin
        FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeInfo).Name[0]));
        while ElemCount > 0 do
        begin
          _FinalizeArray(P, FT.Fields[0].TypeInfo^, FT.Count);
          Inc(PByte(P), FT.Size);
          Dec(ElemCount);
        end;
      end;
    tkRecord:
      begin
        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
        while ElemCount > 0 do
        begin
          _FinalizeRecord(P, TypeInfo);
          Inc(PByte(P), FT.Size);
          Dec(ElemCount);
        end;
      end;
    tkInterface:
      while ElemCount > 0 do
      begin
        _IntfClear(IInterface(P^));
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
    tkDynArray:
      while ElemCount > 0 do
      begin
        { The cast and dereference of P here is to fake out the call to
          _DynArrayClear.  That function expects a var parameter.  Our
          declaration says we got a non-var parameter, but because of
          the data type that got passed to us (tkDynArray), this isn't
          strictly true.  The compiler will have passed us a reference. }
        _DynArrayClear(PPointer(P)^, typeInfo);
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
  else
    Error(reInvalidPtr);
  end;
end;
{$ELSE X86ASMRTL}
procedure _FinalizeArray(P: Pointer; TypeInfo: Pointer; ElemCount: NativeUInt);
asm
        { ->    EAX     pointer to data to be finalized         }
        {       EDX     pointer to type info describing data    }
        {       ECX     number of elements of that type         }

        { This code appears to be PIC safe.  The functions called from
          here either don't make external calls or call Pascal
          routines that will fix up EBX in their prolog code
          (FreeMem, VarClr, IntfClr).  }

        CMP     ECX, 0                        { no array -> nop }
        JE      @@zerolength

        PUSH    EAX
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EDI,ECX

        XOR     EDX,EDX
        MOV     AL,[ESI]
        MOV     DL,[ESI+1]

{$IFDEF WEAKINSTREF}
        CMP     AL,tkMethod
        JE      @@Method
{$ENDIF}

{$IFDEF AUTOREFCOUNT}
        CMP     AL,tkClass
        JE      @@Class
{$ENDIF}

        CMP     AL,tkLString
        JE      @@LString

        CMP     AL,tkUString
        JE      @@UString

        CMP     AL,tkWString
        JE      @@WString

        CMP     AL,tkVariant
        JE      @@Variant

        CMP     AL,tkArray
        JE      @@Array

        CMP     AL,tkRecord
        JE      @@Record

        CMP     AL,tkInterface
        JE      @@Interface

        CMP     AL,tkDynArray
        JE      @@DynArray

        JMP     @@error

@@LString:
        CMP     ECX,1
        MOV     EAX,EBX
        JG      @@LStringArray
        CALL    _LStrClr
        JMP     @@exit
@@LStringArray:
        MOV     EDX,ECX
        CALL    _LStrArrayClr
        JMP     @@exit

@@WString:
        CMP     ECX,1
        MOV     EAX,EBX
        JG      @@WStringArray
        CALL    _WStrClr
        JMP     @@exit
@@WStringArray:
        MOV     EDX,ECX
        CALL    _WStrArrayClr
        JMP     @@exit

@@UString:
        CMP     ECX,1
        MOV     EAX,EBX
        JG      @@UStringArray
        CALL    _UStrClr
        JMP     @@exit
@@UStringArray:
        MOV     EDX,ECX
        CALL    _UStrArrayClr
        JMP     @@exit

@@Variant:
        MOV     EAX,EBX
        ADD     EBX,16
        CALL    _VarClr
        DEC     EDI
        JG      @@Variant
        JMP     @@exit
@@Array:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        PUSH    EBP
        MOV     EBP,EDX
@@ArrayLoop:
        MOV     EDX,[ESI+EBP+2+8]
        MOV     EAX,EBX
        ADD     EBX,[ESI+EBP+2]
        MOV     ECX,[ESI+EBP+2+4]
        MOV     EDX,[EDX]
        CALL    _FinalizeArray
        DEC     EDI
        JG      @@ArrayLoop
        POP     EBP
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        JMP     @@exit

@@Record:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        PUSH    EBP
        MOV     EBP,EDX
@@RecordLoop:
        { inv: EDI = number of array elements to finalize }

        MOV     EAX,EBX
        ADD     EBX,[ESI+EBP+2]
        MOV     EDX,ESI
        CALL    _FinalizeRecord
        DEC     EDI
        JG      @@RecordLoop
        POP     EBP
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        JMP     @@exit

@@Interface:
        MOV     EAX,EBX
        ADD     EBX,4
        CALL    _IntfClear
        DEC     EDI
        JG      @@Interface
        JMP     @@exit

{$IFDEF AUTOREFCOUNT}
@@Class:
        MOV     EAX,EBX
        ADD     EBX,4
        CALL    _InstClear
        DEC     EDI
        JG      @@Class
        JMP     @@exit
{$ENDIF}

{$IFDEF WEAKINSTREF}
@@Method:
        MOV     EAX,EBX
        ADD     EBX,8
        CALL    _ClosureRemoveWeakRef
        DEC     EDI
        JG      @@Method
        JMP     @@exit
{$ENDIF}

@@DynArray:
        MOV     EAX,EBX
        MOV     EDX,ESI
        ADD     EBX,4
        CALL    _DynArrayClear
        DEC     EDI
        JG      @@DynArray
        JMP     @@exit

@@error:
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        POP     EDI
        POP     ESI
        POP     EBX
        POP     EAX
        MOV     AL,reInvalidPtr
        JMP     Error

@@exit:
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        POP     EDI
        POP     ESI
        POP     EBX
        POP     EAX
@@zerolength:
end;
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
function _Finalize(p: Pointer; typeInfo: Pointer): Pointer;
begin
  Result := _FinalizeArray(p, typeInfo, 1);
end;
{$ELSE X86ASMRTL}
procedure _Finalize(p: Pointer; typeInfo: Pointer);
asm
        MOV     ECX,1
        JMP     _FinalizeArray
end;
{$ENDIF X86ASMRTL}

procedure _AddRefRecord(P: Pointer; TypeInfo: Pointer);
{$IFDEF PUREPASCAL}
var
  FT: PFieldTable;
  I: Cardinal;
begin
  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
  if FT.Count > 0 then
  begin
    for I := 0 to FT.Count - 1 do
    begin
{$IFDEF WEAKREF}
      // Check for the sentinal indicating the following fields are weak references
      // which don't need to be reference counted
      if FT.Fields[I].TypeInfo = nil then
        Break;
{$ENDIF}
      _AddRefArray(Pointer(PByte(P) + UIntPtr(FT.Fields[I].Offset)), FT.Fields[I].TypeInfo^, 1);
    end;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        { ->    EAX pointer to record to be referenced  }
        {       EDX pointer to type info        }

        XOR     ECX,ECX

        PUSH    EBX
        MOV     CL,[EDX+1]

        PUSH    ESI
        PUSH    EDI

        MOV     EBX,EAX
        LEA     ESI,[EDX+ECX+2+8]
        MOV     EDI,[EDX+ECX+2+4]
        TEST    EDI,EDI
        JZ      @@exit
@@loop:

        MOV     EDX,[ESI]
{$IFDEF WEAKREF}
        // Check for the sentinal indicating the following fields are weak references
        // which don't need to be reference counted
        TEST    EDX,EDX
        JE      @@exit
{$ENDIF}
        MOV     EAX,[ESI+4]
        ADD     EAX,EBX
        MOV     EDX,[EDX]
        MOV     ECX, 1
        CALL    _AddRefArray
        ADD     ESI,8
        DEC     EDI
        JG      @@loop
@@exit:
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _VarAddRef(var v: TVarData);
begin
  if Assigned(VarAddRefProc) then
    VarAddRefProc(v)
  else
    Error(reVarInvalidOp);
end;

procedure _AddRefArray(P: Pointer; TypeInfo: Pointer; ElemCount: NativeUInt);
{$IFDEF PUREPASCAL}
var
  FT: PFieldTable;
begin
  if ElemCount = 0 then Exit;
  case PTypeInfo(TypeInfo).Kind of
{$IFDEF WEAKINSTREF}
    tkMethod:
      while ElemCount > 0 do
      begin
        _ClosureAddWeakRef(TMethod(P^));
        Inc(PByte(P), SizeOf(TMethod));
        Dec(ElemCount);
      end;
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
    tkClass:
      while ElemCount > 0 do
      begin
        _InstAddRef(TObject(P^));
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
{$ENDIF}
    tkLString:
      while ElemCount > 0 do
      begin
        _LStrAddRef(PPointer(P)^);
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
    tkWString:
      while ElemCount > 0 do
      begin
        {$IFDEF MSWINDOWS}
        _WStrAddRef(PWideString(P)^);
        {$ELSE}
        _WStrAddRef(PPointer(P)^);
        {$ENDIF}
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
    tkUString:
      while ElemCount > 0 do
      begin
        _UStrAddRef(PPointer(P)^);
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
    tkVariant:
      while ElemCount > 0 do
      begin
        _VarAddRef(PVarData(P)^);
        Inc(PByte(P), SizeOf(TVarData));
        Dec(ElemCount);
      end;
    tkArray:
      begin
        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
        while ElemCount > 0 do
        begin
          _AddRefArray(P, FT.Fields[0].TypeInfo^, FT.Count);
          Inc(PByte(P), FT.Size);
          Dec(ElemCount);
        end;
      end;
    tkRecord:
      begin
        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
        while ElemCount > 0 do
        begin
          _AddRefRecord(P, TypeInfo);
          Inc(PByte(P), FT.Size);
          Dec(ElemCount);
        end;
      end;
    tkInterface:
      while ElemCount > 0 do
      begin
        _IntfAddRef(IInterface(P^));
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
    tkDynArray:
      while ElemCount > 0 do
      begin
        _DynArrayAddRef(PPointer(P)^);
        Inc(PByte(P), SizeOf(Pointer));
        Dec(ElemCount);
      end;
  else
    Error(reInvalidPtr);
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAligned
        { ->    EAX     pointer to data to be referenced        }
        {       EDX     pointer to type info describing data    }
        {       ECX     number of elements of that type         }

        { This code appears to be PIC safe.  The functions called from
          here either don't make external calls (LStrAddRef, WStrAddRef) or
          are Pascal routines that will fix up EBX in their prolog code
          (VarAddRef, IntfAddRef).  }

        PUSH    EBX
        PUSH    ESI
        PUSH    EDI

        TEST  ECX,ECX
        JZ    @@exit

        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EDI,ECX

        XOR     EDX,EDX
        MOV     AL,[ESI]
        MOV     DL,[ESI+1]

{$IFDEF WEAKINSTREF}
        CMP     AL,tkMethod
        JE      @@Method
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
        CMP     AL,tkClass
        JE      @@Class
{$ENDIF}
        CMP     AL,tkLString
        JE      @@LString
        CMP     AL,tkWString
        JE      @@WString
        CMP     AL,tkUString
        JE      @@UString
        CMP     AL,tkVariant
        JE      @@Variant
        CMP     AL,tkArray
        JE      @@Array
        CMP     AL,tkRecord
        JE      @@Record
        CMP     AL,tkInterface
        JE      @@Interface
        CMP     AL,tkDynArray
        JE      @@DynArray
        MOV     AL,reInvalidPtr
        POP     EDI
        POP     ESI
        POP     EBX
        JMP     Error

@@LString:
@@UString:
{$IFDEF POSIX}
@@WString:
{$ENDIF POSIX}
        MOV     EAX,[EBX]
        ADD     EBX,4
        CALL    _LStrAddRef
        DEC     EDI
        JG      @@LString
        JMP     @@exit

{$IFDEF MSWINDOWS}
@@WString:
        MOV     EAX,EBX
        ADD     EBX,4
        CALL    _WStrAddRef
        DEC     EDI
        JG      @@WString
        JMP     @@exit
{$ENDIF MSWINDOWS}
@@Variant:
        MOV     EAX,EBX
        ADD     EBX,16
        CALL    _VarAddRef
        DEC     EDI
        JG      @@Variant
        JMP     @@exit

@@Array:
        PUSH    EBP
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        MOV     EBP,EDX
@@ArrayLoop:
        MOV     EDX,[ESI+EBP+2+8]
        MOV     EAX,EBX
        ADD     EBX,[ESI+EBP+2]
        MOV     ECX,[ESI+EBP+2+4]
        MOV     EDX,[EDX]
        CALL    _AddRefArray
        DEC     EDI
        JG      @@ArrayLoop
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        POP     EBP
        JMP     @@exit

@@Record:
        PUSH    EBP
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        MOV     EBP,EDX
@@RecordLoop:
        MOV     EAX,EBX
        ADD     EBX,[ESI+EBP+2]
        MOV     EDX,ESI
        CALL    _AddRefRecord
        DEC     EDI
        JG      @@RecordLoop
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        POP     EBP
        JMP     @@exit

@@Interface:
        MOV     EAX,[EBX]
        ADD     EBX,4
        CALL    _IntfAddRef
        DEC     EDI
        JG      @@Interface
        JMP     @@exit

{$IFDEF AUTOREFCOUNT}
@@Class:
        MOV     EAX,[EBX]
        ADD     EBX,4
        CALL    _InstAddRef
        DEC     EDI
        JG      @@Class
        JMP     @@exit
{$ENDIF}

{$IFDEF WEAKINSTREF}
@@Method:
        MOV     EAX,[EBX]
        ADD     EBX,8
        CALL    _ClosureAddWeakRef
        DEC     EDI
        JG      @@Class
        JMP     @@exit
{$ENDIF}

@@DynArray:
        MOV     EAX,[EBX]
        ADD     EBX,4
        CALL    _DynArrayAddRef
        DEC     EDI
        JG      @@DynArray
@@exit:

        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _AddRef(P: Pointer; TypeInfo: Pointer);
{$IFDEF PUREPASCAL}
begin
  _AddRefArray(P, TypeInfo, 1);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        MOV     ECX,1
        JMP     _AddRefArray
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _VarCopy(var Dest: TVarData; const Src: TVarData);
begin
  if Assigned(VarCopyProc) then
    VarCopyProc(Dest, Src)
  else
    Error(reVarInvalidOp);
end;

{$IF not defined(X86ASMRTL)}
procedure _CopyRecord(Dest, Source, TypeInfo: Pointer);
var
  FT, EFT: PFieldTable;
  I, Count, L: Cardinal;
{$IFDEF WEAKREF}
  J, K: Cardinal;
{$ENDIF}
  Offset: UIntPtr;
  FTypeInfo: PTypeInfo;
  DestOff, SrcOff: Pointer;
begin
  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
  Offset := 0;
  if FT.Count > 0 then
  begin
    Count := FT.Count;
{$IFDEF WEAKREF}
    K := Count;
    for I := Count - 1 downto 0 do
      if FT.Fields[I].TypeInfo = nil then
      begin
        K := I + 1; // found the weak sentinal
        Dec(Count); // remove the sentinal from consideration
        Break;
      end;
    J := 0;
{$ENDIF}
    for L := 0 to Count - 1 do
    begin
{$IFDEF WEAKREF}
      if (FT.Fields[J].TypeInfo <> nil) and ((K = FT.Count) or (FT.Fields[J].Offset < FT.Fields[K].Offset)) then
      begin
        I := J;
        Inc(J);
      end else
      begin
        I := K;
        Inc(K);
      end;
{$ELSE}
      I := L;
{$ENDIF}
      if FT.Fields[I].Offset > Offset then
        Move(Pointer(PByte(Source) + Offset)^,
             Pointer(PByte(Dest) + Offset)^,
             FT.Fields[I].Offset - Offset);
      Offset := FT.Fields[I].Offset;
      FTypeInfo := FT.Fields[I].TypeInfo^;
      DestOff := Pointer(PByte(Dest) + Offset);
      SrcOff := Pointer(PByte(Source) + Offset);
      case FTypeInfo.Kind of
{$IFDEF WEAKINSTREF}
        tkMethod:
          begin
            _CopyClosure(PMethod(DestOff)^, PMethod(SrcOff)^);
            Inc(Offset, SizeOf(TMethod));
          end;
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
        tkClass:
          begin
{$IFDEF WEAKINSTREF}
            if I > J then
              _InstWeakCopy(TObject(PPointer(DestOff)^), TObject(PPointer(SrcOff)^))
            else
{$ENDIF}
              _InstCopy(TObject(PPointer(DestOff)^), TObject(PPointer(SrcOff)^));
            Inc(Offset, SizeOf(Pointer));
          end;
{$ENDIF}
        tkLString:
          begin
            _LStrAsg(_PAnsiStr(DestOff)^, _PAnsiStr(SrcOff)^);
            Inc(Offset, SizeOf(Pointer));
          end;
        tkWString:
          begin
            _WStrAsg(_PWideStr(DestOff)^, _PWideStr(SrcOff)^);
            Inc(Offset, SizeOf(Pointer));
          end;
        tkUString:
          begin
            _UStrAsg(PUnicodeString(DestOff)^, PUnicodeString(SrcOff)^);
            Inc(Offset, SizeOf(Pointer));
          end;
        tkVariant:
          begin
            _VarCopy(PVarData(DestOff)^, PVarData(SrcOff)^);
            Inc(Offset, SizeOf(TVarData));
          end;
        tkArray:
          begin
            EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeInfo(FTypeInfo).Name[0]));
            _CopyArray(DestOff, SrcOff, EFT.Fields[0].TypeInfo^, EFT.Count);
            Inc(Offset, EFT.Size);
          end;
        tkRecord:
          begin
            EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeInfo(FTypeInfo).Name[0]));
            _CopyRecord(DestOff, SrcOff, FTypeInfo);

            Inc(Offset, EFT.Size);
          end;
        tkInterface:
          begin
{$IFDEF WEAKINTFREF}
            if I > J then
              _IntfWeakCopy(IInterface(PPointer(DestOff)^), IInterface(PPointer(SrcOff)^))
            else
{$ENDIF}
              _IntfCopy(IInterface(PPointer(DestOff)^), IInterface(PPointer(SrcOff)^));
            Inc(Offset, SizeOf(Pointer));
          end;
        tkDynArray:
          begin
            _DynArrayAsg(PPointer(DestOff)^, PPointer(SrcOff)^, FTypeInfo);
            Inc(Offset, SizeOf(Pointer));
          end;
      else
        Error(reInvalidPtr);
      end;
    end;
  end;
  if FT.Size > Offset then
    Move(Pointer(PByte(Source) + Offset)^,
         Pointer(PByte(Dest) + Offset)^,
         FT.Size - Offset);
end;
{$ELSE X86ASMRTL}
procedure _CopyRecord{ dest, source, typeInfo: Pointer };
const
  FldPtr = 8;
  EndPtr = 4;
  RecSize = 0;
  TFieldInfoSize = SizeOf(TFieldInfo);
asm
        { ->    EAX pointer to dest             }
        {       EDX pointer to source           }
        {       ECX pointer to typeInfo         }

        PUSH    EBX                      { 12 -> 8  }
        PUSH    ESI                      { 8  -> 4  }
        PUSH    EDI                      { 4  -> 0  }
        PUSH    EBP                      { 0  -> 12 }
        PUSH    0                        { 12 -> 8  use [ESP+FldPtr] for the "saved" Field pointer }
        PUSH    0                        { 8  -> 4  use [ESP+EndPtr] for the "end" of the field info array }

        MOV     EBX,EAX
        MOV     ESI,EDX

        XOR     EAX,EAX
        MOV     AL,[ECX].TTypeInfo.Name.Byte

        LEA     EDI,[ECX+EAX+2+8]
        MOV     EBP,[EDI-4] //TFieldTable.Count
        XOR     EAX,EAX
        MOV     ECX,[EDI-8] //TFieldTable.Size
        TEST    EBP,EBP
        JZ      @@moveWhole
        PUSH    ECX                      { 4  -> 0  }
{$IFDEF WEAKREF}
        MOV     ECX,EBP
        LEA     EDX,[EDI+ECX*TFieldInfoSize]
        MOV     [ESP+EndPtr],EDX
        MOV     [ESP+FldPtr],EDX
@@findWeak:
        CMP     [EDI+ECX*TFieldInfoSize-TFieldInfoSize].TFieldInfo.TypeInfo,0
        JE      @@hasWeak
        DEC     ECX
        JNZ     @@findWeak
        JMP     @@loop
@@hasWeak:
        LEA     ECX,[EDI+ECX*8]
        MOV     [ESP+FldPtr],ECX
        DEC     EBP     { Remove the sentinal from consideration }
{$ENDIF}
@@loop:
{$IFDEF WEAKREF}
        MOV     EDX,[ESP+FldPtr]
        CMP     EDX,[ESP+EndPtr]
        JE      @@noWeak
        CMP     [EDX].TFieldInfo.TypeInfo,0
        JE      @@noWeak
        CMP     [EDI].TFieldInfo.TypeInfo,0
        JE      @@doneStrong  { found the sentinal, so the rest are all weak }
        MOV     ECX,[EDX+4] // TFieldInfo.Offset
        CMP     ECX,[EDI+4] // TFieldInfo.Offset Compare the offsets
        JA      @@noWeak
@@doneStrong:
        XCHG    EDI,[ESP+FldPtr] // Swap the Weak/noWeak pointers
@@noWeak:
{$ENDIF}
        MOV     ECX,[EDI+4] //TFieldInfo.Offset
        SUB     ECX,EAX
        JLE     @@nomove1
        MOV     EDX,EAX
        ADD     EAX,ESI
        ADD     EDX,EBX
        CALL    Move
@@noMove1:
        MOV     EAX,[EDI+4] //TFieldInfo.Offset
        MOV     EDX,[EDI].TFieldInfo.TypeInfo
        MOV     EDX,[EDX]
        MOV     CL,[EDX].TTypeInfo.Kind

{$IFDEF WEAKINSTREF}
        CMP     CL,tkMethod
        JE      @@Method
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
        CMP     CL,tkClass
        JE      @@Class
{$ENDIF}
        CMP     CL,tkInterface
        JE      @@Interface
{$IFDEF WEAKREF}
        CMP     EDI,[ESP+FldPtr]
        JA      @@error
{$ENDIF}
        CMP     CL,tkLString
        JE      @@LString
        CMP     CL,tkWString
        JE      @@WString
        CMP     CL,tkUString
        JE      @@UString
        CMP     CL,tkVariant
        JE      @@Variant
        CMP     CL,tkArray
        JE      @@Array
        CMP     CL,tkRecord
        JE      @@Record
        CMP     CL,tkDynArray
        JE      @@DynArray
@@error:
        MOV     AL,reInvalidPtr
        POP     ECX                      { 0  -> 4  }
        ADD     ESP, 8                   { 4  -> 12 }
        POP     EBP                      { 12 -> 0  }
        POP     EDI                      { 0  -> 4  }
        POP     ESI                      { 4  -> 8  }
        POP     EBX                      { 8  -> 12 }
        JMP     Error

@@LString:
        MOV     EDX,[ESI+EAX]
        ADD     EAX,EBX
        CALL    _LStrAsg
        MOV     EAX,4
        JMP     @@common

@@UString:
        MOV     EDX,[ESI+EAX]
        ADD     EAX,EBX
        CALL    _UStrAsg
        MOV     EAX,4
        JMP     @@common

@@WString:
        MOV     EDX,[ESI+EAX]
        ADD     EAX,EBX
        CALL    _WStrAsg
        MOV     EAX,4
        JMP     @@common

@@Variant:
        LEA     EDX,[ESI+EAX]
        ADD     EAX,EBX
        CALL    _VarCopy
        MOV     EAX,16
        JMP     @@common

@@Array:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8                   { 0  -> 8  }
{$ENDIF ALIGN_STACK}
        XOR     ECX,ECX
        MOV     CL,[EDX+1]
        PUSH    dword ptr [EDX+ECX+2]    { 8  -> 4  }
        PUSH    dword ptr [EDX+ECX+2+4]  { 4  -> 0  }
        MOV     ECX,[EDX+ECX+2+8]
        MOV     ECX,[ECX]
        LEA     EDX,[ESI+EAX]
        ADD     EAX,EBX
        CALL    _CopyArray
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
        JMP     @@common

@@Record:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12                  { 0  -> 4  }
{$ENDIF ALIGN_STACK}
        XOR     ECX,ECX
        MOV     CL,[EDX+1]
        MOV     ECX,[EDX+ECX+2]
        PUSH    ECX                      { 4  -> 0  }
        MOV     ECX,EDX
        LEA     EDX,[ESI+EAX]
        ADD     EAX,EBX
        CALL    _CopyRecord
        POP     EAX                      { 0  -> 4  }
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12                  { 4  -> 0  }
{$ENDIF ALIGN_STACK}
        JMP     @@common

@@Interface:
        MOV     EDX,[ESI+EAX]
        ADD     EAX,EBX
{$IFDEF WEAKINTFREF}
        CMP     EDI,[ESP+FldPtr]                { if Weak then _IntfWeakCopy else _IntfCopy }
        JB      @@intfCopy

        CALL    _IntfWeakCopy
        MOV     EAX,4
        JMP     @@common
@@intfCopy:
{$ENDIF}
        CALL    _IntfCopy
        MOV     EAX,4
        JMP     @@common

{$IFDEF WEAKINSTREF}
@@Method:
        LEA     EDX,[ESI+EAX]
        ADD     EAX,EBX
        CALL    _CopyClosure
        MOV     EAX,8
        JMP     @@common
{$ENDIF}

{$IFDEF AUTOREFCOUNT}
@@Class:
        MOV     EDX,[ESI+EAX]
        ADD     EAX,EBX
{$IFDEF WEAKINSTREF}
        CMP     EDI,[ESP+FldPtr]                { if Weak then _InstWeakCopy else _InstCopy }
        JB      @@instCopy

        CALL    _InstWeakCopy
        MOV     EAX,4
        JMP     @@common
@@instCopy:
{$ENDIF}
        CALL    _InstCopy
        MOV     EAX,4
        JMP     @@common
{$ENDIF}

@@DynArray:
        MOV     ECX,EDX
        MOV     EDX,[ESI+EAX]
        ADD     EAX,EBX
        CALL    _DynArrayAsg
        MOV     EAX,4

@@common:
        ADD     EAX,[EDI+4]
        ADD     EDI,8
        DEC     EBP
        JNZ     @@loop
        POP     ECX                      { 0  -> 4  }

@@moveWhole:
        SUB     ECX,EAX
        JLE     @@noMove2
        LEA     EDX,[EBX+EAX]
        ADD     EAX,ESI
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4                   { 4  -> 0  }
{$ENDIF ALIGN_STACK}
        CALL    Move
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4                   { 0  -> 4  }
{$ENDIF ALIGN_STACK}
@@noMove2:

        ADD     ESP, 8                   { 4  -> 12 }
        POP     EBP                      { 12 -> 0  }
        POP     EDI                      { 0  -> 4  }
        POP     ESI                      { 4  -> 8  }
        POP     EBX                      { 8  -> 12 }
end;                                     { 12 -> 0  RET }
{$ENDIF X86ASMRTL}

procedure MoveRecord(Dest, Source, TypeInfo: Pointer);
var
  FT, EFT: PFieldTable;
  I, Count, L: Cardinal;
{$IFDEF WEAKREF}
  J, K: Cardinal;
{$ENDIF}
  Offset: UIntPtr;
  FTypeInfo: PTypeInfo;
  DestOff, SrcOff: Pointer;
begin
  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
  Offset := 0;
  if FT.Count > 0 then
  begin
    Count := FT.Count;
{$IFDEF WEAKREF}
    K := Count;
    for I := Count - 1 downto 0 do
      if FT.Fields[I].TypeInfo = nil then
      begin
        K := I + 1; // found the weak sentinal
        Dec(Count); // remove the sentinal from consideration
        Break;
      end;
    J := 0;
{$ENDIF}
    for L := 0 to Count - 1 do
    begin
{$IFDEF WEAKREF}
      if (FT.Fields[J].TypeInfo <> nil) and ((K = FT.Count) or (FT.Fields[J].Offset < FT.Fields[K].Offset)) then
      begin
        I := J;
        Inc(J);
      end else
      begin
        I := K;
        Inc(K);
      end;
{$ELSE}
      I := L;
{$ENDIF}
      if FT.Fields[I].Offset > Offset then
        Move(Pointer(PByte(Source) + Offset)^,
             Pointer(PByte(Dest) + Offset)^,
             FT.Fields[I].Offset - Offset);
      Offset := FT.Fields[I].Offset;
      FTypeInfo := FT.Fields[I].TypeInfo^;
      DestOff := Pointer(PByte(Dest) + Offset);
      SrcOff := Pointer(PByte(Source) + Offset);
      case FTypeInfo.Kind of
{$IFDEF WEAKINSTREF}
        tkMethod:
          begin
            _CopyClosure(PMethod(DestOff)^, PMethod(SrcOff)^);
            _ClosureRemoveWeakRef(PMethod(SrcOff)^);
            Inc(Offset, SizeOf(TMethod));
          end;
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
        tkClass:
          begin
{$IFDEF WEAKINSTREF}
            if I > J then
            begin
              _InstWeakCopy(TObject(PPointer(DestOff)^), TObject(PPointer(SrcOff)^));
              _InstWeakClear(TObject(PPointer(SrcOff)^));
            end
            else
{$ENDIF}
              PPointer(DestOff)^ := PPointer(SrcOff)^;
            Inc(Offset, SizeOf(Pointer));
          end;
{$ENDIF}
{$IFNDEF WEAKINSTREF}
        tkMethod:
          begin
            PMethod(DestOff)^ := PMethod(SrcOff)^;
            Inc(Offset, SizeOf(TMethod));
          end;
{$ENDIF !WEAKINSTREF}
{$IFNDEF AUTOREFCOUNT}
        tkClass,
{$ENDIF !AUTOREFCOUNT}
        tkLString,
        tkWString,
        tkUString,
        tkVariant,
        tkDynArray:
          begin
            PPointer(DestOff)^ := PPointer(SrcOff)^;
            Inc(Offset, SizeOf(Pointer));
          end;
        tkArray:
          begin
            EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeInfo(FTypeInfo).Name[0]));
            MoveArray(DestOff, SrcOff, EFT.Fields[0].TypeInfo^, EFT.Count);
            Inc(Offset, EFT.Size);
          end;
        tkRecord:
          begin
            EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeInfo(FTypeInfo).Name[0]));
            MoveRecord(DestOff, SrcOff, FTypeInfo);
            Inc(Offset, EFT.Size);
          end;
        tkInterface:
          begin
{$IFDEF WEAKINTFREF}
            if I > J then
            begin
              _IntfWeakCopy(IInterface(PPointer(DestOff)^), IInterface(PPointer(SrcOff)^));
              _IntfWeakClear(IInterface(PPointer(SrcOff)^));
            end
            else
{$ENDIF}
              PPointer(DestOff)^ := PPointer(SrcOff)^;
            Inc(Offset, SizeOf(Pointer));
          end;
      else
        Error(reInvalidPtr);
      end;
    end;
  end;
  if FT.Size > Offset then
    Move(Pointer(PByte(Source) + Offset)^,
         Pointer(PByte(Dest) + Offset)^,
         FT.Size - Offset);
end;

{$IF not defined(X86ASMRTL)}
procedure _CopyObject(Dest, Source: Pointer; vmtPtrOffs: NativeInt; TypeInfo: Pointer);
var
  SavedVmtPtr: Pointer;
begin
  SavedVmtPtr := PPointer(PByte(Dest) + vmtPtrOffs)^;
  _CopyRecord(Dest, Source, TypeInfo);
  PPointer(PByte(Dest) + vmtPtrOffs)^ := SavedVmtPtr;
end;
{$ELSE X86ASMRTL}
procedure       _CopyObject{ dest, source: Pointer; vmtPtrOffs: NativeInt; typeInfo: Pointer };
asm
        { ->    EAX     pointer to dest         }
        {       EDX     pointer to source       }
        {       ECX     offset of vmt in object }
        {       [ESP+4] pointer to typeInfo     }

        ADD     ECX,EAX                         { pointer to dest vmt }
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    dword ptr [ECX]                 { save dest vmt }
        PUSH    ECX
{$IFDEF ALIGN_STACK}
        MOV     ECX,[ESP+4+4+4+4]
{$ELSE}
        MOV     ECX,[ESP+4+4+4]
{$ENDIF}
        CALL    _CopyRecord
        POP     ECX
        POP     dword ptr [ECX]                 { restore dest vmt }
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
        RET     4

end;
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
procedure _CopyArray(Dest, Source, TypeInfo: Pointer; Count: NativeUInt);
var
  FT: PFieldTable;
begin
  if Count = 0 then Exit;
  case PTypeInfo(TypeInfo).Kind of
{$IFDEF WEAKINSTREF}
    tkMethod:
      while Count > 0 do
      begin
        _CopyClosure(PMethod(Dest)^, PMethod(Source)^);
        Inc(PByte(Dest), SizeOf(TMethod));
        Inc(PByte(Source), SizeOf(TMethod));
        Dec(Count);
      end;
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
    tkClass:
      while Count > 0 do
      begin
        _InstCopy(TObject(PPointer(Dest)^), TObject(PPointer(Source)^));
        Inc(PByte(Dest), SizeOf(Pointer));
        Inc(PByte(Source), SizeOf(Pointer));
        Dec(Count);
      end;
{$ENDIF}
    tkLString:
      while Count > 0 do
      begin
        _LStrAsg(_PAnsiStr(Dest)^, _PAnsiStr(Source)^);
        Inc(PByte(Dest), SizeOf(Pointer));
        Inc(PByte(Source), SizeOf(Pointer));
        Dec(Count);
      end;
    tkWString:
      while Count > 0 do
      begin
        _WStrAsg(_PWideStr(Dest)^, _PWideStr(Source)^);
        Inc(PByte(Dest), SizeOf(Pointer));
        Inc(PByte(Source), SizeOf(Pointer));
        Dec(Count);
      end;
    tkUString:
      while Count > 0 do
      begin
        _UStrAsg(PUnicodeString(Dest)^, PUnicodeString(Source)^);
        Inc(PByte(Dest), SizeOf(Pointer));
        Inc(PByte(Source), SizeOf(Pointer));
        Dec(Count);
      end;
    tkVariant:
      while Count > 0 do
      begin
        _VarCopy(PVarData(Dest)^, PVarData(Source)^);
        Inc(PByte(Dest), SizeOf(TVarData));
        Inc(PByte(Source), SizeOf(TVarData));
        Dec(Count);
      end;
    tkArray:
      begin
        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
        while Count > 0 do
        begin
          _CopyArray(Pointer(Dest), Pointer(Source), FT.Fields[0].TypeInfo^, FT.Count);
          Inc(PByte(Dest), FT.Size);
          Inc(PByte(Source), FT.Size);
          Dec(Count);
        end;
      end;
    tkRecord:
      begin
        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
        while Count > 0 do
        begin
          _CopyRecord(Dest, Source, TypeInfo);
          Inc(PByte(Dest), FT.Size);
          Inc(PByte(Source), FT.Size);
          Dec(Count);
        end;
      end;
    tkInterface:
      while Count > 0 do
      begin
        _IntfCopy(IInterface(PPointer(Dest)^), IInterface(PPointer(Source)^));
        Inc(PByte(Dest), SizeOf(Pointer));
        Inc(PByte(Source), SizeOf(Pointer));
        Dec(Count);
      end;
    tkDynArray:
      while Count > 0 do
      begin
        _DynArrayAsg(PPointer(Dest)^, PPointer(Source)^, TypeInfo);
        Inc(PByte(Dest), SizeOf(Pointer));
        Inc(PByte(Source), SizeOf(Pointer));
        Dec(Count);
      end;
  else
    Error(reInvalidPtr);
  end;
end;
{$ELSE X86ASMRTL}
procedure _CopyArray{ dest, source, typeInfo: Pointer; cnt: Integer };
asm
        { ->    EAX pointer to dest             }
        {       EDX pointer to source           }
        {       ECX pointer to typeInfo         }
        {       [ESP+4] count                   }
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        PUSH    EBP

        MOV     EBX,EAX
        MOV     ESI,EDX
        MOV     EDI,ECX
        MOV     EBP,[ESP+4+4*4]

        MOV     CL,[EDI]

{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
{$IFDEF WEAKINSTREF}
        CMP     CL,tkMethod
        JE      @@Method
{$ENDIF}
{$IFDEF AUTOREFCOUNT}
        CMP     CL,tkClass
        JE      @@Class
{$ENDIF}
        CMP     CL,tkLString
        JE      @@LString
        CMP     CL,tkWString
        JE      @@WString
        CMP     CL,tkUString
        JE      @@UString
        CMP     CL,tkVariant
        JE      @@Variant
        CMP     CL,tkArray
        JE      @@Array
        CMP     CL,tkRecord
        JE      @@Record
        CMP     CL,tkInterface
        JE      @@Interface
        CMP     CL,tkDynArray
        JE      @@DynArray
        MOV     AL,reInvalidPtr
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        POP     EBP
        POP     EDI
        POP     ESI
        POP     EBX
        JMP     Error

@@LString:
        MOV     EAX,EBX
        MOV     EDX,[ESI]
        CALL    _LStrAsg
        ADD     EBX,4
        ADD     ESI,4
        DEC     EBP
        JNE     @@LString
        JMP     @@exit

@@WString:
        MOV     EAX,EBX
        MOV     EDX,[ESI]
        CALL    _WStrAsg
        ADD     EBX,4
        ADD     ESI,4
        DEC     EBP
        JNE     @@WString
        JMP     @@exit

@@UString:
        MOV     EAX,EBX
        MOV     EDX,[ESI]
        CALL    _UStrAsg
        ADD     EBX,4
        ADD     ESI,4
        DEC     EBP
        JNE     @@UString
        JMP     @@exit

@@Variant:
        MOV     EAX,EBX
        MOV     EDX,ESI
        CALL    _VarCopy
        ADD     EBX,16
        ADD     ESI,16
        DEC     EBP
        JNE     @@Variant
        JMP     @@exit

@@Array:
        XOR     ECX,ECX
        MOV     CL,[EDI+1]
        LEA     EDI,[EDI+ECX+2]
@@ArrayLoop:
        MOV     EAX,EBX
        MOV     EDX,ESI
        MOV     ECX,[EDI+8]
        MOV     ECX,[ECX]
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4 // Negitive Adjustment
{$ENDIF ALIGN_STACK}
        PUSH    dword ptr [EDI+4]
        CALL    _CopyArray
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        ADD     EBX,[EDI]
        ADD     ESI,[EDI]
        DEC     EBP
        JNE     @@ArrayLoop
        JMP     @@exit

@@Record:
        MOV     EAX,EBX
        MOV     EDX,ESI
        MOV     ECX,EDI
        CALL    _CopyRecord
        XOR     EAX,EAX
        MOV     AL,[EDI+1]
        ADD     EBX,[EDI+EAX+2]
        ADD     ESI,[EDI+EAX+2]
        DEC     EBP
        JNE     @@Record
        JMP     @@exit

@@Interface:
        MOV     EAX,EBX
        MOV     EDX,[ESI]
        CALL    _IntfCopy
        ADD     EBX,4
        ADD     ESI,4
        DEC     EBP
        JNE     @@Interface
        JMP     @@exit

{$IFDEF WEAKINSTREF}
@@Method:
        MOV     EAX,EBX
        MOV     EDX,ESI
        CALL    _CopyClosure
        ADD     EBX,8
        ADD     ESI,8
        DEC     EBP
        JNE     @@Method
        JMP     @@exit
{$ENDIF}

{$IFDEF AUTOREFCOUNT}
@@Class:
        MOV     EAX,EBX
        MOV     EDX,[ESI]
        CALL    _InstCopy
        ADD     EBX,4
        ADD     ESI,4
        DEC     EBP
        JNE     @@Class
        JMP     @@exit
{$ENDIF}

@@DynArray:
        MOV     EAX,EBX
        MOV     EDX,[ESI]
        MOV     ECX,EDI
        CALL    _DynArrayAsg
        ADD     EBX,4
        ADD     ESI,4
        DEC     EBP
        JNE     @@DynArray

@@exit:
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        POP     EBP
        POP     EDI
        POP     ESI
        POP     EBX
        RET     4
end;
{$ENDIF X86ASMRTL}

procedure MoveArray(Dest, Source, TypeInfo: Pointer; Count: NativeInt);
var
  FT: PFieldTable;
begin
  if Count = 0 then Exit;
  case PTypeInfo(TypeInfo).Kind of
{$IFDEF WEAKINSTREF}
    tkMethod:
      while Count > 0 do
      begin
        _CopyClosure(PMethod(Dest)^, PMethod(Source)^);
        _ClosureRemoveWeakRef(TMethod(Source^));
        Inc(PByte(Dest), SizeOf(TMethod));
        Inc(PByte(Source), SizeOf(TMethod));
        Dec(Count);
      end;
{$ELSE !WEAKINSTREF}
    tkMethod:
      Move(PByte(Source)^, PByte(Dest)^, Count * SizeOf(TMethod));
{$ENDIF WEAKINSTREF}
    tkClass,
    tkLString,
    tkWString,
    tkUString,
    tkVariant,
    tkDynArray,
    tkInterface:
      Move(PByte(Source)^, PByte(Dest)^, Count * SizeOf(Pointer));

    tkArray:
      begin
        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
        while Count > 0 do
        begin
          MoveArray(Dest, Source, FT.Fields[0].TypeInfo^, FT.Count);
          Inc(PByte(Dest), FT.Size);
          Inc(PByte(Source), FT.Size);
          Dec(Count);
        end;
      end;
    tkRecord:
      begin
        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).Name[0]));
        while Count > 0 do
        begin
          MoveRecord(Dest, Source, TypeInfo);
          Inc(PByte(Dest), FT.Size);
          Inc(PByte(Source), FT.Size);
          Dec(Count);
        end;
      end;
  else
    Error(reInvalidPtr);
  end;
end;

function _New(Size: NativeInt; TypeInfo: Pointer): Pointer;
{$IFDEF PUREPASCAL}
begin
  GetMem(Result, Size);
  if Result <> nil then
    _Initialize(Result, TypeInfo);
end;
{$ELSE !PUREPASCAL}
asm
        { ->    EAX size of object to allocate  }
        {       EDX pointer to typeInfo         }
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EDX
        CALL    _GetMem
        POP     EDX
        TEST    EAX,EAX
        JE      @@exit
        PUSH    EAX
        CALL    _Initialize
        POP     EAX
@@exit:
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
end;
{$ENDIF !PUREPASCAL}

procedure _Dispose(P: Pointer; TypeInfo: Pointer);
{$IFDEF PUREPASCAL}
begin
  _Finalize(P, TypeInfo);
  FreeMem(P);
end;
{$ELSE !PUREPASCAL}
asm
        { ->    EAX     Pointer to object to be disposed        }
        {       EDX     Pointer to type info                    }

{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        CALL    _Finalize
        POP     EAX
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        CALL    _FreeMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
end;
{$ENDIF !PUREPASCAL}


procedure CopyArray(Dest, Source, TypeInfo: Pointer; Count: NativeInt);
{$IFDEF PUREPASCAL}
begin
  if Count > 0 then
    _CopyArray(Dest, Source, TypeInfo, Count);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
        // PUSH EBP -- implicitly generated by existence of 4th parameter
        CMP     dword ptr [EBP+8],0
        JBE     @@Exit
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    dword ptr [EBP+8]
        CALL    _CopyArray
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
@@Exit:
        // POP EBP -- implicitly generated by existence of 4th parameter
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure FinalizeArray(P, TypeInfo: Pointer; Count: NativeUInt);
{$IFDEF PUREPASCAL}
begin
  _FinalizeArray(P, TypeInfo, Count);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        JMP     _FinalizeArray
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure CopyRecord(Dest, Source, TypeInfo: Pointer);
{$IFDEF PUREPASCAL}
begin
  _CopyRecord(Dest, Source, TypeInfo);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        JMP     _CopyRecord
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

Procedure FinalizeRecord(P: Pointer; TypeInfo: Pointer);
{$IFDEF PUREPASCAL}
begin
  _FinalizeRecord(P, TypeInfo);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        JMP     _FinalizeRecord
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

{ ----------------------------------------------------- }
{       Wide character support                          }
{ ----------------------------------------------------- }

function WideCharToString(Source: PWideChar): UnicodeString;
begin
  WideCharToStrVar(Source, Result);
end;

function WideCharLenToString(Source: PWideChar; SourceLen: Integer): UnicodeString;
begin
  WideCharLenToStrVar(Source, SourceLen, Result);
end;

procedure WideCharToStrVar(Source: PWideChar; var Dest: UnicodeString);
begin
  _UStrFromPWChar(Dest, Source);
end;

procedure WideCharLenToStrVar(Source: PWideChar; SourceLen: Integer;
  var Dest: UnicodeString);
begin
  _UStrFromPWCharLen(Dest, Source, SourceLen);
end;

procedure WideCharLenToStrVar(Source: PWideChar; SourceLen: Integer;
  var Dest: _AnsiStr);
begin
  _LStrFromPWCharLen(Dest, Source, SourceLen, DefaultSystemCodePage);
end;

function StringToWideChar(const Source: UnicodeString; Dest: PWideChar;
  DestSize: Integer): PWideChar;
begin
  //Check to see if enough storage is allocated
  if Length(Source) + 1 > DestSize then
  begin
    if DestSize > 0 then
    begin
      Dest[0] := #0;
      Result := Dest;
    end
    else
    begin
      Result := '';
    end;
    Exit;
  end;

  Move(Source[Low(string)], Dest[0], Length(Source) * SizeOf(WideChar));
  Dest[Length(Source)] := #0;
  Result := Dest;
end;

{ ----------------------------------------------------- }
{       OLE string support                              }
{ ----------------------------------------------------- }

function OleStrToString(Source: PWideChar): UnicodeString;
begin
  OleStrToStrVar(Source, Result);
end;

procedure OleStrToStrVar(Source: PWideChar; var Dest: _AnsiStr);
begin
  WideCharLenToStrVar(Source, Length(_WideStr(Pointer(Source))), Dest);
end;

procedure OleStrToStrVar(Source: PWideChar; var Dest: UnicodeString);
begin
  WideCharLenToStrVar(Source, Length(_WideStr(Pointer(Source))), Dest);
end;

function StringToOleStr(const Source: _AnsiStr): PWideChar;
begin
  Result := nil;
  _WStrFromPCharLen(_WideStr(Pointer(Result)), _PAnsiChr(Pointer(Source)), Length(Source));
end;

function StringToOleStr(const Source: UnicodeString): PWideChar; overload;
begin
  Result := nil;
  _WStrFromPWCharLen(_WideStr(Pointer(Result)), PWideChar(Pointer(Source)), Length(Source));
end;

{ ----------------------------------------------------- }
{       Variant manager support   (obsolete)            }
{ ----------------------------------------------------- }

procedure GetVariantManager(var VarMgr: TVariantManager);
begin
  FillChar(VarMgr, sizeof(VarMgr), 0);
end;

procedure SetVariantManager(const VarMgr: TVariantManager);
begin
end;

function IsVariantManagerSet: Boolean;
begin
  Result := False;
end;

                                                                 
{$IF not defined(X86ASMRTL)}
procedure _IntfDispCall(Result: Pointer; const Dispatch: IDispatch;
  DispDesc: PDispDesc); cdecl; varargs;
type
  TDispCallByIDProc = procedure(Result: Pointer; const Dispatch: IDispatch;
    DispDesc: PDispDesc; Params: Pointer); cdecl;
var
  VAList: TVarArgList;
begin
  VarArgStart(VAList);
  {$IFDEF RECORD_TVARARGLIST}
                                             
  TDispCallByIDProc(DispCallByIDProc)(Result, Dispatch, DispDesc, @VAList);
  {$ELSE}
  TDispCallByIDProc(DispCallByIDProc)(Result, Dispatch, DispDesc, Pointer(VAList));
  {$ENDIF}
  VarArgEnd(VAList);
end;
{$ELSE X86ASMRTL}
procedure _IntfDispCall;
asm
{$IFDEF PIC}
        PUSH    EAX
        PUSH    ECX
        CALL    GetGOT
        POP     ECX
        LEA     EAX,[EAX].OFFSET DispCallByIDProc
        MOV     EAX,[EAX]
        XCHG    EAX,[ESP]
        RET
{$ELSE}
        JMP     DispCallByIDProc
{$ENDIF}
end;
{$ENDIF X86ASMRTL}

                                                                      
{$IF not defined(X86ASMRTL)}
procedure _DispCallByIDError(Result: Pointer; const Dispatch: IDispatch;
  DispDesc: PDispDesc; Params: Pointer); cdecl;
begin
  ErrorAt(byte(reVarDispatch), ReturnAddress);
end;
{$ELSE X86ASMRTL}
procedure _DispCallByIDError;
asm
        MOV     AL,reVarDispatch
        JMP     Error
end;
{$ENDIF X86ASMRTL}

{$IF not defined(X86ASMRTL)}
procedure _IntfVarCall(Dest: PVarData; const Source: TVarData;
  CallDesc: PCallDesc); cdecl; varargs;
{$ELSE X86ASMRTL}
procedure _IntfVarCall;
{$ENDIF X86ASMRTL}
begin
end;

{$IF defined(CPUX86) and defined(ASSEMBLER)}
// 64 bit integer helper routines
//
// These functions always return the 64-bit result in EAX:EDX

// ------------------------------------------------------------------------------
//  64-bit signed multiply
// ------------------------------------------------------------------------------
//
//  Param 1(EAX:EDX), Param 2([ESP+8]:[ESP+4])  ; before reg pushing
//
procedure __llmul;
asm //StackAlignSafe
        PUSH  EDX
        PUSH  EAX

  // Param2 : [ESP+16]:[ESP+12]  (hi:lo)
  // Param1 : [ESP+4]:[ESP]      (hi:lo)

        MOV   EAX, [ESP+16]
        MUL   DWORD PTR [ESP]
        MOV   ECX, EAX

        MOV   EAX, [ESP+4]
        MUL   DWORD PTR [ESP+12]
        ADD   ECX, EAX

        MOV   EAX, [ESP]
        MUL   DWORD PTR [ESP+12]
        ADD   EDX, ECX

        POP   ECX
        POP   ECX

        RET   8
end;

// ------------------------------------------------------------------------------
//  64-bit signed multiply, with overflow check (98.05.15: overflow not supported yet)
// ------------------------------------------------------------------------------
//
//  Param1 ~= U   (Uh, Ul)
//  Param2 ~= V   (Vh, Vl)
//
//  Param 1(EAX:EDX), Param 2([ESP+8]:[ESP+4])  ; before reg pushing
//
//  compiler-helper function
//  O-flag set on exit   => result is invalid
//  O-flag clear on exit => result is valid
procedure __llmulo;
asm //StackAlignSafe
        PUSH   EDX
        PUSH   EAX

        // Param2 : [ESP+16]:[ESP+12]  (hi:lo)
        // Param1 : [ESP+4]:[ESP]      (hi:lo)

        MOV    EAX, [ESP+16]
        MUL    DWORD PTR [ESP]
        MOV    ECX, EAX

        MOV    EAX, [ESP+4]
        MUL    DWORD PTR [ESP+12]
        ADD    ECX, EAX

        MOV    EAX, [ESP]
        MUL    DWORD PTR [ESP+12]
        ADD    EDX, ECX

        POP    ECX
        POP    ECX

        RET    8
end;

(* ***** BEGIN LICENSE BLOCK *****
 *
 * The function __lldiv is licensed under the CodeGear license terms.
 *
 * The initial developer of the original code is Fastcode
 *
 * Portions created by the initial developer are Copyright (C) 2002-2004
 * the initial developer. All Rights Reserved.
 *
 * Contributor(s): AMD, John O'Harrow and Dennis Christensen
 *
 * ***** END LICENSE BLOCK ***** *)

// ------------------------------------------------------------------------------
//  64-bit signed division
// ------------------------------------------------------------------------------

//
//  Dividend = Numerator, Divisor = Denominator
//
//  Dividend(EAX:EDX), Divisor([ESP+8]:[ESP+4])  ; before reg pushing
//
//
procedure __lldiv; //JOH Version
asm //StackAlignSafe
{$IFDEF PC_MAPPED_EXCEPTIONS}
        PUSH    EBP
        MOV     EBP, ESP
{$ENDIF}
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
{$IFDEF PC_MAPPED_EXCEPTIONS}
        MOV     EBX, [ESP+20]
        MOV     ECX, [ESP+24]
{$ELSE !PC_MAPPED_EXCEPTIONS}
        MOV     EBX, [ESP+16]
        MOV     ECX, [ESP+20]
{$ENDIF !PC_MAPPED_EXCEPTIONS}
        MOV     ESI, EDX
        MOV     EDI, ECX
        SAR     ESI, 31
        XOR     EAX, ESI
        XOR     EDX, ESI
        SUB     EAX, ESI
        SBB     EDX, ESI          // EDX:EAX := abs(Dividend)
        SAR     EDI, 31
        XOR     ESI, EDI          // 0 if X and Y have same sign
        XOR     EBX, EDI
        XOR     ECX, EDI
        SUB     EBX, EDI
        SBB     ECX, EDI          // ECX:EBX := abs(Divisor)
        JNZ     @@BigDivisor      // divisor > 32^32-1
        CMP     EDX, EBX          // only one division needed ? (ecx = 0)
        JB      @@OneDiv          // yes, one division sufficient
        MOV     ECX, EAX          // save dividend-lo in ecx
        MOV     EAX, EDX          // get dividend-hi
        XOR     EDX, EDX          // zero extend it into edx:eax
        DIV     EBX               // quotient-hi in eax
        XCHG    EAX, ECX          // ecx = quotient-hi, eax =dividend-lo
@@OneDiv:
        DIV     EBX               // eax = quotient-lo
        MOV     EDX, ECX          // edx = quotient-hi(quotient in edx:eax)
        JMP     @SetSign
@@BigDivisor:
        SUB     ESP, 12           // Create three local variables.
        MOV     [ESP  ], EAX      // dividend_lo
        MOV     [ESP+4], EBX      // divisor_lo
        MOV     [ESP+8], EDX      // dividend_hi
        MOV     EDI, ECX          //  edi:ebx and ecx:esi
        SHR     EDX, 1            // shift both
        RCR     EAX, 1            //  divisor and
        ROR     EDI, 1            //   and dividend
        RCR     EBX, 1            //    right by 1 bit
        BSR     ECX, ECX          // ecx = number of remaining shifts
        SHRD    EBX, EDI, CL      // scale down divisor and
        SHRD    EAX, EDX, CL      //   dividend such that divisor
        SHR     EDX, CL           //    less than 2^32 (i.e. fits in ebx)
        ROL     EDI, 1            // restore original divisor (edi:esi)
        DIV     EBX               // compute quotient
        MOV     EBX, [ESP]        // dividend_lo
        MOV     ECX, EAX          // save quotient
        IMUL    EDI, EAX          // quotient * divisor hi-word (low only)
        MUL     DWORD PTR [ESP+4] // quotient * divisor low word
        ADD     EDX, EDI          // edx:eax = quotient * divisor
        SUB     EBX, EAX          // dividend-lo - (quot.*divisor)-lo
        MOV     EAX, ECX          // get quotient
        MOV     ECX, [ESP+8]      // dividend_hi
        SBB     ECX, EDX          // subtract divisor * quot. from dividend
        SBB     EAX, 0            // Adjust quotient if remainder is negative.
        XOR     EDX, EDX          // clear hi-word of quot (eax<=FFFFFFFFh)
        ADD     ESP, 12           // Remove local variables.
@SetSign:
        XOR     EAX, ESI          // If (quotient < 0),
        XOR     EDX, ESI          //   compute 1's complement of result.
        SUB     EAX, ESI          // If (quotient < 0),
        SBB     EDX, ESI          //   compute 2's complement of result.
@Done:
        POP     EDI
        POP     ESI
        POP     EBX
{$IFDEF PC_MAPPED_EXCEPTIONS}
        POP     EBP
{$ENDIF}
        RET     8
end;

// ------------------------------------------------------------------------------
//  64-bit signed division with overflow check (98.05.15: not implementated yet)
// ------------------------------------------------------------------------------

//
//  Dividend = Numerator, Divisor = Denominator
//
//  Dividend(EAX:EDX), Divisor([ESP+8]:[ESP+4])
//  Param 1 (EAX:EDX), Param 2([ESP+8]:[ESP+4])
//
//  Param1 ~= U   (Uh, Ul)
//  Param2 ~= V   (Vh, Vl)
//
//  compiler-helper function
//  O-flag set on exit   => result is invalid
//  O-flag clear on exit => result is valid
//
procedure __lldivo;
asm //StackAligned
    //Don't need to stack align only calls local __lldiv which doesn't not call anything else
  // check for overflow condition: min(int64) DIV -1
        push  esi
        mov esi, [esp+12]   // Vh
        and esi, [esp+8]    // Vl
        cmp esi, 0ffffffffh   // V = -1?
        jne @@divok

        mov esi, eax
        or  esi, edx
        cmp esi, 80000000H    // U = min(int64)?
        jne @@divok

@@divOvl:
        mov eax, esi
        pop esi
        dec eax                     // turn on O-flag
        ret 8

@@divok:
        pop esi
        push  dword ptr [esp+8]   // Vh
        push  dword ptr [esp+8]   // Vl (offset is changed from push)

        call  __lldiv
        and eax, eax    // turn off O-flag
        ret 8
end;

// ------------------------------------------------------------------------------
//  64-bit unsigned division
// ------------------------------------------------------------------------------

//  Dividend(EAX(hi):EDX(lo)), Divisor([ESP+8](hi):[ESP+4](lo))  // before reg pushing
procedure __lludiv;
asm //StackAlignSafe
        PUSH    EBP
{$IFDEF PC_MAPPED_EXCEPTIONS}
        MOV     EBP, ESP
{$ENDIF}
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
//
//       Now the stack looks something like this:
//
//               24[esp]: divisor (high dword)
//               20[esp]: divisor (low dword)
//               16[esp]: return EIP
//               12[esp]: previous EBP
//                8[esp]: previous EBX
//                4[esp]: previous ESI
//                 [esp]: previous EDI
//

//       dividend is pushed last, therefore the first in the args
//       divisor next.
//
        MOV     EBX,20[ESP]             // get the first low word
        MOV     ECX,24[ESP]             // get the first high word

        OR      ECX,ECX
        JNZ     @__lludiv@slow_ldiv     // both high words are zero

        OR      EDX,EDX
        JZ      @__lludiv@quick_ldiv

        or      ebx,ebx
        JZ      @__lludiv@quick_ldiv    // if ecx:ebx == 0 force a zero divide
          // we don't expect this to actually
          // work

@__lludiv@slow_ldiv:
        MOV     EBP,ECX
        MOV     ECX,64                  // shift counter
        XOR     EDI,EDI                 // fake a 64 bit dividend
        XOR     ESI,ESI

@__lludiv@xloop:
        SHL     EAX,1                   // shift dividend left one bit
        RCL     EDX,1
        RCL     ESI,1
        RCL     EDI,1
        CMP     EDI,EBP                 // dividend larger?
        JB      @__lludiv@nosub
        JA      @__lludiv@subtract
        CMP     ESI,EBX                 // maybe
        JB      @__lludiv@nosub

@__lludiv@subtract:
        SUB     ESI,EBX
        SBB     EDI,EBP                 // subtract the divisor
        INC     EAX                     // build quotient

@__lludiv@nosub:
        loop    @__lludiv@xloop
//
//       When done with the loop the four registers values' look like:
//
//       |     edi    |    esi     |    edx     |    eax     |
//       |        remainder        |         quotient        |
//

@__lludiv@finish:
        POP     EDI
        POP     ESI
        POP     EBX
        POP     EBP
        RET     8

@__lludiv@quick_ldiv:
        DIV     EBX                     // unsigned divide
        XOR     EDX,EDX
        JMP     @__lludiv@finish
end;

// ------------------------------------------------------------------------------
//  64-bit modulo
// ------------------------------------------------------------------------------

//  Dividend(EAX:EDX), Divisor([ESP+8]:[ESP+4])  // before reg pushing
procedure __llmod;
asm //StackAlignSafe
        PUSH    EBP
{$IFDEF PC_MAPPED_EXCEPTIONS}
        MOV     EBP, ESP
{$ENDIF}
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        XOR     EDI,EDI
//
//       dividend is pushed last, therefore the first in the args
//       divisor next.
//
        MOV     EBX,20[ESP]             // get the first low word
        MOV     ECX,24[ESP]             // get the first high word
        OR      ECX,ECX
        JNZ     @__llmod@slow_ldiv      // both high words are zero

        OR      EDX,EDX
        JZ      @__llmod@quick_ldiv

        OR      EBX,EBX
        JZ      @__llmod@quick_ldiv     // if ecx:ebx == 0 force a zero divide
          // we don't expect this to actually
          // work
@__llmod@slow_ldiv:
//
//               Signed division should be done.  Convert negative
//               values to positive and do an unsigned division.
//               Store the sign value in the next higher bit of
//               di (test mask of 4).  Thus when we are done, testing
//               that bit will determine the sign of the result.
//
        OR      EDX,EDX                 // test sign of dividend
        JNS     @__llmod@onepos
        NEG     EDX
        NEG     EAX
        SBB     EDX,0                   // negate dividend
        OR      EDI,1

@__llmod@onepos:
        OR      ECX,ECX                 // test sign of divisor
        JNS     @__llmod@positive
        NEG     ECX
        NEG     EBX
        SBB     ECX,0                   // negate divisor

@__llmod@positive:
        MOV     EBP,ECX
        MOV     ECX,64                  // shift counter
        PUSH    EDI                     // save the flags
//
//       Now the stack looks something like this:
//
//               24[esp]: divisor (high dword)
//               20[esp]: divisor (low dword)
//               16[esp]: return EIP
//               12[esp]: previous EBP
//                8[esp]: previous EBX
//                4[esp]: previous ESI
//                 [esp]: previous EDI
//
        XOR     EDI,EDI                 // fake a 64 bit dividend
        XOR     ESI,ESI

@__llmod@xloop:
        SHL     EAX,1                   // shift dividend left one bit
        RCL     EDX,1
        RCL     ESI,1
        RCL     EDI,1
        CMP     EDI,EBP                 // dividend larger?
        JB      @__llmod@nosub
        JA      @__llmod@subtract
        CMP     ESI,EBX                 // maybe
        JB      @__llmod@nosub

@__llmod@subtract:
        SUB     ESI,EBX
        SBB     EDI,EBP                 // subtract the divisor
        INC     EAX                     // build quotient

@__llmod@nosub:
        LOOP    @__llmod@xloop
//
//       When done with the loop the four registers values' look like:
//
//       |     edi    |    esi     |    edx     |    eax     |
//       |        remainder        |         quotient        |
//
        MOV     EAX,ESI
        mov     edx,edi                 // use remainder

        POP     EBX                     // get control bits
        TEST    EBX,1                   // needs negative
        JZ      @__llmod@finish
        NEG     EDX
        NEG     EAX
        SBB     EDX,0                    // negate

@__llmod@finish:
        POP     EDI
        POP     ESI
        POP     EBX
        POP     EBP
        RET     8

@__llmod@quick_ldiv:
        DIV     EBX                     // unsigned divide
        XCHG    EAX,EDX
        XOR     EDX,EDX
        JMP     @__llmod@finish
end;

// ------------------------------------------------------------------------------
//  64-bit signed modulo with overflow (98.05.15: overflow not yet supported)
// ------------------------------------------------------------------------------

//  Dividend(EAX:EDX), Divisor([ESP+8]:[ESP+4])
//  Param 1 (EAX:EDX), Param 2([ESP+8]:[ESP+4])
//
//  Param1 ~= U   (Uh, Ul)
//  Param2 ~= V   (Vh, Vl)
//
//  compiler-helper function
//  O-flag set on exit   => result is invalid
//  O-flag clear on exit => result is valid
//
procedure __llmodo;
asm //StackAlignSafe
    //Don't need to stack align only calls local __llmod which doesn't not call anything else
  // check for overflow condition: min(int64) MOD -1
        PUSH  ESI
        MOV   ESI, [ESP+12]     // Vh
        AND   ESI, [ESP+8]      // Vl
        CMP   ESI, 0FFFFFFFFH   // V = -1?
        JNE   @@modok

        MOV   ESI, EAX
        OR    ESI, EDX
        CMP   ESI, 80000000H    // U = min(int64)?
        JNE   @@modok

@@modOvl:
        MOV   EAX, ESI
        POP   ESI
        DEC   EAX               // turn on O-flag
        RET   8

@@modok:
        POP   ESI
        PUSH  DWORD PTR [ESP+8] // Vh
        PUSH  DWORD PTR [ESP+8] // Vl (offset is changed from push)

        CALL  __llmod
        AND   EAX, EAX    // turn off O-flag
        RET   8
end;

// ------------------------------------------------------------------------------
//  64-bit unsigned modulo
// ------------------------------------------------------------------------------
//  Dividend(EAX(hi):EDX(lo)), Divisor([ESP+8](hi):[ESP+4](lo))  // before reg pushing
procedure __llumod;
asm //StackAlignSafe
        PUSH    EBP
{$IFDEF PC_MAPPED_EXCEPTIONS}
        MOV     EBP, ESP
{$ENDIF}
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
//
//       Now the stack looks something like this:
//
//               24[esp]: divisor (high dword)
//               20[esp]: divisor (low dword)
//               16[esp]: return EIP
//               12[esp]: previous EBP
//                8[esp]: previous EBX
//                4[esp]: previous ESI
//                 [esp]: previous EDI
//

//       dividend is pushed last, therefore the first in the args
//       divisor next.
//
        MOV     EBX,20[ESP]             // get the first low word
        MOV     ECX,24[ESP]             // get the first high word
        OR      ECX,ECX
        JNZ     @__llumod@slow_ldiv     // both high words are zero

        OR      EDX,EDX
        JZ      @__llumod@quick_ldiv

        OR      EBX,EBX
        JZ      @__llumod@quick_ldiv    // if ecx:ebx == 0 force a zero divide
          // we don't expect this to actually
          // work
@__llumod@slow_ldiv:
        MOV     EBP,ECX
        MOV     ECX,64                  // shift counter
        XOR     EDI,EDI                 // fake a 64 bit dividend
        XOR     ESI,ESI                 //

@__llumod@xloop:
        SHL     EAX,1                   // shift dividend left one bit
        RCL     EDX,1
        RCL     ESI,1
        RCL     EDI,1
        CMP     EDI,EBP                 // dividend larger?
        JB      @__llumod@nosub
        JA      @__llumod@subtract
        CMP     ESI,EBX                 // maybe
        JB      @__llumod@nosub

@__llumod@subtract:
        SUB     ESI,EBX
        SBB     EDI,EBP                 // subtract the divisor
        INC     EAX                     // build quotient

@__llumod@nosub:
        LOOP    @__llumod@xloop
//
//       When done with the loop the four registers values' look like:
//
//       |     edi    |    esi     |    edx     |    eax     |
//       |        remainder        |         quotient        |
//
        MOV     EAX,ESI
        MOV     EDX,EDI                 // use remainder

@__llumod@finish:
        POP     EDI
        POP     ESI
        POP     EBX
        POP     EBP
        RET     8

@__llumod@quick_ldiv:
        DIV     EBX                     // unsigned divide
        XCHG    EAX,EDX
        XOR     EDX,EDX
        jmp     @__llumod@finish
end;

// ------------------------------------------------------------------------------
//  64-bit shift left
// ------------------------------------------------------------------------------

// target (EAX:EDX) count (ECX)
//
procedure __llshl;
asm //StackAlignSafe
        AND   CL, $3F
        CMP   CL, 32
        JL    @__llshl@below32
        MOV   EDX, EAX
        SHL   EDX, CL
        XOR   EAX, EAX
        RET

@__llshl@below32:
        SHLD  EDX, EAX, CL
        SHL   EAX, CL
        RET
end;

// ------------------------------------------------------------------------------
//  64-bit signed shift right
// ------------------------------------------------------------------------------
// target (EAX:EDX) count (ECX)
procedure __llshr;
asm //StackAlignSafe
        AND   CL, $3F
        CMP   CL, 32
        JL    @__llshr@below32
        MOV   EAX, EDX
        CDQ
        SAR   EAX,CL
        RET

@__llshr@below32:
        SHRD  EAX, EDX, CL
        SAR   EDX, CL
        RET
end;

// ------------------------------------------------------------------------------
//  64-bit unsigned shift right
// ------------------------------------------------------------------------------

// target (EAX:EDX) count (ECX)
procedure __llushr;
asm //StackAlignSafe
        and cl, $3F
        cmp cl, 32
        jl  @__llushr@below32
        mov eax, edx
        xor edx, edx
        shr eax, cl
        ret

@__llushr@below32:
        shrd  eax, edx, cl
        shr edx, cl
        ret
end;
{$ENDIF}

function _StrUInt64Digits(val: UInt64; width: Integer; sign: Boolean): _ShortStr;
var
  d: array[0..31] of Char;  { need 19 digits and a sign }
  i, k: Integer;
  spaces: Integer;
begin
  { Produce an ASCII representation of the number in reverse order }
  i := 0;
  repeat
    d[i] := Chr( (val mod 10) + Ord('0') );
    Inc(i);
    val := val div 10;
  until val = 0;
  if sign then
  begin
    d[i] := '-';
    Inc(i);
  end;

  { Fill the Result with the appropriate number of blanks }
  if width > 255 then
    width := 255;
  k := 1;
  spaces := width - i;
  while k <= spaces do
  begin
    Result[k] := _AnsiChr(' ');
    Inc(k);
  end;

  { Fill the Result with the number }
  while i > 0 do
  begin
    Dec(i);
    Result[k] := _AnsiChr(d[i]);
    Inc(k);
  end;

  { Result is k-1 characters long }
  SetLength(Result, k-1);
end;

function _StrInt64(val: Int64; width: Integer): _ShortStr;
begin
  Result := _StrUInt64Digits(Abs(val), width, val < 0);
end;

function _Str0Int64(val: Int64): _ShortStr;
begin
  Result := _StrInt64(val, 0);
end;

function _StrUInt64(val: UInt64; width: Integer): _ShortStr;
begin
  Result := _StrUInt64Digits(val, width, False);
end;

function _Str0UInt64(val: Int64): _ShortStr;
begin
  Result := _StrUInt64(val, 0);
end;

function _WriteInt64(var t: TTextRec; val: Int64; width: Integer): Pointer;
var
  s: _ShortStr;
begin
  s := _StrInt64(val, 0);
  Result := _WriteString(t, s, width);
end;

function _Write0Int64(var t: TTextRec; val: Int64): Pointer;
begin
  Result := _WriteInt64(t, val, 0);
end;

function _WriteUInt64(var t: TTextRec; val: UInt64; width: Integer): Pointer;
var
  s: _ShortStr;
begin
  s := _StrUInt64Digits(val, 0, False);
  Result := _WriteString(t, s, width);
end;

function _Write0UInt64(var t: TTextRec; val: UInt64): Pointer;
begin
  Result := _WriteUInt64(t, val, 0);
end;

function _ValInt64L(const s: _AnsiStr; var code: Integer): Int64;
begin
  Result := _ValInt64(string(s), code);
end;

function _ReadInt64(var t: TTextRec): Int64;
var
  p: PWord;
  count: Integer;
  c: Byte;
  eof: Boolean;
  code: Integer;
  u: UnicodeString;
begin
  if _SeekEof(t) then
    Result := 0
  else
  begin
    SetLength(U, 32);
    p := PWord(U);
    for count := 1 to 32 do
    begin
      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
      if c <= $20 then break;
      p^ := c;
      _SkipAnsiChar(t);
      Inc(p);
    end;
    SetLength(U, (PByte(p) - PByte(U)) div sizeof(word));
    Result := _ValInt64(u, code);
    if code <> 0 then
      SetInOutRes(106);
  end;
end;

                                              
function _ReadUInt64(var t: TTextRec): UInt64;
var
  p: PWord;
  count: Integer;
  c: Byte;
  eof: Boolean;
  code: Integer;
  u: UnicodeString;
begin
  if _SeekEof(t) then
    Result := 0
  else
  begin
    SetLength(U, 32);
    p := PWord(U);
    for count := 1 to 32 do
    begin
      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);
      if c <= $20 then break;
      p^ := c;
      _SkipAnsiChar(t);
      Inc(p);
    end;
    SetLength(U, (PByte(p) - PByte(U)) div sizeof(word));
    Result := _ValUInt64(u, code);
    if code <> 0 then
      SetInOutRes(106);
  end;
end;

function _ValInt64(const S: string; var Code: Integer): Int64;
const
  FirstIndex = Low(string);
var
  I: Integer;
  Dig: Integer;
  Sign: Boolean;
  Empty: Boolean;
begin
  I := FirstIndex;
  Sign := False;
  Result := 0;
  {$IF not (defined(CPUX64) and not defined(EXTERNALLINKER))}
  Dig := 0;
  {$ENDIF}
  Empty := True;

  if S = '' then
  begin
    Code := 1;
    Exit;
  end;
  while S[I] = ' ' do
    Inc(I);

  if S[I] = '-' then
  begin
    Sign := True;
    Inc(I);
  end
  else if S[I] = '+' then
    Inc(I);
  // Hex
  if ((S[I] = '0') and (I < High(S)) and ((S[I+1] = 'X') or (S[I+1] = 'x'))) or
      (S[I] = '$') or
      (S[I] = 'X') or
      (S[I] = 'x') then
  begin
    if S[I] = '0' then
      Inc(I);
    Inc(I);
    while True do
    begin
      case S[I] of
       '0'..'9': Dig := Ord(S[I]) - Ord('0');
       'A'..'F': Dig := Ord(S[I]) - Ord('A') + 10;
       'a'..'f': Dig := Ord(S[I]) - Ord('a') + 10;
      else
        Break;
      end;
      if (Result < 0) or (Result > (High(Int64) shr 3)) then
        Break;
      Result := Result shl 4 + Dig;
      Inc(I);
      Empty := False;
    end;

    if Sign then
      Result := - Result;
  end
  // Decimal
  else
  begin
    while True do
    begin
      case S[I] of
        '0'..'9': Dig := Ord(S[I]) - Ord('0');
      else
        Break;
      end;
      if (Result < 0) or (Result > (High(Int64) div 10)) then
        Break;
      Result := Result*10 + Dig;
      Inc(I);
      Empty := False;
    end;

    if Sign then
      Result := - Result;
    if (Result <> 0) and (Sign <> (Result < 0)) then
      Dec(I);
  end;

  if ((S[I] <> Char(#0)) or Empty) then
    Code := I + 1 - FirstIndex
  else
    Code := 0;
end;

                                             
function _ValUInt64(const s: string; var code: Integer): UInt64;
const
  FirstIndex = Low(string);
var
  i: Integer;
  dig: Integer;
  sign: Boolean;
  empty: Boolean;
begin
  i := FirstIndex;
  // avoid E1036: Variable 'dig' might not have been initialized
  {$IF not (defined(CPUX64) and not defined(EXTERNALLINKER))}
  dig := 0;
  {$ENDIF}
  Result := 0;
  if s = '' then
  begin
    code := 1;
    exit;
  end;
  while s[i] = Char(' ') do
    Inc(i);
  sign := False;
  if s[i] =  Char('-') then
  begin
    sign := True;
    Inc(i);
  end
  else if s[i] =  Char('+') then
    Inc(i);
  empty := True;
  if (s[i] =  Char('$')) or (Upcase(s[i]) =  Char('X'))
    or ((s[i] =  Char('0')) and (I < High(S)) and (Upcase(s[i+1]) =  Char('X'))) then
  begin
    if s[i] =  Char('0') then
      Inc(i);
    Inc(i);
    while True do
    begin
      case   Char(s[i]) of
       Char('0').. Char('9'): dig := Ord(s[i]) -  Ord('0');
       Char('A').. Char('F'): dig := Ord(s[i]) - (Ord('A') - 10);
       Char('a').. Char('f'): dig := Ord(s[i]) - (Ord('a') - 10);
      else
        break;
      end;
      if Result > (High(UInt64) shr 4) then
        Break;
      if sign and (dig <> 0) then
        Break;
      Result := Result shl 4 + dig;
      Inc(i);
      empty := False;
    end;
  end
  else
  begin
    while True do
    begin
      case  Char(s[i]) of
        Char('0').. Char('9'): dig := Ord(s[i]) - Ord('0');
      else
        break;
      end;
      if Result > (High(UInt64) div 10) then
        Break;
      if sign and (dig <> 0) then
        Break;
      Result := Result*10 + dig;
      Inc(i);
      empty := False;
    end;
  end;
  if (s[i] <> Char(#0)) or empty then
    code := i + 1 - FirstIndex
  else
    code := 0;
end;


{ ----------------------------------------------------- }
{       Compiler helper for Dynamic array support       }
{ ----------------------------------------------------- }

// A must be non-nil.
function __DynArrayLength(const A: Pointer): NativeInt; inline;
begin
  Result := PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec))^.Length;
end;

// A must be non-nil.
function __DynArrayRefCnt(const A: Pointer): Integer; inline;
begin
  Result := PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec))^.RefCnt;
end;

procedure __CopyArray(Dest, Source, TypeInfo: Pointer; Count: NativeInt); inline;
begin
{$IFDEF PUREPASCAL}
  _CopyArray(Dest, Source, TypeInfo, Count);
{$ELSE}
  CopyArray(Dest, Source, TypeInfo, Count);
{$ENDIF}
end;

function _DynArrayLength(const A: Pointer): NativeInt;
begin
  Result := NativeInt(A);
  if Result <> 0 then                                         // TDynArrayRec should be used here but a
    Result := PNativeInt(PByte(Result) - SizeOf(NativeInt))^; // private symbol cannot be inlined
end;

function _DynArrayHigh(const A: Pointer): NativeInt;
begin
  Result := _DynArrayLength(A) - 1;
end;

procedure DynArrayClear(var A: Pointer; TypeInfo: Pointer);
begin
  _DynArrayClear(a, typeInfo);
end;

procedure DynArraySetLength(var a: Pointer; typeInfo: Pointer; dimCnt: NativeInt; lengthVec: PNativeint);
var
  i,j: NativeInt;
  newLength, oldLength, minLength: NativeInt;
  elSize: NativeInt;
  ElTypeInfo: Pointer;
  neededSize: NativeInt;
  p, pp: Pointer;
begin
  p := a;

  // Fetch the new length of the array in this dimension, and the old length
  newLength := lengthVec^;
  if newLength <= 0 then
  begin
    if newLength < 0 then
      Error(reRangeError);
    _DynArrayClear(a, typeInfo);
    exit;
  end;

  oldLength := 0;
  if p <> nil then
  begin
    Dec(PByte(p), SizeOf(TDynArrayRec));
    oldLength := PDynArrayRec(p).Length;
  end;

  // Calculate the needed size of the heap object
  Inc(PByte(typeInfo), PDynArrayTypeInfo(typeInfo).name);
  elSize := PDynArrayTypeInfo(typeInfo).elSize;
  if PDynArrayTypeInfo(typeInfo).elType <> nil then
    ElTypeInfo := PDynArrayTypeInfo(typeInfo).elType^
  else
    ElTypeInfo := nil;
  neededSize := newLength*elSize;
  if neededSize div newLength <> elSize then
    Error(reRangeError);
  Inc(neededSize, SizeOf(TDynArrayRec));
  if neededSize < 0 then
    Error(reRangeError);

  // If the heap object isn't shared (ref count = 1), just resize it. Otherwise, we make a copy
  if (p = nil) or (PDynArrayRec(p).RefCnt = 1) then
  begin
    pp := p;
{$IF not Defined(WEAKREF)}
    if (newLength < oldLength) and (ElTypeInfo <> nil) then
      FinalizeArray(PByte(p) + SizeOf(TDynArrayRec) + newLength*elSize, ElTypeInfo, oldLength - newLength);
    ReallocMem(pp, neededSize);
{$ELSE}
    if (ElTypeInfo <> nil) then
    begin
      if PTypeInfo(ElTypeInfo).Kind in [
    {$IFDEF WEAKINSTREF}
          tkClass, tkMethod,
    {$ENDIF WEAKINSTREF}
    {$IFDEF WEAKINTFREF}
          tkInterface,
    {$ENDIF WEAKINTFREF}
          tkArray, tkRecord, tkDynArray] then
      begin
        if newLength < oldLength then
          minLength := newLength
        else
          minLength := oldLength;
        GetMem(pp, neededSize);
        FillChar((PByte(pp) + SizeOf(TDynArrayRec))^, minLength * elSize, 0);
        if p <> nil then
        begin
          MoveArray(PByte(pp) + SizeOf(TDynArrayRec),
                     PByte(p) + SizeOf(TDynArrayRec), ElTypeInfo, minLength);
          if newLength < oldLength then
            FinalizeArray(PByte(p) + SizeOf(TDynArrayRec) + newLength*elSize, ElTypeInfo, oldLength - newLength);
          FreeMem(p);
        end;
      end
      else
      begin
        if (newLength < oldLength) then
          FinalizeArray(PByte(p) + SizeOf(TDynArrayRec) + newLength*elSize, ElTypeInfo, oldLength - newLength);
        ReallocMem(pp, neededSize);
      end;
    end
    else
      ReallocMem(pp, neededSize);
{$ENDIF}
    p := pp;
  end
  else
  begin
    GetMem(p, neededSize);
    minLength := oldLength;
    if minLength > newLength then
      minLength := newLength;
    if ElTypeInfo <> nil then
    begin
      FillChar((PByte(p) + SizeOf(TDynArrayRec))^, minLength*elSize, 0);
      __CopyArray(PByte(p) + SizeOf(TDynArrayRec), a, ElTypeInfo, minLength)
    end
    else
      Move(PByte(a)^, (PByte(p) + SizeOf(TDynArrayRec))^, minLength*elSize);
    _DynArrayClear(a, typeInfo);
  end;

  // The heap object will now have a ref count of 1 and the new length
  PDynArrayRec(p).RefCnt := 1;
  PDynArrayRec(p).Length := newLength;
  Inc(PByte(p), SizeOf(TDynArrayRec));

  // Set the new memory to all zero bits
  if newLength > oldLength then
    FillChar((PByte(p) + elSize * oldLength)^, elSize * (newLength - oldLength), 0);

  // Take care of the inner dimensions, if any
  if dimCnt > 1 then
  begin
    Inc(lengthVec);
    Dec(dimCnt);
    i := 0;
    try
      while i < newLength do
        begin
          DynArraySetLength(PPointerArray(p)[i], ElTypeInfo, dimCnt, lengthVec);
          Inc(i);
        end;
    except
      // Free arrays on exception
      for j := 0 to i  do
        _DynArrayClear(PPointerArray(p)[j], typeInfo);
      _DynArrayClear(p, ElTypeInfo);
      raise;
    end;
  end;
  a := p;
end;

{$IF not defined(X86ASMRTL)}
procedure _DynArraySetLength(var A: Pointer; TypeInfo: Pointer; DimCnt: NativeInt); cdecl; varargs;
type
  {$IFDEF CPU64BITS}
  NativeIntArray = array [0..256*1024*1024 - 2] of NativeInt;
  {$ELSE !CPU64BITS}
  NativeIntArray = array [0..512*1024*1024 - 2] of NativeInt;
  {$ENDIF !CPU64BITS}
  PNativeIntArray = ^NativeIntArray;
var
  VAList: TVarArgList;
  {$IFDEF RECORD_TVARARGLIST}
  Buf: PNativeIntArray;
  ArgIndex: Integer;
  {$ENDIF}
begin
  VarArgStart(VAList);
  {$IFDEF RECORD_TVARARGLIST}
  GetMem(Buf, DimCnt * SizeOf(NativeInt));
  for ArgIndex := 0 to DimCnt - 1 do
    Buf[ArgIndex] := VarArgGetValue(VAList, NativeInt);
  DynArraySetLength(A, TypeInfo, DimCnt, PNativeInt(Buf));
  FreeMem(Buf);
  {$ELSE}
  DynArraySetLength(A, TypeInfo, DimCnt, PNativeInt(VAList));
  {$ENDIF}
  VarArgEnd(VAList);
end;
{$ELSE X86ASMRTL}
procedure _DynArraySetLength;
asm
{       PROCEDURE _DynArraySetLength(var a: dynarray; typeInfo: PDynArrayTypeInfo; dimCnt: NaativeInt; lengthVec: ^NaativeInt) }
{     ->EAX     Pointer to dynamic array (= pointer to pointer to heap object) }
{       EDX     Pointer to type info for the dynamic array                     }
{       ECX     number of dimensions                                           }
{       [ESP+4] dimensions                                                     }
{$IFDEF ALIGN_STACK}
        PUSH    EBP        // Setup stack frame in case of exception
        MOV     EBP, ESP   // to prevent unwinder from freaking out
        SUB     ESP, 4
        PUSH    ESP
        ADD     dword ptr [ESP],12
{$ELSE !ALIGN_STACK}
        PUSH    ESP
        ADD     dword ptr [ESP],4
{$ENDIF !ALIGN_STACK}
        CALL    DynArraySetLength
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
        POP     EBP
{$ENDIF ALIGN_STACK}
end;
{$ENDIF X86ASMRTL}

{$IF defined(X86ASMRTL)}
procedure _DynArrayCopy(A: Pointer; TypeInfo: Pointer; var Result: Pointer);
begin
  if A <> nil then
    _DynArrayCopyRange(A, TypeInfo, 0, PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec)).Length, Result)
  else
    _DynArrayClear(Result, TypeInfo);
end;
{$ELSE !X86ASMRTL}
procedure _DynArrayCopy(var Result: Pointer; A: Pointer; TypeInfo: Pointer);
begin
  if A <> nil then
    _DynArrayCopyRange(Result, A, TypeInfo, 0, PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec)).Length)
  else
    _DynArrayClear(Result, TypeInfo);
end;
{$ENDIF !X86ASMRTL}

{$IF defined(X86ASMRTL)}
procedure _DynArrayCopyRange(A: Pointer; TypeInfo: Pointer; Index, Count : Integer; var Result: Pointer);
{$ELSE}
procedure _DynArrayCopyRange(var Result: Pointer; A: Pointer; TypeInfo: Pointer; Index, Count: NativeInt);
{$ENDIF}
var
  arrayLength: NativeInt;
  elSize: Integer;
  typeInf: PDynArrayTypeInfo;
  p: Pointer;
begin
  p := nil;
  if A <> nil then
  begin
    typeInf := TypeInfo;

    // Limit index and count to values within the array
    if Index < 0 then
    begin
      Inc(Count, Index);
      Index := 0;
    end;
    arrayLength := PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec)).Length;
    if Index > arrayLength then
      Index := arrayLength;
    if Count > arrayLength - Index then
      Count := arrayLength - Index;
    if Count < 0 then
      Count := 0;

    if Count > 0 then
    begin
      // Figure out the size and type descriptor of the element type
      Inc(PByte(typeInf), typeInf.name);
      elSize := typeInf.elSize;
      if typeInf.elType <> nil then
        typeInf := typeInf.elType^
      else
        typeInf := nil;

      // Allocate the amount of memory needed
      GetMem(p, Count * elSize + SizeOf(TDynArrayRec));

      // The reference count of the new array is 1, the length is count
      PDynArrayRec(p).RefCnt := 1;
      PDynArrayRec(p).Length := Count;
      Inc(PByte(p), SizeOf(TDynArrayRec));
      Inc(PByte(A), Index * elSize);

      // If the element type needs destruction, we must copy each element,
      // otherwise we can just copy the bits
      if Count > 0 then
      begin
        if typeInf <> nil then
        begin
          FillChar(p^, Count * elSize, 0);
          __CopyArray(p, A, typeInf, Count)
        end
        else
          Move(A^, p^, Count * elSize);
      end;
    end;
  end;
  DynArrayClear(Result, TypeInfo);
  Result := p;
end;

{$IF not defined(X86ASMRTL)}
function _DynArrayClear(var A: Pointer; TypeInfo: Pointer): Pointer;
{$ELSE}
procedure _DynArrayClear(var A: Pointer; TypeInfo: Pointer);
{$ENDIF}
{$IFDEF PUREPASCAL}
var
  P: Pointer;
  Len: NativeInt;
begin
  // Nothing to do if Pointer to heap object is nil
  P := A;
  if P <> nil then
  begin
    // Set the variable to be finalized to nil
    A := nil;
    // Decrement ref count. Nothing to do if not zero now.
    if __DynArrayRefCnt(P) > 0 then
    begin
      if AtomicDecrement(PDynArrayRec(PByte(P) - SizeOf(TDynArrayRec))^.RefCnt) = 0 then
      begin
        // Fetch the type descriptor of the elements
        Inc(PByte(TypeInfo), PDynArrayTypeInfo(TypeInfo)^.name);
        if PDynArrayTypeInfo(TypeInfo)^.elType <> nil then
        begin
          Len := PDynArrayRec(PByte(P) - SizeOf(TDynArrayRec))^.Length;
          if Len <> 0 then
          begin
            TypeInfo := PDynArrayTypeInfo(TypeInfo)^.elType^;
            _FinalizeArray(P, TypeInfo, Len);
          end;
        end;
        // Now deallocate the array
        Dec(PByte(P), SizeOf(TDynArrayRec));
        _FreeMem(P);
      end;
    end;
  end;
  Result := @A;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm //StackAlignSafe
{     ->EAX     Pointer to dynamic array (Pointer to pointer to heap object)}
{       EDX     Pointer to type info                                        }

        {       Nothing to do if Pointer to heap object is nil }
        MOV     ECX,[EAX]
        TEST    ECX,ECX
        JE      @@exit

        {       Set the variable to be finalized to nil }
        MOV     dword ptr [EAX],0

        {       If < 0: Literal data. Not in the heap }
        CMP     dword ptr [ECX-8],0
        JLE     @@exit

        {       Decrement ref count. Nothing to do if not zero now. }
   LOCK DEC     dword ptr [ECX-8]
        JNE     @@exit

        {       Save the source - we're supposed to return it }
        PUSH    EAX
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        MOV     EAX,ECX

        {       Fetch the type descriptor of the elements }
        XOR     ECX,ECX
        MOV     CL,[EDX].TDynArrayTypeInfo.name;
        MOV     EDX,[EDX+ECX].TDynArrayTypeInfo.elType;

        {       If it's non-nil, finalize the elements }
        TEST    EDX,EDX
        JE      @@noFinalize
        MOV     ECX,[EAX-4]
        TEST    ECX,ECX
        JE      @@noFinalize
        MOV     EDX,[EDX]
        {       Save/restore the array around the call to _FinalizeArray }
{$IFDEF ALIGN_STACK}
        MOV     [ESP], EAX
{$ELSE !ALIGN_STACK}
        PUSH    EAX
{$ENDIF !ALIGN_STACK}
        CALL    _FinalizeArray
{$IFDEF ALIGN_STACK}
        MOV     EAX, [ESP]
{$ELSE !ALIGN_STACK}
        POP     EAX
{$ENDIF !ALIGN_STACK}
@@noFinalize:
        {       Now deallocate the array }
        SUB     EAX,8
        CALL    _FreeMem
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
        POP     EAX
@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _DynArrayAsg(var Dest: Pointer; Src: Pointer; TypeInfo: Pointer);
{$IFDEF PUREPASCAL}
begin
  if Src <> nil then
  begin
    if __DynArrayRefCnt(Src) < 0 then
    begin
{$IF defined(X86ASMRTL)}
      _DynArrayCopy(Src, TypeInfo, Dest);
{$ELSE}
      _DynArrayCopy(Dest, Src, TypeInfo);
{$ENDIF}
      Exit;
    end;
  end;
  _DynArrayAddRef(Src);
  _DynArrayClear(Dest, TypeInfo);
  Dest := Src;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
{     ->EAX     Pointer to destination (pointer to pointer to heap object) }
{       EDX     source (pointer to heap object) }
{       ECX     Pointer to rtti describing dynamic array }

        {       Increment ref count of source if non-nil and non-negative }
        TEST    EDX,EDX
        JE      @@skipInc
        CMP     dword ptr [EDX-8],0
        JL      @@copyConst
   LOCK INC     dword ptr [EDX-8]
@@skipInc:
        PUSH    EBX
        MOV     EBX,[EAX]
        {       Dec ref count of destination - if it becomes 0, clear dest }
        TEST    EBX,EBX
        JE      @@skipClear
        CMP     dword ptr [EBX-8],0
        JLE     @@skipClear
   LOCK DEC     dword ptr [EBX-8]
        JNZ     @@skipClear
        PUSH    EAX
        PUSH    EDX
        MOV     EDX,ECX
        INC     dword ptr [EBX-8]
        {       Stack is aligned at this point }
        CALL    _DynArrayClear
        POP     EDX
        POP     EAX
@@skipClear:
        {       Finally store source into destination }
        MOV     [EAX],EDX
        POP     EBX
        RET
@@copyConst:
        XCHG    EAX,ECX         { EAX := TypeInfo; EDX := Src; ECX := Dest }
        XCHG    EAX,EDX         { EAX := Src; EDX := TypeInfo; ECX := Dest }
        JMP     _DynArrayCopy
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _DynArrayAddRef(P: Pointer);
{$IFDEF PUREPASCAL}
begin
  if P <> nil then
    if __DynArrayRefCnt(P) >= 0 then
      AtomicIncrement(PDynArrayRec(PByte(P) - SizeOf(TDynArrayRec))^.RefCnt);
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
{     ->EAX     Pointer to heap object }
        TEST    EAX,EAX
        JE      @@exit
        {       If < 0: Literal data. Not in the heap }
        CMP     dword ptr [EAX-8],0
        JL      @@exit
   LOCK INC     dword ptr [EAX-8]
@@exit:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure DynArrayCopy(var Result: Pointer; a: Pointer; typeInfo: Pointer);
begin
{$IF defined(X86ASMRTL)}
  _DynArrayCopy(a, typeInfo, Result);
{$ELSE}
  _DynArrayCopy(Result, a, typeInfo);
{$ENDIF}
end;

procedure DynArrayCopyRange(var Result: Pointer; A: Pointer; TypeInfo: Pointer; Index, Count: NativeInt);
begin
{$IF defined(X86ASMRTL)}
  _DynArrayCopyRange(A, TypeInfo, Index, Count, Result);
{$ELSE}
  _DynArrayCopyRange(Result, A, TypeInfo, Index, Count);
{$ENDIF}
end;

procedure DynArrayUnique(var A: Pointer; typeInfo: Pointer);
begin
  if (A <> nil) and (PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec))^.RefCnt > 1) then
    DynArrayCopy(A, A, typeInfo);
end;

function _DynArrayRelease(P: Pointer): Integer;
begin
  Result := __DynArrayRefCnt(P);
  if Result > 0 then
    Result := AtomicDecrement(PDynArrayRec(PByte(P) - SizeOf(TDynArrayRec))^.RefCnt);
end;

procedure _DynArrayCat(var Dest: Pointer; Source: Pointer; typeInfo: Pointer);
var
  L1, L2, Len: NativeInt;
  ElSize, NeededSize: NativeInt;
  ElTypeInfo: Pointer;
  Dims: array[0..0] of NativeInt;
  Temp: Pointer;
begin
  if Source <> nil then
  begin
    if Dest = nil then
      _DynArrayAsg(Dest, Source, typeInfo)
    else
    begin
      L1 := __DynArrayLength(Dest);
      L2 := __DynArrayLength(Source);
      Len := L1 + L2;

      ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo).name;
      ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;
      if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then
        ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^
      else
        ElTypeInfo := nil;

      // Calculate the needed size of the heap object
      NeededSize := Len * ElSize;
      if NeededSize div Len <> ElSize then
        _IntOver;
      Inc(NeededSize, SizeOf(TDynArrayRec));
      if NeededSize < 0 then
        _IntOver;

      Temp := Dest;
      Dims[0] := Len;
      DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);
      if Temp = Source then
        Source := Dest;
      if ElTypeInfo <> nil then
        __CopyArray(@PByte(Dest)[L1 * ElSize], Source, ElTypeInfo, L2)
      else
        Move(Source^, PByte(Dest)[L1 * ElSize], L2 * ElSize);
    end;
  end;
end;

procedure _DynArrayCat3(var Dest: Pointer; Source1, Source2: Pointer; typeInfo: Pointer);
var
  L1, L2, Len: NativeInt;
  ElSize, NeededSize: NativeInt;
  ElTypeInfo: Pointer;
  Dims: array[0..0] of NativeInt;
  Temp: Pointer;
begin
  if Source1 = nil then
    _DynArrayAsg(Dest, Source2, typeInfo)
  else if Source2 = nil then
    _DynArrayAsg(Dest, Source1, typeInfo)
  else
  begin
    if Dest = Source1 then
      _DynArrayCat(Dest, Source2, typeInfo)
    else if Dest = Source2 then
    begin
      L1 := __DynArrayLength(Source1);
      L2 := __DynArrayLength(Source2);
      Len := L1 + L2;

      ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo).name;
      ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;
      if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then
        ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^
      else
        ElTypeInfo := nil;

      // Calculate the needed size of the heap object
      NeededSize := Len * ElSize;
      if NeededSize div Len <> ElSize then
        _IntOver;
      Inc(NeededSize, SizeOf(TDynArrayRec));
      if NeededSize < 0 then
        _IntOver;

      Temp := nil;
      Dims[0] := Len;
      DynArraySetLength(Temp, typeInfo, 1, @Dims[0]);
      if ElTypeInfo <> nil then
      begin
        __CopyArray(@PByte(Temp)[0          ], Source1, ElTypeInfo, L1);
        __CopyArray(@PByte(Temp)[L1 * ElSize], Source2, ElTypeInfo, L2);
      end
      else
      begin
        Move(Source1^, PByte(Temp)[0          ], L1 * ElSize);
        Move(Source2^, PByte(Temp)[L1 * ElSize], L2 * ElSize);
      end;
      _DynArrayClear(Dest, typeInfo);
      Dest := Temp;
    end
    else
    begin
      _DynArrayAsg(Dest, Source1, typeInfo);
      _DynArrayCat(Dest, Source2, typeInfo);
    end;
  end;
end;

procedure _DynArrayCatN(var Dest: Pointer; ArgCnt: Integer; typeInfo: Pointer; Arrays: PPointer);
var
  I, Start: NativeInt;
  Len, L, SrcLen: NativeInt;
  P: Pointer;
  NewDest: Pointer;
  Appending: Boolean;
  Dims: array[0..0] of NativeInt;
  ElTypeInfo: Pointer;
  ElSize: NativeInt;
begin
  Appending := False;
  Len := 0;
  for I := 0 to ArgCnt - 1 do
  begin
    P := PPointerArray(Arrays)[I];
    if P <> nil then
    begin
      if P = Dest then
        Appending := (I = 0);
      Inc(Len, __DynarrayLength(P));
      if Len < 0 then _IntOver;
    end;
  end;

  ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo).name;
  ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;
  if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then
    ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^
  else
    ElTypeInfo := nil;

  if Appending then
  begin
    // Dest is non-nil
    L := __DynArrayLength(Dest);
    Dims[0] := Len;
    DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);
    NewDest := Pointer(Dest);
    Start := 1;
  end
  else
  begin
    NewDest := nil;
    Dims[0] := Len;
    DynArraySetLength(NewDest, typeInfo, 1, @Dims[0]);
    Start := 0;
    L := 0;
  end;
  for I := Start to ArgCnt - 1 do
  begin
    P := PPointerArray(Arrays)[I];
    if P <> nil then
    begin
      SrcLen := __DynArrayLength(P);
      if ElTypeInfo <> nil then
        __CopyArray(@PByte(NewDest)[L * ElSize], P, ElTypeInfo, SrcLen)
      else
        Move(P^, PByte(NewDest)[L * ElSize], SrcLen * ElSize);
      Inc(L, SrcLen);
    end;
  end;
  if not Appending then
  begin
    if Dest <> nil then
      _DynArrayClear(Dest, typeInfo);
    Dest := NewDest;
  end;
end;

procedure _DynArrayDelete(var Dest: Pointer; Index, Count: NativeInt; typeInfo: Pointer);
var
  L, N, I: NativeInt;
  Dims: array[0..0] of NativeInt;
  ElTypeInfo: Pointer;
  ElSize: NativeInt;
  S, D: Pointer;
begin
  if Dest <> nil then
  begin
    L := __DynArrayLength(Dest);
    if (Index >= 0) and (Index < L) and (Count > 0) then
    begin
      N := L - Index - Count;
      if N < 0 then
        N := 0;

      ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo).name;
      ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;
      if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then
        ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^
      else
        ElTypeInfo := nil;

      D := @PByte(Dest)[Index * ElSize];
      S := @PByte(Dest)[(L - N) * ElSize];
      if ElTypeInfo <> nil then
      begin
        for I := 1 to N do
        begin
          __CopyArray(D, S, ElTypeInfo, 1);
          Inc(PByte(D), ElSize);
          Inc(PByte(S), ElSize);
        end;
      end
      else
        Move(S^, D^, N * ElSize);
      Dims[0] := Index + N;
      DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);
    end;
  end;
end;

procedure _DynArrayInsert(Source: Pointer; var Dest: Pointer; Index: NativeInt; typeInfo: Pointer);
var
  SourceLen, DestLen, NewLen, I: NativeInt;
  SelfInsert: Boolean;
  Dims: array[0..0] of NativeInt;
  ElTypeInfo: Pointer;
  ElSize: NativeInt;
  S, D: Pointer;
begin
  if Source <> nil then
  begin
    SourceLen := __DynArrayLength(Source);
    if SourceLen > 0 then
    begin
      if Dest = nil then
        DestLen := 0
      else
        DestLen := __DynArrayLength(Dest);
      if Index < 0 then
        Index := 0
      else
      begin
        if Index > DestLen then
          Index := DestLen;
      end;
      SelfInsert := (Source = Dest);

      ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo).name;
      ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;
      if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then
        ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^
      else
        ElTypeInfo := nil;

      NewLen := DestLen + SourceLen;
      if NewLen < 0 then   // overflow check
        _IntOver;
      Dims[0] := NewLen;
      DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);
      if Index < DestLen then
      begin
        if ElTypeInfo <> nil then
        begin
          S := @PByte(Dest)[DestLen * ElSize];
          D := @PByte(Dest)[(DestLen + SourceLen) * ElSize];
          for I := Index to DestLen - 1 do
          begin
            Dec(PByte(D), ElSize);
            Dec(PByte(S), ElSize);
            __CopyArray(D, S, ElTypeInfo, 1);
          end;
        end
        else
          Move(PByte(Dest)[Index * ElSize], PByte(Dest)[(Index + SourceLen) * ElSize],
            (DestLen - Index) * ElSize);
      end;
      if ElTypeInfo <> nil then
      begin
        if SelfInsert then
        begin
          S := @PByte(Dest)[SourceLen * ElSize];
          D := @PByte(Dest)[(Index + SourceLen) * ElSize];
          for I := 1 to SourceLen do
          begin
            Dec(PByte(D), ElSize);
            Dec(PByte(S), ElSize);
            __CopyArray(D, S, ElTypeInfo, 1);
          end;
        end
        else
          __CopyArray(@PByte(Dest)[Index * ElSize], Source, ElTypeInfo, SourceLen);
      end
      else
      begin
        if SelfInsert then
          Source := Dest;
        Move(Source^, PByte(Dest)[Index * ElSize], SourceLen * ElSize);
      end;
    end;
  end;
end;

procedure _DynArrayInsertElem(const Source; var Dest: Pointer; Index: NativeInt; typeInfo: Pointer);
type
  PUInt32 = ^UInt32;
const
  SourceLen = 1;
var
  DestLen, NewLen, I: NativeInt;
  Dims: array[0..0] of NativeInt;
  ElTypeInfo: Pointer;
  ElSize: NativeInt;
  S, D: Pointer;
begin
  if Dest = nil then
    DestLen := 0
  else
    DestLen := __DynArrayLength(Dest);
  if Index < 0 then
    Index := 0
  else
  begin
    if Index > DestLen then
      Index := DestLen;
  end;

  ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo).name;
  ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;
  if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then
    ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^
  else
    ElTypeInfo := nil;

  NewLen := DestLen + SourceLen;
  if NewLen < 0 then   // overflow check
    _IntOver;
  Dims[0] := NewLen;
  DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);
  if Index < DestLen then
  begin
    if ElTypeInfo <> nil then
    begin
      S := @PByte(Dest)[DestLen * ElSize];
      D := @PByte(Dest)[(DestLen + SourceLen) * ElSize];
      for I := Index to DestLen - 1 do
      begin
        Dec(PByte(D), ElSize);
        Dec(PByte(S), ElSize);
        __CopyArray(D, S, ElTypeInfo, 1);
      end;
    end
    else
      Move(PByte(Dest)[Index * ElSize], PByte(Dest)[(Index + SourceLen) * ElSize],
        (DestLen - Index) * ElSize);
  end;
  if ElTypeInfo <> nil then
    __CopyArray(@PByte(Dest)[Index * ElSize], @Source, ElTypeInfo, SourceLen)
  else if ElSize = 8 then
    PUInt64(@PByte(Dest)[Index * 8])^ := PUInt64(@Source)^
  else if ElSize = 4 then
    PUInt32(@PByte(Dest)[Index * 4])^ := PUInt32(@Source)^
  else if ElSize = 2 then
    PWord(@PByte(Dest)[Index * 2])^ := PWord(@Source)^
  else if ElSize = 1 then
    PByte(Dest)[Index] := PByte(@Source)^
  else
    Move(Source, PByte(Dest)[Index * ElSize], ElSize);
end;

function DynArrayIndex(P: Pointer; const Indices: array of NativeInt; TypInfo: Pointer): Pointer; overload;
var
  I, L, H: Integer;
begin
  L := Low(Indices);
  H := High(Indices);

  if H >= L then
  begin
    { Start at the beggining of the array }
    for I := L to H do
    begin
      { Skip to the relevant part }
      Inc(PByte(TypInfo), PDynArrayTypeInfo(TypInfo)^.name);

      { Jump into the array at the given position using the indices and element size }
      Inc(PByte(P), Indices[I] * PDynArrayTypeInfo(TypInfo)^.elSize);

      { Go one step deeper into the child arrays only if it's not the last dimension }
      if I < H then
      begin
        if PDynArrayTypeInfo(TypInfo)^.elType <> nil then
          TypInfo := PDynArrayTypeInfo(TypInfo)^.elType^;
        if P = nil then
          Exit(nil);
        P := PPointer(P)^;
      end;
    end;
  end;

  { Result is the input pointer modified }
  Result := P;
end;

function DynArrayIndex(P: Pointer; const Indices: array of Integer; TypInfo: Pointer): Pointer; overload;
{$IFDEF PUREPASCAL}
var
  I, L, H: Integer;
begin
  L := Low(Indices);
  H := High(Indices);

  if H >= L then
  begin
    { Start at the beggining of the array }
    for I := L to H do
    begin
      { Skip to the relevant part }
      Inc(PByte(TypInfo), PDynArrayTypeInfo(TypInfo)^.name);

      { Jump into the array at the given position using the indices and element size }
      Inc(PByte(P), Indices[I] * PDynArrayTypeInfo(TypInfo)^.elSize);

      { Go one step deeper into the child arrays only if it's not the last dimension }
      if I < H then
      begin
        if PDynArrayTypeInfo(TypInfo)^.elType <> nil then
          TypInfo := PDynArrayTypeInfo(TypInfo)^.elType^;
        if P = nil then
          Exit(nil);
        P := PPointer(P)^;
      end;
    end;
  end;

  { Result is the input pointer modified }
  Result := P;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        {     ->EAX     P                       }
        {       EDX     Pointer to Indices      }
        {       ECX     High bound of Indices   }
        {       [EBP+8] TypInfo                 }
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        PUSH    EBP

        MOV     ESI,EDX
        MOV     EDI,[EBP+8]
        MOV     EBP,EAX

        XOR     EBX,EBX                 {  for i := 0 to High(Indices) do       }
        TEST    ECX,ECX
        JGE     @@start
@@loop:
        TEST    EBP, EBP
        JE      @@loopEnd
        MOV     EBP,[EBP]
@@start:
        XOR     EAX,EAX
        MOV     AL,[EDI].TDynArrayTypeInfo.name
        ADD     EDI,EAX
        MOV     EAX,[ESI+EBX*4]         {    P := P + Indices[i]*TypInfo.elSize }
        MUL     [EDI].TDynArrayTypeInfo.elSize
        MOV     EDI,[EDI].TDynArrayTypeInfo.elType
        TEST    EDI,EDI
        JE      @@skip
        MOV     EDI,[EDI]
@@skip:
        ADD     EBP,EAX
        INC     EBX
        CMP     EBX,ECX
        JLE     @@loop

@@loopEnd:

        MOV     EAX,EBP

        POP     EBP
        POP     EDI
        POP     ESI
        POP     EBX
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}


{ Returns the DynArrayTypeInfo of the Element Type of the specified DynArrayTypeInfo }
function DynArrayElTypeInfo(typeInfo: PDynArrayTypeInfo): PDynArrayTypeInfo;
begin
  Result := nil;
  if typeInfo <> nil then
  begin
    Inc(PByte(typeInfo), typeInfo.name);
    if typeInfo.elType <> nil then
      Result := typeInfo.elType^;
  end;
end;

{ Returns # of dimemsions of the DynArray described by the specified DynArrayTypeInfo}
function DynArrayDim(typeInfo: Pointer): Integer;
begin
  Result := 0;
  while (typeInfo <> nil) and (PDynArrayTypeInfo(typeInfo)^.kind = tkDynArray) do
  begin
    Inc(Result);
    typeInfo := DynArrayElTypeInfo(typeInfo);
  end;
end;

{ Returns size of the Dynamic Array}
function DynArraySize(A: Pointer): NativeInt;
begin
  Result := NativeInt(A);
  if Result <> 0 then                                         // TDynArrayRec should be used here but a
    Result := PNativeInt(PByte(Result) - SizeOf(NativeInt))^; // private symbol cannot be inlined
end;

procedure DynArrayAssign(var Dest: Pointer; Source: Pointer; typeInfo: Pointer);
begin
  _DynArrayAsg(Dest, Source, typeInfo);
end;

// Returns whether array is rectangular
function IsDynArrayRectangular(const DynArray: Pointer; typeInfo: Pointer): Boolean;
var
  Dim, I, J, Size, SubSize: Integer;
  P: Pointer;
begin
  // Assume we have a rectangular array
  Result := True;

  P := DynArray;
  Dim := DynArrayDim(typeInfo);

  {NOTE: Start at 1. Don't need to test the first dimension - it's rectangular by definition}
  for I := 1 to dim-1 do
  begin
    if P <> nil then
    begin
      { Get size of this dimension }
      Size := DynArraySize(P);

      { Get Size of first sub. dimension }
      SubSize := DynArraySize(PPointerArray(P)[0]);

      { Walk through every dimension making sure they all have the same size}
      for J := 1  to Size-1 do
        if DynArraySize(PPointerArray(P)[J]) <> SubSize then
        begin
          Result := False;
          Exit;
        end;

      { Point to next dimension}
      P := PPointerArray(P)[0];
    end;
  end;
end;

// Returns Bounds of Dynamic array as an array of integer containing the 'high' of each dimension
function DynArrayBounds(const DynArray: Pointer; typeInfo: Pointer): TBoundArray;
var
  Dim, I: Integer;
  P: Pointer;
begin
  P := DynArray;

  Dim := DynArrayDim(typeInfo);
  SetLength(Result, Dim);

  for I := 0 to dim-1 do
    if P <> nil then
    begin
      Result[I] := DynArraySize(P)-1;
      P := PPointerArray(P)[0]; // Assume rectangular arrays
    end;
end;

{ Decrements to next lower index - Returns True if successful }
{ Indices: Indices to be decremented }
{ Bounds : High bounds of each dimension }
function DecIndices(var Indices: TBoundArray; const Bounds: TBoundArray): Boolean;
var
  I, J: Integer;
begin
  { Find out if we're done: all at zeroes }
  Result := False;
  for I := Low(Indices)  to High(Indices) do
    if Indices[I] <> 0  then
    begin
      Result := True;
      break;
    end;
  if not Result then
    Exit;

  { Two arrays must be of same length }
  Assert(Length(Indices) = Length(Bounds));

  { Find index of item to tweak }
  for I := High(Indices) downto Low(Bounds) do
  begin
    // If not reach zero, dec and bail out
    if Indices[I] <> 0 then
    begin
      Dec(Indices[I]);
      Exit;
    end
    else
    begin
      J := I;
      while Indices[J] = 0 do
      begin
        // Restore high bound when we've reached zero on a particular dimension
        Indices[J] := Bounds[J];
        // Move to higher dimension
        Dec(J);
        Assert(J >= 0);
      end;
      Dec(Indices[J]);
      Exit;
    end;
  end;
end;

{ Package/Module registration/unregistration }

{$IFDEF MSWINDOWS}
const
  LCID_SUPPORTED          = $00000002;  { supported locale ids }
  LOCALE_SABBREVLANGNAME  = $00000003;  { abbreviated language name }
  LOCALE_SISO639LANGNAME  = $00000059;  { ISO abbreviated language name }
  LOCALE_SISO3166CTRYNAME = $0000005A;  { ISO abbreviated country name }
  LOCALE_SNAME            = $0000005c;  { locale name (ie: en-us) }
  LOCALE_SPARENT          = $0000006d;  { Fallback name for resources }
  LOCALE_NAME_MAX_LENGTH  = 85;
  MUI_LANGUAGE_ID         = $4;  { Use traditional language ID convention }
  MUI_LANGUAGE_NAME       = $8;  { Use ISO language (culture) name convention }
  MUI_UI_FALLBACK         = $30; { Retrieve a complete thread preferred UI languages list }
  LOAD_LIBRARY_AS_DATAFILE = 2;
  HKEY_CURRENT_USER = HKEY(NativeUInt($80000001));
  HKEY_LOCAL_MACHINE = HKEY(NativeUInt($80000002));
  KEY_ALL_ACCESS = $000F003F;
  KEY_READ = $000F0019;

  OlderLocaleOverrideKey = 'Software\Borland\Delphi\Locales'; // do not localize
  OldLocaleOverrideKey = 'Software\Borland\Locales'; // do not localize
  NewLocaleOverrideKey = 'Software\CodeGear\Locales'; // do not localize
  NewerLocaleOverrideKey = 'Software\Embarcadero\Locales'; // do not localize
{$ENDIF}

function FindModule(Instance: HINST): PLibModule;
begin
  Result := LibModuleList;
  while Result <> nil do
  begin
    if (Instance = Result.Instance) or
       (Instance = Result.CodeInstance) or
       (Instance = Result.DataInstance) or
       (Instance = Result.ResInstance) then
      Exit;
    Result := Result.Next;
  end;
end;

                                                                                      
function FindHInstance(Address: Pointer): HINST;
{$IFDEF MSWINDOWS}
var
  MemInfo: TMemoryBasicInformation;
begin
  VirtualQuery(Address, MemInfo, SizeOf(MemInfo));
  if MemInfo.State = $1000{MEM_COMMIT} then
    Result := UIntPtr(MemInfo.AllocationBase)
  else
    Result := 0;
end;
{$ENDIF}
{$IFDEF POSIX}
var
  Info: dl_info;
begin
  if (dladdr(UIntPtr(Address), Info) = 0) or (Info.dli_fbase = ExeBaseAddress) then
    Info.dli_fname := nil;   // if it's not in a library, assume the exe
  Result := NativeUInt(dlopen(_PAnsiChr(UTF8Encode(Info.dli_fname)), RTLD_LAZY));
  if Result <> 0 then
    dlclose(Result);
end;
{$ENDIF}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
begin
   Error(rePlatformNotImplemented);
end;
{$ENDIF !MSWINDOWS and !POSIX}

function FindClassHInstance(ClassType: TClass): HINST;
begin
  Result := FindHInstance(Pointer(ClassType));
end;

{$IFDEF POSIX}
function GetModuleFileName(Module: HMODULE; Buffer: PChar; BufLen: Integer): Integer;
var
  Addr: Pointer;
  Info: dl_info;
{$IFDEF LINUX}
  Temp: Integer;
  ProcBuff: array [0..MAX_PATH] of _AnsiChr;
  FoundInModule: HMODULE;
{$ENDIF}
{$IFDEF MACOS}
  LoadedModule: HMODULE;
  Name: _PAnsiChr;
  Index: Integer;
{$ENDIF MACOS}
begin
  Result := 0;
  if BufLen <= 0 then Exit;
  Buffer^ := #0;
  if (Module = MainInstance) or (Module = 0) then
  begin
    // First, try the dlsym approach.
    // dladdr fails to return the name of the main executable
    // in glibc prior to 2.1.91

{   Look for a dynamic symbol exported from this program.
    _DYNAMIC is not required in a main program file.
    If the main program is compiled with Delphi, it will always
    have a resource section, named @Sysinit@ResSym.
    If the main program is not compiled with Delphi, dlsym
    will search the global name space, potentially returning
    the address of a symbol in some other shared object library
    loaded by the program.  To guard against that, we check
    that the address of the symbol found is within the
    main program address range.  }

    dlerror;   // clear error state;  dlsym doesn't
//    Addr := dlsym(Module, '@Sysinit@ResSym');
    if Module = 0 then Module := RTLD_DEFAULT;
    Addr := dlsym(Module, 'SysinitResSym');
    if (Addr <> nil) and (dlerror = nil)
      and (dladdr(UIntPtr(Addr), Info) <> 0)
      and (Info.dli_fname <> nil)
      and (Info.dli_fbase = ExeBaseAddress) then
    begin
      Result := strlen(Info.dli_fname);
      if Result >= BufLen then Result := BufLen-1;

      // dlinfo may not give a full path.  Compare to /proc/self/exe,
      // take longest result.
{$IFDEF LINUX}
//      Temp := readlink('/proc/self/exe', Buffer, BufLen);
      Temp := readlink('/proc/self/exe', ProcBuff, MAX_PATH);
      if Temp >= BufLen then Temp := BufLen-1;
      if Temp > Result then
      begin
        Utf8ToUnicode(Buffer, BufLen, ProcBuff, Temp);
        Result := Temp;
      end
      else
        Move(Info.dli_fname^, Buffer^, Result);
{$ENDIF LINUX}
{$IFDEF MACOS}
      Utf8ToUnicode(Buffer, BufLen, Info.dli_fname, Result);
{$ENDIF MACOS}
      Buffer[Result] := #0;
      Exit;
    end;

{$IFDEF LINUX}
    // Try inspecting the /proc/ virtual file system
    // to find the program filename in the process info
    Result := readlink(_AnsiStr('/proc/self/exe'), ProcBuff, MAX_PATH);
    if Result <> -1 then
    begin
      if Result >= BufLen then Result := BufLen-1;
      ProcBuff[Result] := #0;
      Utf8ToUnicode(Buffer, BufLen, ProcBuff, Result);
    end;
{$ENDIF LINUX}
{$IFDEF AllowParamStrModuleName}
{   Using ParamStr(0) to obtain a module name presents a potential
    security hole.  Resource modules are loaded based upon the filename
    of a given module.  We use dlopen() to load resource modules, which
    means the .init code of the resource module will be executed.
    Normally, resource modules contain no code at all - they're just
    carriers of resource data.
    An unpriviledged user program could launch our trusted,
    priviledged program with a bogus parameter list, tricking us
    into loading a module that contains malicious code in its
    .init section.
    Without this ParamStr(0) section, GetModuleFilename cannot be
    misdirected by unpriviledged code (unless the system program loader
    or the /proc file system or system root directory has been compromised).
    Resource modules are always loaded from the same directory as the
    given module.  Trusted code (programs, packages, and libraries)
    should reside in directories that unpriviledged code cannot alter.

    If you need GetModuleFilename to have a chance of working on systems
    where glibc < 2.1.91 and /proc is not available, and your
    program will not run as a priviledged user (or you don't care),
    you can define AllowParamStrModuleNames and rebuild the System unit
    and baseCLX package.  Note that even with ParamStr(0) support
    enabled, GetModuleFilename can still fail to find the name of
    a module.  C'est la Unix.  }

    if Result = -1 then // couldn't access the /proc filesystem
    begin               // return less accurate ParamStr(0)

{     ParamStr(0) returns the name of the link used
      to launch the app, not the name of the app itself.
      Also, if this app was launched by some other program,
      there is no guarantee that the launching program has set
      up our environment at all.  (example: Apache CGI) }

      if (ArgValues = nil) or (ArgValues^ = nil) or
        (PCharArray(ArgValues^)[0] = nil) then
      begin
        Result := 0;
        Exit;
      end;
      Result := strlen(PCharArray(ArgValues^)[0]);
      if Result >= BufLen then Result := BufLen-1;
      Move(PCharArray(ArgValues^)[0]^, Buffer^, Result);
      Buffer[Result] := #0;
    end;
{$ENDIF AllowParamStrModuleName}
  end
  else
  begin
{$IFDEF LINUX}
{   For shared object libraries, we can rely on the dlsym technique.
    Look for a dynamic symbol in the requested module.
    Don't assume the module was compiled with Delphi.
    We look for a dynamic symbol with the name _DYNAMIC.  This
    exists in all ELF shared object libraries that export
    or import symbols;  If someone has a shared object library that
    contains no imports or exports of any kind, this will probably fail.
    If dlsym can't find the requested symbol in the given module, it
    will search the global namespace and could return the address
    of a symbol from some other module that happens to be loaded
    into this process.  That would be bad, so we double check
    that the module handle of the symbol found matches the
    module handle we asked about.}

    dlerror;   // clear error state;  dlsym doesn't
    Addr := dlsym(Module, '_DYNAMIC');
    if (Addr <> nil) and (dlerror = nil)
      and (dladdr(UIntPtr(Addr), Info) <> 0) then
    begin
      if Info.dli_fbase = ExeBaseAddress then
        Info.dli_fname := nil;
      FoundInModule := HMODULE(dlopen(_PAnsiChr(UTF8Encode(Info.dli_fname)), RTLD_LAZY));
      if FoundInModule <> 0 then
        dlclose(FoundInModule);
      if Module = FoundInModule then
      begin
        if Assigned(Info.dli_fname) then
        begin
          Result := strlen(Info.dli_fname);
          if Result >= BufLen then Result := BufLen-1;
          Move(Info.dli_fname^, Buffer^, Result);
        end
        else
          Result := 0;
        Buffer[Result] := #0;
      end;
    end;
{$ENDIF LINUX}
{$IFDEF MACOS}
{   Iterate through the loaded modules using _dyld_get_image_name,
    comparing those module handles to the handle provided.
    Note that this function is not thread safe as indicies into the
    loaded object list may change if other threads are loading or
    unloading modules. Most of the time this will not be the case;
    failure mode is to just return an empty string. }

    Index := 0;
    Name := _dyld_get_image_name(Index);
    while Name <> nil do
    begin
      LoadedModule := dlopen(Name, RTLD_LAZY);
      dlclose(LoadedModule);

      if LoadedModule = Module then
      begin
        Result := StrLen(Name);
        if Result >= BufLen then Result := BufLen - 1;
        Result := UTF8ToUnicode(Buffer, BufLen, Name, Result);
        Exit(Result);
      end;

      Inc(Index);
      Name := _dyld_get_image_name(Index);
    end;
    Result := 0;
{$ENDIF MACOS}
  end;

  if Result < 0 then Result := 0;
end;
{$ENDIF POSIX}

function DelayLoadResourceModule(Module: PLibModule): HINST;
var
  FileName: array[0..MAX_PATH] of Char;
begin
  if Module.ResInstance = 0 then
  begin
    GetModuleFileName(Module.Instance, FileName, SizeOf(FileName));
    Module.ResInstance := LoadResourceModule(FileName);
    if Module.ResInstance = 0 then
      Module.ResInstance := Module.Instance;
  end;
  Result := Module.ResInstance;
end;

function FindResourceHInstance(Instance: HINST): HINST;
var
  CurModule: PLibModule;
begin
  CurModule := LibModuleList;
  while CurModule <> nil do
  begin
    if (Instance = CurModule.Instance) or
       (Instance = CurModule.CodeInstance) or
       (Instance = CurModule.DataInstance) then
    begin
      Result := DelayLoadResourceModule(CurModule);
      Exit;
    end;
    CurModule := CurModule.Next;
  end;
  Result := Instance;
end;

{$IF defined(LINUX) or defined(ANDROID)}
function GetUILanguages(const LANGID: WORD): string;
var
  Lang: _AnsiStr;
  Ind: integer;
  languagePart: string;
begin
  // language[_territory][.codeset][@modifiers]
  // language and territory shall consist of LETTERS only.
  Lang := _AnsiStr(getenv('LANG'));
  Result := '';
  if Lang = '' then exit;

  languagePart := '';

  for ind := 1 to length(Lang) do
  begin
    if not(Lang[Ind] in ['a'..'z', 'A'..'Z', '_']) then
      break;
    if Lang[Ind] = '_' then languagePart := Result;
    Result := Result + WideChar(Lang[Ind]);
  end;

  if languagePart <> '' then
    Result :=  Result + ',' + languagePart;
end;

function InternalGetLocaleOverride(AppName: string): string;
begin
  Result := ''; // no override mechanism
end;
{$ENDIF LINUX or ANDROID}
{$IFDEF MACOS}
function StringRefToString(StringRef: CFStringRef): string;
var
  Range: CFRange;
begin
  Range.location := 0;
  Range.length := CFStringGetLength(StringRef);
  if Range.length > 0 then
  begin
    SetLength(Result, Range.length);
    CFStringGetCharacters(StringRef, Range, @Result[Low(string)]);
  end
  else
    Result := '';
end;

function GetUILanguages(const LANGID: WORD): string;
var
  PL : CFArrayRef;
  I: integer;
begin
  Result := '';
  PL := CFLocaleCopyPreferredLanguages;
  try
    if CFArrayGetCount(PL) > 0 then
    begin
      Result := StringRefToString(CFArrayGetValueAtIndex(PL, 0));
      for I := 1 to CFArrayGetCount(PL)-1 do
        Result := Result + ',' + StringRefToString(CFArrayGetValueAtIndex(PL, I));
    end;
  finally
    CFRelease(PL);
  end;
end;

function InternalGetLocaleOverride(AppName: string): string;
begin
  Result := ''; // no override mechanism
end;
{$ENDIF MACOS}

{$IFDEF MSWINDOWS}
type
  TLanguageEntry = record
    ID: WORD;
    List: _PAnsiChr;
  end;

{$I LocaleData.INC }

var
  GetThreadPreferredUILanguages : function(dwFlags: LONGWORD; pulNumLanguages: Pointer;
    pwszLanguagesBuffer: PWideChar; pcchLanguagesBuffer: Pointer): Boolean; stdcall;
  SetThreadPreferredUILanguages : function(dwFlags: LONGWORD; pwszLanguagesBuffer: Pointer;
    pulNumLanguages: Pointer): Boolean; stdcall;
  GetThreadUILanguage : function : WORD; stdcall;
  UseThreadUILanguageAPI: Boolean;
  CrSec: TRTLCriticalSection;
  CachedLangID: Word;
  CachedLanguageNames: array[0.. LOCALE_NAME_MAX_LENGTH-1] of Char;

procedure InitializeLocaleData;
begin
  InitializeCriticalSection(CrSec);
  CachedLangID := $7f; //  LANG_INVARIANT
  UseThreadUILanguageAPI := (GetVersion and $000000FF) >= 6;
  if UseThreadUILanguageAPI then
  begin
    @GetThreadPreferredUILanguages := GetProcAddress(GetModuleHandle(kernel), 'GetThreadPreferredUILanguages');
    @SetThreadPreferredUILanguages := GetProcAddress(GetModuleHandle(kernel), 'SetThreadPreferredUILanguages');
    @GetThreadUILanguage:= GetProcAddress(GetModuleHandle(kernel), 'GetThreadUILanguage');
  end;
end;

procedure FinalizeLocaleDate;
begin
  DeleteCriticalSection(CrSec);
end;

procedure StringCopy(Dest: PWideChar; DestSize: integer; Src: PWideChar);
var
  Ch: Char;
begin
  if DestSize = 0 then
    Dest^ := #$0
  else
  begin
    while DestSize > 0 do
    begin
      Ch := Src^;
      Dest^ := Ch;
      if Ch = #$0 then
        exit;
      Inc(Dest);
      Inc(Src);
      Dec(DestSize);
    end;
    if DestSize = 0 then
      (Dest-1)^ := #$0;
  end;
end;

function GetUILanguages(const LANGID: WORD): string;

  function LastHyphenPos(S : String) : integer;
  var
    I: integer;
  begin
    for I := Length(S) downto 1 do
      if S[I] = '-' then exit (I-1);
    Result := 0;
  end;

  function ConvertResToUILanguages(ResBuffer: _PAnsiChr): String;
  var
    I: Integer;
    Separator,
    ALanguage: String;
  begin
    Result := String(_PAnsiChr(ResBuffer));
    for I := 1 to Length(Result) do
      if Result[I] = ',' then exit;
    ALanguage := Result;
    Result := '';
    while ALanguage <> '' do
    begin
      Result := Result + Separator + ALanguage;
      Separator := ',';
      ALanguage := Copy(ALanguage, 1, LastHyphenPos(ALanguage));
    end;
  end;

  function GetPreferredLangForOldOS(LANGID: Word): string;
  var
    Language, Region : array[0.. LOCALE_NAME_MAX_LENGTH-1] of Char;
    H, L, I: Cardinal;
  begin
    Result := '';
    // Lookup exceptional languages table.
    if (NumberOfLocaleData > 0) and (LocaleTable[0].ID <= LANGID) and (LANGID <= LocaleTable[NumberOfLocaleData-1].ID) then
    begin
      H := NumberOfLocaleData-1;
      L := 0;
      while H >= L do
      begin
        I := (H + L) div 2;
        if LocaleTable[I].ID > LANGID then H := I - 1
        else if LocaleTable[I].ID < LANGID then L :=  I + 1
        else
        begin
          Result := ConvertResToUILanguages(LocaleTable[I].List);
          Break;
        end;
      end;
    end;
    if (Result = '') and IsValidLocale(LANGID, LCID_SUPPORTED) then
    begin
      // Generate language names: <language>-<country> and <language>
      GetLocaleInfo(LANGID, LOCALE_SISO639LANGNAME, Language, LOCALE_NAME_MAX_LENGTH);
      GetLocaleInfo(LANGID, LOCALE_SISO3166CTRYNAME, Region, LOCALE_NAME_MAX_LENGTH);
      Result := String(Language) + '-' + String(Region) + ',' + String(Language);
    end;
  end;

  function CheckDifferentLanguageList(src1, src2: PWideChar; len: integer): Boolean;
  begin
    Result := True;
    while len > 0 do
    begin
      if (src1^ <> src2^) then exit;
      inc(src1);
      inc(src2);
      dec(len);
    end;
    Result := False;
  end;

  function ThreadUILanguages(var bufsize: Integer): PWideChar;
  var
    I: Integer;
  begin
    Result := nil;
    bufsize := 0;
    if GetThreadPreferredUILanguages(MUI_LANGUAGE_NAME or MUI_UI_FALLBACK, @I, nil, @bufsize) then
    begin
      GetMem(Result, bufsize * sizeof(Char));
      GetThreadPreferredUILanguages(MUI_LANGUAGE_NAME or MUI_UI_FALLBACK, @I, Result, @bufsize);
    end;
  end;

  function GetPreferredLangForNewOS(const LANGID: WORD): string;
  var
    SavedBufSize, BufSize: Integer;
    SavedUILanguages, UILanguages: PChar;
    I: integer;
    W: WORD;
    IDBuf: array[0..5] of WideChar; // four digits + two #0
  begin
    SavedUILanguages := nil;
    if GetThreadUILanguage <> LANGID then
    begin
      SavedUILanguages := ThreadUILanguages(SavedBufSize);
      W := LANGID;
      for I := 3 downto 0 do
      begin
        IDBuf[I] := WideChar(Ord(hexDigits[W and $0F]));
        W := W div 16;
      end;
      IDBuf[4] := #0; // Double null-terminator.
      IDBuf[5] := #0;
      SetThreadPreferredUILanguages(MUI_LANGUAGE_ID, @IDBuf, @I);
    end;

    UILanguages := ThreadUILanguages(BufSize);
    if UILanguages <> nil then
    begin
      for I := 0 to BufSize - 2 do
        if UILanguages[I] = #0 then UILanguages[I] := ',';
      Result := UILanguages;
      FreeMem(UILanguages);
    end;

    if SavedUILanguages <> nil then
    begin
      SetThreadPreferredUILanguages(0, nil, @I);
      UILanguages := ThreadUILanguages(BufSize);
      if (SavedBufSize <> BufSize) or CheckDifferentLanguageList(SavedUILanguages, UILanguages, BufSize) then
        SetThreadPreferredUILanguages(MUI_LANGUAGE_NAME, SavedUILanguages, @I);
      FreeMem(UILanguages);
      FreeMem(SavedUILanguages);
    end;
  end;

begin
  EnterCriticalSection(CrSec);
  if CachedLangID = LANGID then
  begin
    Result := CachedLanguageNames;
    LeaveCriticalSection(CrSec);
    exit;
  end;
  LeaveCriticalSection(CrSec);

  Result := '';
  if IsValidLocale(LANGID, LCID_SUPPORTED) then
  begin
    if UseThreadUILanguageAPI then
      Result := GetPreferredLangForNewOS(LANGID)
    else
    begin
      Result := GetPreferredLangForOldOS(LANGID);
      if LangID <> GetSystemDefaultUILanguage then
      begin
        if Result <> '' then Result := Result + ',';
        Result := Result + GetPreferredLangForOldOS(GetSystemDefaultUILanguage);
      end;
    end;
  end;

  EnterCriticalSection(CrSec);
  CachedLangID := LANGID;
  StringCopy(CachedLanguageNames, SizeOf(CachedLanguageNames), PChar(Result));
  LeaveCriticalSection(CrSec);
end;

function InternalGetLocaleOverride(AppName: string): string;

  function FindBS(Current: PChar): PChar;
  begin
    Result := Current;
    while (Result^ <> #0) and (Result^ <> '\') do
      Result := CharNext(Result);
  end;

  function ToLongPath(AFileName: PChar; BufLen: Integer): PChar;
  var
    CurrBS, NextBS: PChar;
    {$IFDEF CPU386}
    Module: Integer;
    {$ELSE}
    Module: HMODULE;
    {$ENDIF}
    Handle: THandle;
    L: Integer;
    FindData: TWin32FindData;
    Buffer: array[0..MAX_PATH] of Char;
    GetLongPathName: function (ShortPathName: PChar; LongPathName: PChar;
      cchBuffer: Integer): Integer stdcall;
  const
    longPathName = 'GetLongPathNameW';
  begin
    Result := AFileName;
    Module := GetModuleHandle(kernel);
    if Module <> 0 then
    begin
      @GetLongPathName := GetProcAddress(Module, longPathName);
      if Assigned(GetLongPathName) and
        (GetLongPathName(AFileName, Buffer, Length(Buffer)) <> 0) then
      begin
        StringCopy(AFileName, BufLen, Buffer);
        Exit;
      end;
    end;

    if AFileName[0] = '\' then
    begin
      if AFileName[1] <> '\' then Exit;
      CurrBS := FindBS(AFileName + 2);  // skip server name
      if CurrBS^ = #0 then Exit;
      CurrBS := FindBS(CurrBS + 1);     // skip share name
      if CurrBS^ = #0 then Exit;
    end else
      CurrBS := AFileName + 2;          // skip drive name

    L := CurrBS - AFileName;
    if L + 1 > Length(Buffer) then Exit;
    StringCopy(Buffer, L + 1, AFileName);
    while CurrBS^ <> #0 do
    begin
      NextBS := FindBS(CurrBS + 1);
      if L + (NextBS - CurrBS) + 1 > Length(Buffer) then Exit;
      StringCopy(Buffer + L, (NextBS - CurrBS) + 1, CurrBS);

      Handle := FindFirstFile(Buffer, FindData);
      if Handle = THandle(-1) then Exit;
      FindClose(Handle);

      if L + 1 + _strlen(FindData.cFileName) + 1 > Length(Buffer) then Exit;
      Buffer[L] := '\';
      StringCopy(Buffer + L + 1, Length(Buffer) - L - 1, FindData.cFileName);
      Inc(L, _strlen(FindData.cFileName) + 1);
      CurrBS := NextBS;
    end;
    StringCopy(AFileName, BufLen, Buffer);
  end;

var
  HostAppName: array [0..MAX_PATH] of Char;
  LocaleOverride: PChar;
  Key: HKEY;
  LocSize: Integer;
begin
  if AppName = '' then
    GetModuleFileName(0, HostAppName, Length(HostAppName)) // Get host application name
  else
    StringCopy(HostAppName, Length(HostAppName), PChar(AppName));
  if HostAppName[0] = #$0 then exit;
  LocaleOverride := nil;

  if (RegOpenKeyEx(HKEY_CURRENT_USER, NewerLocaleOverrideKey, 0, KEY_READ, Key) = 0) or
   (RegOpenKeyEx(HKEY_LOCAL_MACHINE, NewerLocaleOverrideKey, 0, KEY_READ, Key) = 0) or
   (RegOpenKeyEx(HKEY_CURRENT_USER, NewLocaleOverrideKey, 0, KEY_READ, Key) = 0) or
   (RegOpenKeyEx(HKEY_LOCAL_MACHINE, NewLocaleOverrideKey, 0, KEY_READ, Key) = 0) or
   (RegOpenKeyEx(HKEY_CURRENT_USER, OldLocaleOverrideKey, 0, KEY_READ, Key) = 0) or
   (RegOpenKeyEx(HKEY_CURRENT_USER, OlderLocaleOverrideKey, 0, KEY_READ, Key) = 0) then
  try
    ToLongPath(HostAppName, Length(HostAppName));
    if RegQueryValueEx(Key, HostAppName, nil, nil, nil, @LocSize) = 0 then
    begin
      GetMem(LocaleOverride, LocSize);
      RegQueryValueEx(Key, HostAppName, nil, nil, PByte(LocaleOverride), @LocSize);
      Result := LocaleOverride;
    end
    else if RegQueryValueEx(Key, '', nil, nil, nil, @LocSize) = 0 then
    begin
      GetMem(LocaleOverride, LocSize);
      RegQueryValueEx(Key, '', nil, nil, PByte(LocaleOverride), @LocSize);
      Result := LocaleOverride;
    end;
  finally
    if LocaleOverride <> nil then
      FreeMem(LocaleOverride);
    RegCloseKey(Key);
  end;
end;
{$ENDIF MSWINDOWS}

var
  PreferredLanguagesOverride: PChar = nil;

function GetLocaleOverride(const AppName: string): string;
begin
  if PreferredLanguagesOverride = nil then
    SetLocaleOverride(InternalGetLocaleOverride(AppName));
  Result := PreferredLanguagesOverride;
end;

procedure SetLocaleOverride(const NewPreferredLanguages: string);
var
  L: Integer;
begin
  if PreferredLanguagesOverride <> nil then
    FreeMem(PreferredLanguagesOverride);
  L := Length(NewPreferredLanguages);
  if L > 0 then
  begin
    Inc(L);
    GetMem(PreferredLanguagesOverride, L * SizeOf(Char));
    MoveChars(NewPreferredLanguages[Low(string)], PreferredLanguagesOverride^, L);
  end
  else
    PreferredLanguagesOverride := nil;
end;

                                                                                    
function GetResourceModuleName(HostAppName, ModuleName: string): string;

  function ResouceDLLExists(S: string): Boolean;
{$IFDEF POSIX}
  var
    st1: _stat;
  begin
    Result := stat(_PAnsiChr(UTF8Encode(S)), st1) <> -1;
  end;
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
  var
    Handle: THandle;
    FindData: TWin32FindData;
  begin
    Handle := FindFirstFile(PWideChar(S), FindData);
    Result := Handle <> THandle(-1);
    if Result then
      FindClose(Handle);
  end;
{$ENDIF}
{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}
  begin
    Error(rePlatformNotImplemented);
    Result := False;
  end;
{$ENDIF !MSWINDOWS and !POSIX}

  function LoadLanguageList(FileNameBody, List: String): string;
  Var
    s, ind : integer;
  begin
    Result := '';
    ind := 1;
    while (ind <= length(List)) do
    begin
      s := ind;
      while (ind <= Length(List)) and (List[ind] <> ',') do inc(ind);
      if s <> ind then
      begin
        Result := FileNameBody + Copy(List, s, ind-s);
        if ResouceDLLExists(Result) then exit;
{$IFDEF MACOS}
        // workaround for 282039.
        if Copy(List, s, ind-s) = 'en' then exit('');
{$ENDIF MACOS}
      end;
      inc(ind);
    end;
    Result := '';
  end;

{$IFDEF MACOS}
  function LoadLocalizedBundle(ModuleName: string): string;

    function CFSTR(const s: string): CFStringRef;
    begin
      Result := CFStringCreateWithCharacters(nil, PChar(s), Length(s));
    end;

  var
    ind: integer;
    resourceName, resourceType : CFStringRef;
    resourceDirectoryURL: CFURLRef;
    resourceDirectoryPath: CFStringRef;
  begin
    Result := '';
    for ind := length(ModuleName) downto 1 do
      if ModuleName[ind] = '/' then
      begin
        ModuleName := copy(ModuleName, ind+1, MAXINT);
        break;
      end;

    resourceName := CFSTR(ModuleName);
    resourceType := CFSTR('resources');
    try
      resourceDirectoryURL := CFBundleCopyResourceURL(CFBundleGetMainBundle, resourceName, resourceType, nil);
      if resourceDirectoryURL <> nil then
      try
        resourceDirectoryPath := CFURLCopyFileSystemPath(resourceDirectoryURL, 0); // kCFURLPOSIXPathStyle
        try
          Result := StringRefToString(resourceDirectoryPath);
          if ResouceDLLExists(Result) then exit;
        finally
          CFRelease(resourceDirectoryPath);
        end;
      finally
        CFRelease(resourceDirectoryURL);
      end;
    finally
      CFRelease(resourceType);
      CFRelease(resourceName);
    end;
    Result := '';
  end;
{$ENDIF MACOS}
{$IFDEF MSWINDOWS}
  function Load3LettersModule(FileNameBody: string): string;
  var
    ExtPart : array[0..3] of char;
  begin
    GetLocaleInfo(GetUserDefaultUILanguage, LOCALE_SABBREVLANGNAME, ExtPart, SizeOf(ExtPart) div SizeOf(ExtPart[0]));
    Result := FileNameBody + string(ExtPart);
    if ResouceDLLExists(Result) then Exit;
    ExtPart[2] := #$0;
    Result := FileNameBody + string(ExtPart);
    if ResouceDLLExists(Result) then Exit;
    Result := '';
  end;
{$ENDIF MSWINDOWS}

var
  LocaleOverrideKey: string;
  FileNameBody : string;
  Ind: integer;
begin
  Result := '';
  if ModuleName = '' then Exit;
{$IFDEF MSWINDOWS}
  FileNameBody := ModuleName;
  for ind := Length(ModuleName) downto 1 do
  begin
    if ModuleName[ind + (Low(ModuleName)-1)] = '.' then
    begin
      FileNameBody := Copy(ModuleName, 1, ind);
      break;
    end;
  end;
{$ENDIF}
{$IFDEF POSIX}
  FileNameBody := ModuleName;
  for ind := Length(ModuleName) downto 1 do
  begin
    if ModuleName[ind + (Low(ModuleName) - 1)] = '.' then
    begin
      if Copy(ModuleName, ind, MaxInt) = '.dylib' then
        FileNameBody := Copy(ModuleName, 1, ind);
      break;
    end;
  end;
  if FileNameBody[Length(FileNameBody) + (Low(FileNameBody) -1 )] <> '.' then
    FileNameBody := FileNameBody + '.';
{$ENDIF}
  LocaleOverrideKey := GetLocaleOverride(HostAppName);
  if LocaleOverrideKey <> '' then
    Result := LoadLanguageList(FileNameBody, LocaleOverrideKey)
  else
  begin
{$IFDEF POSIX}
    Result := LoadLanguageList(FileNameBody, GetUILanguages(0));
{$ENDIF POSIX}
{$IFDEF MSWINDOWS}
    Result := LoadLanguageList(FileNameBody, GetUILanguages(GetUserDefaultUILanguage));
    if (Result = '') and (not UseThreadUILanguageAPI) then
      Result := LoadLanguageList(FileNameBody, GetUILanguages(GetSystemDefaultUILanguage));
    if Result = '' then
      Result := Load3LettersModule(FileNameBody);
{$ENDIF}
  end;
{$IF defined(MACOS)}
  if Result = '' then
    Result := LoadLocalizedBundle(ModuleName);
{$ENDIF}

end;

{$IFDEF POSIX}
function LoadModule(ModuleName, ResModuleName: string; CheckOwner: Boolean): THandle;
var
  st1, st2: _stat;
  ModuleFileName, ResModuleFileName: _UTF8Str;
begin
{ Security check:  make sure the user id (owner) and group id of
  the base module matches the user id and group id of the resource
  module we're considering loading.  This is to prevent loading
  of malicious code dropped into the base module's directory by
  a hostile user.  The app and all its resource modules must
  have the same owner and group.  To disable this security check,
  call this function with CheckOwner set to False. }

  Result := 0;

  ModuleFileName := UTF8Encode(ModuleName);
  if CheckOwner and (stat(_PAnsiChr(ModuleFileName), st1) = -1) then
    Exit;

  ResModuleFileName := UTF8Encode(ResModuleName);

  if (not CheckOwner) or
    ((stat(_PAnsiChr(ResModuleFileName), st2) <> -1)
     and (st1.st_uid = st2.st_uid)
     and (st1.st_gid = st2.st_gid)) then
    Result := THandle(dlopen(_PAnsiChr(ResModuleFileName), RTLD_LAZY));
end;
{$ENDIF}

function LoadResourceModule(ModuleName: PChar; CheckOwner: Boolean): THandle;
var
  HostAppName: array [0..MAX_PATH] of Char;
  ResModuleName : string;
begin
  Result := 0;
  GetModuleFileName(0, HostAppName, Length(HostAppName));
  ResModuleName := GetResourceModuleName(HostAppName, ModuleName);
  if ResModuleName <> '' then
{$IFDEF MSWINDOWS}
    Result := LoadLibraryEx(PChar(ResModuleName), 0, LOAD_LIBRARY_AS_DATAFILE)
{$ENDIF}
{$IFDEF POSIX}
    Result := LoadModule(ModuleName, ResModuleName, CheckOwner);
{$ENDIF}
end;

procedure EnumModules(Func: TEnumModuleFunc; Data: Pointer);
begin
  EnumModules(TEnumModuleFuncLW(Func), Data);
end;

procedure EnumResourceModules(Func: TEnumModuleFunc; Data: Pointer);
begin
  EnumResourceModules(TEnumModuleFuncLW(Func), Data);
end;

procedure EnumModules(Func: TEnumModuleFuncLW; Data: Pointer);
var
  CurModule: PLibModule;
begin
  CurModule := LibModuleList;
  while CurModule <> nil do
  begin
    if not Func(CurModule.Instance, Data) then Exit;
    CurModule := CurModule.Next;
  end;
end;

procedure EnumResourceModules(Func: TEnumModuleFuncLW; Data: Pointer);
var
  CurModule: PLibModule;
begin
  CurModule := LibModuleList;
  while CurModule <> nil do
  begin
    if not Func(DelayLoadResourceModule(CurModule), Data) then Exit;
    CurModule := CurModule.Next;
  end;
end;

procedure AddModuleUnloadProc(Proc: TModuleUnloadProc);
begin
  AddModuleUnloadProc(TModuleUnloadProcLW(Proc));
end;

procedure RemoveModuleUnloadProc(Proc: TModuleUnloadProc);
begin
  RemoveModuleUnloadProc(TModuleUnloadProcLW(Proc));
end;

procedure AddModuleUnloadProc(Proc: TModuleUnloadProcLW);
var
  P: PModuleUnloadRec;
begin
  New(P);
  P.Next := ModuleUnloadList;
  @P.Proc := @Proc;
  ModuleUnloadList := P;
end;

procedure RemoveModuleUnloadProc(Proc: TModuleUnloadProcLW);
var
  P, C: PModuleUnloadRec;
begin
  P := ModuleUnloadList;
  if (P <> nil) and (@P.Proc = @Proc) then
  begin
    ModuleUnloadList := ModuleUnloadList.Next;
    Dispose(P);
  end else
  begin
    C := P;
    while C <> nil do
    begin
      if (C.Next <> nil) and (@C.Next.Proc = @Proc) then
      begin
        P := C.Next;
        C.Next := C.Next.Next;
        Dispose(P);
        Break;
      end;
      C := C.Next;
    end;
  end;
end;

procedure NotifyModuleUnload(HInstance: THandle);
var
  P: PModuleUnloadRec;
begin
  P := ModuleUnloadList;
  while P <> nil do
  begin
    try
      P.Proc(HInstance);
    except
      // Make sure it doesn't stop notifications
    end;
    P := P.Next;
  end;
{$IFDEF LINUX}
  InvalidateModuleCache;
{$ENDIF}
end;

procedure RegisterModule(LibModule: PLibModule);
begin
  LibModule.Next := LibModuleList;
  LibModuleList := LibModule;
end;

procedure UnregisterModule(LibModule: PLibModule);
var
  CurModule: PLibModule;
begin
  try
    NotifyModuleUnload(LibModule.Instance);
  finally
    if LibModule = LibModuleList then
      LibModuleList := LibModule.Next
    else
    begin
      CurModule := LibModuleList;
      while CurModule <> nil do
      begin
        if CurModule.Next = LibModule then
        begin
          CurModule.Next := LibModule.Next;
          Break;
        end;
        CurModule := CurModule.Next;
      end;
    end;
  end;
end;

function _IntfClear(var Dest: IInterface): Pointer;
{$IFDEF PUREPASCAL}
var
  P: Pointer;
begin
  Result := @Dest;
  if Dest <> nil then
  begin
    P := Pointer(Dest);
    Pointer(Dest) := nil;
    IInterface(P)._Release;
  end;
end;
{$ELSE !PUREPASCAL}
{$IFDEF CPUX86}
asm
        MOV     EDX,[EAX]
        TEST    EDX,EDX
        JE      @@1
        MOV     DWORD PTR [EAX],0
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        PUSH    EDX
        MOV     EAX,[EDX]
        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._Release
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
@@1:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _IntfCopy(var Dest: IInterface; const Source: IInterface);
{$IFDEF PUREPASCAL}
var
  P: Pointer;
begin
  P := Pointer(Dest);
  if Source <> nil then
    Source._AddRef;
  Pointer(Dest) := Pointer(Source);
  if P <> nil then
    IInterface(P)._Release;
end;
{$ELSE}
{$IFDEF CPUX86}
asm
{
  The most common case is the single assignment of a non-nil interface
  to a nil interface.  So we streamline that case here.  After this,
  we give essentially equal weight to other outcomes.

    The semantics are:  The source intf must be addrefed *before* it
    is assigned to the destination.  The old intf must be released
    after the new intf is addrefed to support self assignment (I := I).
    Either intf can be nil.  The first requirement is really to make an
    error case function a little better, and to improve the behaviour
    of multithreaded applications - if the addref throws an exception,
    you don't want the interface to have been assigned here, and if the
    assignment is made to a global and another thread references it,
    again you don't want the intf to be available until the reference
    count is bumped.
}
        TEST    EDX,EDX         // is source nil?
        JE      @@NilSource
        PUSH    EDX             // save source
        PUSH    EAX             // save dest
        MOV     EAX,[EDX]       // get source vmt
        PUSH    EDX             // source as arg
        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._AddRef
        POP     EAX             // retrieve dest
        MOV     ECX, [EAX]      // get current value
        POP     [EAX]           // set dest in place
        TEST    ECX, ECX        // is current value nil?
        JNE     @@ReleaseDest   // no, release it
        RET                     // most common case, we return here
@@ReleaseDest:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        MOV     EAX,[ECX]       // get current value vmt
        PUSH    ECX             // current value as arg
        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._Release
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
        RET

{   Now we're into the less common cases.  }
@@NilSource:
        MOV     ECX, [EAX]      // get current value
        TEST    ECX, ECX        // is it nil?
        MOV     [EAX], EDX      // store in dest (which is nil)
        JE      @@Done
        MOV     EAX, [ECX]      // get current vmt
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    ECX             // current value as arg
        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._Release
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
@@Done:
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL}

procedure _IntfCast(var Dest: IInterface; const Source: IInterface; const IID: TGUID);
{$IF defined(PUREPASCAL) or defined(PIC)}
// PIC:  EBX must be correct before calling QueryInterface
var
  Temp: Pointer;
begin
  if Source = nil then
    Dest := nil
  else
  begin
    Temp := nil;
    if Source.QueryInterface(IID, IInterface(Temp)) <> 0 then
      ErrorAt(byte(reIntfCastError), ReturnAddress)
    else
    begin
      if Assigned(Dest) then
          Dest._Release;
      Pointer(Dest) := Temp;
    end;
  end;
end;
{$ELSE !PUREPASCAL or !PIC}
{$IFDEF CPUX86}
asm
        TEST    EDX,EDX
        JE      _IntfClear
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EDI
        MOV     EDI, EAX   // ptr to dest
        PUSH    0
        PUSH    ESP        // ptr to temp
        PUSH    ECX        // ptr to GUID
        PUSH    EDX        // ptr to source
@@1:    MOV     EAX,[EDX]
        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface.QueryInterface
        TEST    EAX,EAX
        JE      @@2
{$IFDEF ALIGN_STACK}
        ADD     ESP, 16
{$ENDIF ALIGN_STACK}
        MOV     AL,reIntfCastError
        JMP     Error
@@2:    MOV     EAX, [EDI]
        TEST    EAX, EAX
        JE      @@3
        PUSH    EAX
        MOV     EAX,[EAX]
        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._Release
@@3:    POP     EAX          // value of temp
        MOV     [EDI], EAX
        POP     EDI
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
end;
{$ENDIF CPUX86}
{$ENDIF !PUREPASCAL or !PIC}

procedure _IntfAddRef(const Dest: IInterface);
begin
  if Dest <> nil then Dest._AddRef;
end;

procedure _IntfOfsCast(var Dest: IInterface; const Source: TObject; const Offset: Integer);
begin
  if Source <> nil then
    _IntfCopy(Dest, IInterface(PByte(Source) + Offset))
  else
    _IntfClear(Dest);
end;

{$IFDEF AUTOREFCOUNT}

function _InstClear(var Dest: TObject): Pointer;
{$IFDEF PUREPASCAL}
var
  P: Pointer;
begin
  Result := @Dest;
  if Dest <> nil then
  begin
    P := Pointer(Dest);
    Pointer(Dest) := nil;
    TObject(P).__ObjRelease;
  end;
end;
{$ELSE}
asm
        MOV     EDX,[EAX]
        TEST    EDX,EDX
        JE      @@1
        MOV     DWORD PTR [EAX],0
{$IFDEF ALIGN_STACK}
        SUB     ESP, 8
{$ENDIF ALIGN_STACK}
        PUSH    EAX
        MOV     EAX,EDX
        MOV     EDX,[EDX]
        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.__ObjRelease
        POP     EAX
{$IFDEF ALIGN_STACK}
        ADD     ESP, 8
{$ENDIF ALIGN_STACK}
@@1:
end;
{$ENDIF !PUREPASCAL}

procedure _InstCopy(var Dest: TObject; const Source: TObject);
{$IFDEF PUREPASCAL}
var
  P: Pointer;
begin
  P := Pointer(Dest);
  if Source <> nil then
    Source.__ObjAddRef;
  Pointer(Dest) := Pointer(Source);
  if P <> nil then
    TObject(P).__ObjRelease;
end;
{$ELSE}
asm
{
  The most common case is the single assignment of a non-nil interface
  to a nil interface.  So we streamline that case here.  After this,
  we give essentially equal weight to other outcomes.

    The semantics are:  The source intf must be addrefed *before* it
    is assigned to the destination.  The old intf must be released
    after the new intf is addrefed to support self assignment (I := I).
    Either intf can be nil.  The first requirement is really to make an
    error case function a little better, and to improve the behaviour
    of multithreaded applications - if the addref throws an exception,
    you don't want the interface to have been assigned here, and if the
    assignment is made to a global and another thread references it,
    again you don't want the intf to be available until the reference
    count is bumped.
}
        TEST    EDX,EDX         // is source nil?
        JE      @@NilSource
{$IFDEF ALIGN_STACK}
        SUB     ESP, 4
{$ENDIF ALIGN_STACK}
        PUSH    EDX             // save source
        PUSH    EAX             // save dest
        MOV     EAX,EDX         // source as arg
        MOV     EDX,[EAX]       // get source vmt
        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.__ObjAddRef
        POP     EAX             // retrieve dest
        MOV     ECX, [EAX]      // get current value
        POP     [EAX]           // set dest in place
{$IFDEF ALIGN_STACK}
        ADD     ESP, 4
{$ENDIF ALIGN_STACK}
        TEST    ECX, ECX        // is current value nil?
        JNE     @@ReleaseDest   // no, release it
        RET                     // most common case, we return here
@@ReleaseDest:
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        MOV     EDX,[ECX]       // get current value vmt
        MOV     EAX,ECX         // current value as arg
        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.__ObjRelease
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
        RET

{   Now we're into the less common cases.  }
@@NilSource:
        MOV     ECX,[EAX]      // get current value
        TEST    ECX,ECX        // is it nil?
        MOV     [EAX],EDX      // store in dest (which is nil)
        JE      @@Done
        MOV     EDX,[ECX]      // get current vmt
{$IFDEF ALIGN_STACK}
        SUB     ESP, 12
{$ENDIF ALIGN_STACK}
        MOV     EAX,ECX        // current value as arg
        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.__ObjRelease
{$IFDEF ALIGN_STACK}
        ADD     ESP, 12
{$ENDIF ALIGN_STACK}
@@Done:
end;
{$ENDIF !PUREPASCAL}

procedure _InstAddRef(const Dest: TObject);
begin
  if Dest <> nil then Dest.__ObjAddRef;
end;

{$ENDIF AUTOREFCOUNT}

{$IFDEF WEAKREF}
type
  TBucket = TArray<PPointer>;

  PInstItem = ^TInstItem;
  TInstItem = record
  const
    BucketHashSize = 31;
  type
    TBucketArray = array[0..BucketHashSize - 1] of TBucket;
  private
    FInstance: Pointer;
    FLock: PMonitor;
    FBuckets: TBucketArray;
    FMethodBuckets: TBucketArray;
    procedure ClearWeakRefs;
    function GetValue: UIntPtr; inline;
    function Hash(Address: Pointer): Integer; inline;
    procedure Lock;
    procedure Unlock;
    procedure RegisterRef(var Buckets: TBucketArray; Address: Pointer);
    procedure UnregisterRef(var Buckets: TBucketArray; Address: Pointer);
  public
    class function Create: PInstItem; static;
    procedure Destroy;
    function Free: Boolean;
    procedure RegisterWeakRef(Address: Pointer); inline;
    procedure UnregisterWeakRef(Address: Pointer); inline;
    procedure RegisterWeakMethodRef(Address: Pointer); inline;
    procedure UnregisterWeakMethodRef(Address: Pointer); inline;
    property Instance: Pointer read FInstance write FInstance;
    property Value: UIntPtr read GetValue;
  end;

  TInstItems = TArray<PInstItem>;

  TInstBucket = record
  private
    FLock: PMonitor;
    FCount: Integer;
    FInstItems: TInstItems;
  public
    procedure Initialize;
    procedure Finalize;
    procedure Lock;
    procedure Unlock;
    procedure AddInstItem(AIndex: Integer; AItem: PInstItem);
    function FindInstItem(AInstance: Pointer; out AIndex: Integer): PInstItem;
    function RemoveInstItem(AInstance: Pointer): PInstItem;
  end;

  TInstHashMap = record
  const
    BucketHashSize = 197;
    MaxFreeInstItems = 512;
  private
    FBuckets: array[0..BucketHashSize - 1] of TInstBucket;
    FFreeInstItems: PInstItem;
    FFreeCount: Integer;
    FInitLock: PMonitor;
    FInitialized: Boolean;
    function Hash(Address: Pointer): Integer; inline;
    procedure FreeInstItem(AItem: PInstItem);
    function NewInstItem(Instance: Pointer): PInstItem;
    function FindInstItem(Instance: Pointer; H: Integer; out AIndex: Integer): PInstItem; inline;
    function AddInstItem(Instance: Pointer; H: Integer; AIndex: Integer): PInstItem; inline;
    function PopInstItem: PInstItem;
  public
    procedure Destroy(Instance: Pointer);
    procedure Initialize;
    procedure Finalize;
    procedure RegisterWeakRef(Address: Pointer; Instance: Pointer);
    procedure UnregisterWeakRef(Address: Pointer; Instance: Pointer);
    procedure RegisterWeakMethodRef(Address: Pointer; Instance: Pointer);
    procedure UnregisterWeakMethodRef(Address: Pointer; Instance: Pointer);
  end;

{ TInstItem }

class function TInstItem.Create: PInstItem;
begin
  Result := AllocMem(SizeOf(Result^));
  Result.FLock := TMonitor.Create;
end;

procedure TInstItem.ClearWeakRefs;
var
  I, J: Integer;
  Loc: PPointer;
begin
  for I := Low(FBuckets) to High(FBuckets) do
  begin
    for J := Low(FBuckets[I]) to High(FBuckets[I]) do
    begin
      Loc := FBuckets[I][J];
      if Loc <> nil then
      begin
        Loc^ := nil;
        FBuckets[I][J] := nil;
      end;
    end;
    for J := Low(FMethodBuckets[I]) to High(FMethodBuckets[I]) do
    begin
      Loc := FMethodBuckets[I][J];
      if Loc <> nil then
      begin
        TMethod(Pointer(Loc)^).Code := nil;
        TMethod(Pointer(Loc)^).Data := nil;
        FMethodBuckets[I][J] := nil;
      end;
    end;
  end;
end;

function TInstItem.GetValue: UIntPtr;
begin
  Result := UIntPtr(FInstance);
end;

function TInstItem.Hash(Address: Pointer): Integer;
begin
  Result := ((IntPtr(Address) shr 13) + (IntPtr(Address) shr 5)) mod BucketHashSize;
end;

procedure TInstItem.Lock;
begin
  if MonitorSupport <> nil then
    FLock.Enter(INFINITE);
end;

procedure TInstItem.Unlock;
begin
  if MonitorSupport <> nil then
    FLock.Exit;
end;

procedure TInstItem.Destroy;
begin
  ClearWeakRefs;
  FInstance := nil;
end;

function TInstItem.Free: Boolean;
begin
  Result := @Self <> nil;
  if Result then
  begin
    ClearWeakRefs;
    FLock.Destroy;
    Dispose(PInstItem(@Self));
  end;
end;

procedure TInstItem.RegisterRef(var Buckets: TBucketArray; Address: Pointer);
var
  I, H: Integer;
begin
  H := Hash(Address);
  Lock;
  try
    for I := Low(Buckets[H]) to High(Buckets[H]) do
      if Buckets[H][I] = nil then
      begin
        Buckets[H][I] := Address;
        Exit;
      end;
    I := Length(Buckets[H]);
    if I = 0 then
      SetLength(Buckets[H], 10)
    else
      SetLength(Buckets[H], I * 2);
    Buckets[H][I] := Address;
  finally
    Unlock;
  end;
end;

procedure TInstItem.UnregisterRef(var Buckets: TBucketArray; Address: Pointer);
var
  I, H: Integer;
begin
  H := Hash(Address);
  Lock;
  try
    for I := Low(Buckets[H]) to High(Buckets[H]) do
      if Buckets[H][I] = Address then
      begin
        Buckets[H][I] := nil;
        Exit;
      end;
  finally
    Unlock;
  end;
end;

procedure TInstItem.RegisterWeakRef(Address: Pointer);
begin
  RegisterRef(FBuckets, Address);
end;

procedure TInstItem.UnregisterWeakRef(Address: Pointer);
begin
  UnregisterRef(FBuckets, Address);
end;

procedure TInstItem.RegisterWeakMethodRef(Address: Pointer);
begin
  RegisterRef(FMethodBuckets, Address);
end;

procedure TInstItem.UnregisterWeakMethodRef(Address: Pointer);
begin
  UnregisterRef(FMethodBuckets, Address);
end;

{ TInstBucket }

procedure TInstBucket.AddInstItem(AIndex: Integer; AItem: PInstItem);
begin
  if Length(FInstItems) = 0 then
    SetLength(FInstItems, 10)
  else if FCount = Length(FInstItems) then
    SetLength(FInstItems, Length(FInstItems) * 2);
  if AIndex >= FCount then
    FInstItems[FCount] := AItem
  else
  begin
    Move(FInstItems[AIndex], FInstItems[AIndex + 1], (FCount - AIndex) * SizeOf(PInstItem));
    FInstItems[AIndex] := AItem;
  end;
  Inc(FCount);
end;

function TInstBucket.FindInstItem(AInstance: Pointer; out AIndex: Integer): PInstItem;
var
  Low, High, Mid: Integer;
  Test: IntPtr;
begin
  Result := nil;
  if FCount > 0 then
  begin
    Low := 0;
    High := FCount - 1;
    while Low <= High do
    begin
      Mid := (Low + High) shr 1;
      Test := FInstItems[Mid].Value - UIntPtr(AInstance);
      if Test < 0 then
        Low := Mid + 1
      else
      begin
        High := Mid - 1;
        if Test = 0 then
        begin
          Result := FInstItems[Mid];
          Low := Mid;
        end;
      end
    end;
    AIndex := Low;
  end else
    AIndex := 0;
end;

procedure TInstBucket.Finalize;
var
  I: Integer;
begin
  for I := 0 to FCount - 1 do
    FInstItems[I].Free;
  FCount := 0;
  FLock.Destroy;
  SetLength(FInstItems, 0);
end;

procedure TInstBucket.Initialize;
begin
  FLock := TMonitor.Create;
  FCount := 0;
end;

procedure TInstBucket.Lock;
begin
  if MonitorSupport <> nil then
    FLock.Enter(INFINITE);
end;

function TInstBucket.RemoveInstItem(AInstance: Pointer): PInstItem;
var
  Index: Integer;
begin
  Result := FindInstItem(AInstance, Index);
  if (Result <> nil) and (Index < FCount) then
  begin
    if Index < FCount - 1 then
      Move(FInstItems[Index + 1], FInstItems[Index], (FCount - Index - 1) * SizeOf(PInstItem));
    Dec(FCount);
  end;
end;

procedure TInstBucket.Unlock;
begin
  if MonitorSupport <> nil then
    FLock.Exit;
end;

{ TInstHashMap }

function TInstHashMap.Hash(Address: Pointer): Integer;
begin
  Result := ((IntPtr(Address) shr 13) + (IntPtr(Address) shr 5)) mod BucketHashSize;
end;

procedure TInstHashMap.FreeInstItem(AItem: PInstItem);
var
  Top: PInstItem;
begin
  if AtomicIncrement(FFreeCount) <= MaxFreeInstItems then
  begin
    repeat
      Top := FFreeInstItems;
      AItem.Instance := Top;
    until AtomicCmpExchange(Pointer(FFreeInstItems), AItem, Top) = Top;
  end else
  begin
    AtomicDecrement(FFreeCount);
    AItem.Free;
  end;
end;

function TInstHashMap.NewInstItem(Instance: Pointer): PInstItem;
begin
  Result := PopInstItem;
  if Result = nil then
    Result := TInstItem.Create;
  Result.Instance := Instance;
end;

function TInstHashMap.PopInstItem: PInstItem;
begin
  repeat
    Result := FFreeInstItems;
    if Result = nil then
      Break;
  until AtomicCmpExchange(Pointer(FFreeInstItems), Result.Instance, Result) = Result;
  if Result <> nil then
    AtomicDecrement(FFreeCount);
end;

function TInstHashMap.FindInstItem(Instance: Pointer; H: Integer; out AIndex: Integer): PInstItem;
begin
  Result := FBuckets[H].FindInstItem(Instance, AIndex);
end;

function TInstHashMap.AddInstItem(Instance: Pointer; H: Integer; AIndex: Integer): PInstItem;
begin
  Result := NewInstItem(Instance);
  FBuckets[H].AddInstItem(AIndex, Result);
end;

procedure TInstHashMap.Finalize;
var
  I: Integer;
begin
  if FInitialized then
  begin
    for I := Low(FBuckets) to High(FBuckets) do
      FBuckets[I].Finalize;
    while PopInstItem.Free do ;
    if FInitLock <> nil then
      FInitLock.Destroy;
  end;
end;

procedure TInstHashMap.Initialize;
var
  I: Integer;
  Lock: PMonitor;
begin
  if not FInitialized then
  begin
    if FInitLock = nil then
    begin
      Lock := TMonitor.Create;
      Lock := AtomicCmpExchange(FInitLock, Lock, nil);
      if Lock <> nil then
        Lock.Destroy;
    end;
    FInitLock.Enter(INFINITE);
    try
      if not FInitialized then
      begin
        for I := Low(FBuckets) to High(FBuckets) do
          FBuckets[I].Initialize;
        FInitialized := True;
      end;
    finally
      FInitLock.Exit;
    end;
  end;
end;

procedure TInstHashMap.Destroy(Instance: Pointer);
var
  H: Integer;
  Item: PInstItem;
begin
  if not FInitialized then Exit;
  H := Hash(Instance);
  FBuckets[H].Lock;
  try
    Item := FBuckets[H].RemoveInstItem(Instance);
  finally
    FBuckets[H].Unlock;
  end;
  if Item <> nil then
  begin
    Item.Destroy;
    FreeInstItem(Item);
  end;
end;

procedure TInstHashMap.RegisterWeakRef(Address: Pointer; Instance: Pointer);
var
  H, Index: Integer;
  Item: PInstItem;
begin
  if not FInitialized then Initialize;
  H := Hash(Instance);
  FBuckets[H].Lock;
  try
    Item := FindInstItem(Instance, H, Index);
    if Item = nil then
      Item := AddInstItem(Instance, H, Index);
  finally
    FBuckets[H].Unlock;
  end;
  Item.RegisterWeakRef(Address);
end;

procedure TInstHashMap.UnregisterWeakRef(Address: Pointer; Instance: Pointer);
var
  H, Index: Integer;
  Item: PInstItem;
begin
  if not FInitialized then Exit;
  H := Hash(Instance);
  FBuckets[H].Lock;
  try
    Item := FindInstItem(Instance, H, Index);
  finally
    FBuckets[H].Unlock;
  end;
  if Item <> nil then
    Item.UnregisterWeakRef(Address);
end;

procedure TInstHashMap.RegisterWeakMethodRef(Address: Pointer; Instance: Pointer);
var
  H, Index: Integer;
  Item: PInstItem;
begin
  if not FInitialized then Initialize;
  H := Hash(Instance);
  FBuckets[H].Lock;
  try
    Item := FindInstItem(Instance, H, Index);
    if Item = nil then
      Item := AddInstItem(Instance, H, Index);
  finally
    FBuckets[H].Unlock;
  end;
  Item.RegisterWeakMethodRef(Address);
end;

procedure TInstHashMap.UnregisterWeakMethodRef(Address: Pointer; Instance: Pointer);
var
  H, Index: Integer;
  Item: PInstItem;
begin
  if not FInitialized then Exit;
  H := Hash(Instance);
  FBuckets[H].Lock;
  try
    Item := FindInstItem(Instance, H, Index);
  finally
    FBuckets[H].Unlock;
  end;
  if Item <> nil then
    Item.UnregisterWeakMethodRef(Address);
end;

var
  InstHashMap: TInstHashMap;

procedure RegisterWeakRef(Address: Pointer; const Instance: TObject);
begin
  if Instance <> nil then
    InstHashMap.RegisterWeakRef(Address, Pointer(Instance));
end;

procedure UnregisterWeakRef(Address: Pointer; const Instance: TObject);
begin
  if Instance <> nil then
    InstHashMap.UnregisterWeakRef(Address, Pointer(Instance));
end;

procedure RegisterWeakMethodRef(Address: Pointer; const Instance: TObject);
begin
  if Instance <> nil then
    InstHashMap.RegisterWeakMethodRef(Address, Pointer(Instance));
end;

procedure UnregisterWeakMethodRef(Address: Pointer; const Instance: TObject);
begin
  if Instance <> nil then
    InstHashMap.UnregisterWeakMethodRef(Address, Pointer(Instance));
end;

procedure _CleanupInstance(Instance: Pointer);
begin
  InstHashMap.Destroy(Instance);
end;

{$IFDEF WEAKINSTREF}
function _InstWeakClear(var Dest: TObject): Pointer;
var
  L: TObject;
begin
  Result := @Dest;
  if Dest <> nil then
  begin
    L := Dest;
    Pointer(Dest) := nil;
    UnregisterWeakRef(Result, L);
  end;
end;

procedure _InstWeakArrayClear(var Dest; Count: Integer);
var
  P: Pointer;
begin
  P := @Dest;
  while Count > 0 do
  begin
    _InstWeakClear(TObject(P^));
    Inc(PByte(P), SizeOf(Pointer));
    Dec(Count);
  end;
end;

procedure _InstWeakCopy(var Dest: TObject; Source: TObject);
begin
  RegisterWeakRef(_InstWeakClear(Dest), Source);
  Pointer(Dest) := Pointer(Source);
end;
{$ENDIF WEAKINSTREF}

{$IFDEF WEAKINTFREF}
function _IntfWeakClear(var Dest: IInterface): Pointer;
var
  L: TObject;
begin
  Result := @Dest;
  if Dest <> nil then
  begin
    L := Dest as TObject;
    Pointer(Dest) := nil;
    UnregisterWeakRef(Result, L);
  end;
end;

procedure _IntfWeakArrayClear(var Dest; Count: Integer);
var
  P: Pointer;
begin
  P := @Dest;
  while Count > 0 do
  begin
    _IntfWeakClear(IInterface(P^));
    Inc(PByte(P), SizeOf(Pointer));
    Dec(Count);
  end;
end;

procedure _IntfWeakCopy(var Dest: IInterface; Source: IInterface);
begin
  RegisterWeakRef(_IntfWeakClear(Dest), Source as TObject);
  Pointer(Dest) := Pointer(Source);
end;
{$ENDIF WEAKINTFREF}

function _ClosureRemoveWeakRef(var Closure: TMethod): Pointer;
var
  L: Pointer;
begin
  Result := @Closure;
  if Closure.Data <> nil then
  begin
    L := Closure.Data;
    Closure.Data := nil;
    Closure.Code := nil;
    UnregisterWeakMethodRef(Result, TObject(L));
  end;
end;

procedure _ClosureAddWeakRef(var Closure: TMethod);
begin
  RegisterWeakMethodRef(@Closure, TObject(Closure.Data));
end;

procedure _ClosureArrayRemoveWeakRef(var Closure: TMethod; Count: Integer);
var
  P: Pointer;
begin
  P := @Closure;
  while Count > 0 do
  begin
    _ClosureRemoveWeakRef(TMethod(P^));
    Inc(PByte(P), SizeOf(TMethod));
    Dec(Count);
  end;
end;

procedure _CopyClosure(var Dest: TMethod; const [Ref] Source: TMethod);
begin
  RegisterWeakMethodRef(_ClosureRemoveWeakRef(Dest), TObject(Source.Data));
  Dest := Source;
end;

function _AsgClosureObj(var Dest: TMethod; const Obj: Pointer; const MethodAddr: Pointer): Pointer;
begin
  Result := Obj;
  RegisterWeakMethodRef(_ClosureRemoveWeakRef(Dest), TObject(Result));
  Dest.Data := Result;
  Dest.Code := MethodAddr;
end;

{$ENDIF WEAKREF}

{$IFNDEF AUTOREFCOUNT}

function TInterfacedObject.GetRefCount: Integer;
begin
  Result := FRefCount and not objDestroyingFlag;
end;

class procedure TInterfacedObject.__MarkDestroying(const Obj);
var
  LRef: Integer;
begin
  repeat
    LRef := TInterfacedObject(Obj).FRefCount;
  until AtomicCmpExchange(TInterfacedObject(Obj).FRefCount, LRef or objDestroyingFlag, LRef) = LRef;
end;

procedure TInterfacedObject.AfterConstruction;
begin
// Release the constructor's implicit refcount
  AtomicDecrement(FRefCount);
end;

procedure TInterfacedObject.BeforeDestruction;
begin
  if RefCount <> 0 then
    Error(reInvalidPtr);
end;

// Set an implicit refcount so that refcounting during construction won't destroy the object.
class function TInterfacedObject.NewInstance: TObject;
begin
  Result := inherited NewInstance;
  TInterfacedObject(Result).FRefCount := 1;
end;

{$ENDIF AUTOREFCOUNT}

function TInterfacedObject.QueryInterface(const IID: TGUID; out Obj): HResult;
begin
  if GetInterface(IID, Obj) then
    Result := 0
  else
    Result := E_NOINTERFACE;
end;

function TInterfacedObject._AddRef: Integer;
begin
{$IFNDEF AUTOREFCOUNT}
  Result := AtomicIncrement(FRefCount);
{$ELSE}
  Result := __ObjAddRef;
{$ENDIF}
end;

function TInterfacedObject._Release: Integer;
begin
{$IFNDEF AUTOREFCOUNT}
  Result := AtomicDecrement(FRefCount);
  if Result = 0 then
  begin
    // Mark the refcount field so that any refcounting during destruction doesn't infinitely recurse.
    __MarkDestroying(Self);
    Destroy;
  end;
{$ELSE}
  Result := __ObjRelease;
{$ENDIF}
end;

{ TAggregatedObject }

constructor TAggregatedObject.Create(const Controller: IInterface);
begin
  // "unsafe" reference to controller - don't keep it alive
  FController := Controller;
end;

function TAggregatedObject.QueryInterface(const IID: TGUID; out Obj): HResult;
begin
  Result := FController.QueryInterface(IID, Obj);
end;

function TAggregatedObject._AddRef: Integer;
begin
  Result := FController._AddRef;
end;

function TAggregatedObject._Release: Integer;
begin
  Result := FController._Release;
end;

{ TContainedObject }

function TContainedObject.QueryInterface(const IID: TGUID; out Obj): HResult;
begin
  if GetInterface(IID, Obj) then
    Result := S_OK
  else
    Result := E_NOINTERFACE;
end;

{ TClassHelperBase }

constructor TClassHelperBase._Create(Instance: TObject);
begin
  inherited Create;
  FInstance := Instance;
end;

function _CheckAutoResult(ResultCode: HResult): HResult;
begin
  if ResultCode < 0 then
  begin
    if Assigned(SafeCallErrorProc) then
      SafeCallErrorProc(ResultCode, ReturnAddress);
    ErrorAt(Byte(reSafeCallError), ReturnAddress);
  end;
  Result := ResultCode;
end;

function  CompToDouble(Value: Comp): Double; cdecl;
begin
  Result := Value;
end;

procedure  DoubleToComp(Value: Double; var Result: Comp); cdecl;
begin
  Result := Value;
end;

function  CompToCurrency(Value: Comp): Currency; cdecl;
begin
  Result := Value;
end;

procedure  CurrencyToComp(Value: Currency; var Result: Comp); cdecl;
begin
  Result := Value;
end;

function GetMemory(Size: NativeInt): Pointer; cdecl;
begin
  Result := MemoryManager.GetMem(Size);
end;

function FreeMemory(P: Pointer): Integer; cdecl;
begin
  if P = nil then
    Result := 0
  else
    Result := MemoryManager.FreeMem(P);
end;

function ReallocMemory(P: Pointer; Size: NativeInt): Pointer; cdecl;
begin
  if P = nil then
    Result := GetMemory(Size)
  else
  Result := MemoryManager.ReallocMem(P, Size);
end;

// UnicodeToUTF8(3):
// Scans the source data to find the null terminator, up to MaxBytes
// Dest must have MaxBytes available in Dest.

function UnicodeToUtf8(Dest: _PAnsiChr; Source: PWideChar; MaxBytes: Integer): Integer;
begin
  Result := UnicodeToUtf8(Dest, MaxBytes, Source, Cardinal(-1));
end;

// UnicodeToUtf8(4):
// MaxDestBytes includes the null terminator (last char in the buffer will be set to null)
// Function result includes the null terminator.
// Nulls in the source data are not considered terminators - SourceChars must be accurate

function UnicodeToUtf8(Dest: _PAnsiChr; MaxDestBytes: Cardinal; Source: PWideChar; SourceChars: Cardinal): Cardinal;
{$IFDEF USE_LIBICU}
var
  DestLen: Int32;
  ErrorConv: UErrorCode;
{$ENDIF USE_LIBICU}
begin
  Result := 0;
  if Source = nil then Exit;
{$IFDEF USE_LIBICU}
  ErrorConv := 0;
  DestLen := 0;
  u_strToUTF8(MarshaledAString(Dest), MaxDestBytes, DestLen, PUChar(Source), SourceChars, ErrorConv);
  Result := DestLen;
  if Dest <> nil then
  begin
    if (Result > 0) and (Result <= MaxDestBytes) then
    begin
      Inc(Result);
      Dest[Result - 1] := #0;
    end;
  end;
{$ELSE}
  if Dest <> nil then
  begin
    Result := Cardinal(LocaleCharsFromUnicode(CP_UTF8, 0, Source, Integer(SourceChars), Dest, Integer(MaxDestBytes), nil, nil));
    if (Result > 0) and (Result <= MaxDestBytes) then
    begin
      if (SourceChars = Cardinal(-1)) and (Dest[Result -1] = #0) then Exit;

      if Result = MaxDestBytes then
      begin
        while (Result > 1) and (Byte(Dest[Result - 1]) > $7F) and (Byte(Dest[Result - 1]) and $80 <> 0) and (Byte(Dest[Result - 1]) and $C0 <> $C0) do
          Dec(Result);
      end else
        Inc(Result);
      Dest[Result - 1] := #0;
    end;
  end else
    Result := Cardinal(LocaleCharsFromUnicode(CP_UTF8, 0, Source, Integer(SourceChars), nil, 0, nil, nil));
{$ENDIF USE_LIBICU}
end;

function Utf8ToUnicode(Dest: PWideChar; Source: _PAnsiChr; MaxChars: Integer): Integer;
begin
  Result := Utf8ToUnicode(Dest, MaxChars, Source, Cardinal(-1));
end;

function Utf8ToUnicode(Dest: PWideChar; MaxDestChars: Cardinal; Source: _PAnsiChr; SourceBytes: Cardinal): Cardinal;
{$IFDEF USE_LIBICU}
var
  DestLen: Int32;
  ErrorConv: UErrorCode;
{$ENDIF USE_LIBICU}
begin
  Result := 0;
  if Source = nil then Exit;
{$IFDEF USE_LIBICU}
  ErrorConv := 0;
  DestLen := 0;
  u_strFromUTF8(PUChar(Dest), MaxDestChars, DestLen, MarshaledAString(Source), SourceBytes, ErrorConv);
  Result := DestLen;
  if Dest <> nil then
  begin
    if (Result > 0) and (Result <= MaxDestChars) then
    begin
      Inc(Result);
      Dest[Result - 1] := #0;
    end;
  end;
{$ELSE}
  if (Dest <> nil) and (MaxDestChars > 0) then
  begin
    Result := Cardinal(UnicodeFromLocaleChars(CP_UTF8, 0, Source, Integer(SourceBytes), Dest, Integer(MaxDestChars)));
    if (Result > 0) and (Result <= MaxDestChars) then
    begin
      if (SourceBytes = Cardinal(-1)) and (Dest[Result - 1] = #0) then Exit;

      if Result = MaxDestChars then
      begin
        if (Result > 1) and (Word(Dest[Result - 1]) >= $DC00) and (Word(Dest[Result - 1]) <= $DFFF) then
          Dec(Result);
      end else
        Inc(Result);
      Dest[Result - 1] := #0;
    end;
  end else
    Result := Cardinal(UnicodeFromLocaleChars(CP_UTF8, 0, Source, Integer(SourceBytes), nil, 0));
{$ENDIF USE_LIBICU}
end;

function Utf8Encode(const WS: _WideStr): _RawByteStr;
var
  L: Integer;
  Temp: _UTF8Str;
begin
  Result := '';
  if WS = '' then Exit;
  L := Length(WS);
  SetLength(Temp, L * 3); // SetLength includes space for null terminator

  L := UnicodeToUtf8(_PAnsiChr(Temp), Length(Temp) + 1, PWideChar(WS), L);
  if L > 0 then
    SetLength(Temp, L - 1)
  else
    Temp := '';
  Result := Temp;
  if Result <> '' then
    PStrRec(PByte(Result) - SizeOf(StrRec)).codePage := CP_UTF8;
end;

function Utf8Encode(const US: UnicodeString): _RawByteStr;
var
  L: Integer;
  Temp: _UTF8Str;
begin
  Result := '';
  if US = '' then Exit;
  L := Length(US);
  SetLength(Temp, L * 3); // SetLength includes space for null terminator

  L := UnicodeToUtf8(_PAnsiChr(Temp), Length(Temp) + 1, PWideChar(US), L);
  if L > 0 then
    SetLength(Temp, L - 1)
  else
    Temp := '';
  Result := Temp;
  if Result <> '' then
    PStrRec(PByte(Result) - SizeOf(StrRec)).codePage := CP_UTF8;
end;

function UTF8Encode(const A: _RawByteStr): _RawByteStr;
begin
  if StringCodePage(A) = CP_UTF8 then
    Result := A
  else
    Result := UTF8Encode(UnicodeString(A));
end;

procedure UTF8Encode(const US: UnicodeString; var B: array of Byte);
begin
  B[0] := UnicodeToUtf8(_PAnsiChr(@B[1]), Length(B) - 1, PWideChar(US), Length(US));
end;

function Max(I1, I2: Integer): Integer; inline;
begin
  if I1 > I2 then
    Result := I1
  else
    Result := I2;
end;

function UTF8EncodeToShortString(const WS: _WideStr): _ShortStr;
begin
  Result[0] := _AnsiChr(Max(0, UnicodeToUtf8(@Result[1], High(Result), PWideChar(WS), Length(WS)) - 1));
end;

function UTF8EncodeToShortString(const US: UnicodeString): _ShortStr;
begin
  Result[0] := _AnsiChr(Max(0, UnicodeToUtf8(@Result[1], High(Result), PWideChar(US), Length(US)) - 1));
end;

function UTF8EncodeToShortString(const A: _RawByteStr): _ShortStr;
begin
  if StringCodePage(A) = CP_UTF8 then
    Result := A
  else
    Result := UTF8EncodeToShortString(UnicodeString(A));
end;

function Utf8Decode(const S: _RawByteStr): _WideStr;
var
  L: Integer;
  Temp: _WideStr;
begin
  Result := '';
  if S = '' then Exit;
  L := Length(S);
  SetLength(Temp, L);

  L := Utf8ToUnicode(PWideChar(Temp), L + 1, _PAnsiChr(S), L);
  if L > 0 then
    SetLength(Temp, L - 1)
  else
    Temp := '';
  Result := Temp;
end;

function UTF8ToWideString(const S: _RawByteStr): _WideStr; inline;
begin
  Result := UTF8Decode(S);
end;

function UTF8ToUnicodeString(const S: _RawByteStr): UnicodeString;
var
  L: Integer;
  Temp: UnicodeString;
begin
  Result := '';
  if S = '' then Exit;
  L := Length(S);
  SetLength(Temp, L);

  L := Utf8ToUnicode(PWideChar(Temp), L + 1, _PAnsiChr(S), L);
  if L > 0 then
    SetLength(Temp, L - 1)
  else
    Temp := '';
  Result := Temp;
end;

function UTF8ToUnicodeString(const S: _PAnsiChr): UnicodeString; overload;
var
  L: Integer;
  Temp: UnicodeString;
begin
  Result := '';
  if S = '' then Exit;
  L := Length(S);
  SetLength(Temp, L);

  L := Utf8ToUnicode(PWideChar(Temp), L + 1, S, L);
  if L > 0 then
    SetLength(Temp, L - 1)
  else
    Temp := '';
  Result := Temp;
end;

function UTF8ToUnicodeString(const S: _ShortStr): UnicodeString; overload;
var
  L: Integer;
  Temp: UnicodeString;
begin
  Result := '';
  if S = '' then Exit;
  L := Length(S);
  SetLength(Temp, L);

  L := Utf8ToUnicode(PWideChar(Temp), L + 1, @S[1], L);
  if L > 0 then
    SetLength(Temp, L - 1)
  else
    Temp := '';
  Result := Temp;
end;

function UTF8ToString(const S: _RawByteStr): string;
begin
  Result := UTF8ToUnicodeString(S);
end;

function UTF8ToString(const S: _ShortStr): string;
begin
  Result := UTF8ToUnicodeString(S);
end;

function UTF8ToString(const S: _PAnsiChr): string;
begin
  Result := UTF8ToUnicodeString(S);
end;

function UTF8ToString(const S: array of _AnsiChr): string;
begin
  Result := UTF8ToUnicodeString(@S[0]);
end;

function UTF8ToString(const S: array of Byte): string; overload;
var
  Dest: array[0..511] of Char;
begin
  SetString(Result, Dest, UTF8ToUnicode(Dest, Length(Dest), _PAnsiChr(@S[1]), S[0])-1);
end;

function AnsiToUtf8(const S: string): _RawByteStr;
begin
  Result := Utf8Encode(S);
end;

function Utf8ToAnsi(const S: _RawByteStr): string;
begin
  Result := string(Utf8ToUnicodeString(S));
end;

{$IFDEF LINUX32}

{$IF Defined(CPUX86)}
function GetCPUType: Integer;
asm
      PUSH      EBX
    // this code assumes ESP is 4 byte aligned
    // test for 80386:  see if bit #18 of EFLAGS (Alignment fault) can be toggled
      PUSHFD
      POP       EAX
      MOV       ECX, EAX
      XOR       EAX, $40000   // flip AC bit in EFLAGS
      PUSH      EAX
      POPFD
      PUSHFD
      POP       EAX
      XOR       EAX, ECX      // zero = 80386 CPU (can't toggle AC bit)
      MOV       EAX, CPUi386
      JZ        @@Exit
      PUSH      ECX
      POPFD                    // restore original flags before next test

      // test for 80486:  see if bit #21 of EFLAGS (CPUID supported) can be toggled
      MOV       EAX, ECX        // get original EFLAGS
      XOR       EAX, $200000    // flip CPUID bit in EFLAGS
      PUSH      EAX
      POPFD
      PUSHFD
      POP       EAX
      XOR       EAX, ECX    // zero = 80486 (can't toggle EFLAGS bit #21)
      MOV       EAX, CPUi486
      JZ        @@Exit

      // Use CPUID instruction to get CPU family
      XOR       EAX, EAX
      CPUID
      CMP       EAX, 1
      JL        @@Exit          // unknown processor response: report as 486
      XOR       EAX, EAX
      INC       EAX       // we only care about info level 1
      CPUID
      AND       EAX, $F00
      SHR       EAX, 8
      // Test8086 values are one less than the CPU model number, for historical reasons
      DEC       EAX

@@Exit:
      POP       EBX
end;
{$ENDIF}
{$ENDIF LINUX32}

{$IF defined(LINUX64) and defined(CPUX64)}
function GetCPUType: Integer;
begin
                                                                  
  Result := CPUPentium;
end;
{$ENDIF LINUX64 and CPUX64}

{$IF defined(LINUX_OLD_RESOURCES)}
const
  sResSymExport = '@Sysinit@ResSym';
  sResStrExport = '@Sysinit@ResStr';
  sResHashExport = '@Sysinit@ResHash';

type
  TElf32Sym = record
    Name: Cardinal;
    Value: Pointer;
    Size: Cardinal;
    Info: Byte;
    Other: Byte;
    Section: Word;
  end;
  PElf32Sym = ^TElf32Sym;

  TElfSymTab = array [0..0] of TElf32Sym;
  PElfSymTab = ^TElfSymTab;

  TElfWordTab = array [0..2] of Cardinal;
  PElfWordTab = ^TElfWordTab;


{ If Name encodes a numeric identifier, return it, else return -1.  }
function NameToId(Name: PChar): Longint;
var digit: Longint;
begin
  if LongInt(IntPtr(Name)) and $ffff0000 = 0 then
  begin
    Result := LongInt(IntPtr(Name)) and $ffff;
  end
  else if Name^ = '#' then
  begin
    Result := 0;
    inc (Name);
    while (Ord(Name^) <> 0) do
    begin
      digit := Ord(Name^) - Ord('0');
      if (LongWord(digit) > 9) then
      begin
        Result := -1;
        exit;
      end;
      Result := Result * 10 + digit;
      inc (Name);
    end;
  end
  else
    Result := -1;
end;


// Return ELF hash value for NAME converted to lower case.
function ElfHashLowercase(Name: PChar): Cardinal;
var
  g: Cardinal;
  c: Char;
begin
  Result := 0;
  while name^ <> #0 do
  begin
    c := name^;
    c := tolower(c);
    Result := (Result shl 4) + Ord(c);
    g := Result and $f0000000;
    Result := (Result xor (g shr 24)) and not g;
    Inc(name);
  end;
end;

type
  PFindResourceCache = ^TFindResourceCache;
  TFindResourceCache = record
    ModuleHandle: HMODULE;
    Version: Cardinal;
    SymbolTable: PElfSymTab;
    StringTable: PChar;
    HashTable: PElfWordTab;
    BaseAddress: Pointer;
  end;

threadvar
  FindResourceCache: TFindResourceCache;

function GetResourceCache(ModuleHandle: HMODULE): PFindResourceCache;
var
  Info: dl_info;
begin
  Result := @FindResourceCache;
  if (ModuleHandle <> Result^.ModuleHandle) or (ModuleCacheVersion <> Result^.Version) then
  begin
    Result^.SymbolTable := dlsym(ModuleHandle, sResSymExport);
    Result^.StringTable := dlsym(ModuleHandle, sResStrExport);
    Result^.HashTable := dlsym(ModuleHandle, sResHashExport);
    Result^.ModuleHandle := ModuleHandle;
    if (dladdr(Result^.HashTable, Info) = 0) or (Info.dli_fbase = ExeBaseAddress) then
      Result^.BaseAddress := nil   // if it's not in a library, assume the exe
    else
      Result^.BaseAddress := Info.dli_fbase;
    Result^.Version := ModuleCacheVersion;
  end;
end;

function FindResource(ModuleHandle: HMODULE; ResourceName: PChar; ResourceType: PChar): TResourceHandle;
var
  P: PFindResourceCache;
  nid, tid: Longint;
  ucs2_key: array [0..2] of WideChar;
  key: array [0..127] of Char;
  len: Integer;
  pc: PChar;
  ch: Char;
  nbucket: Cardinal;
  bucket, chain: PElfWordTab;
  syndx: Cardinal;
begin
  Result := 0;
  if ResourceName = nil then Exit;
  P := GetResourceCache(ModuleHandle);

  tid := NameToId (ResourceType);
  if tid = -1 then Exit;  { not supported (yet?) }

  { This code must match util-common/elfres.c }
  nid := NameToId (ResourceName);
  if nid = -1 then
  begin
    ucs2_key[0] := WideChar(2*tid+2);
    ucs2_key[1] := WideChar(0);
    len := UnicodeToUtf8 (key, ucs2_key, SizeOf (key)) - 1;
    pc := key+len;
    while Ord(ResourceName^) <> 0 do
    begin
      ch := ResourceName^;
      if Ord(ch) > 127 then exit; { insist on 7bit ASCII for now }
      if ('A' <= ch) and (ch <= 'Z') then Inc(ch, Ord('a') - Ord('A'));
      pc^ := ch;
      inc (pc);
      if pc = key + SizeOf(key) then exit;
      inc (ResourceName);
    end;
    pc^ := Char(0);
  end
  else
  begin
    ucs2_key[0] := WideChar(2*tid+1);
    ucs2_key[1] := WideChar(nid);
    ucs2_key[2] := WideChar(0);
    UnicodeToUtf8 (key, ucs2_key, SizeOf (key));
  end;

  with P^ do
  begin
    nbucket := HashTable[0];
  //  nsym := HashTable[1];
    bucket := @HashTable[2];
    chain := @HashTable[2+nbucket];

    syndx := bucket[ElfHashLowercase(key) mod nbucket];
    while (syndx <> 0)
      and (strcasecmp(key, @StringTable[SymbolTable[syndx].Name]) <> 0) do
      syndx := chain[syndx];

    if syndx = 0 then
      Result := 0
    else
      Result := TResourceHandle(@SymbolTable[syndx]);
  end;
end;

function LoadResource(ModuleHandle: HMODULE; ResHandle: TResourceHandle): HGLOBAL;
var
  P: PFindResourceCache;
begin
  if ResHandle <> 0 then
  begin
    P := GetResourceCache(ModuleHandle);
    Result := HGLOBAL(PElf32Sym(ResHandle)^.Value);
    Inc(NativeUInt(Result), UIntPtr(P^.BaseAddress));
  end
  else
    Result := 0;
end;

function SizeofResource(ModuleHandle: HMODULE; ResHandle: TResourceHandle): Integer;
begin
  if ResHandle <> 0 then
    Result := PElf32Sym(ResHandle)^.Size
  else
    Result := 0;
end;

function LockResource(ResData: HGLOBAL): Pointer;
begin
  Result := Pointer(ResData);
end;

function UnlockResource(ResData: HGLOBAL): LongBool;
begin
  Result := False;
end;

function FreeResource(ResData: HGLOBAL): LongBool;
begin
  Result := True;
end;
{$ENDIF LINUX_OLD_RESOURCES}

{$IF (defined(POSIX) and (not defined(EXTERNALLINKER)))}
const
  sResSymExport = 'SysinitResSym';

type
  TResourceHeader = record
    SymtabOffset: Cardinal;
    SymbolCount: Integer;
    HashtableOffset: Cardinal;
  end;
  PResourceHeader = ^TResourceHeader;
  TResourceSym = record
    Name:  Cardinal;
    Data:  Cardinal;
    Size:  Cardinal;
    Chain: Cardinal;            // link to next hash entry, or -1 for end
  end;
  PResourceSym = ^TResourceSym;

  Hashtable = record
    Size: Cardinal;
    Entries: array [0..0] of Cardinal;
  end;
  PHashtable = ^Hashtable;

  TResourceSymTab = array [0..0] of TResourceSym;
  PResourceSymTab = ^TResourceSymTab;

{ If Name encodes a numeric identifier, return it, else return -1.  }
function NameToId(Name: PChar): Integer;
var digit: Integer;
begin
  if UIntPtr(Name) and (not UIntPtr($ffff)) = 0 then
  begin
    Result := Integer(IntPtr(Name)) and $ffff;
  end
  else if Name^ = '#' then
  begin
    Result := 0;
    inc (Name);
    while (Ord(Name^) <> 0) do
    begin
      digit := Ord(Name^) - Ord('0');
      if (Cardinal(digit) > 9) then
      begin
        Result := -1;
        exit;
      end;
      Result := Result * 10 + digit;
      inc (Name);
    end;
  end
  else
    Result := -1;
end;


// Return ELF hash value for NAME converted to lower case.
function ElfHashLowercase(Name: _PAnsiChr): Cardinal;
var
  g: Cardinal;
  c: _AnsiChr;
begin
  Result := 0;
  while name^ <> #0 do
  begin
    c := name^;
    c := _AnsiChr(towlower(UCS4Char(c)));
    Result := (Result shl 4) + Ord(c);
    g := Result and $f0000000;
    Result := (Result xor (g shr 24)) and not g;
    Inc(name);
  end;
end;

type
  PFindResourceCache = ^TFindResourceCache;
  TFindResourceCache = record
    ModuleHandle: HMODULE;
    Version: Cardinal;
    ResourceHeader: PResourceHeader;
    SymbolTable: PResourceSymTab;
    StringTable: _PAnsiChr;
    BaseAddress: Pointer;
    Hashtable: PHashtable;
  end;

threadvar
  FindResourceCache: TFindResourceCache;

function GetResourceCache(ModuleHandle: HMODULE): PFindResourceCache;
var
  info: dl_info;
begin
  Result := @FindResourceCache;
  if (ModuleHandle <> Result^.ModuleHandle) or (ModuleCacheVersion <> Result^.Version) then
  begin
    Result^.ResourceHeader := dlsym(ModuleHandle, sResSymExport);
    Result^.SymbolTable := PResourceSymTab((PByte(Result^.ResourceHeader) +
                                               SizeOf(TResourceHeader)));
    Result^.StringTable := _PAnsiChr((PByte(Result^.ResourceHeader) +
                                         SizeOf(TResourceHeader) +
                                         SizeOf(TResourceSym) * Result^.ResourceHeader^.SymbolCount));
    Result^.ModuleHandle := ModuleHandle;
    if (dladdr(UIntPtr(Result^.ResourceHeader), Info) = 0) or (Info.dli_fbase = ExeBaseAddress) then
      Result^.BaseAddress := nil   // if it's not in a library, assume the exe
    else
      Result^.BaseAddress := Info.dli_fbase;
    Result^.Version := ModuleCacheVersion;
    Result^.Hashtable := PHashtable( PByte(Result^.ResourceHeader)
                                        +  Result^.ResourceHeader^.HashtableOffset);
  end;
end;

// UCS4cToUTF8c matches code in util-common, and must be kept in sync.
function UCS4cToUTF8c(Dest: _PAnsiChr; Src: UInt32): Integer;
begin
  if ((Src and not $7F) = 0) then
  begin
    Dest^ := _AnsiChr(Src);
    Result := 1;
  end
  else if ((Src and not $7FF) = 0) then
  begin
    Dest^ := _AnsiChr($C0 or (Src shr 6));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or (Src and $3F));
    Result := 2;
  end
  else if ((Src and not $FFFF) = 0) then
  begin
    Dest^ := _AnsiChr($E0 or (Src shr 12));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 6) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or (Src and $3F));
    Result := 3;
  end
  else if ((Src and not $1FFFFF) = 0) then
  begin
    Dest^ := _AnsiChr($F0 or (Src shr 18));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 12) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 6) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or (Src and $3F));
    Result := 4;
  end
  else if ((Src and not $3FFFFFF) = 0) then
  begin
    Dest^ := _AnsiChr($F8 or (Src shr 24));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 18) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 12) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 16) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or (Src and $3F));
    Result := 5;
  end
  else if ((Src and not $7FFFFFFFF) = 0) then
  begin
    Dest^ := _AnsiChr($F0 or (Src shr 30));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 24) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 18) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 12) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or ((Src shr 16) and $3F));
    Inc(Dest);
    Dest^ := _AnsiChr($80 or (Src and $3F));
    Result := 6;
  end
  else
     Result := -1;
end;

function FindResource(ModuleHandle: HMODULE; ResourceName: PChar; ResourceType: PChar): TResourceHandle;
var
  ResCacheEntry: PFindResourceCache;
  nid, tid: Integer;
  ucs2_key: array [0..2] of WideChar;
  key: array [0..127] of _AnsiChr;
  len: Integer;
  pc: _PAnsiChr;
  ch: _AnsiChr;
  symName: _PAnsiChr;
  utf8ResName: _PAnsiChr;
  I: Integer;
  syndx: Cardinal;
begin
  Result := 0;
  if ResourceName = nil then Exit;
  ResCacheEntry := GetResourceCache(ModuleHandle);

  tid := NameToId (ResourceType);
  if tid = -1 then Exit;  { not supported (yet?) }

  { This code must match util-common/elfres.c }
  nid := NameToId (ResourceName);
  if nid = -1 then
  begin
    ucs2_key[0] := WideChar(2*tid+2);
    ucs2_key[1] := WideChar(0);
    len := UCS4cToUTF8c(key, 2*tid+2);
    pc := key+len;
    utf8ResName := _PAnsiChr(_AnsiStr(ResourceName));
    while Ord(utf8ResName^) <> 0 do
    begin
      ch := utf8ResName^;
      if Ord(ch) > 127 then exit; { insist on 7bit ASCII for now }
      if ('A' <= ch) and (ch <= 'Z') then Inc(ch, Ord('a') - Ord('A'));
      pc^ := ch;
      inc (pc);
      if pc = key + SizeOf(key) then exit;
      inc (utf8ResName);
    end;
    pc^ := Char(0);
  end
  else
  begin
    len := UCS4cToUTF8c(key, 2*tid+1);
    len := len + UCS4cToUTF8c(key + len, nid);
    key[len] := #0;
  end;

  with ResCacheEntry^ do
  begin
    syndx := ElfHashLowercase(key) mod Hashtable^.Size;
    I := Hashtable^.Entries[syndx];
    while I <> -1 do
    begin
      symName := StringTable + SymbolTable[I].Name;
      if (strcasecmp(key, symName) = 0) then
      begin
        Result := TResourceHandle(@SymbolTable[I]);
        Exit;
      end
      else
      begin
        I := SymbolTable[I].Chain;
      end;
    end;
  end;

end;

function LoadResource(ModuleHandle: HMODULE; ResHandle: TResourceHandle): HGLOBAL;
var
  ResCacheEntry: PFindResourceCache;
begin
  if ResHandle <> 0 then
  begin
    ResCacheEntry := GetResourceCache(ModuleHandle);
    Result := HGLOBAL(PResourceSym(ResHandle)^.Data + HGLOBAL(ResCacheEntry^.ResourceHeader));
  end
  else
    Result := 0;
end;

function SizeofResource(ModuleHandle: HMODULE; ResHandle: TResourceHandle): Integer;
begin
  if ResHandle <> 0 then
    Result := PResourceSym(ResHandle)^.Size
  else
    Result := 0;
end;

function LockResource(ResData: HGLOBAL): Pointer;
begin
  Result := Pointer(ResData);
end;

function UnlockResource(ResData: HGLOBAL): LongBool;
begin
  Result := False;
end;

function FreeResource(ResData: HGLOBAL): LongBool;
begin
  Result := True;
end;
{$ENDIF POSIX and !EXTERNALLINKER}

{ ResString support function }

{$IFDEF MSWINDOWS}
function LoadResString(ResStringRec: PResStringRec): string;
var
  Buffer: array [0..4095] of Char;
begin
  if ResStringRec = nil then Exit;
  if ResStringRec.Identifier < 64*1024 then
    SetString(Result, Buffer,
      LoadString(FindResourceHInstance(ResStringRec.Module^),
        ResStringRec.Identifier, Buffer, Length(Buffer)))
  else
    Result := PChar(ResStringRec.Identifier);
end;
{$ENDIF}

{$IF (defined(POSIX) and (not defined(EXTERNALLINKER)))}
const
  ResStringTableLen = 16;

type
  ResStringTable = array [0..ResStringTableLen-1] of UInt32;

function LoadResString(ResStringRec: PResStringRec): string;
var
  Handle: TResourceHandle;
  Tab: ^ResStringTable;
  ResMod: HMODULE;
  blk: Integer;
begin
  if ResStringRec = nil then Exit;
  ResMod := FindResourceHInstance(ResStringRec^.Module^);
  //P := GetResourceCache(ModuleHandle);
  blk := ResStringRec^.Identifier div ResStringTableLen;
  if blk = 0 then    // can't pass 'nil' to FindResource. use alternate scheme for 0 instead
    Handle := FindResource(ResMod, '#0', PChar(6)) // RT_STRING
  else
    Handle := FindResource(ResMod,
//         PChar(ResStringRec^.Identifier),
       PChar(PByte(blk)),
//       PChar(((blk + 1) shl 16) or $FFFF),
       PChar(6));   // RT_STRING
  Tab := Pointer(LoadResource(ResMod, Handle));
  if Tab = nil then
    Result := ''
  else
  begin
    Result := PWideChar(_PAnsiChr(Tab) + Tab[ResStringRec^.Identifier mod ResStringTableLen]);
  end;
end;
{$ENDIF POSIX and !EXTERNALLINKER}

{$IF defined(EXTERNALLINKER)}
function LoadResString(ResStringRec: PResStringRec): string;
type
  TWCharArray = array[0..$FFFF] of WideChar;
  PResStringResource = ^TResStringResource;
  TResStringResource = packed record
    Len: Word;
    case Integer of
    0: ( CharData: TWCharArray; );
    1: ( LongLen: UInt32;
         LongCharData: TWCharArray; );
  end;
var
  Handle: NativeUInt;
  P: PResStringResource;
  L: Integer;
begin
  Result := '';
  if ResStringRec <> nil then
  begin
    Handle := RTLD_DEFAULT;
    dlerror;   // clear error state;  dlsym doesn't
    P := dlsym(Handle, ResStringRec^.Key);
    if (P <> nil) and (dlerror = nil) then
    begin
      L := P^.Len;
      if L <> $FFFF then
        SetString(Result, P^.CharData, L)
      else
        SetString(Result, P^.LongCharData, P^.LongLen);
    end;
  end;
end;

function FindResource(ModuleHandle: HMODULE; ResourceName: PChar; ResourceType: PChar): TResourceHandle;
const
  ResMangles: array[1..24] of string = ('6CURSOR', '6BITMAP', '4ICON', '4MENU',
    '6DIALOG', '6STRING', '7FONTDIR', '4FONT', '11ACCELERATOR', '6RCDATA',
    '12MESSAGETABLE', '12GROUP_CURSOR', '', '9GROUP_ICON', '', '7VERSION',
    '10DLGINCLUDE', '', '8PLUGPLAY', '3VXD', '9ANICURSOR', '7ANIICON', '4HTML', '8MANIFEST');
  ManglePrefix = '__rsrc_N';
  MangleSuffix = 'E';
var
  Mangle: TPtrWrapper;
  ResType: NativeInt;
  ResName: PChar;
  NameLength: Integer;
  LowerName: string;
  Ch: Integer;
begin
  Result := 0;
  ResType := NativeInt(ResourceType);
  if (ResType >= Low(ResMangles)) and (ResType <= High(ResMangles)) then
  begin
    LowerName := string(ResourceName);
    ResName := PChar(LowerName);
    while Ord(ResName^) <> 0 do
    begin
      Ch := Ord(ResName^);
      if (Ch >= Ord('A')) and (Ch <= Ord('Z')) then
        ResName^ := Chr(Ch or $0020);
      Inc(ResName);
    end;
    NameLength := Length(UTF8Encode(LowerName));  // We need the length of utf8 characters
    Mangle := TMarshal.AllocStringAsUtf8(ManglePrefix + ResMangles[ResType] +
      string(_Str0Int64(NameLength)) + LowerName + MangleSuffix);
    Result := NativeUInt(dlsym(RTLD_DEFAULT, Mangle.ToPointer));
    if Result > 0 then
      Inc(Result, SizeOf(Integer)); // 32-bit data size
    TMarshal.FreeMem(Mangle);
  end;
end;

function LoadResource(ModuleHandle: HMODULE; ResHandle: TResourceHandle): HGLOBAL;
begin
  Result := ResHandle;
end;

function SizeofResource(ModuleHandle: HMODULE; ResHandle: TResourceHandle): Integer;
begin
  if ResHandle > 0 then
    Result := PInteger(PByte(ResHandle) - SizeOf(Integer))^
  else
    Result := 0;
end;

function LockResource(ResData: HGLOBAL): Pointer;
begin
  Result := Pointer(ResData);
end;

function UnlockResource(ResData: HGLOBAL): LongBool;
begin
  Result := False;
end;

function FreeResource(ResData: HGLOBAL): LongBool;
begin
  Result := True;
end;
{$ENDIF !EXTERNALLINKER}

{$IFDEF LINUX}
{ The Win32 program loader sets up the first 64k of process address space
  with no read or write access, to help detect use of invalid pointers
  (whose integer value is 0..64k).  Linux doesn't do this.  Mac OS/X
  does allow this, and the linker will ensure that this is the case by
  reserving 64k at the start of the image.

  Parts of the Delphi RTL and IDE design environment
  rely on the notion that pointer values in the [0..64k] range are
  invalid pointers.  To accomodate this in Linux, we reserve the range
  at startup.  If the range is already allocated, we keep going anyway. }

var
  ZeroPageReserved: Boolean = False;

procedure ReserveZeroPage;
const
  PROT_NONE = 0;
  MAP_PRIVATE   = $02;
  MAP_FIXED     = $10;
  MAP_ANONYMOUS = $20;
var
  P: Pointer;
begin
  if IsLibrary then Exit;  // page reserve is app's job, not .so's

  if not ZeroPageReserved then
  begin
    P := mmap(nil, High(Word), PROT_NONE,
      MAP_ANONYMOUS or MAP_PRIVATE or MAP_FIXED, 0, 0);
    ZeroPageReserved := P = nil;
    if (IntPtr(P) <> -1) and (P <> nil) then  // we didn't get it
      munmap(P, High(Word));
  end;
end;

procedure ReleaseZeroPage;
begin
  if ZeroPageReserved then
  begin
    munmap(nil, High(Word) - 4096);
    ZeroPageReserved := False;
  end;
end;
{$ENDIF LINUX}

var
  xxNull: UCS4Char = 0;
  xxPNull: PUCS4Char = @xxNull;

function PUCS4Chars(const S: UCS4String): PUCS4Char;
begin
  if Length(S) > 0 then
    Result := @S[0]
  else
    Result := xxPNull;
end;

function WideStringToUCS4String(const S: _WideStr): UCS4String;
const
  Offset = Low(_WideStr);
var
  I: Integer;
  CharCount: Integer;
begin
  CharCount := 0;
  SetLength(Result, Length(S) + 1);
  I := Offset;

  while I < (Length(S) + Offset) do
  begin

    if ((S[I] >= #$D800) and (S[I] <= #$DFFF)) and (I < Length(S)) then
    begin
      Result[CharCount] := UCS4Char((Cardinal(S[I]) and $000003FF) shl 10 or (Cardinal(S[I + 1]) and $000003FF) + $00010000);
      Inc(I);
    end
    else
      Result[CharCount] := UCS4Char(S[I]);
    Inc(CharCount);
    Inc(I);
  end;
  Result[CharCount] := 0;
  SetLength(Result, CharCount + 1);
end;

function UCS4StringToWideString(const S: UCS4String): _WideStr;
var
  I: Integer;
  CharCount: Integer;
begin
  SetLength(Result, Length(S) * 2 - 1); //Maximum possible number of characters
  CharCount := 0;

  I := 0;
  while I < Length(S) - 1 do
  begin
    if S[I] >= $10000 then
    begin
      Inc(CharCount);
      Result[CharCount] := WideChar((((S[I] - $00010000) shr 10) and $000003FF) or $D800);
      Inc(CharCount);
      Result[CharCount] := WideChar(((S[I] - $00010000) and $000003FF)or $DC00);
    end
    else
    begin
      Inc(CharCount);
      Result[CharCount] := WideChar(S[I]);
    end;

    Inc(I);
  end;

  SetLength(Result, CharCount);
end;

{$IFDEF POSIX}
type
  TCodePageMapEntry = record
    LocaleName: string;
    CodePage: Cardinal;
  end;

const
  // Predefined set of Name <=> CP mappings for POSIX
  CodePageMapA: array[0..2] of TCodePageMapEntry = (
    (LocaleName: 'ar'; CodePage: 1256),
    (LocaleName: 'az-cyrl'; CodePage: 1251),
    (LocaleName: 'az-latn'; CodePage: 1254));

  CodePageMapBC: array[0..2] of TCodePageMapEntry = (
    (LocaleName: 'be'; CodePage: 1251),
    (LocaleName: 'bg'; CodePage: 1251),
    (LocaleName: 'cs'; CodePage: 1250));

  CodePageMapEF: array[0..2] of TCodePageMapEntry = (
    (LocaleName: 'el'; CodePage: 1253),
    (LocaleName: 'et'; CodePage: 1257),
    (LocaleName: 'fa'; CodePage: 1256));

  CodePageMapH: array[0..2] of TCodePageMapEntry = (
    (LocaleName: 'he'; CodePage: 1255),
    (LocaleName: 'hr'; CodePage: 1250),
    (LocaleName: 'hu'; CodePage: 1250));

  CodePageMapJK: array[0..2] of TCodePageMapEntry = (
    (LocaleName: 'ja'; CodePage: 932),
    (LocaleName: 'kk'; CodePage: 1251),
    (LocaleName: 'ko'; CodePage: 949));

  CodePageMapLM: array[0..2] of TCodePageMapEntry = (
    (LocaleName: 'lt'; CodePage: 1257),
    (LocaleName: 'lv'; CodePage: 1257),
    (LocaleName: 'mk'; CodePage: 1251));

  CodePageMapP: array[0..1] of TCodePageMapEntry = (
    (LocaleName: 'pa-arab'; CodePage: 1256),
    (LocaleName: 'pl'; CodePage: 1250));

  CodePageMapR: array[0..1] of TCodePageMapEntry = (
    (LocaleName: 'ro'; CodePage: 1250),
    (LocaleName: 'ru'; CodePage: 1251));

  CodePageMapS: array[0..4] of TCodePageMapEntry = (
    (LocaleName: 'sk'; CodePage: 1250),
    (LocaleName: 'sl'; CodePage: 1250),
    (LocaleName: 'sq'; CodePage: 1250),
    (LocaleName: 'sr-cyrl'; CodePage: 1251),
    (LocaleName: 'sr-latn'; CodePage: 1250));

  CodePageMapT: array[0..1] of TCodePageMapEntry = (
    (LocaleName: 'th'; CodePage: 874),
    (LocaleName: 'tr'; CodePage: 1254));

  CodePageMapUV: array[0..5] of TCodePageMapEntry = (
    (LocaleName: 'uk'; CodePage: 1251),
    (LocaleName: 'ur'; CodePage: 1256),
    (LocaleName: 'uz-arab'; CodePage: 1256),
    (LocaleName: 'uz-cyrl'; CodePage: 1251),
    (LocaleName: 'uz-latn'; CodePage: 1254),
    (LocaleName: 'vi'; CodePage: 1258));

  // Special case - needs full LANG_CNTRY to determine proper codepage
  CodePageMapZH: array[0..6] of TCodePageMapEntry = (
    (LocaleName: 'zh_cn'; CodePage: 936),
    (LocaleName: 'zh_hk'; CodePage: 950),
    (LocaleName: 'zh-hans_hk'; CodePage: 936),
    (LocaleName: 'zh_mo'; CodePage: 950),
    (LocaleName: 'zh-hans_mo'; CodePage: 936),
    (LocaleName: 'zh_sg'; CodePage: 936),
    (LocaleName: 'zh_tw'; CodePage: 950));

function GetPosixLocaleName: string;
{$IFDEF MACOS}
var
  Locale: CFLocaleRef;
begin
  Locale := CFLocaleCopyCurrent;
  try
    Result := StringRefToString(CFLocaleGetIdentifier(Locale));
  finally
    CFRelease(Locale);
  end;
end;
{$ELSEIF defined(ANDROID)}
begin
  Result := GetAndroidLocaleName;
end;
{$ELSEIF defined(LINUX)}
const
  defaultLocale = 'en_US';
var
  Env: _PAnsiChr;
  Temp: Pointer;
  I, Len: Integer;
  LHasDot: Boolean;
begin
  LHasDot := False;
  Env := getenv(_PAnsiChr('LANG')); // do not localize
  if Env = nil then
    Env := defaultLocale;

  // LANG environment variable is treated as 7-bit ASCII encoding
  Len := 0;
  while (Env[Len] <> #0) and (Env[Len] <> '.') do
  begin
    Inc(Len);
    if Env[Len] = '.' then
      LHasDot := True;
  end;

  Temp := _NewUnicodeString(Len);
  for I := 0 to Len - 1 do
    PWideChar(Temp)[I] := WideChar(Ord(Env[I]));

  _UStrClr(Result);
  Pointer(Result) := Temp;
  if LHasDot then
    Result := Result + '.utf8';
end;
{$ELSE !MACOS and !ANDROID and !LINUX}
begin
  Error(rePlatformNotImplemented);
end;
{$ENDIF !MACOS and !ANDROID and !LINUX}

function GetACP: Cardinal;

  function FindCodePage(const Name: string; const Map: array of TCodePageMapEntry;
    var CodePage: Cardinal): Boolean;
  var
    I: Integer;
  begin
    for I := Low(Map) to High(Map) do
      if Map[I].LocaleName = Name then
      begin
        CodePage := Map[I].CodePage;
        Exit(True);
      end;
    Result := False;
  end;

var
  I: Integer;
  LName: string;
  LCodePage: Cardinal;
begin
  LName := GetPosixLocaleName;
  I := Low(string);
  while I <= High(LName) do
  begin
    if _AnsiChr(LName[I]) in ['A'..'Z'] then         // do not localize
      Inc(LName[I], Ord('a') - Ord('A'))   // do not localize
    else if LName[I] = '_' then            // do not localize
    begin
      SetLength(LName, I - Low(string));
      Break;
    end;
    Inc(I);
  end;

  Result := 1252; // Default codepage
  if Length(LName) > 0 then
    case LName[Low(string)] of
      'a':
        if FindCodePage(LName, CodePageMapA, LCodePage) then
          Result := LCodePage;
      'b','c':
        if FindCodePage(LName, CodePageMapBC, LCodePage) then
          Result := LCodePage;
      'e','f':
        if FindCodePage(LName, CodePageMapEF, LCodePage) then
          Result := LCodePage;
      'h':
        if FindCodePage(LName, CodePageMapH, LCodePage) then
          Result := LCodePage;
      'j','k':
        if FindCodePage(LName, CodePageMapJK, LCodePage) then
          Result := LCodePage;
      'l','m':
        if FindCodePage(LName, CodePageMapLM, LCodePage) then
          Result := LCodePage;
      'p':
        if FindCodePage(LName, CodePageMapP, LCodePage) then
          Result := LCodePage;
      'r':
        if FindCodePage(LName, CodePageMapR, LCodePage) then
          Result := LCodePage;
      's':
        if FindCodePage(LName, CodePageMapS, LCodePage) then
          Result := LCodePage;
      't':
        if FindCodePage(LName, CodePageMapT, LCodePage) then
          Result := LCodePage;
      'u','v':
        if FindCodePage(LName, CodePageMapUV, LCodePage) then
          Result := LCodePage;
      'z':
        begin
          LName := GetPosixLocaleName;
          I := Low(string);
          while I <= High(LName) do
          begin
            if _AnsiChr(LName[I]) in ['A'..'Z'] then         // do not localize
              Inc(LName[I], Ord('a') - Ord('A'))   // do not localize
            else if LName[I] = '@' then            // do not localize
            // Non Gregorian calendars include "@calendar=<calendar>" on MACOS
            begin
              SetLength(LName, I - Low(string));
              Break;
            end;
            Inc(I);
          end;
          if FindCodePage(LName, CodePageMapZH, LCodePage) then
            Result := LCodePage
          else if (Length(LName) >= 2) and (LName[Low(string) + 1] = 'h') then
            // Fallback for Chinese in countries other than cn, hk, mo, tw, sg
            Result := 936;
        end;
    end;
end;
{$ENDIF POSIX}

function LocaleCharsFromUnicode(CodePage, Flags: Cardinal;
  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAnsiChr;
  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar: PLongBool): Integer; overload;
{$IFDEF MSWINDOWS}
begin
  Result := WideCharToMultiByte(CodePage, Flags, UnicodeStr, UnicodeStrLen, LocaleStr,
    LocaleStrLen, DefaultChar, PBOOL(UsedDefaultChar));
end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  Result := LocaleCharsFromUnicode(LocaleNameFromCodePage(CodePage), Flags,
    UnicodeStr, UnicodeStrLen, LocaleStr, LocaleStrLen, DefaultChar, UsedDefaultChar);
end;
{$ENDIF POSIX}

function UnicodeFromLocaleChars(CodePage, Flags: Cardinal; LocaleStr: _PAnsiChr;
  LocaleStrLen: Integer; UnicodeStr: PWideChar; UnicodeStrLen: Integer): Integer; overload;
{$IFDEF MSWINDOWS}
begin
  Result := MultiByteToWideChar(CodePage, Flags, LocaleStr, LocaleStrLen, UnicodeStr, UnicodeStrLen);
end;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
begin
  Result := UnicodeFromLocaleChars(LocaleNameFromCodePage(CodePage), Flags, LocaleStr, LocaleStrLen, UnicodeStr, UnicodeStrLen);
end;
{$ENDIF POSIX}

{$IFDEF POSIX}
const
  MB_ERR_INVALID_CHARS = 8;

{$IFDEF USE_LIBICU}
threadvar
  LastConverter: PUConverter;
  LastConverterName: _AnsiStr;


type
  SubContext = record
    Sub: Byte;
    Used: Boolean;
  end;

procedure UcnvFromUCallbackSubstitute(const context: Pointer; fromArgs: PUConverterFromUnicodeArgs;
  const codeUnits: PUChar; length: Int32; codePoint: UChar32; reason: UConverterCallbackReason; var Err: UErrorCode);cdecl;
begin
  if reason <= UCNV_CB_IRREGULAR then
  begin
    Err := U_ZERO_ERROR;
    SubContext(context^).Used := True;
    ucnv_cbFromUWriteBytes(fromArgs, @SubContext(context^).Sub, 1, 0, Err);

    if Err <= U_ZERO_ERROR then
      Err := UErrorCode(-1000); // We return -1000 to identify a bad encoding
  end;
end;

procedure UcnvFromUCallbackErrorEncoding(const context: Pointer; fromArgs: PUConverterFromUnicodeArgs;
  const codeUnits: PUChar; length: Int32; codePoint: UChar32; reason: UConverterCallbackReason; var Err: UErrorCode);cdecl;
begin
  if reason <= UCNV_CB_IRREGULAR then
  begin
    if (context = nil) or
       ((Ord(PByte(context)^) = UCNV_PRV_STOP_ON_ILLEGAL) and (reason = UCNV_CB_UNASSIGNED)) then
    begin
      Err := UErrorCode(1000); // We return 1000 to identify a bad encoding and stop converting
    end;
  end;
end;


{$ENDIF USE_LIBICU}

function LocaleCharsFromUnicode(const LocaleName: _AnsiStr; Flags: Cardinal;
  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAnsiChr;
  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar: PLongBool): Integer; overload;
{$IFDEF USE_LIBICU}
var
  Err: UErrorCode;
  Conv: PUConverter;
  NSubs: Int32;
  sub: UChar32;
  ctx: SubContext;
begin
  Result := 0;
  // DefaultChar and UsedDefaultChar are not valid with UTF-7 or UTF-8
  if ((DefaultChar <> nil) or (UsedDefaultChar <> nil)) and
     ((LocaleName = 'UTF-8') or (LocaleName = 'UTF-7')) then // do not localize
    Exit(0);

  // When UnicodeStrLen is -1 treat UnicodeStr as a null terminated string
  if UnicodeStrLen = -1 then
    UnicodeStrLen := Length(UnicodeStr);

  Err := 0;
  if LocaleName = 'UTF-8' then
  begin
    if DefaultChar = nil then
      sub := UChar32('?')
    else
      sub := UChar32(DefaultChar^);
    u_strToUTF8WithSub(LocaleStr, LocaleStrLen, Result, UnicodeStr, UnicodeStrLen, sub, NSubs, Err);
    if (LocaleStrLen > 0) and (Err > 0) then Result := 0;
    if (NSubs > 0) and (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) then
      Result := 0; // Return 0 if an invalid character was found
    if (UsedDefaultChar <> nil) then
      UsedDefaultChar^ := (NSubs > 0);
  end
  else
  begin
    if (LastConverter = nil) or (LastConverterName <> LocaleName) then   // Cached last converter
    begin
      Conv := ucnv_open(_PAnsiChr(LocaleName), Err);

      if Err > 0 then Exit;

      if LastConverter <> nil then
        ucnv_close(LastConverter);

      LastConverter := Conv;
      LastConverterName := LocaleName;
    end
    else
    begin
      Conv := LastConverter;
      ucnv_reset(Conv);
    end;

    Err := U_ZERO_ERROR;
    if (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) then
      ucnv_setFromUCallBack(Conv, @UcnvFromUCallbackErrorEncoding, nil, nil, nil, Err)
    else
    begin
      if DefaultChar = nil then
        ctx.Sub := Ord('?')
      else
        ctx.Sub := Byte(DefaultChar^);
      ctx.Used := False;
      ucnv_setFromUCallBack(Conv, @UcnvFromUCallbackSubstitute, @ctx, nil, nil, Err);
    end;

    Err := U_ZERO_ERROR;
    Result := ucnv_fromUChars(Conv, LocaleStr, LocaleStrLen, PUCHAR(UnicodeStr), UnicodeStrLen, Err);

    if ((LocaleStrLen > 0) and (Err > 0)) or (Err = 1000) then Result := 0;
    if (UsedDefaultChar <> nil) then
      UsedDefaultChar^ := ctx.Used;
  end;
end;
{$ELSE !USE_LIBICU}
var
  LContext: iconv_t;
  LSourcePtr, LDestPtr: Pointer;
  LCalcSizeBuf: array of _AnsiChr;
  LDestLen, LSourceLen, LSize: size_t;
  InvalidCharFound: Boolean;
  LastError: Integer;
begin
  Result := 0;
  // DefaultChar and UsedDefaultChar are not valid with UTF-7 or UTF-8
  if ((DefaultChar <> nil) or (UsedDefaultChar <> nil)) and
     ((LocaleName = 'UTF-8') or (LocaleName = 'UTF-7')) then // do not localize
    Exit(0);

  // When UnicodeStrLen is -1 treat UnicodeStr as a null terminated string
  if UnicodeStrLen = -1 then
    UnicodeStrLen := Length(UnicodeStr) + 1; // include terminating null

  LContext := iconv_open(_PAnsiChr(LocaleName), 'UTF-16LE'); // do not localize
  if LContext <> iconv_t(-1) then
    try
      // LocaleStrLen = 0 is a request to calculate the required buffer size,
      // use a local destination buffer for the conversion.
      if LocaleStrLen = 0 then
      begin
        SetLength(LCalcSizeBuf, 1024);
        LDestLen := Length(LCalcSizeBuf);
        LDestPtr := Pointer(@LCalcSizeBuf[0]);
      end
      else
      begin
        LDestLen := LocaleStrLen;
        LDestPtr := Pointer(LocaleStr);
      end;

      LSourceLen := UnicodeStrLen * SizeOf(WideChar);
      LSourcePtr := Pointer(UnicodeStr);

      LSize := 0;
      if UsedDefaultChar <> nil then
        UsedDefaultChar^ := False;

      InvalidCharFound := False;

      while True do
      begin
        Result := iconv(LContext, @LSourcePtr, @LSourceLen, @LDestPtr, @LDestLen);
        // This check is added because iconv returns success, but fails to decode the last character if it is
        // an upper char. Flushing the output buffer solves this issue.
        if (Result = 0) and (LocaleName = 'UTF-7') then
          Result := iconv(LContext, nil, nil, @LDestPtr, @LDestLen);
        if Result <> -1 then
          Break
        else
        begin
          LastError := GetLastError;
          if (LastError = E2BIG) or (LDestLen = 0) then
          begin
            if LocaleStrLen = 0 then
            begin
              // Save converted buffer size and reset to beginning of local buffer
              Inc(LSize, size_t(Length(LCalcSizeBuf)) - LDestLen);
              LDestPtr := Pointer(@LCalcSizeBuf[0]);
              LDestLen := Length(LCalcSizeBuf);
            end
            else
            begin
              LDestLen := LocaleStrLen; // Return a length of 0
              Break;
            end;
          end;
          case LastError of
            E2BIG: // Insufficient destination buffer
              ;
            EILSEQ: // Invalid character for destination character set
              begin
                // Increment pointers and insert '?' (or the DefaultChar
                // if specified) into the destination string.
                Inc(PByte(LSourcePtr), SizeOf(WideChar));
                Dec(LSourceLen, SizeOf(WideChar));
                if LocaleStrLen <> 0 then
                begin
                  if DefaultChar = nil then
                    _PAnsiChr(LDestPtr)^ := _AnsiChr('?') // do not localize
                  else
                    _PAnsiChr(LDestPtr)^ := DefaultChar^;
                  if UsedDefaultChar <> nil then
                    UsedDefaultChar^ := True;
                  InvalidCharFound := True;
                end;
                Inc(PByte(LDestPtr));
                Dec(LDestLen);
              end;
          else
            Exit(0); // Return a length of 0
          end;
        end;
      end;

      if InvalidCharFound and (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) then
        Exit(0); // Return 0 if an invalid character was encountered

      if LocaleStrLen = 0 then
        Result := LSize + size_t(Length(LCalcSizeBuf)) - LDestLen
      else
        Result := size_t(LocaleStrLen) - LDestLen
    finally
      iconv_close(LContext);
    end;
end;
{$ENDIF USE_LIBICU}

{$IFDEF USE_LIBICU}
procedure UcnvToUCallbackSubstitute(const context: Pointer; toArgs: PUConverterToUnicodeArgs;
  const codeUnits: MarshaledAString; length: Int32; reason: UConverterCallbackReason; var err: UErrorCode);cdecl;
var
  sub: Char;
begin
  if reason <= UCNV_CB_IRREGULAR then
  begin
    if (context = nil) or
      ( (Ord(PByte(context)^) = UCNV_PRV_STOP_ON_ILLEGAL) and (reason = UCNV_CB_UNASSIGNED) ) then
    begin
      sub:= '?';
      Err := U_ZERO_ERROR;
      ucnv_cbToUWriteUChars(toArgs, @sub, 1, 0, Err);
      if Err <= U_ZERO_ERROR then Err := UErrorCode(-1000); // We return -1000 to identify a bad encoding
    end;
  end;
end;

procedure UcnvToUCallbackErrorEncoding(const context: Pointer; toArgs: PUConverterToUnicodeArgs;
  const codeUnits: MarshaledAString; length: Int32; reason: UConverterCallbackReason; var err: UErrorCode);cdecl;
begin
  if reason <= UCNV_CB_IRREGULAR then
  begin
    if (context = nil) or
      ( (Ord(PByte(context)^) = UCNV_PRV_STOP_ON_ILLEGAL) and (reason = UCNV_CB_UNASSIGNED) ) then
    begin
      Err := UErrorCode(1000); // We return 1000 to identify a bad encoding and stop converting
    end;
  end;
end;
{$ENDIF USE_LIBICU}

function UnicodeFromLocaleChars(const LocaleName: _AnsiStr; Flags: Cardinal;
  LocaleStr: _PAnsiChr; LocaleStrLen: Integer; UnicodeStr: PWideChar;
  UnicodeStrLen: Integer): Integer; overload;
{$IFDEF USE_LIBICU}
var
  Err: UErrorCode;
  Conv: PUConverter;
  NSubs: Int32;
begin
  Result := 0;
  if LocaleName = 'UTF-8' then
  begin
    Err := U_ZERO_ERROR;
    u_strFromUTF8WithSub(UnicodeStr, UnicodeStrLen, Result, LocaleStr, LocaleStrLen, UChar32('?'), NSubs, Err);
    if (UnicodeStrLen > 0) and (Err > 0) then
      Result := 0;
    if (NSubs > 0) and (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) then
      Result := 0; // Return 0 if an invalid character was found
  end
  else
  begin
    if (LastConverter = nil) or (LastConverterName <> LocaleName) then   // Cached last converter
    begin
      Err := U_ZERO_ERROR;
      Conv := ucnv_open(_PAnsiChr(LocaleName), Err);

      if Err > 0 then Exit;
      if LastConverter <> nil then ucnv_close(LastConverter);
      LastConverter := Conv;
      LastConverterName := LocaleName;
    end
    else
    begin
      Conv := LastConverter;
      ucnv_reset(Conv);
    end;
    Err := U_ZERO_ERROR;
    if (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) then
      ucnv_setToUCallBack(Conv, @UcnvToUCallbackErrorEncoding, nil, nil, nil, Err)
    else
      ucnv_setToUCallBack(Conv, @UcnvToUCallbackSubstitute, nil, nil, nil, Err);

    Err := U_ZERO_ERROR;
    Result := ucnv_toUChars(Conv, UnicodeStr, UnicodeStrLen, LocaleStr, LocaleStrLen, Err);

    if ((UnicodeStrLen > 0) and (Err > 0)) or (Err = 1000) then Result := 0;
  end;
end;
{$ELSE !USE_LIBICU}
var
  LContext: iconv_t;
  InvalidCharFound: Boolean;
  LCalcSizeBuf: array of Byte;
  LDestLen, LSourceLen, LSize, LZero: size_t;
  LSourcePtr, LDestPtr, LNil, LastInvalidChar: Pointer;
  LastError: Integer;
begin
  Result := 0;
  LContext := iconv_open('UTF-16LE', _PAnsiChr(LocaleName)); // do not localize
  if LContext <> iconv_t(-1) then
    try
      // When LocaleStrLen is -1 treat LocaleStr as a null terminated string
      if LocaleStrLen = -1 then
        LocaleStrLen := Length(LocaleStr) + 1; // include terminating null

      // UnicodeStrLen = 0 is a request to calculate the required buffer size,
      // use a local destination buffer for the conversion.
      if UnicodeStrLen = 0 then
      begin
        SetLength(LCalcSizeBuf, 1024);
        LDestLen := Length(LCalcSizeBuf);
        LDestPtr := Pointer(@LCalcSizeBuf[0]);
      end
      else
      begin
        LDestLen := UnicodeStrLen * SizeOf(WideChar);
        LDestPtr := Pointer(UnicodeStr);
      end;

      LSourceLen := LocaleStrLen;
      LSourcePtr := Pointer(LocaleStr);

      LSize := 0;
      LastInvalidChar := nil;
      InvalidCharFound := False;

      while True do
      begin
        Result := iconv(LContext, @LSourcePtr, @LSourceLen, @LDestPtr, @LDestLen);
        if Result <> -1 then
          Break
        else
        begin
          LastError := GetLastError;
          if (LastError = E2BIG) or (LDestLen = 0) then
          begin
            if UnicodeStrLen = 0 then
            begin
              // Save converted buffer size and reset to beginning of local buffer
              Inc(LSize, size_t(Length(LCalcSizeBuf)));
              LDestPtr := Pointer(@LCalcSizeBuf[0]);
              LDestLen := Length(LCalcSizeBuf);
            end
            else
            begin
              // Return a length of Original
              LDestLen := UnicodeStrLen * SizeOf(WideChar);
              Break;
            end;
          end;
          case GetLastError of
            E2BIG: // Insufficient destination buffer
              ;
            EILSEQ: // Invalid character sequence in source string
              if LocaleName = 'UTF-7' then // do not localize
              begin
                // Special case for emulating MultiByteToWideChar with UTF-7.
                // This does not produce an exact match due to differences in the
                // decoders, but it preserves similar behaviour.
                if (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) then
                  Exit(0);
                Inc(PByte(LSourcePtr), SizeOf(_AnsiChr));
                Dec(LSourceLen, SizeOf(_AnsiChr));
                // Reset state of context
                LNil := nil;
                LZero := 0;
                iconv(LContext, @LNil, @LZero, @LNil, @LZero);
              end
              else
              begin
                // Increment pointers and insert #$FFFD into the destination
                // string if the source is a UTF-8 string. Only insert #$FFFD
                // once per invalid UTF-8 character.
                if LSourcePtr <> LastInvalidChar then
                begin
                  if (UnicodeStrLen <> 0) then
                  begin
                    if LocaleName = 'UTF-8' then // do not localize
                      PWideChar(LDestPtr)^ := #$FFFD // Invalid UTF-8 char
                    else if LocaleName = 'ASCII' then // do not localize
                      PWord(LDestPtr)^ := Word(PByte(LSourcePtr)^) and $007F // emulate CP-20127
                    else
                      PWord(LDestPtr)^ := Word(PByte(LSourcePtr)^);
                  end;
                  Inc(PByte(LDestPtr), SizeOf(WideChar));
                  Dec(LDestLen, SizeOf(WideChar));
                end;
                Inc(PByte(LSourcePtr), SizeOf(_AnsiChr));
                Dec(LSourceLen, SizeOf(_AnsiChr));
                LastInvalidChar := LSourcePtr;
                InvalidCharFound := True;
              end;
          else
            Exit(0); // Return a length of 0
          end;
        end;
      end;

      if InvalidCharFound and (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) then
        Exit(0); // Return 0 if an invalid character was encountered

      if UnicodeStrLen = 0 then
        Result := (LSize + size_t(Length(LCalcSizeBuf)) - LDestLen) div SizeOf(WideChar)
      else
        Result := size_t(UnicodeStrLen) - (LDestLen div 2);
    finally
      iconv_close(LContext);
    end;
end;
{$ENDIF USE_LIBICU}
{$ENDIF POSIX}


procedure SetMultiByteConversionCodePage(CodePage: Integer);
begin
  DefaultSystemCodePage := CodePage;
end;

function GetCPUCount: Integer;
{$IFDEF MSWINDOWS}
var
  SysInfo: TSystemInfo;
begin
  GetSystemInfo(SysInfo);
  Result := SysInfo.dwNumberOfProcessors;
end;
{$ENDIF}
{$IFDEF POSIX}
begin
  Result := sysconf(_SC_NPROCESSORS_ONLN);
end;
{$ENDIF}

{$IFDEF MSWINDOWS}
procedure SetUtf8CompareLocale;
var
  OSVersion: Cardinal;
  MajorVersion: Cardinal;
  MinorVersion: Cardinal;
begin
  OSVersion := GetVersion;
  MajorVersion := OSVersion and $000000FF;
  MinorVersion := (OSVersion and $0000FF00) shr 8;

  if ((MajorVersion = 5) and (MinorVersion >= 1)) or
     (MajorVersion > 5) then
    UTF8CompareLocale := LOCALE_INVARIANT
  else
    UTF8CompareLocale := $0409;
end;
{$ENDIF MSWINDOWS}

{$IFDEF POSIX}
{$IF defined(USE_LIBICU)}
var
  InternalUTF8CompareCollator: PUCollator = nil;
  InternalUTF8CompareLocale: MarshaledAString = nil;

function UTF8CompareCollator: Pointer;
begin
  Result := InternalUTF8CompareCollator;
end;

function UTF8CompareLocale: MarshaledAString;
begin
  Result := InternalUTF8CompareLocale;
end;
{$ELSE}
var
  InternalUTF8CompareLocale: Pointer = nil;
  InternalUTF8CompareLocaleName: MarshaledAString = nil;

function UTF8CompareLocale: Pointer;
begin
  Result := InternalUTF8CompareLocale;
end;
function UTF8CompareLocaleName: MarshaledAString;
begin
  Result := InternalUTF8CompareLocaleName;
end;
{$ENDIF defined(USE_LIBICU)}

function SetUTF8CompareLocale(const LocaleName: string): Boolean;
var
  LNewLocale, OldLocale: Pointer;
{$IF defined(USE_LIBICU)}
  NewCollator, OldCollator: PUCollator;
  LocaleLength: Integer;
  ErrorCode: UErrorCode;
  LNewLocaleWrapper: TPtrWrapper;
{$ELSEIF defined(MACOS)}
  StringRef, LocaleIdent: CFStringRef;
{$ELSEIF defined(LINUX)}
  LocaleLength: Integer;
  LNewLocaleWrapper: TPtrWrapper;
  LNewLocaleName, OldLocaleName: MarshaledAString;
{$ENDIF}
begin
{$IF defined(USE_LIBICU)}
  if LocaleName = '' then
    LNewLocaleWrapper := TMarshal.AllocStringAsUtf8(GetPosixLocaleName)
  else
    LNewLocaleWrapper := TMarshal.AllocStringAsUtf8(LocaleName);
  LocaleLength := Length(MarshaledAString(LNewLocaleWrapper.ToPointer))+1;
  LNewLocale := System.AllocMem(LocaleLength);
  System.Move(LNewLocaleWrapper.ToPointer^, LNewLocale^, LocaleLength);
  TMarshal.FreeMem(LNewLocaleWrapper);

  // Create the Cached Collator for the New Locale
  ErrorCode := 0;
  OldCollator := nil;
  NewCollator := ucol_open(MarshaledAString(LNewLocale), ErrorCode);
  if ErrorCode > 0 then
  begin
    // If we cannot create a collator, create a default one from 'en_US'
    if NewCollator <> nil then ucol_close(NewCollator);
    ErrorCode := 0;
    NewCollator := ucol_open('en_US', ErrorCode); // Do not localize
  end;
  if ErrorCode <= 0 then
    OldCollator := AtomicExchange(InternalUTF8CompareCollator, NewCollator);
  if OldCollator <> nil then
    ucol_close(OldCollator);
{$ELSEIF defined(MACOS)}
  Result := False;
  LocaleIdent := CFSTR(LocaleName);
  if LocaleName = '' then
    LNewLocale := CFLocaleCopyCurrent
  else
  begin
    if LocaleIdent <> nil then
    try
      StringRef := CFLocaleCreateCanonicalLocaleIdentifierFromString(nil, LocaleIdent);
      if StringRef <> nil then
      try
        LNewLocale := CFLocaleCreate(nil, LocaleIdent);
      finally
        CFRelease(StringRef);
      end else
        Exit;
    finally
      CFRelease(LocaleIdent);
    end else
      Exit;
  end;
{$ELSEIF defined(LINUX)}
                                 
  if LocaleName = '' then
    LNewLocaleWrapper := TMarshal.AllocStringAsUtf8(GetPosixLocaleName)
  else
    LNewLocaleWrapper := TMarshal.AllocStringAsUtf8(LocaleName);
  LocaleLength := Length(MarshaledAString(LNewLocaleWrapper.ToPointer))+1;
  LNewLocaleName := System.AllocMem(LocaleLength);
  System.Move(LNewLocaleWrapper.ToPointer^, LNewLocaleName^, LocaleLength);
  TMarshal.FreeMem(LNewLocaleWrapper);

  LNewLocale := newlocale(LC_ALL_MASK, LNewLocaleName, nil);

{$ELSE !USE_LIBICU and !MACOS and !LINUX}

{$ENDIF !USE_LIBICU and !MACOS}
  Result := LNewLocale <> nil;
  if Result then
  begin
{$IF defined(LINUX)}
    OldLocaleName := AtomicExchange(InternalUTF8CompareLocaleName, LNewLocaleName);
    if OldLocaleName <> nil then
      FreeMem(OldLocaleName);
{$ENDIF defined(LINUX)}
    OldLocale := AtomicExchange(InternalUTF8CompareLocale, LNewLocale);
    if OldLocale <> nil then
{$IF defined(USE_LIBICU)}
      FreeMem(OldLocale);
{$ELSEIF defined(MACOS)}
      CFRelease(OldLocale);
{$ELSE !USE_LIBICU and !MACOS}
      freelocale(OldLocale);
{$ENDIF !USE_LIBICU and !MACOS }
  end
{$IF defined(LINUX)}
  else
    FreeMem(LNewLocaleName);
{$ENDIF defined(LINUX)}
end;
{$ENDIF POSIX}

class operator TGUID.Equal(const Left, Right: TGUID): Boolean;
{$IFDEF CPU64BITS}
var
  a, b: PInt64Array;
begin
  a := PInt64Array(@Left);
  b := PInt64Array(@Right);
  Result := (a^[0] = b^[0]) and (a^[1] = b^[1]);
end;
{$ELSE !CPU64BITS}
var
  a, b: PIntegerArray;
begin
  a := PIntegerArray(@Left);
  b := PIntegerArray(@Right);
  Result := (a^[0] = b^[0]) and (a^[1] = b^[1]) and (a^[2] = b^[2]) and (a^[3] = b^[3]);
end;
{$ENDIF !CPU64BITS}

class operator TGUID.NotEqual(const Left, Right: TGUID): Boolean;
begin
  Result := not (Left = Right);
end;

class function TGUID.Create(const Data; BigEndian: Boolean): TGUID;
begin
  Result := PGuid(@Data)^;
  if BigEndian then
  begin
    Result.D1 := (Swap(Word(Result.D1)) shl 16) or Swap(Word(Result.D1 shr 16));
    Result.D2 := Swap(Result.D2);
    Result.D3 := Swap(Result.D3);
  end;
end;

class function TGUID.Create(const Data: array of Byte; AStartIndex: Cardinal; BigEndian: Boolean): TGUID;
begin
  if Length(Data) < Integer(16 + AStartIndex) then
    Result := TGUID.Empty
  else
    Result := TGUID.Create(Data[AStartIndex], BigEndian);
end;

class function TGUID.Empty: TGUID;
begin
  FillChar(Result, Sizeof(Result), 0)
end;

{ TPtrWrapper }

constructor TPtrWrapper.Create(AValue: NativeInt);
begin
  Value := PByte(AValue);
end;

constructor TPtrWrapper.Create(AValue: Pointer);
begin
  Value := AValue;
end;

function TPtrWrapper.ToPointer: Pointer;
begin
  Result := Value;
end;

function TPtrWrapper.ToInteger: NativeInt;
begin
  Result := NativeInt(Value);
end;

class function TPtrWrapper.GetNilValue: TPtrWrapper;
begin
  Result.Value := nil;
end;

class operator TPtrWrapper.Equal(Left, Right: TPtrWrapper): Boolean;
begin
  Result := Left.Value = Right.Value;
end;

class operator TPtrWrapper.NotEqual(Left, Right: TPtrWrapper): Boolean;
begin
  Result := Left.Value <> Right.Value;
end;

{ TMarshal }

constructor TMarshal.Create;
begin
  Error(reInvalidPtr);
end;

class function TMarshal.InString(const S: string): MarshaledString;
begin
  Result := MarshaledString(S);
end;

class function TMarshal.OutString(const S: string): MarshaledString;
begin
  Result := MarshaledString(S);
end;

class function TMarshal.InOutString(const S: string): MarshaledString;
begin
  Result := MarshaledString(S);
end;

class function TMarshal.AsAnsi(const S: string): _AnsiStr;
begin
  Result := _AnsiStr(S);
end;

class function TMarshal.AsAnsi(S: PWideChar): _AnsiStr;
begin
  Result := _AnsiStr(S);
end;

class function TMarshal.AllocMem(Size: NativeInt): TPtrWrapper;
begin
  Result.Value := System.AllocMem(Size);
end;

class function TMarshal.ReallocMem(OldPtr: TPtrWrapper; NewSize: NativeInt): TPtrWrapper;
begin
  System.ReallocMem(OldPtr.Value, NewSize); // ReallocMem should take NativeInt not Integer
  Result := OldPtr;
end;

class procedure TMarshal.FreeMem(Ptr: TPtrWrapper);
begin
  System.FreeMem(Ptr.Value);
end;

class procedure TMarshal.Copy(Src: TArray<Byte>; StartIndex: Integer; Dest: TPtrWrapper;
  Count: Integer);
begin
  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0]));
end;

class procedure TMarshal.Copy(Src: TPtrWrapper; Dest: TArray<Byte>; StartIndex, Count: Integer);
begin
  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[0]));
end;

class procedure TMarshal.Copy(Src: TArray<Char>; StartIndex: Integer; Dest: TPtrWrapper;
  Count: Integer);
begin
  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0]));
end;

class procedure TMarshal.Copy(Src: TPtrWrapper; Dest: TArray<Char>; StartIndex, Count: Integer);
begin
  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[0]));
end;

class procedure TMarshal.Copy(Src: TArray<Word>; StartIndex: Integer; Dest: TPtrWrapper;
  Count: Integer);
begin
  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0]));
end;

class procedure TMarshal.Copy(Src: TPtrWrapper; Dest: TArray<Word>; StartIndex, Count: Integer);
begin
  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[0]));
end;

class procedure TMarshal.Copy(Src: TArray<Shortint>; StartIndex: Integer; Dest: TPtrWrapper;
  Count: Integer);
begin
  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0]));
end;

class procedure TMarshal.Copy(Src: TPtrWrapper; Dest: TArray<Shortint>; StartIndex, Count: Integer);
begin
  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[0]));
end;

class procedure TMarshal.Copy(Src: TArray<Smallint>; StartIndex: Integer; Dest: TPtrWrapper;
  Count: Integer);
begin
  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0]));
end;

class procedure TMarshal.Copy(Src: TPtrWrapper; Dest: TArray<Smallint>; StartIndex, Count: Integer);
begin
  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[0]));
end;

class procedure TMarshal.Copy(Src: TArray<Integer>; StartIndex: Integer; Dest: TPtrWrapper;
  Count: Integer);
begin
  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0]));
end;

class procedure TMarshal.Copy(Src: TPtrWrapper; Dest: TArray<Integer>; StartIndex, Count: Integer);
begin
  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[0]));
end;

class procedure TMarshal.Copy(Src: TArray<Int64>; StartIndex: Integer; Dest: TPtrWrapper;
  Count: Integer);
begin
  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0]));
end;

class procedure TMarshal.Copy(Src: TPtrWrapper; Dest: TArray<Int64>; StartIndex, Count: Integer);
begin
  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[0]));
end;

class procedure TMarshal.Copy(Src: TArray<TPtrWrapper>; StartIndex: Integer; Dest: TPtrWrapper;
  Count: Integer);
begin
  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0]));
end;

class procedure TMarshal.Copy(Src: TPtrWrapper; Dest: TArray<TPtrWrapper>;
  StartIndex, Count: Integer);
begin
  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[0]));
end;

class function TMarshal.ReadByte(Ptr: TPtrWrapper; Ofs: NativeInt): Byte;
begin
  Result := PByte(Ptr.Value + Ofs)^;
end;

class function TMarshal.ReadInt16(Ptr: TPtrWrapper; Ofs: NativeInt): Smallint;
begin
  Result := PSmallint(Ptr.Value + Ofs)^;
end;

class function TMarshal.ReadInt32(Ptr: TPtrWrapper; Ofs: NativeInt): Integer;
begin
  Result := PInteger(Ptr.Value + Ofs)^;
end;

class function TMarshal.ReadInt64(Ptr: TPtrWrapper; Ofs: NativeInt): Int64;
begin
  Result := PInt64(Ptr.Value + Ofs)^;
end;

class function TMarshal.ReadPtr(Ptr: TPtrWrapper; Ofs: NativeInt): TPtrWrapper;
begin
  Result.Value := PPointer(Ptr.Value + Ofs)^;
end;

class procedure TMarshal.WriteByte(Ptr: TPtrWrapper; Value: Byte);
begin
  PByte(Ptr.Value)^ := Value;
end;

class procedure TMarshal.WriteByte(Ptr: TPtrWrapper; Ofs: NativeInt; Value: Byte);
begin
  PByte(Ptr.Value + Ofs)^ := Value;
end;

class procedure TMarshal.WriteInt16(Ptr: TPtrWrapper; Value: Smallint);
begin
  PSmallint(Ptr.Value)^ := Value;
end;

class procedure TMarshal.WriteInt16(Ptr: TPtrWrapper; Ofs: NativeInt; Value: Smallint);
begin
  PSmallint(Ptr.Value + Ofs)^ := Value;
end;

class procedure TMarshal.WriteInt32(Ptr: TPtrWrapper; Value: Integer);
begin
  PInteger(Ptr.Value)^ := Value;
end;

class procedure TMarshal.WriteInt32(Ptr: TPtrWrapper; Ofs: NativeInt; Value: Integer);
begin
  PInteger(Ptr.Value + Ofs)^ := Value;
end;

class procedure TMarshal.WriteInt64(Ptr: TPtrWrapper; Value: Int64);
begin
  PInt64(Ptr.Value)^ := Value;
end;

class procedure TMarshal.WriteInt64(Ptr: TPtrWrapper; Ofs: NativeInt; Value: Int64);
begin
  PInt64(Ptr.Value + Ofs)^ := Value;
end;

class procedure TMarshal.WritePtr(Ptr, Value: TPtrWrapper);
begin
  PPointer(Ptr.Value)^ := Value.Value;
end;

class procedure TMarshal.WritePtr(Ptr: TPtrWrapper; Ofs: NativeInt; Value: TPtrWrapper);
begin
  PPointer(Ptr.Value + Ofs)^ := Value.Value;
end;

class procedure TMarshal.Move(Src, Dest: TPtrWrapper; Count: NativeInt);
begin
  System.Move(Src.Value^, Dest.Value^, Count);
end;

class function TMarshal.FixArray<T>(const Arr: TArray<T>): TPtrWrapper;
type
  TArray = TArray<T>;
  PArray = ^TArray;
begin
  // Add ref
  Result.Value := nil;
  PArray(@Result.Value)^ := Arr;
end;

class procedure TMarshal.UnfixArray<T>(ArrPtr: TPtrWrapper);
type
  TArray = TArray<T>;
  PArray = ^TArray;
begin
  // Release ref
  PArray(@ArrPtr.Value)^ := nil;
end;

const
  NullStr: array[0..0] of Char = ( #0 );

class function TMarshal.FixString(var Str: string): TPtrWrapper;
begin
  // For strings with refcount = 1, we avoid copying but we will copy in all
  // other cases. This is different semantics to existing Delphi PChar() cast,
  // but it is more robust - reduces accidental sharing.
  UniqueString(Str);
  // Add reference
  Result.Value := nil;
  PString(@Result.Value)^ := Str;
  // Emulate PChar() cast semantics on empty string.
  if Result.Value = nil then
    Result.Value := @NullStr;
end;

class function TMarshal.UnsafeFixString(const Str: string): TPtrWrapper;
begin
  // Not caring about accidental sharing.
  PString(@Result.Value)^ := Str;
  // Emulate PChar() cast semantics on empty string.
  if Result.Value = nil then
    Result.Value := @NullStr;
end;

class procedure TMarshal.UnfixString(Ptr: TPtrWrapper);
begin
  if Ptr.Value <> @NullStr then
    PString(@Ptr.Value)^ := '';
end;

class function TMarshal.UnsafeAddrOf(var Value): TPtrWrapper;
begin
  Result.Value := @Value;
end;

class function TMarshal.AllocStringAsAnsi(const Str: string): TPtrWrapper;
begin
  Result := AllocStringAsAnsi(Str, DefaultSystemCodePage);
end;

class function TMarshal.AllocStringAsAnsi(const Str: string; CodePage: Word): TPtrWrapper;
var
  len: Integer;
begin
  len := LocaleCharsFromUnicode(CodePage, 0, PWideChar(Str), Length(Str) + 1, nil, 0, nil, nil);
  if len > 0 then
  begin
    Result := AllocMem(len);
    LocaleCharsFromUnicode(CodePage, 0, PWideChar(Str), Length(Str) + 1, Pointer(Result.Value),
      len, nil, nil);
  end
  else
  begin
    Result.Value := nil;
  end;
end;

class function TMarshal.AllocStringAsUnicode(const Str: string): TPtrWrapper;
begin
  Result := AllocMem((Length(Str) + 1) * SizeOf(WideChar));
  if Length(Str) > 0 then
    System.Move(PWideChar(Str)^, Result.Value^, (Length(Str) + 1) * SizeOf(WideChar))
  else
    Result.Value := nil;
end;

class function TMarshal.AllocStringAsAnsi(S: PWideChar): TPtrWrapper;
begin
  Result := AllocStringAsAnsi(S, DefaultSystemCodePage);
end;

class function TMarshal.AllocStringAsAnsi(S: PWideChar; CodePage: Word): TPtrWrapper;
var
  srcLen, len: Integer;
begin
  srcLen := _PWCharLen(S) + 1;
  len := LocaleCharsFromUnicode(CodePage, 0, S, srcLen, nil, 0, nil, nil);
  if len > 0 then
  begin
    Result := AllocMem(len);
    LocaleCharsFromUnicode(CodePage, 0, S, srcLen, Pointer(Result.Value), len, nil, nil);
  end
  else
  begin
    Result.Value := nil;
  end;
end;

class function TMarshal.AllocStringAsUtf8(const Str: string): TPtrWrapper;
begin
  Result := AllocStringAsAnsi(Str, CP_UTF8);
end;

class function TMarshal.AllocStringAsUtf8(S: PWideChar): TPtrWrapper;
begin
  Result := AllocStringAsAnsi(S, CP_UTF8);
end;

class function TMarshal.ReadStringAsAnsi(Ptr: TPtrWrapper; Len: Integer): string;
begin
  Result := ReadStringAsAnsi(DefaultSystemCodePage, Ptr, Len);
end;

class function TMarshal.ReadStringAsAnsi(CodePage: Word; Ptr: TPtrWrapper; Len: Integer): string;
var
  dstLen: Integer;
begin
  if Len < 0 then
    if (Ptr.Value = nil) or (_PAnsiChr(Ptr.Value)^ = #0) then
      Exit('')
    else
      Len := _PCharLen(_PAnsiChr(Ptr.Value));

  dstLen := UnicodeFromLocaleChars(CodePage, 0, Pointer(Ptr.Value), Len + 1, nil, 0);
  if dstLen > 0 then
  begin
    SetLength(Result, dstLen - 1);
    if dstLen > 1 then // more than just null terminator
      UnicodeFromLocaleChars(CodePage, 0, Pointer(Ptr.Value), Len, Pointer(Result), dstLen);
  end
  else
  begin
    Result := '';
  end;
end;

class function TMarshal.ReadStringAsUnicode(Ptr: TPtrWrapper; Len: Integer): string;
begin
  if Len < 0 then
    Len := _PWCharLen(PWideChar(Ptr.Value));

  SetLength(Result, Len);
  if Len > 0 then
    System.Move(Ptr.Value^, Pointer(Result)^, Len * SizeOf(Result[Low(string)]));
end;

class function TMarshal.ReadStringAsUtf8(Ptr: TPtrWrapper; Len: Integer): string;
begin
  Result := ReadStringAsAnsi(CP_UTF8, Ptr, Len);
end;

class function TMarshal.ReadStringAsAnsiUpTo(CodePage: Word; Ptr: TPtrWrapper;
  MaxLen: Integer): string;
var
  p: PByte;
begin
  p := PByte(Ptr);
  while (MaxLen > 0) and (p^ <> 0) do
  begin
    Dec(MaxLen);
    Inc(p);
  end;
  Result := ReadStringAsAnsi(CodePage, Ptr, p - PByte(Ptr));
end;

class function TMarshal.ReadStringAsUnicodeUpTo(Ptr: TPtrWrapper; MaxLen: Integer): string;
var
  p: PWideChar;
begin
  p := PWideChar(Ptr);
  while (MaxLen > 0) and (p^ <> #0) do
  begin
    Dec(MaxLen);
    Inc(p);
  end;
  Result := ReadStringAsUnicode(Ptr, p - PWideChar(Ptr));
end;

class function TMarshal.ReadStringAsUtf8UpTo(Ptr: TPtrWrapper; MaxLen: Integer): string;
begin
  Result := ReadStringAsAnsiUpTo(CP_UTF8, Ptr, MaxLen);
end;

class procedure TMarshal.WriteStringAsAnsi(Ptr: TPtrWrapper; const Value: string;
  MaxCharsIncNull: Integer);
begin
  WriteStringAsAnsi(Ptr, Value, MaxCharsIncNull, DefaultSystemCodePage);
end;

class procedure TMarshal.WriteStringAsAnsi(Ptr: TPtrWrapper; const Value: string;
  MaxCharsIncNull: Integer; CodePage: Word);
begin
  if MaxCharsIncNull < 0 then
    MaxCharsIncNull := LocaleCharsFromUnicode(CodePage, 0, PWideChar(Value), Length(Value) + 1,
      nil, 0, nil, nil);
  LocaleCharsFromUnicode(CodePage, 0, PWideChar(Value), Length(Value) + 1, Pointer(Ptr.Value),
    MaxCharsIncNull, nil, nil);
end;

class procedure TMarshal.WriteStringAsAnsi(Ptr: TPtrWrapper; Ofs: NativeInt; const Value: string;
  MaxCharsIncNull: Integer);
begin
  WriteStringAsAnsi(Ptr, Ofs, Value, MaxCharsIncNull, DefaultSystemCodePage);
end;

class procedure TMarshal.WriteStringAsAnsi(Ptr: TPtrWrapper; Ofs: NativeInt; const Value: string;
  MaxCharsIncNull: Integer; CodePage: Word);
begin
  if MaxCharsIncNull < 0 then
    MaxCharsIncNull := LocaleCharsFromUnicode(CodePage, 0, PWideChar(Value), Length(Value) + 1,
      nil, 0, nil, nil);
  LocaleCharsFromUnicode(CodePage, 0, PWideChar(Value), Length(Value) + 1,
    Pointer(Ptr.Value + Ofs), MaxCharsIncNull, nil, nil);
end;

class procedure TMarshal.WriteStringAsUnicode(Ptr: TPtrWrapper; const Value: string;
  MaxCharsIncNull: Integer);
begin
  if MaxCharsIncNull < 0 then
    MaxCharsIncNull := Length(Value) + 1;
  System.Move(PWideChar(Value)^, Pointer(Ptr.Value)^, MaxCharsIncNull * SizeOf(WideChar));
end;

class procedure TMarshal.WriteStringAsUnicode(Ptr: TPtrWrapper; Ofs: NativeInt;
  const Value: string; MaxCharsIncNull: Integer);
begin
  if MaxCharsIncNull < 0 then
    MaxCharsIncNull := Length(Value) + 1;
  System.Move(PWideChar(Value)^, Pointer(Ptr.Value + Ofs)^, MaxCharsIncNull * SizeOf(WideChar));
end;

class procedure TMarshal.WriteStringAsUtf8(Ptr: TPtrWrapper; const Value: string;
  MaxCharsIncNull: Integer);
begin
  WriteStringAsAnsi(Ptr, Value, MaxCharsIncNull, CP_UTF8);
end;

class procedure TMarshal.WriteStringAsUtf8(Ptr: TPtrWrapper; Ofs: NativeInt; const Value: string;
  MaxCharsIncNull: Integer);
begin
  WriteStringAsAnsi(Ptr, Ofs, Value, MaxCharsIncNull, CP_UTF8);
end;

{$IF defined(LINUX) or defined(MACOS)}

procedure SetDefaultPosixLocaleName(const ALocaleName: string);
  function GetMarshaledAString(const s: string): MarshaledAString;
  var
    I, L: Integer;
  begin
    L := Length(s);
    Result := GetMemory(L + 1);
    for I := 0 to L do
      Result[I] := _AnsiChr(s[I + Low(string)]);
  end;

var
  LTempLocale: MarshaledAString;
begin
  LTempLocale := GetMarshaledAString(ALocaleName);
  setlocale(LC_ALL, LTempLocale);
  FreeMemory(LTempLocale);
end;
{$ENDIF defined(LINUX) or defined(MACOS)}

initialization
{$IFDEF MSWINDOWS}
  SetThreadLocale(LOCALE_USER_DEFAULT);
  InitializeMemoryManager;
  InitializeLocaleData;
{$ENDIF}
{$IF defined(LINUX) or defined(MACOS)}
  // POSIX Locale is always present. Set it to initialize properly and then try with system configured one.
  SetDefaultPosixLocaleName('POSIX');
  SetDefaultPosixLocaleName(GetPosixLocaleName);
{$ENDIF}

  FileMode := 2;

{$IFDEF MSWINDOWS}
  RaiseExceptionProc := @RaiseException;
  RTLUnwindProc := @RTLUnwind;
{$ENDIF MSWINDOWS}

{$IFDEF MSWINDOWS}
  Test8086 := 2;
{$ENDIF MSWINDOWS}
{$IFDEF POSIX}
  // Default File Access Rights for Posix Platforms.
  FileAccessRights := S_IRUSR or S_IWUSR or S_IRGRP or S_IWGRP or S_IROTH or S_IWOTH;
{$ENDIF POSIX}
{$IFDEF LINUX}
{$IF defined(CPUX86) or defined(CPUX64)}
  Test8086 := GetCPUType;
{$ENDIF defined(CPUX86) or defined(CPUX64)}
  IsConsole := True;
  {$IF defined(LINUX_OLD_RESOURCES)}
  FindResourceCache.ModuleHandle := NativeUInt(NativeInt(-1));
  {$ENDIF}
  ReserveZeroPage;
{$ENDIF LINUX}
{$IFDEF MACOS}
{$IF defined(CPUX86) or defined(CPUX64)}
  Test8086 := 2;
{$ENDIF defined(CPUX86) or defined(CPUX64)}
  IsConsole := True;
//  FindResourceCache.ModuleHandle := NativeUInt(NativeInt(-1));
{$ENDIF MACOS}
  CPUCount := GetCPUCount;
  DispCallByIDProc := @_DispCallByIDError;

  _InitializeControlWord;
  _FpuInit();

  TTextRec(Input).Mode := fmClosed;
  TTextRec(Output).Mode := fmClosed;
  TTextRec(ErrOutput).Mode := fmClosed;

{$IFDEF MSWINDOWS}
  CmdLine := GetCommandLine;
  CmdShow := GetCmdShow;
{$ENDIF MSWINDOWS}

{$IFDEF USE_LIBICU}
  InitICU;
  LastLeadCodePage := 0;
{$ENDIF USE_LIBICU}

  DefaultSystemCodePage := GetACP;
  DefaultUnicodeCodePage := CP_UTF16; // UTF16 - Do not pass to MultiByteToWideChar or WideCharToMultiByte
  MainThreadID := GetCurrentThreadID;

{$IF defined(MSWINDOWS)}
  SetUtf8CompareLocale;
{$ELSEIF defined(POSIX)}
  // Ensure that we at least have a valid compare locale. Environment variable can be misconfigured...
  SetUTF8CompareLocale('POSIX');  // POSIX locale;
  SetUTF8CompareLocale(GetPosixLocaleName);  // system default locale;
{$ENDIF}

finalization
{$IFDEF WEAKREF}
  InstHashMap.Finalize;
{$ENDIF}
  Close(Input);
  Close(Output);
  Close(ErrOutput);
{$IFDEF LINUX}
  ReleaseZeroPage;
{$ENDIF LINUX}
{$IF defined(USE_LIBICU)}
  FreeMem(InternalUTF8CompareLocale);
{$ELSEIF defined(POSIX)}
  if InternalUTF8CompareLocale <> nil then
    freelocale(InternalUTF8CompareLocale);
{$ENDIF defined(POSIX)}
{$IFDEF MSWINDOWS}
  FinalizeLocaleDate;
  if PreferredLanguagesOverride <> nil then
    FreeMem(PreferredLanguagesOverride);
  {Uninitialize the default memory manager, and free all memory allocated by
   this memory manager.}
  FinalizeMemoryManager;
{$ENDIF MSWINDOWS}
{$IFDEF USE_LIBICU}
  if LastConverter <> nil then
    ucnv_close(LastConverter);
{$ENDIF MSWINDOWS}
end.
