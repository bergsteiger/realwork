unit Xml.Internal.AdomCore_4_3;

// ADOM Core 5.1.6
// Alternative Document Object Model 5.1.6
// Delphi 5/6/7/8/2005/2006/2007/2009/2010/XE1/XE2 and Kylix 3 Implementation
// March 2012
//
//
// LICENSE
//
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// "http://www.mozilla.org/MPL/"
//
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
// the specific language governing rights and limitations under the License.
//
// The Original Code is "AdomCore_4_3.pas".
//
// The Initial Developer of the Original Code is Dieter Köhler (Heidelberg,
// Germany, "http://www.philo.de/"). Portions created by the Initial Developer
// are Copyright (C) 1999-2012 Dieter Köhler. All Rights Reserved.
//
// Alternatively, the contents of this file may be used under the terms of the
// GNU General Public License Version 2 or later (the "GPL"), in which case the
// provisions of the GPL are applicable instead of those above. If you wish to
// allow use of your version of this file only under the terms of the GPL, and
// not to allow others to use your version of this file under the terms of the
// MPL, indicate your decision by deleting the provisions above and replace them
// with the notice and other provisions required by the GPL. If you do not delete
// the provisions above, a recipient may use your version of this file under the
// terms of any one of the MPL or the GPL.

//{$HINTS OFF}
//{$WARNINGS OFF}

{$WARN SYMBOL_PLATFORM OFF}

{$IFDEF WIN32}
  {$IFNDEF VER140}
    {$DEFINE MSWINDOWS}
  {$ENDIF}
{$ENDIF}
{$IFDEF WIN16}
  {$DEFINE MSWINDOWS}
{$ENDIF}
{$IFDEF VER140}
  {$DEFINE VER140+}
{$ENDIF}
{$IFDEF VER150}
  {$DEFINE VER140+}
{$ENDIF}
{$IFDEF VER160}
  {$DEFINE VER140+}
{$ENDIF}
{$IFDEF VER170}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
{$ENDIF}
{$IFDEF VER180}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
{$ENDIF}
{$IFDEF VER185}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
{$ENDIF}
{$IFDEF VER190}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
{$ENDIF}
{$IFDEF VER200}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
  {$DEFINE VER200+}
{$ENDIF}
{$IFDEF VER210}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
  {$DEFINE VER200+}
{$ENDIF}
{$IFDEF VER220}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
  {$DEFINE VER200+}
{$ENDIF}
{$IFDEF VER230}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
  {$DEFINE VER200+}
  {$DEFINE VER230+_OR_CLR}
{$ENDIF}
{$IFDEF VER240}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
  {$DEFINE VER200+}
  {$DEFINE VER230+_OR_CLR}
{$ENDIF}
{$IFDEF conditionalexpressions}
{$IF CompilerVersion >= 25}
  {$DEFINE VER140+}
  {$DEFINE VER170+}
  {$DEFINE VER200+}
  {$DEFINE VER230+_OR_CLR}
  {$DEFINE VER250+}
{$ENDIF}
{$ENDIF}


{$IFDEF CLR}
  {$DEFINE VER230+_OR_CLR}
  {$IFNDEF ALL_OS}
    {$DEFINE SystemEncodingName_DECLARED}
  {$ENDIF}
{$ELSE}
  {$IFDEF MSWINDOWS}
    {$DEFINE SystemEncodingName_DECLARED}
  {$ENDIF}
{$ENDIF}

interface

uses
  {$IFDEF CLR}
    DK.Utilities.CodecUtilsRTL, DK.Utilities.ParserUtilsRTL,
    DK.Utilities.TreeUtils, DK.Utilities.WideStringUtils,
  {$ELSE}
    Xml.Internal.CodecUtilsWin32, Xml.Internal.ParserUtilsWin32, Xml.Internal.TreeUtils,
    Xml.Internal.WideStringUtils,
  {$ENDIF}
    // The above units are contained in the Open XML Utilities package 2.0.x
    // available at "http://www.philo.de/xml/".

  Xml.xmldom,

  System.Generics.Collections, System.SysUtils, System.Classes, System.Types;

{$IFDEF NEXTGEN}
  function HexToInt64(const Hex: string): Int64;
{$ELSE !NEXTGEN}
  function HexToInt64(const Hex: WideString): Int64;
{$ENDIF NEXTGEN}

type
  EDomException = class(Exception);

  EIndex_Size_Err = class(EdomException);
  EHierarchy_Request_Err = class(EdomException);
  EWrong_Document_Err = class(EdomException);
  EInvalid_Character_Err = class(EdomException);
  ENo_Data_Allowed_Err = class(EdomException);
  ENo_Modification_Allowed_Err = class(EdomException);
  ENot_Found_Err = class(EdomException);
  ENot_Supported_Err = class(EdomException);
  EInuse_Err = class(EdomException);
  EInvalid_State_Err = class(EdomException);
  ESyntax_Err = class(EdomException);
  EInvalid_Modification_Err = class(EdomException);
  ENamespace_Err = class(EdomException);
  EWrong_DOM_Implementation_Err = class(EdomException);

  EParserException = class(EdomException);

  EXPath_Exception = class(EdomException);
  EXPath_Invalid_Expression_Err = class(EXPath_Exception);
  EXPath_Invalid_Function_Call_Err = class(EXPath_Exception);
  EXPath_Type_Err = class(EXPath_Exception);


  TXmlErrorType = (

    // Remark: The order and number of this error types is likely subject to
    //         change in future ADOM versions.  Therefore, you are strongly
    //         adviced to refer to error types by using the constants below,
    //         but avoid using their numerical equivalents!

    ET_NONE, // No error

    ET_DOCTYPE_NOT_FOUND,
    ET_DOUBLE_ATTLISTDECL,
    ET_DOUBLE_ATTDEF,
    ET_DOUBLE_ENTITY_DECL,
    ET_DOUBLE_PARAMETER_ENTITY_DECL,
    ET_FRAGMENT_IDENTIFIER_IN_SYSTEM_IDENTIFIER,
    ET_SYSTEM_IDENTIFIER_IS_NOT_URI_REFERENCE,
    ET_UNPARSED_ENTITY_REFERENCED_IN_ENTITY_DECLARATION,
    ET_XML_SPACE_ATTRIBUTE_ERRONEOUS_VALUE_DECLARED,
    ET_XML_SPACE_ATTRIBUTE_ERRONEOUS_VALUE_SPECIFIED,
    ET_XML_SPACE_ATTRIBUTE_NOT_ENUMERATED_TYPE,

    ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH,
    ET_ATTRIBUTE_TYPE_MISMATCH,
    ET_DUPLICATE_ELEMENT_TYPE_DECL,
    ET_DUPLICATE_ENUMERATION_TOKEN,
    ET_DUPLICATE_ID_ON_ELEMENT_TYPE,
    ET_DUPLICATE_ID_VALUE,
    ET_DUPLICATE_NAME_IN_MIXED_CONTENT,
    ET_DUPLICATE_NOTATION_DECL,
    ET_DUPLICATE_NOTATION_ON_ELEMENT_TYPE,
    ET_DUPLICATE_NOTATION_TOKEN,
    ET_DUPLICATE_TOKENS,
    ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_CDATA_SECTION_WHERE_ELEMENT_ONLY,
    ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_CHILD_ELEMENT_TYPE,
    ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_ELEMENT_WHERE_PCDATA_ONLY,
    ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_PCDATA_WHERE_ELEMENT_ONLY,
    ET_ELEMENT_DECLARED_EMPTY_HAS_CONTENT,
    ET_ENTITY_REFERENCED_BEFORE_DECLARED_VC,
    ET_FIXED_ATTRIBUTE_MISMATCH,
    ET_ID_NEITHER_IMPLIED_NOR_REQUIRED,
    ET_NONDETERMINISTIC_ELEMENT_CONTENT_MODEL,
    ET_NOTATION_ON_EMPTY_ELEMENT,
    ET_PE_NOT_PROPERLY_NESTED_WITH_CONDITIONAL_SECTION,
    ET_PE_NOT_PROPERLY_NESTED_WITH_DECL,
    ET_PE_NOT_PROPERLY_NESTED_WITH_PARENTHESIZED_GROUP,
    ET_PREDEFINED_ENTITY_INCORRECTLY_REDECLARED,
    ET_REQUIRED_ATTRIBUTE_NOT_SPECIFIED,
    ET_TARGET_ID_VALUE_NOT_FOUND,
    ET_UNDEFINED_ATTRIBUTE,
    ET_UNDEFINED_ELEMENT_TYPE,
    ET_UNDEFINED_ENTITY_VC,
    ET_UNDEFINED_NOTATION,
    ET_UNDEFINED_PARAMETER_ENTITY,
    ET_UNDEFINED_TARGET_UNPARSED_ENTITY,
    ET_UNNORMALIZED_EXT_ATTR_IN_STANDALONE_DOC,
    ET_UNRESOLVABLE_EXTERNAL_SUBSET,
    ET_UNSPECIFIED_EXT_ATTR_IN_STANDALONE_DOC,
    ET_WHITESPACE_IN_EXT_ELEMENT_CONTENT_IN_STANDALONE_DOC,
    ET_WRONG_ROOT_ELEMENT_TYPE,

    ET_ATTRIBUTE_VALUE_REFERS_TO_EXTERNAL_ENTITY,
    ET_BYTE_ORDER_MARK_ENCODING_MISMATCH,
    ET_CDATA_START_EXPECTED,
    ET_COMMENT_START_EXPECTED,
    ET_DOCTYPE_START_EXPECTED,
    ET_DOUBLE_ATTRIBUTE_NAME,
    ET_DOUBLE_EQUALITY_SIGN,
    ET_DOUBLE_HYPHEN_IN_COMMENT,
    ET_DOUBLE_ROOT_ELEMENT,
    ET_ENTITY_REFERENCED_BEFORE_DECLARED_WFC,
    ET_EXT_DECL_ENTITY_REFERENCED_IN_STANDALONE_DOC,
    ET_HYPHEN_AT_COMMENT_END,
    ET_INVALID_ATTRIBUTE_NAME,
    ET_INVALID_ATTRIBUTE_VALUE,
    ET_INVALID_CDATA_SECTION,
    ET_INVALID_CHARACTER,
    ET_INVALID_CHAR_REF,
    ET_INVALID_COMMENT,
    ET_INVALID_ELEMENT_NAME,
    ET_INVALID_ENCODING_NAME,
    ET_INVALID_ENTITY_NAME,
    ET_INVALID_PARAMETER_ENTITY_NAME,
    ET_INVALID_PROCESSING_INSTRUCTION,
    ET_INVALID_PUBID_LITERAL,
    ET_INVALID_SYSTEM_LITERAL,
    ET_INVALID_TEXT_DECL,
    ET_INVALID_VERSION_NUMBER,
    ET_INVALID_XML_DECL,
    ET_LEFT_SQUARE_BRACKET_EXPECTED,
    ET_LT_IN_ATTRIBUTE_VALUE,
    ET_MISSING_ELEMENT_NAME,
    ET_MISSING_END_TAG,
    ET_MISSING_ENTITY_NAME,
    ET_MISSING_EQUALITY_SIGN,
    ET_MISSING_QUOTATION_MARK,
    ET_MISSING_START_TAG,
    ET_MISSING_WHITE_SPACE,
    ET_NOT_IN_ROOT_ELEMENT,
    ET_NO_PROPER_MARKUP_REFERENCED,
    ET_PE_BETWEEN_DECLARATIONS,
    ET_PUBLIC_KEYWORD_EXPECTED,
    ET_QUOTATION_MARK_EXPECTED,
    ET_RECURSIVE_REFERENCE,
    ET_REFERS_TO_UNPARSED_ENTITY,
    ET_RIGHT_SQUARE_BRACKET_EXPECTED,
    ET_ROOT_ELEMENT_NOT_FOUND,
    ET_SYSTEM_KEYWORD_EXPECTED,
    ET_UNCLOSED_CDATA_SECTION,
    ET_UNCLOSED_CHAR_REF,
    ET_UNCLOSED_COMMENT,
    ET_UNCLOSED_DOCTYPE,
    ET_UNCLOSED_ELEMENT,
    ET_UNCLOSED_ENTITY_REF,
    ET_UNCLOSED_PROCESSING_INSTRUCTION,
    ET_UNDEFINED_ENTITY_WFC,
    ET_WRONG_ORDER,

    ET_ATTLIST_DECL_START_EXPECTED,
    ET_CONDITIONAL_SECTION_NOT_ALLOWED,
    ET_DOUBLE_DOCTYPE,
    ET_ELEMENT_DECL_START_EXPECTED,
    ET_ENTITY_DECL_START_EXPECTED,
    ET_INVALID_ATTLIST_DECL_NAME,
    ET_INVALID_ATTRIBUTE_DECL,
    ET_INVALID_ATTRIBUTE_NAME_IN_ATTRIBUTE_DECL,
    ET_INVALID_CONDITIONAL_SECTION,
    ET_INVALID_CONTENT_MODEL_TOKEN_IN_ELEMENT_DECL,
    ET_INVALID_ELEMENT_DECL,
    ET_INVALID_ELEMENT_NAME_IN_ATTRIBUTE_DECL,
    ET_INVALID_ELEMENT_NAME_IN_ELEMENT_DECL,
    ET_INVALID_ENTITY_DECL,
    ET_INVALID_ENTITY_NAME_IN_ENTITY_DECL,
    ET_INVALID_ENTITY_NAME_IN_PARAMETER_ENTITY_DECL,
    ET_INVALID_ENTITY_VALUE_IN_ENTITY_DECL,
    ET_INVALID_ENTITY_VALUE_IN_PARAMETER_ENTITY_DECL,
    ET_INVALID_ENUMERATION_TOKEN_IN_ATTRIBUTE_DECL,
    ET_INVALID_MARKUP_DECL,
    ET_INVALID_NOTATION_DECL,
    ET_INVALID_NOTATION_NAME_IN_ENTITY_DECL,
    ET_INVALID_NOTATION_NAME_IN_NOTATION_DECL,
    ET_INVALID_NOTATION_TOKEN_IN_ATTRIBUTE_DECL,
    ET_INVALID_PARAMETER_ENTITY_DECL,
    ET_INVALID_ROOT_ELEMENT_NAME_IN_DOCTYPE_DECL,
    ET_KEYWORD_ANY_NOT_ALLOWED,
    ET_KEYWORD_EMPTY_NOT_ALLOWED,
    ET_KEYWORD_PCDATA_NOT_ALLOWED,
    ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL,
    ET_MISSING_ENTITY_VALUE_IN_ENTITY_DECL,
    ET_MISSING_ENTITY_VALUE_IN_PARAMETER_ENTITY_DECL,
    ET_NOTATION_DECL_START_EXPECTED,
    ET_PARAMETER_ENTITY_REF_NOT_ALLOWED,
    ET_UNCLOSED_ATTLIST_DECL,
    ET_UNCLOSED_CONDITIONAL_SECTION,
    ET_UNCLOSED_ELEMENT_DECL,
    ET_UNCLOSED_ENTITY_DECL,
    ET_UNCLOSED_NOTATION_DECL,
    ET_UNCLOSED_PARAMETER_ENTITY_REF,
    ET_UNKNOWN_DECL_TYPE,
    ET_WHITESPACE_EXPECTED,

    ET_INVALID_NAMESPACE_URI,
    ET_INVALID_PREFIX,
    ET_INVALID_QUALIFIED_NAME,
    ET_NAMESPACE_URI_NOT_FOUND,
    ET_WRONG_PREFIX_MAPPING_NESTING,

    ET_ENCODING_NOT_SUPPORTED,
    ET_EXT_ENTITY_RESOURCE_NOT_FOUND,
    ET_EXT_PARAMETER_ENTITY_RESOURCE_NOT_FOUND,
    ET_INVALID_CHARACTER_IN_EXT_ENTITY,
    ET_XML_VERSION_NOT_SUPPORTED
  );

  TXmlErrorTypes = set of TXmlErrorType;

const
  ET_WARNINGS: TXmlErrorTypes = [
    ET_NONE, // Included in ET_WARNINGS to ease calculations.
    ET_DOCTYPE_NOT_FOUND,
    ET_DOUBLE_ATTLISTDECL,
    ET_DOUBLE_ATTDEF,
    ET_DOUBLE_ENTITY_DECL,
    ET_DOUBLE_PARAMETER_ENTITY_DECL,
    ET_FRAGMENT_IDENTIFIER_IN_SYSTEM_IDENTIFIER,
    ET_SYSTEM_IDENTIFIER_IS_NOT_URI_REFERENCE,
    ET_UNPARSED_ENTITY_REFERENCED_IN_ENTITY_DECLARATION,
    ET_XML_SPACE_ATTRIBUTE_ERRONEOUS_VALUE_DECLARED,
    ET_XML_SPACE_ATTRIBUTE_ERRONEOUS_VALUE_SPECIFIED,
    ET_XML_SPACE_ATTRIBUTE_NOT_ENUMERATED_TYPE
  ];

  ET_ERRORS: TXmlErrorTypes = [
    ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH,
    ET_ATTRIBUTE_TYPE_MISMATCH,
    ET_DUPLICATE_ELEMENT_TYPE_DECL,
    ET_DUPLICATE_ENUMERATION_TOKEN,
    ET_DUPLICATE_ID_ON_ELEMENT_TYPE,
    ET_DUPLICATE_ID_VALUE,
    ET_DUPLICATE_NAME_IN_MIXED_CONTENT,
    ET_DUPLICATE_NOTATION_DECL,
    ET_DUPLICATE_NOTATION_ON_ELEMENT_TYPE,
    ET_DUPLICATE_NOTATION_TOKEN,
    ET_DUPLICATE_TOKENS,
    ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_CDATA_SECTION_WHERE_ELEMENT_ONLY,
    ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_CHILD_ELEMENT_TYPE,
    ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_ELEMENT_WHERE_PCDATA_ONLY,
    ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_PCDATA_WHERE_ELEMENT_ONLY,
    ET_ELEMENT_DECLARED_EMPTY_HAS_CONTENT,
    ET_ENTITY_REFERENCED_BEFORE_DECLARED_VC,
    ET_FIXED_ATTRIBUTE_MISMATCH,
    ET_ID_NEITHER_IMPLIED_NOR_REQUIRED,
    ET_NONDETERMINISTIC_ELEMENT_CONTENT_MODEL,
    ET_NOTATION_ON_EMPTY_ELEMENT,
    ET_PE_NOT_PROPERLY_NESTED_WITH_CONDITIONAL_SECTION,
    ET_PE_NOT_PROPERLY_NESTED_WITH_DECL,
    ET_PE_NOT_PROPERLY_NESTED_WITH_PARENTHESIZED_GROUP,
    ET_PREDEFINED_ENTITY_INCORRECTLY_REDECLARED,
    ET_REQUIRED_ATTRIBUTE_NOT_SPECIFIED,
    ET_TARGET_ID_VALUE_NOT_FOUND,
    ET_UNDEFINED_ATTRIBUTE,
    ET_UNDEFINED_ELEMENT_TYPE,
    ET_UNDEFINED_ENTITY_VC,
    ET_UNDEFINED_NOTATION,
    ET_UNDEFINED_PARAMETER_ENTITY,
    ET_UNDEFINED_TARGET_UNPARSED_ENTITY,
    ET_UNNORMALIZED_EXT_ATTR_IN_STANDALONE_DOC,
    ET_UNRESOLVABLE_EXTERNAL_SUBSET,
    ET_UNSPECIFIED_EXT_ATTR_IN_STANDALONE_DOC,
    ET_WHITESPACE_IN_EXT_ELEMENT_CONTENT_IN_STANDALONE_DOC,
    ET_WRONG_ROOT_ELEMENT_TYPE
  ];

  ET_FATAL_ERRORS: TXmlErrorTypes = [
    ET_ATTRIBUTE_VALUE_REFERS_TO_EXTERNAL_ENTITY,
    ET_BYTE_ORDER_MARK_ENCODING_MISMATCH,
    ET_CDATA_START_EXPECTED,
    ET_COMMENT_START_EXPECTED,
    ET_DOCTYPE_START_EXPECTED,
    ET_DOUBLE_ATTRIBUTE_NAME,
    ET_DOUBLE_EQUALITY_SIGN,
    ET_DOUBLE_HYPHEN_IN_COMMENT,
    ET_DOUBLE_ROOT_ELEMENT,
    ET_ENTITY_REFERENCED_BEFORE_DECLARED_WFC,
    ET_EXT_DECL_ENTITY_REFERENCED_IN_STANDALONE_DOC,
    ET_HYPHEN_AT_COMMENT_END,
    ET_INVALID_ATTRIBUTE_NAME,
    ET_INVALID_ATTRIBUTE_VALUE,
    ET_INVALID_CDATA_SECTION,
    ET_INVALID_CHARACTER,
    ET_INVALID_CHAR_REF,
    ET_INVALID_COMMENT,
    ET_INVALID_ELEMENT_NAME,
    ET_INVALID_ENCODING_NAME,
    ET_INVALID_ENTITY_NAME,
    ET_INVALID_PARAMETER_ENTITY_NAME,
    ET_INVALID_PROCESSING_INSTRUCTION,
    ET_INVALID_PUBID_LITERAL,
    ET_INVALID_SYSTEM_LITERAL,
    ET_INVALID_TEXT_DECL,
    ET_INVALID_VERSION_NUMBER,
    ET_INVALID_XML_DECL,
    ET_LEFT_SQUARE_BRACKET_EXPECTED,
    ET_LT_IN_ATTRIBUTE_VALUE,
    ET_MISSING_ELEMENT_NAME,
    ET_MISSING_END_TAG,
    ET_MISSING_ENTITY_NAME,
    ET_MISSING_EQUALITY_SIGN,
    ET_MISSING_QUOTATION_MARK,
    ET_MISSING_START_TAG,
    ET_MISSING_WHITE_SPACE,
    ET_NOT_IN_ROOT_ELEMENT,
    ET_NO_PROPER_MARKUP_REFERENCED,
    ET_PE_BETWEEN_DECLARATIONS,
    ET_PUBLIC_KEYWORD_EXPECTED,
    ET_QUOTATION_MARK_EXPECTED,
    ET_RECURSIVE_REFERENCE,
    ET_REFERS_TO_UNPARSED_ENTITY,
    ET_ROOT_ELEMENT_NOT_FOUND,
    ET_SYSTEM_KEYWORD_EXPECTED,
    ET_UNCLOSED_CDATA_SECTION,
    ET_UNCLOSED_CHAR_REF,
    ET_UNCLOSED_COMMENT,
    ET_UNCLOSED_DOCTYPE,
    ET_UNCLOSED_ELEMENT,
    ET_UNCLOSED_ENTITY_REF,
    ET_UNCLOSED_PROCESSING_INSTRUCTION,
    ET_UNDEFINED_ENTITY_WFC,
    ET_WRONG_ORDER,

    ET_ATTLIST_DECL_START_EXPECTED,
    ET_CONDITIONAL_SECTION_NOT_ALLOWED,
    ET_DOUBLE_DOCTYPE,
    ET_ELEMENT_DECL_START_EXPECTED,
    ET_ENTITY_DECL_START_EXPECTED,
    ET_INVALID_ATTLIST_DECL_NAME,
    ET_INVALID_ATTRIBUTE_DECL,
    ET_INVALID_ATTRIBUTE_NAME_IN_ATTRIBUTE_DECL,
    ET_INVALID_CONDITIONAL_SECTION,
    ET_INVALID_ELEMENT_DECL,
    ET_INVALID_ELEMENT_NAME_IN_ATTRIBUTE_DECL,
    ET_INVALID_ELEMENT_NAME_IN_ELEMENT_DECL,
    ET_INVALID_ENTITY_DECL,
    ET_INVALID_ENTITY_NAME_IN_ENTITY_DECL,
    ET_INVALID_ENTITY_NAME_IN_PARAMETER_ENTITY_DECL,
    ET_INVALID_ENTITY_VALUE_IN_ENTITY_DECL,
    ET_INVALID_ENTITY_VALUE_IN_PARAMETER_ENTITY_DECL,
    ET_INVALID_ENUMERATION_TOKEN_IN_ATTRIBUTE_DECL,
    ET_INVALID_MARKUP_DECL,
    ET_INVALID_NOTATION_DECL,
    ET_INVALID_NOTATION_NAME_IN_ENTITY_DECL,
    ET_INVALID_NOTATION_NAME_IN_NOTATION_DECL,
    ET_INVALID_NOTATION_TOKEN_IN_ATTRIBUTE_DECL,
    ET_INVALID_PARAMETER_ENTITY_DECL,
    ET_INVALID_ROOT_ELEMENT_NAME_IN_DOCTYPE_DECL,
    ET_KEYWORD_ANY_NOT_ALLOWED,
    ET_KEYWORD_EMPTY_NOT_ALLOWED,
    ET_KEYWORD_PCDATA_NOT_ALLOWED,
    ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL,
    ET_MISSING_ENTITY_VALUE_IN_ENTITY_DECL,
    ET_MISSING_ENTITY_VALUE_IN_PARAMETER_ENTITY_DECL,
    ET_NOTATION_DECL_START_EXPECTED,
    ET_PARAMETER_ENTITY_REF_NOT_ALLOWED,
    ET_UNCLOSED_ATTLIST_DECL,
    ET_UNCLOSED_CONDITIONAL_SECTION,
    ET_UNCLOSED_ELEMENT_DECL,
    ET_UNCLOSED_ENTITY_DECL,
    ET_UNCLOSED_NOTATION_DECL,
    ET_UNCLOSED_PARAMETER_ENTITY_REF,
    ET_UNKNOWN_DECL_TYPE,
    ET_WHITESPACE_EXPECTED,

    ET_INVALID_NAMESPACE_URI,
    ET_INVALID_PREFIX,
    ET_INVALID_QUALIFIED_NAME,
    ET_NAMESPACE_URI_NOT_FOUND,
    ET_WRONG_PREFIX_MAPPING_NESTING,

    ET_ENCODING_NOT_SUPPORTED,
    ET_EXT_ENTITY_RESOURCE_NOT_FOUND,
    ET_EXT_PARAMETER_ENTITY_RESOURCE_NOT_FOUND,
    ET_INVALID_CHARACTER_IN_EXT_ENTITY,
    ET_XML_VERSION_NOT_SUPPORTED
  ];

  ET_NAMESPACE_FATAL_ERRORS: TXmlErrorTypes = [
    ET_INVALID_NAMESPACE_URI,
    ET_INVALID_PREFIX,
    ET_INVALID_QUALIFIED_NAME,
    ET_NAMESPACE_URI_NOT_FOUND,
    ET_WRONG_PREFIX_MAPPING_NESTING
  ];

type
  TDomTrinarean = ( T_UNKNOWN,
                    T_TRUE,
                    T_FALSE );

type
  TDomNodeType = ( ntUnknown,
                   ntElement_Node,
                   ntAttribute_Node,
                   ntText_Node,
                   ntCDATA_Section_Node,
                   ntEntity_Reference_Node,
                   ntProcessing_Instruction_Node,
                   ntComment_Node,
                   ntDocument_Node,
                   ntDocument_Fragment_Node,
                   ntDocument_Type_Decl_Node,
                   ntXPath_Namespace_Node );

  TDomWhatToShow = set of TDomNodeType;

const
  SHOW_ALL: TDomWhatToShow = [ ntElement_Node .. High(TDomNodeType) ];
  AS_UNBOUNDED = High(Integer);

type
  TDomXPathResultType = ( XPATH_BOOLEAN_TYPE,
                          XPATH_NODE_SET_TYPE,
                          XPATH_NUMBER_TYPE,
                          XPATH_STRING_TYPE );

  TDomXPathResultTypes = set of TDomXPathResultType;

const
  XPATH_ANY_TYPE: TDomXPathResultTypes = [XPATH_BOOLEAN_TYPE .. High(TDomXPathResultType)];

type
  TXmlDataType = (AS_STRING_DATATYPE,
                  AS_NOTATION_DATATYPE,
                  AS_ID_DATATYPE,
                  AS_IDREF_DATATYPE,
                  AS_IDREFS_DATATYPE,
                  AS_ENTITY_DATATYPE,
                  AS_ENTITIES_DATATYPE,
                  AS_NMTOKEN_DATATYPE,
                  AS_NMTOKENS_DATATYPE,
                  AS_BOOLEAN_DATATYPE,
                  AS_FLOAT_DATATYPE,
                  AS_DOUBLE_DATATYPE,
                  AS_DECIMAL_DATATYPE,
                  AS_HEXBINARY_DATATYPE,
                  AS_BASE64BINARY_DATATYPE,
                  AS_ANYURI_DATATYPE,
                  AS_QNAME_DATATYPE,
                  AS_DURATION_DATATYPE,
                  AS_DATETIME_DATATYPE,
                  AS_DATE_DATATYPE,
                  AS_TIME_DATATYPE,
                  AS_GYEARMONTH_DATATYPE,
                  AS_GYEAR_DATATYPE,
                  AS_GMONTHDAY_DATATYPE,
                  AS_GDAY_DATATYPE,
                  AS_GMONTH_DATATYPE,
                  AS_INTEGER_DATATYPE,
                  AS_NAME_DATATYPE,
                  AS_NCNAME_DATATYPE,
                  AS_NORMALIZEDSTRING_DATATYPE,
                  AS_TOKEN_DATATYPE,
                  AS_LANGUAGE_DATATYPE,
                  AS_NONPOSITIVEINTEGER_DATATYPE,
                  AS_NEGATIVEINTEGER_DATATYPE,
                  AS_LONG_DATATYPE,
                  AS_INT_DATATYPE,
                  AS_SHORT_DATATYPE,
                  AS_BYTE_DATATYPE,
                  AS_NONNEGATIVEINTEGER_DATATYPE,
                  AS_UNSIGNEDLONG_DATATYPE,
                  AS_UNSIGNEDINT_DATATYPE,
                  AS_UNSIGNEDSHORT_DATATYPE,
                  AS_UNSIGNEDBYTE_DATATYPE,
                  AS_POSITIVEINTEGER_DATATYPE,
                  AS_ANYSIMPLETYPE_DATATYPE,
                  AS_ANYTYPE_DATATYPE
                  );

  TDomAttrValueConstraint = (AVC_DEFAULT,
                             AVC_FIXED,
                             AVC_IMPLIED,
                             AVC_REQUIRED);

  TDtdContentModelType = ( DTD_CHOICE_CM,
                           DTD_ELEMENT_CM,
                           DTD_SEQUENCE_CM);

  TDtdContentType = (DTD_ANY_CONTENTTYPE,
                     DTD_EMPTY_CONTENTTYPE,
                     DTD_ELEMENT_CONTENTTYPE,
                     DTD_MIXED_CONTENTTYPE,
                     DTD_STRICT_MIXED_CONTENTTYPE);

  TDtdEntityType = (DTD_INTERNAL_ENTITY,
                    DTD_EXTERNAL_ENTITY,
                    DTD_PREDEFINED_ENTITY);

  TDtdOrigin = (DTD_INTERNALLY_DECLARED,
                DTD_EXTERNALLY_DECLARED,
                DTD_PREDEFINED);

  TDtdFrequency = (DTD_REQUIRED_FRQ,
                   DTD_OPTIONAL_FRQ,
                   DTD_ONE_OR_MORE_FRQ,
                   DTD_ZERO_OR_MORE_FRQ);

  TDtdObjectType = (DTD_UNDEFINED,
                    DTD_ATTLIST_DECLARATION,
                    DTD_ATTRIBUTE_DECLARATION,
                    DTD_CONTENT_MODEL,
                    DTD_ELEMENT_DECLARATION,
                    DTD_ENTITY_DECLARATION,
                    DTD_NOTATION_DECLARATION);

  TDtdObjectTypeSet = set of TDtdObjectType;

  TDomPieceType = ( xmlProcessingInstruction,
                    xmlComment,
                    xmlCDATA,
                    xmlPCDATA,
                    xmlDoctype,
                    xmlStartTag,
                    xmlEndTag,
                    xmlEmptyElementTag,
                    xmlCharRef,
                    xmlEntityRef,
                    xmlAttribute,
                    xmlParameterEntityRef,
                    xmlEntityDecl,
                    xmlElementDecl,
                    xmlAttributeDecl,
                    xmlNotationDecl,
                    xmlCondSection,
                    xmlParameterEntityDecl,
                    xmlXmlDeclaration,
                    xmlTextDeclaration,
                    xmlUnknown );

  TDomDocumentPosition = set of ( Document_Position_Contained_By,
                                  Document_Position_Contains,
                                  Document_Position_Disconnected,
                                  Document_Position_Equivalent,
                                  Document_Position_Following,
                                  Document_Position_Preceding,
                                  Document_Position_Same_Node );

  TDomEntityResolveOption = (erReplace, erExpand);

  TDomEntityType = (etExternal_Entity, etInternal_Entity);

  TDomFilterResult = (filter_accept, filter_reject, filter_skip);

  TDomFilenameToUriOptions = set of (fuSetLocalhost, fuPlainColon);

  TDomNodeEvent = (neClearing, neRemoving);

  TDomPosition = (posBefore, posAfter);

  TDomStandalone = ( STANDALONE_YES,
                     STANDALONE_NO,
                     STANDALONE_UNSPECIFIED );

  TDtdObject             = class;

  TDomNode               = class;
  TDomAttr               = class;
  TDomElement            = class;
  TDomCustomDocument     = class;
  TDomDocument           = class;
  TDomDocumentNS         = class;
  TDomNodeList           = class;

  TDomAbstractView       = class;

  TDomMediaList          = class;

  TXmlSourceCodePiece    = class;

  TXmlStreamBuilder      = class;
  TXmlDtdModelBuilder    = class;

  TDomXPathSyntaxNode    = class;
  TXPathExpression       = class;
  TDomXPathCustomResult  = class;
  TDomXPathNodeSetResult = class;

  IDomLocator = interface;

                                                                                         
  TDomOperationType = ( OT_NODE_ADOPTED,
                        OT_NODE_CLONED,
                        OT_NODE_DESTROYED,
                        OT_NODE_IMPORTED,
                        OT_NODE_RENAMED );

  TDomAttrChange = ( AC_ADDITION,
                     AC_MODIFICATION,
                     AC_REMOVAL );

  TDomXmlnsDeclType = ( NSDT_DEFAULT,
                        NSDT_PREFIXED,
                        NSDT_NONE );

  TDomPreparationStatus = ( PS_UNPREPARED,
                            PS_INCOMPLETE,
                            PS_INCOMPLETE_STANDALONE,
                            PS_INCOMPLETE_NOT_STANDALONE,
                            PS_INCOMPLETE_ABORTED,
                            PS_INT_SUBSET_COMPLETED,
                            PS_COMPLETED,
                            PS_INEXISTANT );

  TDomDocTypeDeclTreatment = ( dtIgnore,
                               dtCheckWellformedness,
                               dtCheckValidity );

{$IFDEF NEXTGEN}
  TDomUserDataEvent = procedure(const Operation: TDomOperationType;
                                const Key: string;
                                const Data: TObject;
                                const Src,
                                      Dst: TDomNode) of object;
{$ELSE !NEXTGEN}
  TDomUserDataEvent = procedure(const Operation: TDomOperationType;
                                const Key: WideString;
                                const Data: TObject;
                                const Src,
                                      Dst: TDomNode) of object;
{$ENDIF NEXTGEN}

  TDomAttrModifiedEvent = procedure(Sender: TObject;
                                    ModifiedNode: TDomNode;
                                    AttrChange: TDomAttrChange;
                                    RelatedAttr: TDomAttr) of object;

  TDomNotifyNodeEvent = procedure(Sender: TObject;
                                  Node: TDomNode) of object;

  TDomNotifyDtdObjectEvent = procedure(Sender: TObject;
                                       DtdObject: TDtdObject) of object;

  TDomLocationEvent = procedure(Sender: TObject;
                                const Locator: IDomLocator) of object;

{$IFDEF NEXTGEN}
  TDomResolveResourceEvent = procedure(      Sender: TObject;
                                       const ResourceType,
                                             NamespaceURI: string;
                                         var PublicId,
                                             SystemId: string;
                                         var Stream: TStream;
                                         var CertifiedText: Boolean) of object;

  TDomResolveEntityProc = procedure(const Origin: TDtdOrigin;
                                    const BaseURI,
                                          PubId,
                                          SysId: string;
                                      out ReplacementText: string;
                                      out Error: TXmlErrorType) of object;

  TDomResolveEntityEvent = procedure(      Sender: TObject;
                                     const EntityName: string;
                                       var EntityValue,
                                           PubId,
                                           SysId: string;
                                       var Error: TXmlErrorType) of object;
{$ELSE !NEXTGEN}
  TDomResolveResourceEvent = procedure(      Sender: TObject;
                                       const ResourceType,
                                             NamespaceURI: WideString;
                                         var PublicId,
                                             SystemId: WideString;
                                         var Stream: TStream;
                                         var CertifiedText: Boolean) of object;

  TDomResolveEntityProc = procedure(const Origin: TDtdOrigin;
                                    const BaseURI,
                                          PubId,
                                          SysId: WideString;
                                      out ReplacementText: WideString;
                                      out Error: TXmlErrorType) of object;

  TDomResolveEntityEvent = procedure(      Sender: TObject;
                                     const EntityName: WideString;
                                       var EntityValue,
                                           PubId,
                                           SysId: WideString;
                                       var Error: TXmlErrorType) of object;
{$ENDIF NEXTGEN}

  TDomSerializationEvent = procedure(Sender: TXmlStreamBuilder;
                                     PieceType: TDomPieceType;
                                     const Locator: IDomLocator) of object;

{$IFDEF NEXTGEN}
  TDomWideStringLocationEvent = procedure(Sender: TObject;
                                          const S: string;
                                          const Locator: IDomLocator) of object;
{$ELSE !NEXTGEN}
  TDomWideStringLocationEvent = procedure(Sender: TObject;
                                          const S: WideString;
                                          const Locator: IDomLocator) of object;
{$ENDIF NEXTGEN}

  TDomError = class;

  TDomErrorEvent = procedure(    Sender: TObject;
                                 Error: TDomError;
                             var Go: Boolean) of object;

{$IFDEF NEXTGEN}
  TDomRequestXPathFunctionResultEvent = procedure(const NamespaceURI,
                                                        LocalName: string;
                                                  const ContextNode: TDomNode;
                                                  const ContextPosition: Integer;
                                                  const ContextSize: Integer;
                                                  const Arguments: TList<TDomXPathSyntaxNode>;
                                                    var Value: TDomXPathCustomResult) of object;

  TDomRequestXPathVariableEvent = procedure(const Sender: TXPathExpression;
                                            const NamespaceURI,
                                                  LocalName: string;
                                              var Value: TDomXPathCustomResult) of object;

  TDomXPathLookupNamespaceURIEvent = procedure(const Sender: TXPathExpression;
                                               const APrefix: string;
                                                 var ANamespaceURI: string) of object;
{$ELSE !NEXTGEN}
  TDomRequestXPathFunctionResultEvent = procedure(const NamespaceURI,
                                                        LocalName: WideString;
                                                  const ContextNode: TDomNode;
                                                  const ContextPosition: Integer;
                                                  const ContextSize: Integer;
                                                  const Arguments: TList<TDomXPathSyntaxNode>;
                                                    var Value: TDomXPathCustomResult) of object;

  TDomRequestXPathVariableEvent = procedure(const Sender: TXPathExpression;
                                            const NamespaceURI,
                                                  LocalName: WideString;
                                              var Value: TDomXPathCustomResult) of object;

  TDomXPathLookupNamespaceURIEvent = procedure(const Sender: TXPathExpression;
                                               const APrefix: WideString;
                                                 var ANamespaceURI: WideString) of object;
{$ENDIF NEXTGEN}

  TDtdModel               = class;
  TDtdValidationAgent     = class;
  TDtdAttributeDecl       = class;
  TDtdElementDecl         = class;
  TDtdEntityDecl          = class;
  TDtdNotationDecl        = class;

  TCustomResourceResolver = class;

{$IFDEF CLR}
  TUtilsNoRefCount = class(TInterfacedObject)
  end;

    // On the .NET platform reference counting of Interfaces is obsolete.
    // TUtilsNoRefCount is defined anyway for single sourcing.

{$ELSE}
  TUtilsNoRefCount = class(TObject, IUnknown)
  protected
    function QueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
    function _AddRef: Integer; stdcall;
    function _Release: Integer; stdcall;
  end;
{$ENDIF}

{$IFDEF NEXTGEN}
  TDomBaseComponent = class(TComponent)
  protected
    function GetADOMVersion: string;
  public
    property ADOMVersion: string read GetADOMVersion;
  end;
{$ELSE !NEXTGEN}
  TDomBaseComponent = class(TComponent)
  protected
    function GetADOMVersion: WideString;
  public
    property ADOMVersion: WideString read GetADOMVersion;
  end;
{$ENDIF NEXTGEN}

  TDomImplementation = class(TDomBaseComponent)
  private
    FErrorReportLevel: Word;
    FResourceResolver: TCustomResourceResolver;

    FOnAttrModified: TDomAttrModifiedEvent;
    FOnCharacterDataModified: TDomNotifyNodeEvent;
    FOnError: TDomErrorEvent;
    FOnNodeClearing: TDomNotifyNodeEvent;
    FOnNodeInserted: TDomNotifyNodeEvent;
    FOnNodeRemoving: TDomNotifyNodeEvent;
    FOnRequestXPathFunctionResult: TDomRequestXPathFunctionResultEvent;
    FOnRequestXPathVariable: TDomRequestXPathVariableEvent;

    procedure Attach(ADocument: TDomCustomDocument);
    procedure DestroyOwnedDocuments;
    procedure Detach(ADocument: TDomCustomDocument);
    function GetErrorEventsDisabled: Boolean;
  protected
    FDocuments: TDomNodeList;
    FOwnedDocumentsList: TList<TCustomOwnedNode>;
    procedure DoAttrModified(const ModifiedNode: TDomNode;
                             const AttrChange: TDomAttrChange;
                             const RelatedAttr: TDomAttr); virtual;
    procedure DoCharacterDataModified(ModifiedNode: TDomNode); virtual;
    procedure DoError(    Sender: TObject;
                          Error: TDomError;
                      var Go: Boolean); virtual;
    procedure DoNodeClearing(Node: TDomNode); virtual;
    procedure DoNodeInserted(Node: TDomNode); virtual;
    procedure DoNodeRemoving(Node: TDomNode); virtual;
{$IFDEF NEXTGEN}
    procedure DoRequestXPathFunctionResult(const NamespaceURI,
                                                 LocalName: string;
                                           const ContextNode: TDomNode;
                                           const ContextPosition: Integer;
                                           const ContextSize: Integer;
                                           const Arguments: TList<TDomXPathSyntaxNode>;
                                             var Value: TDomXPathCustomResult); virtual;
    procedure DoRequestXPathVariable(const XPathExpression: TXPathExpression;
                                     const NamespaceURI,
                                           LocalName: string;
                                       var Value: TDomXPathCustomResult); virtual;
{$ELSE !NEXTGEN}
    procedure DoRequestXPathFunctionResult(const NamespaceURI,
                                                 LocalName: WideString;
                                           const ContextNode: TDomNode;
                                           const ContextPosition: Integer;
                                           const ContextSize: Integer;
                                           const Arguments: TList<TDomXPathSyntaxNode>;
                                             var Value: TDomXPathCustomResult); virtual;
    procedure DoRequestXPathVariable(const XPathExpression: TXPathExpression;
                                     const NamespaceURI,
                                           LocalName: WideString;
                                       var Value: TDomXPathCustomResult); virtual;
{$ENDIF NEXTGEN}
    function GetDocuments: TDomNodeList; virtual;
    procedure Notification(AComponent: TComponent;
                           Operation: TOperation); override;
    procedure SetResourceResolver(const AResourceResolver: TCustomResourceResolver); virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Clear; virtual;
    procedure DisableErrorEvents; virtual;
    procedure EnableErrorEvents; virtual;
    function HandleError(const Sender: TObject;
                         const Error: TDomError): Boolean; virtual;
{$IFDEF NEXTGEN}
    function ResolveResourceAsStream(const ABaseURI: string;
                                       var PublicId,
                                           SystemId: string): TStream; virtual;
    procedure ResolveResourceAsWideString(const ABaseURI: string;
                                            var PublicId,
                                                SystemId: string;
                                            out S: string;
                                            out Error: TXmlErrorType); virtual;
{$ELSE !NEXTGEN}
    function ResolveResourceAsStream(const ABaseURI: WideString;
                                       var PublicId,
                                           SystemId: WideString): TStream; virtual;
    procedure ResolveResourceAsWideString(const ABaseURI: WideString;
                                            var PublicId,
                                                SystemId: WideString;
                                            out S: WideString;
                                            out Error: TXmlErrorType); virtual;
{$ENDIF NEXTGEN}
    property Documents: TDomNodeList read GetDocuments;
    property ErrorEventsDisabled: Boolean read GetErrorEventsDisabled;
    { Closures with generics cannot be published for C++ }
    property OnRequestXPathFunctionResult:  TDomRequestXPathFunctionResultEvent read FOnRequestXPathFunctionResult write FOnRequestXPathFunctionResult;
  published
    property ResourceResolver: TCustomResourceResolver read FResourceResolver write SetResourceResolver;

    property OnAttrModified:          TDomAttrModifiedEvent read FOnAttrModified write FOnAttrModified;
    property OnCharacterDataModified: TDomNotifyNodeEvent read FOnCharacterDataModified write FOnCharacterDataModified;
    property OnError:                 TDomErrorEvent read FOnError write FOnError;
    property OnNodeClearing:          TDomNotifyNodeEvent read FOnNodeClearing write FOnNodeClearing;
    property OnNodeInserted:          TDomNotifyNodeEvent read FOnNodeInserted write FOnNodeInserted;
    property OnNodeRemoving:          TDomNotifyNodeEvent read FOnNodeRemoving write FOnNodeRemoving;
    property OnRequestXPathVariable:  TDomRequestXPathVariableEvent read FOnRequestXPathVariable write FOnRequestXPathVariable;
  end;

  TDomNodeFilter = class
  public
    function AcceptNode(const N: TDomNode): TDomFilterResult; virtual; abstract;
  end;

  TDomTreeWalker = class
  private
    FCurrentNode: TDomNode;
    FExpandEntityReferences: Boolean;
    FFilter: TDomNodeFilter;
    FRoot: TDomNode;
    FWhatToShow: TDomWhatToShow;
  protected
    function FindFirstChild(const OldNode: TDomNode): TDomNode; virtual;
    function FindLastChild(const OldNode: TDomNode): TDomNode; virtual;
    function FindNextNode(OldNode: TDomNode): TDomNode; virtual;
    function FindNextSibling(const OldNode: TDomNode): TDomNode; virtual;
    function FindParentNode(const OldNode: TDomNode): TDomNode; virtual;
    function FindPreviousNode(const OldNode: TDomNode): TDomNode; virtual;
    function FindPreviousSibling(const OldNode: TDomNode): TDomNode; virtual;
    procedure SetCurrentNode(const Node: TDomNode); virtual;
    procedure SetExpandEntityReferences(const Value: Boolean); virtual;  // Derived classes may move this method to the public section to allow write access.
    procedure SetFilter(const Value: TDomNodeFilter); virtual;           // Derived classes may move this method to the public section to allow write access.
    procedure SetRoot(const Node: TDomNode); virtual;                    // Derived classes may move this method to the public section to allow write access.
    procedure SetWhatToShow(const Value: TDomWhatToShow); virtual;       // Derived classes may move this method to the public section to allow write access.
  public
    constructor Create(const Root: TDomNode;
                       const WhatToShow: TDomWhatToShow;
                       const NodeFilter: TDomNodeFilter;
                       const EntityReferenceExpansion: Boolean); virtual;
    function ParentNode: TDomNode; virtual;
    function FirstChild: TDomNode; virtual;
    function LastChild: TDomNode; virtual;
    function PreviousSibling: TDomNode; virtual;
    function NextSibling: TDomNode; virtual;
    function NextNode: TDomNode; virtual;
    function PreviousNode: TDomNode; virtual;
    property CurrentNode: TDomNode read FCurrentNode write SetCurrentNode;
    property ExpandEntityReferences: Boolean read FExpandEntityReferences;
    property Filter: TDomNodeFilter read FFilter;
    property Root: TDomNode read FRoot;
    property WhatToShow: TDomWhatToShow read FWhatToShow;
  end;

  TDomNodeIterator = class
  private
    FRoot: TDomNode;
    FReferenceNode: TDomNode;
    FPosition: TDomPosition; // Position of the Iterator relativ to FReferenceNode
    FWhatToShow: TDomWhatToShow;
    FExpandEntityReferences: Boolean;
    FFilter: TDomNodeFilter;
    FInvalid: Boolean;
  protected
    procedure HandleNodeEvent(const Node: TDomNode;
                              const EventType: TDomNodeEvent); virtual; // Used to receive notifications about node events.
    function FindNextNode(OldNode: TDomNode): TDomNode; virtual;
    function FindPreviousNode(const OldNode: TDomNode): TDomNode; virtual;
  public
    constructor Create(const Root: TDomNode;
                       const WhatToShow: TDomWhatToShow;
                       const NodeFilter: TDomNodeFilter;
                       const EntityReferenceExpansion: Boolean); virtual;
    procedure Detach; virtual;
    function NextNode: TDomNode; virtual;
    function PreviousNode: TDomNode; virtual;
    property ExpandEntityReferences: Boolean read FExpandEntityReferences;
    property Filter: TDomNodeFilter read FFilter;
    property Root: TDomNode read FRoot;
    property WhatToShow: TDomWhatToShow read FWhatToShow;
  end;

  TDomNodeList = class
  private
    FNodeList: TList<TCustomOwnedNode>;
  protected
    function GetLength: Integer; virtual;
    function IndexOf(const Node: TDomNode): Integer; virtual;
  public
    constructor Create(const NodeList: TList<TCustomOwnedNode>);
    function Item(const Index: Integer): TDomNode; virtual;
    property Length: Integer read GetLength;
  end;

  TDomElementsNodeList = class(TDomNodeList)
  private
{$IFDEF NEXTGEN}
    FQueryName: string;
{$ELSE !NEXTGEN}
    FQueryName: WideString;
{$ENDIF NEXTGEN}
    FStartElement: TDomNode;
  protected
    function GetLength: Integer; override;
  public
    function IndexOf(const Node: TDomNode): Integer; override;
    function Item(const Index: Integer): TDomNode; override;
{$IFDEF NEXTGEN}
    constructor Create(const QueryName: string;
                       const StartElement: TDomNode); virtual;
{$ELSE !NEXTGEN}
    constructor Create(const QueryName: WideString;
                       const StartElement: TDomNode); virtual;
{$ENDIF NEXTGEN}
  end;

  TDomElementsNodeListNS = class(TDomNodeList)
  private
{$IFDEF NEXTGEN}
    FQueryNamespaceURI: string;
    FQueryLocalName: string;
{$ELSE !NEXTGEN}
    FQueryNamespaceURI: WideString;
    FQueryLocalName: WideString;
{$ENDIF NEXTGEN}
    FStartElement: TDomNode;
  protected
    function GetLength: Integer; override;
  public
    function IndexOf(const Node: TDomNode): Integer; override;
    function Item(const Index: Integer): TDomNode; override;
{$IFDEF NEXTGEN}
    constructor Create(const QueryNamespaceURI,
                             QueryLocalName: string;
                       const StartElement: TDomNode); virtual;
{$ELSE !NEXTGEN}
    constructor Create(const QueryNamespaceURI,
                             QueryLocalName: WideString;
                       const StartElement: TDomNode); virtual;
{$ENDIF NEXTGEN}
  end;

{$IFDEF NEXTGEN}
  TDomCustomNode = class(TCustomOwnedNode)
  protected
    function GetNodeName: string; virtual; abstract;
    procedure RaiseException(const E: {$IFDEF CLR}ExceptionClass{$ELSE}ExceptClass{$ENDIF}); override;
  public
    property NodeName: string read GetNodeName;
  end;
{$ELSE !NEXTGEN}
  TDomCustomNode = class(TCustomOwnedNode)
  protected
    function GetNodeName: WideString; virtual; abstract;
    procedure RaiseException(const E: {$IFDEF CLR}ExceptionClass{$ELSE}ExceptClass{$ENDIF}); override;
  public
    property NodeName: WideString read GetNodeName;
  end;
{$ENDIF NEXTGEN}

  TDomNamedNodeMap = class(TDomNodeList)
  private
    FAllowedNodeTypes: TDomWhatToShow;
    FDefaultNamespaceAware: Boolean;
    [Weak] FOwnerNode: TDomNode;
  protected
    procedure CheckAllowedNodeType(const Node: TDomNode);
    procedure CheckHasNode(const Node: TDomNode);
    procedure CheckNamespaceAware;
    procedure CheckNotInUse(const Node: TDomNode);
    procedure CheckNotNamespaceAware;
    procedure CheckNotReadOnly;
    procedure CheckSameRootDocument(const Node: TDomNode);
    function GetNamespaceAware: Boolean;
    function GetReadOnly: Boolean;
    procedure InternalAdd(const Node: TDomNode); virtual;
    procedure InternalRemove(const Node: TDomNode); virtual;
    function RemoveItem(const Arg: TDomNode): TDomNode; virtual;
  public
    constructor Create(const AOwner: TDomNode;
                       const NodeList: TList<TCustomOwnedNode>;
                       const AllowedNTs: TDomWhatToShow;
                       const DefaultNamespaceAware: Boolean); virtual;
{$IFDEF NEXTGEN}
    function GetNamedItem(const Name: string): TDomNode; virtual;
    function GetNamedItemNS(const NamespaceURI,
                                  LocalName: string): TDomNode; virtual;
    function RemoveNamedItem(const Name: string): TDomNode; virtual;
    function RemoveNamedItemNS(const NamespaceURI,
                                     LocalName: string): TDomNode; virtual;
{$ELSE !NEXTGEN}
    function GetNamedItem(const Name: WideString): TDomNode; virtual;
    function GetNamedItemNS(const NamespaceURI,
                                  LocalName: WideString): TDomNode; virtual;
    function RemoveNamedItem(const Name: WideString): TDomNode; virtual;
    function RemoveNamedItemNS(const NamespaceURI,
                                     LocalName: WideString): TDomNode; virtual;
{$ENDIF NEXTGEN}
    function SetNamedItem(const Arg: TDomNode): TDomNode; virtual;
    function SetNamedItemNS(const Arg: TDomNode): TDomNode; virtual;
    property NamespaceAware: Boolean read GetNamespaceAware;
    property OwnerNode: TDomNode read FOwnerNode;
    property readOnly: Boolean read GetReadOnly;
  end;

  TDomNode = class(TDomCustomNode)
  private
    FIsNamespaceNode: Boolean;
    FNodeList: TDomNodeList;
{$IFDEF VER200+}
    FNodeValues: TStringList;
{$ENDIF VER200+}
{$IFDEF NEXTGEN}
    FNodeValue: string;
    [Weak] FOwnerDocument: TDomCustomDocument;
    FUserData: TUtilsWideStringList;
    FUserDataHandlers: TList<TDomUserDataEvent>;
    procedure MakeChildrenReadOnly;
    function PreviousNode: TDomNode;
    function HasEntRef(const EntName: string): Boolean;
{$ELSE !NEXTGEN}
    FNodeValue: WideString;
    FOwnerDocument: TDomCustomDocument;
    FUserData: TUtilsWideStringList;
    FUserDataHandlers: TList<TDomUserDataEvent>;
    procedure MakeChildrenReadOnly;
    function PreviousNode: TDomNode;
    function HasEntRef(const EntName: widestring): Boolean;
{$ENDIF NEXTGEN}
  protected
    FAllowedChildTypes: set of TDomNodeType;
    procedure CheckTypeAllowed(const Node: TDomNode); virtual;
    procedure DoAfterAddition(const Node: TCustomOwnedNode); override;
    procedure DoBeforeClear; override;
    procedure DoBeforeRemoval(const Node: TCustomOwnedNode); override;
    function GetAbsoluteIndex: Integer; virtual;
    function GetAttributes: TDomNamedNodeMap; virtual;
{$IFNDEF NEXTGEN}
    function GetBaseUri: WideString; virtual;
    function GetChildNodes: TDomNodeList; virtual;
    function GetDocument: TDomCustomDocument; virtual;
    function GetExpandedName: WideString; virtual;
    function GetFirstChild: TDomNode; reintroduce; virtual;
    function GetLanguage: WideString; virtual;
    function GetLastChild: TDomNode; reintroduce; virtual;
    function GetLevel: Integer; virtual;
    function GetLocalName: WideString; virtual;
    function GetNamespaceURI: WideString; virtual;
    function GetNextSibling: TDomNode; reintroduce; virtual;
    function GetNodeName: WideString; override;
    function GetNodeValue: WideString; virtual;
    function GetNodeType: TDomNodeType; virtual;
    function GetParentNode: TDomNode; virtual;
    function GetPreviousSibling: TDomNode; reintroduce; virtual;
    function GetPrefix: WideString; virtual;
    function GetRootDocument: TDomCustomDocument; virtual;
    function GetTextContent: WideString; virtual;
    function GetXPathStringValue: WideString; virtual;
    procedure SetNodeValue(const Value: WideString); virtual;
    procedure SetPrefix(const Value: WideString); virtual;
  {$IFDEF VER200+}
    procedure AddNodeValue(const Value: WideString);
  {$ENDIF VER200+}
{$ELSE NEXTGEN}
    function GetBaseUri: DOMString; virtual;
    function GetChildNodes: TDomNodeList; virtual;
    function GetDocument: TDomCustomDocument; virtual;
    function GetExpandedName: string; virtual;
    function GetFirstChild: TDomNode; reintroduce; virtual;
    function GetLanguage: string; virtual;
    function GetLastChild: TDomNode; reintroduce; virtual;
    function GetLevel: Integer; virtual;
    function GetLocalName: string; virtual;
    function GetNamespaceURI: string; virtual;
    function GetNextSibling: TDomNode; reintroduce; virtual;
    function GetNodeName: string; override;
    function GetNodeValue: string; virtual;
    function GetNodeType: TDomNodeType; virtual;
    function GetParentNode: TDomNode; virtual;
    function GetPreviousSibling: TDomNode; reintroduce; virtual;
    function GetPrefix: string; virtual;
    function GetRootDocument: TDomCustomDocument; virtual;
    function GetTextContent: string; virtual;
    function GetXPathStringValue: string; virtual;
    procedure SetNodeValue(const Value: string); virtual;
    procedure SetPrefix(const Value: string); virtual;
  {$IFDEF VER200+}
    procedure AddNodeValue(const Value: string);
  {$ENDIF VER200+}
{$ENDIF !NEXTGEN}

{$IFDEF CLR}
    procedure SetReadOnly(const Value: Boolean); override;
    // Remark: In Delphi for .NET we must repeat a protected declaration inherited
    //         from another assembly in order to use it outside of a direct ancestor.
{$ENDIF}
  public
    constructor Create(const AOwner: TCustomOwnedObject);
    destructor Destroy; override;
    function  AppendChild(const NewChild: TDomNode): TDomNode; virtual;
    procedure Clear; override;
    function  CloneNode(const Deep: Boolean): TDomNode; virtual;
    function  CompareDocumentPosition(const Other: TDomNode): TDomDocumentPosition; virtual;
{$IFDEF NEXTGEN}
    function  EvaluateToBoolean(const Expression: string): Boolean; virtual;
    function  EvaluateToNumber(const Expression: string): Double; virtual;
    function  EvaluateToNode(const Expression: string): TDomNode; virtual;
    function  EvaluateToWideString(const Expression: string): string; virtual;
{$ELSE !NEXTGEN}
    function  EvaluateToBoolean(const Expression: WideString): Boolean; virtual;
    function  EvaluateToNumber(const Expression: WideString): Double; virtual;
    function  EvaluateToNode(const Expression: WideString): TDomNode; virtual;
    function  EvaluateToWideString(const Expression: WideString): WideString; virtual;
{$ENDIF NEXTGEN}
    function  FindFirstChildElement: TDomElement; virtual;
    function  FindLastChildElement: TDomElement; virtual;
    function  FindNextSiblingElement: TDomElement; virtual;
    function  FindParentElement: TDomElement; virtual;
    function  FindPreviousSiblingElement: TDomElement; virtual;
{$IFDEF NEXTGEN}
    function  GetFirstChildElement(const Name: string): TDomElement; virtual;
    function  GetFirstChildElementNS(const NamespaceURI,
                                           LocalName: string): TDomElement; virtual;
    function  GetLastChildElement(const Name: string): TDomElement; virtual;
    function  GetLastChildElementNS(const NamespaceURI,
                                          LocalName: string): TDomElement; virtual;
    function  GetNextSiblingElement(const Name: string): TDomElement; virtual;
    function  GetNextSiblingElementNS(const NamespaceURI,
                                            LocalName: string): TDomElement; virtual;
    function  GetParentElement(const Name: string): TDomElement; virtual;
    function  GetParentElementNS(const NamespaceURI,
                                       LocalName: string): TDomElement; virtual;
    function  GetPreviousSiblingElement(const Name: string): TDomElement; virtual;
    function  GetPreviousSiblingElementNS(const NamespaceURI,
                                                LocalName: string): TDomElement; virtual;
    function  GetUserData(const Key: string): TObject; virtual;
{$ELSE !NEXTGEN}
    function  GetFirstChildElement(const Name: WideString): TDomElement; virtual;
    function  GetFirstChildElementNS(const NamespaceURI,
                                           LocalName: WideString): TDomElement; virtual;
    function  GetLastChildElement(const Name: WideString): TDomElement; virtual;
    function  GetLastChildElementNS(const NamespaceURI,
                                          LocalName: WideString): TDomElement; virtual;
    function  GetNextSiblingElement(const Name: WideString): TDomElement; virtual;
    function  GetNextSiblingElementNS(const NamespaceURI,
                                            LocalName: WideString): TDomElement; virtual;
    function  GetParentElement(const Name: WideString): TDomElement; virtual;
    function  GetParentElementNS(const NamespaceURI,
                                       LocalName: WideString): TDomElement; virtual;
    function  GetPreviousSiblingElement(const Name: WideString): TDomElement; virtual;
    function  GetPreviousSiblingElementNS(const NamespaceURI,
                                                LocalName: WideString): TDomElement; virtual;
    function  GetUserData(const Key: WideString): TObject; virtual;
{$ENDIF NEXTGEN}
    function  HasAsAncestor(const Node: TDomNode): Boolean; reintroduce; virtual;
    function  HasAttributes: Boolean; virtual;
    function  HasChildNodes: Boolean; virtual;
    function  InsertBefore(const NewChild,
                                 RefChild: TDomNode): TDomNode; reintroduce; virtual;
{$IFDEF NEXTGEN}
    function  LookupNamespaceURI(const APrefix: string): string; virtual;
{$ELSE !NEXTGEN}
    function  LookupNamespaceURI(const APrefix: WideString): WideString; virtual;
{$ENDIF NEXTGEN}
    procedure Normalize; virtual;
    function  RemoveChild(const OldChild: TDomNode): TDomNode; virtual;
    function  ReplaceChild(const NewChild,
                                 OldChild: TDomNode): TDomNode; virtual;
{$IFDEF NEXTGEN}
    function  SetUserData(const Key: string;
                          const Data: TObject;
                          const Handler: TDomUserDataEvent): TObject; virtual;

    property AbsoluteIndex:     Integer            read GetAbsoluteIndex;
    property Attributes:        TDomNamedNodeMap   read GetAttributes;
    property BaseUri:           string             read GetBaseUri;
    property ChildNodes:        TDomNodeList       read GetChildNodes;
    property ExpandedName:      string             read GetExpandedName;
    property FirstChild:        TDomNode           read GetFirstChild;
    property IsNamespaceNode:   Boolean            read FIsNamespaceNode;
    property IsReadonly:        Boolean            read GetReadOnly;
    property Language:          string             read GetLanguage;
    property LastChild:         TDomNode           read GetLastChild;
    property Level:             Integer            read GetLevel;
    property LocalName:         string             read GetLocalName;
    property NamespaceURI:      string             read GetNamespaceURI;
    property NextSibling:       TDomNode           read GetNextSibling;
    property NodeType:          TDomNodeType       read GetNodeType;
    property NodeValue:         string             read GetNodeValue write SetNodeValue;
    property OwnerDocument:     TDomCustomDocument read GetDocument;
    property ParentNode:        TDomNode           read GetParentNode;
    property PreviousSibling:   TDomNode           read GetPreviousSibling;
    property Prefix:            string             read GetPrefix    write SetPrefix;
    property RootDocument:      TDomCustomDocument read GetRootDocument;
    property TextContent:       string             read GetTextContent;
    property XPathStringValue:  string             read GetXPathStringValue;
{$ELSE !NEXTGEN}
    function  SetUserData(const Key: WideString;
                          const Data: TObject;
                          const Handler: TDomUserDataEvent): TObject; virtual;

    property AbsoluteIndex:     Integer            read GetAbsoluteIndex;
    property Attributes:        TDomNamedNodeMap   read GetAttributes;
    property BaseUri:           WideString         read GetBaseUri;
    property ChildNodes:        TDomNodeList       read GetChildNodes;
    property ExpandedName:      WideString         read GetExpandedName;
    property FirstChild:        TDomNode           read GetFirstChild;
    property IsNamespaceNode:   Boolean            read FIsNamespaceNode;
    property IsReadonly:        Boolean            read GetReadOnly;
    property Language:          WideString         read GetLanguage;
    property LastChild:         TDomNode           read GetLastChild;
    property Level:             Integer            read GetLevel;
    property LocalName:         WideString         read GetLocalName;
    property NamespaceURI:      WideString         read GetNamespaceURI;
    property NextSibling:       TDomNode           read GetNextSibling;
    property NodeType:          TDomNodeType       read GetNodeType;
    property NodeValue:         WideString         read GetNodeValue write SetNodeValue;
    property OwnerDocument:     TDomCustomDocument read GetDocument;
    property ParentNode:        TDomNode           read GetParentNode;
    property PreviousSibling:   TDomNode           read GetPreviousSibling;
    property Prefix:            WideString         read GetPrefix    write SetPrefix;
    property RootDocument:      TDomCustomDocument read GetRootDocument;
    property TextContent:       WideString         read GetTextContent;
    property XPathStringValue:  WideString         read GetXPathStringValue;
{$ENDIF NEXTGEN}
  end;

  TDomCharacterData = class(TDomNode)
  private
{$IFDEF NEXTGEN}
    function GetData: string; virtual;
    procedure SetData(const Value: string); virtual;
{$ELSE !NEXTGEN}
    function GetData: WideString; virtual;
    procedure SetData(const Value: WideString); virtual;
{$ENDIF NEXTGEN}
    function GetLength: Integer; virtual;
  protected
    procedure DoCharacterDataModified; virtual;
  public
    constructor Create(const AOwner: TDomCustomDocument);
{$IFDEF NEXTGEN}
    function SubstringData(const Offset,
                                 Count: Integer): string; virtual;
    procedure AppendData(const Arg: string); virtual;
    procedure InsertData(const Offset: Integer;
                         const Arg: string); virtual;
    procedure DeleteData(const Offset,
                               Count: Integer); virtual;
    procedure ReplaceData(const Offset,
                                Count: Integer;
                          const Arg: string); virtual;
    property Data: string read GetData write SetData;
{$ELSE !NEXTGEN}
    function SubstringData(const Offset,
                                 Count: Integer): WideString; virtual;
    procedure AppendData(const Arg: WideString); virtual;
    procedure InsertData(const Offset: Integer;
                         const Arg: WideString); virtual;
    procedure DeleteData(const Offset,
                               Count: Integer); virtual;
    procedure ReplaceData(const Offset,
                                Count: Integer;
                          const Arg: WideString); virtual;
    property Data: WideString read GetData write SetData;
{$ENDIF NEXTGEN}
    property Length: Integer read GetLength;
  end;

  TDomAttr = class(TDomNode)
  private
    FIsXmlnsDecl: TDomXmlnsDeclType;
{$IFDEF NEXTGEN}
    FLocalName: string;
    FNamespaceURI: string;
    FNodeName: string;
    [Weak] FOwnerMap: TDomNamedNodeMap;
    FPrefix: string;
{$ELSE !NEXTGEN}
    FLocalName: WideString;
    FNamespaceURI: WideString;
    FNodeName: WideString;
    FOwnerMap: TDomNamedNodeMap;
    FPrefix: WideString;
{$ENDIF NEXTGEN}
    function GetDataType: TXmlDataType;
  protected
    FSpecified: Boolean;
    procedure DoAttrModified(const AttrChange: TDomAttrChange); virtual;
{$IFDEF NEXTGEN}
    function GetExpandedName: string; override;
    function GetIsXmlnsDecl: TDomXmlnsDeclType; virtual;
    function GetLocalName: string; override;
    function GetName: string; virtual;
    function GetNamespaceURI: string; override;
    function GetNextSibling: TDomNode; override;
    function GetNodeName: string; override;
    function GetNodeType: TDomNodeType; override;
    function GetOwnerElement: TDomElement; virtual;
    function GetPrefix: string; override;
    function GetPreviousSibling: TDomNode; override;
    function GetSpecified: Boolean; virtual;
    function GetValue: string; virtual;
    procedure SetNodeValue(const Value: string); override;
    procedure SetPrefix(const Value: string); override;
{$ELSE !NEXTGEN}
    function GetExpandedName: WideString; override;
    function GetIsXmlnsDecl: TDomXmlnsDeclType; virtual;
    function GetLocalName: WideString; override;
    function GetName: WideString; virtual;
    function GetNamespaceURI: WideString; override;
    function GetNextSibling: TDomNode; override;
    function GetNodeName: WideString; override;
    function GetNodeType: TDomNodeType; override;
    function GetOwnerElement: TDomElement; virtual;
    function GetPrefix: WideString; override;
    function GetPreviousSibling: TDomNode; override;
    function GetSpecified: Boolean; virtual;
    function GetValue: WideString; virtual;
    procedure SetNodeValue(const Value: WideString); override;
    procedure SetPrefix(const Value: WideString); override;
{$ENDIF NEXTGEN}
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomDocument;
                       const Name: string;
                       const Spcfd: Boolean);
    constructor CreateNS(const AOwner: TDomDocumentNS;
                         const NamespaceURI,
                               QualifiedName: string;
                         const Spcfd: Boolean);
    destructor Destroy; override;
    function LookupNamespaceURI(const APrefix: string): string; override;

    property DataType: TXmlDataType read GetDataType;
    property IsXmlnsDecl: TDomXmlnsDeclType read GetIsXmlnsDecl;
    property Name: string read GetName;
    property OwnerElement: TDomElement read GetOwnerElement;
    property Specified: Boolean read GetSpecified;
    property Value: string read GetValue;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomDocument;
                       const Name: WideString;
                       const Spcfd: Boolean);
    constructor CreateNS(const AOwner: TDomDocumentNS;
                         const NamespaceURI,
                               QualifiedName: WideString;
                         const Spcfd: Boolean);
    destructor Destroy; override;
    function LookupNamespaceURI(const APrefix: WideString): WideString; override;

    property DataType: TXmlDataType read GetDataType;
    property IsXmlnsDecl: TDomXmlnsDeclType read GetIsXmlnsDecl;
    property Name: WideString read GetName;
    property OwnerElement: TDomElement read GetOwnerElement;
    property Specified: Boolean read GetSpecified;
    property Value: WideString read GetValue;
{$ENDIF NEXTGEN}
  end;

  TDomElement = class(TDomNode)
  private
    FAttributeList: TDomNamedNodeMap;
    FAttributeListing: TList<TCustomOwnedNode>;
    FCreatedElementsNodeListNSs: TList<TDomNodeList>;
    FCreatedElementsNodeLists: TList<TDomNodeList>;
{$IFDEF NEXTGEN}
    FLocalName: string;
    FNamespaceURI: string;
    FNodeName: string;
    FPrefix: string;
{$ELSE !NEXTGEN}
    FLocalName: WideString;
    FNamespaceURI: WideString;
    FNodeName: WideString;
    FPrefix: WideString;
{$ENDIF NEXTGEN}
  protected
    procedure DoAttrModified(const originalTarget: TDomNode;
                             const AttrChange: TDomAttrChange;
                             const RelatedAttr: TDomAttr); virtual;
    procedure DoBeforeClear; override;
{$IFDEF NEXTGEN}
    function GetExpandedName: string; override;
    function GetLocalName: string; override;
    function GetNamespaceURI: string; override;
    function GetNodeName: string; override;
    function GetNodeType: TDomNodeType; override;
    function GetPrefix: string; override;
    procedure SetNodeValue(const Value: string); override;
    procedure SetPrefix(const Value: string); override;
{$ELSE !NEXTGEN}
    function GetExpandedName: WideString; override;
    function GetLocalName: WideString; override;
    function GetNamespaceURI: WideString; override;
    function GetNodeName: WideString; override;
    function GetNodeType: TDomNodeType; override;
    function GetPrefix: WideString; override;
    procedure SetNodeValue(const Value: WideString); override;
    procedure SetPrefix(const Value: WideString); override;
{$ENDIF NEXTGEN}
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomDocument;
                       const TagName: string);
    constructor CreateNS(const AOwner: TDomDocumentNS;
                         const NamespaceURI,
                               QualifiedName: string);
    destructor Destroy; override;
    function GetAttributeLiteralValue(const Name: string): string; virtual;
    function GetAttributeNode(const Name: string): TDomAttr; virtual;
    function GetAttributeNodeNS(const NamespaceURI,
                                      LocalName: string): TDomAttr; virtual;
    function GetAttributeNormalizedValue(const Name: string): string; virtual;
    function GetAttributeNSLiteralValue(const NamespaceURI,
                                              LocalName: string): string; virtual;
    function GetAttributeNSNormalizedValue(const NamespaceURI,
                                                 LocalName: string): string; virtual;
    function GetAttributes: TDomNamedNodeMap; override;
    function GetElementsByTagName(const Name: string): TDomNodeList; virtual;
    function GetElementsByTagNameNS(const NamespaceURI,
                                          LocalName: string): TDomNodeList; virtual;
    function GetTagName: string; virtual;
    function HasAttribute(const Name: string): Boolean; virtual;
    function HasAttributeNS(const NamespaceURI,
                                  LocalName: string): Boolean; virtual;
    function LookupNamespaceURI(const APrefix: string): string; override;
    procedure Normalize; override;
    function RemoveAttribute(const Name: string): TDomAttr; virtual;
    function RemoveAttributeNode(const OldAttr: TDomAttr): TDomAttr; virtual;
    function RemoveAttributeNS(const NamespaceURI,
                                     LocalName: string): TDomAttr; virtual;
    function SetAttribute(const Name,
                                Value: string): TDomAttr; virtual;
    function SetAttributeNode(const NewAttr: TDomAttr): TDomAttr; virtual;
    function SetAttributeNodeNS(const NewAttr: TDomAttr): TDomAttr; virtual;
    function SetAttributeNS(const NamespaceURI,
                                  QualifiedName,
                                  Value: string): TDomAttr; virtual;

    property TagName: string read GetTagName;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomDocument;
                       const TagName: WideString);
    constructor CreateNS(const AOwner: TDomDocumentNS;
                         const NamespaceURI,
                               QualifiedName: WideString);
    destructor Destroy; override;
    function GetAttributeLiteralValue(const Name: WideString): WideString; virtual;
    function GetAttributeNode(const Name: WideString): TDomAttr; virtual;
    function GetAttributeNodeNS(const NamespaceURI,
                                      LocalName: WideString): TDomAttr; virtual;
    function GetAttributeNormalizedValue(const Name: WideString): WideString; virtual;
    function GetAttributeNSLiteralValue(const NamespaceURI,
                                              LocalName: WideString): WideString; virtual;
    function GetAttributeNSNormalizedValue(const NamespaceURI,
                                                 LocalName: WideString): WideString; virtual;
    function GetAttributes: TDomNamedNodeMap; override;
    function GetElementsByTagName(const Name: WideString): TDomNodeList; virtual;
    function GetElementsByTagNameNS(const NamespaceURI,
                                          LocalName: WideString): TDomNodeList; virtual;
    function GetTagName: WideString; virtual;
    function HasAttribute(const Name: WideString): Boolean; virtual;
    function HasAttributeNS(const NamespaceURI,
                                  LocalName: WideString): Boolean; virtual;
    function LookupNamespaceURI(const APrefix: WideString): WideString; override;
    procedure Normalize; override;
    function RemoveAttribute(const Name: WideString): TDomAttr; virtual;
    function RemoveAttributeNode(const OldAttr: TDomAttr): TDomAttr; virtual;
    function RemoveAttributeNS(const NamespaceURI,
                                     LocalName: WideString): TDomAttr; virtual;
    function SetAttribute(const Name,
                                Value: WideString): TDomAttr; virtual;
    function SetAttributeNode(const NewAttr: TDomAttr): TDomAttr; virtual;
    function SetAttributeNodeNS(const NewAttr: TDomAttr): TDomAttr; virtual;
    function SetAttributeNS(const NamespaceURI,
                                  QualifiedName,
                                  Value: WideString): TDomAttr; virtual;

    property TagName: WideString read GetTagName;
{$ENDIF NEXTGEN}
  end;

  TDomText = class(TDomCharacterData)
  private
    FCharRefGenerated: Boolean;
  protected
    function GetIsElementContentWhitespace: Boolean; virtual;
{$IFDEF NEXTGEN}
    function GetNodeName: string; override;
{$ELSE !NEXTGEN}
    function GetNodeName: WideString; override;
{$ENDIF NEXTGEN}
    function GetNodeType: TDomNodeType; override;
  public
    constructor Create(const AOwner: TDomCustomDocument);
    function SplitText(const Offset: Integer): TDomText; virtual;

    property CharRefGenerated: Boolean read FCharRefGenerated write FCharRefGenerated default False;
    property IsElementContentWhitespace: Boolean read GetIsElementContentWhitespace;
  end;

  TDomComment = class(TDomCharacterData)
  protected
{$IFDEF NEXTGEN}
    function GetNodeName: string; override;
{$ELSE !NEXTGEN}
    function GetNodeName: WideString; override;
{$ENDIF NEXTGEN}
    function GetNodeType: TDomNodeType; override;
  public
    constructor Create(const AOwner: TDomCustomDocument);
  end;

  TDomProcessingInstruction = class(TDomNode)
  private
{$IFDEF NEXTGEN}
    FTarget: string;
{$ELSE !NEXTGEN}
    FTarget: WideString;
{$ENDIF NEXTGEN}
  protected
    procedure DoCharacterDataModified; virtual;
{$IFDEF NEXTGEN}
    function GetData: string; virtual;
    function GetExpandedName: string; override;
    function GetNodeName: string; override;
    function GetNodeType: TDomNodeType; override;
    procedure SetData(const Value: string); virtual;
  public
    constructor Create(const AOwner: TDomCustomDocument;
                       const Targ: string);

    property Target: string read FTarget;
    property Data: string read GetData write SetData;
{$ELSE !NEXTGEN}
    function GetData: WideString; virtual;
    function GetExpandedName: WideString; override;
    function GetNodeName: WideString; override;
    function GetNodeType: TDomNodeType; override;
    procedure SetData(const Value: WideString); virtual;
  public
    constructor Create(const AOwner: TDomCustomDocument;
                       const Targ: WideString);

    property Target: WideString read FTarget;
    property Data: WideString read GetData write SetData;
{$ENDIF NEXTGEN}
  end;

  TDomCDATASection = class(TDomText)
  protected
{$IFDEF NEXTGEN}
    function GetNodeName: string; override;
{$ELSE !NEXTGEN}
    function GetNodeName: WideString; override;
{$ENDIF NEXTGEN}
    function GetNodeType: TDomNodeType; override;
  public
    constructor Create(const AOwner: TDomCustomDocument);
  end;

  TDomDocumentTypeDecl = class(TDomNode)
  private
{$IFDEF NEXTGEN}
    FInternalSubset: string;
{$ELSE !NEXTGEN}
    FInternalSubset: WideString;
{$ENDIF NEXTGEN}
    FIntSubsetStartColumn: Int64;
    FIntSubsetCharNumber: Int64;
    FIntSubsetByteNumber: Int64;
    FIntSubsetStartLine: Int64;
{$IFDEF NEXTGEN}
    FNodeName: string;
    FPublicId: string;
    FSystemId: string;
  protected
    function GetInternalSubset: string; virtual;
    function GetName: string; virtual;
    function GetNodeName: string; override;
    function GetNodeType: TDomNodeType; override;
    function GetPublicId: string; virtual;
    function GetSystemId: string; virtual;
    procedure SetNodeValue(const Value: string); override;
  public
    constructor Create(const AOwner: TDomCustomDocument;
                       const DoctypeName,
                             PubId,
                             SysId,
                             IntSubset: string);

    property InternalSubset: string read GetInternalSubset;
{$ELSE !NEXTGEN}
    FNodeName: WideString;
    FPublicId: WideString;
    FSystemId: WideString;
  protected
    function GetInternalSubset: WideString; virtual;
    function GetName: WideString; virtual;
    function GetNodeName: WideString; override;
    function GetNodeType: TDomNodeType; override;
    function GetPublicId: WideString; virtual;
    function GetSystemId: WideString; virtual;
    procedure SetNodeValue(const Value: WideString); override;
  public
    constructor Create(const AOwner: TDomCustomDocument;
                       const DoctypeName,
                             PubId,
                             SysId,
                             IntSubset: WideString);

    property InternalSubset: WideString read GetInternalSubset;
{$ENDIF NEXTGEN}
    property IntSubsetStartByteNumber: Int64 read FIntSubsetByteNumber write FIntSubsetByteNumber default 0;
    property IntSubsetStartCharNumber: Int64 read FIntSubsetCharNumber write FIntSubsetCharNumber default 0;
    property IntSubsetStartColumn: Int64 read FIntSubsetStartColumn write FIntSubsetStartColumn default 0;
    property IntSubsetStartLine: Int64 read FIntSubsetStartLine write FIntSubsetStartLine default 1;
{$IFDEF NEXTGEN}
    property Name: string read GetName;
    property PublicId: string read GetPublicId;
    property SystemId: string read GetSystemId;
{$ELSE !NEXTGEN}
    property Name: WideString read GetName;
    property PublicId: WideString read GetPublicId;
    property SystemId: WideString read GetSystemId;
{$ENDIF NEXTGEN}
  end;

{$IFDEF NEXTGEN}
  TDomEntityReference = class(TDomNode)
  private
    FNodeName: string;
  protected
    function GetNodeName: string; override;
    function GetNodeType: TDomNodeType; override;
    procedure SetNodeValue(const Value: string); override;
  public
    constructor Create(const AOwner: TDomCustomDocument;
                       const Name: string);
  end;
{$ELSE !NEXTGEN}
  TDomEntityReference = class(TDomNode)
  private
    FNodeName: WideString;
  protected
    function GetNodeName: WideString; override;
    function GetNodeType: TDomNodeType; override;
    procedure SetNodeValue(const Value: WideString); override;
  public
    constructor Create(const AOwner: TDomCustomDocument;
                       const Name: WideString);
  end;
{$ENDIF NEXTGEN}

  TDomDocumentFragment = class(TDomNode)
  protected
    function GetAbsoluteIndex: Integer; override;
    function GetLevel: Integer; override;
{$IFDEF NEXTGEN}
    function GetNodeName: string; override;
{$ELSE !NEXTGEN}
    function GetNodeName: WideString; override;
{$ENDIF NEXTGEN}
    function GetNodeType: TDomNodeType; override;
{$IFDEF NEXTGEN}
    procedure SetNodeValue(const Value: string); override;
{$ELSE !NEXTGEN}
    procedure SetNodeValue(const Value: WideString); override;
{$ENDIF NEXTGEN}
  public
    constructor Create(const AOwner: TDomCustomDocument); virtual;
  end;

  TDomXPathNamespace = class(TDomNode)
  private
{$IFDEF NEXTGEN}
    FNamespaceURI: string;
    [Weak] FOwnerElement: TDomElement;
    FPrefix: string;
{$ELSE !NEXTGEN}
    FNamespaceURI: WideString;
    FOwnerElement: TDomElement;
    FPrefix: WideString;
{$ENDIF NEXTGEN}
    function GetOwnerSet: TDomXPathNodeSetResult;
  protected
    function GetDocument: TDomCustomDocument; override;
{$IFDEF NEXTGEN}
    function GetExpandedName: string; override;
    function GetLocalName: string; override;
    function GetNamespaceURI: string; override;
    function GetNodeName: string; override;
    function GetNodeType: TDomNodeType; override;
    function GetNodeValue: string; override;
    function GetOwnerElement: TDomElement; virtual;
    function GetPrefix: string; override;
{$ELSE !NEXTGEN}
    function GetExpandedName: WideString; override;
    function GetLocalName: WideString; override;
    function GetNamespaceURI: WideString; override;
    function GetNodeName: WideString; override;
    function GetNodeType: TDomNodeType; override;
    function GetNodeValue: WideString; override;
    function GetOwnerElement: TDomElement; virtual;
    function GetPrefix: WideString; override;
{$ENDIF NEXTGEN}
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwnerSet: TDomXPathNodeSetResult;
                       const AOwnerElement: TDomElement;
                       const ANamespaceUri,
                             APrefix: string);
{$ELSE !NEXTGEN}
    constructor Create(const AOwnerSet: TDomXPathNodeSetResult;
                       const AOwnerElement: TDomElement;
                       const ANamespaceUri,
                             APrefix: WideString);
{$ENDIF NEXTGEN}
    property OwnerElement: TDomElement read GetOwnerElement;
    property OwnerSet: TDomXPathNodeSetResult read GetOwnerSet;
{$IFDEF NEXTGEN}
    function LookupNamespaceURI(const APrefix: string): string; override;
{$ELSE !NEXTGEN}
    function LookupNamespaceURI(const APrefix: WideString): WideString; override;
{$ENDIF NEXTGEN}
  end;

  TDomCustomDocument = class(TDomNode)
  private
    FCreatedNodeIterators: TList<TDomNodeIterator>;
    FCreatedTreeWalkers: TList<TDomTreeWalker>;
    FDefaultView: TDomAbstractView;
{$IFDEF NEXTGEN}
    FDocumentUri: string;
    [Weak] FDOMImpl: TDomImplementation;
    FInputEncoding: string;
    FModified: Boolean;
    FSystemId: string;
    FXmlEncoding: string;
    FXmlStandalone: TDomStandalone;
    FXmlVersion: string;
{$ELSE !NEXTGEN}
    FDocumentUri: WideString;
    FDOMImpl: TDomImplementation;
    FInputEncoding: WideString;
    FModified: Boolean;
    FSystemId: WideString;
    FXmlEncoding: WideString;
    FXmlStandalone: TDomStandalone;
    FXmlVersion: WideString;
{$ENDIF NEXTGEN}

    FOnAttrModified: TDomAttrModifiedEvent;
    FOnCharacterDataModified: TDomNotifyNodeEvent;
    FOnNodeClearing: TDomNotifyNodeEvent;
    FOnNodeInserted: TDomNotifyNodeEvent;
    FOnNodeRemoving: TDomNotifyNodeEvent;

    procedure NotifyIterators(const Node: TDomNode;
                              const EventType: TDomNodeEvent);
  protected
{$IFDEF NEXTGEN}
    procedure CalculateNormalizedAttrValue(const AttrLiteralValue: string;
                                           const AttrDataType: TXmlDataType;
                                             out NormalizedValue: string;
                                             out Error: TXmlErrorType); virtual;
{$ELSE !NEXTGEN}
    procedure CalculateNormalizedAttrValue(const AttrLiteralValue: WideString;
                                           const AttrDataType: TXmlDataType;
                                             out NormalizedValue: WideString;
                                             out Error: TXmlErrorType); virtual;
{$ENDIF NEXTGEN}
    procedure DoAttrModified(const SourceNode: TDomNode;
                             const AttrChange: TDomAttrChange;
                             const RelatedAttr: TDomAttr); virtual;
    procedure DoBeforeClear; override;
    procedure DoCharacterDataModified(Node: TDomNode); virtual;
    procedure DoNodeClearing(Node: TDomNode); virtual;
    procedure DoNodeInserted(Node: TDomNode); virtual;
    procedure DoNodeRemoving(Node: TDomNode); virtual;
    function GetAbsoluteIndex: Integer; override;
{$IFDEF NEXTGEN}
    function GetAttrDataType(const ElementName,
                                   AttrName: string): TXmlDataType; virtual;
    function GetBaseUri: DOMString; override;
{$ELSE !NEXTGEN}
    function GetAttrDataType(const ElementName,
                                   AttrName: WideString): TXmlDataType; virtual;
    function GetBaseUri: WideString; override;
{$ENDIF NEXTGEN}
    function GetDoctypeDecl: TDomDocumentTypeDecl; virtual;
    function GetDocumentElement: TDomElement; virtual;
    function GetLevel: Integer; override;
{$IFDEF NEXTGEN}
    function GetNodeName: string; override;
{$ELSE !NEXTGEN}
    function GetNodeName: WideString; override;
{$ENDIF NEXTGEN}
    function GetNodeType: TDomNodeType; override;
    function GetRootDocument: TDomCustomDocument; override;
    function ImportNode2(const ImportedNode: TDomNode;
                         const Deep: Boolean): TDomNode; virtual;
{$IFDEF NEXTGEN}
    procedure SetNodeValue(const Value: string); override;
{$ELSE !NEXTGEN}
    procedure SetNodeValue(const Value: WideString); override;
{$ENDIF NEXTGEN}
  public
    constructor Create(const AOwner: TDomImplementation);
    destructor Destroy; override;
    function AppendChild(const NewChild: TDomNode): TDomNode; override;
    procedure ClearInvalidNodeIterators; virtual;
    function CreateNodeIterator(const Root: TDomNode;
                                      WhatToShow: TDomWhatToShow;
                                      NodeFilter: TDomNodeFilter;
                                      EntityReferenceExpansion: Boolean): TDomNodeIterator; virtual;
    function CreateTreeWalker(const Root: TDomNode;
                                    WhatToShow: TDomWhatToShow;
                                    NodeFilter: TDomNodeFilter;
                                    EntityReferenceExpansion: Boolean): TDomTreeWalker; virtual;
    procedure FreeTreeWalker(var TreeWalker: TDomTreeWalker); virtual;
{$IFDEF NEXTGEN}
    function GetElementById(const ElementId: string): TDomElement; virtual; abstract;
{$ELSE !NEXTGEN}
    function GetElementById(const ElementId: WideString): TDomElement; virtual; abstract;
{$ENDIF NEXTGEN}
    function ImportNode(const ImportedNode: TDomNode;
                        const Deep: Boolean): TDomNode; virtual;
    function InsertBefore(const NewChild,
                                RefChild: TDomNode): TDomNode; override;
    function ReplaceChild(const NewChild,
                                OldChild: TDomNode): TDomNode; override;

    property DefaultView: TDomAbstractView read FDefaultView;
    property DoctypeDecl: TDomDocumentTypeDecl read GetDoctypeDecl;
    property DocumentElement: TDomElement read GetDocumentElement;
{$IFDEF NEXTGEN}
    property DocumentUri: string read FDocumentUri write FDocumentUri;
    property DomImplementation: TDomImplementation read FDomImpl;
    property InputEncoding: string read FInputEncoding write FInputEncoding;
    property Modified: Boolean read FModified write FModified;
    property XmlEncoding: string read FXmlEncoding write FXmlEncoding;
    property XmlStandalone: TDomStandalone read FXmlStandalone write FXmlStandalone;
    property XmlVersion: string read FXmlVersion write FXmlVersion;
{$ELSE !NEXTGEN}
    property DocumentUri: WideString read FDocumentUri write FDocumentUri;
    property DomImplementation: TDomImplementation read FDomImpl;
    property InputEncoding: WideString read FInputEncoding write FInputEncoding;
    property Modified: Boolean read FModified write FModified;
    property XmlEncoding: WideString read FXmlEncoding write FXmlEncoding;
    property XmlStandalone: TDomStandalone read FXmlStandalone write FXmlStandalone;
    property XmlVersion: WideString read FXmlVersion write FXmlVersion;
{$ENDIF NEXTGEN}

    property OnAttrModified:          TDomAttrModifiedEvent read FOnAttrModified write FOnAttrModified;
    property OnCharacterDataModified: TDomNotifyNodeEvent read FOnCharacterDataModified write FOnCharacterDataModified;
    property OnNodeClearing:          TDomNotifyNodeEvent read FOnNodeClearing write FOnNodeClearing;
    property OnNodeInserted:          TDomNotifyNodeEvent read FOnNodeInserted write FOnNodeInserted;
    property OnNodeRemoving:          TDomNotifyNodeEvent read FOnNodeRemoving write FOnNodeRemoving;
  end;

  TDomDocument = class(TDomCustomDocument)
  private
    FCreatedElementsNodeLists: TList<TDomNodeList>;
    FValidationAgent: TDtdValidationAgent;
  protected
{$IFDEF NEXTGEN}
    procedure CalculateNormalizedAttrValue(const AttrLiteralValue: string;
                                           const AttrDataType: TXmlDataType;
                                             out NormalizedValue: string;
                                             out Error: TXmlErrorType); override;
    procedure DoBeforeClear; override;
    function GetAttrDataType(const ElementName,
                                   AttrName: string): TXmlDataType; override;
{$ELSE !NEXTGEN}
    procedure CalculateNormalizedAttrValue(const AttrLiteralValue: WideString;
                                           const AttrDataType: TXmlDataType;
                                             out NormalizedValue: WideString;
                                             out Error: TXmlErrorType); override;
    procedure DoBeforeClear; override;
    function GetAttrDataType(const ElementName,
                                   AttrName: WideString): TXmlDataType; override;
{$ENDIF NEXTGEN}
    function GetIsElementContentWhitespace(const TextNode: TDomText): Boolean; virtual;
    function ImportNode2(const ImportedNode: TDomNode;
                         const Deep: Boolean): TDomNode; override;
    function PrepareAttributes2(const Node: TDomNode): Boolean; virtual;
  public
    constructor Create(const AOwner: TDomImplementation);
    destructor Destroy; override;
{$IFDEF NEXTGEN}
    function GetElementById(const ElementId: string): TDomElement; override;
    function GetElementsByTagName(const TagName: string): TDomNodeList; virtual;
{$ELSE !NEXTGEN}
    function GetElementById(const ElementId: WideString): TDomElement; override;
    function GetElementsByTagName(const TagName: WideString): TDomNodeList; virtual;
{$ENDIF NEXTGEN}
    function PrepareAttributes: Boolean; virtual;

    property ValidationAgent: TDtdValidationAgent read FValidationAgent;
  end;

  TDomDocumentNS = class(TDomCustomDocument)
  private
    FCreatedElementsNodeListNSs: TList<TDomNodeList>;
    FIDs: TUtilsWideStringList;
    procedure SetIDs(const Value: TUtilsWideStringList);
  protected
    procedure DoBeforeClear; override;
  public
    constructor Create(const AOwner: TDomImplementation);
    destructor Destroy; override;
{$IFDEF NEXTGEN}
    function GetElementById(const ElementId: string): TDomElement; override;
    function GetElementsByTagNameNS(const NamespaceURI,
                                          LocalName: string): TDomNodeList; virtual;
{$ELSE !NEXTGEN}
    function GetElementById(const ElementId: WideString): TDomElement; override;
    function GetElementsByTagNameNS(const NamespaceURI,
                                          LocalName: WideString): TDomNodeList; virtual;
{$ENDIF NEXTGEN}

    property IDs: TUtilsWideStringList read FIDs write SetIDs;
  end;

  TDomDocumentXPath = class(TDomDocumentNS)
  protected
    procedure DoBeforeAttach(const Obj: TCustomOwnedObject); override;
  end;

  TXmlStandardDomReader = class;

  TDomSeverity = (DOM_SEVERITY_WARNING,
                  DOM_SEVERITY_ERROR,
                  DOM_SEVERITY_FATAL_ERROR);

  IDomLocator = interface
    function GetEndByteNumber: Int64;
    function GetEndCharNumber: Int64;
    function GetEndColumnNumber: Int64;
    function GetEndLineNumber: Int64;
    function GetEndTabsInLine: Int64;
    function GetRelatedDtdObject: TDtdObject;
    function GetRelatedNode: TDomNode;
    function GetStartByteNumber: Int64;
    function GetStartCharNumber: Int64;
    function GetStartColumnNumber: Int64;
    function GetStartLineNumber: Int64;
    function GetStartTabsInLine: Int64;
{$IFDEF NEXTGEN}
    function GetUri: string;
{$ELSE !NEXTGEN}
    function GetUri: WideString;
{$ENDIF NEXTGEN}

    property EndByteNumber: Int64 read GetEndByteNumber;
    property EndCharNumber: Int64 read GetEndCharNumber;
    property EndColumnNumber: Int64 read GetEndColumnNumber;
    property EndLineNumber: Int64 read GetEndLineNumber;
    property EndTabsInLine: Int64 read GetEndTabsInLine;
    property RelatedDtdObject: TDtdObject read GetRelatedDtdObject;
    property RelatedNode: TDomNode read GetRelatedNode;
    property StartByteNumber: Int64 read GetStartByteNumber;
    property StartCharNumber: Int64 read GetStartCharNumber;
    property StartColumnNumber: Int64 read GetStartColumnNumber;
    property StartLineNumber: Int64 read GetStartLineNumber;
    property StartTabsInLine: Int64 read GetStartTabsInLine;
{$IFDEF NEXTGEN}
    property Uri: string read GetUri;
{$ELSE !NEXTGEN}
    property Uri: WideString read GetUri;
{$ENDIF NEXTGEN}
  end;

  TDomError = class(TUtilsNoRefCount, IDomLocator)
  private
{$IFDEF NEXTGEN}
    FClue:              string;
    FCode:              string;
{$ELSE !NEXTGEN}
    FClue:              WideString;
    FCode:              WideString;
{$ENDIF NEXTGEN}
    FEndByteNumber:     Int64;
    FEndCharNumber:     Int64;
    FEndColumnNumber:   Int64;
    FEndLineNumber:     Int64;
    FEndTabsInLine:     Int64;
    FRelatedDtdObject:  TDtdObject;
    FRelatedException:  TXmlErrorType;
    FRelatedNode:       TDomNode;
    FStartByteNumber:   Int64;
    FStartCharNumber:   Int64;
    FStartColumnNumber: Int64;
    FStartLineNumber:   Int64;
    FStartTabsInLine:   Int64;
{$IFDEF NEXTGEN}
    FUri:               string;
{$ELSE !NEXTGEN}
    FUri:               WideString;
{$ENDIF NEXTGEN}
  protected
    function GetSeverity: TDomSeverity; virtual;

    { IDomLocator interface methods: }
    function GetEndByteNumber: Int64; virtual;
    function GetEndCharNumber: Int64; virtual;
    function GetEndColumnNumber: Int64; virtual;
    function GetEndLineNumber: Int64; virtual;
    function GetEndTabsInLine: Int64; virtual;
    function GetRelatedDtdObject: TDtdObject; virtual;
    function GetRelatedNode: TDomNode; virtual;
    function GetStartByteNumber: Int64; virtual;
    function GetStartCharNumber: Int64; virtual;
    function GetStartColumnNumber: Int64; virtual;
    function GetStartLineNumber: Int64; virtual;
    function GetStartTabsInLine: Int64; virtual;
{$IFDEF NEXTGEN}
    function GetUri: string; virtual;
{$ELSE !NEXTGEN}
    function GetUri: WideString; virtual;
{$ENDIF NEXTGEN}
  public
    constructor Create(const ARelatedException: TXmlErrorType;
                       const AStartByteNumber,
                             AStartCharNumber,
                             AStartColumnNumber,
                             AStartLineNumber,
                             AStartTabsInLine,
                             AEndByteNumber,
                             AEndCharNumber,
                             AEndColumnNumber,
                             AEndLineNumber,
                             AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                       const AUri: string;
{$ELSE !NEXTGEN}
                       const AUri: WideString;
{$ENDIF NEXTGEN}
                       const ARelatedDtdObject: TDtdObject;
                       const ARelatedNode: TDomNode;
{$IFDEF NEXTGEN}
                       const ACode,
                             AClue: string);
{$ELSE !NEXTGEN}
                       const ACode,
                             AClue: WideString);
{$ENDIF NEXTGEN}
{$IFDEF NEXTGEN}
    constructor CreateFromLocator(const ARelatedException: TXmlErrorType;
                                  const ALocation: IDomLocator;
                                  const ACode,
                                        AClue: string);
{$ELSE !NEXTGEN}
    constructor CreateFromLocator(const ARelatedException: TXmlErrorType;
                                  const ALocation: IDomLocator;
                                  const ACode,
                                        AClue: WideString);
{$ENDIF NEXTGEN}
                                                                      
    function CloneError: TDomError; virtual;

{$IFDEF NEXTGEN}
    property Clue: string read FClue;
    property Code: string read FCode;
{$ELSE !NEXTGEN}
    property Clue: WideString read FClue;
    property Code: WideString read FCode;
{$ENDIF NEXTGEN}
    property RelatedException: TXmlErrorType read FRelatedException;
    property Severity: TDomSeverity read GetSeverity;

    { IDomLocator interface properties: }
    property EndByteNumber: Int64 read GetEndByteNumber;
    property EndCharNumber: Int64 read GetEndCharNumber;
    property EndColumnNumber: Int64 read GetEndColumnNumber;
    property EndLineNumber: Int64 read GetEndLineNumber;
    property EndTabsInLine: Int64 read GetEndTabsInLine;
    property RelatedDtdObject: TDtdObject read GetRelatedDtdObject;
    property RelatedNode: TDomNode read GetRelatedNode;
    property StartByteNumber: Int64 read GetStartByteNumber;
    property StartCharNumber: Int64 read GetStartCharNumber;
    property StartColumnNumber: Int64 read GetStartColumnNumber;
    property StartLineNumber: Int64 read GetStartLineNumber;
    property StartTabsInLine: Int64 read GetStartTabsInLine;
{$IFDEF NEXTGEN}
    property Uri: string read GetUri;
{$ELSE !NEXTGEN}
    property Uri: WideString read GetUri;
{$ENDIF NEXTGEN}
  end;

  TDtdObjectList = class
  private
    FNodeList: TList<TDtdObject>;
  protected
    procedure Clear;
    function AppendNode(const NewNode: TDtdObject): TDtdObject; virtual;
    procedure Delete(const Index: Integer); virtual;
    function IndexOf(const Node: TDtdObject): Integer; virtual;
    function InsertBefore(const NewNode,
                                RefNode: TDtdObject): TDtdObject; virtual;
    function GetLength: Integer; virtual;
    function RemoveNode(const OldNode: TDtdObject): TDtdObject; virtual;
  public
    constructor Create;
    destructor Destroy; override;
    function Item(const Index: Integer): TDtdObject; virtual;
    property Length: Integer read GetLength;
  end;

  TDtdNamedObjectMap = class
  protected
    FObjectList: TList<TDtdObject>;
    [Weak] FOwnerObject: TDtdModel;
    function GetLength: Integer; virtual;
{$IFDEF NEXTGEN}
    function RemoveNamedItem(const Name: string): TDtdObject; virtual;
{$ELSE !NEXTGEN}
    function RemoveNamedItem(const Name: WideString): TDtdObject; virtual;
{$ENDIF NEXTGEN}
    function SetNamedItem(const Arg: TDtdObject): TDtdObject; virtual;
    procedure Clear; virtual;
  public
    constructor Create(const AOwner: TDtdModel);
    destructor Destroy; override;
{$IFDEF NEXTGEN}
    function GetNamedItem(const Name: string): TDtdObject; virtual;
{$ELSE !NEXTGEN}
    function GetNamedItem(const Name: WideString): TDtdObject; virtual;
{$ENDIF NEXTGEN}
    function Item(const Index: Integer): TDtdObject; virtual;
    property Length: Integer read GetLength;
    property OwnerModel: TDtdModel read FOwnerObject;
  end;

  TDtdValidationAgent = class
  private
    FDtdModel: TDtdModel;
    FIDs: TUtilsWideStringList;
    FIDREFs: TUtilsWideStringList;   // Remark: Only used during validation.
    [Weak] FOwnerDocument: TDomDocument;
    FErrorReportingEnabled: Boolean;

{$IFDEF NEXTGEN}
    procedure AddDefaultAttr(const Elmt: TDomElement;
                             const AttrName,
                                   AttrValue: string);
    function GetDomImplementation: TDomImplementation;
    function IsUnparsedEntity(const EntityName: string): Boolean;
    procedure NormalizeAttrValueStep1(const S: string;
                                      const AttrDeclKey: Int64;
                                        out S_Normalized: string;
                                        out Error: TXmlErrorType);
    procedure NormalizeValue(const AttrLiteralValue: string;
                             const AttrDataType: TXmlDataType;
                             const AttrDeclKey: Int64;
                               out NormalizedValue: string;
                               out Error: TXmlErrorType);
    function ParseWideString(const S: string): TDomDocumentFragment; overload;
{$ELSE !NEXTGEN}
    procedure AddDefaultAttr(const Elmt: TDomElement;
                             const AttrName,
                                   AttrValue: WideString);
    function GetDomImplementation: TDomImplementation;
    function IsUnparsedEntity(const EntityName: WideString): Boolean;
    procedure NormalizeAttrValueStep1(const S: WideString;
                                      const AttrDeclKey: Int64;
                                        out S_Normalized: WideString;
                                        out Error: TXmlErrorType);
    procedure NormalizeValue(const AttrLiteralValue: WideString;
                             const AttrDataType: TXmlDataType;
                             const AttrDeclKey: Int64;
                               out NormalizedValue: WideString;
                               out Error: TXmlErrorType);
    function ParseWideString(const S: WideString): TDomDocumentFragment; overload;
{$ENDIF NEXTGEN}
  protected
    function AddDefaultAttributes(const Elmt: TDomElement): Boolean; virtual;
    procedure AddAndValidateDefaultAttributes(const Elmt: TDomElement;
                                                out IsValid,
                                                    AContinue: Boolean); virtual;
    procedure Clear; virtual;
    function DocumentIsStandalone: Boolean;
    function ExpandEntityReference(const EntRef: TDomEntityReference): TXmlErrorType; virtual;
{$IFDEF NEXTGEN}
    function FindAttributeDecl(const ElementName,
                                     AttributeName: string): TDtdAttributeDecl; virtual;
    function FindElementDecl(const Name: string): TDtdElementDecl; virtual;
    function FindEntityDecl(const Name: string): TDtdEntityDecl; virtual;
    function FindEntityReplacementText(const EntityName: string;
                                         out ReplText: string;
                                         out IsExternalEntity: Boolean;
                                         out Key: Int64): TXmlErrorType; virtual;
    function FindNotationDecl(const Name: string): TDtdNotationDecl; virtual;
    function GetAttrDataType(const ElementName,
                                   AttrName: string): TXmlDataType; virtual;
    function GetElementContentType(const ElementName: string): TDtdContentType; virtual;
    procedure NormalizeAttributeValue(const AttrLiteralValue: string;
                                      const AttrDataType: TXmlDataType;
                                        out NormalizedValue: string;
                                        out Error: TXmlErrorType); virtual;
    procedure NormalizeAttrDeclValue(const AttrDecl: TDtdAttributeDecl;
                                       out NormalizedValue: string;
                                       out Error: TXmlErrorType); virtual;
    procedure ResolveEntity(const Origin: TDtdOrigin;
                            const BaseURI,
                                  PubId,
                                  SysId: string;
                              out ReplacementText: string;
                              out Error: TXmlErrorType); virtual;
{$ELSE !NEXTGEN}
    function FindAttributeDecl(const ElementName,
                                     AttributeName: WideString): TDtdAttributeDecl; virtual;
    function FindElementDecl(const Name: WideString): TDtdElementDecl; virtual;
    function FindEntityDecl(const Name: WideString): TDtdEntityDecl; virtual;
    function FindEntityReplacementText(const EntityName: WideString;
                                         out ReplText: WideString;
                                         out IsExternalEntity: Boolean;
                                         out Key: Int64): TXmlErrorType; virtual;
    function FindNotationDecl(const Name: WideString): TDtdNotationDecl; virtual;
    function GetAttrDataType(const ElementName,
                                   AttrName: WideString): TXmlDataType; virtual;
    function GetElementContentType(const ElementName: WideString): TDtdContentType; virtual;
    procedure NormalizeAttributeValue(const AttrLiteralValue: WideString;
                                      const AttrDataType: TXmlDataType;
                                        out NormalizedValue: WideString;
                                        out Error: TXmlErrorType); virtual;
    procedure NormalizeAttrDeclValue(const AttrDecl: TDtdAttributeDecl;
                                       out NormalizedValue: WideString;
                                       out Error: TXmlErrorType); virtual;
    procedure ResolveEntity(const Origin: TDtdOrigin;
                            const BaseURI,
                                  PubId,
                                  SysId: WideString;
                              out ReplacementText: WideString;
                              out Error: TXmlErrorType); virtual;
{$ENDIF NEXTGEN}
    function SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                   const RelDtdObject: TDtdObject;
                                   const RelNode: TDomNode): Boolean; virtual;
    procedure SetErrorReportingEnabled(const Value: Boolean); virtual;
    procedure ValidateAttr(const Attr: TDomAttr;
                           const Opt: TDomEntityResolveOption;
                             out IsValid,
                                 AContinue: Boolean); virtual;
    procedure ValidateDTD(out IsValid,
                              AContinue: Boolean); virtual;
    procedure ValidateElement(const Elmt: TDomElement;
                              const Opt: TDomEntityResolveOption;
                                out IsValid,
                                    AContinue: Boolean); virtual;
    procedure ValidateEntityRef(const EntRef: TDomEntityReference;
                                  out IsValid,
                                      AContinue: Boolean); virtual;
    procedure ValidateNode(const Node: TDomNode;
                           const Opt: TDomEntityResolveOption;
                             out IsValid,
                                 AContinue: Boolean); virtual;

    property DomImplementation: TDomImplementation read GetDomImplementation;
    property IDs: TUtilsWideStringList read FIDs;
  public
    constructor Create(const AOwner: TDomDocument);
    destructor Destroy; override;
    procedure BuildDtdModel(const ResolveExtEntities: Boolean); virtual;
    function ValidateDocument(const Opt: TDomEntityResolveOption): Boolean; virtual;

    property DtdModel: TDtdModel read FDtdModel;                                                                                                                           
    property ErrorReportingEnabled: Boolean read FErrorReportingEnabled write SetErrorReportingEnabled default True;
    property OwnerDocument: TDomDocument read FOwnerDocument;
  end;

  TDtdObject = class
  private
{$IFDEF NEXTGEN}
    FName: string;
{$ELSE !NEXTGEN}
    FName: WideString;
{$ENDIF NEXTGEN}
    FObjectType: TDtdObjectType;
    [Weak] FOwnerModel: TDtdModel;
    FKey: Int64;
  protected
{$IFDEF NEXTGEN}
    function GetName: string; virtual;
  public
    constructor Create(const AOwner: TDtdModel;
                       const AName: string);
{$ELSE !NEXTGEN}
    function GetName: WideString; virtual;
  public
    constructor Create(const AOwner: TDtdModel;
                       const AName: WideString);
{$ENDIF NEXTGEN}

    property Key: Int64 read FKey;
{$IFDEF NEXTGEN}
    property Name: string read GetName;
{$ELSE !NEXTGEN}
    property Name: WideString read GetName;
{$ENDIF NEXTGEN}
    property ObjectType: TDtdObjectType read FObjectType;
    property OwnerModel: TDtdModel read FOwnerModel;
  end;

  TDtdContentModel = class(TDtdObject)
  protected
    FAllowedChildTypes: set of TDtdContentModelType;
    FContentModelType: TDtdContentModelType;
    FFrequency: TDtdFrequency;
    FInuse: Boolean;
    [Weak] FOwnerElementDecl: TDtdElementDecl;
    FSubModels: TDtdObjectList;
    function ValidateChoiceNames(const Source: TUtilsWideStringList;
                                   var Index: Integer;
                                       Freq: TDtdFrequency;
                                   out IsNonDeterministic: Boolean): Boolean; virtual;
    function ValidateElementNames(const Source: TUtilsWideStringList;
                                    var Index: Integer;
                                        Freq: TDtdFrequency;
                                    out IsNonDeterministic: Boolean): Boolean; virtual;
    function ValidateNames2(const Source: TUtilsWideStringList;
                              var Index: Integer;
                                  Freq: TDtdFrequency;
                              out IsNonDeterministic: Boolean): Boolean; virtual;
    function ValidateNames(const Source: TUtilsWideStringList;
                             var Index: Integer;
                             out IsNonDeterministic: Boolean): Boolean; virtual;
    function ValidateSequenceNames(const Source: TUtilsWideStringList;
                                     var Index: Integer;
                                         Freq: TDtdFrequency;
                                     out IsNonDeterministic: Boolean): Boolean; virtual;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwnerElementDecl: TDtdElementDecl;
                       const AName: string;
                       const AContentModelType: TDtdContentModelType);
{$ELSE !NEXTGEN}
    constructor Create(const AOwnerElementDecl: TDtdElementDecl;
                       const AName: WideString;
                       const AContentModelType: TDtdContentModelType);
{$ENDIF NEXTGEN}
    destructor Destroy; override;
    function AppendSubModel(const NewCM: TDtdContentModel): TDtdContentModel; virtual;
    function InsertBeforeSubModel(const NewCM,
                                        RefCM: TDtdContentModel): TDtdContentModel; virtual;
    function RemoveSubModel(const OldCM: TDtdContentModel): TDtdContentModel; virtual;
    property ContentModelType: TDtdContentModelType read FContentModelType;
    property Frequency: TDtdFrequency read FFrequency write FFrequency default DTD_REQUIRED_FRQ;
    property SubModels: TDtdObjectList read FSubModels;
    property OwnerElementDecl: TDtdElementDecl read FOwnerElementDecl;
  end;

  TDtdAttDeclCollection = class(TDtdObject)
  private
    FAttributeDeclarations: TDtdNamedObjectMap;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDtdModel;
                       const AName: string);
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDtdModel;
                       const AName: WideString);
{$ENDIF NEXTGEN}
    destructor Destroy; override;
    procedure Clear; virtual;
{$IFDEF NEXTGEN}
    function FindAttributeDecl(const Name: string): TDtdAttributeDecl; virtual;
    function RemoveAttributeDecl(const Name: string): Boolean; virtual;
    function SetAttributeDecl(const AAttrName,
                                    AAttrValue: string;
                              const AEnumeration: TUtilsWideStringList;
                              const AAttrType: TXmlDataType;
                              const AConstraintType: TDomAttrValueConstraint;
                              const AOrigin: TDtdOrigin;
                                out AttributeDecl: TDtdAttributeDecl): Boolean; virtual;
{$ELSE !NEXTGEN}
    function FindAttributeDecl(const Name: WideString): TDtdAttributeDecl; virtual;
    function RemoveAttributeDecl(const Name: WideString): Boolean; virtual;
    function SetAttributeDecl(const AAttrName,
                                    AAttrValue: WideString;
                              const AEnumeration: TUtilsWideStringList;
                              const AAttrType: TXmlDataType;
                              const AConstraintType: TDomAttrValueConstraint;
                              const AOrigin: TDtdOrigin;
                                out AttributeDecl: TDtdAttributeDecl): Boolean; virtual;
{$ENDIF NEXTGEN}

    property AttributeDecls: TDtdNamedObjectMap read FAttributeDeclarations;
  end;


  TDtdAttributeDecl = class(TDtdObject)
  private
    FAttrType: TXmlDataType;
{$IFDEF NEXTGEN}
    FDefaultValue: string;
{$ELSE !NEXTGEN}
    FDefaultValue: WideString;
{$ENDIF NEXTGEN}
    FConstraintType: TDomAttrValueConstraint;
    FEnumeration: TUtilsWideStringList;
    FOrigin: TDtdOrigin;
    FOwnerCollection: TDtdAttDeclCollection;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwnerCollection: TDtdAttDeclCollection;
                       const AAttrName,
                             aDefaultValue: string;
                       const AEnumeration: TUtilsWideStringList;
                       const AAttrType: TXmlDataType;
                       const AConstraintType: TDomAttrValueConstraint;
                       const AOrigin: TDtdOrigin);
{$ELSE !NEXTGEN}
    constructor Create(const AOwnerCollection: TDtdAttDeclCollection;
                       const AAttrName,
                             aDefaultValue: WideString;
                       const AEnumeration: TUtilsWideStringList;
                       const AAttrType: TXmlDataType;
                       const AConstraintType: TDomAttrValueConstraint;
                       const AOrigin: TDtdOrigin);
{$ENDIF NEXTGEN}
    destructor Destroy; override;

    property AttrType: TXmlDataType read FAttrType;
    property ConstraintType: TDomAttrValueConstraint read FConstraintType;
{$IFDEF NEXTGEN}
    property DefaultValue: string read FDefaultValue;
{$ELSE !NEXTGEN}
    property DefaultValue: WideString read FDefaultValue;
{$ENDIF NEXTGEN}
    property Enumeration: TUtilsWideStringList read FEnumeration;
    property Origin: TDtdOrigin read FOrigin;
    property OwnerCollection: TDtdAttDeclCollection read FOwnerCollection;
  end;

  TDtdElementDecl = class(TDtdObject)
  private
    FOrigin: TDtdOrigin;
  protected
    FAllowedChildTypes: set of TDtdContentModelType;
    FContentModel: TDtdContentModel;
    FContentType: TDtdContentType;
    FCreatedContentModels: TDtdObjectList;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDtdModel;
                       const AName: string;
                       const AContentType: TDtdContentType;
                       const AOrigin: TDtdOrigin);
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDtdModel;
                       const AName: WideString;
                       const AContentType: TDtdContentType;
                       const AOrigin: TDtdOrigin);
{$ENDIF NEXTGEN}
    destructor Destroy; override;
    procedure Clear; virtual;
{$IFDEF NEXTGEN}
    function CreateContentModel(const Name: string;
                                const ContentModelType: TDtdContentModelType): TDtdContentModel; virtual;
{$ELSE !NEXTGEN}
    function CreateContentModel(const Name: WideString;
                                const ContentModelType: TDtdContentModelType): TDtdContentModel; virtual;
{$ENDIF NEXTGEN}
    procedure FreeAndNilContentModel(var CM: TDtdContentModel); virtual;
    function ReplaceContentModel(const NewContentModel: TDtdContentModel): TDtdContentModel; virtual;

    property ContentModel: TDtdContentModel read FContentModel;
    property ContentType: TDtdContentType read FContentType;
    property CreatedContentModels: TDtdObjectList read FCreatedContentModels;
    property Origin: TDtdOrigin read FOrigin;
  end;

  TDtdEntityDecl = class(TDtdObject)
  private
{$IFDEF NEXTGEN}
    FBaseUri: string;
    FEntityRefs: TUtilsWideStringList;
    FNotationName: string;
    FOrigin: TDtdOrigin;
    FPublicId: string;
    FReplacementText: string;
    FSystemId: string;
    FIsResolved: Boolean;
    function GetEntityType: TDtdEntityType;
    procedure SetReplacementText(const S: string);
{$ELSE !NEXTGEN}
    FBaseUri: WideString;
    FEntityRefs: TUtilsWideStringList;
    FNotationName: WideString;
    FOrigin: TDtdOrigin;
    FPublicId: WideString;
    FReplacementText: WideString;
    FSystemId: WideString;
    FIsResolved: Boolean;
    function GetEntityType: TDtdEntityType;
    procedure SetReplacementText(const S: WideString);
{$ENDIF NEXTGEN}
  protected
    function CheckNoRecursion_2(const AncestorEntities: TUtilsWideStringList): Boolean; virtual;
    function GetIsParsedEntity: Boolean; virtual;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDtdModel;
                       const AName,
                             AReplacementText,
                             APublicId,
                             ASystemId,
                             ANotationName,
                             ABaseUri: string;
                       const AOrigin: TDtdOrigin);
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDtdModel;
                       const AName,
                             AReplacementText,
                             APublicId,
                             ASystemId,
                             ANotationName,
                             ABaseUri: WideString;
                       const AOrigin: TDtdOrigin);
{$ENDIF NEXTGEN}
    destructor Destroy; override;
    function CheckNoRecursion: Boolean; virtual;
    function ResolveReplacementText(const ResolveEntityProc: TDomResolveEntityProc): TXmlErrorType; virtual;

{$IFDEF NEXTGEN}
    property BaseUri: string read FBaseUri;
{$ELSE !NEXTGEN}
    property BaseUri: WideString read FBaseUri;
{$ENDIF NEXTGEN}
    property EntityRefs: TUtilsWideStringList read FEntityRefs;
    property EntityType: TDtdEntityType read GetEntityType;
    property IsParsedEntity: Boolean read GetIsParsedEntity;
{$IFDEF NEXTGEN}
    property NotationName: string read FNotationName;
    property Origin: TDtdOrigin read FOrigin;
    property PublicId: string read FPublicId;
    property ReplacementText: string read FReplacementText;
    property SystemId: string read FSystemId;
{$ELSE !NEXTGEN}
    property NotationName: WideString read FNotationName;
    property Origin: TDtdOrigin read FOrigin;
    property PublicId: WideString read FPublicId;
    property ReplacementText: WideString read FReplacementText;
    property SystemId: WideString read FSystemId;
{$ENDIF NEXTGEN}
    property IsResolved: Boolean read FIsResolved;
  end;

  TDtdNotationDecl = class(TDtdObject)
  private
    FOrigin: TDtdOrigin;
{$IFDEF NEXTGEN}
    FPublicId: string;
    FSystemId: string;
  public
    constructor Create(const AOwner: TDtdModel;
                       const AName,
                             APublicId,
                             ASystemId: string;
                       const AOrigin: TDtdOrigin);

    property Origin: TDtdOrigin read FOrigin;
    property PublicId: string read FPublicId;
    property SystemId: string read FSystemId;
{$ELSE !NEXTGEN}
    FPublicId: WideString;
    FSystemId: WideString;
  public
    constructor Create(const AOwner: TDtdModel;
                       const AName,
                             APublicId,
                             ASystemId: WideString;
                       const AOrigin: TDtdOrigin);

    property Origin: TDtdOrigin read FOrigin;
    property PublicId: WideString read FPublicId;
    property SystemId: WideString read FSystemId;
{$ENDIF NEXTGEN}
  end;

  TDtdModel = class
  private
{$IFDEF NEXTGEN}
    FExtSubsetSysId: string;
    FIntSubsetSysId: string;
{$ELSE !NEXTGEN}
    FExtSubsetSysId: WideString;
    FIntSubsetSysId: WideString;
{$ENDIF NEXTGEN}
    FLastKey: Int64;
    FPEsInIntSubset: Boolean;
    FPreparationStatus: TDomPreparationStatus;
    FSetDefaults: Boolean;            // True during SetDefaults.
    function GetNewKey: Int64;
  protected
    FAttDeclCollections: TDtdNamedObjectMap;
    FElementDeclarations: TDtdNamedObjectMap;
    FEntityDeclarations: TDtdNamedObjectMap;
    FNotationDeclarations: TDtdNamedObjectMap;
    procedure ClearMaps; virtual;
    procedure SetDefaults;
    procedure SetPreparationStatus(const Value: TDomPreparationStatus); virtual;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear; virtual;
{$IFDEF NEXTGEN}
    function FindAttDeclCollection(const Name: string): TDtdAttDeclCollection; virtual;
    function FindAttributeDecl(const ElementName,
                                     AttributeName: string): TDtdAttributeDecl; virtual;
    function FindElementDecl(const Name: string): TDtdElementDecl; virtual;
    function FindEntityDecl(const Name: string): TDtdEntityDecl; virtual;
    function FindNotationDecl(const Name: string): TDtdNotationDecl; virtual;
    function RemoveAttributeDecl(const ElementName,
                                         AttributeName: string): Boolean; virtual;
    function RemoveElementDecl(const Name: string): Boolean; virtual;
    function RemoveEntityDecl(const Name: string): Boolean; virtual;
    function RemoveNotationDecl(const Name: string): Boolean; virtual;
    function SetAttributeDecl(const ElementName,
                                    AttrName,
                                    AttrValue: string;
                              const Enumeration: TUtilsWideStringList;
                              const AttrType: TXmlDataType;
                              const ConstraintType: TDomAttrValueConstraint;
                              const Origin: TDtdOrigin;
                                out AttributeDecl: TDtdAttributeDecl): Boolean; virtual;
    function SetElementDecl(const Name: string;
                            const ContentType: TDtdContentType;
                            const Origin: TDtdOrigin;
                              out ElementDecl: TDtdElementDecl): Boolean; virtual;
    function SetEntityDecl(const Name,
                                 ReplacementText,
                                 PublicId,
                                 SystemId,
                                 NotationName,
                                 BaseUri: string;
                           const Origin: TDtdOrigin;
                             out EntityDecl: TDtdEntityDecl): Boolean; virtual;
    function SetNotationDecl(const Name,
                                   PublicId,
                                   SystemId: string;
                             const Origin: TDtdOrigin;
                               out NotationDecl: TDtdNotationDecl): Boolean; virtual;
{$ELSE !NEXTGEN}
    function FindAttDeclCollection(const Name: WideString): TDtdAttDeclCollection; virtual;
    function FindAttributeDecl(const ElementName,
                                     AttributeName: WideString): TDtdAttributeDecl; virtual;
    function FindElementDecl(const Name: WideString): TDtdElementDecl; virtual;
    function FindEntityDecl(const Name: WideString): TDtdEntityDecl; virtual;
    function FindNotationDecl(const Name: WideString): TDtdNotationDecl; virtual;
    function RemoveAttributeDecl(const ElementName,
                                         AttributeName: WideString): Boolean; virtual;
    function RemoveElementDecl(const Name: WideString): Boolean; virtual;
    function RemoveEntityDecl(const Name: WideString): Boolean; virtual;
    function RemoveNotationDecl(const Name: WideString): Boolean; virtual;
    function SetAttributeDecl(const ElementName,
                                    AttrName,
                                    AttrValue: WideString;
                              const Enumeration: TUtilsWideStringList;
                              const AttrType: TXmlDataType;
                              const ConstraintType: TDomAttrValueConstraint;
                              const Origin: TDtdOrigin;
                                out AttributeDecl: TDtdAttributeDecl): Boolean; virtual;
    function SetElementDecl(const Name: WideString;
                            const ContentType: TDtdContentType;
                            const Origin: TDtdOrigin;
                              out ElementDecl: TDtdElementDecl): Boolean; virtual;
    function SetEntityDecl(const Name,
                                 ReplacementText,
                                 PublicId,
                                 SystemId,
                                 NotationName,
                                 BaseUri: WideString;
                           const Origin: TDtdOrigin;
                             out EntityDecl: TDtdEntityDecl): Boolean; virtual;
    function SetNotationDecl(const Name,
                                   PublicId,
                                   SystemId: WideString;
                             const Origin: TDtdOrigin;
                               out NotationDecl: TDtdNotationDecl): Boolean; virtual;
{$ENDIF NEXTGEN}

    // Declaration collections and maps
    property AttDeclCollections: TDtdNamedObjectMap read FAttDeclCollections;
    property ElementDecls: TDtdNamedObjectMap read FElementDeclarations;
    property EntityDecls: TDtdNamedObjectMap read FEntityDeclarations;
    property NotationDecls: TDtdNamedObjectMap read FNotationDeclarations;

{$IFDEF NEXTGEN}
    property ExtSubsetSysId: string read FExtSubsetSysId write FExtSubsetSysId;
    property IntSubsetSysId: string read FIntSubsetSysId write FIntSubsetSysId;
{$ELSE !NEXTGEN}
    property ExtSubsetSysId: WideString read FExtSubsetSysId write FExtSubsetSysId;
    property IntSubsetSysId: WideString read FIntSubsetSysId write FIntSubsetSysId;
{$ENDIF NEXTGEN}
    property PEsInIntSubset: Boolean read FPEsInIntSubset write FPEsInIntSubset default False;
    property PreparationStatus: TDomPreparationStatus read FPreparationStatus write SetPreparationStatus default PS_UNPREPARED;
  end;

// Views

                                                            
  TDomAbstractView = class
  protected
    FDocument: TDomCustomDocument;
  public
    property Document: TDomCustomDocument read FDocument;
  end;

                                                          
  TDomStyleSheet = class
  private
{$IFDEF NEXTGEN}
    function GetStyleSheetType: string; virtual; abstract;
{$ELSE !NEXTGEN}
    function GetStyleSheetType: WideString; virtual; abstract;
{$ENDIF NEXTGEN}
    function GetDisabled: Boolean; virtual; abstract;
    procedure SetDisabled(const Value: Boolean); virtual; abstract;
    function GetOwnerNode: TDomNode; virtual; abstract;
    function GetParentStyleSheet: TDomStyleSheet; virtual; abstract;
{$IFDEF NEXTGEN}
    function GetHref: string; virtual; abstract;
    function GetTitle: string; virtual; abstract;
    function GetMedia: TDomMediaList; virtual; abstract;
  public
    property StyleSheetType: string read GetStyleSheetType;
{$ELSE !NEXTGEN}
    function GetHref: WideString; virtual; abstract;
    function GetTitle: WideString; virtual; abstract;
    function GetMedia: TDomMediaList; virtual; abstract;
  public
    property StyleSheetType: WideString read GetStyleSheetType;
{$ENDIF NEXTGEN}
    property Disabled: Boolean read GetDisabled write SetDisabled;
    property OwnerNode: TDomNode read GetOwnerNode;
    property ParentStyleSheet: TDomStyleSheet read GetParentStyleSheet;
{$IFDEF NEXTGEN}
    property Href: string read GetHref;
    property Title: string read GetTitle;
{$ELSE !NEXTGEN}
    property Href: WideString read GetHref;
    property Title: WideString read GetTitle;
{$ENDIF NEXTGEN}
    property Media: TDomMediaList read GetMedia;
  end;

                                                         
  TDomMediaList = class
  private
{$IFDEF NEXTGEN}
    function GetCssText: string; virtual; abstract;
    procedure SetCssText(const Value: string); virtual; abstract;
{$ELSE !NEXTGEN}
    function GetCssText: WideString; virtual; abstract;
    procedure SetCssText(const Value: WideString); virtual; abstract;
{$ENDIF NEXTGEN}
    function GetLength: Integer; virtual; abstract;
  public
    function Item(const Index: Integer): TDomStyleSheet; virtual; abstract;
{$IFDEF NEXTGEN}
    procedure Delete(const OldMedium: string); virtual; abstract;
    procedure Append(const NewMedium: string); virtual; abstract;
    property Length: Integer read GetLength;
    property CssText: string read GetCssText write SetCssText;
{$ELSE !NEXTGEN}
    procedure Delete(const OldMedium: WideString); virtual; abstract;
    procedure Append(const NewMedium: WideString); virtual; abstract;
    property Length: Integer read GetLength;
    property CssText: WideString read GetCssText write SetCssText;
{$ENDIF NEXTGEN}
  end;

                                                              
  TDomStyleSheetList = class
  private
    function GetLength: Integer; virtual; abstract;
  public
    function Item(const Index: Integer): TDomStyleSheet; virtual; abstract;
    property Length: Integer read GetLength;
  end;

                                                             
  TDomDocumentStyle = class
  private
    function GetStyleSheets: TDomStyleSheetList; virtual; abstract;
  public
    property StyleSheets: TDomStyleSheetList read GetStyleSheets;
  end;

// XML Source Modeling

  TXmlSourceCode = class(TList)
  private
    procedure CalculatePieceOffset(const StartItem: Integer);
{$IFDEF NEXTGEN}
    function  GetNameOfFirstTag: string;
    function  GetText: string;
{$ELSE !NEXTGEN}
    function  GetNameOfFirstTag: WideString;
    function  GetText: WideString;
{$ENDIF NEXTGEN}
  public
    function  Add(Item: TXmlSourceCodePiece): Integer;
    procedure Clear; override;
    procedure ClearAndFree; virtual;
    procedure Delete(Index: Integer);
    procedure Exchange(Index1, Index2: Integer);
    function  GetPieceAtPos(Pos: Integer): TXmlSourceCodePiece;
    procedure Insert(Index: Integer; Item: TXmlSourceCodePiece);
    procedure Move(CurIndex, NewIndex: Integer);
    procedure Pack;
    function  Remove(Item: TXmlSourceCodePiece): Integer;
    procedure Sort(Compare: TListSortCompare);
{$IFDEF NEXTGEN}
    property  NameOfFirstTag: string read GetNameOfFirstTag;
    property  Text: string read GetText;
{$ELSE !NEXTGEN}
    property  NameOfFirstTag: WideString read GetNameOfFirstTag;
    property  Text: WideString read GetText;
{$ENDIF NEXTGEN}
  end;

  TXmlSourceCodePiece = class
  private
    FPieceType: TDomPieceType;
{$IFDEF NEXTGEN}
    FText: string;
{$ELSE !NEXTGEN}
    FText: WideString;
{$ENDIF NEXTGEN}
    FOffset: Integer;
    [Weak] FOwner: TXmlSourceCode;
  public
    constructor Create(const pt: TDomPieceType); virtual;
    property PieceType: TDomPieceType read FPieceType;
{$IFDEF NEXTGEN}
    property Text: string read FText write FText;
{$ELSE !NEXTGEN}
    property Text: WideString read FText write FText;
{$ENDIF NEXTGEN}
    property Offset: Integer read FOffset;
    property OwnerSourceCode: TXmlSourceCode read FOwner;
  end;


// Parser

  TCustomResourceResolver = class(TDomBaseComponent)
  public
{$IFDEF NEXTGEN}
    function ResolveResource(const ABaseURI: string;
                               var PublicId,
                                   SystemId: string): TStream; virtual; abstract;
{$ELSE !NEXTGEN}
    function ResolveResource(const ABaseURI: WideString;
                               var PublicId,
                                   SystemId: WideString): TStream; virtual; abstract;
{$ENDIF NEXTGEN}
  end;

  TStandardResourceResolver = class(TCustomResourceResolver)
  private
    FOnResolveResource: TDomResolveResourceEvent;
  protected
  {$IFNDEF NEXTGEN}
    function AcquireStreamFromUri(const Uri: WideString): TStream; virtual;
  public
    function ResolveResource(const ABaseURI: WideString;
                               var PublicId,
                                   SystemId: WideString): TStream; override;
  {$ELSE NEXTGEN}
    function AcquireStreamFromUri(const Uri: DOMString): TStream; virtual;
  public
    function ResolveResource(const ABaseURI: DOMString;
                               var PublicId,
                                   SystemId: DOMString): TStream; override;
  {$ENDIF !NEXTGEN}
  published
    property OnResolveResource: TDomResolveResourceEvent read FOnResolveResource write FOnResolveResource;
  end;

  TDomXMLDeclType = ( DT_XML_DECLARATION,
                      DT_TEXT_DECLARATION,
                      DT_XML_OR_TEXT_DECLARATION,
                      DT_UNSPECIFIED );

  TXmlSimpleInputSource = class(TUtilsUCS4Reader)
  private
{$IFDEF NEXTGEN}
    FPublicId: string;
    FStrStream: TStringStream;
    FSystemId: string;
{$ELSE !NEXTGEN}
    FPublicId: WideString;
    FStrStream: TStringStream;
    FSystemId: WideString;
{$ENDIF NEXTGEN}
    FWStrStream: TUtilsWideStringStream;
  protected
    function GetInputEncoding: string; virtual;
  public
    constructor Create(const Stream: TStream;
                       const APublicId,
{$IFDEF NEXTGEN}
                             ASystemId: string;
{$ELSE !NEXTGEN}
                             ASystemId: WideString;
{$ENDIF NEXTGEN}
                       const ABufSize: Integer;
                       const AEncoding: string;
                       const InitialByteCount,
                             InitialCharCount,
                             InitialCharsInLine,
                             InitialTabsInLine,
                             InitialLine: Int64); overload;
    constructor Create(const S: string;
                       const APublicId,
{$IFDEF NEXTGEN}
                             ASystemId: string;
{$ELSE !NEXTGEN}
                             ASystemId: WideString;
{$ENDIF NEXTGEN}
                       const ABufSize: Integer;
                       const AEncoding: string;
                       const InitialByteCount,
                             InitialCharCount,
                             InitialCharsInLine,
                             InitialTabsInLine,
                             InitialLine: Int64); overload;
    constructor Create(const S,
                             APublicId,
{$IFDEF NEXTGEN}
                             ASystemId: string;
{$ELSE !NEXTGEN}
                             ASystemId: WideString;
{$ENDIF NEXTGEN}
                       const ABufSize: Integer;
                       const InitialByteCount,
                             InitialCharCount,
                             InitialCharsInLine,
                             InitialTabsInLine,
                             InitialLine: Int64); overload;
    destructor Destroy; override;
    property InputEncoding: string read GetInputEncoding;
{$IFDEF NEXTGEN}
    property PublicId: string read FPublicId;
    property SystemId: string read FSystemId;
{$ELSE !NEXTGEN}
    property PublicId: WideString read FPublicId;
    property SystemId: WideString read FSystemId;
{$ENDIF NEXTGEN}
  end;

  TXmlInputSource = class(TXmlSimpleInputSource)
  private
    FDeclType: TDomXMLDeclType;
    FHasMalformedDecl: Boolean;
    FXmlEncoding: string;
    FXmlStandalone: TDomStandalone;
    FXmlVersion: string;
    procedure CheckEncoding(const Encoding: string);
    function EvaluateXmlOrTextDecl(out DeclType: TDomXMLDeclType;
                                   out Version,
                                       EncName: string;
                                   out Standalone: TDomStandalone): Boolean;
  public
    constructor Create(const Stream: TStream;
                       const APublicId,
{$IFDEF NEXTGEN}
                             ASystemId: string;
{$ELSE !NEXTGEN}
                             ASystemId: WideString;
{$ENDIF NEXTGEN}
                       const ABufSize: Integer;
                       const AEncoding: string;
                       const InclDecl: Boolean;
                       const InitialByteCount,
                             InitialCharCount,
                             InitialCharsInLine,
                             InitialTabsInLine,
                             InitialLine: Int64); reintroduce; overload;
    constructor Create(const S: string;
                       const APublicId,
{$IFDEF NEXTGEN}
                             ASystemId: string;
{$ELSE !NEXTGEN}
                             ASystemId: WideString;
{$ENDIF NEXTGEN}
                       const ABufSize: Integer;
                       const AEncoding: string;
                       const InclDecl: Boolean;
                       const InitialByteCount,
                             InitialCharCount,
                             InitialCharsInLine,
                             InitialTabsInLine,
                             InitialLine: Int64); overload;
    constructor Create(const S,
                             APublicId,
{$IFDEF NEXTGEN}
                             ASystemId: string;
{$ELSE !NEXTGEN}
                             ASystemId: WideString;
{$ENDIF NEXTGEN}
                       const ABufSize: Integer;
                       const InclDecl: Boolean;
                       const InitialByteCount,
                             InitialCharCount,
                             InitialCharsInLine,
                             InitialTabsInLine,
                             InitialLine: Int64); overload;

    property BufSize;
    property DeclType: TDomXMLDeclType read FDeclType;
    property HasMalformedDecl: Boolean read FHasMalformedDecl;
    property XmlEncoding: string read FXmlEncoding;
    property XmlStandalone: TDomStandalone read FXmlStandalone;
    property XmlVersion: string read FXmlVersion;
  end;

  TXmlCustomTokenizer = class(TUtilsNoRefCount, IDomLocator)
  protected
{$IFDEF NEXTGEN}
    FClue: string;
{$ELSE !NEXTGEN}
    FClue: WideString;
{$ENDIF NEXTGEN}
    FErrorType: TXmlErrorType;
    FInputSource: TXmlSimpleInputSource;
    FTokenEnd: TUtilsUCS4CharData;
    FTokenStart: TUtilsUCS4CharData;
    FTokenValue: TUtilsCustomWideStr;
{$IFDEF NEXTGEN}
    function GetTokenValue: string; virtual;
{$ELSE !NEXTGEN}
    function GetTokenValue: WideString; virtual;
{$ENDIF NEXTGEN}

    { IDomLocator interface methods: }
    function GetEndByteNumber: Int64; virtual;
    function GetEndCharNumber: Int64; virtual;
    function GetEndColumnNumber: Int64; virtual;
    function GetEndLineNumber: Int64; virtual;
    function GetEndTabsInLine: Int64; virtual;
    function GetRelatedDtdObject: TDtdObject; virtual;
    function GetRelatedNode: TDomNode; virtual;
    function GetStartByteNumber: Int64; virtual;
    function GetStartCharNumber: Int64; virtual;
    function GetStartColumnNumber: Int64; virtual;
    function GetStartLineNumber: Int64; virtual;
    function GetStartTabsInLine: Int64; virtual;
{$IFDEF NEXTGEN}
    function GetUri: string; virtual;
{$ELSE !NEXTGEN}
    function GetUri: WideString; virtual;
{$ENDIF NEXTGEN}
  public
    constructor Create(const InputSource: TXmlSimpleInputSource);
    destructor Destroy; override;
    procedure Next; virtual; abstract;

{$IFDEF NEXTGEN}
    property Clue: string read FClue;
    property ErrorType: TXmlErrorType read FErrorType;
    property TokenValue: string read GetTokenValue;
{$ELSE !NEXTGEN}
    property Clue: WideString read FClue;
    property ErrorType: TXmlErrorType read FErrorType;
    property TokenValue: WideString read GetTokenValue;
{$ENDIF NEXTGEN}
  end;

  TXmlDocTokenType = (
    XML_CDATA_TOKEN,
    XML_CHAR_REF_DEC_TOKEN,
    XML_CHAR_REF_HEX_TOKEN,
    XML_COMMENT_TOKEN,
    XML_DOCTYPE_TOKEN,
    XML_EMPTY_ELEMENT_TAG_TOKEN,
    XML_END_OF_SOURCE_TOKEN,
    XML_END_TAG_TOKEN,
    XML_ENTITY_REF_TOKEN,
    XML_PCDATA_TOKEN,
    XML_PI_TOKEN,
    XML_START_OF_SOURCE_TOKEN,
    XML_START_TAG_TOKEN
  );

  TXmlDocTokenizer = class(TXmlCustomTokenizer)
  protected
    FTokenType: TXmlDocTokenType;
  public
    constructor Create(const InputSource: TXmlSimpleInputSource);
    procedure Next; override;

    property TokenType: TXmlDocTokenType read FTokenType;
  end;

  TXmlDtdDetailTokenType = (
    DTD_DETAIL_ATTLIST_DECL_START_TOKEN,
    DTD_DETAIL_COMMENT_TOKEN,
    DTD_DETAIL_COND_SECT_END_TOKEN,
    DTD_DETAIL_COND_SECT_OPENER_TOKEN,
    DTD_DETAIL_COND_SECT_START_TOKEN,
    DTD_DETAIL_DECL_END_TOKEN,
    DTD_DETAIL_ELEMENT_DECL_START_TOKEN,
    DTD_DETAIL_END_OF_SOURCE_TOKEN,
    DTD_DETAIL_ENTITY_DECL_START_TOKEN,
    DTD_DETAIL_INVALID_MARKUP_TOKEN,
    DTD_DETAIL_KEYWORD_TOKEN,
    DTD_DETAIL_NOTATION_DECL_START_TOKEN,
    DTD_DETAIL_OPERATOR_TOKEN,
    DTD_DETAIL_PARAMETER_ENTITY_REF_TOKEN,
    DTD_DETAIL_PI_CONTENT_TOKEN,
    DTD_DETAIL_PI_TARGET_TOKEN,
    DTD_DETAIL_QUOTED_STRING_TOKEN,
    DTD_DETAIL_START_OF_SOURCE_TOKEN,
    DTD_DETAIL_UNQUOTED_STRING_TOKEN,
    DTD_DETAIL_WHITESPACE_TOKEN
  );

  TXmlDtdDetailTokenizer = class(TXmlCustomTokenizer)
  private
    FIsPERefInDeclSep: Boolean;
    FInPI: Boolean;  // Internally used to indicate that the Tokenizer is processing a Processing Instruction.
  protected
    FLastTokenType: TXmlDtdDetailTokenType;
    FTokenType: TXmlDtdDetailTokenType;
  public
    constructor Create(const InputSource: TXmlSimpleInputSource;
                       const AIsPERefInDeclSep: Boolean);
    procedure Next; override;
    procedure NextEndOfIgnoredCondSect; virtual;

    property IsPERefInDeclSep: Boolean read FIsPERefInDeclSep;
    property TokenType: TXmlDtdDetailTokenType read FTokenType;
  end;

  TDomPERepository = class;

  TXmlPERefTreatment = (petResolve, petResolveInDeclSep, petResolveInDeclSepSkipExt);

  TXmlDtdDetailPETokenizer = class(TUtilsNoRefCount, IDomLocator)
  private
    FBufSize: Integer;
    FErrorType: TXmlErrorType;
    FInputSourceStack: TStack<TXmlSimpleInputSource>;
    FPENameStack: TUtilsWideStringList;
    FPERefTreatment: TXmlPERefTreatment;
    FStreamStack: TStack<TUtilsWideStringStream>;
    FTokenizerStack: TStack<TXmlDtdDetailTokenizer>;

    FOnResolveParameterEntity: TDomResolveEntityEvent;

    procedure CreateInternalInputSource(const Stream: TStream;
                                        const PEName,
                                              PubId,
{$IFDEF NEXTGEN}
                                              SysId: string;
{$ELSE !NEXTGEN}
                                              SysId: WideString;
{$ENDIF NEXTGEN}
                                        const IsPERefInDeclSep: Boolean);
    procedure CreateInternalStream(const S,
                                         PEName,
                                         PubId,
{$IFDEF NEXTGEN}
                                         SysId: string;
{$ELSE !NEXTGEN}
                                         SysId: WideString;
{$ENDIF NEXTGEN}
                                   const IsPERefInDeclSep: Boolean);
    procedure CreateInternalTokenizer(const InputSource: TXmlSimpleInputSource;
{$IFDEF NEXTGEN}
                                      const PEName: string;
{$ELSE !NEXTGEN}
                                      const PEName: WideString;
{$ENDIF NEXTGEN}
                                      const IsPERefInDeclSep: Boolean);
    procedure DestroyInternalTokenizer;
{$IFDEF NEXTGEN}
    function GetClue: string;
    function GetCurrentPEName: string;
{$ELSE !NEXTGEN}
    function GetClue: WideString;
    function GetCurrentPEName: WideString;
{$ENDIF NEXTGEN}
    function GetErrorType: TXmlErrorType;
    function GetInternalTokenizer: TXmlDtdDetailTokenizer;
    function GetIsPERefInDeclSep: Boolean;
    function GetTokenType: TXmlDtdDetailTokenType;
{$IFDEF NEXTGEN}
    function GetTokenValue: string;
{$ELSE !NEXTGEN}
    function GetTokenValue: WideString;
{$ENDIF NEXTGEN}
    procedure SetPERefTreatment(const Value: TXmlPERefTreatment);
  protected
    FIsInMarkup: Boolean;
{$IFDEF NEXTGEN}
    procedure DoResolveParameterEntity(const EntityName: string;
                                         out EntityValue,
                                             PubId,
                                             SysId: string;
                                         out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
    procedure DoResolveParameterEntity(const EntityName: WideString;
                                         out EntityValue,
                                             PubId,
                                             SysId: WideString;
                                         out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
    function GetIsProcessingPE: Boolean; virtual;

    { IDomLocator interface methods: }
    function GetEndByteNumber: Int64; virtual;
    function GetEndCharNumber: Int64; virtual;
    function GetEndColumnNumber: Int64; virtual;
    function GetEndLineNumber: Int64; virtual;
    function GetEndTabsInLine: Int64; virtual;
    function GetRelatedDtdObject: TDtdObject; virtual;
    function GetRelatedNode: TDomNode; virtual;
    function GetStartByteNumber: Int64; virtual;
    function GetStartCharNumber: Int64; virtual;
    function GetStartColumnNumber: Int64; virtual;
    function GetStartLineNumber: Int64; virtual;
    function GetStartTabsInLine: Int64; virtual;
{$IFDEF NEXTGEN}
    function GetUri: string; virtual;
{$ELSE !NEXTGEN}
    function GetUri: WideString; virtual;
{$ENDIF NEXTGEN}

    property InternalTokenizer: TXmlDtdDetailTokenizer read GetInternalTokenizer;
  public
    constructor Create(const AInputSource: TXmlSimpleInputSource;
                       const AIsPERefInDeclSep: Boolean);
    destructor Destroy; override;
    procedure Next; virtual;
    procedure NextEndOfIgnoredCondSect; virtual;

{$IFDEF NEXTGEN}
    property Clue: string read GetClue;
    property CurrentPEName: string read GetCurrentPEName;
{$ELSE !NEXTGEN}
    property Clue: WideString read GetClue;
    property CurrentPEName: WideString read GetCurrentPEName;
{$ENDIF NEXTGEN}
    property ErrorType: TXmlErrorType read GetErrorType;
    property IsInMarkup: Boolean read FIsInMarkup;
    property IsPERefInDeclSep: Boolean read GetIsPERefInDeclSep;
    property IsProcessingPE: Boolean read GetIsProcessingPE;
    property PERefTreatment: TXmlPERefTreatment read FPERefTreatment write SetPERefTreatment default petResolve;
    property TokenType: TXmlDtdDetailTokenType read GetTokenType;
{$IFDEF NEXTGEN}
    property TokenValue: string read GetTokenValue;
{$ELSE !NEXTGEN}
    property TokenValue: WideString read GetTokenValue;
{$ENDIF NEXTGEN}

    property OnResolveParameterEntity: TDomResolveEntityEvent read FOnResolveParameterEntity write FOnResolveParameterEntity;
  end;

  TXmlSignal = class;
  TXmlCommentSignal = class;
  TXmlElementTypeDeclarationSignal = class;
  TXmlEntityDeclarationSignal = class;
  TXmlExternalPEReferenceSignal = class;
  TXmlNotationDeclarationSignal = class;
  TXmlParameterEntityDeclarationSignal = class;
  TXmlProcessingInstructionSignal = class;

  TXmlExtSubsetTokenizer = class;

  TXmlDtdAbstractTokenType = (
    DTD_ABSTRACT_ATTLIST_DECL_TOKEN,
    DTD_ABSTRACT_COMMENT_TOKEN,
    DTD_ABSTRACT_CONDITIONAL_SECTION_TOKEN,
    DTD_ABSTRACT_ELEMENT_DECL_TOKEN,
    DTD_ABSTRACT_END_OF_SOURCE_TOKEN,
    DTD_ABSTRACT_ENTITY_DECL_TOKEN,
    DTD_ABSTRACT_EXT_PARAMETER_ENTITY_REF_TOKEN,
    DTD_ABSTRACT_IGNORABLE_WHITESPACE_TOKEN,
    DTD_ABSTRACT_INVALID_MARKUP_TOKEN,
    DTD_ABSTRACT_NOTATION_DECL_TOKEN,
    DTD_ABSTRACT_PARAMETER_ENTITY_DECL_TOKEN,
    DTD_ABSTRACT_PI_TOKEN,
    DTD_ABSTRACT_START_OF_SOURCE_TOKEN
  );

  TXmlCustomSubsetTokenizer = class(TUtilsNoRefCount, IDomLocator)
  private
{$IFDEF NEXTGEN}
    function FindNextAttDef(    Decl: string;
                            out AttType: TXmlDataType;
                            out Constraint: TDomAttrValueConstraint;
                            out AttName,
                                Enumeration,
                                DefaultValue,
                                Rest: string): Boolean;
{$ELSE !NEXTGEN}
    function FindNextAttDef(    Decl: WideString;
                            out AttType: TXmlDataType;
                            out Constraint: TDomAttrValueConstraint;
                            out AttName,
                                Enumeration,
                                DefaultValue,
                                Rest: WideString): Boolean;
{$ENDIF NEXTGEN}
  protected
    FAllowConditionalSections: Boolean;
{$IFDEF NEXTGEN}
    FAttDeclElementType: string;
    FClue: string;
{$ELSE !NEXTGEN}
    FAttDeclElementType: WideString;
    FClue: WideString;
{$ENDIF NEXTGEN}
    FCondSectBracketPEName: TUtilsWideStringList;
    FCondSectStartPEName: TUtilsWideStringList;
    FCurrentSignal: TXmlSignal;
{$IFDEF NEXTGEN}
    FEntityDeclBaseUri: string;
{$ELSE !NEXTGEN}
    FEntityDeclBaseUri: WideString;
{$ENDIF NEXTGEN}
    FErrorType: TXmlErrorType;
    FPERepository: TDomPERepository;
    FTokenType: TXmlDtdAbstractTokenType;
    FOnPEReference: TDomLocationEvent;
    FOnProcessingAttListDecl: TDomWideStringLocationEvent;
    FOpeningBracketPEName: TUtilsWideStringList;
{$IFDEF NEXTGEN}
    FPendingAttrDefs: string;
    FXmlDtdDetailPETokenizer: TXmlDtdDetailPETokenizer;
    function CreateCommentSignal(const Data: string): TXmlCommentSignal;
    function CreateElementDeclSignal(const ElementName,
                                           Data: string;
                                     const IsDeclaredInPE: Boolean): TXmlElementTypeDeclarationSignal;
    function CreateEntityDeclSignal(const EntityName,
                                          EntityValue,
                                          PublicId,
                                          SystemId,
                                          NotationName,
                                          BaseUri: string;
                                    const IsDeclaredInPE: Boolean): TXmlEntityDeclarationSignal;
    function CreateExtPERefSignal(const ParameterEntityReference: string): TXmlExternalPEReferenceSignal;
    function CreateParameterEntityDeclSignal(const EntityName,
                                                   EntityValue,
                                                   PublicId,
                                                   SystemId,
                                                   BaseUri: string): TXmlParameterEntityDeclarationSignal;
    function CreatePISignal(const Target,
                                  Data: string): TXmlProcessingInstructionSignal;
    function CreateNotationDeclSignal(const NotationName,
                                            PubidLiteral,
                                            SystemLiteral: string;
                                      const IsDeclaredInPE: Boolean): TXmlNotationDeclarationSignal;
    procedure DoPEReference;
    procedure DoProcessingAttListDecl(const ElementType: string);
    function GetAllowPEsInMarkup: Boolean; virtual;
    function GetClue: string; virtual;
    function GetEntityDeclBaseUri: string; virtual;
    function GetErrorType: TXmlErrorType; virtual;
    function GetIsProcessingPE: Boolean; virtual;
    function GetSystemId: string; virtual;
    function GetTokenType: TXmlDtdAbstractTokenType ; virtual;
    function IncludePERefsInLiteral(const S: string;
                                   out ErrType: TXmlErrorType): string;
    function ProcessPendingAttrDef: Boolean;
    procedure ResolveParameterEntityEventHandler(      Sender: TObject;
                                                 const EntityName: string;
                                                   var EntityValue,
                                                       PubId,
                                                       SysId: string;
                                                   var Error: TXmlErrorType);  virtual; abstract;
{$ELSE !NEXTGEN}
    FPendingAttrDefs: WideString;
    FXmlDtdDetailPETokenizer: TXmlDtdDetailPETokenizer;
    function CreateCommentSignal(const Data: WideString): TXmlCommentSignal;
    function CreateElementDeclSignal(const ElementName,
                                           Data: WideString;
                                     const IsDeclaredInPE: Boolean): TXmlElementTypeDeclarationSignal;
    function CreateEntityDeclSignal(const EntityName,
                                          EntityValue,
                                          PublicId,
                                          SystemId,
                                          NotationName,
                                          BaseUri: WideString;
                                    const IsDeclaredInPE: Boolean): TXmlEntityDeclarationSignal;
    function CreateExtPERefSignal(const ParameterEntityReference: WideString): TXmlExternalPEReferenceSignal;
    function CreateParameterEntityDeclSignal(const EntityName,
                                                   EntityValue,
                                                   PublicId,
                                                   SystemId,
                                                   BaseUri: WideString): TXmlParameterEntityDeclarationSignal;
    function CreatePISignal(const Target,
                                  Data: WideString): TXmlProcessingInstructionSignal;
    function CreateNotationDeclSignal(const NotationName,
                                            PubidLiteral,
                                            SystemLiteral: WideString;
                                      const IsDeclaredInPE: Boolean): TXmlNotationDeclarationSignal;
    procedure DoPEReference;
    procedure DoProcessingAttListDecl(const ElementType: WideString);
    function GetAllowPEsInMarkup: Boolean; virtual;
    function GetClue: WideString; virtual;
    function GetEntityDeclBaseUri: WideString; virtual;
    function GetErrorType: TXmlErrorType; virtual;
    function GetIsProcessingPE: Boolean; virtual;
    function GetSystemId: WideString; virtual;
    function GetTokenType: TXmlDtdAbstractTokenType ; virtual;
    function IncludePERefsInLiteral(const S: WideString;
                                   out ErrType: TXmlErrorType): WideString;
    function ProcessPendingAttrDef: Boolean;
    procedure ResolveParameterEntityEventHandler(      Sender: TObject;
                                                 const EntityName: WideString;
                                                   var EntityValue,
                                                       PubId,
                                                       SysId: WideString;
                                                   var Error: TXmlErrorType);  virtual; abstract;
{$ENDIF NEXTGEN}

    { IDomLocator interface methods: }
    function GetEndByteNumber: Int64; virtual;
    function GetEndCharNumber: Int64; virtual;
    function GetEndColumnNumber: Int64; virtual;
    function GetEndLineNumber: Int64; virtual;
    function GetEndTabsInLine: Int64; virtual;
    function GetRelatedDtdObject: TDtdObject; virtual;
    function GetRelatedNode: TDomNode; virtual;
    function GetStartByteNumber: Int64; virtual;
    function GetStartCharNumber: Int64; virtual;
    function GetStartColumnNumber: Int64; virtual;
    function GetStartLineNumber: Int64; virtual;
    function GetStartTabsInLine: Int64; virtual;
{$IFDEF NEXTGEN}
    function GetUri: string; virtual;
{$ELSE !NEXTGEN}
    function GetUri: WideString; virtual;
{$ENDIF NEXTGEN}
  public
    constructor Create(const AInputSource: TXmlSimpleInputSource;
                       const APERepository: TDomPERepository);
    destructor Destroy; override;
    procedure Next; virtual;

    property AllowPEsInMarkup: Boolean read GetAllowPEsInMarkup;
{$IFDEF NEXTGEN}
    property Clue: string read GetClue;
    property CurrentSignal: TXmlSignal read FCurrentSignal;
    property EntityDeclBaseUri: string read GetEntityDeclBaseUri;
{$ELSE !NEXTGEN}
    property Clue: WideString read GetClue;
    property CurrentSignal: TXmlSignal read FCurrentSignal;
    property EntityDeclBaseUri: WideString read GetEntityDeclBaseUri;
{$ENDIF NEXTGEN}
    property ErrorType: TXmlErrorType read GetErrorType;
    property IsProcessingPE: Boolean read GetIsProcessingPE;
    property PERepository: TDomPERepository read FPERepository;
{$IFDEF NEXTGEN}
    property SystemId: string read GetSystemId;
{$ELSE !NEXTGEN}
    property SystemId: WideString read GetSystemId;
{$ENDIF NEXTGEN}
    property TokenType: TXmlDtdAbstractTokenType read GetTokenType;

    property OnPEReference: TDomLocationEvent read FOnPEReference write FOnPEReference;
    property OnProcessingAttListDecl: TDomWideStringLocationEvent read FOnProcessingAttListDecl write FOnProcessingAttListDecl;
  end;

  TXmlExtSubsetTokenizer = class(TXmlCustomSubsetTokenizer)
  protected
{$IFDEF NEXTGEN}
    procedure ResolveParameterEntityEventHandler(      Sender: TObject;
                                                 const EntityName: string;
                                                   var EntityValue,
                                                       PubId,
                                                       SysId: string;
                                                   var Error: TXmlErrorType);  override;
{$ELSE !NEXTGEN}
    procedure ResolveParameterEntityEventHandler(      Sender: TObject;
                                                 const EntityName: WideString;
                                                   var EntityValue,
                                                       PubId,
                                                       SysId: WideString;
                                                   var Error: TXmlErrorType);  override;
{$ENDIF NEXTGEN}
  public
    constructor Create(const AInputSource: TXmlInputSource;
                       const APERepository: TDomPERepository);
  end;

  TXmlIntSubsetTokenizer = class(TXmlCustomSubsetTokenizer)
  protected
    function GetResolveExtPEs: Boolean; virtual;
{$IFDEF NEXTGEN}
    procedure ResolveParameterEntityEventHandler(      Sender: TObject;
                                                 const EntityName: string;
                                                   var EntityValue,
                                                       PubId,
                                                       SysId: string;
                                                   var Error: TXmlErrorType);  override;
{$ELSE !NEXTGEN}
    procedure ResolveParameterEntityEventHandler(      Sender: TObject;
                                                 const EntityName: WideString;
                                                   var EntityValue,
                                                       PubId,
                                                       SysId: WideString;
                                                   var Error: TXmlErrorType);  override;
{$ENDIF NEXTGEN}
    procedure SetResolveExtPEs(const Value: Boolean); virtual;
  public
    constructor Create(const AInputSource: TXmlSimpleInputSource;
                       const APERepository: TDomPERepository);

    property ResolveExtPEs: Boolean read GetResolveExtPEs write SetResolveExtPEs default True;
  end;

  TXmlElementCMTokenType = (
    DTD_ECM_ANY_KEYWORD_TOKEN,
    DTD_ECM_CLOSING_BRACKET_TOKEN,
    DTD_ECM_EMPTY_KEYWORD_TOKEN,
    DTD_ECM_END_OF_SOURCE_TOKEN,
    DTD_ECM_FREQUENCY_TOKEN,
    DTD_ECM_INVALID_MARKUP_TOKEN,
    DTD_ECM_NAME_TOKEN,
    DTD_ECM_OPENING_BRACKET_TOKEN,
    DTD_ECM_PCDATA_KEYWORD_TOKEN,
    DTD_ECM_SEPARATOR_TOKEN,
    DTD_ECM_START_OF_SOURCE_TOKEN
  );

  TXmlElementCMTokenizer = class
  protected
{$IFDEF NEXTGEN}
    FClue: string;
{$ELSE !NEXTGEN}
    FClue: WideString;
{$ENDIF NEXTGEN}
    FBracketFound: Boolean;
    FErrorType: TXmlErrorType;
    FUCS4Reader: TUtilsUCS4Reader;
    FStringStream: TUtilsWideStringStream;
    FTokenType: TXmlElementCMTokenType;
    FTokenValue: TUtilsCustomWideStr;
{$IFDEF NEXTGEN}
    function GetTokenValue: string; virtual;
{$ELSE !NEXTGEN}
    function GetTokenValue: WideString; virtual;
{$ENDIF NEXTGEN}
  public
{$IFDEF NEXTGEN}
    constructor Create(const S: string);
{$ELSE !NEXTGEN}
    constructor Create(const S: WideString);
{$ENDIF NEXTGEN}
    destructor Destroy; override;
    procedure Next; virtual;

{$IFDEF NEXTGEN}
    property Clue: string read FClue;
{$ELSE !NEXTGEN}
    property Clue: WideString read FClue;
{$ENDIF NEXTGEN}
    property ErrorType: TXmlErrorType read FErrorType;
    property TokenType: TXmlElementCMTokenType read FTokenType;
{$IFDEF NEXTGEN}
    property TokenValue: string read GetTokenValue;
{$ELSE !NEXTGEN}
    property TokenValue: WideString read GetTokenValue;
{$ENDIF NEXTGEN}
  end;

  TXmlDoctypeDeclTokenType = (
    DOCTYPE_END_OF_SOURCE_TOKEN,
    DOCTYPE_INTSUBSET_TOKEN,
    DOCTYPE_NAME_TOKEN,
    DOCTYPE_PUBID_TOKEN,
    DOCTYPE_START_OF_SOURCE_TOKEN,
    DOCTYPE_SYSID_TOKEN
  );

  TXmlDoctypeDeclTokenizer = class(TUtilsNoRefCount, IDomLocator)
  protected
{$IFDEF NEXTGEN}
    FClue: string;
{$ELSE !NEXTGEN}
    FClue: WideString;
{$ENDIF NEXTGEN}
    FErrorType: TXmlErrorType;
    FInputSource: TXmlSimpleInputSource;
    FStringStream: TUtilsWideStringStream;
    FTokenEnd: TUtilsUCS4CharData;
    FTokenStart: TUtilsUCS4CharData;
    FTokenType: TXmlDoctypeDeclTokenType;
    FTokenValue: TUtilsCustomWideStr;
{$IFDEF NEXTGEN}
    function GetTokenValue: string; virtual;
{$ELSE !NEXTGEN}
    function GetTokenValue: WideString; virtual;
{$ENDIF NEXTGEN}

    { IDomLocator interface methods: }
    function GetEndByteNumber: Int64; virtual;
    function GetEndCharNumber: Int64; virtual;
    function GetEndColumnNumber: Int64; virtual;
    function GetEndLineNumber: Int64; virtual;
    function GetEndTabsInLine: Int64; virtual;
    function GetRelatedDtdObject: TDtdObject; virtual;
    function GetRelatedNode: TDomNode; virtual;
    function GetStartByteNumber: Int64; virtual;
    function GetStartCharNumber: Int64; virtual;
    function GetStartColumnNumber: Int64; virtual;
    function GetStartLineNumber: Int64; virtual;
    function GetStartTabsInLine: Int64; virtual;
{$IFDEF NEXTGEN}
    function GetUri: string; virtual;
{$ELSE !NEXTGEN}
    function GetUri: WideString; virtual;
{$ENDIF NEXTGEN}
  public
    constructor Create(const S,
{$IFDEF NEXTGEN}
                             DocumentUri: string;
{$ELSE !NEXTGEN}
                             DocumentUri: WideString;
{$ENDIF NEXTGEN}
                             InitialByteCount,
                             InitialCharCount,
                             InitialCharsInLine,
                             InitialTabsInLine,
                             InitialLine: Int64);
    destructor Destroy; override;
    procedure Next; virtual;

{$IFDEF NEXTGEN}
    property Clue: string read FClue;
{$ELSE !NEXTGEN}
    property Clue: WideString read FClue;
{$ENDIF NEXTGEN}
    property ErrorType: TXmlErrorType read FErrorType;
    property TokenType: TXmlDoctypeDeclTokenType read FTokenType;
{$IFDEF NEXTGEN}
    property TokenValue: string read GetTokenValue;
{$ELSE !NEXTGEN}
    property TokenValue: WideString read GetTokenValue;
{$ENDIF NEXTGEN}
  end;

  TXmlAttrValueTokenType = (
    ATTR_CHAR_REF,
    ATTR_END_OF_SOURCE_TOKEN,
    ATTR_ENTITY_REF,
    ATTR_START_OF_SOURCE_TOKEN,
    ATTR_TEXT
  );

  TXmlAttrValueTokenizer = class
  protected
    FErrorType: TXmlErrorType;
    FUCS4Reader: TUtilsUCS4Reader;
    FStringStream: TUtilsWideStringStream;
    FTokenType: TXmlAttrValueTokenType;
    FTokenValue: TUtilsCustomWideStr;
{$IFDEF NEXTGEN}
    function GetTokenValue: string; virtual;
  public
    constructor Create(const S: string);
{$ELSE !NEXTGEN}
    function GetTokenValue: WideString; virtual;
  public
    constructor Create(const S: WideString);
{$ENDIF NEXTGEN}
    destructor Destroy; override;
    procedure Next; virtual;

    property ErrorType: TXmlErrorType read FErrorType;
    property TokenType: TXmlAttrValueTokenType read FTokenType;
{$IFDEF NEXTGEN}
    property TokenValue: string read GetTokenValue;
{$ELSE !NEXTGEN}
    property TokenValue: WideString read GetTokenValue;
{$ENDIF NEXTGEN}
  end;

  TXmlOutputSource = class(TUtilsCustomOutputStream)
  private
    FCodec: TUnicodeCodec;
    FEncoding: string;
    procedure SetEncoding(const Value: string);
    function GetWriteLFOption: TCodecWriteLFOption;
    procedure SetWriteLFOption(const Value: TCodecWriteLFOption);
  protected
{$IFDEF CLR}
    procedure Write(const Buf: TBytes; const Count: Longint); override;
    // Remark: In Delphi for .NET we must repeat a protected declaration inherited
    //         from another assembly in order to use it outside of a direct ancestor.
{$ENDIF}
    procedure WriteEventHandler(const Sender: TObject;
                                const Buf{$IFDEF CLR}: array of Byte{$ENDIF};
                                      Count: Longint); virtual;
  public
    constructor Create(const Stream: TStream;
                       const BufSize: Integer);
    destructor Destroy; override;
    function WriteByteOrderMark: Integer; virtual;
    procedure WriteUCS4Char(const C: UCS4Char;
                              out ByteCount: Integer); virtual;

    property BufSize;
    property Encoding: string read FEncoding write SetEncoding;  // The default is 'UTF-8'
    property WriteLFOption: TCodecWriteLFOption read GetWriteLFOption write SetWriteLFOption default lwCRLF;
  end;

  TXmlCustomParser      = class;
  TXmlToDomParser       = class;
  TXmlCustomReader      = class;
  TXmlStandardDocReader = class;
  TXmlStandardDtdReader = class;
  TXmlCustomHandler     = class;

  TXmlProcessingEvent = procedure(Sender: TObject;
                                  Signal: TXmlSignal;
                                  var Accept: Boolean) of object;

  TXmlPostProcessingEvent = procedure(Sender: TObject;
                                      Signal: TXmlSignal) of object;

  TDomPERepository = class
  private
    [Weak] FOwner: TXmlCustomReader;
    FPEList: TUtilsWideStringList;
  protected
{$IFDEF NEXTGEN}
    procedure ResolveResourceAsWideString(const BaseURI: string;
                                          const PublicId,
                                                SystemId: string;
                                            out S: string;
                                            out Error: TXmlErrorType); virtual;
{$ELSE !NEXTGEN}
    procedure ResolveResourceAsWideString(const BaseURI: WideString;
                                          const PublicId,
                                                SystemId: WideString;
                                            out S: WideString;
                                            out Error: TXmlErrorType); virtual;
{$ENDIF NEXTGEN}
  public
    constructor Create(const AOwner: TXmlCustomReader);
    destructor Destroy; override;
{$IFDEF NEXTGEN}
    function Add(const Name,
                       Value: string): Boolean; overload;
    function Add(const Name,
                       BaseUri,
                       PubId,
                       SysId: string): Boolean; overload;
    procedure Clear; virtual;
    function Delete(const Name: string): Boolean; virtual;
    function ResolvePE(const Name: string;
                       const AcceptExtEntity: Boolean;
                         out Value,
                             PubId,
                             SysId: string): TXmlErrorType; virtual;
{$ELSE !NEXTGEN}
    function Add(const Name,
                       Value: WideString): Boolean; overload;
    function Add(const Name,
                       BaseUri,
                       PubId,
                       SysId: WideString): Boolean; overload;
    procedure Clear; virtual;
    function Delete(const Name: WideString): Boolean; virtual;
    function ResolvePE(const Name: WideString;
                       const AcceptExtEntity: Boolean;
                         out Value,
                             PubId,
                             SysId: WideString): TXmlErrorType; virtual;
{$ENDIF NEXTGEN}

    property OwnerReader: TXmlCustomReader read FOwner;
  end;

{$IFDEF NEXTGEN}
  TDomPEInfoObject = class(TDomCustomNode)
  private
    FBaseUri: string;
    FEntityType: TDomEntityType;
    FUpdateAttempted: Boolean;
    FUpdateError: TXmlErrorType;
    FLiteralValue: string;
    FNodeName: string;
    [Weak] FOwnerRepository: TDomPERepository;
    FPublicId: string;
    FSystemId: string;
  protected
    function GetNodeName: string; override;
  public
    constructor Create(const AOwner: TDomPERepository;
                       const EntityName,
                             LitValue: string);
    constructor CreateExtParsed(const AOwner: TDomPERepository;
                                const EntityName,
                                      ABaseUri,
                                      PubId,
                                      SysId: string);
    function EntityURI: string;
    procedure Update;

    property BaseUri: string read FBaseUri;
    property EntityType: TDomEntityType read FEntityType;
    property LiteralValue: string read FLiteralValue;
    property OwnerRepository: TDomPERepository read FOwnerRepository;
    property PublicId: string read FPublicId;
    property SystemId: string read FSystemId;
    property UpdateAttempted: Boolean read FUpdateAttempted;
    property UpdateError: TXmlErrorType read FUpdateError;
  end;
{$ELSE !NEXTGEN}
  TDomPEInfoObject = class(TDomCustomNode)
  private
    FBaseUri: WideString;
    FEntityType: TDomEntityType;
    FUpdateAttempted: Boolean;
    FUpdateError: TXmlErrorType;
    FLiteralValue: WideString;
    FNodeName: WideString;
    FOwnerRepository: TDomPERepository;
    FPublicId: WideString;
    FSystemId: WideString;
  protected
    function GetNodeName: WideString; override;
  public
    constructor Create(const AOwner: TDomPERepository;
                       const EntityName,
                             LitValue: WideString);
    constructor CreateExtParsed(const AOwner: TDomPERepository;
                                const EntityName,
                                      ABaseUri,
                                      PubId,
                                      SysId: WideString);
    function EntityURI: WideString;
    procedure Update;

    property BaseUri: WideString read FBaseUri;
    property EntityType: TDomEntityType read FEntityType;
    property LiteralValue: WideString read FLiteralValue;
    property OwnerRepository: TDomPERepository read FOwnerRepository;
    property PublicId: WideString read FPublicId;
    property SystemId: WideString read FSystemId;
    property UpdateAttempted: Boolean read FUpdateAttempted;
    property UpdateError: TXmlErrorType read FUpdateError;
  end;
{$ENDIF NEXTGEN}

{ XML Fragments }

  TXmlSignalScope = set of ( ssDoc, ssDtd );

  TXmlSignal = class(TUtilsNoRefCount, IDomLocator)
  private
    FEndByteNumber:     Int64;
    FEndCharNumber:     Int64;
    FEndColumnNumber:   Int64;
    FEndLineNumber:     Int64;
    FEndTabsInLine:     Int64;
    FReader:            TXmlCustomReader;
    FRelatedDtdObject:  TDtdObject;
    FRelatedNode:       TDomNode;
    FStartByteNumber:   Int64;
    FStartCharNumber:   Int64;
    FStartColumnNumber: Int64;
    FStartLineNumber:   Int64;
    FStartTabsInLine:   Int64;
{$IFDEF NEXTGEN}
    FUri:               string;
{$ELSE !NEXTGEN}
    FUri:               WideString;
{$ENDIF NEXTGEN}
  protected
    procedure InitSignal(const AReader: TXmlCustomReader;
                         const AStartByteNumber,
                               AStartCharNumber,
                               AStartColumnNumber,
                               AStartLineNumber,
                               AStartTabsInLine,
                               AEndByteNumber,
                               AEndCharNumber,
                               AEndColumnNumber,
                               AEndLineNumber,
                               AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                         const AUri: string;
{$ELSE !NEXTGEN}
                         const AUri: WideString;
{$ENDIF NEXTGEN}
                         const ARelatedDtdObject: TDtdObject;
                         const ARelatedNode: TDomNode); virtual;
    { IDomLocator interface methods: }
    function GetEndByteNumber: Int64; virtual;
    function GetEndCharNumber: Int64; virtual;
    function GetEndColumnNumber: Int64; virtual;
    function GetEndLineNumber: Int64; virtual;
    function GetEndTabsInLine: Int64; virtual;
    function GetRelatedDtdObject: TDtdObject; virtual;
    function GetRelatedNode: TDomNode; virtual;
    function GetStartByteNumber: Int64; virtual;
    function GetStartCharNumber: Int64; virtual;
    function GetStartColumnNumber: Int64; virtual;
    function GetStartLineNumber: Int64; virtual;
    function GetStartTabsInLine: Int64; virtual;
{$IFDEF NEXTGEN}
    function GetUri: string; virtual;
{$ELSE !NEXTGEN}
    function GetUri: WideString; virtual;
{$ENDIF NEXTGEN}
  public
    constructor Create(const AReader: TXmlCustomReader;
                       const AStartByteNumber,
                             AStartCharNumber,
                             AStartColumnNumber,
                             AStartLineNumber,
                             AStartTabsInLine,
                             AEndByteNumber,
                             AEndCharNumber,
                             AEndColumnNumber,
                             AEndLineNumber,
                             AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                       const AUri: string;
{$ELSE !NEXTGEN}
                       const AUri: WideString;
{$ENDIF NEXTGEN}
                       const ARelatedDtdObject: TDtdObject;
                       const ARelatedNode: TDomNode); virtual;
    constructor CreateFromLocator(const AReader: TXmlCustomReader;
                                  const Location: IDomLocator); virtual;
{$IFDEF NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); virtual;
{$ELSE !NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); virtual;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; virtual;
    function Scope: TXmlSignalScope; virtual; abstract;

    property Reader: TXmlCustomReader read FReader;

    { IDomLocator interface properties: }                                                                               
    property EndByteNumber: Int64 read GetEndByteNumber;
    property EndCharNumber: Int64 read GetEndCharNumber;
    property EndColumnNumber: Int64 read GetEndColumnNumber;
    property EndLineNumber: Int64 read GetEndLineNumber;
    property EndTabsInLine: Int64 read GetEndTabsInLine;
    property RelatedDtdObject: TDtdObject read GetRelatedDtdObject;
    property RelatedNode: TDomNode read GetRelatedNode;
    property StartByteNumber: Int64 read GetStartByteNumber;
    property StartCharNumber: Int64 read GetStartCharNumber;
    property StartColumnNumber: Int64 read GetStartColumnNumber;
    property StartLineNumber: Int64 read GetStartLineNumber;
    property StartTabsInLine: Int64 read GetStartTabsInLine;
{$IFDEF NEXTGEN}
    property Uri: string read GetUri;
{$ELSE !NEXTGEN}
    property Uri: WideString read GetUri;
{$ENDIF NEXTGEN}
  end;

  { Special XML Signals }

  TXmlCompletedSignal = class(TXmlSignal)
  public
    function Scope: TXmlSignalScope; override;
  end;

  TXmlAbortedSignal = class(TXmlSignal)
  public
    function Scope: TXmlSignalScope; override;
  end;

  { Non-DTD XML Signals }

  TXmlAttributeSignal = class(TXmlSignal)
  private
    FDataType: TXmlDataType;
{$IFDEF NEXTGEN}
    FName: string;
    FValue: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FName: WideString;
    FValue: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property DataType: TXmlDataType read FDataType write FDataType;
{$IFDEF NEXTGEN}
    property Name: string read FName write FName;
    property Value: string read FValue write FValue;
{$ELSE !NEXTGEN}
    property Name: WideString read FName write FName;
    property Value: WideString read FValue write FValue;
{$ENDIF NEXTGEN}
  end;

  TXmlCDATASignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FData: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FData: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property Data: string read FData write FData;
{$ELSE !NEXTGEN}
    property Data: WideString read FData write FData;
{$ENDIF NEXTGEN}
  end;

  TXmlDoctypeSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FData: string;
    FDoctypeName: string;
{$ELSE !NEXTGEN}
    FData: WideString;
    FDoctypeName: WideString;
{$ENDIF NEXTGEN}
    FIntSubsetByteNumber: Int64;
    FIntSubsetCharNumber: Int64;
    FIntSubsetStartColumn: Int64;
    FIntSubsetStartLine: Int64;
{$IFDEF NEXTGEN}
    FPublicId: string;
    FSystemId: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FPublicId: WideString;
    FSystemId: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property Data: string read FData write FData;
    property DoctypeName: string read FDoctypeName write FDoctypeName;
{$ELSE !NEXTGEN}
    property Data: WideString read FData write FData;
    property DoctypeName: WideString read FDoctypeName write FDoctypeName;
{$ENDIF NEXTGEN}
    property IntSubsetStartByteNumber: Int64 read FIntSubsetByteNumber write FIntSubsetByteNumber;
    property IntSubsetStartCharNumber: Int64 read FIntSubsetCharNumber write FIntSubsetCharNumber;
    property IntSubsetStartColumn: Int64 read FIntSubsetStartColumn write FIntSubsetStartColumn;
    property IntSubsetStartLine: Int64 read FIntSubsetStartLine write FIntSubsetStartLine;
{$IFDEF NEXTGEN}
    property PublicId: string read FPublicId write FPublicId;
    property SystemId: string read FSystemId write FSystemId;
{$ELSE !NEXTGEN}
    property PublicId: WideString read FPublicId write FPublicId;
    property SystemId: WideString read FSystemId write FSystemId;
{$ENDIF NEXTGEN}
  end;

  TXmlEndElementSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FTagName: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FTagName: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property TagName: string read FTagName write FTagName;
{$ELSE !NEXTGEN}
    property TagName: WideString read FTagName write FTagName;
{$ENDIF NEXTGEN}
  end;

  TXmlEndPrefixMappingSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FPrefix: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property Prefix: string read FPrefix write FPrefix;                                                                       
{$ELSE !NEXTGEN}
    FPrefix: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property Prefix: WideString read FPrefix write FPrefix;                                                                       
{$ENDIF NEXTGEN}
  end;

  TXmlEntityRefSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FEntityName: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property EntityName: string read FEntityName write FEntityName;
{$ELSE !NEXTGEN}
    FEntityName: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property EntityName: WideString read FEntityName write FEntityName;
{$ENDIF NEXTGEN}
  end;

  TXmlPCDATASignal = class(TXmlSignal)
  private
    FCharRefGenerated: Boolean;
{$IFDEF NEXTGEN}
    FData: string;
{$ELSE !NEXTGEN}
    FData: WideString;
{$ENDIF NEXTGEN}
  protected
    procedure InitSignal(const AReader: TXmlCustomReader;
                         const AStartByteNumber,
                               AStartCharNumber,
                               AStartColumnNumber,
                               AStartLineNumber,
                               AStartTabsInLine,
                               AEndByteNumber,
                               AEndCharNumber,
                               AEndColumnNumber,
                               AEndLineNumber,
                               AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                         const AUri: string;
{$ELSE !NEXTGEN}
                         const AUri: WideString;
{$ENDIF NEXTGEN}
                         const ARelatedDtdObject: TDtdObject;
                         const ARelatedNode: TDomNode); override;
  public
{$IFDEF NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property CharRefGenerated: Boolean read FCharRefGenerated write FCharRefGenerated default False;
{$IFDEF NEXTGEN}
    property Data: string read FData write FData;
{$ELSE !NEXTGEN}
    property Data: WideString read FData write FData;
{$ENDIF NEXTGEN}
  end;

  TXmlSkippedEntitySignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FEntityName: string;
{$ELSE !NEXTGEN}
    FEntityName: WideString;
{$ENDIF NEXTGEN}
  public
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property EntityName: string read FEntityName write FEntityName;
{$ELSE !NEXTGEN}
    property EntityName: WideString read FEntityName write FEntityName;
{$ENDIF NEXTGEN}
  end;

  TXmlStartDocumentSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FEncodingName: string;
    FInputEncoding: string;
    FStandaloneDecl: TDomStandalone;
    FVersion: string;
{$ELSE !NEXTGEN}
    FEncodingName: WideString;
    FInputEncoding: WideString;
    FStandaloneDecl: TDomStandalone;
    FVersion: WideString;
{$ENDIF NEXTGEN}
  public
{$IFDEF NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property EncodingName: string read FEncodingName write FEncodingName;
    property InputEncoding: string read FInputEncoding write FInputEncoding;
    property StandaloneDecl: TDomStandalone read FStandaloneDecl write FStandaloneDecl;
    property Version: string read FVersion write FVersion;
{$ELSE !NEXTGEN}
    property EncodingName: WideString read FEncodingName write FEncodingName;
    property InputEncoding: WideString read FInputEncoding write FInputEncoding;
    property StandaloneDecl: TDomStandalone read FStandaloneDecl write FStandaloneDecl;
    property Version: WideString read FVersion write FVersion;
{$ENDIF NEXTGEN}
  end;

  TXmlStartDocumentFragmentSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FEncodingName: string;
{$ELSE !NEXTGEN}
    FEncodingName: WideString;
{$ENDIF NEXTGEN}
  public
{$IFDEF NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property EncodingName: string read FEncodingName write FEncodingName;
{$ELSE !NEXTGEN}
    property EncodingName: WideString read FEncodingName write FEncodingName;
{$ENDIF NEXTGEN}
  end;

  TXmlStartElementSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FTagName: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FTagName: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property TagName: string read FTagName write FTagName;
{$ELSE !NEXTGEN}
    property TagName: WideString read FTagName write FTagName;
{$ENDIF NEXTGEN}
  end;

  TXmlStartPrefixMappingSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FPrefix: string;
    FUri: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FPrefix: WideString;
    FUri: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property Prefix: string read FPrefix write FPrefix;
    property Uri: string read FUri write FUri;
{$ELSE !NEXTGEN}
    property Prefix: WideString read FPrefix write FPrefix;
    property Uri: WideString read FUri write FUri;
{$ENDIF NEXTGEN}
  end;

  { Non-DTD as well as DTD XML Signals }

  TXmlCommentSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FData: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FData: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property Data: string read FData write FData;
{$ELSE !NEXTGEN}
    property Data: WideString read FData write FData;
{$ENDIF NEXTGEN}
  end;

  TXmlProcessingInstructionSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FData: string;
    FTarget: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FData: WideString;
    FTarget: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property Data: string read FData write FData;
    property Target: string read FTarget write FTarget;
{$ELSE !NEXTGEN}
    property Data: WideString read FData write FData;
    property Target: WideString read FTarget write FTarget;
{$ENDIF NEXTGEN}
  end;

  { DTD XML Signals }

  TXmlAttributeDefinitionSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FAttributeName: string;
    FAttributeType: TXmlDataType;
    FConstraint: TDomAttrValueConstraint;
    FDefaultValue: string;
    FEnumeration: TUtilsWideStringList;
    FElementName: string;
{$ELSE !NEXTGEN}
    FAttributeName: WideString;
    FAttributeType: TXmlDataType;
    FConstraint: TDomAttrValueConstraint;
    FDefaultValue: WideString;
    FEnumeration: TUtilsWideStringList;
    FElementName: WideString;
{$ENDIF NEXTGEN}
    FIsDeclaredInPE: Boolean;
    procedure SetEnumeration(const Value: TUtilsWideStringList);
  protected
    procedure InitSignal(const AReader: TXmlCustomReader;
                         const AStartByteNumber,
                               AStartCharNumber,
                               AStartColumnNumber,
                               AStartLineNumber,
                               AStartTabsInLine,
                               AEndByteNumber,
                               AEndCharNumber,
                               AEndColumnNumber,
                               AEndLineNumber,
                               AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                         const AUri: string;
{$ELSE !NEXTGEN}
                         const AUri: WideString;
{$ENDIF NEXTGEN}
                         const ARelatedDtdObject: TDtdObject;
                         const ARelatedNode: TDomNode); override;
  public
    destructor Destroy; override;
{$IFDEF NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property AttributeName: string read FAttributeName write FAttributeName;
    property AttributeType: TXmlDataType read FAttributeType write FAttributeType;
    property Constraint: TDomAttrValueConstraint read FConstraint write FConstraint;
    property DefaultValue: string read FDefaultValue write FDefaultValue;
    property ElementName: string read FElementName write FElementName;
{$ELSE !NEXTGEN}
    property AttributeName: WideString read FAttributeName write FAttributeName;
    property AttributeType: TXmlDataType read FAttributeType write FAttributeType;
    property Constraint: TDomAttrValueConstraint read FConstraint write FConstraint;
    property DefaultValue: WideString read FDefaultValue write FDefaultValue;
    property ElementName: WideString read FElementName write FElementName;
{$ENDIF NEXTGEN}
    property Enumeration: TUtilsWideStringList read FEnumeration write SetEnumeration;
    property IsDeclaredInPE: Boolean read FIsDeclaredInPE write FIsDeclaredInPE;
  end;

  TXmlElementTypeDeclarationSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FData: string;
    FElementName: string;
    FIsDeclaredInPE: Boolean;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FData: WideString;
    FElementName: WideString;
    FIsDeclaredInPE: Boolean;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property Data: string read FData write FData;
    property ElementName: string read FElementName write FElementName;
{$ELSE !NEXTGEN}
    property Data: WideString read FData write FData;
    property ElementName: WideString read FElementName write FElementName;
{$ENDIF NEXTGEN}
    property IsDeclaredInPE: Boolean read FIsDeclaredInPE write FIsDeclaredInPE;
  end;

  TXmlEntityDeclarationSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FBaseUri: string;
    FEntityValue: string;
    FPublicId: string;
    FNotationName: string;
    FEntityName: string;
    FSystemId: string;
    FIsDeclaredInPE: Boolean;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property BaseUri: string read FBaseUri write FBaseUri;
    property EntityName: string read FEntityName write FEntityName;
    property EntityValue: string read FEntityValue write FEntityValue;
    property IsDeclaredInPE: Boolean read FIsDeclaredInPE write FIsDeclaredInPE;
    property NotationName: string read FNotationName write FNotationName;
    property PublicId: string read FPublicId write FPublicId;
    property SystemId: string read FSystemId write FSystemId;
{$ELSE !NEXTGEN}
    FBaseUri: WideString;
    FEntityValue: WideString;
    FPublicId: WideString;
    FNotationName: WideString;
    FEntityName: WideString;
    FSystemId: WideString;
    FIsDeclaredInPE: Boolean;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property BaseUri: WideString read FBaseUri write FBaseUri;
    property EntityName: WideString read FEntityName write FEntityName;
    property EntityValue: WideString read FEntityValue write FEntityValue;
    property IsDeclaredInPE: Boolean read FIsDeclaredInPE write FIsDeclaredInPE;
    property NotationName: WideString read FNotationName write FNotationName;
    property PublicId: WideString read FPublicId write FPublicId;
    property SystemId: WideString read FSystemId write FSystemId;
{$ENDIF NEXTGEN}
  end;

  TXmlExternalPEReferenceSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FParameterEntityName: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FParameterEntityName: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property ParameterEntityName: string read FParameterEntityName write FParameterEntityName;
{$ELSE !NEXTGEN}
    property ParameterEntityName: WideString read FParameterEntityName write FParameterEntityName;
{$ENDIF NEXTGEN}
  end;

  TXmlNotationDeclarationSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FNotationName: string;
    FPublicId: string;
    FSystemId: string;
    FIsDeclaredInPE: Boolean;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
{$ELSE !NEXTGEN}
    FNotationName: WideString;
    FPublicId: WideString;
    FSystemId: WideString;
    FIsDeclaredInPE: Boolean;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
{$ENDIF NEXTGEN}
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property IsDeclaredInPE: Boolean read FIsDeclaredInPE write FIsDeclaredInPE;
{$IFDEF NEXTGEN}
    property NotationName: string read FNotationName write FNotationName;
    property PublicId: string read FPublicId write FPublicId;
    property SystemId: string read FSystemId write FSystemId;
{$ELSE !NEXTGEN}
    property NotationName: WideString read FNotationName write FNotationName;
    property PublicId: WideString read FPublicId write FPublicId;
    property SystemId: WideString read FSystemId write FSystemId;
{$ENDIF NEXTGEN}
  end;

  TXmlParameterEntityDeclarationSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FBaseUri: string;
    FEntityName: string;
    FEntityValue: string;
    FPublicId: string;
    FSystemId: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property BaseUri: string read FBaseUri write FBaseUri;
    property EntityName: string read FEntityName write FEntityName;
    property EntityValue: string read FEntityValue write FEntityValue;
    property PublicId: string read FPublicId write FPublicId;
    property SystemId: string read FSystemId write FSystemId;
{$ELSE !NEXTGEN}
    FBaseUri: WideString;
    FEntityName: WideString;
    FEntityValue: WideString;
    FPublicId: WideString;
    FSystemId: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property BaseUri: WideString read FBaseUri write FBaseUri;
    property EntityName: WideString read FEntityName write FEntityName;
    property EntityValue: WideString read FEntityValue write FEntityValue;
    property PublicId: WideString read FPublicId write FPublicId;
    property SystemId: WideString read FSystemId write FSystemId;
{$ENDIF NEXTGEN}
  end;

  TXmlPEReferenceFoundSignal = class(TXmlSignal)
  public
    function Scope: TXmlSignalScope; override;
  end;

  TXmlStartExtDtdSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FEncodingName: string;
    FInputEncoding: string;
    FPublicId: string;
    FSystemId: string;
    FVersion: string;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: string); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property EncodingName: string read FEncodingName write FEncodingName;
    property InputEncoding: string read FInputEncoding write FInputEncoding;
    property PublicId: string read FPublicId write FPublicId;
    property SystemId: string read FSystemId write FSystemId;
    property Version: string read FVersion write FVersion;
{$ELSE !NEXTGEN}
    FEncodingName: WideString;
    FInputEncoding: WideString;
    FPublicId: WideString;
    FSystemId: WideString;
    FVersion: WideString;
  public
    procedure CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                  out Flaw,
                                      Clue: WideString); override;
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

    property EncodingName: WideString read FEncodingName write FEncodingName;
    property InputEncoding: WideString read FInputEncoding write FInputEncoding;
    property PublicId: WideString read FPublicId write FPublicId;
    property SystemId: WideString read FSystemId write FSystemId;
    property Version: WideString read FVersion write FVersion;
{$ENDIF NEXTGEN}
  end;

  TXmlStartIntDtdSignal = class(TXmlSignal)
  private
{$IFDEF NEXTGEN}
    FSystemId: string;
{$ELSE !NEXTGEN}
    FSystemId: WideString;
{$ENDIF NEXTGEN}
    FXmlStandalone: TDomStandalone;
  public
    function CloneSignal(const AReader: TXmlCustomReader): TXmlSignal; override;
    function Scope: TXmlSignalScope; override;

{$IFDEF NEXTGEN}
    property SystemId: string read FSystemId write FSystemId;
{$ELSE !NEXTGEN}
    property SystemId: WideString read FSystemId write FSystemId;
{$ENDIF NEXTGEN}
    property XmlStandalone: TDomStandalone read FXmlStandalone write FXmlStandalone;
  end;

{ XML Reader Components }

  TXmlCustomReader = class(TDomBaseComponent)
  private
    FDOMImpl: TDomImplementation;
    FNextHandler: TXmlCustomHandler;
    FErrorReportingEnabled: Boolean;
  protected
    procedure Notification(AComponent: TComponent;
                           Operation: TOperation); override;
{$IFDEF NEXTGEN}
    procedure ResolveResourceAsWideString(const BaseURI: string;
                                          const PublicId,
                                                SystemId: string;
                                            out S: string;
                                            out Error: TXmlErrorType); virtual;
    procedure SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                    const Location: IDomLocator;
                                    const Code,
                                          Clue: string); virtual;
{$ELSE !NEXTGEN}
    procedure ResolveResourceAsWideString(const BaseURI: WideString;
                                          const PublicId,
                                                SystemId: WideString;
                                            out S: WideString;
                                            out Error: TXmlErrorType); virtual;
    procedure SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                    const Location: IDomLocator;
                                    const Code,
                                          Clue: WideString); virtual;
{$ENDIF NEXTGEN}
    procedure SetDomImpl(const Impl: TDomImplementation); virtual;
    procedure SetErrorReportingEnabled(const Value: Boolean); virtual;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property DOMImpl: TDomImplementation read FDomImpl write SetDomImpl;
    property ErrorReportingEnabled: Boolean read FErrorReportingEnabled write SetErrorReportingEnabled default True;
    property NextHandler: TXmlCustomHandler read FNextHandler write FNextHandler;
  end;

  TXmlStandardDocReader = class(TXmlCustomReader)
  protected
    procedure Parse2(const XmlTokenizer: TXmlDocTokenizer); virtual;
    procedure SendAbortedSignal(const Locator: IDomLocator); virtual;
{$IFDEF NEXTGEN}
    procedure WriteAttribute(const Locator: IDomLocator;
                             const Name,
                                   Value: string); virtual;
    procedure WriteCDATA(const Locator: IDomLocator;
                         const Content: string); virtual;
    procedure WriteCharRefDec(const Locator: IDomLocator;
                              const Content: string); virtual;
    procedure WriteCharRefHex(const Locator: IDomLocator;
                              const Content: string); virtual;
    procedure WriteComment(const Locator: IDomLocator;
                           const Content: string); virtual;
    procedure WritePCDATA(const Locator: IDomLocator;
                          const Content: string); virtual;
    procedure WriteProcessingInstruction(const Locator: IDomLocator;
                                         const Content: string); virtual;
    procedure WriteStartDocument(const Locator: IDomLocator;
                                 const InputEnc,
                                       Version,
                                       EncName: string;
                                       SdDl: TDomStandalone); virtual;
    procedure WriteStartDocumentFragment(const Locator: IDomLocator;
                                         const EncName: string); virtual;
    procedure WriteStartElement(const Locator: IDomLocator;
                                const TagName: string); virtual;
    procedure WriteStartTag(const Locator: IDomLocator;
                                  Content: string;
                              out TagName: string); virtual;
    procedure WriteEndTag(const Locator: IDomLocator;
                          const Content: string); virtual;
    procedure WriteEmptyElementTag(const Locator: IDomLocator;
                                   const Content: string); virtual;
    procedure WriteEntityRef(const Locator: IDomLocator;
                             const Content: string); virtual;
    procedure WriteDoctype(const Locator: IDomLocator;
                           const Content: string); virtual;
{$ELSE !NEXTGEN}
    procedure WriteAttribute(const Locator: IDomLocator;
                             const Name,
                                   Value: WideString); virtual;
    procedure WriteCDATA(const Locator: IDomLocator;
                         const Content: WideString); virtual;
    procedure WriteCharRefDec(const Locator: IDomLocator;
                              const Content: WideString); virtual;
    procedure WriteCharRefHex(const Locator: IDomLocator;
                              const Content: WideString); virtual;
    procedure WriteComment(const Locator: IDomLocator;
                           const Content: WideString); virtual;
    procedure WritePCDATA(const Locator: IDomLocator;
                          const Content: WideString); virtual;
    procedure WriteProcessingInstruction(const Locator: IDomLocator;
                                         const Content: WideString); virtual;
    procedure WriteStartDocument(const Locator: IDomLocator;
                                 const InputEnc,
                                       Version,
                                       EncName: WideString;
                                       SdDl: TDomStandalone); virtual;
    procedure WriteStartDocumentFragment(const Locator: IDomLocator;
                                         const EncName: WideString); virtual;
    procedure WriteStartElement(const Locator: IDomLocator;
                                const TagName: WideString); virtual;
    procedure WriteStartTag(const Locator: IDomLocator;
                                  Content: WideString;
                              out TagName: WideString); virtual;
    procedure WriteEndTag(const Locator: IDomLocator;
                          const Content: WideString); virtual;
    procedure WriteEmptyElementTag(const Locator: IDomLocator;
                                   const Content: WideString); virtual;
    procedure WriteEntityRef(const Locator: IDomLocator;
                             const Content: WideString); virtual;
    procedure WriteDoctype(const Locator: IDomLocator;
                           const Content: WideString); virtual;
{$ENDIF NEXTGEN}
    procedure WriteCompleted(const Locator: IDomLocator); virtual;
  public
    function  Parse(const InputSource: TXmlInputSource): Boolean; virtual;
    function  ParseFragment(const InputSource: TXmlSimpleInputSource): Boolean; virtual;
  end;

  TXmlStandardDtdReader = class(TXmlCustomReader)
  private
    FAttrListDeclNames: TUtilsWideStringList; // List to record the element types of
                                              // attribute-list declarations to detect
                                              // duplicates.
    FPERepository: TDomPERepository; // Collection of parameter entities.
    FXmlErrorDetected: Boolean;
    FXmlFatalErrorDetected: Boolean;
    procedure Parseloop(const Tokenizer: TXmlCustomSubsetTokenizer);
  protected
    function GetXmlErrorDetected: Boolean; virtual;
    function GetXmlFatalErrorDetected: Boolean; virtual;
    procedure PEReferenceEventHandler(      Sender: TObject;
                                      const Locator: IDomLocator); virtual;
{$IFDEF NEXTGEN}
    procedure PEProcessingAttListDeclEventHandler(      Sender: TObject;
                                                  const ElementName: string;
                                                  const Locator: IDomLocator); virtual;
    procedure SendAbortedSignal(const Locator: IDomLocator); virtual;
    procedure SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                    const Location: IDomLocator;
                                    const Code,
                                          Clue: string); override;
    procedure WriteCompleted(const Locator: IDomLocator); virtual;
    procedure WriteStartExtDtd(const Locator: IDomLocator;
                               const InputEnc,
                                     PubId,
                                     SysId,
                                     Version,
                                     EncName: string); virtual;
    procedure WriteStartIntDtd(const Locator: IDomLocator;
                               const SysId: string;
                               const Standalone: TDomStandalone); virtual;
{$ELSE !NEXTGEN}
    procedure PEProcessingAttListDeclEventHandler(      Sender: TObject;
                                                  const ElementName: WideString;
                                                  const Locator: IDomLocator); virtual;
    procedure SendAbortedSignal(const Locator: IDomLocator); virtual;
    procedure SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                    const Location: IDomLocator;
                                    const Code,
                                          Clue: WideString); override;
    procedure WriteCompleted(const Locator: IDomLocator); virtual;
    procedure WriteStartExtDtd(const Locator: IDomLocator;
                               const InputEnc,
                                     PubId,
                                     SysId,
                                     Version,
                                     EncName: WideString); virtual;
    procedure WriteStartIntDtd(const Locator: IDomLocator;
                               const SysId: WideString;
                               const Standalone: TDomStandalone); virtual;
{$ENDIF NEXTGEN}
    procedure WriteSignal(const Signal: TXmlSignal); virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function  ParseExtSubset(const InputSource: TXmlInputSource): Boolean; virtual;
    function  ParseIntSubset(const InputSource: TXmlSimpleInputSource;
                             const Standalone: TDomStandalone;
                             const ResolveExtPEs: Boolean): Boolean; virtual;
    procedure Prepare; virtual;

    property XmlErrorDetected: Boolean read GetXmlErrorDetected;
    property XmlFatalErrorDetected: Boolean read GetXmlFatalErrorDetected;
  end;

  TXmlStandardDomReader = class(TXmlCustomReader)
  private
    FContextNode: TDomNode;
    FIgnoreUnspecified: Boolean;
  protected
    function GetContextNode: TDomNode; virtual;
{$IFDEF NEXTGEN}
    function GetSystemId: string; virtual;
{$ELSE !NEXTGEN}
    function GetSystemId: WideString; virtual;
{$ENDIF NEXTGEN}
    procedure Parseloop(const SourceNode: TDomNode); virtual;
    procedure SendAbortedSignal; virtual;
{$IFDEF NEXTGEN}
    procedure WriteAttribute(const ADataType: TXmlDataType;
                             const ANodeName,
                                   ANodeValue: string); virtual;
    procedure WriteCDATA(const Content: string); virtual;
    procedure WriteComment(const Content: string); virtual;
    procedure WriteDoctype(const DoctypeName,
                                 PublicId,
                                 SystemId,
                                 IntSubset: string); virtual;
    procedure WriteEndElement(const TagName: string); virtual;
    procedure WriteEndPrefixMapping(const Prefix: string); virtual;
    procedure WriteEntityRef(const EntityName: string); virtual;
    procedure WriteCompleted; virtual;
    procedure WritePCDATA(const Content: string;
                          const CharRefGenerated: Boolean); virtual;
    procedure WriteProcessingInstruction(const Targ,
                                               AttribSequence : string); virtual;
    procedure WriteStartDocument(const InputEnc,
                                       Version,
                                       EncName: string;
                                       SdDl: TDomStandalone); virtual;
    procedure WriteStartDocumentFragment(const EncName: string); virtual;
    procedure WriteStartElement(const TagName: string); virtual;
    procedure WriteStartPrefixMapping(const Prefix,
                                            Uri: string); virtual;
{$ELSE !NEXTGEN}
    procedure WriteAttribute(const ADataType: TXmlDataType;
                             const ANodeName,
                                   ANodeValue: WideString); virtual;
    procedure WriteCDATA(const Content: WideString); virtual;
    procedure WriteComment(const Content: WideString); virtual;
    procedure WriteDoctype(const DoctypeName,
                                 PublicId,
                                 SystemId,
                                 IntSubset: WideString); virtual;
    procedure WriteEndElement(const TagName: WideString); virtual;
    procedure WriteEndPrefixMapping(const Prefix: WideString); virtual;
    procedure WriteEntityRef(const EntityName: WideString); virtual;
    procedure WriteCompleted; virtual;
    procedure WritePCDATA(const Content: WideString;
                          const CharRefGenerated: Boolean); virtual;
    procedure WriteProcessingInstruction(const Targ,
                                               AttribSequence : WideString); virtual;
    procedure WriteStartDocument(const InputEnc,
                                       Version,
                                       EncName: WideString;
                                       SdDl: TDomStandalone); virtual;
    procedure WriteStartDocumentFragment(const EncName: WideString); virtual;
    procedure WriteStartElement(const TagName: WideString); virtual;
    procedure WriteStartPrefixMapping(const Prefix,
                                            Uri: WideString); virtual;
{$ENDIF NEXTGEN}
  public
    constructor Create(AOwner: TComponent); override;
    function Parse(const SourceNode: TDomNode): Boolean; virtual;
    property ContextNode: TDomNode read GetContextNode;
  published
    property IgnoreUnspecified: Boolean read FIgnoreUnspecified write FIgnoreUnspecified;
  end;

{ XML Content Handler Components }

  TXmlCustomHandler = class(TDomBaseComponent)
  protected
{$IFDEF NEXTGEN}
    procedure SendErrorNotification(const Target: TXmlCustomReader;
                                    const XmlErrorType: TXmlErrorType;
                                    const Location: IDomLocator;
                                    const Code,
                                          Clue: string); virtual;
{$ELSE !NEXTGEN}
    procedure SendErrorNotification(const Target: TXmlCustomReader;
                                    const XmlErrorType: TXmlErrorType;
                                    const Location: IDomLocator;
                                    const Code,
                                          Clue: WideString); virtual;
{$ENDIF NEXTGEN}
  public
    procedure ProcessSignal(const Signal: TXmlSignal); virtual; abstract;
  end;

  TXmlStandardHandler = class(TXmlCustomHandler)
  protected
    FNextHandler: TXmlCustomHandler;
    FOnSignal: TXmlProcessingEvent;
    FOnSignaled: TXmlPostProcessingEvent;
    procedure Notification(AComponent: TComponent;
                           Operation: TOperation); override;
  public
    procedure ProcessSignal(const Signal: TXmlSignal); override;
  published
    property NextHandler: TXmlCustomHandler read FNextHandler write FNextHandler;

    property OnSignal: TXmlProcessingEvent read FOnSignal write FOnSignal;
    property OnSignaled: TXmlPostProcessingEvent read FOnSignaled write FOnSignaled;
  end;

  TXmlDistributor = class;

  TXmlHandlerItem = class(TCollectionItem)
  protected
    FXmlHandler: TXmlCustomHandler;
    function GetXmlHandler: TXmlCustomHandler;
    procedure SetXmlHandler(Value: TXmlCustomHandler);
  public
    procedure Assign(Source: TPersistent); override;
  published
    property XmlHandler: TXmlCustomHandler read GetXmlHandler write SetXmlHandler;
  end;

  TXmlHandlers = class(TCollection)
  private
    FDistributor: TXmlDistributor;
  protected
    function GetItem(Index: Integer): TXmlHandlerItem; virtual;
    procedure SetItem(Index: Integer; Value: TXmlHandlerItem); virtual;
    function GetOwner: TPersistent; override;
  public
    constructor Create(Distributor: TXmlDistributor);
    function Add: TXmlHandlerItem;
    procedure Assign(Source: TPersistent); override;
    function FindHandlerItem(AHandler: TXmlCustomHandler): TXmlHandlerItem;
    property Distributor: TXmlDistributor read FDistributor;
    property Items[Index: Integer]: TXmlHandlerItem read GetItem write SetItem; default;
  end;

  TXmlDistributor = class(TXmlCustomHandler)
  private
    FDisableCount: Integer;
    procedure ReadData(Reader: TReader);
    procedure WriteData(Writer: TWriter);
  protected
    FNextHandlers: TXmlHandlers;
    procedure DefineProperties(Filer: TFiler); override;
    procedure Notification(AComponent: TComponent;
                           Operation: TOperation); override;
    procedure SetNextHandlers(const Value: TXmlHandlers);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure ProcessSignal(const Signal: TXmlSignal); override;
  published
    property NextHandlers: TXmlHandlers read FNextHandlers write SetNextHandlers;
  end;

  TXmlActivityStatus = ( asInactive, asDocActive, asDocFragActive, asExtDtdActive, asIntDtdActive );

  TXmlRootProcessingStatus = (rsBeforeRoot, rsInRoot, rsAfterRoot);

  TXmlWFTestHandler = class(TXmlCustomHandler)
  protected
    FActivityStatus: TXmlActivityStatus;
    FDoctypeFound: Boolean;
    FNextHandler: TXmlCustomHandler;
    FPrefixStack: TUtilsWideStringList;
    FRootProcessingStatus: TXmlRootProcessingStatus;
    FTagStack: TUtilsWideStringList;
    procedure Notification(AComponent: TComponent;
                           Operation: TOperation); override;
    procedure Reset; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure ProcessSignal(const Signal: TXmlSignal); override;

    property ActivityStatus: TXmlActivityStatus read FActivityStatus;
  published
    property NextHandler: TXmlCustomHandler read FNextHandler write FNextHandler;
  end;

  TXmlNamespaceSignalGenerator = class(TXmlCustomHandler)
  protected
    FAttributeSignals: TList<TXmlSignal>;
{$IFDEF NEXTGEN}
    FElementName: string;
{$ELSE !NEXTGEN}
    FElementName: WideString;
{$ENDIF NEXTGEN}
    FNextHandler: TXmlCustomHandler;
    FPrefixMapping: Boolean;
    FPrefixMappingStack: TList<TUtilsWideStringList>;
    FStartElementIsOpen: Boolean;
    FSuppressXmlns: Boolean;
    procedure ClearPrefixMappingStack; virtual;
    procedure CloseStartElement(const Sender: TXmlCustomReader;
                                const Locator: IDomLocator);
    procedure ProcessAttributeSignal(const Signal: TXmlAttributeSignal); virtual;
    procedure ProcessStartElementSignal(const Signal: TXmlStartElementSignal); virtual;
    procedure WriteEndPrefixMapping(const Sender: TXmlCustomReader;
                                    const Locator: IDomLocator); virtual;
{$IFDEF NEXTGEN}
    procedure WriteStartPrefixMapping(const Sender: TXmlCustomReader;
                                      const Locator: IDomLocator;
                                      const Prefix,
                                            Uri: string); virtual;
{$ELSE !NEXTGEN}
    procedure WriteStartPrefixMapping(const Sender: TXmlCustomReader;
                                      const Locator: IDomLocator;
                                      const Prefix,
                                            Uri: WideString); virtual;
{$ENDIF NEXTGEN}
    procedure Reset; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure ProcessSignal(const Signal: TXmlSignal); override;
  published
    property NextHandler: TXmlCustomHandler read FNextHandler write FNextHandler;
    property PrefixMapping: Boolean read FPrefixMapping write FPrefixMapping default True;
    property SuppressXmlns: Boolean read FSuppressXmlns write FSuppressXmlns default False;
  end;

  TXmlDomBuilder = class(TXmlCustomHandler)
  private
    FBuildIDList: Boolean;
    FDocTypeDeclTreatment: TDomDocTypeDeclTreatment;
    FErrorReportingEnabled: Boolean;
    FKeepCDATASections: Boolean;
    FKeepComments: Boolean;
    FKeepEntityRefs: Boolean;
  protected
    FRefNode: TDomNode;
{$IFDEF NEXTGEN}
    FPrefixUriList: TDictionary<Integer, TPair<string, string>>;
    function GetUriListLastValue(Name: string): string;
    procedure ProcessPCDATA(const Sender: TXmlCustomReader;
                            const Locator: IDomLocator;
                            const Data: string;
                            const CharRefGenerated: Boolean); virtual;
{$ELSE !NEXTGEN}
    FPrefixUriList: TDictionary<Integer, TPair<WideString, WideString>>;
    function GetUriListLastValue(Name: WideString): WideString;
    procedure ProcessPCDATA(const Sender: TXmlCustomReader;
                            const Locator: IDomLocator;
                            const Data: WideString;
                            const CharRefGenerated: Boolean); virtual;
{$ENDIF NEXTGEN}
    procedure Reset; virtual;
    procedure SetErrorReportingEnabled(const Value: Boolean); virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure ProcessSignal(const Signal: TXmlSignal); override;

    property ReferenceNode: TDomNode read FRefNode write FRefNode;
  published
    property BuildIDList: Boolean read FBuildIDList write FBuildIDList default True;
    property DocTypeDeclTreatment: TDomDocTypeDeclTreatment read FDocTypeDeclTreatment write FDocTypeDeclTreatment default dtCheckWellformedness;
    property ErrorReportingEnabled: Boolean read FErrorReportingEnabled write SetErrorReportingEnabled default True;
    property KeepCDATASections: Boolean read FKeepCDATASections write FKeepCDATASections default True;
    property KeepComments: Boolean read FKeepComments write FKeepComments default True;
    property KeepEntityRefs: Boolean read FKeepEntityRefs write FKeepEntityRefs default True;
  end;

  TXmlDtdModelBuilder = class(TXmlCustomHandler)
  private
    FDtdModel: TDtdModel;
  protected
    FActivityStatus: TXmlActivityStatus;
    FDocStandalone: TDomStandalone;
    FIgnoreDeclarations: Boolean;
{$IFDEF NEXTGEN}
    procedure InsertMixedContent(const RefASElementDecl: TDtdElementDecl;
                                 const ContSpec: string); virtual;
    procedure InsertChildrenContent(const RefDtdObject: TDtdObject;
                                    const ContSpec: string); virtual;
{$ELSE !NEXTGEN}
    procedure InsertMixedContent(const RefASElementDecl: TDtdElementDecl;
                                 const ContSpec: WideString); virtual;
    procedure InsertChildrenContent(const RefDtdObject: TDtdObject;
                                    const ContSpec: WideString); virtual;
{$ENDIF NEXTGEN}
    procedure SetDtdModel(const Value: TDtdModel); virtual;
    procedure Reset; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    procedure ProcessSignal(const Signal: TXmlSignal); override;

    property ActivityStatus: TXmlActivityStatus read FActivityStatus;
    property DtdModel: TDtdModel read FDtdModel write SetDtdModel;
  end;

  TXmlBOMOpt = set of ( bomUTF8, bomUTF16, bomUCS2 );

  TXmlStreamBuilder = class(TXmlCustomHandler)
  private
    FAttListDeclIsOpen: Boolean;  // Remark: If this variable is to be "published" the CheckAttListDeclarationOpen method must be modified accordingly!
    FStartElementIsOpen: Boolean;
    FByteCount: Integer;
    FCharacterCount: Integer;
    FColumnCount: Integer;
{$IFDEF NEXTGEN}
    FCurrentAttListDeclName: string;
{$ELSE !NEXTGEN}
    FCurrentAttListDeclName: WideString;
{$ENDIF NEXTGEN}
    FDefaultEncoding: string;
    FIncludeXmlDecl: Boolean;
    FLineFeedCount: Integer;
    FTabCount: Integer;
    FUseByteOrderMark: TXmlBOMOpt;
    FOutputSource: TXmlOutputSource;
    FOnAfterWrite: TDomSerializationEvent;
    FOnBeforeWrite: TDomSerializationEvent;
    procedure CheckAttListDeclarationClosed(const Sender: TXmlCustomReader;
                                            const Locator: IDomLocator);
{$IFDEF NEXTGEN}
    procedure CheckAttListDeclarationOpen(const Sender: TXmlCustomReader;
                                          const Locator: IDomLocator;
                                          const ElementName: string);
{$ELSE !NEXTGEN}
    procedure CheckAttListDeclarationOpen(const Sender: TXmlCustomReader;
                                          const Locator: IDomLocator;
                                          const ElementName: WideString);
{$ENDIF NEXTGEN}
    procedure CheckStartElementClosed(const Sender: TXmlCustomReader;
                                      const Locator: IDomLocator;
                                      ElementIsEmpty: Boolean);
    function GetCurrentEncoding: string;
    procedure ResetCurrentEncoding;
    procedure SetDefaultEncoding(const Value: string);
    procedure SetOutputSource(const Value: TXmlOutputSource);
{$IFDEF NEXTGEN}
    function TrySetCurrentEncoding(const Value: string): Boolean;
    procedure WriteWideString(const S: string;
                              const UseCharRefs: Boolean);
{$ELSE !NEXTGEN}
    function TrySetCurrentEncoding(const Value: WideString): Boolean;
    procedure WriteWideString(const S: WideString;
                              const UseCharRefs: Boolean);
{$ENDIF NEXTGEN}

    procedure WriteAttributeDefinitionSignal(const Signal: TXmlAttributeDefinitionSignal);
    procedure WriteAttributeSignal(const Signal: TXmlAttributeSignal);
    procedure WriteCDATASignal(const Signal: TXmlCDataSignal);
    procedure WriteCommentSignal(const Signal: TXmlCommentSignal);
    procedure WriteDoctypeSignal(const Signal: TXmlDoctypeSignal);
    procedure WriteElementTypeDeclarationSignal(const Signal: TXmlElementTypeDeclarationSignal);
    procedure WriteEndElementSignal(const Signal: TXmlEndElementSignal);
    procedure WriteEntityDeclarationSignal(const Signal: TXmlEntityDeclarationSignal);
    procedure WriteEntityRefSignal(const Signal: TXmlEntityRefSignal);
    procedure WriteCompletedSignal(const Signal: TXmlCompletedSignal);
    procedure WriteNotationDeclarationSignal(const Signal: TXmlNotationDeclarationSignal);
    procedure WriteParameterEntityDeclarationSignal(const Signal: TXmlParameterEntityDeclarationSignal);
    procedure WritePCDATASignal(const Signal: TXmlPCDATASignal);
    procedure WriteProcessingInstructionSignal(const Signal: TXmlProcessingInstructionSignal);
    procedure WriteSkippedEntitySignal(const Signal: TXmlSkippedEntitySignal);
    procedure WriteStartDocumentSignal(const Signal: TXmlStartDocumentSignal);
    procedure WriteStartDocumentFragmentSignal(const Signal: TXmlStartDocumentFragmentSignal);
    procedure WriteStartElementSignal(const Signal: TXmlStartElementSignal);
    procedure WriteStartExtDtdSignal(const Signal: TXmlStartExtDtdSignal);
    procedure WriteStartIntDtdSignal(const Signal: TXmlStartIntDtdSignal);
  protected
    FOpenElementsCount: Integer;
    procedure DoAfterWrite(const PieceType: TDomPieceType;
                           const Locator: IDomLocator);
    procedure DoBeforeWrite(const PieceType: TDomPieceType;
                            const Locator: IDomLocator);
    procedure Reset; virtual;
    procedure SetIncludeXmlDecl(const Value: Boolean); virtual;
    procedure SetUseByteOrderMark(const Value: TXmlBOMOpt); virtual;
    procedure WriteByteOrderMark(const Sender: TXmlCustomReader;
                                 const Locator: IDomLocator;
                                   out ByteCount: Integer); virtual;
{$IFDEF NEXTGEN}
    procedure WriteWideStrings(const Sender: TXmlCustomReader;
                               const Locator: IDomLocator;
                               const XmlStrgs: array of string;
                               const UseCharRefs: Boolean); virtual;
{$ELSE !NEXTGEN}
    procedure WriteWideStrings(const Sender: TXmlCustomReader;
                               const Locator: IDomLocator;
                               const XmlStrgs: array of WideString;
                               const UseCharRefs: Boolean); virtual;
{$ENDIF NEXTGEN}

  public
    constructor Create(AOwner: TComponent); override;
    procedure ProcessSignal(const Signal: TXmlSignal); override;

    property ByteCount: Integer read FByteCount;                                                                     
    property CharacterCount: Integer read FCharacterCount;                                                                
    property ColumnCount: Integer read FColumnCount;                                                                   
    property CurrentEncoding: string read GetCurrentEncoding;
    property DefaultEncoding: string read FDefaultEncoding write SetDefaultEncoding;
    property LineFeedCount: Integer read FLineFeedCount;                                                                 
    property OutputSource: TXmlOutputSource read FOutputSource write SetOutputSource;
    property TabCount: Integer read FTabCount;
  published
    property UseByteOrderMark: TXmlBOMOpt read FUseByteOrderMark write SetUseByteOrderMark default [bomUTF16, bomUCS2];
    property IncludeXmlDecl: Boolean read FIncludeXmlDecl write SetIncludeXmlDecl default True;

    property OnAfterWrite: TDomSerializationEvent read FOnAfterWrite write FOnAfterWrite;
    property OnBeforeWrite: TDomSerializationEvent read FOnBeforeWrite write FOnBeforeWrite;
  end;

  TXmlCustomParser = class(TDomBaseComponent)
  private
    FDOMImpl: TDomImplementation;
    FErrorReportingEnabled: Boolean;
  protected
    procedure SetDomImpl(const Impl: TDomImplementation); virtual;
    procedure SetErrorReportingEnabled(const Value: Boolean); virtual;
    procedure Notification(AComponent: TComponent;
                           Operation: TOperation); override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property DOMImpl: TDomImplementation read FDOMImpl write SetDomImpl;
    property ErrorReportingEnabled: Boolean read FErrorReportingEnabled write SetErrorReportingEnabled default True;
  end;

  TXmlParserAction = ( ACTION_APPEND_AS_CHILDREN,
                       ACTION_INSERT_AFTER,
                       ACTION_INSERT_BEFORE,
                       ACTION_REPLACE,
                       ACTION_REPLACE_CHILDREN );

  TXmlToDomParser = class(TXmlCustomParser)
  private
    function GetKeepCDATASections: Boolean;
    function GetKeepComments: Boolean;
    function GetKeepEntityRefs: Boolean;
    procedure SetKeepCDATASections(const Value: Boolean);
    procedure SetKeepComments(const Value: Boolean);
    procedure SetKeepEntityRefs(const Value: Boolean);
  protected
    FBufferSize: Integer;
    FDocBuilder: TXmlDomBuilder;
    FDocReader:  TXmlStandardDocReader;
    FWFTestHandler: TXmlWFTestHandler;
    procedure CreateSubcomponents; virtual;
    procedure ParseFragment(const InputSource:TXmlSimpleInputSource;
                            const DocFrag: TDomDocumentFragment); virtual;
    function SendErrorNotification(const XmlErrorType: TXmlErrorType): Boolean; virtual;
    procedure SetBufferSize(const Value: Integer); virtual;
    procedure SetDomImpl(const Impl: TDomImplementation); override;
    procedure SetErrorReportingEnabled(const Value: Boolean); override;
  public
    constructor Create(AOwner: TComponent); override;
    function Parse(const InputSource: TXmlInputSource): TDomDocument; virtual;
    function ParseFile(const Filename: TFileName;
                       const InclDecl: Boolean): TDomDocument; virtual;
{$IFDEF NEXTGEN}
    function ParseResource(const BaseUri: string;
                                 PublicId,
                                 SystemId: string;
                           const Encoding: string;
                           const InclDecl: Boolean): TDomDocument; virtual;
{$ELSE !NEXTGEN}
    function ParseResource(const BaseUri: WideString;
                                 PublicId,
                                 SystemId: WideString;
                           const Encoding: WideString;
                           const InclDecl: Boolean): TDomDocument; virtual;
{$ENDIF NEXTGEN}
    function ParseWithContext(const InputSource: TXmlInputSource;
                              const ContextNode: TDomNode;
                              const Action: TXmlParserAction): TDomNode; virtual;
  published
    property BufferSize: Integer read FBufferSize write SetBufferSize default 4096;
    property KeepCDATASections: Boolean read GetKeepCDATASections write SetKeepCDATASections default True;
    property KeepComments: Boolean read GetKeepComments write SetKeepComments default True;
                                                                                                                         
    property KeepEntityRefs: Boolean read GetKeepEntityRefs write SetKeepEntityRefs default True;
  end;

  TDtdToDtdModelParser = class(TXmlCustomParser)
  private
    FBufferSize: Integer;
    function GetXmlErrorDetected: Boolean;
    function GetXmlFatalErrorDetected: Boolean;
  protected
    FDtdModelBuilder: TXmlDtdModelBuilder;
    FDtdReader: TXmlStandardDtdReader;
    FWFTestHandler: TXmlWFTestHandler;
    procedure CreateSubcomponents; virtual;
    function GetTargetDtdModel: TDtdModel; virtual;
    function SendErrorNotification(const XmlErrorType: TXmlErrorType): Boolean; virtual;
    procedure SetBufferSize(const Value: Integer); virtual;
    procedure SetDomImpl(const ADOMImpl: TDomImplementation); override;
    procedure SetErrorReportingEnabled(const Value: Boolean); override;
    procedure SetTargetDtdModel(const Value: TDtdModel); virtual;
  public
    constructor Create(AOwner: TComponent); override;
    procedure ParseDocTypeDecl(const DocTypeDecl: TDomDocumentTypeDecl;
                               const ResolveExtEntities,
                                     InclDecl: Boolean); virtual;
    procedure ParseExtSubset(const InputSource: TXmlInputSource); virtual;
    procedure ParseIntSubset(const InputSource: TXmlSimpleInputSource;
                             const Standalone: TDomStandalone;
                             const ResolveExtPEs: Boolean); virtual;
    procedure Prepare; virtual;

    property TargetDtdModel: TDtdModel read GetTargetDtdModel write SetTargetDtdModel;
    property XmlErrorDetected: Boolean read GetXmlErrorDetected;
    property XmlFatalErrorDetected: Boolean read GetXmlFatalErrorDetected;
  published
    property BufferSize: Integer read FBufferSize write SetBufferSize default 4096;
  end;

  TDomToXmlParser = class(TXmlCustomParser)
  private
    FDomReader: TXmlStandardDomReader;
    FBufferSize: Integer;
    FStreamBuilder: TXmlStreamBuilder;
{$IFDEF SystemEncodingName_DECLARED}
    FUseActiveCodePage: Boolean;
{$ENDIF}
    FWFTestHandler: TXmlWFTestHandler;
    FWriteLFOption: TCodecWriteLFOption;
    function GetOnAfterWrite: TDomSerializationEvent;
    function GetOnBeforeWrite: TDomSerializationEvent;
    function GetStrictErrorChecking: Boolean;
    function GetUseByteOrderMark: TXmlBOMOpt;
    procedure SetOnAfterWrite(const Value: TDomSerializationEvent);
    procedure SetOnBeforeWrite(const Value: TDomSerializationEvent);
    procedure SetStrictErrorChecking(const Value: Boolean);
    procedure SetUseByteOrderMark(const Value: TXmlBOMOpt);
  protected
    function GetIgnoreUnspecified: Boolean; virtual;
    function GetIncludeXmlDecl: Boolean; virtual;
    procedure SetBufferSize(const Value: Integer); virtual;
    procedure SetDomImpl(const Impl: TDomImplementation); override;
    procedure SetErrorReportingEnabled(const Value: Boolean); override;
    procedure SetIgnoreUnspecified(const Value: Boolean); virtual;
    procedure SetIncludeXmlDecl(const Value: Boolean); virtual;
{$IFDEF SystemEncodingName_DECLARED}
    procedure SetUseActiveCodePage(const Value: Boolean); virtual; {$IFDEF VER140+} platform; {$ENDIF}
{$ENDIF}
    procedure SetWriteLFOption(const Value: TCodecWriteLFOption); virtual;

    property DomReader: TXmlStandardDomReader read FDomReader;
    property StreamBuilder: TXmlStreamBuilder read FStreamBuilder;
    property WFTestHandler: TXmlWFTestHandler read FWFTestHandler;
  public
    constructor Create(AOwner: TComponent); override;
    function WriteToStream(const WNode: TDomNode;
                           const Encoding: string;
                           const Destination: TStream): Boolean; virtual;
    function WriteToString(const WNode: TDomNode;
                                 Encoding: string;
                             out S: string): Boolean; virtual;
{$IFDEF NEXTGEN}
    function WriteToWideString(const WNode: TDomNode;
                                 out S: string): Boolean; virtual;
{$ELSE !NEXTGEN}
    function WriteToWideString(const WNode: TDomNode;
                                 out S: WideString): Boolean; virtual;
{$ENDIF NEXTGEN}
  published
    property BufferSize: Integer read FBufferSize write SetBufferSize default 4096;
    property IgnoreUnspecified: Boolean read GetIgnoreUnspecified write SetIgnoreUnspecified;
    property IncludeXmlDecl: Boolean read GetIncludeXmlDecl write SetIncludeXmlDecl default True;
    property StrictErrorChecking: Boolean read GetStrictErrorChecking write SetStrictErrorChecking default False;
{$IFDEF SystemEncodingName_DECLARED}
    property UseActiveCodePage: Boolean read FUseActiveCodePage write SetUseActiveCodePage default False;
{$ENDIF}
    property UseByteOrderMark: TXmlBOMOpt read GetUseByteOrderMark write SetUseByteOrderMark default [bomUTF16, bomUCS2];
    property WriteLFOption: TCodecWriteLFOption read FWriteLFOption write SetWriteLFOption default lwCRLF;

    property OnAfterWrite: TDomSerializationEvent read GetOnAfterWrite write SetOnAfterWrite;
    property OnBeforeWrite: TDomSerializationEvent read GetOnBeforeWrite write SetOnBeforeWrite;
  end;


{XPath implementation}

  TDomXPathExpr  = class;

  TDomXPathTokenType = ( XPATH_LEFT_PARENTHESIS_TOKEN,
                         XPATH_RIGHT_PARENTHESIS_TOKEN,
                         XPATH_LEFT_SQUARE_BRACKET_TOKEN,
                         XPATH_RIGHT_SQUARE_BRACKET_TOKEN,
                         XPATH_SINGLE_DOT_TOKEN,
                         XPATH_DOUBLE_DOT_TOKEN,
                         XPATH_COMMERCIAL_AT_TOKEN,
                         XPATH_COMMA_TOKEN,
                         XPATH_DOUBLE_COLON_TOKEN,
                         XPATH_NAME_TEST_TOKEN,
                         XPATH_NODE_TYPE_COMMENT_TOKEN,
                         XPATH_NODE_TYPE_TEXT_TOKEN,
                         XPATH_NODE_TYPE_PI_TOKEN,
                         XPATH_NODE_TYPE_NODE_TOKEN,
                         XPATH_AND_OPERATOR_TOKEN,
                         XPATH_OR_OPERATOR_TOKEN,
                         XPATH_MOD_OPERATOR_TOKEN,
                         XPATH_DIV_OPERATOR_TOKEN,
                         XPATH_MULTIPLY_OPERATOR_TOKEN,
                         XPATH_SLASH_OPERATOR_TOKEN,
                         XPATH_SHEFFER_STROKE_OPERATOR_TOKEN,
                         XPATH_PLUS_OPERATOR_TOKEN,
                         XPATH_MINUS_OPERATOR_TOKEN,
                         XPATH_IS_EQUAL_OPERATOR_TOKEN,
                         XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN,
                         XPATH_LESS_THAN_OPERATOR_TOKEN,
                         XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN,
                         XPATH_GREATER_THAN_OPERATOR_TOKEN,
                         XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN,
                         XPATH_FUNCTION_NAME_TOKEN,
                         XPATH_AXIS_NAME_ANCESTOR_TOKEN,
                         XPATH_AXIS_NAME_ANCESTOR_OR_SELF_TOKEN,
                         XPATH_AXIS_NAME_ATTRIBUTE_TOKEN,
                         XPATH_AXIS_NAME_CHILD_TOKEN,
                         XPATH_AXIS_NAME_DESCENDANT_TOKEN,
                         XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN,
                         XPATH_AXIS_NAME_FOLLOWING_TOKEN,
                         XPATH_AXIS_NAME_FOLLOWING_SIBLING_TOKEN,
                         XPATH_AXIS_NAME_NAMESPACE_TOKEN,
                         XPATH_AXIS_NAME_PARENT_TOKEN,
                         XPATH_AXIS_NAME_PRECEDING_TOKEN,
                         XPATH_AXIS_NAME_PRECEDING_SIBLING_TOKEN,
                         XPATH_AXIS_NAME_SELF_TOKEN,
                         XPATH_LITERAL_TOKEN,
                         XPATH_NUMBER_TOKEN,
                         XPATH_VARIABLE_REFERENCE_TOKEN,
                         XPATH_END_OF_TEXT_TOKEN,
                         XPATH_INVALID_TOKEN
                       );

  TDomXPathAxisType = ( XPATH_FORWARD_AXIS, XPATH_REVERSE_AXIS );

  TDomXPathFunction = function(const ContextNode: TDomNode;
                               const ContextPosition: Integer;
                               const ContextSize: Integer;
                               const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

  TDomXPathSlashStatus = ( SL_NO_DOUBLE_SLASH,
                           SL_XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN_FOLLOWS,
                           SL_XPATH_DOUBLE_COLON_TOKEN_FOLLOWS,
                           SL_XPATH_NODE_TYPE_NODE_TOKEN_FOLLOWS,
                           SL_XPATH_LEFT_PARENTHESIS_FOLLOWS,
                           SL_XPATH_RIGHT_PARENTHESIS_FOLLOWS,
                           SL_XPATH_SLASH_OPERATOR_TOKEN_FOLLLOWS );

  TDomXPathTokenizer = class
  protected
    FCacheIsActive: Boolean;
    FDoubleSlashStatus: TDomXPathSlashStatus;
{$IFDEF NEXTGEN}
    FExpression: string;
{$ELSE !NEXTGEN}
    FExpression: WideString;
{$ENDIF NEXTGEN}
    FLastSymbol: TDomXPathTokenType;
    FPosition: Integer;
    FPositionCache: Integer;
    FSymbolCache: TDomXPathTokenType;
{$IFDEF NEXTGEN}
    FValueCache: string;
{$ELSE !NEXTGEN}
    FValueCache: WideString;
{$ENDIF NEXTGEN}
    function DoubleColonFollows: Boolean; virtual;
    function GetNextWideChar(out S: WideChar): Boolean; virtual;
    function LeftParanthesisFollows: Boolean; virtual;
    function LookAheadNextWideChar(out S: WideChar): Boolean; virtual;
  public
{$IFDEF NEXTGEN}
    constructor Create(const Expression: string;
                       const XPathVersion: string); virtual;
    function IsFollowing(const Symbol: TDomXPathTokenType): Boolean; virtual;
    procedure Read(out Symbol: TDomXPathTokenType;
                   out Value: string;
                   out Position: Integer); virtual;
{$ELSE !NEXTGEN}
    constructor Create(const Expression: WideString;
                       const XPathVersion: WideString); virtual;
    function IsFollowing(const Symbol: TDomXPathTokenType): Boolean; virtual;
    procedure Read(out Symbol: TDomXPathTokenType;
                   out Value: WideString;
                   out Position: Integer); virtual;
{$ENDIF NEXTGEN}
    procedure Reset; virtual;
  end;

  TDomXPathCustomResult = class(TCustomOwnedNode)
  protected
    function GetAxisType: TDomXPathAxisType; virtual;
    procedure SetAxisType(const Value: TDomXPathAxisType); virtual;
  public
    constructor Create;
    function AsBoolean: Boolean; virtual; abstract;
    function AsNumber: Double; virtual; abstract;
{$IFDEF NEXTGEN}
    function AsWideString: string; virtual; abstract;
{$ELSE !NEXTGEN}
    function AsWideString: WideString; virtual; abstract;
{$ENDIF NEXTGEN}
    function Item(const Index: Integer): TDomNode; virtual;
    function Length: Integer; virtual;
    function ResultType: TDomXPathResultType; virtual; abstract;

    property AxisType: TDomXPathAxisType read GetAxisType write SetAxisType;
  end;

  TDomXPathNodeSetResult = class(TDomXPathCustomResult)
  private
{$IFDEF NEXTGEN}
    function CreateXPathNamespace(const AOwnerElement: TDomElement;
                                  const ANamespaceUri,
                                        APrefix: string): TDomXPathNamespace;
{$ELSE !NEXTGEN}
    function CreateXPathNamespace(const AOwnerElement: TDomElement;
                                  const ANamespaceUri,
                                        APrefix: WideString): TDomXPathNamespace;
{$ENDIF NEXTGEN}
  protected
    FAxisType: TDomXPathAxisType;
    FList: TList<TDomNode>;
{$IFDEF NEXTGEN}
    procedure AddXPathNamespace(const AOwnerElement: TDomElement;
                                const ANamespaceUri,
                                      APrefix: string); virtual;
{$ELSE !NEXTGEN}
    procedure AddXPathNamespace(const AOwnerElement: TDomElement;
                                const ANamespaceUri,
                                      APrefix: WideString); virtual;
{$ENDIF NEXTGEN}
    function GetAxisType: TDomXPathAxisType; override;
    procedure Insert(const Index: Integer;
                     const Node: TDomNode); virtual;
    procedure SetAxisType(const Value: TDomXPathAxisType); override;
  public
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Add(const Node: TDomNode); virtual;
    procedure AddSubtree(const Node: TDomNode); virtual;
    function AsBoolean: Boolean; override;
    function AsNumber: Double; override;
    procedure Assign(Source: TPersistent); override;
{$IFDEF NEXTGEN}
    function AsWideString: string; override;
{$ELSE !NEXTGEN}
    function AsWideString: WideString; override;
{$ENDIF NEXTGEN}
    procedure Clear; reintroduce; virtual;
    procedure Delete(const Index: Integer); virtual;
    function Item(const Index: Integer): TDomNode; override;
    function Length: Integer; override;
    procedure Merge(const NodeSet: TDomXPathNodeSetResult); virtual;
    function ResultType: TDomXPathResultType; override;
    procedure Sort; virtual;
  end;

  TDomXPathBooleanResult = class(TDomXPathCustomResult)
  private
    FBooleanValue: Boolean;
  public
    constructor Create(const ABooleanValue: Boolean); virtual;
    function AsBoolean: Boolean; override;
    function AsNumber: Double; override;
{$IFDEF NEXTGEN}
    function AsWideString: string; override;
{$ELSE !NEXTGEN}
    function AsWideString: WideString; override;
{$ENDIF NEXTGEN}
    function ResultType: TDomXPathResultType; override;
  end;

  TDomXPathNumberResult = class(TDomXPathCustomResult)
  private
    FNumberValue: Double;
  public
    constructor Create(const ANumberValue: Double); virtual;
    function AsBoolean: Boolean; override;
    function AsNumber: Double; override;
{$IFDEF NEXTGEN}
    function AsWideString: string; override;
{$ELSE !NEXTGEN}
    function AsWideString: WideString; override;
{$ENDIF NEXTGEN}
    function ResultType: TDomXPathResultType; override;
  end;

  TDomXPathStringResult = class(TDomXPathCustomResult)
  private
{$IFDEF NEXTGEN}
    FStringValue: string;
  public
    constructor Create(const AStringValue: string); virtual;
{$ELSE !NEXTGEN}
    FStringValue: WideString;
  public
    constructor Create(const AStringValue: WideString); virtual;
{$ENDIF NEXTGEN}
    function AsBoolean: Boolean; override;
    function AsNumber: Double; override;
{$IFDEF NEXTGEN}
    function AsWideString: string; override;
{$ELSE !NEXTGEN}
    function AsWideString: WideString; override;
{$ENDIF NEXTGEN}
    function ResultType: TDomXPathResultType; override;
  end;

  TDomXPathSyntaxTree = class(TCustomOwnedObject)
  private
    [Weak]FOwnerXPathExpression: TXPathExpression;
  protected
    FRootExpr: TDomXPathExpr;
{$IFDEF NEXTGEN}
    function CreateSyntaxNode(const Symbol: TDomXPathTokenType;
                              const Value: string): TDomXPathSyntaxNode; virtual;
{$ELSE !NEXTGEN}
    function CreateSyntaxNode(const Symbol: TDomXPathTokenType;
                              const Value: WideString): TDomXPathSyntaxNode; virtual;
{$ENDIF NEXTGEN}
    function GetContextNode: TDomNode; virtual;
    function GetIsPrepared: Boolean; virtual;
{$IFDEF NEXTGEN}
    function LookupNamespaceURI(const APrefix: string): string;
{$ELSE !NEXTGEN}
    function LookupNamespaceURI(const APrefix: WideString): WideString;
{$ENDIF NEXTGEN}
  public
    constructor Create(AOwner: TXPathExpression);
    procedure Clear; override;
    function Evaluate: TDomXPathCustomResult; virtual;
{$IFDEF NEXTGEN}
    function Prepare(const Expression: string): Boolean; virtual;
{$ELSE !NEXTGEN}
    function Prepare(const Expression: WideString): Boolean; virtual;
{$ENDIF NEXTGEN}
    property ContextNode: TDomNode read GetContextNode;
    property IsPrepared: Boolean read GetIsPrepared;
    property OwnerXPathExpression: TXPathExpression read FOwnerXPathExpression;
  end;

  TXPathExpression = class(TDomBaseComponent)
  private
    FOnLookupNamespaceURI: TDomXPathLookupNamespaceURIEvent;
  protected
    FContextNode: TDomNode;              // The context node for this XPath expression.
    FIsValid: TDomTrinarean;             // Indicates whether the XPath expression is valid.
{$IFDEF NEXTGEN}
    FExpression: string;             // Holds the expression to be evaluated.
{$ELSE !NEXTGEN}
    FExpression: WideString;             // Holds the expression to be evaluated.
{$ENDIF NEXTGEN}
    FSyntaxTree: TDomXPathSyntaxTree;    // Holds the XPath syntax tree.
    FXPathResult: TDomXPathCustomResult; // Holds the result of the evaluation.
{$IFDEF NEXTGEN}
    function LookupNamespaceURI(const APrefix: string): string;
    procedure SetContextNode(const Node: TDomNode); virtual;
    procedure SetExpression(const S: string); virtual;
{$ELSE !NEXTGEN}
    function LookupNamespaceURI(const APrefix: WideString): WideString;
    procedure SetContextNode(const Node: TDomNode); virtual;
    procedure SetExpression(const S: WideString); virtual;
{$ENDIF NEXTGEN}
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function Evaluate: Boolean; virtual;
    function HasNodeSetResult: Boolean; virtual;
    function Prepare: Boolean; virtual;
    function ResultAxisType: TDomXPathAxisType; virtual;
    function ResultAsBoolean: Boolean; virtual;
    function ResultAsNumber: Double; virtual;
{$IFDEF NEXTGEN}
    function ResultAsWideString: string; virtual;
{$ELSE !NEXTGEN}
    function ResultAsWideString: WideString; virtual;
{$ENDIF NEXTGEN}
    function ResultNode(const Index: Integer): TDomNode; virtual;
    function ResultLength: Integer; virtual;

    property ContextNode: TDomNode read FContextNode write SetContextNode;
    property IsValid: TDomTrinarean read FIsValid;
  published
{$IFDEF NEXTGEN}
    property Expression: string read FExpression write SetExpression;
{$ELSE !NEXTGEN}
    property Expression: WideString read FExpression write SetExpression;
{$ENDIF NEXTGEN}

    property OnLookupNamespaceURI: TDomXPathLookupNamespaceURIEvent read FOnLookupNamespaceURI write FOnLookupNamespaceURI;
  end;

  TDomXPathSyntaxNodeStack = class
  private
    FNodeList: TList<TDomXPathSyntaxNode>;
  protected
    function GetLength: Integer; virtual;
  public
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Clear; virtual;
    function Peek(Offset: Integer): TDomXPathSyntaxNode; virtual;
    function Pop: TDomXPathSyntaxNode; virtual;
    procedure Push(Node: TDomXPathSyntaxNode); virtual;
    property Length: Integer read GetLength;
  end;

  TDomXPathSyntaxNode = class(TCustomOwnedObject)
  protected
    FLeft: TDomXPathSyntaxNode;
    FRight: TDomXPathSyntaxNode;
{$IFDEF NEXTGEN}
    FValue: string;
    function GetOwnerSyntaxTree: TDomXPathSyntaxTree; virtual;
    function LookupNamespaceURI(const APrefix: string): string;
  public
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); virtual;
{$ELSE !NEXTGEN}
    FValue: WideString;
    function GetOwnerSyntaxTree: TDomXPathSyntaxTree; virtual;
    function LookupNamespaceURI(const APrefix: WideString): WideString;
  public
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); virtual;
{$ENDIF NEXTGEN}
    property Left: TDomXPathSyntaxNode read FLeft write FLeft;
    property OwnerSyntaxTree: TDomXPathSyntaxTree read GetOwnerSyntaxTree;
    property Right: TDomXPathSyntaxNode read FRight write FRight;
{$IFDEF NEXTGEN}
    property Value: string read FValue;
{$ELSE !NEXTGEN}
    property Value: WideString read FValue;
{$ENDIF NEXTGEN}
  end;

  // Cf. XPath 1.0, prod. [2].
  TDomXPathAbsoluteLocationPath = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [4].
  TDomXPathStep = class(TDomXPathSyntaxNode)
  public
    function AddStep(const Step: TDomXPathStep): Boolean; virtual;
    function Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [6].
  // This class is only used as a common ancestor of the axis name classes below.
  TDomXPathCustomAxisName = class(TDomXPathSyntaxNode)
  protected
    FAxisType: TDomXPathAxisType;
    FPrincipalNodeType: TDomNodeType;
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; virtual; abstract;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
    function Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult; virtual;
    property AxisType: TDomXPathAxisType read FAxisType;
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameAncestor = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameAncestorOrSelf = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameAttribute = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameChild = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameDescendant = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameDescendantOrSelf = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameFollowing = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameFollowingSibling = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameNamespace = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameParent = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNamePreceding = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNamePrecedingSibling = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  public
{$IFDEF NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
  end;

  // Cf. XPath 1.0, prod. [6].
  TDomXPathAxisNameSelf = class(TDomXPathCustomAxisName)
  protected
    function GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult; override;
  end;

  // Cf. XPath 1.0, prod. [7].
  TDomXPathNodeTest = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const oldsnapshotResult: TDomXPathNodeSetResult;
                      const PrincipalNodeType: TDomNodeType): TDomXPathNodeSetResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [8].
  TDomXPathPredicate = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [14].
  TDomXPathExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition: Integer;
                      const ContextSize: Integer): TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [15].
  TDomXPathPrimaryExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition: Integer;
                      const ContextSize: Integer): TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [16].
  TDomXPathFunctionCall = class(TDomXPathSyntaxNode)
  private
    FArguments: TList<TDomXPathSyntaxNode>;
  protected
{$IFDEF NEXTGEN}
    FPrefix: string;
    FLocalName: string;
    FXPathFunction: TDomXPathFunction;
    function GetFunctionName: string; virtual;
    procedure SetFunctionName(const AFunctionName: string); virtual;
  public
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    FPrefix: WideString;
    FLocalName: WideString;
    FXPathFunction: TDomXPathFunction;
    function GetFunctionName: WideString; virtual;
    procedure SetFunctionName(const AFunctionName: WideString); virtual;
  public
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
    destructor Destroy; override;
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition: Integer;
                      const ContextSize: Integer): TDomXPathCustomResult; virtual;
    property Arguments: TList<TDomXPathSyntaxNode> read FArguments;
{$IFDEF NEXTGEN}
    property FunctionName: string read GetFunctionName write SetFunctionName;
{$ELSE !NEXTGEN}
    property FunctionName: WideString read GetFunctionName write SetFunctionName;
{$ENDIF NEXTGEN}
  end;

  // Cf. XPath 1.0, prod. [18].
  TDomXPathUnionExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition: Integer;
                      const ContextSize: Integer): TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [19].
  TDomXPathPathExpr = class(TDomXPathSyntaxNode)
  public
    function AddStep(const Step: TDomXPathStep): Boolean; virtual;
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition: Integer;
                      const ContextSize: Integer): TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [20].
  TDomXPathFilterExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition: Integer;
                      const ContextSize: Integer): TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [21].
  TDomXPathOrExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [22].
  TDomXPathAndExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [23].
  TDomXPathEqualityExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; virtual; abstract;
  end;

  TDomXPathIsEqualExpr = class(TDomXPathEqualityExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  TDomXPathIsNotEqualExpr = class(TDomXPathEqualityExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  // Cf. XPath 1.0, prod. [24].
  TDomXPathRelationalExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; virtual; abstract;
  end;

  TDomXPathLessThanExpr = class(TDomXPathRelationalExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  TDomXPathLessThanOrEqualExpr = class(TDomXPathRelationalExpr)
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  TDomXPathGreaterThanExpr = class(TDomXPathRelationalExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  TDomXPathGreaterThanOrEqualExpr = class(TDomXPathRelationalExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  // Cf. XPath 1.0, prod. [25].
  TDomXPathAdditiveExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; virtual; abstract;
  end;

  TDomXPathPlusExpr = class(TDomXPathAdditiveExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  TDomXPathMinusExpr = class(TDomXPathAdditiveExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  // Cf. XPath 1.0, prod. [26].
  TDomXPathMultiplicativeExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; virtual; abstract;
  end;

  TDomXPathMultiplyExpr = class(TDomXPathMultiplicativeExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  TDomXPathDivExpr = class(TDomXPathMultiplicativeExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  TDomXPathModExpr = class(TDomXPathMultiplicativeExpr)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; override;
  end;

  // Cf. XPath 1.0, prod. [27].
  TDomXPathUnaryExpr = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const ContextNode: TDomNode;
                      const ContextPosition,
                            ContextSize: Integer): TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathLeftParenthesis = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathRightParenthesis = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathLeftSquareBracket = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathRightSquareBracket = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathSingleDot = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathDoubleDot = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathCommercialAt = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathComma = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [28].
  TDomXPathDoubleColon = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [29].
  TDomXPathLiteral = class(TDomXPathSyntaxNode)
  public
    function Evaluate: TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [30].
  TDomXPathNumber = class(TDomXPathSyntaxNode)
  public
    function Evaluate: TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathSlashOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathShefferStrokeOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathPlusOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathMinusOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathIsEqualOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathIsNotEqualOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathLessThanOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathLessThanOrEqualOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathGreaterThanOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [32].
  TDomXPathGreaterThanOrEqualOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [33].
  TDomXPathAndOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [33].
  TDomXPathOrOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [33].
  TDomXPathModOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [33].
  TDomXPathDivOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [34].
  TDomXPathMultiplyOperator = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [35].
  TDomXPathFunctionName = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [36].
  TDomXPathVariableReference = class(TDomXPathSyntaxNode)
  protected
{$IFDEF NEXTGEN}
    FPrefix: string;
    FLocalName: string;
  public
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    FPrefix: WideString;
    FLocalName: WideString;
  public
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
    function Evaluate: TDomXPathCustomResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [37].
  TDomXPathNameTest = class(TDomXPathSyntaxNode)
  protected
{$IFDEF NEXTGEN}
    FPrefix: string;
    FLocalName: string;
  public
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: string); override;
{$ELSE !NEXTGEN}
    FPrefix: WideString;
    FLocalName: WideString;
  public
    constructor Create(const AOwner: TDomXPathSyntaxTree;
                       const Value: WideString); override;
{$ENDIF NEXTGEN}
    function Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult;
                      const PrincipalNodeType: TDomNodeType): TDomXPathNodeSetResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [38].
  TDomXPathNodeTypeComment = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [38].
  TDomXPathNodeTypeNode = class(TDomXPathSyntaxNode)
  end;

  // Cf. XPath 1.0, prod. [38].
  TDomXPathNodeTypePI = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult; virtual;
  end;

  // Cf. XPath 1.0, prod. [38].
  TDomXPathNodeTypeText = class(TDomXPathSyntaxNode)
  public
    function Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult; virtual;
  end;

{ XPath Helper Functions}
function XPathRound(const D: Double): Double;
{$IFDEF NEXTGEN}
function XPathWideStringToNumber(const S: string): Double;
{$ELSE !NEXTGEN}
function XPathWideStringToNumber(const S: WideString): Double;
{$ENDIF NEXTGEN}

{ XPath Conversion Functions }
function XPathBooleanFunc(const oldResult: TDomXPathCustomResult): TDomXPathBooleanResult;
function XPathNumberFunc(const oldResult: TDomXPathCustomResult): TDomXPathNumberResult;
function XPathStringFunc(const oldResult: TDomXPathCustomResult): TDomXPathStringResult;

{ XPath Function Library -- see XPath 1.0, sec. 4 }

{ XPath Node set Functions -- see XPath 1.0, sec. 4.1. }

function XPathFunctionLast(const ContextNode: TDomNode;
                           const ContextPosition: Integer;
                           const ContextSize: Integer;
                           const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionPosition(const ContextNode: TDomNode;
                               const ContextPosition: Integer;
                               const ContextSize: Integer;
                               const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionCount(const ContextNode: TDomNode;
                            const ContextPosition: Integer;
                            const ContextSize: Integer;
                            const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionId(const ContextNode: TDomNode;
                         const ContextPosition: Integer;
                         const ContextSize: Integer;
                         const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionLocalName(const ContextNode: TDomNode;
                                const ContextPosition: Integer;
                                const ContextSize: Integer;
                                const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionNamespaceUri(const ContextNode: TDomNode;
                                   const ContextPosition: Integer;
                                   const ContextSize: Integer;
                                   const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionName(const ContextNode: TDomNode;
                           const ContextPosition: Integer;
                           const ContextSize: Integer;
                           const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

{ XPath String Functions -- see XPath 1.0, sec. 4.2. }

function XPathFunctionString(const ContextNode: TDomNode;
                             const ContextPosition: Integer;
                             const ContextSize: Integer;
                             const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionConcat(const ContextNode: TDomNode;
                             const ContextPosition: Integer;
                             const ContextSize: Integer;
                             const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionStartsWith(const ContextNode: TDomNode;
                                 const ContextPosition: Integer;
                                 const ContextSize: Integer;
                                 const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionContains(const ContextNode: TDomNode;
                               const ContextPosition: Integer;
                               const ContextSize: Integer;
                               const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionSubstringBefore(const ContextNode: TDomNode;
                                      const ContextPosition: Integer;
                                      const ContextSize: Integer;
                                      const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionSubstringAfter(const ContextNode: TDomNode;
                                     const ContextPosition: Integer;
                                     const ContextSize: Integer;
                                     const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionSubstring(const ContextNode: TDomNode;
                                const ContextPosition: Integer;
                                const ContextSize: Integer;
                                const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionStringLength(const ContextNode: TDomNode;
                                   const ContextPosition: Integer;
                                   const ContextSize: Integer;
                                   const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionNormalizeSpace(const ContextNode: TDomNode;
                                     const ContextPosition: Integer;
                                     const ContextSize: Integer;
                                     const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionTranslate(const ContextNode: TDomNode;
                                const ContextPosition: Integer;
                                const ContextSize: Integer;
                                const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

{ XPath Boolean Functions -- see XPath 1.0, sec. 4.3. }

function XPathFunctionBoolean(const ContextNode: TDomNode;
                              const ContextPosition: Integer;
                              const ContextSize: Integer;
                              const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionNot(const ContextNode: TDomNode;
                          const ContextPosition: Integer;
                          const ContextSize: Integer;
                          const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionTrue(const ContextNode: TDomNode;
                           const ContextPosition: Integer;
                           const ContextSize: Integer;
                           const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionFalse(const ContextNode: TDomNode;
                            const ContextPosition: Integer;
                            const ContextSize: Integer;
                            const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionLang(const ContextNode: TDomNode;
                           const ContextPosition: Integer;
                           const ContextSize: Integer;
                           const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

{ XPath Number Functions -- see XPath 1.0, sec. 4.4. }

function XPathFunctionNumber(const ContextNode: TDomNode;
                             const ContextPosition: Integer;
                             const ContextSize: Integer;
                             const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionSum(const ContextNode: TDomNode;
                          const ContextPosition: Integer;
                          const ContextSize: Integer;
                          const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionFloor(const ContextNode: TDomNode;
                            const ContextPosition: Integer;
                            const ContextSize: Integer;
                            const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionCeiling(const ContextNode: TDomNode;
                              const ContextPosition: Integer;
                              const ContextSize: Integer;
                              const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;

function XPathFunctionRound(const ContextNode: TDomNode;
                            const ContextPosition: Integer;
                            const ContextSize: Integer;
                            const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;


{$IFDEF NEXTGEN}
// Whitespace Processing
function NormalizeSpace(const S: string): string;
function NormalizeWhiteSpace(const S: string): string;
function TrimWhitespace(const S: string): string;
function TrimWhitespaceLeft(const S: string): string;
function TrimWhitespaceRight(const S: string): string;

// Routines for XML Namespace Processing
function XmlExtractPrefix(const QualifiedName: string): string;
function XmlExtractLocalName(const QualifiedName: string): string;
function XmlExtractPrefixAndLocalName(const QualifiedName: string;
                                        out Prefix,
                                            LocalName: string): Boolean;

// Entity Reference Conversion
function EscapeDelimiters(const S: string): string;

// Character Reference Conversion
function ResolveCharRefs(const S: string): string;
function XmlCharRefToInt(const S: string): Integer;
function XmlCharRefToStr(const S: string): string;
function XmlIntToCharRef(const Value: Longint): string;
function XmlIntToCharRefHex(const Value: Longint): string;

// Other helper functions:
function XmlReplaceQuotes(const Source: string): string;

procedure XmlTruncRoundBrackets(const Source: string;
                                  var Content: string;
                                  out Error: Boolean);
{$ELSE !NEXTGEN}
// Whitespace Processing
function NormalizeSpace(const S: WideString): WideString;
function NormalizeWhiteSpace(const S: WideString): WideString;
function TrimWhitespace(const S: WideString): WideString;
function TrimWhitespaceLeft(const S: WideString): WideString;
function TrimWhitespaceRight(const S: WideString): WideString;

// Routines for XML Namespace Processing
function XmlExtractPrefix(const QualifiedName: WideString): WideString;
function XmlExtractLocalName(const QualifiedName: WideString): WideString;
function XmlExtractPrefixAndLocalName(const QualifiedName: WideString;
                                        out Prefix,
                                            LocalName: WideString): Boolean;

// Entity Reference Conversion
function EscapeDelimiters(const S: WideString): WideString;

// Character Reference Conversion
function ResolveCharRefs(const S: WideString): WideString;
function XmlCharRefToInt(const S: WideString): Integer;
function XmlCharRefToStr(const S: WideString): WideString;
function XmlIntToCharRef(const Value: Longint): WideString;
function XmlIntToCharRefHex(const Value: Longint): WideString;

// Other helper functions:
function XmlReplaceQuotes(const Source: WideString): WideString;

procedure XmlTruncRoundBrackets(const Source: WideString;
                                  var Content: WideString;
                                  out Error: Boolean);
{$ENDIF NEXTGEN}

implementation

{$B-}  // In the {$B-} state, the compiler generates code for short-circuit
       // Boolean expression evaluation, which means that evaluation stops
       // as soon as the result of the entire expression becomes evident in
       // left to right order of evaluation.
       //
       // {$B-} is the Delphi default, but it is repeated here in order to
       // make sure that this unit is really compiled with {$B-}.

uses
{$IFDEF CLR}
  DK.Utilities.LangUtils, DK.Utilities.UriUtils, DK.Utilities.XmlRulesUtils,
{$ELSE}
  Xml.Internal.LangUtils, Xml.Internal.UriUtils, Xml.Internal.XmlRulesUtils,
{$ENDIF}
    // The above units are contained in the Open XML Utilities package 1.x
    // available at "http://www.philo.de/xml/".
  System.Generics.Defaults,
  System.Character,
  System.Math;

{$IF CompilerVersion >= 24.0}
const
  FirstIndex  = Low(string);
  AdjustIndex = 1-Low(string);
{$ELSE}
const
  FirstIndex  = 1;
  AdjustIndex = 0;
{$ENDIF}

const
  // Unicode scalar values of some important characters:
  TAB = $9;  // Horizontal Tabulation
  LF  = $A;  // Line Feed
  CR  = $D;  // Carriage Return
  DQ  = $22; // Double Quote ('"')
  AMP = $26; // Ampersand ('&')
  LT  = $3C; // Less Than ('<')
  GT  = $3E; // Greater Than ('>')

  // Constants for IEEE 754 floating point operations in XPath functions:
  // These constants should not be used for comparison, only assignments.
  // For comparison use the IsNegZero and IsPosZero functions provided below.
  NegZero = 0.0 / -1.0;
  PosZero = 0.0 / 1.0;

{$IFDEF CLR}

function IsNegZero(const AValue: Double): Boolean;
var
  D: Int64;
begin
  D := BitConverter.DoubleToInt64Bits(AValue);
  Result := D = $8000000000000000;
end;

function IsPosZero(const AValue: Double): Boolean;
var
  D: Int64;
begin
  D := BitConverter.DoubleToInt64Bits(AValue);
  Result := D = $0000000000000000;
end;

{$ELSE}

function IsNegZero(const AValue: Double): Boolean;
begin
  Result := PInt64(@AValue)^ = $8000000000000000;
end;

function IsPosZero(const AValue: Double): Boolean;
begin
  Result := PInt64(@AValue)^ = $0000000000000000;
end;

{$ENDIF}

{$IFNDEF VER140+}
// Redeclarations of constants and functions which are not available in
// Delphi 5 or below.
const
  NaN =  0.0 / 0.0;

function IsNan(const AValue: Double): Boolean;
begin
  Result := ((PInt64(@AValue)^ and $7FF0000000000000)  = $7FF0000000000000) and
            ((PInt64(@AValue)^ and $000FFFFFFFFFFFFF) <> $0000000000000000);
end;

function IsInfinite(const AValue: Double): Boolean;
begin
  Result := ((PInt64(@AValue)^ and $7FF0000000000000) = $7FF0000000000000) and
            ((PInt64(@AValue)^ and $000FFFFFFFFFFFFF) = $0000000000000000);
end;

type
  TValueSign = -1..1;

const
  NegativeValue = Low(TValueSign);
  ZeroValue = 0;
  PositiveValue = High(TValueSign);

function Sign(const AValue: Double): TValueSign;
begin
  if ((PInt64(@AValue)^ and $7FFFFFFFFFFFFFFF) = $0000000000000000) then
    Result := ZeroValue
  else if ((PInt64(@AValue)^ and $8000000000000000) = $8000000000000000) then
    Result := NegativeValue
  else
    Result := PositiveValue;
end;

{$ENDIF}

{$IFDEF NEXTGEN}
function XmlReplaceQuotes(const Source: string): string;
{$ELSE !NEXTGEN}
function XmlReplaceQuotes(const Source: WideString): WideString;
{$ENDIF NEXTGEN}
// This function replaces all single and double quotes
// with their respective character references.
var
  I: Integer;
  Content: TUtilsCustomWideStr;
begin
  Result := '';
  Content := TUtilsCustomWideStr.Create;
  try
    for I := FirstIndex to Length(Source)-AdjustIndex do begin
      case Ord(Source[I]) of
        39: Content.AddWideString('&#39;'); // Single quote
        34: Content.AddWideString('&#34;'); // Double quote
      else
        Content.AddWideChar(Source[I]);
      end;
    end;
    Result := Content.Value;
  finally
    Content.Free;
  end;
end;

{$IFDEF NEXTGEN}
procedure XmlTruncRoundBrackets(const Source: string;
                                  var Content: string;
                                  out Error: Boolean);
{$ELSE !NEXTGEN}
procedure XmlTruncRoundBrackets(const Source: WideString;
                                  var Content: WideString;
                                  out Error: Boolean);
{$ENDIF NEXTGEN}
// This procedure removes leading and trailing white space characters from
// Source.  Afterward it checks whether the remaining WideString is framed
// by round brackets -- '(' and ')'.  If this is the case, the brackets are
// being removed, and again any leading and trailing white space characters
// from the remaining WideString is being removed.  The resulting WideString
// is returned in the Content parameter and the Error parameter returns
// False.  If the check for the framing brackets fails, the Content parameter
// returns an empty WideString and the Error parameter returns True.
var
{$IFDEF NEXTGEN}
  BracketStr: string;
{$ELSE !NEXTGEN}
  BracketStr: WideString;
{$ENDIF NEXTGEN}
begin
  Content := '';
  BracketStr := TrimWhitespace(Source);
  if Length(BracketStr) < 2 then begin Error := True; Exit; end;
  if (BracketStr[FirstIndex] <> '(') or (BracketStr[Length(BracketStr) - AdjustIndex] <> ')')
    then Error := True
    else begin
      Content := TrimWhitespace(Copy(BracketStr, 1+FirstIndex, Length(BracketStr) - 2));
      Error := False;
    end;
end;

{ Whitespace Processing }

{$IFDEF CLR}

function NormalizeSpace(const S: WideString): WideString;
const
  SPACE: WideChar = #$20;
var
  C: WideChar;
  Content: TUtilsCustomWideStr;
  I, L, Start: Integer;
  SpaceFound: Boolean;
begin
  Result := '';
  L := Length(S);
  if L = 0 then Exit;

  // Skip leading spaces:
  Start := FirstIndex;
  repeat
    if S[Start] <> SPACE then
      Break;
    Inc(Start);
  until Start > L-AdjustIndex;

  Content := TUtilsCustomWideStr.Create;
  try
    SpaceFound := False;
    for I := Start to L-AdjustIndex do begin
      C := S[I];
      if C = SPACE then begin
        SpaceFound := True;
      end else begin
        if SpaceFound then begin
          Content.AddWideChar(SPACE);
          SpaceFound := False;
        end;
        Content.AddWideChar(C);
      end;
    end;
    Result := Content.Value;
  finally
    Content.Free;
  end;
end;

function NormalizeWhiteSpace(const S: WideString): WideString;
const
  SPACE: WideChar = #$20;
var
  C: WideChar;
  Content: TUtilsCustomWideStr;
  I, L, Start: Integer;
  WhiteSpaceFound: Boolean;
begin
  Result := '';
  L := Length(S);
  if L = 0 then Exit;

  // Skip leading whitespaces:
  Start := FirstIndex;
  repeat
    if not IsXmlWhiteSpace(S[Start]) then
      Break;
    Inc(Start);
  until Start > L-AdjustIndex;

  Content := TUtilsCustomWideStr.Create;
  try
    WhiteSpaceFound := False;
    for I := Start to L-AdjustIndex do begin
      C := S[I];
      if IsXmlWhiteSpace(C) then begin
        WhiteSpaceFound := True;
      end else begin
        if WhiteSpaceFound then begin
          Content.AddWideChar(SPACE);
          WhiteSpaceFound := False;
        end;
        Content.AddWideChar(C);
      end;
    end;
    Result := Content.Value;
  finally
    Content.Free;
  end;
end;

{$ELSE}

{$IFDEF NEXTGEN}
function NormalizeSpace(const S: string): string;
{$ELSE !NEXTGEN}
function NormalizeSpace(const S: WideString): WideString;
{$ENDIF NEXTGEN}
const
  NULL:  WideChar = #0;   // End of WideString mark
  SPACE: WideChar = #$20;
var
  I: Integer;
  LastPCharWasSpace: Boolean;
  P: PWideChar;
  LResult: array of Char;
begin
  SetLength(LResult, Length(S));
  I := 0;

  // Skip leading spaces:
  P := PWideChar(S);
  while P^ = SPACE do
    Inc(P);

  LastPCharWasSpace := False;
  while P^ <> NULL do begin
    if P^ = SPACE then begin
      LastPCharWasSpace := True;
    end else begin
      if LastPCharWasSpace then begin
        LResult[I] := SPACE;
        Inc(I);
        LastPCharWasSpace := False;
      end;
      LResult[I] := P^;
      Inc(I);
    end;
    Inc(P);
  end;
  Result := string.Create(LResult, 0, I)
end;

{$IFDEF NEXTGEN}
function NormalizeWhiteSpace(const S: string): string;
{$ELSE !NEXTGEN}
function NormalizeWhiteSpace(const S: WideString): WideString;
{$ENDIF NEXTGEN}
const
  NULL:  WideChar = #0;   // End of WideString mark
  SPACE: WideChar = #$20;
var
  I: Integer;
  LastPCharWasWhitespace: Boolean;
  P: PWideChar;
  LResult : array of Char;
begin
  SetLength(LResult, Length(S));
  I := 0;

  // Skip leading white space:
  P := PWideChar(S);
  while IsXmlWhiteSpace(P^) do
    Inc(P);

  LastPCharWasWhitespace := False;
  while P^ <> NULL do begin
    if IsXmlWhiteSpace(P^) then begin
      LastPCharWasWhitespace := True;
    end else begin
      if LastPCharWasWhitespace then begin
        LResult[I] := SPACE;
        Inc(I);
        LastPCharWasWhitespace := False;
      end;
      LResult[I] := P^;
      Inc(I);
    end;
    Inc(P);
  end;
  Result := string.Create(LResult, 0, I);
end;

{$ENDIF}

{$IFDEF NEXTGEN}
function TrimWhitespace(const S: string): string;
{$ELSE !NEXTGEN}
function TrimWhitespace(const S: WideString): WideString;
{$ENDIF NEXTGEN}
var
  I, L: Integer;
begin
  L := Length(S);
  I := 1;
  while (I <= L) and IsXmlWhiteSpace(S[I-AdjustIndex]) do Inc(I);
  if I > L then
    Result := ''
  else begin
    while IsXmlWhiteSpace(S[L-AdjustIndex]) do Dec(L);
    Result := Copy(S, I, L - I + 1);
  end;
end;

{$IFDEF NEXTGEN}
function TrimWhitespaceLeft(const S: string): string;
{$ELSE !NEXTGEN}
function TrimWhitespaceLeft(const S: WideString): WideString;
{$ENDIF NEXTGEN}
var
  I, L: Integer;
begin
  L := Length(S);
  I := 1;
  while (I <= L) and IsXmlWhiteSpace(S[I-AdjustIndex]) do Inc(I);
  Result := Copy(S, I, Maxint);
end;

{$IFDEF NEXTGEN}
function TrimWhitespaceRight(const S: string): string;
{$ELSE !NEXTGEN}
function TrimWhitespaceRight(const S: WideString): WideString;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  I := Length(S);
  while (I > 0) and IsXmlWhiteSpace(S[I-AdjustIndex]) do Dec(I);
  Result := Copy(S, 1, I);
end;

{$IFDEF NEXTGEN}
function XmlExtractPrefix(const QualifiedName: string): string;
var
  ColonPos: Integer;
  LocalPart: string;  // = 0
  Prefix: string;     // = 0
{$ELSE !NEXTGEN}
function XmlExtractPrefix(const QualifiedName: WideString): WideString;
var
  ColonPos: Integer;
  LocalPart: WideString;  // = 0
  Prefix: WideString;     // = 0
{$ENDIF NEXTGEN}
begin
  ColonPos := Pos(':', QualifiedName);
  if ColonPos = 0
    then LocalPart := QualifiedName
    else begin
      Prefix:= Copy(QualifiedName, 1, ColonPos - 1);
      LocalPart:= Copy(QualifiedName, ColonPos + 1, Length(QualifiedName) - ColonPos);
      if not IsXmlPrefix(Prefix)
        then raise EInvalid_Character_Err.Create('Invalid character error.');
    end;
  if not IsXmlLocalPart(LocalPart)
    then raise EInvalid_Character_Err.Create('Invalid character error.');
  Result := Prefix;
end;

{$IFDEF NEXTGEN}
function XmlExtractLocalName(const QualifiedName: string): string;
var
  ColonPos: Integer;
  Prefix,LocalPart: string;
{$ELSE !NEXTGEN}
function XmlExtractLocalName(const QualifiedName: WideString): WideString;
var
  ColonPos: Integer;
  Prefix,LocalPart: WideString;
{$ENDIF NEXTGEN}
begin
  ColonPos := Pos(':', QualifiedName);
  if ColonPos = 0
    then LocalPart := QualifiedName
    else begin
      Prefix:= Copy(QualifiedName, 1, ColonPos - 1);
      LocalPart:= Copy(QualifiedName, ColonPos + 1, Length(QualifiedName) - ColonPos);
      if not IsXmlPrefix(Prefix)
        then raise EInvalid_Character_Err.Create('Invalid character error.');
  end;
  if not IsXmlLocalPart(LocalPart)
    then raise EInvalid_Character_Err.Create('Invalid character error.');
  Result := LocalPart;
end;

{$IFDEF NEXTGEN}
function XmlExtractPrefixAndLocalName(const QualifiedName: string;
                                        out Prefix,
                                            LocalName: string): Boolean;
{$ELSE !NEXTGEN}
function XmlExtractPrefixAndLocalName(const QualifiedName: WideString;
                                        out Prefix,
                                            LocalName: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  ColonPos: Integer;
begin
  ColonPos := Pos(':', QualifiedName);
  if ColonPos = 0 then begin
      Prefix := '';
      if IsXmlLocalPart(QualifiedName) then begin
        LocalName:= QualifiedName;
        Result := True;
      end else begin
        LocalName:= '';
        Result := False;
      end;
    end else begin
      Prefix := Copy(QualifiedName, 1, ColonPos -1 );
      LocalName := Copy(QualifiedName, ColonPos + 1, Length(QualifiedName) - ColonPos);
      if IsXmlPrefix(Prefix) and IsXmlLocalPart(LocalName) then begin
        Result := True;
      end else begin
        Prefix := '';
        LocalName := '';
        Result := False;
      end;
  end;
end;

{$IFDEF NEXTGEN}
function EscapeDelimiters(const S: string): string;
{$ELSE !NEXTGEN}
function EscapeDelimiters(const S: WideString): WideString;
{$ENDIF NEXTGEN}
var
  Content: TUtilsCustomWideStr;
  I: Integer;
begin
  Content:= TUtilsCustomWideStr.Create;
  try
    for I := FirstIndex to Length(S)-AdjustIndex do
      case Ord(S[I]) of
        34: Content.AddWideString('&quot;');
        38: Content.AddWideString('&amp;');
        39: Content.AddWideString('&apos;');
        60: Content.AddWideString('&lt;');
        62: Content.AddWideString('&gt;');
      else
        Content.AddWideChar(S[I]);
      end;
    Result := Content.Value;
  finally
    Content.Free;
  end;
end;

{$IFDEF NEXTGEN}
function ResolveCharRefs(const S: string): string;
{$ELSE !NEXTGEN}
function ResolveCharRefs(const S: WideString): WideString;
{$ENDIF NEXTGEN}
const
  BOM: WideChar = #$FEFF;  // Byte order mark
var
  C, C2: Word;
  I, J, IndexPos: Integer;
{$IFDEF NEXTGEN}
  Ref: string;
{$ELSE !NEXTGEN}
  Ref: WideString;
{$ENDIF NEXTGEN}
  Content: TUtilsCustomWideStr;
begin
  Result := '';
  Content:= TUtilsCustomWideStr.Create;
  try
    I := FirstIndex;

    // Check for byte order mark:
    if Length(S) > 0 then begin
      if S[I] = BOM then begin
        Content.AddWideChar(BOM);
        Inc(I);
      end;
    end;

    while I <= Length(S)-AdjustIndex do begin
      C := Ord(S[I]);
      if IsUtf16LowSurrogate(C) then
        raise EConvertError.Create('WideString must not start with a UTF-16 low surrogate.');
      if IsUtf16HighSurrogate(C) then begin
        if I = Length(S) then
          raise EConvertError.Create('WideString must not end with a UTF-16 high surrogate.');
        Inc(I);
        Content.AddWideChar(WideChar(C));
        C := Ord(S[I]);
        if not IsUtf16LowSurrogate(C) then
          raise EConvertError.Create('WideString contains an UTF-16 high surrogate without its corresponding low surrogate.');
      end;
      if not IsXmlChar(WideChar(C)) then
        raise EConvertError.Create('WideString contains an invalid character.');
      if C = Ord('&') then begin {Reference?}
        IndexPos := -1;
        for J := I + 1 to Length(S)-AdjustIndex do begin
          C2 := Ord(S[J]);
          if C2 = Ord(';') then begin IndexPos := J; Break; end;
        end;
        if IndexPos = -1 then
          raise EConvertError.Create('WideString contains an ''&'' without a '';''.');
                                                                          
        Ref:= Copy(S, I+AdjustIndex, Indexpos - I + 1);
        if IsXmlEntityRef(Ref) then begin
          if IsXmlPredefinedEntityName(Copy(Ref,2, Length(Ref)-2)) then
            Content.AddWideString(XmlPredefinedEntityToStr(Copy(Ref,2, Length(Ref)-2)))
          else
            Content.AddWideString(Ref);
        end else if IsXmlCharRef(Ref) then begin
          Content.AddWideString(XmlCharRefToStr(Ref));
        end else
          raise EConvertError.CreateFmt('WideString contains an invalid reference %S.',[Ref]);
        I := IndexPos;
      end else
        Content.AddWideChar(WideChar(C));
      Inc(I);
    end; {while ...}
    Result := Content.Value;
  finally
    Content.Free;
  end;
end;

{$IFDEF NEXTGEN}
function XmlCharRefToInt(const S: string): Integer;
{$ELSE !NEXTGEN}
function XmlCharRefToInt(const S: WideString): Integer;
{$ENDIF NEXTGEN}
var
  Value: word;
begin
  if not IsXmlCharRef(S)
    then raise EConvertError.CreateFmt('%S is not a valid XmlCharRef value.',[S]);
                                                                         
  if S[2+FirstIndex] = 'x'
    then Result := StrToInt(Concat('$',Copy(S, 4, Length(S) - 4))) // Hex
    else Result := StrToInt(Copy(S, 3, Length(S) - 3));            // Dec
  if Result > $10FFFF
    then raise EConvertError.CreateFmt('%S is not a valid XmlCharRef value.',[S]);
  if Result < $10000 then begin
    Value := Result;
    if not IsXmlChar(WideChar(Value))
      then raise EConvertError.CreateFmt('%S is not a valid XmlCharRef value.',[S]);
    case Result of
      $D800..$DBFF, // Reserved for high surrogate of Unicode character [$10000..$10FFFF]
      $DC00..$DFFF: // Reserved for low surrogate of Unicode character [$10000..$10FFFF]
      raise EConvertError.CreateFmt('%S is not a valid XmlCharRef value.',[S]);
    end; {case ...}
  end; {if ...}
end;

{$IFDEF NEXTGEN}
function XmlCharRefToStr(const S: string): string;
var
  Value: Integer;
  SmallValue: Word;
begin
  Value := XmlCharRefToInt(S);
  if Value < $10000 then begin
    SmallValue := Value;
    Result := WideChar(SmallValue);
  end else
    Result := Concat(WideChar(ExtractUtf16HighSurrogate(Value)),
                     WideChar(ExtractUtf16LowSurrogate(Value)));
end;
{$ELSE !NEXTGEN}
function XmlCharRefToStr(const S: WideString): WideString;
var
  Value: Integer;
  SmallValue: Word;
begin
  Value := XmlCharRefToInt(S);
  if Value < $10000 then begin
    SmallValue := Value;
    Result := WideString(WideChar(SmallValue));
  end else
    Result := Concat(WideString(WideChar(ExtractUtf16HighSurrogate(Value))),
                     WideString(WideChar(ExtractUtf16LowSurrogate(Value))));
end;
{$ENDIF NEXTGEN}

{$IFDEF NEXTGEN}
function XmlIntToCharRef(const Value: Longint): string;
{$ELSE !NEXTGEN}
function XmlIntToCharRef(const Value: Longint): WideString;
{$ENDIF NEXTGEN}
begin
  Result := Concat('&#', IntToStr(Value), ';');
end;

{$IFDEF NEXTGEN}
function XmlIntToCharRefHex(const Value: Longint): string;
{$ELSE !NEXTGEN}
function XmlIntToCharRefHex(const Value: Longint): WideString;
{$ENDIF NEXTGEN}
begin
  Result := Concat('&#x', IntToHex(Value, 1), ';');
end;

function IsSupportedXmlVersion(const VersionStr: string): Boolean;
begin
{$IFDEF NEXTGEN}
  Result := VersionStr.StartsWith('1.');
{$ELSE !NEXTGEN}
  Result := Copy(VersionStr, 1, 2) = '1.';
{$ENDIF NEXTGEN}
end;

function XPathRound(const D: Double): Double;
var
  DPt5: Double;
begin
  DPt5 := D + 0.5;
  if IsNaN(D) or IsInfinite(D) or IsNegZero(D) or IsPosZero(D)
    then Result := D
    else Result := Floor(DPt5);
  if (Result = 0) and (D < 0) then
    Result := NegZero;
end;

{$IFDEF NEXTGEN}
function XPathWideStringToNumber(const S: string): Double;
{$ELSE !NEXTGEN}
function XPathWideStringToNumber(const S: WideString): Double;
{$ENDIF NEXTGEN}
var
  DecimalPointFound: Boolean;
  E, I: Integer;
  W: Word;
begin
  Result := NaN;
  DecimalPointFound := False;
  E := 0;
  I := Length(S);

  // Skip trailing white space:
  while (I > 0) and IsXmlWhiteSpace(S[I-AdjustIndex]) do
    Dec(I);

  if I > 0 then begin
    if S[I-AdjustIndex] = #$2E then begin // '.' at the end of the number --> invalid
      Result := NaN;
      Exit;
    end else Result := 0;
  end;

  while I > 0 do begin
    W := Ord(S[I-AdjustIndex]);
    if W <= $39 then begin
      if W >= $30 then begin // Digit
        Result := Result + ( (W - $30) * Power(10, E) );
        Inc(E);
      end else if W = $2E then begin // '.'
        if DecimalPointFound then begin
          Result := NaN;
          Exit;
        end;
        Result := Result / Power(10, E);
        E := 0;
        DecimalPointFound := True;
      end else if W = $2D then begin // '-'
        Result := -Result;
        Dec(I);
        Break;
      end else Break;
    end else Break;
    Dec(I);
  end;

  // Skip leading white space:
  while (I > 0) and IsXmlWhiteSpace(S[I-AdjustIndex]) do
    Dec(I);

  if I > 0 then
    Result := NaN;
end;

function XPathBooleanFunc(const OldResult: TDomXPathCustomResult): TDomXPathBooleanResult;
begin
  if not Assigned(OldResult) then
    raise ENot_Supported_Err.Create('Not supported error.');
  if OldResult.ResultType = XPATH_BOOLEAN_TYPE then begin
    Result := (OldResult as TDomXPathBooleanResult);
  end else begin
    Result := TDomXPathBooleanResult.Create(OldResult.AsBoolean);
{$IFNDEF AUTOREFCOUNT}
    OldResult.Free;
{$ENDIF !AUTOREFCOUNT}
  end;
end;

function XPathNumberFunc(const OldResult: TDomXPathCustomResult): TDomXPathNumberResult;
begin
  if not Assigned(OldResult) then
    raise ENot_Supported_Err.Create('Not supported error.');
  if OldResult.ResultType = XPATH_NUMBER_TYPE then begin
    Result := (OldResult as TDomXPathNumberResult);
  end else begin
    Result := TDomXPathNumberResult.Create(OldResult.AsNumber);
{$IFNDEF AUTOREFCOUNT}
    OldResult.Free;
{$ENDIF !AUTOREFCOUNT}
  end;
end;

function XPathStringFunc(const OldResult: TDomXPathCustomResult): TDomXPathStringResult;
begin
  if not Assigned(OldResult) then
    raise ENot_Supported_Err.Create('Not supported error.');
  if OldResult.ResultType = XPATH_STRING_TYPE then begin
    Result := (OldResult as TDomXPathStringResult);
  end else begin
    Result := TDomXPathStringResult.Create(OldResult.AsWideString);
{$IFNDEF AUTOREFCOUNT}
    OldResult.Free;
{$ENDIF !AUTOREFCOUNT}
  end;
end;



{$IFNDEF CLR}

//+++++++++++++++++++++++++ TUtilsNoRefCount +++++++++++++++++++++++++

function TUtilsNoRefCount._AddRef: Integer;
begin
  Result := -1
end;

function TUtilsNoRefCount._Release: Integer;
begin
  Result := -1
end;

function TUtilsNoRefCount.QueryInterface(const IID: TGUID;
  out Obj): HResult;
const
  E_NoInterface = HResult($80004002);  // Remark: Redeclared, because E_NoInterface is absent from Delphi 5.
begin
  if GetInterface(IID, Obj) then
    Result := 0
  else
    Result := E_NoInterface;
end;

{$ENDIF}



//+++++++++++++++++++++++++ TDomBaseComponent +++++++++++++++++++++++++
{$IFDEF NEXTGEN}
function TDomBaseComponent.GetADOMVersion: string;
begin
  Result := '5.1.6';
end;
{$ELSE !NEXTGEN}
function TDomBaseComponent.GetADOMVersion: WideString;
begin
  Result := '5.1.6';
end;
{$ENDIF NEXTGEN}

//++++++++++++++++++++++++ TDomImplementation +++++++++++++++++++++++++
constructor TDomImplementation.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOwnedDocumentsList := TList<TCustomOwnedNode>.Create;
  FDocuments := TDomNodeList.Create(FOwnedDocumentsList);
  FResourceResolver := nil;
  FErrorReportLevel := 0;
end;

destructor TDomImplementation.Destroy;
begin
  Clear;
  FOwnedDocumentsList.Free;
  FDocuments.Free;
  inherited;
end;

procedure TDomImplementation.Attach(ADocument: TDomCustomDocument);
begin
  FOwnedDocumentsList.Add(ADocument);
end;

procedure TDomImplementation.Clear;
begin
  DestroyOwnedDocuments;
end;

procedure TDomImplementation.DestroyOwnedDocuments;
var
  I: Integer;
  TempDoc: TDomCustomDocument;
begin
  I := Pred(FOwnedDocumentsList.Count);
  while I >= 0 do
  begin
    TempDoc := TDomCustomDocument(FOwnedDocumentsList[I]);
    TempDoc.FDomImpl := nil;       // For a better performance of larger collections: ...
    FOwnedDocumentsList.Delete(I); // ... Avoid the call to FDomImpl.Detach(Self) in ...
    Dec(I);                        // ... the destructor of the owned document to be freed.
    TempDoc.Free;
    if I >= FOwnedDocumentsList.Count then
      I := Pred(FOwnedDocumentsList.Count);
  end;
end;

procedure TDomImplementation.Detach(ADocument: TDomCustomDocument);
begin
  FOwnedDocumentsList.Remove(ADocument);
end;

procedure TDomImplementation.DisableErrorEvents;
begin
  Inc(FErrorReportLevel);
end;

procedure TDomImplementation.EnableErrorEvents;
begin
  Dec(FErrorReportLevel);
end;

function TDomImplementation.GetDocuments: TDomNodeList;
begin
  Result := FDocuments;
end;

function TDomImplementation.GetErrorEventsDisabled: Boolean;
begin
  Result := FErrorReportLevel > 0;
end;

procedure TDomImplementation.DoAttrModified(const ModifiedNode: TDomNode;
                                            const AttrChange: TDomAttrChange;
                                            const RelatedAttr: TDomAttr);
begin
  if Assigned(FOnAttrModified) then
    FOnAttrModified(Self, ModifiedNode, AttrChange, RelatedAttr);
end;

procedure TDomImplementation.DoCharacterDataModified(ModifiedNode: TDomNode);
begin
  if Assigned(FOnCharacterDataModified) then
    FOnCharacterDataModified(Self, ModifiedNode);
end;

procedure TDomImplementation.DoError(    Sender: TObject;
                                         Error: TDomError;
                                     var Go: Boolean);
begin
  case Error.Severity of
    DOM_SEVERITY_WARNING, DOM_SEVERITY_ERROR:
      Go := True;
    DOM_SEVERITY_FATAL_ERROR:
      Go := False;
  end;
  if Assigned(FOnError) and (FErrorReportLevel = 0) then
    FOnError(Sender, Error, Go);
end;

procedure TDomImplementation.DoNodeClearing(Node: TDomNode);
begin
  if Assigned(FOnNodeClearing) then
    FOnNodeClearing(Self, Node);
end;

procedure TDomImplementation.DoNodeInserted(Node: TDomNode);
begin
  if Assigned(FOnNodeInserted) then
    FOnNodeInserted(Self, Node);
end;

procedure TDomImplementation.DoNodeRemoving(Node: TDomNode);
begin
  if Assigned(FOnNodeRemoving) then
    FOnNodeRemoving(Self, Node);
end;

{$IFDEF NEXTGEN}
procedure TDomImplementation.DoRequestXPathFunctionResult(const NamespaceURI,
                                                                LocalName: string;
{$ELSE !NEXTGEN}
procedure TDomImplementation.DoRequestXPathFunctionResult(const NamespaceURI,
                                                                LocalName: WideString;
{$ENDIF NEXTGEN}
                                                          const ContextNode: TDomNode;
                                                          const ContextPosition,
                                                                ContextSize: Integer;
                                                          const Arguments: TList<TDomXPathSyntaxNode>;
                                                            var Value: TDomXPathCustomResult);
begin
  if Assigned(FOnRequestXPathFunctionResult) then
    FOnRequestXPathFunctionResult(NamespaceURI, LocalName, ContextNode, ContextPosition, ContextSize, Arguments, Value);
end;

procedure TDomImplementation.DoRequestXPathVariable(const XPathExpression: TXPathExpression;
{$IFDEF NEXTGEN}
                                                    const NamespaceURI,
                                                          LocalName: string;
{$ELSE !NEXTGEN}
                                                    const NamespaceURI,
                                                          LocalName: WideString;
{$ENDIF NEXTGEN}
                                                      var Value: TDomXPathCustomResult);
begin
  if Assigned(FOnRequestXPathVariable) then
    FOnRequestXPathVariable(XPathExpression, NamespaceURI, LocalName, Value);
end;

function TDomImplementation.HandleError(const Sender: TObject;
                                        const Error: TDomError): Boolean;
begin
  if not Assigned(Error) then
    raise ENot_Supported_Err.Create('Not supported error.');
  DoError(Sender, Error, Result);
end;

procedure TDomImplementation.Notification(AComponent: TComponent;
                                          Operation: TOperation);
begin
  inherited Notification(AComponent, Operation);
  if (Operation = opRemove) and (AComponent = FResourceResolver) then
    FResourceResolver := nil;
end;

{$IFDEF NEXTGEN}
function TDomImplementation.ResolveResourceAsStream(const ABaseURI: string;
                                                      var PublicId,
                                                          SystemId: string): TStream;
{$ELSE !NEXTGEN}
function TDomImplementation.ResolveResourceAsStream(const ABaseURI: WideString;
                                                      var PublicId,
                                                          SystemId: WideString): TStream;
{$ENDIF NEXTGEN}
begin
  if not Assigned(ResourceResolver) then
    raise ENot_Found_Err.Create('No resource resolver assigned to DOM implementation.');
  Result := ResourceResolver.ResolveResource(ABaseUri, PublicId, SystemId);
end;

{$IFDEF NEXTGEN}
procedure TDomImplementation.ResolveResourceAsWideString(const ABaseURI: string;
                                                           var PublicId,
                                                               SystemId: string;
                                                           out S: string;
                                                           out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TDomImplementation.ResolveResourceAsWideString(const ABaseURI: WideString;
                                                           var PublicId,
                                                               SystemId: WideString;
                                                           out S: WideString;
                                                           out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
var
  Content: TUtilsCustomWideStr;
  InputSrc: TXmlInputSource;
  Stream: TStream;
begin
  Stream := ResolveResourceAsStream(ABaseUri, PublicId, SystemId);
  if not Assigned(Stream) then begin
    S := '';
    Error := ET_EXT_ENTITY_RESOURCE_NOT_FOUND;
    Exit;
  end;

                                                                          
  // Convert external entity value to UTF-16:
  try
    try
      InputSrc := TXmlInputSource.Create(Stream, PublicId, SystemId, 4096,                                                       
                    '', False, 0, 0, 0, 0, 1);
    except
      on ENot_Supported_Err do begin
        S := '';
        Error := ET_ENCODING_NOT_SUPPORTED;
        Exit;
      end;
      on EConvertError do begin
        S := '';
        Error := ET_BYTE_ORDER_MARK_ENCODING_MISMATCH;
        Exit;
      end;
    end;

    try
      if InputSrc.HasMalformedDecl
         or not ( InputSrc.DeclType in [DT_TEXT_DECLARATION,
                                        DT_XML_OR_TEXT_DECLARATION,
                                        DT_UNSPECIFIED] ) then
      begin
        S := '';
        Error := ET_INVALID_TEXT_DECL;
      end
      else if not IsSupportedXmlVersion(InputSrc.XmlVersion) then begin
          S := '';
          Error := ET_XML_VERSION_NOT_SUPPORTED;
        end else begin
          Error := ET_NONE;
          Content := TUtilsCustomWideStr.Create;
          try
            InputSrc.Next;
            while not InputSrc.Eof do
            begin
              Content.AddUCS4Char(InputSrc.CurrentCharInfo.CodePoint);
              InputSrc.Next;
            end;
            S := Content.Value;
          except
            S := '';
            Error := ET_INVALID_CHARACTER_IN_EXT_ENTITY;
          end;
          Content.Free;
        end;
    finally
      InputSrc.Free;
    end; {try ...}
  finally
    Stream.Free;
  end; {try ...}
end;

procedure TDomImplementation.SetResourceResolver(const AResourceResolver: TCustomResourceResolver);
begin
  if FResourceResolver = AResourceResolver then Exit;
  {$IFDEF VER140+}
  if Assigned(FResourceResolver) then
    FResourceResolver.RemoveFreeNotification(Self);
  {$ENDIF}
  {$IFNDEF MSWINDOWS}
  if Assigned(FResourceResolver) then
    FResourceResolver.RemoveFreeNotification(Self);
  {$ENDIF}
  FResourceResolver := AResourceResolver;
  if Assigned(AResourceResolver) then
    AResourceResolver.FreeNotification(Self);
end;



//++++++++++++++++++++++++++++ TDomTreeWalker +++++++++++++++++++++++++++++++
constructor TDomTreeWalker.Create(const Root: TDomNode;
                                  const WhatToShow: TDomWhatToShow;
                                  const NodeFilter: TDomNodeFilter;
                                  const EntityReferenceExpansion: Boolean);
begin
  if not Assigned(Root) then
    raise ENot_Supported_Err.Create('Not supported error.');
  inherited Create;
  FWhatToShow := WhatToShow;
  FFilter := NodeFilter;
  FExpandEntityReferences := EntityReferenceExpansion;
  FRoot := Root;
  FCurrentNode := Root;
end;

procedure TDomTreeWalker.SetCurrentNode(const Node: TDomNode);
begin
  if not Assigned(Node) then
    raise ENot_Supported_Err.Create('Not supported error.');
  FCurrentNode := Node;
end;

procedure TDomTreeWalker.SetExpandEntityReferences(const Value: Boolean);
begin
  FExpandEntityReferences := Value;
end;

procedure TDomTreeWalker.SetFilter(const Value: TDomNodeFilter);
begin
  FFilter := Value;
end;

procedure TDomTreeWalker.SetRoot(const Node: TDomNode);
begin
  if not Assigned(Node) then
    raise ENot_Supported_Err.Create('Not supported error.');
  FRoot := Node;
end;

procedure TDomTreeWalker.SetWhatToShow(const Value: TDomWhatToShow);
begin
  FWhatToShow := Value;
end;

function TDomTreeWalker.FindNextSibling(const OldNode: TDomNode): TDomNode;
var
  Accept: TDomFilterResult;
  NewNode: TDomNode;
begin
  Result := nil;
  if OldNode = Root then Exit;
  NewNode := OldNode.NextSibling;
  if Assigned(NewNode) then begin
    if NewNode.NodeType in FWhatToShow then begin
      if Assigned(FFilter)
        then Accept := FFilter.AcceptNode(NewNode)
        else Accept := filter_accept;
    end else Accept := filter_skip;
    case Accept of
      filter_reject:
        Result := FindNextSibling(NewNode);
      filter_skip:
        begin
          Result := FindFirstChild(NewNode);
          if not Assigned(Result) then
            Result := FindNextSibling(NewNode);
        end;
      filter_accept:
        Result := NewNode;
    end; {case ...}
  end else begin
    if not Assigned(OldNode.ParentNode)
      then begin Result := nil; Exit; end; // TreeWalker.Root not found!
    if OldNode.ParentNode.NodeType in FWhatToShow then begin
      if Assigned(FFilter)
        then Accept := FFilter.AcceptNode(OldNode.ParentNode)
        else Accept := filter_accept;
    end else Accept := filter_skip;
    case Accept of
      filter_reject, filter_skip:
        Result := FindNextSibling(OldNode.ParentNode);
      filter_accept:
        Result := nil;
    end; {case ...}
  end;
end;

function TDomTreeWalker.FindPreviousSibling(const OldNode: TDomNode): TDomNode;
var
  Accept: TDomFilterResult;
  NewNode: TDomNode;
begin
  Result := nil;
  if OldNode = Root then Exit;
  NewNode := OldNode.PreviousSibling;
  if Assigned(NewNode) then begin
    if NewNode.NodeType in FWhatToShow then begin
      if Assigned(FFilter)
        then Accept := FFilter.AcceptNode(NewNode)
        else Accept := filter_accept;
    end else Accept := filter_skip;
    case Accept of
      filter_reject:
        Result := FindPreviousSibling(NewNode);
      filter_skip:
        begin
          Result := FindLastChild(NewNode);
          if not Assigned(Result) then
            Result := FindPreviousSibling(NewNode);
        end;
      filter_accept:
        Result := NewNode;
    end; {case ...}
  end else begin
    if not Assigned(OldNode.ParentNode)
      then begin Result := nil; Exit; end; // TreeWalker.Root not found!
    if OldNode.ParentNode.NodeType in FWhatToShow then begin
      if Assigned(FFilter)
        then Accept := FFilter.AcceptNode(OldNode.ParentNode)
        else Accept := filter_accept;
    end else Accept := filter_skip;
    case Accept of
      filter_reject, filter_skip:
        Result := FindPreviousSibling(OldNode.ParentNode);
      filter_accept:
        Result := nil;
    end; {case ...}
  end;
end;

function TDomTreeWalker.FindParentNode(const OldNode: TDomNode): TDomNode;
var
  Accept: TDomFilterResult;
begin
  Result := nil;
  if OldNode = Root then Exit;
  Result := OldNode.ParentNode;
  if not Assigned(Result)
    then begin Result := nil; Exit; end; // TreeWalker.Root not found!
  if Result.NodeType in FWhatToShow then begin
    if Assigned(FFilter)
      then Accept := FFilter.AcceptNode(Result)
      else Accept := filter_accept;
  end else Accept := filter_skip;
  case Accept of
    filter_reject, filter_skip:
      Result := FindParentNode(Result);
  end;
end;

function TDomTreeWalker.FindFirstChild(const OldNode: TDomNode): TDomNode;
var
  I: Integer;
  NewNode: TDomNode;
  Accept: TDomFilterResult;
begin
  Result := nil;
  if (OldNode.NodeType = ntEntity_Reference_Node) and not FExpandEntityReferences
    then Exit;
  for I := 0 to Pred(Oldnode.ChildNodes.Length) do begin
    NewNode := Oldnode.ChildNodes.Item(I);
    if NewNode.NodeType in FWhatToShow then begin
      if Assigned(FFilter)
        then Accept := FFilter.AcceptNode(NewNode)
        else Accept := filter_accept;
    end else Accept := filter_skip;
    case Accept of
      filter_skip:
        Result := FindFirstChild(NewNode);
      filter_accept:
        Result := NewNode;
    end; {case ...}
    if Assigned(Result) then Break;
  end; {for ...}
end;

function TDomTreeWalker.FindLastChild(const OldNode: TDomNode): TDomNode;
var
  I: Integer;
  NewNode: TDomNode;
  Accept: TDomFilterResult;
begin
  Result := nil;
  if (OldNode.NodeType = ntEntity_Reference_Node) and not FExpandEntityReferences
    then Exit;
  for I := Pred(Oldnode.ChildNodes.Length) downto 0 do begin
    NewNode := Oldnode.ChildNodes.Item(I);
    if NewNode.NodeType in FWhatToShow then begin
      if Assigned(FFilter)
        then Accept := FFilter.AcceptNode(NewNode)
        else Accept := filter_accept;
    end else Accept := filter_skip;
    case Accept of
      filter_skip:
        Result := FindLastChild(NewNode);
      filter_accept:
        Result := NewNode;
    end; {case ...}
    if Assigned(Result) then Break;
  end; {for ...}
end;

function TDomTreeWalker.FindNextNode(OldNode: TDomNode): TDomNode;
var
  NewNode: TDomNode;
begin
  Result := FindFirstChild(OldNode);
  if OldNode = Root then Exit;
  if not Assigned(Result)then
    Result := FindNextSibling(OldNode);
  while not Assigned(Result) do begin
    NewNode := FindParentNode(OldNode);
    if not Assigned(NewNode) then Exit;  // No next node.
    Result := FindNextSibling(NewNode);
    OldNode := NewNode;
  end;
end;

function TDomTreeWalker.FindPreviousNode(const OldNode: TDomNode): TDomNode;
var
  NewNode: TDomNode;
begin
  Result := nil;
  if OldNode = Root then Exit;
  Result := FindPreviousSibling(OldNode);
  if Assigned(Result) then begin
    NewNode := FindLastChild(Result);
    if Assigned(NewNode) then Result := NewNode;
  end else
    Result := FindParentNode(OldNode);
end;

function TDomTreeWalker.ParentNode: TDomNode;
begin
  Result := FindParentNode(FCurrentNode);
  if Assigned(Result) then FCurrentNode:= Result;
end;

function TDomTreeWalker.FirstChild: TDomNode;
begin
  Result := FindFirstChild(FCurrentNode);
  if Assigned(Result) then FCurrentNode:= Result;
end;

function TDomTreeWalker.LastChild: TDomNode;
begin
  Result := FindLastChild(FCurrentNode);
  if Assigned(Result) then FCurrentNode:= Result;
end;

function TDomTreeWalker.PreviousSibling: TDomNode;
begin
  Result := FindPreviousSibling(FCurrentNode);
  if Assigned(Result) then FCurrentNode:= Result;
end;

function TDomTreeWalker.NextSibling: TDomNode;
begin
  Result := FindNextSibling(FCurrentNode);
  if Assigned(Result) then FCurrentNode:= Result;
end;

function TDomTreeWalker.PreviousNode: TDomNode;
begin
  Result := FindPreviousNode(FCurrentNode);
  if Assigned(Result) then FCurrentNode:= Result;
end;

function TDomTreeWalker.NextNode: TDomNode;
begin
  Result := FindNextNode(FCurrentNode);
  if Assigned(Result) then FCurrentNode:= Result;
end;



//++++++++++++++++++++++++++++ TDomNodeIterator +++++++++++++++++++++++++++++++
constructor TDomNodeIterator.Create(const Root: TDomNode;
                                    const WhatToShow: TDomWhatToShow;
                                    const NodeFilter: TDomNodeFilter;
                                    const EntityReferenceExpansion: Boolean);
begin
  if not Assigned(Root) then
    raise ENot_Supported_Err.Create('Not supported error.');
  inherited Create;
  FRoot := Root;
  FWhatToShow := WhatToShow;
  FFilter := NodeFilter;
  FExpandEntityReferences := EntityReferenceExpansion;
  FReferenceNode := Root;
  FInvalid := False;
  FPosition := posBefore;
end;

procedure TDomNodeIterator.HandleNodeEvent(const Node: TDomNode;
                                           const EventType: TDomNodeEvent);
var
  NewRefNode: TDomNode;
  NewPosition: TDomPosition;
  DP_Ref, DP_Root: TDomDocumentPosition;
begin
  if FInvalid then Exit;
  case EventType of
    neClearing: begin
      DP_Ref := FReferenceNode.CompareDocumentPosition(Node);
      if Document_Position_Following in DP_Ref then begin
        // The Iterator's reference node is affected.
        DP_Root := FRoot.CompareDocumentPosition(Node);
        if Document_Position_Following in DP_Root then begin
          // The Iterator's Root node is affected too,
          // so we must invalidate the Iterator:
          FReferenceNode := nil;
          FRoot := nil;
          FInvalid := True;
        end else begin
          // Reposition the Iterator:
          FReferenceNode := Node;
          FPosition := posAfter;
        end;
      end;
    end;
    neRemoving: begin
      DP_Root := FRoot.CompareDocumentPosition(Node);
      if Document_Position_Preceding in DP_Root then begin
        DP_Ref := FReferenceNode.CompareDocumentPosition(Node);
        if ( (Document_Position_Following in DP_Ref) or
             (Document_Position_Same_Node in DP_Ref) ) then begin

          NewRefNode := nil;
          NewPosition := FPosition;
          case FPosition of
            posBefore: begin
              NewRefNode := Node.NextSibling;
              if not Assigned(NewRefNode) then begin
                NewRefNode := FindPreviousNode(Node);
                NewPosition := posAfter;
              end;
            end;
            posAfter: begin
              NewRefNode := Node.NextSibling;
              if not Assigned(NewRefNode) then begin
                NewRefNode := FindPreviousNode(Node);
                NewPosition := posBefore;
              end;
            end;
          end; {case ...}
          if Assigned(NewRefNode) then begin
            FReferenceNode := NewRefNode;
            FPosition := NewPosition;
          end else begin
            // The Iterator is in an invalid state, so we invalidate it
            // (usually this should not happen, but we care for it anyway):
            FReferenceNode := nil;
            FRoot := nil;
            FInvalid := True;
          end;
        end;
      end;
    end;
  end; {case ...}
end;

procedure TDomNodeIterator.Detach;
begin
  FReferenceNode:= nil;
  FInvalid:= True;
end;

function TDomNodeIterator.FindNextNode(OldNode: TDomNode): TDomNode;
var
  NewNode: TDomNode;
begin
  if OldNode.HasChildNodes
    and (FExpandEntityReferences or (OldNode.NodeType <> ntEntity_Reference_Node) )
    then Result := OldNode.FirstChild
    else Result := OldNode.NextSibling;
  while not Assigned(Result) do begin
    NewNode := OldNode.ParentNode;
    if not Assigned(NewNode) then Exit;  // No next node.
    Result := NewNode.NextSibling;
    OldNode := NewNode;
  end;
end;

function TDomNodeIterator.FindPreviousNode(const OldNode: TDomNode): TDomNode;
var
  NewNode: TDomNode;
begin
  Result := OldNode.PreviousSibling;
  if Assigned(Result) then begin
    NewNode := Result;
    while Assigned(NewNode) do begin
      Result := NewNode;
      NewNode := NewNode.LastChild;
    end;
  end else Result := OldNode.ParentNode;
end;

function TDomNodeIterator.NextNode: TDomNode;
var
  Accept: TDomFilterResult;
  NewNode: TDomNode;
begin
  NewNode := nil;
  if FInvalid then
    raise EInvalid_State_Err.Create('Invalid state error.');
  case FPosition of
    posBefore: begin
      FPosition := posAfter;
      NewNode := FReferenceNode;
    end;
    posAfter: begin
      NewNode := FindNextNode(FReferenceNode);
    end;
  end;
  repeat
    Accept := filter_accept;
    if Assigned(NewNode) then begin
      if NewNode.NodeType in FWhatToShow then begin
        if Assigned(FFilter)
          then Accept := FFilter.AcceptNode(NewNode);
      end else Accept := filter_skip;
      if not (Accept = filter_accept)
        then NewNode := FindNextNode(NewNode);
    end;
  until Accept = filter_accept;
  if Assigned(NewNode) then
    if not (NewNode.HasAsAncestor(Root) or (NewNode = Root)) then
      if (FReferenceNode.HasAsAncestor(Root) or (FReferenceNode = Root)) then
        NewNode := nil;
  if Assigned(NewNode) then
    FReferenceNode:= NewNode;
  Result := NewNode;
end;

function TDomNodeIterator.PreviousNode: TDomNode;
var
  Accept: TDomFilterResult;
  NewNode: TDomNode;
begin
  NewNode := nil;
  if FInvalid then
    raise EInvalid_State_Err.Create('Invalid state error.');
  case FPosition of
    posBefore: begin
      NewNode := FindPreviousNode(FReferenceNode);
    end;
    posAfter: begin
      FPosition := posBefore;
      NewNode := FReferenceNode;
    end;
  end;
  repeat
    Accept := filter_accept;
    if Assigned(NewNode) then begin
      if NewNode.NodeType in FWhatToShow then begin
        if Assigned(FFilter)
          then Accept := FFilter.AcceptNode(NewNode);
      end else Accept := filter_skip;
      if not (Accept = filter_accept)
        then NewNode := FindPreviousNode(NewNode);
    end;
  until Accept = filter_accept;
  if Assigned(NewNode) then
    if not (NewNode.HasAsAncestor(Root) or (NewNode = Root)) then
      if (FReferenceNode.HasAsAncestor(Root) or (FReferenceNode = Root)) then
        NewNode := nil;
  if Assigned(NewNode) then FReferenceNode:= NewNode;
  Result := NewNode;
end;



//++++++++++++++++++++++++++++ TDomNodeList +++++++++++++++++++++++++++++++
constructor TDomNodeList.Create(const NodeList: TList<TCustomOwnedNode>);
begin
  inherited Create;
  FNodeList := NodeList;
end;

function TDomNodeList.GetLength: Integer;
begin
  Result := FNodeList.Count;
end;

function TDomNodeList.IndexOf(const Node: TDomNode): Integer;
begin
  Result := FNodeList.IndexOf(Node);
end;

{$IFDEF CLR}

function TDomNodeList.Item(const Index: Integer): TDomNode;
begin
  if (Index < 0) or (Index >= FNodeList.Count)
    then Result := nil
    else Result := TDomNode(FNodeList[Index]);
end;

{$ELSE}

function TDomNodeList.Item(const Index: Integer): TDomNode;
begin
  if (Index < 0) or (Index >= FNodeList.Count)
    then Result := nil
    else Result := TDomNode(FNodeList.List[Index]);
end;

{$ENDIF}



//++++++++++++++++++++++++ TDomElementsNodeList ++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomElementsNodeList.Create(const QueryName: string;
{$ELSE !NEXTGEN}
constructor TDomElementsNodeList.Create(const QueryName: WideString;
{$ENDIF NEXTGEN}
                                        const StartElement: TDomNode);
begin
  inherited Create(nil);
  FQueryName:= QueryName;
  FStartElement:= StartElement;
end;

function TDomElementsNodeList.GetLength: Integer;
var
  AktNode,NewNode: TDomNode;
  Level: Integer;
begin
  Result := 0;
  if not Assigned(FStartElement) then Exit;
  Level := 0;
  AktNode := FStartElement;
  if AktNode.NodeType = ntElement_Node then
    if (AktNode.NodeName = FQueryName) or (FQueryName = '*') then
      Inc(Result);
  repeat
    if AktNode.HasChildNodes
      then begin NewNode := AktNode.FirstChild; Inc(Level); end
      else NewNode := AktNode.NextSibling;
    while not Assigned(NewNode) do begin
      Dec(Level);
      if Level < 1 then Break;
      AktNode := AktNode.ParentNode;
      NewNode := AktNode.NextSibling;
    end;
    if Level < 1 then Break;
    AktNode := NewNode;
    if AktNode.NodeType = ntElement_Node then
      if (AktNode.NodeName = FQueryName) or (FQueryName = '*') then
        Inc(Result);
  until Level < 1;
end;

function TDomElementsNodeList.IndexOf(const Node: TDomNode): Integer;
var
  AktNode, NewNode: TDomNode;
  Level, I: Integer;
begin
  Result := -1;
  if not Assigned(FStartElement) then Exit;
  if not (Node is TDomNode) then Exit;
  if Node.NodeType <> ntElement_Node then Exit;
  I := -1;
  Level := 0;
  AktNode := FStartElement;
  repeat
    if AktNode.HasChildNodes
      then begin NewNode := AktNode.FirstChild; Inc(Level); end
      else NewNode := AktNode.NextSibling;
    while not Assigned(NewNode) do begin
      Dec(Level);
      if Level < 1 then Break;
      AktNode:= AktNode.ParentNode;
      NewNode := AktNode.NextSibling;
    end;
    if Level < 1 then Break;
    AktNode := NewNode;
    if AktNode.NodeType = ntElement_Node then
      if (AktNode.NodeName = FQueryName) or (FQueryName = '*') then begin
        Inc(I);
        if AktNode = Node then begin Result := I; Break; end;
      end;
  until Level < 1;
end;

function TDomElementsNodeList.Item(const Index: Integer): TDomNode;
var
  AktNode, NewNode: TDomNode;
  Level, I: Integer;
begin
  Result := nil;
  if not Assigned(FStartElement) then Exit;
  if (Index < 0) then Exit;
  I := -1;
  Level := 0;
  AktNode := FStartElement;
  repeat
    if AktNode.HasChildNodes
      then begin NewNode := AktNode.FirstChild; Inc(Level); end
      else NewNode := AktNode.NextSibling;
    while not Assigned(NewNode) do begin
      Dec(Level);
      if Level < 1 then Break;
      AktNode := AktNode.ParentNode;
      NewNode := AktNode.NextSibling;
    end;
    if Level < 1 then Break;
    AktNode := NewNode;
    if AktNode.NodeType = ntElement_Node then
      if (AktNode.NodeName = FQueryName) or (FQueryName = '*') then begin
        Inc(I);
        if I = Index then begin Result := AktNode; Break; end;
      end;
  until Level < 1;
end;



//+++++++++++++++++++++ TDomElementsNodeListNS ++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomElementsNodeListNS.Create(const QueryNamespaceURI,
                                                QueryLocalName: string;
                                          const StartElement: TDomNode);
{$ELSE !NEXTGEN}
constructor TDomElementsNodeListNS.Create(const QueryNamespaceURI,
                                                QueryLocalName: WideString;
                                          const StartElement: TDomNode);
{$ENDIF NEXTGEN}
begin
  inherited Create(nil);
  FQueryNamespaceURI := QueryNamespaceURI;
  FQueryLocalName := QueryLocalName;
  FStartElement := StartElement;
end;

function TDomElementsNodeListNS.GetLength: Integer;
var
  AktNode, NewNode: TDomNode;
  Level: Integer;
begin
  Result := 0;
  if not Assigned(FStartElement) then Exit;
  Level := 0;
  AktNode := FStartElement;
  repeat
    if AktNode.HasChildNodes
      then begin NewNode := AktNode.FirstChild; Inc(Level); end
      else NewNode := AktNode.NextSibling;
    while not Assigned(NewNode) do begin
      Dec(Level);
      if Level < 1 then Break;
      AktNode := AktNode.ParentNode;
      NewNode := AktNode.NextSibling;
    end;
    if Level < 1 then Break;
    AktNode:= NewNode;
    if AktNode.NodeType = ntElement_Node then
      if ((AktNode.NamespaceURI = FQueryNamespaceURI) or (FQueryNamespaceURI = '*'))
        and ((AktNode.LocalName = FQueryLocalName) or (FQueryLocalName = '*'))
          then Inc(Result);
  until Level < 1;
end;

function TDomElementsNodeListNS.IndexOf(const Node: TDomNode): Integer;
var
  AktNode, NewNode: TDomNode;
  Level, I: Integer;
begin
  Result := -1;
  if not Assigned(FStartElement) then Exit;
  if not (Node is TDomNode) then Exit;
  if Node.NodeType <> ntElement_Node then Exit;
  I := -1;
  Level := 0;
  AktNode := FStartElement;
  repeat
    if AktNode.HasChildNodes
      then begin NewNode := AktNode.FirstChild; Inc(Level); end
      else NewNode := AktNode.NextSibling;
    while not Assigned(NewNode) do begin
      Dec(Level);
      if Level < 1 then Break;
      AktNode := AktNode.ParentNode;
      NewNode := AktNode.NextSibling;
    end;
    if Level < 1 then Break;
    AktNode := NewNode;
    if AktNode.NodeType = ntElement_Node then
      if ((AktNode.NamespaceURI = FQueryNamespaceURI) or (FQueryNamespaceURI = '*'))
        and ((AktNode.LocalName = FQueryLocalName) or (FQueryLocalName = '*'))
          then begin
            Inc(I);
            if AktNode = Node then begin Result := I; Break; end;
          end;
  until Level < 1;
end;

function TDomElementsNodeListNS.Item(const Index: Integer): TDomNode;
var
  AktNode, NewNode: TDomNode;
  Level, I: Integer;
begin
  Result := nil;
  if not Assigned(FStartElement) then Exit;
  if (Index < 0) then Exit;
  I := -1;
  Level := 0;
  AktNode := FStartElement;
  repeat
    if AktNode.HasChildNodes
      then begin NewNode := AktNode.FirstChild; Inc(Level); end
      else NewNode := AktNode.NextSibling;
    while not Assigned(NewNode) do begin
      Dec(Level);
      if Level < 1 then Break;
      AktNode:= AktNode.ParentNode;
      NewNode := AktNode.NextSibling;
    end;
    if Level < 1 then Break;
    AktNode:= NewNode;
    if AktNode.NodeType = ntElement_Node then
      if ((AktNode.NamespaceURI = FQueryNamespaceURI) or (FQueryNamespaceURI = '*'))
        and ((AktNode.LocalName = FQueryLocalName) or (FQueryLocalName = '*'))
          then begin
            Inc(I);
            if I = Index then begin Result := AktNode; Break; end;
          end;
  until Level < 1;
end;



//+++++++++++++++++++++++++ TDomNamedNodeMap +++++++++++++++++++++++++++++
constructor TDomNamedNodeMap.Create(const AOwner: TDomNode;
                                    const NodeList: TList<TCustomOwnedNode>;
                                    const AllowedNTs: TDomWhatToShow;
                                    const DefaultNamespaceAware: Boolean);
begin
  inherited Create(NodeList);
  FOwnerNode := AOwner;
  FAllowedNodeTypes := AllowedNTs;
  FDefaultNamespaceAware := DefaultNamespaceAware;
end;

procedure TDomNamedNodeMap.CheckAllowedNodeType(const Node: TDomNode);
begin
  if not (Node.NodeType in FAllowedNodeTypes) then
    raise EHierarchy_Request_Err.Create('Hierarchy request error.');
end;

procedure TDomNamedNodeMap.CheckHasNode(const Node: TDomNode);
begin
  if FNodeList.IndexOf(Node) = -1 then
    raise ENot_Found_Err.Create('Node not found error.');
end;

procedure TDomNamedNodeMap.CheckNamespaceAware;
begin
  if not NamespaceAware then
    raise ENamespace_Err.Create('Namespace error.');
end;

procedure TDomNamedNodeMap.CheckNotInUse(const Node: TDomNode);
begin
  if Assigned(Node.ParentNode) then
    raise EInuse_Err.Create('Inuse node error.');
  if Node.NodeType = ntAttribute_Node then
    if Assigned((Node as TDomAttr).FOwnerMap) then
      if (Node as TDomAttr).FOwnerMap <> Self then
        raise EInuse_Err.Create('Inuse attribute error.');
end;

procedure TDomNamedNodeMap.CheckNotNamespaceAware;
begin
  if NamespaceAware then
    raise ENamespace_Err.Create('Namespace error.');
end;

procedure TDomNamedNodeMap.CheckNotReadOnly;
begin
  if ReadOnly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');
end;

procedure TDomNamedNodeMap.CheckSameRootDocument(const Node: TDomNode);
begin
  if OwnerNode.RootDocument <> Node.RootDocument then
    raise EWrong_Document_Err.Create('Wrong document error.');
end;

{$IFDEF NEXTGEN}
function TDomNamedNodeMap.GetNamedItem(const Name: string): TDomNode;
{$ELSE !NEXTGEN}
function TDomNamedNodeMap.GetNamedItem(const Name: WideString): TDomNode;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  CheckNotNamespaceAware;
  Result := nil;
  for I := 0 to Pred(FNodeList.Count) do
    if TDomNode(FNodeList[I]).NodeName = Name then begin
      Result := TDomNode(FNodeList[I]);
      Break;
    end;
end;

{$IFDEF NEXTGEN}
function TDomNamedNodeMap.GetNamedItemNS(const NamespaceURI,
                                               LocalName: string): TDomNode;
{$ELSE !NEXTGEN}
function TDomNamedNodeMap.GetNamedItemNS(const NamespaceURI,
                                               LocalName: WideString): TDomNode;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  CheckNamespaceAware;
  Result := nil;
  for I := 0 to Pred(FNodeList.Count) do
    if (TDomNode(FNodeList[I]).NamespaceURI = NamespaceURI)
      and (TDomNode(FNodeList[I]).LocalName = LocalName) then begin
      Result := TDomNode(FNodeList[I]);
      Break;
    end;
end;

function TDomNamedNodeMap.GetNamespaceAware: Boolean;
begin
  if Assigned(OwnerNode)
    then Result := OwnerNode.IsNamespaceNode
    else Result := FDefaultNamespaceAware;
end;

function TDomNamedNodeMap.GetReadOnly: Boolean;
begin
  if Assigned(OwnerNode)
    then Result := OwnerNode.IsReadonly
    else Result := False;
end;

procedure TDomNamedNodeMap.InternalAdd(const Node: TDomNode);
begin
  FNodeList.Add(Node);
  if (Node.NodeType = ntAttribute_Node)
    then (Node as TDomAttr).FOwnerMap := Self;
end;

procedure TDomNamedNodeMap.InternalRemove(const Node: TDomNode);
begin
  FNodeList.Remove(Node);
  if (Node.NodeType = ntAttribute_Node)
    then (Node as TDomAttr).FOwnerMap := nil;
end;

function TDomNamedNodeMap.RemoveItem(const Arg: TDomNode): TDomNode;
begin
  CheckNotReadOnly;
  CheckHasNode(Arg);
  Result := Arg;
  InternalRemove(Arg);
end;

{$IFDEF NEXTGEN}
function TDomNamedNodeMap.RemoveNamedItem(const Name: string): TDomNode;
{$ELSE !NEXTGEN}
function TDomNamedNodeMap.RemoveNamedItem(const Name: WideString): TDomNode;
{$ENDIF NEXTGEN}
begin
  CheckNotNamespaceAware;
  CheckNotReadOnly;
  Result := GetNamedItem(Name);
  if not Assigned(Result) then
    raise ENot_Found_Err.Create('Node not found error.');
  InternalRemove(Result);
end;

{$IFDEF NEXTGEN}
function TDomNamedNodeMap.RemoveNamedItemNS(const NamespaceURI,
                                                  LocalName: string): TDomNode;
{$ELSE !NEXTGEN}
function TDomNamedNodeMap.RemoveNamedItemNS(const NamespaceURI,
                                                  LocalName: WideString): TDomNode;
{$ENDIF NEXTGEN}
begin
  CheckNamespaceAware;
  CheckNotReadOnly;
  Result := GetNamedItemNS(NamespaceURI, LocalName);
  if not Assigned(Result) then
    raise ENot_Found_Err.Create('Node not found error.');
  InternalRemove(Result);
end;

function TDomNamedNodeMap.SetNamedItem(const Arg: TDomNode): TDomNode;
begin
  CheckNotNamespaceAware;
  CheckNotReadOnly;
  CheckSameRootDocument(Arg);
  CheckAllowedNodeType(Arg);
  CheckNotInUse(Arg);

  Result := GetNamedItem(Arg.NodeName);
  if Result = Arg then begin  // Is Arg already in the map?
    Result := nil;
  end else begin
    if Assigned(Result) then
      InternalRemove(Result);
    InternalAdd(Arg);
  end;
end;

function TDomNamedNodeMap.SetNamedItemNS(const Arg: TDomNode): TDomNode;
begin
  CheckNamespaceAware;
  CheckNotReadOnly;
  CheckSameRootDocument(Arg);
  CheckAllowedNodeType(Arg);
  CheckNotInUse(Arg);

  Result := GetNamedItemNS(Arg.NamespaceURI, Arg.LocalName);
  if Result = Arg then begin  // Is Arg already in the map?
    Result := nil;
  end else begin
    if Assigned(Result)
      then InternalRemove(Result);
    InternalAdd(Arg);
  end;
end;



//+++++++++++++++++++++++++++ TDomCustomNode ++++++++++++++++++++++++++++++
procedure TDomCustomNode.RaiseException(const E: {$IFDEF CLR}ExceptionClass{$ELSE}ExceptClass{$ENDIF});
begin
  if E = EHierarchyRequestError then
    raise EHierarchy_Request_Err.Create('EHierarchy request error.')

  else if E = ENoModificationAllowedError then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed.')

  else if E = ENotAssignedError then
    raise ENot_Supported_Err.Create('Node not specified.')

  else if E = ENotFoundError then
    raise ENot_Found_Err.Create('Node not found.')

  else if E = EWrongOwnerError then
    raise EWrong_Document_Err.Create('Wrong document.')

  else
    raise E.Create(E.ClassName);
end;



//++++++++++++++++++++++++++++++ TDomNode +++++++++++++++++++++++++++++++++
constructor TDomNode.Create(const AOwner: TCustomOwnedObject);
begin
  inherited Create(AOwner);
  FNodeList := TDomNodeList.Create(Items);
  FAllowedChildTypes := [ ntElement_Node,
                          ntText_Node,
                          ntCDATA_Section_Node,
                          ntEntity_Reference_Node,
                          ntProcessing_Instruction_Node,
                          ntComment_Node,
                          ntDocument_Type_Decl_Node,
                          ntDocument_Fragment_Node ];
  FIsNamespaceNode := False;
  if AOwner is TDomCustomDocument
    then FOwnerDocument := AOwner as TDomCustomDocument
    else FOwnerDocument := nil;
{$IFDEF VER200+}
  FNodeValues := TStringList.Create;
  FNodeValues.LineBreak := '';
  FNodeValues.WriteBOM := False;
{$ENDIF VER200+}
end;

destructor TDomNode.Destroy;
var
  I: Integer;
  UserDataEvent: TDomUserDataEvent;
begin
  // Call user data event handlers:
  if Assigned(FUserData) then
    for I := 0 to Pred(FUserData.Count) do begin
      UserDataEvent := FUserDataHandlers[I];
      if Assigned(UserDataEvent) then
        UserDataEvent(OT_NODE_DESTROYED, FUserData.WideStrings[I], FUserData.Objects[I], nil, nil);
    end;

{$IFDEF VER200+}
  FNodeValues.Free;
{$ENDIF VER200+}
  FNodeList.Free;
  FUserData.Free;
  FUserDataHandlers.Free;
  inherited Destroy;
end;

function TDomNode.AppendChild(const NewChild: TDomNode): TDomNode;
begin
  CheckTypeAllowed(NewChild);

  if NewChild is TDomDocumentFragment then begin

    CheckAssigned(NewChild);
    CheckSameOwner(NewChild);

    while NewChild.HasChildNodes do
      Append(NewChild.ChildNodes.Item(0));
    Result := NewChild;

  end else
    Result := Append(NewChild) as TDomNode;
end;

procedure TDomNode.CheckTypeAllowed(const Node: TDomNode);
var
  I: Integer;
begin
  if Assigned(Node) then begin
    if not (Node.NodeType in FAllowedChildTypes) then
      raise EHierarchy_Request_Err.CreateFmt(
        'Nodes of type %s are not allowed as children of nodes of type %s',
        [Node.ClassName, ClassName]
      );
    if Node is TDomDocumentFragment then
      for I := 0  to Pred(Node.ChildNodes.Length) do
        CheckTypeAllowed(Node.Childnodes.Item(I));
  end;
end;

procedure TDomNode.Clear;
begin
{$IFDEF VER200+}
  FNodeValues.Clear;
{$ENDIF VER200+}
  inherited Clear;
end;

function TDomNode.CloneNode(const Deep: Boolean): TDomNode;
var
  I: Integer;
  UserDataEvent: TDomUserDataEvent;
begin
  Result := RootDocument.ImportNode2(Self, Deep);

  // Call user data event handlers:
  if Assigned(Result) and Assigned(FUserData) then
    for I := 0 to Pred(FUserData.Count) do begin
      UserDataEvent := FUserDataHandlers[I];
      if Assigned(UserDataEvent) then
        UserDataEvent(OT_NODE_CLONED, FUserData.WideStrings[I], FUserData.Objects[I], Self, Result);
    end;
end;

function TDomNode.CompareDocumentPosition(const Other: TDomNode): TDomDocumentPosition;

  procedure BuildAncestorList(Node: TDomNode;
                              const Ancestors: TList<TDomNode>);
  begin
    Ancestors.Clear;
    while True do begin

      Ancestors.Insert(0, Node);

      if Assigned(Node.ParentNode) then begin
        Node := Node.ParentNode;
      end else begin
        case Node.NodeType of
          ntAttribute_Node:
            if Assigned(TDomAttr(Node).OwnerElement)
              then Node := TDomAttr(Node).OwnerElement
              else Break;
          ntXPath_Namespace_Node:
            if Assigned(TDomXPathNamespace(Node).OwnerElement)
              then Node := TDomXPathNamespace(Node).OwnerElement
              else Break;
        else
          Break;
        end;
      end;

    end; {while ...}
  end;

var
  SelfAncestors, OtherAncestors: TList<TDomNode>;
  I: Integer;
begin
  if not Assigned(Other) then
    raise ENot_Supported_Err.Create('Not supported error.');
  if Other = Self then begin
    Result := [Document_Position_Equivalent, Document_Position_Same_Node];
    Exit;
  end;

  SelfAncestors := TList<TDomNode>.Create;
  OtherAncestors := TList<TDomNode>.Create;
  try
    BuildAncestorList(Self, SelfAncestors);
    BuildAncestorList(Other, OtherAncestors);

    // Disconnected?
    if SelfAncestors[0] <> OtherAncestors[0] then begin
      Result := [Document_Position_Disconnected];
      Exit;
    end;

    // Reduce list to the last common ancestor:
    SelfAncestors.Add(nil);   // Add stop-nil
    OtherAncestors.Add(nil);  // Add stop-nil
    while SelfAncestors[1] = OtherAncestors[1] do begin
      SelfAncestors.Delete(0);
      OtherAncestors.Delete(0);
      // Remark: No run over, because 'self' and 'other' are not identical.
    end;

    // Is 'other' ancestor?
    if OtherAncestors.Count = 2 then begin // Remark: 2, because 'other' and nil are in the list.
      Result := [Document_Position_Contains, Document_Position_Preceding];
      Exit;
    end;

    // Is 'other' descendant?
    if SelfAncestors.Count = 2 then begin
      Result := [Document_Position_Contained_By, Document_Position_Following];
      Exit;
    end;

    // XPathNamespaces involved?
    if (TDomNode(SelfAncestors[1]).NodeType = ntXPath_Namespace_Node) then begin
      if (TDomNode(OtherAncestors[1]).NodeType = ntXPath_Namespace_Node)
        then Result := [Document_Position_Equivalent]
        else Result := [Document_Position_Following];
      Exit;
    end;
    if (TDomNode(OtherAncestors[1]).NodeType = ntXPath_Namespace_Node) then begin
      Result := [Document_Position_Preceding];
      Exit;
    end;

    // Attributes involved?
    if (TDomNode(SelfAncestors[1]).NodeType = ntAttribute_Node) then begin
      if (TDomNode(OtherAncestors[1]).NodeType = ntAttribute_Node)
        then Result := [Document_Position_Equivalent]
        else Result := [Document_Position_Following];
      Exit;
    end;
    if (TDomNode(OtherAncestors[1]).NodeType = ntAttribute_Node) then begin
      Result := [Document_Position_Preceding];
      Exit;
    end;

    // No Attributes or XPathNamespaces.  Determine the order of the nodes.
    for I := 0 to Pred(TDomNode(SelfAncestors[0]).ChildNodes.Length) do begin
      if TDomNode(SelfAncestors[0]).ChildNodes.Item(I) = SelfAncestors[1] then begin
        Result := [Document_Position_Following];
        Exit;
      end;
      if TDomNode(SelfAncestors[0]).ChildNodes.Item(I) = OtherAncestors[1] then begin
        Result := [Document_Position_Preceding];
        Exit;
      end;
    end;

  finally
    SelfAncestors.Free;
    OtherAncestors.Free;
  end;
end;

procedure TDomNode.DoAfterAddition(const Node: TCustomOwnedNode);
begin
  if Assigned(RootDocument) then
    RootDocument.DoNodeInserted(Node as TDomNode);
end;

procedure TDomNode.DoBeforeClear;
begin
  if Assigned(RootDocument) then
    RootDocument.DoNodeClearing(Self);
end;

procedure TDomNode.DoBeforeRemoval(const Node: TCustomOwnedNode);
begin
  if Assigned(RootDocument)
    then RootDocument.DoNodeRemoving(Node as TDomNode);
end;

{$IFDEF NEXTGEN}
function TDomNode.EvaluateToBoolean(const Expression: string): Boolean;
{$ELSE !NEXTGEN}
function TDomNode.EvaluateToBoolean(const Expression: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  XPathExpression: TXPathExpression;
begin
  XPathExpression := TXPathExpression.Create(nil);
  try
    XPathExpression.Expression := Expression;
    XPathExpression.ContextNode := Self;
    XPathExpression.Evaluate;
    Result := XPathExpression.ResultAsBoolean;
  finally
    XPathExpression.Free;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.EvaluateToNode(const Expression: string): TDomNode;
{$ELSE !NEXTGEN}
function TDomNode.EvaluateToNode(const Expression: WideString): TDomNode;
{$ENDIF NEXTGEN}
var
  XPathExpression: TXPathExpression;
begin
  XPathExpression := TXPathExpression.Create(nil);
  try
    XPathExpression.Expression := Expression;
    XPathExpression.ContextNode := Self;
    XPathExpression.Evaluate;
    Result := XPathExpression.ResultNode(0); // Remark: Returns nil, if there exists no ResultNode(0).
  finally
    XPathExpression.Free;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.EvaluateToNumber(const Expression: string): Double;
{$ELSE !NEXTGEN}
function TDomNode.EvaluateToNumber(const Expression: WideString): Double;
{$ENDIF NEXTGEN}
var
  XPathExpression: TXPathExpression;
begin
  XPathExpression := TXPathExpression.Create(nil);
  try
    XPathExpression.Expression := Expression;
    XPathExpression.ContextNode := Self;
    XPathExpression.Evaluate;
    Result := XPathExpression.ResultAsNumber;
  finally
    XPathExpression.Free;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.EvaluateToWideString(const Expression: string): string;
{$ELSE !NEXTGEN}
function TDomNode.EvaluateToWideString(const Expression: WideString): WideString;
{$ENDIF NEXTGEN}
var
  XPathExpression: TXPathExpression;
begin
  XPathExpression := TXPathExpression.Create(nil);
  try
    XPathExpression.Expression := Expression;
    XPathExpression.ContextNode := Self;
    XPathExpression.Evaluate;
    Result := XPathExpression.ResultAsWideString;
  finally
    XPathExpression.Free;
  end;
end;

function TDomNode.FindFirstChildElement: TDomElement;
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := FirstChild;
  while Assigned(NodeToTest) do begin
    if NodeToTest.NodeType = ntElement_Node then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.NextSibling;
  end;
end;

function TDomNode.FindLastChildElement: TDomElement;
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := LastChild;
  while Assigned(NodeToTest) do begin
    if NodeToTest.NodeType = ntElement_Node then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.PreviousSibling;
  end;
end;

function TDomNode.FindNextSiblingElement: TDomElement;
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := NextSibling;
  while Assigned(NodeToTest) do begin
    if NodeToTest.NodeType = ntElement_Node then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.NextSibling;
  end;
end;

function TDomNode.FindParentElement: TDomElement;
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := ParentNode;
  while Assigned(NodeToTest) do begin
    if NodeToTest.NodeType = ntElement_Node then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.ParentNode;
  end;
end;

function TDomNode.FindPreviousSiblingElement: TDomElement;
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := PreviousSibling;
  while Assigned(NodeToTest) do begin
    if NodeToTest.NodeType = ntElement_Node then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.PreviousSibling;
  end;
end;

function TDomNode.GetAbsoluteIndex: Integer;
var
  N: TDomNode;
begin
  N := PreviousNode;
  if Assigned(N) then begin
    Result := N.AbsoluteIndex;
    if Result > -1 then Inc(Result);
  end else Result := -1;
end;

function TDomNode.GetAttributes: TDomNamedNodeMap;
begin
  Result := nil;
end;

{$IFNDEF NEXTGEN}
function TDomNode.GetBaseUri: WideString;
var
  Attr: TDomAttr;
  UriAnalyzer: TUriWideStrAnalyzer;
  Uri1, Uri2: WideString;
begin
  case NodeType of
  ntElement_Node: begin
    if IsNamespaceNode
      then Attr := TDomElement(Self).GetAttributeNodeNS('http://www.w3.org/XML/1998/namespace','base')
      else Attr := TDomElement(Self).GetAttributeNode('xml:base');
    if Assigned(Attr) then begin

      Uri1 := Attr.Value;
      UriAnalyzer := TUriWideStrAnalyzer.Create;
      try
        UriAnalyzer.SetUriReference(Uri1);
        if UriAnalyzer.HasUriScheme then begin
          // absolute URI --> we are done
          Result := Attr.Value;
        end else begin
          Uri2 := Attr.BaseUri;
          ResolveRelativeUriWideStr(Uri2, Uri1, Result);
              // Remark: Returns an empty Result if ResolveRelativeUriWideStr attempt fails.
        end;
      finally
        UriAnalyzer.Free;
      end;

    end else begin
      if Assigned(ParentNode)
        then Result := ParentNode.BaseUri
        else Result := '';
    end; {if ... else ...}
  end;
  ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
  ntProcessing_Instruction_Node, ntComment_Node, ntDocument_Type_Decl_Node:
    if Assigned(ParentNode)
      then Result := ParentNode.BaseUri
      else Result := '';
  ntAttribute_Node: begin
    Result := '';
    if Assigned(TDomAttr(Self).OwnerElement) then begin
      if ( (NamespaceURI = 'http://www.w3.org/XML/1998/namespace') and ( LocalName = 'base') )
         or ( (NamespaceURI = '') and ( NodeName = 'xml:base') ) then begin
        if Assigned(TDomAttr(Self).OwnerElement.ParentNode)
          then Result := TDomAttr(Self).OwnerElement.ParentNode.BaseUri;
      end else Result := TDomAttr(Self).OwnerElement.BaseUri;
    end;
  end;
  else
    Result := '';
  end;
end;
{$ELSE NEXTGEN}
function TDomNode.GetBaseUri: DomString;
var
  Attr: TDomAttr;
  UriAnalyzer: TUriStrAnalyzer;
  Uri1, Uri2: DomString;
begin
  case NodeType of
  ntElement_Node: begin
    if IsNamespaceNode
      then Attr := TDomElement(Self).GetAttributeNodeNS('http://www.w3.org/XML/1998/namespace','base')
      else Attr := TDomElement(Self).GetAttributeNode('xml:base');
    if Assigned(Attr) then begin

      Uri1 := Attr.Value;
      UriAnalyzer := TUriStrAnalyzer.Create;
      try
        UriAnalyzer.SetUriReference(Uri1);
        if UriAnalyzer.HasUriScheme then begin
          // absolute URI --> we are done
          Result := Attr.Value;
        end else begin
          Uri2 := Attr.BaseUri;
          ResolveRelativeUriStr(Uri2, Uri1, Result);
              // Remark: Returns an empty Result if ResolveRelativeUriWideStr attempt fails.
        end;
      finally
        UriAnalyzer.Free;
      end;

    end else begin
      if Assigned(ParentNode)
        then Result := ParentNode.BaseUri
        else Result := '';
    end; {if ... else ...}
  end;
  ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
  ntProcessing_Instruction_Node, ntComment_Node, ntDocument_Type_Decl_Node:
    if Assigned(ParentNode)
      then Result := ParentNode.BaseUri
      else Result := '';
  ntAttribute_Node: begin
    Result := '';
    if Assigned(TDomAttr(Self).OwnerElement) then begin
      if ( (NamespaceURI = 'http://www.w3.org/XML/1998/namespace') and ( LocalName = 'base') )
         or ( (NamespaceURI = '') and ( NodeName = 'xml:base') ) then begin
        if Assigned(TDomAttr(Self).OwnerElement.ParentNode)
          then Result := TDomAttr(Self).OwnerElement.ParentNode.BaseUri;
      end else Result := TDomAttr(Self).OwnerElement.BaseUri;
    end;
  end;
  else
    Result := '';
  end;
end;
{$ENDIF NEXTGEN}

function TDomNode.GetChildNodes: TDomNodeList;
begin
  Result := FNodeList;
end;

function TDomNode.GetDocument: TDomCustomDocument;
begin
  Result := FOwnerDocument;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetExpandedName: string;
{$ELSE !NEXTGEN}
function TDomNode.GetExpandedName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '';
end;

function TDomNode.GetFirstChild: TDomNode;
begin
  Result := (inherited GetFirstChild as TDomNode);
end;

{$IFDEF NEXTGEN}
function TDomNode.GetFirstChildElement(const Name: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetFirstChildElement(const Name: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := FirstChild;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node) and (NodeToTest.NodeName = Name) then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.NextSibling;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetFirstChildElementNS(const NamespaceURI,
                                               LocalName: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetFirstChildElementNS(const NamespaceURI,
                                               LocalName: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := FirstChild;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node)
      and (NodeToTest.NamespaceURI = NamespaceURI)
      and (NodeToTest.LocalName = LocalName)
      then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.NextSibling;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetLanguage: string;
{$ELSE !NEXTGEN}
function TDomNode.GetLanguage: WideString;
{$ENDIF NEXTGEN}
var
  Attr: TDomAttr;
begin
  case NodeType of
  ntElement_Node: begin
    if IsNamespaceNode
      then Attr := TDomElement(Self).GetAttributeNodeNS('http://www.w3.org/XML/1998/namespace','lang')
      else Attr := TDomElement(Self).GetAttributeNode('xml:lang');
    if Assigned(Attr) then begin
      Result := Attr.Value;
    end else begin
      if Assigned(ParentNode)
        then Result := ParentNode.Language
        else Result := '';
    end; {if ... else ...}
  end;
  ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
  ntProcessing_Instruction_Node, ntComment_Node:
    if Assigned(ParentNode)
      then Result := ParentNode.Language
      else Result := '';
  ntAttribute_Node:
    if Assigned(TDomAttr(Self).OwnerElement)
      then Result := TDomAttr(Self).OwnerElement.Language
      else Result := '';
  ntXPath_Namespace_Node:
    if Assigned(TDomXPathNamespace(Self).OwnerElement)
      then Result := TDomXPathNamespace(Self).OwnerElement.Language
      else Result := '';
  else
    Result := '';
  end;
end;

function TDomNode.GetLastChild: TDomNode;
begin
  Result := (inherited GetLastChild as TDomNode);
end;

{$IFDEF NEXTGEN}
function TDomNode.GetLastChildElement(const Name: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetLastChildElement(const Name: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := LastChild;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node) and (NodeToTest.NodeName = Name) then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.PreviousSibling;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetLastChildElementNS(const NamespaceURI,
                                              LocalName: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetLastChildElementNS(const NamespaceURI,
                                              LocalName: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := LastChild;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node)
      and (NodeToTest.NamespaceURI = NamespaceURI)
      and (NodeToTest.LocalName = LocalName)
      then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.PreviousSibling;
  end;
end;

function TDomNode.GetLevel: Integer;
begin
  if Assigned(ParentNode) then begin
    Result := ParentNode.Level;
    if Result > -1 then Inc(Result);
  end else Result := -1;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetLocalName: string;
{$ELSE !NEXTGEN}
function TDomNode.GetLocalName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '';
end;

{$IFDEF NEXTGEN}
function TDomNode.GetNamespaceURI: string;
{$ELSE !NEXTGEN}
function TDomNode.GetNamespaceURI: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '';
end;

function TDomNode.GetNextSibling: TDomNode;
begin
  Result := (inherited GetNextSibling as TDomNode);
end;

{$IFDEF NEXTGEN}
function TDomNode.GetNextSiblingElement(const Name: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetNextSiblingElement(const Name: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := NextSibling;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node) and (NodeToTest.NodeName = Name) then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.NextSibling;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetNextSiblingElementNS(const NamespaceURI,
                                                LocalName: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetNextSiblingElementNS(const NamespaceURI,
                                                LocalName: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := NextSibling;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node)
      and (NodeToTest.NamespaceURI = NamespaceURI)
      and (NodeToTest.LocalName = LocalName)
      then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.NextSibling;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomNode.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '';
end;

function TDomNode.GetNodeType: TDomNodeType;
begin
  Result := ntUnknown;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetNodeValue: string;
{$ELSE !NEXTGEN}
function TDomNode.GetNodeValue: WideString;
{$ENDIF NEXTGEN}
begin
{$IFDEF VER200+}
  if FNodeValue = '' then
  begin
    if FNodeValues.Count = 1 then
      FNodeValue := FNodeValues.Strings[0]
    else
      FNodeValue := FNodeValues.Text;
  end;
{$ENDIF VER200+}
  Result := FNodeValue;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetParentElement(const Name: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetParentElement(const Name: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := ParentNode;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node) and (NodeToTest.NodeName = Name) then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.ParentNode;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetParentElementNS(const NamespaceURI,
                                           LocalName: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetParentElementNS(const NamespaceURI,
                                           LocalName: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := ParentNode;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node)
      and (NodeToTest.NamespaceURI = NamespaceURI)
      and (NodeToTest.LocalName = LocalName)
      then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.ParentNode;
  end;
end;

function TDomNode.GetParentNode: TDomNode;
begin
  Result := (inherited GetParent as TDomNode);
end;

{$IFDEF NEXTGEN}
function TDomNode.GetPrefix: string;
{$ELSE !NEXTGEN}
function TDomNode.GetPrefix: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '';
end;

function TDomNode.GetPreviousSibling: TDomNode;
begin
  Result := (inherited GetPreviousSibling as TDomNode);
end;

{$IFDEF NEXTGEN}
function TDomNode.GetPreviousSiblingElement(const Name: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetPreviousSiblingElement(const Name: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := PreviousSibling;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node) and (NodeToTest.NodeName = Name) then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.PreviousSibling;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetPreviousSiblingElementNS(const NamespaceURI,
                                                    LocalName: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomNode.GetPreviousSiblingElementNS(const NamespaceURI,
                                                    LocalName: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  NodeToTest: TDomNode;
begin
  Result := nil;
  NodeToTest := PreviousSibling;
  while Assigned(NodeToTest) do begin
    if (NodeToTest.NodeType = ntElement_Node)
      and (NodeToTest.NamespaceURI = NamespaceURI)
      and (NodeToTest.LocalName = LocalName)
      then begin
      Result := (NodeToTest as TDomElement);
      Exit;
    end;
    NodeToTest := NodeToTest.PreviousSibling;
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetUserData(const Key: string): TObject;
{$ELSE !NEXTGEN}
function TDomNode.GetUserData(const Key: WideString): TObject;
{$ENDIF NEXTGEN}
var
  Index: Integer;
begin
  if Assigned(FUserData) then begin
    Index := FUserData.IndexOf(Key);
    if Index = -1
      then Result := nil
      else Result := FUserData.Objects[Index];
  end else Result := nil;
end;

function TDomNode.GetRootDocument: TDomCustomDocument;
begin
  Result := OwnerDocument;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetTextContent: string;
{$ELSE !NEXTGEN}
function TDomNode.GetTextContent: WideString;
{$ENDIF NEXTGEN}
var
  ChildType: TDomNodeType;
  ChildItem: TDomNode;
  I, Cl: Integer;
  S: TUtilsCustomWideStr;
begin
  case NodeType of
    ntElement_Node, ntEntity_Reference_Node, ntDocument_Fragment_Node: begin
      S := TUtilsCustomWideStr.Create;
      try
        Cl := Pred(Childnodes.Length);
        for I := 0 to Cl do begin
          ChildItem := Childnodes.Item(I);
          ChildType := ChildItem.NodeType;
          if (ChildType <> ntComment_Node) and (ChildType <> ntProcessing_Instruction_Node) then
            S.AddWideString(ChildItem.TextContent);
        end;
        Result := S.Value;
      finally
        S.Free;
      end;
    end;
    ntAttribute_Node, ntText_Node, ntCDATA_Section_Node, ntComment_Node, ntProcessing_Instruction_Node:
      Result := NodeValue;
  else
    Result := '';
  end;
end;

{$IFDEF NEXTGEN}
function TDomNode.GetXPathStringValue: string;
{$ELSE !NEXTGEN}
function TDomNode.GetXPathStringValue: WideString;
{$ENDIF NEXTGEN}
begin
  case NodeType of
    ntElement_Node:
      Result := TextContent;
    ntAttribute_Node, ntComment_Node, ntProcessing_Instruction_Node, ntText_Node:
      Result := NodeValue;
    ntDocument_Node:
      if Assigned(TDomCustomDocument(Self).DocumentElement)
        then Result := TDomCustomDocument(Self).DocumentElement.TextContent
        else Result := '';
    ntXPath_Namespace_Node:
      Result := NamespaceUri;
  else
    Result := '';
  end;
end;

function TDomNode.HasAsAncestor(const Node: TDomNode): Boolean;
begin
  Result := inherited HasAsAncestor(Node);
end;

function TDomNode.HasAttributes: Boolean;
begin
  if Assigned(Attributes)
    then Result := Attributes.Length > 0
    else Result := False;
end;

function TDomNode.HasChildNodes: Boolean;
begin
  Result := HasChildren;
end;

{$IFDEF NEXTGEN}
function TDomNode.HasEntRef(const EntName: string): Boolean;
{$ELSE !NEXTGEN}
function TDomNode.HasEntRef(const EntName: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  Result := False;
  for I := 0 to Pred(Childnodes.Length) do
    if (Childnodes.Item(I).NodeType = ntEntity_Reference_Node)
        and (Childnodes.Item(I).NodeName = EntName)
      then Result := True
      else if Childnodes.Item(I).HasEntRef(EntName) then begin Result := True; Exit; end;
end;

function TDomNode.InsertBefore(const NewChild,
                                     RefChild: TDomNode): TDomNode;
begin
  CheckTypeAllowed(NewChild);

  if NewChild is TDomDocumentFragment then begin

    CheckAssigned(NewChild);
    CheckSameOwner(NewChild);
    CheckDissimilarity(NewChild, RefChild);

    while NewChild.HasChildNodes do
      InsertBefore(NewChild.ChildNodes.Item(0), RefChild);
    Result := NewChild;

  end else
    Result := inherited InsertBefore(NewChild, RefChild) as TDomNode;
end;

{$IFDEF NEXTGEN}
function TDomNode.LookupNamespaceURI(const APrefix: string): string;
{$ELSE !NEXTGEN}
function TDomNode.LookupNamespaceURI(const APrefix: WideString): WideString;
{$ENDIF NEXTGEN}
begin
  if APrefix = 'xml'
    then Result := 'http://www.w3.org/XML/1998/namespace'
    else if APrefix = 'xmlns'
      then Result := 'http://www.w3.org/2000/xmlns/'
      else Result := '';
end;

procedure TDomNode.MakeChildrenReadOnly;
var
  I: Integer;
begin
  for I := 0 to Pred(Childnodes.Length) do
  begin
    Childnodes.Item(I).SetReadOnly(True);
    Childnodes.Item(I).MakeChildrenReadOnly;
  end;
end;

procedure TDomNode.Normalize;
var
  I: Integer;
begin
  for I := 0 to Pred(ChildNodes.Length) do
    ChildNodes.Item(I).Normalize;
end;

function TDomNode.PreviousNode: TDomNode;
// Finds the previous node in document order.
var
  NewNode: TDomNode;
begin
  Result := PreviousSibling;
  if Assigned(Result) then begin
    NewNode := Result;
    while Assigned(NewNode) do begin
      Result := NewNode;
      NewNode := NewNode.LastChild;
    end;
  end else Result := ParentNode;
end;

function TDomNode.RemoveChild(const OldChild: TDomNode): TDomNode;
begin
  Result := (inherited Remove(OldChild) as TDomNode);
end;

function TDomNode.ReplaceChild(const NewChild,
                                     OldChild: TDomNode): TDomNode;
var
  LastFragmentChild: TDomNode;
begin
  CheckTypeAllowed(NewChild);

  if NewChild is TDomDocumentFragment then begin

    CheckAssigned(NewChild);
    CheckSameOwner(NewChild);
    CheckHasChild(OldChild);

    LastFragmentChild := NewChild.LastChild;
    if Assigned(LastFragmentChild) then begin
      Result := ReplaceChild(LastFragmentChild, OldChild);
      while NewChild.HasChildNodes do
        InsertBefore(NewChild.ChildNodes.Item(0), LastFragmentChild);
    end else
      Result := RemoveChild(OldChild);

  end else
    Result := inherited Replace(NewChild, OldChild) as TDomNode;
end;

{$IFDEF NEXTGEN}
procedure TDomNode.SetNodeValue(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomNode.SetNodeValue(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  if IsReadonly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');
  FNodeValue := Value;
{$IFDEF VER200+}
  FNodeValues.Clear;
{$ENDIF VER200+}
end;

{$IFDEF NEXTGEN}
procedure TDomNode.SetPrefix(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomNode.SetPrefix(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  if IsReadonly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');
end;

{$IFDEF CLR}
procedure TDomNode.SetReadOnly(const Value: Boolean);
begin
  inherited;
end;
{$ENDIF}

{$IFDEF NEXTGEN}
function TDomNode.SetUserData(const Key: string;
                              const Data: TObject;
                              const Handler: TDomUserDataEvent): TObject;
{$ELSE !NEXTGEN}
function TDomNode.SetUserData(const Key: WideString;
                              const Data: TObject;
                              const Handler: TDomUserDataEvent): TObject;
{$ENDIF NEXTGEN}
var
  Index: Integer;
begin
  if Assigned(Data) then begin

    if Assigned(FUserData) then begin
      Index := FUserData.IndexOf(Key);
      if Index = -1 then begin
        Result := nil;
        FUserData.AddObject(Key, Data);
        FUserDataHandlers.Add(Handler);
      end else begin
        Result := FUserData.Objects[Index];
        FUserData.WideStrings[Index] := Key;
        FUserData.Objects[Index] := Data;
        FUserDataHandlers[Index] := Handler;
      end;
    end else begin
      FUserData := TUtilsWideStringList.Create;
      FUserDataHandlers := TList<TDomUserDataEvent>.Create;
      Result := nil;
      FUserData.AddObject(Key, Data);
      FUserDataHandlers.Add(Handler);
    end;

  end else begin

    if Assigned(FUserData) then begin
      Index := FUserData.IndexOf(Key);
      if Index > -1 then begin
        Result := FUserData.Objects[Index];
        FUserData.Delete(Index);
        FUserDataHandlers.Delete(Index);
        if FUserData.Count = 0 then begin
          FUserData.Free;
          FUserData := nil;
          FUserDataHandlers.Free;
          FUserDataHandlers := nil;
        end;
      end else
        Result := nil;
    end else
      Result := nil;

  end;
end;

{$IFDEF VER200+}
{$IFDEF NEXTGEN}
procedure TDomNode.AddNodeValue(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomNode.AddNodeValue(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  if (FNodeValues.Count = 0) and (FNodeValue <> '') then
    FNodeValues.Append(FNodeValue+Value)
  else
    FNodeValues.Append(Value);
  FNodeValue := '';
end;
{$ENDIF VER200+}


//+++++++++++++++++++++++++ TDomCharacterData ++++++++++++++++++++++++++++
constructor TDomCharacterData.Create(const AOwner: TDomCustomDocument);
begin
  inherited Create(AOwner);
  FAllowedChildTypes := [];
end;

{$IFDEF NEXTGEN}
procedure TDomCharacterData.AppendData(const Arg: string);
{$ELSE !NEXTGEN}
procedure TDomCharacterData.AppendData(const Arg: WideString);
{$ENDIF NEXTGEN}
begin
  if IsReadonly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');
{$IFDEF VER200+}
  AddNodeValue(Arg);
{$ELSE !VER200+}
  Data := Concat(Data, Arg);
{$ENDIF VER200+}
end;

procedure TDomCharacterData.deleteData(const Offset,
                                             Count: Integer);
begin
  ReplaceData(Offset, Count, '');
end;

procedure TDomCharacterData.DoCharacterDataModified;
begin
  if Assigned(RootDocument)
    then RootDocument.DoCharacterDataModified(Self);
end;

{$IFDEF NEXTGEN}
function TDomCharacterData.GetData: string;
{$ELSE !NEXTGEN}
function TDomCharacterData.GetData: WideString;
{$ENDIF NEXTGEN}
begin
  Result := NodeValue;
end;

function TDomCharacterData.GetLength: Integer;
begin
  Result := {$IFDEF CLR}Borland.Delphi.{$ENDIF}System.Length(Data);
end;

{$IFDEF NEXTGEN}
procedure TDomCharacterData.InsertData(const Offset: Integer;
                                       const Arg: string);
{$ELSE !NEXTGEN}
procedure TDomCharacterData.InsertData(const Offset: Integer;
                                       const Arg: WideString);
{$ENDIF NEXTGEN}
begin
  ReplaceData(Offset, 0, Arg);
end;

{$IFDEF NEXTGEN}
procedure TDomCharacterData.ReplaceData(const Offset,
                                              Count: Integer;
                                        const Arg: string);
var
  Len: Integer;
  Data1, Data2: string;
{$ELSE !NEXTGEN}
procedure TDomCharacterData.ReplaceData(const Offset,
                                              Count: Integer;
                                        const Arg: WideString);
var
  Len: Integer;
  Data1, Data2: WideString;
{$ENDIF NEXTGEN}
begin
  if IsReadonly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');
  if (Offset < 0) or (Offset > Length) or (Count < 0) then
    raise EIndex_Size_Err.Create('Index size error.');
  // Make sure, that the length of the WideString is not
  // exeeded, when using Count and Offset:
  Len := Length - Offset;
  if Count < Len then Len := Count;
  Data1 := SubstringData(0, Offset);
  Data2 := SubstringData(Offset + Len, Length - Offset - Len);
  Data := Concat(Data1, Arg, Data2);
end;

{$IFDEF NEXTGEN}
procedure TDomCharacterData.SetData(const Value: string);
begin
  NodeValue := Value;
  DoCharacterDataModified;
end;
{$ELSE !NEXTGEN}
procedure TDomCharacterData.SetData(const Value: WideString);
var
  PrevValue: WideString;
begin
  PrevValue := NodeValue;
  NodeValue := Value;
  DoCharacterDataModified;
end;
{$ENDIF NEXTGEN}

{$IFDEF NEXTGEN}
function TDomCharacterData.SubstringData(const Offset,
                                               Count: Integer): string;
{$ELSE !NEXTGEN}
function TDomCharacterData.SubstringData(const Offset,
                                               Count: Integer): WideString;
{$ENDIF NEXTGEN}
var
  Len: Integer;
begin
  if (Offset < 0) or (Offset > Length) or (Count < 0) then
    raise EIndex_Size_Err.Create('Index size error.');
  // Make sure, that the length of the WideString is not
  // exeeded, when using Count and Offset:
  Len := Length - Offset;
  if Count < Len then Len := Count;
{$IFDEF CLR}
  Result := Copy(Data, Offset, Len);
{$ELSE}
  SetString(Result, PWideChar(Data) + Offset, Len);
{$ENDIF}
end;



// +++++++++++++++++++++++++++++++ TDomAttr +++++++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomAttr.Create(const AOwner: TDomDocument;
                            const Name: string;
                            const Spcfd: Boolean);
{$ELSE !NEXTGEN}
constructor TDomAttr.Create(const AOwner: TDomDocument;
                            const Name: WideString;
                            const Spcfd: Boolean);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(Name)
    then raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwner);
  if IsXmlDefaultAttName(Name) then begin
    FIsXmlnsDecl:= NSDT_DEFAULT;
  end else if IsXmlPrefixedAttName(Name) then begin
    FIsXmlnsDecl:= NSDT_PREFIXED;
  end else FIsXmlnsDecl:= NSDT_NONE;
  FNodeName := Name;
  FNodeValue := '';
  FPrefix := '';
  FSpecified := Spcfd;
  FAllowedChildTypes := [];
end;

{$IFDEF NEXTGEN}
constructor TDomAttr.CreateNS(const AOwner: TDomDocumentNS;
                              const NamespaceURI,
                                    QualifiedName: string;
                              const Spcfd: Boolean);
var
  LocName, Prfx: string;
{$ELSE !NEXTGEN}
constructor TDomAttr.CreateNS(const AOwner: TDomDocumentNS;
                              const NamespaceURI,
                                    QualifiedName: WideString;
                              const Spcfd: Boolean);
var
  LocName, Prfx: WideString;
{$ENDIF NEXTGEN}
begin
  if not XmlExtractPrefixAndLocalName(QualifiedName, Prfx, LocName) then begin
    if not IsXmlName(QualifiedName)
      then raise EInvalid_Character_Err.Create('Invalid character error.')
      else raise ENamespace_Err.Create('Namespace error.');
  end;

  if Prfx = 'xmlns' then begin
    if not (NamespaceURI = 'http://www.w3.org/2000/xmlns/') then
      raise ENamespace_Err.Create('Namespace error.');
    FIsXmlnsDecl := NSDT_PREFIXED;
  end else if QualifiedName = 'xmlns' then begin
    if not (NamespaceURI = 'http://www.w3.org/2000/xmlns/') then
      raise ENamespace_Err.Create('Namespace error.');
    FIsXmlnsDecl := NSDT_DEFAULT;
  end else begin
    if NamespaceURI = 'http://www.w3.org/2000/xmlns/' then
      raise ENamespace_Err.Create('Namespace error.');
    FIsXmlnsDecl := NSDT_NONE;
  end;

  if (NamespaceURI = '') and (Prfx <> '') then
    raise ENamespace_Err.Create('Namespace error.');

  if (Prfx = 'xml') then begin
    if (NamespaceURI <> 'http://www.w3.org/XML/1998/namespace') then
      raise ENamespace_Err.Create('Namespace error.');
  end else if NamespaceURI = 'http://www.w3.org/XML/1998/namespace' then
    raise ENamespace_Err.Create('Namespace error.');

  inherited Create(AOwner);
  FNodeName := QualifiedName;
  FNamespaceURI := NamespaceURI;
  FPrefix := Prfx;
  FLocalName := LocName;
  FIsNamespaceNode := True;
  FNodeValue := '';
  FSpecified := Spcfd;
  FAllowedChildTypes := [];
end;

destructor TDomAttr.Destroy;
var
  OldReadOnly: Boolean;
  Temp: TDomElement;
begin
  Temp := OwnerElement;
  if Assigned(Temp) then begin
    OldReadOnly := Temp.IsReadOnly;
    Temp.SetReadOnly(False);
    try
      Temp.RemoveAttributeNode(Self)
    finally
      Temp.SetReadOnly(OldReadonly);
    end;
  end;
  inherited;
end;

procedure TDomAttr.DoAttrModified(const AttrChange: TDomAttrChange);
begin
  if Assigned(OwnerElement)
    then OwnerElement.DoAttrModified(OwnerElement, AttrChange, Self);
end;

function TDomAttr.GetDataType: TXmlDataType;
begin
  if Assigned(RootDocument) and Assigned(OwnerElement) then
    Result := RootDocument.GetAttrDataType(OwnerElement.NodeName, NodeName)
  else
    Result := AS_STRING_DATATYPE;
end;

{$IFDEF NEXTGEN}
function TDomAttr.GetExpandedName: string;
{$ELSE !NEXTGEN}
function TDomAttr.GetExpandedName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := NodeName;
end;

function TDomAttr.GetIsXmlnsDecl: TDomXmlnsDeclType;
begin
  Result := FIsXmlnsDecl;
end;

{$IFDEF NEXTGEN}
function TDomAttr.GetLocalName: string;
{$ELSE !NEXTGEN}
function TDomAttr.GetLocalName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FLocalName;
end;

{$IFDEF NEXTGEN}
function TDomAttr.GetName: string;
{$ELSE !NEXTGEN}
function TDomAttr.GetName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := NodeName;
end;

{$IFDEF NEXTGEN}
function TDomAttr.GetNamespaceURI: string;
{$ELSE !NEXTGEN}
function TDomAttr.GetNamespaceURI: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNamespaceURI;
end;

function TDomAttr.GetNextSibling: TDomNode;
begin
  Result := nil;
end;

{$IFDEF NEXTGEN}
function TDomAttr.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomAttr.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNodeName;
end;

function TDomAttr.GetNodeType: TDomNodeType;
begin
  Result := ntAttribute_Node;
end;

function TDomAttr.GetOwnerElement: TDomElement;
var
  Node: TDomNode;
begin
  if Assigned(FOwnerMap) then begin
    Node := FOwnerMap.OwnerNode;
    if Node.NodeType = ntElement_Node
      then Result := (Node as TDomElement)
      else Result := nil;
  end else Result := nil;
end;

{$IFDEF NEXTGEN}
function TDomAttr.GetPrefix: string;
{$ELSE !NEXTGEN}
function TDomAttr.GetPrefix: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FPrefix;
end;

function TDomAttr.GetPreviousSibling: TDomNode;
begin
  Result := nil;
end;

function TDomAttr.GetSpecified: Boolean;
begin
  Result := FSpecified;
end;

{$IFDEF NEXTGEN}
function TDomAttr.GetValue: string;
{$ELSE !NEXTGEN}
function TDomAttr.GetValue: WideString;
{$ENDIF NEXTGEN}
var
  Error: TXmlErrorType;
begin
  RootDocument.CalculateNormalizedAttrValue(NodeValue, DataType, Result, Error);
  if not (Error in ET_WARNINGS) then
    raise EConvertError.Create('Attribute value normalization failed.');
end;

{$IFDEF NEXTGEN}
function TDomAttr.LookupNamespaceURI(const APrefix: string): string;
{$ELSE !NEXTGEN}
function TDomAttr.LookupNamespaceURI(const APrefix: WideString): WideString;
{$ENDIF NEXTGEN}
begin
  if APrefix = '' then begin
    Result := '';
  end else begin
    if Assigned(OwnerElement)
      then Result := OwnerElement.LookupNamespaceURI(APrefix)
      else Result := inherited LookupNamespaceURI(APrefix);
  end;
end;

{$IFDEF NEXTGEN}
procedure TDomAttr.SetNodeValue(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomAttr.SetNodeValue(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
   DoAttrModified(AC_MODIFICATION);
end;

{$IFDEF NEXTGEN}
procedure TDomAttr.SetPrefix(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomAttr.SetPrefix(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  if Value = '' then begin
    FPrefix := '';
    FNodeName := LocalName;
    Exit;
  end;

  if IsReadonly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');

  if NodeName = 'xmlns' then
    raise ENamespace_Err.Create('Namespace error.');

  if NamespaceURI = 'http://www.w3.org/2000/xmlns/' then begin
    if Value <> 'xmlns' then
      raise ENamespace_Err.Create('Namespace error.');
  end else if NamespaceURI = 'http://www.w3.org/XML/1998/namespace' then begin
    if Value <> 'xml' then
      raise ENamespace_Err.Create('Namespace error.');
  end else begin
    if (NamespaceURI = '') and (Value <> '') then
      raise ENamespace_Err.Create('Namespace error.');
    if Value = 'xml' then
      raise ENamespace_Err.Create('Namespace error.');
    if Value = 'xmlns' then
      raise ENamespace_Err.Create('Namespace error.');
  end;

  if not IsXmlName(Value) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  if not IsXmlPrefix(Value) then
    raise ENamespace_Err.Create('Namespace error.');

  FPrefix := Value;
  FNodeName := Concat(Value, ':', LocalName);
end;



//++++++++++++++++++++++++++++ TDomElement ++++++++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomElement.Create(const AOwner: TDomDocument;
                               const TagName: string);
{$ELSE !NEXTGEN}
constructor TDomElement.Create(const AOwner: TDomDocument;
                               const TagName: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(TagName) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwner);
  FNodeName := TagName;
  FNodeValue := '';
  FPrefix := '';
  FAttributeListing := TList<TCustomOwnedNode>.Create;
  FCreatedElementsNodeLists := TList<TDomNodeList>.Create;
  FCreatedElementsNodeListNSs := TList<TDomNodeList>.Create;
  FAttributeList := TDomNamedNodeMap.Create(Self, FAttributeListing, [ntAttribute_Node], False);
  FAllowedChildTypes := [ ntElement_Node,
                          ntText_Node,
                          ntCDATA_Section_Node,
                          ntEntity_Reference_Node,
                          ntProcessing_Instruction_Node,
                          ntComment_Node,
                          ntDocument_Fragment_Node ];
end;

{$IFDEF NEXTGEN}
constructor TDomElement.CreateNS(const AOwner: TDomDocumentNS;
                                 const NamespaceURI,
                                       QualifiedName: string);
var
  locName,prfx: string;
{$ELSE !NEXTGEN}
constructor TDomElement.CreateNS(const AOwner: TDomDocumentNS;
                                 const NamespaceURI,
                                       QualifiedName: WideString);
var
  locName,prfx: WideString;
{$ENDIF NEXTGEN}
begin
  if not XmlExtractPrefixAndLocalName(QualifiedName, Prfx, LocName) then begin
    if not IsXmlName(QualifiedName)
      then raise EInvalid_Character_Err.Create('Invalid character error.')
      else raise ENamespace_Err.Create('Namespace error.');
  end;

  if (Prfx = 'xmlns') or (NamespaceURI = 'http://www.w3.org/2000/xmlns/') then
    raise ENamespace_Err.Create('Namespace error.');

  if (NamespaceURI = '') and (Prfx <> '') then
    raise ENamespace_Err.Create('Namespace error.');

  if (Prfx = 'xml') then begin
    if (NamespaceURI <> 'http://www.w3.org/XML/1998/namespace') then
      raise ENamespace_Err.Create('Namespace error.');
  end else if NamespaceURI = 'http://www.w3.org/XML/1998/namespace' then
    raise ENamespace_Err.Create('Namespace error.');

  inherited Create(AOwner);

  FNodeName:= QualifiedName;
  FNamespaceURI:= NamespaceURI;
  FPrefix := Prfx;
  FLocalName := LocName;
  FIsNamespaceNode:= True;
  FNodeValue := '';
  FAttributeListing:= TList<TCustomOwnedNode>.Create;
  FCreatedElementsNodeLists:= TList<TDomNodeList>.Create;
  FCreatedElementsNodeListNSs:= TList<TDomNodeList>.Create;
  FAttributeList:= TDomNamedNodeMap.Create(Self,FAttributeListing,[ntAttribute_Node],True);
  FAllowedChildTypes:= [ntElement_Node,
                        ntText_Node,
                        ntCDATA_Section_Node,
                        ntEntity_Reference_Node,
                        ntProcessing_Instruction_Node,
                        ntComment_Node,
                        ntDocument_Fragment_Node];
end;

destructor TDomElement.Destroy;
{$IFNDEF AUTOREFCOUNT}
var
  I: Integer;
{$ENDIF !AUTOREFCOUNT}
begin
  ReadOnly := False;
  DoBeforeClear; // Removes all attached attribute nodes.
  FAttributeList.Free;
  FAttributeList := nil;
  FAttributeListing.Free;
{$IFNDEF AUTOREFCOUNT}
  if Assigned(FCreatedElementsNodeLists) then
    for I := 0 to Pred(FCreatedElementsNodeLists.Count) do
      TDomElementsNodeList(FCreatedElementsNodeLists[I]).Free;
  if Assigned(FCreatedElementsNodeListNSs) then
    for I := 0 to Pred(FCreatedElementsNodeListNSs.Count) do
      TDomElementsNodeListNS(FCreatedElementsNodeListNSs[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedElementsNodeLists.Free;
  FCreatedElementsNodeListNSs.Free;
  inherited Destroy;
end;

procedure TDomElement.DoAttrModified(const originalTarget: TDomNode;
                                     const AttrChange: TDomAttrChange;
                                     const RelatedAttr: TDomAttr);
begin
  if Assigned(RootDocument)
    then RootDocument.DoAttrModified(OriginalTarget, AttrChange, RelatedAttr);
end;

procedure TDomElement.DoBeforeClear;
var
  OldAttr: TDomAttr;
begin
  while HasAttributes do begin
    OldAttr := RemoveAttributeNode(Attributes.Item(0) as TDomAttr);
    OldAttr.Free;
  end;
end;

{$IFDEF NEXTGEN}
function TDomElement.GetTagName: string;
{$ELSE !NEXTGEN}
function TDomElement.GetTagName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := NodeName;
end;

function TDomElement.GetAttributes: TDomNamedNodeMap;
begin
  Result := FAttributeList;
end;

{$IFDEF NEXTGEN}
function TDomElement.GetAttributeLiteralValue(const Name: string): string;
{$ELSE !NEXTGEN}
function TDomElement.GetAttributeLiteralValue(const Name: WideString): WideString;
{$ENDIF NEXTGEN}
var
  Attr: TDomAttr;
begin
  Attr := GetAttributeNode(Name);
    // Raises ENamespace_Err, if attributes.namespaceAware is 'True'.
  if Assigned(Attr)
    then Result := ResolveCharRefs(Attr.NodeValue)
    else Result := '';
end;

{$IFDEF NEXTGEN}
function TDomElement.GetAttributeNode(const Name: string): TDomAttr;
{$ELSE !NEXTGEN}
function TDomElement.GetAttributeNode(const Name: WideString): TDomAttr;
{$ENDIF NEXTGEN}
begin
  Result := TDomAttr(Attributes.GetNamedItem(Name));
    // Raises ENamespace_Err, if attributes.namespaceAware is 'True'.
end;

{$IFDEF NEXTGEN}
function TDomElement.GetAttributeNodeNS(const NamespaceURI,
                                              LocalName: string): TDomAttr;
{$ELSE !NEXTGEN}
function TDomElement.GetAttributeNodeNS(const NamespaceURI,
                                              LocalName: WideString): TDomAttr;
{$ENDIF NEXTGEN}
begin
  Result := TDomAttr(Attributes.GetNamedItemNS(NamespaceURI, LocalName));
    // Raises ENamespace_Err, if attributes.namespaceAware is 'False'.
end;

{$IFDEF NEXTGEN}
function TDomElement.GetAttributeNormalizedValue(const Name: string): string;
{$ELSE !NEXTGEN}
function TDomElement.GetAttributeNormalizedValue(const Name: WideString): WideString;
{$ENDIF NEXTGEN}
var
  Attr: TDomAttr;
begin
  Attr := GetAttributeNode(Name);  // Raises ENamespace_Err, if attributes.namespaceAware is 'True'.
  if Assigned(Attr) then begin
    try
      Result := Attr.Value;
    except
      raise EConvertError.Create('Literal attribute value cannot be resolved.');
    end;
  end else Result := '';
end;

{$IFDEF NEXTGEN}
function TDomElement.GetAttributeNSLiteralValue(const NamespaceURI,
                                                      LocalName: string): string;
{$ELSE !NEXTGEN}
function TDomElement.GetAttributeNSLiteralValue(const NamespaceURI,
                                                      LocalName: WideString): WideString;
{$ENDIF NEXTGEN}
var
  Attr: TDomAttr;
begin
  Attr := GetAttributeNodeNS(NamespaceURI, LocalName); // Raises ENamespace_Err, if attributes.namespaceAware is 'False'.
  if Assigned(Attr)
    then Result := ResolveCharRefs(Attr.NodeValue)
    else Result := '';
end;

{$IFDEF NEXTGEN}
function TDomElement.GetAttributeNSNormalizedValue(const NamespaceURI,
                                                         LocalName: string): string;
{$ELSE !NEXTGEN}
function TDomElement.GetAttributeNSNormalizedValue(const NamespaceURI,
                                                         LocalName: WideString): WideString;
{$ENDIF NEXTGEN}
var
  Attr: TDomAttr;
begin
  Attr := GetAttributeNodeNS(NamespaceURI, LocalName); // Raises ENamespace_Err, if attributes.namespaceAware is 'False'.
  if Assigned(Attr) then begin
    try
      Result := Attr.Value;
    except
      raise EConvertError.Create('Literal attribute value cannot be resolved.');
    end;
  end else Result := '';
end;

{$IFDEF NEXTGEN}
function TDomElement.GetElementsByTagName(const Name: string): TDomNodeList;
{$ELSE !NEXTGEN}
function TDomElement.GetElementsByTagName(const Name: WideString): TDomNodeList;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  for I := 0 to Pred(FCreatedElementsNodeLists.Count) do
    if TDomElementsNodeList(FCreatedElementsNodeLists[I]).FQueryName = Name
      then begin Result := TDomElementsNodeList(FCreatedElementsNodeLists[I]); Exit; end;
  Result := TDomElementsNodeList.Create(Name, Self);
  FCreatedElementsNodeLists.Add(Result);
end;

{$IFDEF NEXTGEN}
function TDomElement.GetElementsByTagNameNS(const NamespaceURI,
                                                  LocalName: string): TDomNodeList;
{$ELSE !NEXTGEN}
function TDomElement.GetElementsByTagNameNS(const NamespaceURI,
                                                  LocalName: WideString): TDomNodeList;
{$ENDIF NEXTGEN}
var
  I: Integer;
  NL: TDomElementsNodeListNS;
begin
  for I := 0 to Pred(FCreatedElementsNodeListNSs.Count) do begin
    NL := TDomElementsNodeListNS(FCreatedElementsNodeListNSs[I]);
    if (NL.FQueryNamespaceURI = NamespaceURI) and (NL.FQueryLocalName = LocalName)
      then begin Result := NL; Exit; end;
  end;
  Result := TDomElementsNodeListNS.Create(NamespaceURI, LocalName, Self);
  FCreatedElementsNodeListNSs.Add(Result);
end;

{$IFDEF NEXTGEN}
function TDomElement.GetExpandedName: string;
{$ELSE !NEXTGEN}
function TDomElement.GetExpandedName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := NodeName;
end;

{$IFDEF NEXTGEN}
function TDomElement.GetLocalName: string;
{$ELSE !NEXTGEN}
function TDomElement.GetLocalName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FLocalName;
end;

{$IFDEF NEXTGEN}
function TDomElement.GetNamespaceURI: string;
{$ELSE !NEXTGEN}
function TDomElement.GetNamespaceURI: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNamespaceURI;
end;

{$IFDEF NEXTGEN}
function TDomElement.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomElement.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNodeName;
end;

function TDomElement.GetNodeType: TDomNodeType;
begin
  Result := ntElement_Node;
end;

{$IFDEF NEXTGEN}
function TDomElement.GetPrefix: string;
{$ELSE !NEXTGEN}
function TDomElement.GetPrefix: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FPrefix;
end;

{$IFDEF NEXTGEN}
function TDomElement.HasAttribute(const Name: string): Boolean;
{$ELSE !NEXTGEN}
function TDomElement.HasAttribute(const Name: WideString): Boolean;
{$ENDIF NEXTGEN}
begin
  Result := Assigned(Attributes.GetNamedItem(Name));
end;

{$IFDEF NEXTGEN}
function TDomElement.HasAttributeNS(const NamespaceURI,
                                          LocalName: string): Boolean;
{$ELSE !NEXTGEN}
function TDomElement.HasAttributeNS(const NamespaceURI,
                                          LocalName: WideString): Boolean;
{$ENDIF NEXTGEN}
begin
  Result := Assigned(Attributes.GetNamedItemNS(NamespaceURI, LocalName));
end;

{$IFDEF NEXTGEN}
function TDomElement.LookupNamespaceURI(const APrefix: string): string;
{$ELSE !NEXTGEN}
function TDomElement.LookupNamespaceURI(const APrefix: WideString): WideString;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  if APrefix = '' then begin
    for I := 0 to Pred(Attributes.Length) do
      if TDomAttr(Attributes.Item(I)).IsXmlnsDecl = NSDT_DEFAULT then begin
        Result := Attributes.Item(I).NodeValue;
        Exit;
      end;
  end else begin
    for I := 0 to Pred(Attributes.Length) do
      if (TDomAttr(Attributes.Item(I)).IsXmlnsDecl = NSDT_PREFIXED) and (Attributes.Item(I).LocalName = APrefix) then begin
        Result := Attributes.Item(I).NodeValue;
        Exit;
      end;
  end;
  if Assigned(ParentNode)
    then Result := ParentNode.LookupNamespaceURI(APrefix)
    else Result := inherited LookupNamespaceURI(APrefix);
end;

procedure TDomElement.Normalize;
var
  PrevNode, CurrentNode: TDomNode;
  I: Integer;
begin
  {Normalize text:}
  PrevNode := nil;
  I := ChildNodes.Length;
  while I > 0 do
  begin
    Dec(I);
    CurrentNode := ChildNodes.Item(I);
    if (CurrentNode.NodeType = ntText_Node) then
      begin
         if (Assigned(PrevNode)) and (PrevNode.NodeType = ntText_Node) then begin
            (CurrentNode as TDomText).AppendData((PrevNode as TDomText).Data);
            if (PrevNode as TDomText).CharRefGenerated then
              (CurrentNode as TDomText).CharRefGenerated := True;
            PrevNode.Free;  // Removes and frees the node.
         end;
      end
    else  // no text node, then normalize
      CurrentNode.Normalize;
    PrevNode := CurrentNode;
  end;

  {Normalize attributes:}
  for I := 0 to Attributes.Length - 1 do
    Attributes.Item(I).Normalize;
end;

{$IFDEF NEXTGEN}
function TDomElement.RemoveAttribute(const Name: string): TDomAttr;
{$ELSE !NEXTGEN}
function TDomElement.RemoveAttribute(const Name: WideString): TDomAttr;
{$ENDIF NEXTGEN}
begin
  Result := RemoveAttributeNode(GetAttributeNode(Name));
     // GetAttributeNode() raises an ENamespace_Err if attributes.namespaceAware is 'True'.
     // RemoveAttributeNode() raises an ENo_Modification_Allowed_Err if readonly, ...
     // ... and an ENot_Found_Err if the node was not found.
end;

function TDomElement.RemoveAttributeNode(const OldAttr: TDomAttr): TDomAttr;
begin
  Result := Attributes.RemoveItem(OldAttr) as TDomAttr;
     // Raises an ENo_Modification_Allowed_Err if readonly, ...
     // ... and an ENot_Found_Err if the node was not found.

  DoAttrModified(Self, AC_REMOVAL, OldAttr);
end;

{$IFDEF NEXTGEN}
function TDomElement.RemoveAttributeNS(const NamespaceURI,
                                             LocalName: string): TDomAttr;
{$ELSE !NEXTGEN}
function TDomElement.RemoveAttributeNS(const NamespaceURI,
                                             LocalName: WideString): TDomAttr;
{$ENDIF NEXTGEN}
begin
  Result := RemoveAttributeNode(GetAttributeNodeNS(NamespaceURI, LocalName));
     // GetAttributeNodeNS() raises ENamespace_Err if attributes.namespaceAware is 'False'.
     // RemoveAttributeNode() raises an ENo_Modification_Allowed_Err if readonly, ...
     // ... and an ENot_Found_Err if the node was not found.
end;

{$IFDEF NEXTGEN}
function TDomElement.SetAttribute(const Name,
                                        Value: string): TDomAttr;
{$ELSE !NEXTGEN}
function TDomElement.SetAttribute(const Name,
                                        Value: WideString): TDomAttr;
{$ENDIF NEXTGEN}
var
  Attr: TDomAttr;
begin
  if IsReadonly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');
  Attr := GetAttributeNode(Name);
    // Raises ENamespace_Err, if attributes.namespaceAware is 'True'.
  if Assigned(Attr) then begin
    Attr.NodeValue := Value;
    Result := nil;
  end else begin
    Result := TDomAttr.Create(RootDocument as TDomDocument, Name, True);
    Result.NodeValue := Value; // Important: Set the nodeValue before adding the attribute to avoid double OnAttrModified event call.
    Attributes.InternalAdd(Result);
    DoAttrModified(Self, AC_ADDITION, Result);
  end;
end;

{$IFDEF NEXTGEN}
function TDomElement.SetAttributeNS(const NamespaceURI,
                                          QualifiedName,
                                          Value: string): TDomAttr;
var
  Attr: TDomAttr;
  Prfx, Localname: string;
{$ELSE !NEXTGEN}
function TDomElement.SetAttributeNS(const NamespaceURI,
                                          QualifiedName,
                                          Value: WideString): TDomAttr;
var
  Attr: TDomAttr;
  Prfx, Localname: WideString;
{$ENDIF NEXTGEN}
begin
  if IsReadonly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');

  if not XmlExtractPrefixAndLocalName(QualifiedName, Prfx, LocalName) then begin
    if not IsXmlName(QualifiedName)
      then raise EInvalid_Character_Err.Create('Invalid character error.'+QualifiedName)
      else raise ENamespace_Err.Create('Namespace error.');
  end;

  if ((Prfx = 'xmlns') or (QualifiedName = 'xmlns')) then begin
    if not (NamespaceURI = 'http://www.w3.org/2000/xmlns/') then
      raise ENamespace_Err.Create('Namespace error.');
  end else begin
    if NamespaceURI = 'http://www.w3.org/2000/xmlns/' then
      raise ENamespace_Err.Create('Namespace error.');
  end;

  if (NamespaceURI = '') and (Prfx <> '') then
    raise ENamespace_Err.Create('Namespace error.');

  if (Prfx = 'xml') then begin
    if (NamespaceURI <> 'http://www.w3.org/XML/1998/namespace') then
      raise ENamespace_Err.Create('Namespace error.');
  end else if NamespaceURI = 'http://www.w3.org/XML/1998/namespace' then
    raise ENamespace_Err.Create('Namespace error.');

  Attr := GetAttributeNodeNS(NamespaceURI, LocalName);
    // Raises ENamespace_Err, if Attributes.NamespaceAware is 'False'.

  if Assigned(Attr) then begin
    Attr.SetPrefix(Prfx);
    Attr.NodeValue := Value;
    Result := nil;
  end else begin
    Result := TDomAttr.CreateNS(RootDocument as TDomDocumentNS, NamespaceURI, QualifiedName, True);
    Result.NodeValue := Value; // Important: Set the NodeValue before adding the attribute to avoid double OnAttrModified event call.
    Attributes.InternalAdd(Result);
    DoAttrModified(Self, AC_ADDITION, Result);
  end;
end;

function TDomElement.SetAttributeNode(const NewAttr: TDomAttr): TDomAttr;
var
  AttrModified: Boolean;
begin
  AttrModified := NewAttr.OwnerElement = nil;
  Result := (Attributes.SetNamedItem(NewAttr) as TDomAttr); // Raises all required exceptions.
  if AttrModified then
    DoAttrModified(Self, AC_ADDITION, NewAttr);
end;

function TDomElement.SetAttributeNodeNS(const NewAttr: TDomAttr): TDomAttr;
var
  AttrModified: Boolean;
begin
  AttrModified := NewAttr.OwnerElement = nil;
  Result := (Attributes.SetNamedItemNS(NewAttr) as TDomAttr); // Raises all required exceptions.
  if AttrModified then
    DoAttrModified(Self, AC_ADDITION, NewAttr);
end;

{$IFDEF NEXTGEN}
procedure TDomElement.SetNodeValue(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomElement.SetNodeValue(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  // Do nothing.
end;

{$IFDEF NEXTGEN}
procedure TDomElement.SetPrefix(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomElement.SetPrefix(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  if IsReadonly then
    raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');

  if NamespaceURI = 'http://www.w3.org/XML/1998/namespace' then begin
    if Value <> 'xml' then
      raise ENamespace_Err.Create('Namespace error.');
  end else begin
    if (NamespaceURI = '') and (Value <> '') then
      raise ENamespace_Err.Create('Namespace error.');
    if Value = 'xml' then
      raise ENamespace_Err.Create('Namespace error.');
    if Value = 'xmlns' then
      raise ENamespace_Err.Create('Namespace error.');
  end;

  if Value = '' then begin
    FPrefix := '';
    FNodeName := LocalName;
    Exit;
  end;

  if not IsXmlName(Value) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  if not IsXmlPrefix(Value) then
    raise ENamespace_Err.Create('Namespace error.');

  FPrefix := Value;
  FNodeName := Concat(Value, ':', LocalName);
end;



//+++++++++++++++++++++++++++++ TDomText +++++++++++++++++++++++++++++++++
constructor TDomText.Create(const AOwner: TDomCustomDocument);
begin
  inherited;
  FNodeValue := '';
  FCharRefGenerated := False;
  FAllowedChildTypes:= [];
end;

function TDomText.GetIsElementContentWhitespace: Boolean;
begin
  if RootDocument is TDomDocument
    then Result := (RootDocument as TDomDocument).GetIsElementContentWhitespace(Self)
    else Result := False;
end;

{$IFDEF NEXTGEN}
function TDomText.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomText.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '#text';
end;

function TDomText.GetNodeType: TDomNodeType;
begin
  Result := ntText_Node;
end;

function TDomText.SplitText(const Offset: Integer): TDomText;
begin
  if IsReadonly
    then raise ENo_Modification_Allowed_Err.Create('No modification allowed error.');
  if(Offset < 0) or (Offset > Length)
    then raise EIndex_Size_Err.Create('Index size error.');
  Result := TDomText.Create(RootDocument);
  Result.Data := SubstringData(Offset, Length - Offset);
  Result.CharRefGenerated := CharRefGenerated;
  DeleteData(Offset, Length - Offset);
  if Assigned(ParentNode) then
    ParentNode.InsertBefore(Result, Self.NextSibling);
end;



//++++++++++++++++++++++++++++ TDomComment +++++++++++++++++++++++++++++++
constructor TDomComment.Create(const AOwner: TDomCustomDocument);
begin
  inherited Create(AOwner);
  FNodeValue := '';
  FAllowedChildTypes := [];
end;

{$IFDEF NEXTGEN}
function TDomComment.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomComment.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '#comment';
end;

function TDomComment.GetNodeType: TDomNodeType;
begin
  Result := ntComment_Node;
end;



//+++++++++++++++++++++ TDomProcessingInstruction +++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomProcessingInstruction.Create(const AOwner: TDomCustomDocument;
                                             const Targ: string);
{$ELSE !NEXTGEN}
constructor TDomProcessingInstruction.Create(const AOwner: TDomCustomDocument;
                                             const Targ: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlPITarget(Targ) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwner);
  FTarget := Targ;
  FNodeValue := '';
  FAllowedChildTypes := [];
end;

procedure TDomProcessingInstruction.DoCharacterDataModified;
begin
  if Assigned(RootDocument) then
    RootDocument.DoCharacterDataModified(Self);
end;

{$IFDEF NEXTGEN}
function TDomProcessingInstruction.GetData: string;
{$ELSE !NEXTGEN}
function TDomProcessingInstruction.GetData: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNodeValue;
end;

{$IFDEF NEXTGEN}
function TDomProcessingInstruction.GetExpandedName: string;
{$ELSE !NEXTGEN}
function TDomProcessingInstruction.GetExpandedName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := Target;
end;

{$IFDEF NEXTGEN}
function TDomProcessingInstruction.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomProcessingInstruction.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := Target;
end;

function TDomProcessingInstruction.GetNodeType: TDomNodeType;
begin
  Result := ntProcessing_Instruction_Node;
end;

{$IFDEF NEXTGEN}
procedure TDomProcessingInstruction.SetData(const Value: string);
var
  PrevValue: string;
{$ELSE !NEXTGEN}
procedure TDomProcessingInstruction.SetData(const Value: WideString);
var
  PrevValue: WideString;
{$ENDIF NEXTGEN}
begin
  PrevValue := NodeValue;
  NodeValue := Value;
  DoCharacterDataModified;
end;



//++++++++++++++++++++++++++ TDomCDATASection +++++++++++++++++++++++++++++
constructor TDomCDATASection.Create(const AOwner: TDomCustomDocument);
begin
  inherited Create(AOwner);
  FNodeValue := '';
end;

{$IFDEF NEXTGEN}
function TDomCDATASection.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomCDATASection.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '#cdata-section';
end;

function TDomCDATASection.GetNodeType: TDomNodeType;
begin
  Result := ntCDATA_Section_Node;
end;



//++++++++++++++++++++++++ TDomDocumentTypeDecl +++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomDocumentTypeDecl.Create(const AOwner: TDomCustomDocument;
                                        const DoctypeName,
                                              PubId,
                                              SysId,
                                              IntSubset: string);
{$ELSE !NEXTGEN}
constructor TDomDocumentTypeDecl.Create(const AOwner: TDomCustomDocument;
                                        const DoctypeName,
                                              PubId,
                                              SysId,
                                              IntSubset: WideString);
{$ENDIF NEXTGEN}
begin
  inherited Create(AOwner);
  FNodeName := DoctypeName;
  FNodeValue := '';
  FPublicId := PubId;
  FSystemId := SysId;
  FInternalSubset := IntSubset;
  FIntSubsetByteNumber := 0;
  FIntSubsetCharNumber := 0;
  FIntSubsetStartColumn := 0;
  FIntSubsetStartLine := 1;
  FAllowedChildTypes := [];
end;

{$IFDEF NEXTGEN}
function TDomDocumentTypeDecl.GetInternalSubset: string;
{$ELSE !NEXTGEN}
function TDomDocumentTypeDecl.GetInternalSubset: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FInternalSubset;
end;

{$IFDEF NEXTGEN}
function TDomDocumentTypeDecl.GetName: string;
{$ELSE !NEXTGEN}
function TDomDocumentTypeDecl.GetName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := NodeName;
end;

{$IFDEF NEXTGEN}
function TDomDocumentTypeDecl.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomDocumentTypeDecl.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNodeName;
end;

function TDomDocumentTypeDecl.GetNodeType: TDomNodeType;
begin
  Result := ntDocument_Type_Decl_Node;
end;

{$IFDEF NEXTGEN}
function TDomDocumentTypeDecl.GetPublicId: string;
{$ELSE !NEXTGEN}
function TDomDocumentTypeDecl.GetPublicId: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FPublicId;
end;

{$IFDEF NEXTGEN}
function TDomDocumentTypeDecl.GetSystemId: string;
{$ELSE !NEXTGEN}
function TDomDocumentTypeDecl.GetSystemId: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FSystemId;
end;

{$IFDEF NEXTGEN}
procedure TDomDocumentTypeDecl.SetNodeValue(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomDocumentTypeDecl.SetNodeValue(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  // Do nothing.
end;



//++++++++++++++++++++++++ TDomEntityReference +++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomEntityReference.Create(const AOwner: TDomCustomDocument;
                                       const Name: string);
{$ELSE !NEXTGEN}
constructor TDomEntityReference.Create(const AOwner: TDomCustomDocument;
                                       const Name: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(Name)
    then raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwner);
  SetReadOnly(True);
  FNodeName := Name;
  FNodeValue := '';
  FAllowedChildTypes := [ ntElement_Node,
                          ntText_Node,
                          ntCDATA_Section_Node,
                          ntEntity_Reference_Node,
                          ntProcessing_Instruction_Node,
                          ntComment_Node,
                          ntDocument_Fragment_Node ];
end;

{$IFDEF NEXTGEN}
function TDomEntityReference.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomEntityReference.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNodeName;
end;

function TDomEntityReference.GetNodeType: TDomNodeType;
begin
  Result := ntEntity_Reference_Node;
end;

{$IFDEF NEXTGEN}
procedure TDomEntityReference.SetNodeValue(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomEntityReference.SetNodeValue(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  // Do nothing.
end;



//++++++++++++++++++++++++ TDomDocumentFragment +++++++++++++++++++++++++++
constructor TDomDocumentFragment.Create(const AOwner: TDomCustomDocument);
begin
  inherited Create(AOwner);
  FNodeValue := '';
  FAllowedChildTypes:= [ntElement_Node,
                        ntText_Node,
                        ntCDATA_Section_Node,
                        ntEntity_Reference_Node,
                        ntProcessing_Instruction_Node,
                        ntComment_Node,
                        ntDocument_Fragment_Node];
end;

function TDomDocumentFragment.GetAbsoluteIndex: Integer;
begin
  Result := -1;
end;

function TDomDocumentFragment.GetLevel: Integer;
begin
  Result := -1;
end;

{$IFDEF NEXTGEN}
function TDomDocumentFragment.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomDocumentFragment.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '#document-fragment';
end;

function TDomDocumentFragment.GetNodeType: TDomNodeType;
begin
  Result := ntDocument_Fragment_Node;
end;

{$IFDEF NEXTGEN}
procedure TDomDocumentFragment.SetNodeValue(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomDocumentFragment.SetNodeValue(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  // Do nothing.
end;



//+++++++++++++++++++++++++ TDomXPathNamespace ++++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomXPathNamespace.Create(const AOwnerSet: TDomXPathNodeSetResult;
                                      const AOwnerElement: TDomElement;
                                      const ANamespaceUri,
                                            APrefix: string);
{$ELSE !NEXTGEN}
constructor TDomXPathNamespace.Create(const AOwnerSet: TDomXPathNodeSetResult;
                                      const AOwnerElement: TDomElement;
                                      const ANamespaceUri,
                                            APrefix: WideString);
{$ENDIF NEXTGEN}
begin
  if not ( IsXmlPrefix(APrefix) or (APrefix = '') )
    then raise EInvalid_Character_Err.Create('Invalid character error.');

  if ( (APrefix = 'xmlns') and not (ANamespaceUri = 'http://www.w3.org/2000/xmlns/') )
    then raise ENamespace_Err.Create('Namespace error.');

  if (ANamespaceUri = '') and (APrefix <> '')
    then raise ENamespace_Err.Create('Namespace error.');

  if (APrefix = 'xml') and (ANamespaceUri <> 'http://www.w3.org/XML/1998/namespace')
    then raise ENamespace_Err.Create('Namespace error.');

  inherited Create(AOwnerSet);

  FAllowedChildTypes := [];
  SetReadOnly(True);
  FNamespaceURI := ANamespaceUri;
  FOwnerElement := AOwnerElement;
  FPrefix := APrefix;
end;

function TDomXPathNamespace.GetDocument: TDomCustomDocument;
begin
  if Assigned(FOwnerElement)
    then Result := FOwnerElement.OwnerDocument
    else Result := nil;
end;

{$IFDEF NEXTGEN}
function TDomXPathNamespace.GetExpandedName: string;
{$ELSE !NEXTGEN}
function TDomXPathNamespace.GetExpandedName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FPrefix;
end;

{$IFDEF NEXTGEN}
function TDomXPathNamespace.GetLocalName: string;
{$ELSE !NEXTGEN}
function TDomXPathNamespace.GetLocalName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FPrefix;
end;

{$IFDEF NEXTGEN}
function TDomXPathNamespace.GetNamespaceURI: string;
{$ELSE !NEXTGEN}
function TDomXPathNamespace.GetNamespaceURI: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNamespaceURI;
end;

{$IFDEF NEXTGEN}
function TDomXPathNamespace.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomXPathNamespace.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '#namespace';
end;

function TDomXPathNamespace.GetNodeType: TDomNodeType;
begin
  Result := ntXPath_Namespace_Node;
end;

{$IFDEF NEXTGEN}
function TDomXPathNamespace.GetNodeValue: string;
{$ELSE !NEXTGEN}
function TDomXPathNamespace.GetNodeValue: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNamespaceURI;
end;

function TDomXPathNamespace.GetOwnerElement: TDomElement;
begin
  Result := FOwnerElement;
end;

function TDomXPathNamespace.GetOwnerSet: TDomXPathNodeSetResult;
begin
  Result := (GetOwner as TDomXPathNodeSetResult);
end;

{$IFDEF NEXTGEN}
function TDomXPathNamespace.GetPrefix: string;
{$ELSE !NEXTGEN}
function TDomXPathNamespace.GetPrefix: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FPrefix;
end;

{$IFDEF NEXTGEN}
function TDomXPathNamespace.LookupNamespaceURI(const APrefix: string): string;
{$ELSE !NEXTGEN}
function TDomXPathNamespace.LookupNamespaceURI(const APrefix: WideString): WideString;
{$ENDIF NEXTGEN}
begin
  if Assigned(OwnerElement)
    then Result := OwnerElement.LookupNamespaceURI(APrefix)
    else Result := inherited LookupNamespaceURI(APrefix);
end;



//+++++++++++++++++++++++++++ TDomCustomDocument ++++++++++++++++++++++++++++
constructor TDomCustomDocument.Create(const AOwner: TDomImplementation);
begin
  inherited Create(nil);
  FDomImpl := AOwner;
  if Assigned(FDomImpl) then
    FDomImpl.Attach(Self);

  FNodeValue := '';
  FSystemId := '';
  FXmlEncoding := '';
  FXmlStandalone := STANDALONE_UNSPECIFIED;
  FXmlVersion := '';
  FModified := False;
  FDefaultView := nil;
  FCreatedNodeIterators := TList<TDomNodeIterator>.Create;
  FCreatedTreeWalkers := TList<TDomTreeWalker>.Create;
  FAllowedChildTypes := [ ntElement_Node,
                          ntProcessing_Instruction_Node,
                          ntComment_Node,
                          ntDocument_Type_Decl_Node,
                          ntDocument_Fragment_Node ];
end;

destructor TDomCustomDocument.Destroy;
{$IFNDEF AUTOREFCOUNT}
var
  I : Integer;
{$ENDIF !AUTOREFCOUNT}
begin
  // Free all NodeIterators:
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedNodeIterators.Count) do
    TDomNodeIterator(FCreatedNodeIterators[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedNodeIterators.Free;

  // Free all TreeWalkers:
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedTreeWalkers.Count) do
    TDomTreeWalker(FCreatedTreeWalkers[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedTreeWalkers.Free;

  if Assigned(FDomImpl) then
    FDomImpl.Detach(Self);
  inherited Destroy;
end;

function TDomCustomDocument.AppendChild(const NewChild: TDomNode): TDomNode;
begin
  if not Assigned(NewChild) then
    raise ENot_Supported_Err.Create('Not supported error.');
  case NewChild.NodeType of
    ntElement_Node:
      if Assigned(DocumentElement) then
        raise EHierarchy_Request_Err.Create('Hierarchy request error.');
    ntDocument_Type_Decl_Node:
      if Assigned(DocumentElement) or Assigned(DoctypeDecl) then
        raise EHierarchy_Request_Err.Create('Hierarchy request error.');
  end;
  Result := inherited AppendChild(NewChild);
end;

procedure TDomCustomDocument.ClearInvalidNodeIterators;
var
  I : Integer;
begin
  for I := 0 to Pred(FCreatedNodeIterators.Count) do
  if TDomNodeIterator(FCreatedNodeIterators[I]).FInvalid then begin
{$IFNDEF AUTOREFCOUNT}
    FCreatedNodeIterators[I].Free;
{$ENDIF !AUTOREFCOUNT}
    FCreatedNodeIterators[I] := nil;
  end;
  FCreatedNodeIterators.Pack;
  FCreatedNodeIterators.Capacity:= FCreatedNodeIterators.Count;
end;

procedure TDomCustomDocument.DoAttrModified(const SourceNode: TDomNode;
                                            const AttrChange: TDomAttrChange;
                                            const RelatedAttr: TDomAttr);
begin
  FModified := True;
  try
    if Assigned(FOnAttrModified) then
      FOnAttrModified(Self, SourceNode, AttrChange, RelatedAttr);
  finally
    if Assigned(DomImplementation) then
      DomImplementation.DoAttrModified(SourceNode, AttrChange, RelatedAttr);
  end;
end;

procedure TDomCustomDocument.DoBeforeClear;
{$IFNDEF AUTOREFCOUNT}
var
  I : Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedNodeIterators.Count) do
    TDomNodeIterator(FCreatedNodeIterators[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedNodeIterators.Clear;
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedTreeWalkers.Count) do
    TDomTreeWalker(FCreatedTreeWalkers[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedTreeWalkers.Clear;
end;

procedure TDomCustomDocument.DoCharacterDataModified(Node: TDomNode);
begin
  FModified := True;
  try
    if Assigned(FOnCharacterDataModified) then
      FOnCharacterDataModified(Self, Node);
  finally
    if Assigned(DomImplementation) then
      DomImplementation.DoCharacterDataModified(Node);
  end;
end;

procedure TDomCustomDocument.DoNodeClearing(Node: TDomNode);
begin
  FModified := True;
  try
    if Assigned(FOnNodeClearing) then
      FOnNodeClearing(Self, Node);
  finally
    if Assigned(DomImplementation) then
      DomImplementation.DoNodeClearing(Node);
    NotifyIterators(Node, neClearing);
  end;
end;

procedure TDomCustomDocument.DoNodeInserted(Node: TDomNode);
begin
  FModified := True;
  try
    if Assigned(FOnNodeInserted) then
      FOnNodeInserted(Self, Node);
  finally
    if Assigned(DomImplementation) then
      DomImplementation.DoNodeInserted(Node);
  end;
end;

procedure TDomCustomDocument.DoNodeRemoving(Node: TDomNode);
begin
  FModified := True;
  try
    if Assigned(FOnNodeRemoving) then
      FOnNodeRemoving(Self, Node);
  finally
    if Assigned(DomImplementation) then
      DomImplementation.DoNodeRemoving(Node);
    NotifyIterators(Node, neRemoving);
  end;
end;

function TDomCustomDocument.GetAbsoluteIndex: Integer;
begin
  Result := 0;
end;

{$IFDEF NEXTGEN}
function TDomCustomDocument.GetAttrDataType(const ElementName,
                                                  AttrName: string): TXmlDataType;
{$ELSE !NEXTGEN}
function TDomCustomDocument.GetAttrDataType(const ElementName,
                                                  AttrName: WideString): TXmlDataType;
{$ENDIF NEXTGEN}
begin
  Result := AS_STRING_DATATYPE;
end;

function TDomCustomDocument.GetLevel: Integer;
begin
  Result := 0;
end;

{$IFDEF NEXTGEN}
function TDomCustomDocument.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomCustomDocument.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := '#document';
end;

function TDomCustomDocument.GetNodeType: TDomNodeType;
begin
  Result := ntDocument_Node;
end;

function TDomCustomDocument.GetRootDocument: TDomCustomDocument;
begin
  Result := Self;
end;

function TDomCustomDocument.ImportNode(const ImportedNode: TDomNode;
                                       const Deep: Boolean): TDomNode;
var
  I: Integer;
  UserDataEvent: TDomUserDataEvent;
begin
  Result := ImportNode2(ImportedNode, Deep);

    if Assigned(Result) and Assigned(ImportedNode.FUserData) then
      for I := 0 to Pred(ImportedNode.FUserData.Count) do begin
        UserDataEvent := ImportedNode.FUserDataHandlers[I];
        if Assigned(UserDataEvent) then
          UserDataEvent(OT_NODE_IMPORTED, ImportedNode.FUserData.WideStrings[I],
                        ImportedNode.FUserData.Objects[I], ImportedNode, Result);
      end;
end;

function TDomCustomDocument.ImportNode2(const ImportedNode: TDomNode;
                                        const Deep: Boolean): TDomNode;
var
  I: Integer;
  NewChild: TDomNode;
  OldAttr: TDomAttr;
begin
  if not Assigned(ImportedNode) then
    raise ENot_Supported_Err.Create('Not supported error.');
  case ImportedNode.NodeType of
    ntAttribute_Node:
      begin
        if ImportedNode.IsNamespaceNode
          then Result := TDomAttr.CreateNS(Self as TDomDocumentNS, ImportedNode.NamespaceURI, ImportedNode.NodeName, True)
          else Result := TDomAttr.Create(Self as TDomDocument, ImportedNode.NodeName, True);
        Result.FNodeValue := ImportedNode.FNodeValue;
      end;
    ntCDATA_Section_Node:
      begin
        Result := TDomCDATASection.Create(Self);
        (Result as TDomCDATASection).Data := (ImportedNode as TDomCDATASection).Data;
      end;
    ntComment_Node:
      begin
        Result := TDomComment.Create(Self);
        (Result as TDomComment).Data := (ImportedNode as TDomComment).Data;
      end;
    ntDocument_Fragment_Node:
      begin
        Result := TDomDocumentFragment.Create(Self);
        if Deep then for I := 0 to Pred(ImportedNode.ChildNodes.Length) do begin
          NewChild := ImportNode(ImportedNode.ChildNodes.Item(I), True);
          Result.AppendChild(NewChild);
        end;
      end;
    ntElement_Node:
      begin
        if ImportedNode.IsNamespaceNode then begin
          Result := TDomElement.CreateNS(Self as TDomDocumentNS, ImportedNode.NamespaceURI, ImportedNode.NodeName);
          // Duplicating specified attributes:
          for I := 0 to Pred(ImportedNode.Attributes.Length) do begin
            OldAttr := TDomAttr(ImportedNode.Attributes.Item(I));
            if OldAttr.Specified then begin
              NewChild := ImportNode(OldAttr, True);
              (Result as TDomElement).SetAttributeNodeNS((NewChild as TDomAttr));
            end;
          end; {for ...}
        end else begin
          Result := TDomElement.Create(Self as TDomDocument, ImportedNode.NodeName);
          // Duplicating specified attributes:
          for I := 0 to Pred(ImportedNode.Attributes.Length) do begin
            OldAttr := TDomAttr(ImportedNode.Attributes.Item(I));
            if OldAttr.Specified then begin
              NewChild := ImportNode(OldAttr, True);
              (Result as TDomElement).SetAttributeNode((NewChild as TDomAttr));
            end;
          end; {for ...}
        end; {if ... else ...}

        // Duplicating child nodes:
        if Deep then
          for I := 0 to Pred(ImportedNode.ChildNodes.Length) do begin
            NewChild := ImportNode(ImportedNode.ChildNodes.Item(I), True);
            Result.AppendChild(NewChild);
          end;
      end;
    ntEntity_Reference_Node:
      begin
        Result := TDomEntityReference.Create(Self, ImportedNode.NodeName);
        // Remark: Derived classes should implement entity reference expansion if possible.
      end;
    ntProcessing_Instruction_Node:
      begin
        Result := TDomProcessingInstruction.Create(Self, (ImportedNode as TDomProcessingInstruction).Target);
        (Result as TDomProcessingInstruction).Data := (ImportedNode as TDomProcessingInstruction).Data;
      end;
    ntText_Node:
      begin
        Result := TDomText.Create(Self);
        (Result as TDomText).Data := (ImportedNode as TDomText).Data;
        (Result as TDomText).CharRefGenerated := (ImportedNode as TDomText).CharRefGenerated;
      end;
  else
    raise ENot_Supported_Err.Create('Not supported error.');
  end;
end;

{$IFNDEF NEXTGEN}
function TDomCustomDocument.GetBaseUri: WideString;
begin
  if IsUriAbsoluteURIWideStr(DocumentUri)
    then Result := DocumentUri
    else Result := '';
end;
{$ELSE NEXTGEN}
function TDomCustomDocument.GetBaseUri: DOMString;
begin
  if IsUriAbsoluteURIStr(DocumentUri)
    then Result := DocumentUri
    else Result := '';
end;
{$ENDIF !NEXTGEN}

function TDomCustomDocument.GetDoctypeDecl: TDomDocumentTypeDecl;
var
  Child: TDomNode;
begin
  Result := nil;
  Child := FirstChild;
  while Assigned(Child) do begin
    if Child.NodeType = ntDocument_Type_Decl_Node then begin
      Result := (Child as TDomDocumentTypeDecl);
      Break;
    end;
    Child := Child.NextSibling;
  end;
end;

function TDomCustomDocument.GetDocumentElement: TDomElement;
begin
  Result := FindFirstChildElement;
end;

function TDomCustomDocument.InsertBefore(const NewChild,
                                               RefChild: TDomNode): TDomNode;
begin
  if not Assigned(NewChild) then
    raise ENot_Supported_Err.Create('Not supported error.');
  case NewChild.NodeType of
    ntElement_Node: begin
      if Assigned(DocumentElement) then
        raise EHierarchy_Request_Err.Create('Hierarchy request error.');
      if Assigned(DoctypeDecl) then
        if ChildNodes.IndexOf(DoctypeDecl) >= ChildNodes.IndexOf(RefChild) then
          raise EHierarchy_Request_Err.Create('Hierarchy request error.');
    end;
    ntDocument_Type_Decl_Node: begin
      if Assigned(DocumentElement) then
        if ChildNodes.IndexOf(DocumentElement) < ChildNodes.IndexOf(RefChild) then
          raise EHierarchy_Request_Err.Create('Hierarchy request error.');
      if Assigned(DoctypeDecl) then
        raise EHierarchy_Request_Err.Create('Hierarchy request error.');
    end;
  end;
  Result := inherited InsertBefore(NewChild, RefChild);
end;

procedure TDomCustomDocument.NotifyIterators(const Node: TDomNode;
                                             const EventType: TDomNodeEvent);
var
  I: Integer;
begin
  for I := 0 to Pred(FCreatedNodeIterators.Count) do
    TDomNodeIterator(FCreatedNodeIterators[I]).HandleNodeEvent(Node, EventType);
end;

{$IFDEF NEXTGEN}
procedure TDomCustomDocument.CalculateNormalizedAttrValue(const AttrLiteralValue: string;
                                                          const AttrDataType: TXmlDataType;
                                                            out NormalizedValue: string;
                                                            out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TDomCustomDocument.CalculateNormalizedAttrValue(const AttrLiteralValue: WideString;
                                                          const AttrDataType: TXmlDataType;
                                                            out NormalizedValue: WideString;
                                                            out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
const
  SPACE: WideChar = #$20;  // ' '
type
  TKindOfToken = (IS_TEXT, IS_REFSTART, IS_CHARREF, IS_ENTITYREF);
var
{$IFDEF NEXTGEN}
  CharRefStr: string;
{$ELSE !NEXTGEN}
  CharRefStr: WideString;
{$ENDIF NEXTGEN}
  Text: TUtilsCustomWideStr;
  Tokenizer: TXmlAttrValueTokenizer;
begin
  Error := ET_NONE;
  Text := TUtilsCustomWideStr.Create;
  try

    Tokenizer := TXmlAttrValueTokenizer.Create(AttrLiteralValue);
    try
      while not (Tokenizer.TokenType = ATTR_END_OF_SOURCE_TOKEN) do begin
        Tokenizer.Next;

        if Tokenizer.ErrorType <> ET_NONE then begin
          if Tokenizer.ErrorType in ET_FATAL_ERRORS then begin
            Error := Tokenizer.ErrorType;
            NormalizedValue := '';
            Exit;
          end;
          if not (Error in ET_ERRORS) then
            Error := Tokenizer.ErrorType;
        end;

        case Tokenizer.TokenType of

          ATTR_CHAR_REF:
            try
{$IFDEF NEXTGEN}
              CharRefStr := XmlCharRefToStr(Concat(string('&#'), Tokenizer.TokenValue, string(';')));
{$ELSE !NEXTGEN}
              CharRefStr := XmlCharRefToStr(Concat(WideString('&#'), Tokenizer.TokenValue, WideString(';')));
{$ENDIF NEXTGEN}
              if CharRefStr = '<' then begin
                Error := ET_LT_IN_ATTRIBUTE_VALUE;
                Exit;
              end;
              Text.AddWideString(CharRefStr);
            except
              on EConvertError do begin
                Error := ET_INVALID_CHAR_REF;
                Exit;
              end;
            end;

          ATTR_ENTITY_REF:
            if Tokenizer.TokenValue = 'lt' then begin
              Text.AddWideString('<');
            end else if Tokenizer.TokenValue = 'gt' then begin
              Text.AddWideString('>');
            end else if Tokenizer.TokenValue = 'amp' then begin
              Text.AddWideString('&');
            end else if Tokenizer.TokenValue = 'apos' then begin
              Text.AddWideString('''');
            end else if Tokenizer.TokenValue = 'quot' then begin
              Text.AddWideString('"');
            end else begin
              Error := ET_UNDEFINED_ENTITY_VC;
              Exit
            end;

          ATTR_TEXT:
            if IsXmlS(Tokenizer.TokenValue)
              then Text.AddWideChar(SPACE)
              else Text.AddWideString(Tokenizer.TokenValue);

        end; {case ...}

      end; {while ...}
    finally
      Tokenizer.Free;
    end;

    NormalizedValue := Text.Value;

  finally
    Text.Free;
  end;
end;

{$IFDEF NEXTGEN}
procedure TDomCustomDocument.SetNodeValue(const Value: string);
{$ELSE !NEXTGEN}
procedure TDomCustomDocument.SetNodeValue(const Value: WideString);
{$ENDIF NEXTGEN}
begin
  // Do nothing.
end;

procedure TDomCustomDocument.FreeTreeWalker(var TreeWalker: TDomTreeWalker);
var
  TreeWalkerIndex: Integer;
begin
  if not Assigned(TreeWalker) then Exit;
  TreeWalkerIndex := FCreatedTreeWalkers.IndexOf(TreeWalker);
  if TreeWalkerIndex = -1
    then raise EWrong_Document_Err.Create('Wrong document error.');
  FCreatedTreeWalkers.Delete(TreeWalkerIndex);
  TreeWalker.Free;
  TreeWalker := nil;
end;

function TDomCustomDocument.ReplaceChild(const NewChild,
                                               OldChild: TDomNode): TDomNode;
begin
  if not ( Assigned(NewChild) and Assigned(OldChild) ) then
    raise ENot_Supported_Err.Create('Not supported error.');
  case NewChild.NodeType of
    ntElement_Node: begin
      if Assigned(DocumentElement) and (DocumentElement <> OldChild) then
        raise EHierarchy_Request_Err.Create('Hierarchy request error.');
      if Assigned(DoctypeDecl) then
        if ChildNodes.IndexOf(DoctypeDecl) > ChildNodes.IndexOf(OldChild) then
          raise EHierarchy_Request_Err.Create('Hierarchy request error.');
    end;
    ntDocument_Type_Decl_Node: begin
      if Assigned(DoctypeDecl) and (DoctypeDecl <> OldChild) then
        raise EHierarchy_Request_Err.Create('Hierarchy request error.');
      if Assigned(DocumentElement) then
        if ChildNodes.IndexOf(DocumentElement) < ChildNodes.IndexOf(OldChild) then
          raise EHierarchy_Request_Err.Create('Hierarchy request error.');
    end;
  end;
  Result := inherited ReplaceChild(NewChild, OldChild);
end;

function TDomCustomDocument.CreateNodeIterator(const Root: TDomNode;
                                                     WhatToShow: TDomWhatToShow;
                                                     NodeFilter: TDomNodeFilter;
                                                     EntityReferenceExpansion: Boolean): TDomNodeIterator;
begin
  Result := TDomNodeIterator.Create(Root, WhatToShow, NodeFilter, EntityReferenceExpansion);
  FCreatedNodeIterators.Add(Result);
end;

function TDomCustomDocument.CreateTreeWalker(const Root: TDomNode;
                                                   WhatToShow: TDomWhatToShow;
                                                   NodeFilter: TDomNodeFilter;
                                                   EntityReferenceExpansion: Boolean): TDomTreeWalker;
begin;
  Result := TDomTreeWalker.Create(Root, WhatToShow, NodeFilter, EntityReferenceExpansion);
  FCreatedTreeWalkers.Add(Result);
end;



//++++++++++++++++++++++++++++++ TDomDocument +++++++++++++++++++++++++++++++
constructor TDomDocument.Create(const AOwner: TDomImplementation);
begin
  inherited;
  FCreatedElementsNodeLists := TList<TDomNodeList>.Create;
  FValidationAgent := TDtdValidationAgent.Create(Self);
end;

destructor TDomDocument.Destroy;
{$IFNDEF AUTOREFCOUNT}
var
  I : Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedElementsNodeLists.Count) do
    TDomElementsNodeList(FCreatedElementsNodeLists[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedElementsNodeLists.Free;

  FValidationAgent.Free;

  inherited;
end;

{$IFDEF NEXTGEN}
procedure TDomDocument.CalculateNormalizedAttrValue(const AttrLiteralValue: string;
                                                    const AttrDataType: TXmlDataType;
                                                      out NormalizedValue: string;
                                                      out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TDomDocument.CalculateNormalizedAttrValue(const AttrLiteralValue: WideString;
                                                    const AttrDataType: TXmlDataType;
                                                      out NormalizedValue: WideString;
                                                      out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
begin
  ValidationAgent.NormalizeAttributeValue(AttrLiteralValue, AttrDataType, NormalizedValue, Error);
end;

procedure TDomDocument.DoBeforeClear;
{$IFNDEF AUTOREFCOUNT}
var
  I : Integer;
{$ENDIF !AUTOREFCOUNT}
begin
  inherited;
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedElementsNodeLists.Count) do
    TDomElementsNodeList(FCreatedElementsNodeLists[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedElementsNodeLists.Clear;
end;

{$IFDEF NEXTGEN}
function TDomDocument.GetAttrDataType(const ElementName,
                                            AttrName: string): TXmlDataType;
{$ELSE !NEXTGEN}
function TDomDocument.GetAttrDataType(const ElementName,
                                            AttrName: WideString): TXmlDataType;
{$ENDIF NEXTGEN}
begin
  Result := ValidationAgent.GetAttrDataType(ElementName, AttrName);
end;

{$IFDEF NEXTGEN}
function TDomDocument.GetElementById(const ElementId: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomDocument.GetElementById(const ElementId: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  Index: Integer;
begin
  if ValidationAgent.IDs.Find(ElementId, Index)
    then Result := TDomElement(ValidationAgent.IDs.Objects[Index])
    else Result := nil;
end;

{$IFDEF NEXTGEN}
function TDomDocument.GetElementsByTagName(const TagName: string): TDomNodeList;
{$ELSE !NEXTGEN}
function TDomDocument.GetElementsByTagName(const TagName: WideString): TDomNodeList;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  for I := 0 to FCreatedElementsNodeLists.Count - 1 do
    if TDomElementsNodeList(FCreatedElementsNodeLists[I]).FQueryName = TagName
      then begin Result := TDomElementsNodeList(FCreatedElementsNodeLists[I]); Exit; end;
  Result := TDomElementsNodeList.Create(TagName, Self);
  FCreatedElementsNodeLists.Add(Result);
end;

function TDomDocument.GetIsElementContentWhitespace(const TextNode: TDomText): Boolean;
var
  P: TDomNode;
begin
  Result := False;
  if not TextNode.CharRefGenerated then  // Was TextNode generated from at least one character reference?
    if (IsXMLS(TextNode.NodeValue) or (TextNode.NodeValue = '')) then begin  // Does TextNode contain whitespace only?
      P := TextNode.ParentNode;
      while Assigned(P) do
        case P.NodeType of
          ntElement_Node: begin
            Result := ValidationAgent.GetElementContentType((P as TDomElement).NodeName) = DTD_ELEMENT_CONTENTTYPE;
            Break;
          end;
          ntEntity_Reference_Node:
            P := P.ParentNode;
        else
          Break;
        end;
    end;
end;

function TDomDocument.ImportNode2(const ImportedNode: TDomNode;
                                  const Deep: Boolean): TDomNode;
begin
  Result := inherited ImportNode2(ImportedNode, Deep);
  if Result.NodeType = ntEntity_Reference_Node then
    ValidationAgent.ExpandEntityReference(Result as TDomEntityReference);
end;

function TDomDocument.PrepareAttributes: Boolean;
begin
  if Assigned(DocumentElement)
    then Result := PrepareAttributes2(DocumentElement)
    else Result := True;
end;

function TDomDocument.PrepareAttributes2(const Node: TDomNode): Boolean;
var
  Attr: TDomAttr;
  I: Integer;
begin
  Result := True;

  if Node.NodeType = ntElement_Node then begin

    if Node.IsNamespaceNode then
      Result := False;


    // Step 1: Remove all TDomAttr nodes attached to this element whose
    //         'Specified' property is 'False'.

    for I := Pred(Node.Attributes.Length) downto 0 do begin
      Attr := Node.Attributes.Item(I) as TDomAttr;
      if not Attr.Specified then
        Attr.Free;  // Removes and frees the attribute node.
    end;


    // Step 2: Create and add missing fixed and default TDomAttr nodes with
    //         'Specified' set to 'False'.

    ValidationAgent.AddDefaultAttributes(Node as TDomElement);

  end;

  // Step 3: Prepare the attributes of the child nodes.

  for I := 0 to Pred(Node.Childnodes.Length) do
    if not PrepareAttributes2(Node.Childnodes.Item(I)) then
      Result := False;
end;



//+++++++++++++++++++++++++++++ TDomDocumentNS ++++++++++++++++++++++++++++++
constructor TDomDocumentNS.Create(const AOwner: TDomImplementation);
begin
  inherited;
  FCreatedElementsNodeListNSs:= TList<TDomNodeList>.Create;
  FIDs:= TUtilsWideStringList.Create;
  FIDs.Sorted:= True;
  FIDs.Duplicates:= dupIgnore;
end;

destructor TDomDocumentNS.Destroy;
{$IFNDEF AUTOREFCOUNT}
var
  I : Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedElementsNodeListNSs.Count) do
    TDomElementsNodeListNS(FCreatedElementsNodeListNSs[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedElementsNodeListNSs.Free;

  FIDs.Free;

  inherited;
end;

procedure TDomDocumentNS.DoBeforeClear;
{$IFNDEF AUTOREFCOUNT}
var
  I : Integer;
{$ENDIF !AUTOREFCOUNT}
begin
  inherited;
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedElementsNodeListNSs.Count) do
    TDomElementsNodeListNS(FCreatedElementsNodeListNSs[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedElementsNodeListNSs.Clear;
end;

{$IFDEF NEXTGEN}
function TDomDocumentNS.GetElementById(const ElementId: string): TDomElement;
{$ELSE !NEXTGEN}
function TDomDocumentNS.GetElementById(const ElementId: WideString): TDomElement;
{$ENDIF NEXTGEN}
var
  Index: Integer;
begin
  if IDs.Find(ElementId, Index)
    then Result := TDomElement(IDs.Objects[Index])
    else Result := nil;
end;

{$IFDEF NEXTGEN}
function TDomDocumentNS.GetElementsByTagNameNS(const NamespaceURI,
                                                     LocalName: string): TDomNodeList;
{$ELSE !NEXTGEN}
function TDomDocumentNS.GetElementsByTagNameNS(const NamespaceURI,
                                                     LocalName: WideString): TDomNodeList;
{$ENDIF NEXTGEN}
var
  I: Integer;
  NL: TDomElementsNodeListNS;
begin
  for I := 0 to FCreatedElementsNodeListNSs.Count - 1 do begin
    NL := TDomElementsNodeListNS(FCreatedElementsNodeListNSs[I]);
    if (NL.FQueryNamespaceURI = NamespaceURI) and (NL.FQueryLocalName = LocalName)
      then begin Result := NL; Exit; end;
  end;
  Result := TDomElementsNodeListNS.Create(NamespaceURI, LocalName, Self);
  FCreatedElementsNodeListNSs.Add(Result);
end;

procedure TDomDocumentNS.SetIDs(const Value: TUtilsWideStringList);
begin
  FIDs.Assign(Value);
end;



//++++++++++++++++++++++++++++ TDomDocumentXPath ++++++++++++++++++++++++++++
procedure TDomDocumentXPath.DoBeforeAttach(const Obj: TCustomOwnedObject);
begin
  if not ( (Obj is TDomDocumentFragment) or
           (Obj is TDomProcessingInstruction) or
           (Obj is TDomElement) or
           (Obj is TDomAttr) or
           (Obj is TDomComment) or
           (Obj is TDomText) or
           (Obj is TDomEntityReference) or
           (Obj is TDomDocumentTypeDecl) ) then
    raise ENot_Supported_Err.Create('Not supported error: ' + Obj.ClassName);

  inherited;
end;



//+++++++++++++++++++++++++++++ TDtdObjectList ++++++++++++++++++++++++++++
constructor TDtdObjectList.Create;
begin
  inherited Create;
  FNodeList:= TList<TDtdObject>.Create;
end;

destructor TDtdObjectList.Destroy;
begin
  FNodeList.Free;
  inherited;
end;

procedure TDtdObjectList.Clear;
begin
  FNodeList.Clear;
end;

function TDtdObjectList.AppendNode(const NewNode: TDtdObject): TDtdObject;
begin
  FNodeList.Add(NewNode);
  Result := NewNode;
end;

procedure TDtdObjectList.Delete(const Index: Integer);
begin
  FNodeList.Delete(Index);
end;

function TDtdObjectList.IndexOf(const Node: TDtdObject): Integer;
begin
  Result := FNodeList.IndexOf(Node);
end;

function TDtdObjectList.GetLength: Integer;
begin
  Result := FNodeList.Count;
end;

function TDtdObjectList.InsertBefore(const NewNode,
                                             RefNode: TDtdObject): TDtdObject;
begin
  Result := NewNode;
  if Assigned(RefNode)
    then FNodeList.Insert(FNodeList.IndexOf(RefNode), NewNode)
    else FNodeList.Add(NewNode);
end;

function TDtdObjectList.RemoveNode(const OldNode: TDtdObject): TDtdObject;
begin
  Result := OldNode;
  FNodeList.Remove(OldNode);
end;

function TDtdObjectList.Item(const Index: Integer): TDtdObject;
begin
  if (Index < 0) or (Index >= FNodeList.Count)
    then Result := nil
    else Result := TDtdObject(FNodeList.Items[Index]);
end;



//+++++++++++++++++++++++++ TDtdNamedObjectMap +++++++++++++++++++++++++
constructor TDtdNamedObjectMap.Create(const AOwner: TDtdModel);
begin
  inherited Create;
  FOwnerObject:= AOwner;
  FObjectList:= TList<TDtdObject>.Create;
end;

destructor TDtdNamedObjectMap.Destroy;
begin
  FObjectList.Free;
  inherited;
end;

procedure TDtdNamedObjectMap.Clear;
begin
  FObjectList.Clear;
end;

function TDtdNamedObjectMap.GetLength: Integer;
begin
  Result := FObjectList.Count;
end;

{$IFDEF NEXTGEN}
function TDtdNamedObjectMap.GetNamedItem(const Name: string): TDtdObject;
{$ELSE !NEXTGEN}
function TDtdNamedObjectMap.GetNamedItem(const Name: WideString): TDtdObject;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to Pred(FObjectList.Count) do
    if (TDtdObject(FObjectList[I]).Name = Name) then begin
      Result := TDtdObject(FObjectList[I]);
      Break;
    end;
end;

function TDtdNamedObjectMap.Item(const Index: Integer): TDtdObject;
begin
  if (Index < 0) or (Index >= FObjectList.Count)
    then Result := nil
    else Result := TDtdObject(FObjectList.Items[Index]);
end;

{$IFDEF NEXTGEN}
function TDtdNamedObjectMap.RemoveNamedItem(const Name: string): TDtdObject;
{$ELSE !NEXTGEN}
function TDtdNamedObjectMap.RemoveNamedItem(const Name: WideString): TDtdObject;
{$ENDIF NEXTGEN}
begin
  Result := GetNamedItem(Name);
  if not Assigned(Result) then
    raise ENot_Found_Err.Create('Not found error.');
  FObjectList.Remove(Result);
end;

function TDtdNamedObjectMap.SetNamedItem(const Arg: TDtdObject): TDtdObject;
begin
  if Assigned(GetNamedItem(Arg.Name))
    then Result := RemoveNamedItem(Arg.Name)
    else Result := nil;
  FObjectList.Add(Arg);
end;



//++++++++++++++++++++++ TDtdValidationAgent ++++++++++++++++++++++++++
constructor TDtdValidationAgent.Create(const AOwner: TDomDocument);
begin
  if not Assigned(AOwner) then
    raise ENot_Supported_Err.Create('Not supported error.');
  inherited Create;

  FOwnerDocument := AOwner;

  FErrorReportingEnabled := True;

  FIDs := TUtilsWideStringList.Create;
  FIDs.Sorted := True;
  FIDs.Duplicates := dupError;

  FIDREFs := TUtilsWideStringList.Create;
  FIDREFs.Sorted := False;
  FIDREFs.Duplicates := dupAccept;

  FDtdModel := TDtdModel.Create;
end;

destructor TDtdValidationAgent.Destroy;
begin
  FDtdModel.Free;
  FIDREFs.Free;
  FIDs.Free;
  inherited;
end;

{$IFDEF NEXTGEN}
procedure TDtdValidationAgent.AddDefaultAttr(const Elmt: TDomElement;
                                             const AttrName,
                                                   AttrValue: string);
{$ELSE !NEXTGEN}
procedure TDtdValidationAgent.AddDefaultAttr(const Elmt: TDomElement;
                                             const AttrName,
                                                   AttrValue: WideString);
{$ENDIF NEXTGEN}
// Adds a new attribute (with specified set to False) to Elmt, no matter whether
// Elmt is readonly or not.
var
  NewAttr: TDomAttr;
  ReadOnlyBackup: Boolean;
begin
  NewAttr := TDomAttr.Create(Elmt.OwnerDocument as TDomDocument, AttrName, False);
  NewAttr.NodeValue := AttrValue;
  ReadOnlyBackup := Elmt.IsReadOnly;
  Elmt.SetReadOnly(False);
  try
    Elmt.SetAttributeNode(NewAttr);
  finally
    Elmt.SetReadOnly(ReadOnlyBackup);
  end;
end;

function TDtdValidationAgent.AddDefaultAttributes(const Elmt: TDomElement): Boolean;
// Adds missing default attributes to an element, checks whether the value of
// all fixed attributes match and whether all required attributes are specified.
// Return value:
//   'True' if all attributes to be inserted were actually inserted.
//   'False' if an attribute was skipped due to a malformed declaration.
var
  AttrDecl: TDtdAttributeDecl;
{$IFDEF NEXTGEN}
  NormalizedDefaultValue: string;
{$ELSE !NEXTGEN}
  NormalizedDefaultValue: WideString;
{$ENDIF NEXTGEN}
  AttDeclCol: TDtdAttDeclCollection;
  Error: TXmlErrorType;
  I: Integer;
  SpecifiedAttr: TDomAttr;
begin
  Assert(Assigned(Elmt));

  Result := True;

  AttDeclCol := DtdModel.FindAttDeclCollection(Elmt.NodeName);
  if Assigned(AttDeclCol) then
    for I := 0 to Pred(AttDeclCol.AttributeDecls.Length) do begin

      AttrDecl := AttDeclCol.AttributeDecls.Item(I) as TDtdAttributeDecl;
      if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then begin

        SpecifiedAttr := Elmt.GetAttributeNode(AttrDecl.Name);

        // If the attribute was not specified, then set it:
        if not Assigned(SpecifiedAttr) then begin
          NormalizeAttrDeclValue(AttrDecl, NormalizedDefaultValue, Error);
          if Error in ET_WARNINGS
            then AddDefaultAttr(Elmt, AttrDecl.Name, NormalizedDefaultValue)
            else Result := False;
        end;

      end;

    end; {for ...}
end;

procedure TDtdValidationAgent.AddAndValidateDefaultAttributes(const Elmt: TDomElement;
                                                                out IsValid,
                                                                    AContinue: Boolean);
// Adds missing default attributes to an element, checks whether the value of
// all fixed attributes match and whether all required attributes are specified.
// Return Values:
// - IsValid: Indicates whether the element is valid according to some tests
//            made in this subroutine.
// - AContinue: 'False' to indicate that the validation should be aborted.
var
  AttrDecl: TDtdAttributeDecl;
  AttDeclCol: TDtdAttDeclCollection;
  Error: TXmlErrorType;
  I: Integer;
{$IFDEF NEXTGEN}
  NormalizedAttrValue: string;
  NormalizedDefaultValue: string;
{$ELSE !NEXTGEN}
  NormalizedAttrValue: WideString;
  NormalizedDefaultValue: WideString;
{$ENDIF NEXTGEN}
  SpecifiedAttr: TDomAttr;
begin
  Assert(Assigned(Elmt));

  AContinue := True;
  IsValid := True;
  AttDeclCol := DtdModel.FindAttDeclCollection(Elmt.NodeName);
  if Assigned(AttDeclCol) then
  begin
    for I := 0 to Pred(AttDeclCol.AttributeDecls.Length) do begin
      AttrDecl := AttDeclCol.AttributeDecls.Item(I) as TDtdAttributeDecl;
      case AttrDecl.ConstraintType of

        AVC_DEFAULT:
        begin
          SpecifiedAttr := Elmt.GetAttributeNode(AttrDecl.Name);

          // If the attribute was not specified, then set it:
          if not Assigned(SpecifiedAttr) then begin
            NormalizeAttrDeclValue(AttrDecl, NormalizedDefaultValue, Error);
            if Error in ET_WARNINGS then begin
              AddDefaultAttr(Elmt, AttrDecl.Name, NormalizedDefaultValue);
            end else begin
              IsValid := False;
              if not SendErrorNotification(Error, AttrDecl, Elmt) then begin
                AContinue := False;
                Exit;
              end;
            end;
          end;

        end;

        AVC_FIXED: // VC: Fixed Attribute Default (XML 1.0, § 3.3.2)
        begin
          NormalizeAttrDeclValue(AttrDecl, NormalizedDefaultValue, Error);
          if Error in ET_WARNINGS then begin

            SpecifiedAttr := Elmt.GetAttributeNode(AttrDecl.Name);
            if Assigned(SpecifiedAttr) then begin
              // Check whether the specified attribute value and the
              // default value of the attribute declaration match:
              NormalizeAttributeValue(SpecifiedAttr.NodeValue, AttrDecl.AttrType, NormalizedAttrValue, Error);
              if not (Error in ET_WARNINGS) or
                 not (NormalizedAttrValue = NormalizedDefaultValue) then
              begin
                IsValid := False;
                if not SendErrorNotification(ET_FIXED_ATTRIBUTE_MISMATCH, AttrDecl, Elmt) then begin
                  AContinue := False;
                  Exit;
                end;
              end;
            end else
              AddDefaultAttr(Elmt, AttrDecl.Name, NormalizedDefaultValue);

          end else begin
            IsValid := False;
            if not SendErrorNotification(Error, AttrDecl, Elmt) then begin
              AContinue := False;
              Exit;
            end;
          end;
        end;

        AVC_REQUIRED: // VC: Required Attribute (XML 1.0, § 3.3.2)
        begin
          if not Elmt.HasAttribute(AttrDecl.Name) then begin
            IsValid := False;
            if not SendErrorNotification(ET_REQUIRED_ATTRIBUTE_NOT_SPECIFIED, AttrDecl, Elmt) then begin
              AContinue := False;
              Exit;
            end;
          end;
        end;

      end; {case ...}
    end; {for ...}
  end; {if ...}
end;

procedure TDtdValidationAgent.Clear;
begin
  FDtdModel.Clear;
  FIDs.Clear;
  FIDREFs.Clear;
end;

function TDtdValidationAgent.DocumentIsStandalone: Boolean;
// Returns 'True' if the document has no DTD or it has only an internal DTD
// subset which contains no parameter entity references or if standalone status
// of the document is 'yes'.  Otherwise 'False' is returned.
begin
  Assert(Assigned(OwnerDocument));

  if Assigned(OwnerDocument.DoctypeDecl) then begin
    if (OwnerDocument.DoctypeDecl.PublicId = '') and (OwnerDocument.DoctypeDecl.SystemId = '') then begin
      Result := not DtdModel.PEsInIntSubset;
    end else
      Result := OwnerDocument.XmlStandalone = STANDALONE_YES;
  end else
    Result := True;
end;

function TDtdValidationAgent.ExpandEntityReference(const EntRef: TDomEntityReference): TXmlErrorType;
var
  DocFrag: TDomDocumentFragment;
  Dummy1: Boolean;
  Dummy2: Int64;
{$IFDEF NEXTGEN}
  ReplacementText: string;
{$ELSE !NEXTGEN}
  ReplacementText: WideString;
{$ENDIF NEXTGEN}
begin
  EntRef.SetReadOnly(False);
  try
    EntRef.Clear;

    Result := FindEntityReplacementText(EntRef.NodeName, ReplacementText, Dummy1, Dummy2);
    if (Result in ET_WARNINGS) then begin
      try
        DocFrag := ParseWideString(ReplacementText);
        try
          EntRef.AppendChild(DocFrag);
        finally
          DocFrag.Free;
        end;
      except
        Result := ET_NO_PROPER_MARKUP_REFERENCED;                                                              
      end;
    end;

    EntRef.MakeChildrenReadOnly;

  finally
    EntRef.SetReadOnly(True);
  end;
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.FindAttributeDecl(const ElementName,
                                                     AttributeName: string): TDtdAttributeDecl;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.FindAttributeDecl(const ElementName,
                                                     AttributeName: WideString): TDtdAttributeDecl;
{$ENDIF NEXTGEN}
begin
  Result := DtdModel.FindAttributeDecl(ElementName, AttributeName);
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.FindElementDecl(const Name: string): TDtdElementDecl;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.FindElementDecl(const Name: WideString): TDtdElementDecl;
{$ENDIF NEXTGEN}
begin
  Result := DtdModel.FindElementDecl(Name);
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.FindEntityDecl(const Name: string): TDtdEntityDecl;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.FindEntityDecl(const Name: WideString): TDtdEntityDecl;
{$ENDIF NEXTGEN}
begin
  Result := DtdModel.FindEntityDecl(Name);
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.FindEntityReplacementText(const EntityName: string;
                                                         out ReplText: string;
                                                         out IsExternalEntity: Boolean;
                                                         out Key: Int64): TXmlErrorType;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.FindEntityReplacementText(const EntityName: WideString;
                                                         out ReplText: WideString;
                                                         out IsExternalEntity: Boolean;
                                                         out Key: Int64): TXmlErrorType;
{$ENDIF NEXTGEN}
var
  EntDecl: TDtdEntityDecl;
begin
  Assert(Assigned(OwnerDocument));

  IsExternalEntity := False;
  Key := 0; // The Key return value must be 0 if no entity declaration was fount.
  EntDecl := FindEntityDecl(EntityName);

  if Assigned(EntDecl) then begin

    IsExternalEntity := EntDecl.EntityType = DTD_EXTERNAL_ENTITY;
    Key := EntDecl.Key;

    Result := EntDecl.ResolveReplacementText(ResolveEntity);
    if not (Result in ET_WARNINGS) then begin
      ReplText := '';
      Exit;
    end;

    if not EntDecl.CheckNoRecursion then begin
      ReplText := '';
      Result := ET_RECURSIVE_REFERENCE;
    end else begin
      Result := ET_NONE;
      ReplText := EntDecl.ReplacementText;
      if EntDecl.Origin = DTD_EXTERNALLY_DECLARED then begin
        if DocumentIsStandalone then
          // WFC: Entity declared (XML 1.0, § 4.1)
          Result := ET_EXT_DECL_ENTITY_REFERENCED_IN_STANDALONE_DOC;
      end;
    end;

  end else begin

    ReplText := '';
    if DocumentIsStandalone then begin
      // WFC: Entity declared (XML 1.0, § 4.1)
      Result := ET_UNDEFINED_ENTITY_WFC;
    end else begin
      // VC: Entity declared (XML 1.0, § 4.1)
      Result := ET_UNDEFINED_ENTITY_VC;
    end;

  end;
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.FindNotationDecl(const Name: string): TDtdNotationDecl;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.FindNotationDecl(const Name: WideString): TDtdNotationDecl;
{$ENDIF NEXTGEN}
begin
  Result := DtdModel.FindNotationDecl(Name);
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.GetAttrDataType(const ElementName,
                                                   AttrName: string): TXmlDataType;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.GetAttrDataType(const ElementName,
                                                   AttrName: WideString): TXmlDataType;
{$ENDIF NEXTGEN}
var
  AttrDecl: TDtdAttributeDecl;
begin
  AttrDecl := DtdModel.FindAttributeDecl(ElementName, AttrName);
  if Assigned(AttrDecl)
    then Result := AttrDecl.AttrType
    else Result := AS_STRING_DATATYPE;
end;

function TDtdValidationAgent.GetDomImplementation: TDomImplementation;
begin
  Assert(Assigned(OwnerDocument));
  Result := OwnerDocument.DomImplementation;
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.GetElementContentType(const ElementName: string): TDtdContentType;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.GetElementContentType(const ElementName: WideString): TDtdContentType;
{$ENDIF NEXTGEN}
var
  E_Decl: TDtdElementDecl;
begin
  E_Decl := FindElementDecl(ElementName);
  if Assigned(E_Decl)
    then Result := E_Decl.ContentType
    else Result := DTD_ANY_CONTENTTYPE;
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.IsUnparsedEntity(const EntityName: string): Boolean;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.IsUnparsedEntity(const EntityName: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  EntityDecl: TDtdEntityDecl;
begin
  EntityDecl := FindEntityDecl(EntityName);
  if Assigned(EntityDecl)
    then Result := not EntityDecl.IsParsedEntity
    else Result := False;
end;

{$IFDEF NEXTGEN}
procedure TDtdValidationAgent.NormalizeAttrValueStep1(const S: string;
                                                      const AttrDeclKey: Int64;
                                                        out S_Normalized: string;
                                                        out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TDtdValidationAgent.NormalizeAttrValueStep1(const S: WideString;
                                                      const AttrDeclKey: Int64;
                                                        out S_Normalized: WideString;
                                                        out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
// This method performs the first steps of attribute value normalization (see
// XML 1.0, sec. 3.3.3).  All line breaks in 'S' must have been normalized to
// #xA. The function starts with a normalized value consisting of the empty
// WideString. For each character, entity reference, or character reference in
// the unnormalized attribute value, beginning with the first and continuing to
// the last, it does the following:
//
// - For a character reference, it appends the referenced character to the
//   normalized value.
// - For an entity reference, it recursively applies this step to the
//   replacement text of the entity.
// - For a white space character (#x20, #xD, #xA, #x9), it appends a space
//   character (#x20) to the normalized value.
// - For another character, it appends the character to the normalized value.
//
// The AttrDeclKey parameter indicates whether the value of an (ordinary)
// attribute is to be normalized (AttrDeclKey = 0) or the default value of an
// attribute definition (AttrDeclKey > 0).

const
  SPACE: WideChar = #$20; // ' '
  LT:    WideChar = #$3C; // '<'
type
  TKindOfToken = (IS_TEXT, IS_REFSTART, IS_CHARREF, IS_ENTITYREF);
var
{$IFDEF NEXTGEN}
  CharRefStr: string;
  NormalizedReplacementText: string;
  ReplacementText: string;
{$ELSE !NEXTGEN}
  CharRefStr: WideString;
  NormalizedReplacementText: WideString;
  ReplacementText: WideString;
{$ENDIF NEXTGEN}
  EntityKey: Int64;
  IsExternalEntity: Boolean;
  Text: TUtilsCustomWideStr;
  Tokenizer: TXmlAttrValueTokenizer;
begin
  Error := ET_NONE;
  Text := TUtilsCustomWideStr.Create;
  try

    Tokenizer := TXmlAttrValueTokenizer.Create(S);
    try
      while not (Tokenizer.TokenType = ATTR_END_OF_SOURCE_TOKEN) do begin
        Tokenizer.Next;

        if Tokenizer.ErrorType <> ET_NONE then begin
          if Tokenizer.ErrorType in ET_FATAL_ERRORS then begin
            Error := Tokenizer.ErrorType;
            S_Normalized := '';
            Exit;
          end;
          if not (Error in ET_ERRORS) then
            Error := Tokenizer.ErrorType;
        end;

        case Tokenizer.TokenType of

          ATTR_CHAR_REF:
            try
{$IFDEF NEXTGEN}
              CharRefStr := XmlCharRefToStr(Concat(string('&#'), Tokenizer.TokenValue, string(';')));
{$ELSE !NEXTGEN}
              CharRefStr := XmlCharRefToStr(Concat(WideString('&#'), Tokenizer.TokenValue, WideString(';')));
{$ENDIF NEXTGEN}
              Text.AddWideString(CharRefStr);
            except
              on EConvertError do begin
                Error := ET_INVALID_CHAR_REF;
                Exit;
              end;
            end;

          ATTR_ENTITY_REF: begin
            Error := FindEntityReplacementText(Tokenizer.TokenValue,
                       ReplacementText, IsExternalEntity, EntityKey);

            // References to external entities are not allowed in attribute
            // values or default values of attribute definitions (see XML 1.0,
            // sec. 3.1 and 3.3.2).
            if IsExternalEntity then begin
              // WFC: No External Entity Reference (XML 1.0, § 3.1)
              Error := ET_ATTRIBUTE_VALUE_REFERS_TO_EXTERNAL_ENTITY;
              Exit;
            end;

            if not (Error in  ET_WARNINGS) then
              // VC: Entity declared (XML 1.0, § 4.1)
              Exit;

            if Pos(LT, ReplacementText) <> 0 then begin
              // WFC: No < in Attribute Values (XML 1.0, § 3.1)
              Error := ET_LT_IN_ATTRIBUTE_VALUE;
              Exit;
            end;

            // The declaration of a general entity must precede any
            // attribute-list declaration containing a default value with a
            // direct or indirect reference to that general entity (see
            // XML 1.0, sec. 4.1).
            //
            // AttrDeclKey > 0 indicates that we are processing the default
            // value of an attribute definition, not an (ordinary)
            // attribute value.
            if (AttrDeclKey > 0) and (EntityKey > AttrDeclKey) then begin
              if DocumentIsStandalone then begin
                // WFC: Entity declared (XML 1.0, § 4.1)
                Error := ET_ENTITY_REFERENCED_BEFORE_DECLARED_WFC;
              end else begin
                // VC: Entity declared (XML 1.0, § 4.1)
                Error := ET_ENTITY_REFERENCED_BEFORE_DECLARED_VC;
              end;
              Exit;
            end;

            NormalizeAttrValueStep1(ReplacementText, AttrDeclKey,
                                    NormalizedReplacementText, Error);

            if not (Error in  ET_WARNINGS) then
              Exit;
            Text.AddWideString(NormalizedReplacementText);
          end;

          ATTR_TEXT:
            if IsXmlS(Tokenizer.TokenValue)
              then Text.AddWideChar(SPACE)
              else Text.AddWideString(Tokenizer.TokenValue);

        end; {case ...}

      end; {while ...}
    finally
      Tokenizer.Free;
    end;

    S_Normalized := Text.Value;

  finally
    Text.Free;
  end;
end;

{$IFDEF NEXTGEN}
procedure TDtdValidationAgent.NormalizeValue(const AttrLiteralValue: string;
                                             const AttrDataType: TXmlDataType;
                                             const AttrDeclKey: Int64;
                                               out NormalizedValue: string;
                                               out Error: TXmlErrorType);
var
  S: string;
{$ELSE !NEXTGEN}
procedure TDtdValidationAgent.NormalizeValue(const AttrLiteralValue: WideString;
                                             const AttrDataType: TXmlDataType;
                                             const AttrDeclKey: Int64;
                                               out NormalizedValue: WideString;
                                               out Error: TXmlErrorType);
var
  S: WideString;
{$ENDIF NEXTGEN}
begin
  if AttrDataType = AS_STRING_DATATYPE then begin
    NormalizeAttrValueStep1(AttrLiteralValue, AttrDeclKey, NormalizedValue, Error);
  end else begin
    NormalizeAttrValueStep1(AttrLiteralValue, AttrDeclKey, S, Error);
    // Further attribute normalization (See XML 1.0, § 3.3.3):
    NormalizedValue := NormalizeSpace(S);
  end;
end;

{$IFDEF NEXTGEN}
procedure TDtdValidationAgent.NormalizeAttributeValue(const AttrLiteralValue: string;
                                                      const AttrDataType: TXmlDataType;
                                                        out NormalizedValue: string;
                                                        out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TDtdValidationAgent.NormalizeAttributeValue(const AttrLiteralValue: WideString;
                                                      const AttrDataType: TXmlDataType;
                                                        out NormalizedValue: WideString;
                                                        out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
begin
  NormalizeValue(AttrLiteralValue, AttrDataType, 0, NormalizedValue, Error);
end;

{$IFDEF NEXTGEN}
procedure TDtdValidationAgent.NormalizeAttrDeclValue(const AttrDecl: TDtdAttributeDecl;
                                                       out NormalizedValue: string;
                                                       out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TDtdValidationAgent.NormalizeAttrDeclValue(const AttrDecl: TDtdAttributeDecl;
                                                       out NormalizedValue: WideString;
                                                       out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
begin
  NormalizeValue(AttrDecl.DefaultValue, AttrDecl.AttrType, AttrDecl.Key, NormalizedValue, Error);
end;

procedure TDtdValidationAgent.BuildDtdModel(const ResolveExtEntities: Boolean);
const
  BUFFER_SIZE: Integer = 4096;
var
  DtdToDtdModelParser: TDtdToDtdModelParser;
begin
  Assert(Assigned(OwnerDocument));

  Clear;
  if Assigned(OwnerDocument.DoctypeDecl) then begin
    DtdToDtdModelParser := TDtdToDtdModelParser.Create(nil);
    try
      DtdToDtdModelParser.DOMImpl := DomImplementation;
      DtdToDtdModelParser.BufferSize := BUFFER_SIZE;
      DtdToDtdModelParser.TargetDtdModel := DtdModel;
      DtdToDtdModelParser.ParseDocTypeDecl(OwnerDocument.DoctypeDecl, ResolveExtEntities, True);                                                      
    finally
      DtdToDtdModelParser.Free;
    end;
  end else
    DtdModel.PreparationStatus := PS_INEXISTANT;
end;

{$IFDEF NEXTGEN}
function TDtdValidationAgent.ParseWideString(const S: string): TDomDocumentFragment;
{$ELSE !NEXTGEN}
function TDtdValidationAgent.ParseWideString(const S: WideString): TDomDocumentFragment;
{$ENDIF NEXTGEN}
const
  BUFFER_SIZE: Integer = 4096;
var
  InputSource: TXmlSimpleInputSource;
  Parser: TXmlToDomParser;
begin
  Result := TDomDocumentFragment.Create(OwnerDocument);
  try
    Parser := TXmlToDomParser.Create(nil);
    try
      Parser.DOMImpl := DomImplementation;
      InputSource := TXmlSimpleInputSource.Create(S, '' ,'', BUFFER_SIZE, 0, 0, 0, 0, 1);
      try
                                                                                                      
        Parser.ParseFragment(InputSource, Result);
      finally
        InputSource.Free;
      end;
    finally
      Parser.Free;
    end;
  except
    Result.Free;
    raise;
  end;
end;

{$IFNDEF NEXTGEN}
procedure TDtdValidationAgent.ResolveEntity(const Origin: TDtdOrigin;
                                            const BaseURI,
                                                  PubId,
                                                  SysId: WideString;
                                              out ReplacementText: WideString;
                                              out Error: TXmlErrorType);
// Resolves an entity resource as a WideString.  Used as call-back function for
// TDtdEntityDecl.Resolve function calls.
//
// Parameters:
// - Origin
//    DTD_EXTERNALLY_DECLARED, if the declaration of the external entity appeared
//    in the external subset of a DTD or in a parameter entity (external or
//    internal, the latter being included because non-validating processors are
//    not required to read them); DTD_INTERNALLY_DECLARED otherwise.
// - BaseURI
//    The base URI of the resource to retreive.
// - PubId
//    The public identifier of the external entity to be resolved, or an empty
//    WideString, if the public identifier is unknown.
// - SysId
//    The system identifier of the external entity to be resolved, or an empty
//    WideString, if the system identifier is unknown.
// - ReplacementText
//    The replacement text of the entity as a WideString, if available.
// - Error
//    If an attempt to resolve an entity failed the Error parameter returns the
//    error code indicating the type of the error.  If no error occurred ET_NONE
//    is returned.
var
  PId: WideString;
  SId: WideString;
begin
  if not Assigned(DomImplementation) then begin
    ReplacementText := '';
    Error := ET_EXT_ENTITY_RESOURCE_NOT_FOUND;
    Exit;
  end;

  PId := PubId;
  // Calculate absolute system identifier:
  ResolveRelativeUriWideStr(BaseUri, SysId, SId);
     // Remark: Returns an empty SId if ResolveRelativeUriWideStr attempt fails.

  if Origin = DTD_INTERNALLY_DECLARED
    then DomImplementation.ResolveResourceAsWideString(DtdModel.IntSubsetSysId, PId, SId, ReplacementText, Error)
    else DomImplementation.ResolveResourceAsWideString(DtdModel.ExtSubsetSysId, PId, SId, ReplacementText, Error);
end;
{$ELSE NEXTGEN}
procedure TDtdValidationAgent.ResolveEntity(const Origin: TDtdOrigin;
                                            const BaseURI,
                                                  PubId,
                                                  SysId: DOMString;
                                              out ReplacementText: DOMString;
                                              out Error: TXmlErrorType);
// Resolves an entity resource as a WideString.  Used as call-back function for
// TDtdEntityDecl.Resolve function calls.
//
// Parameters:
// - Origin
//    DTD_EXTERNALLY_DECLARED, if the declaration of the external entity appeared
//    in the external subset of a DTD or in a parameter entity (external or
//    internal, the latter being included because non-validating processors are
//    not required to read them); DTD_INTERNALLY_DECLARED otherwise.
// - BaseURI
//    The base URI of the resource to retreive.
// - PubId
//    The public identifier of the external entity to be resolved, or an empty
//    WideString, if the public identifier is unknown.
// - SysId
//    The system identifier of the external entity to be resolved, or an empty
//    WideString, if the system identifier is unknown.
// - ReplacementText
//    The replacement text of the entity as a WideString, if available.
// - Error
//    If an attempt to resolve an entity failed the Error parameter returns the
//    error code indicating the type of the error.  If no error occurred ET_NONE
//    is returned.
var
  PId: DOMString;
  SId: DOMString;
begin
  if not Assigned(DomImplementation) then begin
    ReplacementText := '';
    Error := ET_EXT_ENTITY_RESOURCE_NOT_FOUND;
    Exit;
  end;

  PId := PubId;
  // Calculate absolute system identifier:
  ResolveRelativeUriStr(BaseUri, SysId, SId);
     // Remark: Returns an empty SId if ResolveRelativeUriWideStr attempt fails.

  if Origin = DTD_INTERNALLY_DECLARED
    then DomImplementation.ResolveResourceAsWideString(DtdModel.IntSubsetSysId, PId, SId, ReplacementText, Error)
    else DomImplementation.ResolveResourceAsWideString(DtdModel.ExtSubsetSysId, PId, SId, ReplacementText, Error);
end;
{$ENDIF !NEXTGEN}

function TDtdValidationAgent.SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                                   const RelDtdObject: TDtdObject;
                                                   const RelNode: TDomNode): Boolean;
// Used to centralize code for sending error notifications to the DomImplementation.
// Usually used during validation.
var
  Error: TDomError;
begin
  if ErrorReportingEnabled then begin
    Error := TDomError.Create(XmlErrorType, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                              '', RelDtdObject, RelNode, '', '');
    try
      if Assigned(DomImplementation) then begin
        Result := DomImplementation.HandleError(Self, Error);
      end else if Error.Severity = DOM_SEVERITY_FATAL_ERROR
        then Result := False
        else Result := True;
    finally
      Error.Free;
    end;
  end else
    Result := not (XmlErrorType in ET_FATAL_ERRORS);
end;

procedure TDtdValidationAgent.SetErrorReportingEnabled(const Value: Boolean);
begin
  FErrorReportingEnabled := Value;
end;

procedure TDtdValidationAgent.ValidateAttr(const Attr: TDomAttr;
                                           const Opt: TDomEntityResolveOption;
                                             out IsValid,
                                                 AContinue: Boolean);
// Return Values:
// - IsValid: Indicates whether the element is valid according to some tests
//            made in this subroutine.
// - AContinue: 'False' to indicate that the validation should be aborted.

{$IFDEF NEXTGEN}
  function HasAttrEnum(const AttriDecl: TDtdAttributeDecl;
                       const AttriValue: string): Boolean;
{$ELSE !NEXTGEN}
  function HasAttrEnum(const AttriDecl: TDtdAttributeDecl;
                       const AttriValue: WideString): Boolean;
{$ENDIF NEXTGEN}
  var
    I: Integer;
  begin
    Result := False;
    if AttriDecl.Enumeration.Count = 0 then
      Result := True;
    for I := 0 to Pred(AttriDecl.Enumeration.Count) do
      if AttriDecl.Enumeration[I] = AttriValue then begin
        Result := True;
        Break;
      end;
  end;

const
  NULL: WideChar = #$0;  // End of WideString mark
  SPACE: WideChar  = #$20;
var
  C: WideChar;
  Error: TXmlErrorType;
  I, StartIndex, IndexCount: Integer;
  AttriDecl: TDtdAttributeDecl;
{$IFDEF NEXTGEN}
  NormalizedValue: string;
  StandaloneValue: string;
  S: string;
{$ELSE !NEXTGEN}
  NormalizedValue: WideString;
  StandaloneValue: WideString;
  S: WideString;
{$ENDIF NEXTGEN}
  Target: TUtilsCustomWideStr;
begin
  Assert(Assigned(Attr));
  Assert(Assigned(Attr.OwnerElement));
  AContinue := True;
  IsValid := True;

  // VC: Entity declared (XML 1.0, § 4.1)
  // WFC: No External Entity Reference (XML 1.0, § 3.1)
  // WFC: No < in Attribute Values (XML 1.0, § 3.1)
  NormalizeAttributeValue(Attr.NodeValue, Attr.DataType, NormalizedValue, Error);
  if not (Error = ET_NONE) then begin
    if not (Error in ET_WARNINGS) then
      IsValid := False;
    if not SendErrorNotification(Error, nil, Attr) then begin
      AContinue := False;
      Exit;
    end;
  end;

  // VC: Attribute Value Type (XML 1.0, § 3.1)
  AttriDecl := FindAttributeDecl(Attr.OwnerElement.NodeName, Attr.NodeName);
  if not Assigned(AttriDecl) then begin
    IsValid := False;
    if not SendErrorNotification(ET_UNDEFINED_ATTRIBUTE, nil, Attr) then
      AContinue := False;
    Exit;  // Exit even if SendErrorNotification returned 'True',
           // because AttriDecl must be assigned for the following operations.
  end;

  // VC: Standalone Document Declaration (XML 1.0, § 2.9)
  if AttriDecl.Origin = DTD_EXTERNALLY_DECLARED then
    if DocumentIsStandalone then begin

      if not Attr.Specified then begin
        IsValid := False;
        if not SendErrorNotification(ET_UNSPECIFIED_EXT_ATTR_IN_STANDALONE_DOC, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;

      // Calculate the replacement text of the attribute as if no type information had been provided:
      NormalizeAttrValueStep1(Attr.NodeValue, 0, StandaloneValue, Error);
      if Error in ET_WARNINGS then
        if StandaloneValue <> NormalizedValue then begin
          IsValid := False;
          if not SendErrorNotification(ET_UNNORMALIZED_EXT_ATTR_IN_STANDALONE_DOC, AttriDecl, Attr) then begin
            AContinue := False;
            Exit;
          end;
        end;
        // Remark: Errors encoutered during NormalizeAttrValueStep1 are
        // not considered, because that has been done after the call to
        // NormalizeAttributeValue above.

    end;



  // Resolve Entity References
  //
  // If the Opt parameter is 'erReplace' the literal value of the TDomAttr is
  // replaced with its normalized value which is modified as follows:
  // All ampersands (&) are replaced with &amp;, all open angle brackets (<)
  // with &lt;, all quotation mark characters with &quot;, and the whitespace
  // characters #x9, #xA, and #xD, with character references. The character
  // references are written in uppercase hexadecimal with no leading zeroes (for
  // example, #xD is represented by the character reference &#xD;).
  if Opt = erReplace then begin
    Target := TUtilsCustomWideStr.Create;
    try
      for I := FirstIndex to {$IFDEF CLR}Borland.Delphi.{$ENDIF}System.Length(NormalizedValue) - AdjustIndex do begin
        C := NormalizedValue[I];
        case Ord(C) of
          TAB: Target.AddWideString('&#x9;');
          LF:  Target.AddWideString('&#xA;');
          CR:  Target.AddWideString('&#xD;');
          DQ:  Target.AddWideString('&quot;');
          AMP: Target.AddWideString('&amp;');
          LT:  Target.AddWideString('&lt;');
        else
          Target.AddWideChar(C);
        end;
      end;
      Attr.NodeValue := Target.Value;
    finally
      Target.Free;
    end;
  end;

  // VC: Attribute Value Type (XML 1.0, § 3.1)
  case AttriDecl.AttrType of

    AS_STRING_DATATYPE:
    begin
      // VC: XML Schema Part 2: Datatypes: Strings
      if not IsXMLChars(NormalizedValue) then begin
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;
    end;

    AS_NOTATION_DATATYPE:
    begin
      // VC: Notation Attributes (XML 1.0, § 3.3.1)
      if not HasAttrEnum(AttriDecl, NormalizedValue) then begin
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;
    end;

    AS_ID_DATATYPE:
    begin
      // VC: Entity (XML 1.0, § 3.3.1)
      if not IsXMLName(NormalizedValue) then begin
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;

      try
        FIDs.AddObject(NormalizedValue, Attr.OwnerElement);
      except
        // VC: ID (XML 1.0, § 3.3.1)
        on EStringListError do begin
          IsValid := False;
          if not SendErrorNotification(ET_DUPLICATE_ID_VALUE, AttriDecl, Attr) then begin
            AContinue := False;
            Exit;
          end;
        end;
      end;
    end;

    AS_IDREF_DATATYPE:
    begin
      // VC: Entity (XML 1.0, § 3.3.1)
      if not IsXMLName(NormalizedValue) then begin
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;

      FIDREFs.AddObject(NormalizedValue, Attr);
    end;

    AS_IDREFS_DATATYPE:
    begin
      // VC: Entity (XML 1.0, § 3.3.1)
      if not IsXmlNames(NormalizedValue) then begin
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;

      StartIndex := 1; IndexCount := 0;
      for I := 1 to {$IFDEF CLR}Borland.Delphi.{$ENDIF}System.Length(NormalizedValue) do begin
        if NormalizedValue[I-AdjustIndex] = SPACE then begin
          S := Copy(NormalizedValue, StartIndex, IndexCount);
          FIDREFs.AddObject(S, Attr);
          StartIndex := Succ(I);
          IndexCount := 0;
        end else
          Inc(IndexCount);
      end;
      S := Copy(NormalizedValue, StartIndex, IndexCount);
      FIDREFs.AddObject(S, Attr);
    end;

    AS_ENTITY_DATATYPE:
    begin
      // VC: Entity Name (XML 1.0, § 3.3.1)
      if IsXMLName(NormalizedValue) then begin
        if not IsUnparsedEntity(NormalizedValue) then begin
          IsValid := False;
          if not SendErrorNotification(ET_UNDEFINED_TARGET_UNPARSED_ENTITY, AttriDecl, Attr) then begin
            AContinue := False;
            Exit;
          end;
        end;
      end else begin
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;
    end;

    AS_ENTITIES_DATATYPE:
    begin
      // VC: Entity Name (XML 1.0, § 3.3.1)
      if IsXmlNames(NormalizedValue) then begin
        StartIndex := 1; IndexCount := 0;
        for I := 1 to {$IFDEF CLR}Borland.Delphi.{$ENDIF}System.Length(NormalizedValue) do begin
          if NormalizedValue[I-AdjustIndex] = SPACE then begin
            if not IsUnparsedEntity(Copy(NormalizedValue, StartIndex, IndexCount)) then begin
              IsValid := False;
              if not SendErrorNotification(ET_UNDEFINED_TARGET_UNPARSED_ENTITY, AttriDecl, Attr) then begin
                AContinue := False;
                Exit;
              end;
            end;
            StartIndex := Succ(I);
            indexCount := 0;
          end else Inc(IndexCount);
        end;
        if not IsUnparsedEntity(Copy(NormalizedValue, StartIndex, IndexCount)) then begin
          IsValid := False;
          if not SendErrorNotification(ET_UNDEFINED_TARGET_UNPARSED_ENTITY, AttriDecl, Attr) then begin
            AContinue := False;
            Exit;
          end;
        end;
      end else begin
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;
    end;

    AS_NMTOKEN_DATATYPE:
    begin
      if IsXmlNmtoken(NormalizedValue) then begin
        // VC: Enumeration (XML 1.0, § 3.3.1)
        if not HasAttrEnum(AttriDecl, NormalizedValue) then begin
          IsValid := False;
          if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
            AContinue := False;
            Exit;
          end;
        end;
      end else begin
        // VC: Name Token (XML 1.0, § 3.3.1)
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;
    end;

    AS_NMTOKENS_DATATYPE:
    begin
      // VC: Name Token (XML 1.0, § 3.3.1)
      if not IsXmlNmtokens(NormalizedValue) then begin
        IsValid := False;
        if not SendErrorNotification(ET_ATTRIBUTE_TYPE_MISMATCH, AttriDecl, Attr) then begin
          AContinue := False;
          Exit;
        end;
      end;
    end;

  end; {case ...}

end;

procedure TDtdValidationAgent.ValidateDTD(out IsValid,
                                              AContinue: Boolean);
// Validates the DTD model.  Each fatal error, error or warning encountered
// is reported via the OnError event of the TDomImplementation component
// associated with the owner document.  OnError events might occur more than
// once, if more than one fatal error, error or warning is encountered.
//
// Return Values:
// - IsValid: Indicates whether the DTD itself is valid or not.
// - AContinue: 'False' to indicate that the validation should be aborted.
//
// Note that not every violation of a validity constraint is being detected,
// since documents using the TDtdValidationAgent object are themselves not
// automatically checked for validity.

  procedure ValidateElementDeclarations(out IsValid, AContinue: Boolean);
  var
    Dummy: Integer;
    ElmtDecl: TDtdElementDecl;
    EnumerationTypes: TUtilsWideStringList;
    ContModel: TDtdContentModel;
    I, J: Integer;
  begin
    AContinue := True;
    IsValid := True;
    for I := 0 to Pred(DtdModel.ElementDecls.Length) do begin
      ElmtDecl := TDtdElementDecl(DtdModel.ElementDecls.Item(I));
      // VC: No Duplicate Types (XML 1.0, § 3.2.2).
      if ElmtDecl.ContentType = DTD_MIXED_CONTENTTYPE then begin                                                                  
        if not Assigned(ElmtDecl.ContentModel) then begin
          IsValid := False;
          if not SendErrorNotification(ET_INVALID_ELEMENT_DECL, ElmtDecl, nil) then begin                                                                                
            AContinue := False;
            Exit;
          end;
        end else begin
          if ElmtDecl.ContentModel.ContentModelType = DTD_CHOICE_CM then begin
            EnumerationTypes := TUtilsWideStringList.Create;
            EnumerationTypes.Sorted := True;
            EnumerationTypes.Duplicates := dupError;
            try
              for J := 0 to Pred(ElmtDecl.ContentModel.SubModels.Length) do begin
                if ElmtDecl.ContentModel.SubModels.Item(J).ObjectType <> DTD_CONTENT_MODEL then begin
                  IsValid := False;
                  if not SendErrorNotification(ET_INVALID_ELEMENT_DECL, ElmtDecl, nil) then begin                                                                                
                    AContinue := False;
                    Exit;
                  end;
                end else begin
                  ContModel := TDtdContentModel(ElmtDecl.ContentModel.SubModels.Item(J));
                  if ContModel.ContentModelType <> DTD_ELEMENT_CM then begin
                    IsValid := False;
                    if not SendErrorNotification(ET_INVALID_ELEMENT_DECL, ElmtDecl, nil) then begin                                                                                
                      AContinue := False;
                      Exit;
                    end;
                  end else begin
                    if EnumerationTypes.Find(ContModel.Name, Dummy) then begin
                      IsValid := False;
                      if not SendErrorNotification(ET_DUPLICATE_NAME_IN_MIXED_CONTENT, ElmtDecl, nil) then begin
                        AContinue := False;
                        Exit;
                      end;
                    end else EnumerationTypes.Add(ContModel.Name);
                  end; {if ... else ...}
                end; {if ... else ...}
              end; {for J ...}
            finally
              EnumerationTypes.Free;
            end;
          end else begin
            IsValid := False;
            if not SendErrorNotification(ET_INVALID_ELEMENT_DECL, ElmtDecl, nil) then begin                                                                                
              AContinue := False;
              Exit;
            end;
          end; {if ... else ...}
        end; {if ... else ...}
      end; {if ...}
    end; {for I ...}
  end;

  procedure ValidateEntityDeclarations(out IsValid, AContinue: Boolean);
  var
    I, J: Integer;
  begin
    AContinue := True;
    IsValid := True;
    for I := 0 to Pred(DtdModel.EntityDecls.Length) do
    begin
      // Issue warning, if system identifier is erroneous (cf. XML 1.0, § 4.2.2)
      //if not IsUriURI_referenceWideStr(SystemId) then begin
      if not IsUriURI_referenceStr(TDtdEntityDecl(DtdModel.EntityDecls.Item(I)).SystemId) then begin
        if not SendErrorNotification(ET_SYSTEM_IDENTIFIER_IS_NOT_URI_REFERENCE, TDtdEntityDecl(DtdModel.EntityDecls.Item(I)), nil) then begin
          IsValid := False;                                                                                             
          AContinue := False;
          Exit;
        end;
      end else if Pos('#', TDtdEntityDecl(DtdModel.EntityDecls.Item(I)).SystemId) > 0 then begin
        if not SendErrorNotification(ET_FRAGMENT_IDENTIFIER_IN_SYSTEM_IDENTIFIER, TDtdEntityDecl(DtdModel.EntityDecls.Item(I)), nil) then begin
          IsValid := False;                                                                                              
          AContinue := False;
          Exit;
        end;
      end;

      // Issue warning, if a reference to an unparsed entity appears in the
      // EntityValue in an entity declaration (cf. XML 1.0., § 4.4.9)
      for J := 0 to Pred(TDtdEntityDecl(DtdModel.EntityDecls.Item(I)).EntityRefs.Count) do
        if IsUnparsedEntity(TDtdEntityDecl(DtdModel.EntityDecls.Item(I)).EntityRefs[J]) then begin
          if not SendErrorNotification(ET_UNPARSED_ENTITY_REFERENCED_IN_ENTITY_DECLARATION, TDtdEntityDecl(TDtdEntityDecl(DtdModel.EntityDecls.Item(I))), nil) then begin
            IsValid := False;                                                                                             
            AContinue := False;
            Exit;
          end;
          Break;
        end;




      // VC: Notation Declared (XML 1.0, § 4.2.2)
      if not TDtdEntityDecl(DtdModel.EntityDecls.Item(I)).IsParsedEntity then
        if not Assigned(FindNotationDecl(TDtdEntityDecl(DtdModel.EntityDecls.Item(I)).NotationName)) then begin
          IsValid := False;
          if not Self.SendErrorNotification(ET_UNDEFINED_NOTATION, TDtdEntityDecl(DtdModel.EntityDecls.Item(I)), nil) then begin
            AContinue := False;
            Exit;
          end;
        end;

    end;
  end;

  procedure ValidateAttributeDeclarations(const IDNames,
                                                NotationNames: TUtilsWideStringList;
                                            out IsValid, AContinue: Boolean);
  var
    AttrDecl: TDtdAttributeDecl;
    Dummy: Integer;
    AttDeclCol: TDtdAttDeclCollection;
    ElmtDecl: TDtdElementDecl;
    EnumerationTokens: TUtilsWideStringList;
    I, J, K: Integer;
    NormalizationError: TXmlErrorType;
{$IFDEF NEXTGEN}
    NormalizedValue: string;
{$ELSE !NEXTGEN}
    NormalizedValue: WideString;
{$ENDIF NEXTGEN}
    NotationTokens: TUtilsWideStringList;
  begin
    AContinue := True;
    IsValid := True;
    for I := 0 to Pred(DtdModel.AttDeclCollections.Length) do begin
      AttDeclCol := TDtdAttDeclCollection(DtdModel.AttDeclCollections.Item(I));
        for J := 0 to Pred(AttDeclCol.AttributeDecls.Length) do begin
          AttrDecl := TDtdAttributeDecl(AttDeclCol.AttributeDecls.Item(J));

          if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then begin
            NormalizeAttrDeclValue(AttrDecl, NormalizedValue, NormalizationError);
            if not (NormalizationError in ET_WARNINGS) then
              IsValid := False;
            if NormalizationError <> ET_NONE then begin
              if not SendErrorNotification(NormalizationError, AttrDecl, nil) then begin
                AContinue := False;
                Exit;
              end;
            end;
          end else
            NormalizedValue := '';

          case AttrDecl.AttrType of

            AS_ID_DATATYPE:
            begin
              // VC: One ID per Element Type (XML 1.0, § 3.3.1)
              if IdNames.Find(AttDeclCol.Name, Dummy) then begin
                IsValid := False;
                if not SendErrorNotification(ET_DUPLICATE_ID_ON_ELEMENT_TYPE, AttrDecl, nil) then begin
                  AContinue := False;
                  Exit;
                end;
              end else
                IdNames.Add(AttDeclCol.Name);
              // VC: ID Attribute Default (XML 1.0, § 3.3.1)
              if not ( AttrDecl.ConstraintType in [AVC_IMPLIED, AVC_REQUIRED] ) then begin
                IsValid := False;
                if not SendErrorNotification(ET_ID_NEITHER_IMPLIED_NOR_REQUIRED, AttrDecl, nil) then begin
                  AContinue := False;
                  Exit;
                end;
              end;
            end;

            AS_NOTATION_DATATYPE:
            begin
              NotationTokens := TUtilsWideStringList.Create;
              NotationTokens.Sorted := True;
              NotationTokens.Duplicates := dupError;
              try
                for K := 0 to Pred(AttrDecl.Enumeration.Count) do begin
                  // VC: Notation Attributes (XML 1.0, § 3.3.1)
                  if not Assigned(FindNotationDecl(AttrDecl.Enumeration.WideStrings[K])) then begin
                    IsValid := False;
                    if not SendErrorNotification(ET_UNDEFINED_NOTATION, AttrDecl, nil) then begin
                      AContinue := False;
                      Exit;
                    end;
                  end;
                  // VC: No Duplicate Tokens (XML 1.0, § 3.3.1)
                  if NotationTokens.Find(AttrDecl.Enumeration.WideStrings[K], Dummy) then begin
                    IsValid := False;
                    if not SendErrorNotification(ET_DUPLICATE_NOTATION_TOKEN, AttrDecl, nil) then begin
                      AContinue := False;
                      Exit;
                    end;
                  end else
                    NotationTokens.Add(AttrDecl.Enumeration.WideStrings[K]);
                end; {for ...}

                // VC: Attribute Default Value Syntactically Correct (XML 1.0, § 3.3.2)
                if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then
                  if not NotationTokens.Find(NormalizedValue, Dummy) then begin
                    IsValid := False;
                    if not SendErrorNotification(ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH, AttrDecl, nil) then begin
                      AContinue := False;
                      Exit;
                    end;
                  end;
              finally
                NotationTokens.Free;
              end;

              // VC: One Notation per Element Type (XML 1.0, § 3.3.1)
              if NotationNames.Find(AttDeclCol.Name, Dummy) then begin
                IsValid := False;
                if not SendErrorNotification(ET_DUPLICATE_NOTATION_ON_ELEMENT_TYPE, AttrDecl, nil) then begin
                  AContinue := False;
                  Exit;
                end;
              end else
                NotationNames.Add(AttDeclCol.Name);

              // VC: No Notation on Empty Element (XML 1.0, § 3.3.1)
              ElmtDecl := FindElementDecl(AttDeclCol.Name);
              if ElmtDecl.ContentType = DTD_EMPTY_CONTENTTYPE then begin
                IsValid := False;
                if not SendErrorNotification(ET_NOTATION_ON_EMPTY_ELEMENT, AttrDecl, nil) then begin
                  AContinue := False;
                  Exit;
                end;
              end;
            end; {AS_NOTATION_DATATYPE ...}

            AS_IDREF_DATATYPE:
            begin
              // VC: IDREF (XML 1.0, § 3.3.1)
              if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then begin
                // VC: Attribute Default Value Syntactically Correct (XML 1.0, § 3.3.2)
                if not IsXMLName(NormalizedValue) then begin
                  IsValid := False;
                  if not SendErrorNotification(ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH, AttrDecl, nil) then begin
                    AContinue := False;
                    Exit;
                  end;
                end;
              end;
            end;

            AS_IDREFS_DATATYPE:
            begin
              // VC: IDREF (XML 1.0, § 3.3.1)
              if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then begin
                // VC: Attribute Default Value Syntactically Correct (XML 1.0, § 3.3.2)
                if not IsXmlNames(NormalizedValue) then begin
                  IsValid := False;
                  if not SendErrorNotification(ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH, AttrDecl, nil) then begin
                    AContinue := False;
                    Exit;
                  end;
                end;
              end;
            end;

            AS_ENTITY_DATATYPE:
            begin
              // VC: Entity Name (XML 1.0, § 3.3.1)
              if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then begin
                // VC: Attribute Default Value Syntactically Correct (XML 1.0, § 3.3.2)
                if not IsXMLName(NormalizedValue) then begin
                  IsValid := False;
                  if not SendErrorNotification(ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH, AttrDecl, nil) then begin
                    AContinue := False;
                    Exit;
                  end;
                end;
              end;
            end;

            AS_ENTITIES_DATATYPE:
            begin
              // VC: Entity Name (XML 1.0, § 3.3.1)
              if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then begin
                // VC: Attribute Default Value Syntactically Correct (XML 1.0, § 3.3.2)
                if not IsXmlNames(NormalizedValue) then begin
                  IsValid := False;
                  if not SendErrorNotification(ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH, AttrDecl, nil) then begin
                    AContinue := False;
                    Exit;
                  end;
                end;
              end;
            end;

            AS_NMTOKEN_DATATYPE:
            begin
              EnumerationTokens := TUtilsWideStringList.Create;
              try
                EnumerationTokens.Sorted := True;
                EnumerationTokens.Duplicates := dupError;
                // VC: No Duplicate Tokens (XML 1.0, § 3.3.1)
                for K := 0 to Pred(AttrDecl.Enumeration.Count) do begin
                  if EnumerationTokens.Find(AttrDecl.Enumeration.WideStrings[K], Dummy) then begin
                    IsValid := False;
                    if not SendErrorNotification(ET_DUPLICATE_ENUMERATION_TOKEN, AttrDecl, nil) then begin
                      AContinue := False;
                      Exit;
                    end;
                  end else
                    EnumerationTokens.Add(AttrDecl.Enumeration.WideStrings[K]);
                end;
                // VC: Name Token (XML 1.0, § 3.3.1)
                if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then begin
                  // VC: Attribute Default Value Syntactically Correct (XML 1.0, § 3.3.2)
                  if not IsXmlNmtoken(NormalizedValue) then begin
                    IsValid := False;
                    if not SendErrorNotification(ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH, AttrDecl, nil) then begin
                      AContinue := False;
                      Exit;
                    end
                  end else if EnumerationTokens.Count > 0 then
                    if not EnumerationTokens.Find(NormalizedValue, Dummy) then begin
                      IsValid := False;
                      if not SendErrorNotification(ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH, AttrDecl, nil) then begin
                        AContinue := False;
                        Exit;
                      end;
                    end;
                end;
              finally
                EnumerationTokens.Free;
              end;
            end;

            AS_NMTOKENS_DATATYPE:
            begin
              // VC: Name Token (XML 1.0, § 3.3.1)
              if AttrDecl.ConstraintType in [AVC_DEFAULT, AVC_FIXED] then begin
                // VC: Attribute Default Value Syntactically Correct (XML 1.0, § 3.3.2)
                if not IsXmlNmtokens(NormalizedValue) then begin
                  IsValid := False;
                  if not SendErrorNotification(ET_ATTRIBUTE_DEFAULT_TYPE_MISMATCH, AttrDecl, nil) then begin
                    AContinue := False;
                    Exit;
                  end;
                end;
              end;
            end;

          end; {case}

          // Issue warning, if declaration of xml:space attribute is erroneous (cf. XML 1.0, § 2.10)
          if AttrDecl.Name = 'xml:space' then begin
            if AttrDecl.AttrType <> AS_NMTOKEN_DATATYPE then begin
              if not SendErrorNotification(ET_XML_SPACE_ATTRIBUTE_NOT_ENUMERATED_TYPE, AttrDecl, nil) then begin
                IsValid := False;                                                                                             
                AContinue := False;
                Exit;
              end;
            end else begin
              case AttrDecl.Enumeration.Count of
                1: if (AttrDecl.Enumeration[0] <> 'default') and (AttrDecl.Enumeration[0] <> 'preserve') then begin
                  if not SendErrorNotification(ET_XML_SPACE_ATTRIBUTE_ERRONEOUS_VALUE_DECLARED, AttrDecl, nil) then begin
                    IsValid := False;                                                                                             
                    AContinue := False;
                    Exit;
                  end;
                end;
                2: if not ( (AttrDecl.Enumeration[0] = 'default') and (AttrDecl.Enumeration[1] = 'preserve') or
                            (AttrDecl.Enumeration[0] = 'preserve') and (AttrDecl.Enumeration[1] = 'default') ) then begin
                  if not SendErrorNotification(ET_XML_SPACE_ATTRIBUTE_ERRONEOUS_VALUE_DECLARED, AttrDecl, nil) then begin
                    IsValid := False;                                                                                             
                    AContinue := False;
                    Exit;
                  end;
                end;
              else
                if not SendErrorNotification(ET_XML_SPACE_ATTRIBUTE_ERRONEOUS_VALUE_DECLARED, AttrDecl, nil) then begin
                  IsValid := False;                                                                                             
                  AContinue := False;
                  Exit;
                end;
              end;

            end;
          end;
      end; {for J ...}
    end; {for I ...}
  end;

var
  IdNames: TUtilsWideStringList;
  NotationNames: TUtilsWideStringList;
  IsValid_2: Boolean;
begin
  // Validiate Element Declarations:
  ValidateElementDeclarations(IsValid, AContinue);
  if not AContinue then Exit;

  // Validiate Entity Declarations:
  ValidateEntityDeclarations(IsValid_2, AContinue);
  IsValid := IsValid and IsValid_2;
  if not AContinue then Exit;

  // Validiate Attribute Declarations:
  IdNames := TUtilsWideStringList.Create;
  IdNames.Sorted := True;
  IdNames.Duplicates := dupError;
  NotationNames := TUtilsWideStringList.Create;
  NotationNames.Sorted := True;
  NotationNames.Duplicates := dupError;
  try
    ValidateAttributeDeclarations(IDNames, NotationNames, IsValid_2, AContinue);
    IsValid := IsValid and IsValid_2;
    if not AContinue then Exit;
  finally
    IDNames.Free;
    NotationNames.Free;
  end;
end;

function TDtdValidationAgent.ValidateDocument(const Opt: TDomEntityResolveOption): Boolean;
var
  Dummy: Integer;
  I: Integer;
  IsValid, AContinue: Boolean;
begin
  Result := True;
  FIDs.Clear;
  FIDREFs.Clear;

  try

    // Build the DTD model:
    if not (DtdModel.PreparationStatus = PS_COMPLETED) then begin
      BuildDtdModel(True);
      Result := DtdModel.PreparationStatus <> PS_INCOMPLETE_ABORTED;
    end;

    if DtdModel.PreparationStatus = PS_INEXISTANT then begin
      if not SendErrorNotification(ET_DOCTYPE_NOT_FOUND, nil, OwnerDocument) then
        Exit;
    end else begin
      // Validate the DTD model:
      ValidateDTD(IsValid, AContinue);
      Result := Result and IsValid;
      if not AContinue then
        Exit;
    end;

    if Assigned(OwnerDocument.DocumentElement) then begin

      // VC: Root Element Type (XML 1.0, § 2.8)
      if Assigned(OwnerDocument.DoctypeDecl) then
        if OwnerDocument.DoctypeDecl.Name <> OwnerDocument.DocumentElement.NodeName then begin
          Result := False;
          if not SendErrorNotification(ET_WRONG_ROOT_ELEMENT_TYPE, nil, OwnerDocument.DocumentElement) then
            Exit;
        end;

      // Validate the child nodes:
      ValidateNode(OwnerDocument.DocumentElement, Opt, IsValid, AContinue);
      Result := Result and IsValid;
      if not AContinue then
        Exit;

      // VC: IDREF (XML 1.0, § 3.3.1)
      for I := 0 to Pred(FIDREFs.Count) do
        if not FIDs.Find(FIDREFs[I], Dummy) then begin
          Result := False;
          if not SendErrorNotification(ET_TARGET_ID_VALUE_NOT_FOUND, nil, FIDREFs.Objects[I] as TDomAttr) then
            Exit;
        end;

    end else begin
      Result := False;
      if not SendErrorNotification(ET_ROOT_ELEMENT_NOT_FOUND, nil, OwnerDocument) then
        Exit;
    end;

  finally
    if not Result then begin
      FIDs.Clear;
      FIDREFs.Clear;
    end;
  end;
end;

procedure TDtdValidationAgent.ValidateElement(const Elmt: TDomElement;
                                              const Opt: TDomEntityResolveOption;
                                                out IsValid,
                                                    AContinue: Boolean);
// Return Values:
// - IsValid: Indicates whether the element is valid according to some tests
//            made in this subroutine.
// - AContinue: 'False' to indicate that the validation should be aborted.

  procedure ResolveEntityReferences(const Elmt: TDomElement;
                                    const Opt: TDomEntityResolveOption;
                                      out IsValid,
                                          AContinue: Boolean);
  var
    Dummy1: Boolean;
    Dummy2: Int64;
    Error: TXmlErrorType;
    I: Integer;
    HasEntRefs: Boolean;
    Child: TDomNode;
    DocFrag: TDomDocumentFragment;
{$IFDEF NEXTGEN}
    ReplacementText: string;
{$ELSE !NEXTGEN}
    ReplacementText: WideString;
{$ENDIF NEXTGEN}
  begin
    AContinue := True;
    IsValid := True;
    case Opt of

      erReplace:
      begin
        HasEntRefs := False;
        I := 0;
        while I < Elmt.ChildNodes.Length do begin
          Child := Elmt.ChildNodes.Item(I);
          if Child.NodeType = ntEntity_Reference_Node then begin
            HasEntRefs := True;

            Error := FindEntityReplacementText(Child.NodeName, ReplacementText, Dummy1, Dummy2);
            if Error <> ET_NONE then begin
              if not (Error in ET_WARNINGS) then
                IsValid := False;
              if not SendErrorNotification(Error, nil, Child) then begin
                AContinue := False;
                Exit;
              end;
            end;

            try
              DocFrag := ParseWideString(ReplacementText);
              try
                Elmt.ReplaceChild(DocFrag, Child);
                Child.Free;
                Dec(I); // Necessary, if an empty entity was referenced.
              finally
                DocFrag.Free;
              end;
            except
              Error := ET_NO_PROPER_MARKUP_REFERENCED;                                                              
              IsValid := False;
              if not SendErrorNotification(Error, nil, Child) then begin
                AContinue := False;
                Exit;
              end;
            end;

          end;
          Inc(I);
        end; {while ...}
        if HasEntRefs then
          Elmt.Normalize;
      end;

      erExpand:
      begin
        for I := 0 to Pred(Elmt.ChildNodes.Length) do begin
          Child := Elmt.ChildNodes.Item(I);
          if Child.NodeType = ntEntity_Reference_Node then begin
            Error := ExpandEntityReference(Child as TDomEntityReference);
            if Error <> ET_NONE then begin
              if not (Error in ET_WARNINGS) then
                IsValid := False;
              if not SendErrorNotification(Error, nil, Child) then begin
                AContinue := False;
                Exit;
              end;
            end;
          end;
        end; {for ...}
      end;

    end;
  end;

var
  ElementNames: TUtilsWideStringList;
  ElmDecl: TDtdElementDecl;
  I, Index: Integer;
  IsNonDeterministic: Boolean;
  NodeToTest: TDomNode;
  Dummy, IsValid_2, Ok: Boolean;
  TreeWalker: TDomTreeWalker;
begin
  Assert(Assigned(Elmt));
  AContinue := True;
  IsValid := True;

  // VC: Element Valid (XML 1.0, § 3)
  ElmDecl := FindElementDecl(Elmt.NodeName);
  if not Assigned(ElmDecl) then begin
    IsValid := False;
    if not SendErrorNotification(ET_UNDEFINED_ELEMENT_TYPE, nil, Elmt) then begin
      AContinue := False;
      Exit;
    end;
    ResolveEntityReferences(Elmt, Opt, Dummy, Dummy);
    Exit;  // Exit, because ElmDecl is unassigned.
  end;

  case ElmDecl.ContentType of

    DTD_ANY_CONTENTTYPE:
      ResolveEntityReferences(Elmt, Opt, IsValid, AContinue);

    DTD_EMPTY_CONTENTTYPE:
    begin
      for I := 0 to Pred(Elmt.ChildNodes.Length) do begin
        NodeToTest := Elmt.ChildNodes.Item(I);
        if not ( (NodeToTest.NodeType = ntText_Node) and (NodeToTest.NodeValue = '') ) then begin
          IsValid := False;
          if not SendErrorNotification(ET_ELEMENT_DECLARED_EMPTY_HAS_CONTENT, ElmDecl, Elmt) then begin
            AContinue := False;
            Exit;
          end;
        end;
      end;
      ResolveEntityReferences(Elmt, Opt, IsValid_2, AContinue);
      IsValid := IsValid and IsValid_2;
    end;

    DTD_ELEMENT_CONTENTTYPE:
    begin

      ResolveEntityReferences(Elmt, Opt, IsValid, AContinue);
      if not AContinue then
        Exit;

      ElementNames := TUtilsWideStringList.Create;
      try

        TreeWalker := Elmt.OwnerDocument.CreateTreeWalker( Elmt,
                        [ ntElement_Node, ntText_Node, ntCDATA_Section_Node ],
                        nil, True );
        try
          NodeToTest := TreeWalker.FirstChild;
          while Assigned(NodeToTest) do begin
            case NodeToTest.NodeType of
              ntElement_Node:
                Elementnames.Add(NodeToTest.NodeName);
              ntText_Node:
                if not (NodeToTest as TDomText).IsElementContentWhitespace then begin
                  IsValid := False;
                  AContinue := SendErrorNotification(ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_PCDATA_WHERE_ELEMENT_ONLY, ElmDecl, Elmt);
                  Exit;
                end else begin

                  // VC: Standalone Document Declaration (XML 1.0, § 2.9)
                  if ElmDecl.Origin = DTD_EXTERNALLY_DECLARED then
                    if DocumentIsStandalone then begin
                      IsValid := False;
                      AContinue := SendErrorNotification(ET_WHITESPACE_IN_EXT_ELEMENT_CONTENT_IN_STANDALONE_DOC, ElmDecl, Elmt);
                      Exit;
                    end;

                end;
              ntCDATA_Section_Node:
                begin
                  IsValid := False;
                  AContinue := SendErrorNotification(ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_CDATA_SECTION_WHERE_ELEMENT_ONLY, ElmDecl, Elmt);
                  Exit;
                end;
            end; {case ...}
            NodeToTest := TreeWalker.NextSibling;
          end; {while ...}
        finally
          Elmt.OwnerDocument.FreeTreeWalker(TreeWalker);
        end; {try ...}

        if not Assigned(ElmDecl.ContentModel) then
          raise EParserException.Create('Internal Parser error.');
        Index := 0;
        Ok := ElmDecl.ContentModel.ValidateNames(Elementnames, Index, IsNonDeterministic);
        if IsNonDeterministic then begin
          IsValid := False;
          AContinue := SendErrorNotification(ET_NONDETERMINISTIC_ELEMENT_CONTENT_MODEL, ElmDecl, Elmt);
        end else if not (Ok and (Index = Elementnames.Count)) then begin
          IsValid := False;
          AContinue := SendErrorNotification(ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_CHILD_ELEMENT_TYPE, ElmDecl, Elmt);
        end;

      finally
        Elementnames.Free;
      end;
    end;

    DTD_MIXED_CONTENTTYPE:
    begin

      ResolveEntityReferences(Elmt, Opt, IsValid, AContinue);
      if not AContinue then
        Exit;

      Elementnames := TUtilsWideStringList.Create;
      try

        TreeWalker := Elmt.OwnerDocument.CreateTreeWalker( Elmt, [ ntElement_Node ], nil, True );
        try
          NodeToTest := TreeWalker.FirstChild;
          while Assigned(NodeToTest) do begin
             Elementnames.Add(NodeToTest.NodeName);
            NodeToTest := TreeWalker.NextSibling;
          end;
        finally
          Elmt.OwnerDocument.FreeTreeWalker(TreeWalker);
        end; {try ...}

        if not Assigned(ElmDecl.ContentModel) then
          raise EParserException.Create('Internal Parser error.');
        if (ElmDecl.ContentModel.ContentModelType = DTD_CHOICE_CM) and
           (ElmDecl.ContentModel.SubModels.Length = 0) then begin  // Is PCDATA only?
          if Elementnames.Count > 0 then begin
            IsValid := False;
            AContinue := SendErrorNotification(ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_ELEMENT_WHERE_PCDATA_ONLY, ElmDecl, Elmt);
          end;
        end else begin
          Index := 0;
          Ok := ElmDecl.ContentModel.ValidateNames(Elementnames, Index, IsNonDeterministic);
          if IsNonDeterministic then begin                                                                                                                        
            IsValid := False;
            AContinue := SendErrorNotification(ET_NONDETERMINISTIC_ELEMENT_CONTENT_MODEL, ElmDecl, Elmt);
          end else if not (Ok and (Index = Elementnames.Count)) then begin
            IsValid := False;
            AContinue := SendErrorNotification(ET_ELEMENT_CONTENT_MODEL_MISMATCH_WITH_CHILD_ELEMENT_TYPE, ElmDecl, Elmt);
          end;
        end; {if ... else ...}

      finally
        Elementnames.Free;
      end;
    end;

    DTD_STRICT_MIXED_CONTENTTYPE:                                                                  
      raise EParserException.Create('DTD_STRICT_MIXED_CONTENTTYPE is currently not supported.');

  end; {case ...}
end;

procedure TDtdValidationAgent.ValidateEntityRef(const EntRef: TDomEntityReference;
                                                  out IsValid,
                                                      AContinue: Boolean);
// Return Values:
// - IsValid: Indicates whether the element is valid according to some tests
//            made in this subroutine.
// - AContinue: 'False' to indicate that the validation should be aborted.
var
  EntDecl: TDtdEntityDecl;
  Error: TXmlErrorType;
begin
  Assert(Assigned(OwnerDocument));

  AContinue := True;
  EntDecl := FindEntityDecl(EntRef.NodeName);

  if Assigned(EntDecl) then begin

    IsValid := True;

    Error := EntDecl.ResolveReplacementText(ResolveEntity);
    if not (Error = ET_NONE) then begin
      if not (Error in ET_WARNINGS) then
        IsValid := False;
      if not SendErrorNotification(Error, EntDecl, EntRef) then begin
        AContinue := False;
        Exit;
      end;
    end;

    if not EntDecl.CheckNoRecursion then begin
      // WFC: No Recursion (XML 1.0, § 4.1)
      IsValid := False;
      if not SendErrorNotification(ET_RECURSIVE_REFERENCE, EntDecl, EntRef) then begin
        AContinue := False;
        Exit;
      end;
    end;

    if EntDecl.Origin = DTD_EXTERNALLY_DECLARED then begin
      if DocumentIsStandalone then begin
        // WFC: Entity declared (XML 1.0, § 4.1)
        IsValid := False;
        if not SendErrorNotification(ET_EXT_DECL_ENTITY_REFERENCED_IN_STANDALONE_DOC, EntDecl, EntRef) then begin
          AContinue := False;
          Exit;
        end;
      end;
    end;

  end else begin

    IsValid := False;

    if DocumentIsStandalone then begin
      // WFC: Entity declared (XML 1.0, § 4.1)
      if not SendErrorNotification(ET_UNDEFINED_ENTITY_WFC, nil, EntRef) then begin
        AContinue := False;
        Exit;
      end;
    end else begin
      // VC: Entity declared (XML 1.0, § 4.1)
      if not SendErrorNotification(ET_UNDEFINED_ENTITY_VC, nil, EntRef) then begin
        AContinue := False;
        Exit;
      end;
    end;

  end;

end;

procedure TDtdValidationAgent.ValidateNode(const Node: TDomNode;
                                           const Opt: TDomEntityResolveOption;
                                             out IsValid,
                                                 AContinue: Boolean);
var
  I: Integer;
  IsValid_2: Boolean;
begin
  AContinue := True;
  IsValid := True;

  if Node is TDomElement then begin
    // Update and validate default and fixed attributes:
    AddAndValidateDefaultAttributes(TDomElement(Node), IsValid, AContinue);
    if not AContinue then
      Exit;

    // Validate the element content model:
    ValidateElement(TDomElement(Node), Opt, IsValid_2, AContinue);
    IsValid := IsValid and IsValid_2;
    if not AContinue then
      Exit;

    // Validate attributes:
    for I := 0 to Pred(Node.Attributes.Length) do begin
      ValidateNode(Node.Attributes.Item(I), Opt, IsValid_2, AContinue);
      IsValid := IsValid and IsValid_2;
      if not AContinue then
        Exit;
    end;

    // Validate child nodes:
    for I := 0 to Pred(Node.Childnodes.Length) do begin
      ValidateNode(Node.Childnodes.Item(I), Opt, IsValid_2, AContinue);
      IsValid := IsValid and IsValid_2;
      if not AContinue then
        Exit;
    end;

  end else if Node is TDomAttr then begin
    ValidateAttr(TDomAttr(Node), Opt, IsValid, AContinue);
    if not AContinue then
      Exit;

  end else if Node is TDomEntityReference then begin
    ValidateEntityRef(TDomEntityReference(Node), IsValid, AContinue);
    if not AContinue then
      Exit;
    // Validate child nodes:
    for I := 0 to Pred(Node.Childnodes.Length) do begin
      ValidateNode(Node.Childnodes.Item(I), Opt, IsValid_2, AContinue);
      IsValid := IsValid and IsValid_2;
      if not AContinue then
        Exit;
    end;

  end;
end;



//+++++++++++++++++++++++++++ TDtdObject +++++++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDtdObject.Create(const AOwner: TDtdModel;
                              const AName: string);
{$ELSE !NEXTGEN}
constructor TDtdObject.Create(const AOwner: TDtdModel;
                              const AName: WideString);
{$ENDIF NEXTGEN}
begin
  if not Assigned(AOwner) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Owner DTD subset model not specified.');

  inherited Create;

  FObjectType := DTD_UNDEFINED;
  FOwnerModel := AOwner;
  FName := AName;
  FKey := AOwner.GetNewKey;
end;

{$IFDEF NEXTGEN}
function TDtdObject.GetName: string;
{$ELSE !NEXTGEN}
function TDtdObject.GetName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FName;
end;



//+++++++++++++++++++++++++++ TDtdContentModel +++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDtdContentModel.Create(const AOwnerElementDecl: TDtdElementDecl;
                                      const AName: string;
                                      const AContentModelType: TDtdContentModelType);
{$ELSE !NEXTGEN}
constructor TDtdContentModel.Create(const AOwnerElementDecl: TDtdElementDecl;
                                      const AName: WideString;
                                      const AContentModelType: TDtdContentModelType);
{$ENDIF NEXTGEN}
begin
  if AContentModelType = DTD_ELEMENT_CM
    then inherited Create(AOwnerElementDecl.OwnerModel, AName)
    else inherited Create(AOwnerElementDecl.OwnerModel, '');

  case AContentModelType of
    DTD_ELEMENT_CM:
      FAllowedChildTypes := [];
    DTD_CHOICE_CM, DTD_SEQUENCE_CM:
      FAllowedChildTypes := [ DTD_ELEMENT_CM,
                              DTD_CHOICE_CM,
                              DTD_SEQUENCE_CM ];
  end;

  FContentModelType := AContentModelType;
  FFrequency := DTD_REQUIRED_FRQ;
  FInuse := False;
  FObjectType := DTD_CONTENT_MODEL;
  FOwnerElementDecl := AOwnerElementDecl;
  FSubModels := TDtdObjectList.Create;
end;

destructor TDtdContentModel.Destroy;
begin
  FSubModels.Free;
  inherited;
end;

function TDtdContentModel.AppendSubModel(const NewCM: TDtdContentModel): TDtdContentModel;
begin
  if NewCM.FInuse then
    raise EInuse_Err.Create('Content model in use error.');
  Result := (FSubModels.AppendNode(NewCM) as TDtdContentModel);
  NewCM.FInuse:= True;
end;

function TDtdContentModel.InsertBeforeSubModel(const NewCM,
                                                       RefCM: TDtdContentModel): TDtdContentModel;
begin
  if NewCM.FInuse then
    raise EInuse_Err.Create('Content model in use error.');
  Result := (FSubModels.InsertBefore(NewCM, RefCM) as TDtdContentModel);
  NewCM.FInuse:= True;
end;

function TDtdContentModel.RemoveSubModel(const OldCM: TDtdContentModel): TDtdContentModel;
begin
  if FSubModels.indexof(OldCM) = -1 then
    raise ENot_Found_Err.Create('Node not found error.');
  Result := (FSubModels.RemoveNode(OldCM) as TDtdContentModel);
  OldCM.FInuse:= False;
end;

function TDtdContentModel.ValidateChoiceNames(const Source: TUtilsWideStringList;
                                                  var Index: Integer;
                                                      Freq: TDtdFrequency;
                                                  out IsNonDeterministic: Boolean): Boolean;
var
  I: Integer;
  Matched: Boolean;
  MatchNumber: Integer;
  RestIndex, TempIndex: Integer;
begin
  IsNonDeterministic:= False;
  Result := False;

  RestIndex := Index;
  Matched := False;
  MatchNumber := 0;
  for I := 0 to Pred(SubModels.Length) do begin
    TempIndex := Index;
    if (SubModels.Item(I) as TDtdContentModel).ValidateNames(Source, TempIndex, IsNonDeterministic) then begin
      Matched := True;
      if Index <> TempIndex then begin // Do not count matching empty expressions
        Inc(MatchNumber);
        if MatchNumber > 1 then begin
          IsNonDeterministic := True;
          Break;
        end;
        RestIndex := TempIndex;
      end;
    end else if IsNonDeterministic then Break;
  end;

  case Freq of

    DTD_REQUIRED_FRQ:
    begin
      if Matched then begin
        Index := RestIndex;
        Result := True;
      end else Result := False;
    end;

    DTD_OPTIONAL_FRQ:
    begin
      if Matched then Index := RestIndex;
      Result := True;
    end;

  end; {case ...}

  if IsNonDeterministic then Result := False;
end;

function TDtdContentModel.ValidateElementNames(const Source: TUtilsWideStringList;
                                                   var Index: Integer;
                                                       Freq: TDtdFrequency;
                                                   out IsNonDeterministic: Boolean): Boolean;
begin
  IsNonDeterministic:= False;
  Result := False;

  case Freq of

    DTD_REQUIRED_FRQ:
    begin
      if Index = Source.Count then Exit;
      if Source[Index] = Name then begin
        Inc(Index);
        Result := True;
      end else Result := False;
    end;

    DTD_OPTIONAL_FRQ:
    begin
      Result := True;
      if Index = Source.Count then Exit;
      if Source[Index] = Name then Inc(Index);
    end;

  end; {case ...}
end;

function TDtdContentModel.ValidateNames2(const Source: TUtilsWideStringList;
                                             var Index: Integer;
                                                 Freq: TDtdFrequency;
                                             out IsNonDeterministic: Boolean): Boolean;
begin
  case ContentModelType of
    DTD_CHOICE_CM:   Result := ValidateChoiceNames(Source, Index, Freq, IsNonDeterministic);
    DTD_ELEMENT_CM:  Result := ValidateElementNames(Source, Index, Freq, IsNonDeterministic);
    DTD_SEQUENCE_CM: Result := ValidateSequenceNames(Source, Index, Freq, IsNonDeterministic);
  else
    Result := True;
  end;
end;

function TDtdContentModel.ValidateNames(const Source: TUtilsWideStringList;
                                            var Index: Integer;
                                            out IsNonDeterministic: Boolean): Boolean;
// Validates a sequence of names contained in the 'Source' list, starting at
// the 'Index' position against the content model.  If successful, 'Index'
// returns the position of the first name of the 'Source' list which remains
// after applying the content model to the names of the list.
var
  TempIndex: Integer;
begin
  Result := False;
  IsNonDeterministic:= False;
  case Frequency of

    DTD_REQUIRED_FRQ:
      Result := ValidateNames2(Source, Index, DTD_REQUIRED_FRQ, IsNonDeterministic);

    DTD_OPTIONAL_FRQ:
    Result := ValidateNames2(Source, Index, DTD_OPTIONAL_FRQ, IsNonDeterministic);

    DTD_ONE_OR_MORE_FRQ:
    begin
      Result := ValidateNames2(Source, Index, DTD_REQUIRED_FRQ, IsNonDeterministic);
      if Result then begin
        TempIndex := Index;
        while TempIndex < Source.Count do begin
          if not ValidateNames2(Source, TempIndex, DTD_REQUIRED_FRQ, IsNonDeterministic) then Break;
          if Index = TempIndex then Break; // Check for expressions of the form: (foo*)+
          Index := TempIndex;
        end;
      end;
    end;

    DTD_ZERO_OR_MORE_FRQ:
    begin
      Result := ValidateNames2(Source, Index, DTD_OPTIONAL_FRQ, IsNonDeterministic);
      if Result then begin
        TempIndex := Index;
        while TempIndex < Source.Count do begin
          if not ValidateNames2(Source, TempIndex, DTD_REQUIRED_FRQ, IsNonDeterministic) then Break;
          if Index = TempIndex then Break; // Check for expressions of the form: (foo*)* or (foo+)*
          Index := TempIndex;
        end;
      end;
    end;

  end; {case ...}

  if IsNonDeterministic then
    Result := False;
end;

function TDtdContentModel.ValidateSequenceNames(const Source: TUtilsWideStringList;
                                                    var Index: Integer;
                                                        Freq: TDtdFrequency;
                                                    out IsNonDeterministic: Boolean): Boolean;
var
  I: Integer;
  Ok: Boolean;
  Tempindex: Integer;
begin
  IsNonDeterministic := False;
  Result := False;
  Tempindex := Index;

  Ok := False;
  for I := 0 to Pred(SubModels.Length) do begin
    Ok := (SubModels.Item(I) as TDtdContentModel).ValidateNames(Source, Tempindex, IsNonDeterministic);
    if not Ok then Break;
  end;

  case Freq of

    DTD_REQUIRED_FRQ:
    begin
      if Ok then begin
        Index := Tempindex;
        Result := True;
      end else Result := False;
    end;

    DTD_OPTIONAL_FRQ:
    begin
      if Ok then Index := Tempindex;
      Result := True;
    end;

  end; {case ...}

  if IsNonDeterministic then
    Result := False;
end;



// ++++++++++++++++++++++++++ TDtdAttDeclCollection ++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDtdAttDeclCollection.Create(const AOwner: TDtdModel;
                                           const AName: string);
{$ELSE !NEXTGEN}
constructor TDtdAttDeclCollection.Create(const AOwner: TDtdModel;
                                           const AName: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(AName) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwner, AName);

  FObjectType := DTD_ATTLIST_DECLARATION;
  FAttributeDeclarations := TDtdNamedObjectMap.Create(AOwner);
end;

destructor TDtdAttDeclCollection.Destroy;
begin
  Clear;
  FAttributeDeclarations.Free;

  inherited;
end;

procedure TDtdAttDeclCollection.Clear;
{$IFNDEF AUTOREFCOUNT}
var
  I: Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FAttributeDeclarations.Length) do
    TDtdAttributeDecl(FAttributeDeclarations.Item(I)).Free;
{$ENDIF !AUTOREFCOUNT}
  FAttributeDeclarations.Clear;
end;

{$IFDEF NEXTGEN}
function TDtdAttDeclCollection.FindAttributeDecl(const Name: string): TDtdAttributeDecl;
{$ELSE !NEXTGEN}
function TDtdAttDeclCollection.FindAttributeDecl(const Name: WideString): TDtdAttributeDecl;
{$ENDIF NEXTGEN}
begin
  Result := (FAttributeDeclarations.GetNamedItem(Name) as TDtdAttributeDecl);
end;

{$IFDEF NEXTGEN}
function TDtdAttDeclCollection.RemoveAttributeDecl(const Name: string): Boolean;
{$ELSE !NEXTGEN}
function TDtdAttDeclCollection.RemoveAttributeDecl(const Name: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  Obj: TDtdObject;
begin
  Obj := FAttributeDeclarations.GetNamedItem(Name);
  if Assigned(Obj) then begin
    FAttributeDeclarations.RemoveNamedItem(Name);
    Obj.Free;
    Result := True;
  end else Result := False;
end;

{$IFDEF NEXTGEN}
function TDtdAttDeclCollection.SetAttributeDecl(const AAttrName,
                                                        AAttrValue: string;
                                                  const AEnumeration: TUtilsWideStringList;
                                                  const AAttrType: TXmlDataType;
                                                  const AConstraintType: TDomAttrValueConstraint;
                                                  const AOrigin: TDtdOrigin;
                                                    out AttributeDecl: TDtdAttributeDecl): Boolean;
{$ELSE !NEXTGEN}
function TDtdAttDeclCollection.SetAttributeDecl(const AAttrName,
                                                        AAttrValue: WideString;
                                                  const AEnumeration: TUtilsWideStringList;
                                                  const AAttrType: TXmlDataType;
                                                  const AConstraintType: TDomAttrValueConstraint;
                                                  const AOrigin: TDtdOrigin;
                                                    out AttributeDecl: TDtdAttributeDecl): Boolean;
{$ENDIF NEXTGEN}
begin
  AttributeDecl := FindAttributeDecl(AAttrName);
  if Assigned(AttributeDecl) then begin
    Result := False;
  end else begin
    AttributeDecl := TDtdAttributeDecl.Create(Self, AAttrName, AAttrValue,
                       AEnumeration, AAttrType, AConstraintType, AOrigin);
    FAttributeDeclarations.SetNamedItem(AttributeDecl);
    Result := True;
  end;
end;



//+++++++++++++++++++++++++ TDtdAttributeDecl ++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDtdAttributeDecl.Create(const AOwnerCollection: TDtdAttDeclCollection;
                                       const AAttrName,
                                             aDefaultValue: string;
                                       const AEnumeration: TUtilsWideStringList;
                                       const AAttrType: TXmlDataType;
                                       const AConstraintType: TDomAttrValueConstraint;
                                       const AOrigin: TDtdOrigin);
{$ELSE !NEXTGEN}
constructor TDtdAttributeDecl.Create(const AOwnerCollection: TDtdAttDeclCollection;
                                       const AAttrName,
                                             aDefaultValue: WideString;
                                       const AEnumeration: TUtilsWideStringList;
                                       const AAttrType: TXmlDataType;
                                       const AConstraintType: TDomAttrValueConstraint;
                                       const AOrigin: TDtdOrigin);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(AAttrName) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwnerCollection.OwnerModel, AAttrName);

  FObjectType := DTD_ATTRIBUTE_DECLARATION;
  FAttrType := AAttrType;
  FDefaultValue := ADefaultValue;
  FConstraintType := AConstraintType;
  FOwnerCollection := AOwnerCollection;
  FEnumeration := TUtilsWideStringList.Create;
  FEnumeration.Assign(AEnumeration);
  FOrigin := AOrigin;
end;

destructor TDtdAttributeDecl.Destroy;
begin
  FEnumeration.Free;
  inherited;
end;



//+++++++++++++++++++++++++++ TDtdEntityDecl +++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDtdEntityDecl.Create(const AOwner: TDtdModel;
                                    const AName,
                                          AReplacementText,
                                          APublicId,
                                          ASystemId,
                                          ANotationName,
                                          ABaseUri: string;
                                    const AOrigin: TDtdOrigin);
{$ELSE !NEXTGEN}
constructor TDtdEntityDecl.Create(const AOwner: TDtdModel;
                                    const AName,
                                          AReplacementText,
                                          APublicId,
                                          ASystemId,
                                          ANotationName,
                                          ABaseUri: WideString;
                                    const AOrigin: TDtdOrigin);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(AName) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwner, AName);

  FObjectType := DTD_ENTITY_DECLARATION;
  FPublicId := APublicId;
  FSystemId := ASystemId;
  FNotationName := ANotationName;
  FBaseUri := ABaseUri;

  FEntityRefs := TUtilsWideStringList.Create;
  FEntityRefs.Duplicates := dupIgnore;

  if EntityType = DTD_INTERNAL_ENTITY then begin
    SetReplacementText(AReplacementText);
  end else if EntityType = DTD_EXTERNAL_ENTITY then begin
    FReplacementText := '';
    FIsResolved := False;
  end else begin
    // Predefined Entity:
    FReplacementText := AReplacementText;
    FIsResolved := True;
  end;

  FOrigin := AOrigin;
end;

destructor TDtdEntityDecl.Destroy;
begin
  FEntityRefs.Free;
  inherited;
end;

function TDtdEntityDecl.CheckNoRecursion: Boolean;
begin
  Result := CheckNoRecursion_2(nil);
end;

function TDtdEntityDecl.CheckNoRecursion_2(const AncestorEntities: TUtilsWideStringList): Boolean;
var
  I: Integer;
  DereferencedEntityDecl: TDtdEntityDecl;
  AncestorEntitiesNew: TUtilsWideStringList;
begin
  Assert(Assigned(OwnerModel));
  Result := True;
  if EntityRefs.Count > 0 then begin
    AncestorEntitiesNew := TUtilsWideStringList.Create;
    try
      if Assigned(AncestorEntities) then
        AncestorEntitiesNew.Assign(AncestorEntities);
      AncestorEntitiesNew.Add(Name);
      // Check current entity:
      for I := 0 to Pred(EntityRefs.Count) do begin
        if AncestorEntitiesNew.IndexOf(EntityRefs.WideStrings[I]) <> -1 then begin
          Result := False;  // Circular reference found.
          Exit;
        end;
        DereferencedEntityDecl := OwnerModel.FindEntityDecl(EntityRefs.WideStrings[I]);
        if Assigned(DereferencedEntityDecl) then
          if not DereferencedEntityDecl.CheckNoRecursion_2(AncestorEntitiesNew) then begin
            Result := False;  // Circular reference found.
            Exit;
          end;
      end;
    finally
      AncestorEntitiesNew.Free;
    end;
  end;
end;

function TDtdEntityDecl.GetEntityType: TDtdEntityType;
begin
  if (FPublicId = '') and (FSystemId = '') and (FNotationName = '') then begin
    if IsXmlPredefinedEntityName(Name)
      then Result := DTD_PREDEFINED_ENTITY
      else Result := DTD_INTERNAL_ENTITY;
  end else Result := DTD_EXTERNAL_ENTITY;
end;

function TDtdEntityDecl.GetIsParsedEntity: Boolean;
begin
  Result := FNotationName = '';
end;

function TDtdEntityDecl.ResolveReplacementText(const ResolveEntityProc: TDomResolveEntityProc): TXmlErrorType;
var
{$IFDEF NEXTGEN}
  S: string;
{$ELSE !NEXTGEN}
  S: WideString;
{$ENDIF NEXTGEN}
begin
  Result := ET_NONE;
  if (EntityType = DTD_EXTERNAL_ENTITY) and not IsResolved then
    if IsParsedEntity then begin
      ResolveEntityProc(Origin, BaseUri, PublicId, SystemId, S, Result);
      if Result in ET_WARNINGS then
        SetReplacementText(S);
    end else
      // WFC: Parsed Entity (XML 1.0, § 4.1)
      Result := ET_REFERS_TO_UNPARSED_ENTITY;
end;

{$IFDEF NEXTGEN}
procedure TDtdEntityDecl.SetReplacementText(const S: string);
{$ELSE !NEXTGEN}
procedure TDtdEntityDecl.SetReplacementText(const S: WideString);
{$ENDIF NEXTGEN}
var
  Tokenizer: TXmlAttrValueTokenizer;
begin
  FReplacementText := S;
  FIsResolved := True;

  // Build FEntityRefs list:
  FEntityRefs.Clear;
  Tokenizer := TXmlAttrValueTokenizer.Create(S);
  try
    while not (Tokenizer.TokenType = ATTR_END_OF_SOURCE_TOKEN) do begin
      Tokenizer.Next;
      if Tokenizer.TokenType = ATTR_ENTITY_REF then
        FEntityRefs.Add(Tokenizer.TokenValue);
    end;
  finally
    Tokenizer.Free;
  end;
end;



//++++++++++++++++++++++++++ TDtdNotationDecl ++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDtdNotationDecl.Create(const AOwner: TDtdModel;
                                      const AName,
                                            APublicId,
                                            ASystemId: string;
                                      const AOrigin: TDtdOrigin);
{$ELSE !NEXTGEN}
constructor TDtdNotationDecl.Create(const AOwner: TDtdModel;
                                      const AName,
                                            APublicId,
                                            ASystemId: WideString;
                                      const AOrigin: TDtdOrigin);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(AName)
    then raise EInvalid_Character_Err.Create('Invalid character error.');
  if not IsXmlPubidChars(APublicId)
    then raise EInvalid_Character_Err.Create('Invalid character error.');
  if not IsXmlSystemChars(ASystemId)
    then raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwner, AName);
  FObjectType := DTD_NOTATION_DECLARATION;
  FPublicId:= APublicId;
  FSystemId:= ASystemId;
  FOrigin := AOrigin;
end;



//++++++++++++++++++++++++++ TDtdElementDecl +++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDtdElementDecl.Create(const AOwner: TDtdModel;
                                     const AName: string;
                                     const AContentType: TDtdContentType;
                                     const AOrigin: TDtdOrigin);
{$ELSE !NEXTGEN}
constructor TDtdElementDecl.Create(const AOwner: TDtdModel;
                                     const AName: WideString;
                                     const AContentType: TDtdContentType;
                                     const AOrigin: TDtdOrigin);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(AName) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(AOwner, AName);

  FContentType := AContentType;
  case FContentType of
    DTD_ANY_CONTENTTYPE,
    DTD_EMPTY_CONTENTTYPE: FAllowedChildTypes:= [];
    DTD_ELEMENT_CONTENTTYPE,
    DTD_MIXED_CONTENTTYPE,
    DTD_STRICT_MIXED_CONTENTTYPE: FAllowedChildTypes:= [DTD_CHOICE_CM, DTD_SEQUENCE_CM];
  end;

  FCreatedContentModels := TDtdObjectList.Create;
  FObjectType := DTD_ELEMENT_DECLARATION;
  FOrigin := AOrigin;
end;

destructor TDtdElementDecl.Destroy;
begin
  Clear;
  FCreatedContentModels.Free;
  inherited;
end;

procedure TDtdElementDecl.Clear;
{$IFNDEF AUTOREFCOUNT}
var
  I: Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FCreatedContentModels.Length) do
    TDtdContentModel(FCreatedContentModels.Item(I)).Free;
{$ENDIF !AUTOREFCOUNT}
  FCreatedContentModels.Clear;
  FContentModel := nil;
end;

{$IFDEF NEXTGEN}
function TDtdElementDecl.CreateContentModel(const Name: string;
                                            const ContentModelType: TDtdContentModelType): TDtdContentModel;
{$ELSE !NEXTGEN}
function TDtdElementDecl.CreateContentModel(const Name: WideString;
                                              const ContentModelType: TDtdContentModelType): TDtdContentModel;
{$ENDIF NEXTGEN}
begin
  Result := TDtdContentModel.Create(Self, Name, ContentModelType);
  FCreatedContentModels.AppendNode(Result);
end;

procedure TDtdElementDecl.FreeAndNilContentModel(var CM: TDtdContentModel);
var
  SubModel: TDtdContentModel;
begin
  if CM.FInuse then
    raise EInuse_Err.Create('Content model in use error.');
  // First recursively free the submodels:
  while CM.SubModels.Length > 0 do begin
    SubModel := Cm.RemoveSubModel(CM.SubModels.Item(Pred(CM.SubModels.Length)) as TDtdContentModel);
    FreeAndNilContentModel(SubModel);
  end;
  // Now free the content model:
  FCreatedContentModels.RemoveNode(CM);
  CM.Free;
  CM := nil;
end;

function TDtdElementDecl.ReplaceContentModel(const NewContentModel: TDtdContentModel): TDtdContentModel;
begin
  if FContentModel = NewContentModel then begin
    Result := NewContentModel;
    Exit;
  end;
  if Assigned(NewContentModel) then begin
    if NewContentModel.OwnerModel <> OwnerModel then
      raise ENot_Supported_Err.Create('Not supported error: Wrong owner element declaration.');
    if not (NewContentModel.ContentModelType in FAllowedChildTypes) then
      raise ENot_Supported_Err.Create('Not supported error.');
    if NewContentModel.FInuse then
      raise EInuse_Err.Create('Content model in use error.');
    NewContentModel.FInuse := True;
  end;
  if Assigned(FContentModel)
    then FContentModel.FInuse:= False;
  Result := FContentModel;
  FContentModel := NewContentModel;
end;



//++++++++++++++++++++++++++++++++ TDtdModel ++++++++++++++++++++++++++++++++
constructor TDtdModel.Create;
begin
  inherited Create;

  FLastKey := 0;
  FAttDeclCollections   := TDtdNamedObjectMap.Create(Self);
  FElementDeclarations  := TDtdNamedObjectMap.Create(Self);
  FEntityDeclarations   := TDtdNamedObjectMap.Create(Self);
  FNotationDeclarations := TDtdNamedObjectMap.Create(Self);

  SetDefaults;
end;

destructor TDtdModel.Destroy;
begin
  ClearMaps;
  FAttDeclCollections.Free;
  FElementDeclarations.Free;
  FEntityDeclarations.Free;
  FNotationDeclarations.Free;
  inherited;
end;

procedure TDtdModel.Clear;
begin
  ClearMaps;
  SetDefaults;
end;

procedure TDtdModel.ClearMaps;
{$IFNDEF AUTOREFCOUNT}
var
  I: Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FAttDeclCollections.Length) do
    TDtdAttDeclCollection(FAttDeclCollections.Item(I)).Free;
{$ENDIF !AUTOREFCOUNT}
  FAttDeclCollections.Clear;
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FElementDeclarations.Length) do
    TDtdElementDecl(FElementDeclarations.Item(I)).Free;
{$ENDIF !AUTOREFCOUNT}
  FElementDeclarations.Clear;
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FEntityDeclarations.Length) do
    TDtdEntityDecl(FEntityDeclarations.Item(I)).Free;
{$ENDIF !AUTOREFCOUNT}
  FEntityDeclarations.Clear;
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FNotationDeclarations.Length) do
    TDtdNotationDecl(FNotationDeclarations.Item(I)).Free;
{$ENDIF !AUTOREFCOUNT}
  FNotationDeclarations.Clear;
end;

{$IFDEF NEXTGEN}
function TDtdModel.FindAttDeclCollection(const Name: string): TDtdAttDeclCollection;
{$ELSE !NEXTGEN}
function TDtdModel.FindAttDeclCollection(const Name: WideString): TDtdAttDeclCollection;
{$ENDIF NEXTGEN}
begin
  Result := (FAttDeclCollections.GetNamedItem(Name) as TDtdAttDeclCollection);
end;

{$IFDEF NEXTGEN}
function TDtdModel.FindAttributeDecl(const ElementName,
                                           AttributeName: string): TDtdAttributeDecl;
{$ELSE !NEXTGEN}
function TDtdModel.FindAttributeDecl(const ElementName,
                                           AttributeName: WideString): TDtdAttributeDecl;
{$ENDIF NEXTGEN}
var
  AttDeclCol: TDtdAttDeclCollection;
begin
  AttDeclCol := FindAttDeclCollection(ElementName);
  if Assigned(AttDeclCol)
    then Result := AttDeclCol.FindAttributeDecl(AttributeName)
    else Result := nil;
end;

{$IFDEF NEXTGEN}
function TDtdModel.FindElementDecl(const Name: string): TDtdElementDecl;
{$ELSE !NEXTGEN}
function TDtdModel.FindElementDecl(const Name: WideString): TDtdElementDecl;
{$ENDIF NEXTGEN}
begin
  Result := (FElementDeclarations.GetNamedItem(Name) as TDtdElementDecl);
end;

{$IFDEF NEXTGEN}
function TDtdModel.FindEntityDecl(const Name: string): TDtdEntityDecl;
{$ELSE !NEXTGEN}
function TDtdModel.FindEntityDecl(const Name: WideString): TDtdEntityDecl;
{$ENDIF NEXTGEN}
begin
  Result := (FEntityDeclarations.GetNamedItem(Name) as TDtdEntityDecl);
end;

{$IFDEF NEXTGEN}
function TDtdModel.FindNotationDecl(const Name: string): TDtdNotationDecl;
{$ELSE !NEXTGEN}
function TDtdModel.FindNotationDecl(const Name: WideString): TDtdNotationDecl;
{$ENDIF NEXTGEN}
begin
  Result := (FNotationDeclarations.GetNamedItem(Name) as TDtdNotationDecl);
end;

function TDtdModel.GetNewKey: Int64;
begin
  Inc(FLastKey);
  Result := FLastKey;
end;

{$IFDEF NEXTGEN}
function TDtdModel.RemoveAttributeDecl(const ElementName,
                                             AttributeName: string): Boolean;
{$ELSE !NEXTGEN}
function TDtdModel.RemoveAttributeDecl(const ElementName,
                                             AttributeName: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  AttDeclCol: TDtdAttDeclCollection;
begin
  AttDeclCol := FindAttDeclCollection(ElementName);
  if Assigned(AttDeclCol) then begin
    if AttDeclCol.RemoveAttributeDecl(AttributeName) then begin
      Result := True;
      if AttDeclCol.AttributeDecls.Length = 0 then
        FAttDeclCollections.RemoveNamedItem(ElementName);
        AttDeclCol.Free;
    end else
      Result := False;
  end else
    Result := False;
end;

{$IFDEF NEXTGEN}
function TDtdModel.RemoveElementDecl(const Name: string): Boolean;
{$ELSE !NEXTGEN}
function TDtdModel.RemoveElementDecl(const Name: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  Obj: TDtdObject;
begin
  Obj := FElementDeclarations.GetNamedItem(Name);
  if Assigned(Obj) then begin
    FElementDeclarations.RemoveNamedItem(Name);
    Obj.Free;
    Result := True;
  end else Result := False;
end;

{$IFDEF NEXTGEN}
function TDtdModel.RemoveEntityDecl(const Name: string): Boolean;
{$ELSE !NEXTGEN}
function TDtdModel.RemoveEntityDecl(const Name: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  EntityDecl: TDtdEntityDecl;
begin
  EntityDecl := FEntityDeclarations.GetNamedItem(Name) as TDtdEntityDecl;
  if Assigned(EntityDecl) then begin
    if EntityDecl.Origin <> DTD_PREDEFINED then begin
      FEntityDeclarations.RemoveNamedItem(Name);
      EntityDecl.Free;
      Result := True;
    end else
      Result := False;
  end else Result := False;
end;

{$IFDEF NEXTGEN}
function TDtdModel.RemoveNotationDecl(const Name: string): Boolean;
{$ELSE !NEXTGEN}
function TDtdModel.RemoveNotationDecl(const Name: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  Obj: TDtdObject;
begin
  Obj := FNotationDeclarations.GetNamedItem(Name);
  if Assigned(Obj) then begin
    FNotationDeclarations.RemoveNamedItem(Name);
    Obj.Free;
    Result := True;
  end else Result := False;
end;

{$IFDEF NEXTGEN}
function TDtdModel.SetAttributeDecl(const ElementName,
                                          AttrName,
                                          AttrValue: string;
                                    const Enumeration: TUtilsWideStringList;
                                    const AttrType: TXmlDataType;
                                    const ConstraintType: TDomAttrValueConstraint;
                                    const Origin: TDtdOrigin;
                                      out AttributeDecl: TDtdAttributeDecl): Boolean;
{$ELSE !NEXTGEN}
function TDtdModel.SetAttributeDecl(const ElementName,
                                          AttrName,
                                          AttrValue: WideString;
                                    const Enumeration: TUtilsWideStringList;
                                    const AttrType: TXmlDataType;
                                    const ConstraintType: TDomAttrValueConstraint;
                                    const Origin: TDtdOrigin;
                                      out AttributeDecl: TDtdAttributeDecl): Boolean;
{$ENDIF NEXTGEN}
var
  AttDeclCol: TDtdAttDeclCollection;
begin
  AttDeclCol := FindAttDeclCollection(ElementName);
  if not Assigned(AttDeclCol) then begin
    AttDeclCol := TDtdAttDeclCollection.Create(Self, ElementName);
    FAttDeclCollections.SetNamedItem(AttDeclCol);
  end;
  Result := AttDeclCol.SetAttributeDecl(AttrName, AttrValue, Enumeration,
                         AttrType, ConstraintType, Origin, AttributeDecl);
end;

{$IFDEF NEXTGEN}
function TDtdModel.SetElementDecl(const Name: string;
                                  const ContentType: TDtdContentType;
                                  const Origin: TDtdOrigin;
                                    out ElementDecl: TDtdElementDecl): Boolean;
{$ELSE !NEXTGEN}
function TDtdModel.SetElementDecl(const Name: WideString;
                                  const ContentType: TDtdContentType;
                                  const Origin: TDtdOrigin;
                                    out ElementDecl: TDtdElementDecl): Boolean;
{$ENDIF NEXTGEN}
begin
  ElementDecl := FindElementDecl(Name);
  if Assigned(ElementDecl) then begin
    Result := False;
  end else begin
    ElementDecl := TDtdElementDecl.Create(Self, Name, ContentType, Origin);
    FElementDeclarations.SetNamedItem(ElementDecl);
    Result := True;
  end;
end;

{$IFDEF NEXTGEN}
function TDtdModel.SetEntityDecl(const Name,
                                       ReplacementText,
                                       PublicId,
                                       SystemId,
                                       NotationName,
                                       BaseUri: string;
                                 const Origin: TDtdOrigin;
                                   out EntityDecl: TDtdEntityDecl): Boolean;
{$ELSE !NEXTGEN}
function TDtdModel.SetEntityDecl(const Name,
                                       ReplacementText,
                                       PublicId,
                                       SystemId,
                                       NotationName,
                                       BaseUri: WideString;
                                 const Origin: TDtdOrigin;
                                   out EntityDecl: TDtdEntityDecl): Boolean;
{$ENDIF NEXTGEN}
begin
  if (Origin = DTD_PREDEFINED) and not FSetDefaults then
    raise ENot_Supported_Err.Create('Setting of predefined entity declarations not supported.');
  EntityDecl := FindEntityDecl(Name);
  if Assigned(EntityDecl) then begin
    Result := False;
  end else begin
    EntityDecl := TDtdEntityDecl.Create(Self, Name, ReplacementText, PublicId, SystemId, NotationName, BaseUri, Origin);
    FEntityDeclarations.SetNamedItem(EntityDecl);
    Result := True;
  end;
end;

{$IFDEF NEXTGEN}
function TDtdModel.SetNotationDecl(const Name,
                                         PublicId,
                                         SystemId: string;
                                   const Origin: TDtdOrigin;
                                     out NotationDecl: TDtdNotationDecl): Boolean;
{$ELSE !NEXTGEN}
function TDtdModel.SetNotationDecl(const Name,
                                         PublicId,
                                         SystemId: WideString;
                                   const Origin: TDtdOrigin;
                                     out NotationDecl: TDtdNotationDecl): Boolean;
{$ENDIF NEXTGEN}
begin
  NotationDecl := FindNotationDecl(Name);
  if Assigned(NotationDecl) then begin
    Result := False;
  end else begin
    NotationDecl := TDtdNotationDecl.Create(Self, Name, PublicId, SystemId, Origin);
    FNotationDeclarations.SetNamedItem(NotationDecl);
    Result := True;
  end;
end;

procedure TDtdModel.SetDefaults;
var
  Dummy: TDtdEntityDecl;
begin
  FSetDefaults := True;
  try
    FPEsInIntSubset := False;
    FPreparationStatus := PS_UNPREPARED;
    // Set the predefined entities:
    SetEntityDecl('lt', '&#60;', '', '', '', '', DTD_PREDEFINED, Dummy);
    SetEntityDecl('gt', #62, '', '', '', '', DTD_PREDEFINED, Dummy);
    SetEntityDecl('amp', '&#38;', '', '', '', '', DTD_PREDEFINED, Dummy);
    SetEntityDecl('apos', #39, '', '', '', '', DTD_PREDEFINED, Dummy);
    SetEntityDecl('quot', #34, '', '', '', '', DTD_PREDEFINED, Dummy);
  finally
    FSetDefaults := False;
  end;
end;

procedure TDtdModel.SetPreparationStatus(const Value: TDomPreparationStatus);
begin
  FPreparationStatus := Value;
end;



// +++++++++++++++++++++++++++ TXmlSourceCode ++++++++++++++++++++++++++
procedure TXmlSourceCode.calculatePieceOffset(const StartItem: Integer);
var
  Os, I: Integer;
begin
  if (StartItem < Count) and (StartItem >= 0) then begin
    if StartItem = 0
      then Os := 0
      else begin
        if not Assigned(Items[StartItem-1])
          then begin
            Pack;
            Exit;
          end else
            Os := TXmlSourceCodePiece(Items[StartItem-1]).FOffset + Length(TXmlSourceCodePiece(Items[StartItem-1]).FText);
      end;
    for I := StartItem to Pred(Count) do
      if not Assigned(Items[I])
        then begin
          Pack;
          Exit;
        end else
        begin
          TXmlSourceCodePiece(Items[I]).FOffset := Os;
          Os := Os + Length(TXmlSourceCodePiece(Items[I]).FText);
        end;
  end; {if ...}
end;

{$IFDEF NEXTGEN}
function TXmlSourceCode.GetNameOfFirstTag: string;
{$ELSE !NEXTGEN}
function TXmlSourceCode.GetNameOfFirstTag: WideString;
{$ENDIF NEXTGEN}
var
  I, J, K: Integer;
  SrcCodePiece: TXmlSourceCodePiece;
begin
  Result := '';
  for I := 0 to Pred(Count) do
    if Assigned(Items[I]) then
    begin
      SrcCodePiece := TXmlSourceCodePiece(Items[I]);
      if (SrcCodePiece.PieceType = xmlStartTag) or (SrcCodePiece.PieceType = xmlEmptyElementTag) then begin
        if SrcCodePiece.PieceType = xmlStartTag
          then K := Length(SrcCodePiece.Text) - 1
          else K := Length(SrcCodePiece.Text) - 2;
        J := 1;
        while J < K do begin
          Inc(J);
          if IsXmlWhiteSpace(SrcCodePiece.Text[J-AdjustIndex]) then Break;
{$IFDEF NEXTGEN}
          Result := Concat(Result, string(WideChar(SrcCodePiece.Text[J-AdjustIndex])));
{$ELSE !NEXTGEN}
          Result := Concat(Result, WideString(WideChar(SrcCodePiece.Text[J-AdjustIndex])));
{$ENDIF NEXTGEN}
        end;
        Exit;
      end;
    end;
end;

{$IFDEF NEXTGEN}
function TXmlSourceCode.GetText: string;
{$ELSE !NEXTGEN}
function TXmlSourceCode.GetText: WideString;
{$ENDIF NEXTGEN}
var
  Content: TUtilsCustomWideStr;
  I: Integer;
begin
  Content:= TUtilsCustomWideStr.Create;
  try
    Content.AddWideChar(#$FFEF);  // Add byte order mark.
    for I := 0 to Pred(Count) do
      Content.AddWideString(TXmlSourceCodePiece(Items[I]).Text);
    Result := Content.Value;
  finally
    Content.Free;
  end;
end;

function TXmlSourceCode.Add(Item: TXmlSourceCodePiece): Integer;
begin
  if Assigned(Item) then begin
    if not Assigned(Item.FOwner)
      then Item.FOwner := Self
      else Error('Inuse source code piece error.', -1);
  end else Error('Item not Assigned error.', -1);
  Result := inherited Add(Item);
  CalculatePieceOffset(Result);
end;

procedure TXmlSourceCode.Clear;
var
  I: Integer;
begin
  for I := 0 to Pred(Count) do
    if Assigned(Items[I]) then
    begin
      TXmlSourceCodePiece(Items[I]).FOffset := 0;
      TXmlSourceCodePiece(Items[I]).FOwner := nil;
    end;
  inherited Clear;
end;

procedure TXmlSourceCode.ClearAndFree;
{$IFNDEF AUTOREFCOUNT}
var
  I: Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(Count) do
    if Assigned(Items[I]) then TXmlSourceCodePiece(Items[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  inherited Clear;
end;

procedure TXmlSourceCode.Delete(Index: Integer);
begin
  if Assigned(Items[Index]) then
  begin
    TXmlSourceCodePiece(Items[Index]).FOffset := 0;
    TXmlSourceCodePiece(Items[Index]).FOwner := nil;
  end;
  inherited Delete(Index);
  CalculatePieceOffset(Index);
end;

procedure TXmlSourceCode.Exchange(Index1, Index2: Integer);
var
  Nr: Integer;
begin
  Nr := MinIntValue([Index1, Index2]);
  inherited Exchange(Index1, Index2);
  CalculatePieceOffset(Nr);
end;

function TXmlSourceCode.GetPieceAtPos(Pos: Integer): TXmlSourceCodePiece;
var
  I: Integer;
begin
                                                  
  Result := nil;
  if Pos < 1 then Exit;
  for I := 0 to Pred(Count) do
    if not Assigned(Items[I]) then begin
      Pack;
      Result := GetPieceAtPos(Pos);
    end else
    begin
      if (TXmlSourceCodePiece(Items[I]).FOffset + Length(TXmlSourceCodePiece(Items[I]).FText)) >= Pos then begin
        Result := TXmlSourceCodePiece(Items[I]);
        Exit;
      end;
    end;
end;

procedure TXmlSourceCode.Insert(Index: Integer; Item: TXmlSourceCodePiece);
begin
  if Assigned(Item) then begin
    if not Assigned(Item.FOwner)
      then Item.FOwner := Self
      else Error('Inuse source code piece error.', -1);
  end else Error('Item not Assigned error.', -1);
  inherited Insert(Index, Item);
  CalculatePieceOffset(Index);
end;

procedure TXmlSourceCode.Move(CurIndex, NewIndex: Integer);
var
  Nr: Integer;
begin
  Nr := MinIntValue([CurIndex, NewIndex]);
  inherited Move(CurIndex, NewIndex);
  CalculatePieceOffset(Nr);
end;

procedure TXmlSourceCode.Pack;
begin
  inherited Pack;
  CalculatePieceOffset(0);
end;

function TXmlSourceCode.Remove(Item: TXmlSourceCodePiece): Integer;
var
  Nr: Integer;
begin
  Nr := IndexOf(Item);
  Result := inherited Remove(Item);
  if Assigned(Items[Nr]) then
  begin
    Item.FOffset := 0;
    Item.FOwner := nil;
  end;
  CalculatePieceOffset(Nr);
end;

procedure TXmlSourceCode.Sort(Compare: TListSortCompare);
begin
  inherited Sort(Compare);
  CalculatePieceOffset(0);
end;



// ++++++++++++++++++++++++ TXmlSourceCodePiece ++++++++++++++++++++++++
constructor TXmlSourceCodePiece.Create(const pt: TDomPieceType);
begin
  inherited Create;
  FPieceType := pt;
  Ftext:= '';
  FOffset:= 0;
  FOwner := nil;
end;



// +++++++++++++++++++++++ TStandardResourceResolver +++++++++++++++++++++++
{$IFNDEF NEXTGEN}
function TStandardResourceResolver.AcquireStreamFromUri(const Uri: WideString): TStream;
var
  Path: TFilename;
  Authority, Query, Fragment: WideString; // Only dummies.
  UriAnalyzer: TUriWideStrAnalyzer;
begin
  UriAnalyzer := TUriWideStrAnalyzer.Create;
  try
    UriAnalyzer.SetUriReference(Uri);
    if not UriAnalyzer.HasUriScheme then
      raise EFOpenError.CreateFmt('URI "%s" contains no scheme.', [Uri]);
    if UriAnalyzer.UriScheme <> 'file' then
      raise EFOpenError.CreateFmt('URI scheme "%s" not supported.', [UriAnalyzer.UriScheme]);

    UriWideStrToFilename(Uri, Path, Authority, Query, Fragment);

  finally
    UriAnalyzer.Free;
  end;

  if not FileExists(Path) then
    raise EFOpenError.CreateFmt('File "%s" not found.', [ExpandFileName(Path)]);
  Result := TFileStream.Create(Path, fmOpenRead);
end;

function TStandardResourceResolver.ResolveResource(const ABaseURI: WideString;
                                                     var PublicId,
                                                         SystemId: WideString): TStream;
// Remark: ResourceType and NamespaceURI are currently not evaluated.  They are
//         placeholders for XML Schema support in the future.  CertifiedText is
//         also not evaluated.  It is a placeholder for XML 1.1 support.
var
  ResourceType, NamespaceURI: WideString;
  CertifiedText: Boolean;
  Uri: WideString;
begin
  ResourceType := 'http://www.w3.org/TR/REC-xml';  // Signals an XML 1.0 resource.
  NamespaceURI := '';                              // Currently not used.
  CertifiedText := False;                          // Currently not used.

  Result := nil;

  // Calculate absolute system identifier:
  ResolveRelativeUriWideStr(ABaseUri, SystemId, Uri);
     // Remark: Returns an empty URI if ResolveRelativeUriWideStr attempt fails.
  SystemId := Uri;

  if Assigned(FOnResolveResource) then
    FOnResolveResource(Self, ResourceType, NamespaceURI, PublicId, SystemId, Result, CertifiedText);

  if not Assigned(Result) and (SystemId <> '') then begin
    try
      Result := AcquireStreamFromURI(SystemId);
    except
      Result.Free;
      Result := nil;
    end;
  end;
end;

{$ELSE}
function TStandardResourceResolver.AcquireStreamFromUri(const Uri: DOMString): TStream;
var
  Path: TFilename;
  Authority, Query, Fragment: string; // Only dummies.
  UriAnalyzer: TUriStrAnalyzer;
begin
  UriAnalyzer := TUriStrAnalyzer.Create;
  try
    UriAnalyzer.SetUriReference(Uri);
    if not UriAnalyzer.HasUriScheme then
      raise EFOpenError.CreateFmt('URI "%s" contains no scheme.', [Uri]);
    if UriAnalyzer.UriScheme <> 'file' then
      raise EFOpenError.CreateFmt('URI scheme "%s" not supported.', [UriAnalyzer.UriScheme]);

    UriStrToFilename(Uri, Path, Authority, Query, Fragment);
  finally
    UriAnalyzer.Free;
  end;

  if not FileExists(Path) then
    raise EFOpenError.CreateFmt('File "%s" not found.', [ExpandFileName(Path)]);
  Result := TFileStream.Create(Path, fmOpenRead);
end;

function TStandardResourceResolver.ResolveResource(const ABaseURI: DOMString;
                                                     var PublicId,
                                                         SystemId: DOMString): TStream;
// Remark: ResourceType and NamespaceURI are currently not evaluated.  They are
//         placeholders for XML Schema support in the future.  CertifiedText is
//         also not evaluated.  It is a placeholder for XML 1.1 support.
var
  ResourceType, NamespaceURI: DOMString;
  CertifiedText: Boolean;
  Uri: DOMString;
begin
  ResourceType := 'http://www.w3.org/TR/REC-xml';  // Signals an XML 1.0 resource.
  NamespaceURI := '';                              // Currently not used.
  CertifiedText := False;                          // Currently not used.

  Result := nil;

  // Calculate absolute system identifier:
  ResolveRelativeUriStr(ABaseUri, SystemId, Uri);
     // Remark: Returns an empty URI if ResolveRelativeUriWideStr attempt fails.
  SystemId := Uri;

  if Assigned(FOnResolveResource) then
    FOnResolveResource(Self, ResourceType, NamespaceURI, PublicId, SystemId, Result, CertifiedText);

  if not Assigned(Result) and (SystemId <> '') then begin
    try
      Result := AcquireStreamFromURI(SystemId);
    except
      Result.Free;
      Result := nil;
    end;
  end;
end;

{$ENDIF !NEXTGEN}

{ TXmlSimpleInputSource }

{$IFDEF NEXTGEN}
constructor TXmlSimpleInputSource.Create(const Stream: TStream;
                                         const APublicId,
                                               ASystemId: string;
                                         const ABufSize: Integer;
                                         const AEncoding: string;
                                         const InitialByteCount,
                                               InitialCharCount,
                                               InitialCharsInLine,
                                               InitialTabsInLine,
                                               InitialLine: Int64);
{$ELSE !NEXTGEN}
constructor TXmlSimpleInputSource.Create(const Stream: TStream;
                                         const APublicId,
                                               ASystemId: WideString;
                                         const ABufSize: Integer;
                                         const AEncoding: string;
                                         const InitialByteCount,
                                               InitialCharCount,
                                               InitialCharsInLine,
                                               InitialTabsInLine,
                                               InitialLine: Int64);
{$ENDIF NEXTGEN}
begin
  FStrStream := nil;  // Remark: If an exception occurs, the destructor is automatically called.
  FWStrStream := nil; //         Therefore, we need to initialize critical objects with nil first.
  FPublicId := APublicId;
  FSystemId := ASystemId;
  inherited Create(Stream, ABufSize, AEncoding, InitialByteCount,
      InitialCharCount, InitialCharsInLine, InitialTabsInLine,
      InitialLine);
end;

{$IFDEF NEXTGEN}
constructor TXmlSimpleInputSource.Create(const S: string;
                                         const APublicId,
                                               ASystemId: string;
                                         const ABufSize: Integer;
                                         const AEncoding: string;
                                         const InitialByteCount,
                                               InitialCharCount,
                                               InitialCharsInLine,
                                               InitialTabsInLine,
                                               InitialLine: Int64);
{$ELSE !NEXTGEN}
constructor TXmlSimpleInputSource.Create(const S: string;
                                         const APublicId,
                                               ASystemId: WideString;
                                         const ABufSize: Integer;
                                         const AEncoding: string;
                                         const InitialByteCount,
                                               InitialCharCount,
                                               InitialCharsInLine,
                                               InitialTabsInLine,
                                               InitialLine: Int64);
{$ENDIF NEXTGEN}
begin
  FStrStream := nil;  // Remark: If an exception occurs, the destructor is automatically called.
  FWStrStream := nil; //         Therefore, we need to initialize critical objects with nil first.
  FPublicId := APublicId;
  FSystemId := ASystemId;
  FStrStream := TStringStream.Create(S);
  inherited Create(FStrStream, ABufSize, AEncoding, InitialByteCount,
      InitialCharCount, InitialCharsInLine, InitialTabsInLine,
      InitialLine);
end;

{$IFDEF NEXTGEN}
constructor TXmlSimpleInputSource.Create(const S,
                                               APublicId,
                                               ASystemId: string;
                                         const ABufSize: Integer;
                                         const InitialByteCount,
                                               InitialCharCount,
                                               InitialCharsInLine,
                                               InitialTabsInLine,
                                               InitialLine: Int64);
{$ELSE !NEXTGEN}
constructor TXmlSimpleInputSource.Create(const S,
                                               APublicId,
                                               ASystemId: WideString;
                                         const ABufSize: Integer;
                                         const InitialByteCount,
                                               InitialCharCount,
                                               InitialCharsInLine,
                                               InitialTabsInLine,
                                               InitialLine: Int64);
{$ENDIF NEXTGEN}
begin
  FStrStream := nil;  // Remark: If an exception occurs, the destructor is automatically called.
  FWStrStream := nil; //         Therefore, we need to initialize critical objects with nil first.
  FPublicId := APublicId;
  FSystemId := ASystemId;
  FWStrStream := TUtilsWideStringStream.Create(S);
  inherited Create(FWStrStream, ABufSize, 'UTF-16LE', InitialByteCount,
      InitialCharCount, InitialCharsInLine, InitialTabsInLine,
      InitialLine);
end;

destructor TXmlSimpleInputSource.Destroy;
begin
  inherited;
  FStrStream.Free;
  FWStrStream.Free;
end;

function TXmlSimpleInputSource.GetInputEncoding: string;
begin
  if Assigned(Codec) then
    Result := Codec.Name
  else
    Result := '';
end;



{ TXmlInputSource }

{$IFDEF NEXTGEN}
constructor TXmlInputSource.Create(const Stream: TStream;
                                   const APublicId,
                                         ASystemId: string;
                                   const ABufSize: Integer;
                                   const AEncoding: string;
                                   const InclDecl: Boolean;
                                   const InitialByteCount,
                                         InitialCharCount,
                                         InitialCharsInLine,
                                         InitialTabsInLine,
                                         InitialLine: Int64);
{$ELSE !NEXTGEN}
constructor TXmlInputSource.Create(const Stream: TStream;
                                   const APublicId,
                                         ASystemId: WideString;
                                   const ABufSize: Integer;
                                   const AEncoding: string;
                                   const InclDecl: Boolean;
                                   const InitialByteCount,
                                         InitialCharCount,
                                         InitialCharsInLine,
                                         InitialTabsInLine,
                                         InitialLine: Int64);
{$ENDIF NEXTGEN}
begin
  inherited Create(Stream, APublicId, ASystemId, ABufSize, AEncoding,
      InitialByteCount, InitialCharCount, InitialCharsInLine,
      InitialTabsInLine, InitialLine);

  FHasMalformedDecl := not EvaluateXmlOrTextDecl(FDeclType, FXmlVersion,
                             FXmlEncoding, FXmlStandalone);

  if AEncoding = '' then
    CheckEncoding(FXmlEncoding);

  if not InclDecl then
    InitialUCS4CharData := CurrentCharInfo;
  Reset;
end;

{$IFDEF NEXTGEN}
constructor TXmlInputSource.Create(const S: string;
                                   const APublicId,
                                         ASystemId: string;
                                   const ABufSize: Integer;
                                   const AEncoding: string;
                                   const InclDecl: Boolean;
                                   const InitialByteCount,
                                         InitialCharCount,
                                         InitialCharsInLine,
                                         InitialTabsInLine,
                                         InitialLine: Int64);
{$ELSE !NEXTGEN}
constructor TXmlInputSource.Create(const S: string;
                                   const APublicId,
                                         ASystemId: WideString;
                                   const ABufSize: Integer;
                                   const AEncoding: string;
                                   const InclDecl: Boolean;
                                   const InitialByteCount,
                                         InitialCharCount,
                                         InitialCharsInLine,
                                         InitialTabsInLine,
                                         InitialLine: Int64);
{$ENDIF NEXTGEN}
begin
  inherited Create(S, APublicId, ASystemId, ABufSize, AEncoding,
      InitialByteCount, InitialCharCount, InitialCharsInLine,
      InitialTabsInLine, InitialLine);

  FHasMalformedDecl := not EvaluateXmlOrTextDecl(FDeclType, FXmlVersion,
                             FXmlEncoding, FXmlStandalone);

  if AEncoding = '' then
    CheckEncoding(FXmlEncoding);

  if not InclDecl then
    InitialUCS4CharData := CurrentCharInfo;
  Reset;
end;

{$IFDEF NEXTGEN}
constructor TXmlInputSource.Create(const S,
                                         APublicId,
                                         ASystemId: string;
                                   const ABufSize: Integer;
                                   const InclDecl: Boolean;
                                   const InitialByteCount,
                                         InitialCharCount,
                                         InitialCharsInLine,
                                         InitialTabsInLine,
                                         InitialLine: Int64);
{$ELSE !NEXTGEN}
constructor TXmlInputSource.Create(const S,
                                         APublicId,
                                         ASystemId: WideString;
                                   const ABufSize: Integer;
                                   const InclDecl: Boolean;
                                   const InitialByteCount,
                                         InitialCharCount,
                                         InitialCharsInLine,
                                         InitialTabsInLine,
                                         InitialLine: Int64);
{$ENDIF NEXTGEN}
begin
  inherited Create(S, APublicId, ASystemId, ABufSize,
      InitialByteCount, InitialCharCount, InitialCharsInLine,
      InitialTabsInLine, InitialLine);

  FHasMalformedDecl := not EvaluateXmlOrTextDecl(FDeclType, FXmlVersion,
                             FXmlEncoding, FXmlStandalone);

  if not InclDecl then
    InitialUCS4CharData := CurrentCharInfo;
  Reset;
end;

procedure TXmlInputSource.CheckEncoding(const Encoding: string);
// Calculates the codec class as specified in the XML or text declaration.
const
  UTF16_STR: string = 'UTF-16';
  UTF16BE_STR: string = 'UTF-16BE';
begin
  if Encoding = '' then Exit;

  if HasByteOrderMark and
     ( ( (Codec is TUTF16BECodec) and
         (TUTF16BECodec.AliasIndexOf(Encoding) = -1) and
         (TUCS4BECodec.AliasIndexOf(Encoding) = -1) )
       or
       ( (Codec is TUTF16LECodec) and
         (TUTF16LECodec.AliasIndexOf(Encoding) = -1) and
         (TUCS4LECodec.AliasIndexOf(Encoding) = -1) )
       or
       ( (Codec is TUTF8Codec) and
         (TUTF8Codec.AliasIndexOf(Encoding) = -1) ) ) then
    raise EConvertError.Create('Declared encoding does not match byte order mark.');

  if CompareText(Encoding, UTF16_STR) = 0 then begin // UTF-16 specified.
    if not HasByteOrderMark then begin
      SetEncoding(UTF16BE_STR);
      // Cf. RFC 2781: "UTF-16, an encoding of ISO 10646", sec. 4.3:
      //   If the first two octets of the text is not 0xFE followed by
      //   0xFF, and is not 0xFF followed by 0xFE, then the text SHOULD be
      //   interpreted as being big-endian.
    end else if not ( (Codec is TUTF16BECodec) or (Codec is TUTF16LECodec) ) then
      raise EConvertError.Create('Declared encoding does not match byte order mark.');
    Exit;
  end;

  try
    SetEncoding(Encoding);
  except
    on EParserUtilsException do
      raise ENot_Supported_Err.Create('Encoding not supported error.');
  end;
end;

function TXmlInputSource.EvaluateXmlOrTextDecl(out DeclType: TDomXMLDeclType;
                                               out Version,
                                                   EncName: string;
                                               out Standalone: TDomStandalone): Boolean;

  function IsXmlVersionNumCharCodePoint(const UCS4: Longint): Boolean;
  begin
    case UCS4 of
      // [.] , [0..9]
      $002E, $0030..$0039:
        Result := True
    else
      Result := False;
    end;
  end;

var
  QM: UCS4Char;
  WhitespaceSkipped: Boolean;
begin
  Result := True;
  DeclType := DT_UNSPECIFIED;
  EncName := '';
  Version := '1.0';  // Version 1.0 is the default.  Cf. XML 1.1, sec. 4.3.4.
  Standalone := STANDALONE_UNSPECIFIED;
  try
    if Match('<?xml') then begin // Does the stream start with '<?xml'?
      DeclType := DT_XML_OR_TEXT_DECLARATION;

      WhitespaceSkipped := SkipNext(GetXmlWhitespaceWideString) > 0;

      // version:
      if CurrentCharInfo.CodePoint = $0076 then begin // 'v'
        if not WhitespaceSkipped then begin
          Result := False;
          Exit;
        end;
        if Match('ersion') then begin
          SkipNext(GetXmlWhitespaceWideString);
          if not ( CurrentCharInfo.CodePoint = $003D ) then begin  // '='
            Result := False;
            Exit;
          end;
          SkipNext(GetXmlWhitespaceWideString);
          if not ( ( CurrentCharInfo.CodePoint = $0022 ) or
                   ( CurrentCharInfo.CodePoint = $0027 ) ) then begin  // '"' or '''
            Result := False;
            Exit;
          end;
          QM := CurrentCharInfo.CodePoint;
          Next;
          if IsXmlVersionNumCharCodePoint(CurrentCharInfo.CodePoint) then begin
            Version := string(Char(CurrentCharInfo.CodePoint));
          end else begin
            Result := False;
            Exit;
          end;
          Next;
          while IsXmlVersionNumCharCodePoint(CurrentCharInfo.CodePoint) do begin
            Version := Concat(Version, string(Char(CurrentCharInfo.CodePoint)));
            Next;
          end;
          if CurrentCharInfo.CodePoint <> QM then begin  // Is the first quotation mark of the same type as the second?
            Result := False;
            Exit;
          end;
          WhitespaceSkipped := SkipNext(GetXmlWhitespaceWideString) > 0;
        end else begin
          Result := False;
          Exit;
        end; {if ... else ...}
      end else DeclType := DT_TEXT_DECLARATION;

      // EncodingDecl:
      if CurrentCharInfo.CodePoint = $0065 then begin // 'e'
        if not WhitespaceSkipped then begin
          Result := False;
          Exit;
        end;
        if Match('ncoding') then begin
          SkipNext(GetXmlWhitespaceWideString);
          if not ( CurrentCharInfo.CodePoint = $003D ) then begin  // '='
            Result := False;
            Exit;
          end;
          SkipNext(GetXmlWhitespaceWideString);
          if not ( ( CurrentCharInfo.CodePoint = $0022 ) or
                   ( CurrentCharInfo.CodePoint = $0027 ) ) then begin  // '"' or '''
            Result := False;
            Exit;
          end;
          QM := CurrentCharInfo.CodePoint;
          Next;
          if IsXmlEncNameLeadingCharCodePoint(CurrentCharInfo.CodePoint) then begin
            EncName := string(Char(CurrentCharInfo.CodePoint));
          end else begin
            Result := False;
            Exit;
          end;
          Next;
          while IsXmlEncNameFollowingCharCodePoint(CurrentCharInfo.CodePoint) do begin
            EncName := Concat(EncName, string(Char(CurrentCharInfo.CodePoint)));
            Next;
          end;
          if CurrentCharInfo.CodePoint <> QM then begin  // Is the first quotation mark of the same type as the second?
            Result := False;
            Exit;
          end;
          WhitespaceSkipped := SkipNext(GetXmlWhitespaceWideString) > 0;
        end else begin
          Result := False;
          Exit;
        end; {if ... else ...}
      end else begin
        if DeclType = DT_TEXT_DECLARATION then begin
          Result := False;
          Exit;
        end else DeclType := DT_XML_DECLARATION;
      end; {if ... else ...}

      // SDDecl:
      if CurrentCharInfo.CodePoint = $0073 then begin // 's'
        if not WhitespaceSkipped then begin
          Result := False;
          Exit;
        end;
        if Match('tandalone') then begin
          SkipNext(GetXmlWhitespaceWideString);
          if not ( CurrentCharInfo.CodePoint = $003D ) then begin  // '='
            Result := False;
            Exit;
          end;
          SkipNext(GetXmlWhitespaceWideString);
          if not ( ( CurrentCharInfo.CodePoint = $0022 ) or
                   ( CurrentCharInfo.CodePoint = $0027 ) ) then begin  // '"' or '''
            Result := False;
            Exit;
          end;
          QM := CurrentCharInfo.CodePoint;
          Next;

          case CurrentCharInfo.CodePoint of
            $0079: begin // 'y'
              Next;
              if CurrentCharInfo.CodePoint = $0065 then begin  // 'e'
                Next;
                if CurrentCharInfo.CodePoint = $0073 then begin // 's'
                  Standalone := STANDALONE_YES;
                end else begin
                  Result := False;
                  Exit;
                end;
              end else begin
                Result := False;
                Exit;
              end;
            end;
            $006e: begin // 'n'
              Next;
              if CurrentCharInfo.CodePoint = $006f then begin // 'o'
                Standalone := STANDALONE_NO;
              end else begin
                Result := False;
                Exit;
              end;
            end;
          else
            Result := False;
            Exit;
          end; {case ...}
          Next;
          if CurrentCharInfo.CodePoint <> QM then begin  // Is the first quotation mark of the same type as the second?
            Result := False;
            Exit;
          end;
          SkipNext(GetXmlWhitespaceWideString);
        end else begin
          Result := False;
          Exit;
        end; {if ... else ...}
        if DeclType = DT_TEXT_DECLARATION then begin
          Result := False;
          Exit;
        end else DeclType := DT_XML_DECLARATION;
      end; {if ...}

      // '?>':
      if (CurrentCharInfo.CodePoint = $003F) // '?'
        and Match('>') then begin   // '>'

        ResetPosition := Position - NextCharInfo.Size;

      end else
        Result := False;

    end else
      Reset;

  except
    Result := False;
  end; {try ...}
end;



{ TXmlCustomTokenizer }

constructor TXmlCustomTokenizer.Create(const InputSource: TXmlSimpleInputSource);
begin
  inherited Create;
  FTokenValue := TUtilsCustomWideStr.Create;
  FInputSource := InputSource;
  FTokenStart := InputSource.CurrentCharInfo;
  FTokenEnd := InputSource.PreviousCharInfo;
  FErrorType := ET_NONE;
end;

destructor TXmlCustomTokenizer.Destroy;
begin
  FTokenValue.Free;
  inherited;
end;

function TXmlCustomTokenizer.GetEndByteNumber: Int64;
begin
  Result := FTokenEnd.ByteCount;
end;

function TXmlCustomTokenizer.GetEndCharNumber: Int64;
begin
  Result := FTokenEnd.CharCount;
end;

function TXmlCustomTokenizer.GetEndColumnNumber: Int64;
begin
  Result := FTokenEnd.CharsInLine;
end;

function TXmlCustomTokenizer.GetEndLineNumber: Int64;
begin
  Result := FTokenEnd.Line;
end;

function TXmlCustomTokenizer.GetEndTabsInLine: Int64;
begin
  Result := FTokenEnd.TabsInLine;
end;

function TXmlCustomTokenizer.GetRelatedDtdObject: TDtdObject;
begin
  Result := nil;
end;

function TXmlCustomTokenizer.GetRelatedNode: TDomNode;
begin
  Result := nil;
end;

function TXmlCustomTokenizer.GetStartByteNumber: Int64;
begin
  Result := FTokenStart.ByteCount - FTokenStart.Size;
end;

function TXmlCustomTokenizer.GetStartCharNumber: Int64;
begin
  Result := FTokenStart.CharCount;
end;

function TXmlCustomTokenizer.GetStartColumnNumber: Int64;
begin
  Result := FTokenStart.CharsInLine;
end;

function TXmlCustomTokenizer.GetStartLineNumber: Int64;
begin
  Result := FTokenStart.Line;
end;

function TXmlCustomTokenizer.GetStartTabsInLine: Int64;
begin
  Result := FTokenStart.TabsInLine;
end;

{$IFDEF NEXTGEN}
function TXmlCustomTokenizer.GetTokenValue: string;
{$ELSE !NEXTGEN}
function TXmlCustomTokenizer.GetTokenValue: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FTokenValue.Value;
end;

{$IFDEF NEXTGEN}
function TXmlCustomTokenizer.GetUri: string;
{$ELSE !NEXTGEN}
function TXmlCustomTokenizer.GetUri: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FInputSource.SystemId;
end;



{ TXmlDocTokenizer }

constructor TXmlDocTokenizer.Create(const InputSource: TXmlSimpleInputSource);
begin
  inherited Create(InputSource);
  if Assigned(InputSource)
    then FTokenType := XML_START_OF_SOURCE_TOKEN
    else FTokenType := XML_END_OF_SOURCE_TOKEN;
end;

procedure TXmlDocTokenizer.Next;
const
  EM_CODE          = $21; // code of !
  DQ_CODE          = $22; // code of "
  NUMBER_CODE      = $23; // code of #
  AMP_CODE         = $26; // code of &
  SQ_CODE          = $27; // code of '
  HYPHEN_CODE      = $2D; // code of -
  SOLIDUS_CODE     = $2F; // code of /
  SEMICOLON_CODE   = $3B; // code of ;
  LT_CODE          = $3C; // code of <
  GT_CODE          = $3E; // code of >
  QM_CODE          = $3F; // code of ?
  CAPITAL_C_CODE   = $43; // code of C
  CAPITAL_D_CODE   = $44; // code of D
  CAPITAL_O_CODE   = $4F; // code of O
  LS_BRACKET_CODE  = $5B; // code of [
  RS_BRACKET_CODE  = $5D; // code of ]
  SMALL_C_CODE     = $63; // code of c
  SMALL_D_CODE     = $64; // code of d
  SMALL_O_CODE     = $6F; // code of o
  SMALL_X_CODE     = $78; // code of x
  STRING_TERMINATOR_CODE = $9C;

  CDATA_START: array[0..5] of UCS4Char =
    (Ord('C'), Ord('D'), Ord('A'), Ord('T'), Ord('A'), Ord('['));
  DOCTYPE_START: array[0..5] of UCS4Char =
    (Ord('O'), Ord('C'), Ord('T'), Ord('Y'), Ord('P'), Ord('E'));

{$IFDEF NEXTGEN}
  PIEND: string = '?>';
{$ELSE !NEXTGEN}
  PIEND: WideString = '?>';
{$ENDIF NEXTGEN}
var
  I: Integer;
{$IFDEF NEXTGEN}
  SubEndMarker, SubStartMarker: string;
{$ELSE !NEXTGEN}
  SubEndMarker, SubStartMarker: WideString;
{$ENDIF NEXTGEN}
  SQ_Open, DQ_Open, Bracket_Open: Boolean;
begin
  if FTokenType = XML_END_OF_SOURCE_TOKEN then Exit;

  FTokenValue.Clear;
  FErrorType := ET_NONE;
  FClue := '';
  FTokenStart := FInputSource.NextCharInfo;

  try
    FInputSource.Next;

    case FInputSource.CurrentCharInfo.CodePoint of

      // '<' found:
      LT_CODE: begin
        case FInputSource.NextCharInfo.CodePoint of

          // '/' --> End Tag found:
          SOLIDUS_CODE: begin
            FTokenType := XML_END_TAG_TOKEN;
            FInputSource.Next;
            FTokenStart := FInputSource.NextCharInfo;
            while not ( IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) or
                        (FInputSource.NextCharInfo.CodePoint = GT_CODE) or // '>'
                        (FInputSource.NextCharInfo.CodePoint = STRING_TERMINATOR_CODE) ) do begin
              FInputSource.Next;
              FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            end;
            FTokenEnd := FInputSource.CurrentCharInfo;
            while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do // Skip whitespace.
              FInputSource.Next;
            if FInputSource.NextCharInfo.CodePoint = GT_CODE then begin// '>' ?
              FInputSource.Next;
            end else begin
              FErrorType := ET_UNCLOSED_ELEMENT;
              FClue := '>';
            end;
          end;

          // '?' --> Processing Instruction found:
          QM_CODE: begin
            FTokenType := XML_PI_TOKEN;
            FInputSource.Next;
            FTokenStart := FInputSource.NextCharInfo;
            while FInputSource.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE do begin
              FInputSource.Next;
              if (FInputSource.CurrentCharInfo.CodePoint = QM_CODE) and
                 (FInputSource.NextCharInfo.CodePoint = GT_CODE)
              then begin
                // '?>' found:
                FTokenEnd := FInputSource.PreviousCharInfo;
                FInputSource.Next;
                Exit;
              end;
              FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            end;
            FTokenEnd := FInputSource.PreviousCharInfo;
            FErrorType := ET_UNCLOSED_PROCESSING_INSTRUCTION;
            FClue := '?';
          end;

          // '!' --> Comment, CDATA Section or Document Type Declaration found:
          EM_CODE: begin
            FInputSource.Next;
            case FInputSource.NextCharInfo.CodePoint of

              HYPHEN_CODE: begin // '-' --> Comment found:
                FTokenType := XML_COMMENT_TOKEN;
                FInputSource.Next;
                if FInputSource.NextCharInfo.CodePoint = HYPHEN_CODE then begin // '<!--' found:
                  FInputSource.Next;
                  FTokenStart := FInputSource.NextCharInfo;
                  while FInputSource.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE do begin
                    FInputSource.Next;
                    if FInputSource.CurrentCharInfo.CodePoint = HYPHEN_CODE then begin // '-' found
                      FTokenEnd := FInputSource.PreviousCharInfo;
                      FInputSource.Next;
                      case FInputSource.CurrentCharInfo.CodePoint of
                        HYPHEN_CODE: begin // Second '-'
                          if FInputSource.NextCharInfo.CodePoint = GT_CODE then begin// '>'?
                            FInputSource.Next;
                          end else begin
                            FTokenEnd := FInputSource.CurrentCharInfo;
                            FErrorType := ET_DOUBLE_HYPHEN_IN_COMMENT;
                            FClue := '>';
                          end;
                          Exit;
                        end;
                        STRING_TERMINATOR_CODE: begin
                          FTokenEnd := FInputSource.PreviousCharInfo;
                          FErrorType := ET_UNCLOSED_COMMENT;
                          FClue := '-->';
                          Exit;
                        end;
                      else
                        // No second '-' --> Add '-' to content of comment:
                        FTokenValue.AddUCS4Char(HYPHEN_CODE);
                      end;
                    end;
                    FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
                  end;
                  FTokenEnd := FInputSource.CurrentCharInfo;
                  FErrorType := ET_UNCLOSED_COMMENT;
                  FClue := '-->';
                  Exit;
                end;
                FTokenEnd := FInputSource.CurrentCharInfo;
                FErrorType := ET_COMMENT_START_EXPECTED;
                FClue := '<!--';
              end;

              LS_BRACKET_CODE: begin // '[' --> CDATA Section found:
                FTokenType := XML_CDATA_TOKEN;
                FInputSource.Next;
                for I := 0 to 5 do
                  if FInputSource.NextCharInfo.CodePoint = CDATA_START[I] then begin
                    FInputSource.Next;
                  end else begin
                    FTokenEnd := FInputSource.CurrentCharInfo;
                    FErrorType := ET_CDATA_START_EXPECTED;
                    FClue := '<![CDATA[';
                    Exit;
                  end;
                FTokenStart := FInputSource.NextCharInfo;
                while FInputSource.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE do begin
                  FInputSource.Next;
                  while (FInputSource.CurrentCharInfo.CodePoint = RS_BRACKET_CODE) and
                        (FInputSource.NextCharInfo.CodePoint = RS_BRACKET_CODE) do begin
                    // ']]' found:
                    FTokenEnd := FInputSource.PreviousCharInfo;
                    FInputSource.Next;
                    if FInputSource.NextCharInfo.CodePoint = GT_CODE then begin
                      // '>' found:
                      FInputSource.Next;
                      Exit;
                    end else
                      FTokenValue.AddUCS4Char(RS_BRACKET_CODE);
                  end;
                  FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
                end;
                FTokenEnd := FInputSource.CurrentCharInfo;
                FErrorType := ET_UNCLOSED_CDATA_SECTION;
                FClue := ']]>';
              end;

              CAPITAL_D_CODE: begin // 'D' --> Document Type Declaration found:
                FTokenType := XML_DOCTYPE_TOKEN;
                FInputSource.Next;
                for I := 0 to 5 do
                  if FInputSource.NextCharInfo.CodePoint = DOCTYPE_START[I] then begin
                    FInputSource.Next;
                  end else begin
                    FErrorType := ET_DOCTYPE_START_EXPECTED;
                    FClue := '<!DOCTYPE';
                    Exit;
                  end;
                DQ_Open := False;
                SQ_Open := False;
                Bracket_Open := False;
                SubStartMarker := '';
                SubEndMarker := '';
                FTokenStart := FInputSource.NextCharInfo;
                while FInputSource.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE do begin
                  FInputSource.Next;
                  if (FInputSource.CurrentCharInfo.CodePoint = GT_CODE) // '>'
                     and (not DQ_Open)
                     and (not SQ_Open)
                     and (not Bracket_Open)
                     and (SubEndMarker = '')
                    then begin
                      FTokenEnd := FInputSource.PreviousCharInfo;
                      Exit;
                    end;
                  FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);

                  if (SubEndMarker = '') then begin

                    if (FInputSource.CurrentCharInfo.CodePoint = SQ_CODE) and (not DQ_Open) then begin
                      SQ_Open := not SQ_Open;
                    end else if (FInputSource.CurrentCharInfo.CodePoint = DQ_CODE) and (not SQ_Open) then begin
                      DQ_Open := not DQ_Open;
                    end;

                    if Bracket_Open then begin
                      if not (SQ_Open or DQ_Open) then begin
                        if FInputSource.CurrentCharInfo.CodePoint = LT_CODE then begin  // '<'
                          SubStartMarker := '<';
                        end else if (FInputSource.CurrentCharInfo.CodePoint = EM_CODE) and (SubStartMarker = '<') then begin // '!'
                          SubStartMarker := '<!';
                        end else if (FInputSource.CurrentCharInfo.CodePoint = QM_CODE) and (SubStartMarker = '<') then begin // '?'
                          SubStartMarker := '';
                          SubEndMarker := PIEND;
                        end else if (FInputSource.CurrentCharInfo.CodePoint = HYPHEN_CODE) and (SubStartMarker = '<!')then begin // '-'
                          SubStartMarker := '<!-';
                        end else if (FInputSource.CurrentCharInfo.CodePoint = HYPHEN_CODE) and (SubStartMarker = '<!-')then begin // '-'
                          SubStartMarker := '';
                          SubEndMarker := '-->';
                        end else if SubStartMarker <> '' then begin
                          SubStartMarker := '';
                        end;
                        if (FInputSource.CurrentCharInfo.CodePoint = RS_BRACKET_CODE) // ']'
                          and (not SQ_Open)
                          and (not DQ_Open)
                          then Bracket_Open:= False;
                      end; {if not ...}
                    end else begin {if BracketOpened ... }
                      if (FInputSource.CurrentCharInfo.CodePoint = LS_BRACKET_CODE) // '['
                        and (not SQ_Open)
                        and (not DQ_Open) then Bracket_Open:= True;
                    end; {if BracketOpened ... else ...}

                  end else begin; {if (SubEndMarker = '') ...}
                    if FTokenValue.EndsWith(SubEndMarker) then SubEndMarker := '';
                  end; {if (SubEndMarker = '') ... else ...}

                end;
                FTokenEnd := FInputSource.CurrentCharInfo;
                FErrorType := ET_UNCLOSED_DOCTYPE;
                FClue := ']>';
              end;

              SMALL_D_CODE, CAPITAL_O_CODE, SMALL_O_CODE: begin // 'd', 'O' 'o' --> Possible Document Type Declaration typo found:
                FTokenEnd := FInputSource.CurrentCharInfo;
                FTokenType := XML_DOCTYPE_TOKEN;
                FErrorType := ET_DOCTYPE_START_EXPECTED;
                FClue := '<!DOCTYPE';
              end;

              RS_BRACKET_CODE, CAPITAL_C_CODE, SMALL_C_CODE: begin // ']' 'C', 'c' --> Possible CDATA section typo found:
                FTokenEnd := FInputSource.CurrentCharInfo;
                FTokenType := XML_CDATA_TOKEN;
                FErrorType := ET_CDATA_START_EXPECTED;
                FClue := '<![CDATA[';
              end;

            else
              FTokenEnd := FInputSource.CurrentCharInfo;
              FTokenType := XML_COMMENT_TOKEN;
              FErrorType := ET_COMMENT_START_EXPECTED;
              FClue := '<!--';
            end;
          end;

          GT_CODE: begin
            FTokenEnd := FInputSource.CurrentCharInfo;
            FInputSource.Next;
            FTokenType := XML_START_TAG_TOKEN;
            FErrorType := ET_MISSING_ELEMENT_NAME;
          end;

          STRING_TERMINATOR_CODE: begin
            FTokenEnd := FInputSource.CurrentCharInfo;
            FTokenType := XML_START_TAG_TOKEN;
            FErrorType := ET_MISSING_ELEMENT_NAME;
          end;

        else

          // Start Tag or Empty Element Tag found:
          SQ_Open:= False;
          DQ_Open:= False;
          FInputSource.Next;
          FTokenStart := FInputSource.CurrentCharInfo;
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          while not (FInputSource.NextCharInfo.CodePoint in [SOLIDUS_CODE, GT_CODE, STRING_TERMINATOR_CODE]) do begin
            FInputSource.Next;
            FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            if FInputSource.CurrentCharInfo.CodePoint = SQ_CODE then
              SQ_Open:= True;
            if FInputSource.CurrentCharInfo.CodePoint = DQ_CODE then
              DQ_Open:= True;
            while SQ_Open and (FInputSource.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE) do begin
              FInputSource.Next;
              FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
              if FInputSource.CurrentCharInfo.CodePoint = SQ_CODE then
                SQ_Open:= False;
            end;
            while DQ_Open and (FInputSource.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE) do begin
              FInputSource.Next;
              FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
              if FInputSource.CurrentCharInfo.CodePoint = DQ_CODE then
                DQ_Open:= False;
            end;
          end;
          FTokenEnd := FInputSource.CurrentCharInfo;
          case FInputSource.NextCharInfo.CodePoint of
            SOLIDUS_CODE: begin
              FTokenType := XML_EMPTY_ELEMENT_TAG_TOKEN;
              FInputSource.Next;
              if FInputSource.NextCharInfo.CodePoint = GT_CODE then begin
                FInputSource.Next;
              end else begin
                FErrorType := ET_UNCLOSED_ELEMENT;
                FClue := '>';
              end;
            end;
            GT_CODE: begin
              FTokenType := XML_START_TAG_TOKEN;
              FInputSource.Next;
            end;
            STRING_TERMINATOR_CODE: begin
              FTokenType := XML_START_TAG_TOKEN;
              FErrorType := ET_UNCLOSED_ELEMENT;
              if SQ_Open then begin
                FClue := '''>';
              end else if DQ_Open then begin
                FClue := '">';
              end else
                FClue := '>';
            end;
          end;
        end;
      end;

      // Start of reference ('&') found:
      AMP_CODE: begin
        if FInputSource.NextCharInfo.CodePoint = NUMBER_CODE then begin // '#' found --> Character reference.
          FInputSource.Next;

          if FInputSource.NextCharInfo.CodePoint = SMALL_X_CODE then begin // 'x' found --> Hexadecimal character reference.
            FTokenType := XML_CHAR_REF_HEX_TOKEN;
            FInputSource.Next;
            FTokenStart := FInputSource.NextCharInfo;
            while IsXmlHexDigitCodePoint(FInputSource.NextCharInfo.CodePoint) do begin
              FInputSource.Next;
              FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            end;
          end else begin // Decimal character reference
            FTokenType := XML_CHAR_REF_DEC_TOKEN;
            FTokenStart := FInputSource.NextCharInfo;
            while IsXmlDecDigitCodePoint(FInputSource.NextCharInfo.CodePoint) do begin
              FInputSource.Next;
              FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            end;
          end;
          FTokenEnd := FInputSource.CurrentCharInfo;
          if FInputSource.NextCharInfo.CodePoint = SEMICOLON_CODE then begin // ';' found
            FInputSource.Next;
          end else begin
            FErrorType := ET_UNCLOSED_CHAR_REF;
            FClue := ';';
          end;

        end else begin // Entity reference
          FTokenType := XML_ENTITY_REF_TOKEN;

          FTokenStart := FInputSource.NextCharInfo;
          if IsXmlNameStartCharCodePoint(FInputSource.NextCharInfo.CodePoint)
          then begin
            FInputSource.Next;
            FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            while IsXmlNameCharCodePoint(FInputSource.NextCharInfo.CodePoint) do begin
              FInputSource.Next;
              FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            end;
            FTokenEnd := FInputSource.CurrentCharInfo;
            if FInputSource.NextCharInfo.CodePoint = SEMICOLON_CODE then begin// ';' found
              FInputSource.Next;
            end else begin
              FErrorType := ET_UNCLOSED_ENTITY_REF;
              FClue := ';';
            end;
          end else begin
            FTokenEnd := FInputSource.CurrentCharInfo;
            FErrorType := ET_MISSING_ENTITY_NAME;
          end;
        end;
      end;

      // End of source found:
      STRING_TERMINATOR_CODE: begin
        FTokenEnd := FInputSource.CurrentCharInfo;
        FTokenType := XML_END_OF_SOURCE_TOKEN;
      end;

    else
      // PCDATA found:
      FTokenType := XML_PCDATA_TOKEN;
      FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
      while not (FInputSource.NextCharInfo.CodePoint in [AMP_CODE, LT_CODE, STRING_TERMINATOR_CODE]) do begin
        FInputSource.Next;
        FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
      end;
      FTokenEnd := FInputSource.CurrentCharInfo;
    end;

  except
    on EConvertError do begin
      FTokenEnd := FInputSource.CurrentCharInfo;
      FErrorType := ET_INVALID_CHARACTER;
    end;
  end; {try ...}
end;



{ TXmlDoctypeDeclTokenizer }

{$IFDEF NEXTGEN}
constructor TXmlDoctypeDeclTokenizer.Create(const S,
                                                  DocumentUri: string;
                                                  InitialByteCount,
                                                  InitialCharCount,
                                                  InitialCharsInLine,
                                                  InitialTabsInLine,
                                                  InitialLine: Int64);
{$ELSE !NEXTGEN}
constructor TXmlDoctypeDeclTokenizer.Create(const S,
                                                  DocumentUri: WideString;
                                                  InitialByteCount,
                                                  InitialCharCount,
                                                  InitialCharsInLine,
                                                  InitialTabsInLine,
                                                  InitialLine: Int64);
{$ENDIF NEXTGEN}
begin
  inherited Create;
  if InitialCharsInLine < 0 then // Indicates a starting LF
    Dec(InitialLine);                                                 
  FInputSource := nil;  // Remark: If an exception occurs, the destructor is automatically called.
  FStringStream := nil; //         Therefore, we need to initialize critical objects with nil first.
  FTokenValue := TUtilsCustomWideStr.Create;
  FStringStream := TUtilsWideStringStream.Create(S);
  FInputSource := TXmlSimpleInputSource.Create(FStringStream, '', DocumentUri, 4096,
                   'UTF-16LE', InitialByteCount, InitialCharCount,
                   InitialCharsInLine, InitialTabsInLine, InitialLine);

  FTokenStart := FInputSource.CurrentCharInfo;
  FTokenEnd := FInputSource.PreviousCharInfo;
  FTokenType := DOCTYPE_START_OF_SOURCE_TOKEN;
  FErrorType := ET_NONE;
end;

destructor TXmlDoctypeDeclTokenizer.Destroy;
begin
  FInputSource.Free;  // Remark: Free the Reader before the stream.
  FStringStream.Free;
  FTokenValue.Free;
  inherited;
end;

function TXmlDoctypeDeclTokenizer.GetEndByteNumber: Int64;
begin
  Result := FTokenEnd.ByteCount;
end;

function TXmlDoctypeDeclTokenizer.GetEndCharNumber: Int64;
begin
  Result := FTokenEnd.CharCount;
end;

function TXmlDoctypeDeclTokenizer.GetEndColumnNumber: Int64;
begin
  Result := FTokenEnd.CharsInLine;
end;

function TXmlDoctypeDeclTokenizer.GetEndLineNumber: Int64;
begin
  Result := FTokenEnd.Line;
end;

function TXmlDoctypeDeclTokenizer.GetEndTabsInLine: Int64;
begin
  Result := FTokenEnd.TabsInLine;
end;

function TXmlDoctypeDeclTokenizer.GetRelatedDtdObject: TDtdObject;
begin
  Result := nil;
end;

function TXmlDoctypeDeclTokenizer.GetRelatedNode: TDomNode;
begin
  Result := nil;
end;

function TXmlDoctypeDeclTokenizer.GetStartByteNumber: Int64;
begin
  Result := FTokenStart.ByteCount - FTokenStart.Size;
end;

function TXmlDoctypeDeclTokenizer.GetStartCharNumber: Int64;
begin
  Result := FTokenStart.CharCount;
end;

function TXmlDoctypeDeclTokenizer.GetStartColumnNumber: Int64;
begin
  Result := FTokenStart.CharsInLine;
end;

function TXmlDoctypeDeclTokenizer.GetStartLineNumber: Int64;
begin
  Result := FTokenStart.Line;
end;

function TXmlDoctypeDeclTokenizer.GetStartTabsInLine: Int64;
begin
  Result := FTokenStart.TabsInLine;
end;

{$IFDEF NEXTGEN}
function TXmlDoctypeDeclTokenizer.GetTokenValue: string;
{$ELSE !NEXTGEN}
function TXmlDoctypeDeclTokenizer.GetTokenValue: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FTokenValue.Value;
end;

{$IFDEF NEXTGEN}
function TXmlDoctypeDeclTokenizer.GetUri: string;
{$ELSE !NEXTGEN}
function TXmlDoctypeDeclTokenizer.GetUri: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FInputSource.SystemId;
end;

procedure TXmlDoctypeDeclTokenizer.Next;
const
  EM_CODE          = $21; // code of !
  DQ_CODE          = $22; // code of "
  SQ_CODE          = $27; // code of '
  HYPHEN_CODE      = $2D; // code of -
  LT_CODE          = $3C; // code of <
  GT_CODE          = $3E; // code of >
  QM_CODE          = $3F; // code of ?
  CAPITAL_P_CODE   = $50; // code of P
  CAPITAL_S_CODE   = $53; // code of S
  LS_BRACKET_CODE  = $5B; // code of [
  RS_BRACKET_CODE  = $5D; // code of ]
  STRING_TERMINATOR_CODE = $9C;

  PUBLIC_ID_START: array[0..4] of UCS4Char =
    (Ord('U'), Ord('B'), Ord('L'), Ord('I'), Ord('C'));
  SYSTEM_ID_START: array[0..4] of UCS4Char =
    (Ord('Y'), Ord('S'), Ord('T'), Ord('E'), Ord('M'));
var
  CommentStartFound: Boolean;
  CommentEndFound: Boolean;
  DoctypeNameStart: Boolean;
  DQ_Open: Boolean;
  EM_Found: Boolean;
  I: Integer;
  InComment: Boolean;
  InPI: Boolean;
  LT_Found: Boolean;
  QuoteCode: UCS4Char;
  SQ_Open: Boolean;
begin
  if FTokenType = DOCTYPE_END_OF_SOURCE_TOKEN then Exit;

  FTokenValue.Clear;
  FErrorType := ET_NONE;
  FClue := '';
  FTokenStart := FInputSource.NextCharInfo;

  try

    case FTokenType of
      DOCTYPE_INTSUBSET_TOKEN:
        begin
          // Skip whitespace:
          while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do
            FInputSource.Next;

          FInputSource.Next;
          if FInputSource.CurrentCharInfo.CodePoint = STRING_TERMINATOR_CODE then begin
            FTokenEnd := FInputSource.PreviousCharInfo;
            FTokenType := DOCTYPE_END_OF_SOURCE_TOKEN
          end else begin
            FTokenEnd := FInputSource.CurrentCharInfo;
            FErrorType := ET_UNCLOSED_DOCTYPE;
          end;
        end;

      DOCTYPE_NAME_TOKEN:
        begin
          // Skip optional whitespace:
          while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do
            FInputSource.Next;

          case FInputSource.NextCharInfo.CodePoint of
            STRING_TERMINATOR_CODE:
              begin
                FInputSource.Next;
                FTokenEnd := FInputSource.PreviousCharInfo;
                FTokenType := DOCTYPE_END_OF_SOURCE_TOKEN;
              end;
            CAPITAL_P_CODE: // 'P' --> 'PUBLIC' found.
              begin
                FInputSource.Next;
                FTokenStart := FInputSource.CurrentCharInfo;
                for I := 0 to 4 do
                  if FInputSource.NextCharInfo.CodePoint = PUBLIC_ID_START[I] then begin
                    FInputSource.Next;
                  end else begin
                    FTokenEnd := FInputSource.CurrentCharInfo;
                    FErrorType := ET_PUBLIC_KEYWORD_EXPECTED;
                    FClue := 'PUBLIC';
                    Exit;
                  end;

                FTokenType := DOCTYPE_PUBID_TOKEN;
                FTokenStart := FInputSource.NextCharInfo;

                // Check for whitespace:
                if not IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) then begin
                  FTokenEnd := FInputSource.CurrentCharInfo;
                  FErrorType := ET_MISSING_WHITE_SPACE;
                  FClue := ' ';
                  Exit;
                end;

                // Skip whitespace:
                FInputSource.Next;
                while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do
                  FInputSource.Next;

                FTokenStart := FInputSource.NextCharInfo;

                // Find public identifier:
                if not (FInputSource.NextCharInfo.CodePoint in [DQ_CODE, SQ_CODE]) then begin
                  FTokenEnd := FInputSource.CurrentCharInfo;
                  FErrorType := ET_QUOTATION_MARK_EXPECTED;
                  FClue := '"';
                  Exit;
                end;
                FInputSource.Next;
                FTokenStart := FInputSource.NextCharInfo;
                QuoteCode := FInputSource.CurrentCharInfo.CodePoint;
                while not (FInputSource.NextCharInfo.CodePoint in [QuoteCode, STRING_TERMINATOR_CODE]) do begin
                  FInputSource.Next;
                  FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
                end;
                FTokenEnd := FInputSource.CurrentCharInfo;
                if FInputSource.NextCharInfo.CodePoint <> QuoteCode then begin
                  FErrorType := ET_QUOTATION_MARK_EXPECTED;
                  FClue := WideChar(QuoteCode);
                  Exit;
                end;
                FInputSource.Next;

              end;
            CAPITAL_S_CODE: // 'S' --> 'SYSTEM' found.
              begin
                FInputSource.Next;
                FTokenStart := FInputSource.CurrentCharInfo;
                for I := 0 to 4 do
                  if FInputSource.NextCharInfo.CodePoint = SYSTEM_ID_START[I] then begin
                    FInputSource.Next;
                  end else begin
                    FTokenEnd := FInputSource.CurrentCharInfo;
                    FErrorType := ET_SYSTEM_KEYWORD_EXPECTED;
                    FClue := 'SYSTEM';
                    Exit;
                  end;
                FTokenType := DOCTYPE_PUBID_TOKEN;
                Self.Next;
              end;
            LS_BRACKET_CODE: // '[' found.
              begin
                FTokenType := DOCTYPE_SYSID_TOKEN;
                Self.Next;
              end;
          else
            FInputSource.Next;
            FTokenEnd := FInputSource.CurrentCharInfo;
            FErrorType := ET_SYSTEM_KEYWORD_EXPECTED;
            FClue := 'SYSTEM';
          end; {case ...}

        end;

      DOCTYPE_PUBID_TOKEN:
        begin
          FTokenType := DOCTYPE_SYSID_TOKEN;
          FTokenStart := FInputSource.NextCharInfo;

          // Check for whitespace:
          if not IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) then begin
            FTokenEnd := FInputSource.CurrentCharInfo;
            FErrorType := ET_MISSING_WHITE_SPACE;
            FClue := ' ';
            Exit;
          end;

          // Skip whitespace:
          FInputSource.Next;
          while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do
            FInputSource.Next;

          FTokenStart := FInputSource.NextCharInfo;

          // Find system identifier:
          if not (FInputSource.NextCharInfo.CodePoint in [DQ_CODE, SQ_CODE]) then begin
            FTokenEnd := FInputSource.CurrentCharInfo;
            FErrorType := ET_QUOTATION_MARK_EXPECTED;
            FClue := '"';
            Exit;
          end;
          FInputSource.Next;
          QuoteCode := FInputSource.CurrentCharInfo.CodePoint;
          while not (FInputSource.NextCharInfo.CodePoint in [QuoteCode, STRING_TERMINATOR_CODE]) do begin
            FInputSource.Next;
            FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          end;
          FTokenEnd := FInputSource.CurrentCharInfo;
          if FInputSource.NextCharInfo.CodePoint <> QuoteCode then begin
            FErrorType := ET_QUOTATION_MARK_EXPECTED;
            FClue := WideChar(QuoteCode);
            Exit;
          end;
          FInputSource.Next;
        end;

      DOCTYPE_START_OF_SOURCE_TOKEN:
        begin
          FTokenType := DOCTYPE_NAME_TOKEN;

          // Check for leading whitespace:
          FInputSource.Next;
          FTokenStart := FInputSource.CurrentCharInfo;
          if not IsXmlWhiteSpaceCodePoint(FInputSource.CurrentCharInfo.CodePoint) then begin
            FTokenEnd := FInputSource.CurrentCharInfo;
            FErrorType := ET_MISSING_WHITE_SPACE;
            FClue := ' ';
            Exit;
          end;

          // Skip whitespace:
          while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do
            FInputSource.Next;

          // Find doctype name:
          DoctypeNameStart := True;
          FTokenStart := FInputSource.NextCharInfo;
          while not ( IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) or
                      (FInputSource.NextCharInfo.CodePoint = LS_BRACKET_CODE) or // ['
                      (FInputSource.NextCharInfo.CodePoint = GT_CODE) or         // '>'
                      (FInputSource.NextCharInfo.CodePoint = STRING_TERMINATOR_CODE) ) do begin
            FInputSource.Next;
            FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            if DoctypeNameStart then begin
              DoctypeNameStart := False;
            end;
          end;
          FTokenEnd := FInputSource.CurrentCharInfo;
        end;

      DOCTYPE_SYSID_TOKEN:
        begin
          // Skip optional whitespace:
          while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do
            FInputSource.Next;

          case FInputSource.NextCharInfo.CodePoint of
            STRING_TERMINATOR_CODE:
              begin
                FInputSource.Next;
                FTokenEnd := FInputSource.PreviousCharInfo;
                FTokenType := DOCTYPE_END_OF_SOURCE_TOKEN;
              end;
            LS_BRACKET_CODE: // '[' found.
              begin
                FTokenType := DOCTYPE_INTSUBSET_TOKEN;
                FInputSource.Next;
                FTokenStart := FInputSource.NextCharInfo;
                LT_Found := False;
                EM_Found := False;
                CommentStartFound := False;
                CommentEndFound := False;
                InComment := False;
                InPI := False;
                DQ_Open := False;
                SQ_Open := False;
                while FInputSource.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE do begin
                  FInputSource.Next;
                  if CommentEndFound then begin
                    CommentEndFound := False;
                    InComment := False;
                    if FInputSource.NextCharInfo.CodePoint <> GT_Code then begin
                      FTokenEnd := FInputSource.CurrentCharInfo;
                      FErrorType := ET_UNCLOSED_COMMENT;
                      FClue := '-->';
                      Exit;
                    end;
                  end;
                  if InComment then begin
                    if (FInputSource.CurrentCharInfo.CodePoint = HYPHEN_Code) and
                      (FInputSource.NextCharInfo.CodePoint = HYPHEN_Code) then
                      CommentEndFound := True;
                  end;
                  if InPI then begin
                    if (FInputSource.CurrentCharInfo.CodePoint = QM_Code) and
                      (FInputSource.NextCharInfo.CodePoint = GT_Code) then
                      InPI := False;
                  end;
                  if CommentStartFound then begin
                    CommentStartFound := False;
                    if FInputSource.CurrentCharInfo.CodePoint = HYPHEN_CODE then
                      InComment := True;
                  end;
                  if EM_Found then begin
                    EM_Found := False;
                    if FInputSource.CurrentCharInfo.CodePoint = HYPHEN_CODE then
                      CommentStartFound := True;
                  end;
                  if LT_Found then begin
                    LT_Found := False;
                    case FInputSource.CurrentCharInfo.CodePoint of
                      QM_CODE:
                        InPI := True;
                      EM_CODE:
                        EM_Found := True;
                    end;
                  end;
                  if DQ_Open then begin
                    DQ_Open := FInputSource.CurrentCharInfo.CodePoint <> DQ_CODE;
                  end else if SQ_Open then begin
                    SQ_Open := FInputSource.CurrentCharInfo.CodePoint <> SQ_CODE;
                  end else if not (InPI or InComment) then begin
                    case FInputSource.CurrentCharInfo.CodePoint of
                      LT_CODE:         // '<'
                        if not (InPI or InComment) then
                          LT_Found := True;
                      DQ_CODE:         // '"'
                        DQ_Open := True;
                      SQ_CODE:         // '''
                        SQ_Open := True;
                      RS_BRACKET_CODE: // ']'
                        begin
                          FTokenEnd := FInputSource.PreviousCharInfo;
                          Exit;
                        end;
                    end;
                  end;
                  FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
                end;

                if FInputSource.NextCharInfo.CodePoint <> RS_BRACKET_CODE then begin
                  FTokenEnd := FInputSource.CurrentCharInfo;
                  FErrorType := ET_RIGHT_SQUARE_BRACKET_EXPECTED;
                  FClue := ']';
                  Exit;
                end;
                FInputSource.Next;
              end;
          else
            FInputSource.Next;
            FTokenEnd := FInputSource.CurrentCharInfo;
            FErrorType := ET_LEFT_SQUARE_BRACKET_EXPECTED;
            FClue := '[';
          end; {case ...}
        end;
    end;

  except
    on EConvertError do begin
      FTokenEnd := FInputSource.CurrentCharInfo;
      FErrorType := ET_INVALID_CHARACTER;
    end;
  end; {try ...}
end;



{ TXmlDtdDetailTokenizer }

constructor TXmlDtdDetailTokenizer.Create(const InputSource: TXmlSimpleInputSource;
                                          const AIsPERefInDeclSep: Boolean);
begin
  inherited Create(InputSource);
  FInPI := False;
  FIsPERefInDeclSep := AIsPERefInDeclSep;
  FLastTokenType := DTD_DETAIL_START_OF_SOURCE_TOKEN;
  FErrorType := ET_NONE;
  if Assigned(InputSource) then
    FTokenType := DTD_DETAIL_START_OF_SOURCE_TOKEN
  else
    FTokenType := DTD_DETAIL_END_OF_SOURCE_TOKEN;
end;

procedure TXmlDtdDetailTokenizer.Next;
const
  EM_CODE              = $21; // code of !
  DQ_CODE              = $22; // code of "
  PERCENT_CODE         = $25; // code of %
  SQ_CODE              = $27; // code of '
  OPENING_BRACKET_CODE = $28; // code of (
  CLOSING_BRACKET_CODE = $29; // code of )
  ASTERISK_CODE        = $2A; // code of *
  PLUS_SIGN_CODE       = $2B; // code of +
  COMMA_CODE           = $2C; // code of ,
  HYPHEN_CODE          = $2D; // code of -
  SEMICOLON_CODE       = $3B; // code of ;
  LT_CODE              = $3C; // code of <
  GT_CODE              = $3E; // code of >
  QM_CODE              = $3F; // code of ?
  CAPITAL_A_CODE       = $41; // code of A
  CAPITAL_E_CODE       = $45; // code of E
  CAPITAL_L_CODE       = $4C; // code of L
  CAPITAL_N_CODE       = $4E; // code of N
  LS_BRACKET_CODE      = $5B; // code of [
  RS_BRACKET_CODE      = $5D; // code of ]
  VERTICAL_LINE_CODE   = $7C; // code of |

  STRING_TERMINATOR_CODE = $9C;

  ENTITY_DECL_START: array[0..3] of UCS4Char =
    (Ord('T'), Ord('I'), Ord('T'), Ord('Y'));
  ELEMENT_DECL_START: array[0..4] of UCS4Char =
    (Ord('E'), Ord('M'), Ord('E'), Ord('N'), Ord('T'));
  ATTLIST_DECL_START: array[0..5] of UCS4Char =
    (Ord('T'), Ord('T'), Ord('L'), Ord('I'), Ord('S'), Ord('T'));
  NOTATION_DECL_START: array[0..6] of UCS4Char =
    (Ord('O'), Ord('T'), Ord('A'), Ord('T'), Ord('I'), Ord('O'), Ord('N'));
var
  I: Integer;
  QuoteCode: UCS4Char;
begin
  if FTokenType = DTD_DETAIL_END_OF_SOURCE_TOKEN then Exit;

  FTokenValue.Clear;
  FTokenType := DTD_DETAIL_INVALID_MARKUP_TOKEN;
  FErrorType := ET_NONE;
  FClue := '';
  FTokenStart := FInputSource.NextCharInfo;

  try
    FInputSource.Next;

    if FInPI then begin

      if FInputSource.CurrentCharInfo.CodePoint = STRING_TERMINATOR_CODE then begin

        // End of source found:
        FTokenType := DTD_DETAIL_END_OF_SOURCE_TOKEN;
        FTokenEnd := FInputSource.CurrentCharInfo;
        FErrorType := ET_UNCLOSED_PROCESSING_INSTRUCTION;
        FInPI := False;

      end else
      if IsXmlWhiteSpaceCodePoint(FInputSource.CurrentCharInfo.CodePoint) then begin

        // Whitespace found:
        FTokenType := DTD_DETAIL_WHITESPACE_TOKEN;
        FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
        while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do begin
          FInputSource.Next;
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
        end;
        FTokenEnd := FInputSource.CurrentCharInfo;

      end else begin

        // Processing Instruction content found:
        FTokenType := DTD_DETAIL_PI_CONTENT_TOKEN;
        while FInputSource.CurrentCharInfo.CodePoint <> STRING_TERMINATOR_CODE do begin
          if (FInputSource.CurrentCharInfo.CodePoint = QM_CODE) and
             (FInputSource.NextCharInfo.CodePoint = GT_CODE)
          then begin
            // '?>' found:
            FTokenEnd := FInputSource.PreviousCharInfo;
            FInputSource.Next;
            FInPI := False;
            Exit;
          end;
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          FInputSource.Next;
        end;
        FTokenEnd := FInputSource.CurrentCharInfo;
        FErrorType := ET_UNCLOSED_PROCESSING_INSTRUCTION;
        FClue := '?';
        FInPI := False;

      end;

    end else begin
      case FInputSource.CurrentCharInfo.CodePoint of

        // '<' found:
        LT_CODE: begin
          case FInputSource.NextCharInfo.CodePoint of

            // '?' --> Processing Instruction found:
            QM_CODE: begin
              FInputSource.Next;
              FTokenType := DTD_DETAIL_PI_TARGET_TOKEN;
              FTokenStart := FInputSource.NextCharInfo;
              while not ( ( FInputSource.NextCharInfo.CodePoint in
                             [ PERCENT_CODE, LT_CODE, GT_CODE, OPENING_BRACKET_CODE,
                               CLOSING_BRACKET_CODE, VERTICAL_LINE_CODE, COMMA_CODE,
                               DQ_CODE, SQ_CODE, RS_BRACKET_CODE, LS_BRACKET_CODE,
                               QM_CODE, STRING_TERMINATOR_CODE ] ) or
                          IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) ) do begin
                FInputSource.Next;
                FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
              end;
              FTokenEnd := FInputSource.CurrentCharInfo;
              FInPI := True;
            end;

            // '!' --> Markup declaration found:
            EM_CODE: begin
              FInputSource.Next;
              case FInputSource.NextCharInfo.CodePoint of

                HYPHEN_CODE: begin // '-' --> Comment found:
                  FTokenType := DTD_DETAIL_COMMENT_TOKEN;
                  FInputSource.Next;
                  if FInputSource.NextCharInfo.CodePoint = HYPHEN_CODE then begin // '<!--' found:
                    FInputSource.Next;
                    FTokenStart := FInputSource.NextCharInfo;
                    while FInputSource.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE do begin
                      FInputSource.Next;
                      if FInputSource.CurrentCharInfo.CodePoint = HYPHEN_CODE then begin // '-' found
                        FTokenEnd := FInputSource.PreviousCharInfo;
                        FInputSource.Next;
                        case FInputSource.CurrentCharInfo.CodePoint of
                          HYPHEN_CODE: begin // Second '-'
                            if FInputSource.NextCharInfo.CodePoint = GT_CODE then begin// '>'?
                              FInputSource.Next;
                            end else begin
                              FTokenEnd := FInputSource.CurrentCharInfo;
                              FErrorType := ET_DOUBLE_HYPHEN_IN_COMMENT;
                              FClue := '>';
                            end;
                            Exit;
                          end;
                          STRING_TERMINATOR_CODE: begin
                            FTokenEnd := FInputSource.PreviousCharInfo;
                            FErrorType := ET_UNCLOSED_COMMENT;
                            FClue := '-->';
                            Exit;
                          end;
                        else
                          // No second '-' --> Add '-' to content of comment:
                          FTokenValue.AddUCS4Char(HYPHEN_CODE);
                        end;
                      end;
                      FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
                    end;
                    FTokenEnd := FInputSource.CurrentCharInfo;
                    FErrorType := ET_UNCLOSED_COMMENT;
                    FClue := '-->';
                    Exit;
                  end;
                  FTokenEnd := FInputSource.CurrentCharInfo;
                  FErrorType := ET_COMMENT_START_EXPECTED;
                  FClue := '<!--';
                end;

                LS_BRACKET_CODE: begin // '[' --> Conditional Section found:
                  FTokenType := DTD_DETAIL_COND_SECT_START_TOKEN;
                  FInputSource.Next;
                  FTokenEnd := FInputSource.CurrentCharInfo;
                end;

              else // --> Element, Entity, Attlist or Notation Declaration found:
                case FInputSource.NextCharInfo.CodePoint of
                  CAPITAL_E_CODE: begin // 'E' --> Element or Entity Declaration found:
                    FInputSource.Next;
                    case FInputSource.NextCharInfo.CodePoint of

                      CAPITAL_L_CODE: begin // 'L' --> Element Declaration found:
                        FTokenType := DTD_DETAIL_ELEMENT_DECL_START_TOKEN;
                        FInputSource.Next;
                        for I := 0 to 4 do
                          if FInputSource.NextCharInfo.CodePoint = ELEMENT_DECL_START[I] then begin
                            FInputSource.Next;
                          end else begin
                            FTokenEnd := FInputSource.CurrentCharInfo;
                            FErrorType := ET_ELEMENT_DECL_START_EXPECTED;
                            FClue := '<!ELEMENT';
                            Exit;
                          end;
                      end;

                      CAPITAL_N_CODE: begin // 'N' --> Entity Declaration found:
                        FTokenType := DTD_DETAIL_ENTITY_DECL_START_TOKEN;
                        FInputSource.Next;
                        for I := 0 to 3 do
                          if FInputSource.NextCharInfo.CodePoint = ENTITY_DECL_START[I] then begin
                            FInputSource.Next;
                          end else begin
                            FTokenEnd := FInputSource.CurrentCharInfo;
                            FErrorType := ET_ENTITY_DECL_START_EXPECTED;
                            FClue := '<!ENTITY';
                            Exit;
                          end;
                      end;

                    else
                      FTokenEnd := FInputSource.CurrentCharInfo;
                      FErrorType := ET_INVALID_MARKUP_DECL;
                      Exit;
                    end;
                  end;

                  CAPITAL_A_CODE: begin // 'A' --> Attribute List Declaration found:
                    FTokenType := DTD_DETAIL_ATTLIST_DECL_START_TOKEN;
                    FInputSource.Next;
                    for I := 0 to 5 do
                      if FInputSource.NextCharInfo.CodePoint = ATTLIST_DECL_START[I] then begin
                        FInputSource.Next;
                      end else begin
                        FTokenEnd := FInputSource.CurrentCharInfo;
                        FErrorType := ET_ATTLIST_DECL_START_EXPECTED;
                        FClue := '<!ATTLIST';
                        Exit;
                      end;
                  end;

                  CAPITAL_N_CODE: begin // 'N' --> Notation Declaration found:
                    FTokenType := DTD_DETAIL_NOTATION_DECL_START_TOKEN;
                    FInputSource.Next;
                    for I := 0 to 6 do
                      if FInputSource.NextCharInfo.CodePoint = NOTATION_DECL_START[I] then begin
                        FInputSource.Next;
                      end else begin
                        FTokenEnd := FInputSource.CurrentCharInfo;
                        FErrorType := ET_NOTATION_DECL_START_EXPECTED;
                        FClue := '<!NOTATION';
                        Exit;
                      end;
                  end;
                else
                  FTokenEnd := FInputSource.CurrentCharInfo;
                  FErrorType := ET_INVALID_MARKUP_DECL;
                  Exit;
                end;

              end;
            end; {EM_CODE:}

          else
            FTokenEnd := FInputSource.CurrentCharInfo;
            FErrorType := ET_INVALID_MARKUP_DECL;
            FClue := '<!';
          end;
        end;

        LS_BRACKET_CODE: begin
          FTokenType := DTD_DETAIL_COND_SECT_OPENER_TOKEN;
          FTokenEnd := FInputSource.CurrentCharInfo;
        end;

        // End of markup declaration found:
        GT_CODE: begin
          FTokenType := DTD_DETAIL_DECL_END_TOKEN;
          FTokenEnd := FInputSource.CurrentCharInfo;
        end;

        // End of Conditional Section found:
        RS_BRACKET_CODE: begin
          FTokenType := DTD_DETAIL_COND_SECT_END_TOKEN;
          if FInputSource.NextCharInfo.CodePoint = RS_BRACKET_CODE then begin // ']'
            FInputSource.Next;
            if FInputSource.NextCharInfo.CodePoint = GT_CODE then begin // '>'
              FTokenStart := FInputSource.NextCharInfo;
              FInputSource.Next;
            end else begin
              FErrorType := ET_INVALID_CHARACTER;
              FClue := ']]>';
            end;
          end else begin
            FErrorType := ET_INVALID_CHARACTER;
            FClue := ']]>';
          end;
          FTokenEnd := FInputSource.CurrentCharInfo;
        end;

        // Quoted string found:
        DQ_CODE, SQ_CODE: begin
          FTokenType := DTD_DETAIL_QUOTED_STRING_TOKEN;
          QuoteCode := FInputSource.CurrentCharInfo.CodePoint;
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          while FInputSource.NextCharInfo.CodePoint <> QuoteCode do begin
            if FInputSource.NextCharInfo.CodePoint = STRING_TERMINATOR_CODE then begin
              FTokenEnd := FInputSource.CurrentCharInfo;
              FErrorType := ET_QUOTATION_MARK_EXPECTED;
              FClue := WideChar(QuoteCode);
              Exit;
            end;
            FInputSource.Next;
            FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          end;
          FInputSource.Next;
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          FTokenEnd := FInputSource.CurrentCharInfo;
        end;

        OPENING_BRACKET_CODE, VERTICAL_LINE_CODE, COMMA_CODE: begin
          FTokenType := DTD_DETAIL_OPERATOR_TOKEN;
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          FTokenEnd := FInputSource.CurrentCharInfo;
        end;

        CLOSING_BRACKET_CODE: begin
          FTokenType := DTD_DETAIL_OPERATOR_TOKEN;
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          if FInputSource.NextCharInfo.CodePoint in [ASTERISK_CODE, PLUS_SIGN_CODE, QM_CODE] then begin
            FInputSource.Next;
            FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          end;
          FTokenEnd := FInputSource.CurrentCharInfo;
        end;

        // End of source found:
        STRING_TERMINATOR_CODE: begin
          FTokenType := DTD_DETAIL_END_OF_SOURCE_TOKEN;
          FTokenEnd := FInputSource.CurrentCharInfo;
        end;

      else

        if IsXmlWhiteSpaceCodePoint(FInputSource.CurrentCharInfo.CodePoint) then begin

          // Whitespace found:
          FTokenType := DTD_DETAIL_WHITESPACE_TOKEN;
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          while IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) do begin
            FInputSource.Next;
            FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          end;

        end else begin

          if FInputSource.CurrentCharInfo.CodePoint = PERCENT_CODE
            then FTokenType := DTD_DETAIL_KEYWORD_TOKEN // Keyword (or parameter reference) found.
            else FTokenType := DTD_DETAIL_UNQUOTED_STRING_TOKEN;  // Unquoted string found.
          FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
          while not ( ( FInputSource.NextCharInfo.CodePoint in
                         [ PERCENT_CODE, LT_CODE, GT_CODE, OPENING_BRACKET_CODE,
                           CLOSING_BRACKET_CODE, VERTICAL_LINE_CODE, COMMA_CODE,
                           DQ_CODE, SQ_CODE, RS_BRACKET_CODE, LS_BRACKET_CODE,
                           STRING_TERMINATOR_CODE ] ) or
                      IsXmlWhiteSpaceCodePoint(FInputSource.NextCharInfo.CodePoint) ) do begin
            FInputSource.Next;
            FTokenValue.AddUCS4Char(FInputSource.CurrentCharInfo.CodePoint);
            if FInputSource.CurrentCharInfo.CodePoint = SEMICOLON_CODE then
              Break;
          end;

        end;
        FTokenEnd := FInputSource.CurrentCharInfo;

      end;

   end; {if ... else ...}

  except
    on EConvertError do
    begin
      FTokenEnd := FInputSource.CurrentCharInfo;
      FErrorType := ET_INVALID_CHARACTER;
    end;
  end; {try ...}
end;

procedure TXmlDtdDetailTokenizer.NextEndOfIgnoredCondSect;
const
  EM_CODE          = $21; // code of !
  LT_CODE          = $3C; // code of <
  GT_CODE          = $3E; // code of >
  LS_BRACKET_CODE  = $5B; // code of [
  RS_BRACKET_CODE  = $5D; // code of ]
  STRING_TERMINATOR_CODE = $9C;
var
  N: Integer;
begin
  if FTokenType = DTD_DETAIL_END_OF_SOURCE_TOKEN then Exit;

  FTokenValue.Clear;
  FTokenType := DTD_DETAIL_INVALID_MARKUP_TOKEN;
  FErrorType := ET_NONE;
  FClue := '';
  N := 0;

  try

    while FTokenType = DTD_DETAIL_INVALID_MARKUP_TOKEN do begin

      FInputSource.Next;

      case FInputSource.CurrentCharInfo.CodePoint of

        // '<' found:
        LT_CODE:
          if FInputSource.NextCharInfo.CodePoint = EM_CODE then begin // '!' found?
            FInputSource.Next;
            if FInputSource.NextCharInfo.CodePoint = LS_BRACKET_CODE then begin
              // '<![' --> Conditional section start found:
              FInputSource.Next;
              Inc(N);
            end;
          end;

        // ']' found:
        RS_BRACKET_CODE:
          if FInputSource.NextCharInfo.CodePoint = RS_BRACKET_CODE then begin // ']' found?
            FInputSource.Next;
            while FInputSource.NextCharInfo.CodePoint = RS_BRACKET_CODE do // more ']'?
              FInputSource.Next;
            if FInputSource.NextCharInfo.CodePoint = GT_CODE then begin
              // ']]>' --> Conditional section end found:
              FInputSource.Next;
              if N = 0
                then FTokenType := DTD_DETAIL_COND_SECT_END_TOKEN
                else Dec(N);
            end;
          end;

        // End of source found:
        STRING_TERMINATOR_CODE:
          FTokenType := DTD_DETAIL_END_OF_SOURCE_TOKEN;
      end;

    end; {while ...}
  except
    on EConvertError do
      FErrorType := ET_INVALID_CHARACTER;
  end; {try ...}
end;



{ TXmlDtdDetailPETokenizer }

constructor TXmlDtdDetailPETokenizer.Create(const AInputSource: TXmlSimpleInputSource;
                                            const AIsPERefInDeclSep: Boolean);
begin
  if not Assigned(AInputSource) then
    raise ENot_Supported_Err.Create('Not supported error.');
  inherited Create;
  FPERefTreatment := petResolve;
  FIsInMarkup := False;
  FBufSize := AInputSource.BufSize;
  FTokenizerStack   := TStack<TXmlDtdDetailTokenizer>.Create;
  FInputSourceStack := TStack<TXmlSimpleInputSource>.Create;
  FStreamStack      := TStack<TUtilsWideStringStream>.Create;
  FPENameStack      := TUtilsWideStringList.Create;
  FPENameStack.Duplicates := dupAccept;
  FPENameStack.Sorted := False;
  FErrorType := ET_NONE;

  FStreamStack.Push(nil);
  FInputSourceStack.Push(nil);
  CreateInternalTokenizer(AInputSource, '', AIsPERefInDeclSep);
end;

{$IFDEF NEXTGEN}
procedure TXmlDtdDetailPETokenizer.CreateInternalInputSource(const Stream: TStream;
                                                             const PEName,
                                                                   PubId,
                                                                   SysId: string;
                                                             const IsPERefInDeclSep: Boolean);
{$ELSE !NEXTGEN}
procedure TXmlDtdDetailPETokenizer.CreateInternalInputSource(const Stream: TStream;
                                                             const PEName,
                                                                   PubId,
                                                                   SysId: WideString;
                                                             const IsPERefInDeclSep: Boolean);
{$ENDIF NEXTGEN}
var
  XmlInputSource: TXmlSimpleInputSource;
begin
  XmlInputSource := TXmlSimpleInputSource.Create(Stream, PubId, SysId, FBufSize,
                                   'UTF-16LE', 0, 0, 0, 0, 0);                                                        
  try
    CreateInternalTokenizer(XmlInputSource, PEName, IsPERefInDeclSep);
    FInputSourceStack.Push(XmlInputSource);
  except
    XmlInputSource.Free;
    raise;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlDtdDetailPETokenizer.CreateInternalStream(const S,
                                                              PEName,
                                                              PubId,
                                                              SysId: string;
                                                        const IsPERefInDeclSep: Boolean);
{$ELSE !NEXTGEN}
procedure TXmlDtdDetailPETokenizer.CreateInternalStream(const S,
                                                              PEName,
                                                              PubId,
                                                              SysId: WideString;
                                                        const IsPERefInDeclSep: Boolean);
{$ENDIF NEXTGEN}
var
  Stream: TUtilsWideStringStream;
begin
  Stream := TUtilsWideStringStream.Create(S);
  try
    CreateInternalInputSource(Stream, PEName, PubId, SysId, IsPERefInDeclSep);
    FStreamStack.Push(Stream);
  except
    Stream.Free;
    raise;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlDtdDetailPETokenizer.CreateInternalTokenizer(const InputSource: TXmlSimpleInputSource;
                                                           const PEName: string;
                                                           const IsPERefInDeclSep: Boolean);
{$ELSE !NEXTGEN}
procedure TXmlDtdDetailPETokenizer.CreateInternalTokenizer(const InputSource: TXmlSimpleInputSource;
                                                           const PEName: WideString;
                                                           const IsPERefInDeclSep: Boolean);
{$ENDIF NEXTGEN}
begin
  FTokenizerStack.Push(TXmlDtdDetailTokenizer.Create(InputSource, IsPERefInDeclSep));
  FPENameStack.Append(PEName);
end;

destructor TXmlDtdDetailPETokenizer.Destroy;
begin
  while FTokenizerStack.Count > 0 do
    DestroyInternalTokenizer;
  FPENameStack.Free;
  FStreamStack.Free;
  FInputSourceStack.Free;
  FTokenizerStack.Free;
  inherited;
end;

procedure TXmlDtdDetailPETokenizer.DestroyInternalTokenizer;
begin
{$IFDEF AUTOREFCOUNT}
  FTokenizerStack.Pop;
  FInputSourceStack.Pop;
  FStreamStack.Pop;
{$ELSE !AUTOREFCOUNT}
  TXmlDtdDetailTokenizer(FTokenizerStack.Pop).Free;
  TXmlSimpleInputSource(FInputSourceStack.Pop).Free;
  TUtilsWideStringStream(FStreamStack.Pop).Free;
{$ENDIF AUTOREFCOUNT}
  FPENameStack.Delete(Pred(FPENameStack.Count));
end;

{$IFDEF NEXTGEN}
procedure TXmlDtdDetailPETokenizer.DoResolveParameterEntity(const EntityName: string;
                                                              out EntityValue,
                                                                  PubId,
                                                                  SysId: string;
                                                              out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TXmlDtdDetailPETokenizer.DoResolveParameterEntity(const EntityName: WideString;
                                                              out EntityValue,
                                                                  PubId,
                                                                  SysId: WideString;
                                                              out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
begin
  EntityValue := '';
  PubId := '';
  SysId := '';
  Error := ET_UNDEFINED_PARAMETER_ENTITY;
  if Assigned(FOnResolveParameterEntity) then
    FOnResolveParameterEntity(Self, EntityName, EntityValue, PubId, SysId, Error);
end;

{$IFDEF NEXTGEN}
function TXmlDtdDetailPETokenizer.GetClue: string;
{$ELSE !NEXTGEN}
function TXmlDtdDetailPETokenizer.GetClue: WideString;
{$ENDIF NEXTGEN}
begin
  Result := InternalTokenizer.Clue;
end;

{$IFDEF NEXTGEN}
function TXmlDtdDetailPETokenizer.GetCurrentPEName: string;
{$ELSE !NEXTGEN}
function TXmlDtdDetailPETokenizer.GetCurrentPEName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FPENameStack[Pred(FPENameStack.Count)];
end;

function TXmlDtdDetailPETokenizer.GetEndByteNumber: Int64;
begin
  Result := InternalTokenizer.GetEndByteNumber;
end;

function TXmlDtdDetailPETokenizer.GetEndCharNumber: Int64;
begin
  Result := InternalTokenizer.GetEndCharNumber;
end;

function TXmlDtdDetailPETokenizer.GetEndColumnNumber: Int64;
begin
  Result := InternalTokenizer.GetEndColumnNumber;
end;

function TXmlDtdDetailPETokenizer.GetEndLineNumber: Int64;
begin
  Result := InternalTokenizer.GetEndLineNumber;
end;

function TXmlDtdDetailPETokenizer.GetEndTabsInLine: Int64;
begin
  Result := InternalTokenizer.GetEndTabsInLine;
end;

function TXmlDtdDetailPETokenizer.GetErrorType: TXmlErrorType;
begin
  if FErrorType in ET_WARNINGS
    then Result := InternalTokenizer.ErrorType
    else Result := FErrorType;
  // Remark: FErrorType indicates an error when attempting to resolve a
  //         parameter entity reference.
end;

function TXmlDtdDetailPETokenizer.GetInternalTokenizer: TXmlDtdDetailTokenizer;
begin
  Result := TXmlDtdDetailTokenizer(FTokenizerStack.Peek);
end;

function TXmlDtdDetailPETokenizer.GetIsPERefInDeclSep: Boolean;
begin
  Result := InternalTokenizer.IsPERefInDeclSep;
end;

function TXmlDtdDetailPETokenizer.GetIsProcessingPE: Boolean;
begin
  Result := FTokenizerStack.Count > 1;
end;

function TXmlDtdDetailPETokenizer.GetRelatedDtdObject: TDtdObject;
begin
  Result := InternalTokenizer.GetRelatedDtdObject;
end;

function TXmlDtdDetailPETokenizer.GetRelatedNode: TDomNode;
begin
  Result := InternalTokenizer.GetRelatedNode;
end;

function TXmlDtdDetailPETokenizer.GetStartByteNumber: Int64;
begin
  Result := InternalTokenizer.GetStartByteNumber;
end;

function TXmlDtdDetailPETokenizer.GetStartCharNumber: Int64;
begin
  Result := InternalTokenizer.GetStartCharNumber;
end;

function TXmlDtdDetailPETokenizer.GetStartColumnNumber: Int64;
begin
  Result := InternalTokenizer.GetStartColumnNumber;
end;

function TXmlDtdDetailPETokenizer.GetStartLineNumber: Int64;
begin
  Result := InternalTokenizer.GetStartLineNumber;
end;

function TXmlDtdDetailPETokenizer.GetStartTabsInLine: Int64;
begin
  Result := InternalTokenizer.GetStartTabsInLine;
end;

function TXmlDtdDetailPETokenizer.GetTokenType: TXmlDtdDetailTokenType;
begin
  Result := InternalTokenizer.TokenType;
  if Result = DTD_DETAIL_KEYWORD_TOKEN then
    if IsXmlPEReference(TokenValue) then
      Result := DTD_DETAIL_PARAMETER_ENTITY_REF_TOKEN;
end;

{$IFDEF NEXTGEN}
function TXmlDtdDetailPETokenizer.GetTokenValue: string;
{$ELSE !NEXTGEN}
function TXmlDtdDetailPETokenizer.GetTokenValue: WideString;
{$ENDIF NEXTGEN}
begin
  Result := InternalTokenizer.TokenValue;
end;

{$IFDEF NEXTGEN}
function TXmlDtdDetailPETokenizer.GetUri: string;
{$ELSE !NEXTGEN}
function TXmlDtdDetailPETokenizer.GetUri: WideString;
{$ENDIF NEXTGEN}
begin
  Result := InternalTokenizer.GetUri;
end;

procedure TXmlDtdDetailPETokenizer.Next;
var
{$IFDEF NEXTGEN}
  AbsoluteSystemId: string;
  PEName, PEValue, PEPubId, PESysId: string;
  S: string;
{$ELSE !NEXTGEN}
  AbsoluteSystemId: WideString;
  PEName, PEValue, PEPubId, PESysId: WideString;
  S: WideString;
{$ENDIF NEXTGEN}
  Error: TXmlErrorType;
  LastTokenType: TXmlDtdDetailTokenType;
begin
  LastTokenType := TokenType;
  InternalTokenizer.Next;
  FErrorType := ET_NONE;

  // Parameter entity reference found?
  case TokenType of

    DTD_DETAIL_PARAMETER_ENTITY_REF_TOKEN:
      if IsInMarkup and not (PERefTreatment = petResolve) then begin
        FErrorType := ET_PARAMETER_ENTITY_REF_NOT_ALLOWED;
      end else begin

        // Resolve parameter entity reference:
        PEName := Copy(InternalTokenizer.TokenValue, 2, Length(InternalTokenizer.TokenValue) - 2);
        DoResolveParameterEntity(PEName, PEValue, PEPubId, PESysId, Error);

        if (Error in [ET_EXT_ENTITY_RESOURCE_NOT_FOUND, ET_UNDEFINED_PARAMETER_ENTITY]) and
           (PERefTreatment = petResolveInDeclSepSkipExt) then begin
          FErrorType := ET_NONE;  // Reference to an external parameter entity during wellformedness test.
        end else

        if Error in ET_WARNINGS then begin

          // Calculate absolute system identifier:
{$IFDEF NEXTGEN}
          ResolveRelativeUriStr(GetUri,
{$ELSE NEXTGEN}
          ResolveRelativeUriWideStr(GetUri,
{$ENDIF NEXTGEN}
                                    PESysId,
                                    AbsoluteSystemId);  // Remark: Returns an empty AbsoluteSystemId
                                                        // if resolution attempt fails.

          // Process parameter entity:
          if LastTokenType in [ DTD_DETAIL_PARAMETER_ENTITY_REF_TOKEN, DTD_DETAIL_WHITESPACE_TOKEN ]
{$IFDEF NEXTGEN}
            then S := Concat(PEValue, string(#$0020))  // Remark: Suppress dublicate whitespace to make the evaluation easier.
            else S := Concat(string(#$0020), PEValue, string(#$0020)); // Add byte order mark.
{$ELSE !NEXTGEN}
            then S := Concat(PEValue, WideString(#$0020))  // Remark: Suppress dublicate whitespace to make the evaluation easier.
            else S := Concat(WideString(#$0020), PEValue, WideString(#$0020)); // Add byte order mark.
{$ENDIF NEXTGEN}
          try
            CreateInternalStream(S, PEName, PEPubId, AbsoluteSystemId, not IsInMarkup);
          except
            FErrorType := ET_EXT_PARAMETER_ENTITY_RESOURCE_NOT_FOUND;
          end;

          if ErrorType in ET_WARNINGS then begin  // Remark: ErrorType must be used instead of FErrorType in order to
            Next;                                 //         test whether InternalTokenizer.ErrorType reports an error
          end;                                    //         detected in the previous call of CreateInternalStream.

        end else

          FErrorType := Error;

      end;

    DTD_DETAIL_ATTLIST_DECL_START_TOKEN,
    DTD_DETAIL_ELEMENT_DECL_START_TOKEN,
    DTD_DETAIL_ENTITY_DECL_START_TOKEN,
    DTD_DETAIL_NOTATION_DECL_START_TOKEN:
      FIsInMarkup := True;

    DTD_DETAIL_DECL_END_TOKEN:
      FIsInMarkup := False;

    DTD_DETAIL_END_OF_SOURCE_TOKEN:
      if FTokenizerStack.Count > 1 then begin
        if InternalTokenizer.IsPERefInDeclSep and FIsInMarkup then begin
          // WFC: PE Between Declaration (XML 1.0, § 2.8)
          FErrorType := ET_PE_BETWEEN_DECLARATIONS;
          DestroyInternalTokenizer;
        end else begin
          DestroyInternalTokenizer;
          Next;
        end;
      end;
  end;
end;

procedure TXmlDtdDetailPETokenizer.NextEndOfIgnoredCondSect;
begin
  InternalTokenizer.NextEndOfIgnoredCondSect;
end;

procedure TXmlDtdDetailPETokenizer.SetPERefTreatment(const Value: TXmlPERefTreatment);
begin
  FPERefTreatment := Value;
end;



{ TXmlCustomSubsetTokenizer }

constructor TXmlCustomSubsetTokenizer.Create(const AInputSource: TXmlSimpleInputSource;
                                             const APERepository: TDomPERepository);
begin
  if not Assigned(AInputSource) then
    raise ENot_Supported_Err.Create('Not supported error.');
  if not Assigned(APERepository) then
    raise ENot_Supported_Err.Create('Not supported error.');
  inherited Create;

  FAllowConditionalSections := True;
  FCondSectBracketPEName := TUtilsWideStringList.Create;
  FCondSectBracketPEName.Duplicates := dupAccept;
  FCondSectBracketPEName.Sorted := False;
  FCondSectStartPEName := TUtilsWideStringList.Create;
  FCondSectStartPEName.Duplicates := dupAccept;
  FCondSectStartPEName.Sorted := False;

  FOpeningBracketPEName := TUtilsWideStringList.Create;
  FOpeningBracketPEName.Duplicates := dupAccept;
  FOpeningBracketPEName.Sorted := False;

  FCurrentSignal := nil;

  FPERepository := APERepository;

  FXmlDtdDetailPETokenizer := TXmlDtdDetailPETokenizer.Create(AInputSource, False);
  FXmlDtdDetailPETokenizer.OnResolveParameterEntity := ResolveParameterEntityEventHandler;
  if FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_START_OF_SOURCE_TOKEN
    then FTokenType := DTD_ABSTRACT_START_OF_SOURCE_TOKEN
    else FTokenType := DTD_ABSTRACT_END_OF_SOURCE_TOKEN;
  FErrorType := FXmlDtdDetailPETokenizer.ErrorType;  // Value depents on wellformedness of the XML declaration (if any).
end;

destructor TXmlCustomSubsetTokenizer.Destroy;
begin
  FCurrentSignal.Free;
  FXmlDtdDetailPETokenizer.Free;
  FOpeningBracketPEName.Free;
  FCondSectBracketPEName.Free;
  FCondSectStartPEName.Free;
  inherited;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateCommentSignal(const Data: string): TXmlCommentSignal;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateCommentSignal(const Data: WideString): TXmlCommentSignal;
{$ENDIF NEXTGEN}
begin
  Result := TXmlCommentSignal.CreateFromLocator(nil, Self);
  try
    Result.Data := Data;
  except
    Result.Free;
    raise;
  end;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateElementDeclSignal(const ElementName,
                                                                 Data: string;
                                                           const IsDeclaredInPE: Boolean): TXmlElementTypeDeclarationSignal;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateElementDeclSignal(const ElementName,
                                                                 Data: WideString;
                                                           const IsDeclaredInPE: Boolean): TXmlElementTypeDeclarationSignal;
{$ENDIF NEXTGEN}
begin
  Result := TXmlElementTypeDeclarationSignal.CreateFromLocator(nil, Self);
  try
    Result.ElementName := ElementName;
    Result.Data := Data;
    Result.IsDeclaredInPE := IsDeclaredInPE;
  except
    Result.Free;
    raise;
  end;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateEntityDeclSignal(const EntityName,
                                                                EntityValue,
                                                                PublicId,
                                                                SystemId,
                                                                NotationName,
                                                                BaseUri: string;
                                                          const IsDeclaredInPE: Boolean): TXmlEntityDeclarationSignal;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateEntityDeclSignal(const EntityName,
                                                                EntityValue,
                                                                PublicId,
                                                                SystemId,
                                                                NotationName,
                                                                BaseUri: WideString;
                                                          const IsDeclaredInPE: Boolean): TXmlEntityDeclarationSignal;
{$ENDIF NEXTGEN}
begin
  Result := TXmlEntityDeclarationSignal.CreateFromLocator(nil, Self);
  try
    Result.BaseUri := BaseUri;
    Result.EntityName := EntityName;
    Result.EntityValue := EntityValue;
    Result.PublicId := PublicId;
    Result.SystemId := SystemId;
    Result.NotationName := NotationName;
    Result.IsDeclaredInPE := IsDeclaredInPE;
  except
    Result.Free;
    raise;
  end;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateExtPERefSignal(const ParameterEntityReference: string): TXmlExternalPEReferenceSignal;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateExtPERefSignal(const ParameterEntityReference: WideString): TXmlExternalPEReferenceSignal;
{$ENDIF NEXTGEN}
begin
  Result := TXmlExternalPEReferenceSignal.CreateFromLocator(nil, Self);
  try
    Result.ParameterEntityName := Copy(ParameterEntityReference, 2, Length(ParameterEntityReference) - 2);
  except
    Result.Free;
    raise;
  end;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateParameterEntityDeclSignal(const EntityName,
                                                                         EntityValue,
                                                                         PublicId,
                                                                         SystemId,
                                                                         BaseUri: string): TXmlParameterEntityDeclarationSignal;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateParameterEntityDeclSignal(const EntityName,
                                                                         EntityValue,
                                                                         PublicId,
                                                                         SystemId,
                                                                         BaseUri: WideString): TXmlParameterEntityDeclarationSignal;
{$ENDIF NEXTGEN}
begin
  Result := TXmlParameterEntityDeclarationSignal.CreateFromLocator(nil, Self);
  try
      Result.BaseUri := BaseUri;
      Result.EntityName := EntityName;
      Result.EntityValue := EntityValue;
      Result.PublicId := PublicId;
      Result.SystemId := SystemId;
  except
    Result.Free;
    raise;
  end;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.CreatePISignal(const Target,
                                                        Data: string): TXmlProcessingInstructionSignal;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.CreatePISignal(const Target,
                                                        Data: WideString): TXmlProcessingInstructionSignal;
{$ENDIF NEXTGEN}
begin
  Result := TXmlProcessingInstructionSignal.CreateFromLocator(nil, Self);
  try
    Result.Target := Target;
    Result.Data := Data;
  except
    Result.Free;
    raise;
  end;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateNotationDeclSignal(const NotationName,
                                                                  PubidLiteral,
                                                                  SystemLiteral: string;
                                                            const IsDeclaredInPE: Boolean): TXmlNotationDeclarationSignal;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.CreateNotationDeclSignal(const NotationName,
                                                                  PubidLiteral,
                                                                  SystemLiteral: WideString;
                                                            const IsDeclaredInPE: Boolean): TXmlNotationDeclarationSignal;
{$ENDIF NEXTGEN}
begin
  Result := TXmlNotationDeclarationSignal.CreateFromLocator(nil, Self);
  try
    Result.NotationName := NotationName;
    Result.PublicId := PubidLiteral;
    Result.SystemId := SystemLiteral;
    Result.IsDeclaredInPE := IsDeclaredInPE;
  except
    Result.Free;
    raise;
  end;
end;

procedure TXmlCustomSubsetTokenizer.DoPEReference;
begin
  if Assigned(FOnPEReference) then
    FOnPEReference(Self, Self);
end;

{$IFDEF NEXTGEN}
procedure TXmlCustomSubsetTokenizer.DoProcessingAttListDecl(const ElementType: string);
{$ELSE !NEXTGEN}
procedure TXmlCustomSubsetTokenizer.DoProcessingAttListDecl(const ElementType: WideString);
{$ENDIF NEXTGEN}
begin
  if Assigned(FOnProcessingAttListDecl) then
    FOnProcessingAttListDecl(Self, ElementType, Self);
end;

function TXmlCustomSubsetTokenizer.GetAllowPEsInMarkup: Boolean;
begin
  Result := FXmlDtdDetailPETokenizer.PERefTreatment = petResolve;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.GetClue: string;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.GetClue: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FClue;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.GetEntityDeclBaseUri: string;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.GetEntityDeclBaseUri: WideString;
{$ENDIF NEXTGEN}
begin
  if FTokenType in [ DTD_ABSTRACT_ENTITY_DECL_TOKEN,
                     DTD_ABSTRACT_PARAMETER_ENTITY_DECL_TOKEN ]
    then Result := FEntityDeclBaseUri
    else Result := '';
end;

function TXmlCustomSubsetTokenizer.GetErrorType: TXmlErrorType;
begin
  Result := FErrorType;
end;

function TXmlCustomSubsetTokenizer.GetIsProcessingPE: Boolean;
begin
  Result := FXmlDtdDetailPETokenizer.IsProcessingPE;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.GetSystemId: string;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.GetSystemId: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FXmlDtdDetailPETokenizer.GetUri;
end;

function TXmlCustomSubsetTokenizer.GetTokenType: TXmlDtdAbstractTokenType;
begin
  Result := FTokenType;
end;

procedure TXmlCustomSubsetTokenizer.Next;
const
  DQ: WideChar    = #$0022; // Double Quote ('"')
  SPACE: WideChar = #$0020;
var
  BracketPEMisnested: Boolean;
  ErrorKind: TXmlErrorType;
{$IFDEF NEXTGEN}
  ElementName, EntityName, EntityValue, NotationName, PITarget, PIData: string;
  PEName, PubId, SysId: string;
  S, S1: string;
{$ELSE !NEXTGEN}
  ElementName, EntityName, EntityValue, NotationName, PITarget, PIData: WideString;
  PEName, PubId, SysId: WideString;
  S, S1: WideString;
{$ENDIF NEXTGEN}
  AttrDefs, ElmtCont: TUtilsCustomWideStr;
begin
  FCurrentSignal.Free;
  FCurrentSignal := nil;

  if ProcessPendingAttrDef then
    Exit;

  FXmlDtdDetailPETokenizer.Next;

  if FXmlDtdDetailPETokenizer.ErrorType <> ET_NONE then begin
    FTokenType := DTD_ABSTRACT_INVALID_MARKUP_TOKEN;
    FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
    FClue := FXmlDtdDetailPETokenizer.Clue;
  end else begin
    Assert(FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_INVALID_MARKUP_TOKEN);
    Assert(FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_START_OF_SOURCE_TOKEN);
    FErrorType := ET_NONE;
    FClue := '';

    case FXmlDtdDetailPETokenizer.TokenType of

      DTD_DETAIL_ATTLIST_DECL_START_TOKEN: begin
        // Process attribute list declaration
        // ----------------------------------
        //
        // Attribute list declaration start:
        FTokenType := DTD_ABSTRACT_ATTLIST_DECL_TOKEN;
        FErrorType := ET_INVALID_ATTRIBUTE_DECL;
        PEName := FXmlDtdDetailPETokenizer.CurrentPEName;

        // Whitespace:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then
          Exit;

        // Attribute list declaration name:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_UNQUOTED_STRING_TOKEN then
          Exit;

        FAttDeclElementType := FXmlDtdDetailPETokenizer.TokenValue;

        // Attribute definitions:
        AttrDefs := TUtilsCustomWideStr.Create;
        try
          repeat
            FXmlDtdDetailPETokenizer.Next;
            if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
              FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
              FClue := FXmlDtdDetailPETokenizer.Clue;
              Exit;
            end;
            if FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_DECL_END_TOKEN then begin
              FErrorType := ET_NONE;
              Break;
            end;
            AttrDefs.AddWideString(FXmlDtdDetailPETokenizer.TokenValue);
          until FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_END_OF_SOURCE_TOKEN;
          FPendingAttrDefs := AttrDefs.Value;
        finally
          AttrDefs.Free;
        end;

        // VC: Proper Declaration/PE Nesting (XML 1.0, § 2.8)
        if FXmlDtdDetailPETokenizer.CurrentPEName <> PEName then
          FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_DECL;

        if not IsXmlName(FAttDeclElementType) then
          FErrorType := ET_INVALID_ATTLIST_DECL_NAME;
          // Remark: This test is necessary here, because if no attribute
          //         definitions are encountered no further checks in a
          //         processor pipeline will be carried out.

        if not (FErrorType in ET_FATAL_ERRORS) then begin
          DoProcessingAttListDecl(FAttDeclElementType);
          if not ProcessPendingAttrDef then
            Next;
        end;

      end;

      DTD_DETAIL_COMMENT_TOKEN: begin
        // Process comment:
        FTokenType := DTD_ABSTRACT_COMMENT_TOKEN;
        FCurrentSignal := CreateCommentSignal(FXmlDtdDetailPETokenizer.TokenValue);
        FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
        FClue := FXmlDtdDetailPETokenizer.Clue;
      end;

      DTD_DETAIL_ELEMENT_DECL_START_TOKEN: begin
        // Process element type declaration:
        // ---------------------------------
        //
        // Element type declaration start:
        FTokenType := DTD_ABSTRACT_ELEMENT_DECL_TOKEN;
        FErrorType := ET_INVALID_ELEMENT_DECL;
        PEName := FXmlDtdDetailPETokenizer.CurrentPEName;

        // Whitespace:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then
          Exit;

        // Element type declaration name:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_UNQUOTED_STRING_TOKEN then
          Exit;
        ElementName := FXmlDtdDetailPETokenizer.TokenValue;

        // Whitespace:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then
          Exit;

        // Element content specification:
        FOpeningBracketPEName.Clear;
        BracketPEMisnested := False;
        ElmtCont := TUtilsCustomWideStr.Create;
        try
          repeat
            FXmlDtdDetailPETokenizer.Next;
            if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
              FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
              FClue := FXmlDtdDetailPETokenizer.Clue;
              Exit;
            end;
            case FXmlDtdDetailPETokenizer.TokenType of
              DTD_DETAIL_DECL_END_TOKEN: begin
                FErrorType := ET_NONE;
                Break;
              end;
              DTD_DETAIL_OPERATOR_TOKEN: begin
                if FXmlDtdDetailPETokenizer.TokenValue = '(' then begin
                  FOpeningBracketPEName.Append(FXmlDtdDetailPETokenizer.CurrentPEName);
                end else if FXmlDtdDetailPETokenizer.TokenValue[FirstIndex] = ')' then begin
                  if FOpeningBracketPEName.Count > 0 then begin
                    if FOpeningBracketPEName[Pred(FOpeningBracketPEName.Count)] <> FXmlDtdDetailPETokenizer.CurrentPEName then
                      BracketPEMisnested := True;
                    FOpeningBracketPEName.Delete(Pred(FOpeningBracketPEName.Count));
                  end;
                end;
              end;
            end;
            ElmtCont.AddWideString(FXmlDtdDetailPETokenizer.TokenValue);
          until FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_END_OF_SOURCE_TOKEN;

          // VC: Proper Group/PE Nesting (XML 1.0, §§ 3.2.1 and 3.2.2)
          if BracketPEMisnested then
            FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_PARENTHESIZED_GROUP;

          // VC: Proper Declaration/PE Nesting (XML 1.0, § 2.8)
          if FXmlDtdDetailPETokenizer.CurrentPEName <> PEName then
            FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_DECL;

          if not (FErrorType in ET_FATAL_ERRORS) then
            FCurrentSignal := CreateElementDeclSignal(ElementName, ElmtCont.Value, IsProcessingPE);
        finally
          ElmtCont.Free;
        end;
      end;

      DTD_DETAIL_ENTITY_DECL_START_TOKEN: begin
        // Entity or parameter entity declaration
        // --------------------------------------
        //
        // Entity declaration start:
        FTokenType := DTD_ABSTRACT_ENTITY_DECL_TOKEN;
        FErrorType := ET_INVALID_ENTITY_DECL;
        PEName := FXmlDtdDetailPETokenizer.CurrentPEName;
        FEntityDeclBaseUri := FXmlDtdDetailPETokenizer.GetUri;
          // Remark: Cf. [XML 1.0], sec. 4.2.2:
          // "... relative URIs are relative to the location of the resource
          // within which the entity declaration occurs. This is defined to be
          // the external entity containing the '<' which starts the
          // declaration, at the point when it is parsed as a declaration."

        // Whitespace:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then
          Exit;

        // Entity declaration name or %:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        case FXmlDtdDetailPETokenizer.TokenType of

          DTD_DETAIL_UNQUOTED_STRING_TOKEN: begin
            // Entity declaration:
            EntityName := FXmlDtdDetailPETokenizer.TokenValue;
          end;

          DTD_DETAIL_KEYWORD_TOKEN: begin
            // Parameter entity declaration:

            FTokenType := DTD_ABSTRACT_PARAMETER_ENTITY_DECL_TOKEN;
            FErrorType := ET_INVALID_PARAMETER_ENTITY_DECL;
            if FXmlDtdDetailPETokenizer.TokenValue <> '%' then
              Exit;

            // Whitespace:
            FXmlDtdDetailPETokenizer.Next;
            if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
              FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
              FClue := FXmlDtdDetailPETokenizer.Clue;
              Exit;
            end;
            if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then
              Exit;

            // Parameter entity name:
            FXmlDtdDetailPETokenizer.Next;
            if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
              FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
              FClue := FXmlDtdDetailPETokenizer.Clue;
              Exit;
            end;
            if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_UNQUOTED_STRING_TOKEN then
              Exit;
            EntityName := FXmlDtdDetailPETokenizer.TokenValue;
          end;

        else
          Exit;
        end; {case ...}

        // Whitespace:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then
          Exit;

        // Entity definition:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        case FXmlDtdDetailPETokenizer.TokenType of

          DTD_DETAIL_QUOTED_STRING_TOKEN: begin
            // Internal entity
            // ---------------
            //
            // Entity value:
            S := Copy(FXmlDtdDetailPETokenizer.TokenValue,
                      2,
                      Length(FXmlDtdDetailPETokenizer.TokenValue) - 2); // Remove leading and trailing quotation mark.
            S1 := IncludePERefsInLiteral(S, ErrorKind);
            EntityValue := XmlReplaceQuotes(S1);
            if not (ErrorKind in ET_WARNINGS) then begin
              FErrorType := ErrorKind;
              Exit;
            end;

            // Optional whitespace:
            repeat
              FXmlDtdDetailPETokenizer.Next;
              if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                FClue := FXmlDtdDetailPETokenizer.Clue;
                Exit;
              end;
            until FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN;

            // '>':
            if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_DECL_END_TOKEN then
              Exit;

            FErrorType := ET_NONE;
            if FTokenType = DTD_ABSTRACT_PARAMETER_ENTITY_DECL_TOKEN then begin
              try
                if not PERepository.Add(EntityName, S1) then
                  FErrorType := ET_DOUBLE_PARAMETER_ENTITY_DECL;
              except
                FErrorType := ET_INVALID_PARAMETER_ENTITY_DECL;
                Exit;
              end;
            end;

          end;

          DTD_DETAIL_UNQUOTED_STRING_TOKEN: begin
            // External entity
            // ---------------
            if FXmlDtdDetailPETokenizer.TokenValue = 'SYSTEM' then begin

              // Whitespace:
              FXmlDtdDetailPETokenizer.Next;
              if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                FClue := FXmlDtdDetailPETokenizer.Clue;
                Exit;
              end;
              if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then begin
                FClue := ' ';
                Exit;
              end;

              // System literal:
              FXmlDtdDetailPETokenizer.Next;
              if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                FClue := FXmlDtdDetailPETokenizer.Clue;
                Exit;
              end;
              if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_QUOTED_STRING_TOKEN then
                Exit;
              PubId := '';
              SysId := Copy(FXmlDtdDetailPETokenizer.TokenValue,
                            2,
                            Length(FXmlDtdDetailPETokenizer.TokenValue) - 2); // Remove leading and trailing quotation mark.
              if not IsXmlSystemChars(SysId) then
                Exit;

            end else if FXmlDtdDetailPETokenizer.TokenValue = 'PUBLIC' then begin

              // Whitespace:
              FXmlDtdDetailPETokenizer.Next;
              if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                FClue := FXmlDtdDetailPETokenizer.Clue;
                Exit;
              end;
              if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then begin
                FClue := ' ';
                Exit;
              end;

              // PubId literal:
              FXmlDtdDetailPETokenizer.Next;
              if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                FClue := FXmlDtdDetailPETokenizer.Clue;
                Exit;
              end;
              if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_QUOTED_STRING_TOKEN then
                Exit;
              PubId := Copy(FXmlDtdDetailPETokenizer.TokenValue,
                            2,
                            Length(FXmlDtdDetailPETokenizer.TokenValue) - 2); // Remove leading and trailing quotation mark.
              if not IsXmlPubidChars(PubId) then
                Exit;

              // Whitespace:
              FXmlDtdDetailPETokenizer.Next;
              if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                FClue := FXmlDtdDetailPETokenizer.Clue;
                Exit;
              end;
              if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then begin
                FClue := ' ';
                Exit;
              end;

              // System literal:
              FXmlDtdDetailPETokenizer.Next;
              if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                FClue := FXmlDtdDetailPETokenizer.Clue;
                Exit;
              end;
              if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_QUOTED_STRING_TOKEN then
                Exit;
              SysId := Copy(FXmlDtdDetailPETokenizer.TokenValue,
                            2,
                            Length(FXmlDtdDetailPETokenizer.TokenValue) - 2); // Remove leading and trailing quotation mark.
              if not IsXmlSystemChars(SysId) then
                Exit;

            end else
              Exit;

            if FTokenType = DTD_ABSTRACT_PARAMETER_ENTITY_DECL_TOKEN then begin
              // Parameter entity declaration (end)

              // Optional whitespace:
              repeat
                FXmlDtdDetailPETokenizer.Next;
                if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                  FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                  FClue := FXmlDtdDetailPETokenizer.Clue;
                  Exit;
                end;
              until FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN;

              // '>':
              if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_DECL_END_TOKEN then
                Exit;
              FErrorType := ET_NONE;
              try
                // Issue warning, if system identifier is erroneous (cf. XML 1.0, § 4.2.2)
                //if not IsUriURI_referenceWideStr(SysId) then begin
                if not IsUriURI_referenceStr(SysId) then begin
                  FErrorType := ET_SYSTEM_IDENTIFIER_IS_NOT_URI_REFERENCE;
                  FClue := SysId;
                end else if Pos('#', SysId) > 0 then begin
                  FErrorType := ET_FRAGMENT_IDENTIFIER_IN_SYSTEM_IDENTIFIER;
                  FClue := SysId;
                end;

                PERepository.Add(EntityName, EntityDeclBaseUri, PubId, SysId);
              except
                FErrorType := ET_INVALID_PARAMETER_ENTITY_DECL;
                Exit;
              end;

            end else begin
              // Entity declaration (end)
              FXmlDtdDetailPETokenizer.Next;
              if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                FClue := FXmlDtdDetailPETokenizer.Clue;
                Exit;
              end;
              case FXmlDtdDetailPETokenizer.TokenType of

                DTD_DETAIL_DECL_END_TOKEN: begin
                  // '>':
                  FErrorType := ET_NONE;
                end;

                DTD_DETAIL_WHITESPACE_TOKEN: begin
                  FXmlDtdDetailPETokenizer.Next;
                  if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                    FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                    FClue := FXmlDtdDetailPETokenizer.Clue;
                    Exit;
                  end;
                  case FXmlDtdDetailPETokenizer.TokenType of
                    DTD_DETAIL_DECL_END_TOKEN: begin
                      // '>':
                      FErrorType := ET_NONE;
                    end;
                    DTD_DETAIL_UNQUOTED_STRING_TOKEN: begin
                      // 'NDATA' keyword:
                      if FXmlDtdDetailPETokenizer.TokenValue <> 'NDATA' then
                        Exit;
                      // Whitespace:
                      FXmlDtdDetailPETokenizer.Next;
                      if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                        FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                        FClue := FXmlDtdDetailPETokenizer.Clue;
                        Exit;
                      end;
                      if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then begin
                        FClue := ' ';
                        Exit;
                      end;
                      // Notation name:
                      FXmlDtdDetailPETokenizer.Next;
                      if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                        FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                        FClue := FXmlDtdDetailPETokenizer.Clue;
                        Exit;
                      end;
                      if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_UNQUOTED_STRING_TOKEN then
                        Exit;
                      NotationName := FXmlDtdDetailPETokenizer.TokenValue;
                      if not IsXmlName(NotationName) then
                        Exit;
                      // Optional whitespace:
                      repeat
                        FXmlDtdDetailPETokenizer.Next;
                        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                          FClue := FXmlDtdDetailPETokenizer.Clue;
                          Exit;
                        end;
                      until FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN;
                      // '>':
                      if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_DECL_END_TOKEN then
                        Exit;
                      FErrorType := ET_NONE;
                    end;
                  else
                    Exit;
                  end; {case ...}
                end;

              else
                Exit;
              end; {case ...}

            end; {if TokenType = DTD_ABSTRACT_PARAMETER_ENTITY_DECL_TOKEN ... else ...}
          end; {DTD_DETAIL_UNQUOTED_STRING_TOKEN ...}

        else
          Exit;
        end; {case FXmlDtdDetailPETokenizer.TokenType ...}

        // VC: Proper Declaration/PE Nesting (XML 1.0, § 2.8)
        if FXmlDtdDetailPETokenizer.CurrentPEName <> PEName then
          FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_DECL;

        if FTokenType = DTD_ABSTRACT_PARAMETER_ENTITY_DECL_TOKEN then begin
          if not (FErrorType in ET_FATAL_ERRORS) then
            FCurrentSignal := CreateParameterEntityDeclSignal(EntityName,
                                EntityValue, PubId, SysId, EntityDeclBaseUri);
        end else
        if FTokenType = DTD_ABSTRACT_ENTITY_DECL_TOKEN then begin
          if not (FErrorType in ET_FATAL_ERRORS) then
            FCurrentSignal := CreateEntityDeclSignal(EntityName,
                                EntityValue, PubId, SysId, NotationName, EntityDeclBaseUri, IsProcessingPE);
        end;
      end; {DTD_DETAIL_ENTITY_DECL_START_TOKEN ...}

      DTD_DETAIL_NOTATION_DECL_START_TOKEN: begin
        // Process notation declaration:
        // ---------------------------------
        //
        // Notation declaration start:
        FTokenType := DTD_ABSTRACT_NOTATION_DECL_TOKEN;
        FErrorType := ET_INVALID_NOTATION_DECL;
        PEName := FXmlDtdDetailPETokenizer.CurrentPEName;

        // Whitespace:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then
          Exit;

        // Notation declaration name:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_UNQUOTED_STRING_TOKEN then
          Exit;
        NotationName := FXmlDtdDetailPETokenizer.TokenValue;

        // Whitespace:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then
          Exit;

        // 'SYSTEM' or 'PUBLIC' keyword:
        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_UNQUOTED_STRING_TOKEN then
          Exit;
        if FXmlDtdDetailPETokenizer.TokenValue = 'SYSTEM' then begin

          // Whitespace:
          FXmlDtdDetailPETokenizer.Next;
          if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
            FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
            FClue := FXmlDtdDetailPETokenizer.Clue;
            Exit;
          end;
          if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then begin
            FClue := ' ';
            Exit;
          end;

          // System literal:
          FXmlDtdDetailPETokenizer.Next;
          if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
            FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
            FClue := FXmlDtdDetailPETokenizer.Clue;
            Exit;
          end;
          if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_QUOTED_STRING_TOKEN then
            Exit;
          PubId := '';
          SysId := Copy(FXmlDtdDetailPETokenizer.TokenValue,
                        2,
                        Length(FXmlDtdDetailPETokenizer.TokenValue) - 2); // Remove leading and trailing quotation mark.
          if not IsXmlSystemChars(SysId) then
            Exit;

          // Optional whitespace:
          repeat
            FXmlDtdDetailPETokenizer.Next;
            if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
              FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
              FClue := FXmlDtdDetailPETokenizer.Clue;
              Exit;
            end;
          until FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN;

          // '>':
          if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_DECL_END_TOKEN then
            Exit;

          FErrorType := ET_NONE;

        end else if FXmlDtdDetailPETokenizer.TokenValue = 'PUBLIC' then begin

          // Whitespace:
          FXmlDtdDetailPETokenizer.Next;
          if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
            FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
            FClue := FXmlDtdDetailPETokenizer.Clue;
            Exit;
          end;
          if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN then begin
            FClue := ' ';
            Exit;
          end;

          // PubId literal:
          FXmlDtdDetailPETokenizer.Next;
          if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
            FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
            FClue := FXmlDtdDetailPETokenizer.Clue;
            Exit;
          end;
          if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_QUOTED_STRING_TOKEN then
            Exit;
          PubId := Copy(FXmlDtdDetailPETokenizer.TokenValue,
                        2,
                        Length(FXmlDtdDetailPETokenizer.TokenValue) - 2); // Remove leading and trailing quotation mark.
          if not IsXmlPubidChars(PubId) then
            Exit;

          // Whitespace (?):
          FXmlDtdDetailPETokenizer.Next;
          if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
            FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
            FClue := FXmlDtdDetailPETokenizer.Clue;
            Exit;
          end;
          if FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_WHITESPACE_TOKEN then begin

            FXmlDtdDetailPETokenizer.Next;
            if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
              FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
              FClue := FXmlDtdDetailPETokenizer.Clue;
              Exit;
            end;

            // '>':
            if FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_DECL_END_TOKEN then begin
              SysId := '';
              FErrorType := ET_NONE;
            end else
            // System literal:
            if FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_QUOTED_STRING_TOKEN then begin

              SysId := Copy(FXmlDtdDetailPETokenizer.TokenValue,
                            2,
                            Length(FXmlDtdDetailPETokenizer.TokenValue) - 2); // Remove leading and trailing quotation mark.
              if not IsXmlSystemChars(SysId) then
                Exit;

              // Optional whitespace:
              repeat
                FXmlDtdDetailPETokenizer.Next;
                if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
                  FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
                  FClue := FXmlDtdDetailPETokenizer.Clue;
                  Exit;
                end;
              until FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN;

              // '>':
              if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_DECL_END_TOKEN then
                Exit;

              FErrorType := ET_NONE;

            end else
              Exit;

          end else
          // '>':
          if FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_DECL_END_TOKEN then begin
            SysId := '';
            FErrorType := ET_NONE;
          end else
            Exit;

        end else
          Exit;

        // VC: Proper Declaration/PE Nesting (XML 1.0, § 2.8)
        if FXmlDtdDetailPETokenizer.CurrentPEName <> PEName then
          FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_DECL;

        // Issue warning, if system identifier is erroneous (cf. XML 1.0, § 4.2.2)
        //if not IsUriURI_referenceWideStr(SysId) then begin
        if not IsUriURI_referenceStr(SysId) then begin
          FErrorType := ET_SYSTEM_IDENTIFIER_IS_NOT_URI_REFERENCE;
          FClue := SysId;
        end else if Pos('#', SysId) > 0 then begin
          FErrorType := ET_FRAGMENT_IDENTIFIER_IN_SYSTEM_IDENTIFIER;
          FClue := SysId;
        end;

        if not (FErrorType in ET_FATAL_ERRORS) then
          FCurrentSignal := CreateNotationDeclSignal(NotationName, PubId, SysId, IsProcessingPE);
      end;

      DTD_DETAIL_PI_TARGET_TOKEN: begin
        // Process processing instructions:
        FTokenType := DTD_ABSTRACT_PI_TOKEN;
        PITarget := FXmlDtdDetailPETokenizer.TokenValue;

        FXmlDtdDetailPETokenizer.Next;
        if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
          FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
          FClue := FXmlDtdDetailPETokenizer.Clue;
          Exit;
        end;
        case FXmlDtdDetailPETokenizer.TokenType of

          // Whitespace:
          DTD_DETAIL_WHITESPACE_TOKEN: begin
            // PI content:
            FXmlDtdDetailPETokenizer.Next;
            if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
              FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
              FClue := FXmlDtdDetailPETokenizer.Clue;
              Exit;
            end;
            if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_PI_CONTENT_TOKEN then begin
              FErrorType := ET_UNCLOSED_PROCESSING_INSTRUCTION;
              FClue := '?>';
              Exit;
            end;
            PIData := FXmlDtdDetailPETokenizer.TokenValue;

          end;

          // PI without content:
          DTD_DETAIL_PI_CONTENT_TOKEN:
            if FXmlDtdDetailPETokenizer.TokenValue <> '' then begin
              FErrorType := ET_MISSING_WHITE_SPACE;
              FClue := ' ';
              Exit;
            end else
              PIData := '';

        else
          FErrorType := ET_UNCLOSED_PROCESSING_INSTRUCTION;
          FClue := '?>';
          Exit;
        end; {case ...}

        FCurrentSignal := CreatePISignal(PITarget, PIData);
      end;

      DTD_DETAIL_WHITESPACE_TOKEN: begin
        FTokenType := DTD_ABSTRACT_IGNORABLE_WHITESPACE_TOKEN;
      end;

      DTD_DETAIL_COND_SECT_START_TOKEN: begin

        if not (IsProcessingPE or FAllowConditionalSections) then begin
          FErrorType := ET_CONDITIONAL_SECTION_NOT_ALLOWED;
          Exit;
        end;

        FCondSectStartPEName.Append(FXmlDtdDetailPETokenizer.CurrentPEName);

        // Optional whitespace:
        repeat
          FXmlDtdDetailPETokenizer.Next;
          if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
            FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
            FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
            FClue := FXmlDtdDetailPETokenizer.Clue;
            Exit;
          end;
        until FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN;

        // 'INCLUDE' or 'IGNORE' keyword:
        S := FXmlDtdDetailPETokenizer.TokenValue;
        if (FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_UNQUOTED_STRING_TOKEN) or
           ( (S <> 'IGNORE') and (S <> 'INCLUDE') ) then
        begin
          FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
          FTokenType := DTD_ABSTRACT_CONDITIONAL_SECTION_TOKEN;
          FErrorType := ET_INVALID_CONDITIONAL_SECTION;
          Exit;
        end;

        // Optional whitespace:
        repeat
          FXmlDtdDetailPETokenizer.Next;
          if FXmlDtdDetailPETokenizer.ErrorType in ET_FATAL_ERRORS then begin
            FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
            FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
            FClue := FXmlDtdDetailPETokenizer.Clue;
            Exit;
          end;
        until FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_WHITESPACE_TOKEN;

        // '[':
        if FXmlDtdDetailPETokenizer.TokenType <> DTD_DETAIL_COND_SECT_OPENER_TOKEN then begin
          FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
          FTokenType := DTD_ABSTRACT_CONDITIONAL_SECTION_TOKEN;
          FErrorType := ET_INVALID_CONDITIONAL_SECTION;
          FClue := '[';
          Exit;
        end;

        FCondSectBracketPEName.Append(FXmlDtdDetailPETokenizer.CurrentPEName);

        if S = 'INCLUDE' then begin
          Next;
        end else begin
          FXmlDtdDetailPETokenizer.NextEndOfIgnoredCondSect;
          if FXmlDtdDetailPETokenizer.ErrorType <> ET_NONE then begin
            FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
            FCondSectBracketPEName.Delete(Pred(FCondSectBracketPEName.Count));
            FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
            FClue := FXmlDtdDetailPETokenizer.Clue;
            FTokenType := DTD_ABSTRACT_INVALID_MARKUP_TOKEN;
          end else if FXmlDtdDetailPETokenizer.TokenType = DTD_DETAIL_COND_SECT_END_TOKEN then begin
            if FCondSectStartPEName[Pred(FCondSectStartPEName.Count)] <> FCondSectBracketPEName[Pred(FCondSectBracketPEName.Count)] then begin
              FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
              FCondSectBracketPEName.Delete(Pred(FCondSectBracketPEName.Count));
              FTokenType := DTD_ABSTRACT_CONDITIONAL_SECTION_TOKEN;
              FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_CONDITIONAL_SECTION;
              FClue := '[';
              Exit;
            end;
            if FCondSectStartPEName[Pred(FCondSectStartPEName.Count)] <> FXmlDtdDetailPETokenizer.CurrentPEName then begin
              FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
              FCondSectBracketPEName.Delete(Pred(FCondSectBracketPEName.Count));
              FTokenType := DTD_ABSTRACT_CONDITIONAL_SECTION_TOKEN;
              FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_CONDITIONAL_SECTION;
              FClue := ']]>';
              Exit;
            end;
            FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
            FCondSectBracketPEName.Delete(Pred(FCondSectBracketPEName.Count));
            Next;
          end else begin
            FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
            FCondSectBracketPEName.Delete(Pred(FCondSectBracketPEName.Count));
            FErrorType := ET_INVALID_CONDITIONAL_SECTION;
          end;
        end;
      end;

      DTD_DETAIL_COND_SECT_END_TOKEN: begin
        if FCondSectStartPEName.Count = 0 then begin
          // End of conditional section without start
          FTokenType := DTD_ABSTRACT_CONDITIONAL_SECTION_TOKEN;
          FErrorType := ET_INVALID_CONDITIONAL_SECTION;
        end else begin
          if FCondSectStartPEName[Pred(FCondSectStartPEName.Count)] <> FCondSectBracketPEName[Pred(FCondSectBracketPEName.Count)] then begin
            FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
            FCondSectBracketPEName.Delete(Pred(FCondSectBracketPEName.Count));
            FTokenType := DTD_ABSTRACT_CONDITIONAL_SECTION_TOKEN;
            FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_CONDITIONAL_SECTION;
            FClue := '[';
            Exit;
          end;
          if FCondSectStartPEName[Pred(FCondSectStartPEName.Count)] <> FXmlDtdDetailPETokenizer.CurrentPEName then begin
            FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
            FCondSectBracketPEName.Delete(Pred(FCondSectBracketPEName.Count));
            FTokenType := DTD_ABSTRACT_CONDITIONAL_SECTION_TOKEN;
            FErrorType := ET_PE_NOT_PROPERLY_NESTED_WITH_CONDITIONAL_SECTION;
            FClue := ']]>';
            Exit;
          end;
          FCondSectStartPEName.Delete(Pred(FCondSectStartPEName.Count));
          FCondSectBracketPEName.Delete(Pred(FCondSectBracketPEName.Count));
          Next;
        end;
      end;

      DTD_DETAIL_END_OF_SOURCE_TOKEN: begin
        FTokenType := DTD_ABSTRACT_END_OF_SOURCE_TOKEN;
        if FCondSectStartPEName.Count <> 0 then begin
          FErrorType := ET_UNCLOSED_CONDITIONAL_SECTION;
          FClue := ']]>';
        end;
      end;

      DTD_DETAIL_PARAMETER_ENTITY_REF_TOKEN: begin
        // Process reference to an external parameter entity (which has not been resolved):
        FTokenType := DTD_ABSTRACT_EXT_PARAMETER_ENTITY_REF_TOKEN;
        FCurrentSignal := CreateExtPERefSignal(FXmlDtdDetailPETokenizer.TokenValue);
        FErrorType := FXmlDtdDetailPETokenizer.ErrorType;
        FClue := FXmlDtdDetailPETokenizer.Clue;
      end;

      DTD_DETAIL_COND_SECT_OPENER_TOKEN,
      DTD_DETAIL_DECL_END_TOKEN,
      DTD_DETAIL_KEYWORD_TOKEN,
      DTD_DETAIL_OPERATOR_TOKEN,
      DTD_DETAIL_PI_CONTENT_TOKEN,
      DTD_DETAIL_QUOTED_STRING_TOKEN,
      DTD_DETAIL_UNQUOTED_STRING_TOKEN: begin
        FTokenType := DTD_ABSTRACT_INVALID_MARKUP_TOKEN;
        FErrorType := ET_INVALID_MARKUP_DECL;
      end;

    end; {case ...}
  end;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.FindNextAttDef(    Decl: string;
                                                  out AttType: TXmlDataType;
                                                  out Constraint: TDomAttrValueConstraint;
                                                  out AttName,
                                                      Enumeration,
                                                      DefaultValue,
                                                      Rest: string): Boolean;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.FindNextAttDef(    Decl: WideString;
                                                  out AttType: TXmlDataType;
                                                  out Constraint: TDomAttrValueConstraint;
                                                  out AttName,
                                                      Enumeration,
                                                      DefaultValue,
                                                      Rest: WideString): Boolean;
{$ENDIF NEXTGEN}
// Return value: 'False' if a wellformedness error occured; 'True' otherwise.

{$IFDEF NEXTGEN}
  function StrToDataType(const S: string;
                           out DataType: TXmlDataType): Boolean;
{$ELSE !NEXTGEN}
  function StrToDataType(const S: WideString;
                           out DataType: TXmlDataType): Boolean;
{$ENDIF NEXTGEN}
  begin
    if S = '' then begin
      DataType := AS_NMTOKEN_DATATYPE;
      Result := True;
    end else if S = 'CDATA' then begin
      DataType := AS_STRING_DATATYPE;
      Result := True;
    end else if S = 'ID' then begin
      DataType := AS_ID_DATATYPE;
      Result := True;
    end else if S = 'IDREF' then begin
      DataType := AS_IDREF_DATATYPE;
      Result := True;
    end else if S = 'IDREFS' then begin
      DataType := AS_IDREFS_DATATYPE;
      Result := True;
    end else if S = 'ENTITY' then begin
      DataType := AS_ENTITY_DATATYPE;
      Result := True;
    end else if S = 'ENTITIES' then begin
      DataType := AS_ENTITIES_DATATYPE;
      Result := True;
    end else if S = 'NMTOKEN' then begin
      DataType := AS_NMTOKEN_DATATYPE;
      Result := True;
    end else if S = 'NMTOKENS' then begin
      DataType := AS_NMTOKENS_DATATYPE;
      Result := True;
    end else if S = 'NOTATION' then begin
      DataType := AS_NOTATION_DATATYPE;
      Result := True;
    end else
      Result := False;
  end;

{$IFDEF NEXTGEN}
  function StrToConstaintType(const S: string;
                                var AVC: TDomAttrValueConstraint): Boolean;
{$ELSE !NEXTGEN}
  function StrToConstaintType(const S: WideString;
                                var AVC: TDomAttrValueConstraint): Boolean;
{$ENDIF NEXTGEN}
  begin
    if S = '#REQUIRED' then begin
      AVC := AVC_REQUIRED;
      Result := True;
    end else if S = '#IMPLIED' then begin
      AVC := AVC_IMPLIED;
      Result := True;
    end else if S = '#FIXED' then begin
      AVC := AVC_FIXED;
      Result := True;
    end else
      Result := False;
  end;


var
  I, J: Integer;
  FindEnumeration, FindConstraint, FindDefaultValue: Boolean;
  QuoteType: WideChar;
{$IFDEF NEXTGEN}
  S: string;
{$ELSE !NEXTGEN}
  S: WideString;
{$ENDIF NEXTGEN}
begin
  Result := True;

  S := '';
  DefaultValue := '';
  Enumeration := '';
  FindDefaultValue := False;
  FindEnumeration := False;
  FindConstraint := False;
  Constraint := AVC_DEFAULT;
  AttName := '';
  Rest := '';

  if Length(Decl) = 0
    then begin Result := False; Exit; end;
  I := FirstIndex;

  {White-space?}
  while IsXmlWhiteSpace(Decl[I]) do begin
    Inc(I);
    if I > Length(Decl) - AdjustIndex
      then begin Result := False; Exit; end;
  end;
  J := I;

  {AttName?}
  while not IsXmlWhiteSpace(Decl[I]) do begin
    Inc(I);
    if I > Length(Decl) - AdjustIndex
      then begin Result := False; Exit; end;
  end;
  AttName := Copy(Decl, J + AdjustIndex, I - J);

  {White-space?}
  while IsXmlWhiteSpace(Decl[I]) do begin
    Inc(I);
    if I > Length(Decl) - AdjustIndex
      then begin Result := False; Exit; end;
  end;
  J := I;

  if Decl[J] = '(' then FindEnumeration:= True;

  {AttType?}
  if FindEnumeration then begin
    AttType := AS_NMTOKEN_DATATYPE;
  end else begin
    while not IsXmlWhiteSpace(Decl[I]) do begin
      Inc(I);
      if I > Length(Decl) - AdjustIndex
        then begin Result := False; Exit; end;
    end;
    if not StrToDataType(Copy(Decl, J + AdjustIndex, I - J), AttType)
      then begin Result := False; Exit; end;
    if AttType = AS_NOTATION_DATATYPE then
      FindEnumeration := True;

    {White-space?}
    while IsXmlWhiteSpace(Decl[I]) do begin
      Inc(I);
      if I > Length(Decl) - AdjustIndex
        then begin Result := False; Exit; end;
    end;
    J := I;
  end; {if ...}

  {Bracket?}
  if FindEnumeration then begin
    if Decl[J] <> '('
      then begin Result := False; Exit; end;
    while not (Decl[I] = ')') do begin
      Inc(I);
      if I >= Length(Decl)-AdjustIndex
        then begin Result := False; Exit; end;
    end;
    Enumeration := Copy(Decl, J + AdjustIndex, I - J + 1);

    {White-space?}
    Inc(I);
    if not IsXmlWhiteSpace(Decl[I])
      then begin Result := False; Exit; end;
    while IsXmlWhiteSpace(Decl[I]) do begin
      Inc(I);
      if I > Length(Decl) - AdjustIndex
        then begin Result := False; Exit; end;
    end;
    J := I;
  end; {if ...}

  if Decl[J] = '#'
    then FindConstraint := True
    else FindDefaultValue := True;

  {Constraint?}
  if FindConstraint then begin
    while not IsXmlWhiteSpace(Decl[I]) do begin
      Inc(I);
      if I > Length(Decl) - AdjustIndex then Break;
    end; {while ...}
    if not  StrToConstaintType(Copy(Decl, J + AdjustIndex, I - J), Constraint)
      then begin Result := False; Exit; end;
    if Constraint = AVC_FIXED then begin
      FindDefaultValue := True;
      {White-space?}
      if I > Length(Decl) - AdjustIndex
        then begin Result := False; Exit; end;
      while IsXmlWhiteSpace(Decl[I]) do begin
        Inc(I);
        if I > Length(Decl) - AdjustIndex
          then begin Result := False; Exit; end;
      end; {while ...}
      J := I;
    end; {if ...}
  end; {if ...}

  {DefaultValue?}
  if FindDefaultValue then begin
    if I = Length(Decl) - AdjustIndex
      then begin Result := False; Exit; end;
    QuoteType := Decl[I];
    if not ( (QuoteType = '"') or (QuoteType = #$0027))
      then begin Result := False; Exit; end;
    Inc(I);
    while not (Decl[I] = QuoteType) do begin
      Inc(I);
      if I > Length(Decl) - AdjustIndex
        then begin Result := False; Exit; end;
    end; {while ...}
    DefaultValue := Copy(Decl, J + 1 + AdjustIndex, I - J - 1);
    Inc(I);
  end; {if ...}

  Rest:= Copy(Decl, I + AdjustIndex, Length(Decl) - I + 1);
end;

function TXmlCustomSubsetTokenizer.GetEndByteNumber: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetEndByteNumber;
end;

function TXmlCustomSubsetTokenizer.GetEndCharNumber: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetEndCharNumber;
end;

function TXmlCustomSubsetTokenizer.GetEndColumnNumber: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetEndColumnNumber;
end;

function TXmlCustomSubsetTokenizer.GetEndLineNumber: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetEndLineNumber;
end;

function TXmlCustomSubsetTokenizer.GetEndTabsInLine: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetEndTabsInLine;
end;

function TXmlCustomSubsetTokenizer.GetRelatedDtdObject: TDtdObject;
begin
  Result := FXmlDtdDetailPETokenizer.GetRelatedDtdObject;
end;

function TXmlCustomSubsetTokenizer.GetRelatedNode: TDomNode;
begin
  Result := FXmlDtdDetailPETokenizer.GetRelatedNode;
end;

function TXmlCustomSubsetTokenizer.GetStartByteNumber: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetStartByteNumber;
end;

function TXmlCustomSubsetTokenizer.GetStartCharNumber: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetStartCharNumber;
end;

function TXmlCustomSubsetTokenizer.GetStartColumnNumber: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetStartColumnNumber;
end;

function TXmlCustomSubsetTokenizer.GetStartLineNumber: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetStartLineNumber;
end;

function TXmlCustomSubsetTokenizer.GetStartTabsInLine: Int64;
begin
  Result := FXmlDtdDetailPETokenizer.GetStartTabsInLine;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.GetUri: string;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.GetUri: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FXmlDtdDetailPETokenizer.GetUri;
end;

{$IFDEF NEXTGEN}
function TXmlCustomSubsetTokenizer.IncludePERefsInLiteral(const S: string;
                                                           out ErrType: TXmlErrorType): string;
{$ELSE !NEXTGEN}
function TXmlCustomSubsetTokenizer.IncludePERefsInLiteral(const S: WideString;
                                                           out ErrType: TXmlErrorType): WideString;
{$ENDIF NEXTGEN}
const
  NULL:      WideChar = #$00; // End of WideString mark
  PERCENT:   WideChar = #$25; // '%'
  SEMICOLON: WideChar = #$3B; // ';'
  PERCENT_CODE = $25; // code of %
var
  C: WideChar;
  I, L: Integer;
  ResultStr: TUtilsCustomWideStr;
  PEStr: TUtilsCustomWideStr;
{$IFDEF NEXTGEN}
  PEValue, PEPubId, PESysId: string;
{$ELSE !NEXTGEN}
  PEValue, PEPubId, PESysId: WideString;
{$ENDIF NEXTGEN}
begin
  ErrType := ET_NONE;
  ResultStr := TUtilsCustomWideStr.Create;
  try
    L := Length(S);
    I := 0;
    while I < L do begin
      Inc(I);
      C := S[I-AdjustIndex];
      if (C = PERCENT) and (I < L - 1) then begin
        Inc(I);
        C := S[I-AdjustIndex];
        if IsXmlNameStartChar(C) then begin
          PEStr := TUtilsCustomWideStr.Create;
          try
            PEStr.AddWideChar(C);
            Inc(I);
            C := S[I-AdjustIndex];
            while IsXmlNameChar(C) do begin
              PEStr.AddWideChar(C);
              Inc(I);
              if I > L then Break;
              C := S[I-AdjustIndex];
            end;
            if C = SEMICOLON then begin
              // PE found:
              if AllowPEsInMarkup or IsProcessingPE then begin
                // Include as PE:
                ErrType := PERepository.ResolvePE(PEStr.Value, True, PEValue, PEPubId, PESysId);
                ResultStr.AddWideString(PEValue);
              end else
                ErrType := ET_PARAMETER_ENTITY_REF_NOT_ALLOWED;
              if ErrType <> ET_NONE then begin
                Result := S;
                Exit;
              end;
            end else begin
              ResultStr.AddUCS4Char(PERCENT_CODE);
              ResultStr.AddWideString(PEStr.Value);
              Dec(I);
            end;
          finally
            PEStr.Free;
          end;
        end else begin
          ResultStr.AddUCS4Char(PERCENT_CODE);
          Dec(I);
        end;
      end else
        ResultStr.AddWideChar(C);
    end; {while ...}
    Result := ResultStr.Value;
  finally
    ResultStr.Free;
  end;
end;

function TXmlCustomSubsetTokenizer.ProcessPendingAttrDef: Boolean;
// If an attribute list declaration had been encountered its attribute
// definitions typically cannot be processed in one turn.  Thus, the pending
// attribute definitions are stored in the backup FPendingAttrDefs WideString
// variable and gradually processed whenever Next is called.
//
// This function returns True, if a pending attribute definition had been
// processed (successfully or not). Otherwise False is returned.
var
{$IFDEF NEXTGEN}
  Dummy, Piece: string;
{$ELSE !NEXTGEN}
  Dummy, Piece: WideString;
{$ENDIF NEXTGEN}
  Separator: Integer;
  Error, Ok: Boolean;
  AttType: TXmlDataType;
  Constraint: TDomAttrValueConstraint;
{$IFDEF NEXTGEN}
  AttDefName, Enum1, Enum2, DefaultValue, Rest: string;
{$ELSE !NEXTGEN}
  AttDefName, Enum1, Enum2, DefaultValue, Rest: WideString;
{$ENDIF NEXTGEN}
begin
  Dummy := TrimWhitespace(FPendingAttrDefs);
  FPendingAttrDefs := Dummy;

  if FPendingAttrDefs <> '' then begin
    Result := True;
    Ok := FindNextAttDef(FPendingAttrDefs, AttType, Constraint, AttDefName, Enum1, DefaultValue, Rest);
    FPendingAttrDefs := Rest;

    if not Ok then begin
      FErrorType := ET_INVALID_ATTRIBUTE_DECL;
      Exit;
    end;

    FCurrentSignal := TXmlAttributeDefinitionSignal.CreateFromLocator(nil, Self);
    try
      (FCurrentSignal as TXmlAttributeDefinitionSignal).AttributeName := AttDefName;
      (FCurrentSignal as TXmlAttributeDefinitionSignal).AttributeType := AttType;
      (FCurrentSignal as TXmlAttributeDefinitionSignal).Constraint := Constraint;
      (FCurrentSignal as TXmlAttributeDefinitionSignal).DefaultValue := DefaultValue;
      (FCurrentSignal as TXmlAttributeDefinitionSignal).ElementName := FAttDeclElementType;
      (FCurrentSignal as TXmlAttributeDefinitionSignal).IsDeclaredInPE := IsProcessingPE;

      // Process enumeration of attributes:
      if Enum1 <> '' then begin
        XMLTruncRoundBrackets(Enum1, Enum2, Error);
        if Error or (Enum2 = '') then begin
          FErrorType := ET_INVALID_ATTRIBUTE_DECL;
          Exit;
        end;
        while Enum2 <> '' do begin
{$IFDEF NEXTGEN}
          Separator := Pos(string('|'), Enum2);
{$ELSE !NEXTGEN}
          Separator := Pos(WideString('|'), Enum2);
{$ENDIF NEXTGEN}
          if Separator = 0 then begin
            Piece := Enum2;
            Enum2 := '';
          end else begin
            Piece := TrimWhitespace(Copy(Enum2, 1, Separator - 1));
            Dummy := TrimWhitespace(Copy(Enum2, Separator + 1, Length(Enum2) - Separator));
            Enum2 := Dummy;
            if Enum2 = '' then begin
              FErrorType := ET_INVALID_ATTRIBUTE_DECL;
              Exit;
            end;
          end;
          (FCurrentSignal as TXmlAttributeDefinitionSignal).Enumeration.Add(Piece);
        end; {while ...}
      end;

    except
      FCurrentSignal.Free;
      FCurrentSignal := nil;
      raise;
    end;

  end else
    Result := False;
end;



{ TXmlExtSubsetTokenizer }

constructor TXmlExtSubsetTokenizer.Create(const AInputSource: TXmlInputSource;
                                          const APERepository: TDomPERepository);
begin
  inherited Create(AInputSource, APERepository);

  FXmlDtdDetailPETokenizer.PERefTreatment := petResolve;

  if AInputSource.HasMalformedDecl
     or not ( AInputSource.DeclType in [ DT_TEXT_DECLARATION,
                                         DT_XML_OR_TEXT_DECLARATION,
                                         DT_UNSPECIFIED ] )
  then begin
    FTokenType := DTD_ABSTRACT_END_OF_SOURCE_TOKEN;
    FErrorType := ET_INVALID_TEXT_DECL;
  end else if not IsSupportedXmlVersion(AInputSource.XmlVersion) then begin
    FTokenType := DTD_ABSTRACT_END_OF_SOURCE_TOKEN;
    FErrorType := ET_XML_VERSION_NOT_SUPPORTED;
  end else begin
    FTokenType := DTD_ABSTRACT_START_OF_SOURCE_TOKEN;
    FErrorType := ET_NONE;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlExtSubsetTokenizer.ResolveParameterEntityEventHandler(      Sender: TObject;
                                                                    const EntityName: string;
                                                                      var EntityValue,
                                                                          PubId,
                                                                          SysId: string;
                                                                      var Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TXmlExtSubsetTokenizer.ResolveParameterEntityEventHandler(      Sender: TObject;
                                                                    const EntityName: WideString;
                                                                      var EntityValue,
                                                                          PubId,
                                                                          SysId: WideString;
                                                                      var Error: TXmlErrorType);
{$ENDIF NEXTGEN}
begin
  DoPEReference;
  Error := PERepository.ResolvePE(EntityName, True, EntityValue, PubId, SysId);
end;



{ TXmlIntSubsetTokenizer }

constructor TXmlIntSubsetTokenizer.Create(const AInputSource: TXmlSimpleInputSource;
                                          const APERepository: TDomPERepository);
begin
  inherited Create(AInputSource, APERepository);
  FAllowConditionalSections := False;
  FXmlDtdDetailPETokenizer.PERefTreatment := petResolveInDeclSep;
end;

function TXmlIntSubsetTokenizer.GetResolveExtPEs: Boolean;
begin
  Result := FXmlDtdDetailPETokenizer.PERefTreatment <> petResolveInDeclSepSkipExt;
end;

{$IFDEF NEXTGEN}
procedure TXmlIntSubsetTokenizer.ResolveParameterEntityEventHandler(      Sender: TObject;
                                                                    const EntityName: string;
                                                                      var EntityValue,
                                                                          PubId,
                                                                          SysId: string;
                                                                      var Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TXmlIntSubsetTokenizer.ResolveParameterEntityEventHandler(      Sender: TObject;
                                                                    const EntityName: WideString;
                                                                      var EntityValue,
                                                                          PubId,
                                                                          SysId: WideString;
                                                                      var Error: TXmlErrorType);
{$ENDIF NEXTGEN}
begin
  DoPEReference;
  Error := PERepository.ResolvePE(EntityName, ResolveExtPEs, EntityValue, PubId, SysId);
end;


procedure TXmlIntSubsetTokenizer.SetResolveExtPEs(const Value: Boolean);
begin
  if Value
    then FXmlDtdDetailPETokenizer.PERefTreatment := petResolveInDeclSep
    else FXmlDtdDetailPETokenizer.PERefTreatment := petResolveInDeclSepSkipExt;
end;



{ TXmlElementCMTokenizer }

{$IFDEF NEXTGEN}
constructor TXmlElementCMTokenizer.Create(const S: string);
{$ELSE !NEXTGEN}
constructor TXmlElementCMTokenizer.Create(const S: WideString);
{$ENDIF NEXTGEN}
begin
  inherited Create;
  FBracketFound := False;
  FUCS4Reader := nil;   // Remark: If an exception occurs, the destructor is automatically called.
  FStringStream := nil; //         Therefore, we need to initialize critical objects with nil first.
  FTokenValue := TUtilsCustomWideStr.Create;
  FStringStream := TUtilsWideStringStream.Create(S);
  FUCS4Reader := TUtilsUCS4Reader.Create(FStringStream, 4096, 'UTF-16LE', 0, 0, 0, 0, 1);                                                                                        
  FTokenType := DTD_ECM_START_OF_SOURCE_TOKEN;
  FErrorType := ET_NONE;
end;

destructor TXmlElementCMTokenizer.Destroy;
begin
  FUCS4Reader.Free;  // Remark: Free the UCS-4 Reader before the stream.
  FStringStream.Free;
  FTokenValue.Free;
  inherited;
end;

{$IFDEF NEXTGEN}
function TXmlElementCMTokenizer.GetTokenValue: string;
{$ELSE !NEXTGEN}
function TXmlElementCMTokenizer.GetTokenValue: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FTokenValue.Value;
end;

procedure TXmlElementCMTokenizer.Next;
const
  NUMBER_CODE            = $23; // code of #
  OPENING_BRACKET_CODE   = $28; // code of (
  CLOSING_BRACKET_CODE   = $29; // code of )
  ASTERISK_CODE          = $2A; // code of *
  PLUS_SIGN_CODE         = $2B; // code of +
  COMMA_CODE             = $2C; // code of ,
  QM_CODE                = $3F; // code of ?
  VERTICAL_LINE_CODE     = $7C; // code of |
  STRING_TERMINATOR_CODE = $9C;

  PCDATA_KEYWORD: array[0..5] of UCS4Char =
    (Ord('P'), Ord('C'), Ord('D'), Ord('A'), Ord('T'), Ord('A'));

{$IFDEF NEXTGEN}
  ANY_KEYWORD: string = 'ANY';
  EMPTY_KEYWORD: string = 'EMPTY';
{$ELSE !NEXTGEN}
  ANY_KEYWORD: WideString = 'ANY';
  EMPTY_KEYWORD: WideString = 'EMPTY';
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  if FTokenType = DTD_ECM_END_OF_SOURCE_TOKEN then Exit;

  FTokenValue.Clear;
  FErrorType := ET_NONE;
  FClue := '';

  try
    repeat
      FUCS4Reader.Next;
    until not IsXmlWhiteSpaceCodePoint(FUCS4Reader.CurrentCharInfo.CodePoint); // Skip whitespace.

    case FUCS4Reader.CurrentCharInfo.CodePoint of

      NUMBER_CODE: begin
        FTokenType := DTD_ECM_PCDATA_KEYWORD_TOKEN;
        FTokenValue.AddUCS4Char(NUMBER_CODE);
        for I := 0 to 5 do
          if FUCS4Reader.NextCharInfo.CodePoint = PCDATA_KEYWORD[I] then begin
            FUCS4Reader.Next;
            FTokenValue.AddUCS4Char(FUCS4Reader.CurrentCharInfo.CodePoint);
          end else begin
            FErrorType := ET_INVALID_CONTENT_MODEL_TOKEN_IN_ELEMENT_DECL;
            FClue := '#PCDATA';
          end;
      end;

      OPENING_BRACKET_CODE: begin
        FBracketFound := True;
        FTokenType := DTD_ECM_OPENING_BRACKET_TOKEN;
        FTokenValue.AddUCS4Char(OPENING_BRACKET_CODE);
      end;

      CLOSING_BRACKET_CODE: begin
        FTokenType := DTD_ECM_CLOSING_BRACKET_TOKEN;
        FTokenValue.AddUCS4Char(CLOSING_BRACKET_CODE);
      end;

      ASTERISK_CODE: begin
        FTokenType := DTD_ECM_FREQUENCY_TOKEN;
        FTokenValue.AddUCS4Char(ASTERISK_CODE);
      end;

      PLUS_SIGN_CODE: begin
        FTokenType := DTD_ECM_FREQUENCY_TOKEN;
        FTokenValue.AddUCS4Char(PLUS_SIGN_CODE);
      end;

      COMMA_CODE: begin
        FTokenType := DTD_ECM_SEPARATOR_TOKEN;
        FTokenValue.AddUCS4Char(COMMA_CODE);
      end;

      QM_CODE: begin
        FTokenType := DTD_ECM_FREQUENCY_TOKEN;
        FTokenValue.AddUCS4Char(QM_CODE);
      end;

      VERTICAL_LINE_CODE: begin
        FTokenType := DTD_ECM_SEPARATOR_TOKEN;
        FTokenValue.AddUCS4Char(VERTICAL_LINE_CODE);
      end;

      // End of source found:
      STRING_TERMINATOR_CODE: begin
        FTokenType := DTD_ECM_END_OF_SOURCE_TOKEN;
      end;

    else
      // ANY or EMPTY keword, or Element type name found etc.:
      FTokenType := DTD_ECM_NAME_TOKEN;
      FTokenValue.AddUCS4Char(FUCS4Reader.CurrentCharInfo.CodePoint);
      if IsXmlNameStartCharCodePoint(FUCS4Reader.CurrentCharInfo.CodePoint) then begin
        while IsXmlNameCharCodePoint(FUCS4Reader.NextCharInfo.CodePoint) do begin
          FUCS4Reader.Next;
          FTokenValue.AddUCS4Char(FUCS4Reader.CurrentCharInfo.CodePoint);
        end;
        if not FBracketFound then begin
          if FTokenValue.IsEqual(ANY_KEYWORD) then
            FTokenType := DTD_ECM_ANY_KEYWORD_TOKEN
          else if FTokenValue.IsEqual(EMPTY_KEYWORD) then
            FTokenType := DTD_ECM_EMPTY_KEYWORD_TOKEN;
        end;
      end else begin
        FTokenType := DTD_ECM_INVALID_MARKUP_TOKEN;
        FErrorType := ET_INVALID_CONTENT_MODEL_TOKEN_IN_ELEMENT_DECL;
      end;
    end;

  except
    on EConvertError do
      FErrorType := ET_INVALID_CHARACTER;
  end; {try ...}
end;



{ TXmlAttrValueTokenizer }

{$IFDEF NEXTGEN}
constructor TXmlAttrValueTokenizer.Create(const S: string);
{$ELSE !NEXTGEN}
constructor TXmlAttrValueTokenizer.Create(const S: WideString);
{$ENDIF NEXTGEN}
const
  BOM: WideChar = #$FEFF;  // Byte order mark
begin
  inherited Create;
  FUCS4Reader := nil;   // Remark: If an exception occurs, the destructor is automatically called.
  FStringStream := nil; //         Therefore, we need to initialize critical objects with nil first.
  FTokenValue := TUtilsCustomWideStr.Create;
  FStringStream := TUtilsWideStringStream.Create(BOM + S); // Add BOM in order to identify BOM duplicates.
  FUCS4Reader := TUtilsUCS4Reader.Create(FStringStream, 4096, 'UTF-16LE', 0, 0, 0, 0, 1);                                                                                        
  FTokenType := ATTR_START_OF_SOURCE_TOKEN;
  FErrorType := ET_NONE;
end;

destructor TXmlAttrValueTokenizer.Destroy;
begin
  FUCS4Reader.Free;  // Remark: Free the UCS-4 Reader before the stream.
  FStringStream.Free;
  FTokenValue.Free;
  inherited;
end;

{$IFDEF NEXTGEN}
function TXmlAttrValueTokenizer.GetTokenValue: string;
{$ELSE !NEXTGEN}
function TXmlAttrValueTokenizer.GetTokenValue: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FTokenValue.Value;
end;

procedure TXmlAttrValueTokenizer.Next;
const
  NUMBER_CODE      = $23; // code of #
  AMP_CODE         = $26; // code of &
  SEMICOLON_CODE   = $3B; // code of ;
  LT_CODE          = $3C; // code of <
  STRING_TERMINATOR_CODE = $9C;
begin
  if FTokenType = ATTR_END_OF_SOURCE_TOKEN then Exit;

  FTokenValue.Clear;
  FErrorType := ET_NONE;

  FUCS4Reader.Next;

  case FUCS4Reader.CurrentCharInfo.CodePoint of

    // '&' Entity found:
    AMP_CODE: begin

      // Entity reference or character reference?
      if FUCS4Reader.NextCharInfo.CodePoint = NUMBER_CODE then begin
        FUCS4Reader.Next;
        FTokenType := ATTR_CHAR_REF;
        FErrorType := ET_UNCLOSED_CHAR_REF;
      end else begin
        FTokenType := ATTR_ENTITY_REF;
        FErrorType := ET_UNCLOSED_ENTITY_REF;
      end;

      FErrorType := ET_NONE;
      while FUCS4Reader.NextCharInfo.CodePoint <> STRING_TERMINATOR_CODE do begin
        FUCS4Reader.Next;

        // End of entity reference (';') found?
        if FUCS4Reader.CurrentCharInfo.CodePoint = SEMICOLON_CODE then begin
          FErrorType := ET_NONE;
          Exit;
        end;

        FTokenValue.AddUCS4Char(FUCS4Reader.CurrentCharInfo.CodePoint);
      end;

    end;

    // End of source found:
    STRING_TERMINATOR_CODE: begin
      FTokenType := ATTR_END_OF_SOURCE_TOKEN;
    end;

  else
    // Ordinary text found:
    FTokenType := ATTR_TEXT;
    FTokenValue.AddUCS4Char(FUCS4Reader.CurrentCharInfo.CodePoint);
  end;
end;



// +++++++++++++++++++++++++ TXmlOutputSource +++++++++++++++++++++++++
constructor TXmlOutputSource.Create(const Stream: TStream;
                                    const BufSize: Integer);
begin
  inherited;
  FEncoding := 'UTF-8';
  FCodec := TUTF8Codec.Create;
  FCodec.OnWrite := WriteEventHandler;
  FCodec.WriteLFOption := lwCRLF;
end;

destructor TXmlOutputSource.Destroy;
begin
  FCodec.Free;
  inherited;
end;

function TXmlOutputSource.GetWriteLFOption: TCodecWriteLFOption;
begin
  Result := FCodec.WriteLFOption;
end;

procedure TXmlOutputSource.SetEncoding(const Value: string);
var
  NewCodec: TUnicodeCodec;
begin
  if Value = '' then
    raise ENot_Supported_Err.Create('Encoding must be specified.');

  NewCodec := TEncodingRepository.CreateCodecByAlias(Value);
  if not Assigned(NewCodec) then
    raise ENot_Supported_Err.Create('Encoding not supported error.');

  // Initialize the properties of the new codec:
  NewCodec.OnWrite := WriteEventHandler;
  NewCodec.WriteLFOption := FCodec.WriteLFOption;

  // Store encoding name used:
  FEncoding := Value;

  // Replace the old codec with the new:
  FCodec.Free;
  FCodec := NewCodec;
end;

procedure TXmlOutputSource.SetWriteLFOption(const Value: TCodecWriteLFOption);
begin
  FCodec.WriteLFOption:= Value;
end;

{$IFDEF CLR}
procedure TXmlOutputSource.Write(const Buf: TBytes; const Count: Longint);
begin
  inherited;
end;
{$ENDIF}

function TXmlOutputSource.WriteByteOrderMark: Integer;
const
  UTF_8_BOM     : array[0..2] of Byte = ($EF, $BB, $BF);
  UTF_16BE_BOM  : array[0..1] of Byte = ($FE, $FF);
  UTF_16LE_BOM  : array[0..1] of Byte = ($FF, $FE);
  UCS4BE_BOM    : array[0..3] of Byte = ($00, $00, $FE, $FF);
  UCS4LE_BOM    : array[0..3] of Byte = ($FF, $FE, $00, $00);
  UCS4_2143_BOM : array[0..3] of Byte = ($00, $00, $FF, $FE);
  UCS4_3412_BOM : array[0..3] of Byte = ($FE, $FF, $00, $00);
begin
  if Position > 0 then
    raise EWriteError.Create('Byte order mark only allowed at output start.');

  Result := 0;
  try
    if FCodec is TUTF16BECodec then begin
      Result := 2;
      Write(UTF_16BE_BOM, 2);
    end else if FCodec is TUTF16LECodec then begin
      Result := 2;
      Write(UTF_16LE_BOM, 2);
    end else if FCodec is TUCS2BECodec then begin
      Result := 2;
      Write(UTF_16BE_BOM, 2);
    end else if FCodec is TUCS2LECodec then begin
      Result := 2;
      Write(UTF_16LE_BOM, 2);
    end else if FCodec is TUTF8Codec then begin
      Result := 3;
      Write(UTF_8_BOM, 3);
    end;
  except
    raise EWriteError.Create('Writing byte order mark failed.');
  end;
end;

procedure TXmlOutputSource.WriteEventHandler(const Sender: TObject;
  const Buf{$IFDEF CLR}: array of Byte{$ENDIF}; Count: LongInt);
begin
  Write(Buf, Count);
end;

procedure TXmlOutputSource.WriteUCS4Char(const C: UCS4Char;
                                           out ByteCount: Integer);
begin
  FCodec.WriteUCS4Char(C, ByteCount);
end;



// ++++++++++++++++++++++++++ TDomError ++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomError.Create(const ARelatedException: TXmlErrorType;
                             const AStartByteNumber,
                                   AStartCharNumber,
                                   AStartColumnNumber,
                                   AStartLineNumber,
                                   AStartTabsInLine,
                                   AEndByteNumber,
                                   AEndCharNumber,
                                   AEndColumnNumber,
                                   AEndLineNumber,
                                   AEndTabsInLine: Int64;
                             const AUri: string;
                             const ARelatedDtdObject: TDtdObject;
                             const ARelatedNode: TDomNode;
                             const ACode,
                                   AClue: string);
{$ELSE !NEXTGEN}
constructor TDomError.Create(const ARelatedException: TXmlErrorType;
                             const AStartByteNumber,
                                   AStartCharNumber,
                                   AStartColumnNumber,
                                   AStartLineNumber,
                                   AStartTabsInLine,
                                   AEndByteNumber,
                                   AEndCharNumber,
                                   AEndColumnNumber,
                                   AEndLineNumber,
                                   AEndTabsInLine: Int64;
                             const AUri: WideString;
                             const ARelatedDtdObject: TDtdObject;
                             const ARelatedNode: TDomNode;
                             const ACode,
                                   AClue: WideString);
{$ENDIF NEXTGEN}
begin
  inherited Create;

  FRelatedException :=  ARelatedException;

  FStartByteNumber :=   AStartByteNumber;
  FStartCharNumber :=   AStartCharNumber;
  FStartColumnNumber := AStartColumnNumber;
  FStartLineNumber :=   AStartLineNumber;
  FStartTabsInLine :=   AStartTabsInLine;
  FEndByteNumber :=     AEndByteNumber;
  FEndCharNumber :=     AEndCharNumber;
  FEndColumnNumber :=   AEndColumnNumber;
  FEndLineNumber :=     AEndLineNumber;
  FEndTabsInLine :=     AEndTabsInLine;
  FUri :=               AUri;
  FRelatedDtdObject :=  ARelatedDtdObject;
  FRelatedNode :=       ARelatedNode;
  FCode :=              ACode;
  FClue :=              AClue;
end;

{$IFDEF NEXTGEN}
constructor TDomError.CreateFromLocator(const ARelatedException: TXmlErrorType;
                                        const ALocation: IDomLocator;
                                        const ACode,
                                              AClue: string);
{$ELSE !NEXTGEN}
constructor TDomError.CreateFromLocator(const ARelatedException: TXmlErrorType;
                                        const ALocation: IDomLocator;
                                        const ACode,
                                              AClue: WideString);
{$ENDIF NEXTGEN}
begin
  if Assigned(ALocation) then
    Self.Create(ARelatedException,  ALocation.StartByteNumber, ALocation.StartCharNumber,
          ALocation.StartColumnNumber, ALocation.StartLineNumber, ALocation.StartTabsInLine, ALocation.EndByteNumber,
          ALocation.EndCharNumber, ALocation.EndColumnNumber, ALocation.EndLineNumber, ALocation.EndTabsInLine, ALocation.Uri,
          ALocation.RelatedDtdObject, ALocation.RelatedNode, ACode, AClue)
   else Create(ARelatedException, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, '', nil, nil, ACode, AClue);
end;

function TDomError.CloneError: TDomError;
begin
  Result := TDomError.Create(RelatedException, StartByteNumber,
          StartCharNumber, StartColumnNumber, StartLineNumber, StartTabsInLine,
          EndByteNumber, EndCharNumber, EndColumnNumber, EndLineNumber,
          EndTabsInLine, Uri, RelatedDtdObject, RelatedNode, Code, Clue);
end;

function TDomError.GetEndByteNumber: Int64;
begin
  Result := FEndByteNumber;
end;

function TDomError.GetEndCharNumber: Int64;
begin
  Result := FEndCharNumber;
end;

function TDomError.GetEndColumnNumber: Int64;
begin
  Result := FEndColumnNumber;
end;

function TDomError.GetEndLineNumber: Int64;
begin
  Result := FEndLineNumber;
end;

function TDomError.GetEndTabsInLine: Int64;
begin
  Result := FEndTabsInLine;
end;

function TDomError.GetRelatedDtdObject: TDtdObject;
begin
  Result := FRelatedDtdObject;
end;

function TDomError.GetRelatedNode: TDomNode;
begin
  Result := FRelatedNode;
end;

function TDomError.GetSeverity: TDomSeverity;
begin
  if RelatedException in ET_FATAL_ERRORS
    then Result := DOM_SEVERITY_FATAL_ERROR
  else if RelatedException in ET_ERRORS
    then Result := DOM_SEVERITY_ERROR
  else Result := DOM_SEVERITY_WARNING;
end;

function TDomError.GetStartByteNumber: Int64;
begin
  Result := FStartByteNumber;
end;

function TDomError.GetStartCharNumber: Int64;
begin
  Result := FStartCharNumber;
end;

function TDomError.GetStartColumnNumber: Int64;
begin
  Result := FStartColumnNumber;
end;

function TDomError.GetStartLineNumber: Int64;
begin
  Result := FStartLineNumber;
end;

function TDomError.GetStartTabsInLine: Int64;
begin
  Result := FStartTabsInLine;
end;

{$IFDEF NEXTGEN}
function TDomError.GetUri: string;
{$ELSE !NEXTGEN}
function TDomError.GetUri: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FUri;
end;



// ++++++++++++++++++++++++++++ TDomPERepository +++++++++++++++++++++++++++++
constructor TDomPERepository.Create(const AOwner: TXmlCustomReader);
begin
  if not Assigned(AOwner) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('AOwner not specified.');
  inherited Create;
  FOwner := AOwner;
  FPEList := TUtilsWideStringList.Create;
  FPEList.Duplicates := dupError;
  FPEList.Sorted:= True;
end;

destructor TDomPERepository.Destroy;
begin
  Clear;
  FPEList.Free;
  inherited;
end;

{$IFDEF NEXTGEN}
function TDomPERepository.Add(const Name,
                                    Value: string): Boolean;
{$ELSE !NEXTGEN}
function TDomPERepository.Add(const Name,
                                    Value: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  NewPEInfoObj: TDomPEInfoObject;
begin
  if FPEList.IndexOf(Name) = -1 then begin  // Ignore declaration duplicates
    NewPEInfoObj := TDomPEInfoObject.Create(Self, Name, Value);
    try
      Result := True;
      FPEList.AddObject(NewPEInfoObj.NodeName, NewPEInfoObj);
    except
      NewPEInfoObj.Free;
      raise;
    end;
  end else
    Result := False;
end;

{$IFDEF NEXTGEN}
function TDomPERepository.Add(const Name,
                                    BaseUri,
                                    PubId,
                                    SysId: string): Boolean;
{$ELSE !NEXTGEN}
function TDomPERepository.Add(const Name,
                                    BaseUri,
                                    PubId,
                                    SysId: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  NewPEInfoObj: TDomPEInfoObject;
begin
  if FPEList.IndexOf(Name) = -1 then begin  // Ignore declaration duplicates
    NewPEInfoObj := TDomPEInfoObject.CreateExtParsed(Self, Name, BaseUri, PubId, SysId);
    try
      Result := True;
      FPEList.AddObject(NewPEInfoObj.NodeName, NewPEInfoObj);
    except
      NewPEInfoObj.Free;
      raise;
    end;
  end else
    Result := False;
end;

procedure TDomPERepository.Clear;
{$IFNDEF AUTOREFCOUNT}
var
  Index: Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for Index := 0 to Pred(FPEList.Count) do
    FPEList.Objects[Index].Free;
{$ENDIF !AUTOREFCOUNT}
  FPEList.Clear;
end;

{$IFDEF NEXTGEN}
function TDomPERepository.Delete(const Name: string): Boolean;
{$ELSE !NEXTGEN}
function TDomPERepository.Delete(const Name: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  Index: Integer;
begin
  Index := FPEList.IndexOf(Name);
  if Index > -1 then begin  // PE with specified Name in list?
{$IFNDEF AUTOREFCOUNT}
    FPEList.Objects[Index].Free; // Free the TDomPEInfoObject
{$ENDIF !AUTOREFCOUNT}
    FPEList.Delete(Index);
    Result := True;
  end else
    Result := False;
end;

{$IFDEF NEXTGEN}
function TDomPERepository.ResolvePE(const Name: string;
                                    const AcceptExtEntity: Boolean;
                                      out Value,
                                          PubId,
                                          SysId: string): TXmlErrorType;
{$ELSE !NEXTGEN}
function TDomPERepository.ResolvePE(const Name: WideString;
                                    const AcceptExtEntity: Boolean;
                                      out Value,
                                          PubId,
                                          SysId: WideString): TXmlErrorType;
{$ENDIF NEXTGEN}
var
  Index: Integer;
  PEInfoObject: TDomPEInfoObject;
begin
  if IsXmlName(Name) then begin
    Index := FPEList.IndexOf(Name);
    if Index > -1 then begin
      PEInfoObject := FPEList.Objects[Index] as TDomPEInfoObject;

      // Update the literal value in case the parameter entity is external:
      if PEInfoObject.EntityType = etExternal_Entity then begin
        if AcceptExtEntity then begin
          if not PEInfoObject.UpdateAttempted then
            PEInfoObject.Update;
          Result := PEInfoObject.UpdateError;
        end else
          Result := ET_EXT_ENTITY_RESOURCE_NOT_FOUND;  // Return error, if external PEs are switched off.
      end else
        Result := ET_NONE;

      if Result in ET_WARNINGS then begin
        Value := PEInfoObject.LiteralValue;
        PubId := PEInfoObject.PublicId;
        SysId := PEInfoObject.EntityURI;
      end else begin
        Value := '';
        PubId := '';
        SysId := '';
        Exit;
      end;

    end else begin
      Value := '';
      PubId := '';
      SysId := '';
      Result := ET_UNDEFINED_PARAMETER_ENTITY;
    end;
  end else begin
    Value := '';
    PubId := '';
    SysId := '';
    Result := ET_INVALID_PARAMETER_ENTITY_NAME;
  end;
end;

{$IFDEF NEXTGEN}
procedure TDomPERepository.ResolveResourceAsWideString(const BaseURI,
                                                             PublicId,
                                                             SystemId: string;
                                                         out S: string;
                                                         out Error: TXmlErrorType);
{$ELSE !NEXTGEN}
procedure TDomPERepository.ResolveResourceAsWideString(const BaseURI,
                                                             PublicId,
                                                             SystemId: WideString;
                                                         out S: WideString;
                                                         out Error: TXmlErrorType);
{$ENDIF NEXTGEN}
begin
  OwnerReader.ResolveResourceAsWideString(BaseURI, PublicId, SystemId, S, Error);
end;



// ++++++++++++++++++++++ TDomPEInfoObject ++++++++++++++++++++++
{$IFDEF NEXTGEN}
constructor TDomPEInfoObject.Create(const AOwner: TDomPERepository;
                                    const EntityName,
                                          LitValue: string);
{$ELSE !NEXTGEN}
constructor TDomPEInfoObject.Create(const AOwner: TDomPERepository;
                                    const EntityName,
                                          LitValue: WideString);
{$ENDIF NEXTGEN}
begin
  if not Assigned(AOwner) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('AOwner not specified.');
  if not IsXmlName(EntityName) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(nil);
  FOwnerRepository := AOwner;
  FUpdateAttempted := True;
  FUpdateError := ET_NONE;
  FEntityType := etInternal_Entity;
  try
    FLiteralValue := ResolveCharRefs(LitValue);
  except
    raise EInvalid_Character_Err.Create('Invalid character error.');
  end;
  FNodeName := EntityName;
  FPublicId := '';
  FSystemId := '';
end;

{$IFDEF NEXTGEN}
constructor TDomPEInfoObject.CreateExtParsed(const AOwner: TDomPERepository;
                                             const EntityName,
                                                   ABaseUri,
                                                   PubId,
                                                   SysId: string);
{$ELSE !NEXTGEN}
constructor TDomPEInfoObject.CreateExtParsed(const AOwner: TDomPERepository;
                                             const EntityName,
                                                   ABaseUri,
                                                   PubId,
                                                   SysId: WideString);
{$ENDIF NEXTGEN}
begin
  if not Assigned(AOwner) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('AOwner not specified.');
  if not IsXmlName(EntityName) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  if not IsXmlSystemChars(SysId) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  if not IsXmlPubidChars(PubId) then
    raise EInvalid_Character_Err.Create('Invalid character error.');
  inherited Create(nil);
  FBaseUri := ABaseUri;
  FOwnerRepository := AOwner;
  FEntityType := etExternal_Entity;
  FLiteralValue := '';
  FNodeName := EntityName;
  FPublicId := PubId;
  FSystemId := SysId;
  FUpdateError := ET_NONE;
  FUpdateAttempted := False;
end;

{$IFDEF NEXTGEN}
function TDomPEInfoObject.EntityURI: string;
begin
  // Calculate absolute system identifier:
  ResolveRelativeUriStr(BaseUri, SystemId, Result);
     // Remark: Returns an empty Result if ResolveRelativeUriWideStr attempt fails.
end;
{$ELSE !NEXTGEN}
function TDomPEInfoObject.EntityURI: WideString;
begin
  // Calculate absolute system identifier:
  ResolveRelativeUriWideStr(BaseUri, SystemId, Result);
     // Remark: Returns an empty Result if ResolveRelativeUriWideStr attempt fails.
end;
{$ENDIF NEXTGEN}

{$IFDEF NEXTGEN}
function TDomPEInfoObject.GetNodeName: string;
{$ELSE !NEXTGEN}
function TDomPEInfoObject.GetNodeName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FNodeName;
end;

procedure TDomPEInfoObject.Update;
begin
  if EntityType = etExternal_Entity then begin
    FUpdateAttempted := True;
    OwnerRepository.ResolveResourceAsWideString(BaseURI, PublicId, SystemId,
                                                FLiteralValue, FUpdateError);
  end;
end;



// +++++++++++++++++++++++++++++++ TXmlSignal +++++++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
procedure TXmlSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                         out Flaw,
                                             Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                         out Flaw,
                                             Clue: WideString);
{$ENDIF NEXTGEN}
begin
  XmlErrorType := ET_NONE;
  Flaw := '';
  Clue := '';
end;

function TXmlSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
  type
    TXmlSignalClass = class of TXmlSignal;
begin
  Result := TXmlSignalClass(ClassType).Create(AReader, StartByteNumber,
              StartCharNumber, StartColumnNumber, StartLineNumber,
              StartTabsInLine, EndByteNumber, EndCharNumber, EndColumnNumber,
              EndLineNumber, EndTabsInLine, Uri, RelatedDtdObject, RelatedNode);
end;

constructor TXmlSignal.Create(const AReader: TXmlCustomReader;
                              const AStartByteNumber,
                                    AStartCharNumber,
                                    AStartColumnNumber,
                                    AStartLineNumber,
                                    AStartTabsInLine,
                                    AEndByteNumber,
                                    AEndCharNumber,
                                    AEndColumnNumber,
                                    AEndLineNumber,
                                    AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                              const AUri: string;
{$ELSE !NEXTGEN}
                              const AUri: WideString;
{$ENDIF NEXTGEN}
                              const ARelatedDtdObject: TDtdObject;
                              const ARelatedNode: TDomNode);
begin
  inherited Create;
  InitSignal(AReader, AStartByteNumber, AStartCharNumber, AStartColumnNumber,
             AStartLineNumber, AStartTabsInLine, AEndByteNumber, AEndCharNumber,
             AEndColumnNumber, AEndLineNumber, AEndTabsInLine, AUri,
             ARelatedDtdObject, ARelatedNode);
end;

constructor TXmlSignal.CreateFromLocator(const AReader: TXmlCustomReader;
                                         const Location: IDomLocator);
begin
  inherited Create;
  if Assigned(Location) then
    InitSignal(AReader, Location.StartByteNumber, Location.StartCharNumber, Location.StartColumnNumber,
                Location.StartLineNumber, Location.StartTabsInLine, Location.EndByteNumber, Location.EndCharNumber,
                Location.EndColumnNumber, Location.EndLineNumber, Location.EndTabsInLine,
                Location.Uri, RelatedDtdObject, RelatedNode)
  else
    InitSignal(AReader, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, '', nil, nil);
end;

function TXmlSignal.GetEndByteNumber: Int64;
begin
  Result := FEndByteNumber;
end;

function TXmlSignal.GetEndCharNumber: Int64;
begin
  Result := FEndCharNumber;
end;

function TXmlSignal.GetEndColumnNumber: Int64;
begin
  Result := FEndColumnNumber;
end;

function TXmlSignal.GetEndLineNumber: Int64;
begin
  Result := FEndLineNumber;
end;

function TXmlSignal.GetEndTabsInLine: Int64;
begin
  Result := FEndTabsInLine;
end;

function TXmlSignal.GetRelatedDtdObject: TDtdObject;
begin
  Result := FRelatedDtdObject;
end;

function TXmlSignal.GetRelatedNode: TDomNode;
begin
  Result := FRelatedNode;
end;

function TXmlSignal.GetStartByteNumber: Int64;
begin
  Result := FStartByteNumber;
end;

function TXmlSignal.GetStartCharNumber: Int64;
begin
  Result := FStartCharNumber;
end;

function TXmlSignal.GetStartColumnNumber: Int64;
begin
  Result := FStartColumnNumber;
end;

function TXmlSignal.GetStartLineNumber: Int64;
begin
  Result := FStartLineNumber;
end;

function TXmlSignal.GetStartTabsInLine: Int64;
begin
  Result := FStartTabsInLine;
end;

{$IFDEF NEXTGEN}
function TXmlSignal.GetUri: string;
{$ELSE !NEXTGEN}
function TXmlSignal.GetUri: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FUri;
end;

procedure TXmlSignal.InitSignal(const AReader: TXmlCustomReader;
                                const AStartByteNumber,
                                      AStartCharNumber,
                                      AStartColumnNumber,
                                      AStartLineNumber,
                                      AStartTabsInLine,
                                      AEndByteNumber,
                                      AEndCharNumber,
                                      AEndColumnNumber,
                                      AEndLineNumber,
                                      AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                                const AUri: string;
{$ELSE !NEXTGEN}
                                const AUri: WideString;
{$ENDIF NEXTGEN}
                                const ARelatedDtdObject: TDtdObject;
                                const ARelatedNode: TDomNode);
// InitSignal is a workaround for a bug in some Delphi for .NET versions,
// according to which overriding constructors of derived classes are not
// correctly called when using class references, viz. only the constructor
// of the base class is called.
//
// To work around that bug we call this virtual InitSignal procedure that is
// called from the base class. Overriding InitSignal procedures are correctly
// called from the base class.
begin
  FReader := AReader;

  FStartByteNumber :=   AStartByteNumber;
  FStartCharNumber :=   AStartCharNumber;
  FStartColumnNumber := AStartColumnNumber;
  FStartLineNumber :=   AStartLineNumber;
  FStartTabsInLine :=   AStartTabsInLine;
  FEndByteNumber :=     AEndByteNumber;
  FEndCharNumber :=     AEndCharNumber;
  FEndColumnNumber :=   AEndColumnNumber;
  FEndLineNumber :=     AEndLineNumber;
  FEndTabsInLine :=     AEndTabsInLine;
  FUri :=               AUri;
  FRelatedDtdObject :=  ARelatedDtdObject;
  FRelatedNode :=       ARelatedNode;
end;

{ TXmlCompletedSignal }

function TXmlCompletedSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc, ssDtd];
end;

{ TXmlAbortedSignal }

function TXmlAbortedSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc, ssDtd];
end;

{ TXmlAttributeSignal }

{$IFDEF NEXTGEN}
procedure TXmlAttributeSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                  out Flaw,
                                                      Clue: string);
var
  CharacRef: string;
  I: Integer;
  InEntityRef: Boolean;
  Text: string;
  V: string;
{$ELSE !NEXTGEN}
procedure TXmlAttributeSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                  out Flaw,
                                                      Clue: WideString);
var
  CharacRef: WideString;
  I: Integer;
  InEntityRef: Boolean;
  Text: WideString;
  V: WideString;
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(Name) then begin
    XmlErrorType := ET_INVALID_ATTRIBUTE_NAME;
    Flaw := Name;
    Clue := '';
    Exit;
  end;

  InEntityRef := False;
  Text := '';
  for I := FirstIndex to Length(Value)-AdjustIndex do begin
    if InEntityRef then begin
      if Value[I] = ';' then begin
        if Text[FirstIndex] = '#' then begin // CharRef
          try
{$IFDEF NEXTGEN}
            CharacRef := Concat(string('&'), Text, string(';'));
{$ELSE !NEXTGEN}
            CharacRef := Concat(WideString('&'), Text, WideString(';'));
{$ENDIF NEXTGEN}
            V := XmlCharRefToStr(CharacRef);
          except
            on EConvertError do begin
              XmlErrorType := ET_INVALID_CHAR_REF;
              Flaw := CharacRef;
              Clue := '';
              Exit;
            end;
          end; {try}
        end else begin  // EntityRef
          if not IsXmlName(Text) then begin
            XmlErrorType := ET_INVALID_ENTITY_NAME;
            Flaw := Text;
            Clue := '';
            Exit;
          end;
        end;
        Text := '';
        InEntityRef := False;
      end else
{$IFDEF NEXTGEN}
        Text:= Concat(Text, string(Value[I]));
{$ELSE !NEXTGEN}
        Text:= Concat(Text, WideString(Value[I]));
{$ENDIF NEXTGEN}
    end else begin
      if Value[I] = '&' then begin
        InEntityRef := True;
      end else if (Value[I] = '<') then begin
        // WFC: No < in Attribute Values (XML 1.0, § 3.3.2)
        XmlErrorType := ET_LT_IN_ATTRIBUTE_VALUE;
        Flaw := Value[I];
        Clue := '';
        Exit;
      end else if not IsXmlChar(Value[I]) then begin
        XmlErrorType := ET_INVALID_ATTRIBUTE_VALUE;
        Flaw := Value[I];
        Clue := '';
        Exit;
      end;
    end; {if ...}
  end; {for I ...}

  if InEntityRef then begin
    if Length(Text) > 0 then begin
      if Text[FirstIndex] = '#' then
        XmlErrorType := ET_UNCLOSED_CHAR_REF
      else
        XmlErrorType := ET_UNCLOSED_ENTITY_REF;
    end else
      XmlErrorType := ET_UNCLOSED_ENTITY_REF;
    Flaw := Value;
    Clue := '';
    Exit;
  end; {if ...}

  // Issue warning, if specification of xml:space attribute is erroneous (cf. XML 1.0, § 2.10)
  // Remark: Checking for warnings must be performed last so that it does not
  //         override wellformedness tests.
  if Name = 'xml:space' then
    if (Value <> 'default') and (Value <> 'preserve') then begin
      XmlErrorType := ET_XML_SPACE_ATTRIBUTE_ERRONEOUS_VALUE_SPECIFIED;
      Flaw := Value;
      Clue := '';
      Exit;
    end;

  XmlErrorType := ET_NONE;
  Flaw := '';
  Clue := '';
end;

function TXmlAttributeSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlAttributeSignal(Result).DataType := DataType;
  TXmlAttributeSignal(Result).Name := Name;
  TXmlAttributeSignal(Result).Value := Value;
end;

function TXmlAttributeSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlCDATASignal }

{$IFDEF NEXTGEN}
procedure TXmlCDATASignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                              out Flaw,
                                                  Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlCDATASignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                              out Flaw,
                                                  Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if IsXmlCData(Data)
    then XmlErrorType := ET_NONE
    else XmlErrorType := ET_INVALID_CDATA_SECTION;
  Flaw := '';
  Clue := '';
end;

function TXmlCDATASignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlCDATASignal(Result).Data := Data;
end;

function TXmlCDATASignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlDoctypeSignal }

{$IFDEF NEXTGEN}
procedure TXmlDoctypeSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                out Flaw,
                                                    Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlDoctypeSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                out Flaw,
                                                    Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(DoctypeName) then begin
    XmlErrorType := ET_INVALID_ROOT_ELEMENT_NAME_IN_DOCTYPE_DECL;
    Flaw := DoctypeName;
    Clue := '';
  end else

  if not IsXmlPubidChars(PublicId) then begin
    XmlErrorType := ET_INVALID_PUBID_LITERAL;
    Flaw := PublicId;
    Clue := '';
  end else

  if not IsXmlSystemChars(SystemId)  then begin
    XmlErrorType := ET_INVALID_SYSTEM_LITERAL;
    Flaw := SystemId;
    Clue := '';

  end else begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end;
end;

function TXmlDoctypeSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlDoctypeSignal(Result).Data := Data;
  TXmlDoctypeSignal(Result).DoctypeName := DoctypeName;
  TXmlDoctypeSignal(Result).IntSubsetStartByteNumber := IntSubsetStartByteNumber;
  TXmlDoctypeSignal(Result).IntSubsetStartCharNumber := IntSubsetStartCharNumber;
  TXmlDoctypeSignal(Result).IntSubsetStartColumn := IntSubsetStartColumn;
  TXmlDoctypeSignal(Result).IntSubsetStartLine := IntSubsetStartLine;
  TXmlDoctypeSignal(Result).PublicId := PublicId;
  TXmlDoctypeSignal(Result).SystemId := SystemId;
end;

function TXmlDoctypeSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlEndElementSignal }

{$IFDEF NEXTGEN}
procedure TXmlEndElementSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                   out Flaw,
                                                       Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlEndElementSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                   out Flaw,
                                                       Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if IsXmlName(TagName) then begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end else begin
    XmlErrorType := ET_INVALID_ELEMENT_NAME;
    Flaw := TagName;
    Clue := '';
  end;
end;

function TXmlEndElementSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlEndElementSignal(Result).TagName := TagName;
end;

function TXmlEndElementSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlEndPrefixMappingSignal }

{$IFDEF NEXTGEN}
procedure TXmlEndPrefixMappingSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                         out Flaw,
                                                             Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlEndPrefixMappingSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                         out Flaw,
                                                             Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if IsXmlPrefix(Prefix) or (Prefix = '') then begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end else begin
    XmlErrorType := ET_INVALID_PREFIX;
    Flaw := Prefix;
    Clue := '';
  end;
end;

function TXmlEndPrefixMappingSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlEndPrefixMappingSignal(Result).Prefix := Prefix;
end;

function TXmlEndPrefixMappingSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlEntityRefSignal }

{$IFDEF NEXTGEN}
procedure TXmlEntityRefSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                  out Flaw,
                                                      Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlEntityRefSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                  out Flaw,
                                                      Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if IsXmlName(EntityName) then begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end else begin
    XmlErrorType := ET_INVALID_ENTITY_NAME;
    Flaw := EntityName;
    Clue := '';
  end;
end;

function TXmlEntityRefSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlEntityRefSignal(Result).EntityName := EntityName;
end;

function TXmlEntityRefSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlStartElementSignal }

{$IFDEF NEXTGEN}
procedure TXmlStartElementSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                     out Flaw,
                                                         Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlStartElementSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                     out Flaw,
                                                         Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if IsXmlName(TagName) then begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end else begin
    XmlErrorType := ET_INVALID_ELEMENT_NAME;
    Flaw := TagName;
    Clue := '';
  end;
end;

function TXmlStartElementSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlStartElementSignal(Result).TagName := TagName;
end;

function TXmlStartElementSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlPCDATASignal }

procedure TXmlPCDATASignal.InitSignal(const AReader: TXmlCustomReader;
                                      const AStartByteNumber,
                                            AStartCharNumber,
                                            AStartColumnNumber,
                                            AStartLineNumber,
                                            AStartTabsInLine,
                                            AEndByteNumber,
                                            AEndCharNumber,
                                            AEndColumnNumber,
                                            AEndLineNumber,
                                            AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                                      const AUri: string;
{$ELSE !NEXTGEN}
                                      const AUri: WideString;
{$ENDIF NEXTGEN}
                                      const ARelatedDtdObject: TDtdObject;
                                      const ARelatedNode: TDomNode);
begin
  inherited;
  FCharRefGenerated := False;
end;

{$IFDEF NEXTGEN}
procedure TXmlPCDATASignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                               out Flaw,
                                                   Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlPCDATASignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                               out Flaw,
                                                   Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if IsXmlCData(Data) then begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end else begin
    XmlErrorType := ET_INVALID_CHARACTER;
    Flaw := Data;                                                       
    Clue := '';
  end;
end;

function TXmlPCDATASignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlPCDATASignal(Result).Data := Data;
  TXmlPCDATASignal(Result).CharRefGenerated := CharRefGenerated;
end;

function TXmlPCDATASignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlSkippedEntitySignal }

function TXmlSkippedEntitySignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlSkippedEntitySignal(Result).EntityName := EntityName;
end;

function TXmlSkippedEntitySignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlStartDocumentSignal }

{$IFDEF NEXTGEN}
procedure TXmlStartDocumentSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                      out Flaw,
                                                          Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlStartDocumentSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                      out Flaw,
                                                          Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if not ( IsXmlEncName(EncodingName) or (EncodingName = '') ) then begin
    XmlErrorType := ET_INVALID_ENCODING_NAME;
    Flaw := '';
    Clue := '';
  end else

  if not ( IsXmlVersionNum(Version) or (Version = '') ) then begin
    XmlErrorType := ET_INVALID_VERSION_NUMBER;
    Flaw := '';
    Clue := '';

  end else begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end;
end;

function TXmlStartDocumentSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlStartDocumentSignal(Result).EncodingName := EncodingName;
  TXmlStartDocumentSignal(Result).InputEncoding := InputEncoding;
  TXmlStartDocumentSignal(Result).StandaloneDecl := StandaloneDecl;
  TXmlStartDocumentSignal(Result).Version := Version;
end;

function TXmlStartDocumentSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlStartDocumentFragmentSignal }

{$IFDEF NEXTGEN}
procedure TXmlStartDocumentFragmentSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                              out Flaw,
                                                                  Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlStartDocumentFragmentSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                              out Flaw,
                                                                  Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if not ( IsXmlEncName(EncodingName) or (EncodingName = '') ) then begin
    XmlErrorType := ET_INVALID_ENCODING_NAME;
    Flaw := '';
    Clue := '';
  end else begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end;;
end;

function TXmlStartDocumentFragmentSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlStartDocumentFragmentSignal(Result).EncodingName := EncodingName;
end;

function TXmlStartDocumentFragmentSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlStartPrefixMappingSignal }

{$IFDEF NEXTGEN}
procedure TXmlStartPrefixMappingSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                           out Flaw,
                                                               Clue: string);
const
  SQ: string = #39; // code of '
  DQ: string = #34; // code of "
{$ELSE !NEXTGEN}
procedure TXmlStartPrefixMappingSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                           out Flaw,
                                                               Clue: WideString);
const
  SQ: WideString = #39; // code of '
  DQ: WideString = #34; // code of "
{$ENDIF NEXTGEN}
begin
  if ( (Prefix = 'xmlns') and (Uri <> 'http://www.w3.org/2000/xmlns/') )
    or ( (Prefix <> '') and not isXmlPrefix(Prefix) ) then begin
    XmlErrorType := ET_INVALID_PREFIX;
    Flaw := Prefix;
    Clue := '';
//  end else if not IsUriURI_referenceWideStr(Uri) then begin
  end else if not IsUriURI_referenceStr(Uri) then begin
    XmlErrorType := ET_INVALID_NAMESPACE_URI;
    Flaw := Uri;
    Clue := '';
  end else begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end;
end;

function TXmlStartPrefixMappingSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlStartPrefixMappingSignal(Result).Prefix := Prefix;
  TXmlStartPrefixMappingSignal(Result).Uri := Uri;
end;

function TXmlStartPrefixMappingSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc];
end;

{ TXmlCommentSignal }

{$IFDEF NEXTGEN}
procedure TXmlCommentSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                out Flaw,
                                                    Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlCommentSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                out Flaw,
                                                    Clue: WideString);
{$ENDIF NEXTGEN}
const
  HYPHEN: WideChar = #$2D; // Flaw of -
begin
  if Data <> '' then begin
{$IFDEF NEXTGEN}
    if Pos(string('--'), Data) > 0 then begin
{$ELSE !NEXTGEN}
    if Pos(AnsiString('--'), Data) > 0 then begin
{$ENDIF NEXTGEN}
      XmlErrorType := ET_DOUBLE_HYPHEN_IN_COMMENT;
      Flaw := '--';
      Clue := '-';
      Exit;
    end else if Data[Length(Data)-AdjustIndex] = HYPHEN then begin
      XmlErrorType := ET_HYPHEN_AT_COMMENT_END;
      Flaw := '-';
      Clue := '';
      Exit;
    end else if not IsXmlChars(Data) then begin
      XmlErrorType := ET_INVALID_CHARACTER;
      Flaw := Data;                                                       
      Clue := '';
      Exit;
    end;
  end;
  XmlErrorType := ET_NONE;
  Flaw := '';
  Clue := '';
end;

function TXmlCommentSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlCommentSignal(Result).Data := Data;
end;

function TXmlCommentSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc, ssDtd];
end;

{ TXmlProcessingInstructionSignal }

{$IFDEF NEXTGEN}
procedure TXmlProcessingInstructionSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                              out Flaw,
                                                                  Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlProcessingInstructionSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                              out Flaw,
                                                                  Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlPITarget(Target) then begin
    XmlErrorType := ET_INVALID_PROCESSING_INSTRUCTION;
    Flaw := Target;
    Clue := '';
{$IFDEF NEXTGEN}
  end else if Pos(string('?>'), Data) > 0 then begin
{$ELSE !NEXTGEN}
  end else if Pos(AnsiString('?>'), Data) > 0 then begin
{$ENDIF NEXTGEN}
    XmlErrorType := ET_INVALID_PROCESSING_INSTRUCTION;
    Flaw := '?>';
    Clue := '';
  end else if not IsXmlChars(Data) then begin
    XmlErrorType := ET_INVALID_CHARACTER;
    Flaw := Data;                                                        
    Clue := '';
  end else begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end;
end;

function TXmlProcessingInstructionSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlProcessingInstructionSignal(Result).Data := Data;
  TXmlProcessingInstructionSignal(Result).Target := Target;
end;

function TXmlProcessingInstructionSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDoc, ssDtd];
end;

{ TXmlAttributeDefinitionSignal }

{$IFDEF NEXTGEN}
procedure TXmlAttributeDefinitionSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                            out Flaw,
                                                                Clue: string);
var
  CharacRef: string;
  I: Integer;
  InEntityRef: Boolean;
  Text: string;
  V: string;
{$ELSE !NEXTGEN}
procedure TXmlAttributeDefinitionSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                            out Flaw,
                                                                Clue: WideString);
var
  CharacRef: WideString;
  I: Integer;
  InEntityRef: Boolean;
  Text: WideString;
  V: WideString;
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(AttributeName) then begin
    XmlErrorType := ET_INVALID_ATTRIBUTE_NAME_IN_ATTRIBUTE_DECL;
    Flaw := AttributeName;
    Clue := '';
    Exit;
  end;

  if not IsXmlName(ElementName) then begin
    XmlErrorType := ET_INVALID_ELEMENT_NAME_IN_ATTRIBUTE_DECL;
    Flaw := ElementName;
    Clue := '';
    Exit;
  end;

  if AttributeType = AS_NOTATION_DATATYPE then begin
    for I := 0 to Pred(Enumeration.Count) do
      if not IsXmlName(Enumeration[I]) then begin
        XmlErrorType := ET_INVALID_NOTATION_TOKEN_IN_ATTRIBUTE_DECL;
        Flaw := Enumeration[I];
        Clue := '';
        Exit;
      end;
  end else begin
    for I := 0 to Pred(Enumeration.Count) do
      if not IsXmlNmtoken(Enumeration[I]) then begin
        XmlErrorType := ET_INVALID_ENUMERATION_TOKEN_IN_ATTRIBUTE_DECL;
        Flaw := Enumeration[I];
        Clue := '';
        Exit;
      end;
  end;

  // Check default value:
  InEntityRef := False;
  Text := '';
  for I := FirstIndex to Length(DefaultValue)-AdjustIndex do begin
    if InEntityRef then begin
      if DefaultValue[I] = ';' then begin
        if Text[FirstIndex] = '#' then begin // CharRef
          try
{$IFDEF NEXTGEN}
            CharacRef := Concat(string('&'), Text, string(';'));
{$ELSE !NEXTGEN}
            CharacRef := Concat(WideString('&'), Text, WideString(';'));
{$ENDIF NEXTGEN}
            V := XmlCharRefToStr(CharacRef);
          except
            on EConvertError do begin
              XmlErrorType := ET_INVALID_CHAR_REF;
              Flaw := CharacRef;
              Clue := '';
              Exit;
            end;
          end; {try}
        end else begin  // EntityRef
          if not IsXmlName(Text) then begin
            XmlErrorType := ET_INVALID_ENTITY_NAME;
            Flaw := Text;
            Clue := '';
            Exit;
          end;
        end;
        Text := '';
        InEntityRef := False;
      end else
{$IFDEF NEXTGEN}
        Text:= Concat(Text, string(DefaultValue[I]));
{$ELSE !NEXTGEN}
        Text:= Concat(Text, WideString(DefaultValue[I]));
{$ENDIF NEXTGEN}
    end else begin
      if DefaultValue[I] = '&' then begin
        InEntityRef := True;
      end else if (DefaultValue[I] = '<') then begin
        // WFC: No < in Attribute Values (XML 1.0, § 3.3.2), etc.
        XmlErrorType := ET_LT_IN_ATTRIBUTE_VALUE;
        Flaw := DefaultValue[I];
        Clue := '';
        Exit;
      end else if not IsXmlChar(DefaultValue[I]) then begin
        XmlErrorType := ET_INVALID_ATTRIBUTE_VALUE;
        Flaw := DefaultValue[I];
        Clue := '';
        Exit;
      end;
    end; {if ...}
  end; {for ...}

  if InEntityRef then begin
    if Length(Text) > 0 then begin
      if Text[FirstIndex] = '#' then
        XmlErrorType := ET_UNCLOSED_CHAR_REF
      else
        XmlErrorType := ET_UNCLOSED_ENTITY_REF;
    end else
      XmlErrorType := ET_UNCLOSED_ENTITY_REF;
    Flaw := DefaultValue;
    Clue := '';
    Exit;
  end; {if ...}

  XmlErrorType := ET_NONE;
  Flaw := '';
  Clue := '';
end;

function TXmlAttributeDefinitionSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlAttributeDefinitionSignal(Result).AttributeName := AttributeName;
  TXmlAttributeDefinitionSignal(Result).AttributeType := AttributeType;
  TXmlAttributeDefinitionSignal(Result).Constraint := Constraint;
  TXmlAttributeDefinitionSignal(Result).DefaultValue := DefaultValue;
  TXmlAttributeDefinitionSignal(Result).ElementName := ElementName;
  TXmlAttributeDefinitionSignal(Result).Enumeration := Enumeration;
  TXmlAttributeDefinitionSignal(Result).IsDeclaredInPE := IsDeclaredInPE;
end;

destructor TXmlAttributeDefinitionSignal.Destroy;
begin
  FEnumeration.Free;
  inherited;
end;

procedure TXmlAttributeDefinitionSignal.InitSignal(const AReader: TXmlCustomReader;
                                                   const AStartByteNumber,
                                                         AStartCharNumber,
                                                         AStartColumnNumber,
                                                         AStartLineNumber,
                                                         AStartTabsInLine,
                                                         AEndByteNumber,
                                                         AEndCharNumber,
                                                         AEndColumnNumber,
                                                         AEndLineNumber,
                                                         AEndTabsInLine: Int64;
{$IFDEF NEXTGEN}
                                                   const AUri: string;
{$ELSE !NEXTGEN}
                                                   const AUri: WideString;
{$ENDIF NEXTGEN}
                                                   const ARelatedDtdObject: TDtdObject;
                                                   const ARelatedNode: TDomNode);
begin
  inherited;
  if not Assigned(FEnumeration) then
    FEnumeration := TUtilsWideStringList.Create;
end;

function TXmlAttributeDefinitionSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;

procedure TXmlAttributeDefinitionSignal.SetEnumeration(const Value: TUtilsWideStringList);
begin
  FEnumeration.Assign(Value);
end;

{ TXmlElementTypeDeclarationSignal }

{$IFDEF NEXTGEN}
procedure TXmlElementTypeDeclarationSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                               out Flaw,
                                                                   Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlElementTypeDeclarationSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                               out Flaw,
                                                                   Clue: WideString);
{$ENDIF NEXTGEN}
  type
    TXmlParsedElementCMTokenType = (
      DTD_PECM_CHOICE_TOKEN,
      DTD_PECM_CHOICE_NAME_TOKEN,
      DTD_PECM_CLOSING_BRACKET_TOKEN,
      DTD_PECM_END_TOKEN,
      DTD_PECM_FREQUENCY_TOKEN,
      DTD_PECM_NAME_TOKEN,
      DTD_PECM_OPENING_BRACKET_TOKEN,
      DTD_PECM_PCDATA_TOKEN,
      DTD_PECM_PCDATA_CHOICE_TOKEN,
      DTD_PECM_PCDATA_NAME_BRACKET_TOKEN,
      DTD_PECM_PCDATA_NAME_TOKEN,
      DTD_PECM_PCDATA_ONLY_BRACKET_TOKEN,
      DTD_PECM_START_TOKEN,
      DTD_PECM_SEQUENCE_TOKEN,
      DTD_PECM_SEQUENCE_NAME_TOKEN
    );

  function ReplacePrecedingBracket(const Stack: TStack<TXmlParsedElementCMTokenType>): TXmlErrorType;
  // Replaces a preceding bracket, if any.
  begin
    Result := ET_NONE;
    if TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_CLOSING_BRACKET_TOKEN then begin
      // Completely remove the last bracket ...
      repeat
        Stack.Pop;
      until TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_OPENING_BRACKET_TOKEN;
      Stack.Pop;
      // ... and replace it with an appropriate faked element name token:
      case TXmlParsedElementCMTokenType(Stack.Peek) of
        DTD_PECM_OPENING_BRACKET_TOKEN:
          Stack.Push(DTD_PECM_NAME_TOKEN);
        DTD_PECM_CHOICE_TOKEN:
          Stack.Push(DTD_PECM_CHOICE_NAME_TOKEN);
        DTD_PECM_SEQUENCE_TOKEN:
          Stack.Push(DTD_PECM_SEQUENCE_NAME_TOKEN);
      else
        Result := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
      end;
    end;
  end;

var
  Tokenizer: TXmlElementCMTokenizer;
  Stack: TStack<TXmlParsedElementCMTokenType>;//TStack;
begin
  // Check element name:
  if not IsXmlName(ElementName) then begin
    XmlErrorType := ET_INVALID_ELEMENT_NAME_IN_ELEMENT_DECL;
    Flaw := ElementName;
    Clue := '';
    Exit;
  end;

  // Check content model:
  XmlErrorType := ET_NONE;
  Flaw := '';
  Clue := '';
  Stack := TStack<TXmlParsedElementCMTokenType>.Create;
  try
    Tokenizer := TXmlElementCMTokenizer.Create(Data);
    try
      while True do begin

        case Tokenizer.TokenType of
          DTD_ECM_START_OF_SOURCE_TOKEN: begin
            // Initialize the stack:
            Stack.Push(DTD_PECM_START_TOKEN);
          end;

          DTD_ECM_ANY_KEYWORD_TOKEN:
            if TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_START_TOKEN then begin
              Stack.Push(DTD_PECM_END_TOKEN);
            end else begin
              XmlErrorType := ET_KEYWORD_ANY_NOT_ALLOWED;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;

          DTD_ECM_EMPTY_KEYWORD_TOKEN:
            if TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_START_TOKEN then begin
              Stack.Push(DTD_PECM_END_TOKEN);
            end else begin
              XmlErrorType := ET_KEYWORD_EMPTY_NOT_ALLOWED;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;

          DTD_ECM_PCDATA_KEYWORD_TOKEN:
            if TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_OPENING_BRACKET_TOKEN then begin
              Stack.Push(DTD_PECM_PCDATA_TOKEN);
            end else begin
              XmlErrorType := ET_KEYWORD_PCDATA_NOT_ALLOWED;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;

          DTD_ECM_OPENING_BRACKET_TOKEN:
            if TXmlParsedElementCMTokenType(Stack.Peek)
                 in [ DTD_PECM_CHOICE_TOKEN,
                      DTD_PECM_OPENING_BRACKET_TOKEN,
                      DTD_PECM_START_TOKEN,
                      DTD_PECM_SEQUENCE_TOKEN ]

            then begin
              Stack.Push(DTD_PECM_OPENING_BRACKET_TOKEN);
            end else begin
              XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;

          DTD_ECM_CLOSING_BRACKET_TOKEN: begin
            if TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_FREQUENCY_TOKEN then
              Stack.Pop;  // Pop optional preceding frequency operator.

            if TXmlParsedElementCMTokenType(Stack.Peek)
                 in [ DTD_PECM_CHOICE_TOKEN,
                      DTD_PECM_END_TOKEN,
                      DTD_PECM_OPENING_BRACKET_TOKEN,
                      DTD_PECM_PCDATA_CHOICE_TOKEN,
                      DTD_PECM_PCDATA_NAME_BRACKET_TOKEN,
                      DTD_PECM_PCDATA_ONLY_BRACKET_TOKEN,
                      DTD_PECM_START_TOKEN,
                      DTD_PECM_SEQUENCE_TOKEN ]
            then begin
              XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;

            if ReplacePrecedingBracket(Stack) <> ET_NONE then begin
              XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;

            case TXmlParsedElementCMTokenType(Stack.Peek) of
              DTD_PECM_PCDATA_TOKEN:
                Stack.Push(DTD_PECM_PCDATA_ONLY_BRACKET_TOKEN);
              DTD_PECM_PCDATA_NAME_TOKEN:
                Stack.Push(DTD_PECM_PCDATA_NAME_BRACKET_TOKEN);
            else
              Stack.Push(DTD_PECM_CLOSING_BRACKET_TOKEN);
            end;
          end;

          DTD_ECM_NAME_TOKEN:
            case TXmlParsedElementCMTokenType(Stack.Peek) of
              DTD_PECM_CHOICE_TOKEN:
                Stack.Push(DTD_PECM_CHOICE_NAME_TOKEN);
              DTD_PECM_OPENING_BRACKET_TOKEN:
                Stack.Push(DTD_PECM_NAME_TOKEN);
              DTD_PECM_PCDATA_CHOICE_TOKEN:
                Stack.Push(DTD_PECM_PCDATA_NAME_TOKEN);
              DTD_PECM_SEQUENCE_TOKEN:
                Stack.Push(DTD_PECM_SEQUENCE_NAME_TOKEN);
            else
              XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;

          DTD_ECM_SEPARATOR_TOKEN: begin
            if TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_FREQUENCY_TOKEN then
              Stack.Pop;  // Pop optional preceding frequency operator.
            if ReplacePrecedingBracket(Stack) <> ET_NONE then begin
              XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;
            if Tokenizer.TokenValue = ',' then begin
              case TXmlParsedElementCMTokenType(Stack.Peek) of
                DTD_PECM_NAME_TOKEN, DTD_PECM_SEQUENCE_NAME_TOKEN:
                  Stack.Push(DTD_PECM_SEQUENCE_TOKEN);
              else
                XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
                Flaw := Tokenizer.TokenValue;
                Clue := '';
                Exit;
              end;
            end else begin  // Tokenizer.TokenValue = '|'
              case TXmlParsedElementCMTokenType(Stack.Peek) of
                DTD_PECM_NAME_TOKEN,
                DTD_PECM_CHOICE_NAME_TOKEN:
                  Stack.Push(DTD_PECM_CHOICE_TOKEN);
                DTD_PECM_PCDATA_TOKEN,
                DTD_PECM_PCDATA_NAME_TOKEN,
                DTD_PECM_PCDATA_CHOICE_TOKEN:
                  Stack.Push(DTD_PECM_PCDATA_CHOICE_TOKEN);
              else
                XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
                Flaw := Tokenizer.TokenValue;
                Clue := '';
                Exit;
              end;
            end;
          end;

          DTD_ECM_FREQUENCY_TOKEN:
            case TXmlParsedElementCMTokenType(Stack.Peek) of
              DTD_PECM_CHOICE_NAME_TOKEN,
              DTD_PECM_CLOSING_BRACKET_TOKEN,
              DTD_PECM_NAME_TOKEN,
              DTD_PECM_SEQUENCE_NAME_TOKEN:
                Stack.Push(DTD_PECM_FREQUENCY_TOKEN);
              DTD_PECM_PCDATA_NAME_BRACKET_TOKEN,
              DTD_PECM_PCDATA_ONLY_BRACKET_TOKEN:
                if Tokenizer.TokenValue = '*' then begin
                  Stack.Push(DTD_PECM_END_TOKEN);
                end else begin
                  XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
                  Flaw := Tokenizer.TokenValue;
                  Clue := '';
                  Exit;
                end;
            else
              XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
              Flaw := Tokenizer.TokenValue;
              Clue := '';
              Exit;
            end;

          DTD_ECM_END_OF_SOURCE_TOKEN: begin
            if not ( TXmlParsedElementCMTokenType(Stack.Peek)
                       in [ DTD_PECM_END_TOKEN,
                            DTD_PECM_PCDATA_ONLY_BRACKET_TOKEN ] )

            then begin
              if TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_FREQUENCY_TOKEN then
                Stack.Pop;  // Pop optional preceding frequency operator.
              if TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_CLOSING_BRACKET_TOKEN then begin
                // Completely remove the last bracket ...
                repeat
                  Stack.Pop;
                until TXmlParsedElementCMTokenType(Stack.Peek) = DTD_PECM_OPENING_BRACKET_TOKEN;
                Stack.Pop;
                // ... and check whether something remains on the stack:
                if TXmlParsedElementCMTokenType(Stack.Peek) <> DTD_PECM_START_TOKEN then begin
                  XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
                  Flaw := Tokenizer.TokenValue;
                  Clue := '';
                  Exit;
                end;
              end else begin
                XmlErrorType := ET_MALFORMED_CONTENT_MODEL_IN_ELEMENT_DECL;
                Flaw := Tokenizer.TokenValue;
                Clue := '';
                Exit;
              end;
            end;
            Exit;
          end;

        end; {case ...}

        Tokenizer.Next;

        if Tokenizer.ErrorType in ET_FATAL_ERRORS then begin
          XmlErrorType := Tokenizer.ErrorType;
          Flaw := Tokenizer.TokenValue;
          Clue := Tokenizer.Clue;
          Exit;
        end;

      end; {while ...}
    finally
      Tokenizer.Free;
    end;
  finally
    Stack.Free;
  end;
end;

function TXmlElementTypeDeclarationSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlElementTypeDeclarationSignal(Result).Data := Data;
  TXmlElementTypeDeclarationSignal(Result).ElementName := ElementName;
  TXmlElementTypeDeclarationSignal(Result).IsDeclaredInPE := IsDeclaredInPE;
end;

function TXmlElementTypeDeclarationSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;

{ TXmlEntityDeclarationSignal }

{$IFDEF NEXTGEN}
procedure TXmlEntityDeclarationSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                          out Flaw,
                                                              Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlEntityDeclarationSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                          out Flaw,
                                                              Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(EntityName) then begin
    XmlErrorType := ET_INVALID_ENTITY_NAME_IN_ENTITY_DECL;
    Flaw := EntityName;
    Clue := '';
    Exit;
  end;
  if EntityValue <> '' then begin
    if not IsXmlEntityValueChars(EntityValue) then begin
      XmlErrorType := ET_INVALID_ENTITY_VALUE_IN_ENTITY_DECL;
      Flaw := EntityValue;
      Clue := '';
      Exit;
    end;
    if not ( (PublicId = '') and
             (SystemId = '') and
             (NotationName = '') ) then begin
      XmlErrorType := ET_MISSING_ENTITY_VALUE_IN_ENTITY_DECL;
      Flaw := '';
      Clue := '';
      Exit;
    end;
  end;
  if not IsXmlSystemChars(SystemId) then begin
    XmlErrorType := ET_INVALID_SYSTEM_LITERAL;
    Flaw := SystemId;
    Clue := '';
    Exit;
  end;
  if not IsXmlPubidChars(PublicId) then begin
    XmlErrorType := ET_INVALID_PUBID_LITERAL;
    Flaw := PublicId;
    Clue := '';
    Exit;
  end;
  if (NotationName <> '') and (not IsXmlName(NotationName)) then begin
    XmlErrorType := ET_INVALID_NOTATION_NAME_IN_ENTITY_DECL;
    Flaw := NotationName;
    Clue := '';
    Exit;
  end;

  XmlErrorType := ET_NONE;
  Flaw := '';
  Clue := '';
end;

function TXmlEntityDeclarationSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlEntityDeclarationSignal(Result).BaseUri := BaseUri;
  TXmlEntityDeclarationSignal(Result).EntityName := EntityName;
  TXmlEntityDeclarationSignal(Result).EntityValue := EntityValue;
  TXmlEntityDeclarationSignal(Result).IsDeclaredInPE := IsDeclaredInPE;
  TXmlEntityDeclarationSignal(Result).NotationName := NotationName;
  TXmlEntityDeclarationSignal(Result).PublicId := PublicId;
  TXmlEntityDeclarationSignal(Result).SystemId := SystemId;
end;

function TXmlEntityDeclarationSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;

{ TXmlExternalPEReferenceSignal }

{$IFDEF NEXTGEN}
procedure TXmlExternalPEReferenceSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                            out Flaw, Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlExternalPEReferenceSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                            out Flaw, Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if IsXmlName(ParameterEntityName) then begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end else begin
    XmlErrorType := ET_INVALID_PARAMETER_ENTITY_NAME;
    Flaw := ParameterEntityName;
    Clue := '';
  end;
end;

function TXmlExternalPEReferenceSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlExternalPEReferenceSignal(Result).ParameterEntityName := ParameterEntityName;
end;

function TXmlExternalPEReferenceSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;

{ TXmlNotationDeclarationSignal }

{$IFDEF NEXTGEN}
procedure TXmlNotationDeclarationSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                            out Flaw,
                                                                Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlNotationDeclarationSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                            out Flaw,
                                                                Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(NotationName) then begin
    XmlErrorType := ET_INVALID_NOTATION_NAME_IN_NOTATION_DECL;
    Flaw := NotationName;
    Clue := '';
  end else if not IsXmlSystemChars(SystemId) then begin
    XmlErrorType := ET_INVALID_SYSTEM_LITERAL;
    Flaw := SystemId;
    Clue := '';
  end else if not IsXmlPubidChars(PublicId) then begin
    XmlErrorType := ET_INVALID_PUBID_LITERAL;
    Flaw := PublicId;
    Clue := '';
  end else begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end;
end;

function TXmlNotationDeclarationSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlNotationDeclarationSignal(Result).IsDeclaredInPE := IsDeclaredInPE;
  TXmlNotationDeclarationSignal(Result).NotationName := NotationName;
  TXmlNotationDeclarationSignal(Result).PublicId := PublicId;
  TXmlNotationDeclarationSignal(Result).SystemId := SystemId;
end;

function TXmlNotationDeclarationSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;

{ TXmlParameterEntityDeclarationSignal }

{$IFDEF NEXTGEN}
procedure TXmlParameterEntityDeclarationSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                                   out Flaw,
                                                                       Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlParameterEntityDeclarationSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                                   out Flaw,
                                                                       Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if not IsXmlName(EntityName) then begin
    XmlErrorType := ET_INVALID_ENTITY_NAME_IN_PARAMETER_ENTITY_DECL;
    Flaw := EntityName;
    Clue := '';
    Exit;
  end;
  if EntityValue <> '' then begin
    if not IsXmlEntityValueChars(EntityValue) then begin
      XmlErrorType := ET_INVALID_ENTITY_VALUE_IN_PARAMETER_ENTITY_DECL;
      Flaw := EntityValue;
      Clue := '';
      Exit;
    end;
    if not ( (PublicId = '') and
             (SystemId = '') ) then begin
      XmlErrorType := ET_MISSING_ENTITY_VALUE_IN_PARAMETER_ENTITY_DECL;
      Flaw := '';
      Clue := '';
      Exit;
    end;
  end;
  if not IsXmlSystemChars(SystemId) then begin
    XmlErrorType := ET_INVALID_SYSTEM_LITERAL;
    Flaw := SystemId;
    Clue := '';
    Exit;
  end;
  if not IsXmlPubidChars(PublicId) then begin
    XmlErrorType := ET_INVALID_PUBID_LITERAL;
    Flaw := PublicId;
    Clue := '';
    Exit;
  end;

  XmlErrorType := ET_NONE;
  Flaw := '';
  Clue := '';
end;

function TXmlParameterEntityDeclarationSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlParameterEntityDeclarationSignal(Result).BaseUri := BaseUri;
  TXmlParameterEntityDeclarationSignal(Result).EntityName := EntityName;
  TXmlParameterEntityDeclarationSignal(Result).EntityValue := EntityValue;
  TXmlParameterEntityDeclarationSignal(Result).PublicId := PublicId;
  TXmlParameterEntityDeclarationSignal(Result).SystemId := SystemId;
end;

function TXmlParameterEntityDeclarationSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;

{ TXmlPEReferenceFoundSignal }

function TXmlPEReferenceFoundSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;

{ TXmlStartExtDtdSignal }

{$IFDEF NEXTGEN}
procedure TXmlStartExtDtdSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                    out Flaw,
                                                        Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlStartExtDtdSignal.CheckWellformedness(out XmlErrorType: TXmlErrorType;
                                                    out Flaw,
                                                        Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if not ( IsXmlEncName(EncodingName) or (EncodingName = '') ) then begin
    XmlErrorType := ET_INVALID_ENCODING_NAME;
    Flaw := '';
    Clue := '';
  end else

  if not ( IsXmlVersionNum(Version) or (Version = '') ) then begin
    XmlErrorType := ET_INVALID_VERSION_NUMBER;
    Flaw := '';
    Clue := '';

  end else begin
    XmlErrorType := ET_NONE;
    Flaw := '';
    Clue := '';
  end;
end;

function TXmlStartExtDtdSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlStartExtDtdSignal(Result).EncodingName := EncodingName;
  TXmlStartExtDtdSignal(Result).InputEncoding := InputEncoding;
  TXmlStartExtDtdSignal(Result).PublicId := PublicId;
  TXmlStartExtDtdSignal(Result).SystemId := SystemId;
  TXmlStartExtDtdSignal(Result).Version := Version;
end;

function TXmlStartExtDtdSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;

{ TXmlStartIntDtdSignal }

function TXmlStartIntDtdSignal.CloneSignal(const AReader: TXmlCustomReader): TXmlSignal;
begin
  Result := inherited CloneSignal(AReader);
  TXmlStartIntDtdSignal(Result).SystemId := SystemId;
  TXmlStartIntDtdSignal(Result).XmlStandalone := XmlStandalone;
end;

function TXmlStartIntDtdSignal.Scope: TXmlSignalScope;
begin
  Result := [ssDtd];
end;



// ++++++++++++++++++++++++++++ TXmlCustomHandler ++++++++++++++++++++++++++++
{$IFDEF NEXTGEN}
procedure TXmlCustomHandler.SendErrorNotification(const Target: TXmlCustomReader;
                                                  const XmlErrorType: TXmlErrorType;
                                                  const Location: IDomLocator;
                                                  const Code,
                                                        Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlCustomHandler.SendErrorNotification(const Target: TXmlCustomReader;
                                                  const XmlErrorType: TXmlErrorType;
                                                  const Location: IDomLocator;
                                                  const Code,
                                                        Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if Assigned(Target) then begin
    Target.SendErrorNotification(XmlErrorType, Location, Code, Clue);
  end else if XmlErrorType in ET_FATAL_ERRORS then begin
    raise EParserException.Create('Signal Processing Exception');
  end;
end;



// +++++++++++++++++++++++++++ TXmlStandardHandler +++++++++++++++++++++++++++
procedure TXmlStandardHandler.Notification(AComponent: TComponent;
                                           Operation: TOperation);
begin
  inherited Notification(AComponent, Operation);
  if (Operation = opRemove) and (AComponent = FNextHandler)
    then FNextHandler := nil;
end;

procedure TXmlStandardHandler.ProcessSignal(const Signal: TXmlSignal);
var
  Accept: Boolean;
begin
  Accept := True;
  if Assigned(FOnSignal) then
    FOnSignal(Self, Signal, Accept);
  if Accept and Assigned(NextHandler) then
    NextHandler.ProcessSignal(Signal);
  if Assigned(FOnSignaled) then
    FOnSignaled(Self, Signal);
end;



// +++++++++++++++++++++++++++++ TXmlHandlerItem +++++++++++++++++++++++++++++
function TXmlHandlerItem.GetXmlHandler: TXmlCustomHandler;
begin
  Result := FXmlHandler;
end;

procedure TXmlHandlerItem.SetXmlHandler(Value: TXmlCustomHandler);
begin
  FXmlHandler := Value;
end;

procedure TXmlHandlerItem.Assign(Source: TPersistent);
begin
  if Source is TXmlHandlerItem
    then XmlHandler := TXmlHandlerItem(Source).XmlHandler
    else inherited Assign(Source);
end;


// +++++++++++++++++++++++++++++++ TXmlHandlers ++++++++++++++++++++++++++++++
constructor TXmlHandlers.Create(Distributor: TXmlDistributor);
begin
  inherited Create(TXmlHandlerItem);
  FDistributor := Distributor;
end;

function TXmlHandlers.GetItem(Index: Integer): TXmlHandlerItem;
begin
  Result := TXmlHandlerItem(inherited GetItem(Index));
end;

procedure TXmlHandlers.SetItem(Index: Integer; Value: TXmlHandlerItem);
begin
  inherited SetItem(Index, Value);
end;

function TXmlHandlers.GetOwner: TPersistent;
begin
  Result := FDistributor;
end;

function TXmlHandlers.Add: TXmlHandlerItem;
begin
  Result := TXmlHandlerItem(inherited Add);
end;

procedure TXmlHandlers.Assign(Source: TPersistent);
var
  I : Integer;
begin
  if Source = Self then Exit;
  if Source is TStrings then begin
    Clear;
    for I := 0 to Pred(TStrings(Source).Count) do
      if Assigned(TStrings(Source).Objects[I]) then
        if TStrings(Source).Objects[I] is TXmlCustomHandler then
          Self.Add.XmlHandler := TXmlCustomHandler(TStrings(Source).Objects[I]);
  end else inherited Assign(Source);
end;

function TXmlHandlers.FindHandlerItem(AHandler: TXmlCustomHandler): TXmlHandlerItem;
var
  I: Integer;
begin
  for I := 0 to Pred(Count) do
  begin
    Result := TXmlHandlerItem(inherited GetItem(I));
    if Result.FXmlHandler = AHandler then Exit;
  end;
  Result := nil;
end;



// +++++++++++++++++++++++++++++ TXmlDistributor +++++++++++++++++++++++++++++
constructor TXmlDistributor.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FDisableCount := 0;
  FNextHandlers := TXmlHandlers.Create(Self);
end;

destructor TXmlDistributor.Destroy;
begin
  FNextHandlers.Free;
  inherited Destroy;
end;

procedure TXmlDistributor.DefineProperties(Filer: TFiler);
begin
  inherited DefineProperties(Filer);
  // Advice the Filer to read or write the NextHandlers collection as if it
  // were a property:
  Filer.DefineProperty('NextHandlers', ReadData, WriteData, True);
end;

procedure TXmlDistributor.Notification(AComponent: TComponent;
                                       Operation: TOperation);
var
  HandlerItem: TXmlHandlerItem;
begin
  inherited Notification(AComponent, Operation);
  if not (csDestroying in ComponentState) and (Operation = opRemove) then begin
    if (AComponent is TXmlCustomHandler) then  begin
      HandlerItem := NextHandlers.FindHandlerItem(TXmlCustomHandler(AComponent));
      if HandlerItem <> nil then HandlerItem.XmlHandler := nil;
    end;
  end;
end;

procedure TXmlDistributor.ProcessSignal(const Signal: TXmlSignal);
var
  I: Integer;
  Ok: Boolean;
  SignalCopy: TXmlSignal;
begin
  OK := True;
  for I := 0 to Pred(NextHandlers.Count) do begin
    if not Assigned(NextHandlers.Items[I].XmlHandler) then Continue;
    SignalCopy := Signal.CloneSignal(Signal.Reader);  // We use a copy of the signal,
    try                                               // because subsequent Signal Handlers
      NextHandlers.Items[I].XmlHandler.ProcessSignal(SignalCopy);  // might change the signal's properties.
    except
      Ok := False;
    end;
    SignalCopy.Free;
  end;
  if not Ok then
    raise EParserException.Create('Signal Processing Exception');
end;

procedure TXmlDistributor.ReadData(Reader: TReader);
begin
  Reader.ReadCollection(NextHandlers);
end;

procedure TXmlDistributor.SetNextHandlers(const Value: TXmlHandlers);
begin
  FNextHandlers.Assign(Value);
end;

procedure TXmlDistributor.WriteData(Writer: TWriter);
begin
  Writer.WriteCollection(NextHandlers);
end;



// +++++++++++++++++++++++ TXmlWFTestHandler +++++++++++++++++++++++
constructor TXmlWFTestHandler.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FActivityStatus := asInactive;
  FDoctypeFound := False;
  FPrefixStack := TUtilsWideStringList.Create;
  FRootProcessingStatus := rsBeforeRoot;
  FTagStack := TUtilsWideStringList.Create;
end;

destructor TXmlWFTestHandler.Destroy;
begin
  FPrefixStack.Free;
  FTagStack.Free;
  inherited Destroy;
end;

procedure TXmlWFTestHandler.ProcessSignal(const Signal: TXmlSignal);

{$IFDEF NEXTGEN}
  procedure CheckDoctypeSignal(const DoctypeSignal: TXmlDoctypeSignal;
                                 var AXmlErrorType:  TXmlErrorType;
                                 var AFlaw: string);
{$ELSE !NEXTGEN}
  procedure CheckDoctypeSignal(const DoctypeSignal: TXmlDoctypeSignal;
                                 var AXmlErrorType:  TXmlErrorType;
                                 var AFlaw: WideString);
{$ENDIF NEXTGEN}
  begin
    if FDoctypeFound then begin
      AXmlErrorType := ET_DOUBLE_DOCTYPE;
      AFlaw := DoctypeSignal.DoctypeName;
    end else begin;
      FDoctypeFound := True;
      if FRootProcessingStatus <> rsBeforeRoot then begin
        AXmlErrorType := ET_WRONG_ORDER;
        AFlaw := DoctypeSignal.DoctypeName;
      end;
    end;
  end;

{$IFDEF NEXTGEN}
  procedure CheckEndElementSignal(const EndElementSignal: TXmlEndElementSignal;
                                    var AXmlErrorType:  TXmlErrorType;
                                    var AFlaw: string);
{$ELSE !NEXTGEN}
  procedure CheckEndElementSignal(const EndElementSignal: TXmlEndElementSignal;
                                    var AXmlErrorType:  TXmlErrorType;
                                    var AFlaw: WideString);
{$ENDIF NEXTGEN}
  var
    LastItemIndex: Integer;
  begin
    LastItemIndex := Pred(FTagStack.Count);
    if LastItemIndex = -1 then begin
      AXmlErrorType := ET_MISSING_START_TAG;
      AFlaw := EndElementSignal.TagName;
    end else begin
      if FTagStack[LastItemIndex] = EndElementSignal.TagName then begin
        FTagStack.Delete(LastItemIndex);
        if LastItemIndex = 0 then
          FRootProcessingStatus := rsAfterRoot;
      end else begin
        AXmlErrorType := ET_MISSING_START_TAG;
        AFlaw := EndElementSignal.TagName;
      end;
    end;
  end;

{$IFDEF NEXTGEN}
  procedure CheckEndPrefixMappingSignal(const EndPrefixMappingSignal: TXmlEndPrefixMappingSignal;
                                          var AXmlErrorType:  TXmlErrorType;
                                          var AFlaw: string);
{$ELSE !NEXTGEN}
  procedure CheckEndPrefixMappingSignal(const EndPrefixMappingSignal: TXmlEndPrefixMappingSignal;
                                          var AXmlErrorType:  TXmlErrorType;
                                          var AFlaw: WideString);
{$ENDIF NEXTGEN}
  var
    L: Integer;
  begin
    L := Pred(FPrefixStack.Count);
    if L = -1 then begin
      AXmlErrorType := ET_WRONG_PREFIX_MAPPING_NESTING;
      AFlaw := EndPrefixMappingSignal.Prefix;
    end else begin
      if FPrefixStack[L] <> EndPrefixMappingSignal.Prefix then begin
        AXmlErrorType := ET_WRONG_PREFIX_MAPPING_NESTING;
        AFlaw := EndPrefixMappingSignal.Prefix;
      end else
        FPrefixStack.Delete(L);
    end;
  end;

{$IFDEF NEXTGEN}
  function LastOpenTag: string;
{$ELSE !NEXTGEN}
  function LastOpenTag: WideString;
{$ENDIF NEXTGEN}
  var
    LastItemIndex: Integer;
  begin
    LastItemIndex := Pred(FTagStack.Count);
    if LastItemIndex = -1
      then Result := ''
      else Result := FTagStack[LastItemIndex];
  end;

var
{$IFDEF NEXTGEN}
  Flaw, Clue: string;
{$ELSE !NEXTGEN}
  Flaw, Clue: WideString;
{$ENDIF NEXTGEN}
  XmlErrorType: TXmlErrorType;
begin
  XmlErrorType := ET_NONE;
  Flaw := '';
  Clue := '';

  case FActivityStatus of

    asDocActive: begin

      if Signal is TXmlCDATASignal then begin
        if FRootProcessingStatus <> rsInRoot then begin
          XmlErrorType := ET_NOT_IN_ROOT_ELEMENT;
          Flaw := TXmlCDATASignal(Signal).Data;
        end;
      end else

      if Signal is TXmlDoctypeSignal then begin
        CheckDoctypeSignal(TXmlDoctypeSignal(Signal), XmlErrorType, Flaw);
      end else

      if Signal is TXmlEndElementSignal then begin
        CheckEndElementSignal(TXmlEndElementSignal(Signal), XmlErrorType, Flaw);
      end else

      if Signal is TXmlEntityRefSignal then begin
        if FRootProcessingStatus <> rsInRoot then begin
          XmlErrorType := ET_NOT_IN_ROOT_ELEMENT;
          Flaw := Concat('&',TXmlEntityRefSignal(Signal).EntityName,';');
        end;
      end else

      if Signal is TXmlPCDATASignal then begin
        if FRootProcessingStatus <> rsInRoot then begin
          if TXmlPCDATASignal(Signal).CharRefGenerated then begin
            XmlErrorType := ET_NOT_IN_ROOT_ELEMENT;
            Flaw := '&#';
          end else if not IsXmlS(TXmlPCDATASignal(Signal).Data) then begin
            XmlErrorType := ET_NOT_IN_ROOT_ELEMENT;
            Flaw := TXmlPCDATASignal(Signal).Data;
          end;
        end;
      end else

      if Signal is TXmlSkippedEntitySignal then begin
                                                                                      
      end else

      if Signal is TXmlStartElementSignal then begin
        if FRootProcessingStatus = rsAfterRoot then begin
          XmlErrorType := ET_DOUBLE_ROOT_ELEMENT;
          Flaw := TXmlStartElementSignal(Signal).TagName;
        end else begin
          FRootProcessingStatus := rsInRoot;
          FTagStack.Add(TXmlStartElementSignal(Signal).TagName);
        end;
      end else

      if Signal is TXmlStartPrefixMappingSignal then begin
        FPrefixStack.Add(TXmlStartPrefixMappingSignal(Signal).Prefix);
      end else

      if Signal is TXmlEndPrefixMappingSignal then begin
        CheckEndPrefixMappingSignal(TXmlEndPrefixMappingSignal(Signal), XmlErrorType, Flaw);
      end else

      if Signal is TXmlCompletedSignal then begin
        case FRootProcessingStatus of
          rsBeforeRoot: begin
            XmlErrorType := ET_ROOT_ELEMENT_NOT_FOUND;
            Flaw := '';
          end;
          rsInRoot: begin
            XmlErrorType := ET_MISSING_END_TAG;
            Flaw := '';
            Clue := LastOpenTag;
          end
        else
          FDoctypeFound := False;
          FRootProcessingStatus := rsBeforeRoot;
        end;
        FActivityStatus := asInactive;
      end else

      if Signal is TXmlAbortedSignal then begin
        Reset;
      end else

      if not (ssDoc in Signal.Scope) then
        raise EParserException.Create('Internal Parser Exception');
    end;

    asDocFragActive: begin

      if Signal is TXmlDoctypeSignal then begin
        CheckDoctypeSignal(TXmlDoctypeSignal(Signal), XmlErrorType, Flaw);
      end else

      if Signal is TXmlEndElementSignal then begin
        CheckEndElementSignal(TXmlEndElementSignal(Signal), XmlErrorType, Flaw);
      end else

      if Signal is TXmlSkippedEntitySignal then begin
                                                                                      
      end else

      if Signal is TXmlStartElementSignal then begin
        FRootProcessingStatus := rsInRoot;
        FTagStack.Add(TXmlStartElementSignal(Signal).TagName);
      end else

      if Signal is TXmlStartPrefixMappingSignal then begin
        FPrefixStack.Add(TXmlStartPrefixMappingSignal(Signal).Prefix);
      end else

      if Signal is TXmlEndPrefixMappingSignal then begin
        CheckEndPrefixMappingSignal(TXmlEndPrefixMappingSignal(Signal), XmlErrorType, Flaw);
      end else

      if Signal is TXmlCompletedSignal then begin
        if FRootProcessingStatus = rsInRoot then begin
          XmlErrorType := ET_MISSING_END_TAG;
          Flaw := '';
          Clue := LastOpenTag;
        end else begin
          FDoctypeFound := False;
          FRootProcessingStatus := rsBeforeRoot;
        end;
        FActivityStatus := asInactive;
      end else

      if Signal is TXmlAbortedSignal then begin
        Reset;
      end else

      if not (ssDoc in Signal.Scope) then
        raise EParserException.Create('Internal Parser Exception');
    end;

    asExtDtdActive, asIntDtdActive: begin

      if not (ssDtd in Signal.Scope) then
        raise EParserException.Create('Internal Parser Exception');

      if Signal is TXmlCompletedSignal then
        FActivityStatus := asInactive;

    end;

    asInactive: begin

      if (Signal is TXmlStartDocumentSignal) then begin
        FActivityStatus := asDocActive;
        FPrefixStack.Clear;
        FTagStack.Clear;
        FDoctypeFound := False;
        FRootProcessingStatus := rsBeforeRoot;
      end else

      if (Signal is TXmlStartDocumentFragmentSignal) then begin
        FActivityStatus := asDocFragActive;
        FPrefixStack.Clear;
        FTagStack.Clear;
        FDoctypeFound := False;
        FRootProcessingStatus := rsBeforeRoot;
      end else

      if Signal is TXmlStartExtDtdSignal then begin
        FActivityStatus := asExtDtdActive;
      end else

      if Signal is TXmlStartIntDtdSignal then begin
        FActivityStatus := asIntDtdActive;
      end else

      if Signal is TXmlAbortedSignal then begin
        Reset;
      end else

        raise EParserException.Create('Internal Parser Exception');
    end;

  end; {case ...}

  if XmlErrorType = ET_NONE then
    Signal.CheckWellformedness(XmlErrorType, Flaw, Clue);

  if XmlErrorType = ET_NONE then begin
    if Assigned(NextHandler) then
      NextHandler.ProcessSignal(Signal);
  end else
    SendErrorNotification(Signal.Reader, XmlErrorType, Signal, Flaw, Clue);
end;

procedure TXmlWFTestHandler.Notification(AComponent: TComponent;
                                         Operation: TOperation);
begin
  inherited notification(AComponent,Operation);
  if (Operation = opRemove) and (AComponent = FNextHandler)
    then FNextHandler := nil;
end;

procedure TXmlWFTestHandler.Reset;
begin
  FActivityStatus := asInactive;
  FDoctypeFound := False;
  FRootProcessingStatus := rsBeforeRoot;
  FPrefixStack.Clear;
  FTagStack.Clear;
end;



// +++++++++++++++++++++ TXmlNamespaceSignalGenerator +++++++++++++++++++++
constructor TXmlNamespaceSignalGenerator.Create(AOwner: TComponent);
begin
  inherited;
  FPrefixMapping := True;
  FSuppressXmlns := False;

  FStartElementIsOpen := False;

  FAttributeSignals := TList<TXmlSignal>.Create;//TObjectList.Create;
  //FAttributeSignals.OwnsObjects := True;

  FPrefixMappingStack := TList<TUtilsWideStringList>.Create;
end;

destructor TXmlNamespaceSignalGenerator.Destroy;
begin
  ClearPrefixMappingStack;
  FPrefixMappingStack.Free;
  FAttributeSignals.Free;
  inherited;
end;

procedure TXmlNamespaceSignalGenerator.ClearPrefixMappingStack;
begin
  while FPrefixMappingStack.Count > 0 do begin
{$IFNDEF AUTOREFCOUNT}
    TUtilsWideStringList(FPrefixMappingStack.Last).Free;
{$ENDIF !AUTOREFCOUNT}
    FPrefixMappingStack.Delete(Pred(FPrefixMappingStack.Count));
  end;
end;

procedure TXmlNamespaceSignalGenerator.CloseStartElement(const Sender: TXmlCustomReader;
                                                         const Locator: IDomLocator);
var
  XmlAttributeSignal: TXmlAttributeSignal;
  XmlStartElementSignal: TXmlStartElementSignal;
begin
  if FStartElementIsOpen then begin

    if Assigned(NextHandler) then begin

      XmlStartElementSignal := TXmlStartElementSignal.CreateFromLocator(Sender, Locator);
      try
        XmlStartElementSignal.TagName := FElementName;
        NextHandler.ProcessSignal(XmlStartElementSignal);
      finally
        XmlStartElementSignal.Free;
      end;

      while FAttributeSignals.Count > 0 do begin
        XmlAttributeSignal := TXmlAttributeSignal(FAttributeSignals.Extract(FAttributeSignals.First));
          // Remark:
          //   The TObjectList.Extract function returns a pointer in Delphi 5
          //   and 6 (but a TObject in Delphi 7+).  Therefore, we must not
          //   write here
          //     XmlAttributeSignal := Extract(First) as TXmlAttributeSignal;
          //   because Delphi 5 and 6 would complain with an "Operator not
          //   applicable to this operant type" error.
        try
          NextHandler.ProcessSignal(XmlAttributeSignal);
        finally
          XmlAttributeSignal.Free;
        end;
      end;

    end; {if ...}

    FStartElementIsOpen := False;
  end;
end;

procedure TXmlNamespaceSignalGenerator.ProcessAttributeSignal(const Signal: TXmlAttributeSignal);
var
  Len: Integer;
{$IFDEF NEXTGEN}
  NamespacePrefix: string;
{$ELSE !NEXTGEN}
  NamespacePrefix: WideString;
{$ENDIF NEXTGEN}
  PfxUriList: TUtilsWideStringList;
begin
  if not FStartElementIsOpen then
    raise EParserException.Create('Internal Parser Exception');

{$IFDEF NEXTGEN}
  if StartsWideStr(string('xmlns'), Signal.Name) then begin
{$ELSE !NEXTGEN}
  if StartsWideStr(WideString('xmlns'), Signal.Name) then begin
{$ENDIF NEXTGEN}
    if FPrefixMapping then begin
      PfxUriList := TUtilsWideStringList(FPrefixMappingStack.Last);
      if not Assigned(PfxUriList) then
        raise EParserException.Create('Internal Parser Exception');

      Len := Length(Signal.Name);
      if Len > 6 then begin
        // Attribute name has the form 'xmlns:...':
        NamespacePrefix := Copy(Signal.Name, 7, Len);
        PfxUriList.Add(NamespacePrefix);
        WriteStartPrefixMapping(Signal.Reader, Signal, NamespacePrefix, Signal.Value);
      end else begin
        // Attribute name has the form 'xmlns':
        PfxUriList.Add('');
        WriteStartPrefixMapping(Signal.Reader, Signal, '', Signal.Value);
      end;
    end;
    if not FSuppressXmlns then
      FAttributeSignals.Add(Signal.CloneSignal(Signal.Reader)); // Store a copy of the signal.
  end else
    FAttributeSignals.Add(Signal.CloneSignal(Signal.Reader));   // Store a copy of the signal.
end;

procedure TXmlNamespaceSignalGenerator.ProcessSignal(const Signal: TXmlSignal);
begin
  if Signal is TXmlAttributeSignal then begin
    ProcessAttributeSignal(Signal as TXmlAttributeSignal);
  end else begin

    if Signal is TXmlAbortedSignal then begin
      Reset;
      if Assigned(NextHandler) then
        NextHandler.ProcessSignal(Signal);
    end else begin

      CloseStartElement(Signal.Reader, Signal);

      if Signal is TXmlStartElementSignal then begin
        ProcessStartElementSignal(Signal as TXmlStartElementSignal);
      end else

      if (Signal is TXmlEndElementSignal) then begin
        if Assigned(NextHandler) then
          NextHandler.ProcessSignal(Signal);
        WriteEndPrefixMapping(Signal.Reader, Signal);

      end else begin

        if (Signal is TXmlCompletedSignal) or
           (Signal is TXmlStartDocumentSignal) or
           (Signal is TXmlStartDocumentFragmentSignal) then
          Reset;

        if Assigned(NextHandler) then
          NextHandler.ProcessSignal(Signal);

      end;

    end; {if ... else ...}

  end; {if ... else ...}
end;

procedure TXmlNamespaceSignalGenerator.ProcessStartElementSignal(const Signal: TXmlStartElementSignal);
begin
  if FStartElementIsOpen then
    raise EParserException.Create('Internal Parser Exception');

  FElementName := Signal.TagName;
  FAttributeSignals.Clear;
  FStartElementIsOpen := True;

  if FPrefixMapping then
    FPrefixMappingStack.Add(TUtilsWideStringList.Create);
end;

procedure TXmlNamespaceSignalGenerator.Reset;
begin
  ClearPrefixMappingStack;
  FAttributeSignals.Clear;
  FStartElementIsOpen := False;
end;

procedure TXmlNamespaceSignalGenerator.WriteEndPrefixMapping(const Sender: TXmlCustomReader;
                                                             const Locator: IDomLocator);
var
  XmlEndPrefixMappingSignal: TXmlEndPrefixMappingSignal;
  PfxUriList: TUtilsWideStringList;
  I: Integer;
begin
  if FPrefixMapping then
    if FPrefixMappingStack.Count > 0 then begin
      PfxUriList := TUtilsWideStringList(FPrefixMappingStack.Last);
      FPrefixMappingStack.Delete(Pred(FPrefixMappingStack.Count));
      try
        if Assigned(NextHandler) then
          for I := Pred(PfxUriList.Count) downto 0 do begin
            XmlEndPrefixMappingSignal := TXmlEndPrefixMappingSignal.CreateFromLocator(Sender, Locator);
            try
              XmlEndPrefixMappingSignal.Prefix := PfxUriList.WideStrings[I];
              NextHandler.ProcessSignal(XmlEndPrefixMappingSignal);
            finally
              XmlEndPrefixMappingSignal.Free;
            end;
          end;
      finally
        PfxUriList.Free;
      end;
    end; {if ...}
end;

{$IFDEF NEXTGEN}
procedure TXmlNamespaceSignalGenerator.WriteStartPrefixMapping(const Sender: TXmlCustomReader;
                                                               const Locator: IDomLocator;
                                                               const Prefix,
                                                                     Uri: string);
{$ELSE !NEXTGEN}
procedure TXmlNamespaceSignalGenerator.WriteStartPrefixMapping(const Sender: TXmlCustomReader;
                                                               const Locator: IDomLocator;
                                                               const Prefix,
                                                                     Uri: WideString);
{$ENDIF NEXTGEN}
var
  XmlStartPrefixMappingSignal: TXmlStartPrefixMappingSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartPrefixMappingSignal := TXmlStartPrefixMappingSignal.CreateFromLocator(Sender, Locator);
    try
      XmlStartPrefixMappingSignal.Prefix := Prefix;
      XmlStartPrefixMappingSignal.Uri := Uri;
      NextHandler.ProcessSignal(XmlStartPrefixMappingSignal);
    finally
      XmlStartPrefixMappingSignal.Free;
    end;
  end;
end;



// ++++++++++++++++++++++++++++ TXmlDomBuilder ++++++++++++++++++++++++++++
constructor TXmlDomBuilder.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FRefNode := nil;
  FBuildIDList := True;
  FDocTypeDeclTreatment := dtCheckWellformedness;
  FErrorReportingEnabled := True;
  FKeepCDATASections := True;
  FKeepComments := True;
  FKeepEntityRefs := True;
{$IFDEF NEXTGEN}
  FPrefixUriList := TDictionary<Integer, TPair<string, string>>.Create;
{$ELSE !NEXTGEN}
  FPrefixUriList := TDictionary<Integer, TPair<WideString, WideString>>.Create;
{$ENDIF NEXTGEN}
end;

destructor TXmlDomBuilder.Destroy;
begin
  FPrefixUriList.Free;
  inherited Destroy;
end;

{$IFDEF NEXTGEN}
function TXmlDomBuilder.GetUriListLastValue(Name: string): string;
{$ELSE !NEXTGEN}
function TXmlDomBuilder.GetUriListLastValue(Name: WideString): WideString;
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  Result := '';
  for I := FPrefixUriList.Count downto 1 do
  begin
    if FPrefixUriList.ContainsKey(I) and (FPrefixUriList.Items[I].Key = Name) then
    begin
      Result := FPrefixUriList.Items[I].Value;
      Exit;
    end;
  end;
end;

procedure TXmlDomBuilder.ProcessSignal(const Signal: TXmlSignal);
var
{$IFDEF NEXTGEN}
  Prfx, LocalName, AttrNsUri: string;
  ElementNsUri: string; // = ''
{$ELSE !NEXTGEN}
  Prfx, LocalName, AttrNsUri: WideString;
  ElementNsUri: WideString; // = ''
{$ENDIF NEXTGEN}
  ErrorReportingEnabledBackup: Boolean;
  NewCData: TDomCDATASection;
  NewComment: TDomComment;
  NewDocType: TDomDocumentTypeDecl;
  NewElement: TDomElement;
  NewEntityRef: TDomEntityReference;
  NewPI: TDomProcessingInstruction;
begin
  if Signal is TXmlAttributeSignal then begin
    if Assigned(FRefNode) then begin
      if FRefNode.RootDocument is TDomDocumentNS then begin // Build namespace tree?

        // Compute namespace attribute:
        if TXmlAttributeSignal(Signal).Name = 'xmlns' then begin
          (FRefNode as TDomElement).SetAttributeNS('http://www.w3.org/2000/xmlns/',
                                                   'xmlns',
                                                   TXmlAttributeSignal(Signal).Value);
        end else begin
          XmlExtractPrefixAndLocalName(TXmlAttributeSignal(Signal).Name, Prfx, LocalName);
          if Prfx = '' then begin
            AttrNsUri := '';
          end else if Prfx = 'xml' then begin
            AttrNsUri := 'http://www.w3.org/XML/1998/namespace';
          end else if Prfx = 'xmlns' then begin
            AttrNsUri := 'http://www.w3.org/2000/xmlns/';
          end else begin
            AttrNsUri := GetUriListLastValue(Prfx);
          end;
          (FRefNode as TDomElement).SetAttributeNS(AttrNsUri,
                                                   TXmlAttributeSignal(Signal).Name,
                                                   TXmlAttributeSignal(Signal).Value);
        end; {if ... else ...}

        // Update IDs:
        if BuildIDList then
          if TXmlAttributeSignal(Signal).DataType = AS_ID_DATATYPE then
            (FRefNode.RootDocument as TDomDocumentNS).IDs.AddObject(
              TXmlAttributeSignal(Signal).Value, FRefNode);

      end else begin

        (FRefNode as TDomElement).SetAttribute(TXmlAttributeSignal(Signal).Name,
                                               TXmlAttributeSignal(Signal).Value);

      end; {if ... else ...}
    end; {if Assigned(FRefNode) ...}
  end else

  if Signal is TXmlCDATASignal then begin
    if Assigned(FRefNode) then begin
      if FKeepCDATASections then begin
        NewCData := TDomCDATASection.Create(FRefNode.RootDocument);
        try
          NewCData.Data:= TXmlCDATASignal(Signal).Data;
          FRefNode.AppendChild(NewCData);
        except
          NewCData.Free;
          raise;
        end; {try ...}
      end else
        ProcessPCDATA(Signal.Reader, Signal, TXmlCDATASignal(Signal).Data, False);
    end; {if Assigned(FRefNode) ...}
  end else


  if Signal is TXmlCommentSignal then begin
    if FKeepComments then begin
      if Assigned(FRefNode) then begin
        NewComment := TDomComment.Create(FRefNode.RootDocument);
        try
          NewComment.Data:= TXmlCommentSignal(Signal).Data;
          FRefNode.AppendChild(NewComment);
        except
          NewComment.Free;
          raise;
        end; {try ...}
      end; {if Assigned(FRefNode) ...}
    end; {if FKeepComments ...}
  end else


  if Signal is TXmlDoctypeSignal then begin
    if Assigned(FRefNode) then begin
      if DocTypeDeclTreatment <> dtIgnore then begin
         NewDocType := TDomDocumentTypeDecl.Create(
                        FRefNode.RootDocument,
                        TXmlDoctypeSignal(Signal).DoctypeName,
                        TXmlDoctypeSignal(Signal).PublicId,
                        TXmlDoctypeSignal(Signal).SystemId,
                        TXmlDoctypeSignal(Signal).Data);
        try
          NewDocType.IntSubsetStartByteNumber := TXmlDoctypeSignal(Signal).IntSubsetStartByteNumber;
          NewDocType.IntSubsetStartCharNumber := TXmlDoctypeSignal(Signal).IntSubsetStartCharNumber;
          NewDocType.IntSubsetStartColumn := TXmlDoctypeSignal(Signal).IntSubsetStartColumn;
          NewDocType.IntSubsetStartLine := TXmlDoctypeSignal(Signal).IntSubsetStartLine;
          FRefNode.AppendChild(NewDocType);
          if FRefNode is TDomDocument then
            case DocTypeDeclTreatment of
              dtCheckWellformedness: begin
                ErrorReportingEnabledBackup := (FRefNode as TDomDocument).ValidationAgent.ErrorReportingEnabled;
                try
                  (FRefNode as TDomDocument).ValidationAgent.ErrorReportingEnabled := Self.ErrorReportingEnabled;
                  (FRefNode as TDomDocument).ValidationAgent.BuildDtdModel(False);
                  if (FRefNode as TDomDocument).ValidationAgent.DtdModel.PreparationStatus = PS_INCOMPLETE_ABORTED then
                    raise EParserException.Create('Non-wellformed DTD.');
                finally
                  (FRefNode as TDomDocument).ValidationAgent.ErrorReportingEnabled := ErrorReportingEnabledBackup;
                end;
              end;
              dtCheckValidity: begin
                ErrorReportingEnabledBackup := (FRefNode as TDomDocument).ValidationAgent.ErrorReportingEnabled;
                try
                  (FRefNode as TDomDocument).ValidationAgent.ErrorReportingEnabled := Self.ErrorReportingEnabled;
                  (FRefNode as TDomDocument).ValidationAgent.BuildDtdModel(True);
                  if (FRefNode as TDomDocument).ValidationAgent.DtdModel.PreparationStatus = PS_INCOMPLETE_ABORTED then
                    raise EParserException.Create('Non-wellformed or invalid DTD.');                                                                    
                finally
                  (FRefNode as TDomDocument).ValidationAgent.ErrorReportingEnabled := ErrorReportingEnabledBackup;
                end;
              end;
            end;
        except
          NewDocType.Free;
          raise;
        end; {try ...}
      end; {if ...}
    end; {if Assigned(FRefNode) ...}
  end else


  if Signal is TXmlEndElementSignal then begin
    if Assigned(FRefNode) then
      FRefNode:= FRefNode.ParentNode;
  end else


  if Signal is TXmlEndPrefixMappingSignal then begin
    FPrefixUriList.Remove(FPrefixUriList.Count);
  end else


  if Signal is TXmlEntityRefSignal then begin
    if Assigned(FRefNode) then begin
      if KeepEntityRefs or not IsXmlPredefinedEntityName(TXmlEntityRefSignal(Signal).EntityName) then begin
        NewEntityRef := TDomEntityReference.Create(
                          FRefNode.RootDocument,
                          TXmlEntityRefSignal(Signal).EntityName);
        try
          FRefNode.AppendChild(NewEntityRef);
        except
          NewEntityRef.Free;
          raise;
        end; {try ...}
      end else begin
        if TXmlEntityRefSignal(Signal).EntityName = 'lt' then begin
          ProcessPCDATA(Signal.Reader,Signal, #60, False);
        end else if TXmlEntityRefSignal(Signal).EntityName = 'gt' then begin
          ProcessPCDATA(Signal.Reader,Signal, #62, False);
        end else if TXmlEntityRefSignal(Signal).EntityName = 'amp' then begin
          ProcessPCDATA(Signal.Reader,Signal, #38, False);
        end else if TXmlEntityRefSignal(Signal).EntityName = 'apos' then begin
          ProcessPCDATA(Signal.Reader,Signal, #39, False);
        end else if TXmlEntityRefSignal(Signal).EntityName = 'quot' then begin
          ProcessPCDATA(Signal.Reader,Signal, #34, False);
        end;
      end; {if ... else}
    end; {if Assigned(FRefNode) ...}
  end else


  if Signal is TXmlPCDATASignal then begin
    if Assigned(FRefNode) then
      if FRefNode.NodeType <> ntDocument_Node then
        ProcessPCDATA(Signal.Reader, Signal, TXmlPCDATASignal(Signal).Data,
                      TXmlPCDATASignal(Signal).CharRefGenerated);
  end else


  if Signal is TXmlProcessingInstructionSignal then begin
    if Assigned(FRefNode) then begin
      NewPI := TDomProcessingInstruction.Create(
                 FRefNode.RootDocument,
                 TXmlProcessingInstructionSignal(Signal).Target);
      try
        NewPI.Data:= TXmlProcessingInstructionSignal(Signal).Data;
        FRefNode.AppendChild(NewPI);
      except
        NewPI.Free;
        raise;
      end;
    end; {if Assigned(FRefNode) ...}
  end else


  if Signal is TXmlSkippedEntitySignal then begin
    // Notifications through skippedEntity() are being ignored.
  end else


  if Signal is TXmlStartDocumentSignal then begin
    FPrefixUriList.Clear;

    if Assigned(FRefNode) then begin
      if (FRefNode.NodeType = ntDocument_Node) then begin
        (FRefNode as TDomCustomDocument).InputEncoding := TXmlStartDocumentSignal(Signal).InputEncoding;
        (FRefNode as TDomCustomDocument).XmlEncoding := TXmlStartDocumentSignal(Signal).EncodingName;
        (FRefNode as TDomCustomDocument).XmlStandalone := TXmlStartDocumentSignal(Signal).StandaloneDecl;
        (FRefNode as TDomCustomDocument).XmlVersion := TXmlStartDocumentSignal(Signal).Version;
        (FRefNode as TDomCustomDocument).DocumentUri := Signal.Uri
      end;
      if FRefNode is TDomDocumentNS then
        (FRefNode as TDomDocumentNS).IDs.Clear;
    end;
  end else


  if Signal is TXmlStartDocumentFragmentSignal then begin
    FPrefixUriList.Clear;
  end else


  if Signal is TXmlStartElementSignal then begin
    if Assigned(FRefNode) then begin

      if FRefNode.RootDocument is TDomDocumentNS then begin // Build namespace tree?

        // Parse into namespace-aware document tree:

        XmlExtractPrefixAndLocalName(TXmlStartElementSignal(Signal).TagName, Prfx, LocalName);
        ElementNsUri := GetUriListLastValue(Prfx);

        NewElement := TDomElement.CreateNS(FRefNode.RootDocument as TDomDocumentNS,
                        ElementNsUri, TXmlStartElementSignal(Signal).TagName);
        FRefNode.AppendChild(NewElement);
        FRefNode := NewElement;

      end else begin

        // Parse into non-namespace-aware document tree:

        NewElement := TDomElement.Create(FRefNode.RootDocument as TDomDocument,
                        TXmlStartElementSignal(Signal).TagName);
        FRefNode.AppendChild(NewElement);
        FRefNode := NewElement;

      end;

    end; {if Assigned(FRefNode) ...}
  end else


  if Signal is TXmlStartPrefixMappingSignal then begin
{$IFDEF NEXTGEN}
    FPrefixUriList.Add(FPrefixUriList.Count + 1,
                       TPair<string, string>.Create(TXmlStartPrefixMappingSignal(Signal).Prefix,
                                                    TXmlStartPrefixMappingSignal(Signal).Uri));
{$ELSE !NEXTGEN}
    FPrefixUriList.Add(FPrefixUriList.Count + 1,
                       TPair<WideString, WideString>.Create(TXmlStartPrefixMappingSignal(Signal).Prefix,
                                                            TXmlStartPrefixMappingSignal(Signal).Uri));
{$ENDIF NEXTGEN}
  end else


  if Signal is TXmlAbortedSignal then begin
    Reset;
  end else

  if not (ssDoc in Signal.Scope) then
    raise EParserException.Create('Internal Parser Exception');

end;

procedure TXmlDomBuilder.Reset;
begin
  FPrefixUriList.Clear;
end;

procedure TXmlDomBuilder.SetErrorReportingEnabled(const Value: Boolean);
begin
  FErrorReportingEnabled := Value;
end;

{$IFDEF NEXTGEN}
procedure TXmlDomBuilder.ProcessPCDATA(const Sender: TXmlCustomReader;
                                       const Locator: IDomLocator;
                                       const Data: string;
                                       const CharRefGenerated: Boolean);
{$ELSE !NEXTGEN}
procedure TXmlDomBuilder.ProcessPCDATA(const Sender: TXmlCustomReader;
                                       const Locator: IDomLocator;
                                       const Data: WideString;
                                       const CharRefGenerated: Boolean);
{$ENDIF NEXTGEN}
var
  NewPcdata: TDomText;
  Last: TDomNode;
begin
  Last := FRefNode.LastChild;
  if Assigned(Last) and (Last.NodeType = ntText_Node) then begin
    (Last as TDomText).AppendData(Data);
    if CharRefGenerated then
      (Last as TDomText).CharRefGenerated := True;
  end else begin
    NewPcdata := TDomText.Create(FRefNode.RootDocument);
    try
      NewPcdata.Data := Data;
      NewPcdata.CharRefGenerated := CharRefGenerated;
      FRefNode.AppendChild(NewPcdata);
    except
      NewPcdata.Free;
      raise;
    end;
  end;
end;



// +++++++++++++++++++++++++++ TXmlDtdModelBuilder ++++++++++++++++++++++++++++
constructor TXmlDtdModelBuilder.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FActivityStatus := asInactive;
  FDocStandalone := STANDALONE_UNSPECIFIED;
  FIgnoreDeclarations := False;
  FDtdModel := nil;
end;

{$IFDEF NEXTGEN}
procedure TXmlDtdModelBuilder.InsertMixedContent(const RefASElementDecl: TDtdElementDecl;
                                                 const ContSpec: string);
var
  Dummy, Content, Piece: string;
{$ELSE !NEXTGEN}
procedure TXmlDtdModelBuilder.InsertMixedContent(const RefASElementDecl: TDtdElementDecl;
                                                 const ContSpec: WideString);
var
  Dummy, Content, Piece: WideString;
{$ENDIF NEXTGEN}
  Freq: TDtdFrequency;
  Separator: Integer;
  Error: Boolean;
  NewASContentModel: TDtdContentModel;
begin
                                                               

  Content := TrimWhitespace(ContSpec);
  Freq := DTD_REQUIRED_FRQ;
  if (Content[Length(Content) - AdjustIndex] = '*') then begin
    Freq := DTD_ZERO_OR_MORE_FRQ;
    Dummy := Copy(Content, 1, Length(Content) - 1);
    Content := Dummy;
  end;
  if Length(Content) = 0 then
    raise EParserException.Create('Parser error.');
  if WideChar(Content[Length(Content) - AdjustIndex]) <> ')' then
    raise EParserException.Create('Parser error.');
  XMLTruncRoundBrackets(Content, Dummy, Error);
  if Error or (Dummy = '') then
    raise EParserException.Create('Parser error.');
  Content := Dummy;
  NewASContentModel := RefASElementDecl.CreateContentModel('', DTD_CHOICE_CM);
  NewASContentModel.Frequency := Freq;
  RefASElementDecl.ReplaceContentModel(NewASContentModel);
  if Content = '#PCDATA' then begin
    if (Freq <> DTD_REQUIRED_FRQ) and (Freq <> DTD_ZERO_OR_MORE_FRQ) then
      raise EParserException.Create('Parser error.');
    Exit;
  end;
  if Freq <> DTD_ZERO_OR_MORE_FRQ then
    raise EParserException.Create('Parser error.');
{$IFDEF NEXTGEN}
  Separator := Pos(string('|'), Content);
{$ELSE !NEXTGEN}
  Separator := Pos(WideString('|'), Content);
{$ENDIF NEXTGEN}
  if Separator = 0 then
    raise EParserException.Create('Parser error.');
  Dummy := TrimWhitespace(Copy(Content, Separator + 1, Length(Content) - Separator));
  Content := Dummy;
  while Content <> '' do begin
{$IFDEF NEXTGEN}
    Separator := Pos(string('|'), Content);
{$ELSE !NEXTGEN}
    Separator := Pos(WideString('|'), Content);
{$ENDIF NEXTGEN}
    if Separator = 0 then begin
      Piece := Content;
      Content := '';
    end else begin
      Piece := TrimWhitespace(Copy(Content, 1, Separator - 1));
      Dummy := TrimWhitespace(Copy(Content, Separator + 1, Length(Content) - Separator));
      Content := Dummy;
      if Content = '' then
        raise EParserException.Create('Parser error.');
    end; {if ...}
    if not IsXmlName(Piece) then
      raise EParserException.Create('Parser error.');
    NewASContentModel.SubModels.AppendNode(RefASElementDecl.CreateContentModel(Piece, DTD_ELEMENT_CM));
  end; {while ...}
end;

{$IFDEF NEXTGEN}
procedure TXmlDtdModelBuilder.InsertChildrenContent(const RefDtdObject: TDtdObject;
                                                    const ContSpec: string);
var
  Piece, Dummy, Content: string;
{$ELSE !NEXTGEN}
procedure TXmlDtdModelBuilder.InsertChildrenContent(const RefDtdObject: TDtdObject;
                                                    const ContSpec: WideString);
var
  Piece, Dummy, Content: WideString;
{$ENDIF NEXTGEN}
  SeparatorChar: WideChar;
  Freq: TDtdFrequency;
  J, I, BracketNr: Integer;
  NewASContentModel_1, NewASContentModel_2: TDtdContentModel;
  Error: Boolean;
begin
                                                               

  Content := TrimWhitespace(ContSpec);
  if Content[Length(Content) - AdjustIndex] = WideChar('?') then begin
    Freq := DTD_OPTIONAL_FRQ;
    Dummy := Copy(Content, 1, Length(Content) - 1);
    Content := Dummy;
  end else if Content[Length(Content) - AdjustIndex] = WideChar('*') then begin
    Freq := DTD_ZERO_OR_MORE_FRQ;
    Dummy := Copy(Content, 1, Length(Content) - 1);
    Content := Dummy;
  end else if Content[Length(Content) - AdjustIndex] = WideChar('+') then begin
    Freq := DTD_ONE_OR_MORE_FRQ;
    Dummy := Copy(Content, 1, Length(Content) - 1);
    Content := Dummy;
  end else Freq := DTD_REQUIRED_FRQ;
  if Length(Content) = 0 then
    raise EParserException.Create('Parser error.');
  if WideChar(Content[Length(Content) - AdjustIndex]) <> ')' then
    raise EParserException.Create('Parser error.');
  XMLTruncRoundBrackets(Content, Dummy, Error);
  if Error or (Dummy = '') then
    raise EParserException.Create('Parser error.');
  Content := Dummy;

  BracketNr := 0;
  SeparatorChar := ',';
  for I := FirstIndex to Length(Content)-AdjustIndex do begin
    if (Content[I] = ',') and (BracketNr = 0) then begin
      SeparatorChar := ',';
      Break;
    end; {if ...}
    if (Content[I] = '|') and (BracketNr = 0) then begin
      SeparatorChar := '|';
      Break;
    end; {if ...}
    if Content[I] = '(' then Inc(BracketNr);
    if Content[I] = ')' then begin
      if BracketNr = 0 then raise EParserException.Create('Parser error.');
      Dec(BracketNr);
    end;
  end; {for ...}

  if SeparatorChar = ',' then begin
    case RefDtdObject.ObjectType of
      DTD_CONTENT_MODEL:
      begin
        NewASContentModel_1 := (RefDtdObject as TDtdContentModel).OwnerElementDecl.CreateContentModel('', DTD_SEQUENCE_CM);
        NewASContentModel_1.Frequency := Freq;
        (RefDtdObject as TDtdContentModel).SubModels.AppendNode(NewASContentModel_1);
      end;
      DTD_ELEMENT_DECLARATION:
      begin
        NewASContentModel_1 := (RefDtdObject as TDtdElementDecl).CreateContentModel('', DTD_SEQUENCE_CM);
        NewASContentModel_1.Frequency := Freq;
        (RefDtdObject as TDtdElementDecl).ReplaceContentModel(NewASContentModel_1);
      end;
    else
      raise EParserException.Create('Parser error.');
    end;
  end else begin
    case RefDtdObject.ObjectType of
      DTD_CONTENT_MODEL:
      begin
        NewASContentModel_1 := (RefDtdObject as TDtdContentModel).OwnerElementDecl.CreateContentModel('', DTD_CHOICE_CM);
        NewASContentModel_1.Frequency := Freq;
        (RefDtdObject as TDtdContentModel).SubModels.AppendNode(NewASContentModel_1);
      end;
      DTD_ELEMENT_DECLARATION:
      begin
        NewASContentModel_1 := (RefDtdObject as TDtdElementDecl).CreateContentModel('', DTD_CHOICE_CM);
        NewASContentModel_1.Frequency := Freq;
        (RefDtdObject as TDtdElementDecl).ReplaceContentModel(NewASContentModel_1);
      end;
    else
      raise EParserException.Create('Parser error.');
    end;
  end;

  BracketNr := 0;
  I := FirstIndex;
  J := FirstIndex;
  while I <= Length(Content)-AdjustIndex do begin
    if Content[I] = '(' then Inc(BracketNr);
    if Content[I] = ')' then begin
      if BracketNr = 0 then raise EParserException.Create('Parser error.');
      Dec(BracketNr);
    end;
    if ((Content[I] = SeparatorChar) and (BracketNr = 0)) or
       (I = Length(Content)-AdjustIndex) then begin
      if BracketNr > 0 then raise EParserException.Create('Parser error.');
      if I = Length(Content)-AdjustIndex
        then Piece := TrimWhitespace(Copy(Content, J+AdjustIndex, I + 1 - J))
        else Piece := TrimWhitespace(Copy(Content, J+AdjustIndex, I - J));
      J := I + 1;

      if Piece[FirstIndex] = '(' then begin
        InsertChildrenContent(NewASContentModel_1, Piece);
      end else begin
        if Piece[Length(Piece)-AdjustIndex] = WideChar('?') then begin
          Freq := DTD_OPTIONAL_FRQ;
          Dummy := Copy(Piece, 1, Length(Piece) - 1);
          Piece := Dummy;
        end else if Piece[Length(Piece)-AdjustIndex] = WideChar('*') then begin
          Freq := DTD_ZERO_OR_MORE_FRQ;
          Dummy := Copy(Piece, 1, Length(Piece) - 1);
          Piece := Dummy;
        end else if Piece[Length(Piece)-AdjustIndex] = WideChar('+') then begin
          Freq := DTD_ONE_OR_MORE_FRQ;
          Dummy := Copy(Piece, 1, Length(Piece) - 1);
          Piece := Dummy;
        end else Freq := DTD_REQUIRED_FRQ;
        if not IsXmlName(Piece)
          then raise EParserException.Create('Parser error.');
        NewASContentModel_2 := NewASContentModel_1.OwnerElementDecl.CreateContentModel(Piece, DTD_ELEMENT_CM);
        NewASContentModel_2.Frequency := Freq;
        NewASContentModel_1.SubModels.AppendNode(NewASContentModel_2);
      end; {if ...}

    end; {if ...}
    Inc(I);
  end; {while ...}

end;

procedure TXmlDtdModelBuilder.ProcessSignal(const Signal: TXmlSignal);

var
  NewASAttributeDecl: TDtdAttributeDecl;
  NewElementDecl: TDtdElementDecl;
  NewEntityDecl: TDtdEntityDecl;
  NewNotationDecl: TDtdNotationDecl;
  ContentType: TDtdContentType;
  Origin: TDtdOrigin;
{$IFDEF NEXTGEN}
  Data2: string;
{$ELSE !NEXTGEN}
  Data2: WideString;
{$ENDIF NEXTGEN}
begin
  if not Assigned(DtdModel) then
    Exit;

  if (Signal is TXmlAttributeDefinitionSignal) then begin
    if not FIgnoreDeclarations then
    begin
      if (ActivityStatus = asExtDtdActive) or TXmlAttributeDefinitionSignal(Signal).IsDeclaredInPE
        then Origin := DTD_EXTERNALLY_DECLARED
        else Origin := DTD_INTERNALLY_DECLARED;
      if not DtdModel.SetAttributeDecl(TXmlAttributeDefinitionSignal(Signal).ElementName,
                        TXmlAttributeDefinitionSignal(Signal).AttributeName,
                        TXmlAttributeDefinitionSignal(Signal).DefaultValue,
                        TXmlAttributeDefinitionSignal(Signal).Enumeration,
                        TXmlAttributeDefinitionSignal(Signal).AttributeType,
                        TXmlAttributeDefinitionSignal(Signal).Constraint,
                        Origin, NewASAttributeDecl) then
        SendErrorNotification(Signal.Reader, ET_DOUBLE_ATTDEF, Signal,
          TXmlAttributeDefinitionSignal(Signal).AttributeName, '');
    end;
  end else

  if (Signal is TXmlElementTypeDeclarationSignal) then begin
    if not FIgnoreDeclarations then

      Data2 := TrimWhitespace(TXmlElementTypeDeclarationSignal(Signal).Data);

      if Data2 = 'EMPTY' then begin
        ContentType := DTD_EMPTY_CONTENTTYPE;
        Data2 := '';
      end else if Data2 = 'ANY' then begin
        ContentType := DTD_ANY_CONTENTTYPE;
        Data2 := '';
{$IFDEF NEXTGEN}
      end else if Pos(string('#PCDATA'), Data2) > 0 then
{$ELSE !NEXTGEN}
      end else if Pos(AnsiString('#PCDATA'), Data2) > 0 then
{$ENDIF NEXTGEN}
        ContentType := DTD_MIXED_CONTENTTYPE
      else
        ContentType := DTD_ELEMENT_CONTENTTYPE;

      if (ActivityStatus = asExtDtdActive) or TXmlElementTypeDeclarationSignal(Signal).IsDeclaredInPE
        then Origin := DTD_EXTERNALLY_DECLARED
        else Origin := DTD_INTERNALLY_DECLARED;

      try
        if DtdModel.SetElementDecl(TXmlElementTypeDeclarationSignal(Signal).ElementName,
                                     ContentType, Origin, NewElementDecl)
        then begin
          case ContentType of
            DTD_MIXED_CONTENTTYPE: InsertMixedContent(NewElementDecl, TXmlElementTypeDeclarationSignal(Signal).Data);
            DTD_ELEMENT_CONTENTTYPE: InsertChildrenContent(NewElementDecl, TXmlElementTypeDeclarationSignal(Signal).Data);
          end;
        end else
          // VC: Unique Element Type Declaration (XML 1.0, § 3.2)
          SendErrorNotification(Signal.Reader, ET_DUPLICATE_ELEMENT_TYPE_DECL, Signal,
            TXmlElementTypeDeclarationSignal(Signal).ElementName, '');
      except
        SendErrorNotification(Signal.Reader, ET_INVALID_ELEMENT_DECL, Signal,
          TXmlElementTypeDeclarationSignal(Signal).ElementName, '');
      end; {try ...}

  end else

  if Signal is TXmlEntityDeclarationSignal then begin
    if not FIgnoreDeclarations then begin
      if (ActivityStatus = asExtDtdActive) or TXmlEntityDeclarationSignal(Signal).IsDeclaredInPE
        then Origin := DTD_EXTERNALLY_DECLARED
        else Origin := DTD_INTERNALLY_DECLARED;

      if DtdModel.SetEntityDecl(TXmlEntityDeclarationSignal(Signal).EntityName,
                                ResolveCharRefs(TXmlEntityDeclarationSignal(Signal).EntityValue),  // [*]   {TODO 4 -cRevisit : Change character reference resolvement?  What about exceptions?}
                                TXmlEntityDeclarationSignal(Signal).PublicId,
                                TXmlEntityDeclarationSignal(Signal).SystemId,
                                TXmlEntityDeclarationSignal(Signal).NotationName,
                                TXmlEntityDeclarationSignal(Signal).BaseUri,
                                Origin,
                                NewEntityDecl) then begin
            // [*] Note that the TXmlEntityDeclarationSignal.EntityValue property
            //     contains a semi-processed entity value: Paremeter entity
            //     references, which may appear in entity declarations in the
            //     external subset of a DTD, have already been replaced.  What
            //     needs to be done in order to construct the replacement text
            //     of an internal entity is to replace the character references
            //     (cf. [XML 1.0], sec. 4.5).
        if not NewEntityDecl.CheckNoRecursion then
          SendErrorNotification(Signal.Reader, ET_RECURSIVE_REFERENCE, Signal,
            TXmlEntityDeclarationSignal(Signal).EntityName, '');
      end else
        SendErrorNotification(Signal.Reader, ET_DOUBLE_ENTITY_DECL, Signal,
          TXmlEntityDeclarationSignal(Signal).EntityName, '');
    end;
  end else

  if Signal is TXmlNotationDeclarationSignal then begin
    if not FIgnoreDeclarations then begin
      if (ActivityStatus = asExtDtdActive) or TXmlNotationDeclarationSignal(Signal).IsDeclaredInPE
        then Origin := DTD_EXTERNALLY_DECLARED
        else Origin := DTD_INTERNALLY_DECLARED;
      if not DtdModel.SetNotationDecl(TXmlNotationDeclarationSignal(Signal).NotationName,
                                      TXmlNotationDeclarationSignal(Signal).PublicId,
                                      TXmlNotationDeclarationSignal(Signal).SystemId,
                                      Origin,
                                      NewNotationDecl) then
        SendErrorNotification(Signal.Reader, ET_DUPLICATE_NOTATION_DECL, Signal,
          TXmlNotationDeclarationSignal(Signal).NotationName, '');
    end;
  end else

  if Signal is TXmlPEReferenceFoundSignal then begin
    if FActivityStatus = asIntDtdActive then
      DtdModel.PEsInIntSubset := True;
  end else

  if Signal is TXmlExternalPEReferenceSignal then begin
    if FActivityStatus = asIntDtdActive then begin
      if FDocStandalone in [ STANDALONE_NO, STANDALONE_UNSPECIFIED ] then begin
        FIgnoreDeclarations := True;
        DtdModel.PreparationStatus := PS_INCOMPLETE_NOT_STANDALONE;
      end else
        DtdModel.PreparationStatus := PS_INCOMPLETE_STANDALONE;
    end else
      raise EParserException.Create('Internal Parser Exception');
  end else

  if Signal is TXmlStartExtDtdSignal then begin
    if DtdModel.PreparationStatus in [ PS_UNPREPARED, PS_INT_SUBSET_COMPLETED, PS_COMPLETED, PS_INEXISTANT ] then
      DtdModel.PreparationStatus := PS_INCOMPLETE;
    DtdModel.ExtSubsetSysId := TXmlStartExtDtdSignal(Signal).SystemId;
    FActivityStatus := asExtDtdActive;
  end else

  if Signal is TXmlStartIntDtdSignal then begin
    DtdModel.PreparationStatus := PS_INCOMPLETE;
    DtdModel.IntSubsetSysId := TXmlStartIntDtdSignal(Signal).SystemId;
    FDocStandalone := TXmlStartIntDtdSignal(Signal).XmlStandalone;
    FActivityStatus := asIntDtdActive;
  end else

  if Signal is TXmlCompletedSignal then begin
    if FActivityStatus = asIntDtdActive then begin
      if DtdModel.PreparationStatus = PS_INCOMPLETE then
        DtdModel.PreparationStatus := PS_INT_SUBSET_COMPLETED;
    end else if FActivityStatus = asExtDtdActive then begin
      if DtdModel.PreparationStatus = PS_INCOMPLETE then
        DtdModel.PreparationStatus := PS_COMPLETED;
    end else
      raise EParserException.Create('Internal Parser Exception');
    FActivityStatus := asInactive;
    FDocStandalone := STANDALONE_UNSPECIFIED;
  end else

  if Signal is TXmlAbortedSignal then begin
    Reset;
  end else

  if not (ssDtd in Signal.Scope) then
    raise EParserException.Create('Internal Parser Exception');
end;

procedure TXmlDtdModelBuilder.Reset;
begin
  FActivityStatus := asInactive;
  FDocStandalone := STANDALONE_UNSPECIFIED;
  FIgnoreDeclarations := False;
end;

procedure TXmlDtdModelBuilder.SetDtdModel(const Value: TDtdModel);
begin
  FDtdModel := Value;
end;



// ++++++++++++++++++++++++ TXmlStreamBuilder ++++++++++++++++++++++++++
constructor TXmlStreamBuilder.Create(AOwner: TComponent);
begin
  inherited;
  FIncludeXmlDecl := True;
  FDefaultEncoding := '';
  ResetCurrentEncoding;
  FUseByteOrderMark := [bomUTF16, bomUCS2];
  FOutputSource:= nil;
  FOpenElementsCount:= 0;
  FAttListDeclIsOpen := False;
  FStartElementIsOpen := False;
  FByteCount := 0;
  FCharacterCount := 0;
  FColumnCount := 0;
  FLineFeedCount := 0;
  FTabCount := 0;
end;

procedure TXmlStreamBuilder.DoAfterWrite(const PieceType: TDomPieceType;
                                         const Locator:IDomLocator);
begin
  if Assigned(FOnAfterWrite) then
    FOnAfterWrite(Self, PieceType, Locator);
end;

procedure TXmlStreamBuilder.DoBeforeWrite(const PieceType: TDomPieceType;
                                          const Locator: IDomLocator);
begin
  if Assigned(FOnBeforeWrite) then
    FOnBeforeWrite(Self, PieceType, Locator);
end;

procedure TXmlStreamBuilder.CheckAttListDeclarationClosed(const Sender: TXmlCustomReader;
                                                          const Locator: IDomLocator);
begin
  if FAttListDeclIsOpen then begin
    WriteWideStrings(Sender, Locator, ['>'], False);
    FAttListDeclIsOpen := False;
    DoAfterWrite(xmlAttributeDecl, Locator);
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStreamBuilder.CheckAttListDeclarationOpen(const Sender: TXmlCustomReader;
                                                        const Locator: IDomLocator;
                                                        const ElementName: string);
{$ELSE !NEXTGEN}
procedure TXmlStreamBuilder.CheckAttListDeclarationOpen(const Sender: TXmlCustomReader;
                                                        const Locator: IDomLocator;
                                                        const ElementName: WideString);
{$ENDIF NEXTGEN}
begin
  if FAttListDeclIsOpen then begin
    if FCurrentAttListDeclName <> ElementName then begin
      WriteWideStrings(Sender, Locator, ['>'], False);
      DoAfterWrite(xmlAttributeDecl, Locator);
      DoBeforeWrite(xmlAttributeDecl, Locator);
      WriteWideStrings(Sender, Locator, [#10'<!ATTLIST ', ElementName, #10], False);
      FCurrentAttListDeclName := ElementName;
    end;
  end else begin
    DoBeforeWrite(xmlAttributeDecl, Locator);
    WriteWideStrings(Sender, Locator, [#10'<!ATTLIST ', ElementName, #10], False);
    FCurrentAttListDeclName := ElementName;
    FAttListDeclIsOpen := True;
  end;
end;

procedure TXmlStreamBuilder.CheckStartElementClosed(const Sender: TXmlCustomReader;
                                                    const Locator: IDomLocator;
                                                    ElementIsEmpty: Boolean);
var
{$IFDEF NEXTGEN}
  EmptyCloseTagStr: string;
{$ELSE !NEXTGEN}
  EmptyCloseTagStr: WideString;
{$ENDIF NEXTGEN}
begin
  if FStartElementIsOpen then begin
    if ElementIsEmpty then
      EmptyCloseTagStr := '/';
    WriteWideStrings(Sender, Locator, [EmptyCloseTagStr, '>'], False);
    FStartElementIsOpen := False;
    DoAfterWrite(xmlStartTag, Locator);
  end;
end;

function TXmlStreamBuilder.GetCurrentEncoding: string;
begin
  if Assigned(FOutputSource)
    then Result := FOutputSource.Encoding
    else Result := 'UTF-8';
end;

procedure TXmlStreamBuilder.ResetCurrentEncoding;
begin
  if Assigned(FOutputSource) then begin
    if DefaultEncoding = ''
      then FOutputSource.Encoding := 'UTF-8'
      else FOutputSource.Encoding := DefaultEncoding;
  end;
end;

procedure TXmlStreamBuilder.SetDefaultEncoding(const Value: string);
var
  Dummy: TUnicodeCodec;
begin
  if Value = '' then begin
    FDefaultEncoding := '';
  end else begin
    Dummy := TEncodingRepository.CreateCodecByAlias(Value);
    if not Assigned(Dummy) then
      raise ENot_Supported_Err.Create('Encoding not supported error.');
    Dummy.Free;
    FDefaultEncoding := Value;
  end;
  ResetCurrentEncoding;
end;

procedure TXmlStreamBuilder.SetIncludeXmlDecl(const Value: Boolean);
begin
  FIncludeXmlDecl := Value;
end;

procedure TXmlStreamBuilder.SetOutputSource(const Value: TXmlOutputSource);
begin
  FOutputSource := Value;
  ResetCurrentEncoding;
end;

procedure TXmlStreamBuilder.SetUseByteOrderMark(const Value: TXmlBOMOpt);
begin
  FUseByteOrderMark := Value;
end;

{$IFDEF NEXTGEN}
function TXmlStreamBuilder.TrySetCurrentEncoding(const Value: string): Boolean;
{$ELSE !NEXTGEN}
function TXmlStreamBuilder.TrySetCurrentEncoding(const Value: WideString): Boolean;
{$ENDIF NEXTGEN}
begin
  Result := True;
  if Assigned(FOutputSource) then begin
    try
      if Value = ''
        then FOutputSource.Encoding := 'UTF-8'
        else FOutputSource.Encoding := Value;
    except
      on ENot_Supported_Err do
        Result := False;
    end;
  end;
end;

procedure TXmlStreamBuilder.WriteByteOrderMark(const Sender: TXmlCustomReader;
                                               const Locator: IDomLocator;
                                                 out ByteCount: Integer);
begin
  ByteCount := 0;
  if not Assigned(FOutputSource) then Exit;

  try
    if (FOutputSource.FCodec is TUTF16BECodec) then begin
      if (bomUTF16 in UseByteOrderMark) then
        ByteCount := FOutputSource.WriteByteOrderMark;
    end else if FOutputSource.FCodec is TUTF16LECodec then begin
      if (bomUTF16 in UseByteOrderMark) then
        ByteCount := FOutputSource.WriteByteOrderMark;
    end else if FOutputSource.FCodec is TUCS2BECodec then begin
      if (bomUCS2 in UseByteOrderMark) then
        ByteCount := FOutputSource.WriteByteOrderMark;
    end else if FOutputSource.FCodec is TUCS2LECodec then begin
      if (bomUCS2 in UseByteOrderMark) then
        ByteCount := FOutputSource.WriteByteOrderMark;
    end else if FOutputSource.FCodec is TUTF8Codec then begin
      if (bomUTF8 in UseByteOrderMark) then
        ByteCount := FOutputSource.WriteByteOrderMark;
    end;
  except
    raise EParserException.Create('Signal Processing Exception');
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStreamBuilder.WriteWideString(const S: string;
                                            const UseCharRefs: Boolean);
const
  ERROR_STR: string = 'Invalid Character';
var
  CharRef: string;
{$ELSE !NEXTGEN}
procedure TXmlStreamBuilder.WriteWideString(const S: WideString;
                                            const UseCharRefs: Boolean);
const
  ERROR_STR: string = 'Invalid Character';
var
  CharRef: WideString;
{$ENDIF NEXTGEN}
  HighSurrogate, LowSurrogate: Word;
  I, J: Integer;
  BytesUsed, BytesUsed_2: Integer;
  UCS4: UCS4Char;
begin
  if not Assigned(FOutputSource) then Exit;
  try
    I := FirstIndex;
    while I <= Length(S)-AdjustIndex do begin
      UCS4 := Ord(S[I]);

      // TestCheck for UTF-16 surrogates and recalculate UCS-4 codepoint if necessary:
      case UCS4 of
      $D800..$DBFF: // High surrogate of Unicode character [$10000..$10FFFF]
        begin
          if I = Length(S)-AdjustIndex // End of WideString --> No low surrogate found
            then raise EWriteError.Create(ERROR_STR);
          HighSurrogate := Ord(S[I]);
          Inc(I);
          LowSurrogate := Ord(S[I]);
          if not IsUtf16LowSurrogate(LowSurrogate)  // No low surrogate found
            then raise EWriteError.Create(ERROR_STR);

          UCS4 := UTF16SurrogateToInt(HighSurrogate, LowSurrogate);
        end;
      $DC00..$DFFF: // Low surrogate, but no preceeding high surrogate
        raise EWriteError.Create(ERROR_STR);
      end; {case ...}

      try
        FOutputSource.WriteUCS4Char(UCS4, BytesUsed);
      except
        on EConvertError do
          if UseCharRefs then begin
            CharRef := XmlIntToCharRefHex(UCS4);
            BytesUsed := 0;
            for J := FirstIndex to Length(CharRef)-AdjustIndex do begin
              FOutputSource.WriteUCS4Char(Ord(CharRef[J]), BytesUsed_2);
              BytesUsed := BytesUsed + BytesUsed_2;
            end;
          end else
            raise;
      end;

      // Update position properties:
      case UCS4 of
        LF: begin
          Inc(FLineFeedCount);
          FColumnCount := 0;
          FTabCount := 0;
        end;
        TAB: begin
          Inc(FTabCount);
          Inc(FColumnCount);
        end
      else
        Inc(FColumnCount);
      end;
      FByteCount := FByteCount + BytesUsed;
      Inc(FCharacterCount);

      Inc(I);
    end; {while ...}

  except
    on EConvertError do raise EWriteError.Create(ERROR_STR);
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStreamBuilder.WriteWideStrings(const Sender: TXmlCustomReader;
                                             const Locator: IDomLocator;
                                             const XmlStrgs: array of string;
                                             const UseCharRefs: Boolean);
{$ELSE !NEXTGEN}
procedure TXmlStreamBuilder.WriteWideStrings(const Sender: TXmlCustomReader;
                                             const Locator: IDomLocator;
                                             const XmlStrgs: array of WideString;
                                             const UseCharRefs: Boolean);
{$ENDIF NEXTGEN}
var
  I: Integer;
begin
  if not Assigned(FOutputSource) then Exit;
  for I := 0 to High(XmlStrgs) do begin
    try
      WriteWideString(XmlStrgs[I], UseCharRefs);
    except
      SendErrorNotification(Sender, ET_INVALID_CHARACTER, Locator, XmlStrgs[I], '');                                                                  
    end;
  end;
end;

procedure TXmlStreamBuilder.ProcessSignal(const Signal: TXmlSignal);
begin
  if not (Signal is TXmlAttributeDefinitionSignal) then
    CheckAttListDeclarationClosed(Signal.Reader, Signal);

  if not (Signal is TXmlAttributeSignal) and not (Signal is TXmlEndElementSignal) then
    CheckStartElementClosed(Signal.Reader, Signal, False);

  if Signal is TXmlAttributeDefinitionSignal then begin
    WriteAttributeDefinitionSignal(TXmlAttributeDefinitionSignal(Signal));

  end else if Signal is TXmlAttributeSignal then begin
    WriteAttributeSignal(TXmlAttributeSignal(Signal));

  end else if Signal is TXmlCDataSignal then begin
    WriteCDataSignal(TXmlCDataSignal(Signal));

  end else if Signal is TXmlCommentSignal then begin
    WriteCommentSignal(TXmlCommentSignal(Signal));

  end else if Signal is TXmlDoctypeSignal then begin
    WriteDoctypeSignal(TXmlDoctypeSignal(Signal));

  end else if Signal is TXmlElementTypeDeclarationSignal then begin
    WriteElementTypeDeclarationSignal(TXmlElementTypeDeclarationSignal(Signal));

  end else if Signal is TXmlEndElementSignal then begin
    WriteEndElementSignal(TXmlEndElementSignal(Signal));

  end else if Signal is TXmlEndPrefixMappingSignal then begin
    // do nothing;

  end else if Signal is TXmlEntityDeclarationSignal then begin
    WriteEntityDeclarationSignal(TXmlEntityDeclarationSignal(Signal));

  end else if Signal is TXmlEntityRefSignal then begin
    WriteEntityRefSignal(TXmlEntityRefSignal(Signal));

  end else if Signal is TXmlNotationDeclarationSignal then begin
    WriteNotationDeclarationSignal(TXmlNotationDeclarationSignal(Signal));

  end else if Signal is TXmlParameterEntityDeclarationSignal then begin
    WriteParameterEntityDeclarationSignal(TXmlParameterEntityDeclarationSignal(Signal));

  end else if Signal is TXmlPCDATASignal then begin
    WritePCDATASignal(TXmlPCDATASignal(Signal));

  end else if Signal is TXmlProcessingInstructionSignal then begin
    WriteProcessingInstructionSignal(TXmlProcessingInstructionSignal(Signal));

  end else if Signal is TXmlSkippedEntitySignal then begin
    WriteSkippedEntitySignal(TXmlSkippedEntitySignal(Signal));

  end else if Signal is TXmlStartDocumentSignal then begin
    WriteStartDocumentSignal(TXmlStartDocumentSignal(Signal));

  end else if Signal is TXmlStartDocumentFragmentSignal then begin
    WriteStartDocumentFragmentSignal(TXmlStartDocumentFragmentSignal(Signal));

  end else if Signal is TXmlStartElementSignal then begin
    WriteStartElementSignal(TXmlStartElementSignal(Signal));

  end else if Signal is TXmlStartExtDtdSignal then begin
    WriteStartExtDtdSignal(TXmlStartExtDtdSignal(Signal));

  end else if Signal is TXmlStartIntDtdSignal then begin
    WriteStartIntDtdSignal(TXmlStartIntDtdSignal(Signal));

  end else if Signal is TXmlStartPrefixMappingSignal then begin
    // do nothing;

  end else if Signal is TXmlCompletedSignal then begin
    WriteCompletedSignal(TXmlCompletedSignal(Signal));

  end else if Signal is TXmlAbortedSignal then begin
    Reset;

  end else
    raise EParserException.Create('Internal Parser Exception');

end;

procedure TXmlStreamBuilder.WriteAttributeSignal(const Signal: TXmlAttributeSignal);
begin
  WriteWideStrings(Signal.Reader, Signal, [' '], False);
  DoBeforeWrite(xmlAttribute, Signal); // Trigger the OnBeforeWrite event immediately before serializing the attribute name.
  WriteWideStrings(Signal.Reader, Signal, [Signal.Name, '="'], False);
  WriteWideStrings(Signal.Reader, Signal, [EscapeDelimiters(Signal.Value)], True);
  WriteWideStrings(Signal.Reader, Signal, ['"'], False);
  DoAfterWrite(xmlAttribute, Signal);
end;

procedure TXmlStreamBuilder.WriteCDATASignal(const Signal: TXmlCDataSignal);
begin
  DoBeforeWrite(xmlCDATA, Signal);
  WriteWideStrings(Signal.Reader, Signal, ['<![CDATA[', Signal.Data, ']]>'], False);
  DoAfterWrite(xmlCDATA, Signal);
end;

procedure TXmlStreamBuilder.WriteCommentSignal(const Signal: TXmlCommentSignal);
begin
  DoBeforeWrite(xmlComment, Signal);
  if FOpenElementsCount > 0
    then WriteWideStrings(Signal.Reader, Signal, ['<!--', Signal.Data, '-->'], False)
    else WriteWideStrings(Signal.Reader, Signal, ['<!--', Signal.Data, '-->'#10], False);
  DoAfterWrite(xmlComment, Signal);
end;

procedure TXmlStreamBuilder.WriteDoctypeSignal(const Signal: TXmlDoctypeSignal);
{$IFDEF NEXTGEN}
const
  SQ: string = #39; // code of '
  DQ: string = #34; // code of "
var
  Qm: string;
{$ELSE !NEXTGEN}
const
  SQ: WideString = #39; // code of '
  DQ: WideString = #34; // code of "
var
  Qm: WideString;
{$ENDIF NEXTGEN}
begin
  DoBeforeWrite(xmlDoctype, Signal);
  WriteWideStrings(Signal.Reader, Signal, ['<!DOCTYPE ', Signal.DoctypeName], False);
  if Signal.SystemId = '' then begin
    if Signal.PublicId <> '' then
{$IFDEF NEXTGEN}
      WriteWideStrings(Signal.Reader, Signal, [string(' PUBLIC "'), Signal.PublicId, string('"')], False);
{$ELSE !NEXTGEN}
      WriteWideStrings(Signal.Reader, Signal, [WideString(' PUBLIC "'), Signal.PublicId, WideString('"')], False);
{$ENDIF NEXTGEN}
  end else begin
    if Pos(DQ, Signal.SystemId) = 0
      then Qm := DQ
      else Qm := SQ;
    if Signal.PublicId = ''
{$IFDEF NEXTGEN}
      then WriteWideStrings(Signal.Reader, Signal, [string(' SYSTEM '), Qm, Signal.SystemId, Qm], False)
      else WriteWideStrings(Signal.Reader, Signal, [string(' PUBLIC "'), Signal.PublicId, string('" '), qm, Signal.SystemId, qm], False);
{$ELSE !NEXTGEN}
      then WriteWideStrings(Signal.Reader, Signal, [WideString(' SYSTEM '), Qm, Signal.SystemId, Qm], False)
      else WriteWideStrings(Signal.Reader, Signal, [WideString(' PUBLIC "'), Signal.PublicId, WideString('" '), qm, Signal.SystemId, qm], False);
{$ENDIF NEXTGEN}
  end;
  if Length(Signal.Data) = 0
    then WriteWideStrings(Signal.Reader, Signal, [' >'#10], False)
    else WriteWideStrings(Signal.Reader, Signal, [' [',Signal.Data,'] >'#10], False);
  DoAfterWrite(xmlDoctype, Signal);
end;

procedure TXmlStreamBuilder.WriteEndElementSignal(const Signal: TXmlEndElementSignal);
begin
  DoBeforeWrite(xmlEndTag, Signal);
  if FStartElementIsOpen then
    CheckStartElementClosed(Signal.Reader, Signal, True)
  else
    WriteWideStrings(Signal.Reader, Signal, ['</', Signal.TagName, '>'], False);
  Dec(FOpenElementsCount);
  if FOpenElementsCount = 0 then
    WriteWideStrings(Signal.Reader, Signal, [#10], False);
  DoAfterWrite(xmlEndTag, Signal);
end;

procedure TXmlStreamBuilder.WriteEntityRefSignal(const Signal: TXmlEntityRefSignal);
begin
  DoBeforeWrite(xmlEntityRef, Signal);
  WriteWideStrings(Signal.Reader, Signal,['&', Signal.EntityName, ';'], False);
  DoAfterWrite(xmlEntityRef, Signal);
end;

procedure TXmlStreamBuilder.WriteCompletedSignal(const Signal: TXmlCompletedSignal);
begin
  ResetCurrentEncoding;
  FAttListDeclIsOpen := False;
  FStartElementIsOpen := False;
  FOpenElementsCount := 0;
end;

procedure TXmlStreamBuilder.WritePCDATASignal(const Signal: TXmlPCDATASignal);
var
  I: Integer;
  Content: TUtilsCustomWideStr;
{$IFDEF NEXTGEN}
  S: string;
{$ELSE !NEXTGEN}
  S: WideString;
{$ENDIF NEXTGEN}
begin
  DoBeforeWrite(xmlPCDATA, Signal);
  Content:= TUtilsCustomWideStr.Create;
  try
    for I := FirstIndex to Length(Signal.Data)-AdjustIndex do begin
      case Ord(Signal.Data[I]) of
        AMP: Content.AddWideString('&amp;'); // Ampersand ('&')
        LT:  Content.AddWideString('&lt;');  // Less than ('<')
        GT:  Content.AddWideString('&gt;');  // Greater than ('>')
        CR:  Content.AddWideString('&#xD;'); // Carriage Return
      else
        Content.AddWideChar(Signal.Data[I]);
      end;
    end;
    S := Content.Value;
  finally
    Content.Free;
  end;
  WriteWideStrings(Signal.Reader, Signal, [S], True);
  DoAfterWrite(xmlPCDATA, Signal);
end;

procedure TXmlStreamBuilder.WriteProcessingInstructionSignal(const Signal: TXmlProcessingInstructionSignal);
begin
  DoBeforeWrite(xmlProcessingInstruction, Signal);
  if Signal.Data = '' then begin
    if FOpenElementsCount > 0
      then WriteWideStrings(Signal.Reader, Signal, ['<?', Signal.Target, '?>'], False)
      else WriteWideStrings(Signal.Reader, Signal, ['<?', Signal.Target, '?>'#10], False);
  end else begin
    if FOpenElementsCount > 0
      then WriteWideStrings(Signal.Reader, Signal, ['<?', Signal.Target, ' ', Signal.Data, '?>'], False)
      else WriteWideStrings(Signal.Reader, Signal, ['<?', Signal.Target, ' ', Signal.Data, '?>'#10], False);
  end;
  DoAfterWrite(xmlProcessingInstruction, Signal);
end;

procedure TXmlStreamBuilder.WriteSkippedEntitySignal(const Signal: TXmlSkippedEntitySignal);
begin
                                                                          
end;

procedure TXmlStreamBuilder.WriteStartDocumentSignal(const Signal: TXmlStartDocumentSignal);
var
{$IFDEF NEXTGEN}
  NewEncName: string;
{$ELSE !NEXTGEN}
  NewEncName: WideString;
{$ENDIF NEXTGEN}
begin
  FAttListDeclIsOpen := False;
  FStartElementIsOpen := False;
  FOpenElementsCount := 0;
  FByteCount:= 0;
  FCharacterCount:= 0;
  FColumnCount:= 0;
  FLineFeedCount:= 0;
  FTabCount:= 0;

  if DefaultEncoding = '' then begin
    if Signal.EncodingName = ''
      then NewEncName := 'UTF-8'
      else NewEncName := Signal.EncodingName;
  end else
    NewEncName := DefaultEncoding;                                                                     

  if not TrySetCurrentEncoding(NewEncName) then begin
    SendErrorNotification(Signal.Reader, ET_ENCODING_NOT_SUPPORTED, Signal, NewEncName, '');
    Exit;
  end;

  DoBeforeWrite(xmlXmlDeclaration, Signal);

  WriteByteOrderMark(Signal.Reader, Signal, FByteCount);

  if IncludeXmlDecl then begin
    if Signal.Version = ''
      then WriteWideStrings(Signal.Reader, Signal, ['<?xml version="1.0"'], False)
      else WriteWideStrings(Signal.Reader, Signal, ['<?xml version="', Signal.Version, '"'], False);
                                                 
    WriteWideStrings(Signal.Reader, Signal, [' encoding="', NewEncName, '"'], False);
    case Signal.StandaloneDecl of
      STANDALONE_YES: WriteWideStrings(Signal.Reader, Signal, [' standalone="yes"'], False);
      STANDALONE_NO: WriteWideStrings(Signal.Reader, Signal, [' standalone="no"'], False);
    end;
    WriteWideStrings(Signal.Reader, Signal, ['?>'], False);
  end;

  DoAfterWrite(xmlXmlDeclaration, Signal);
end;

procedure TXmlStreamBuilder.WriteStartDocumentFragmentSignal(const Signal: TXmlStartDocumentFragmentSignal);
var
{$IFDEF NEXTGEN}
  NewEncName: string;
{$ELSE !NEXTGEN}
  NewEncName: WideString;
{$ENDIF NEXTGEN}
begin
  FAttListDeclIsOpen := False;
  FStartElementIsOpen := False;
  FOpenElementsCount := 0;
  FByteCount:= 0;
  FCharacterCount:= 0;
  FColumnCount:= 0;
  FLineFeedCount:= 0;
  FTabCount:= 0;

  if DefaultEncoding = '' then begin
    if Signal.EncodingName = ''
      then NewEncName := 'UTF-8'
      else NewEncName := Signal.EncodingName;
  end else
    NewEncName := DefaultEncoding;                                                                    

  if not TrySetCurrentEncoding(NewEncName) then begin
    SendErrorNotification(Signal.Reader, ET_ENCODING_NOT_SUPPORTED, Signal, NewEncName, '');
    Exit;
  end;

  DoBeforeWrite(xmlXmlDeclaration, Signal);

  WriteByteOrderMark(Signal.Reader, Signal, FByteCount);

  DoAfterWrite(xmlXmlDeclaration, Signal);
end;

procedure TXmlStreamBuilder.WriteStartElementSignal(const Signal: TXmlStartElementSignal);
begin
  DoBeforeWrite(xmlStartTag, Signal);
//  with Signal do begin
    Inc(FOpenElementsCount);
    FStartElementIsOpen := True;
    WriteWideStrings(Signal.Reader, Signal, ['<', Signal.TagName], False);
//  end;
end;

procedure TXmlStreamBuilder.WriteAttributeDefinitionSignal(const Signal: TXmlAttributeDefinitionSignal);

{$IFDEF NEXTGEN}
  function XmlDataTypeToAttTypeStr(const DataType: TXmlDataType): string;
{$ELSE !NEXTGEN}
  function XmlDataTypeToAttTypeStr(const DataType: TXmlDataType): WideString;
{$ENDIF NEXTGEN}
  begin
    case DataType of
      AS_STRING_DATATYPE:   Result := 'CDATA';
      AS_ID_DATATYPE:       Result := 'ID';
      AS_IDREF_DATATYPE:    Result := 'IDREF';
      AS_IDREFS_DATATYPE:   Result := 'IDREFS';
      AS_ENTITY_DATATYPE:   Result := 'ENTITY';
      AS_ENTITIES_DATATYPE: Result := 'ENTITIES';
      AS_NMTOKEN_DATATYPE:  Result := 'NMTOKEN';
      AS_NMTOKENS_DATATYPE: Result := 'NMTOKENS';
      AS_NOTATION_DATATYPE: Result := 'NOTATION';
    else
      raise EConvertError.Create('Datatype conversion not supported');;
    end;
  end;

const
  DQ: WideChar = #$22; // code of "
  SQ: WideChar = #$27; // code of '
var
  I: Integer;
begin
  CheckAttListDeclarationOpen(Signal.Reader, Signal, Signal.ElementName);
  WriteWideStrings(Signal.Reader, Signal, ['          ', Signal.AttributeName, ' '], False);
  if Signal.Enumeration.Count > 0 then begin
    WriteWideStrings(Signal.Reader, Signal, ['('], False);
    for I := 0 to Pred(Signal.Enumeration.Count) do begin
      WriteWideStrings(Signal.Reader, Signal, [' ',Signal.Enumeration[I],' '], False);
      if I < Pred(Signal.Enumeration.Count) then
        WriteWideStrings(Signal.Reader, Signal, ['|'], False);
    end;
    WriteWideStrings(Signal.Reader, Signal, [') '], False);
  end else
    WriteWideStrings(Signal.Reader, Signal, [XmlDataTypeToAttTypeStr(Signal.AttributeType), ' '], False);
  case Signal.Constraint of
    AVC_FIXED:    WriteWideStrings(Signal.Reader, Signal, [' #FIXED'], False);
    AVC_IMPLIED:  WriteWideStrings(Signal.Reader, Signal, [' #IMPLIED'], False);
    AVC_REQUIRED: WriteWideStrings(Signal.Reader, Signal, [' #REQUIRED'], False);
  end;
  if Signal.Constraint in [AVC_DEFAULT, AVC_FIXED] then
    if Pos(DQ, Signal.DefaultValue) > 0
      then WriteWideStrings(Signal.Reader, Signal, [' ', SQ, Signal.DefaultValue, SQ, #10], False)
      else WriteWideStrings(Signal.Reader, Signal, [' ', DQ, Signal.DefaultValue, DQ, #10], False);
end;

procedure TXmlStreamBuilder.WriteElementTypeDeclarationSignal(const Signal: TXmlElementTypeDeclarationSignal);
begin
  DoBeforeWrite(xmlElementDecl, Signal);
  WriteWideStrings(Signal.Reader, Signal, [#10'<!ELEMENT ', Signal.ElementName, ' ', Signal.Data, ' >'], False);
  DoAfterWrite(xmlElementDecl, Signal);
end;

procedure TXmlStreamBuilder.WriteEntityDeclarationSignal(const Signal: TXmlEntityDeclarationSignal);
const
  SQ: WideChar = #39; // code of '
  DQ: WideChar = #34; // code of "
begin
  DoBeforeWrite(xmlEntityDecl, Signal);
  WriteWideStrings(Signal.Reader, Signal, [#10'<!ENTITY ', Signal.EntityName, ' '], False);
  if ((Signal.PublicId = '') and (Signal.SystemId = '')) then begin
    if Pos(DQ, Signal.EntityValue) > 0
      then WriteWideStrings(Signal.Reader, Signal, [SQ, Signal.EntityValue, SQ], False)
      else WriteWideStrings(Signal.Reader, Signal, [DQ, Signal.EntityValue, DQ], False);
  end else begin
    if Signal.PublicId = '' then begin
      if Pos(DQ, Signal.SystemId) > 0
        then WriteWideStrings(Signal.Reader, Signal, ['SYSTEM ', SQ, Signal.SystemId, SQ], False)
        else WriteWideStrings(Signal.Reader, Signal, ['SYSTEM ', DQ, Signal.SystemId, DQ], False);
    end else begin
      if Signal.SystemId = '' then begin
        WriteWideStrings(Signal.Reader, Signal, [' PUBLIC "', Signal.PublicId, '"'], False);
      end else begin
        if Pos(DQ, Signal.SystemId) > 0
          then WriteWideStrings(Signal.Reader, Signal, ['PUBLIC "', Signal.PublicId, '" ', SQ, Signal.SystemId, SQ], False)
          else WriteWideStrings(Signal.Reader, Signal, ['PUBLIC "', Signal.PublicId, '" "', Signal.SystemId, '"'], False);
      end;
    end; {if ...}
    if Signal.NotationName <> '' then
      WriteWideStrings(Signal.Reader, Signal, [' NDATA ', Signal.NotationName], False);
  end;
  WriteWideStrings(Signal.Reader, Signal, ['>'], False);
  DoAfterWrite(xmlEntityDecl, Signal);
end;

procedure TXmlStreamBuilder.WriteNotationDeclarationSignal(const Signal: TXmlNotationDeclarationSignal);
const
  SQ: WideChar = #39; // code of '
  DQ: WideChar = #34; // code of "
begin
  DoBeforeWrite(xmlNotationDecl, Signal);
  WriteWideStrings(Signal.Reader, Signal, [#10'<!NOTATION ', Signal.NotationName, ' '], False);
  if Signal.PublicId = '' then begin
    if Pos(DQ, Signal.SystemId) > 0
      then WriteWideStrings(Signal.Reader, Signal, ['SYSTEM ', SQ, Signal.SystemId, SQ], False)
      else WriteWideStrings(Signal.Reader, Signal, ['SYSTEM ', DQ, Signal.SystemId, DQ], False);
  end else begin
    if Signal.SystemId = '' then begin
      WriteWideStrings(Signal.Reader, Signal, [' PUBLIC "',Signal.PublicId,'"'], False);
    end else begin
      if Pos(DQ, Signal.SystemId) > 0
        then WriteWideStrings(Signal.Reader, Signal, ['PUBLIC "', Signal.PublicId, '" ', SQ, Signal.SystemId, SQ], False)
        else WriteWideStrings(Signal.Reader, Signal, ['PUBLIC "', Signal.PublicId, '" "', Signal.SystemId, '"'], False);
    end;
  end; {if ...}
  WriteWideStrings(Signal.Reader, Signal, ['>'], False);
  DoAfterWrite(xmlNotationDecl, Signal);
end;

procedure TXmlStreamBuilder.WriteParameterEntityDeclarationSignal(const Signal: TXmlParameterEntityDeclarationSignal);
const
  SQ: WideChar = #39; // code of '
  DQ: WideChar = #34; // code of "
begin
  DoBeforeWrite(xmlParameterEntityDecl, Signal);
  WriteWideStrings(Signal.Reader, Signal, [#10'<!ENTITY % ', Signal.entityName, ' '], False);
  if ((Signal.PublicId = '') and (Signal.SystemId = '')) then begin
    if Pos(DQ, Signal.EntityValue) > 0
      then WriteWideStrings(Signal.Reader, Signal, [SQ, Signal.EntityValue, SQ], False)
      else WriteWideStrings(Signal.Reader, Signal, [DQ, Signal.EntityValue, DQ], False);
  end else begin
    if Signal.PublicId = '' then begin
      if Pos(DQ, Signal.SystemId) > 0
        then WriteWideStrings(Signal.Reader, Signal, ['SYSTEM ', SQ, Signal.SystemId, SQ], False)
        else WriteWideStrings(Signal.Reader, Signal, ['SYSTEM ', DQ, Signal.SystemId, DQ], False);
    end else begin
      if Signal.SystemId = '' then begin
        WriteWideStrings(Signal.Reader, Signal, [' PUBLIC "',Signal.PublicId,'"'], False);
      end else begin
        if Pos(DQ, Signal.SystemId) > 0
          then WriteWideStrings(Signal.Reader, Signal, ['PUBLIC "', Signal.PublicId, '" ', SQ, Signal.SystemId, SQ], False)
          else WriteWideStrings(Signal.Reader, Signal, ['PUBLIC "', Signal.PublicId, '" "', Signal.SystemId, '"'], False);
      end;
    end;
  end;
  WriteWideStrings(Signal.Reader, Signal, ['>'], False);
  DoAfterWrite(xmlParameterEntityDecl, Signal);
end;

procedure TXmlStreamBuilder.WriteStartExtDtdSignal(const Signal: TXmlStartExtDtdSignal);
var
{$IFDEF NEXTGEN}
  NewEncName: string;
{$ELSE !NEXTGEN}
  NewEncName: WideString;
{$ENDIF NEXTGEN}
begin
  FAttListDeclIsOpen := False;
  FByteCount:= 0;
  FCharacterCount:= 0;
  FColumnCount:= 0;
  FLineFeedCount:= 0;
  FTabCount:= 0;

  if DefaultEncoding = '' then begin
    if Signal.EncodingName = ''
      then NewEncName := 'UTF-8'
      else NewEncName := Signal.EncodingName;
  end else
    NewEncName := DefaultEncoding;                                                                    

  if not TrySetCurrentEncoding(NewEncName) then begin
    SendErrorNotification(Signal.Reader, ET_ENCODING_NOT_SUPPORTED, Signal, NewEncName, '');
    Exit;
  end;

  DoBeforeWrite(xmlTextDeclaration, Signal);

  WriteByteOrderMark(Signal.Reader, Signal, FByteCount);

  if IncludeXmlDecl then begin
    if Signal.Version = ''
      then WriteWideStrings(Signal.Reader, Signal, ['<?xml version="1.0"'], False)
      else WriteWideStrings(Signal.Reader, Signal, ['<?xml version="', Signal.Version, '"'], False);
    if NewEncName <> '' then
      WriteWideStrings(Signal.Reader, Signal, [' encoding="', NewEncName, '"'], False);
    WriteWideStrings(Signal.Reader, Signal, ['?>'#10], False);
  end;

  DoAfterWrite(xmlTextDeclaration, Signal);
end;

procedure TXmlStreamBuilder.WriteStartIntDtdSignal(const Signal: TXmlStartIntDtdSignal);
begin
                                                                                             
// To-Do: Add a parameter to TXmlStreamBuilder which controls the
//        following intializations:
//
//  FByteCount := 0;
//  FCharacterCount := 0;
//  FColumnCount := 0;
//  FLineFeedCount := 0;
//  FTabCount := 0;
//

  ResetCurrentEncoding;
  FAttListDeclIsOpen := False;
end;

procedure TXmlStreamBuilder.Reset;
begin
  ResetCurrentEncoding;
  FAttListDeclIsOpen := False;
  FStartElementIsOpen := False;
  FOpenElementsCount:= 0;
end;



// +++++++++++++++++++++++++ TXmlCustomReader ++++++++++++++++++++++++++
constructor TXmlCustomReader.Create(AOwner: TComponent);
begin
  inherited;
  FDOMImpl := nil;
  FErrorReportingEnabled := True;
  FNextHandler := nil;
end;

procedure TXmlCustomReader.Notification(AComponent: TComponent;
                                        Operation: TOperation);
begin
  inherited Notification(AComponent, Operation);
  if Operation = opRemove then begin
    if AComponent = FNextHandler then FNextHandler := nil;
    if AComponent = FDOMImpl then FDOMImpl:= nil;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlCustomReader.ResolveResourceAsWideString(const BaseURI,
                                                             PublicId,
                                                             SystemId: string;
                                                         out S: string;
                                                         out Error: TXmlErrorType);
var
  PId, SId: string;
{$ELSE !NEXTGEN}
procedure TXmlCustomReader.ResolveResourceAsWideString(const BaseURI,
                                                             PublicId,
                                                             SystemId: WideString;
                                                         out S: WideString;
                                                         out Error: TXmlErrorType);
var
  PId, SId: WideString;
{$ENDIF NEXTGEN}
begin
  PId := PublicId;
  SId := SystemId;
  if Assigned(DomImpl) then begin
    DomImpl.ResolveResourceAsWideString(BaseUri, PId, SId, S, Error)
  end else begin
    S := '';
    Error := ET_EXT_ENTITY_RESOURCE_NOT_FOUND;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlCustomReader.SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                                 const Location: IDomLocator;
                                                 const Code,
                                                       Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlCustomReader.SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                                 const Location: IDomLocator;
                                                 const Code,
                                                       Clue: WideString);
{$ENDIF NEXTGEN}
var
  Error: TDomError;
  Ok: Boolean;
begin
  if ErrorReportingEnabled then begin
    Error := TDomError.CreateFromLocator(XmlErrorType, Location, Code, Clue);
    try

      if Assigned(DomImpl) then begin
        Ok := DomImpl.HandleError(Self, Error);
      end else if Error.Severity = DOM_SEVERITY_FATAL_ERROR
        then Ok := False
        else Ok := True;

      if not Ok then
        raise EParserException.Create('Signal Processing Exception');
    finally
      Error.Free;
    end;
  end else if XmlErrorType in ET_FATAL_ERRORS then
    raise EParserException.Create('Signal Processing Exception');
end;

procedure TXmlCustomReader.SetDomImpl(const Impl: TDomImplementation);
begin
  if FDOMImpl = Impl then Exit;
  {$IFDEF VER140+}
  if Assigned(FDOMImpl)
    then FDOMImpl.RemoveFreeNotification(Self);
  {$ENDIF}
  {$IFNDEF MSWINDOWS}
  if Assigned(FDOMImpl)
    then FDOMImpl.RemoveFreeNotification(Self);
  {$ENDIF}
  FDOMImpl := Impl;
  if Assigned(Impl)
    then Impl.FreeNotification(Self);
end;

procedure TXmlCustomReader.SetErrorReportingEnabled(const Value: Boolean);
begin
  FErrorReportingEnabled := Value;
end;



// ++++++++++++++++++++++ TXmlStandardDocReader ++++++++++++++++++++++++
procedure TXmlStandardDocReader.SendAbortedSignal(const Locator: IDomLocator);
var
  XmlAbortedSignal: TXmlAbortedSignal;
begin
  if Assigned(NextHandler) then begin
    XmlAbortedSignal := TXmlAbortedSignal.CreateFromLocator(Self, Locator);
    try
      NextHandler.ProcessSignal(XmlAbortedSignal);
    finally
      XmlAbortedSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteAttribute(const Locator: IDomLocator;
                                               const Name,
                                                     Value: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteAttribute(const Locator: IDomLocator;
                                               const Name,
                                                     Value: WideString);
{$ENDIF NEXTGEN}
var
  XmlAttributeSignal: TXmlAttributeSignal;
begin
  if Assigned(NextHandler) then begin
    XmlAttributeSignal := TXmlAttributeSignal.CreateFromLocator(Self, Locator);
    try
      XmlAttributeSignal.DataType := AS_STRING_DATATYPE;  // Remark: AS_STRING_DATATYPE is the default for unkown attribute data types.
      XmlAttributeSignal.Name := Name;
      XmlAttributeSignal.Value := Value;
      NextHandler.ProcessSignal(XmlAttributeSignal);
    finally
      XmlAttributeSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteCDATA(const Locator: IDomLocator;
                                           const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteCDATA(const Locator: IDomLocator;
                                           const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlCDATASignal: TXmlCDATASignal;
begin
  if Assigned(NextHandler) then begin
    XmlCDATASignal := TXmlCDATASignal.CreateFromLocator(Self, Locator);
    try
      XmlCDATASignal.Data := Content;
      NextHandler.ProcessSignal(XmlCDATASignal);
    finally
      XmlCDATASignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteCharRefDec(const Locator: IDomLocator;
                                                const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteCharRefDec(const Locator: IDomLocator;
                                                const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlPCDATASignal: TXmlPCDATASignal;
  S: TUtilsCustomWideStr;
begin
  S := TUtilsCustomWideStr.Create;
  try
    try
      S.AddUCS4Char(StrToInt64(Content));

      if Assigned(NextHandler) then begin
        XmlPCDATASignal := TXmlPCDATASignal.CreateFromLocator(Self, Locator);
        try
          XmlPCDATASignal.CharRefGenerated := True;
          XmlPCDATASignal.Data := S.Value;
          NextHandler.ProcessSignal(XmlPCDATASignal);
        finally
          XmlPCDATASignal.Free;
        end;
      end;

    except
      SendErrorNotification(ET_INVALID_CHAR_REF, Locator,'&' + Content + ';', '');
    end;
  finally
    S.Free;
  end;
end;

{$IFDEF NEXTGEN}
  function HexToInt64(const Hex: string): Int64;
{$ELSE !NEXTGEN}
  function HexToInt64(const Hex: WideString): Int64;
{$ENDIF NEXTGEN}
  // Remark 1: We cannot use StrToInt64(Concat('$', Hex) here, because under
  //           Delphi for .NET it throws an exception for too many leading
  //           zeros.
  // Remark 2: We must calculate the multiplier inside the case statement
  //           in order to avoid EConvert exceptions for leading zeros.

    function Multiplier(const Position: Integer): Int64; {$IFDEF VER170+}inline;{$ENDIF}
    var
      I: Integer;
    begin
      Result := 1;
      for I := 1 to Position do
        Result := 16 * Result;
    end;

  var
    A, B, I: Integer;
  begin
    Result := 0;
    B := 0;
    for I := Length(Hex)-AdjustIndex downto FirstIndex do begin
      A := Ord(Hex[I]);
      case A of
        48: ;   // '0' -- Do nothing.
        49..57: // '1'..'9'
          try
            Result := Result + (A - 48) * Multiplier(B);
          except
            raise EConvertError.CreateFmt('%S is not a valid integer value.',[Hex]);
          end;
        65..70: // 'A'..'F'
          try
            Result := Result + (A - 55) * Multiplier(B);
          except
            raise EConvertError.CreateFmt('%S is not a valid integer value.',[Hex]);
          end;
        97..102: // 'a'..'f'
          try
            Result := Result + (A - 87) * Multiplier(B);
          except
            raise EConvertError.CreateFmt('%S is not a valid integer value.',[Hex]);
          end;
      else
        raise EConvertError.CreateFmt('%S is not a hexadecimal number.',[Hex]);
      end;
      Inc(B);
    end;
  end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteCharRefHex(const Locator: IDomLocator;
                                                const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteCharRefHex(const Locator: IDomLocator;
                                                const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlPCDATASignal: TXmlPCDATASignal;
  S: TUtilsCustomWideStr;
begin
  S := TUtilsCustomWideStr.Create;
  try
    try
      S.AddUCS4Char(HexToInt64(Content));

      if Assigned(NextHandler) then begin
        XmlPCDATASignal := TXmlPCDATASignal.CreateFromLocator(Self, Locator);
        try
          XmlPCDATASignal.CharRefGenerated := True;
          XmlPCDATASignal.Data := S.Value;
          NextHandler.ProcessSignal(XmlPCDATASignal);
        finally
          XmlPCDATASignal.Free;
        end;
      end;

    except
      SendErrorNotification(ET_INVALID_CHAR_REF, Locator, '&x' + Content + ';', '');
    end;
  finally
    S.Free;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteComment(const Locator: IDomLocator;
                                             const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteComment(const Locator: IDomLocator;
                                             const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlCommentSignal: TXmlCommentSignal;
begin
  if Assigned(NextHandler) then begin
    XmlCommentSignal := TXmlCommentSignal.CreateFromLocator(Self, Locator);
    try
      XmlCommentSignal.Data := Content;
      NextHandler.ProcessSignal(XmlCommentSignal);
    finally
      XmlCommentSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WritePCDATA(const Locator: IDomLocator;
                                            const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WritePCDATA(const Locator: IDomLocator;
                                            const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlPCDATASignal: TXmlPCDATASignal;
begin
  if Assigned(NextHandler) then begin
    XmlPCDATASignal := TXmlPCDATASignal.CreateFromLocator(Self, Locator);
    try
      XmlPCDATASignal.CharRefGenerated := False;
      XmlPCDATASignal.Data := Content;
      NextHandler.ProcessSignal(XmlPCDATASignal);
    finally
      XmlPCDATASignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteProcessingInstruction(const Locator: IDomLocator;
                                                           const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteProcessingInstruction(const Locator: IDomLocator;
                                                           const Content: WideString);
{$ENDIF NEXTGEN}

{$IFDEF CLR}
  procedure AnalysePI(const S: WideString;
                        out Target,
                            Data: WideString);
  var
    I, L, TargetEnd, DataStart: Integer;
  begin
    L := Length(S)-AdjustIndex;

    // Extract Target:
    TargetEnd := L;
    for I := FirstIndex to L do
      if IsXmlWhiteSpace(S[I]) then begin
        TargetEnd := I - 1;
        Break;
      end;
    Target := Copy(S, 1, TargetEnd + AdjustIndex);

    // Extract Data:
    DataStart := L + 1;
    for I := TargetEnd + 1 to L do
      if not IsXmlWhiteSpace(S[I]) then begin
        DataStart := I;
        Break;
      end;
    Data := Copy(S, DataStart+AdjustIndex, L + AdjustIndex);
  end;

{$ELSE}

{$IFDEF NEXTGEN}
  procedure AnalysePI(const S: string;
                        out Target,
                            Data: string);
{$ELSE !NEXTGEN}
  procedure AnalysePI(const S: WideString;
                        out Target,
                            Data: WideString);
{$ENDIF NEXTGEN}
  var
    C: PWideChar;
  begin
    // Extract Target:
    C := PWideChar(S);
    while not IsXmlWhiteSpaceOrNull(C^) do
      Inc(C);
    SetString(Target, PWideChar(S), C - PWideChar(S));

    // Skip white space:
    while IsXmlWhiteSpace(C^) do
      Inc(C);

    // Extract Data:
    Data := Copy(S, C - PWideChar(S) + 1, Length(S));
  end;
{$ENDIF}

var
  XmlProcessingInstructionSignal: TXmlProcessingInstructionSignal;
{$IFDEF NEXTGEN}
  TargetName, PIData: string;
{$ELSE !NEXTGEN}
  TargetName, PIData: WideString;
{$ENDIF NEXTGEN}
begin
  if Assigned(NextHandler) then begin
    XmlProcessingInstructionSignal := TXmlProcessingInstructionSignal.CreateFromLocator(Self, Locator);
    try
      AnalysePI(Content, TargetName, PIData);
      XmlProcessingInstructionSignal.Target := TargetName;
      XmlProcessingInstructionSignal.Data := PIData;
      NextHandler.ProcessSignal(XmlProcessingInstructionSignal);
    finally
      XmlProcessingInstructionSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteStartDocument(const Locator: IDomLocator;
                                                   const InputEnc,
                                                         Version,
                                                         EncName: string;
                                                         SdDl: TDomStandalone);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteStartDocument(const Locator: IDomLocator;
                                                   const InputEnc,
                                                         Version,
                                                         EncName: WideString;
                                                         SdDl: TDomStandalone);
{$ENDIF NEXTGEN}
var
  XmlStartDocumentSignal: TXmlStartDocumentSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartDocumentSignal := TXmlStartDocumentSignal.CreateFromLocator(Self, Locator);
    try
      XmlStartDocumentSignal.InputEncoding := InputEnc;
      XmlStartDocumentSignal.Version := Version;
      XmlStartDocumentSignal.EncodingName := EncName;
      XmlStartDocumentSignal.StandaloneDecl := SdDl;
      NextHandler.ProcessSignal(XmlStartDocumentSignal);
    finally
      XmlStartDocumentSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteStartDocumentFragment(const Locator: IDomLocator;
                                                           const EncName: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteStartDocumentFragment(const Locator: IDomLocator;
                                                           const EncName: WideString);
{$ENDIF NEXTGEN}
var
  XmlStartDocumentFragmentSignal: TXmlStartDocumentFragmentSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartDocumentFragmentSignal := TXmlStartDocumentFragmentSignal.CreateFromLocator(Self, Locator);
    try
      XmlStartDocumentFragmentSignal.EncodingName := EncName;
      NextHandler.ProcessSignal(XmlStartDocumentFragmentSignal);
    finally
      XmlStartDocumentFragmentSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteStartElement(const Locator: IDomLocator;
                                                  const TagName: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteStartElement(const Locator: IDomLocator;
                                                  const TagName: WideString);
{$ENDIF NEXTGEN}
var
  XmlStartElementSignal: TXmlStartElementSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartElementSignal := TXmlStartElementSignal.CreateFromLocator(Self, Locator);
    try
      XmlStartElementSignal.TagName := TagName;
      NextHandler.ProcessSignal(XmlStartElementSignal);
    finally
      XmlStartElementSignal.Free;
    end;
  end; {if ...}
end;

{$IFDEF CLR}
procedure TXmlStandardDocReader.WriteStartTag(const Locator: IDomLocator;
                                                    Content: WideString;
                                                out TagName: WideString);
const
  SQ: WideChar = #39;  // code of '
  DQ: WideChar = #34;  // code of "
  EQ: WideChar = #61;  // code of =
var
  C: WideChar;
  I, L: Integer;
  Head, Tail: Integer;
  AttrNames: TUtilsWideStringList;
  AttrName, AttrValue: WideString;
  QuotationMark: WideChar;
begin
  AttrNames := TUtilsWideStringList.Create;
  try
    AttrNames.Sorted := True;
    AttrNames.Duplicates := dupError;
    L := Length(Content);

    // Find tag name:
    Tail := L;
    for I := 1 to L do
      if IsXmlWhiteSpace(Content[I]) then begin
        Tail := I - 1;
        Break;
      end;
    TagName := Copy(Content, 1, Tail);
    WriteStartElement(Locator, TagName);

    // Skip white space:
    Head := L + 1;
    for I := Tail + 1 to L do
      if not IsXmlWhiteSpace(Content[I]) then begin
        Head := I;
        Break;
      end;

    while Head <= L do begin

      // Find next attribute name:
      Tail := L;
      for I := Head to L do begin
        C := Content[I];
        if IsXmlWhiteSpace(C) or (C = EQ) then begin
          Tail := I - 1;
          Break;
        end;
      end;
      AttrName := Copy(Content, Head, Tail - Head + 1);

      // Find equation sign and quotation mark:
      Head := L + 1;
      for I := Tail + 1 to L do
        if not IsXmlWhiteSpace(Content[I]) then begin
          Head := I;
          Break;
        end;
      if Head > L then begin
        SendErrorNotification(ET_MISSING_EQUALITY_SIGN, Locator, '', '=');
        Exit;
      end;
      if Content[Head] <> EQ then begin
        SendErrorNotification(ET_MISSING_EQUALITY_SIGN, Locator, '', '=');
        Exit;
      end;
      for I := Head + 1 to L do
        if not IsXmlWhiteSpace(Content[I]) then begin
          Head := I;
          Break;
        end;
      if Head > L then begin
        SendErrorNotification(ET_MISSING_QUOTATION_MARK, Locator, '', '"');
        Exit;
      end;
      C := Content[Head];
      if not ( (C = SQ) or (C = DQ) ) then begin
        SendErrorNotification(ET_MISSING_QUOTATION_MARK, Locator, '', '"');
        Exit;
      end;
      QuotationMark := C;
      Inc(Head);

      // Find next attribute value:
      Tail := L;
      for I := Head to L do begin
        if Content[I] = QuotationMark then begin
          Tail := I - 1;
          Break;
        end;
      end;
      if Tail = L then begin
        SendErrorNotification(ET_MISSING_QUOTATION_MARK, Locator, '', QuotationMark);
        Exit;
      end;
      AttrValue := Copy(Content, Head, Tail - Head + 1);

      // Process the attribute:
      try
        AttrNames.Add(AttrName);
      except
        SendErrorNotification(ET_DOUBLE_ATTRIBUTE_NAME, Locator, AttrName, '');
        Exit;
      end;
      WriteAttribute(Locator, AttrName, AttrValue);

      // Check for white space:
      Head := Tail + 2;
      if Head <= L then
        if not IsXmlWhiteSpace(Content[Head]) then begin
          SendErrorNotification(ET_MISSING_WHITE_SPACE, Locator, '', ' ');
          Exit;
        end;

      // Skip white space:
      Head := L + 1;
      for I := Tail + 3 to L do
        if not IsXmlWhiteSpace(Content[I]) then begin
          Head := I;
          Break;
        end;
    end; {while ...}
  finally
    AttrNames.Free;
  end;
end;

{$ELSE}

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteStartTag(const Locator: IDomLocator;
                                                    Content: string;
                                                out TagName: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteStartTag(const Locator: IDomLocator;
                                                    Content: WideString;
                                                out TagName: WideString);
{$ENDIF NEXTGEN}
const
  NULL:  WideChar = #0; // end of WideString mark
  SQ:    WideChar = #39;  // code of '
  DQ:    WideChar = #34;  // code of "
  EQ:    WideChar = #61;  // code of =
var
  AttrNames: TUtilsWideStringList;
  Head, Tail: PWideChar;
{$IFDEF NEXTGEN}
  AttrName, AttrValue: string;
{$ELSE !NEXTGEN}
  AttrName, AttrValue: WideString;
{$ENDIF NEXTGEN}
  QuotationMark: WideChar;
begin
  AttrNames := TUtilsWideStringList.Create;
  try
    AttrNames.Sorted := True;
    AttrNames.Duplicates := dupError;

    // Find tag name:
    Head := PWideChar(Content);
    Tail := Head;
    while not IsXmlWhiteSpaceOrNull(Tail^) do
      Inc(Tail);
    SetString(TagName, Head, Tail - Head);
    WriteStartElement(Locator, TagName);

    // Skip white space:
    Head := Tail;
    while IsXmlWhiteSpace(Head^) do
      Inc(Head);

    while Head^ <> NULL do begin

      // Find next attribute name:
      Tail := Head;
//      while not IsXmlWhiteSpace(Tail^) and not (Tail^ in [NULL, EQ]) do
      while not IsXmlWhiteSpace(Tail^) and not Char(Tail^).IsInArray([NULL, EQ]) do
        Inc(Tail);
      SetString(AttrName, Head, Tail - Head);

      // Find equation sign and quotation mark:
      Head := Tail;
      while IsXmlWhiteSpace(Head^) do
        Inc(Head);
      if Head^ <> EQ then begin
        SendErrorNotification(ET_MISSING_EQUALITY_SIGN, Locator, '', '=');
        Exit;
      end;
      Inc(Head);
      while IsXmlWhiteSpace(Head^) do
        Inc(Head);
//      if not (Head^ in [SQ, DQ]) then begin
      if not Head^.IsInArray([SQ, DQ]) then begin
        SendErrorNotification(ET_MISSING_QUOTATION_MARK, Locator, '', '"');
        Exit;
      end;
      QuotationMark := WideChar(Head^);
      Inc(Head);
      Tail := Head;

      // Find next attribute value:
//      while not (Tail^ in [NULL, QuotationMark]) do
      while not Tail^.IsInArray([NULL, QuotationMark]) do
        Inc(Tail);
      if Tail^ = NULL then begin
        SendErrorNotification(ET_MISSING_QUOTATION_MARK, Locator, '', WideChar(QuotationMark));
        Exit;
      end;
      SetString(AttrValue, Head, Tail - Head);

      // Process the attribute:
      try
        AttrNames.Add(AttrName);
      except
        SendErrorNotification(ET_DOUBLE_ATTRIBUTE_NAME, Locator, AttrName, '');
        Exit;
      end;
      WriteAttribute(Locator, AttrName, AttrValue);

      // Skip white space:
      Head := Tail;
      Inc(Head);
      if not IsXmlWhiteSpaceOrNull(Head^) then begin
        SendErrorNotification(ET_MISSING_WHITE_SPACE, Locator, '', ' ');
        Exit;
      end;
      while IsXmlWhiteSpace(Head^) do
        Inc(Head);
    end; {while ...}
  finally
    AttrNames.Free;
  end;
end;
{$ENDIF}

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteEndTag(const Locator: IDomLocator;
                                            const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteEndTag(const Locator: IDomLocator;
                                            const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlEndElementSignal: TXmlEndElementSignal;
begin
  if Assigned(NextHandler) then begin
    XmlEndElementSignal := TXmlEndElementSignal.CreateFromLocator(Self, Locator);
    try
      XmlEndElementSignal.TagName := Content;
      NextHandler.ProcessSignal(XmlEndElementSignal);
    finally
      XmlEndElementSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteEmptyElementTag(const Locator: IDomLocator;
                                                     const Content: string);
var
  TagName: string;
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteEmptyElementTag(const Locator: IDomLocator;
                                                     const Content: WideString);
var
  TagName: WideString;
{$ENDIF NEXTGEN}
begin
  WriteStartTag(Locator, Content, TagName);
  WriteEndTag(Locator, TagName);
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteEntityRef(const Locator: IDomLocator;
                                               const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteEntityRef(const Locator: IDomLocator;
                                               const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlEntityRefSignal: TXmlEntityRefSignal;
begin
  if Assigned(NextHandler) then begin
    XmlEntityRefSignal := TXmlEntityRefSignal.CreateFromLocator(Self, Locator);
    try
      XmlEntityRefSignal.EntityName := Content;
      NextHandler.ProcessSignal(XmlEntityRefSignal);
    finally
      XmlEntityRefSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDocReader.WriteDoctype(const Locator: IDomLocator;
                                             const Content: string);

var
  DoctypeDeclTokenizer: TXmlDoctypeDeclTokenizer;
  DoctypeName: string;
  IntDtdByteNumber, IntDtdCharNumber, IntDtdLine, IntDtdColumn: Integer;
  IntDtd: string;
  PubidLiteral: string;
  SystemLiteral: string;
{$ELSE !NEXTGEN}
procedure TXmlStandardDocReader.WriteDoctype(const Locator: IDomLocator;
                                             const Content: WideString);

var
  DoctypeDeclTokenizer: TXmlDoctypeDeclTokenizer;
  DoctypeName: WideString;
  IntDtdByteNumber, IntDtdCharNumber, IntDtdLine, IntDtdColumn: Integer;
  IntDtd: WideString;
  PubidLiteral: WideString;
  SystemLiteral: WideString;
{$ENDIF NEXTGEN}
  XmlDoctypeSignal: TXmlDoctypeSignal;
begin
  IntDtdByteNumber := 0;
  IntDtdCharNumber := 0;
  IntDtdLine := 1;
  IntDtdColumn := 0;

  DoctypeDeclTokenizer := TXmlDoctypeDeclTokenizer.Create(Content, Locator.Uri,
                            Locator.StartByteNumber, Locator.StartCharNumber - 1,
                            Locator.StartColumnNumber - 1, Locator.StartTabsInLine,
                            Locator.StartLineNumber);
  try
    while DoctypeDeclTokenizer.TokenType <> DOCTYPE_END_OF_SOURCE_TOKEN do begin
      DoctypeDeclTokenizer.Next;
      if DoctypeDeclTokenizer.ErrorType <> ET_NONE then begin
        SendErrorNotification(DoctypeDeclTokenizer.ErrorType, DoctypeDeclTokenizer,
                              DoctypeDeclTokenizer.TokenValue, DoctypeDeclTokenizer.Clue);
        Exit;
      end;
      case DoctypeDeclTokenizer.TokenType of
        DOCTYPE_NAME_TOKEN:
          DoctypeName := DoctypeDeclTokenizer.TokenValue;
        DOCTYPE_PUBID_TOKEN:
          PubidLiteral := DoctypeDeclTokenizer.TokenValue;
        DOCTYPE_SYSID_TOKEN:
          SystemLiteral := DoctypeDeclTokenizer.TokenValue;
        DOCTYPE_INTSUBSET_TOKEN:
          begin
            IntDtdByteNumber := DoctypeDeclTokenizer.GetStartByteNumber;
            IntDtdCharNumber := DoctypeDeclTokenizer.GetStartCharNumber - 1;
            IntDtdColumn := DoctypeDeclTokenizer.GetStartColumnNumber - 1;
            IntDtdLine := DoctypeDeclTokenizer.GetStartLineNumber;
            if IntDtdColumn = -1 then  // Indicates a starting LF
              Dec(IntDtdLine);
            IntDtd := DoctypeDeclTokenizer.TokenValue;
          end;
      end;
    end;
  finally
    DoctypeDeclTokenizer.Free;
  end;

  if Assigned(NextHandler) then begin
    XmlDoctypeSignal := TXmlDoctypeSignal.CreateFromLocator(Self, Locator);
    try
      XmlDoctypeSignal.DoctypeName := DoctypeName;
      XmlDoctypeSignal.PublicId := PubidLiteral;
      XmlDoctypeSignal.SystemId := SystemLiteral;
      XmlDoctypeSignal.Data := IntDtd;
      XmlDoctypeSignal.IntSubsetStartByteNumber := IntDtdByteNumber;
      XmlDoctypeSignal.IntSubsetStartCharNumber := IntDtdCharNumber;
      XmlDoctypeSignal.IntSubsetStartColumn := IntDtdColumn;
      XmlDoctypeSignal.IntSubsetStartLine := IntDtdLine;
      NextHandler.ProcessSignal(XmlDoctypeSignal);
    finally
      XmlDoctypeSignal.Free;
    end;
  end;
end;

procedure TXmlStandardDocReader.WriteCompleted(const Locator: IDomLocator);
var
  XmlCompletedSignal: TXmlCompletedSignal;
begin
  if Assigned(NextHandler) then begin
    XmlCompletedSignal := TXmlCompletedSignal.CreateFromLocator(Self, Locator);
    try
      NextHandler.ProcessSignal(XmlCompletedSignal);
    finally
      XmlCompletedSignal.Free;
    end;
  end;
end;

function TXmlStandardDocReader.Parse(const InputSource: TXmlInputSource): Boolean;
var
  XmlTokenizer: TXmlDocTokenizer;
begin
  XmlTokenizer := TXmlDocTokenizer.Create(InputSource);
  try
    Result := True;
    try
      WriteStartDocument(XmlTokenizer, InputSource.InputEncoding, InputSource.XmlVersion,
                         InputSource.XmlEncoding, InputSource.XmlStandalone);
                                                                             
      Parse2(XmlTokenizer);
      WriteCompleted(XmlTokenizer);
    except
      Result := False;
      SendAbortedSignal(XmlTokenizer);
    end; {try ...}
  finally
    XmlTokenizer.Free;
  end;
end;

function TXmlStandardDocReader.ParseFragment(const InputSource: TXmlSimpleInputSource): Boolean;
var
  XmlTokenizer: TXmlDocTokenizer;
begin
  XmlTokenizer := TXmlDocTokenizer.Create(InputSource);
  try
    Result := True;
    try
      if not Assigned(InputSource) then Exit;
      WriteStartDocumentFragment(XmlTokenizer, InputSource.InputEncoding);
                                                                             
      Parse2(XmlTokenizer);
      WriteCompleted(XmlTokenizer);
    except
      SendAbortedSignal(XmlTokenizer);
      Result := False;
    end; {try ...}
  finally
    XmlTokenizer.Free;
  end;
end;

procedure TXmlStandardDocReader.Parse2(const XmlTokenizer: TXmlDocTokenizer);
var
{$IFDEF NEXTGEN}
  Dummy: string;
{$ELSE !NEXTGEN}
  Dummy: WideString;
{$ENDIF NEXTGEN}
begin
  while XmlTokenizer.TokenType <> XML_END_OF_SOURCE_TOKEN do begin
    XmlTokenizer.Next;
    if XmlTokenizer.ErrorType <> ET_NONE then
      SendErrorNotification(XmlTokenizer.ErrorType, XmlTokenizer, XmlTokenizer.TokenValue, XmlTokenizer.Clue);
    // For speed optimization, the case statements are ordered according to
    // what I guess is their frequency in a typical XML document.
    case XmlTokenizer.TokenType of
      XML_PCDATA_TOKEN:            WritePCDATA(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_START_TAG_TOKEN:         WriteStartTag(XmlTokenizer, XmlTokenizer.TokenValue ,Dummy);
      XML_END_TAG_TOKEN:           WriteEndTag(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_ENTITY_REF_TOKEN:        WriteEntityRef(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_EMPTY_ELEMENT_TAG_TOKEN: WriteEmptyElementTag(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_CHAR_REF_HEX_TOKEN:      WriteCharRefHex(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_CHAR_REF_DEC_TOKEN:      WriteCharRefDec(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_COMMENT_TOKEN:           WriteComment(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_PI_TOKEN:                WriteProcessingInstruction(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_CDATA_TOKEN:             WriteCDATA(XmlTokenizer, XmlTokenizer.TokenValue);
      XML_DOCTYPE_TOKEN:           WriteDoctype(XmlTokenizer, XmlTokenizer.TokenValue);
    end;
  end;
end;



// +++++++++++++++++++++ TXmlStandardDtdReader +++++++++++++++++++++
constructor TXmlStandardDtdReader.Create(AOwner: TComponent);
begin
  inherited;
  FAttrListDeclNames := TUtilsWideStringList.Create;
  FPERepository := TDomPERepository.Create(Self);
end;

destructor TXmlStandardDtdReader.Destroy;
begin
  FPERepository.Free;
  FAttrListDeclNames.Free;
  inherited;
end;

function TXmlStandardDtdReader.GetXmlErrorDetected: Boolean;
begin
  Result := FXmlErrorDetected;
end;

function TXmlStandardDtdReader.GetXmlFatalErrorDetected: Boolean;
begin
  Result := FXmlFatalErrorDetected;
end;

procedure TXmlStandardDtdReader.PEReferenceEventHandler(      Sender: TObject;
                                                        const Locator: IDomLocator);
var
  XmlPEReferenceFoundSignal: TXmlPEReferenceFoundSignal;
begin
  if Assigned(NextHandler) then begin
    XmlPEReferenceFoundSignal := TXmlPEReferenceFoundSignal.CreateFromLocator(Self, Locator);
    try
      NextHandler.ProcessSignal(XmlPEReferenceFoundSignal);
    finally
      XmlPEReferenceFoundSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDtdReader.PEProcessingAttListDeclEventHandler(      Sender: TObject;
                                                                    const ElementName: string;
                                                                    const Locator: IDomLocator);
{$ELSE !NEXTGEN}
procedure TXmlStandardDtdReader.PEProcessingAttListDeclEventHandler(      Sender: TObject;
                                                                    const ElementName: WideString;
                                                                    const Locator: IDomLocator);
{$ENDIF NEXTGEN}
begin
  // Keep track of the element types of attribute-list declarations and warn the
  // application when detecting a duplicate:
  if FAttrListDeclNames.IndexOf(ElementName) = -1
    then FAttrListDeclNames.Add(ElementName)
    else SendErrorNotification(ET_DOUBLE_ATTLISTDECL, Locator, ElementName, '');
end;

procedure TXmlStandardDtdReader.SendAbortedSignal(const Locator: IDomLocator);
var
  XmlAbortedSignal: TXmlAbortedSignal;
begin
  if Assigned(NextHandler) then begin
    XmlAbortedSignal := TXmlAbortedSignal.CreateFromLocator(Self, Locator);
    try
      NextHandler.ProcessSignal(XmlAbortedSignal);
    finally
      XmlAbortedSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDtdReader.SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                                      const Location: IDomLocator;
                                                      const Code,
                                                            Clue: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDtdReader.SendErrorNotification(const XmlErrorType: TXmlErrorType;
                                                      const Location: IDomLocator;
                                                      const Code,
                                                            Clue: WideString);
{$ENDIF NEXTGEN}
begin
  if XmlErrorType in ET_FATAL_ERRORS then begin
    FXmlFatalErrorDetected := True;
  end else if XmlErrorType in ET_ERRORS then
    FXmlErrorDetected := True;
  inherited;
end;

procedure TXmlStandardDtdReader.WriteCompleted(const Locator: IDomLocator);
var
  XmlCompletedSignal: TXmlCompletedSignal;
begin
  if Assigned(NextHandler) then begin
    XmlCompletedSignal := TXmlCompletedSignal.CreateFromLocator(Self, Locator);
    try
      NextHandler.ProcessSignal(XmlCompletedSignal);
    finally
      XmlCompletedSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDtdReader.WriteStartExtDtd(const Locator: IDomLocator;
                                                 const InputEnc,
                                                       PubId,
                                                       SysId,
                                                       Version,
                                                       EncName: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDtdReader.WriteStartExtDtd(const Locator: IDomLocator;
                                                 const InputEnc,
                                                       PubId,
                                                       SysId,
                                                       Version,
                                                       EncName: WideString);
{$ENDIF NEXTGEN}
var
  XmlStartExtDtdSignal: TXmlStartExtDtdSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartExtDtdSignal := TXmlStartExtDtdSignal.CreateFromLocator(Self, Locator);
    try
      XmlStartExtDtdSignal.InputEncoding := InputEnc;
      XmlStartExtDtdSignal.PublicId := PubId;
      XmlStartExtDtdSignal.SystemId := SysId;
      XmlStartExtDtdSignal.Version := Version;
      XmlStartExtDtdSignal.EncodingName := EncName;
      NextHandler.ProcessSignal(XmlStartExtDtdSignal);
    finally
      XmlStartExtDtdSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDtdReader.WriteStartIntDtd(const Locator: IDomLocator;
                                                 const SysId: string;
                                                 const Standalone: TDomStandalone);
{$ELSE !NEXTGEN}
procedure TXmlStandardDtdReader.WriteStartIntDtd(const Locator: IDomLocator;
                                                 const SysId: WideString;
                                                 const Standalone: TDomStandalone);
{$ENDIF NEXTGEN}
var
  XmlStartIntDtdSignal: TXmlStartIntDtdSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartIntDtdSignal := TXmlStartIntDtdSignal.CreateFromLocator(Self, Locator);
    try
      XmlStartIntDtdSignal.SystemId := SysId;
      XmlStartIntDtdSignal.XmlStandalone := Standalone;
      NextHandler.ProcessSignal(XmlStartIntDtdSignal);
    finally
      XmlStartIntDtdSignal.Free;
    end;
  end;
end;

procedure TXmlStandardDtdReader.WriteSignal(const Signal: TXmlSignal);
var
  NewSignal: TXmlSignal;
begin
  if Assigned(Signal) and Assigned(NextHandler) then begin
    NewSignal := Signal.CloneSignal(Self);
    try
      NextHandler.ProcessSignal(NewSignal);
    finally
      NewSignal.Free;
    end;
  end;
end;

procedure TXmlStandardDtdReader.Parseloop(const Tokenizer: TXmlCustomSubsetTokenizer);
begin
  while not (Tokenizer.TokenType = DTD_ABSTRACT_END_OF_SOURCE_TOKEN) do begin
    Tokenizer.Next;
    if Tokenizer.ErrorType <> ET_NONE then
      SendErrorNotification(Tokenizer.ErrorType, Tokenizer, '', Tokenizer.Clue);
    if Tokenizer.TokenType in [ DTD_ABSTRACT_ATTLIST_DECL_TOKEN,
                                DTD_ABSTRACT_COMMENT_TOKEN,
                                DTD_ABSTRACT_ELEMENT_DECL_TOKEN,
                                DTD_ABSTRACT_ENTITY_DECL_TOKEN,
                                DTD_ABSTRACT_EXT_PARAMETER_ENTITY_REF_TOKEN,
                                DTD_ABSTRACT_NOTATION_DECL_TOKEN,
                                DTD_ABSTRACT_PARAMETER_ENTITY_DECL_TOKEN,
                                DTD_ABSTRACT_PI_TOKEN ] then
      WriteSignal(Tokenizer.CurrentSignal);
  end;
end;

function TXmlStandardDtdReader.ParseExtSubset(const InputSource: TXmlInputSource): Boolean;
var
  Tokenizer: TXmlExtSubsetTokenizer;
begin
  Tokenizer := TXmlExtSubsetTokenizer.Create(InputSource, FPERepository);
  try
    Tokenizer.OnPEReference := PEReferenceEventHandler;
    Tokenizer.OnProcessingAttListDecl := PEProcessingAttListDeclEventHandler;
    try
      WriteStartExtDtd(Tokenizer, InputSource.InputEncoding, InputSource.PublicId,
                       InputSource.SystemId, InputSource.XmlVersion, InputSource.XmlEncoding);
                                                                             
      if Tokenizer.ErrorType = ET_NONE
        then Parseloop(Tokenizer)
        else SendErrorNotification(Tokenizer.ErrorType, Tokenizer, '', Tokenizer.Clue);
      WriteCompleted(Tokenizer);
    except
      SendAbortedSignal(Tokenizer);
    end;
  finally
    Tokenizer.Free;
  end;

  Result := not (XmlFatalErrorDetected or XmlErrorDetected);
end;

function TXmlStandardDtdReader.ParseIntSubset(const InputSource: TXmlSimpleInputSource;
                                              const Standalone: TDomStandalone;
                                              const ResolveExtPEs: Boolean): Boolean;
var
  Tokenizer: TXmlIntSubsetTokenizer;
begin
  Tokenizer := TXmlIntSubsetTokenizer.Create(InputSource, FPERepository);
  try
    Tokenizer.OnPEReference := PEReferenceEventHandler;
    Tokenizer.OnProcessingAttListDecl := PEProcessingAttListDeclEventHandler;
    Tokenizer.ResolveExtPEs := ResolveExtPEs;
    try
      WriteStartIntDtd(Tokenizer, InputSource.SystemId, Standalone);
      if Tokenizer.ErrorType = ET_NONE
        then Parseloop(Tokenizer)
        else SendErrorNotification(Tokenizer.ErrorType, Tokenizer, '', Tokenizer.Clue);
      WriteCompleted(Tokenizer);
    except
      SendAbortedSignal(Tokenizer);
    end;
  finally
    Tokenizer.Free;
  end;

  Result := not (XmlFatalErrorDetected or XmlErrorDetected);
end;

procedure TXmlStandardDtdReader.Prepare;
begin
  FAttrListDeclNames.Clear;
  FPERepository.Clear;
  FXmlFatalErrorDetected := False;
  FXmlErrorDetected := False;
end;



// +++++++++++++++++++++++ TXmlStandardDomReader +++++++++++++++++++++++
constructor TXmlStandardDomReader.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FIgnoreUnspecified := True;
end;

function TXmlStandardDomReader.GetContextNode: TDomNode;
begin
  Result := FContextNode;
end;

{$IFDEF NEXTGEN}
function TXmlStandardDomReader.GetSystemId: string;
{$ELSE !NEXTGEN}
function TXmlStandardDomReader.GetSystemId: WideString;
{$ENDIF NEXTGEN}
var
  doc: TDomCustomDocument;
begin
  if Assigned(ContextNode) then begin
    doc := ContextNode.RootDocument;
    if Assigned(doc)
      then Result := doc.DocumentUri
      else Result := '';
  end else Result := '';
end;

procedure TXmlStandardDomReader.Parseloop(const SourceNode: TDomNode);
var
  I: Integer;
  ContextNodeBackup: TDomNode;

  procedure ParseElement(const SourceElement: TDomElement);
  var
    I: Integer;

    procedure ParseAttribute(const SourceAttribute: TDomAttr);
    var
      ContextNodeBackup2: TDomNode;
    begin
      ContextNodeBackup2 := FContextNode;
      FContextNode := SourceAttribute;
      try
        WriteAttribute(SourceAttribute.DataType, SourceAttribute.NodeName, SourceAttribute.NodeValue);
      finally
        FContextNode := ContextNodeBackup2;
      end;
    end;

  begin
    WriteStartElement(SourceElement.NodeName);
    if FIgnoreUnspecified then begin
      for I := 0 to Pred(SourceElement.Attributes.Length) do
        if (SourceElement.Attributes.Item(I) as TDomAttr).Specified then
          ParseAttribute(SourceElement.Attributes.Item(I) as TDomAttr);
    end else begin
      for I := 0 to Pred(SourceElement.Attributes.Length) do
        ParseAttribute(SourceElement.Attributes.Item(I) as TDomAttr);
    end;
    for I := 0  to Pred(SourceElement.ChildNodes.Length) do
      Parseloop(SourceElement.ChildNodes.Item(I));
    WriteEndElement(SourceElement.NodeName);
  end;

begin
  ContextNodeBackup := FContextNode;
  FContextNode := SourceNode;
  try
    case SourceNode.NodeType of
      ntElement_Node:
        ParseElement(SourceNode as TDomElement);
      ntText_Node:
        WritePCData(SourceNode.NodeValue,
                    (SourceNode as TDomText).CharRefGenerated);
      ntCDATA_Section_Node:
        WriteCDATA(SourceNode.NodeValue);
      ntEntity_Reference_Node:
        WriteEntityRef(SourceNode.NodeName);
      ntProcessing_Instruction_Node:
        WriteProcessingInstruction(SourceNode.NodeName, SourceNode.NodeValue);
      ntComment_Node:
        WriteComment(SourceNode.NodeValue);
      ntDocument_Node:
        for I := 0  to Pred(SourceNode.ChildNodes.Length) do
          Parseloop(SourceNode.ChildNodes.Item(I));
      ntDocument_Type_Decl_Node:
        WriteDoctype(SourceNode.NodeName,
                     (SourceNode as TDomDocumentTypeDecl).PublicId,
                     (SourceNode as TDomDocumentTypeDecl).SystemId,
                     (SourceNode as TDomDocumentTypeDecl).InternalSubset);
      else
        raise EParserException.Create('Internal Parser error.');
    end;
  finally
    FContextNode := ContextNodeBackup;
  end;
end;

procedure TXmlStandardDomReader.SendAbortedSignal;
var
  XmlAbortedSignal: TXmlAbortedSignal;
begin
  if Assigned(NextHandler) then begin
    XmlAbortedSignal := TXmlAbortedSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, '', nil, nil);                                                      
    try
      NextHandler.ProcessSignal(XmlAbortedSignal);
    finally
      XmlAbortedSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteAttribute(const ADataType: TXmlDataType;
                                               const ANodeName,
                                                     ANodeValue: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteAttribute(const ADataType: TXmlDataType;
                                               const ANodeName,
                                                     ANodeValue: WideString);
{$ENDIF NEXTGEN}
var
  XmlAttributeSignal: TXmlAttributeSignal;
begin
  if Assigned(NextHandler) then begin
    XmlAttributeSignal := TXmlAttributeSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlAttributeSignal.DataType := ADataType;
      XmlAttributeSignal.Name := ANodeName;
      XmlAttributeSignal.Value := ANodeValue;
      NextHandler.ProcessSignal(XmlAttributeSignal);
    finally
      XmlAttributeSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteCDATA(const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteCDATA(const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlCDATASignal: TXmlCDATASignal;
begin
  if Assigned(NextHandler) then begin
    XmlCDATASignal := TXmlCDATASignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlCDATASignal.Data := Content;
      NextHandler.ProcessSignal(XmlCDATASignal);
    finally
      XmlCDATASignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteComment(const Content: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteComment(const Content: WideString);
{$ENDIF NEXTGEN}
var
  XmlCommentSignal: TXmlCommentSignal;
begin
  if Assigned(NextHandler) then begin
    XmlCommentSignal := TXmlCommentSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlCommentSignal.Data := Content;
      NextHandler.ProcessSignal(XmlCommentSignal);
    finally
      XmlCommentSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteDoctype(const DoctypeName,
                                                   PublicId,
                                                   SystemId,
                                                   IntSubset: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteDoctype(const DoctypeName,
                                                   PublicId,
                                                   SystemId,
                                                   IntSubset: WideString);
{$ENDIF NEXTGEN}
var
  XmlDoctypeSignal: TXmlDoctypeSignal;
begin
  if Assigned(NextHandler) then begin
    XmlDoctypeSignal := TXmlDoctypeSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlDoctypeSignal.DoctypeName := DoctypeName;
      XmlDoctypeSignal.PublicId := PublicId;
      XmlDoctypeSignal.SystemId := SystemId;
      XmlDoctypeSignal.Data := IntSubset;
      NextHandler.ProcessSignal(XmlDoctypeSignal);
    finally
      XmlDoctypeSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteEndElement(const TagName: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteEndElement(const TagName: WideString);
{$ENDIF NEXTGEN}
var
  XmlEndElementSignal: TXmlEndElementSignal;
begin
  if Assigned(NextHandler) then begin
    XmlEndElementSignal := TXmlEndElementSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlEndElementSignal.TagName := TagName;
      NextHandler.ProcessSignal(XmlEndElementSignal);
    finally
      XmlEndElementSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteEndPrefixMapping(const Prefix: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteEndPrefixMapping(const Prefix: WideString);
{$ENDIF NEXTGEN}
var
  XmlEndPrefixMappingSignal: TXmlEndPrefixMappingSignal;
begin
  if Assigned(NextHandler) then begin
    XmlEndPrefixMappingSignal := TXmlEndPrefixMappingSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlEndPrefixMappingSignal.Prefix := Prefix;
      NextHandler.ProcessSignal(XmlEndPrefixMappingSignal);
    finally
      XmlEndPrefixMappingSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteEntityRef(const EntityName: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteEntityRef(const EntityName: WideString);
{$ENDIF NEXTGEN}
var
  XmlEntityRefSignal: TXmlEntityRefSignal;
begin
  if Assigned(NextHandler) then begin
    XmlEntityRefSignal := TXmlEntityRefSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlEntityRefSignal.EntityName := EntityName;
      NextHandler.ProcessSignal(XmlEntityRefSignal);
    finally
      XmlEntityRefSignal.Free;
    end;
  end;
end;

procedure TXmlStandardDomReader.WriteCompleted;
var
  XmlCompletedSignal: TXmlCompletedSignal;
begin
  if Assigned(NextHandler) then begin
    XmlCompletedSignal := TXmlCompletedSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      NextHandler.ProcessSignal(XmlCompletedSignal);
    finally
      XmlCompletedSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WritePCDATA(const Content: string;
                                            const CharRefGenerated: Boolean);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WritePCDATA(const Content: WideString;
                                            const CharRefGenerated: Boolean);
{$ENDIF NEXTGEN}
var
  XmlPCDATASignal: TXmlPCDATASignal;
begin
  if Content = '' then Exit;

  if Assigned(NextHandler) then begin
    XmlPCDATASignal := TXmlPCDATASignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlPCDATASignal.CharRefGenerated := CharRefGenerated;
      XmlPCDATASignal.Data := Content;
      NextHandler.ProcessSignal(XmlPCDATASignal);
    finally
      XmlPCDATASignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteProcessingInstruction(const Targ,
                                                                 AttribSequence : string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteProcessingInstruction(const Targ,
                                                                 AttribSequence : WideString);
{$ENDIF NEXTGEN}
var
  XmlProcessingInstructionSignal: TXmlProcessingInstructionSignal;
begin
  if Assigned(NextHandler) then begin
    XmlProcessingInstructionSignal := TXmlProcessingInstructionSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlProcessingInstructionSignal.Target := Targ;
      XmlProcessingInstructionSignal.Data := AttribSequence;
      NextHandler.ProcessSignal(XmlProcessingInstructionSignal);
    finally
      XmlProcessingInstructionSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteStartDocument(const InputEnc,
                                                         Version,
                                                         EncName: string;
                                                         SdDl: TDomStandalone);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteStartDocument(const InputEnc,
                                                         Version,
                                                         EncName: WideString;
                                                         SdDl: TDomStandalone);
{$ENDIF NEXTGEN}
var
  XmlStartDocumentSignal: TXmlStartDocumentSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartDocumentSignal := TXmlStartDocumentSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlStartDocumentSignal.InputEncoding  := InputEnc;
      XmlStartDocumentSignal.Version        := Version;
      XmlStartDocumentSignal.EncodingName   := EncName;
      XmlStartDocumentSignal.StandaloneDecl := SdDl;
      NextHandler.ProcessSignal(XmlStartDocumentSignal);
    finally
      XmlStartDocumentSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteStartDocumentFragment(const EncName: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteStartDocumentFragment(const EncName: WideString);
{$ENDIF NEXTGEN}
var
  XmlStartDocumentFragmentSignal: TXmlStartDocumentFragmentSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartDocumentFragmentSignal := TXmlStartDocumentFragmentSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlStartDocumentFragmentSignal.EncodingName  := EncName;
      NextHandler.ProcessSignal(XmlStartDocumentFragmentSignal);
    finally
      XmlStartDocumentFragmentSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteStartElement(const TagName: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteStartElement(const TagName: WideString);
{$ENDIF NEXTGEN}
var
  XmlStartElementSignal: TXmlStartElementSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartElementSignal := TXmlStartElementSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlStartElementSignal.TagName := TagName;
      NextHandler.ProcessSignal(XmlStartElementSignal);
    finally
      XmlStartElementSignal.Free;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TXmlStandardDomReader.WriteStartPrefixMapping(const Prefix,
                                                              Uri: string);
{$ELSE !NEXTGEN}
procedure TXmlStandardDomReader.WriteStartPrefixMapping(const Prefix,
                                                              Uri: WideString);
{$ENDIF NEXTGEN}
var
  XmlStartPrefixMappingSignal: TXmlStartPrefixMappingSignal;
begin
  if Assigned(NextHandler) then begin
    XmlStartPrefixMappingSignal := TXmlStartPrefixMappingSignal.Create(Self, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, GetSystemId, nil, ContextNode);
    try
      XmlStartPrefixMappingSignal.Prefix    := Prefix;
      XmlStartPrefixMappingSignal.Uri := Uri;
      NextHandler.ProcessSignal(XmlStartPrefixMappingSignal);
    finally
      XmlStartPrefixMappingSignal.Free;
    end;
  end;
end;

function TXmlStandardDomReader.Parse(const SourceNode: TDomNode): Boolean;
begin
  if not Assigned(SourceNode) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Source node not specified.');

  Result := True;
  try

    if SourceNode.NodeType = ntDocument_Node then begin
      FContextNode:= SourceNode;
      WriteStartDocument((SourceNode as TDomCustomDocument).InputEncoding,
                         (SourceNode as TDomCustomDocument).XmlVersion,
                         (SourceNode as TDomCustomDocument).XmlEncoding,
                         (SourceNode as TDomCustomDocument).XmlStandalone);
      WritePCDATA(#10, False); // Insert LF after XML declaration.
    end else begin
      FContextNode:= nil;
      if SourceNode.RootDocument.XmlEncoding = ''
        then WriteStartDocumentFragment(SourceNode.RootDocument.InputEncoding)
        else WriteStartDocumentFragment(SourceNode.RootDocument.XmlEncoding);
    end;

    Parseloop(SourceNode);

    WriteCompleted;

  except
    SendAbortedSignal;
    Result := False;
  end; {try ...}
end;



// +++++++++++++++++++++++++ TXmlCustomParser +++++++++++++++++++++++++
constructor TXmlCustomParser.Create(AOwner: TComponent);
begin
  inherited;
  FDOMImpl := nil;
  FErrorReportingEnabled := True;
end;

procedure TXmlCustomParser.Notification(AComponent: TComponent;
                                        Operation: TOperation);
begin
  inherited Notification(AComponent,Operation);
  if (Operation = opRemove) and (AComponent = FDomImpl) then
    FDomImpl:= nil;
end;

procedure TXmlCustomParser.SetDomImpl(const Impl: TDomImplementation);
begin
  if FDOMImpl = Impl then Exit;
  {$IFDEF VER140+}
  if Assigned(FDOMImpl) then
    FDOMImpl.RemoveFreeNotification(Self);
  {$ENDIF}
  {$IFNDEF MSWINDOWS}
  if Assigned(FDOMImpl) then
    FDOMImpl.RemoveFreeNotification(Self);
  {$ENDIF}
  FDOMImpl := Impl;
  if Assigned(Impl) then
    Impl.FreeNotification(Self);
end;

procedure TXmlCustomParser.SetErrorReportingEnabled(const Value: Boolean);
begin
  FErrorReportingEnabled := Value;
end;



{ TXmlToDomParser }

{constructor / destructor}

constructor TXmlToDomParser.Create(AOwner: TComponent);
begin
  inherited;
  CreateSubcomponents;
  FBufferSize := 4096;
  KeepCDATASections := True;
  KeepComments := True;
  KeepEntityRefs := True;
end;

procedure TXmlToDomParser.CreateSubcomponents;
begin
  FDocReader := TXmlStandardDocReader.Create(Self);
  FWFTestHandler := TXmlWFTestHandler.Create(Self);
  FDocBuilder := TXmlDomBuilder.Create(Self);
  FDocBuilder.DocTypeDeclTreatment := dtCheckWellformedness;

  FDocReader.DOMImpl := FDOMImpl;

  FDocReader.NextHandler := FWFTestHandler;
  FWFTestHandler.NextHandler := FDocBuilder;
end;

{property methods}

function TXmlToDomParser.GetKeepCDATASections: Boolean;
begin
  Result := FDocBuilder.KeepCDATASections;
end;

function TXmlToDomParser.GetKeepComments: Boolean;
begin
  Result := FDocBuilder.KeepComments;
end;

function TXmlToDomParser.GetKeepEntityRefs: Boolean;
begin
  Result := FDocBuilder.KeepEntityRefs;
end;

procedure TXmlToDomParser.SetBufferSize(const Value: Integer);
begin
  if Value < 1024 then
    raise ENot_Supported_Err.Create('BufferSize must not be less than 1024.');
  FBufferSize := Value;
end;

procedure TXmlToDomParser.SetKeepCDATASections(const Value: Boolean);
begin
  FDocBuilder.KeepCDATASections := Value;
end;

procedure TXmlToDomParser.SetKeepComments(const Value: Boolean);
begin
  FDocBuilder.KeepComments := Value;
end;

procedure TXmlToDomParser.SetKeepEntityRefs(const Value: Boolean);
begin
  FDocBuilder.KeepEntityRefs := Value;
end;

procedure TXmlToDomParser.SetDomImpl(const Impl: TDomImplementation);
begin
  inherited;
  FDocReader.DOMImpl := Impl;
end;

procedure TXmlToDomParser.SetErrorReportingEnabled(const Value: Boolean);
begin
  inherited;
  FDocReader.ErrorReportingEnabled := Value;
end;

{error reporting}

function TXmlToDomParser.SendErrorNotification(const XmlErrorType: TXmlErrorType): Boolean;
var
  Error: TDomError;
begin
  if ErrorReportingEnabled then begin
    Error := TDomError.CreateFromLocator(XmlErrorType, nil, '', '');
    try
      if Assigned(DomImpl)
        then Result := DomImpl.HandleError(Self, Error)
        else Result := not (Error.Severity = DOM_SEVERITY_FATAL_ERROR);
    finally
      Error.Free;
    end;
  end else
    Result := not (XmlErrorType in ET_FATAL_ERRORS);
end;

{parsing methods}

procedure TXmlToDomParser.ParseFragment(const InputSource: TXmlSimpleInputSource;
                                        const DocFrag: TDomDocumentFragment);
begin
  if not Assigned(DocFrag) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Reference document fragment not specified.');
  if not Assigned(DOMImpl) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('DOM implementation not specified.');

  FDocBuilder.ReferenceNode := DocFrag;
  if not FDocReader.ParseFragment(InputSource) then
    raise EParserException.Create('Parser error.');
end;

function TXmlToDomParser.Parse(const InputSource: TXmlInputSource): TDomDocument;
var
  NewDoc: TDomDocument;
begin
  if not Assigned(InputSource) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Input source not specified.');
  if not Assigned(DOMImpl) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('DOM implementation not specified.');

  if InputSource.HasMalformedDecl
   or not ( InputSource.DeclType in [ DT_XML_DECLARATION,
                                      DT_XML_OR_TEXT_DECLARATION,
                                      DT_UNSPECIFIED ] )
  then begin
    SendErrorNotification(ET_INVALID_XML_DECL);
    raise EParserException.Create('Parser error.');
  end;
  if not IsSupportedXmlVersion(InputSource.XmlVersion) then begin
    SendErrorNotification(ET_XML_VERSION_NOT_SUPPORTED);
    raise EParserException.Create('Parser error.');
  end;

  NewDoc := TDomDocument.Create(DOMImpl);
  try
    NewDoc.DocumentUri := InputSource.SystemId;
    FDocBuilder.ReferenceNode := NewDoc;
    if not FDocReader.Parse(InputSource) then
      raise EParserException.Create('Parser error.');
    Result := NewDoc;
  except
    NewDoc.Free;
    raise;
  end;
end;

function TXmlToDomParser.ParseFile(const Filename: TFileName;
                                   const InclDecl: Boolean): TDomDocument;
var
  InputSrc: TXmlInputSource;
  SourceStream: TFileStream;
{$IFDEF NEXTGEN}
  SysId: string;
{$ELSE !NEXTGEN}
  SysId: WideString;
{$ENDIF NEXTGEN}
begin
  Result := nil;
  if Filename = '' then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Filename not specified.');
  SourceStream := TFileStream.Create(Filename, fmOpenRead);
  try
    try
      //SysId := FilenameToUriWideStr(Filename, []);
      SysId := FilenameToUriStr(Filename, []);
      InputSrc := TXmlInputSource.Create(SourceStream, '', SysId, FBufferSize,
                    '', InclDecl, 0, 0, 0, 0, 1);                                                        
    except
      on ENot_Supported_Err do begin
        SendErrorNotification(ET_ENCODING_NOT_SUPPORTED);
        raise EParserException.Create('Parser error.');
      end;
      on EConvertError do begin
        SendErrorNotification(ET_BYTE_ORDER_MARK_ENCODING_MISMATCH);
        raise EParserException.Create('Parser error.');
      end;
    end;
    try
      Result := Parse(InputSrc);
    finally
      InputSrc.Free;
    end;
  finally
    SourceStream.Free;
  end;
end;

{$IFDEF NEXTGEN}
function TXmlToDomParser.ParseResource(const BaseUri: string;
                                             PublicId,
                                             SystemId: string;
                                       const Encoding: string;
                                       const InclDecl: Boolean): TDomDocument;
{$ELSE !NEXTGEN}
function TXmlToDomParser.ParseResource(const BaseUri: WideString;
                                             PublicId,
                                             SystemId: WideString;
                                       const Encoding: WideString;
                                       const InclDecl: Boolean): TDomDocument;
{$ENDIF NEXTGEN}
var
  InputSrc: TXmlInputSource;
  Stream: TStream;
{$IFDEF NEXTGEN}
  Uri: string;
{$ELSE !NEXTGEN}
  Uri: WideString;
{$ENDIF NEXTGEN}
begin
  Result := nil;
  Stream := DOMImpl.ResolveResourceAsStream(BaseUri, PublicId, SystemId); // Creates Stream.  Raises EAccessViolation if DOMImpl = nil.
  if not Assigned(Stream) then
    raise EParserException.Create('No input specified.');

  try
{$IFDEF NEXTGEN}
    ResolveRelativeUriStr(BaseUri, SystemId, Uri);
{$ELSE !NEXTGEN}
    ResolveRelativeUriWideStr(BaseUri, SystemId, Uri);
{$ENDIF NEXTGEN}
        // Remark: Returns an empty Uri if ResolveRelativeUriWideStr attempt fails.
    try
      InputSrc := TXmlInputSource.Create(Stream, PublicId, Uri, 4096,
                    Encoding, InclDecl, 0, 0, 0, 0, 1);
    except
      on ENot_Supported_Err do begin
        SendErrorNotification(ET_ENCODING_NOT_SUPPORTED);
        raise EParserException.Create('Parser error.');
      end;
      on EConvertError do begin
        SendErrorNotification(ET_BYTE_ORDER_MARK_ENCODING_MISMATCH);
        raise EParserException.Create('Parser error.');
      end;
    end;
    try
      Result := Parse(InputSrc);
    finally
      InputSrc.Free;
    end;
  finally
    Stream.Free;
  end;
end;

function TXmlToDomParser.ParseWithContext(const InputSource: TXmlInputSource;
                                          const ContextNode: TDomNode;
                                          const Action: TXmlParserAction): TDomNode;
var
  DocFrag: TDomDocumentFragment;
  OldNode, OldNode_2: TDomNode;
  Parent: TDomNode;
  Sibling: TDomNode;
begin
  if not Assigned(InputSource) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Input source not specified.');
  if not Assigned(DOMImpl) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('DOM implementation not specified.');
  if not Assigned(ContextNode) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Context node not specified.');

  if not (InputSource.DeclType = DT_UNSPECIFIED) then
    if not ( (ContextNode is TDomDocument) and (Action = ACTION_REPLACE) ) then begin
      SendErrorNotification(ET_INVALID_XML_DECL);                                                                                             
      raise EParserException.Create('XML declaration not allowed here.');
    end;

  DocFrag := TDomDocumentFragment.Create(ContextNode.OwnerDocument);
  try
    ParseFragment(InputSource, DocFrag);
    Result := DocFrag.FirstChild;
    case Action of

      ACTION_APPEND_AS_CHILDREN:
        ContextNode.AppendChild(DocFrag);

      ACTION_INSERT_AFTER: begin
        Parent := ContextNode.ParentNode;
        if not ( (Parent is TDomElement) or (Parent is TDomDocumentFragment) ) then
          raise EHierarchy_Request_Err.Create('Hierarchy request error.');
        Sibling := ContextNode.NextSibling;
        if Assigned(Sibling) then
          Parent.InsertBefore(DocFrag, Sibling)
        else
          Parent.AppendChild(DocFrag);
      end;

      ACTION_INSERT_BEFORE: begin
        Parent := ContextNode.ParentNode;
        if not ( (Parent is TDomElement) or (Parent is TDomDocumentFragment) ) then
          raise EHierarchy_Request_Err.Create('Hierarchy request error.');
        Parent.InsertBefore(DocFrag, ContextNode);
      end;

      ACTION_REPLACE: begin
        Parent := ContextNode.ParentNode;
        if not ( (Parent is TDomElement) or (Parent is TDomDocumentFragment) ) then
          raise EHierarchy_Request_Err.Create('Hierarchy request error.');
        try
          Parent.ReplaceChild(DocFrag, ContextNode);
        finally
{$IFNDEF AUTOREFCOUNT}
          // Make sure that the context node is freed, even if
          // Parent.ReplaceChild() fails:
          if not Assigned(ContextNode.ParentNode) then
            ContextNode.Free;
{$ENDIF !AUTOREFCOUNT}
        end;
      end;

      ACTION_REPLACE_CHILDREN: begin
        if not ( (ContextNode is TDomElement) or (ContextNode is TDomDocumentFragment)
                 or (ContextNode is TDomDocument) ) then
          raise EHierarchy_Request_Err.Create('Hierarchy request error.');

        // Delete child nodes:
        OldNode := ContextNode.LastChild;
        while Assigned(OldNode) do begin
          OldNode_2 := OldNode.PreviousSibling;
          ContextNode.RemoveChild(OldNode);
          OldNode.Free;
          OldNode := OldNode_2;
        end;

        ContextNode.AppendChild(DocFrag);

        if ContextNode is TDomDocument then
        begin
          (ContextNode as TDomDocument).DocumentUri := InputSource.SystemId;
          (ContextNode as TDomDocument).InputEncoding := InputSource.InputEncoding;                                                                    
          (ContextNode as TDomDocument).XmlVersion := InputSource.XmlVersion;                                                                          
          (ContextNode as TDomDocument).XmlEncoding := InputSource.XmlEncoding;                                                                        
          (ContextNode as TDomDocument).XmlStandalone := InputSource.XmlStandalone;
        end;
      end;

    end;
  finally
    DocFrag.Free;
  end;
end;



{ TDtdToDtdModelParser }

constructor TDtdToDtdModelParser.Create(AOwner: TComponent);
begin
  inherited;
  CreateSubcomponents;
  FBufferSize := 4096;
end;

procedure TDtdToDtdModelParser.CreateSubcomponents;
begin
  FDtdReader := TXmlStandardDtdReader.Create(Self);
  FDtdReader.DOMImpl:= DOMImpl;

  FWFTestHandler := TXmlWFTestHandler.Create(Self);
  FDtdModelBuilder := TXmlDtdModelBuilder.Create(Self);

  FDtdReader.NextHandler := FWFTestHandler;
  FWFTestHandler.NextHandler := FDtdModelBuilder;
end;

function TDtdToDtdModelParser.GetTargetDtdModel: TDtdModel;
begin
  Result := FDtdModelBuilder.DtdModel;
end;

function TDtdToDtdModelParser.GetXmlErrorDetected: Boolean;
begin
  Result := FDtdReader.XmlErrorDetected;
end;

function TDtdToDtdModelParser.GetXmlFatalErrorDetected: Boolean;
begin
  Result := FDtdReader.XmlFatalErrorDetected;
end;

procedure TDtdToDtdModelParser.ParseDocTypeDecl(const DocTypeDecl: TDomDocumentTypeDecl;
                                                const ResolveExtEntities,
                                                      InclDecl: Boolean);
var
{$IFDEF NEXTGEN}
  DocUri: string;
{$ELSE !NEXTGEN}
  DocUri: WideString;
{$ENDIF NEXTGEN}
  ExtDtdStream: TStream;
  ExtInputSource: TXmlInputSource;
  IntInputSource: TXmlSimpleInputSource;
{$IFDEF NEXTGEN}
  PubId, SysId, SysUri: string;
{$ELSE !NEXTGEN}
  PubId, SysId, SysUri: WideString;
{$ENDIF NEXTGEN}
  Standalone: TDomStandalone;
begin
  if not Assigned(DocTypeDecl) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Document type declaration not specified.');
  if not Assigned(DOMImpl) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('DOM implementation not specified.');
  if not Assigned(TargetDtdModel) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Target DTD model not specified.');

  if Assigned(DocTypeDecl.RootDocument) then begin
    if not (DocTypeDecl.RootDocument.DomImplementation = DOMImpl) then
      raise EWrong_DOM_Implementation_Err.Create('Wrong DOM implementation error.');
    DocUri := DocTypeDecl.RootDocument.DocumentUri;
  end else
    raise EWrong_DOM_Implementation_Err.Create('Wrong DOM implementation error.');

  Prepare;

  if Assigned(DocTypeDecl.OwnerDocument)
    then Standalone := DocTypeDecl.OwnerDocument.XmlStandalone
    else Standalone := STANDALONE_UNSPECIFIED;

  try

    // Parse the internal subset of the DTD, if any:
    if DocTypeDecl.InternalSubset = '' then begin
      TargetDtdModel.PreparationStatus := PS_INEXISTANT;
    end else begin
      IntInputSource := TXmlSimpleInputSource.Create(DocTypeDecl.InternalSubset,
                                            '',
                                            DocUri,
                                            FBufferSize,
                                            DocTypeDecl.IntSubsetStartByteNumber,
                                            DocTypeDecl.IntSubsetStartCharNumber,
                                            DocTypeDecl.IntSubsetStartColumn,
                                            0,
                                            DocTypeDecl.IntSubsetStartLine);                                                                      
      try
        ParseIntSubset(IntInputSource, Standalone, ResolveExtEntities);
      finally
        IntInputSource.Free;
      end;
    end;

    if TargetDtdModel.PreparationStatus in [ PS_INT_SUBSET_COMPLETED, PS_INEXISTANT ] then begin
      // Parse the external subset of the DTD, if any:
      PubId := DocTypeDecl.PublicId;
      SysId := DocTypeDecl.SystemId;
      if (PubId <> '') or (SysId <> '') then begin
        if ResolveExtEntities then begin

          // Issue warning, if system identifier is erroneous (cf. XML 1.0, § 4.2.2).
{$IFDEF NEXTGEN}
          if not IsUriURI_referenceStr(SysId) then begin
{$ELSE !NEXTGEN}
          if not IsUriURI_referenceWideStr(SysId) then begin
{$ENDIF NEXTGEN}
            SendErrorNotification(ET_SYSTEM_IDENTIFIER_IS_NOT_URI_REFERENCE);
          end else if Pos('#', SysID) > 0 then begin
            SendErrorNotification(ET_FRAGMENT_IDENTIFIER_IN_SYSTEM_IDENTIFIER);
          end;

          ExtDtdStream := DOMImpl.ResolveResourceAsStream(DocUri, PubId, SysId);
          if Assigned(ExtDtdStream) then begin
            try
{$IFDEF NEXTGEN}
              ResolveRelativeUriStr(DocUri, SysId, SysUri);
{$ELSE !NEXTGEN}
              ResolveRelativeUriWideStr(DocUri, SysId, SysUri);
{$ENDIF NEXTGEN}
                  // Remark: Returns an empty SysUri if ResolveRelativeUriWideStr attempt fails.
              ExtInputSource := TXmlInputSource.Create(ExtDtdStream,
                                                    PubId,
                                                    SysUri,
                                                    FBufferSize,
                                                    '',
                                                    InclDecl,
                                                    DocTypeDecl.IntSubsetStartByteNumber,
                                                    DocTypeDecl.IntSubsetStartCharNumber,
                                                    DocTypeDecl.IntSubsetStartColumn,
                                                    0,
                                                    DocTypeDecl.IntSubsetStartLine);                                                                      
              try
                ParseExtSubset(ExtInputSource);
              finally
                ExtInputSource.Free;
              end;
            finally
              ExtDtdStream.Free;
            end; {try ... finally ...}
          end else begin
            SendErrorNotification(ET_UNRESOLVABLE_EXTERNAL_SUBSET);
            TargetDtdModel.PreparationStatus := PS_INCOMPLETE_ABORTED;
          end; {if ...}
        end else
        if TargetDtdModel.PreparationStatus = PS_INT_SUBSET_COMPLETED then
          TargetDtdModel.PreparationStatus := PS_INCOMPLETE_STANDALONE;
      end else
        if TargetDtdModel.PreparationStatus = PS_INT_SUBSET_COMPLETED then
          TargetDtdModel.PreparationStatus := PS_COMPLETED;
    end;

  except
    TargetDtdModel.PreparationStatus := PS_INCOMPLETE_ABORTED;
  end;
end;

procedure TDtdToDtdModelParser.ParseExtSubset(const InputSource: TXmlInputSource);
begin
  if not Assigned(InputSource) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Input source not specified.');
  if not Assigned(DOMImpl) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('DOM implementation not specified.');

  FDtdReader.ParseExtSubset(InputSource);
  if XmlErrorDetected or XmlFatalErrorDetected then
    raise EParserException.Create('Parser error.');
end;

procedure TDtdToDtdModelParser.ParseIntSubset(const InputSource: TXmlSimpleInputSource;
                                              const Standalone: TDomStandalone;
                                              const ResolveExtPEs: Boolean);
begin
  if not Assigned(InputSource) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Input source not specified.');
  if not Assigned(DOMImpl) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('DOM implementation not specified.');

  FDtdReader.ParseIntSubset(InputSource, Standalone, ResolveExtPEs);
  if XmlErrorDetected or XmlFatalErrorDetected then
    raise EParserException.Create('Parser error.');
end;

procedure TDtdToDtdModelParser.Prepare;
begin
  FDtdReader.Prepare;
  if Assigned(TargetDtdModel) then
    TargetDtdModel.Clear;
end;

function TDtdToDtdModelParser.SendErrorNotification(const XmlErrorType: TXmlErrorType): Boolean;
var
  Error: TDomError;
begin
  if ErrorReportingEnabled then begin
    Error := TDomError.CreateFromLocator(XmlErrorType, nil, '', '');
    try
      if Assigned(DomImpl) then begin
        Result := DomImpl.HandleError(Self, Error);
      end else if Error.Severity = DOM_SEVERITY_FATAL_ERROR
        then Result := False
        else Result := True;
    finally
      Error.Free;
    end;
  end else
    Result := not (XmlErrorType in ET_FATAL_ERRORS);
end;

procedure TDtdToDtdModelParser.SetBufferSize(const Value: Integer);
begin
  if Value < 1024
    then raise ENot_Supported_Err.Create('BufferSize must not be less than 1024.');
  FBufferSize := Value;
end;

procedure TDtdToDtdModelParser.SetDomImpl(const ADOMImpl: TDomImplementation);
begin
  inherited;
  FDtdReader.DOMImpl:= ADOMImpl;
end;

procedure TDtdToDtdModelParser.SetErrorReportingEnabled(const Value: Boolean);
begin
  inherited;
  FDtdReader.ErrorReportingEnabled := Value;
end;

procedure TDtdToDtdModelParser.SetTargetDtdModel(const Value: TDtdModel);
begin
  if FDtdModelBuilder.DtdModel <> Value then
    FDtdModelBuilder.DtdModel := Value;
end;



{ TDomToXmlParser }

constructor TDomToXmlParser.Create(AOwner: TComponent);
begin
  inherited;

  FDomReader := TXmlStandardDomReader.Create(Self);
  FStreamBuilder := TXmlStreamBuilder.Create(Self);
  FStreamBuilder.IncludeXmlDecl  := True;
  FWFTestHandler := TXmlWFTestHandler.Create(Self);
  FWFTestHandler.NextHandler := FStreamBuilder;
  FDomReader.DOMImpl:= DOMImpl;
  FDomReader.IgnoreUnspecified := True;
  FDomReader.NextHandler := FStreamBuilder;

  FBufferSize := 4096;
{$IFDEF SystemEncodingName_DECLARED}
  FUseActiveCodePage := False;
{$ENDIF}
  FWriteLFOption := lwCRLF;
end;

function TDomToXmlParser.GetIgnoreUnspecified: Boolean;
begin
  Result := DomReader.IgnoreUnspecified;
end;

function TDomToXmlParser.GetIncludeXmlDecl: Boolean;
begin
  Result := StreamBuilder.IncludeXmlDecl;
end;

function TDomToXmlParser.GetOnAfterWrite: TDomSerializationEvent;
begin
  Result := StreamBuilder.OnAfterWrite;
end;

function TDomToXmlParser.GetOnBeforeWrite: TDomSerializationEvent;
begin
  Result := StreamBuilder.OnBeforeWrite;
end;

function TDomToXmlParser.GetStrictErrorChecking: Boolean;
begin
  Result := (DomReader.NextHandler = FWFTestHandler);
end;

function TDomToXmlParser.GetUseByteOrderMark: TXmlBOMOpt;
begin
  Result := StreamBuilder.UseByteOrderMark;
end;

procedure TDomToXmlParser.SetBufferSize(const Value: Integer);
begin
  if Value < 1024 then
    raise ENot_Supported_Err.Create('BufferSize must not be less than 1024.');
  FBufferSize := Value;
end;

procedure TDomToXmlParser.SetDomImpl(const Impl: TDomImplementation);
begin
  inherited;
  DomReader.DOMImpl := Impl;
end;

procedure TDomToXmlParser.SetErrorReportingEnabled(const Value: Boolean);
begin
  inherited;
  DomReader.ErrorReportingEnabled := Value;
end;

procedure TDomToXmlParser.SetIgnoreUnspecified(const Value: Boolean);
begin
  DomReader.IgnoreUnspecified := Value;
end;

procedure TDomToXmlParser.SetIncludeXmlDecl(const Value: Boolean);
begin
  StreamBuilder.IncludeXmlDecl := Value;
end;

procedure TDomToXmlParser.SetOnAfterWrite(const Value: TDomSerializationEvent);
begin
  StreamBuilder.OnAfterWrite := Value;
end;

procedure TDomToXmlParser.SetOnBeforeWrite(const Value: TDomSerializationEvent);
begin
  StreamBuilder.OnBeforeWrite := Value;
end;

procedure TDomToXmlParser.SetStrictErrorChecking(const Value: Boolean);
begin
  if Value
    then DomReader.NextHandler := WFTestHandler
    else DomReader.NextHandler := StreamBuilder;
end;

{$IFDEF SystemEncodingName_DECLARED}
procedure TDomToXmlParser.SetUseActiveCodePage(const Value: Boolean);
begin
  FUseActiveCodePage := Value;
end;
{$ENDIF}

procedure TDomToXmlParser.SetUseByteOrderMark(const Value: TXmlBOMOpt);
begin
  StreamBuilder.UseByteOrderMark := Value;
end;

procedure TDomToXmlParser.SetWriteLFOption(const Value: TCodecWriteLFOption);
begin
  FWriteLFOption := Value;
end;

function TDomToXmlParser.WriteToStream(const WNode: TDomNode;
                                       const Encoding: string;                                                                                                                 
                                       const Destination: TStream): Boolean;
var
  OutputSource: TXmlOutputSource;
begin
  if not Assigned(DOMImpl) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('DOMImplementation not specified.');
  if not Assigned(Destination) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Destination stream not specified.');
  if not Assigned(WNode) then
    raise {$IFDEF CLR}ArgumentNullException{$ELSE}EAccessViolation{$ENDIF}.Create('Source node not specified.');

  DomReader.DOMImpl := DOMImpl;
{$IFDEF SystemEncodingName_DECLARED}
  if UseActiveCodePage
    then StreamBuilder.DefaultEncoding := TEncodingRepository.SystemEncodingName
    else StreamBuilder.DefaultEncoding := Encoding;  // Raises an ENot_Supported_Err, if the specified encoding is not supported
{$ELSE}
  StreamBuilder.DefaultEncoding := Encoding;  // Raises an ENot_Supported_Err, if the specified encoding is not supported
{$ENDIF}
  OutputSource := TXmlOutputSource.Create(Destination, FBufferSize);
  try
    OutputSource.WriteLFOption := WriteLFOption;
    StreamBuilder.OutputSource := OutputSource;
    Result := DomReader.Parse(WNode);
  finally
    StreamBuilder.OutputSource := nil;
    OutputSource.Free;
  end;
end;

function TDomToXmlParser.WriteToString(const WNode: TDomNode;
                                             Encoding: string;
                                         out S: string): Boolean;
var
  XmlStream: TStringStream;
begin
  XmlStream := TStringStream.Create('');
  try
    Result := WriteToStream(WNode, Encoding, XmlStream);
    S := XmlStream.DataString;
  finally
    XmlStream.Free;
  end;
end;

{$IFDEF NEXTGEN}
function TDomToXmlParser.WriteToWideString(const WNode: TDomNode;
                                             out S: string): Boolean;
{$ELSE !NEXTGEN}
function TDomToXmlParser.WriteToWideString(const WNode: TDomNode;
                                             out S: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  XmlStream: TUtilsWideStringStream;
begin
  XmlStream := TUtilsWideStringStream.Create('');
  try
    Result := WriteToStream(WNode, 'UTF-16LE', XmlStream);
    S := XmlStream.DataString;
  finally
    XmlStream.Free;
  end;
end;



{XPath Function Library -- see XPath 1.0, sec. 4}

{XPath Node set Functions -- see XPath 1.0, sec. 4.1.}

function XPathFunctionLast(const ContextNode: TDomNode;
                           const ContextPosition: Integer;
                           const ContextSize: Integer;
                           const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
begin
  if Arguments.Count > 0 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['last']);
  if ContextSize < 1 then
    raise EXPath_Invalid_Function_Call_Err.Create('Invalid context size.');
  Result := TDomXPathNumberResult.Create(ContextSize);
end;

function XPathFunctionPosition(const ContextNode: TDomNode;
                               const ContextPosition: Integer;
                               const ContextSize: Integer;
                               const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
begin
  if Arguments.Count > 0 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['position']);
  if ContextPosition < 1 then
    raise EXPath_Invalid_Function_Call_Err.Create('Invalid context position.');
  Result := TDomXPathNumberResult.Create(ContextPosition);
end;

function XPathFunctionCount(const ContextNode: TDomNode;
                            const ContextPosition: Integer;
                            const ContextSize: Integer;
                            const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['count']);
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathNodeSetResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to node-set.',['count']);
    Result := TDomXPathNumberResult.Create(TDomXPathNodeSetResult(ExprResult).Length);
  finally
    ExprResult.Free;
  end;
end;

function XPathFunctionId(const ContextNode: TDomNode;
                         const ContextPosition: Integer;
                         const ContextSize: Integer;
                         const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  Doc: TDomDocumentNS;
  ExprResult: TDomXPathCustomResult;
  I: Integer;
  IdList: TUtilsWideStringList;
  IdNode: TDomNode;

{$IFDEF NEXTGEN}
  procedure AddId(const IdList: TUtilsWideStringList;
                  const S: string);
  var
    I, L, Head, Tail: Integer;
    IdString: string;
{$ELSE !NEXTGEN}
  procedure AddId(const IdList: TUtilsWideStringList;
                  const S: WideString);
  var
    I, L, Head, Tail: Integer;
    IdString: WideString;
{$ENDIF NEXTGEN}
  begin
    L := Length(S)-AdjustIndex;

    // Skip white space:
    Head := L + 1;
    for I := FirstIndex to L do
      if not IsXmlWhiteSpace(S[I]) then begin
        Head := I;
        Break;
      end;

    while Head <= L do begin
      // Determine next ID:
      Tail := L;
      for I := Head to L do begin
        if IsXmlWhiteSpace(S[I]) then begin
          Tail := I;
          Break;
        end;
      end;
      IdString := Copy(S, Head, Tail - Head);
      IdList.Add(idString);

      // Skip white space:
      Head := L + 1;
      for I := Tail + 1 to L do
        if not IsXmlWhiteSpace(S[I]) then begin
          Head := I;
          Break;
        end;
    end;
  end;

begin
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['id']);
  if not Assigned(ContextNode) then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Context node not specified for %s().',['id']);
  if not Assigned(ContextNode.OwnerDocument) then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Context node with no owner document specified for %s().',['id']);
  IdList := nil; // Remark: This saves one try ... finally block.
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try

    // Determine ID list:
    IdList:= TUtilsWideStringList.Create;
    IdList.Duplicates := dupIgnore;
    IdList.Sorted := True;
    if ExprResult is TDomXPathNodeSetResult then begin
      for I := 0 to Pred(TDomXPathNodeSetResult(ExprResult).Length) do
        AddId(IdList, TDomXPathNodeSetResult(ExprResult).Item(I).XPathStringValue);
    end else
      AddId(IdList, ExprResult.AsWideString);

    // Find ID nodes:
    Result := TDomXPathNodeSetResult.Create;
    try
      Doc := ContextNode.OwnerDocument as TDomDocumentNS;
      for I := 0 to Pred(IdList.Count) do begin
        IdNode := Doc.GetElementById(IdList[I]);
        if Assigned(IdNode) then
          TDomXPathNodeSetResult(Result).Add(IdNode);
      end;
      TDomXPathNodeSetResult(Result).Sort;
    except
      Result.Free;
      raise;
    end;

  finally
    IdList.Free;
    ExprResult.Free;
  end;
end;

function XPathFunctionLocalName(const ContextNode: TDomNode;
                                const ContextPosition: Integer;
                                const ContextSize: Integer;
                                const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count > 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['local-name']);
  if Arguments.Count = 0 then begin
    ExprResult := TDomXPathNodeSetResult.Create;
    TDomXPathNodeSetResult(ExprResult).Add(ContextNode);
  end else
    ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathNodeSetResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to node-set.',['local-name']);
    ExprResult.AxisType := XPATH_FORWARD_AXIS;
    if ExprResult.Length = 0 then begin
      Result := TDomXPathStringResult.Create('');
    end else begin
      if ExprResult.Item(0) is TDomProcessingInstruction
        then Result := TDomXPathStringResult.Create(TDomProcessingInstruction(ExprResult.Item(0)).Target)
        else Result := TDomXPathStringResult.Create(TDomNode(ExprResult.Item(0)).LocalName);
    end;
  finally
    ExprResult.Free;
  end;
end;

function XPathFunctionNamespaceUri(const ContextNode: TDomNode;
                                   const ContextPosition: Integer;
                                   const ContextSize: Integer;
                                   const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count > 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['namespace-uri']);
  if Arguments.Count = 0 then begin
    ExprResult := TDomXPathNodeSetResult.Create;
    TDomXPathNodeSetResult(ExprResult).Add(ContextNode);
  end else
    ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathNodeSetResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to node-set.',['namespace-uri']);
    ExprResult.AxisType := XPATH_FORWARD_AXIS;
    if ExprResult.Length = 0
      then Result := TDomXPathStringResult.Create('')
      else Result := TDomXPathStringResult.Create(TDomNode(ExprResult.Item(0)).NamespaceUri);
  finally
    ExprResult.Free;
  end;
end;

function XPathFunctionName(const ContextNode: TDomNode;
                           const ContextPosition: Integer;
                           const ContextSize: Integer;
                           const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count > 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['name']);
  if Arguments.Count = 0 then begin
    ExprResult := TDomXPathNodeSetResult.Create;
    TDomXPathNodeSetResult(ExprResult).Add(ContextNode);
  end else
    ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathNodeSetResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to node-set.',['name']);
    ExprResult.AxisType := XPATH_FORWARD_AXIS;
    if ExprResult.Length = 0
      then Result := TDomXPathStringResult.Create('')
      else Result := TDomXPathStringResult.Create(TDomNode(ExprResult.Item(0)).ExpandedName);
  finally
    ExprResult.Free;
  end;
end;

{XPath String Functions -- see XPath 1.0, sec. 4.2.}

function XPathFunctionString(const ContextNode: TDomNode;
                             const ContextPosition: Integer;
                             const ContextSize: Integer;
                             const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  if Arguments.Count > 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['string']);
  if Arguments.Count = 0 then begin
    ExprResult := TDomXPathNodeSetResult.Create;
    TDomXPathNodeSetResult(ExprResult).Add(ContextNode);
  end else
    ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  Result := XPathStringFunc(ExprResult);  // As a side-effect automatically frees ExprResult.
end;

function XPathFunctionConcat(const ContextNode: TDomNode;
                             const ContextPosition: Integer;
                             const ContextSize: Integer;
                             const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
  I: Integer;
{$IFDEF NEXTGEN}
  S: string;
{$ELSE !NEXTGEN}
  S: WideString;
{$ENDIF NEXTGEN}
begin
  if Arguments.Count < 2 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['concat']);
  S := '';
  for I := 0 to Pred(Arguments.Count) do begin
    ExprResult := TDomXPathExpr(Arguments[I]).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      if not (ExprResult is TDomXPathStringResult) then
        raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['concat']);
      S := Concat(S, ExprResult.AsWideString);
    finally
      ExprResult.Free;
    end;
  end;
  Result := TDomXPathStringResult.Create(S);
end;

function XPathFunctionStartsWith(const ContextNode: TDomNode;
                                 const ContextPosition: Integer;
                                 const ContextSize: Integer;
                                 const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  S1_Result, S2_Result: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 2 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['starts-with']);
  S2_Result := nil; // Remark: Saves one try ... finally block
  S1_Result := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    S2_Result := TDomXPathExpr(Arguments[1]).Evaluate(ContextNode, ContextPosition, ContextSize);
    if not ( (S1_Result is TDomXPathStringResult) and (S2_Result is TDomXPathStringResult) ) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['starts-with']);
    Result := TDomXPathBooleanResult.Create(
                CompareWideStr(
                  Copy(S1_Result.AsWideString, 1, Length(S2_Result.AsWideString)),
                  S2_Result.AsWideString
                ) = 0
              );
  finally
    S1_Result.Free;
    S2_Result.Free;
  end;
end;

function XPathFunctionContains(const ContextNode: TDomNode;
                               const ContextPosition: Integer;
                               const ContextSize: Integer;
                               const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  S1_Result, S2_Result: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 2 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['contains']);
  S2_Result := nil; // Remark: Saves one try ... finally block
  S1_Result := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    S2_Result := TDomXPathExpr(Arguments[1]).Evaluate(ContextNode, ContextPosition, ContextSize);
    if not ( (S1_Result is TDomXPathStringResult) and (S2_Result is TDomXPathStringResult) ) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['contains']);
    if Length(S2_Result.AsWideString) = 0
      then Result := TDomXPathBooleanResult.Create(True)
      else Result := TDomXPathBooleanResult.Create(
                       Pos(S2_Result.AsWideString,S1_Result.AsWideString) > 0
                     );
  finally
    S1_Result.Free;
    S2_Result.Free;
  end;
end;

function XPathFunctionSubstringBefore(const ContextNode: TDomNode;
                                      const ContextPosition: Integer;
                                      const ContextSize: Integer;
                                      const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  S1_Result, S2_Result: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 2 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['substring-before']);
  S2_Result := nil; // Remark: Saves one try ... finally block
  S1_Result := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    S2_Result := TDomXPathExpr(Arguments[1]).Evaluate(ContextNode, ContextPosition, ContextSize);
    if not ( (S1_Result is TDomXPathStringResult) and (S2_Result is TDomXPathStringResult) ) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['substring-before']);
    Result := TDomXPathStringResult.Create(
                Copy(S1_Result.AsWideString, 1,
                       Pred( Pos(S2_Result.AsWideString, S1_Result.AsWideString ) ) )
              );
  finally
    S1_Result.Free;
    S2_Result.Free;
  end;
end;

function XPathFunctionSubstringAfter(const ContextNode: TDomNode;
                                     const ContextPosition: Integer;
                                     const ContextSize: Integer;
                                     const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  S1_Result, S2_Result: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 2 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['substring-after']);
  S2_Result := nil; // Remark: Saves one try ... finally block
  S1_Result := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    S2_Result := TDomXPathExpr(Arguments[1]).Evaluate(ContextNode, ContextPosition, ContextSize);
    if not ( (S1_Result is TDomXPathStringResult) and (S2_Result is TDomXPathStringResult) ) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['substring-after']);
    if Length(S2_Result.AsWideString) = 0
      then Result := TDomXPathStringResult.Create(S1_Result.AsWideString)
      else Result := TDomXPathStringResult.Create(
                       Copy(S1_Result.AsWideString,
                            Pos(S2_Result.AsWideString, S1_Result.AsWideString )
                              + Length(S2_Result.AsWideString),
                            Length(S1_Result.AsWideString)
                           )
                     );
  finally
    S1_Result.Free;
    S2_Result.Free;
  end;
end;

function XPathFunctionSubstring(const ContextNode: TDomNode;
                                const ContextPosition: Integer;
                                const ContextSize: Integer;
                                const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  S1_Result, N1_Result, N2_Result: TDomXPathCustomResult;
  I, L: Integer;
begin
  Result := nil;
  if (Arguments.Count <> 2) and (Arguments.Count <> 3) then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['substring']);
  N1_Result := nil; // Remark: Saves one try ... finally block
  N2_Result := nil; // Remark: Saves one try ... finally block
  S1_Result := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    N1_Result := TDomXPathExpr(Arguments[1]).Evaluate(ContextNode, ContextPosition, ContextSize);
    if not (S1_Result is TDomXPathStringResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['substring']);
    if not (N1_Result is TDomXPathNumberResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to number.',['substring']);
    if Arguments.Count = 3 then begin
      N2_Result := TDomXPathExpr(Arguments[2]).Evaluate(ContextNode, ContextPosition, ContextSize);
      if not (N2_Result is TDomXPathNumberResult) then
        raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to number.',['substring']);

      if IsNaN(N1_Result.AsNumber) or
         IsInfinite(N1_Result.AsNumber) or
         IsNaN(N2_Result.AsNumber)
      then begin
        Result := TDomXPathStringResult.Create('');
      end else if IsInfinite(N2_Result.AsNumber) then begin
        if Sign(N2_Result.AsNumber) = 1
          then Result := TDomXPathStringResult.Create(Copy( S1_Result.AsWideString,
                                                            Trunc(XPathRound(N1_Result.AsNumber)),
                                                            Length(S1_Result.AsWideString) ))
          else Result := TDomXPathStringResult.Create('');
      end else begin
        I := Max(Trunc(XPathRound((N1_Result.AsNumber))), 1);
        L := Trunc(XPathRound((N1_Result.AsNumber)) + XPathRound((N2_Result.AsNumber))) - I;
        Result := TDomXPathStringResult.Create(Copy(S1_Result.AsWideString, I, L) );
      end;

    end else begin

      if IsNaN(N1_Result.AsNumber) then begin
        Result := TDomXPathStringResult.Create('');
      end else if IsInfinite(N1_Result.AsNumber) then begin
        if Sign(N1_Result.AsNumber) = 1
          then Result := TDomXPathStringResult.Create('')
          else Result := TDomXPathStringResult.Create(S1_Result.AsWideString);
      end else
        Result := TDomXPathStringResult.Create(Copy( S1_Result.AsWideString,
                                                     Trunc(XPathRound(N1_Result.AsNumber)),
                                                     Length(S1_Result.AsWideString) ));

    end;
  finally
    S1_Result.Free;
    N1_Result.Free;
    N2_Result.Free;
  end;
end;

function XPathFunctionStringLength(const ContextNode: TDomNode;
                                   const ContextPosition: Integer;
                                   const ContextSize: Integer;
                                   const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count > 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['string-length']);
  if Arguments.Count = 0 then begin
    if not Assigned(ContextNode) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Context node not specified for %s().',['string-length']);
    Result := TDomXPathNumberResult.Create(Length(ContextNode.XPathStringValue));
  end else begin
    ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      if not (ExprResult is TDomXPathStringResult) then
        raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['string-length']);
      Result := TDomXPathNumberResult.Create(Length(ExprResult.AsWideString));
    finally
      ExprResult.Free;
    end;
  end;
end;

function XPathFunctionNormalizeSpace(const ContextNode: TDomNode;
                                     const ContextPosition: Integer;
                                     const ContextSize: Integer;
                                     const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count > 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['normalize-space']);
  if Arguments.Count = 0 then begin
    if not Assigned(ContextNode) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Context node not specified for %s().',['normalize-space']);
    Result := TDomXPathStringResult.Create(NormalizeWhiteSpace(ContextNode.XPathStringValue));
  end else begin
    ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      if not (ExprResult is TDomXPathStringResult) then
        raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['normalize-space']);
      Result := TDomXPathStringResult.Create(NormalizeWhiteSpace(ExprResult.AsWideString));
    finally
      ExprResult.Free;
    end;
  end;
end;

function XPathFunctionTranslate(const ContextNode: TDomNode;
                                const ContextPosition: Integer;
                                const ContextSize: Integer;
                                const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  S1, S2, S3: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 3 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['translate']);
  S2 := nil; // Remark: Saves one try ... finally block
  S3 := nil; // Remark: Saves one try ... finally block
  S1 := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    S2 := TDomXPathExpr(Arguments[1]).Evaluate(ContextNode, ContextPosition, ContextSize);
    S3 := TDomXPathExpr(Arguments[2]).Evaluate(ContextNode, ContextPosition, ContextSize);
    if not ( (S1 is TDomXPathStringResult) and (S2 is TDomXPathStringResult) and (S3 is TDomXPathStringResult) ) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['translate']);
    Result := TDomXPathStringResult.Create(
                translateWideString(S1.AsWideString, S2.AsWideString, S3.AsWideString) );
  finally
    S1.Free;
    S2.Free;
    S3.Free;
  end;
end;

{XPath Boolean Functions -- see XPath 1.0, sec. 4.3.}

function XPathFunctionBoolean(const ContextNode: TDomNode;
                              const ContextPosition: Integer;
                              const ContextSize: Integer;
                              const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['boolean']);
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  Result := XPathBooleanFunc(ExprResult);  // As a side-effect automatically frees ExprResult.
end;

function XPathFunctionNot(const ContextNode: TDomNode;
                          const ContextPosition: Integer;
                          const ContextSize: Integer;
                          const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['not']);
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathBooleanResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to boolean.',['not']);
    Result := TDomXPathBooleanResult.Create(not(ExprResult.AsBoolean));
  finally
    ExprResult.Free;
  end;
end;

function XPathFunctionTrue(const ContextNode: TDomNode;
                           const ContextPosition: Integer;
                           const ContextSize: Integer;
                           const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
begin
  if Arguments.Count > 0 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['true']);
  Result := TDomXPathBooleanResult.Create(True);
end;

function XPathFunctionFalse(const ContextNode: TDomNode;
                            const ContextPosition: Integer;
                            const ContextSize: Integer;
                            const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
begin
  if Arguments.Count > 0 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['false']);
  Result := TDomXPathBooleanResult.Create(False);
end;

function XPathFunctionLang(const ContextNode: TDomNode;
                           const ContextPosition: Integer;
                           const ContextSize: Integer;
                           const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['lang']);
  if not Assigned(ContextNode) then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Context node not specified for %s().',['lang']);
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathStringResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to string.',['lang']);
    Result := TDomXPathBooleanResult.Create(
                isSubLanguage(ExprResult.AsWideString, ContextNode.language)
              );
  finally
    ExprResult.Free;
  end;
end;

{ XPath Number Functions -- see XPath 1.0, sec. 4.4. }

function XPathFunctionNumber(const ContextNode: TDomNode;
                             const ContextPosition: Integer;
                             const ContextSize: Integer;
                             const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  if Arguments.Count > 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['number']);
  if Arguments.Count = 0 then begin
    ExprResult := TDomXPathNodeSetResult.Create;
    TDomXPathNodeSetResult(ExprResult).Add(ContextNode);
  end else
    ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  Result := XPathNumberFunc(ExprResult);  // As a side-effect automatically frees ExprResult.
end;

function XPathFunctionSum(const ContextNode: TDomNode;
                          const ContextPosition: Integer;
                          const ContextSize: Integer;
                          const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF}
  {$ENDIF VER250+}
{$ENDIF}
  ExprResult: TDomXPathCustomResult;
  I: Integer;
  M, N: Double;
begin
  Result := nil;
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['sum']);
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathNodeSetResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to node-set.',['sum']);
    N := 0;
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
    ExceptionMaskBackup := SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
    try
{$ENDIF}
      for I := 0 to Pred(TDomXPathNodeSetResult(ExprResult).Length) do begin
        try
          M := XPathWideStringToNumber(TDomXPathNodeSetResult(ExprResult).Item(I).XPathStringValue);
        except
          M := NaN;
        end;
        N := N + M;
      end;
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
    finally
      SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
    except
      N := NaN;
  {$ENDIF}
    end;
{$ENDIF}
    Result := TDomXPathNumberResult.Create(N);
  finally
    ExprResult.Free;
  end;
end;

function XPathFunctionFloor(const ContextNode: TDomNode;
                            const ContextPosition: Integer;
                            const ContextSize: Integer;
                            const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['floor']);
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathNumberResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to a number.',['floor']);
    if IsNaN(ExprResult.AsNumber) or IsInfinite(ExprResult.AsNumber)
      then Result := TDomXPathNumberResult.Create(ExprResult.AsNumber)
      else Result := TDomXPathNumberResult.Create(Floor(ExprResult.AsNumber));
  finally
    ExprResult.Free;
  end;
end;

function XPathFunctionCeiling(const ContextNode: TDomNode;
                              const ContextPosition: Integer;
                              const ContextSize: Integer;
                              const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['ceiling']);
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathNumberResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to a number.',['ceiling']);
    if IsNaN(ExprResult.AsNumber) or IsInfinite(ExprResult.AsNumber)
      then Result := TDomXPathNumberResult.Create(ExprResult.AsNumber)
      else Result := TDomXPathNumberResult.Create(Ceil(ExprResult.AsNumber));
  finally
    ExprResult.Free;
  end;
end;

function XPathFunctionRound(const ContextNode: TDomNode;
                            const ContextPosition: Integer;
                            const ContextSize: Integer;
                            const Arguments: TList<TDomXPathSyntaxNode>): TDomXPathCustomResult;
var
  ExprResult: TDomXPathCustomResult;
begin
  Result := nil;
  if Arguments.Count <> 1 then
    raise EXPath_Invalid_Function_Call_Err.CreateFmt('Arguments mismatch error in %s().',['round']);
  ExprResult := TDomXPathExpr(Arguments[0]).Evaluate(ContextNode, ContextPosition, ContextSize);
  try
    if not (ExprResult is TDomXPathNumberResult) then
      raise EXPath_Invalid_Function_Call_Err.CreateFmt('Argument mismatch error in %s(): Expression does not evaluate to a number.',['round']);
    Result := TDomXPathNumberResult.Create(XPathRound(ExprResult.AsNumber));
  finally
    ExprResult.Free;
  end;
end;

{ TDomXPathTokenizer }

{$IFDEF NEXTGEN}
constructor TDomXPathTokenizer.Create(const Expression: string;
                                      const XPathVersion: string);
{$ELSE !NEXTGEN}
constructor TDomXPathTokenizer.Create(const Expression: WideString;
                                      const XPathVersion: WideString);
{$ENDIF NEXTGEN}
begin
  inherited Create;
  if xpathVersion <> '1.0'
    then raise ENot_Supported_Err.CreateFmt('XPath version "%S" not supproted.',[xpathVersion]);
  FExpression := Expression;
  FLastSymbol := XPATH_INVALID_TOKEN;  // Use XPATH_INVALID_TOKEN as a dummy value
  FPosition:= 0;
  FDoubleSlashStatus:= SL_NO_DOUBLE_SLASH;
  FPositionCache:= 0;
  FSymbolCache:= XPATH_INVALID_TOKEN;
  FValueCache:= '';
  FCacheIsActive:= False;
end;

function TDomXPathTokenizer.DoubleColonFollows: Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := FPosition+FirstIndex to Pred(Length(FExpression))-AdjustIndex do begin
    if FExpression[I] = #$3a then begin
      if FExpression[I+1] = #$3a
        then Result := True;
      Exit;
    end;
    if not IsXmlWhiteSpace(FExpression[I]) then Exit;
  end;
end;

function TDomXPathTokenizer.GetNextWideChar(out S: WideChar): Boolean;
begin
  if FPosition = Length(FExpression)-AdjustIndex then begin
    S := #0;
    Result := False;
  end else begin
    Inc(FPosition);
    S := FExpression[FPosition];
    Result := True;
  end;
end;

function TDomXPathTokenizer.IsFollowing(const Symbol: TDomXPathTokenType): Boolean;
begin
  if not FCacheIsActive then begin
    Read(FSymbolCache,FValueCache,FPositionCache);
    FCacheIsActive:= True;
  end;
  if FSymbolCache = Symbol
    then Result := True
    else Result := False;
end;

function TDomXPathTokenizer.LeftParanthesisFollows: Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := FPosition+1 to Length(FExpression)-AdjustIndex do begin
    if FExpression[I] = #$28 then begin
      Result := True;
      Exit;
    end;
    if not IsXmlWhiteSpace(FExpression[I]) then Exit;
  end;
end;

function TDomXPathTokenizer.LookAheadNextWideChar(out S: WideChar): Boolean;
begin
  if FPosition = Length(FExpression)-AdjustIndex then begin
    S := #0;
    Result := False;
  end else begin
    S := FExpression[FPosition+1];
    Result := True;
  end;
end;

{$IFDEF NEXTGEN}
procedure TDomXPathTokenizer.Read(out Symbol: TDomXPathTokenType;
                                  out Value: string;
                                  out Position: Integer);
{$ELSE !NEXTGEN}
procedure TDomXPathTokenizer.Read(out Symbol: TDomXPathTokenType;
                                  out Value: WideString;
                                  out Position: Integer);
{$ENDIF NEXTGEN}
var
  S: WideChar;
  L: WideChar;
  DecimalPointFound: Boolean;
begin
  if FCacheIsActive then begin
    Symbol := FSymbolCache;
    Value := FValueCache;
    Position := FPositionCache;
    FCacheIsActive:= False;
    Exit;
  end;
  case FDoubleSlashStatus of
    SL_NO_DOUBLE_SLASH: begin
      repeat
        if not GetNextWideChar(S) then begin
          // End of text:
          Symbol := XPATH_END_OF_TEXT_TOKEN;
          Value := '';
          Position := -1;
          Exit;
        end;
      until not IsXmlWhiteSpace(S);

      case Ord(S) of
        $28: begin // '('
          Symbol := XPATH_LEFT_PARENTHESIS_TOKEN;
          FLastSymbol := XPATH_LEFT_PARENTHESIS_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $29: begin // ')'
          Symbol := XPATH_RIGHT_PARENTHESIS_TOKEN;
          FLastSymbol := XPATH_RIGHT_PARENTHESIS_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $5b: begin // '['
          Symbol := XPATH_LEFT_SQUARE_BRACKET_TOKEN;
          FLastSymbol := XPATH_LEFT_SQUARE_BRACKET_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $5d: begin // ']'
          Symbol := XPATH_RIGHT_SQUARE_BRACKET_TOKEN;
          FLastSymbol := XPATH_RIGHT_SQUARE_BRACKET_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $40: begin // '@'
          Symbol := XPATH_COMMERCIAL_AT_TOKEN;
          FLastSymbol := XPATH_COMMERCIAL_AT_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $2c: begin // ','
          Symbol := XPATH_COMMA_TOKEN;
          FLastSymbol := XPATH_COMMA_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $3a: begin // ':'
          LookAheadNextWideChar(L);
          if L = #$3a then begin // '::'
            Inc(FPosition);
            Symbol := XPATH_DOUBLE_COLON_TOKEN;
            FLastSymbol := XPATH_DOUBLE_COLON_TOKEN;
            Value := '';
            Position := FPosition;
          end else begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
            Value := ':';
            Position := FPosition;
          end;
        end;
        $7c: begin // '|'
          Symbol := XPATH_SHEFFER_STROKE_OPERATOR_TOKEN;
          FLastSymbol := XPATH_SHEFFER_STROKE_OPERATOR_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $2b: begin // '+'
          Symbol := XPATH_PLUS_OPERATOR_TOKEN;
          FLastSymbol := XPATH_PLUS_OPERATOR_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $2d: begin // '-'
          Symbol := XPATH_MINUS_OPERATOR_TOKEN;
          FLastSymbol := XPATH_MINUS_OPERATOR_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $3d: begin // '='
          Symbol := XPATH_IS_EQUAL_OPERATOR_TOKEN;
          FLastSymbol := XPATH_IS_EQUAL_OPERATOR_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $21: begin // '!'
          LookAheadNextWideChar(L);
          if L = #$3d then begin // '!='
            Inc(FPosition);
            Symbol := XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN;
            FLastSymbol := XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN;
            Value := '';
            Position := FPosition;
          end else begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
            Value := '!';
            Position := FPosition;
          end;
        end;
        $2f: begin // '/'
          LookAheadNextWideChar(L);
          if L = #$2f then begin // '//'
            Inc(FPosition);
            FDoubleSlashStatus:= SL_XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN_FOLLOWS;
          end;
          Symbol := XPATH_SLASH_OPERATOR_TOKEN;
          FLastSymbol := XPATH_SLASH_OPERATOR_TOKEN;
          Value := '';
          Position := FPosition;
        end;
        $3c: begin // '<'
          LookAheadNextWideChar(L);
          if L = #$3d then begin // '<='
            Inc(FPosition);
            Symbol := XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN;
            FLastSymbol := XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN;
          end else begin
            Symbol := XPATH_LESS_THAN_OPERATOR_TOKEN;
            FLastSymbol := XPATH_LESS_THAN_OPERATOR_TOKEN;
          end;
          Value := '';
          Position := FPosition;
        end;
        $3e: begin // '>'
          LookAheadNextWideChar(L);
          if L = #$3d then begin // '>='
            Inc(FPosition);
            Symbol := XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN;
            FLastSymbol := XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN;
          end else begin
            Symbol := XPATH_GREATER_THAN_OPERATOR_TOKEN;
            FLastSymbol := XPATH_GREATER_THAN_OPERATOR_TOKEN;
          end;
          Value := '';
          Position := FPosition;
        end;
        $2e: begin // '.'
          LookAheadNextWideChar(L);
          case Ord(L) of
            $2e: begin // '..'
              Inc(FPosition);
              Symbol := XPATH_DOUBLE_DOT_TOKEN;
              FLastSymbol := XPATH_DOUBLE_DOT_TOKEN;
              Value := '';
              Position := FPosition;
            end;
            $30..$39: begin // Digit
              Value := '.';
              repeat
                Inc(FPosition);
{$IFDEF NEXTGEN}
                Value := Concat(Value, string(L));
{$ELSE !NEXTGEN}
                Value := Concat(Value, WideString(L));
{$ENDIF NEXTGEN}
                LookAheadNextWideChar(L);
              until not (Ord(L) in [$30..$39]);
              Symbol := XPATH_NUMBER_TOKEN;
              FLastSymbol := XPATH_NUMBER_TOKEN;
              Position := FPosition;
            end;
          else // '.'
            Symbol := XPATH_SINGLE_DOT_TOKEN;
            FLastSymbol := XPATH_SINGLE_DOT_TOKEN;
            Value := '';
            Position := FPosition;
          end; {case ... else}
        end;
        $30..$39: begin // Digit
          Value := S;
          DecimalPointFound:= False;
          if LookAheadNextWideChar(S) then begin
            while (Ord(S) in [$30..$39]) or ((S = #$2e) and not DecimalPointFound) do begin
              Inc(FPosition);
{$IFDEF NEXTGEN}
              Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
              Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
              if S = #$2e then DecimalPointFound:= True;
              LookAheadNextWideChar(S);
            end;
          end;
          Symbol := XPATH_NUMBER_TOKEN;
          FLastSymbol := XPATH_NUMBER_TOKEN;
          Position := FPosition;
        end;
        $22: begin // '"'
          Value := '';
          if not GetNextWideChar(S) then begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
            Position := FPosition;
            Exit;
          end;
          while S <> #$22 do begin
{$IFDEF NEXTGEN}
            Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
            Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
            if not GetNextWideChar(S) then begin
              Symbol := XPATH_INVALID_TOKEN;
              FLastSymbol := XPATH_INVALID_TOKEN;
              Position := FPosition;
              Exit;
            end;
          end;
          Symbol := XPATH_LITERAL_TOKEN;
          FLastSymbol := XPATH_LITERAL_TOKEN;
          Position := FPosition;
        end;
        $27: begin // '"'
          Value := '';
          if not GetNextWideChar(S) then begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
            Position := FPosition;
            Exit;
          end;
          while S <> #$27 do begin
{$IFDEF NEXTGEN}
            Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
            Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
            if not GetNextWideChar(S) then begin
              Symbol := XPATH_INVALID_TOKEN;
              FLastSymbol := XPATH_INVALID_TOKEN;
              Position := FPosition;
              Exit;
            end;
          end;
          Symbol := XPATH_LITERAL_TOKEN;
          FLastSymbol := XPATH_LITERAL_TOKEN;
          Position := FPosition;
        end;
        $24: begin // '$'
          if not LookAheadNextWideChar(S) then begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
            Position := FPosition;
            Exit;
          end;
          if not IsXmlNCNameStartChar(S) then begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
            Position := FPosition;
{$IFDEF NEXTGEN}
            Value := string(S);
{$ELSE !NEXTGEN}
            Value := WideString(S);
{$ENDIF NEXTGEN}
            Exit;
          end;
          Value := '';
          while IsXmlNCNameChar(S) do begin
            Inc(FPosition);
{$IFDEF NEXTGEN}
            Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
            Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
            if not LookAheadNextWideChar(S)
              then Break;
          end;
          if S = #$3a then begin // ':' ?
            Inc(FPosition);
            if not LookAheadNextWideChar(S) then begin
              Symbol := XPATH_INVALID_TOKEN;
              FLastSymbol := XPATH_INVALID_TOKEN;
              Position := FPosition;
              Value := Concat(Value, ':');
              Exit;
            end;
            if S = #$3a then begin // '::' ?
              Dec(FPosition);
            end else begin
              Value := Concat(Value, ':');
             if not IsXmlNCNameStartChar(S) then begin
                Symbol := XPATH_INVALID_TOKEN;
                FLastSymbol := XPATH_INVALID_TOKEN;
                Position := FPosition;
{$IFDEF NEXTGEN}
                Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
                Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
                Exit;
              end;
              while IsXmlNCNameChar(S) do begin
                Inc(FPosition);
{$IFDEF NEXTGEN}
                Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
                Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
                if not Self.LookAheadNextWideChar(S)
                  then Break;
              end;
            end;
          end;
          Symbol := XPATH_VARIABLE_REFERENCE_TOKEN;
          FLastSymbol := XPATH_VARIABLE_REFERENCE_TOKEN;
          Position := FPosition;
        end;
        $2a: begin // '*'
          if FLastSymbol in [ XPATH_LEFT_PARENTHESIS_TOKEN,
                              XPATH_LEFT_SQUARE_BRACKET_TOKEN,
                              XPATH_COMMERCIAL_AT_TOKEN,
                              XPATH_COMMA_TOKEN,
                              XPATH_DOUBLE_COLON_TOKEN,
                              XPATH_AND_OPERATOR_TOKEN,
                              XPATH_OR_OPERATOR_TOKEN,
                              XPATH_MOD_OPERATOR_TOKEN,
                              XPATH_DIV_OPERATOR_TOKEN,
                              XPATH_MULTIPLY_OPERATOR_TOKEN,
                              XPATH_SLASH_OPERATOR_TOKEN,
                              XPATH_SHEFFER_STROKE_OPERATOR_TOKEN,
                              XPATH_PLUS_OPERATOR_TOKEN,
                              XPATH_MINUS_OPERATOR_TOKEN,
                              XPATH_IS_EQUAL_OPERATOR_TOKEN,
                              XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN,
                              XPATH_LESS_THAN_OPERATOR_TOKEN,
                              XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN,
                              XPATH_GREATER_THAN_OPERATOR_TOKEN,
                              XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN,
                              XPATH_INVALID_TOKEN  // = no preceding token
                            ]
          then begin
            Symbol := XPATH_NAME_TEST_TOKEN;
            FLastSymbol := XPATH_NAME_TEST_TOKEN;
            Value := '*';
          end else begin
            Symbol := XPATH_MULTIPLY_OPERATOR_TOKEN;
            FLastSymbol := XPATH_MULTIPLY_OPERATOR_TOKEN;
            Value := '';
          end;
          Position := FPosition;
        end;
      else  {case ...}

        // Parse NCName:
        if not IsXmlNCNameStartChar(S) then begin
          Symbol := XPATH_INVALID_TOKEN;
          FLastSymbol := XPATH_INVALID_TOKEN;
          Position := FPosition;
{$IFDEF NEXTGEN}
          Value := string(S);
{$ELSE !NEXTGEN}
          Value := WideString(S);
{$ENDIF NEXTGEN}
          Exit;
        end;
        Value := '';
        Dec(FPosition);
        while IsXmlNCNameChar(S) do begin
          Inc(FPosition);
{$IFDEF NEXTGEN}
          Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
          Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
          if not LookAheadNextWideChar(S)
            then Break;
        end;

        if not ( FLastSymbol in [ XPATH_LEFT_PARENTHESIS_TOKEN,
                                  XPATH_LEFT_SQUARE_BRACKET_TOKEN,
                                  XPATH_COMMERCIAL_AT_TOKEN,
                                  XPATH_COMMA_TOKEN,
                                  XPATH_DOUBLE_COLON_TOKEN,
                                  XPATH_AND_OPERATOR_TOKEN,
                                  XPATH_OR_OPERATOR_TOKEN,
                                  XPATH_MOD_OPERATOR_TOKEN,
                                  XPATH_DIV_OPERATOR_TOKEN,
                                  XPATH_MULTIPLY_OPERATOR_TOKEN,
                                  XPATH_SLASH_OPERATOR_TOKEN,
                                  XPATH_SHEFFER_STROKE_OPERATOR_TOKEN,
                                  XPATH_PLUS_OPERATOR_TOKEN,
                                  XPATH_MINUS_OPERATOR_TOKEN,
                                  XPATH_IS_EQUAL_OPERATOR_TOKEN,
                                  XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN,
                                  XPATH_LESS_THAN_OPERATOR_TOKEN,
                                  XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN,
                                  XPATH_GREATER_THAN_OPERATOR_TOKEN,
                                  XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN,
                                  XPATH_INVALID_TOKEN  // = no preceding token
                                ] )
        then begin
          if Value = 'and' then begin
            Symbol := XPATH_AND_OPERATOR_TOKEN;
            FLastSymbol := XPATH_AND_OPERATOR_TOKEN;
            Value := '';
          end else if Value = 'or' then begin
            Symbol := XPATH_OR_OPERATOR_TOKEN;
            FLastSymbol := XPATH_OR_OPERATOR_TOKEN;
            Value := '';
          end else if Value = 'mod' then begin
            Symbol := XPATH_MOD_OPERATOR_TOKEN;
            FLastSymbol := XPATH_MOD_OPERATOR_TOKEN;
            Value := '';
          end else if Value = 'div' then begin
            Symbol := XPATH_DIV_OPERATOR_TOKEN;
            FLastSymbol := XPATH_DIV_OPERATOR_TOKEN;
            Value := '';
          end else begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
          end;
          Position := FPosition;
          Exit;
        end;

        if DoubleColonFollows then begin
          if Value = 'ancestor' then begin
            Symbol := XPATH_AXIS_NAME_ANCESTOR_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_ANCESTOR_TOKEN;
            Value := '';
          end else if Value = 'ancestor-or-self' then begin
            Symbol := XPATH_AXIS_NAME_ANCESTOR_OR_SELF_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_ANCESTOR_OR_SELF_TOKEN;
            Value := '';
          end else if Value = 'attribute' then begin
            Symbol := XPATH_AXIS_NAME_ATTRIBUTE_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_ATTRIBUTE_TOKEN;
            Value := '';
          end else if Value = 'child' then begin
            Symbol := XPATH_AXIS_NAME_CHILD_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_CHILD_TOKEN;
            Value := '';
          end else if Value = 'descendant' then begin
            Symbol := XPATH_AXIS_NAME_DESCENDANT_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_DESCENDANT_TOKEN;
            Value := '';
          end else if Value = 'descendant-or-self' then begin
            Symbol := XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN;
            Value := '';
          end else if Value = 'following' then begin
            Symbol := XPATH_AXIS_NAME_FOLLOWING_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_FOLLOWING_TOKEN;
            Value := '';
          end else if Value = 'following-sibling' then begin
            Symbol := XPATH_AXIS_NAME_FOLLOWING_SIBLING_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_FOLLOWING_SIBLING_TOKEN;
            Value := '';
          end else if Value = 'namespace' then begin
            Symbol := XPATH_AXIS_NAME_NAMESPACE_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_NAMESPACE_TOKEN;
            Value := '';
          end else if Value = 'parent' then begin
            Symbol := XPATH_AXIS_NAME_PARENT_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_PARENT_TOKEN;
            Value := '';
          end else if Value = 'preceding' then begin
            Symbol := XPATH_AXIS_NAME_PRECEDING_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_PRECEDING_TOKEN;
          end else if Value = 'preceding-sibling' then begin
            Symbol := XPATH_AXIS_NAME_PRECEDING_SIBLING_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_PRECEDING_SIBLING_TOKEN;
            Value := '';
          end else if Value = 'self' then begin
            Symbol := XPATH_AXIS_NAME_SELF_TOKEN;
            FLastSymbol := XPATH_AXIS_NAME_SELF_TOKEN;
            Value := '';
          end else begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
            Value := '';
          end;
          Position := FPosition;
          Exit;
        end;

        if S = #$3a then begin // ':' ?
          Inc(FPosition);
          if not LookAheadNextWideChar(S) then begin
            Symbol := XPATH_INVALID_TOKEN;
            FLastSymbol := XPATH_INVALID_TOKEN;
            Position := FPosition;
            Value := Concat(Value, ':');
            Exit;
          end;
          if S = #$3a then begin // '::' ?
            Dec(FPosition);
          end else begin
            Value := Concat(Value, ':');
            if not IsXmlNCNameStartChar(S) then begin
              if S = #$2a then begin // '*
                Symbol := XPATH_NAME_TEST_TOKEN;
                FLastSymbol := XPATH_NAME_TEST_TOKEN;
              end else begin
                Symbol := XPATH_INVALID_TOKEN;
                FLastSymbol := XPATH_INVALID_TOKEN;
              end;
              Inc(FPosition);
              Position := FPosition;
{$IFDEF NEXTGEN}
              Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
              Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
              Exit;
            end;
            while IsXmlNCNameChar(S) do begin
              Inc(FPosition);
{$IFDEF NEXTGEN}
              Value := Concat(Value, string(S));
{$ELSE !NEXTGEN}
              Value := Concat(Value, WideString(S));
{$ENDIF NEXTGEN}
              if not Self.LookAheadNextWideChar(S)
                then Break;
            end;
          end;
        end;

        if leftParanthesisFollows then begin
          if Value = 'comment' then begin
            Symbol := XPATH_NODE_TYPE_COMMENT_TOKEN;
            FLastSymbol := XPATH_NODE_TYPE_COMMENT_TOKEN;
            Value := '';
          end else if Value = 'text' then begin
            Symbol := XPATH_NODE_TYPE_TEXT_TOKEN;
            FLastSymbol := XPATH_NODE_TYPE_TEXT_TOKEN;
            Value := '';
          end else if Value = 'processing-instruction' then begin
            Symbol := XPATH_NODE_TYPE_PI_TOKEN;
            FLastSymbol := XPATH_NODE_TYPE_PI_TOKEN;
            Value := '';
          end else if Value = 'node' then begin
            Symbol := XPATH_NODE_TYPE_NODE_TOKEN;
            FLastSymbol := XPATH_NODE_TYPE_NODE_TOKEN;
            Value := '';
          end else begin
            Symbol := XPATH_FUNCTION_NAME_TOKEN;
            FLastSymbol := XPATH_FUNCTION_NAME_TOKEN;
          end;
        end else begin
          Symbol := XPATH_NAME_TEST_TOKEN;
          FLastSymbol := XPATH_NAME_TEST_TOKEN;
        end;
        Position := FPosition;

      end; {case ... else ...}

    end;
    SL_XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN_FOLLOWS: begin
      Symbol := XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN;
      // FLastSymbol := XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN;
      // FLastSymbol will never be evaluated, so we do not need to set it.
      Position := FPosition;
      Value := '';
      FDoubleSlashStatus:= SL_XPATH_DOUBLE_COLON_TOKEN_FOLLOWS;
    end;
    SL_XPATH_DOUBLE_COLON_TOKEN_FOLLOWS: begin
      Symbol := XPATH_DOUBLE_COLON_TOKEN;
      // FLastSymbol := XPATH_DOUBLE_COLON_TOKEN;
      // FLastSymbol will never be evaluated, so we do not need to set it.
      Position := FPosition;
      Value := '';
      FDoubleSlashStatus:= SL_XPATH_NODE_TYPE_NODE_TOKEN_FOLLOWS;
    end;
    SL_XPATH_NODE_TYPE_NODE_TOKEN_FOLLOWS: begin
      Symbol := XPATH_NODE_TYPE_NODE_TOKEN;
      // FLastSymbol := XPATH_NODE_TYPE_NODE_TOKEN;
      // FLastSymbol will never be evaluated, so we do not need to set it.
      Position := FPosition;
      Value := '';
      FDoubleSlashStatus:= SL_XPATH_LEFT_PARENTHESIS_FOLLOWS;
    end;
    SL_XPATH_LEFT_PARENTHESIS_FOLLOWS: begin
      Symbol := XPATH_LEFT_PARENTHESIS_TOKEN;
      // FLastSymbol := XPATH_LEFT_PARENTHESIS_TOKEN;
      // FLastSymbol will never be evaluated, so we do not need to set it.
      Position := FPosition;
      Value := '';
      FDoubleSlashStatus:= SL_XPATH_RIGHT_PARENTHESIS_FOLLOWS;
    end;
    SL_XPATH_RIGHT_PARENTHESIS_FOLLOWS: begin
      Symbol := XPATH_RIGHT_PARENTHESIS_TOKEN;
      // FLastSymbol := XPATH_RIGHT_PARENTHESIS_TOKEN;
      // FLastSymbol will never be evaluated, so we do not need to set it.
      Position := FPosition;
      Value := '';
      FDoubleSlashStatus:= SL_XPATH_SLASH_OPERATOR_TOKEN_FOLLLOWS;
    end;
    SL_XPATH_SLASH_OPERATOR_TOKEN_FOLLLOWS: begin
      Symbol := XPATH_SLASH_OPERATOR_TOKEN;
      FLastSymbol := XPATH_SLASH_OPERATOR_TOKEN;
      Position := FPosition;
      Value := '';
      FDoubleSlashStatus:= SL_NO_DOUBLE_SLASH;
    end;
  end; {case FDoubleSlashStatus ...}
end;

procedure TDomXPathTokenizer.Reset;
begin
  FCacheIsActive:= False;
  FLastSymbol := XPATH_INVALID_TOKEN;  // Use XPATH_INVALID_TOKEN as a dummy value
  FPosition:= 0;
  FDoubleSlashStatus:= SL_NO_DOUBLE_SLASH;
end;

{ TDomXPathCustomResult }

constructor TDomXPathCustomResult.Create;
begin
  inherited Create(nil);
end;

function TDomXPathCustomResult.GetAxisType: TDomXPathAxisType;
begin
  Result := XPATH_FORWARD_AXIS;
end;

function TDomXPathCustomResult.Item(const Index: Integer): TDomNode;
begin
  Result := nil;
end;

function TDomXPathCustomResult.Length: Integer;
begin
  Result := 0;
end;

procedure TDomXPathCustomResult.SetAxisType(const Value: TDomXPathAxisType);
begin
  // By default do nothing.
end;

{ TDomXPathNodeSetResult }

constructor TDomXPathNodeSetResult.Create;
begin
  inherited Create;
  FAxisType := XPATH_FORWARD_AXIS;
  FList:= TList<TDomNode>.Create;
end;

destructor TDomXPathNodeSetResult.Destroy;
begin
  FList.Free;
  inherited;
end;

procedure TDomXPathNodeSetResult.Add(const Node: TDomNode);
begin
  if Node.NodeType = ntXPath_Namespace_Node then
    AddXPathNamespace((Node as TDomXPathNamespace).OwnerElement,
                      (Node as TDomXPathNamespace).NamespaceUri,
                      (Node as TDomXPathNamespace).Prefix)
  else FList.Add(Node);
end;

procedure TDomXPathNodeSetResult.AddSubtree(const Node: TDomNode);
// Adds 'node' and its subtree, excluding attributes.
var
  N: TDomNode;
  Iter: TDomNodeIterator;
  BufferList: TList<TDomNode>;
  I: Integer;
begin
  if AxisType = XPATH_FORWARD_AXIS then begin
    if Assigned(Node) then begin
      Iter := Node.RootDocument.CreateNodeIterator( Node,
                                                  [ ntElement_Node,
                                                    ntText_Node,
                                                    ntCDATA_Section_Node,
                                                    ntEntity_Reference_Node,
                                                    ntProcessing_Instruction_Node,
                                                    ntComment_Node,
                                                    ntDocument_Node ],
                                                  nil,
                                                  False );
      N := Iter.NextNode;
      while Assigned(N) do begin
        FList.Add(N);
        N := Iter.NextNode;
      end;
      Iter.Detach;
      Node.RootDocument.ClearInvalidNodeIterators;
    end;
  end else begin
    if Assigned(Node) then begin
      BufferList:= TList<TDomNode>.Create;
      try
        Iter := Node.RootDocument.CreateNodeIterator( Node,
                                                    [ ntElement_Node,
                                                      ntText_Node,
                                                      ntCDATA_Section_Node,
                                                      ntEntity_Reference_Node,
                                                      ntProcessing_Instruction_Node,
                                                      ntComment_Node,
                                                      ntDocument_Node ],
                                                    nil,
                                                    False );
        N := Iter.NextNode;
        while Assigned(N) do begin
          BufferList.Add(N);
          N := Iter.NextNode;
        end;
        Iter.Detach;
        Node.RootDocument.ClearInvalidNodeIterators;

        for I := Pred(BufferList.Count) downto 0 do
          FList.Add(BufferList[I]);

      finally
        BufferList.Free;
      end;
    end;
  end;
end;

{$IFDEF NEXTGEN}
procedure TDomXPathNodeSetResult.AddXPathNamespace(const AOwnerElement: TDomElement;
                                                   const ANamespaceUri,
                                                         APrefix: string);
{$ELSE !NEXTGEN}
procedure TDomXPathNodeSetResult.AddXPathNamespace(const AOwnerElement: TDomElement;
                                                   const ANamespaceUri,
                                                         APrefix: WideString);
{$ENDIF NEXTGEN}
begin
  FList.Add(CreateXPathNamespace(AOwnerElement, ANamespaceUri, APrefix));
end;

function TDomXPathNodeSetResult.AsBoolean: Boolean;
begin
  Result := Length > 0;
end;

function TDomXPathNodeSetResult.AsNumber: Double;
begin
  Result := XPathWideStringToNumber(AsWideString);
end;

{$IFDEF NEXTGEN}
function TDomXPathNodeSetResult.AsWideString: string;
{$ELSE !NEXTGEN}
function TDomXPathNodeSetResult.AsWideString: WideString;
{$ENDIF NEXTGEN}
begin
  if Length = 0 then begin
    Result := ''
  end else if AxisType = XPATH_FORWARD_AXIS then begin
    Result := Item(0).XPathStringValue;
  end else Result := Item(Length).XPathStringValue;
end;

{$IFDEF NEXTGEN}
function TDomXPathNodeSetResult.CreateXPathNamespace(const AOwnerElement: TDomElement;
                                                     const ANamespaceUri,
                                                           APrefix: string): TDomXPathNamespace;
{$ELSE !NEXTGEN}
function TDomXPathNodeSetResult.CreateXPathNamespace(const AOwnerElement: TDomElement;
                                                     const ANamespaceUri,
                                                           APrefix: WideString): TDomXPathNamespace;
{$ENDIF NEXTGEN}
begin
  Result := TDomXPathNamespace.Create(Self, AOwnerElement, ANamespaceUri, APrefix);
end;

procedure TDomXPathNodeSetResult.Clear;
{$IFNDEF AUTOREFCOUNT}
var
  I: Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  // Free all XPath Namespace nodes:
  for I := 0 to Pred(FList.Count) do
    if TDomNode(FList[I]).NodeType = ntXPath_Namespace_Node then
      TDomNode(FList[I]).Free;
{$ENDIF !AUTOREFCOUNT}
  FList.Clear;
end;

procedure TDomXPathNodeSetResult.Delete(const Index: Integer);
begin
  // If the node is an XPath Namespace node then free it:
{$IFNDEF AUTOREFCOUNT}
  if TDomNode(FList[Index]).NodeType = ntXPath_Namespace_Node then
    TDomNode(FList[Index]).Free;
{$ENDIF !AUTOREFCOUNT}
  FList.Delete(Index);
end;

function TDomXPathNodeSetResult.GetAxisType: TDomXPathAxisType;
begin
  Result := FAxisType;
end;

procedure TDomXPathNodeSetResult.Insert(const Index: Integer;
                                        const Node: TDomNode);
begin
  if Node.NodeType = ntXPath_Namespace_Node then
    FList.Insert(Index, CreateXPathNamespace((Node as TDomXPathNamespace).OwnerElement,
                                             (Node as TDomXPathNamespace).NamespaceUri,
                                             (Node as TDomXPathNamespace).Prefix))
  else FList.Insert(Index, Node);
end;

{$IFDEF CLR}

function TDomXPathNodeSetResult.Item(const Index: Integer): TDomNode;
begin
  if (Index < 0) or (Index >= FList.Count)
    then Result := nil
    else Result := TDomNode(FList[Index]);
end;

{$ELSE}

function TDomXPathNodeSetResult.Item(const Index: Integer): TDomNode;
begin
  if (Index < 0) or (Index >= FList.Count)
    then Result := nil
    else Result := TDomNode(FList.List[Index]);
end;

{$ENDIF}

function TDomXPathNodeSetResult.Length: Integer;
begin
  Result := FList.Count;
end;

procedure TDomXPathNodeSetResult.Merge(const NodeSet: TDomXPathNodeSetResult);
// Merges two sorted TDomXPathNodeSetResult objects.
var
  I, X, Y: Integer;
  DocPos: TDomDocumentPosition;
  EquivalentItems: TList<TDomNode>;
begin
  if nodeSet = Self then Exit;
  nodeSet.AxisType := AxisType;
  X:= 0;
  Y:= 0;
  EquivalentItems:= TList<TDomNode>.Create;
  try

    if AxisType = XPATH_FORWARD_AXIS then begin
      while (X < Length) and (Y < nodeSet.Length) do begin
        DocPos:= Item(X).CompareDocumentPosition(nodeSet.Item(Y));
        if (Document_Position_Same_Node in DocPos) then begin
          Inc(Y);
        end else if (Document_Position_Equivalent in DocPos) then begin
          EquivalentItems.Add(nodeSet.Item(Y));
          Inc(Y);
        end else if (Document_Position_Following in DocPos) then begin
          Inc(X);
          for I := Pred(EquivalentItems.Count) downto 0 do
            if (Document_Position_Same_Node in Item(X).CompareDocumentPosition(TDomNode(EquivalentItems[I])))
              then EquivalentItems.Delete(I);
        end else if (Document_Position_Disconnected in DocPos) then begin
          for I := 0 to Pred(EquivalentItems.Count) do begin
            Insert(X, TDomNode(EquivalentItems[I]));
            EquivalentItems.Delete(I);
            Inc(X);
          end;
          Inc(X);
        end else begin
          for I := 0 to Pred(EquivalentItems.Count) do begin
            Insert(X, TDomNode(EquivalentItems[I]));
            EquivalentItems.Delete(I);
            Inc(X);
          end;
          Insert(X,nodeSet.Item(Y));
          Inc(X);
          Inc(Y);
        end;
      end;
    end else begin
      while (X < Length) and (Y < nodeSet.Length) do begin
        DocPos:= Item(X).CompareDocumentPosition(nodeSet.Item(Y));
        if (Document_Position_Same_Node in DocPos) then begin
          Inc(Y);
        end else if (Document_Position_Equivalent in DocPos) then begin
          EquivalentItems.Add(nodeSet.Item(Y));
          Inc(Y);
        end else if (Document_Position_Preceding in DocPos) then begin
          Inc(X);
          for I := Pred(EquivalentItems.Count) downto 0 do
            if (Document_Position_Same_Node in Item(X).CompareDocumentPosition(TDomNode(EquivalentItems[I])))
              then EquivalentItems.Delete(I);
        end else if (Document_Position_Disconnected in DocPos) then begin
          for I := 0 to Pred(EquivalentItems.Count) do begin
            Insert(X, TDomNode(EquivalentItems[I]));
            EquivalentItems.Delete(I);
            Inc(X);
          end;
          Inc(X);
        end else begin
          for I := 0 to Pred(EquivalentItems.Count) do begin
            Insert(X, TDomNode(EquivalentItems[I]));
            EquivalentItems.Delete(I);
            Inc(X);
          end;
          Insert(X, NodeSet.Item(Y));
          Inc(X);
          Inc(Y);
        end;
      end;
    end;

    Inc(X);
    while (EquivalentItems.Count > 0) and (X < Length) do begin
      if not (Document_Position_Equivalent in Item(X).CompareDocumentPosition(TDomNode(EquivalentItems[0]))) then begin
        for I := 0 to Pred(EquivalentItems.Count) do begin
          Insert(X, TDomNode(EquivalentItems[I]));
          EquivalentItems.Delete(I);
        end;
      end;
      for I := Pred(EquivalentItems.Count) downto 0 do
        if (Document_Position_Same_Node in Item(X).CompareDocumentPosition(TDomNode(EquivalentItems[I])))
          then EquivalentItems.Delete(I);
      Inc(X);
    end;

    for I := 0 to Pred(EquivalentItems.Count) do
      Add(TDomNode(EquivalentItems[I]));

    if Y < nodeSet.Length then
      for I := Y to Pred(nodeSet.Length) do
        Add(nodeSet.Item(I));

  finally
    EquivalentItems.Free;
  end;
end;

function TDomXPathNodeSetResult.ResultType: TDomXPathResultType;
begin
  Result := XPATH_NODE_SET_TYPE;
end;

{$IFDEF CLR}

procedure TDomXPathNodeSetResult.SetAxisType(const Value: TDomXPathAxisType);
var
  Index1, Index2, I: Integer;
begin
  if FAxisType <> Value then begin
    FAxisType := Value;
    I := Pred(FList.Count);
    if I >= 0 then begin
      for Index1 := 0 to ( I shr 1 ) do begin
        Index2 := I - Index1;
        FList.Exchange(Index1, Index2);
      end;
    end;
  end;
end;

{$ELSE}

procedure TDomXPathNodeSetResult.SetAxisType(const Value: TDomXPathAxisType);
var
  Item: Pointer;
  Index1, Index2, J: Integer;
begin
  if FAxisType <> Value then begin
    FAxisType := Value;
    J := Pred(FList.Count);
    if J >= 0 then begin
      for Index1 := 0 to ( J shr 1 ) do begin
        Index2 := J - Index1;
        Item := FList.List[Index1];
        FList.List[Index1] := FList.List[Index2];
        FList.List[Index2] := Item;
        // Remark: FList.Exchange(Index1, Index2) could have been used here
        //         instead, but re-implementing the swaping is faster, because
        //         parameter tests are avoided.
      end;
    end;
  end;
end;

{$ENDIF}

procedure TDomXPathNodeSetResult.Assign(Source: TPersistent);
var
  I: Integer;
begin
  if Source is TDomXPathNodeSetResult then begin
    if Source = Self then Exit;
    Clear;
    AxisType := TDomXPathNodeSetResult(Source).AxisType;
    for I := 0 to Pred(TDomXPathNodeSetResult(Source).Length) do
      Add(TDomXPathNodeSetResult(Source).Item(I));
  end else if Source is TXPathExpression then begin
    if TXPathExpression(Source).FXPathResult = Self then Exit;
    Clear;
    AxisType := TXPathExpression(Source).ResultAxisType;
    for I := 0 to Pred(TXPathExpression(Source).ResultLength) do
      Add(TXPathExpression(Source).ResultNode(I));
  end else inherited Assign(Source);
end;

(*
function CompareNodePosForwardAxis(Item1, Item2: {$IFDEF CLR}TObject{$ELSE}Pointer{$ENDIF}): Integer;
var
  DocPos: TDomDocumentPosition;
begin
  DocPos := TDomNode(Item1).CompareDocumentPosition(TDomNode(Item2));
  if Document_Position_Following in DocPos then
    Result := -1
  else if Document_Position_Preceding in DocPos then
    Result := 1
  else
    Result := 0;
end;

function CompareNodePosReverseAxis(Item1, Item2: {$IFDEF CLR}TObject{$ELSE}Pointer{$ENDIF}): Integer;
var
  DocPos: TDomDocumentPosition;
begin
  DocPos := TDomNode(Item1).CompareDocumentPosition(TDomNode(Item2));
  if Document_Position_Following in DocPos then
    Result := 1
  else if Document_Position_Preceding in DocPos then
    Result := -1
  else
    Result := 0;
end;
*)


function CompareNodePosForwardAxis(const Item1, Item2: TDomNode): Integer;
var
  DocPos: TDomDocumentPosition;
begin
  DocPos := TDomNode(Item1).CompareDocumentPosition(TDomNode(Item2));
  if Document_Position_Following in DocPos then
    Result := -1
  else if Document_Position_Preceding in DocPos then
    Result := 1
  else
    Result := 0;
end;

function CompareNodePosReverseAxis(const Item1, Item2: TDomNode): Integer;
var
  DocPos: TDomDocumentPosition;
begin
  DocPos := TDomNode(Item1).CompareDocumentPosition(TDomNode(Item2));
  if Document_Position_Following in DocPos then
    Result := 1
  else if Document_Position_Preceding in DocPos then
    Result := -1
  else
    Result := 0;
end;



procedure TDomXPathNodeSetResult.Sort;
var
  CmpFor: IComparer<TDomNode>;
  CmpBck: IComparer<TDomNode>;
begin
  CmpFor := TDelegatedComparer<TDomNode>.Create(CompareNodePosForwardAxis);
  CmpBck := TDelegatedComparer<TDomNode>.Create(CompareNodePosReverseAxis);
  if AxisType = XPATH_FORWARD_AXIS then
    //FList.Sort(CompareNodePosForwardAxis)
    FList.Sort(CmpFor)
  else
    //FList.Sort(CompareNodePosReverseAxis);
    FList.Sort(CmpBck);
end;

{ TDomXPathBooleanResult }

constructor TDomXPathBooleanResult.Create(const ABooleanValue: Boolean);
begin
  inherited Create;
  FBooleanValue := ABooleanValue;
end;

function TDomXPathBooleanResult.AsBoolean: Boolean;
begin
  Result := FBooleanValue;
end;

function TDomXPathBooleanResult.AsNumber: Double;
begin
  if AsBoolean
    then Result := 1
    else Result := 0;
end;

{$IFDEF NEXTGEN}
function TDomXPathBooleanResult.AsWideString: string;
{$ELSE !NEXTGEN}
function TDomXPathBooleanResult.AsWideString: WideString;
{$ENDIF NEXTGEN}
begin
  if AsBoolean
    then Result := 'true'
    else Result := 'false';
end;

function TDomXPathBooleanResult.ResultType: TDomXPathResultType;
begin
  Result := XPATH_BOOLEAN_TYPE;
end;

{ TDomXPathNumberResult }

constructor TDomXPathNumberResult.Create(const ANumberValue: Double);
begin
  inherited Create;
  FNumberValue := ANumberValue;
end;

function TDomXPathNumberResult.AsBoolean: Boolean;
begin
  Result := not( (AsNumber = 0) or IsNaN(AsNumber) );
end;

function TDomXPathNumberResult.AsNumber: Double;
begin
  Result := FNumberValue;
end;

{$IFDEF NEXTGEN}
function TDomXPathNumberResult.AsWideString: string;
{$ELSE !NEXTGEN}
function TDomXPathNumberResult.AsWideString: WideString;
{$ENDIF NEXTGEN}
begin
  if IsNaN(AsNumber) then begin
    Result := 'NaN';
  end else if IsInfinite(AsNumber) then begin
    if Sign(AsNumber) = 1
      then Result := 'Infinity'
      else Result := '-Infinity';
  end else Result := FloatToStr(AsNumber);
end;

function TDomXPathNumberResult.ResultType: TDomXPathResultType;
begin
  Result := XPATH_NUMBER_TYPE;
end;

{ TDomXPathStringResult }

{$IFDEF NEXTGEN}
constructor TDomXPathStringResult.Create(const AStringValue: string);
{$ELSE !NEXTGEN}
constructor TDomXPathStringResult.Create(const AStringValue: WideString);
{$ENDIF NEXTGEN}
begin
  inherited Create;
  FStringValue := AStringValue;
end;

function TDomXPathStringResult.AsBoolean: Boolean;
begin
  Result := {$IFDEF CLR}Borland.Delphi.{$ENDIF}System.Length(AsWideString) > 0;
end;

function TDomXPathStringResult.AsNumber: Double;
begin
  Result := XPathWideStringToNumber(AsWideString);
end;

{$IFDEF NEXTGEN}
function TDomXPathStringResult.AsWideString: string;
{$ELSE !NEXTGEN}
function TDomXPathStringResult.AsWideString: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FStringValue;
end;

function TDomXPathStringResult.ResultType: TDomXPathResultType;
begin
  Result := XPATH_STRING_TYPE;
end;

{ TDomXPathSyntaxTree }

constructor TDomXPathSyntaxTree.Create(AOwner: TXPathExpression);
begin
  inherited Create(nil);
  FOwnerXPathExpression := AOwner;
end;

procedure TDomXPathSyntaxTree.Clear;
begin
  inherited;
  FRootExpr := nil; // Remark: FRootExpr was freed in the inherited Clear procedure.
end;

{$IFDEF NEXTGEN}
function TDomXPathSyntaxTree.CreateSyntaxNode(const Symbol: TDomXPathTokenType;
                                              const Value: string): TDomXPathSyntaxNode;
{$ELSE !NEXTGEN}
function TDomXPathSyntaxTree.CreateSyntaxNode(const Symbol: TDomXPathTokenType;
                                              const Value: WideString): TDomXPathSyntaxNode;
{$ENDIF NEXTGEN}
begin
  case Symbol of
    XPATH_LEFT_PARENTHESIS_TOKEN:
      Result := TDomXPathLeftParenthesis.Create(Self, Value);
    XPATH_RIGHT_PARENTHESIS_TOKEN:
      Result := TDomXPathRightParenthesis.Create(Self, Value);
    XPATH_LEFT_SQUARE_BRACKET_TOKEN:
      Result := TDomXPathLeftSquareBracket.Create(Self, Value);
    XPATH_RIGHT_SQUARE_BRACKET_TOKEN:
      Result := TDomXPathRightSquareBracket.Create(Self, Value);
    XPATH_SINGLE_DOT_TOKEN:
      Result := TDomXPathSingleDot.Create(Self, Value);
    XPATH_DOUBLE_DOT_TOKEN:
      Result := TDomXPathDoubleDot.Create(Self, Value);
    XPATH_COMMERCIAL_AT_TOKEN:
      Result := TDomXPathCommercialAt.Create(Self, Value);
    XPATH_COMMA_TOKEN:
      Result := TDomXPathComma.Create(Self, Value);
    XPATH_DOUBLE_COLON_TOKEN:
      Result := TDomXPathDoubleColon.Create(Self, Value);
    XPATH_NAME_TEST_TOKEN:
      Result := TDomXPathNameTest.Create(Self, Value);
    XPATH_NODE_TYPE_COMMENT_TOKEN:
      Result := TDomXPathNodeTypeComment.Create(Self, Value);
    XPATH_NODE_TYPE_TEXT_TOKEN:
      Result := TDomXPathNodeTypeText.Create(Self, Value);
    XPATH_NODE_TYPE_PI_TOKEN:
      Result := TDomXPathNodeTypePI.Create(Self, Value);
    XPATH_NODE_TYPE_NODE_TOKEN:
      Result := TDomXPathNodeTypeNode.Create(Self, Value);
    XPATH_AND_OPERATOR_TOKEN:
      Result := TDomXPathAndOperator.Create(Self, Value);
    XPATH_OR_OPERATOR_TOKEN:
      Result := TDomXPathOrOperator.Create(Self, Value);
    XPATH_MOD_OPERATOR_TOKEN:
      Result := TDomXPathModOperator.Create(Self, Value);
    XPATH_DIV_OPERATOR_TOKEN:
      Result := TDomXPathDivOperator.Create(Self, Value);
    XPATH_MULTIPLY_OPERATOR_TOKEN:
      Result := TDomXPathMultiplyOperator.Create(Self, Value);
    XPATH_SLASH_OPERATOR_TOKEN:
      Result := TDomXPathSlashOperator.Create(Self, Value);
    XPATH_SHEFFER_STROKE_OPERATOR_TOKEN:
      Result := TDomXPathShefferStrokeOperator.Create(Self, Value);
    XPATH_PLUS_OPERATOR_TOKEN:
      Result := TDomXPathPlusOperator.Create(Self, Value);
    XPATH_MINUS_OPERATOR_TOKEN:
      Result := TDomXPathMinusOperator.Create(Self, Value);
    XPATH_IS_EQUAL_OPERATOR_TOKEN:
      Result := TDomXPathIsEqualOperator.Create(Self, Value);
    XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN:
      Result := TDomXPathIsNotEqualOperator.Create(Self, Value);
    XPATH_LESS_THAN_OPERATOR_TOKEN:
      Result := TDomXPathLessThanOperator.Create(Self, Value);
    XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN:
      Result := TDomXPathLessThanOrEqualOperator.Create(Self, Value);
    XPATH_GREATER_THAN_OPERATOR_TOKEN:
      Result := TDomXPathGreaterThanOperator.Create(Self, Value);
    XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN:
      Result := TDomXPathGreaterThanOrEqualOperator.Create(Self, Value);
    XPATH_FUNCTION_NAME_TOKEN:
      Result := TDomXPathFunctionName.Create(Self, Value);
    XPATH_AXIS_NAME_ANCESTOR_TOKEN:
      Result := TDomXPathAxisNameAncestor.Create(Self, Value);
    XPATH_AXIS_NAME_ANCESTOR_OR_SELF_TOKEN:
      Result := TDomXPathAxisNameAncestorOrSelf.Create(Self, Value);
    XPATH_AXIS_NAME_ATTRIBUTE_TOKEN:
      Result := TDomXPathAxisNameAttribute.Create(Self, Value);
    XPATH_AXIS_NAME_CHILD_TOKEN:
      Result := TDomXPathAxisNameChild.Create(Self, Value);
    XPATH_AXIS_NAME_DESCENDANT_TOKEN:
      Result := TDomXPathAxisNameDescendant.Create(Self, Value);
    XPATH_AXIS_NAME_DESCENDANT_OR_SELF_TOKEN:
      Result := TDomXPathAxisNameDescendantOrSelf.Create(Self, Value);
    XPATH_AXIS_NAME_FOLLOWING_TOKEN:
      Result := TDomXPathAxisNameFollowing.Create(Self, Value);
    XPATH_AXIS_NAME_FOLLOWING_SIBLING_TOKEN:
      Result := TDomXPathAxisNameFollowingSibling.Create(Self, Value);
    XPATH_AXIS_NAME_NAMESPACE_TOKEN:
      Result := TDomXPathAxisNameNamespace.Create(Self, Value);
    XPATH_AXIS_NAME_PARENT_TOKEN:
      Result := TDomXPathAxisNameParent.Create(Self, Value);
    XPATH_AXIS_NAME_PRECEDING_TOKEN:
      Result := TDomXPathAxisNamePreceding.Create(Self, Value);
    XPATH_AXIS_NAME_PRECEDING_SIBLING_TOKEN:
      Result := TDomXPathAxisNamePrecedingSibling.Create(Self, Value);
    XPATH_AXIS_NAME_SELF_TOKEN:
      Result := TDomXPathAxisNameSelf.Create(Self, Value);
    XPATH_LITERAL_TOKEN:
      Result := TDomXPathLiteral.Create(Self, Value);
    XPATH_NUMBER_TOKEN:
      Result := TDomXPathNumber.Create(Self, Value);
    XPATH_VARIABLE_REFERENCE_TOKEN:
      Result := TDomXPathVariableReference.Create(Self, Value);
  else
    Result := nil;
  end;
end;

function TDomXPathSyntaxTree.Evaluate: TDomXPathCustomResult;
begin
  if Assigned(ContextNode) then
    if not (ContextNode.NodeType in [ ntElement_Node,
                                      ntAttribute_Node,
                                      ntText_Node,
                                      ntProcessing_Instruction_Node,
                                      ntComment_Node,
                                      ntDocument_Node,
                                      ntXPath_Namespace_Node ] ) then
        raise ENot_Supported_Err.Create('Not supported error.');
  if not Assigned(FRootExpr) then
    raise EXPath_Invalid_Expression_Err.Create('No valid XPath expression prepared.');
  Result := FRootExpr.Evaluate(ContextNode, 1, 1);
end;

function TDomXPathSyntaxTree.GetIsPrepared: Boolean;
begin
  Result := Assigned(FRootExpr);
end;

{$IFDEF NEXTGEN}
function TDomXPathSyntaxTree.Prepare(const Expression: string): Boolean;
{$ELSE !NEXTGEN}
function TDomXPathSyntaxTree.Prepare(const Expression: WideString): Boolean;
{$ENDIF NEXTGEN}
var
  Position: Integer;
  Stack: TDomXPathSyntaxNodeStack;
  Symbol: TDomXPathTokenType;
  Tokenizer: TDomXPathTokenizer;
{$IFDEF NEXTGEN}
  Value: string;
{$ELSE !NEXTGEN}
  Value: WideString;
{$ENDIF NEXTGEN}
  AxisNode: TDomXPathSyntaxNode;
  LastSyntaxNode: TDomXPathSyntaxNode;
  NewSyntaxNode: TDomXPathSyntaxNode;
  NodeTestNode: TDomXPathSyntaxNode;
  FunctionCallNode: TDomXPathFunctionCall;
  NodeTypePI: TDomXPathSyntaxNode;
  PILiteral: TDomXPathSyntaxNode;
begin
  Clear; // Free the root expression, if any, and all its children.
  Tokenizer := TDomXPathTokenizer.Create(Expression,'1.0');
  try
    Stack:= TDomXPathSyntaxNodeStack.Create;
    try
      repeat
        Tokenizer.Read(Symbol, Value, position);
        case Symbol of
        XPATH_END_OF_TEXT_TOKEN, XPATH_INVALID_TOKEN: Break;
        else
          LastSyntaxNode:= CreateSyntaxNode(Symbol, Value);
          repeat
            // -- if LastSyntaxNode is TDomXPathAbsoluteLocationPath then ... --
            // (TDomXPathAbsoluteLocationPath will not appear in this loop,
            // so we leave it out here.)
            if LastSyntaxNode is TDomXPathAndExpr then begin
              if Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MULTIPLY_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_DIV_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MOD_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_PLUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MINUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LESS_THAN_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_GREATER_THAN_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_IS_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_AND_OPERATOR_TOKEN)
              then begin
                // Operator of higher precedence is following, so we postpone building the expression.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              if (Stack.Peek(0) is TDomXPathOrOperator) and
                 ( (Stack.Peek(1) is TDomXPathOrExpr) )
              then begin
                // XPath 1.0, prod. [21]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathOrExpr.Create(Self, ''); // Create OrExpr.
                NewSyntaxNode.Left:= Stack.Pop;                   // Append OrExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;             // Append AndExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                // XPath 1.0, prod. [21]:
                NewSyntaxNode:= TDomXPathOrExpr.Create(Self, ''); // Create OrExpr.
                NewSyntaxNode.Left:= LastSyntaxNode;              // Append AndExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if (LastSyntaxNode is TDomXPathAndOperator) or
                        (LastSyntaxNode is TDomXPathComma) or
                        (LastSyntaxNode is TDomXPathCommercialAt) or
                        (LastSyntaxNode is TDomXPathCustomAxisName)
            then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if (LastSyntaxNode is TDomXPathDivExpr) or
                        (LastSyntaxNode is TDomXPathModExpr) or
                        (LastSyntaxNode is TDomXPathMultiplyExpr)
            then begin
              if Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MULTIPLY_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_DIV_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MOD_OPERATOR_TOKEN)
              then begin
                // Operator of higher precedence is following, so we postpone building the expression.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              if (Stack.Peek(0) is TDomXPathPlusOperator) and
                 ( (Stack.Peek(1) is TDomXPathPlusExpr) or
                   (Stack.Peek(1) is TDomXPathMinusExpr) )
              then begin
                // XPath 1.0, prod. [25]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathPlusExpr.Create(Self, ''); // Create PlusExpr.
                NewSyntaxNode.Left:= Stack.Pop;                     // Append AdditiveExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;               // Append MultiplicativeExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else if (Stack.Peek(0) is TDomXPathMinusOperator) and
                 ( (Stack.Peek(1) is TDomXPathPlusExpr) or
                   (Stack.Peek(1) is TDomXPathMinusExpr) )
              then begin
                // XPath 1.0, prod. [25]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathMinusExpr.Create(Self, ''); // Create MinusExpr.
                NewSyntaxNode.Left:= Stack.Pop;                      // Append AdditiveExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                // Append MultiplicativeExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                // XPath 1.0, prod. [25]:
                NewSyntaxNode:= TDomXPathPlusExpr.Create(Self, ''); // Create PlusExpr.
                NewSyntaxNode.Left:= LastSyntaxNode;                // Append MultiplicativeExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if (LastSyntaxNode is TDomXPathDivOperator) or
                        (LastSyntaxNode is TDomXPathDoubleColon)
            then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if LastSyntaxNode is TDomXPathDoubleDot then begin
              // XPath 1.0, prod. [12]:
              LastSyntaxNode.Free;
              LastSyntaxNode:= TDomXPathStep.Create(Self, '');
              LastSyntaxNode.Left:= TDomXPathAxisNameParent.Create(Self, '');
              LastSyntaxNode.Left.Left:= TDomXPathNodeTest.Create(Self, '');
              LastSyntaxNode.Left.Left.Left:= TDomXPathNodeTypeNode.Create(Self, '');
            end else if LastSyntaxNode is TDomXPathExpr then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if LastSyntaxNode is TDomXPathFilterExpr then begin
              // XPath 1.0, prod. [19]:
              if Tokenizer.IsFollowing(XPATH_SLASH_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LEFT_SQUARE_BRACKET_TOKEN)
              then begin
                // A Slash or Predicate is following, so we postpone building the PathExpr.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              NewSyntaxNode:= TDomXPathPathExpr.Create(Self, ''); // Create PathExpr.
              NewSyntaxNode.Left:= LastSyntaxNode;                // Append FilterExpr.
              LastSyntaxNode:= NewSyntaxNode;
            end else if LastSyntaxNode is TDomXPathFunctionName then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if (LastSyntaxNode is TDomXPathGreaterThanExpr) or
                        (LastSyntaxNode is TDomXPathGreaterThanOrEqualExpr) or
                        (LastSyntaxNode is TDomXPathLessThanExpr) or
                        (LastSyntaxNode is TDomXPathLessThanOrEqualExpr)
            then begin
              if Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MULTIPLY_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_DIV_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MOD_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_PLUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MINUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LESS_THAN_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_GREATER_THAN_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN)
              then begin
                // Operator of higher precedence is following, so we postpone building the expression.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              if (Stack.Peek(0) is TDomXPathIsEqualOperator) and
                 ( (Stack.Peek(1) is TDomXPathIsEqualExpr) or
                   (Stack.Peek(1) is TDomXPathIsNotEqualExpr) )
              then begin
                // XPath 1.0, prod. [23]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathIsEqualExpr.Create(Self, ''); // Create IsEqualExpr.
                NewSyntaxNode.Left:= Stack.Pop;                        // Append EqualityExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                  // Append RelationalExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else if (Stack.Peek(0) is TDomXPathIsNotEqualOperator) and
                 ( (Stack.Peek(1) is TDomXPathIsEqualExpr) or
                   (Stack.Peek(1) is TDomXPathIsNotEqualExpr) )
              then begin
                // XPath 1.0, prod. [23]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathIsNotEqualExpr.Create(Self, ''); // Create IsNotEqualExpr.
                NewSyntaxNode.Left:= Stack.Pop;                           // Append EqualityExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                     // Append RelationalExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                // XPath 1.0, prod. [23]:
                NewSyntaxNode:= TDomXPathIsEqualExpr.Create(Self, ''); // Create IsEqualExpr.
                NewSyntaxNode.Left:= LastSyntaxNode;                   // Append RelationalExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if (LastSyntaxNode is TDomXPathGreaterThanOperator) or
                        (LastSyntaxNode is TDomXPathGreaterThanOrEqualOperator)
            then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if (LastSyntaxNode is TDomXPathIsEqualExpr) or
                        (LastSyntaxNode is TDomXPathIsNotEqualExpr)
            then begin
              if Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MULTIPLY_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_DIV_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MOD_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_PLUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MINUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LESS_THAN_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_GREATER_THAN_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_IS_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN)
              then begin
                // Operator of higher precedence is following, so we postpone building the expression.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              if (Stack.Peek(0) is TDomXPathAndOperator) and
                 ( (Stack.Peek(1) is TDomXPathAndExpr) )
              then begin
                // XPath 1.0, prod. [22]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathAndExpr.Create(Self, ''); // Create AndExpr.
                NewSyntaxNode.Left:= Stack.Pop;                    // Append AndExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;              // Append EqualityExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                // XPath 1.0, prod. [22]:
                NewSyntaxNode:= TDomXPathAndExpr.Create(Self, ''); // Create AndExpr.
                NewSyntaxNode.Left:= LastSyntaxNode;               // Append EqualityExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if (LastSyntaxNode is TDomXPathIsEqualOperator) or
                        (LastSyntaxNode is TDomXPathIsNotEqualOperator) or
                        (LastSyntaxNode is TDomXPathLeftParenthesis) or
                        (LastSyntaxNode is TDomXPathLeftSquareBracket) or
                        (LastSyntaxNode is TDomXPathLessThanOperator) or
                        (LastSyntaxNode is TDomXPathLessThanOrEqualOperator)
            then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if LastSyntaxNode is TDomXPathLiteral then begin
              if (Stack.Peek(0) is TDomXPathLeftParenthesis) and
                 (Stack.Peek(1) is TDomXPathNodeTypePI) and
                 Tokenizer.IsFollowing(XPATH_RIGHT_PARENTHESIS_TOKEN)
              then begin
                // Literal is part of a processing-instruction node test,
                // so we postpone building the expression.
                Stack.Push(LastSyntaxNode);
                Break;
              end else begin
                // XPath 1.0, prod. [15]:
                NewSyntaxNode:= TDomXPathPrimaryExpr.Create(Self, ''); // Create PrimaryExpr.
                NewSyntaxNode.Left:= LastSyntaxNode;                   // Append Literal.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if (LastSyntaxNode is TDomXPathMinusExpr) or
                        (LastSyntaxNode is TDomXPathPlusExpr)
            then begin
              if Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MULTIPLY_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_DIV_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MOD_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_PLUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MINUS_OPERATOR_TOKEN)
              then begin
                // Operator of higher precedence is following, so we postpone building the expression.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              if (Stack.Peek(0) is TDomXPathLessThanOperator) and
                 ( (Stack.Peek(1) is TDomXPathLessThanExpr) or
                   (Stack.Peek(1) is TDomXPathLessThanOrEqualExpr) or
                   (Stack.Peek(1) is TDomXPathGreaterThanExpr) or
                   (Stack.Peek(1) is TDomXPathGreaterThanOrEqualExpr) )
              then begin
                // XPath 1.0, prod. [24]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathLessThanExpr.Create(Self, ''); // Create LessThanExpr.
                NewSyntaxNode.Left:= Stack.Pop;                         // Append RelationalExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                   // Append AdditiveExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else if (Stack.Peek(0) is TDomXPathLessThanOrEqualOperator) and
                 ( (Stack.Peek(1) is TDomXPathLessThanExpr) or
                   (Stack.Peek(1) is TDomXPathLessThanOrEqualExpr) or
                   (Stack.Peek(1) is TDomXPathGreaterThanExpr) or
                   (Stack.Peek(1) is TDomXPathGreaterThanOrEqualExpr) )
              then begin
                // XPath 1.0, prod. [24]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathLessThanOrEqualExpr.Create(Self, ''); // Create LessThanOrEqualExpr.
                NewSyntaxNode.Left:= Stack.Pop;                                // Append RelationalExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                          // Append AdditiveExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else if (Stack.Peek(0) is TDomXPathGreaterThanOperator) and
                 ( (Stack.Peek(1) is TDomXPathLessThanExpr) or
                   (Stack.Peek(1) is TDomXPathLessThanOrEqualExpr) or
                   (Stack.Peek(1) is TDomXPathGreaterThanExpr) or
                   (Stack.Peek(1) is TDomXPathGreaterThanOrEqualExpr) )
              then begin
                // XPath 1.0, prod. [24]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathGreaterThanExpr.Create(Self, ''); // Create GreaterThanExpr.
                NewSyntaxNode.Left:= Stack.Pop;                            // Append RelationalExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                      // Append AdditiveExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else if (Stack.Peek(0) is TDomXPathGreaterThanOrEqualOperator) and
                 ( (Stack.Peek(1) is TDomXPathLessThanExpr) or
                   (Stack.Peek(1) is TDomXPathLessThanOrEqualExpr) or
                   (Stack.Peek(1) is TDomXPathGreaterThanExpr) or
                   (Stack.Peek(1) is TDomXPathGreaterThanOrEqualExpr) )
              then begin
                // XPath 1.0, prod. [24]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathGreaterThanOrEqualExpr.Create(Self, ''); // Create GreaterThanOrEqualExpr.
                NewSyntaxNode.Left:= Stack.Pop;                                   // Append RelationalExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                             // Append AdditiveExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                // XPath 1.0, prod. [24]:
                NewSyntaxNode:= TDomXPathLessThanExpr.Create(Self, ''); // Create LessThanExpr.
                NewSyntaxNode.Left:= LastSyntaxNode;                    // Append AdditiveExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if (LastSyntaxNode is TDomXPathMinusOperator) or
                        (LastSyntaxNode is TDomXPathModOperator) or
                        (LastSyntaxNode is TDomXPathMultiplyOperator)
            then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if LastSyntaxNode is TDomXPathNameTest then begin
              // XPath 1.0, prod. [7]:
              NewSyntaxNode:= TDomXPathNodeTest.Create(Self, '');  // Create NodeTest.
              NewSyntaxNode.Left:= LastSyntaxNode;                 // Append NameTest.
              LastSyntaxNode:= NewSyntaxNode;
            end else if LastSyntaxNode is TDomXPathNodeTest then begin
              // XPath 1.0, prod. [4]:
              if Tokenizer.IsFollowing(XPATH_LEFT_SQUARE_BRACKET_TOKEN) then begin
                // A Predicate is following, so we postpone building the Step.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              if Stack.Peek(0) is TDomXPathDoubleColon then begin
                if Stack.Peek(1) is TDomXPathCustomAxisName then begin
{$IFDEF AUTOREFCOUNT}
                  Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                  Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                  NewSyntaxNode:= Stack.Pop;
                  NewSyntaxNode.Left:= LastSyntaxNode;             // Append NodeTest to AxisName.
                  LastSyntaxNode:= TDomXPathStep.Create(Self, ''); // Create Step.
                  LastSyntaxNode.Left:= NewSyntaxNode;             // Append AxisName to Step.
                end else begin
                  // Malformed XPath Expression.  We are parsing it anyway ...
                  Stack.Push(LastSyntaxNode);
                  Break;
                end;
              end else if Stack.Peek(0) is TDomXPathCommercialAt then begin
                // XPath 1.0, prod. [13]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathAxisNameAttribute.Create(Self, '');
                NewSyntaxNode.Left:= LastSyntaxNode;             // Append NodeTest to AxisName.
                LastSyntaxNode:= TDomXPathStep.Create(Self, ''); // Create Step.
                LastSyntaxNode.Left:= NewSyntaxNode;             // Append AxisName to Step.
              end else begin
                // XPath 1.0, prod. [13]:
                NewSyntaxNode:= TDomXPathAxisNameChild.Create(Self, '');
                NewSyntaxNode.Left:= LastSyntaxNode;             // Append NodeTest to AxisName.
                LastSyntaxNode:= TDomXPathStep.Create(Self, ''); // Create Step.
                LastSyntaxNode.Left:= NewSyntaxNode;             // Append AxisName to Step.
              end;
            end else if (LastSyntaxNode is TDomXPathNodeTypeComment) or
                        (LastSyntaxNode is TDomXPathNodeTypeNode) or
                        (LastSyntaxNode is TDomXPathNodeTypePI) or
                        (LastSyntaxNode is TDomXPathNodeTypeText)
            then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if LastSyntaxNode is TDomXPathNumber then begin
              // XPath 1.0, prod. [15]:
              NewSyntaxNode:= TDomXPathPrimaryExpr.Create(Self, ''); // Create PrimaryExpr.
              NewSyntaxNode.Left:= LastSyntaxNode;                   // Append Number.
              LastSyntaxNode:= NewSyntaxNode;
            end else if LastSyntaxNode is TDomXPathOrExpr then begin
              if Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MULTIPLY_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_DIV_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MOD_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_PLUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_MINUS_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LESS_THAN_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_LESS_THAN_OR_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_GREATER_THAN_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_GREATER_THAN_OR_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_IS_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_IS_NOT_EQUAL_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_AND_OPERATOR_TOKEN) or
                 Tokenizer.IsFollowing(XPATH_OR_OPERATOR_TOKEN)
              then begin
                // Operator of higher precedence is following, so we postpone building the expression.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              // XPath 1.0, prod. [14]:
              NewSyntaxNode:= TDomXPathExpr.Create(Self, ''); // Create Expr.
              NewSyntaxNode.Left:= LastSyntaxNode;            // Append OrExpr.
              LastSyntaxNode:= NewSyntaxNode;
            end else if LastSyntaxNode is TDomXPathOrOperator then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if LastSyntaxNode is TDomXPathPathExpr then begin
              // XPath 1.0, prod. [18]:
              if Tokenizer.IsFollowing(XPATH_SLASH_OPERATOR_TOKEN) then begin
                // A Slash is following, so we postpone building the TDomXPathUnionExpr.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              if (Stack.Peek(0) is TDomXPathShefferStrokeOperator) and
                 (Stack.Peek(1) is TDomXPathUnionExpr)
              then begin
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathUnionExpr.Create(Self, ''); // Create UnionExpr.
                NewSyntaxNode.Left:= Stack.Pop;                      // Append UnionExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                // Append PathExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                NewSyntaxNode:= TDomXPathUnionExpr.Create(Self, ''); // Create UnionExpr.
                NewSyntaxNode.Left:= LastSyntaxNode;                 // Append PathExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if LastSyntaxNode is TDomXPathPlusOperator then begin
              Stack.Push(LastSyntaxNode);
              Break;
            end else if LastSyntaxNode is TDomXPathPredicate then begin
              if Stack.Peek(0) is TDomXPathFilterExpr then begin
                // XPath 1.0, prod. [20]:
                NewSyntaxNode:= TDomXPathFilterExpr.Create(Self, '');
                NewSyntaxNode.Left:= Stack.Pop;
                NewSyntaxNode.Right:= LastSyntaxNode;
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                // XPath 1.0, prod. [4]:
                if Tokenizer.IsFollowing(XPATH_LEFT_SQUARE_BRACKET_TOKEN) then begin
                  // Another Predicate is following, so we postpone building the Step.
                  Stack.Push(LastSyntaxNode);
                  Break;
                end;
                if Stack.Peek(0) is TDomXPathPredicate then begin
                  NewSyntaxNode:= Stack.Pop;
                  NewSyntaxNode.Right:= LastSyntaxNode;
                  LastSyntaxNode:= NewSyntaxNode;
                end else if Stack.Peek(0) is TDomXPathNodeTest then begin
                  if Stack.Peek(1) is TDomXPathDoubleColon then begin
                    if Stack.Peek(2) is TDomXPathCustomAxisName then begin
                      NodeTestNode:= Stack.Pop; // Pop the NodeTest from the stack.
{$IFDEF AUTOREFCOUNT}
                      Stack.Pop;                // Pop and delete the DoubleColon.
{$ELSE !AUTOREFCOUNT}
                      Stack.Pop.Free;           // Pop and delete the DoubleColon.
{$ENDIF AUTOREFCOUNT}
                      AxisNode:= Stack.Pop;     // Pop the AxisName from the stack.
                      AxisNode.Left:= NodeTestNode;                    // Append NodeTest to AxisName.
                      AxisNode.Right:= LastSyntaxNode;                 // Append Predicate to AxisName.
                      LastSyntaxNode:= TDomXPathStep.Create(Self, ''); // Create Step.
                      LastSyntaxNode.Left:= AxisNode;                  // Append AxisName to Step.
                    end else begin
                      // Malformed XPath Expression.  We are parsing it anyway ...
                      Stack.Push(LastSyntaxNode);
                      Break;
                    end;
                  end else if Stack.Peek(1) is TDomXPathCommercialAt then begin
                    // XPath 1.0, prod. [13]:
                    NodeTestNode:= Stack.Pop;                               // Pop the NodeTest from the stack.
{$IFDEF AUTOREFCOUNT}
                    Stack.Pop;                                              // Pop and delete the DoubleColon.
{$ELSE !AUTOREFCOUNT}
                    Stack.Pop.Free;                                         // Pop and delete the DoubleColon.
{$ENDIF AUTOREFCOUNT}
                    AxisNode:= TDomXPathAxisNameAttribute.Create(Self, ''); // Create attribute axis AxisName.
                    AxisNode.Left:= NodeTestNode;                           // Append NodeTest to AxisName.
                    AxisNode.Right:= LastSyntaxNode;                        // Append Predicate to AxisName.
                    LastSyntaxNode:= TDomXPathStep.Create(Self, '');        // Create Step.
                    LastSyntaxNode.Left:= AxisNode;                         // Append AxisName to Step.
                  end else begin
                    // XPath 1.0, prod. [13]:
                    NodeTestNode:= Stack.Pop;                            // Pop the NodeTest from the stack.
                    AxisNode:= TDomXPathAxisNameChild.Create(Self, '');  // Create child axis AxisName.
                    AxisNode.Left:= NodeTestNode;                        // Append NodeTest to AxisName.
                    AxisNode.Right:= LastSyntaxNode;                     // Append Predicate to AxisName.
                    LastSyntaxNode:= TDomXPathStep.Create(Self, '');     // Create Step.
                    LastSyntaxNode.Left:= AxisNode;                      // Append AxisName to Step.
                  end;
                end else begin
                  // Malformed XPath Expression.  We are parsing it anyway ...
                  Stack.Push(LastSyntaxNode);
                  Break;
                end;
              end;
            end else if LastSyntaxNode is TDomXPathPrimaryExpr then begin
              // XPath 1.0, prod. [20]:
              NewSyntaxNode:= TDomXPathFilterExpr.Create(Self, ''); // Create FilterExpr.
              NewSyntaxNode.Left:= LastSyntaxNode;                  // Append PrimaryExpr.
              LastSyntaxNode:= NewSyntaxNode;
            end else if LastSyntaxNode is TDomXPathRightParenthesis then begin
              // XPath 1.0, prod. [7]:
              if (Stack.Peek(0) is TDomXPathLeftParenthesis) and
                 ( (Stack.Peek(1) is TDomXPathNodeTypeComment) or
                   (Stack.Peek(1) is TDomXPathNodeTypeNode) or
                   (Stack.Peek(1) is TDomXPathNodeTypePI) or
                   (Stack.Peek(1) is TDomXPathNodeTypeText) )
              then begin
                LastSyntaxNode.Free;
                LastSyntaxNode:= TDomXPathNodeTest.Create(Self, '');
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                LastSyntaxNode.Left:= Stack.Pop;
              end else if (Stack.Peek(0) is TDomXPathLiteral) and
                          (Stack.Peek(1) is TDomXPathLeftParenthesis) and
                          (Stack.Peek(2) is TDomXPathNodeTypePI)
              then begin
                LastSyntaxNode.Free;
                LastSyntaxNode:= TDomXPathNodeTest.Create(Self, ''); // Create NodeTest
                PILiteral:= Stack.Pop;
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;                                           // Remove LeftParenthesist from stack.
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;                                      // Remove LeftParenthesist from stack.
{$ENDIF AUTOREFCOUNT}
                nodeTypePI:= Stack.Pop;
                nodeTypePI.Left:= PILiteral;                         // Append Literal to NodeTypePI
                LastSyntaxNode.Left:= nodeTypePI;                    // Append NodeTypePI to NodeTest
              end else if (Stack.Peek(0) is TDomXPathExpr) and
                          (Stack.Peek(1) is TDomXPathLeftParenthesis) and not
                          (Stack.Peek(2) is TDomXPathFunctionName)
              then begin
                LastSyntaxNode.Free;
                NewSyntaxNode:= TDomXPathPrimaryExpr.Create(Self, ''); // Create PrimaryExpr.
                NewSyntaxNode.Left:= Stack.Pop;                        // Append Expr.
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;                                           // Remove LeftParenthesist from stack.
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;                                      // Remove LeftParenthesist from stack.
{$ENDIF AUTOREFCOUNT}
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                // XPath 1.0, prod. [16]:
                functionCallNode:= TDomXPathFunctionCall.Create(Self, ''); // Create FunctionCall.
                while Stack.Peek(0) is TDomXPathExpr do begin
                  functionCallNode.Arguments.Insert(0, TDomXPathExpr(Stack.Pop)); // Add Expr as first argument to FunctionCall.
                  if Stack.Peek(0) is TDomXPathComma then begin
{$IFDEF AUTOREFCOUNT}
                    Stack.Pop                                      // Remove Comma from stack.
{$ELSE !AUTOREFCOUNT}
                    Stack.Pop.Free                                 // Remove Comma from stack.
{$ENDIF AUTOREFCOUNT}
                  end else if not (Stack.Peek(0) is TDomXPathLeftParenthesis) then begin
                    // Malformed XPath Expression.  We are parsing it anyway ...
                    Break;
                  end;
                end;
                if (Stack.Peek(0) is TDomXPathLeftParenthesis) and
                   (Stack.Peek(1) is TDomXPathFunctionName)
                then begin
                  // XPath 1.0, prod. [15]:
                  LastSyntaxNode.Free;
{$IFDEF AUTOREFCOUNT}
                  Stack.Pop;                                           // Remove LeftParenthesist from stack.
{$ELSE !AUTOREFCOUNT}
                  Stack.Pop.Free;                                      // Remove LeftParenthesist from stack.
{$ENDIF AUTOREFCOUNT}
                  functionCallNode.functionName := Stack.Peek(0).Value;  // Set function name on FunctionCallNode.
{$IFDEF AUTOREFCOUNT}
                  Stack.Pop;                                           // Remove FunctionName.
{$ELSE !AUTOREFCOUNT}
                  Stack.Pop.Free;                                      // Remove FunctionName.
{$ENDIF AUTOREFCOUNT}
                  NewSyntaxNode:= TDomXPathPrimaryExpr.Create(Self, ''); // Create PrimaryExpr.
                  NewSyntaxNode.Left:= functionCallNode;                 // Append FunctionCall.
                  LastSyntaxNode:= NewSyntaxNode;
                end else begin
                  // Malformed XPath Expression.  We are parsing it anyway ...
                  Stack.Push(functionCallNode);
                  Stack.Push(LastSyntaxNode);
                  Break;
                end;
              end;
            end else if LastSyntaxNode is TDomXPathRightSquareBracket then begin
              // XPath 1.0, prod. [8] and [9]:
              if (Stack.Peek(0) is TDomXPathExpr) and
                 (Stack.Peek(1) is TDomXPathLeftSquareBracket)
              then begin
                LastSyntaxNode.Free;
                LastSyntaxNode:= TDomXPathPredicate.Create(Self, ''); // Create Predicate.
                LastSyntaxNode.Left:= Stack.Pop;                      // Append Expr.
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;                                            // Remove LeftSquareBracket from stack.
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;                                       // Remove LeftSquareBracket from stack.
{$ENDIF AUTOREFCOUNT}
              end else begin
                // Malformed XPath Expression.  We are parsing it anyway ...
                Stack.Push(LastSyntaxNode);
                Break;
              end;
            end else if LastSyntaxNode is TDomXPathShefferStrokeOperator then begin
              if Stack.Peek(0) is TDomXPathPathExpr then begin
                NewSyntaxNode:= TDomXPathUnionExpr.Create(Self, ''); // Create UnionExpr.
                NewSyntaxNode.Left:= Stack.Pop;                      // Append PathExpr from stack.
                Stack.Push(NewSyntaxNode);                           // Push the UnionExpr on the stack.
                Stack.Push(LastSyntaxNode);                          // Push the ShefferStrokeOperator on the stack.
                Break;
              end else begin
                // Malformed XPath Expression.  We are parsing it anyway ...
                Stack.Push(LastSyntaxNode);
                Break;
              end;
            end else if LastSyntaxNode is TDomXPathSingleDot then begin
              // XPath 1.0, prod. [12]:
              LastSyntaxNode.Free;
              LastSyntaxNode:= TDomXPathStep.Create(Self, '');                        // Create Step.
              LastSyntaxNode.Left:= TDomXPathAxisNameSelf.Create(Self, '');           // Create and append AxisName to Step.
              LastSyntaxNode.Left.Left:= TDomXPathNodeTest.Create(Self, '');          // Create and append NodeTest to AxisName.
              LastSyntaxNode.Left.Left.Left:= TDomXPathNodeTypeNode.Create(Self, ''); // Create and append NodeType to NodeTest.
            end else if LastSyntaxNode is TDomXPathSlashOperator then begin
              // XPath 1.0, prod. [2]:
              if ( (not Assigned(Stack.Peek(0))) or
                   (Stack.Peek(0) is TDomXPathShefferStrokeOperator) ) and
                 ( Tokenizer.IsFollowing(XPATH_END_OF_TEXT_TOKEN) or
                   Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN)    )
              then begin
                LastSyntaxNode.Free;
                LastSyntaxNode:= TDomXPathPathExpr.Create(Self, '');                  // Create PathExpr.
                LastSyntaxNode.Left:= TDomXPathAbsoluteLocationPath.Create(Self, ''); // Create and append AbsolutLocationPath.
              end else begin
                Stack.Push(LastSyntaxNode);
                Break;
              end;
            end else if LastSyntaxNode is TDomXPathStep then begin
              // XPath 1.0, prod. [3] and [19]:
              if Stack.Peek(0) is TDomXPathSlashOperator then begin
                if Stack.Peek(1) is TDomXPathFilterExpr then begin
{$IFDEF AUTOREFCOUNT}
                  Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                  Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                  NewSyntaxNode:= TDomXPathPathExpr.Create(Self, ''); // Create PathExpr.
                  NewSyntaxNode.Left:= Stack.Pop;                     // Append FilterExpr to PathExpr.
                  NewSyntaxNode.Right:= LastSyntaxNode;               // Append Step to PathExpr.
                  LastSyntaxNode:= NewSyntaxNode;
                end else if Stack.Peek(1) is TDomXPathPathExpr then begin
{$IFDEF AUTOREFCOUNT}
                  Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                  Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                  if TDomXPathPathExpr(Stack.Peek(0)).AddStep(TDomXPathStep(LastSyntaxNode)) then begin
                    LastSyntaxNode:= Stack.Pop;
                  end else begin
                    // Malformed XPath Expression.  We are parsing it anyway ...
                    Stack.Push(LastSyntaxNode);
                    Break;
                  end;
                end else if (not Assigned(Stack.Peek(1)) ) or
                            (Stack.Peek(1) is TDomXPathShefferStrokeOperator) or
                            (Stack.Peek(1) is TDomXPathLeftParenthesis)
                then begin
                  // XPath 1.0, prod. [2]:
{$IFDEF AUTOREFCOUNT}
                  Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                  Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                  NewSyntaxNode:= TDomXPathPathExpr.Create(Self, '');                  // Create PathExpr.
                  NewSyntaxNode.Left:= TDomXPathAbsoluteLocationPath.Create(Self, ''); // Create and append AbsolutLocationPath.
                  NewSyntaxNode.Right:= LastSyntaxNode;                                // Append Step.
                  LastSyntaxNode:= NewSyntaxNode;
                end else begin
                  // Malformed XPath Expression.  We are parsing it anyway ...
                  Stack.Push(LastSyntaxNode);
                  Break;
                end;
              end else begin
                NewSyntaxNode:= TDomXPathPathExpr.Create(Self, ''); // Create PathExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;               // Append Step to PathExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if LastSyntaxNode is TDomXPathUnaryExpr then begin
              if Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN) then begin
                // Operator of higher precedence is following, so we postpone building the expression.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              if (Stack.Peek(0) is TDomXPathMinusOperator) and not (
                   (Stack.Peek(1) is TDomXPathPlusExpr) or
                   (Stack.Peek(1) is TDomXPathMinusExpr) or
                   (Stack.Peek(1) is TDomXPathMultiplyExpr) or
                   (Stack.Peek(1) is TDomXPathDivExpr) or
                   (Stack.Peek(1) is TDomXPathModExpr) or
                   (Stack.Peek(1) is TDomXPathUnaryExpr) or
                   (Stack.Peek(1) is TDomXPathUnionExpr)  )
              then begin
                // XPath 1.0, prod. [27]:
                NewSyntaxNode:= TDomXPathUnaryExpr.Create(Self, ''); // Create UnaryExpr.
                NewSyntaxNode.Left:= Stack.Pop;                      // Append MinusOperator.
                NewSyntaxNode.Right:= LastSyntaxNode;                // Append UnaryExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else if (Stack.Peek(0) is TDomXPathMultiplyOperator) and
                 ( (Stack.Peek(1) is TDomXPathMultiplyExpr) or
                   (Stack.Peek(1) is TDomXPathDivExpr) or
                   (Stack.Peek(1) is TDomXPathModExpr) )
              then begin
                // XPath 1.0, prod. [26]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathMultiplyExpr.Create(Self, ''); // Create MultiplyExpr.
                NewSyntaxNode.Left:= Stack.Pop;                         // Append MultiplicativeExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;                   // Append UnaryExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else if (Stack.Peek(0) is TDomXPathDivOperator) and
                 ( (Stack.Peek(1) is TDomXPathMultiplyExpr) or
                   (Stack.Peek(1) is TDomXPathDivExpr) or
                   (Stack.Peek(1) is TDomXPathModExpr) )
              then begin
                // XPath 1.0, prod. [26]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathDivExpr.Create(Self, ''); // Create DivExpr.
                NewSyntaxNode.Left:= Stack.Pop;                    // Append MultiplicativeExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;              // Append UnaryExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else if (Stack.Peek(0) is TDomXPathModOperator) and
                 ( (Stack.Peek(1) is TDomXPathMultiplyExpr) or
                   (Stack.Peek(1) is TDomXPathDivExpr) or
                   (Stack.Peek(1) is TDomXPathModExpr) )
              then begin
                // XPath 1.0, prod. [26]:
{$IFDEF AUTOREFCOUNT}
                Stack.Pop;
{$ELSE !AUTOREFCOUNT}
                Stack.Pop.Free;
{$ENDIF AUTOREFCOUNT}
                NewSyntaxNode:= TDomXPathModExpr.Create(Self, ''); // Create ModExpr.
                NewSyntaxNode.Left:= Stack.Pop;                    // Append MultiplicativeExpr.
                NewSyntaxNode.Right:= LastSyntaxNode;              // Append UnaryExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end else begin
                // XPath 1.0, prod. [26]:
                NewSyntaxNode:= TDomXPathMultiplyExpr.Create(Self, ''); // Create MultiplyExpr.
                NewSyntaxNode.Left:= LastSyntaxNode;                    // Append UnaryExpr.
                LastSyntaxNode:= NewSyntaxNode;
              end;
            end else if LastSyntaxNode is TDomXPathUnionExpr then begin
              // XPath 1.0, prod. [27]:
              if Tokenizer.IsFollowing(XPATH_SHEFFER_STROKE_OPERATOR_TOKEN) then begin
                // A Sheffer's Stroke is following, so we postpone building the UnaryExpr.
                Stack.Push(LastSyntaxNode);
                Break;
              end;
              NewSyntaxNode:= TDomXPathUnaryExpr.Create(Self, ''); // Create UnaryExpr.
              NewSyntaxNode.Left:= LastSyntaxNode;                 // Append the UnionExpr.
              LastSyntaxNode:= NewSyntaxNode;
            end else if LastSyntaxNode is TDomXPathVariableReference then begin
              // XPath 1.0, prod. [15]:
              NewSyntaxNode:= TDomXPathPrimaryExpr.Create(Self, ''); // Create PrimaryExpr.
              NewSyntaxNode.Left:= LastSyntaxNode;                   // Append VariableReference.
              LastSyntaxNode:= NewSyntaxNode;
            end;
          until False;
        end; {case ... else ...}
      until False;

      // Is the syntax tree valid, I.e. does the evaluation reach the end of the text
      // and does the stack hold exactly one root node of type TDomXPathExpr?
      if (Symbol =  XPATH_END_OF_TEXT_TOKEN) and
         (Stack.Length = 1) and
         (Stack.Peek(0) is TDomXPathExpr)
      then begin
        FRootExpr := TDomXPathExpr(Stack.Pop);
        Result := True;
      end else Result := False;

    finally
      Stack.Free; // Remark: Frees also all object still in the stack.
    end;
  finally
    Tokenizer.Free;
  end;
end;

function TDomXPathSyntaxTree.GetContextNode: TDomNode;
begin
  if Assigned(OwnerXPathExpression)
    then Result := OwnerXPathExpression.ContextNode
    else Result := nil;
end;

{$IFDEF NEXTGEN}
function TDomXPathSyntaxTree.LookupNamespaceURI(const APrefix: string): string;
{$ELSE !NEXTGEN}
function TDomXPathSyntaxTree.LookupNamespaceURI(const APrefix: WideString): WideString;
{$ENDIF NEXTGEN}
begin
  if Assigned(OwnerXPathExpression)
    then Result := OwnerXPathExpression.LookupNamespaceURI(APrefix)
    else Result := '';
end;

{ TXPathExpression }

constructor TXPathExpression.Create(AOwner: TComponent);
begin
  inherited;
  FIsValid:= T_UNKNOWN;
  FSyntaxTree:= TDomXPathSyntaxTree.Create(Self);
end;

destructor TXPathExpression.Destroy;
begin
  FXPathResult.Free;
  FSyntaxTree.Free;
  inherited;
end;

function TXPathExpression.Evaluate: Boolean;
begin
  FXPathResult.Free;
  FXPathResult := nil;
  try
    Result := Prepare;
    if Result then
      FXPathResult := FSyntaxTree.Evaluate;
  except
    Result := False;
    FXPathResult.Free;
    FXPathResult := nil;
  end;
end;

function TXPathExpression.HasNodeSetResult: Boolean;
begin
  if Assigned(FXPathResult)
    then Result := FXPathResult.Length > 0
    else Result := False;
end;

{$IFDEF NEXTGEN}
function TXPathExpression.LookupNamespaceURI(const APrefix: string): string;
{$ELSE !NEXTGEN}
function TXPathExpression.LookupNamespaceURI(const APrefix: WideString): WideString;
{$ENDIF NEXTGEN}
begin
  if Assigned(ContextNode)
    then Result := ContextNode.LookupNamespaceURI(APrefix)
    else Result := '';
  if Assigned(FOnLookupNamespaceURI) then
    FOnLookupNamespaceURI(Self, APrefix, Result);
end;

function TXPathExpression.Prepare: Boolean;
begin
  if isValid = T_UNKNOWN then begin
    Result := FSyntaxTree.Prepare(FExpression);
    if Result
      then FIsValid:= T_TRUE
      else FIsValid:= T_FALSE;
  end else Result := FIsValid = T_TRUE;
end;

function TXPathExpression.ResultAsBoolean: Boolean;
begin
  if Assigned(FXPathResult)
    then Result := FXPathResult.AsBoolean
    else Result := False;
end;

function TXPathExpression.ResultAsNumber: Double;
begin
  if Assigned(FXPathResult)
    then Result := FXPathResult.AsNumber
    else Result := NaN;
end;

{$IFDEF NEXTGEN}
function TXPathExpression.ResultAsWideString: string;
{$ELSE !NEXTGEN}
function TXPathExpression.ResultAsWideString: WideString;
{$ENDIF NEXTGEN}
begin
  if Assigned(FXPathResult)
    then Result := FXPathResult.AsWideString
    else Result := '';
end;

function TXPathExpression.ResultAxisType: TDomXPathAxisType;
begin
  if Assigned(FXPathResult)
    then Result := FXPathResult.AxisType
    else Result := XPATH_FORWARD_AXIS;
end;

function TXPathExpression.ResultLength: Integer;
begin
  if Assigned(FXPathResult)
    then Result := FXPathResult.Length
    else Result := 0;
end;

function TXPathExpression.ResultNode(const Index: Integer): TDomNode;
begin
  if Assigned(FXPathResult)
    then Result := FXPathResult.Item(Index)
    else Result := nil;
end;

procedure TXPathExpression.SetContextNode(const Node: TDomNode);
begin
  if Assigned(Node) then
    if not (Node.RootDocument is TDomDocumentXPath) then
      raise ENot_Supported_Err.Create('Not supported error.');

  FContextNode := Node;
end;

{$IFDEF NEXTGEN}
procedure TXPathExpression.SetExpression(const S: string);
{$ELSE !NEXTGEN}
procedure TXPathExpression.SetExpression(const S: WideString);
{$ENDIF NEXTGEN}
begin
  if S <> FExpression then begin
    FExpression:= S;
    FSyntaxTree.Clear;
    FIsValid:= T_UNKNOWN;
  end;
end;

{ TDomXPathSyntaxNodeStack }

constructor TDomXPathSyntaxNodeStack.Create;
begin
  inherited;
  FNodeList:= TList<TDomXPathSyntaxNode>.Create;
end;

destructor TDomXPathSyntaxNodeStack.Destroy;
begin
  Clear;
  FNodeList.Free;
  inherited;
end;

procedure TDomXPathSyntaxNodeStack.Clear;
{$IFNDEF AUTOREFCOUNT}
var
  I: Integer;
{$ENDIF !AUTOREFCOUNT}
begin
{$IFNDEF AUTOREFCOUNT}
  for I := 0 to Pred(FNodeList.Count) do
    TDomXPathSyntaxNode(FNodeList[I]).Free;
{$ENDIF !AUTOREFCOUNT}
end;

function TDomXPathSyntaxNodeStack.GetLength: Integer;
begin
  Result := FNodeList.Count;
end;

function TDomXPathSyntaxNodeStack.Peek(Offset: Integer): TDomXPathSyntaxNode;
var
  Index: Integer;
begin
  Index := Pred(FNodeList.Count) - Offset;
  if (Index < 0) or (Index >= FNodeList.Count)
    then Result := nil
{$IFDEF CLR}
    else Result := TDomXPathSyntaxNode(FNodeList[Index]);
{$ELSE}
    else Result := TDomXPathSyntaxNode(FNodeList.List[Index]);
{$ENDIF}
end;

function TDomXPathSyntaxNodeStack.Pop: TDomXPathSyntaxNode;
begin
  Result := TDomXPathSyntaxNode(FNodeList[Pred(FNodeList.Count)]);
  FNodeList.Delete(Pred(FNodeList.Count));
end;

procedure TDomXPathSyntaxNodeStack.Push(Node: TDomXPathSyntaxNode);
begin
  FNodeList.Add(Node);
end;

{ TDomXPathSyntaxNode }

{$IFDEF NEXTGEN}
constructor TDomXPathSyntaxNode.Create(const AOwner: TDomXPathSyntaxTree;
                                       const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathSyntaxNode.Create(const AOwner: TDomXPathSyntaxTree;
                                       const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited Create(AOwner);
  FLeft:= nil;
  FRight:= nil;
  FValue := Value;
end;

function TDomXPathSyntaxNode.GetOwnerSyntaxTree: TDomXPathSyntaxTree;
begin
  Result := (GetOwner as TDomXPathSyntaxTree);
end;

{$IFDEF NEXTGEN}
function TDomXPathSyntaxNode.LookupNamespaceURI(const APrefix: string): string;
{$ELSE !NEXTGEN}
function TDomXPathSyntaxNode.LookupNamespaceURI(const APrefix: WideString): WideString;
{$ENDIF NEXTGEN}
begin
  if Assigned(OwnerSyntaxTree)
    then Result := OwnerSyntaxTree.LookupNamespaceURI(APrefix)
    else Result := '';
end;

{ TDomXPathStep }

function TDomXPathStep.AddStep(const Step: TDomXPathStep): Boolean;
begin
  if not Assigned(Right) then begin
    Right:= Step;
    Result := True;
  end else begin
    if Right is TDomXPathStep
      then Result := TDomXPathStep(Right).AddStep(Step)
      else Result := False;
  end;
end;

function TDomXPathStep.Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult;
var
  NewResult: TDomXPathNodeSetResult;
begin
  if not Assigned(OldSnapshotResult) then
    raise EXPath_Type_Err.Create('XPath type error.');
  if Left is TDomXPathCustomAxisName then begin

    if OldSnapshotResult.Length > 0 then begin
      NewResult := TDomXPathCustomAxisName(Left).Evaluate(OldSnapshotResult);
      if Right is TDomXPathStep
        then Result := TDomXPathStep(Right).Evaluate(NewResult)
        else Result := NewResult;
    end else Result := OldSnapshotResult;

  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathCustomAxisName }

{$IFDEF NEXTGEN}
constructor TDomXPathCustomAxisName.Create(const AOwner: TDomXPathSyntaxTree;
                                           const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathCustomAxisName.Create(const AOwner: TDomXPathSyntaxTree;
                                           const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FAxisType := XPATH_FORWARD_AXIS;
  FPrincipalNodeType := ntElement_Node;
end;

function TDomXPathCustomAxisName.Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult;
var
  I: Integer;
  N: TDomNode;
  AxisNodeSnapshot, InputSnapshot, NodeTestSnapshot: TDomXPathNodeSetResult;

  function EvaluatePredicate(const snapshot: TDomXPathNodeSetResult): TDomXPathNodeSetResult;
  begin
    if Assigned(Right) then begin
      if Right is TDomXPathPredicate then begin
        if snapshot.Length > 0
          then Result := TDomXPathPredicate(Right).Evaluate(snapshot)
          else Result := snapshot;
      end else begin
{$IFNDEF AUTOREFCOUNT}
        snapshot.Free;
{$ENDIF !AUTOREFCOUNT}
        raise EXPath_Type_Err.Create('XPath type error.');
      end;
    end else Result := snapshot;
  end;

  function EvaluateNodeTest(const snapshot: TDomXPathNodeSetResult): TDomXPathNodeSetResult;
  begin
    if Assigned(Left) then begin
      if Left is TDomXPathNodeTest then begin
        if snapshot.Length > 0
          then Result := TDomXPathNodeTest(Left).Evaluate(snapshot,FPrincipalNodeType)
          else Result := snapshot;
      end else begin
{$IFNDEF AUTOREFCOUNT}
        snapshot.Free;
{$ENDIF !AUTOREFCOUNT}
        raise EXPath_Type_Err.Create('XPath type error.');
      end;
    end else raise EXPath_Type_Err.Create('XPath type error.');
  end;

begin
  if not Assigned(OldSnapshotResult) then
    raise EXPath_Type_Err.Create('XPath type error.');
  try
    Result := TDomXPathNodeSetResult.Create;
    try
      Result.AxisType := AxisType;
      for I := 0 to Pred(OldSnapshotResult.Length) do begin
        N := OldSnapshotResult.Item(I);
        if Assigned(N) then begin
          InputSnapshot:= GetAxisNodeSnapshot(N);
          NodeTestSnapshot:= EvaluateNodeTest(InputSnapshot);
          AxisNodeSnapshot:= EvaluatePredicate(NodeTestSnapshot);
          try
            Result.Merge(AxisNodeSnapshot);
          finally
            AxisNodeSnapshot.Free;
          end;
        end;
      end;
    except
      Result.Free;
      raise;
    end;
  finally
{$IFNDEF AUTOREFCOUNT}
    OldSnapshotResult.Free;
{$ENDIF !AUTOREFCOUNT}
  end;
end;

{ TDomXPathAxisNameAncestor }

{$IFDEF NEXTGEN}
constructor TDomXPathAxisNameAncestor.Create(const AOwner: TDomXPathSyntaxTree;
                                             const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathAxisNameAncestor.Create(const AOwner: TDomXPathSyntaxTree;
                                             const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FAxisType := XPATH_REVERSE_AXIS;
end;

function TDomXPathAxisNameAncestor.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  N: TDomNode;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    case ContextNode.NodeType of
      ntElement_Node, ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
      ntProcessing_Instruction_Node, ntComment_Node:
        N := ContextNode.ParentNode;
      ntAttribute_Node:
        N := TDomAttr(ContextNode).OwnerElement;
      ntXPath_Namespace_Node:
        N := TDomXPathNamespace(ContextNode).OwnerElement;
    else
      N := nil;
    end;
    while Assigned(N) do begin
      Result.Add(N);
      N := N.ParentNode;
    end;
  end;
end;

{ TDomXPathAxisNameAncestorOrSelf }

{$IFDEF NEXTGEN}
constructor TDomXPathAxisNameAncestorOrSelf.Create(const AOwner: TDomXPathSyntaxTree;
                                                   const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathAxisNameAncestorOrSelf.Create(const AOwner: TDomXPathSyntaxTree;
                                                   const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FAxisType := XPATH_REVERSE_AXIS;
end;

function TDomXPathAxisNameAncestorOrSelf.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  N: TDomNode;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    Result.Add(ContextNode);
    case ContextNode.NodeType of
      ntElement_Node, ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
      ntProcessing_Instruction_Node, ntComment_Node:
        N := ContextNode.ParentNode;
      ntAttribute_Node:
        N := TDomAttr(ContextNode).OwnerElement;
      ntXPath_Namespace_Node:
        N := TDomXPathNamespace(ContextNode).OwnerElement;
    else
      N := nil;
    end;
    while Assigned(N) do begin
      Result.Add(N);
      N := N.ParentNode;
    end;
  end;
end;

{ TDomXPathAxisNameAttribute }

{$IFDEF NEXTGEN}
constructor TDomXPathAxisNameAttribute.Create(const AOwner: TDomXPathSyntaxTree;
                                              const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathAxisNameAttribute.Create(const AOwner: TDomXPathSyntaxTree;
                                              const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FPrincipalNodeType := ntAttribute_Node;
end;

function TDomXPathAxisNameAttribute.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  I: Integer;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then
    if ContextNode.NodeType = ntElement_Node then
      for I := 0 to Pred(ContextNode.Attributes.Length) do
        if (ContextNode.Attributes.Item(I) as TDomAttr).IsXmlnsDecl = NSDT_NONE then
          Result.Add(ContextNode.Attributes.Item(I));
end;

{ TDomXPathAxisNameChild }

function TDomXPathAxisNameChild.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  I: Integer;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then
    for I := 0 to Pred(ContextNode.ChildNodes.Length) do
      Result.Add(ContextNode.ChildNodes.Item(I));
end;

{ TDomXPathAxisNameDescendant }

function TDomXPathAxisNameDescendant.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  N: TDomNode;
  Iter: TDomNodeIterator;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    ITer := ContextNode.RootDocument.CreateNodeIterator(ContextNode,
                                                      [ ntElement_Node,
                                                        ntText_Node,
                                                        ntCDATA_Section_Node,
                                                        ntEntity_Reference_Node,
                                                        ntProcessing_Instruction_Node,
                                                        ntComment_Node ],
                                                      nil,
                                                      False);
    N := Iter.NextNode;
    if N = ContextNode then N := Iter.NextNode;
    while Assigned(N) do begin
      Result.Add(N);
      N := Iter.NextNode;
    end;
    Iter.Detach;
    ContextNode.RootDocument.ClearInvalidNodeIterators;
  end;
end;

{ TDomXPathAxisNameDescendantOrSelf }

function TDomXPathAxisNameDescendantOrSelf.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  N: TDomNode;
  Iter: TDomNodeIterator;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    Iter := ContextNode.RootDocument.CreateNodeIterator(ContextNode,
                                                      [ ntElement_Node,
                                                        ntText_Node,
                                                        ntCDATA_Section_Node,
                                                        ntEntity_Reference_Node,
                                                        ntProcessing_Instruction_Node,
                                                        ntComment_Node,
                                                        ntDocument_Node ],
                                                      nil,
                                                      False);
    N := Iter.NextNode;
    while Assigned(N) do begin
      Result.Add(N);
      N := Iter.NextNode;
    end;
    Iter.Detach;
    ContextNode.RootDocument.ClearInvalidNodeIterators;
  end;
end;

{ TDomXPathAxisNameFollowing }

function TDomXPathAxisNameFollowing.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  P, Q: TDomNode;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    case ContextNode.NodeType of
      ntElement_Node, ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
      ntProcessing_Instruction_Node, ntComment_Node: begin
        Q := ContextNode;
        P := ContextNode.NextSibling;
        while Assigned(P) do begin
          if not ( ( (Q.NodeType = ntText_Node) or
                     (Q.NodeType = ntCDATA_Section_Node) or
                     (Q.NodeType = ntEntity_Reference_Node) ) and
                   ( (P.NodeType = ntText_Node) or
                     (P.NodeType = ntCDATA_Section_Node) or
                     (P.NodeType = ntEntity_Reference_Node) ) )
          then Result.AddSubtree(P);
          Q := P;
          P.NextSibling;
        end;
      end;
    end;
  end;
end;

{ TDomXPathAxisNameFollowingSibling }

function TDomXPathAxisNameFollowingSibling.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  P, Q: TDomNode;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    case ContextNode.NodeType of
      ntElement_Node, ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
      ntProcessing_Instruction_Node, ntComment_Node: begin
        Q := ContextNode;
        P := ContextNode.NextSibling;
        while Assigned(P) do begin
          if not ( ( (Q.NodeType = ntText_Node) or
                     (Q.NodeType = ntCDATA_Section_Node) or
                     (Q.NodeType = ntEntity_Reference_Node) ) and
                   ( (P.NodeType = ntText_Node) or
                     (P.NodeType = ntCDATA_Section_Node) or
                     (P.NodeType = ntEntity_Reference_Node) ) )
          then Result.Add(P);
          Q := P;
          P := Q.NextSibling;
        end;
      end;
    end;
  end;
end;

{ TDomXPathAxisNameNamespace }

{$IFDEF NEXTGEN}
constructor TDomXPathAxisNameNamespace.Create(const AOwner: TDomXPathSyntaxTree;
                                              const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathAxisNameNamespace.Create(const AOwner: TDomXPathSyntaxTree;
                                              const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FPrincipalNodeType := ntXPath_Namespace_Node;
end;

function TDomXPathAxisNameNamespace.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  PrefixUriList: TUtilsNameValueList;
  CNode: TDomNode;
  I: Integer;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;

  if ContextNode.NodeType = ntElement_Node then begin
    PrefixUriList:= TUtilsNameValueList.Create;
    try
      PrefixUriList.Sorted := True;
      PrefixUriList.Duplicates := dupIgnore;
      PrefixUriList.Add('xml', 'http://www.w3.org/XML/1998/namespace');

      CNode := ContextNode;
      while Assigned(CNode) do begin
        if CNode.NodeType <> ntElement_Node then Break;
        for I := 0 to Pred(CNode.Attributes.Length) do
          case TDomAttr(CNode.Attributes.Item(I)).IsXmlnsDecl of
            NSDT_DEFAULT: PrefixUriList.Add('', TDomAttr(CNode.Attributes.Item(I)).NodeValue);
            NSDT_PREFIXED: PrefixUriList.Add(TDomAttr(CNode.Attributes.Item(I)).LocalName, TDomAttr(CNode.Attributes.Item(I)).NodeValue);
          end;
        CNode:= CNode.ParentNode;
      end;

      for I := 0 to Pred(PrefixUriList.Length) do
        Result.AddXPathNamespace(ContextNode as TDomElement, PrefixUriList.Values[I], PrefixUriList.Names[I]);

    finally
      PrefixUriList.Free;
    end;
  end;
end;

{ TDomXPathAxisNameParent }

function TDomXPathAxisNameParent.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  N: TDomNode;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    case ContextNode.NodeType of
      ntElement_Node, ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
      ntProcessing_Instruction_Node, ntComment_Node:
        N := ContextNode.ParentNode;
      ntAttribute_Node:
        N := TDomAttr(ContextNode).OwnerElement;
      ntXPath_Namespace_Node:
        N := TDomXPathNamespace(ContextNode).OwnerElement;
    else
      N := nil;
    end;
    if Assigned(N)
      then Result.Add(N);
  end;
end;

{ TDomXPathAxisNamePreceding }

{$IFDEF NEXTGEN}
constructor TDomXPathAxisNamePreceding.Create(const AOwner: TDomXPathSyntaxTree;
                                              const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathAxisNamePreceding.Create(const AOwner: TDomXPathSyntaxTree;
                                              const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FAxisType := XPATH_REVERSE_AXIS;
end;

function TDomXPathAxisNamePreceding.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  N: TDomNode;

  procedure AddPreceding(const Snapshot: TDomXPathNodeSetResult;
                         const Node: TDomNode);
  var
    P, Q: TDomNode;
  begin
    case Node.NodeType of
      ntElement_Node, ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
      ntProcessing_Instruction_Node, ntComment_Node: begin
        P := Node.PreviousSibling;
        while Assigned(P) do begin
          Q := P.PreviousSibling;
          if Assigned(Q) then begin
            if not ( ( (P.NodeType = ntText_Node) or
                       (P.NodeType = ntCDATA_Section_Node) or
                       (P.NodeType = ntEntity_Reference_Node) ) and
                     ( (Q.NodeType = ntText_Node) or
                       (Q.NodeType = ntCDATA_Section_Node) or
                       (Q.NodeType = ntEntity_Reference_Node) ) )
            then snapshot.AddSubtree(P);
            P := Q;
          end else begin
            snapshot.AddSubtree(P);
            Break;
          end;
        end;
      end;
    end;
  end;

begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    AddPreceding(Result,ContextNode);
    case ContextNode.NodeType of
      ntElement_Node, ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
      ntProcessing_Instruction_Node, ntComment_Node:
        N := ContextNode.ParentNode;
      ntAttribute_Node:
        N := TDomAttr(ContextNode).OwnerElement;
      ntXPath_Namespace_Node:
        N := TDomXPathNamespace(ContextNode).OwnerElement;
    else
      N := nil;
    end;
    while Assigned(N) do begin
      AddPreceding(Result,N);
      N := N.ParentNode;
    end;
  end;
end;

{ TDomXPathAxisNamePrecedingSibling }

{$IFDEF NEXTGEN}
constructor TDomXPathAxisNamePrecedingSibling.Create(const AOwner: TDomXPathSyntaxTree;
                                                     const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathAxisNamePrecedingSibling.Create(const AOwner: TDomXPathSyntaxTree;
                                                     const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FAxisType := XPATH_REVERSE_AXIS;
end;

function TDomXPathAxisNamePrecedingSibling.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
var
  P, Q: TDomNode;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode) then begin
    case ContextNode.NodeType of
      ntElement_Node, ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node,
      ntProcessing_Instruction_Node, ntComment_Node: begin
        P := ContextNode.PreviousSibling;
        while Assigned(P) do begin
          Q := P.PreviousSibling;
          if Assigned(Q) then begin
            if not ( ( (P.NodeType = ntText_Node) or
                       (P.NodeType = ntCDATA_Section_Node) or
                       (P.NodeType = ntEntity_Reference_Node) ) and
                     ( (Q.NodeType = ntText_Node) or
                       (Q.NodeType = ntCDATA_Section_Node) or
                       (Q.NodeType = ntEntity_Reference_Node) ) )
            then Result.Add(P);
            P := Q;
          end else begin
            Result.Add(P);
            Break;
          end;
        end;
      end;
    end;
  end;
end;

{ TDomXPathAxisNameSelf }

function TDomXPathAxisNameSelf.GetAxisNodeSnapshot(const ContextNode: TDomNode): TDomXPathNodeSetResult;
begin
  Result := TDomXPathNodeSetResult.Create;
  Result.AxisType := AxisType;
  if Assigned(ContextNode)
    then Result.Add(ContextNode);
end;

{ TDomXPathNodeTest }

function TDomXPathNodeTest.Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult;
                                    const PrincipalNodeType: TDomNodeType): TDomXPathNodeSetResult;
begin
  if not Assigned(OldSnapshotResult) then
    raise EXPath_Type_Err.Create('XPath type error.');

  if Left is TDomXPathNameTest then begin
    Result := TDomXPathNameTest(Left).Evaluate(OldSnapshotResult,principalNodeType);
  end else if Left is TDomXPathNodeTypeComment then begin
    Result := TDomXPathNodeTypeComment(Left).Evaluate(OldSnapshotResult);
  end else if Left is TDomXPathNodeTypeText then begin
    Result := TDomXPathNodeTypeText(Left).Evaluate(OldSnapshotResult);
  end else if Left is TDomXPathNodeTypePI then begin
    Result := TDomXPathNodeTypePI(Left).Evaluate(OldSnapshotResult);
  end else if Left is TDomXPathNodeTypeNode then begin
    Result := OldSnapshotResult;
  end else begin
{$IFNDEF AUTOREFCOUNT}
    OldSnapshotResult.Free;
{$ENDIF !AUTOREFCOUNT}
    raise EXPath_Type_Err.Create('XPath type error.');
  end;
end;

{ TDomXPathPredicate }

function TDomXPathPredicate.Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult;
var
  ContextNode: TDomNode;
  NextPredicateResult: TDomXPathNodeSetResult;
  PredicateResult: TDomXPathCustomResult;
  PredicateResultAsBoolean: TDomXPathBooleanResult;
  ContextPosition: Integer;
begin
  if not Assigned(OldSnapshotResult) then
    raise EXPath_Type_Err.Create('XPath type error.');
  if not (Left is TDomXPathExpr) then begin
{$IFNDEF AUTOREFCOUNT}
    OldSnapshotResult.Free;
{$ENDIF !AUTOREFCOUNT}
    raise EXPath_Type_Err.Create('XPath type error.');
  end;

  try
    Result := TDomXPathNodeSetResult.Create;
    Result.AxisType := OldSnapshotResult.AxisType;
    for ContextPosition:= 1 to OldSnapshotResult.Length do begin
      ContextNode:= OldSnapshotResult.Item(Pred(ContextPosition));
      try
        PredicateResult := TDomXPathExpr(Left).Evaluate(ContextNode, ContextPosition, OldSnapshotResult.Length);
        if PredicateResult is TDomXPathNumberResult then begin
          if PredicateResult.AsNumber = ContextPosition then
            Result.Add(ContextNode);
          PredicateResult.Free;
        end else begin
          PredicateResultAsBoolean:= XPathBooleanFunc(PredicateResult);
          if PredicateResultAsBoolean.AsBoolean then
            Result.Add(ContextNode);
          PredicateResultAsBoolean.Free;
        end;
      except
        Result.Free;
        raise;
      end;
    end;

    if Assigned(Right) then begin
      if Right is TDomXPathPredicate then begin
        NextPredicateResult := TDomXPathPredicate(Right).Evaluate(Result);
        Result := NextPredicateResult;
      end else begin
        Result.Free;
        raise EXPath_Type_Err.Create('XPath type error.');
      end;
    end;

  finally
{$IFNDEF AUTOREFCOUNT}
    OldSnapshotResult.Free;
{$ENDIF !AUTOREFCOUNT}
  end;
end;

{ TDomXPathExpr }

function TDomXPathExpr.Evaluate(const ContextNode: TDomNode;
                                const ContextPosition,
                                      ContextSize: Integer): TDomXPathCustomResult;
begin
  if (Left is TDomXPathOrExpr) then begin
    Result := TDomXPathOrExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathPrimaryExpr }

function TDomXPathPrimaryExpr.Evaluate(const ContextNode: TDomNode;
                                       const ContextPosition,
                                             ContextSize: Integer): TDomXPathCustomResult;
begin
  if (Left is TDomXPathVariableReference) then begin
    Result := TDomXPathVariableReference(Left).Evaluate;
  end else if (Left is TDomXPathExpr) then begin
    Result := TDomXPathExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else if (Left is TDomXPathLiteral) then begin
    Result := TDomXPathLiteral(Left).Evaluate;
  end else if (Left is TDomXPathNumber) then begin
    Result := TDomXPathNumber(Left).Evaluate;
  end else if (Left is TDomXPathFunctionCall) then begin
    Result := TDomXPathFunctionCall(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathFunctionCall }

{$IFDEF NEXTGEN}
constructor TDomXPathFunctionCall.Create(const AOwner: TDomXPathSyntaxTree;
                                         const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathFunctionCall.Create(const AOwner: TDomXPathSyntaxTree;
                                         const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FArguments:= TList<TDomXPathsyntaxNode>.Create;
end;

destructor TDomXPathFunctionCall.Destroy;
begin
  FArguments.Free;
  inherited;
end;

function TDomXPathFunctionCall.Evaluate(const ContextNode: TDomNode;
                                        const ContextPosition: Integer;
                                        const ContextSize: Integer): TDomXPathCustomResult;
var
{$IFDEF NEXTGEN}
  NsUri: string;
{$ELSE !NEXTGEN}
  NsUri: WideString;
{$ENDIF NEXTGEN}
begin
  if Assigned(FXPathFunction) then begin
    Result := FXPathFunction(ContextNode, ContextPosition, ContextSize, Arguments);
  end else begin
    Result := nil;
    // Determine Namespace URI
    NsUri := LookupNamespaceURI(FPrefix);
    if (NsUri = '') and (FPrefix <> '') then
      raise ENamespace_Err.CreateFmt('Namespace URI of prefix ''%S'' not found.',
                                     [FPrefix]);

    if Assigned(OwnerSyntaxTree) then
      if Assigned(OwnerSyntaxTree.ContextNode) then
        if Assigned(OwnerSyntaxTree.ContextNode.OwnerDocument) then
          if Assigned(OwnerSyntaxTree.ContextNode.OwnerDocument.DomImplementation) then
            OwnerSyntaxTree.ContextNode.OwnerDocument.DomImplementation.DoRequestXPathFunctionResult(
              NsUri, FLocalName, OwnerSyntaxTree.ContextNode, ContextPosition, ContextSize, Arguments, Result
            );

    if not Assigned(Result) then
      raise EXPath_Exception.Create('Unknown function name.');
  end;
end;

{$IFDEF NEXTGEN}
function TDomXPathFunctionCall.GetFunctionName: string;
{$ELSE !NEXTGEN}
function TDomXPathFunctionCall.GetFunctionName: WideString;
{$ENDIF NEXTGEN}
begin
  Result := FValue;
end;

{$IFDEF NEXTGEN}
procedure TDomXPathFunctionCall.SetFunctionName(const AFunctionName: string);
{$ELSE !NEXTGEN}
procedure TDomXPathFunctionCall.SetFunctionName(const AFunctionName: WideString);
{$ENDIF NEXTGEN}
begin
  if AFunctionName <> FValue then begin
    FValue := AFunctionName;
    FPrefix := XmlExtractPrefix(Value);
    FLocalName := XmlExtractLocalName(Value);
    if FPrefix = '' then begin
      if FLocalName = 'last' then begin
        FXPathFunction := XPathFunctionLast;
      end else if FLocalName = 'position' then begin
        FXPathFunction := XPathFunctionPosition;
      end else if FLocalName = 'count' then begin
        FXPathFunction := XPathFunctionCount;
      end else if FLocalName = 'id' then begin
        FXPathFunction := XPathFunctionId;
      end else if FLocalName = 'local-name' then begin
        FXPathFunction := XPathFunctionLocalName;
      end else if FLocalName = 'namespace-uri' then begin
        FXPathFunction := XPathFunctionNamespaceUri;
      end else if FLocalName = 'name' then begin
        FXPathFunction := XPathFunctionName;
      end else if FLocalName = 'string' then begin
        FXPathFunction := XPathFunctionString;
      end else if FLocalName = 'concat' then begin
        FXPathFunction := XPathFunctionConcat;
      end else if FLocalName = 'starts-with' then begin
        FXPathFunction := XPathFunctionStartsWith;
      end else if FLocalName = 'contains' then begin
        FXPathFunction := XPathFunctionContains;
      end else if FLocalName = 'substring-before' then begin
        FXPathFunction := XPathFunctionSubstringBefore;
      end else if FLocalName = 'substring-after' then begin
        FXPathFunction := XPathFunctionSubstringAfter;
      end else if FLocalName = 'substring' then begin
        FXPathFunction := XPathFunctionSubstring;
      end else if FLocalName = 'string-length' then begin
        FXPathFunction := XPathFunctionStringLength;
      end else if FLocalName = 'normalize-space' then begin
        FXPathFunction := XPathFunctionNormalizeSpace;
      end else if FLocalName = 'translate' then begin
        FXPathFunction := XPathFunctionTranslate;
      end else if FLocalName = 'boolean' then begin
        FXPathFunction := XPathFunctionBoolean;
      end else if FLocalName = 'not' then begin
        FXPathFunction := XPathFunctionNot;
      end else if FLocalName = 'true' then begin
        FXPathFunction := XPathFunctionTrue;
      end else if FLocalName = 'false' then begin
        FXPathFunction := XPathFunctionFalse;
      end else if FLocalName = 'lang' then begin
        FXPathFunction := XPathFunctionLang;
      end else if FLocalName = 'number' then begin
        FXPathFunction := XPathFunctionNumber;
      end else if FLocalName = 'sum' then begin
        FXPathFunction := XPathFunctionSum;
      end else if FLocalName = 'floor' then begin
        FXPathFunction := XPathFunctionFloor;
      end else if FLocalName = 'ceiling' then begin
        FXPathFunction := XPathFunctionCeiling;
      end else if FLocalName = 'round' then begin
        FXPathFunction := XPathFunctionRound;
      end else FXPathFunction := nil;
    end else FXPathFunction := nil;
  end;
end;

{ TDomXPathUnionExpr }

function TDomXPathUnionExpr.Evaluate(const ContextNode: TDomNode;
                                     const ContextPosition,
                                           ContextSize: Integer): TDomXPathCustomResult;
var
  LeftSnapshotResult: TDomXPathNodeSetResult;
begin
  if (Left is TDomXPathUnionExpr) and (Right is TDomXPathPathExpr) then begin

    LeftSnapshotResult := TDomXPathNodeSetResult(TDomXPathUnionExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize));
    LeftSnapshotResult.AxisType := XPATH_FORWARD_AXIS;
    try
      Result := TDomXPathPathExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize);
      TDomXPathNodeSetResult(Result).Merge(LeftSnapshotResult);
    finally
      LeftSnapshotResult.Free;
    end;

  end else if (Left is TDomXPathPathExpr) and not Assigned(Right) then begin

    Result := TDomXPathPathExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    if Result is TDomXPathNodeSetResult
      then Result.AxisType := XPATH_FORWARD_AXIS;

  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathPathExpr }

function TDomXPathPathExpr.AddStep(const Step: TDomXPathStep): Boolean;
begin
  if not Assigned(Right) then begin
    Right := Step;
    Result := True;
  end else begin
    if Right is TDomXPathStep
      then Result := TDomXPathStep(Right).AddStep(Step)
      else Result := False;
  end;
end;

function TDomXPathPathExpr.Evaluate(const ContextNode: TDomNode;
                                    const ContextPosition,
                                          ContextSize: Integer): TDomXPathCustomResult;
var
  NewResult: TDomXPathCustomResult;
begin
  if Left is TDomXPathFilterExpr then begin
    // Filter expression plus optional relative location path:
    NewResult := TDomXPathFilterExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    if Right is TDomXPathStep then begin
      if not (NewResult is TDomXPathNodeSetResult) then begin
        NewResult.Free;
        raise EXPath_Type_Err.Create('XPath type error.');
      end;
      Result := TDomXPathStep(Right).Evaluate(TDomXPathNodeSetResult(NewResult));
    end else Result := NewResult;
  end else if Left is TDomXPathAbsoluteLocationPath then begin
    // Absolute location path:
    if not Assigned(ContextNode) then
      raise EXPath_Type_Err.Create('XPath type error.');
    if not Assigned(ContextNode.RootDocument) then
      raise EXPath_Type_Err.Create('XPath type error.');
    NewResult := TDomXPathNodeSetResult.Create;
    TDomXPathNodeSetResult(NewResult).Add(ContextNode.RootDocument);
    if Right is TDomXPathStep
      then Result := TDomXPathStep(Right).Evaluate(TDomXPathNodeSetResult(NewResult))
      else Result := NewResult;
  end else begin
    // Relative location path:
    if not (Right is TDomXPathStep) then
      raise EXPath_Type_Err.Create('XPath type error.');
    if not Assigned(ContextNode) then
      raise EXPath_Type_Err.Create('XPath type error.');
    NewResult := TDomXPathNodeSetResult.Create;
    TDomXPathNodeSetResult(NewResult).Add(ContextNode);
    Result := TDomXPathStep(Right).Evaluate(TDomXPathNodeSetResult(NewResult))
  end;
end;

{ TDomXPathFilterExpr }

function TDomXPathFilterExpr.Evaluate(const ContextNode: TDomNode;
                                      const ContextPosition,
                                            ContextSize: Integer): TDomXPathCustomResult;
var
  NewResult: TDomXPathCustomResult;
begin
  if (Left is TDomXPathFilterExpr) and (Right is TDomXPathPredicate)
  then begin
    // Filter expression plus predicate:
    NewResult := TDomXPathFilterExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    if not (NewResult is TDomXPathNodeSetResult) then begin
      NewResult.Free;
      raise EXPath_Type_Err.Create('XPath type error.');
    end;

    // A predicate filters the node-set with respect to the child axis,
    // so the axis always has to be a forward axis, no matter what axis
    // the previous expression required:
    if NewResult is TDomXPathNodeSetResult
      then NewResult.AxisType := XPATH_FORWARD_AXIS;

    Result := TDomXPathPredicate(Right).Evaluate(TDomXPathNodeSetResult(NewResult));
  end else if (Left is TDomXPathPrimaryExpr) and not Assigned(Right) then begin
    // PrimaryExpr:
    Result := TDomXPathPrimaryExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathOrExpr }

function TDomXPathOrExpr.Evaluate(const ContextNode: TDomNode;
                                  const ContextPosition,
                                        ContextSize: Integer): TDomXPathCustomResult;
var
  BooleanResult: TDomXPathBooleanResult;
begin
  if (Left is TDomXPathOrExpr) and (Right is TDomXPathAndExpr) then begin
    BooleanResult := XPathBooleanFunc(TDomXPathOrExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize));
    if BooleanResult.AsBoolean then begin
      Result := BooleanResult;
    end else begin
      BooleanResult.Free;
      Result := XPathBooleanFunc(TDomXPathAndExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize));
    end;
  end else if (Left is TDomXPathAndExpr) then begin
    Result := TDomXPathAndExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathAndExpr }

function TDomXPathAndExpr.Evaluate(const ContextNode: TDomNode;
                                   const ContextPosition,
                                         ContextSize: Integer): TDomXPathCustomResult;
var
  BooleanResult: TDomXPathBooleanResult;
begin
  if (Left is TDomXPathAndExpr) and (Right is TDomXPathEqualityExpr) then begin
    BooleanResult := XPathBooleanFunc(TDomXPathAndExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize));
    if not BooleanResult.AsBoolean then begin
      Result := BooleanResult;
    end else begin
      BooleanResult.Free;
      Result := XPathBooleanFunc(TDomXPathEqualityExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize));
    end;
  end else if Left is TDomXPathEqualityExpr then begin
    Result := TDomXPathEqualityExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathIsEqualExpr }

function TDomXPathIsEqualExpr.Evaluate(const ContextNode: TDomNode;
                                       const ContextPosition,
                                             ContextSize: Integer): TDomXPathCustomResult;
var
  LeftResult, RightResult, SwapResult: TDomXPathCustomResult;
  StringResult: TDomXPathStringResult;
  LeftBoolean, RightBoolean: TDomXPathBooleanResult;
  LeftNumber, RightNumber: TDomXPathNumberResult;
  LeftString, RightString: TDomXPathStringResult;
{$IFDEF NEXTGEN}
  LeftResultString: string;
{$ELSE !NEXTGEN}
  LeftResultString: WideString;
{$ENDIF NEXTGEN}
  I, J: Integer;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF}
  {$ENDIF VER250+}
{$ENDIF}
begin
  Result := nil;
  if (Left is TDomXPathEqualityExpr) and (Right is TDomXPathRelationalExpr) then begin
    RightResult := nil; // Saves one try ... finally block.
    LeftResult := TDomXPathEqualityExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      RightResult := TDomXPathRelationalExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize);

      // Make sure, that if at least one set takes part in the comparision,
      // it is Assigned to RightResult:
      if RightResult is TDomXPathNodeSetResult then begin
        SwapResult := LeftResult;
        LeftResult := RightResult;
        RightResult := SwapResult;
      end;

      if LeftResult is TDomXPathNodeSetResult then begin
        if RightResult is TDomXPathNodeSetResult then begin
          for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
            LeftResultString:= TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue;
            for J := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
              if TDomXPathNodeSetResult(RightResult).Item(J).XPathStringValue = LeftResultString then begin
                Result := TDomXPathBooleanResult.Create(True);
                Exit;
              end;
            end;
          end;
          Result := TDomXPathBooleanResult.Create(False);
          Exit;
        end else if (RightResult is TDomXPathNumberResult) or
                    (RightResult is TDomXPathBooleanResult) or
                    (RightResult is TDomXPathStringResult)
        then begin
          StringResult := XPathStringFunc(RightResult);
          for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
            if TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue = StringResult.AsWideString then begin
              Result := TDomXPathBooleanResult.Create(True);
              RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
              Exit;
            end;
          end;
          Result := TDomXPathBooleanResult.Create(False);
          RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
          Exit;
        end;
      end else if (LeftResult is TDomXPathBooleanResult) or
                  (RightResult is TDomXPathBooleanResult)
      then begin
        LeftBoolean:= XPathBooleanFunc(LeftResult);
        RightBoolean:= XPathBooleanFunc(RightResult);
        if LeftBoolean.AsBoolean = RightBoolean.AsBoolean
          then Result := TDomXPathBooleanResult.Create(True)
          else Result := TDomXPathBooleanResult.Create(False);
        LeftResult := LeftBoolean;    // Re-assignment is required for correct
        RightResult := RightBoolean;  // freeing the TDomXPathCustomResult below.
      end else if (LeftResult is TDomXPathNumberResult) or
                  (RightResult is TDomXPathNumberResult)
      then begin
        LeftNumber := XPathNumberFunc(LeftResult);
        RightNumber := XPathNumberFunc(RightResult);
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
        ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
        try
{$ENDIF}
          if LeftNumber.AsNumber = RightNumber.AsNumber
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
        finally
          SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
        except
          if (IsNaN(LeftNumber.AsNumber) and  IsNaN(RightNumber.AsNumber)) or
             (Sign(LeftNumber.AsNumber) = Sign(RightNumber.AsNumber))
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
  {$ENDIF}
        end;
{$ENDIF}
        LeftResult := LeftNumber;    // Re-assignment is required for correct
        RightResult := RightNumber;  // freeing the TDomXPathCustomResult below.
      end else begin
        LeftString:= XPathStringFunc(LeftResult);
        RightString:= XPathStringFunc(RightResult);
        if LeftString.AsWideString = RightString.AsWideString
          then Result := TDomXPathBooleanResult.Create(True)
          else Result := TDomXPathBooleanResult.Create(False);
        LeftResult := LeftString;    // Re-assignment is required for correct
        RightResult := RightString;  // freeing the TDomXPathCustomResult below.
      end;

    finally
      RightResult.Free;
      LeftResult.Free;
    end;
  end else if Left is TDomXPathRelationalExpr then begin
    Result := TDomXPathRelationalExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathIsNotEqualExpr }

function TDomXPathIsNotEqualExpr.Evaluate(const ContextNode: TDomNode;
                                          const ContextPosition,
                                                ContextSize: Integer): TDomXPathCustomResult;
var
  LeftResult, RightResult, SwapResult: TDomXPathCustomResult;
  StringResult: TDomXPathStringResult;
  LeftBoolean, RightBoolean: TDomXPathBooleanResult;
  LeftNumber, RightNumber: TDomXPathNumberResult;
  LeftString, RightString: TDomXPathStringResult;
{$IFDEF NEXTGEN}
  LeftResultString: string;
{$ELSE !NEXTGEN}
  LeftResultString: WideString;
{$ENDIF NEXTGEN}
  I, J: Integer;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  Result := nil;
  if (Left is TDomXPathEqualityExpr) and (Right is TDomXPathRelationalExpr) then begin
    RightResult := nil; // Saves one try ... finally block.
    LeftResult := TDomXPathEqualityExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      RightResult := TDomXPathRelationalExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize);

      // Make sure, that if at least one set takes part in the comparision,
      // it is Assigned to RightResult:
      if RightResult is TDomXPathNodeSetResult then begin
        SwapResult := LeftResult;
        LeftResult := RightResult;
        RightResult := SwapResult;
      end;

      if LeftResult is TDomXPathNodeSetResult then begin
        if RightResult is TDomXPathNodeSetResult then begin
          for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
            LeftResultString:= TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue;
            for J := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
              if TDomXPathNodeSetResult(RightResult).Item(J).XPathStringValue <> LeftResultString then begin
                Result := TDomXPathBooleanResult.Create(True);
                Exit;
              end;
            end;
          end;
          Result := TDomXPathBooleanResult.Create(False);
          Exit;
        end else if (RightResult is TDomXPathNumberResult) or
                    (RightResult is TDomXPathBooleanResult) or
                    (RightResult is TDomXPathStringResult)
        then begin
          StringResult := XPathStringFunc(RightResult);
          for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
            if TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue <> StringResult.AsWideString then begin
              Result := TDomXPathBooleanResult.Create(True);
              RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
              Exit;
            end;
          end;
          Result := TDomXPathBooleanResult.Create(False);
          RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
          Exit;
        end;
      end else if (LeftResult is TDomXPathBooleanResult) or
                  (RightResult is TDomXPathBooleanResult)
      then begin
        LeftBoolean:= XPathBooleanFunc(LeftResult);
        RightBoolean:= XPathBooleanFunc(RightResult);
        if LeftBoolean.AsBoolean <> RightBoolean.AsBoolean
          then Result := TDomXPathBooleanResult.Create(True)
          else Result := TDomXPathBooleanResult.Create(False);
        LeftResult := LeftBoolean;    // Re-assignment is required for correct
        RightResult := RightBoolean;  // freeing the TDomXPathCustomResult below.
      end else if (LeftResult is TDomXPathNumberResult) or
                  (RightResult is TDomXPathNumberResult)
      then begin
        LeftNumber := XPathNumberFunc(LeftResult);
        RightNumber := XPathNumberFunc(RightResult);
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
        ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
        try
{$ENDIF}
          if LeftNumber.AsNumber <> RightNumber.AsNumber
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
        finally
          SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
        except
          if (IsNaN(LeftNumber.AsNumber) and not IsNaN(RightNumber.AsNumber)) or
             (IsNaN(RightNumber.AsNumber) and not IsNaN(LeftNumber.AsNumber)) or
             (Sign(LeftNumber.AsNumber) <> Sign(RightNumber.AsNumber))
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
  {$ENDIF}
        end;
{$ENDIF}
        LeftResult := LeftNumber;    // Re-assignment is required for correct
        RightResult := RightNumber;  // freeing the TDomXPathCustomResult below.
      end else begin
        LeftString:= XPathStringFunc(LeftResult);
        RightString:= XPathStringFunc(RightResult);
        if LeftString.AsWideString <> RightString.AsWideString
          then Result := TDomXPathBooleanResult.Create(True)
          else Result := TDomXPathBooleanResult.Create(False);
        LeftResult := LeftString;    // Re-assignment is required for correct
        RightResult := RightString;  // freeing the TDomXPathCustomResult below.
      end;

    finally
      RightResult.Free;
      LeftResult.Free;
    end;
  end else if Left is TDomXPathRelationalExpr then begin
    Result := TDomXPathRelationalExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathLessThanExpr }

function TDomXPathLessThanExpr.Evaluate(const ContextNode: TDomNode;
                                        const ContextPosition,
                                              ContextSize: Integer): TDomXPathCustomResult;
var
  LeftResult, RightResult: TDomXPathCustomResult;
  StringResult: TDomXPathStringResult;
  LeftNumber, RightNumber: TDomXPathNumberResult;
{$IFDEF NEXTGEN}
  LeftResultString: string;
{$ELSE !NEXTGEN}
  LeftResultString: WideString;
{$ENDIF NEXTGEN}
  I, J: Integer;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathRelationalExpr) and (Right is TDomXPathAdditiveExpr) then begin
    RightResult := nil; // Saves one try ... finally block.
    LeftResult := TDomXPathRelationalExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      RightResult := TDomXPathAdditiveExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize);

      if (LeftResult is TDomXPathNodeSetResult) and
         (RightResult is TDomXPathNodeSetResult)
      then begin
        for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
          LeftResultString:= TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue;
          for J := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
            if TDomXPathNodeSetResult(RightResult).Item(J).XPathStringValue < LeftResultString then begin
              Result := TDomXPathBooleanResult.Create(True);
              Exit;
            end;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        Exit;
      end else if (LeftResult is TDomXPathNodeSetResult) and
                  ( (RightResult is TDomXPathNumberResult) or
                    (RightResult is TDomXPathBooleanResult) or
                    (RightResult is TDomXPathStringResult) )
      then begin
        StringResult := XPathStringFunc(RightResult);
        for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
          if TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue < StringResult.AsWideString then begin
            Result := TDomXPathBooleanResult.Create(True);
            RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
            Exit;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
        Exit;
      end else if ( (LeftResult is TDomXPathNumberResult) or
                    (LeftResult is TDomXPathBooleanResult) or
                    (LeftResult is TDomXPathStringResult) ) and
                  (RightResult is TDomXPathNodeSetResult)
      then begin
        StringResult := XPathStringFunc(LeftResult);
        for I := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
          if StringResult.AsWideString < TDomXPathNodeSetResult(RightResult).Item(I).XPathStringValue then begin
            Result := TDomXPathBooleanResult.Create(True);
            LeftResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
            Exit;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        LeftResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
        Exit;
      end else begin
        LeftNumber := XPathNumberFunc(LeftResult);
        RightNumber := XPathNumberFunc(RightResult);
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
        ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
        try
{$ENDIF}
          if LeftNumber.AsNumber < RightNumber.AsNumber
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
        finally
          SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
        except
          Result := TDomXPathBooleanResult.Create(False);
  {$ENDIF}
        end;
{$ENDIF}
        LeftResult := LeftNumber;    // Re-assignment is required for correct
        RightResult := RightNumber;  // freeing the TDomXPathCustomResult below.
      end;

    finally
      RightResult.Free;
      LeftResult.Free;
    end;
  end else if Left is TDomXPathAdditiveExpr then begin
    Result := TDomXPathAdditiveExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathLessThanOrEqualExpr }

function TDomXPathLessThanOrEqualExpr.Evaluate(const ContextNode: TDomNode;
                                               const ContextPosition,
                                                     ContextSize: Integer): TDomXPathCustomResult;
var
  LeftResult, RightResult: TDomXPathCustomResult;
  StringResult: TDomXPathStringResult;
  LeftNumber, RightNumber: TDomXPathNumberResult;
{$IFDEF NEXTGEN}
  LeftResultString: string;
{$ELSE !NEXTGEN}
  LeftResultString: WideString;
{$ENDIF NEXTGEN}
  I, J: Integer;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathRelationalExpr) and (Right is TDomXPathAdditiveExpr) then begin
    RightResult := nil; // Saves one try ... finally block.
    LeftResult := TDomXPathRelationalExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      RightResult := TDomXPathAdditiveExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize);

      if (LeftResult is TDomXPathNodeSetResult) and
         (RightResult is TDomXPathNodeSetResult)
      then begin
        for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
          LeftResultString:= TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue;
          for J := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
            if TDomXPathNodeSetResult(RightResult).Item(J).XPathStringValue <= LeftResultString then begin
              Result := TDomXPathBooleanResult.Create(True);
              Exit;
            end;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        Exit;
      end else if (LeftResult is TDomXPathNodeSetResult) and
                  ( (RightResult is TDomXPathNumberResult) or
                    (RightResult is TDomXPathBooleanResult) or
                    (RightResult is TDomXPathStringResult) )
      then begin
        StringResult := XPathStringFunc(RightResult);
        for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
          if TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue <= StringResult.AsWideString then begin
            Result := TDomXPathBooleanResult.Create(True);
            RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
            Exit;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
        Exit;
      end else if ( (LeftResult is TDomXPathNumberResult) or
                    (LeftResult is TDomXPathBooleanResult) or
                    (LeftResult is TDomXPathStringResult) ) and
                  (RightResult is TDomXPathNodeSetResult)
      then begin
        StringResult := XPathStringFunc(LeftResult);
        for I := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
          if StringResult.AsWideString <= TDomXPathNodeSetResult(RightResult).Item(I).XPathStringValue then begin
            Result := TDomXPathBooleanResult.Create(True);
            LeftResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
            Exit;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        LeftResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
        Exit;
      end else begin
        LeftNumber := XPathNumberFunc(LeftResult);
        RightNumber := XPathNumberFunc(RightResult);
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
        ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
        try
{$ENDIF}
          if LeftNumber.AsNumber <= RightNumber.AsNumber
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
        finally
          SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
        except
          if (IsNaN(LeftNumber.AsNumber) and not IsNaN(RightNumber.AsNumber)) or
             (IsNaN(RightNumber.AsNumber) and not IsNaN(LeftNumber.AsNumber)) or
             (Sign(LeftNumber.AsNumber) <> Sign(RightNumber.AsNumber))
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
  {$ENDIF}
        end;
{$ENDIF}
        LeftResult := LeftNumber;    // Re-assignment is required for correct
        RightResult := RightNumber;  // freeing the TDomXPathCustomResult below.
      end;

    finally
      RightResult.Free;
      LeftResult.Free;
    end;
  end else if Left is TDomXPathAdditiveExpr then begin
    Result := TDomXPathAdditiveExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathGreaterThanExpr }

function TDomXPathGreaterThanExpr.Evaluate(const ContextNode: TDomNode;
                                           const ContextPosition,
                                                 ContextSize: Integer): TDomXPathCustomResult;
var
  LeftResult, RightResult: TDomXPathCustomResult;
  StringResult: TDomXPathStringResult;
  LeftNumber,RightNumber: TDomXPathNumberResult;
{$IFDEF NEXTGEN}
  LeftResultString: string;
{$ELSE !NEXTGEN}
  LeftResultString: WideString;
{$ENDIF NEXTGEN}
  I, J: Integer;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathRelationalExpr) and (Right is TDomXPathAdditiveExpr) then begin
    RightResult := nil; // Saves one try ... finally block.
    LeftResult := TDomXPathRelationalExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      RightResult := TDomXPathAdditiveExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize);

      if (LeftResult is TDomXPathNodeSetResult) and
         (RightResult is TDomXPathNodeSetResult)
      then begin
        for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
          LeftResultString:= TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue;
          for J := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
            if TDomXPathNodeSetResult(RightResult).Item(J).XPathStringValue > LeftResultString then begin
              Result := TDomXPathBooleanResult.Create(True);
              Exit;
            end;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        Exit;
      end else if (LeftResult is TDomXPathNodeSetResult) and
                  ( (RightResult is TDomXPathNumberResult) or
                    (RightResult is TDomXPathBooleanResult) or
                    (RightResult is TDomXPathStringResult) )
      then begin
        StringResult := XPathStringFunc(RightResult);
        for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
          if TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue > StringResult.AsWideString then begin
            Result := TDomXPathBooleanResult.Create(True);
            RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
            Exit;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
        Exit;
      end else if ( (LeftResult is TDomXPathNumberResult) or
                    (LeftResult is TDomXPathBooleanResult) or
                    (LeftResult is TDomXPathStringResult) ) and
                  (RightResult is TDomXPathNodeSetResult)
      then begin
        StringResult := XPathStringFunc(LeftResult);
        for I := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
          if StringResult.AsWideString > TDomXPathNodeSetResult(RightResult).Item(I).XPathStringValue then begin
            Result := TDomXPathBooleanResult.Create(True);
            LeftResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
            Exit;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        LeftResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
        Exit;
      end else begin
        LeftNumber := XPathNumberFunc(LeftResult);
        RightNumber := XPathNumberFunc(RightResult);
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
        ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
        try
{$ENDIF}
          if LeftNumber.AsNumber > RightNumber.AsNumber
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
        finally
          SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
        except
          Result := TDomXPathBooleanResult.Create(False);
  {$ENDIF}
        end;
{$ENDIF}
        LeftResult := LeftNumber;    // Re-assignment is required for correct
        RightResult := RightNumber;  // freeing the TDomXPathCustomResult below.
      end;

    finally
      RightResult.Free;
      LeftResult.Free;
    end;
  end else if Left is TDomXPathAdditiveExpr then begin
    Result := TDomXPathAdditiveExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathGreaterThanOrEqualExpr }

function TDomXPathGreaterThanOrEqualExpr.Evaluate(const ContextNode: TDomNode;
                                                  const ContextPosition,
                                                        ContextSize: Integer): TDomXPathCustomResult;
var
  LeftResult,RightResult: TDomXPathCustomResult;
  StringResult: TDomXPathStringResult;
  LeftNumber,RightNumber: TDomXPathNumberResult;
{$IFDEF NEXTGEN}
  LeftResultString: string;
{$ELSE !NEXTGEN}
  LeftResultString: WideString;
{$ENDIF NEXTGEN}
  I,J: Integer;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathRelationalExpr) and (Right is TDomXPathAdditiveExpr) then begin
    RightResult := nil; // Saves one try ... finally block.
    LeftResult := TDomXPathRelationalExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
    try
      RightResult := TDomXPathAdditiveExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize);

      if (LeftResult is TDomXPathNodeSetResult) and
         (RightResult is TDomXPathNodeSetResult)
      then begin
        for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
          LeftResultString:= TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue;
          for J := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
            if TDomXPathNodeSetResult(RightResult).Item(J).XPathStringValue >= LeftResultString then begin
              Result := TDomXPathBooleanResult.Create(True);
              Exit;
            end;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        Exit;
      end else if (LeftResult is TDomXPathNodeSetResult) and
                  ( (RightResult is TDomXPathNumberResult) or
                    (RightResult is TDomXPathBooleanResult) or
                    (RightResult is TDomXPathStringResult) )
      then begin
        StringResult := XPathStringFunc(RightResult);
        for I := 0 to Pred(TDomXPathNodeSetResult(LeftResult).Length) do begin
          if TDomXPathNodeSetResult(LeftResult).Item(I).XPathStringValue >= StringResult.AsWideString then begin
            Result := TDomXPathBooleanResult.Create(True);
            RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
            Exit;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        RightResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
        Exit;
      end else if ( (LeftResult is TDomXPathNumberResult) or
                    (LeftResult is TDomXPathBooleanResult) or
                    (LeftResult is TDomXPathStringResult) ) and
                  (RightResult is TDomXPathNodeSetResult)
      then begin
        StringResult := XPathStringFunc(LeftResult);
        for I := 0 to Pred(TDomXPathNodeSetResult(RightResult).Length) do begin
          if StringResult.AsWideString >= TDomXPathNodeSetResult(RightResult).Item(I).XPathStringValue then begin
            Result := TDomXPathBooleanResult.Create(True);
            LeftResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
            Exit;
          end;
        end;
        Result := TDomXPathBooleanResult.Create(False);
        LeftResult := StringResult;  // Re-assignment is required for correct freeing the TDomXPathCustomResult below.
        Exit;
      end else begin
        LeftNumber := XPathNumberFunc(LeftResult);
        RightNumber := XPathNumberFunc(RightResult);
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
        ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
        try
{$ENDIF}
          if LeftNumber.AsNumber >= RightNumber.AsNumber
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
        finally
          SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
        except
          if (IsNaN(LeftNumber.AsNumber) and not IsNaN(RightNumber.AsNumber)) or
             (IsNaN(RightNumber.AsNumber) and not IsNaN(LeftNumber.AsNumber)) or
             (Sign(LeftNumber.AsNumber) <> Sign(RightNumber.AsNumber))
            then Result := TDomXPathBooleanResult.Create(True)
            else Result := TDomXPathBooleanResult.Create(False);
  {$ENDIF}
        end;
{$ENDIF}
        LeftResult := LeftNumber;    // Re-assignment is required for correct
        RightResult := RightNumber;  // freeing the TDomXPathCustomResult below.
      end;

    finally
      RightResult.Free;
      LeftResult.Free;
    end;
  end else if Left is TDomXPathAdditiveExpr then begin
    Result := TDomXPathAdditiveExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathPlusExpr }

function TDomXPathPlusExpr.Evaluate(const ContextNode: TDomNode;
                                    const ContextPosition,
                                          ContextSize: Integer): TDomXPathCustomResult;
var
  LeftNumber,RightNumber: TDomXPathNumberResult;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathAdditiveExpr) and (Right is TDomXPathMultiplicativeExpr) then begin
    RightNumber := nil; // Saves one try ... finally block.
    LeftNumber := XPathNumberFunc(TDomXPathAdditiveExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize));
    try
      RightNumber := XPathNumberFunc(TDomXPathMultiplicativeExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize));
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
      ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
      try
{$ENDIF}
        Result := TDomXPathNumberResult.Create(LeftNumber.AsNumber + RightNumber.AsNumber);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
      finally
        SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
      except
        Result := TDomXPathNumberResult.Create(NaN);
  {$ENDIF}
      end;
{$ENDIF}
    finally
      RightNumber.Free;
      LeftNumber.Free;
    end;
  end else if Left is TDomXPathMultiplicativeExpr then begin
    Result := TDomXPathMultiplicativeExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathMinusExpr }

function TDomXPathMinusExpr.Evaluate(const ContextNode: TDomNode;
                                     const ContextPosition,
                                           ContextSize: Integer): TDomXPathCustomResult;
var
  LeftNumber,RightNumber: TDomXPathNumberResult;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathAdditiveExpr) and (Right is TDomXPathMultiplicativeExpr) then begin
    RightNumber := nil; // Saves one try ... finally block.
    LeftNumber := XPathNumberFunc(TDomXPathAdditiveExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize));
    try
      RightNumber := XPathNumberFunc(TDomXPathMultiplicativeExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize));
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
      ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
      try
{$ENDIF}
        Result := TDomXPathNumberResult.Create(LeftNumber.AsNumber - RightNumber.AsNumber);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
      finally
        SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
      except
        Result := TDomXPathNumberResult.Create(NaN);
  {$ENDIF}
      end;
{$ENDIF}
    finally
      RightNumber.Free;
      LeftNumber.Free;
    end;
  end else if Left is TDomXPathMultiplicativeExpr then begin
    Result := TDomXPathMultiplicativeExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathMultiplyExpr }

function TDomXPathMultiplyExpr.Evaluate(const ContextNode: TDomNode;
                                        const ContextPosition,
                                              ContextSize: Integer): TDomXPathCustomResult;
var
  LeftNumber,RightNumber: TDomXPathNumberResult;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathMultiplicativeExpr) and (Right is TDomXPathUnaryExpr) then begin
    RightNumber := nil; // Saves one try ... finally block.
    LeftNumber := XPathNumberFunc(TDomXPathMultiplicativeExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize));
    try
      RightNumber := XPathNumberFunc(TDomXPathUnaryExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize));
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
      ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
      try
{$ENDIF}
        Result := TDomXPathNumberResult.Create(LeftNumber.AsNumber * RightNumber.AsNumber);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
      finally
        SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
      except
        Result := TDomXPathNumberResult.Create(NaN);
  {$ENDIF}
      end;
{$ENDIF}
    finally
      RightNumber.Free;
      LeftNumber.Free;
    end;
  end else if Left is TDomXPathUnaryExpr then begin
    Result := TDomXPathUnaryExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathDivExpr }

function TDomXPathDivExpr.Evaluate(const ContextNode: TDomNode;
                                   const ContextPosition,
                                         ContextSize: Integer): TDomXPathCustomResult;
var
  LeftNumber,RightNumber: TDomXPathNumberResult;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathMultiplicativeExpr) and (Right is TDomXPathUnaryExpr) then begin
    RightNumber := nil; // Saves one try ... finally block.
    LeftNumber := XPathNumberFunc(TDomXPathMultiplicativeExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize));
    try
      RightNumber := XPathNumberFunc(TDomXPathUnaryExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize));
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
      ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
      try
{$ENDIF}
        Result := TDomXPathNumberResult.Create(LeftNumber.AsNumber / RightNumber.AsNumber);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
      finally
        SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
      except
        Result := TDomXPathNumberResult.Create(NaN);
  {$ENDIF}
      end;
{$ENDIF}
    finally
      RightNumber.Free;
      LeftNumber.Free;
    end;
  end else if Left is TDomXPathUnaryExpr then begin
    Result := TDomXPathUnaryExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathModExpr }

function TDomXPathModExpr.Evaluate(const ContextNode: TDomNode;
                                   const ContextPosition,
                                         ContextSize: Integer): TDomXPathCustomResult;
var
  LeftNumber,RightNumber: TDomXPathNumberResult;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathMultiplicativeExpr) and (Right is TDomXPathUnaryExpr) then begin
    RightNumber := nil; // Saves one try ... finally block.
    LeftNumber := XPathNumberFunc(TDomXPathMultiplicativeExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize));
    try
      RightNumber := XPathNumberFunc(TDomXPathUnaryExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize));
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
      ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
      try
{$ENDIF}
        Result := TDomXPathNumberResult.Create(LeftNumber.AsNumber - Trunc(LeftNumber.AsNumber / RightNumber.AsNumber) * RightNumber.AsNumber);
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
      finally
        SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
      except
        Result := TDomXPathNumberResult.Create(NaN);
  {$ENDIF}
      end;
{$ENDIF}
    finally
      RightNumber.Free;
      LeftNumber.Free;
    end;
  end else if Left is TDomXPathUnaryExpr then begin
    Result := TDomXPathUnaryExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathUnaryExpr }

function TDomXPathUnaryExpr.Evaluate(const ContextNode: TDomNode;
                                     const ContextPosition,
                                           ContextSize: Integer): TDomXPathCustomResult;
var
  Number: TDomXPathNumberResult;
{$IFNDEF CLR}
  {$IFDEF VER250+}
  ExceptionMaskBackup: TArithmeticExceptionMask;
  {$ELSE !VER250+}
  {$IFDEF VER140+}
  ExceptionMaskBackup: TFPUExceptionMask;
  {$ENDIF VER140+}
  {$ENDIF VER250+}
{$ENDIF}
begin
  if (Left is TDomXPathMinusOperator) and (Right is TDomXPathUnaryExpr) then begin
    Number := XPathNumberFunc(TDomXPathUnaryExpr(Right).Evaluate(ContextNode, ContextPosition, ContextSize));
    try
{$IFDEF CLR}
  {$FINITEFLOAT OFF}
{$ELSE}
  {$IFDEF VER140+}
      ExceptionMaskBackup:= SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
      try
{$ENDIF}
        Result := TDomXPathNumberResult.Create(-(Number.AsNumber));
{$IFDEF CLR}
  {$FINITEFLOAT ON}
{$ELSE}
  {$IFDEF VER140+}
      finally
        SetExceptionMask(ExceptionMaskBackup);
  {$ELSE}
      except
        Result := TDomXPathNumberResult.Create(NaN);
  {$ENDIF}
      end;
{$ENDIF}
    finally
      Number.Free;
    end;
  end else if Left is TDomXPathUnionExpr then begin
    Result := TDomXPathUnionExpr(Left).Evaluate(ContextNode, ContextPosition, ContextSize);
  end else raise EXPath_Type_Err.Create('XPath type error.');
end;

{ TDomXPathLiteral }

function TDomXPathLiteral.Evaluate: TDomXPathCustomResult;
begin
  Result := TDomXPathStringResult.Create(Value);
end;

{ TDomXPathNumber }

function TDomXPathNumber.Evaluate: TDomXPathCustomResult;
begin
  Result := TDomXPathNumberResult.Create(XPathWideStringToNumber(Value));
end;

{ TDomXPathVariableReference }

{$IFDEF NEXTGEN}
constructor TDomXPathVariableReference.Create(const AOwner: TDomXPathSyntaxTree;
                                              const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathVariableReference.Create(const AOwner: TDomXPathSyntaxTree;
                                              const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  FPrefix := XmlExtractPrefix(Value);
  FLocalName := XmlExtractLocalName(Value);
end;

function TDomXPathVariableReference.Evaluate: TDomXPathCustomResult;
var
{$IFDEF NEXTGEN}
  NsUri: string;
{$ELSE !NEXTGEN}
  NsUri: WideString;
{$ENDIF NEXTGEN}
begin
  Result := nil;

  // Determine Namespace URI
  NsUri := LookupNamespaceURI(FPrefix);
  if (NsUri = '') and (FPrefix <> '') then
    raise ENamespace_Err.CreateFmt('Namespace URI of prefix ''%S'' not found.',
                                   [FPrefix]);

  if Assigned(OwnerSyntaxTree) then
    if Assigned(OwnerSyntaxTree.ContextNode) then
      if Assigned(OwnerSyntaxTree.ContextNode.OwnerDocument) then
        if Assigned(OwnerSyntaxTree.ContextNode.OwnerDocument.DomImplementation) then
          OwnerSyntaxTree.ContextNode.OwnerDocument.DomImplementation.DoRequestXPathVariable(OwnerSyntaxTree.OwnerXPathExpression, NsUri, FLocalName, Result);

  if not Assigned(Result) then
    raise EXPath_Exception.CreateFmt('No binding for variable $%s provided.',[Value]);
end;

{ TDomXPathNameTest }

{$IFDEF NEXTGEN}
constructor TDomXPathNameTest.Create(const AOwner: TDomXPathSyntaxTree;
                                     const Value: string);
{$ELSE !NEXTGEN}
constructor TDomXPathNameTest.Create(const AOwner: TDomXPathSyntaxTree;
                                     const Value: WideString);
{$ENDIF NEXTGEN}
begin
  inherited;
  if Value = '*' then begin
    FPrefix := '';
    FLocalName := '*';
  end else if Value[Length(Value)-AdjustIndex] = '*' then begin
    FPrefix := Copy(Value, 1,Length(Value)-2);
    FLocalName := '*';
  end else begin
    FPrefix := XmlExtractPrefix(Value);
    FLocalName := XmlExtractLocalName(Value);
  end;
end;

function TDomXPathNameTest.Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult;
                                    const PrincipalNodeType: TDomNodeType): TDomXPathNodeSetResult;
var
{$IFDEF NEXTGEN}
  NsUri: string;
{$ELSE !NEXTGEN}
  NsUri: WideString;
{$ENDIF NEXTGEN}
  I: Integer;
begin
  if not Assigned(OldSnapshotResult) then
    raise EXPath_Type_Err.Create('XPath type error.');

  if Value = '*' then begin
    I := Pred(OldSnapshotResult.Length);
    while I >= 0 do begin
      if OldSnapshotResult.Item(I).NodeType <> principalNodeType then
        OldSnapshotResult.Delete(I);
      Dec(I);
    end;
  end else begin
    // Determine Namespace URI
    if FPrefix = '' then
      NsUri := ''
    else begin
      NsUri := LookupNamespaceURI(FPrefix);
      if NsUri = '' then begin
{$IFNDEF AUTOREFCOUNT}
        OldSnapshotResult.Free;
{$ENDIF !AUTOREFCOUNT}
        raise ENamespace_Err.CreateFmt('Namespace URI of prefix ''%S'' not found.',
                                       [FPrefix]);
      end;
    end;

    if FLocalName = '*' then begin
      I := Pred(OldSnapshotResult.Length);
      while I >= 0 do begin
        //with OldSnapshotResult.Item(I) do
          if (OldSnapshotResult.Item(I).NodeType <> principalNodeType) or
             (OldSnapshotResult.Item(I).NamespaceURI <> NsUri) then
            OldSnapshotResult.Delete(I);
        Dec(I);
      end;
    end else begin
      I := Pred(OldSnapshotResult.Length);
      while I >= 0 do begin
        if (OldSnapshotResult.Item(I).NodeType <> principalNodeType) or
           (OldSnapshotResult.Item(I).NamespaceURI <> NsUri) or
           (OldSnapshotResult.Item(I).LocalName <> FLocalName) then
          OldSnapshotResult.Delete(I);
        Dec(I);
      end;
    end;
  end;

  Result := OldSnapshotResult;
end;

{ TDomXPathNodeTypeComment }

function TDomXPathNodeTypeComment.Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult;
var
  I: Integer;
begin
  if not Assigned(OldSnapshotResult) then
    raise EXPath_Type_Err.Create('XPath type error.');

  I := Pred(OldSnapshotResult.Length);
  while I >= 0 do begin
    if OldSnapshotResult.Item(I).NodeType <> ntComment_Node
      then OldSnapshotResult.Delete(I);
    Dec(I);
  end;

  Result := OldSnapshotResult;
end;

{ TDomXPathNodeTypePI }

function TDomXPathNodeTypePI.Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult;
var
  I: Integer;
begin
  if not Assigned(OldSnapshotResult) then
    raise EXPath_Type_Err.Create('XPath type error.');

  if Assigned(Left) then begin
    if Left is TDomXPathLiteral then begin
      I := Pred(OldSnapshotResult.Length);
      while I >= 0 do begin
        if (OldSnapshotResult.Item(I).NodeType <> ntProcessing_Instruction_Node) or
           (OldSnapshotResult.Item(I).NodeValue <> TDomXPathLiteral(Left).Value)
          then OldSnapshotResult.Delete(I);
        Dec(I);
      end;
    end else begin
{$IFNDEF AUTOREFCOUNT}
      OldSnapshotResult.Free;
{$ENDIF !AUTOREFCOUNT}
      raise EXPath_Type_Err.Create('XPath type error.');
    end;
  end else begin
    I := Pred(OldSnapshotResult.Length);
    while I >= 0 do begin
      if OldSnapshotResult.Item(I).NodeType <> ntProcessing_Instruction_Node
        then OldSnapshotResult.Delete(I);
      Dec(I);
    end;
  end;

  Result := OldSnapshotResult;
end;

{ TDomXPathNodeTypeText }

function TDomXPathNodeTypeText.Evaluate(const OldSnapshotResult: TDomXPathNodeSetResult): TDomXPathNodeSetResult;
var
  I: Integer;
begin
  if not Assigned(OldSnapshotResult) then
    raise EXPath_Type_Err.Create('XPath type error.');

  I := Pred(OldSnapshotResult.Length);
  while I >= 0 do begin
    if not (OldSnapshotResult.Item(I).NodeType in [ntText_Node, ntCDATA_Section_Node, ntEntity_Reference_Node] )
      then OldSnapshotResult.Delete(I);
    Dec(I);
  end;

  Result := OldSnapshotResult;
end;

end.
