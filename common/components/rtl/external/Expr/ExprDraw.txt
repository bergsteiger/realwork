Библиотека ExprDraw содержит классы, позволяющие отображать математические формулы. Библиотека
содержит классы, достаточные для отображения практически любой формулы. Имена всех классов имеют
префикс TExpr. Для отображения выражения необходимо построить дерево выражения, узлами и листьями
которого являются классы TExprXXXX. В простейшем случае (число, переменная) дерево состоит из одного
класса. Конкртеный класс для каждого узла дерева выбирается исходя из смысловой нагрузки, которую
узел несёт в формуле. Так, например, для отображения простой дроби используется класс TExprRatio,
имеющий две ветви: для числителя и знаменателя. Сами ветви также могут быть составными, глубина
дерева ограничивается только ресурсами компьютера. Таким образом, можно построить выражение практически
любой сложности.

Данное описание библиотеки ExprDraw не претендует на полноту, а лишь излагает основные принципы,
на которых базируется библиотека. В частности, не описываются многие второстепенные функции. Этого
вполне хватает для полноценного использования библиотеки, но её совершенсвование потребует более
детального знакомства с кодом.

-------------------------------------------------------------------------------------------------------

Иерархия классов библиотеки ExprDraw:

TExprClass
|-TExprParent
| |-TExprBigParent
| | |-TExprRatio
| | |-TExprRoot
| | |-TExprAtValue
| | |-TExprCommonFunc
| |   |-ExprFunc
| |-TExprChain
| | |-TExprBracketed
| |   |-TExprRound
| |   |-TExprArgument
| |   |-TExprBase
| |-TExprTwinParent
| | |-TExprIndex
| | |-TExprGroupOp
| |   |-TExprSumma
| |   |-TExprProd
| |   |-TExprCirc
| |   |-TExprIntegral
| |-TExprLim
| |-TExprCap
| |-TExprStand
| |-TExprMatrix
| |-TExprCase
|-TExprSimple
| |-TExprVar
| |-TExprCustomText
| |-TExprFuncName
| |-TExprAsterix
|-TExprNumber
| |-TExprExpNumber
|-TExprExtSymbol
| |-TExprPlank
| |-TExprSign
| |-TExprComma
| |-TExprLambda
| |-TExprNabla
|-TExprSpace
|-TExprStrokes
|-TExprEmpty

-------------------------------------------------------------------------------------------------------

Базовым классом для всех классов библиотеки ExprDraw является TExprClass. Он поддерживает следующую
функциональность: сообщает свои геометрические размеры (свойства Width и Height), параметры,
необходимые для более красивого отображения узла (свойства MidLineUp, MidLineDown, PowerXPos,
PowerYPos, IndexXPos, IndexYPos, CapDXRight, CapDXLeft, CapDY). Если узел не является корневым,
то поле FParent содержит указатель на родительский узел. Свойство Next используется для построения
цепочек классов. Изменение шрифта или канвы передаются далее по цепочке. Свойства Font и Canvas
используются для задания шрифта и канвы отображения. По умолчанию используется шрифт Times New Roman,
использование других гарнитур нежелательно, так как все размеры отсупов рассчитывались именно для
этой гарнитуры. Изменение стилей шрифта не имеет смысла, так как каждый узел сам устанавливает себе
стили, определяемые его смысловой нагрузкой. Единственный параметр шрифта, которым имеет смысл
управлять - это его размер. Размер задаётся только для корневого узла дерева, далее установки
передаются всем ветвям (узлы ветвей не обязательно получают такой же размер шрифта, что и корень: в
некоторых случаях предусмотрено изменение размеров шрифта дочерних узлов, например, при добавлении
верхнего или нижнего индекса). Канва также назначается корневому узлу и передаётся всем остальным
узлам. Геометрические размеры и параметры не могут быть вычислены до того, как дереву назначены
шрифт и канва. Параметры имеют следующий смысл:

MidLineUp, MidLineDown - расстояния (в пихелях) от средней линии до верхнего и нижнего края выражения.
Средняя линия - это линия, на которой должен стоять знак "-", если его поставить перед выражением.

PowerXPos, PowerYPos - если выражению добавляется верхний индекс, то эти параметры используются при
расчёте его положения.

IndexXPos, IndexYPos - аналогичная пара для нижнего индекса.

CapDXLeft, CapDXRight, CapDY - параметры, использующиеся для позиционирования диакритического знака
(вектора, тильды и т.п.), если он ставится над выражением.

Вычисление размеров и параметров выражения производится один раз с помощью функций с префиксом Calc,
далее оно сохраняется в переменной и повторное вычисление в целях оптимизации не производится.
Поле ToChange хранит флаги tcXXXX, которые показывают, какие параметры уже вычислены, а какие ещё
нет. Если происходят изменения, влияющие на значения параметров (например, меняется шрифт или канва),
соответсвующие флаги в ToChange взводятся, указывая, что параметры нужно вновь вычислять, а не
использовать сохранённые ранее значения.

Отображение выражения осуществляется с помощью функции Draw. В качестве параметров ей передаются
координаты и флаги выравнивания по горизонтали (констаны ehXXX) и вертикали (константы evXXXX).
Выравнивать можно по левому краю, правому краю и по центру (по горизонтали) и по верхнему краю,
нижнему краю и по средней линии (по вертикали). Отображение выражения реализуется виртуальной
функцией Paint. Эта функция вызывается функцией Draw после соответсвующих преобразований координат.

Функция FTType возвращает комбинацию флагов efXXXX, которые используются в библиотеке ExprMake при
перемножении выражений с помощью символа "*". Данные флаги показывают, может ли выражение быть
умножено без знака слева, справа, является ли оно числом и т.д.

Функция NeedBrackets возвращает True, если появление данного выражения в цепочке выражений вызывает
необходимость заключения данной цепочки в скобки при умножении её на другое выражение.

Функция ArgNeedBrackets возвращает True, если при использовании данного выражения в качестве имени
функции (см. класс TExprCommonFunc) аргумент должен заключаться в скобки.

Свойство Color определяет цвет, которым будет отображаться выражение. Если задан цвет clNone,
используется цвет родительского узла. Если для корневого узла задан цвет clNone, используется
чёрный цвет.

Поля WX, WY, RWX и RWY используются при вычислении размеров пропусков, линий и т.п. WX равено толщине
вертикальной линии знака "+", а WY - горизонтальной. В RWX и RWY хранятся величины, линейно зависящие
от размера шрифта. Эти величины используются при выводе выражений.


-------------------------------------------------------------------------------------------------------

Класс TExprParent является базовым классом для всех компонентов-родителей. Свойство Son этого класса
хранит указатель на дочерний узел дерева выражения. Создавать экземпляры TExprParent не имеет смысла,
так как вся функциональность этого класса сводится к управлению шрифтами и канвой дочернего выражения.

Дочернее выражение и выражение, на которое ссылается свойство Next, сильно различаются по смыслу.
Если класс включен в цепочку, организованную с помощью свойства Next, это никак не влияет на его
размеры и вид выражения, отображаемого с его помощью. Строго говоря, значение свойства Next никак
не используется самим классом, если не считать того, что канва, цвет и шрифт передаются далее по
цепочке. То, что классы объединены в цепочку, может использоваться родительским узлом первого класса
в цепочке. С другой стороны, выражение, задаваемое свойством Son, является неотъемлемой частью
выражения, определяемого самим классом. В качестве примера можно привести класс, реализующий
квадратный корень. Son указывает на подкоренное выражение. Когда, например, нужно вычислить размеры
выражения, этот класс вызывает Son.Width и Son.Height и прибавляет к полученным величинам размеры
знака извлечения корня. При вызове функции Draw этот класс рисует знак квадратного корня, а затем
вызывает Son.Draw для отображения подкоренного выражения. Таким образом, свойство Next используется
для организации цепочек классов, причём то, что класс входит в такую цепочку, им самим не используется.
А свойство Son используется для задания выражения, являющегося частью того выражения, которое
задаётся классом.

-------------------------------------------------------------------------------------------------------

Класс TExprBigParent является наследником класса TExprParent. В нём добавлена ссылка на ещё один
дочерний узел - свойство Daughter. Этот класс является базовым для реализации выражений, в которых
есть две составные части. Примером такого выражения может служить простая дробь, в которой одно из
дочерних выражений определяет числитель, а другое - знаменатель.

-------------------------------------------------------------------------------------------------------

Класс TExprTwinParent является наследником класса TExprParent. В нём добавлены указатели на два
дочерних узла-близнеца. Примером выражения, для которого может понадобиться такой класс, является
индексированное выражение. Son ссылается на то выражение, которому добавляются индексы, а Twin1 и
Twin2 - на верхний и нижний индексы.

-------------------------------------------------------------------------------------------------------

Класс TExprGroupOp является наследником класса TExprTwinParent. Это базовый класс для всех выражений
типа суммы или интеграла. Все эти выражения характеризуются строятся одинаково: Son указывает на
выражение, стоящее после знака суммы или интеграла, Twin1 - стоящее под знаком, Twin2 - над ним.
Twin1 и Twin2 могут быть равны nil одновременно или по одному. В этом случае под знаком и/или над
ним ничего не пишется.

-------------------------------------------------------------------------------------------------------

Класс TExprSimple служит для отображения плоского текста. Текст выводится прямым шрифтом.

-------------------------------------------------------------------------------------------------------

Класс TExprVar является наследником TExprSimple. Главное отличие - текст выводится не прямым шрифтом,
а курсивом, как это принято при отображении переменных в выражениях.

-------------------------------------------------------------------------------------------------------

Класс TExprCustomText является наследником TExprSimple. С его помощью можно вывести текст с любыми
атрибутами и любой гарнитурой.

-------------------------------------------------------------------------------------------------------

Класс TExprChain является наследником TExprParent. Этот класс служит для отображения цепочки выражений.
Первым в цепочке выводится Son, затем Son.Next, затем - Son.Next.Next и так далее, пока не будет
достигнут конец цепочки.

-------------------------------------------------------------------------------------------------------

Класс TExprBracketed является наследником TExprChain. Он выводит цепочку выражений, заключённую в
скобки. Возможны круглые, квадратные, фигурные и прямые скобки (задаются константами ebXXXX).
Скобки могут быть непарными (например, открывающая скобка круглая, а закрывающая - квадратная).
Возможен также вариант, когда скобка стоит только с одной стороны выражения. Выражение заключается
в скобки только в том случае, если функция IsBracketed возвращает True.

-------------------------------------------------------------------------------------------------------

Класс TExprRound является наследником TExprBracketed. Он переопределяет функцию FTType. Этот класс
используется библиотекой ExprMake при сокращении лишних скобок.

-------------------------------------------------------------------------------------------------------

Класс TExprArgument является наследником TExprBracketed. В нём переопределён конструктор таким образом,
чтобы скобки всегда были круглыми. Кроме того, переопределена функция IsBracketed таким образом, чтобы
она возвращала True только в том случае, если хотя бы один из узлов цепочки, на которую указывает
Son, нуждается в скобках (т.е. его функция NeedBrackets возвращает True). В скобках нуждаются,
например, узлы, реализующие знаки "+" и "-". Таким образом, если цепочка выражений представляет собой
сумму нескольких слагаемых, оно заключается в скобки, есди это произведение нескольких множителей -
не заключается. Это совпадает с тем, как записываются аргументы функций (например, cos 2x, но cos(x+y)).
Этот же класс используется для реализации отдельных множителей: если в составе множителя есть опреации
сложения или вычитания, он заключается в скобки, если нет, то не заключается.

В класс также добавлена функция SetBrackets, которая заставляет рисовать скобки независимо от того,
есть ли в цепочке нуждающиеся в скобках узлы.

Если класс TExprArgument используется как аргумент функции (в этом случае его родительский узел
является экземпляром класса TExprCommonFunc), то вызывается соответсвующая функция родительского
класса для определения, нужны ли скобки аргументу.

При построении дерева вручную для конкретного выражения всегда заранее известно, нужно ли заключать
какие-то его части в скобки или нет. В этом случае лучше использовать классы TExprBracketed и
TExprChain. Но при автоматизированном построении дерева (например, с помощью библиотеки ExprMake)
данный класс может быть очень полезным.

-------------------------------------------------------------------------------------------------------

Класс TExprBase является наследником TExprBracketed. Он отображает выражение, заключённое в круглые
скобки, если цепочка, на которую указывает Son, содержит более одного узла. В противном случае
выражение в скобки не заключается. Это совпадает с тем, как должна отображаться база при возведении
в степень (например, x^2, но (2x)^2).

Класс TExprBase, как и TExprArgument, предназначен только для автоматизации построения дерева.

-------------------------------------------------------------------------------------------------------

Класс TExprRatio является наследником класса TExprBigParent. Реализует простую дробь. Son указывает на
числитель, Daughter - на знаменатель.

-------------------------------------------------------------------------------------------------------

Класс TExprRoot является наследником класса TExprBigParent. Реализует извлечение корня. Son указывает
на подкоренное выражение, Daughter - на показатель степени корня. Для Daughter допускается значение
nil. В этом случае показатель степени перед корнем не ставится (квадратный корень).

-------------------------------------------------------------------------------------------------------

Класс TExprAtValue является наследником класса TExprBigParent. Реализует "значение при условии".
Отображается это следующим образом: после выражения, на которое указывает Son, ставится вертикальная
черта, а справа от неё внизу пишется выражение, на которое указывает Daughter.

-------------------------------------------------------------------------------------------------------

Класс TExprCommonFunc является наследником класса TExprBigParent. Он реализует "общую" функцию,
в качестве "имени" которой может использоваться любое выражение. Son указывает на "имя" функции,
Daughter - на её аргумент.

-------------------------------------------------------------------------------------------------------

Класс TExprFuncName является наследником класса TExprSimple. Он реализует имя функции в том случае,
когда оно пишется прямым шрифтом. Переопределена функция ArgNeedBrackets таким образом, чтобы аргумент
не заключался в скобки, если это не является необходимым. Чтобы аргумент мог воспользоваться
результатом, возвращаемым функцией TExprFuncName.ArgNeedBrackets, он должен иметь тип TExprArgument.

-------------------------------------------------------------------------------------------------------

Класс TExprFunc является наследником TExprCommonFunc. Он реализует традиционную функцию, имя которой
является обычной комбинацией букв. Конструктор сам создаёт класс нужного типа для отображения имени
функции. Если имя имеет длину 1 символ, то используется класс TExprVar, если оно длиннее - класс
TExprFuncName. В первом случае имя функции пишется курсивом, а аргумент всегда заключается в скобки,
так как в классе TExprVar функция ArgNeedBrackets не переопределена соответствующим образом. Во втором
случае имя функции пишется прямым шрифтом, а аргумент заключается в скобки лишь при необходимости.

-------------------------------------------------------------------------------------------------------

Класс TExprLim является наследником TExprParent. Этот класс реализует знак предела (lim), а под ним -
выражение, на которое указывает Son. Класс разработан для совместного использования с TExprCommonFunc:
TExprCommonFunc.Son указывает на экземпляр TExprLim, а TExprCommonFunc.Daughter - на выражение, для
которого вычисляется предел.

-------------------------------------------------------------------------------------------------------

Класс TExprSumma является наследником TExprGroupOp. Реализует сумму (с помощью греческой буквы сигма).

-------------------------------------------------------------------------------------------------------

Класс TExprProd является наследником TExprGroupOp. Реализует произведение (с помощью греческой буквы
пи).

-------------------------------------------------------------------------------------------------------

Класс TExprCirc является наследником TExprGroupOp. Реализует циркуляцию (интеграл с колечком).

-------------------------------------------------------------------------------------------------------

Класс TExprIntegral яаляется наследником TExprGroupOp. Реализует однократный или многократный
интеграл. Параметр коснтруктора Mult задаёт кратность интеграла. Если Mult<=0, рисуется символ
интеграла неопределённой кратности (два символа интеграла, многоточие, ещё один символ интеграла).

-------------------------------------------------------------------------------------------------------

Класс TExprExtSymbol используется для отображения одиночных символов, которых нет в стандартной
кодировке ANSI. В TExprExtSymbol используется кодировка Unicode. Символы выводятся прямым шрифтом.

Для простоты определены константы, содержащие коды часто используемых символов:
esPlus - знак "+"
esMinus - знак "-" (минус, а не дефис!)
esLess - знак "<"
esEqual - знак "="
esGreater - знак ">"
esNotEqual - знак "не равно"
esMultiply - знак умножения в виде точки
esLessOrEqual - знак "меньше или равно"
esGreaterOrEqual - знак "больше или равно"
esApproxEqual - знак "примерно равно"
esCrossMultiply - знак умножения в виде косого креста
esDivide - знак деления в виде черты и точек снизу и сверху.
esTilde - знак тильды
esEquivalent - знак "тождественно"
esArrow - стрелка слева направо (знак "стремится к")
esSlash - деление в виде косой черты
esEllipsis - многоточие
esInfinum - бесконечность
esPartDiff - знак "частного дифференциала" (округлая d)

-------------------------------------------------------------------------------------------------------

Класс TExprPlank является наследником TExprExtSymbol. Предназначен для отображения "h с чертой",
которая часто используется в квантовой механике. Выводится курсивом.

-------------------------------------------------------------------------------------------------------

Класс TExprLambda является наследником TExprExtSymbol. Предназначен для отображения "лямбды с чертой",
которая часто используется в квантовой механике. Такой символ отсутсвует в наборе Unicode, поэтому
черта к лямбде пририсовывается вручную.

-------------------------------------------------------------------------------------------------------

Класс TExprNabla является наследником TExprExtSymbol. Предназначен для отображения символа "набла".
Такой символ отсутсвует в кодировке Unicode, поэтому для отображения используется заглавная греческая
дельта, повёрнутая на 180 градусов.

-------------------------------------------------------------------------------------------------------

Класс TExprComma является наслдеником TExprExtSymbol. Предназначен для отображения запятой.
Переопределена функция NeedBrackets (чтобы выражения, содержащие запятую, заключались при необходимости
в скобки).

-------------------------------------------------------------------------------------------------------

Класс TExprSign является наследником TExprExtSymbol. Предназначен для отображения различных символов,
в том числе и тех, которых нет в кодировке Unicode. Некоторыеиз таких символов получаются из имеющихся
путём пририсовки недостающих элементов, некоторые рисуются целиком.

При автоматическом построении выражений даже для простых символов (например, "+", "-" и т.д.)
рекомендуется пользоваться классом TExprSign, а не TExprExtSymbol или TExprSimple. Связано это с тем,
что TExprSign переопределяет функцию NeedBrackets, которая помогает правильно расставить скобки.

Для расширенных символов определены следующие константы:
esMuchLess - знак "много меньше" (<<)
esMuchGreater - знак "много больше" (>>)
esApproxLess - знак "меньше или порядка" (знак "меньше" с тильдой под ним)
esApproxGreater - знак "больше или порядка" (знак "больше" с тильдой под ним)
esPlusMinus - знак "плюс-минус"
esMinusPlus - знак "минус-плюс"
esAlmostEqual - знак "равно или порядка" (знак равенства с тильдой над ним)
esParallel - знак "параллельно" (две вертикальные черты)
esPerpendicular - знак "перпендикулярно" (горизонтальная черта внизу и вертикальная посередине)
esAngle - знак угла

-------------------------------------------------------------------------------------------------------

Класс TExprNumber предназначен для отображения чисел в обычной или экспоненциальной форме. Если
параметр конструктора ExpVal равен True, используется экспоненциальная форма, в противном случае -
обычная.

-------------------------------------------------------------------------------------------------------

Класс TExprExpNumber является наследником TExprNumber. Служит для отображения чисел с возможностью
гибкого управления форматированием числа.

-------------------------------------------------------------------------------------------------------

Класс TExprIndex является наследником TExprTwinParent. Используется для отображения выражений с верхним
или нижним индексом. Son указывает на выражение, которому добавляются индексы, Twin1 - нижний индекс,
Twin2 - верхний индекс. Twin1 или Twin2 могут быть равны nil - в этом случае выражению добаляется
только один индекс. Верхний индекс также используется как показатель степени.

-------------------------------------------------------------------------------------------------------

Класс TExprCap является наследником TExprParent. Рисует над выражением, на которое указывает Son,
диакритический знак. Возможны следующие знаки:

ecPoints - точки, обозначающие производную по времени
ecVector - стрелка, обозначающая вектор
ecCap - "крышка" (^)
ecTilde - тильда (~)
ecLine - прямая линия

Конструктор содержит параметр Count, который задаёт число точек при стиле ecPoints. При прочих стилях
этот параметр игнорируется.

-------------------------------------------------------------------------------------------------------

Класс TExprStand является наследником TExprParent. Предназначен для вывода нескольких выражений в
виде столбика. Первым выводится выражение, на которое указывает Son, под ним - Son.Next, ещё ниже -
Son.Next.Next и так далее до конца цепочки. Параметр конструктора Align показывает, будут ли выражения
выравниваться по левому краю, по правому краю или по центру.

-------------------------------------------------------------------------------------------------------

TExprMatrix является наследником TExprParent. Предназначен для вывода матрицы. Размеры матрицы
определяются параметрами конструктора HorSize и VertSize. Левый верхний элемент матрицы задаётся
выражением Son, второй слева в верхней строке - Son.Next и так далее слева направо сверху вниз. Если
цепочка длиннее, чем HorSize*VertSize, при отображении матрицы лишние элементы игнорируются (однако
они не игнорируются при подсчёте размеров ячейки матрицы, что может привести к искажению вида матрицы).
Если цепочка содержит меньше элементов, чем HorSize*VertSize, ячейки, на которые не хватило узлов,
будут пустыми.

-------------------------------------------------------------------------------------------------------

Класс TExprCase является наслдеником TExprParent. Этот класс используется для отображения вариантной
конструкции: несколько выражений обводятся слева фигурной скобкой, после каждого ставится условие,
когда данный вариант используется. Son указывает на первый вариант, Son.Next - на условие его
применимости, Son.Next.Next - на второй вариант, Son.Next.Next.Next - на условие его применимости
и т.д. Если цепочка содержит нечётное число узлов, последний вариант остаётся без условия.

-------------------------------------------------------------------------------------------------------

Класс TExprAsterix является наследником класса TExprSimple. Предназначен для отображения звёздочки (*),
смещённой по горизонтали. Эта звёздочка используется в качестве верхнего индекса (в квантовой механике
звёздочкой в верхнем индексе принято обозначать сопряжённые величины).

-------------------------------------------------------------------------------------------------------

Класс TExprSpace предназначен для разрядки, вставки в формулу пустого пространства. Параметр
конструктора Space задаёт ширину этого пробела в единицах ширины (одна единица ширины примерно равна
ширине вертикальной линии в символе "+").

-------------------------------------------------------------------------------------------------------

Класс TExprStrokes предназначен для отображения чёрточек, которыми обозначается производная.
Используется совместно с классом TExprIndex: функция задаётся в TExprIndex.Son, TExprStrokes
используется как верхний индекс.

-------------------------------------------------------------------------------------------------------

Класс TExprEmpty используется для отображения выражения с нулевой шириной, но высотой, равной высоте
обычного текста. Используется вместе с TExprIndex для создания индексов, "висящих в воздухе".

-------------------------------------------------------------------------------------------------------

Примеры использования библиотеки ExprDraw.

Пример 1.
                   c
Выражение вида a+b(-+1) (используется простая дробь).
                   d

var Expr,Expr2:TExprClass;
 begin
  Expr:=TExprRatio.Create(TExprVar.Create('c'),TExprVar.Create('d'));
  // Теперь Expr содержит дробь c/d
  Expr.AddNext(TExprSign.Create(esPlus));
  Expr.AddNext(TExprNumber.Create(1));
  // Теперь Expr является началом цепочки, в которой есть ещё знак "+" и единица
  Expr:=TExprBracketed.Create(Expr,ebRound,ebRound);
  // Теперь Expr содержит выражение, которое заключено в скобки
  Expr2:=TExprVar.Create('a');
  Expr2.AddNext(TExprSign.Create(esPlus));
  Expr2.AddNext(TExprVar.Create('b'));
  Expr2.AddNext(Expr);
  // Теперь Expr2 содержит всю цепочку выражений, которая нам нужна.
  Expr:=TExprChain.Create(Expr2);
  // Еспользуем класс TExprChain, предназначенный для отображения цепочки как единого целого.
  // Построение дерева выражения закончено.

  Expr.Font.Size:=12;
  // Теперь размер шрифта установлен

  Expr.Canvas:=Form1.Canvas;
  Expr.Draw(5,5,ehLeft,evTop);
  // Для отображения выражения на форме нужно установить его канву и вызвать Draw

  Printer.BeginDoc;
  Expr.Canvas:=Printer.Canvas;
  Expr.Draw(50,50,ehLeft,evTop);
  Printer.EndDoc;
  // Можно поменять канву и отобразить это же выражение на другом устройстве

  Expr.Canvas:=Form1.Canvas;
  Expr.Font.Height:=24;
  Expr.Draw(Form1.ClientWidth-5,Form1.ClientHeight-5,ehRight,evBottom);
  // Можно поменять шрифт и снова вернуться к канве формы (или перейти к любой другой канве


  Expr.Free
  // После использования нужно очистить дерево. Деструктор автоматически вызывает деструкторы
  // для всех узлов дерева. Expr2.Free в данном случае вызывать не нужно, так как дерево Expr2
  // стало частью дерева Expr, поэтому при вызове Expr.Free оно также будет очищено.
 end;

В данном примере, кроме собственно построения дерева выражения, показано, как это дерево потом
использовать. Однако простейший способ, показанный здесь, не всегда позволяет достичь требуемой
производительности. Каждый раз при смене канвы и шрифта приходится заново рассчитывать все размеры
выражения, поэтому менять их нужно как можно реже. Кроме того, даже если все размеры уже рассчитаны,
вывод формулы также происходит сравнительно медленно. Если формула предназначена для многократного
отображения только на экране, лучше построить дерево один раз, вывести формулу на TBitmap, затем
освободить дерево формулы, а затем каждый раз отображать полученный растр.

Следует также отметить, что после вызова TExprClass.Draw обычно меняется перо, кисть и шрифт,
выбранные в данной канве. Если отображение формул перемежается выводом графических примитивов,
каждый раз после вызова Draw следует заново восстанавливать кисть, перо и шрифт.


Пример 2.
Выражение "игрек равно корень третьей степени из икс минус 1"

var Expr,Expr2:TExprClass;
 begin
  Expr:=TExprVar.Create('x');
  Expr.AddNext(TExprSign.Create(esMinus));
  Expr.AddNext(TExprNumber.Create(1,False));
  Expr:=TExprChain.Create(Expr);
  Expr2:=TExprVar.Create('y');
  Expr2.AddNext(TExprSign.Create(esEqual));
  Expr2.AddNext(TExprRoot.Create(Expr,TExprNumber.Create(3,False)));
  Expr:=TExprChain.Create(Expr2);
  // Дерево построено, здесь должен быть код, отображающий его
  Expr.Free
 end;


Пример 3.
Вырежение "игрек равно е в степени икс"

var Expr:TExprClass;
 begin
  Expr:=TExprVar.Create('y');
  Expr.AddNext(TExprSign.Create(esEqual));
  Expr.AddNext(TExprIndex.Create(TExprVar.Create('e'),nil,TExprVar.Create('x')));
  Expr:=TExprChain.Create(Expr);
  // Дерево построено, здесь должен быть код, отображающий его
  Expr.Free
 end;

Пример 4.
Выражение "Косинус квадрат фи плюс синус квадрат фи равно единице"

var Expr,Expr2:TExprClass;
 begin
  Expr2:=TExprIndex.Create(TExprSimple.Create('cos'),nil,TExprNumber.Create(2,False));
  // Expr2 содержит "косинус квадрат"
  Expr:=TExprCommonFunc.Create(Expr2,TExprExtSymbol.Create(966));
  // Expr содержит общую функцию, в которой "именем" является "косинус квадрат", а аргументом - фи
  // (966 - код строчной фи в кодировке Unicode)
  Expr.AddNext(TExprSign.Create(esPlus));
  Expr2:=TExprIndex.Create(TExprSimple.Create('sin'),nil,TExprNumber.Create(2,False));
  Expr.AddNext(TExprCommonFunc.Create(Expr2,TExprExtSymbol.Create(966)));
  Expr.AddNext(TExprSign.Create(esEqual));
  Expr.AddNext(TExprNumber.Create(1,False));
  Expr:=TExprChain.Create(Expr);
  // Дерево построено, здесь должен быть код, отображающий его
  Expr.Free
 end;


Пример 5
Билинейная форма

var Expr,Expr2:TExprClass;
 begin
  Expr:=TExprIndex.Create(TExprVar.Create('a'),TExprVar.Create('ij'),nil);
  Expr.AddNext(TExprIndex.Create(TExprVar.Create('x'),TExprVar.Create('i'),nil));
  Expr.AddNext(TExprIndex.Create(TExprVar.Create('x'),TExprVar.Create('j'),nil));
  Expr:=TExprChain.Create(Expr);
  Expr2:=TExprVar.Create('j');
  Expr2.AddNext(TExprSign.Create(esEqual));
  Expr2.AddNext(TExprNumber.Create(1,False));
  Expr2:=TExprChain.Create(Expr2);
  Expr:=TExprSumma.Create(Expr,Expr2,TExprVar.Create('n'));
  Expr2:=TExprVar.Create('i');
  Expr2.AddNext(TExprSign.Create(esEqual));
  Expr2.AddNext(TExprNumber.Create(1,False));
  Expr2:=TExprChain.Create(Expr2);
  Expr:=TExprSumma.Create(Expr,Expr2,TExprVar.Create('n'));
  // В данном случае цепочка, на которую указывает Expr, состоит из одного узла, поэтому
  // использовать класс TExprChain не нужно.
  // Дерево построено, здесь должен быть код, отображающий его
  Expr.Free
 end;


Пример 6
Выражение "предел 1/х при х, стремящемся к 0, равен плюс-минус бесконечности"

var Expr,Expr2:TExprClass;
 begin
  Expr2:=TExprVar.Create('x');
  Expr2.AddNext(TExprSign.Create(esArrow));
  Expr2.AddNext(TExprNumber.Create(0,False));
  Expr2:=TExprChain.Create(Expr2);
  Expr2:=TExprLim.Create(Expr2);
  Expr:=TExprRatio.Create(TExprNumber.Create(1,False),TExprVar.Create('x'));
  Expr:=TExprCommonFunc.Create(Expr2,Expr);
  Expr.AddNext(TExprSign.Create(esEqual));
  Expr.AddNext(TExprSign.Create(esPlusMinus));
  Expr.AddNext(TExprExtSymbol.Create(esInfinum));
  Expr:=TExprChain.Create(Expr);
  // Дерево построено, здесь должен быть код, отображающий его
  Expr.Free
 end;


Пример 7
Производная произведения функций

var Expr,Expr2:TExprClass;
 begin
  Expr2:=TExprFunc.Create('f',TExprBracketed.Create(TExprVar.Create('x'),ebRound,ebRound));
  Expr2.AddNext(TExprFunc.Create('g',TExprBracketed.Create(TExprVar.Create('x'),ebRound,ebRound)));
  Expr2:=TExprBracketed.Create(Expr2,ebRound,ebRound);
  Expr:=TExprIndex.Create(Expr2,nil,TExprStrokes.Create(1));
  Expr.AddNext(TExprSign.Create(esEqual));
  Expr2:=TExprIndex.Create(TExprVar.Create('f'),nil,TExprStrokes.Create(1));
  Expr2:=TExprCommonFunc.Create(Expr2,TExprBracketed.Create(TExprVar.Create('x'),ebRound,ebRound));
  Expr.AddNext(Expr2);
  Expr.AddNext(TExprFunc.Create('g',TExprBracketed.Create(TExprVar.Create('x'),ebRound,ebRound)));
  Expr.AddNext(TExprSign.Create(esPlus));
  Expr.AddNext(TExprFunc.Create('f',TExprBracketed.Create(TExprVar.Create('x'),ebRound,ebRound)));
  Expr2:=TExprIndex.Create(TExprVar.Create('g'),nil,TExprStrokes.Create(1));
  Expr2:=TExprCommonFunc.Create(Expr2,TExprBracketed.Create(TExprVar.Create('x'),ebRound,ebRound));
  Expr.AddNext(Expr2);
  Expr:=TExprChain.Create(Expr);
  // Дерево построено, здесь должен быть код, отображающий его
  Expr.Free
 end;

-------------------------------------------------------------------------------------------------------

Пример неправильного построения дерева выражения

Если выражение содержит повторяющиеся части, один и тот же узел не должен использоваться в нескольких
местах. Иначе возникнут проблемы при изменении шрифта, а при освобождении дерева этот узел программа
попытается освободить дважды, и в результате возникнет Access Violation.

Проиллюстрируем это правило на примере выражения e^x+x:

Пример неправильного построения дерева:

Expr2:=TExprVar.Create('x');
Expr:=TExprIndex.Create(TExprVar.Create('e'),nil,Expr2); // Expr2 используется первый раз
Expr.AddNext(TExprSign.Create(esPlus));
Expr.AddNext(Expr2); // Expr2 используется во второй раз
Expr:=TExprChain.Create(Expr);

Правильно будет создать ещё один узел для отображения "х", а не использовать повторно имеющийся.

Правильный пример:

Expr2:=TExprVar.Create('x');
Expr:=TExprIndex.Create(TExprVar.Create('e'),nil,Expr2);
Expr.AddNext(TExprSign.Create(esPlus));
Expr2:=TExprVar.Create('x'); // Чтобы не использовать узел повторно, создаём другой такой же
Expr.AddNext(Expr2);
Expr:=TExprChain.Create(Expr);
