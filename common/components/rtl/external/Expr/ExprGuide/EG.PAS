unit EG;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, ExtCtrls, ExprDraw, ExprMake, Printers, Buttons;

type TArticle=record
               Title:string;
               Samples:array of string;
               Desc:string
              end;

  TFormGuide = class(TForm)
    ListBox: TListBox;
    Memo: TMemo;
    ScrollBox1: TScrollBox;
    Image: TImage;
    BtnPrint: TBitBtn;
    procedure FormCreate(Sender: TObject);
    procedure ListBoxClick(Sender: TObject);
    procedure BtnPrintClick(Sender: TObject);
   private
    Arts:array of TArticle;
    Index:Integer;
    procedure Add(Tlt,D:string;Smpls:array of string);
    procedure MakePict;
   public
  end;

var
  FormGuide: TFormGuide;

implementation

procedure TFormGuide.Add;
 var I:Integer;
  begin
   SetLength(Arts,Length(Arts)+1);
   with Arts[High(Arts)] do
    begin
     Title:=Tlt;
     Desc:=D;
     SetLength(Samples,Length(Smpls));
     for I:=Low(Smpls) to High(Smpls) do
      Samples[I]:=Smpls[I]
    end;
   I:=ListBox.Items.Add(Tlt);
   SendMessage(ListBox.Handle,LB_SetItemData,I,High(Arts))
  end;

{$R *.DFM}

procedure TFormGuide.FormCreate(Sender: TObject);
 begin
  Add('Простые выражения','К простым выражениям относятся идентификаторы, токены и цифровые константы. Токены - это зарезервированные слова, использующиеся для обозначения специальных символов (пример 1).'+' Регистр символов при написании токенов не важен за исключением токенов, обозначающих греческие буквы. Если первый символ такого токена имеет верхний регистр,'+' то получается заглавная буква, если нижний - строчная. Идентификаторы воспроизводятся так, как они написаны в тексте. Идентификаторы могут состоять из английских и русских букв и цифр,'+' причём начинаться идентификатор должен с буквы. Если идентификатор начинается с английской буквы, он выводится наклонным шрифтом (пример 2), если с русской - прямым (пример 3). Вывести английский текст прямым шрифтом можно с помощью функции String'+' Если в конце идентификатора стоят цифры, а TExprBuilder.VarAutoIndex=True (по умолчанию), то они рассматриваются как нижний индекс (пример 4).'+
                          ' Если цифры стоят после токена, то они также рассматриваются как нижний индекс (пример 5).'+
                          ' Цифровые константы записываются в обычном для Паскаля синтаксисе (пример 6). Допускается использование английской "e" или "E" для обозначения экпоненциальной части числа.'+' Оптимальный формат вывода числа подбирается автоматически. Если он по каким-то причинам не устраивает, можно воспользоваться символом "#" или функцией Num.',['Alpha, alpha','EnglEnc','РУС','x12','beta0','1.234,0.7e9,1234678']);
  Add('Функции','Функцией считается текст, после которого в скобках стоит один или несколько аргументов. Существуют зарезервированные имена функций, которые используются для специальных целей. Все зарезервированные функции описаны в данном справочнике.'+
                ' При описании используется следующие условные обозначения: E, E1, E2 и т. д. - произвольные выражения, m, n, n1, n2 и т. д. - целочисленные константы, R - вещественная константа. Имена зарезервированных функций нечувствительны к регистру символов.'+
                ' Если имя функции не является зарезервированным словом, результат зависит от длины имени. Имена функций, состоящие из одного символа, выводятся курсивом, а их аргументы всегда заключаются в круглые скобки (пример 1).'+
                ' Более длинные имена функций выводятся прямым шрифтом, а их аргументы заключаются в скобки только при необходимости (пример 2). Можно принудительно заключить аргумент в скобки, используя вместо открывающей скобки комбинацию "!(" (пример 3).'+
                ' При возведении функции в степень или присоденении к ней индекса знаки соответсвующих операций должны стоять после аргумента (пример 4).'+
                ' Цифры, стоящие в конце имени функции, интерпретируются как нижний индекс, если TExprBuilder.FuncAutoIndex=True (по умолчанию; пример 5).'+
                ' В качестве имён функций можно использовать токены, обозначающие греческие буквы, а также токены Nabla и PLambda. В этом случае цифры в конце также интерпретируются как нижний индекс (пример 6).',['f(x,y,z)','cos(x), sin(pi/2+x), tg(1/x)','cos!(x)','f(x)_n,cos(x)^2','f0(x)=g1(x)','gamma0(x)']);
  Add('Выражения','Выражения состоят из операндов, разделённых знаками сравнения, операнды - из слагаемых, разделённых знаками сложения и вычитания, слагаемые - из множителей, разделённых знаками умножения и деления.'+
                  ' В примере 1 "a" и "b+c/d" - операнды, "b" и "c/d" - слагаемые, "c" и "d" - множители. Множители могут быть одного из следующих видов:'+
                  #13#10'1. Числовая константа (в том числе начинающаяся с символа "#", идентификатор или токен'+
                  #13#10'2. Выражение, заключенное в круглые, квадратные, прямые или фигурные скобки.'+
                  #13#10'3. Функция.'+
                  #13#10'Перед множителем может стоять символ "_", обозначающий вектор, и/или символы "+", "-", "+-", "-+", обозначающие соответсвующие унарные операции.'+
                  ' Если TExBuilder.PostSymbols=True (по умолчанию), после множителя могут стоять символы "_", "^", "!" или "`". Несколько выражений могут склеиваться в одно при помощи символа "&" или запятой.',['a=b+c/d','B_(2*k)=((-1)^(n-1)**2*(2*k)!/(2*pi)^(2*k))*summa(1/n^(2*k),n=1,inf)','line(u_i^2)=(2*plank^2/M/k/Theta)*((T^2/Theta^2)*int(x*diff(x)/(e^x-1),0,T//Theta)+1/4)','a0=(r2^2*(r2-3*r1)*V1(r1)-r1^2*(r1-3*r2)*V3(r2)-(r2*strokes(V1(r1))+r1*strokes(V3(r2)))*r1*r2*(r2-r1))/(r2-r1)^3','int(phi*cap(p)_x*psi*diff(x))=-i*plank*int(phi*pdiffrf(psi,x)*diff(x))=i*plank*int(psi*pdiffrf(phi,x)*diff(x))=int(psi*cap(p)_x^asterix*phi*diff(x))','grad(U)=lim(v->0,circ(U*diff(_S),Sigma)/v) & space(15) & div(_V)=lim(v->0,int(_V*diff(_S),Sigma)/v) & space(15) & rot(_V)=-lim(v->0,int(_V*+d*_S,Sigma)/v)','P(x)=summa(prod((x-x_j)/(x_i-x_j),standc(j=0,j<>i),n),i=0,n)']);
  Add('Единицы ширины','Единицы ширины, использующиеся в некоторых зарезервированных функциях для указания размера пробела, подобраны так, что одна единица ширины примерно равна толщине вертикальной линии в символе "+".',['a&space(20)&b']);
  Add('Токен ...','Многоточие.',['f(x1,x2,...,x_n)=0']);
  Add('Токен Alpha','Греческая буква альфа',['Alpha','alpha']);
  Add('Токен Beta','Греческая буква бета',['Beta','beta']);
  Add('Токен Gamma','Греческая буква гамма',['Gamma','gamma']);
  Add('Токен Delta','Греческая буква дельта',['Delta','delta']);
  Add('Токен Epsilon','Греческая буква эпсилон',['Epsilon','epsilon']);
  Add('Токен Zeta','Греческая буква зета',['Zeta','zeta']);
  Add('Токен Eta','Греческая буква ета',['Eta','eta']);
  Add('Токен Theta','Греческая буква тета',['Theta','theta']);
  Add('Токен Iota','Греческая буква йота',['Iota','iota']);
  Add('Токен Kappa','Греческая буква каппа',['Kappa','kappa']);
  Add('Токен Lambda','Греческая буква лямбда',['Lambda','lambda']);
  Add('Токен Mu','Греческая буква мю',['Mu','mu']);
  Add('Токен Nu','Греческая буква ню',['Nu','nu']);
  Add('Токен Xi','Греческая буква кси',['Xi','xi']);
  Add('Токен Omicron','Греческая буква омикрон',['Omicron','omicron']);
  Add('Токен Pi','Греческая буква пи',['Pi','pi']);
  Add('Токен Rho','Греческая буква ро',['Rho','rho']);
  Add('Токен Sigma','Греческая буква сигма',['Sigma','sigma']);
  Add('Токен Tau','Греческая буква тау',['Tau','tau']);
  Add('Токен Upsilon','Греческая буква упсилон',['Upsilon','upsilon']);
  Add('Токен Phi','Греческая буква фи',['Phi','phi']);
  Add('Токен Chi','Греческая буква хи',['Chi','chi']);
  Add('Токен Psi','Греческая буква пси',['Psi','psi']);
  Add('Токен Omega','Греческая буква омега',['Omega','omega']);
  Add('Токен Inf','Символ бесконечности',['lim(x->0,1/x)=+-Inf']);
  Add('Токен Plank','Постоянная Планка с чертой',['Plank=h/2/pi']);
  Add('Токен Nil','Пустое выражение, имеющее нулевые размеры. Используется там, где по синтаксису должно быть выражение, но в конкретном случае требуется, чтобы его не было.',['lim(nil,f(x))=0']);
  Add('Токен Comma','Вставляет в текст запятую. В большинстве случаев может быть заменена символом "," или функцией Comma.',['x&comma&y']);
  Add('Токен Const','Слово const, обозначающее произвольную константу. В отличие от обычных идентификаторов, пишется прямым шрифтом, а не курсивом.',['Int(x*Diff(x))=x^2/2+const']);
  Add('Токен Asterix','Символ "*", несколько опущенный вниз по сравнению с обычным положением. Предназначен для использования в верхних индексах.',['Summa(a_n*a_n^Asterix,n)=Int(Psi*Psi^Asterix*Diff(q))']);
  Add('Токен Minus','Знак "минус". Предназначен для использования преимущественно в индексах. Прочие знаки ("+", "=" и т. п.) можно отобразить с помощью функции String.'+' Но выражение String(-) даст не минус, а дефис, который существенно короче (в кодировке Unicode минус и дефис - это разные символы).',['a_Minus<>a_String(-)']);
  Add('Токен Parallel','Знак параллельности.',['_a & Parallel & _b','H_Parallel']);
  Add('Токен Perpendicular','Знак перпендикулярности.',['_a & Perpendicular & _b','v_Perpendicular']);
  Add('Токен Angle','Знак угла',['Angle**A']);
  Add('Токен Empty','Пустое выражение. В отличие от Nil, имеет только нулевую ширину, а высота равна высоте символов.',['Empty^2']);
  Add('Токен PLambda','Лямбда с чертой (используется в квантвой механике).',['PLambda=lambda/2/pi']);
  Add('Токен Nabla','Символ "набла".',['Nabla*f=PDiffRF(f,x)*_e_x+PDiffRF(f,y)*_e_y+PDiffRF(f,z)*_e_z','Nabla*_a=PDiffRF(a_x,x)+PDiffRF(a_y,y)+PDiffRF(a_z,z)']);
  Add('Скобки ()','Круглые скобки, служат для изменения порядка выполнения действий. Могут быть убраны, если в это не приведёт к искажению смысла выражения. Для принудительной установки скобок используйте скобки !().',['(x+1)*(y-2)','(x+1)/(x-1)','a+(b+c)=d*.(e*.f)','a*(b+c)<>d+(e*f)','y=(1+1/(1+1/x))']);
  Add('Скобки !()','Используются там же, где и обычные круглые скобки, но никогда не убираются построителем формулы.',['!(x+1)*!(y-2)','!(x+1)/!(x-1)','a+!(b+c)=d*.!(e*.f)','a*!(b+c)<>d+!(e*f)','y=!(1+1/!(1+1/x))']);
  Add('Скобки []','Квадратные скобки. Никогда не убираются построителем.',['[x+1]*[y-2]','[x+1]/[x-1]','a+[b+c]=d*.[e*.f]','a*[b+c]<>d+[e*f]','y=[1+1/[1+1/x]]']);
  Add('Скобки {}','Фигурные скобки. Никогда не убираются построителем.',['{x+1}*{y-2}','{x+1}/{x-1}','a+{b+c}=d*.{e*.f}','a*{b+c}<>d+{e*f}','y={1+1/{1+1/x}}']);
  Add('Скобки ||','Прямые скобки. Никогда не убираются построителем.',['|x+1|*|y-2|','|x+1|/|x-1|','a+|b+c|=d*.|e*.f|','a*|b+c|<>d+|e*f|','y=|1+1/|1+1/x||']);
  Add('Символ "+"','Символ "плюс", использующийя обычно для обозначения сложения',['a+b']);
  Add('Символ "-"','Символ "минус", использующийся обычно для обозначения вычитания',['a-b']);
  Add('Символ "*"','Операция умножения. Проверяет, могут ли сомножители быть перемноженными без знака. Если могут, то знак умножения не используется (пример 1). Сомножители могут быть переставлены местами, чтобы обеспечить умножение без символа (пример 2).'+' Если среди сомножителей несколько чисел, то числа объединяются в одно (пример 3). Если перемножение без символа невозможно ни при каком порядке множителей, используется символ точка (пример 4)',['5*x','y*2','2*a*3','sin(x)*cos(x)']);
  Add('Символ "**"','Операция умножения. Сомножители перемножаются без знака независимо от того, допустимо ли такое перемножение. Перестановка множителей не производится.',['5**x','y**2','2**a**3','sin(x)**cos(x)']);
  Add('Символ "*."','Операция умножения. Сомножители перемножаются с помощью знака точки. Перестановка множителей не производится.',['5*.x','y*.2','2*.a*.3','sin(x)*.cos(x)']);
  Add('Символ "*+"','Операция умножения. Сомножители перемножаются с помощью знака косого креста. Перестановка множителей не производится.',['5*+x','y*+2','2*+a*+3','sin(x)*+cos(x)']);
  Add('Символ "<"','Знак операции "меньше"',['a<b']);
  Add('Символ "<<"','Знак операции "много меньше"',['a<<b']);
  Add('Символ "<>"','Знак операции "не равно"',['a<>b']);
  Add('Символ "<~"','Знак операции "меньше или порядка"',['a<~b']);
  Add('Символ "<="','Знак операции "меньше или равно"',['a<=b']);
  Add('Символ ">"','Знак операции "больше"',['a>b']);
  Add('Символ ">>"','Знак операции "много больше"',['a>>b']);
  Add('Символ ">~"','Знак операции "больше или порядка"',['a>~b']);
  Add('Символ ">="','Знак операции "больше или равно"',['a>=b']);
  Add('Символ "="','Знак операции "равно"',['a=b']);
  Add('Символ "=="','Знак операции "тождественно"',['a==b']);
  Add('Символ "=~"','Знак операции "равно или порядка"',['a=~b']);
  Add('Символ "~"','Знак операции "порядка"',['a~b']);
  Add('Символ "~~"','Знак операции "примерно равно"',['a~~b']);
  Add('Символ "-+','Знак операции "минус-плюс"',['a-+b']);
  Add('Символ "+-"','Знак операции "плюс-минус"',['a+-b']);
  Add('Символ "->"','Знак операции "стремится к"',['a->b']);
  Add('Символ "/"','Знак операции деления. Всегда используется деление в виде простой дроби. В сложных выражениях, использующих различные символы умножения и деления в произвольном порядке "интеллектуально"'+' распределяет множители между числителем и знаменателем (пример 2). Чтобы вынести множитель за пределы дроби, нужно дробь заключить в скобки (примеры 3, 4 и 5)',['a/b','(x+1)/(x-1)*(x+2)/(x-2)/(x//y)*4','(1/2)*x','(3/4)*((x+1)/(x-1))','(3/4)*(x+1)/(x-1)']);
  Add('Символ "//"','Знак операции деления. Используется косая черта. В некотогрых случаях неправильно убирает скобки (пример 2). В этом случае рекомендуется пользоваться скобками !() (пример 3)',['a//b','x//(2*y)','x//!(2*y)']);
  Add('Символ "/+"','Знак операции деления.',['a/+b']);
  Add('Символ "&" или " & "','Конкатенация двух выражений. Символ должен либо не отделяться от обоих выражений пробелами (пример 1), либо отделяться от каждого из них одним пробелом (пример 2)',['x&y','x & y']);
  Add('Символ "_" (вектор)','Символ используется для обозначения вектора, ставится перед выражением. В некоторых случаях возможна неправильная расстановка скобок. В таких случаях вместо символа рекомендуется использовать функцию Vect.',['_a']);
  Add('Символ "_" (нижний индекс)','Символ используется для обозначения нижнего индекса. В некоторых случаях возможна неправильная расстановка скобок или многоступенчатых индексов (пример 2). В таких случаях вместо'+' символа рекомендуется использовать функцию Ind (пример 3). Использование символа "_" для обозначения нижнего индекса возможно только если TExprBuilder.PostSymbols=True (по умолчанию)',['a_b','a_x_0','Ind(a,Ind(x,0))']);
  Add('Символ "^"','Символ используется для обозначения верхнего индекса или возведения в степень. В некоторых случаях возможна неправильная расстановка скобок или многоступенчатых индексов. В таких случаях вместо символа рекомендуется использовать функцию Pow.'+' Если используется вместа с нижним индексом (символ "_" или функция Ind), то сначала указывается нижний индекс, а затем - верхний (пример 2), в противном случае индексы будут отображаться некорректно (пример 3).'+' Использование символа "^" возможно только если TExprBuilder.PostSymbols=True (по умолчанию)',['a^b','Ind(x,a)^2, x_a^2','Ind(x^2,a), x^2_a']);
  Add('Символ "`" (обратный апостроф)','Используется для обозначения производной. Допустимо использование нескольких знаков подряд для обозначения производных высших степеней. В некоторых случаях возможна неправильная расстоновка скобок.'+' В таких случаях вместо символа рекомендуется использовать функцию Strokes. Использование символа "`" возможно только если TExprBuilder.PostSymbols=True (по умолчанию)',['f(x)`','f(x)```']);
  Add('Символ "!"','Символ факториала. Использование символа "!" для обозначения факториала возможно только если TExprBuilder.PostSymbols=True (по умолчанию)',['C_n^k=n!/k!/(n-k)!']);
  Add('Символ ","','Запятая, отделяющая несколько подряд идущих выражений. После запятой может быть произвольное число пробелов, однако это не влияет на расстояние между выражениями, которое составляет семь единиц толщины. Перед запятой пробелов быть не должно.',['a0,a1, a2,    a3']);
  Add('Символ "#"','Ставится перед цифровыми константами для указания, что они должны быть выведены в научном формате. Сравните пример 1 и пример 2',['0.03*x','#0.03*x']);
  Add('Функция Sqrt','Синтаксис: Sqrt(E). Извлечение квадратного корня из E.',['Sqrt(x^2+y^2)']);
  Add('Функция Sqr','Синтаксис: Sqr(E). Возведение выражения E в квадрат. Не имеет никаких преимуществ по сравнению с использованием символа "^" или функции Pow. Добавлена для совместимости с синтаксисом Паскаля',['Sqr(a+b)=Sqr(a)+2*a*b+Sqr(b)']);
  Add('Функция Log','Синтаксис: Log(E1,E2). Логарифм E2 по основанию E1.',['log(a,x+1)=ln(x+1)/ln(a)']);
  Add('Функция Abs','Синтаксис: Abs(E). Модуль E. Не имеет никаких преимуществ перед использованием скобок ||, добавлена для совместимости с синтаксисом Паскаля.',['Abs(x^2)=Abs(x)^2']);
  Add('Функция Pow','Синтаксис: Pow(E1,E2). Возведение E1 в степень E2. При использовании с функций Ind должна применяться после Ind (пример 2). В большинстве соучаев может быть заменена символом "^"',['Pow(x+2,2//3)','Pow(Ind(x,a),3)']);
  Add('Функция Root','Синтаксис: Root(E1,E2). Извлечение корня степени E1 из выражения E2.',['Root(3,x-1)']);
  Add('Функция Ind','Синтаксис: Ind(E1,E2). Добавление к E1 нижнего индекса в виде E2. В большинстве случаев может быть заменена символом "_". При использовании с функций Pow должна применяться раньше Pow (пример 2).',['Ind(a,n)','Pow(Ind(x,n),2)=(Pow(Ind(x,n+1),2)+Pow(Ind(x,n-1),2))/2']);
  Add('Функция Lim','Синтаскис: Lim(E1,E2). Предел выражения E2 при условии E1.',['Lim(StandC(x->0,x>0),f(x))=1']);
  Add('Функция Func','Синтаксис: Func(E1,E2). Функция, "именем" которой является E1, а аргументом - E2',['Func(PDiffRF(f,x,3),x)']);
  Add('Функция Space','Синтаксис: Space(n). Пробел размером в n единиц толщины. Используется для разделения выражений.',['y=x & space(7) & z=q']);
  Add('Функция Diff','Синтксис: Diff(E1[,E2]). Дифференциал E1 степени E2.',['Diff(x)','Diff(x,n)']);
  Add('Функция PDiff','Синтаксис: PDiff(E1[,E2]). "Частный дифференциал" E1 спепени E2. С математической точки зрения подобный "дифференциал" не имеет смысла, но функция очень удобна для создания выражений типа примера 3',['PDiff(x)','PDiff(x,n)','PDiffN(f(x,y),3)/PDiff(x)/PDiff(y,2)']);
  Add('Функция DiffN','Синтаксис: DiffN(E1[,E2]). Дифференциал степени E2 выражения E1',['DiffN(x)','DiffN(x,n)']);
  Add('Функция PDiffN','Синтаксис: PDiffN(E1[,E2]). "Частный дифференциал" спепени E2 выражения E1. С математической точки зрения подобный "дифференциал" не имеет смысла, но функция очень удобна для создания выражений типа примера 3',['PDiffN(x)','PDiffN(x,n)','PDiffN(f(x,y),3)/PDiff(x)/PDiff(y,2)']);
  Add('Функция DiffR','Синтаксис: DiffR(E1[,E2]). Полная производная по E1 степени E2.',['DiffR(x)','DiffR(x,n)','DiffR(x,2)*f(x)=DiffR(x)*DiffR(x)*f(x)']);
  Add('Функция PDiffR','Синтаксис: PDiffR(E1[,E2]). Частная производная по E1 степени E2.',['PDiffR(x)','PDiffR(x,n)','Nabla=PDiffR(x)*_e_x+PDiffR(y)*_e_y+PDiffR(z)*_e_z']);
  Add('Функция DiffRF','Синтаксис: DiffRF(E1,E2[,E3]). Полная производная E1 по E2 степени E3.',['DiffRF(f,x)','DiffRF(f(x),x,n)']);
  Add('Функция PDiffRF','Синтаксис: PDiffRF(E1,E2[,E3]). Частная производная E1 по E2 степени E3.',['PDiffRF(f,x)','PDiffRF(f(x,y),x,n)']);
  Add('Функция String','Синтаксис: String(Текст) или String("Текст"). Текст, выаодящийся прямым шрифтом без изменений. Если в тексте встречаются круглые скобки, он должен быть заключён в двойные кавычки',['String(Произвольный текст)','String("Текст (со скобками)")']);
  Add('Функция Strokes','Синтаксис: Strokes(E[,n]). Добавляет к E штрихи, обычно обозначающие производную.',['Strokes(f(x))','Strokes(y,3)']);
  Add('Функция Fact','Синтаксис: Fact(E). Факториал E. Может быть заменена символом "!" после E.',['Fact(n)','Fact(k+1)']);
  Add('Функция At','Синтаксис: At(E1,E2). Значение E1 при условии E2.',['At(DiffRF(f,x),x=0)=1']);
  Add('Функция Line','Синтаксис: Line(E). Горизонтальная черта над E.',['Line(x)','Line(x^2)']);
  Add('Функция Vect','Синтаксис: Vect(E). Стрелка (вектор) над E. В большинстве случаев может быть заменена на символ "_" перед E.',['Vect(a)']);
  Add('Функция Cap','Синтаксис: Cap(E). Знак "крышка" над E.',['Cap(x)']);
  Add('Функция Tilde','Синтаксис: Tilde(E). Знак тильды над E.',['Tilde(x)']);
  Add('Функция Points','Синтаксис: Points(E[,n]). Точки над E, обычно означающие производную по времени.',['Points(y,2)=y*Points(x)']);
  Add('Функция StandL','Синтаксис: StandL(E[,...]). Размещает несколько выражений одно под другим, выравнивая по левому краю.',['StandL(0<=i<n,i<>j)']);
  Add('Функция StandR','Синтаксис: StandR(E[,...]). Размещает несколько выражений одно под другим, выравнивая по правому краю.',['StandR(0<=i<n,i<>j)']);
  Add('Функция StandC','Синтаксис: StandC(E[,...]). Размещает несколько выражений одно под другим, выравнивая по центру.',['StandC(0<=i<n,i<>j)']);
  Add('Функция Matrix','Синтаксис: Matrix(n,m,E[,...]). Матрица размером n на m. Выражения E и следующие за ним расставляются по ячейкам матрицы. Выражений может быть меньше, чем n*m - в этом случае последние ячейки остаются пустыми.'+' Матрица не обрамляется скобками, скобки надо добавлять явно',['Matrix(2,3,x,y,x-y,x+y,z,z+y)','!(Matrix(2,2,1,2,-3,4))','[_a,_b]=|Matrix(3,3,_e_x,_e_y,_e_z,x_a,y_a,z_a,x_b,y_b,z_b)|']);
  Add('Функция Summa','Синтаксис: Summa(E1[,E2[,E3]]). Сумма выражений E1. Под знаком суммы ставится E2, над ним - E3.',['Summa(a_i)','Summa(a_i,i<>j)','Summa(a_i,i=0,n)']);
  Add('Функция Prod','Синтаксис: Prod(E1[,E2[,E3]]). Произведение выражений E1. Под знаком произведения ставится E2, над ним - E3.',['Prod(a_i)','Prod(a_i,i<>j)','Prod(a_i,i=0,n)']);
  Add('Функция Circ','Синтаксис: Circ(E1[,E2[,E3]]). Циркуляция выражения E1. Под знаком циркуляции ставится E2, над ним - E3.',['Circ(_E*Diff(_l),L)']);
  Add('Функция Int','Синтаксис: Int(E1[,E2[,E3]]). Интеграл выражения E1. Под знаком интеграла ставится E2, над ним - E3.',['F(x)=Int(f(x)*Diff(x))','Phi=Int(_H*Diff(_S),S)','Int(x,0,1)=1']);
  Add('Функция IntM','Синтаксис: IntM(n,E1[,E2[,E3]]). n-кратный интеграл выражения E1. Под знаком интеграла ставится E2, над ним - E3. Если n<=0, рисуется интеграл с неизвестной кратностью (используется многоточие).',['IntM(3,f(x,y,z)*Diff(x)*Diff(y)*Diff(z),V)','IntM(0,f(x1,...,x_n)*DiffN(x,n))']);
  Add('Функция Case','Синтаксис: Case(E[,...]). Выбор одного из возможных вариантов. Выражения в скобках идут в виде пар вариант-условие.',['|x|=Case(-x,x<0,0,x=0,x,x>0)']);
  Add('Функция Comma','Синтаксис: Comma(n). Вставляет в выражение запятую, а после неё - пробел шириной в n единиц ширины.',['x & comma(15) & y']);
  Add('Функция Brackets','Синтаксис: Brackets(S1S2,E). Заключает E в различные скобки. В качестве S1 может стоять символ "(", "[", "{", "|" или "0", в качестве S2 - ")", "]", "}", "|" или "0" ("0" означает отсутствие скобки с данной стороны).',['Brackets((],0&comma&1)']);
  Add('Функция System','Синтаксис: System(E[,...]). Объединяет выражения в систему.',['System(x+y=5,x*y=6)']);
  Add('Функция Num','Синтаксис: Num(R[,n1[,n2[,n3]]]). Позволяет управлять форматом записи числа R. Если порядок числа меньше или равен -n3, используется научная запись с точностью n1, если больше - обычная запись с числом разрядов'+' перед точкой n1 и общим n2. По умолчанию n1=4, n2=4, n3=2',['Num(0.00123456)','Num(0.00123456, 6)','Num(0.00123456, 4, 4, 3)','Num(0.00123456, 4, 6, 3)']);
  Add('Функция Symbol','Синтаксис: Symbol(n). Вставляет в выражение символ с кодом n в кодировке Unicode.',['Symbol(198)=1']);
  Add('Функция Angle','Синтаксис: Angle(Текст) или Angle("Текст"). Ставит перед текстом знак угла. Если текст содержит круглые скобки, его следует заключать в кавычки.',['Angle(ABC)']);
  ListBox.ItemIndex:=0;
  ListBoxClick(Self)
 end;

procedure TFormGuide.ListBoxClick(Sender: TObject);
 begin
  Index:=SendMessage(ListBox.Handle,LB_GetItemData,ListBox.ItemIndex,0);
  Memo.Text:=Arts[Index].Desc;
  MakePict
 end;

procedure TFormGuide.MakePict;
 var I:Integer;
     Expr:TExprClass;
     DY:Integer;
     Builder:TExprBuilder;
     MX:Integer;
  begin
   with Image.Picture.Bitmap do
    begin
     Width:=2000;
     Height:=1000;
     Canvas.Brush.Style:=bsSolid;
     Canvas.Brush.Color:=clInfoBk;
     Canvas.FillRect(Rect(0,0,Width,Height))
    end;
   DY:=5;
   MX:=0;
   Builder:=TExprBuilder.Create;
   for I:=0 to High(Arts[Index].Samples) do
    begin
     Expr:=TExprVar.Create('Пример '+IntToStr(I+1)+': ');
     Expr.Color:=clBlue;
     Expr.AddNext(TExprSimple.Create(Arts[Index].Samples[I]));
     Expr.AddNext(TExprVar.Create(' Результат: '));
     Expr.Next.Next.Color:=clBlue;
     Expr.AddNext(Builder.BuildExpr(Arts[Index].Samples[I]));
     Expr:=TExprChain.Create(Expr);
     Expr.Canvas:=Image.Picture.Bitmap.Canvas;
     Expr.Font.Size:=11;
     Expr.Draw(5,DY,ehLeft,evTop);
     Inc(DY,Expr.Height+5);
     if MX<Expr.Width then
      MX:=Expr.Width;
     Expr.Free
    end;
   Builder.Free;
{   Image.Picture.Bitmap.Width := 0;
   Image.Picture.Bitmap.Height := 0;}
//   try
    Image.Picture.Bitmap.Width:=MX+10;
    Image.Width:=MX+10;
{   except
    on EOutOfResources do begin
     Image.Picture.Bitmap.Width:=500;
     Image.Width:=500;
    end;//EOutOfResources
   end;//try..except}
//   try
    Image.Picture.Bitmap.Height:=DY;
    Image.Height:=DY;
{   except
    on EOutOfResources do begin
     Image.Picture.Bitmap.Height:=500;
     Image.Height:=500;
    end;//EOutOfResources
   end;//try..except}
  end;

procedure TFormGuide.BtnPrintClick(Sender: TObject);
 var I,J,TH,AH,PH,PW,DX,DY,CY,Index:Integer;
     R:TRect;
     VP,HP:Extended;
     Expr,Expr2:TExprClass;
     Builder:TExprBuilder;
  begin
   with Printer do
    begin
     BeginDoc;
     SetBkMode(Canvas.Handle,Transparent);
     VP:=GetDeviceCaps(Canvas.Handle,LogPixelSY)/2.54;
     HP:=GetDeviceCaps(Canvas.Handle,LogPixelSX)/2.54;
     DX:=Round(VP);
     PW:=Printer.PageWidth-2*DX;
     DY:=Round(1.5*HP);
     PH:=Printer.PageHeight-DY;
     CY:=DY;
     Builder:=TExprBuilder.Create;
     for I:=0 to ListBox.Items.Count-1 do
      begin
       Index:=SendMessage(ListBox.Handle,LB_GetItemData,I,0);
       Canvas.Font.Name:='Times New Roman';
       Canvas.Font.Charset:=Russian_Charset;
       Canvas.Font.Style:=[fsBold];
       Canvas.Font.Size:=13;
       R:=Rect(DX,CY,DX+PW,PH);
       DrawText(Canvas.Handle,PChar(Arts[Index].Title),-1,R,DT_CalcRect or DT_Center or DT_Top or DT_WordBreak or DT_NoPrefix);
       TH:=R.Bottom-R.Top;
       Canvas.Font.Name:='Arial';
       Canvas.Font.Charset:=Russian_Charset;
       Canvas.Font.Style:=[];
       Canvas.Font.Size:=11;
       R:=Rect(DX,CY,DX+PW,PH);
       DrawText(Canvas.Handle,PChar(Arts[Index].Desc),-1,R,DT_CalcRect or DT_Left or DT_Top or DT_WordBreak or DT_NoPrefix);
       AH:=R.Bottom-R.Top;
       if CY+TH+AH>PH then
        begin
         NewPage;
         CY:=DY;
         SetBkMode(Canvas.Handle,Transparent)
        end;
       Canvas.Font.Name:='Times New Roman';
       Canvas.Font.Style:=[fsBold];
       Canvas.Font.Size:=13;
       R:=Rect(DX,CY,DX+PW,PH);
       DrawText(Canvas.Handle,PChar(Arts[Index].Title),-1,R,DT_Center or DT_Top or DT_WordBreak or DT_NoPrefix);
       Inc(CY,TH);
       Canvas.Font.Name:='Arial';
       Canvas.Font.Style:=[];
       Canvas.Font.Size:=11;
       R:=Rect(DX,CY,DX+PW,PH);
       DrawText(Canvas.Handle,PChar(Arts[Index].Desc),-1,R,DT_Left or DT_Top or DT_WordBreak or DT_NoPrefix);
       Inc(CY,AH);
       for J:=0 to High(Arts[Index].Samples) do
        begin
         Expr:=TExprCustomText.Create('Пример '+IntToStr(J+1)+': ');
         Expr.AddNext(TExprSimple.Create(Arts[Index].Samples[J]));
         Expr.AddNext(TExprCustomText.Create('  Результат: '));
         Expr.AddNext(Builder.BuildExpr(Arts[Index].Samples[J]));
         Expr:=TExprChain.Create(Expr);
         Expr.Canvas:=Canvas;
         Expr.Font.Size:=11;
         if Expr.Width>PW then
          begin
           Expr.Free;
           Expr:=TExprCustomText.Create('Пример '+IntToStr(J+1)+': ');
           Expr.AddNext(TExprSimple.Create(Arts[Index].Samples[J]));
           Expr:=TExprChain.Create(Expr);
           Expr2:=TExprCustomText.Create('Результат: ');
           Expr2.AddNext(Builder.BuildExpr(Arts[Index].Samples[J]));
           Expr.AddNext(TExprChain.Create(Expr2));
           Expr:=TExprStand.Create(Expr,ehLeft);
           Expr.Canvas:=Canvas;
           Expr.Font.Size:=11;
           while Expr.Width>PW do
            Expr.Font.Size:=Expr.Font.Size-1
          end;
         if CY+Expr.Height>PH then
          begin
           NewPage;
           CY:=DY
          end;
         Expr.Draw(DX,CY,ehLeft,evTop);
         Inc(CY,Expr.Height+Round(0.2*HP));
         Expr.Free
        end
      end;
     Builder.Free;
     EndDoc
    end
  end;

end.
