// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 1999
// Object Oriented Concepts, Inc.
// Billerica, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.0b2
// License: non-commercial

#include <OB/CORBAClient.h>
#include "calendar.h"

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined!
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 3999952L)
#       error ORBacus version mismatch!
#   endif
#endif

OB::TypeCodeConst _tc_date(
"010000001d00000062000000010000000d00000049444c3a646174653a312e300072672f05000"
"00064617465006d0000000000000300000004000000646179000400000001000100060000006d"
"6f6e7468002f000400000001000000050000007965617200000100040000000100"
);

OB::TypeCodeConst _tc_Calendar(
"014c30000e00000029000000010000001100000049444c3a43616c656e6461723a312e3000410"
"0000900000043616c656e64617200"
);

//
// IDL:date:1.0
//
const char* date::_ob_id_ = "IDL:date:1.0";

void
OBDuplicate(date* p)
{
    CORBA::add_ref(p);
}

void
OBRelease(date* p)
{
    CORBA::remove_ref(p);
}

date*
date::_downcast(CORBA::ValueBase* p)
{
    return dynamic_cast<date*>(p);
}

date*
date::_downcast(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
        return _downcast(p -> _OB_toValue());
    return 0;
}

const char*
date::_OB_typeId() const
{
    return _ob_id_;
}

const char*
date::_OB_id()
{
    return _ob_id_;
}

void
date::_OB_marshalValue(OB::OutputStream_ptr _ob_out)
{
    _ob_out -> write_ushort(day());
    _ob_out -> write_ushort(month());
    _ob_out -> write_ushort(year());
}

void
date::_OB_unmarshalValue(OB::InputStream_ptr _ob_in)
{
    CORBA::UShort _ob_m0;
    _ob_m0 = _ob_in -> read_ushort();
    day(_ob_m0);
    CORBA::UShort _ob_m1;
    _ob_m1 = _ob_in -> read_ushort();
    month(_ob_m1);
    CORBA::UShort _ob_m2;
    _ob_m2 = _ob_in -> read_ushort();
    year(_ob_m2);
}

void
date::_OB_marshal(date* v, OB::OutputStream_ptr out)
{
    out -> write_Value(v, _OB_id());
}

void
date::_OB_unmarshal(date*& v, OB::InputStream_ptr in)
{
    CORBA::ValueBase* vb = in -> read_Value(_OB_id());
    v = _downcast(vb);
}

void
operator<<=(CORBA::Any& any, date** v)
{
    static const OB::ValueInfo info(date::_OB_id());
    any.replace(_tc_date, (CORBA::ValueBase*)*v, true, &info);
}

void
operator<<=(CORBA::Any& any, date* v)
{
    CORBA::add_ref(v);
    any <<= &v;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, date*& v)
{
    if(any.check_type(_tc_date))
    {
        if(!any.info())
        {
            OB::InputStream_var in = any.create_input_stream();
            CORBA::ValueBase_var vb = in -> read_Value();
            date* val = date::_downcast(vb);
            (CORBA::Any&)any <<= val;
        }

        CORBA::ValueBase* vb = (CORBA::ValueBase*)any.value();
        v = dynamic_cast<date*>(vb);
        return true;
    }
    else
        return false;
}

date_init*
date_init::_downcast(CORBA::ValueFactory f)
{
    return dynamic_cast<date_init*>(f);
}

//
// IDL:Calendar:1.0
//
const char* Calendar::ids_[] =
{
    "IDL:Calendar:1.0",
    0
};

OBStubImpl_Calendar_ptr
Calendar::_OB_getStubImpl_Calendar()
{
#ifdef HAVE_JTC
    JTCSynchronized sync(_ob_stubImplMutex_);
#endif

    if(CORBA::is_nil(_ob_stubImpl_Calendar_))
    {
        _OB_setStubImpl();
        assert(!CORBA::is_nil(_ob_stubImpl_Calendar_));
    }

    return OBStubImpl_Calendar::_duplicate(_ob_stubImpl_Calendar_);
}

void
Calendar::_OB_setStubImpl()
{
#ifdef HAVE_JTC
    JTCSynchronized sync(_ob_stubImplMutex_);
#endif

    _ob_stubImplBase_ = _ob_stubImplFactory_ -> createStubImpl(this);
    _ob_stubImpl_Calendar_ = dynamic_cast<OBStubImpl_Calendar_ptr>(_ob_stubImplBase_.in());
    assert(!CORBA::is_nil(_ob_stubImpl_Calendar_));
}

void
Calendar::_OB_clearStubImpl()
{
#ifdef HAVE_JTC
    JTCSynchronized sync(_ob_stubImplMutex_);
#endif

    _ob_stubImplBase_ = OB::StubImplBase::_nil();
    _ob_stubImpl_Calendar_ = OBStubImpl_Calendar::_nil();
}

OB::MarshalStubImpl_ptr
Calendar::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_Calendar;
}

Calendar::Calendar()
    : _ob_stubImpl_Calendar_(OBStubImpl_Calendar::_nil())
{
}

void
OBDuplicate(Calendar_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(Calendar_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

Calendar_ptr
Calendar::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Calendar_ptr v = dynamic_cast<Calendar_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Calendar_ptr val = new Calendar;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Calendar_ptr
Calendar::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
        return _narrow(p -> _OB_toObject());
    return _nil();
}

const char**
Calendar::_OB_ids() const
{
    return ids_;
}

const char**
Calendar::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(Calendar_ptr _ob_v, OB::OutputStream_ptr _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(Calendar_ptr& _ob_v, OB::InputStream_ptr _ob_in)
{
    Calendar_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        _ob_v = new Calendar;
        _ob_v -> _OB_copyFrom(p);
    }
    else
        _ob_v = Calendar::_nil();
}

void
operator<<=(CORBA::Any& any, Calendar_ptr* v)
{
    any.replace(_tc_Calendar, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Calendar_ptr v)
{
    Calendar_ptr val = Calendar::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Calendar_ptr& v)
{
    if(any.check_type(_tc_Calendar))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Calendar_ptr>(val)))
            {
                v = new Calendar;
                v -> _OB_copyFrom(val);
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Calendar::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:Calendar/insert:1.0
//
void
Calendar::insert(date* _ob_a0,
                 const char* _ob_a1)
{
    bool _ob_failure = false;
    while(true)
    {
        try
        {
            OBStubImpl_Calendar_var _ob_stubImpl = _OB_getStubImpl_Calendar();
            _ob_stubImpl -> insert(_ob_a0, _ob_a1);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _ob_failure = _OB_handleException(_ob_ex, _ob_failure);
        }
    }
}

//
// IDL:Calendar/find_date:1.0
//
CORBA::Boolean
Calendar::find_date(date* _ob_a0,
                    CORBA::String_out _ob_a1)
{
    bool _ob_failure = false;
    while(true)
    {
        try
        {
            OBStubImpl_Calendar_var _ob_stubImpl = _OB_getStubImpl_Calendar();
            return _ob_stubImpl -> find_date(_ob_a0, _ob_a1);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _ob_failure = _OB_handleException(_ob_ex, _ob_failure);
        }
    }
}

//
// IDL:Calendar/find_note:1.0
//
CORBA::Boolean
Calendar::find_note(const char* _ob_a0,
                    date*& _ob_a1)
{
    bool _ob_failure = false;
    while(true)
    {
        try
        {
            OBStubImpl_Calendar_var _ob_stubImpl = _OB_getStubImpl_Calendar();
            return _ob_stubImpl -> find_note(_ob_a0, _ob_a1);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _ob_failure = _OB_handleException(_ob_ex, _ob_failure);
        }
    }
}

//
// IDL:Calendar:1.0
//
void
OBDuplicate(OBStubImpl_Calendar_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_Calendar_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:Calendar/insert:1.0
//
void
OBMarshalStubImpl_Calendar::insert(date* _ob_a0,
                                   const char* _ob_a1)
{
    OB::Downcall_var _ob_down = new OB::Downcall(this, "insert", true);
    _ob_down -> preinvoke();
    try
    {
        OB::OutputStream_ptr _ob_out = _ob_down -> output_nodup();
        date::_OB_marshal(_ob_a0, _ob_out);
        _ob_out -> write_string(_ob_a1);
        _ob_down -> request();
        _OB_handleDowncall(_ob_down);
    }
    catch(...)
    {
        _ob_down -> postinvoke();
        throw;
    }
    _ob_down -> postinvoke();
}

//
// IDL:Calendar/find_date:1.0
//
CORBA::Boolean
OBMarshalStubImpl_Calendar::find_date(date* _ob_a0,
                                      CORBA::String_out _ob_a1)
{
    OB::Downcall_var _ob_down = new OB::Downcall(this, "find_date", true);
    _ob_down -> preinvoke();
    try
    {
        OB::OutputStream_ptr _ob_out = _ob_down -> output_nodup();
        date::_OB_marshal(_ob_a0, _ob_out);
        _ob_down -> request();
        _OB_handleDowncall(_ob_down);
    }
    catch(...)
    {
        _ob_down -> postinvoke();
        throw;
    }
    OB::InputStream_ptr _ob_in = _ob_down -> input_nodup();
    CORBA::Boolean _ob_r = _ob_in -> read_boolean();
    _ob_a1 = _ob_in -> read_string();
    _ob_down -> postinvoke();
    return _ob_r;
}

//
// IDL:Calendar/find_note:1.0
//
CORBA::Boolean
OBMarshalStubImpl_Calendar::find_note(const char* _ob_a0,
                                      date*& _ob_a1)
{
    OB::Downcall_var _ob_down = new OB::Downcall(this, "find_note", true);
    _ob_down -> preinvoke();
    try
    {
        OB::OutputStream_ptr _ob_out = _ob_down -> output_nodup();
        _ob_out -> write_string(_ob_a0);
        _ob_down -> request();
        _OB_handleDowncall(_ob_down);
    }
    catch(...)
    {
        _ob_down -> postinvoke();
        throw;
    }
    OB::InputStream_ptr _ob_in = _ob_down -> input_nodup();
    CORBA::Boolean _ob_r = _ob_in -> read_boolean();
    _ob_a1 = 0;
    date::_OB_unmarshal(_ob_a1, _ob_in);
    _ob_down -> postinvoke();
    return _ob_r;
}

//
// IDL:date:1.0
//
OBV_date::OBV_date()
{
#ifdef OB_CLEAR_MEM
    memset(&_obv_day_, 0, sizeof(_obv_day_));
    memset(&_obv_month_, 0, sizeof(_obv_month_));
    memset(&_obv_year_, 0, sizeof(_obv_year_));
#endif
}

OBV_date::OBV_date(CORBA::UShort day,
                   CORBA::UShort month,
                   CORBA::UShort year) :
    _obv_day_(day),
    _obv_month_(month),
    _obv_year_(year)
{
}

OBV_date::~OBV_date()
{
}

//
// IDL:date/day:1.0
//
void
OBV_date::day(CORBA::UShort _ob_a)
{
    _obv_day_ = _ob_a;
}

CORBA::UShort
OBV_date::day() const
{
    return _obv_day_;
}

//
// IDL:date/month:1.0
//
void
OBV_date::month(CORBA::UShort _ob_a)
{
    _obv_month_ = _ob_a;
}

CORBA::UShort
OBV_date::month() const
{
    return _obv_month_;
}

//
// IDL:date/year:1.0
//
void
OBV_date::year(CORBA::UShort _ob_a)
{
    _obv_year_ = _ob_a;
}

CORBA::UShort
OBV_date::year() const
{
    return _obv_year_;
}
