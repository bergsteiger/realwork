// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 1999
// Object Oriented Concepts, Inc.
// Billerica, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.0b2
// License: non-commercial

#ifndef ___calendar_h__
#define ___calendar_h__

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined!
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 3999952L)
#       error ORBacus version mismatch!
#   endif
#endif

class date;

class Calendar;
typedef Calendar* Calendar_ptr;
typedef Calendar* CalendarRef;

void OBDuplicate(date*);
void OBRelease(date*);

void OBMarshal(date*, OB::OutputStream_ptr);
void OBUnmarshal(date*&, OB::InputStream_ptr);

void OBDuplicate(Calendar_ptr);
void OBRelease(Calendar_ptr);

void OBMarshal(Calendar_ptr, OB::OutputStream_ptr);
void OBUnmarshal(Calendar_ptr&, OB::InputStream_ptr);

typedef OB::ObjVar< date > date_var;

typedef OB::ObjVar< Calendar > Calendar_var;
typedef OB::ObjOut< Calendar > Calendar_out;

class OBStubImpl_Calendar;
typedef OBStubImpl_Calendar* OBStubImpl_Calendar_ptr;

void OBDuplicate(OBStubImpl_Calendar_ptr);
void OBRelease(OBStubImpl_Calendar_ptr);

typedef OB::ObjVar< OBStubImpl_Calendar > OBStubImpl_Calendar_var;

//
// IDL:date:1.0
//
class date : virtual public CORBA::ValueBase
{
    void operator=(const date&);

    static const char* _ob_id_;

protected:

    date() { }
    virtual ~date() { }

public:

    static date* _downcast(CORBA::ValueBase*);
    static date* _downcast(CORBA::AbstractBase_ptr);

    //
    // IDL:date/equal:1.0
    //
    virtual CORBA::Boolean equal(date* other) = 0;

    //
    // IDL:date/compare:1.0
    //
    virtual CORBA::Short compare(date* other) = 0;

    //
    // IDL:date/day:1.0
    //
    virtual void day(CORBA::UShort) = 0;
    virtual CORBA::UShort day() const = 0;

    //
    // IDL:date/month:1.0
    //
    virtual void month(CORBA::UShort) = 0;
    virtual CORBA::UShort month() const = 0;

    //
    // IDL:date/year:1.0
    //
    virtual void year(CORBA::UShort) = 0;
    virtual CORBA::UShort year() const = 0;

    static const char* _OB_id();

    virtual const char* _OB_typeId() const;

    virtual void _OB_marshalValue(OB::OutputStream_ptr);
    virtual void _OB_unmarshalValue(OB::InputStream_ptr);

    static void _OB_marshal(date*, OB::OutputStream_ptr);
    static void _OB_unmarshal(date*&, OB::InputStream_ptr);
};

extern OB::TypeCodeConst _tc_date;

class date_init : public CORBA::ValueFactoryBase
{
protected:

    date_init()
    {
    }

public:

    virtual ~date_init()
    {
    }

    static date_init* _downcast(CORBA::ValueFactory);

    virtual date* create(CORBA::UShort dd,
                         CORBA::UShort mm,
                         CORBA::UShort yyyy) = 0;
};

//
// IDL:Calendar:1.0
//
class Calendar : virtual public CORBA::Object
{
    Calendar(const Calendar&);
    void operator=(const Calendar&);

    static const char* ids_[];

protected:

    OBStubImpl_Calendar_ptr _ob_stubImpl_Calendar_;

    OBStubImpl_Calendar_ptr _OB_getStubImpl_Calendar();
    virtual void _OB_setStubImpl();
    virtual void _OB_clearStubImpl();
    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    Calendar();

    typedef Calendar_ptr _ptr_type;
    typedef Calendar_var _var_type;

    static inline Calendar_ptr
    _duplicate(Calendar_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline Calendar_ptr
    _nil()
    {
        return 0;
    }

    static Calendar_ptr _narrow(CORBA::Object_ptr);
    static Calendar_ptr _narrow(CORBA::AbstractBase_ptr);

    virtual const char** _OB_ids() const;
    static const char** _OB_staticIds();

    //
    // IDL:Calendar/insert:1.0
    //
    void insert(date* when,
                const char* what);

    //
    // IDL:Calendar/find_date:1.0
    //
    CORBA::Boolean find_date(date* when,
                             CORBA::String_out what);

    //
    // IDL:Calendar/find_note:1.0
    //
    CORBA::Boolean find_note(const char* what,
                             date*& when);
};

extern OB::TypeCodeConst _tc_Calendar;

//
// IDL:Calendar:1.0
//
class OBStubImpl_Calendar : virtual public OB::StubImplBase
{
    OBStubImpl_Calendar(const OBStubImpl_Calendar&);
    void operator=(const OBStubImpl_Calendar&);

protected:

    OBStubImpl_Calendar() { }

public:

    static inline OBStubImpl_Calendar_ptr
    _duplicate(OBStubImpl_Calendar_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline OBStubImpl_Calendar_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:Calendar/insert:1.0
    //
    virtual void insert(date* when,
                        const char* what) = 0;

    //
    // IDL:Calendar/find_date:1.0
    //
    virtual CORBA::Boolean find_date(date* when,
                                     CORBA::String_out what) = 0;

    //
    // IDL:Calendar/find_note:1.0
    //
    virtual CORBA::Boolean find_note(const char* what,
                                     date*& when) = 0;
};

//
// IDL:Calendar:1.0
//
class OBMarshalStubImpl_Calendar : virtual public OBStubImpl_Calendar,
                                   virtual public OB::MarshalStubImpl
{
    OBMarshalStubImpl_Calendar(const OBMarshalStubImpl_Calendar&);
    void operator=(const OBMarshalStubImpl_Calendar&);

protected:

    OBMarshalStubImpl_Calendar() { }
    friend class Calendar;

public:

    //
    // IDL:Calendar/insert:1.0
    //
    virtual void insert(date* when,
                        const char* what);

    //
    // IDL:Calendar/find_date:1.0
    //
    virtual CORBA::Boolean find_date(date* when,
                                     CORBA::String_out what);

    //
    // IDL:Calendar/find_note:1.0
    //
    virtual CORBA::Boolean find_note(const char* what,
                                     date*& when);
};

//
// IDL:date:1.0
//
class OBV_date : virtual public date
{
    void operator=(const OBV_date&);

    CORBA::UShort _obv_day_;
    CORBA::UShort _obv_month_;
    CORBA::UShort _obv_year_;

protected:

    OBV_date();
    OBV_date(CORBA::UShort,
             CORBA::UShort,
             CORBA::UShort);
    virtual ~OBV_date();

public:

    //
    // IDL:date/day:1.0
    //
    virtual void day(CORBA::UShort);
    virtual CORBA::UShort day() const;

    //
    // IDL:date/month:1.0
    //
    virtual void month(CORBA::UShort);
    virtual CORBA::UShort month() const;

    //
    // IDL:date/year:1.0
    //
    virtual void year(CORBA::UShort);
    virtual CORBA::UShort year() const;
};

//
// IDL:date:1.0
//
void operator<<=(CORBA::Any&, date**);
void operator<<=(CORBA::Any&, date*);
CORBA::Boolean operator>>=(const CORBA::Any&, date*&);

inline void
operator<<=(CORBA::Any_var& any, date** val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, date* val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, date*& val)
{
    return any.in() >>= val;
}

//
// IDL:Calendar:1.0
//
namespace CORBA
{

inline void
release(Calendar_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(Calendar_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_Calendar_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_Calendar_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Calendar_ptr*);
void operator<<=(CORBA::Any&, Calendar_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Calendar_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Calendar_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Calendar_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Calendar_ptr& val)
{
    return any.in() >>= val;
}

#endif
