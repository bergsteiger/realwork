// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:26
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i../..//idl -i./ ./\calendar.idl" 
//                                                                            
unit calendar;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, calendar_int, value_int, value, poa_int, poa;

type

  {** IDL:datetest:1.0 } 
  Tdatetest = class(TValueBase,Idatetest,IValueBase)
  protected
    Fdatetest_day : _ushort;
    Fdatetest_month : _ushort;
    Fdatetest_year : _ushort;
    function day : _ushort; overload;
    procedure day(val : _ushort); overload;
    function month : _ushort; overload;
    procedure month(val : _ushort); overload;
    function year : _ushort; overload;
    procedure year(val : _ushort); overload;
    function equal(const other: Idatetest): Boolean; virtual; abstract;
    function compare(const other: Idatetest): Short; virtual; abstract;
    function _copy_value : IValueBase; override;
    procedure _copy_members(const v: TObject); override;
    procedure _marshal_members(const enc: IEncoder); override;
    procedure _get_marshal_info(const str: TStrings;out chunked: Boolean); override;
    function  _demarshal_members(const dec: Idecoder): Boolean; override;
    function narrow_helper(const repoid: RepositoryID): Pointer; override;
  public
    class function _downcast(const vb : IValueBase): Idatetest;
  end;

  {** factory for valuetype IDL:datetest:1.0} 
  Tdatetest_init = class(TInterfacedObject,Idatetest_init,IValueFactory)
  protected
    function _create(dd: _ushort; mm: _ushort; yyyy: _ushort): Idatetest; virtual; abstract;
    function narrow_helper(const repoid: RepositoryID): Pointer;
    function create_for_umarshal(): IValueBase; virtual; abstract;
  public
    class function _downcast(const vf : IValueFactory): Idatetest_init;
  end;

  Tdatetest_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Calendar:1.0 } 
  TCalendar = class(TORBObject,ICalendar)
  protected
    procedure insert(const when: Idatetest; const what: AnsiString); virtual; abstract;
    function find_date(const when: Idatetest; out what: AnsiString): Boolean; virtual; abstract;
    function find_note(const what: AnsiString; out when: Idatetest): Boolean; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICalendar;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Calendar:1.0} 
  TCalendar_stub = class(TCalendar)
  protected
    procedure insert(const when: Idatetest; const what: AnsiString); override;
    function find_date(const when: Idatetest; out what: AnsiString): Boolean; override;
    function find_note(const what: AnsiString; out when: Idatetest): Boolean; override;
  end;

  {** POA stub for interface IDL:Calendar:1.0} 
  TCalendar_stub_clp = class(TPOAStub,IPOAStub,ICalendar)
  protected
    procedure insert(const when: Idatetest; const what: AnsiString); virtual;
    function find_date(const when: Idatetest; out what: AnsiString): Boolean; virtual;
    function find_note(const what: AnsiString; out when: Idatetest): Boolean; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Calendar:1.0} 
  TCalendar_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICalendar)
  protected
    procedure insert(const when: Idatetest; const what: AnsiString); virtual; abstract;
    function find_date(const when: Idatetest; out what: AnsiString): Boolean; virtual; abstract;
    function find_note(const what: AnsiString; out when: Idatetest): Boolean; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICalendar;
    class function _narrow(const srv : IServant): ICalendar;
  end;

  TCalendar_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  datetest_marshaller : IStaticTypeInfo;
  Calendar_marshaller : IStaticTypeInfo;
  _tc_datetest : ITypeCodeConst;
  _tc_Calendar : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// Tdatetest
//***********************************************************
function Tdatetest.day: _ushort;
begin
  result := Fdatetest_day;
end;

procedure Tdatetest.day(val : _ushort);
begin
  Fdatetest_day := val;
end;

function Tdatetest.month: _ushort;
begin
  result := Fdatetest_month;
end;

procedure Tdatetest.month(val : _ushort);
begin
  Fdatetest_month := val;
end;

function Tdatetest.year: _ushort;
begin
  result := Fdatetest_year;
end;

procedure Tdatetest.year(val : _ushort);
begin
  Fdatetest_year := val;
end;

function Tdatetest.narrow_helper(const repoid: RepositoryID): Pointer;
begin
  if strcomp(PAnsiChar(repoid),'IDL:datetest:1.0') = 0 then
    result := Pointer(Self as Idatetest)
  else
    result := nil;
end;

class function Tdatetest._downcast(const vb : IValueBase): Idatetest;
var
  ptr: pointer;
begin
  result := nil;
  if vb <> nil then
    begin
      ptr := vb.narrow_helper('IDL:datetest:1.0');
      if ptr <> nil then
        result := Idatetest(ptr);
    end;
end;

procedure Tdatetest._get_marshal_info(const str: TStrings; out chunked: Boolean);
begin
  str.Add('IDL:datetest:1.0');
  chunked := false;
end;

procedure Tdatetest._marshal_members(const enc: IEncoder);
begin
  stat_ushort.marshal(enc,@Fdatetest_day);
  stat_ushort.marshal(enc,@Fdatetest_month);
  stat_ushort.marshal(enc,@Fdatetest_year);
end;

function  Tdatetest._demarshal_members(const dec: IDecoder): Boolean;
begin
  result := false;
  if not stat_ushort.demarshal(dec,@Fdatetest_day) then exit;
  if not stat_ushort.demarshal(dec,@Fdatetest_month) then exit;
  if not stat_ushort.demarshal(dec,@Fdatetest_year) then exit;
  result := true;
end;

procedure Tdatetest._copy_members(const v: TObject);
var
  other : Tdatetest;
begin
  inherited _copy_members(v);
  other := v as Tdatetest;
  day(other.day);
  month(other.month);
  year(other.year);
end;

function  Tdatetest._copy_value: IValueBase;
var
  list: TStrings;
begin
  list := TStringList.Create;
  try
    result := _create(list,'IDL:datetest:1.0');
    result._copy_members(self);
  finally
    list.free;
  end;
end;

//***********************************************************
// Tdatetest_init
//***********************************************************
class function Tdatetest_init._downcast(const vf : IValueFactory): Idatetest_init;
var
  ptr: pointer;
begin
  result := nil;
  if vf <> nil then
    begin
      ptr := vf.narrow_helper('IDL:datetest:1.0');
      if ptr <> nil then result := Idatetest_init(ptr);
    end;
end;

function Tdatetest_init.narrow_helper(const repoid: RepositoryID): Pointer;
begin
  result := nil;
  if strcomp(PAnsiChar(repoid),'IDL:datetest:1.0')= 0 then
    result := Pointer( self as Idatetest_init);
end;

//***********************************************************
// Tdatetest_marshaller
//***********************************************************
procedure Tdatetest_marshaller._create(var addr: Pointer);
begin
  Idatetest(addr^) := Tdatetest.Create as Idatetest;
end;

procedure Tdatetest_marshaller._assign(dst, src: Pointer);
begin
  Idatetest(dst^) := Idatetest(src^);
end;

procedure Tdatetest_marshaller._free(var addr: Pointer);
begin
  Idatetest(addr^) := nil;
end;

function Tdatetest_marshaller.demarshal(dec: IDecoder;
  const addr: Pointer): Boolean;
var
  vb : IValueBase;
begin
  result := TValueBase._demarshal(dec,vb,'IDL:datetest:1.0');
  if not result then exit;
  Idatetest(addr^) := Tdatetest._downcast(vb);
  result := (vb = nil) or (vb <> nil) and (Pointer(addr^) <> nil);
end;

procedure Tdatetest_marshaller.marshal(enc: IEncoder; const addr: Pointer);
begin
  TValueBase._marshal(enc,Idatetest(addr^) as IValueBase);
end;

function Tdatetest_marshaller.typecode: ITypeCode;
begin
  result := _tc_datetest.typecode;
end;

//***********************************************************
// TCalendar
//***********************************************************
function TCalendar.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Calendar:1.0' then
    begin
      result := Pointer(self as ICalendar);
      exit;
    end;
end;

class function TCalendar._narrow(const obj : IORBObject): ICalendar;
var
  p: Pointer;
  stub: TCalendar_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Calendar:1.0');
  if p <> nil then
    result := ICalendar(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Calendar:1.0') then
        begin
          stub := TCalendar_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCalendar.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Calendar:1.0'
end;

//***********************************************************
// TCalendar_stub
//***********************************************************
procedure TCalendar_stub.insert(const when: Idatetest; const what: AnsiString);
var
  req: IStaticRequest;
  _when: IStaticAny;
  _what: IStaticAny;
begin
  _when := StaticAny(datetest_marshaller,@when);
  _what := StaticAny(stat_string,@what);
  req := StaticRequest(self,'insert');
  req.add_in_arg(_when);
  req.add_in_arg(_what);
  req.invoke;
  dorb_static_throw(req);
end;

function TCalendar_stub.find_date(const when: Idatetest; out what: AnsiString): Boolean;
var
  req: IStaticRequest;
  _when: IStaticAny;
  _what: IStaticAny;
  _result: IStaticAny;
begin
  _when := StaticAny(datetest_marshaller,@when);
  _what := StaticAny(stat_string,@what);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'find_date');
  req.add_in_arg(_when);
  req.add_out_arg(_what);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCalendar_stub.find_note(const what: AnsiString; out when: Idatetest): Boolean;
var
  req: IStaticRequest;
  _what: IStaticAny;
  _when: IStaticAny;
  _result: IStaticAny;
begin
  _what := StaticAny(stat_string,@what);
  _when := StaticAny(datetest_marshaller,@when);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'find_note');
  req.add_in_arg(_what);
  req.add_out_arg(_when);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TCalendar_stub_clp
//***********************************************************
function TCalendar_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Calendar:1.0' then
    begin
      result := Pointer(self as ICalendar);
      exit;
  end;
end;

procedure TCalendar_stub_clp.insert(const when: Idatetest; const what: AnsiString);
var
  _srv: IServant;
  srv: ICalendar;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCalendar_serv._narrow(_srv);
      if srv <> nil then
        srv.insert(when, what)
    end;
  _postinvoke();
end;

function TCalendar_stub_clp.find_date(const when: Idatetest; out what: AnsiString): Boolean;
var
  _srv: IServant;
  srv: ICalendar;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCalendar_serv._narrow(_srv);
      if srv <> nil then
        result := srv.find_date(when, what)
    end;
  _postinvoke();
end;

function TCalendar_stub_clp.find_note(const what: AnsiString; out when: Idatetest): Boolean;
var
  _srv: IServant;
  srv: ICalendar;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCalendar_serv._narrow(_srv);
      if srv <> nil then
        result := srv.find_note(what, when)
    end;
  _postinvoke();
end;

//***********************************************************
// TCalendar_serv
//***********************************************************
function TCalendar_serv._this(): ICalendar;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCalendar._narrow(obj);
end;

function TCalendar_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Calendar:1.0';
end;

function TCalendar_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Calendar:1.0';
end;

function TCalendar_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCalendar_stub_clp.Create(poa,obj);
end;

procedure TCalendar_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCalendar_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Calendar:1.0' then
    begin
      result := Pointer(ICalendar(self));
      exit;
    end;
end;

class function TCalendar_serv._narrow(const srv : IServant): ICalendar;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Calendar:1.0');
  if p <> nil then
    result := ICalendar(p)
end;

function TCalendar_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  insert_when: Idatetest;
  insert_what: AnsiString;
  find_date_result: Boolean;
  find_date_when: Idatetest;
  find_date_what: AnsiString;
  find_note_result: Boolean;
  find_note_what: AnsiString;
  find_note_when: Idatetest;
begin
  result := true;
  if req.op_name = 'insert' then
    begin
      req.add_in_arg(StaticAny(datetest_marshaller,@insert_when) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@insert_what) as IStaticAny);
      if not req.read_args() then  exit;
      insert(insert_when, insert_what);
      req.write_results();
      exit;
    end
  else if req.op_name = 'find_date' then
    begin
      req.add_in_arg(StaticAny(datetest_marshaller,@find_date_when) as IStaticAny);
      req.add_out_arg(StaticAny(stat_string,@find_date_what) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@find_date_result) as IStaticAny);
      if not req.read_args() then  exit;
      find_date_result := find_date(find_date_when, find_date_what);
      req.write_results();
      exit;
    end
  else if req.op_name = 'find_note' then
    begin
      req.add_in_arg(StaticAny(stat_string,@find_note_what) as IStaticAny);
      req.add_out_arg(StaticAny(datetest_marshaller,@find_note_when) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@find_note_result) as IStaticAny);
      if not req.read_args() then  exit;
      find_note_result := find_note(find_note_what, find_note_when);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCalendar_marshaller
//***********************************************************
function TCalendar_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICalendar(addr^) := TCalendar._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCalendar_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICalendar(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCalendar_marshaller._free(var addr: Pointer);
begin
  ICalendar(addr^) := nil;
end;

procedure TCalendar_marshaller._create(var addr: Pointer);
begin
  ICalendar(addr^) := TCalendar_stub.Create();
end;

procedure TCalendar_marshaller._assign(dst, src: Pointer);
begin
  ICalendar(dst^) := ICalendar(src^);
end;

function TCalendar_marshaller.typecode: ITypeCode;
begin
  result := _tc_Calendar.typecode;
end;

initialization
  datetest_marshaller := Tdatetest_marshaller.Create();
  Calendar_marshaller := TCalendar_marshaller.Create();
  _tc_datetest := CreateTypeCodeConst('010000001d00000034000000010000001100000049444c3a64617465746573743a312e3000000000090000006461746574657374000000'+
    '000000000000000000');
  _tc_Calendar := CreateTypeCodeConst('010000000e00000029000000010000001100000049444c3a43616c656e6461723a312e30000000000900000043616c656e64617200');
end.
