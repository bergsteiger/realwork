// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:27
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -poa -notabs -i../..//idl -i./ ./\account.idl" 
//                                                                            
unit account;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, account_int, poa_int, poa;

type

  {** IDL:Bank/Account:1.0 } 
  TBank_Account = class(TORBObject,IBank_Account)
  protected
    function balance: Float; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IBank_Account;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Bank/Account:1.0} 
  TBank_Account_stub = class(TBank_Account)
  protected
    function balance: Float; override;
  end;

  {** POA stub for interface IDL:Bank/Account:1.0} 
  TBank_Account_stub_clp = class(TPOAStub,IPOAStub,IBank_Account)
  protected
    function balance: Float; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Bank/Account:1.0} 
  TBank_Account_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IBank_Account)
  private
    FImplementation: IBank_Account;
  protected
    function balance: Float; virtual;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    constructor Create(const AImpl: IBank_Account = nil);
    function _this(): IBank_Account;
    class function _narrow(const srv : IServant): IBank_Account;
  end;

  TBank_Account_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Bank/AccountEx:1.0 } 
  TBank_AccountEx = class(TBank_Account,IBank_AccountEx)
  protected
    procedure debit(const value: Double); virtual; abstract;
    procedure credit(const value: Double); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IBank_AccountEx;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Bank/AccountEx:1.0} 
  TBank_AccountEx_stub = class(TBank_AccountEx)
  protected
    function balance: Float; override;
    procedure debit(const value: Double); override;
    procedure credit(const value: Double); override;
  end;

  {** POA stub for interface IDL:Bank/AccountEx:1.0} 
  TBank_AccountEx_stub_clp = class(TBank_Account_stub_clp,IBank_AccountEx)
  protected
    procedure debit(const value: Double); virtual;
    procedure credit(const value: Double); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Bank/AccountEx:1.0} 
  TBank_AccountEx_serv = class(TBank_Account_serv,IBank_AccountEx)
  private
    FImplementation: IBank_AccountEx;
  protected
    procedure debit(const value: Double); virtual;
    procedure credit(const value: Double); virtual;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    constructor Create(const AImpl: IBank_AccountEx = nil);
    function _this(): IBank_AccountEx;
    class function _narrow(const srv : IServant): IBank_AccountEx;
  end;

  TBank_AccountEx_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  Bank_Account_marshaller : IStaticTypeInfo;
  Bank_AccountEx_marshaller : IStaticTypeInfo;
  _tc_Bank_Account : ITypeCodeConst;
  _tc_Bank_AccountEx : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TBank_Account
//***********************************************************
function TBank_Account.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Bank/Account:1.0' then
    begin
      result := Pointer(self as IBank_Account);
      exit;
    end;
end;

class function TBank_Account._narrow(const obj : IORBObject): IBank_Account;
var
  p: Pointer;
  stub: TBank_Account_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Bank/Account:1.0');
  if p <> nil then
    result := IBank_Account(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Bank/Account:1.0') then
        begin
          stub := TBank_Account_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TBank_Account.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Bank/Account:1.0'
end;

//***********************************************************
// TBank_Account_stub
//***********************************************************
function TBank_Account_stub.balance: Float;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_float, @result);
  req := StaticRequest(self,'balance');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TBank_Account_stub_clp
//***********************************************************
function TBank_Account_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Bank/Account:1.0' then
    begin
      result := Pointer(self as IBank_Account);
      exit;
  end;
end;

function TBank_Account_stub_clp.balance: Float;
var
  _srv: IServant;
  srv: IBank_Account;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBank_Account_serv._narrow(_srv);
      if srv <> nil then
        result := srv.balance
    end;
  _postinvoke();
end;

//***********************************************************
// TBank_Account_serv
//***********************************************************
constructor TBank_Account_serv.Create(const AImpl: IBank_Account);
begin
  inherited Create();
  FImplementation := AImpl;
end;

function TBank_Account_serv.balance: Float;
begin
  result := FImplementation.balance;
end;

function TBank_Account_serv._this(): IBank_Account;
var
  obj: IORBObject;
begin
  obj := this();
  result := TBank_Account._narrow(obj);
end;

function TBank_Account_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Bank/Account:1.0';
end;

function TBank_Account_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Bank/Account:1.0';
end;

function TBank_Account_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TBank_Account_stub_clp.Create(poa,obj);
end;

procedure TBank_Account_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TBank_Account_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Bank/Account:1.0' then
    begin
      result := Pointer(IBank_Account(self));
      exit;
    end;
end;

class function TBank_Account_serv._narrow(const srv : IServant): IBank_Account;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Bank/Account:1.0');
  if p <> nil then
    result := IBank_Account(p)
end;

function TBank_Account_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  balance_result: Float;
begin
  result := true;
  if req.op_name = 'balance' then
    begin
      req.set_result(StaticAny(stat_float,@balance_result) as IStaticAny);
      if not req.read_args() then  exit;
      balance_result := balance;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TBank_Account_marshaller
//***********************************************************
function TBank_Account_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IBank_Account(addr^) := TBank_Account._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TBank_Account_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IBank_Account(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TBank_Account_marshaller._free(var addr: Pointer);
begin
  IBank_Account(addr^) := nil;
end;

procedure TBank_Account_marshaller._create(var addr: Pointer);
begin
  IBank_Account(addr^) := TBank_Account_stub.Create();
end;

procedure TBank_Account_marshaller._assign(dst, src: Pointer);
begin
  IBank_Account(dst^) := IBank_Account(src^);
end;

function TBank_Account_marshaller.typecode: ITypeCode;
begin
  result := _tc_Bank_Account.typecode;
end;

//***********************************************************
// TBank_AccountEx
//***********************************************************
function TBank_AccountEx.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:Bank/AccountEx:1.0' then
    begin
      result := Pointer(self as IBank_AccountEx);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TBank_AccountEx._narrow(const obj : IORBObject): IBank_AccountEx;
var
  p: Pointer;
  stub: TBank_AccountEx_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Bank/AccountEx:1.0');
  if p <> nil then
    result := IBank_AccountEx(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Bank/AccountEx:1.0') then
        begin
          stub := TBank_AccountEx_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TBank_AccountEx.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Bank/AccountEx:1.0'
end;

//***********************************************************
// TBank_AccountEx_stub
//***********************************************************
function TBank_AccountEx_stub.balance: Float;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_float, @result);
  req := StaticRequest(self,'balance');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TBank_AccountEx_stub.debit(const value: Double);
var
  req: IStaticRequest;
  _value: IStaticAny;
begin
  _value := StaticAny(stat_double,@value);
  req := StaticRequest(self,'debit');
  req.add_in_arg(_value);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TBank_AccountEx_stub.credit(const value: Double);
var
  req: IStaticRequest;
  _value: IStaticAny;
begin
  _value := StaticAny(stat_double,@value);
  req := StaticRequest(self,'credit');
  req.add_in_arg(_value);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TBank_AccountEx_stub_clp
//***********************************************************
function TBank_AccountEx_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:Bank/AccountEx:1.0' then
    begin
      result := Pointer(self as IBank_AccountEx);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TBank_AccountEx_stub_clp.debit(const value: Double);
var
  _srv: IServant;
  srv: IBank_AccountEx;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBank_AccountEx_serv._narrow(_srv);
      if srv <> nil then
        srv.debit(value)
    end;
  _postinvoke();
end;

procedure TBank_AccountEx_stub_clp.credit(const value: Double);
var
  _srv: IServant;
  srv: IBank_AccountEx;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBank_AccountEx_serv._narrow(_srv);
      if srv <> nil then
        srv.credit(value)
    end;
  _postinvoke();
end;

//***********************************************************
// TBank_AccountEx_serv
//***********************************************************
constructor TBank_AccountEx_serv.Create(const AImpl: IBank_AccountEx);
begin
  inherited Create(AImpl);
  FImplementation := AImpl;
end;

procedure TBank_AccountEx_serv.debit(const value: Double);
begin
  FImplementation.debit(value);
end;

procedure TBank_AccountEx_serv.credit(const value: Double);
begin
  FImplementation.credit(value);
end;

function TBank_AccountEx_serv._this(): IBank_AccountEx;
var
  obj: IORBObject;
begin
  obj := this();
  result := TBank_AccountEx._narrow(obj);
end;

function TBank_AccountEx_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Bank/AccountEx:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TBank_AccountEx_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Bank/AccountEx:1.0';
end;

function TBank_AccountEx_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TBank_AccountEx_stub_clp.Create(poa,obj);
end;

procedure TBank_AccountEx_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TBank_AccountEx_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:Bank/AccountEx:1.0' then
    begin
      result := Pointer(IBank_AccountEx(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TBank_AccountEx_serv._narrow(const srv : IServant): IBank_AccountEx;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Bank/AccountEx:1.0');
  if p <> nil then
    result := IBank_AccountEx(p)
end;

function TBank_AccountEx_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  debit_value: Double;
  credit_value: Double;
begin
  result := true;
  if req.op_name = 'debit' then
    begin
      req.add_in_arg(StaticAny(stat_double,@debit_value) as IStaticAny);
      if not req.read_args() then  exit;
      debit(debit_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'credit' then
    begin
      req.add_in_arg(StaticAny(stat_double,@credit_value) as IStaticAny);
      if not req.read_args() then  exit;
      credit(credit_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TBank_AccountEx_marshaller
//***********************************************************
function TBank_AccountEx_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IBank_AccountEx(addr^) := TBank_AccountEx._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TBank_AccountEx_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IBank_AccountEx(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TBank_AccountEx_marshaller._free(var addr: Pointer);
begin
  IBank_AccountEx(addr^) := nil;
end;

procedure TBank_AccountEx_marshaller._create(var addr: Pointer);
begin
  IBank_AccountEx(addr^) := TBank_AccountEx_stub.Create();
end;

procedure TBank_AccountEx_marshaller._assign(dst, src: Pointer);
begin
  IBank_AccountEx(dst^) := IBank_AccountEx(src^);
end;

function TBank_AccountEx_marshaller.typecode: ITypeCode;
begin
  result := _tc_Bank_AccountEx.typecode;
end;

initialization
  Bank_Account_marshaller := TBank_Account_marshaller.Create();
  Bank_AccountEx_marshaller := TBank_AccountEx_marshaller.Create();
  _tc_Bank_Account := CreateTypeCodeConst('010000000e0000002c000000010000001500000049444c3a42616e6b2f4163636f756e743a312e3000000000080000004163636f756e7400');
  _tc_Bank_AccountEx := CreateTypeCodeConst('010000000e0000002e000000010000001700000049444c3a42616e6b2f4163636f756e7445783a312e3000000a0000004163636f756e74457800');
end.
