// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:27
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i../../..//idl -i./ ./\abstract.idl" 
//                                                                            
unit abstract;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, abstract_int, value_int, value, poa_int, poa;

type

  {** IDL:Describable:1.0 } 
  TDescribable = class(TAbstractBase,IDescribable)
  protected
    function get_description: AnsiString; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _downcast(const vb : IValueBase): IDescribable; 
    class function _narrow(const obj : IORBObject): IDescribable; overload;
    class function _narrow(const obj : IAbstractBase): IDescribable; overload;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Describable:1.0} 
  TDescribable_stub = class(TDescribable)
  protected
    function get_description: AnsiString; override;
  end;

  {** POA stub for interface IDL:Describable:1.0} 
  TDescribable_stub_clp = class(TPOAStub,IPOAStub,IDescribable)
  protected
    function get_description: AnsiString; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Describable:1.0} 
  TDescribable_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IDescribable)
  protected
    function get_description: AnsiString; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IDescribable;
    class function _narrow(const srv : IServant): IDescribable;
  end;

  TDescribable_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Example:1.0 } 
  TExample = class(TORBObject,IExample)
  protected
    procedure display(const anObject: IDescribable); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IExample;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Example:1.0} 
  TExample_stub = class(TExample)
  protected
    procedure display(const anObject: IDescribable); override;
  end;

  {** POA stub for interface IDL:Example:1.0} 
  TExample_stub_clp = class(TPOAStub,IPOAStub,IExample)
  protected
    procedure display(const anObject: IDescribable); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Example:1.0} 
  TExample_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IExample)
  protected
    procedure display(const anObject: IDescribable); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IExample;
    class function _narrow(const srv : IServant): IExample;
  end;

  TExample_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Account:1.0 } 
  TAccount = class(TORBObject,IDescribable,IAbstractBase,IAccount)
  protected
    function _to_object: IORBObject;
    function _to_value: IValueBase;
    function get_description: AnsiString; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IAccount;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Account:1.0} 
  TAccount_stub = class(TAccount)
  protected
    function get_description: AnsiString; override;
  end;

  {** POA stub for interface IDL:Account:1.0} 
  TAccount_stub_clp = class(TDescribable_stub_clp,IAccount)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Account:1.0} 
  TAccount_serv = class(TDescribable_serv,IAccount)
  protected
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IAccount;
    class function _narrow(const srv : IServant): IAccount;
  end;

  TAccount_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Currency:1.0 } 
  TCurrency = class(TValueBase,IDescribable,IAbstractBase,ICurrency,IValueBase)
  protected
    function _to_object: IORBObject;
    function _to_value: IValueBase;
    function get_description: AnsiString; virtual;
    function _copy_value : IValueBase; override;
    procedure _copy_members(const v: TObject); override;
    procedure _marshal_members(const enc: IEncoder); override;
    procedure _get_marshal_info(const str: TStrings;out chunked: Boolean); override;
    function  _demarshal_members(const dec: Idecoder): Boolean; override;
    function narrow_helper(const repoid: RepositoryID): Pointer; override;
  public
    class function _downcast(const vb : IValueBase): ICurrency;
  end;

  TCurrency_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  Describable_marshaller : IStaticTypeInfo;
  Example_marshaller : IStaticTypeInfo;
  Account_marshaller : IStaticTypeInfo;
  Currency_marshaller : IStaticTypeInfo;
  _tc_Describable : ITypeCodeConst;
  _tc_Example : ITypeCodeConst;
  _tc_Account : ITypeCodeConst;
  _tc_Currency : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TDescribable
//***********************************************************
function TDescribable.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Describable:1.0' then
    begin
      result := Pointer(self as IDescribable);
      exit;
    end;
end;

class function TDescribable._narrow(const obj : IAbstractBase): IDescribable;
begin
  result := _downcast(obj._to_value);
  if not assigned(result) then
    result := _narrow(obj._to_object);
end;

class function TDescribable._downcast(const vb : IValueBase): IDescribable;
begin
  result := nil;
  if assigned(vb) then
    result := IDescribable(vb.narrow_helper('IDL:Describable:1.0'));
end;

class function TDescribable._narrow(const obj : IORBObject): IDescribable;
var
  p: Pointer;
  stub: TDescribable_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Describable:1.0');
  if p <> nil then
    result := IDescribable(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Describable:1.0') then
        begin
          stub := TDescribable_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TDescribable.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Describable:1.0'
end;

//***********************************************************
// TDescribable_stub
//***********************************************************
function TDescribable_stub.get_description: AnsiString;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self._to_object,'get_description');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TDescribable_stub_clp
//***********************************************************
function TDescribable_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Describable:1.0' then
    begin
      result := Pointer(self as IDescribable);
      exit;
  end;
end;

function TDescribable_stub_clp.get_description: AnsiString;
var
  _srv: IServant;
  srv: IDescribable;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TDescribable_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_description
    end;
  _postinvoke();
end;

//***********************************************************
// TDescribable_serv
//***********************************************************
function TDescribable_serv._this(): IDescribable;
var
  obj: IORBObject;
begin
  obj := this();
  result := TDescribable._narrow(obj);
end;

function TDescribable_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Describable:1.0';
end;

function TDescribable_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Describable:1.0';
end;

function TDescribable_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TDescribable_stub_clp.Create(poa,obj);
end;

procedure TDescribable_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TDescribable_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Describable:1.0' then
    begin
      result := Pointer(IDescribable(self));
      exit;
    end;
end;

class function TDescribable_serv._narrow(const srv : IServant): IDescribable;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Describable:1.0');
  if p <> nil then
    result := IDescribable(p)
end;

function TDescribable_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  get_description_result: AnsiString;
begin
  result := true;
  if req.op_name = 'get_description' then
    begin
      req.set_result(StaticAny(stat_string,@get_description_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_description_result := get_description;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TDescribable_marshaller
//***********************************************************
function TDescribable_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  ab: IAbstractBase;
begin
  result := false;
  if not TAbstractBase._demarshal(dec,ab) then exit;
  IDescribable(addr^) := TDescribable._narrow(ab);
  result := (ab = nil) or (Pointer(addr^) <> nil);
end;

procedure TDescribable_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  TAbstractBase._marshal(enc,IDescribable(addr^) as IAbstractBase);
end;

procedure TDescribable_marshaller._free(var addr: Pointer);
begin
  IDescribable(addr^) := nil;
end;

procedure TDescribable_marshaller._create(var addr: Pointer);
begin
  IDescribable(addr^) := TDescribable_stub.Create();
end;

procedure TDescribable_marshaller._assign(dst, src: Pointer);
begin
  IDescribable(dst^) := IDescribable(src^);
end;

function TDescribable_marshaller.typecode: ITypeCode;
begin
  result := _tc_Describable.typecode;
end;

//***********************************************************
// TExample
//***********************************************************
function TExample.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Example:1.0' then
    begin
      result := Pointer(self as IExample);
      exit;
    end;
end;

class function TExample._narrow(const obj : IORBObject): IExample;
var
  p: Pointer;
  stub: TExample_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Example:1.0');
  if p <> nil then
    result := IExample(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Example:1.0') then
        begin
          stub := TExample_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TExample.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Example:1.0'
end;

//***********************************************************
// TExample_stub
//***********************************************************
procedure TExample_stub.display(const anObject: IDescribable);
var
  req: IStaticRequest;
  _anObject: IStaticAny;
begin
  _anObject := StaticAny(Describable_marshaller,@anObject);
  req := StaticRequest(self,'display');
  req.add_in_arg(_anObject);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TExample_stub_clp
//***********************************************************
function TExample_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Example:1.0' then
    begin
      result := Pointer(self as IExample);
      exit;
  end;
end;

procedure TExample_stub_clp.display(const anObject: IDescribable);
var
  _srv: IServant;
  srv: IExample;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TExample_serv._narrow(_srv);
      if srv <> nil then
        srv.display(anObject)
    end;
  _postinvoke();
end;

//***********************************************************
// TExample_serv
//***********************************************************
function TExample_serv._this(): IExample;
var
  obj: IORBObject;
begin
  obj := this();
  result := TExample._narrow(obj);
end;

function TExample_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Example:1.0';
end;

function TExample_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Example:1.0';
end;

function TExample_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TExample_stub_clp.Create(poa,obj);
end;

procedure TExample_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TExample_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Example:1.0' then
    begin
      result := Pointer(IExample(self));
      exit;
    end;
end;

class function TExample_serv._narrow(const srv : IServant): IExample;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Example:1.0');
  if p <> nil then
    result := IExample(p)
end;

function TExample_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  display_anObject: IDescribable;
begin
  result := true;
  if req.op_name = 'display' then
    begin
      req.add_in_arg(StaticAny(Describable_marshaller,@display_anObject) as IStaticAny);
      if not req.read_args() then  exit;
      display(display_anObject);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TExample_marshaller
//***********************************************************
function TExample_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IExample(addr^) := TExample._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TExample_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IExample(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TExample_marshaller._free(var addr: Pointer);
begin
  IExample(addr^) := nil;
end;

procedure TExample_marshaller._create(var addr: Pointer);
begin
  IExample(addr^) := TExample_stub.Create();
end;

procedure TExample_marshaller._assign(dst, src: Pointer);
begin
  IExample(dst^) := IExample(src^);
end;

function TExample_marshaller.typecode: ITypeCode;
begin
  result := _tc_Example.typecode;
end;

//***********************************************************
// TAccount
//***********************************************************
function TAccount.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Account:1.0' then
    begin
      result := Pointer(self as IAccount);
      exit;
    end;
  if str = 'IDL:Describable:1.0' then
    begin
      result := Pointer(self as IDescribable);
      exit;
    end;
end;

function TAccount._to_object: IORBObject;
begin
  result := self;
end;

function TAccount._to_value: IValueBase;
begin
  result := nil;
end;

class function TAccount._narrow(const obj : IORBObject): IAccount;
var
  p: Pointer;
  stub: TAccount_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Account:1.0');
  if p <> nil then
    result := IAccount(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Account:1.0') then
        begin
          stub := TAccount_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TAccount.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Account:1.0'
end;

//***********************************************************
// TAccount_stub
//***********************************************************
function TAccount_stub.get_description: AnsiString;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'get_description');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TAccount_stub_clp
//***********************************************************
function TAccount_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Account:1.0' then
    begin
      result := Pointer(self as IAccount);
      exit;
    end
  else if str = 'IDL:Describable:1.0' then
    begin
      result := Pointer(self as IDescribable);
      exit;
    end;
end;

//***********************************************************
// TAccount_serv
//***********************************************************
function TAccount_serv._this(): IAccount;
var
  obj: IORBObject;
begin
  obj := this();
  result := TAccount._narrow(obj);
end;

function TAccount_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Account:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TAccount_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Account:1.0';
end;

function TAccount_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TAccount_stub_clp.Create(poa,obj);
end;

procedure TAccount_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TAccount_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:Account:1.0' then
    begin
      result := Pointer(IAccount(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TAccount_serv._narrow(const srv : IServant): IAccount;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Account:1.0');
  if p <> nil then
    result := IAccount(p)
end;

function TAccount_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TAccount_marshaller
//***********************************************************
function TAccount_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IAccount(addr^) := TAccount._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TAccount_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IAccount(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TAccount_marshaller._free(var addr: Pointer);
begin
  IAccount(addr^) := nil;
end;

procedure TAccount_marshaller._create(var addr: Pointer);
begin
  IAccount(addr^) := TAccount_stub.Create();
end;

procedure TAccount_marshaller._assign(dst, src: Pointer);
begin
  IAccount(dst^) := IAccount(src^);
end;

function TAccount_marshaller.typecode: ITypeCode;
begin
  result := _tc_Account.typecode;
end;

//***********************************************************
// TCurrency
//***********************************************************
function TCurrency._to_object: IORBObject;
begin
  result := nil;
end;

function TCurrency._to_value: IValueBase;
begin
  result := self;
end;

function TCurrency.get_description: AnsiString;
begin
  result := '';
end;

function TCurrency.narrow_helper(const repoid: RepositoryID): Pointer;
begin
  if strcomp(PAnsiChar(repoid),'IDL:Currency:1.0') = 0 then
    result := Pointer(Self as ICurrency)
  else if strcomp(PAnsiChar(repoid),'IDL:Describable:1.0') = 0 then
    result := Pointer(Self as IDescribable)
  else
    result := nil;
end;

class function TCurrency._downcast(const vb : IValueBase): ICurrency;
var
  ptr: pointer;
begin
  result := nil;
  if vb <> nil then
    begin
      ptr := vb.narrow_helper('IDL:Currency:1.0');
      if ptr <> nil then
        result := ICurrency(ptr);
    end;
end;

procedure TCurrency._get_marshal_info(const str: TStrings; out chunked: Boolean);
begin
  str.Add('IDL:Currency:1.0');
  chunked := false;
end;

procedure TCurrency._marshal_members(const enc: IEncoder);
begin
end;

function  TCurrency._demarshal_members(const dec: IDecoder): Boolean;
begin
  result := true;
end;

procedure TCurrency._copy_members(const v: TObject);
begin
  inherited _copy_members(v);
end;

function  TCurrency._copy_value: IValueBase;
var
  list: TStrings;
begin
  list := TStringList.Create;
  try
    result := _create(list,'IDL:Currency:1.0');
    result._copy_members(self);
  finally
    list.free;
  end;
end;

//***********************************************************
// TCurrency_marshaller
//***********************************************************
procedure TCurrency_marshaller._create(var addr: Pointer);
begin
  ICurrency(addr^) := TCurrency.Create as ICurrency;
end;

procedure TCurrency_marshaller._assign(dst, src: Pointer);
begin
  ICurrency(dst^) := ICurrency(src^);
end;

procedure TCurrency_marshaller._free(var addr: Pointer);
begin
  ICurrency(addr^) := nil;
end;

function TCurrency_marshaller.demarshal(dec: IDecoder;
  const addr: Pointer): Boolean;
var
  vb : IValueBase;
begin
  result := TValueBase._demarshal(dec,vb,'IDL:Currency:1.0');
  if not result then exit;
  ICurrency(addr^) := TCurrency._downcast(vb);
  result := (vb = nil) or (vb <> nil) and (Pointer(addr^) <> nil);
end;

procedure TCurrency_marshaller.marshal(enc: IEncoder; const addr: Pointer);
begin
  TValueBase._marshal(enc,ICurrency(addr^) as IValueBase);
end;

function TCurrency_marshaller.typecode: ITypeCode;
begin
  result := _tc_Currency.typecode;
end;

initialization
  Describable_marshaller := TDescribable_marshaller.Create();
  Example_marshaller := TExample_marshaller.Create();
  Account_marshaller := TAccount_marshaller.Create();
  Currency_marshaller := TCurrency_marshaller.Create();
  _tc_Describable := CreateTypeCodeConst('010000000e0000002c000000010000001400000049444c3a4465736372696261626c653a312e30000c0000004465736372696261626c6500');
  _tc_Example := CreateTypeCodeConst('010000000e00000024000000010000001000000049444c3a4578616d706c653a312e3000080000004578616d706c6500');
  _tc_Account := CreateTypeCodeConst('010000000e00000024000000010000001000000049444c3a4163636f756e743a312e3000080000004163636f756e7400');
  _tc_Currency := CreateTypeCodeConst('010000001d00000034000000010000001100000049444c3a43757272656e63793a312e30000000000900000043757272656e6379000000'+
    '000000000000000000');
end.
