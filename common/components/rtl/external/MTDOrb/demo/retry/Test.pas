// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:27
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i../..//idl -i./ ./\Test.idl" 
//                                                                            
unit Test;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, Test_int, poa_int, poa;

type

  {** IDL:Test:1.0 } 
  TTest = class(TORBObject,ITest)
  protected
    procedure aMethod; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ITest;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Test:1.0} 
  TTest_stub = class(TTest)
  protected
    procedure aMethod; override;
  end;

  {** POA stub for interface IDL:Test:1.0} 
  TTest_stub_clp = class(TPOAStub,IPOAStub,ITest)
  protected
    procedure aMethod; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Test:1.0} 
  TTest_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ITest)
  protected
    procedure aMethod; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ITest;
    class function _narrow(const srv : IServant): ITest;
  end;

  TTest_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Retry:1.0 } 
  TRetry = class(TTest,IRetry)
  protected
    function get_count: _ulong; virtual; abstract;
    procedure raise_exception(const max: _ulong; const maybe: Boolean); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IRetry;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Retry:1.0} 
  TRetry_stub = class(TRetry)
  protected
    procedure aMethod; override;
    function get_count: _ulong; override;
    procedure raise_exception(const max: _ulong; const maybe: Boolean); override;
  end;

  {** POA stub for interface IDL:Retry:1.0} 
  TRetry_stub_clp = class(TTest_stub_clp,IRetry)
  protected
    function get_count: _ulong; virtual;
    procedure raise_exception(const max: _ulong; const maybe: Boolean); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Retry:1.0} 
  TRetry_serv = class(TTest_serv,IRetry)
  protected
    function get_count: _ulong; virtual; abstract;
    procedure raise_exception(const max: _ulong; const maybe: Boolean); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IRetry;
    class function _narrow(const srv : IServant): IRetry;
  end;

  TRetry_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:RetryServer:1.0 } 
  TRetryServer = class(TORBObject,IRetryServer)
  protected
    function get_location_forward_object: ITest; virtual; abstract;
    function get_retry_object: IRetry; virtual; abstract;
    procedure deactivate; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IRetryServer;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:RetryServer:1.0} 
  TRetryServer_stub = class(TRetryServer)
  protected
    function get_location_forward_object: ITest; override;
    function get_retry_object: IRetry; override;
    procedure deactivate; override;
  end;

  {** POA stub for interface IDL:RetryServer:1.0} 
  TRetryServer_stub_clp = class(TPOAStub,IPOAStub,IRetryServer)
  protected
    function get_location_forward_object: ITest; virtual;
    function get_retry_object: IRetry; virtual;
    procedure deactivate; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:RetryServer:1.0} 
  TRetryServer_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IRetryServer)
  protected
    function get_location_forward_object: ITest; virtual; abstract;
    function get_retry_object: IRetry; virtual; abstract;
    procedure deactivate; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IRetryServer;
    class function _narrow(const srv : IServant): IRetryServer;
  end;

  TRetryServer_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  Test_marshaller : IStaticTypeInfo;
  Retry_marshaller : IStaticTypeInfo;
  RetryServer_marshaller : IStaticTypeInfo;
  _tc_Test : ITypeCodeConst;
  _tc_Retry : ITypeCodeConst;
  _tc_RetryServer : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TTest
//***********************************************************
function TTest.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Test:1.0' then
    begin
      result := Pointer(self as ITest);
      exit;
    end;
end;

class function TTest._narrow(const obj : IORBObject): ITest;
var
  p: Pointer;
  stub: TTest_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Test:1.0');
  if p <> nil then
    result := ITest(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Test:1.0') then
        begin
          stub := TTest_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TTest.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Test:1.0'
end;

//***********************************************************
// TTest_stub
//***********************************************************
procedure TTest_stub.aMethod;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'aMethod');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TTest_stub_clp
//***********************************************************
function TTest_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Test:1.0' then
    begin
      result := Pointer(self as ITest);
      exit;
  end;
end;

procedure TTest_stub_clp.aMethod;
var
  _srv: IServant;
  srv: ITest;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTest_serv._narrow(_srv);
      if srv <> nil then
        srv.aMethod
    end;
  _postinvoke();
end;

//***********************************************************
// TTest_serv
//***********************************************************
function TTest_serv._this(): ITest;
var
  obj: IORBObject;
begin
  obj := this();
  result := TTest._narrow(obj);
end;

function TTest_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Test:1.0';
end;

function TTest_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Test:1.0';
end;

function TTest_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TTest_stub_clp.Create(poa,obj);
end;

procedure TTest_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TTest_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Test:1.0' then
    begin
      result := Pointer(ITest(self));
      exit;
    end;
end;

class function TTest_serv._narrow(const srv : IServant): ITest;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Test:1.0');
  if p <> nil then
    result := ITest(p)
end;

function TTest_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if req.op_name = 'aMethod' then
    begin
      if not req.read_args() then  exit;
      aMethod;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TTest_marshaller
//***********************************************************
function TTest_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ITest(addr^) := TTest._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TTest_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ITest(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TTest_marshaller._free(var addr: Pointer);
begin
  ITest(addr^) := nil;
end;

procedure TTest_marshaller._create(var addr: Pointer);
begin
  ITest(addr^) := TTest_stub.Create();
end;

procedure TTest_marshaller._assign(dst, src: Pointer);
begin
  ITest(dst^) := ITest(src^);
end;

function TTest_marshaller.typecode: ITypeCode;
begin
  result := _tc_Test.typecode;
end;

//***********************************************************
// TRetry
//***********************************************************
function TRetry.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:Retry:1.0' then
    begin
      result := Pointer(self as IRetry);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TRetry._narrow(const obj : IORBObject): IRetry;
var
  p: Pointer;
  stub: TRetry_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Retry:1.0');
  if p <> nil then
    result := IRetry(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Retry:1.0') then
        begin
          stub := TRetry_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TRetry.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Retry:1.0'
end;

//***********************************************************
// TRetry_stub
//***********************************************************
procedure TRetry_stub.aMethod;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'aMethod');
  req.invoke;
  dorb_static_throw(req);
end;

function TRetry_stub.get_count: _ulong;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulong, @result);
  req := StaticRequest(self,'get_count');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TRetry_stub.raise_exception(const max: _ulong; const maybe: Boolean);
var
  req: IStaticRequest;
  _max: IStaticAny;
  _maybe: IStaticAny;
begin
  _max := StaticAny(stat_ulong,@max);
  _maybe := StaticAny(stat_boolean,@maybe);
  req := StaticRequest(self,'raise_exception');
  req.add_in_arg(_max);
  req.add_in_arg(_maybe);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TRetry_stub_clp
//***********************************************************
function TRetry_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:Retry:1.0' then
    begin
      result := Pointer(self as IRetry);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TRetry_stub_clp.get_count: _ulong;
var
  _srv: IServant;
  srv: IRetry;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRetry_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_count
    end;
  _postinvoke();
end;

procedure TRetry_stub_clp.raise_exception(const max: _ulong; const maybe: Boolean);
var
  _srv: IServant;
  srv: IRetry;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRetry_serv._narrow(_srv);
      if srv <> nil then
        srv.raise_exception(max, maybe)
    end;
  _postinvoke();
end;

//***********************************************************
// TRetry_serv
//***********************************************************
function TRetry_serv._this(): IRetry;
var
  obj: IORBObject;
begin
  obj := this();
  result := TRetry._narrow(obj);
end;

function TRetry_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Retry:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TRetry_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Retry:1.0';
end;

function TRetry_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TRetry_stub_clp.Create(poa,obj);
end;

procedure TRetry_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TRetry_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:Retry:1.0' then
    begin
      result := Pointer(IRetry(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TRetry_serv._narrow(const srv : IServant): IRetry;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Retry:1.0');
  if p <> nil then
    result := IRetry(p)
end;

function TRetry_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  get_count_result: _ulong;
  raise_exception_max: _ulong;
  raise_exception_maybe: Boolean;
begin
  result := true;
  if req.op_name = 'get_count' then
    begin
      req.set_result(StaticAny(stat_ulong,@get_count_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_count_result := get_count;
      req.write_results();
      exit;
    end
  else if req.op_name = 'raise_exception' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@raise_exception_max) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@raise_exception_maybe) as IStaticAny);
      if not req.read_args() then  exit;
      raise_exception(raise_exception_max, raise_exception_maybe);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TRetry_marshaller
//***********************************************************
function TRetry_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IRetry(addr^) := TRetry._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TRetry_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IRetry(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TRetry_marshaller._free(var addr: Pointer);
begin
  IRetry(addr^) := nil;
end;

procedure TRetry_marshaller._create(var addr: Pointer);
begin
  IRetry(addr^) := TRetry_stub.Create();
end;

procedure TRetry_marshaller._assign(dst, src: Pointer);
begin
  IRetry(dst^) := IRetry(src^);
end;

function TRetry_marshaller.typecode: ITypeCode;
begin
  result := _tc_Retry.typecode;
end;

//***********************************************************
// TRetryServer
//***********************************************************
function TRetryServer.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:RetryServer:1.0' then
    begin
      result := Pointer(self as IRetryServer);
      exit;
    end;
end;

class function TRetryServer._narrow(const obj : IORBObject): IRetryServer;
var
  p: Pointer;
  stub: TRetryServer_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:RetryServer:1.0');
  if p <> nil then
    result := IRetryServer(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:RetryServer:1.0') then
        begin
          stub := TRetryServer_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TRetryServer.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:RetryServer:1.0'
end;

//***********************************************************
// TRetryServer_stub
//***********************************************************
function TRetryServer_stub.get_location_forward_object: ITest;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Test_marshaller, @result);
  req := StaticRequest(self,'get_location_forward_object');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRetryServer_stub.get_retry_object: IRetry;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Retry_marshaller, @result);
  req := StaticRequest(self,'get_retry_object');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TRetryServer_stub.deactivate;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'deactivate');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TRetryServer_stub_clp
//***********************************************************
function TRetryServer_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:RetryServer:1.0' then
    begin
      result := Pointer(self as IRetryServer);
      exit;
  end;
end;

function TRetryServer_stub_clp.get_location_forward_object: ITest;
var
  _srv: IServant;
  srv: IRetryServer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRetryServer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_location_forward_object
    end;
  _postinvoke();
end;

function TRetryServer_stub_clp.get_retry_object: IRetry;
var
  _srv: IServant;
  srv: IRetryServer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRetryServer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_retry_object
    end;
  _postinvoke();
end;

procedure TRetryServer_stub_clp.deactivate;
var
  _srv: IServant;
  srv: IRetryServer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRetryServer_serv._narrow(_srv);
      if srv <> nil then
        srv.deactivate
    end;
  _postinvoke();
end;

//***********************************************************
// TRetryServer_serv
//***********************************************************
function TRetryServer_serv._this(): IRetryServer;
var
  obj: IORBObject;
begin
  obj := this();
  result := TRetryServer._narrow(obj);
end;

function TRetryServer_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:RetryServer:1.0';
end;

function TRetryServer_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:RetryServer:1.0';
end;

function TRetryServer_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TRetryServer_stub_clp.Create(poa,obj);
end;

procedure TRetryServer_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TRetryServer_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:RetryServer:1.0' then
    begin
      result := Pointer(IRetryServer(self));
      exit;
    end;
end;

class function TRetryServer_serv._narrow(const srv : IServant): IRetryServer;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:RetryServer:1.0');
  if p <> nil then
    result := IRetryServer(p)
end;

function TRetryServer_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  get_location_forward_object_result: ITest;
  get_retry_object_result: IRetry;
begin
  result := true;
  if req.op_name = 'get_location_forward_object' then
    begin
      req.set_result(StaticAny(Test_marshaller,@get_location_forward_object_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_location_forward_object_result := get_location_forward_object;
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_retry_object' then
    begin
      req.set_result(StaticAny(Retry_marshaller,@get_retry_object_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_retry_object_result := get_retry_object;
      req.write_results();
      exit;
    end
  else if req.op_name = 'deactivate' then
    begin
      if not req.read_args() then  exit;
      deactivate;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TRetryServer_marshaller
//***********************************************************
function TRetryServer_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IRetryServer(addr^) := TRetryServer._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TRetryServer_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IRetryServer(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TRetryServer_marshaller._free(var addr: Pointer);
begin
  IRetryServer(addr^) := nil;
end;

procedure TRetryServer_marshaller._create(var addr: Pointer);
begin
  IRetryServer(addr^) := TRetryServer_stub.Create();
end;

procedure TRetryServer_marshaller._assign(dst, src: Pointer);
begin
  IRetryServer(dst^) := IRetryServer(src^);
end;

function TRetryServer_marshaller.typecode: ITypeCode;
begin
  result := _tc_RetryServer.typecode;
end;

initialization
  Test_marshaller := TTest_marshaller.Create();
  Retry_marshaller := TRetry_marshaller.Create();
  RetryServer_marshaller := TRetryServer_marshaller.Create();
  _tc_Test := CreateTypeCodeConst('010000000e00000021000000010000000d00000049444c3a546573743a312e3000000000050000005465737400');
  _tc_Retry := CreateTypeCodeConst('010000000e00000022000000010000000e00000049444c3a52657472793a312e3000000006000000526574727900');
  _tc_RetryServer := CreateTypeCodeConst('010000000e0000002c000000010000001400000049444c3a52657472795365727665723a312e30000c000000526574727953657276657200');
end.
