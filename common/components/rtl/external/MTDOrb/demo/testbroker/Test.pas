// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:27
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i../..//idl -i./ ./\Test.idl" 
//                                                                            
unit Test;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, Test_int, poa_int, poa;

type

  TTestStruct_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TTestEnum_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TTestException_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:TestException:1.0 } 
  TTestException = class(UserException,ITestException)
  private
    Fmessage : AnsiString;
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
    procedure message(const val : AnsiString); overload;
  public
    function message: AnsiString; overload;
    constructor Create(ex: TTestException); overload;
    constructor Create(_message: AnsiString = ''); overload;
  end;

  {** IDL:TestIntfFactory:1.0 } 
  TTestIntfFactory = class(TORBObject,ITestIntfFactory)
  protected
    function create_test_intf: ITestIntf; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ITestIntfFactory;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:TestIntfFactory:1.0} 
  TTestIntfFactory_stub = class(TTestIntfFactory)
  protected
    function create_test_intf: ITestIntf; override;
  end;

  {** POA stub for interface IDL:TestIntfFactory:1.0} 
  TTestIntfFactory_stub_clp = class(TPOAStub,IPOAStub,ITestIntfFactory)
  protected
    function create_test_intf: ITestIntf; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:TestIntfFactory:1.0} 
  TTestIntfFactory_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ITestIntfFactory)
  protected
    function create_test_intf: ITestIntf; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ITestIntfFactory;
    class function _narrow(const srv : IServant): ITestIntfFactory;
  end;

  TTestIntfFactory_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:TestIntf:1.0 } 
  TTestIntf = class(TORBObject,ITestIntf)
  protected
    function check_short(const value_in: Short; var value_inout: Short; out value_out: Short): Short; virtual; abstract;
    function check_long(const value_in: long; var value_inout: long; out value_out: long): long; virtual; abstract;
    function check_unsigned_short(const value_in: _ushort; var value_inout: _ushort; out value_out: _ushort): _ushort; virtual; abstract;
    function check_unsigned_long(const value_in: _ulong; var value_inout: _ulong; out value_out: _ulong): _ulong; virtual; abstract;
    function check_float(const value_in: Float; var value_inout: Float; out value_out: Float): Float; virtual; abstract;
    function check_double(const value_in: Double; var value_inout: Double; out value_out: Double): Double; virtual; abstract;
    function check_boolean(const value_in: Boolean; var value_inout: Boolean; out value_out: Boolean): Boolean; virtual; abstract;
    function check_char(const value_in: AnsiChar; var value_inout: AnsiChar; out value_out: AnsiChar): AnsiChar; virtual; abstract;
    function check_octet(const value_in: octet; var value_inout: octet; out value_out: octet): octet; virtual; abstract;
    function check_string(const value_in: AnsiString; var value_inout: AnsiString; out value_out: AnsiString): AnsiString; virtual; abstract;
    function check_longlong(const value_in: longlong; var value_inout: longlong; out value_out: longlong): longlong; virtual; abstract;
    function check_unsigned_longlong(const value_in: _ulonglong; var value_inout: _ulonglong; out value_out: _ulonglong): _ulonglong; virtual; abstract;
    function check_wchar(const value_in: WideChar; var value_inout: WideChar; out value_out: WideChar): WideChar; virtual; abstract;
    function check_wstring(const value_in: WideString; var value_inout: WideString; out value_out: WideString): WideString; virtual; abstract;
    function check_octet_seq(const value_in: TTestOctetSeq; var value_inout: TTestOctetSeq; out value_out: TTestOctetSeq): TTestOctetSeq; virtual; abstract;
    function check_struct(const value_in: TTestStruct; var value_inout: TTestStruct; out value_out: TTestStruct): TTestStruct; virtual; abstract;
    function check_enum(const value_in: TTestEnum; var value_inout: TTestEnum; out value_out: TTestEnum): TTestEnum; virtual; abstract;
    function check_obj(const value_in: ITestIntf; var value_inout: ITestIntf; out value_out: ITestIntf): ITestIntf; virtual; abstract;
    procedure check_exception(const mes: AnsiString); virtual; abstract;
    procedure deactivate; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ITestIntf;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:TestIntf:1.0} 
  TTestIntf_stub = class(TTestIntf)
  protected
    function check_short(const value_in: Short; var value_inout: Short; out value_out: Short): Short; override;
    function check_long(const value_in: long; var value_inout: long; out value_out: long): long; override;
    function check_unsigned_short(const value_in: _ushort; var value_inout: _ushort; out value_out: _ushort): _ushort; override;
    function check_unsigned_long(const value_in: _ulong; var value_inout: _ulong; out value_out: _ulong): _ulong; override;
    function check_float(const value_in: Float; var value_inout: Float; out value_out: Float): Float; override;
    function check_double(const value_in: Double; var value_inout: Double; out value_out: Double): Double; override;
    function check_boolean(const value_in: Boolean; var value_inout: Boolean; out value_out: Boolean): Boolean; override;
    function check_char(const value_in: AnsiChar; var value_inout: AnsiChar; out value_out: AnsiChar): AnsiChar; override;
    function check_octet(const value_in: octet; var value_inout: octet; out value_out: octet): octet; override;
    function check_string(const value_in: AnsiString; var value_inout: AnsiString; out value_out: AnsiString): AnsiString; override;
    function check_longlong(const value_in: longlong; var value_inout: longlong; out value_out: longlong): longlong; override;
    function check_unsigned_longlong(const value_in: _ulonglong; var value_inout: _ulonglong; out value_out: _ulonglong): _ulonglong; override;
    function check_wchar(const value_in: WideChar; var value_inout: WideChar; out value_out: WideChar): WideChar; override;
    function check_wstring(const value_in: WideString; var value_inout: WideString; out value_out: WideString): WideString; override;
    function check_octet_seq(const value_in: TTestOctetSeq; var value_inout: TTestOctetSeq; out value_out: TTestOctetSeq): TTestOctetSeq; override;
    function check_struct(const value_in: TTestStruct; var value_inout: TTestStruct; out value_out: TTestStruct): TTestStruct; override;
    function check_enum(const value_in: TTestEnum; var value_inout: TTestEnum; out value_out: TTestEnum): TTestEnum; override;
    function check_obj(const value_in: ITestIntf; var value_inout: ITestIntf; out value_out: ITestIntf): ITestIntf; override;
    procedure check_exception(const mes: AnsiString); override;
    procedure deactivate; override;
  end;

  {** POA stub for interface IDL:TestIntf:1.0} 
  TTestIntf_stub_clp = class(TPOAStub,IPOAStub,ITestIntf)
  protected
    function check_short(const value_in: Short; var value_inout: Short; out value_out: Short): Short; virtual;
    function check_long(const value_in: long; var value_inout: long; out value_out: long): long; virtual;
    function check_unsigned_short(const value_in: _ushort; var value_inout: _ushort; out value_out: _ushort): _ushort; virtual;
    function check_unsigned_long(const value_in: _ulong; var value_inout: _ulong; out value_out: _ulong): _ulong; virtual;
    function check_float(const value_in: Float; var value_inout: Float; out value_out: Float): Float; virtual;
    function check_double(const value_in: Double; var value_inout: Double; out value_out: Double): Double; virtual;
    function check_boolean(const value_in: Boolean; var value_inout: Boolean; out value_out: Boolean): Boolean; virtual;
    function check_char(const value_in: AnsiChar; var value_inout: AnsiChar; out value_out: AnsiChar): AnsiChar; virtual;
    function check_octet(const value_in: octet; var value_inout: octet; out value_out: octet): octet; virtual;
    function check_string(const value_in: AnsiString; var value_inout: AnsiString; out value_out: AnsiString): AnsiString; virtual;
    function check_longlong(const value_in: longlong; var value_inout: longlong; out value_out: longlong): longlong; virtual;
    function check_unsigned_longlong(const value_in: _ulonglong; var value_inout: _ulonglong; out value_out: _ulonglong): _ulonglong; virtual;
    function check_wchar(const value_in: WideChar; var value_inout: WideChar; out value_out: WideChar): WideChar; virtual;
    function check_wstring(const value_in: WideString; var value_inout: WideString; out value_out: WideString): WideString; virtual;
    function check_octet_seq(const value_in: TTestOctetSeq; var value_inout: TTestOctetSeq; out value_out: TTestOctetSeq): TTestOctetSeq; virtual;
    function check_struct(const value_in: TTestStruct; var value_inout: TTestStruct; out value_out: TTestStruct): TTestStruct; virtual;
    function check_enum(const value_in: TTestEnum; var value_inout: TTestEnum; out value_out: TTestEnum): TTestEnum; virtual;
    function check_obj(const value_in: ITestIntf; var value_inout: ITestIntf; out value_out: ITestIntf): ITestIntf; virtual;
    procedure check_exception(const mes: AnsiString); virtual;
    procedure deactivate; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:TestIntf:1.0} 
  TTestIntf_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ITestIntf)
  protected
    function check_short(const value_in: Short; var value_inout: Short; out value_out: Short): Short; virtual; abstract;
    function check_long(const value_in: long; var value_inout: long; out value_out: long): long; virtual; abstract;
    function check_unsigned_short(const value_in: _ushort; var value_inout: _ushort; out value_out: _ushort): _ushort; virtual; abstract;
    function check_unsigned_long(const value_in: _ulong; var value_inout: _ulong; out value_out: _ulong): _ulong; virtual; abstract;
    function check_float(const value_in: Float; var value_inout: Float; out value_out: Float): Float; virtual; abstract;
    function check_double(const value_in: Double; var value_inout: Double; out value_out: Double): Double; virtual; abstract;
    function check_boolean(const value_in: Boolean; var value_inout: Boolean; out value_out: Boolean): Boolean; virtual; abstract;
    function check_char(const value_in: AnsiChar; var value_inout: AnsiChar; out value_out: AnsiChar): AnsiChar; virtual; abstract;
    function check_octet(const value_in: octet; var value_inout: octet; out value_out: octet): octet; virtual; abstract;
    function check_string(const value_in: AnsiString; var value_inout: AnsiString; out value_out: AnsiString): AnsiString; virtual; abstract;
    function check_longlong(const value_in: longlong; var value_inout: longlong; out value_out: longlong): longlong; virtual; abstract;
    function check_unsigned_longlong(const value_in: _ulonglong; var value_inout: _ulonglong; out value_out: _ulonglong): _ulonglong; virtual; abstract;
    function check_wchar(const value_in: WideChar; var value_inout: WideChar; out value_out: WideChar): WideChar; virtual; abstract;
    function check_wstring(const value_in: WideString; var value_inout: WideString; out value_out: WideString): WideString; virtual; abstract;
    function check_octet_seq(const value_in: TTestOctetSeq; var value_inout: TTestOctetSeq; out value_out: TTestOctetSeq): TTestOctetSeq; virtual; abstract;
    function check_struct(const value_in: TTestStruct; var value_inout: TTestStruct; out value_out: TTestStruct): TTestStruct; virtual; abstract;
    function check_enum(const value_in: TTestEnum; var value_inout: TTestEnum; out value_out: TTestEnum): TTestEnum; virtual; abstract;
    function check_obj(const value_in: ITestIntf; var value_inout: ITestIntf; out value_out: ITestIntf): ITestIntf; virtual; abstract;
    procedure check_exception(const mes: AnsiString); virtual; abstract;
    procedure deactivate; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ITestIntf;
    class function _narrow(const srv : IServant): ITestIntf;
  end;

  TTestIntf_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  TestStruct_marshaller : IStaticTypeInfo;
  TestEnum_marshaller : IStaticTypeInfo;
  TestException_marshaller : IStaticTypeInfo;
  TestIntfFactory_marshaller : IStaticTypeInfo;
  TestIntf_marshaller : IStaticTypeInfo;
  _tc_TestStruct : ITypeCodeConst;
  _tc_TestEnum : ITypeCodeConst;
  _tc_TestException : ITypeCodeConst;
  _tc_TestIntfFactory : ITypeCodeConst;
  _tc_TestIntf : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TTestStruct_marshaller
//***********************************************************
function TTestStruct_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: Test_int.TTestStruct;
begin
  result := false;
  if not stat_long.demarshal(dec,@struct.value_long) then exit;
  if not stat_string.demarshal(dec,@struct.value_string) then exit;
  Test_int.TTestStruct(addr^) := struct;
  result := true;
end;

procedure TTestStruct_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: Test_int.TTestStruct;
begin
  struct := Test_int.TTestStruct(addr^);
  stat_long.marshal(enc,@struct.value_long);
  stat_string.marshal(enc,@struct.value_string);
end;

procedure TTestStruct_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(Test_int.TTestStruct(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TTestStruct_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(Test_int.TTestStruct));
{$HINTS OFF}
  System.Initialize(Test_int.TTestStruct(addr^));
{$HINTS ON}
end;

procedure TTestStruct_marshaller._assign(dst, src: Pointer);
begin
  Test_int.TTestStruct(dst^) := Test_int.TTestStruct(src^);
end;

function TTestStruct_marshaller.typecode: ITypeCode;
begin
  result := _tc_TestStruct.typecode;
end;

//***********************************************************
// TTestEnum_marshaller
//***********************************************************
function TTestEnum_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TTestEnum_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TTestEnum_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TTestEnum_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TTestEnum_marshaller._assign(dst, src: Pointer);
begin
  TTestEnum(dst^) := TTestEnum(src^);
end;

function TTestEnum_marshaller.typecode: ITypeCode;
begin
  result := _tc_TestEnum.typecode;
end;

//***********************************************************
// TTestException_marshaller
//***********************************************************
function TTestException_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
  _message: AnsiString;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not stat_string.demarshal(dec,@_message) then exit;
  ITestException(addr^).message(_message);
  if not dec.except_end then exit;
  result := true;
end;

procedure TTestException_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  _message: AnsiString;
begin
  enc.except_begin('IDL:TestException:1.0');
  _message:= ITestException(addr^).message;
  stat_string.marshal(enc,@_message);
  enc.except_end;
end;

procedure TTestException_marshaller._free(var addr: Pointer);
begin
  ITestException(addr^) := nil;
end;

procedure TTestException_marshaller._create(var addr: Pointer);
begin
  ITestException(addr^) := TTestException.Create();
end;

procedure TTestException_marshaller._assign(dst, src: Pointer);
begin
  ITestException(dst^) := ITestException(src^);
end;

function TTestException_marshaller.typecode: ITypeCode;
begin
  result := _tc_TestException.typecode;
end;

//***********************************************************
// TTestException
//***********************************************************
constructor TTestException.Create(ex: TTestException);
begin
  Fmessage:= ex.message;
  inherited Create();
end;

procedure TTestException.throw;
begin
  raise TTestException.Create(self);
end;

function TTestException.clone(): IORBException;
begin
  result := TTestException.Create(self);
end;

procedure TTestException.encode(const enc: IEncoder);
var
  int : ITestException;
begin
  int := self;
  TestException_marshaller.marshal(enc,@int);
end;

procedure TTestException.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(TestException_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TTestException.Create(_message: AnsiString);
begin
  Fmessage := _message;
  inherited Create();
end;

function TTestException.repoid(): RepositoryID;
begin
  result := 'IDL:TestException:1.0';
end;

procedure TTestException.message(const val: AnsiString);
begin
  Fmessage := val;
end;

function TTestException.message: AnsiString;
begin
  result := Fmessage;
end;

//***********************************************************
// TTestIntfFactory
//***********************************************************
function TTestIntfFactory.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:TestIntfFactory:1.0' then
    begin
      result := Pointer(self as ITestIntfFactory);
      exit;
    end;
end;

class function TTestIntfFactory._narrow(const obj : IORBObject): ITestIntfFactory;
var
  p: Pointer;
  stub: TTestIntfFactory_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:TestIntfFactory:1.0');
  if p <> nil then
    result := ITestIntfFactory(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:TestIntfFactory:1.0') then
        begin
          stub := TTestIntfFactory_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TTestIntfFactory.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:TestIntfFactory:1.0'
end;

//***********************************************************
// TTestIntfFactory_stub
//***********************************************************
function TTestIntfFactory_stub.create_test_intf: ITestIntf;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(TestIntf_marshaller, @result);
  req := StaticRequest(self,'create_test_intf');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TTestIntfFactory_stub_clp
//***********************************************************
function TTestIntfFactory_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:TestIntfFactory:1.0' then
    begin
      result := Pointer(self as ITestIntfFactory);
      exit;
  end;
end;

function TTestIntfFactory_stub_clp.create_test_intf: ITestIntf;
var
  _srv: IServant;
  srv: ITestIntfFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntfFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_test_intf
    end;
  _postinvoke();
end;

//***********************************************************
// TTestIntfFactory_serv
//***********************************************************
function TTestIntfFactory_serv._this(): ITestIntfFactory;
var
  obj: IORBObject;
begin
  obj := this();
  result := TTestIntfFactory._narrow(obj);
end;

function TTestIntfFactory_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:TestIntfFactory:1.0';
end;

function TTestIntfFactory_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:TestIntfFactory:1.0';
end;

function TTestIntfFactory_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TTestIntfFactory_stub_clp.Create(poa,obj);
end;

procedure TTestIntfFactory_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TTestIntfFactory_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:TestIntfFactory:1.0' then
    begin
      result := Pointer(ITestIntfFactory(self));
      exit;
    end;
end;

class function TTestIntfFactory_serv._narrow(const srv : IServant): ITestIntfFactory;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:TestIntfFactory:1.0');
  if p <> nil then
    result := ITestIntfFactory(p)
end;

function TTestIntfFactory_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  create_test_intf_result: ITestIntf;
begin
  result := true;
  if req.op_name = 'create_test_intf' then
    begin
      req.set_result(StaticAny(TestIntf_marshaller,@create_test_intf_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_test_intf_result := create_test_intf;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TTestIntfFactory_marshaller
//***********************************************************
function TTestIntfFactory_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ITestIntfFactory(addr^) := TTestIntfFactory._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TTestIntfFactory_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ITestIntfFactory(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TTestIntfFactory_marshaller._free(var addr: Pointer);
begin
  ITestIntfFactory(addr^) := nil;
end;

procedure TTestIntfFactory_marshaller._create(var addr: Pointer);
begin
  ITestIntfFactory(addr^) := TTestIntfFactory_stub.Create();
end;

procedure TTestIntfFactory_marshaller._assign(dst, src: Pointer);
begin
  ITestIntfFactory(dst^) := ITestIntfFactory(src^);
end;

function TTestIntfFactory_marshaller.typecode: ITypeCode;
begin
  result := _tc_TestIntfFactory.typecode;
end;

//***********************************************************
// TTestIntf
//***********************************************************
function TTestIntf.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:TestIntf:1.0' then
    begin
      result := Pointer(self as ITestIntf);
      exit;
    end;
end;

class function TTestIntf._narrow(const obj : IORBObject): ITestIntf;
var
  p: Pointer;
  stub: TTestIntf_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:TestIntf:1.0');
  if p <> nil then
    result := ITestIntf(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:TestIntf:1.0') then
        begin
          stub := TTestIntf_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TTestIntf.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:TestIntf:1.0'
end;

//***********************************************************
// TTestIntf_stub
//***********************************************************
function TTestIntf_stub.check_short(const value_in: Short; var value_inout: Short; out value_out: Short): Short;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_short,@value_in);
  _value_inout := StaticAny(stat_short,@value_inout);
  _value_out := StaticAny(stat_short,@value_out);
  _result := StaticAny(stat_short, @result);
  req := StaticRequest(self,'check_short');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_long(const value_in: long; var value_inout: long; out value_out: long): long;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_long,@value_in);
  _value_inout := StaticAny(stat_long,@value_inout);
  _value_out := StaticAny(stat_long,@value_out);
  _result := StaticAny(stat_long, @result);
  req := StaticRequest(self,'check_long');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_unsigned_short(const value_in: _ushort; var value_inout: _ushort; out value_out: _ushort): _ushort;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_ushort,@value_in);
  _value_inout := StaticAny(stat_ushort,@value_inout);
  _value_out := StaticAny(stat_ushort,@value_out);
  _result := StaticAny(stat_ushort, @result);
  req := StaticRequest(self,'check_unsigned_short');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_unsigned_long(const value_in: _ulong; var value_inout: _ulong; out value_out: _ulong): _ulong;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_ulong,@value_in);
  _value_inout := StaticAny(stat_ulong,@value_inout);
  _value_out := StaticAny(stat_ulong,@value_out);
  _result := StaticAny(stat_ulong, @result);
  req := StaticRequest(self,'check_unsigned_long');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_float(const value_in: Float; var value_inout: Float; out value_out: Float): Float;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_float,@value_in);
  _value_inout := StaticAny(stat_float,@value_inout);
  _value_out := StaticAny(stat_float,@value_out);
  _result := StaticAny(stat_float, @result);
  req := StaticRequest(self,'check_float');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_double(const value_in: Double; var value_inout: Double; out value_out: Double): Double;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_double,@value_in);
  _value_inout := StaticAny(stat_double,@value_inout);
  _value_out := StaticAny(stat_double,@value_out);
  _result := StaticAny(stat_double, @result);
  req := StaticRequest(self,'check_double');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_boolean(const value_in: Boolean; var value_inout: Boolean; out value_out: Boolean): Boolean;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_boolean,@value_in);
  _value_inout := StaticAny(stat_boolean,@value_inout);
  _value_out := StaticAny(stat_boolean,@value_out);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'check_boolean');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_char(const value_in: AnsiChar; var value_inout: AnsiChar; out value_out: AnsiChar): AnsiChar;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_char,@value_in);
  _value_inout := StaticAny(stat_char,@value_inout);
  _value_out := StaticAny(stat_char,@value_out);
  _result := StaticAny(stat_char, @result);
  req := StaticRequest(self,'check_char');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_octet(const value_in: octet; var value_inout: octet; out value_out: octet): octet;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_octet,@value_in);
  _value_inout := StaticAny(stat_octet,@value_inout);
  _value_out := StaticAny(stat_octet,@value_out);
  _result := StaticAny(stat_octet, @result);
  req := StaticRequest(self,'check_octet');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_string(const value_in: AnsiString; var value_inout: AnsiString; out value_out: AnsiString): AnsiString;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_string,@value_in);
  _value_inout := StaticAny(stat_string,@value_inout);
  _value_out := StaticAny(stat_string,@value_out);
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'check_string');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_longlong(const value_in: longlong; var value_inout: longlong; out value_out: longlong): longlong;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_longlong,@value_in);
  _value_inout := StaticAny(stat_longlong,@value_inout);
  _value_out := StaticAny(stat_longlong,@value_out);
  _result := StaticAny(stat_longlong, @result);
  req := StaticRequest(self,'check_longlong');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_unsigned_longlong(const value_in: _ulonglong; var value_inout: _ulonglong; out value_out: _ulonglong): _ulonglong;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_ulonglong,@value_in);
  _value_inout := StaticAny(stat_ulonglong,@value_inout);
  _value_out := StaticAny(stat_ulonglong,@value_out);
  _result := StaticAny(stat_ulonglong, @result);
  req := StaticRequest(self,'check_unsigned_longlong');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_wchar(const value_in: WideChar; var value_inout: WideChar; out value_out: WideChar): WideChar;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_widechar,@value_in);
  _value_inout := StaticAny(stat_widechar,@value_inout);
  _value_out := StaticAny(stat_widechar,@value_out);
  _result := StaticAny(stat_widechar, @result);
  req := StaticRequest(self,'check_wchar');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_wstring(const value_in: WideString; var value_inout: WideString; out value_out: WideString): WideString;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_widestring,@value_in);
  _value_inout := StaticAny(stat_widestring,@value_inout);
  _value_out := StaticAny(stat_widestring,@value_out);
  _result := StaticAny(stat_widestring, @result);
  req := StaticRequest(self,'check_wstring');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_octet_seq(const value_in: TTestOctetSeq; var value_inout: TTestOctetSeq; out value_out: TTestOctetSeq): TTestOctetSeq;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(stat_seq_octet,@value_in);
  _value_inout := StaticAny(stat_seq_octet,@value_inout);
  _value_out := StaticAny(stat_seq_octet,@value_out);
  _result := StaticAny(stat_seq_octet, @result);
  req := StaticRequest(self,'check_octet_seq');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_struct(const value_in: TTestStruct; var value_inout: TTestStruct; out value_out: TTestStruct): TTestStruct;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(TestStruct_marshaller,@value_in);
  _value_inout := StaticAny(TestStruct_marshaller,@value_inout);
  _value_out := StaticAny(TestStruct_marshaller,@value_out);
  _result := StaticAny(TestStruct_marshaller, @result);
  req := StaticRequest(self,'check_struct');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_enum(const value_in: TTestEnum; var value_inout: TTestEnum; out value_out: TTestEnum): TTestEnum;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(TestEnum_marshaller,@value_in);
  _value_inout := StaticAny(TestEnum_marshaller,@value_inout);
  _value_out := StaticAny(TestEnum_marshaller,@value_out);
  _result := StaticAny(TestEnum_marshaller, @result);
  req := StaticRequest(self,'check_enum');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTestIntf_stub.check_obj(const value_in: ITestIntf; var value_inout: ITestIntf; out value_out: ITestIntf): ITestIntf;
var
  req: IStaticRequest;
  _value_in: IStaticAny;
  _value_inout: IStaticAny;
  _value_out: IStaticAny;
  _result: IStaticAny;
begin
  _value_in := StaticAny(TestIntf_marshaller,@value_in);
  _value_inout := StaticAny(TestIntf_marshaller,@value_inout);
  _value_out := StaticAny(TestIntf_marshaller,@value_out);
  _result := StaticAny(TestIntf_marshaller, @result);
  req := StaticRequest(self,'check_obj');
  req.add_in_arg(_value_in);
  req.add_inout_arg(_value_inout);
  req.add_out_arg(_value_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TTestIntf_stub.check_exception(const mes: AnsiString);
var
  req: IStaticRequest;
  _mes: IStaticAny;
begin
  _mes := StaticAny(stat_string,@mes);
  req := StaticRequest(self,'check_exception');
  req.add_in_arg(_mes);
  req.set_exceptions_tc([_tc_TestException.typecode]);
  req.invoke;
  dorb_static_throw(req,[TestException_marshaller, 'IDL:TestException:1.0']);
end;

procedure TTestIntf_stub.deactivate;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'deactivate');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TTestIntf_stub_clp
//***********************************************************
function TTestIntf_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:TestIntf:1.0' then
    begin
      result := Pointer(self as ITestIntf);
      exit;
  end;
end;

function TTestIntf_stub_clp.check_short(const value_in: Short; var value_inout: Short; out value_out: Short): Short;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_short(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_long(const value_in: long; var value_inout: long; out value_out: long): long;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_long(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_unsigned_short(const value_in: _ushort; var value_inout: _ushort; out value_out: _ushort): _ushort;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_unsigned_short(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_unsigned_long(const value_in: _ulong; var value_inout: _ulong; out value_out: _ulong): _ulong;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_unsigned_long(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_float(const value_in: Float; var value_inout: Float; out value_out: Float): Float;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_float(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_double(const value_in: Double; var value_inout: Double; out value_out: Double): Double;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_double(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_boolean(const value_in: Boolean; var value_inout: Boolean; out value_out: Boolean): Boolean;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_boolean(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_char(const value_in: AnsiChar; var value_inout: AnsiChar; out value_out: AnsiChar): AnsiChar;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := #0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_char(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_octet(const value_in: octet; var value_inout: octet; out value_out: octet): octet;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_octet(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_string(const value_in: AnsiString; var value_inout: AnsiString; out value_out: AnsiString): AnsiString;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_string(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_longlong(const value_in: longlong; var value_inout: longlong; out value_out: longlong): longlong;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_longlong(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_unsigned_longlong(const value_in: _ulonglong; var value_inout: _ulonglong; out value_out: _ulonglong): _ulonglong;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_unsigned_longlong(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_wchar(const value_in: WideChar; var value_inout: WideChar; out value_out: WideChar): WideChar;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := #0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_wchar(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_wstring(const value_in: WideString; var value_inout: WideString; out value_out: WideString): WideString;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_wstring(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_octet_seq(const value_in: TTestOctetSeq; var value_inout: TTestOctetSeq; out value_out: TTestOctetSeq): TTestOctetSeq;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_octet_seq(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_struct(const value_in: TTestStruct; var value_inout: TTestStruct; out value_out: TTestStruct): TTestStruct;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_struct(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_enum(const value_in: TTestEnum; var value_inout: TTestEnum; out value_out: TTestEnum): TTestEnum;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := te_Valie1;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_enum(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

function TTestIntf_stub_clp.check_obj(const value_in: ITestIntf; var value_inout: ITestIntf; out value_out: ITestIntf): ITestIntf;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        result := srv.check_obj(value_in, value_inout, value_out)
    end;
  _postinvoke();
end;

procedure TTestIntf_stub_clp.check_exception(const mes: AnsiString);
var
  _srv: IServant;
  srv: ITestIntf;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        srv.check_exception(mes)
    end;
  _postinvoke();
end;

procedure TTestIntf_stub_clp.deactivate;
var
  _srv: IServant;
  srv: ITestIntf;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTestIntf_serv._narrow(_srv);
      if srv <> nil then
        srv.deactivate
    end;
  _postinvoke();
end;

//***********************************************************
// TTestIntf_serv
//***********************************************************
function TTestIntf_serv._this(): ITestIntf;
var
  obj: IORBObject;
begin
  obj := this();
  result := TTestIntf._narrow(obj);
end;

function TTestIntf_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:TestIntf:1.0';
end;

function TTestIntf_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:TestIntf:1.0';
end;

function TTestIntf_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TTestIntf_stub_clp.Create(poa,obj);
end;

procedure TTestIntf_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TTestIntf_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:TestIntf:1.0' then
    begin
      result := Pointer(ITestIntf(self));
      exit;
    end;
end;

class function TTestIntf_serv._narrow(const srv : IServant): ITestIntf;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:TestIntf:1.0');
  if p <> nil then
    result := ITestIntf(p)
end;

function TTestIntf_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  check_short_result: Short;
  check_short_value_in: Short;
  check_short_value_inout: Short;
  check_short_value_out: Short;
  check_long_result: long;
  check_long_value_in: long;
  check_long_value_inout: long;
  check_long_value_out: long;
  check_unsigned_short_result: _ushort;
  check_unsigned_short_value_in: _ushort;
  check_unsigned_short_value_inout: _ushort;
  check_unsigned_short_value_out: _ushort;
  check_unsigned_long_result: _ulong;
  check_unsigned_long_value_in: _ulong;
  check_unsigned_long_value_inout: _ulong;
  check_unsigned_long_value_out: _ulong;
  check_float_result: Float;
  check_float_value_in: Float;
  check_float_value_inout: Float;
  check_float_value_out: Float;
  check_double_result: Double;
  check_double_value_in: Double;
  check_double_value_inout: Double;
  check_double_value_out: Double;
  check_boolean_result: Boolean;
  check_boolean_value_in: Boolean;
  check_boolean_value_inout: Boolean;
  check_boolean_value_out: Boolean;
  check_char_result: AnsiChar;
  check_char_value_in: AnsiChar;
  check_char_value_inout: AnsiChar;
  check_char_value_out: AnsiChar;
  check_octet_result: octet;
  check_octet_value_in: octet;
  check_octet_value_inout: octet;
  check_octet_value_out: octet;
  check_string_result: AnsiString;
  check_string_value_in: AnsiString;
  check_string_value_inout: AnsiString;
  check_string_value_out: AnsiString;
  check_longlong_result: longlong;
  check_longlong_value_in: longlong;
  check_longlong_value_inout: longlong;
  check_longlong_value_out: longlong;
  check_unsigned_longlong_result: _ulonglong;
  check_unsigned_longlong_value_in: _ulonglong;
  check_unsigned_longlong_value_inout: _ulonglong;
  check_unsigned_longlong_value_out: _ulonglong;
  check_wchar_result: WideChar;
  check_wchar_value_in: WideChar;
  check_wchar_value_inout: WideChar;
  check_wchar_value_out: WideChar;
  check_wstring_result: WideString;
  check_wstring_value_in: WideString;
  check_wstring_value_inout: WideString;
  check_wstring_value_out: WideString;
  check_octet_seq_result: TTestOctetSeq;
  check_octet_seq_value_in: TTestOctetSeq;
  check_octet_seq_value_inout: TTestOctetSeq;
  check_octet_seq_value_out: TTestOctetSeq;
  check_struct_result: TTestStruct;
  check_struct_value_in: TTestStruct;
  check_struct_value_inout: TTestStruct;
  check_struct_value_out: TTestStruct;
  check_enum_result: TTestEnum;
  check_enum_value_in: TTestEnum;
  check_enum_value_inout: TTestEnum;
  check_enum_value_out: TTestEnum;
  check_obj_result: ITestIntf;
  check_obj_value_in: ITestIntf;
  check_obj_value_inout: ITestIntf;
  check_obj_value_out: ITestIntf;
  check_exception_mes: AnsiString;
begin
  result := true;
  if req.op_name = 'check_short' then
    begin
      req.add_in_arg(StaticAny(stat_short,@check_short_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_short,@check_short_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_short,@check_short_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_short,@check_short_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_short_result := check_short(check_short_value_in, check_short_value_inout, check_short_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_long' then
    begin
      req.add_in_arg(StaticAny(stat_long,@check_long_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_long,@check_long_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_long,@check_long_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_long,@check_long_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_long_result := check_long(check_long_value_in, check_long_value_inout, check_long_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_unsigned_short' then
    begin
      req.add_in_arg(StaticAny(stat_ushort,@check_unsigned_short_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_ushort,@check_unsigned_short_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_ushort,@check_unsigned_short_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_ushort,@check_unsigned_short_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_unsigned_short_result := check_unsigned_short(check_unsigned_short_value_in, check_unsigned_short_value_inout, check_unsigned_short_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_unsigned_long' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@check_unsigned_long_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_ulong,@check_unsigned_long_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_ulong,@check_unsigned_long_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_ulong,@check_unsigned_long_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_unsigned_long_result := check_unsigned_long(check_unsigned_long_value_in, check_unsigned_long_value_inout, check_unsigned_long_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_float' then
    begin
      req.add_in_arg(StaticAny(stat_float,@check_float_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_float,@check_float_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_float,@check_float_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_float,@check_float_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_float_result := check_float(check_float_value_in, check_float_value_inout, check_float_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_double' then
    begin
      req.add_in_arg(StaticAny(stat_double,@check_double_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_double,@check_double_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_double,@check_double_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_double,@check_double_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_double_result := check_double(check_double_value_in, check_double_value_inout, check_double_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_boolean' then
    begin
      req.add_in_arg(StaticAny(stat_boolean,@check_boolean_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_boolean,@check_boolean_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_boolean,@check_boolean_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@check_boolean_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_boolean_result := check_boolean(check_boolean_value_in, check_boolean_value_inout, check_boolean_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_char' then
    begin
      req.add_in_arg(StaticAny(stat_char,@check_char_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_char,@check_char_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_char,@check_char_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_char,@check_char_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_char_result := check_char(check_char_value_in, check_char_value_inout, check_char_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_octet' then
    begin
      req.add_in_arg(StaticAny(stat_octet,@check_octet_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_octet,@check_octet_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_octet,@check_octet_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_octet,@check_octet_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_octet_result := check_octet(check_octet_value_in, check_octet_value_inout, check_octet_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_string' then
    begin
      req.add_in_arg(StaticAny(stat_string,@check_string_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_string,@check_string_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_string,@check_string_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_string,@check_string_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_string_result := check_string(check_string_value_in, check_string_value_inout, check_string_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_longlong' then
    begin
      req.add_in_arg(StaticAny(stat_longlong,@check_longlong_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_longlong,@check_longlong_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_longlong,@check_longlong_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_longlong,@check_longlong_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_longlong_result := check_longlong(check_longlong_value_in, check_longlong_value_inout, check_longlong_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_unsigned_longlong' then
    begin
      req.add_in_arg(StaticAny(stat_ulonglong,@check_unsigned_longlong_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_ulonglong,@check_unsigned_longlong_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_ulonglong,@check_unsigned_longlong_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_ulonglong,@check_unsigned_longlong_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_unsigned_longlong_result := check_unsigned_longlong(check_unsigned_longlong_value_in, check_unsigned_longlong_value_inout, check_unsigned_longlong_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_wchar' then
    begin
      req.add_in_arg(StaticAny(stat_widechar,@check_wchar_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_widechar,@check_wchar_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_widechar,@check_wchar_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_widechar,@check_wchar_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_wchar_result := check_wchar(check_wchar_value_in, check_wchar_value_inout, check_wchar_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_wstring' then
    begin
      req.add_in_arg(StaticAny(stat_widestring,@check_wstring_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_widestring,@check_wstring_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_widestring,@check_wstring_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_widestring,@check_wstring_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_wstring_result := check_wstring(check_wstring_value_in, check_wstring_value_inout, check_wstring_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_octet_seq' then
    begin
      req.add_in_arg(StaticAny(stat_seq_octet,@check_octet_seq_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_seq_octet,@check_octet_seq_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(stat_seq_octet,@check_octet_seq_value_out) as IStaticAny);
      req.set_result(StaticAny(stat_seq_octet,@check_octet_seq_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_octet_seq_result := check_octet_seq(check_octet_seq_value_in, check_octet_seq_value_inout, check_octet_seq_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_struct' then
    begin
      req.add_in_arg(StaticAny(TestStruct_marshaller,@check_struct_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(TestStruct_marshaller,@check_struct_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(TestStruct_marshaller,@check_struct_value_out) as IStaticAny);
      req.set_result(StaticAny(TestStruct_marshaller,@check_struct_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_struct_result := check_struct(check_struct_value_in, check_struct_value_inout, check_struct_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_enum' then
    begin
      req.add_in_arg(StaticAny(TestEnum_marshaller,@check_enum_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(TestEnum_marshaller,@check_enum_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(TestEnum_marshaller,@check_enum_value_out) as IStaticAny);
      req.set_result(StaticAny(TestEnum_marshaller,@check_enum_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_enum_result := check_enum(check_enum_value_in, check_enum_value_inout, check_enum_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_obj' then
    begin
      req.add_in_arg(StaticAny(TestIntf_marshaller,@check_obj_value_in) as IStaticAny);
      req.add_inout_arg(StaticAny(TestIntf_marshaller,@check_obj_value_inout) as IStaticAny);
      req.add_out_arg(StaticAny(TestIntf_marshaller,@check_obj_value_out) as IStaticAny);
      req.set_result(StaticAny(TestIntf_marshaller,@check_obj_result) as IStaticAny);
      if not req.read_args() then  exit;
      check_obj_result := check_obj(check_obj_value_in, check_obj_value_inout, check_obj_value_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'check_exception' then
    begin
      req.add_in_arg(StaticAny(stat_string,@check_exception_mes) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_TestException.typecode]);
      try
        check_exception(check_exception_mes);
      except
        on TestException: TTestException do
          req.set_exception(TTestException.Create(TestException) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'deactivate' then
    begin
      if not req.read_args() then  exit;
      deactivate;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TTestIntf_marshaller
//***********************************************************
function TTestIntf_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ITestIntf(addr^) := TTestIntf._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TTestIntf_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ITestIntf(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TTestIntf_marshaller._free(var addr: Pointer);
begin
  ITestIntf(addr^) := nil;
end;

procedure TTestIntf_marshaller._create(var addr: Pointer);
begin
  ITestIntf(addr^) := TTestIntf_stub.Create();
end;

procedure TTestIntf_marshaller._assign(dst, src: Pointer);
begin
  ITestIntf(dst^) := ITestIntf(src^);
end;

function TTestIntf_marshaller.typecode: ITypeCode;
begin
  result := _tc_TestIntf.typecode;
end;

initialization
  TestStruct_marshaller := TTestStruct_marshaller.Create();
  TestEnum_marshaller := TTestEnum_marshaller.Create();
  TestException_marshaller := TTestException_marshaller.Create();
  TestIntfFactory_marshaller := TTestIntfFactory_marshaller.Create();
  TestIntf_marshaller := TTestIntf_marshaller.Create();
  _tc_TestStruct := CreateTypeCodeConst('010000000f00000060000000010000001300000049444c3a546573745374727563743a312e3000000b0000005465737453747275637400'+
    '00020000000b00000076616c75655f6c6f6e670000030000000d00000076616c75655f737472696e67000000001200000000000000');
  _tc_TestEnum := CreateTypeCodeConst('01000000110000004e000000010000001100000049444c3a54657374456e756d3a312e30000000000900000054657374456e756d000000'+
    '00020000000a00000074655f56616c6965310000000a00000074655f56616c75653200');
  _tc_TestException := CreateTypeCodeConst('010000001600000038000000010000001600000049444c3a54657374457863657074696f6e3a312e300000000e00000054657374457863'+
    '657074696f6e00000000000000');
  _tc_TestIntfFactory := CreateTypeCodeConst('010000000e00000034000000010000001800000049444c3a54657374496e7466466163746f72793a312e30001000000054657374496e74'+
    '66466163746f727900');
  _tc_TestIntf := CreateTypeCodeConst('010000000e00000029000000010000001100000049444c3a54657374496e74663a312e30000000000900000054657374496e746600');
end.
