// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:26
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i./ ./\union.idl" 
//                                                                            
unit union;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, union_int, poa_int, poa;

type

  TA64_octet_array_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TS_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TA20_long_array_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TA10_A20_long_array_array_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:U:1.0 } 
  TU = class(TInterfacedObject,IU)
  private
    Fx: long;
    Fy: TBytesTest;
    Fz: AnsiString;
    Fw: TS;
    Farray: TU_array_array;
    Fseq: TU_seq_seq;
    Fobj: Ifoo;
    Fdiscriminator: long;
  protected
    procedure set_x(const val: long);
    function get_x: long;
    procedure set_y(const val: TBytesTest);
    function get_y: TBytesTest;
    procedure set_z(const val: AnsiString);
    function get_z: AnsiString;
    procedure set_w(const val: TS);
    function get_w: TS;
    procedure set_array(const val: TU_array_array);
    function get_array: TU_array_array;
    procedure set_seq(const val: TU_seq_seq);
    function get_seq: TU_seq_seq;
    procedure set_obj(const val: Ifoo);
    function get_obj: Ifoo;
    function discriminator: long;
  end;

  TU_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TE_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:U2:1.0 } 
  TU2 = class(TInterfacedObject,IU2)
  private
    Fx: long;
    Fy: Short;
    Fdiscriminator: TE_Alias;
  protected
    procedure set_x(const val: long);
    function get_x: long;
    procedure set_y(const val: Short);
    function get_y: Short;
    function discriminator: TE_Alias;
  end;

  TU2_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:U3:1.0 } 
  TU3 = class(TInterfacedObject,IU3)
  private
    Fx: long;
    Fdiscriminator: TE_Alias;
  protected
    procedure set_x(const val: long);
    function get_x: long;
    function discriminator: TE_Alias;
  end;

  TU3_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:foo:1.0 } 
  Tfoo = class(TORBObject,Ifoo)
  protected
    procedure bar(const x: IU; out y: IU; out z: IU2); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): Ifoo;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:foo:1.0} 
  Tfoo_stub = class(Tfoo)
  protected
    procedure bar(const x: IU; out y: IU; out z: IU2); override;
  end;

  {** POA stub for interface IDL:foo:1.0} 
  Tfoo_stub_clp = class(TPOAStub,IPOAStub,Ifoo)
  protected
    procedure bar(const x: IU; out y: IU; out z: IU2); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:foo:1.0} 
  Tfoo_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,Ifoo)
  protected
    procedure bar(const x: IU; out y: IU; out z: IU2); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): Ifoo;
    class function _narrow(const srv : IServant): Ifoo;
  end;

  Tfoo_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  A64_octet_array_marshaller : IStaticTypeInfo;
  S_marshaller : IStaticTypeInfo;
  A20_long_array_marshaller : IStaticTypeInfo;
  A10_A20_long_array_array_marshaller : IStaticTypeInfo;
  U_marshaller : IStaticTypeInfo;
  E_marshaller : IStaticTypeInfo;
  U2_marshaller : IStaticTypeInfo;
  U3_marshaller : IStaticTypeInfo;
  foo_marshaller : IStaticTypeInfo;
  _tc_A64_octet_array : ITypeCodeConst;
  _tc_S : ITypeCodeConst;
  _tc_A20_long_array : ITypeCodeConst;
  _tc_A10_A20_long_array_array : ITypeCodeConst;
  _tc_U : ITypeCodeConst;
  _tc_E : ITypeCodeConst;
  _tc_U2 : ITypeCodeConst;
  _tc_U3 : ITypeCodeConst;
  _tc_foo : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TA64_octet_array_marshaller
//***********************************************************
type 
  A64_octet_array = array [0..63] of octet;
  PA64_octet_array = ^A64_octet_array;

function TA64_octet_array_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  i: integer;
begin
  result := false;
  for i := 0 to 63 do
    if not dec.get_octet(PA64_octet_array(addr)^[i]) then exit;
  result := true;
end;

procedure TA64_octet_array_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  i: integer;
begin
  for i := 0 to 63 do
    enc.put_octet(PA64_octet_array(addr)^[i]);
end;

procedure TA64_octet_array_marshaller._free(var addr: Pointer);
begin
  freemem(addr,sizeof(A64_octet_array));
end;

procedure TA64_octet_array_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(A64_octet_array));
end;

procedure TA64_octet_array_marshaller._assign(dst, src: Pointer);
begin
  PA64_octet_array(dst)^ := PA64_octet_array(src)^;
end;

function TA64_octet_array_marshaller.typecode: ITypeCode;
begin
  result := _tc_A64_octet_array.typecode;
end;

//***********************************************************
// TS_marshaller
//***********************************************************
function TS_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: union_int.TS;
begin
  result := false;
  if not stat_long.demarshal(dec,@struct.len) then exit;
  union_int.TS(addr^) := struct;
  result := true;
end;

procedure TS_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: union_int.TS;
begin
  struct := union_int.TS(addr^);
  stat_long.marshal(enc,@struct.len);
end;

procedure TS_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(union_int.TS(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TS_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(union_int.TS));
{$HINTS OFF}
  System.Initialize(union_int.TS(addr^));
{$HINTS ON}
end;

procedure TS_marshaller._assign(dst, src: Pointer);
begin
  union_int.TS(dst^) := union_int.TS(src^);
end;

function TS_marshaller.typecode: ITypeCode;
begin
  result := _tc_S.typecode;
end;

//***********************************************************
// TA20_long_array_marshaller
//***********************************************************
type 
  A20_long_array = array [0..19] of long;
  PA20_long_array = ^A20_long_array;

function TA20_long_array_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  i: integer;
begin
  result := false;
  for i := 0 to 19 do
    if not dec.get_long(PA20_long_array(addr)^[i]) then exit;
  result := true;
end;

procedure TA20_long_array_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  i: integer;
begin
  for i := 0 to 19 do
    enc.put_long(PA20_long_array(addr)^[i]);
end;

procedure TA20_long_array_marshaller._free(var addr: Pointer);
begin
  freemem(addr,sizeof(A20_long_array));
end;

procedure TA20_long_array_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(A20_long_array));
end;

procedure TA20_long_array_marshaller._assign(dst, src: Pointer);
begin
  PA20_long_array(dst)^ := PA20_long_array(src)^;
end;

function TA20_long_array_marshaller.typecode: ITypeCode;
begin
  result := _tc_A20_long_array.typecode;
end;

//***********************************************************
// TA10_A20_long_array_array_marshaller
//***********************************************************
type 
  A10_A20_long_array_array = array [0..9] of A20_long_array;
  PA10_A20_long_array_array = ^A10_A20_long_array_array;

function TA10_A20_long_array_array_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  i: integer;
begin
  result := false;
  for i := 0 to 9 do
    if not A20_long_array_marshaller.demarshal(dec,@PA10_A20_long_array_array(addr)^[i]) then exit;
  result := true;
end;

procedure TA10_A20_long_array_array_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  i: integer;
begin
  for i := 0 to 9 do
    A20_long_array_marshaller.marshal(enc,@PA10_A20_long_array_array(addr)^[i]);
end;

procedure TA10_A20_long_array_array_marshaller._free(var addr: Pointer);
begin
  freemem(addr,sizeof(A10_A20_long_array_array));
end;

procedure TA10_A20_long_array_array_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(A10_A20_long_array_array));
end;

procedure TA10_A20_long_array_array_marshaller._assign(dst, src: Pointer);
begin
  PA10_A20_long_array_array(dst)^ := PA10_A20_long_array_array(src)^;
end;

function TA10_A20_long_array_array_marshaller.typecode: ITypeCode;
begin
  result := _tc_A10_A20_long_array_array.typecode;
end;

//***********************************************************
// TU_marshaller
//***********************************************************
function TU_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  discr: long;
  _x : long;
  _y : TBytesTest;
  _z : AnsiString;
  _w : TS;
  _array : TU_array_array;
  _seq : TU_seq_seq;
  _obj : Ifoo;
begin
  result := false;
  if not stat_long.demarshal(dec,@discr) then exit;
  IU(addr^) := TU.Create;
  case discr of
    1 : begin
        if not stat_long.demarshal(dec,@_x) then exit;
        IU(addr^).set_x(_x);
      end;
    2 : begin
        if not A64_octet_array_marshaller.demarshal(dec,@_y) then exit;
        IU(addr^).set_y(_y);
      end;
    3 : begin
        if not stat_string.demarshal(dec,@_z) then exit;
        IU(addr^).set_z(_z);
      end;
    4, 5 : begin
        if not S_marshaller.demarshal(dec,@_w) then exit;
        IU(addr^).set_w(_w);
      end;
    6 : begin
        if not A10_A20_long_array_array_marshaller.demarshal(dec,@_array) then exit;
        IU(addr^).set_array(_array);
      end;
    7 : begin
        if not stat_seq_long.demarshal(dec,@_seq) then exit;
        IU(addr^).set_seq(_seq);
      end;
    else begin
        if not foo_marshaller.demarshal(dec,@_obj) then exit;
        IU(addr^).set_obj(_obj);
      end;
  end;
  result := true;
end;

procedure TU_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  discr: long;
  _x : long;
  _y : TBytesTest;
  _z : AnsiString;
  _w : TS;
  _array : TU_array_array;
  _seq : TU_seq_seq;
  _obj : Ifoo;
begin
  discr := IU(addr^).discriminator;
  stat_long.marshal(enc, @discr);
  case discr of
    1 : begin
      _x := IU(addr^).get_x;
      stat_long.marshal(enc,@_x);
    end;
    2 : begin
      _y := IU(addr^).get_y;
      A64_octet_array_marshaller.marshal(enc,@_y);
    end;
    3 : begin
      _z := IU(addr^).get_z;
      stat_string.marshal(enc,@_z);
    end;
    4, 5 : begin
      _w := IU(addr^).get_w;
      S_marshaller.marshal(enc,@_w);
    end;
    6 : begin
      _array := IU(addr^).get_array;
      A10_A20_long_array_array_marshaller.marshal(enc,@_array);
    end;
    7 : begin
      _seq := IU(addr^).get_seq;
      stat_seq_long.marshal(enc,@_seq);
    end;
    else begin
      _obj := IU(addr^).get_obj;
      foo_marshaller.marshal(enc,@_obj);
    end;
  end;
end;

procedure TU_marshaller._free(var addr: Pointer);
begin
  IU(addr^) := nil;
end;

procedure TU_marshaller._create(var addr: Pointer);
begin
  IU(addr^) := TU.Create();
end;

procedure TU_marshaller._assign(dst, src: Pointer);
begin
  IU(dst^) := IU(src^);
end;

function TU_marshaller.typecode: ITypeCode;
begin
  result := _tc_U.typecode;
end;

//***********************************************************
// TU
//***********************************************************
procedure TU.set_x(const val: long);
begin
  Fdiscriminator := 1;
  Fx := val;
end;

function TU.get_x: long;
begin
  result := Fx;
end;

procedure TU.set_y(const val: TBytesTest);
begin
  Fdiscriminator := 2;
  Fy := val;
end;

function TU.get_y: TBytesTest;
begin
  result := Fy;
end;

procedure TU.set_z(const val: AnsiString);
begin
  Fdiscriminator := 3;
  Fz := val;
end;

function TU.get_z: AnsiString;
begin
  result := Fz;
end;

procedure TU.set_w(const val: TS);
begin
  Fdiscriminator := 4;
  Fw := val;
end;

function TU.get_w: TS;
begin
  result := Fw;
end;

procedure TU.set_array(const val: TU_array_array);
begin
  Fdiscriminator := 6;
  Farray := val;
end;

function TU.get_array: TU_array_array;
begin
  result := Farray;
end;

procedure TU.set_seq(const val: TU_seq_seq);
begin
  Fdiscriminator := 7;
  Fseq := val;
end;

function TU.get_seq: TU_seq_seq;
begin
  result := Fseq;
end;

procedure TU.set_obj(const val: Ifoo);
begin
  Fdiscriminator := 0;
  Fobj := val;
end;

function TU.get_obj: Ifoo;
begin
  result := Fobj;
end;

function TU.discriminator: long;
begin
  result := FDiscriminator;
end;

//***********************************************************
// TE_marshaller
//***********************************************************
function TE_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TE_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TE_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TE_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TE_marshaller._assign(dst, src: Pointer);
begin
  TE(dst^) := TE(src^);
end;

function TE_marshaller.typecode: ITypeCode;
begin
  result := _tc_E.typecode;
end;

//***********************************************************
// TU2_marshaller
//***********************************************************
function TU2_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  discr: TE_Alias;
  _x : long;
  _y : Short;
begin
  result := false;
  if not E_marshaller.demarshal(dec,@discr) then exit;
  IU2(addr^) := TU2.Create;
  case discr of
    A : begin
        if not stat_long.demarshal(dec,@_x) then exit;
        IU2(addr^).set_x(_x);
      end;
    B : begin
        if not stat_short.demarshal(dec,@_y) then exit;
        IU2(addr^).set_y(_y);
      end;
  end;
  result := true;
end;

procedure TU2_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  discr: TE_Alias;
  _x : long;
  _y : Short;
begin
  discr := IU2(addr^).discriminator;
  E_marshaller.marshal(enc, @discr);
  case discr of
    A : begin
      _x := IU2(addr^).get_x;
      stat_long.marshal(enc,@_x);
    end;
    B : begin
      _y := IU2(addr^).get_y;
      stat_short.marshal(enc,@_y);
    end;
  end;
end;

procedure TU2_marshaller._free(var addr: Pointer);
begin
  IU2(addr^) := nil;
end;

procedure TU2_marshaller._create(var addr: Pointer);
begin
  IU2(addr^) := TU2.Create();
end;

procedure TU2_marshaller._assign(dst, src: Pointer);
begin
  IU2(dst^) := IU2(src^);
end;

function TU2_marshaller.typecode: ITypeCode;
begin
  result := _tc_U2.typecode;
end;

//***********************************************************
// TU2
//***********************************************************
procedure TU2.set_x(const val: long);
begin
  Fdiscriminator := A;
  Fx := val;
end;

function TU2.get_x: long;
begin
  result := Fx;
end;

procedure TU2.set_y(const val: Short);
begin
  Fdiscriminator := B;
  Fy := val;
end;

function TU2.get_y: Short;
begin
  result := Fy;
end;

function TU2.discriminator: TE;
begin
  result := FDiscriminator;
end;

//***********************************************************
// TU3_marshaller
//***********************************************************
function TU3_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  discr: TE_Alias;
  _x : long;
begin
  result := false;
  if not E_marshaller.demarshal(dec,@discr) then exit;
  IU3(addr^) := TU3.Create;
  case discr of
    B : begin
        if not stat_long.demarshal(dec,@_x) then exit;
        IU3(addr^).set_x(_x);
      end;
  end;
  result := true;
end;

procedure TU3_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  discr: TE_Alias;
  _x : long;
begin
  discr := IU3(addr^).discriminator;
  E_marshaller.marshal(enc, @discr);
  case discr of
    B : begin
      _x := IU3(addr^).get_x;
      stat_long.marshal(enc,@_x);
    end;
  end;
end;

procedure TU3_marshaller._free(var addr: Pointer);
begin
  IU3(addr^) := nil;
end;

procedure TU3_marshaller._create(var addr: Pointer);
begin
  IU3(addr^) := TU3.Create();
end;

procedure TU3_marshaller._assign(dst, src: Pointer);
begin
  IU3(dst^) := IU3(src^);
end;

function TU3_marshaller.typecode: ITypeCode;
begin
  result := _tc_U3.typecode;
end;

//***********************************************************
// TU3
//***********************************************************
procedure TU3.set_x(const val: long);
begin
  Fdiscriminator := B;
  Fx := val;
end;

function TU3.get_x: long;
begin
  result := Fx;
end;

function TU3.discriminator: TE;
begin
  result := FDiscriminator;
end;

//***********************************************************
// Tfoo
//***********************************************************
function Tfoo.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:foo:1.0' then
    begin
      result := Pointer(self as Ifoo);
      exit;
    end;
end;

class function Tfoo._narrow(const obj : IORBObject): Ifoo;
var
  p: Pointer;
  stub: Tfoo_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:foo:1.0');
  if p <> nil then
    result := Ifoo(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:foo:1.0') then
        begin
          stub := Tfoo_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function Tfoo.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:foo:1.0'
end;

//***********************************************************
// Tfoo_stub
//***********************************************************
procedure Tfoo_stub.bar(const x: IU; out y: IU; out z: IU2);
var
  req: IStaticRequest;
  _x: IStaticAny;
  _y: IStaticAny;
  _z: IStaticAny;
begin
  _x := StaticAny(U_marshaller,@x);
  _y := StaticAny(U_marshaller,@y);
  _z := StaticAny(U2_marshaller,@z);
  req := StaticRequest(self,'bar');
  req.add_in_arg(_x);
  req.add_out_arg(_y);
  req.add_out_arg(_z);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// Tfoo_stub_clp
//***********************************************************
function Tfoo_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:foo:1.0' then
    begin
      result := Pointer(self as Ifoo);
      exit;
  end;
end;

procedure Tfoo_stub_clp.bar(const x: IU; out y: IU; out z: IU2);
var
  _srv: IServant;
  srv: Ifoo;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := Tfoo_serv._narrow(_srv);
      if srv <> nil then
        srv.bar(x, y, z)
    end;
  _postinvoke();
end;

//***********************************************************
// Tfoo_serv
//***********************************************************
function Tfoo_serv._this(): Ifoo;
var
  obj: IORBObject;
begin
  obj := this();
  result := Tfoo._narrow(obj);
end;

function Tfoo_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:foo:1.0';
end;

function Tfoo_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:foo:1.0';
end;

function Tfoo_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := Tfoo_stub_clp.Create(poa,obj);
end;

procedure Tfoo_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function Tfoo_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:foo:1.0' then
    begin
      result := Pointer(Ifoo(self));
      exit;
    end;
end;

class function Tfoo_serv._narrow(const srv : IServant): Ifoo;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:foo:1.0');
  if p <> nil then
    result := Ifoo(p)
end;

function Tfoo_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  bar_x: IU;
  bar_y: IU;
  bar_z: IU2;
begin
  result := true;
  if req.op_name = 'bar' then
    begin
      req.add_in_arg(StaticAny(U_marshaller,@bar_x) as IStaticAny);
      req.add_out_arg(StaticAny(U_marshaller,@bar_y) as IStaticAny);
      req.add_out_arg(StaticAny(U2_marshaller,@bar_z) as IStaticAny);
      if not req.read_args() then  exit;
      bar(bar_x, bar_y, bar_z);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// Tfoo_marshaller
//***********************************************************
function Tfoo_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  Ifoo(addr^) := Tfoo._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure Tfoo_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := Ifoo(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure Tfoo_marshaller._free(var addr: Pointer);
begin
  Ifoo(addr^) := nil;
end;

procedure Tfoo_marshaller._create(var addr: Pointer);
begin
  Ifoo(addr^) := Tfoo_stub.Create();
end;

procedure Tfoo_marshaller._assign(dst, src: Pointer);
begin
  Ifoo(dst^) := Ifoo(src^);
end;

function Tfoo_marshaller.typecode: ITypeCode;
begin
  result := _tc_foo.typecode;
end;

initialization
  A64_octet_array_marshaller := TA64_octet_array_marshaller.Create();
  S_marshaller := TS_marshaller.Create();
  A20_long_array_marshaller := TA20_long_array_marshaller.Create();
  A10_A20_long_array_array_marshaller := TA10_A20_long_array_array_marshaller.Create();
  U_marshaller := TU_marshaller.Create();
  E_marshaller := TE_marshaller.Create();
  U2_marshaller := TU2_marshaller.Create();
  U3_marshaller := TU3_marshaller.Create();
  foo_marshaller := Tfoo_marshaller.Create();
  _tc_A64_octet_array := CreateTypeCodeConst('01000000140000000c000000010000000a00000040000000');
  _tc_S := CreateTypeCodeConst('010000000f0000002c000000010000000a00000049444c3a533a312e30000000020000005300000001000000040000006c656e0003000000');
  _tc_A20_long_array := CreateTypeCodeConst('01000000140000000c000000010000000300000014000000');
  _tc_A10_A20_long_array_array := CreateTypeCodeConst('01000000140000001c00000001000000140000000c0000000100000003000000140000000a000000');
  _tc_U := CreateTypeCodeConst('0100000010000000ac000000010000000a00000049444c3a553a312e30000000020000005500000003000000ffffffff08000000010000'+
    '000200000078000000010000000200000002000000790000000100000003000000020000007a0000000100000004000000020000007700'+
    '00000100000005000000020000007700000001000000060000000600000061727261790000000100000007000000040000007365710001'+
    '00000000000000040000006f626a0001000000');
  _tc_E := CreateTypeCodeConst('01000000110000002e000000010000000a00000049444c3a453a312e300000000200000045000000020000000200000041000000020000004200');
  _tc_U2 := CreateTypeCodeConst('0100000010000000a8000000010000000b00000049444c3a55323a312e3000000300000055320000150000005a00000001000000100000'+
    '0049444c3a455f416c6961733a312e300008000000455f416c69617300110000002e000000010000000a00000049444c3a453a312e3000'+
    '000002000000450000000200000002000000410000000200000042000000ffffffff020000000000000002000000780000000100000001'+
    '000000020000007900000001000000');
  _tc_U3 := CreateTypeCodeConst('010000001000000098000000010000000b00000049444c3a55333a312e3000000300000055330000150000005a00000001000000100000'+
    '0049444c3a455f416c6961733a312e300008000000455f416c69617300110000002e000000010000000a00000049444c3a453a312e3000'+
    '000002000000450000000200000002000000410000000200000042000000ffffffff0100000001000000020000007800000001000000');
  _tc_foo := CreateTypeCodeConst('010000000e0000001c000000010000000c00000049444c3a666f6f3a312e300004000000666f6f00');
end.
