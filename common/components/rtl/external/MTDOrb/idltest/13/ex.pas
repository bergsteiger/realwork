// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:26
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i./ ./\ex.idl" 
//                                                                            
unit ex;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, ex_int, poa_int, poa;

type

  TCalc_ex1_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Calc/ex1:1.0 } 
  TCalc_ex1 = class(UserException,ICalc_ex1)
  private
    Fmsg : AnsiString;
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
    procedure msg(const val : AnsiString); overload;
  public
    function msg: AnsiString; overload;
    constructor Create(ex: TCalc_ex1); overload;
    constructor Create(_msg: AnsiString = ''); overload;
  end;

  TCalc_ex2_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Calc/ex2:1.0 } 
  TCalc_ex2 = class(UserException,ICalc_ex2)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TCalc_ex2); overload;
    constructor Create(); overload;
  end;

  TCalc_ex3_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:Calc/ex3:1.0 } 
  TCalc_ex3 = class(UserException,ICalc_ex3)
  private
    Fmsg : AnsiString;
    Ferr : long;
    Fiface : ICalc;
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
    procedure msg(const val : AnsiString); overload;
    procedure err(const val : long); overload;
    procedure iface(const val : ICalc); overload;
  public
    function msg: AnsiString; overload;
    function err: long; overload;
    function iface: ICalc; overload;
    constructor Create(ex: TCalc_ex3); overload;
    constructor Create(_msg: AnsiString = '';_err: long = 0;_iface: ICalc = nil); overload;
  end;

  {** IDL:Calc:1.0 } 
  TCalc = class(TORBObject,ICalc)
  protected
    procedure m; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICalc;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:Calc:1.0} 
  TCalc_stub = class(TCalc)
  protected
    procedure m; override;
  end;

  {** POA stub for interface IDL:Calc:1.0} 
  TCalc_stub_clp = class(TPOAStub,IPOAStub,ICalc)
  protected
    procedure m; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:Calc:1.0} 
  TCalc_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICalc)
  protected
    procedure m; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICalc;
    class function _narrow(const srv : IServant): ICalc;
  end;

  TCalc_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  Calc_ex1_marshaller : IStaticTypeInfo;
  Calc_ex2_marshaller : IStaticTypeInfo;
  Calc_ex3_marshaller : IStaticTypeInfo;
  Calc_marshaller : IStaticTypeInfo;
  _tc_Calc_ex1 : ITypeCodeConst;
  _tc_Calc_ex2 : ITypeCodeConst;
  _tc_Calc_ex3 : ITypeCodeConst;
  _tc_Calc : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TCalc_ex1_marshaller
//***********************************************************
function TCalc_ex1_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
  _msg: AnsiString;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not stat_string.demarshal(dec,@_msg) then exit;
  ICalc_ex1(addr^).msg(_msg);
  if not dec.except_end then exit;
  result := true;
end;

procedure TCalc_ex1_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  _msg: AnsiString;
begin
  enc.except_begin('IDL:Calc/ex1:1.0');
  _msg:= ICalc_ex1(addr^).msg;
  stat_string.marshal(enc,@_msg);
  enc.except_end;
end;

procedure TCalc_ex1_marshaller._free(var addr: Pointer);
begin
  ICalc_ex1(addr^) := nil;
end;

procedure TCalc_ex1_marshaller._create(var addr: Pointer);
begin
  ICalc_ex1(addr^) := TCalc_ex1.Create();
end;

procedure TCalc_ex1_marshaller._assign(dst, src: Pointer);
begin
  ICalc_ex1(dst^) := ICalc_ex1(src^);
end;

function TCalc_ex1_marshaller.typecode: ITypeCode;
begin
  result := _tc_Calc_ex1.typecode;
end;

//***********************************************************
// TCalc_ex1
//***********************************************************
constructor TCalc_ex1.Create(ex: TCalc_ex1);
begin
  Fmsg:= ex.msg;
  inherited Create();
end;

procedure TCalc_ex1.throw;
begin
  raise TCalc_ex1.Create(self);
end;

function TCalc_ex1.clone(): IORBException;
begin
  result := TCalc_ex1.Create(self);
end;

procedure TCalc_ex1.encode(const enc: IEncoder);
var
  int : ICalc_ex1;
begin
  int := self;
  Calc_ex1_marshaller.marshal(enc,@int);
end;

procedure TCalc_ex1.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(Calc_ex1_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TCalc_ex1.Create(_msg: AnsiString);
begin
  Fmsg := _msg;
  inherited Create();
end;

function TCalc_ex1.repoid(): RepositoryID;
begin
  result := 'IDL:Calc/ex1:1.0';
end;

procedure TCalc_ex1.msg(const val: AnsiString);
begin
  Fmsg := val;
end;

function TCalc_ex1.msg: AnsiString;
begin
  result := Fmsg;
end;

//***********************************************************
// TCalc_ex2_marshaller
//***********************************************************
function TCalc_ex2_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TCalc_ex2_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:Calc/ex2:1.0');
  enc.except_end;
end;

procedure TCalc_ex2_marshaller._free(var addr: Pointer);
begin
  ICalc_ex2(addr^) := nil;
end;

procedure TCalc_ex2_marshaller._create(var addr: Pointer);
begin
  ICalc_ex2(addr^) := TCalc_ex2.Create();
end;

procedure TCalc_ex2_marshaller._assign(dst, src: Pointer);
begin
  ICalc_ex2(dst^) := ICalc_ex2(src^);
end;

function TCalc_ex2_marshaller.typecode: ITypeCode;
begin
  result := _tc_Calc_ex2.typecode;
end;

//***********************************************************
// TCalc_ex2
//***********************************************************
constructor TCalc_ex2.Create(ex: TCalc_ex2);
begin
  inherited Create();
end;

procedure TCalc_ex2.throw;
begin
  raise TCalc_ex2.Create(self);
end;

function TCalc_ex2.clone(): IORBException;
begin
  result := TCalc_ex2.Create(self);
end;

procedure TCalc_ex2.encode(const enc: IEncoder);
var
  int : ICalc_ex2;
begin
  int := self;
  Calc_ex2_marshaller.marshal(enc,@int);
end;

procedure TCalc_ex2.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(Calc_ex2_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TCalc_ex2.Create();
begin
  inherited Create();
end;

function TCalc_ex2.repoid(): RepositoryID;
begin
  result := 'IDL:Calc/ex2:1.0';
end;

//***********************************************************
// TCalc_ex3_marshaller
//***********************************************************
function TCalc_ex3_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
  _msg: AnsiString;
  _err: long;
  _iface: ICalc;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not stat_string.demarshal(dec,@_msg) then exit;
  ICalc_ex3(addr^).msg(_msg);
  if not stat_long.demarshal(dec,@_err) then exit;
  ICalc_ex3(addr^).err(_err);
  if not Calc_marshaller.demarshal(dec,@_iface) then exit;
  ICalc_ex3(addr^).iface(_iface);
  if not dec.except_end then exit;
  result := true;
end;

procedure TCalc_ex3_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  _msg: AnsiString;
  _err: long;
  _iface: ICalc;
begin
  enc.except_begin('IDL:Calc/ex3:1.0');
  _msg:= ICalc_ex3(addr^).msg;
  stat_string.marshal(enc,@_msg);
  _err:= ICalc_ex3(addr^).err;
  stat_long.marshal(enc,@_err);
  _iface:= ICalc_ex3(addr^).iface;
  Calc_marshaller.marshal(enc,@_iface);
  enc.except_end;
end;

procedure TCalc_ex3_marshaller._free(var addr: Pointer);
begin
  ICalc_ex3(addr^) := nil;
end;

procedure TCalc_ex3_marshaller._create(var addr: Pointer);
begin
  ICalc_ex3(addr^) := TCalc_ex3.Create();
end;

procedure TCalc_ex3_marshaller._assign(dst, src: Pointer);
begin
  ICalc_ex3(dst^) := ICalc_ex3(src^);
end;

function TCalc_ex3_marshaller.typecode: ITypeCode;
begin
  result := _tc_Calc_ex3.typecode;
end;

//***********************************************************
// TCalc_ex3
//***********************************************************
constructor TCalc_ex3.Create(ex: TCalc_ex3);
begin
  Fmsg:= ex.msg;
  Ferr:= ex.err;
  Fiface:= ex.iface;
  inherited Create();
end;

procedure TCalc_ex3.throw;
begin
  raise TCalc_ex3.Create(self);
end;

function TCalc_ex3.clone(): IORBException;
begin
  result := TCalc_ex3.Create(self);
end;

procedure TCalc_ex3.encode(const enc: IEncoder);
var
  int : ICalc_ex3;
begin
  int := self;
  Calc_ex3_marshaller.marshal(enc,@int);
end;

procedure TCalc_ex3.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(Calc_ex3_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TCalc_ex3.Create(_msg: AnsiString;_err: long;_iface: ICalc);
begin
  Fmsg := _msg;
  Ferr := _err;
  Fiface := _iface;
  inherited Create();
end;

function TCalc_ex3.repoid(): RepositoryID;
begin
  result := 'IDL:Calc/ex3:1.0';
end;

procedure TCalc_ex3.msg(const val: AnsiString);
begin
  Fmsg := val;
end;

function TCalc_ex3.msg: AnsiString;
begin
  result := Fmsg;
end;

procedure TCalc_ex3.err(const val: long);
begin
  Ferr := val;
end;

function TCalc_ex3.err: long;
begin
  result := Ferr;
end;

procedure TCalc_ex3.iface(const val: ICalc);
begin
  Fiface := val;
end;

function TCalc_ex3.iface: ICalc;
begin
  result := Fiface;
end;

//***********************************************************
// TCalc
//***********************************************************
function TCalc.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Calc:1.0' then
    begin
      result := Pointer(self as ICalc);
      exit;
    end;
end;

class function TCalc._narrow(const obj : IORBObject): ICalc;
var
  p: Pointer;
  stub: TCalc_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:Calc:1.0');
  if p <> nil then
    result := ICalc(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:Calc:1.0') then
        begin
          stub := TCalc_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCalc.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:Calc:1.0'
end;

//***********************************************************
// TCalc_stub
//***********************************************************
procedure TCalc_stub.m;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'m');
  req.set_exceptions_tc([_tc_Calc_ex1.typecode]);
  req.invoke;
  dorb_static_throw(req,[Calc_ex1_marshaller, 'IDL:Calc/ex1:1.0']);
end;

//***********************************************************
// TCalc_stub_clp
//***********************************************************
function TCalc_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Calc:1.0' then
    begin
      result := Pointer(self as ICalc);
      exit;
  end;
end;

procedure TCalc_stub_clp.m;
var
  _srv: IServant;
  srv: ICalc;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCalc_serv._narrow(_srv);
      if srv <> nil then
        srv.m
    end;
  _postinvoke();
end;

//***********************************************************
// TCalc_serv
//***********************************************************
function TCalc_serv._this(): ICalc;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCalc._narrow(obj);
end;

function TCalc_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:Calc:1.0';
end;

function TCalc_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:Calc:1.0';
end;

function TCalc_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCalc_stub_clp.Create(poa,obj);
end;

procedure TCalc_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCalc_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:Calc:1.0' then
    begin
      result := Pointer(ICalc(self));
      exit;
    end;
end;

class function TCalc_serv._narrow(const srv : IServant): ICalc;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:Calc:1.0');
  if p <> nil then
    result := ICalc(p)
end;

function TCalc_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if req.op_name = 'm' then
    begin
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Calc_ex1.typecode]);
      try
        m;
      except
        on ex1: TCalc_ex1 do
          req.set_exception(TCalc_ex1.Create(ex1) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCalc_marshaller
//***********************************************************
function TCalc_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICalc(addr^) := TCalc._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCalc_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICalc(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCalc_marshaller._free(var addr: Pointer);
begin
  ICalc(addr^) := nil;
end;

procedure TCalc_marshaller._create(var addr: Pointer);
begin
  ICalc(addr^) := TCalc_stub.Create();
end;

procedure TCalc_marshaller._assign(dst, src: Pointer);
begin
  ICalc(dst^) := ICalc(src^);
end;

function TCalc_marshaller.typecode: ITypeCode;
begin
  result := _tc_Calc.typecode;
end;

initialization
  Calc_ex1_marshaller := TCalc_ex1_marshaller.Create();
  Calc_ex2_marshaller := TCalc_ex2_marshaller.Create();
  Calc_ex3_marshaller := TCalc_ex3_marshaller.Create();
  Calc_marshaller := TCalc_marshaller.Create();
  _tc_Calc_ex1 := CreateTypeCodeConst('010000001600000028000000010000001100000049444c3a43616c632f6578313a312e3000000000040000006578310000000000');
  _tc_Calc_ex2 := CreateTypeCodeConst('010000001600000028000000010000001100000049444c3a43616c632f6578323a312e3000000000040000006578320000000000');
  _tc_Calc_ex3 := CreateTypeCodeConst('010000001600000028000000010000001100000049444c3a43616c632f6578333a312e3000000000040000006578330000000000');
  _tc_Calc := CreateTypeCodeConst('010000000e00000021000000010000000d00000049444c3a43616c633a312e30000000000500000043616c6300');
end.
