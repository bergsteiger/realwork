// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:26
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i./ ./\b.idl" 
//                                                                            
unit b;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, b_int, poa_int, poa;

type

  TB_S_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  B_S_seq = Array of TB_S;
  PB_S_seq = ^B_S_seq;

  TB_S_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  B_S_marshaller : IStaticTypeInfo;
  B_S_seq_marshaller : IStaticTypeInfo;
  _tc_B_S : ITypeCodeConst;
  _tc_B_S_seq : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TB_S_marshaller
//***********************************************************
function TB_S_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: b_int.TB_S;
begin
  result := false;
  if not stat_long.demarshal(dec,@struct.x) then exit;
  b_int.TB_S(addr^) := struct;
  result := true;
end;

procedure TB_S_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: b_int.TB_S;
begin
  struct := b_int.TB_S(addr^);
  stat_long.marshal(enc,@struct.x);
end;

procedure TB_S_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(b_int.TB_S(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TB_S_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(b_int.TB_S));
{$HINTS OFF}
  System.Initialize(b_int.TB_S(addr^));
{$HINTS ON}
end;

procedure TB_S_marshaller._assign(dst, src: Pointer);
begin
  b_int.TB_S(dst^) := b_int.TB_S(src^);
end;

function TB_S_marshaller.typecode: ITypeCode;
begin
  result := _tc_B_S.typecode;
end;

//***********************************************************
// TB_S_seq_marshaller
//***********************************************************

function TB_S_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TB_S;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(B_S_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not B_S_marshaller.demarshal(dec,@val) then exit;
        B_S_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TB_S_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(B_S_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      B_S_marshaller.marshal(enc,@B_S_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TB_S_seq_marshaller._free(var addr: Pointer);
begin
  setLength(B_S_seq(addr^),0);
  freemem(addr);
end;

procedure TB_S_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TB_S_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TB_S_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_B_S_seq.typecode;
end;

initialization
  B_S_marshaller := TB_S_marshaller.Create();
  B_S_seq_marshaller := TB_S_seq_marshaller.Create();
  _tc_B_S := CreateTypeCodeConst('010000000f0000002c000000010000000c00000049444c3a422f533a312e3000020000005300000001000000020000007800000003000000');
  _tc_B_S_seq := CreateTypeCodeConst('01000000130000003c000000010000000f0000002c000000010000000c00000049444c3a422f533a312e30000200000053000000010000'+
    '0002000000780000000300000000000000');
end.
