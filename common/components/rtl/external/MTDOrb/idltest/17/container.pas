// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:26
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i./ ./\container.idl" 
//                                                                            
unit container;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, container_int, poa_int, poa;

type

  TA_C_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TA_E_F_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:A/E:1.0 } 
  TA_E = class(TInterfacedObject,IA_E)
  private
    Ff: TA_E_F;
    Fdiscriminator: TA_C;
  protected
    procedure set_f(const val: TA_E_F);
    function get_f: TA_E_F;
    function discriminator: TA_C;
  end;

  TA_E_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TA_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  A_C_marshaller : IStaticTypeInfo;
  A_E_F_marshaller : IStaticTypeInfo;
  A_E_marshaller : IStaticTypeInfo;
  A_marshaller : IStaticTypeInfo;
  _tc_A_C : ITypeCodeConst;
  _tc_A_E_F : ITypeCodeConst;
  _tc_A_E : ITypeCodeConst;
  _tc_A : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TA_C_marshaller
//***********************************************************
function TA_C_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TA_C_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TA_C_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TA_C_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TA_C_marshaller._assign(dst, src: Pointer);
begin
  TA_C(dst^) := TA_C(src^);
end;

function TA_C_marshaller.typecode: ITypeCode;
begin
  result := _tc_A_C.typecode;
end;

//***********************************************************
// TA_E_F_marshaller
//***********************************************************
function TA_E_F_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: container_int.TA_E_F;
begin
  result := false;
  if not stat_boolean.demarshal(dec,@struct.b) then exit;
  container_int.TA_E_F(addr^) := struct;
  result := true;
end;

procedure TA_E_F_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: container_int.TA_E_F;
begin
  struct := container_int.TA_E_F(addr^);
  stat_boolean.marshal(enc,@struct.b);
end;

procedure TA_E_F_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(container_int.TA_E_F(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TA_E_F_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(container_int.TA_E_F));
{$HINTS OFF}
  System.Initialize(container_int.TA_E_F(addr^));
{$HINTS ON}
end;

procedure TA_E_F_marshaller._assign(dst, src: Pointer);
begin
  container_int.TA_E_F(dst^) := container_int.TA_E_F(src^);
end;

function TA_E_F_marshaller.typecode: ITypeCode;
begin
  result := _tc_A_E_F.typecode;
end;

//***********************************************************
// TA_E_marshaller
//***********************************************************
function TA_E_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  discr: TA_C;
  _f : TA_E_F;
begin
  result := false;
  if not A_C_marshaller.demarshal(dec,@discr) then exit;
  IA_E(addr^) := TA_E.Create;
  case discr of
    JUST_TESTING : begin
        if not A_E_F_marshaller.demarshal(dec,@_f) then exit;
        IA_E(addr^).set_f(_f);
      end;
  end;
  result := true;
end;

procedure TA_E_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  discr: TA_C;
  _f : TA_E_F;
begin
  discr := IA_E(addr^).discriminator;
  A_C_marshaller.marshal(enc, @discr);
  case discr of
    JUST_TESTING : begin
      _f := IA_E(addr^).get_f;
      A_E_F_marshaller.marshal(enc,@_f);
    end;
  end;
end;

procedure TA_E_marshaller._free(var addr: Pointer);
begin
  IA_E(addr^) := nil;
end;

procedure TA_E_marshaller._create(var addr: Pointer);
begin
  IA_E(addr^) := TA_E.Create();
end;

procedure TA_E_marshaller._assign(dst, src: Pointer);
begin
  IA_E(dst^) := IA_E(src^);
end;

function TA_E_marshaller.typecode: ITypeCode;
begin
  result := _tc_A_E.typecode;
end;

//***********************************************************
// TA_E
//***********************************************************
procedure TA_E.set_f(const val: TA_E_F);
begin
  Fdiscriminator := JUST_TESTING;
  Ff := val;
end;

function TA_E.get_f: TA_E_F;
begin
  result := Ff;
end;

function TA_E.discriminator: TA_C;
begin
  result := FDiscriminator;
end;

//***********************************************************
// TA_marshaller
//***********************************************************
function TA_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: container_int.TA;
begin
  result := false;
  if not A_C_marshaller.demarshal(dec,@struct.c) then exit;
  if not stat_long.demarshal(dec,@struct.d) then exit;
  if not A_E_marshaller.demarshal(dec,@struct.e) then exit;
  container_int.TA(addr^) := struct;
  result := true;
end;

procedure TA_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: container_int.TA;
begin
  struct := container_int.TA(addr^);
  A_C_marshaller.marshal(enc,@struct.c);
  stat_long.marshal(enc,@struct.d);
  A_E_marshaller.marshal(enc,@struct.e);
end;

procedure TA_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(container_int.TA(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TA_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(container_int.TA));
{$HINTS OFF}
  System.Initialize(container_int.TA(addr^));
{$HINTS ON}
end;

procedure TA_marshaller._assign(dst, src: Pointer);
begin
  container_int.TA(dst^) := container_int.TA(src^);
end;

function TA_marshaller.typecode: ITypeCode;
begin
  result := _tc_A.typecode;
end;

initialization
  A_C_marshaller := TA_C_marshaller.Create();
  A_E_F_marshaller := TA_E_F_marshaller.Create();
  A_E_marshaller := TA_E_marshaller.Create();
  A_marshaller := TA_marshaller.Create();
  _tc_A_C := CreateTypeCodeConst('010000001100000031000000010000000c00000049444c3a412f433a312e30000200000043000000010000000d0000004a5553545f5445'+
    '5354494e4700');
  _tc_A_E_F := CreateTypeCodeConst('010000000f00000030000000010000000e00000049444c3a412f452f463a312e30000000020000004600000001000000020000006200000008000000');
  _tc_A_E := CreateTypeCodeConst('010000001000000070000000010000000c00000049444c3a412f453a312e300002000000450000001100000031000000010000000c0000'+
    '0049444c3a412f433a312e30000200000043000000010000000d0000004a5553545f54455354494e4700000000ffffffff010000000000'+
    '0000020000006600000001000000');
  _tc_A := CreateTypeCodeConst('010000000f000000f0000000010000000a00000049444c3a413a312e300000000200000041000000030000000200000063000000110000'+
    '0031000000010000000c00000049444c3a412f433a312e30000200000043000000010000000d0000004a5553545f54455354494e470000'+
    '000002000000640000000300000002000000650000001000000070000000010000000c00000049444c3a412f453a312e30000200000045'+
    '0000001100000031000000010000000c00000049444c3a412f433a312e30000200000043000000010000000d0000004a5553545f544553'+
    '54494e4700000000ffffffff0100000000000000020000006600000001000000');
end.
