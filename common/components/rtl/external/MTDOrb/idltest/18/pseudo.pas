// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:26
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -any -i./ ./\pseudo.idl" 
//                                                                            
unit pseudo;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, pseudo_int, value_int, value, poa_int, poa;

type

  TS1_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TS2_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TS3_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TE_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  S2_seq = Array of TS2;
  PS2_seq = ^S2_seq;

  TS2_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:v:1.0 } 
  Tv = class(TValueBase,Iv,IValueBase)
  protected
    Fv_ve : TE;
    Fv_vs : TS1;
    function ve : TE; overload;
    procedure ve(val : TE); overload;
    function vs : TS1; overload;
    procedure vs(val : TS1); overload;
    function _copy_value : IValueBase; override;
    procedure _copy_members(const v: TObject); override;
    procedure _marshal_members(const enc: IEncoder); override;
    procedure _get_marshal_info(const str: TStrings;out chunked: Boolean); override;
    function  _demarshal_members(const dec: Idecoder): Boolean; override;
    function narrow_helper(const repoid: RepositoryID): Pointer; override;
  public
    class function _downcast(const vb : IValueBase): Iv;
  end;

  {** factory for valuetype IDL:v:1.0} 
  Tv_init = class(TInterfacedObject,Iv_init,IValueFactory)
  protected
    function init(ve: TE): Iv; virtual; abstract;
    function narrow_helper(const repoid: RepositoryID): Pointer;
    function create_for_umarshal(): IValueBase; virtual; abstract;
  public
    class function _downcast(const vf : IValueFactory): Iv_init;
  end;

  Tv_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  Tresult_type_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:foo:1.0 } 
  Tfoo = class(TORBObject,Ifoo)
  protected
    function bar(const a1: IAny; out a2: IAny; var a3: IAny): IAny; virtual; abstract;
    function bar1(const tc1: ITypeCode; out tc2: ITypeCode; var tc3: ITypeCode): ITypeCode; virtual; abstract;
    function bar2(const rtype: IAny): IAny; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): Ifoo;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:foo:1.0} 
  Tfoo_stub = class(Tfoo)
  protected
    function bar(const a1: IAny; out a2: IAny; var a3: IAny): IAny; override;
    function bar1(const tc1: ITypeCode; out tc2: ITypeCode; var tc3: ITypeCode): ITypeCode; override;
    function bar2(const rtype: IAny): IAny; override;
  end;

  {** POA stub for interface IDL:foo:1.0} 
  Tfoo_stub_clp = class(TPOAStub,IPOAStub,Ifoo)
  protected
    function bar(const a1: IAny; out a2: IAny; var a3: IAny): IAny; virtual;
    function bar1(const tc1: ITypeCode; out tc2: ITypeCode; var tc3: ITypeCode): ITypeCode; virtual;
    function bar2(const rtype: IAny): IAny; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:foo:1.0} 
  Tfoo_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,Ifoo)
  protected
    function bar(const a1: IAny; out a2: IAny; var a3: IAny): IAny; virtual; abstract;
    function bar1(const tc1: ITypeCode; out tc2: ITypeCode; var tc3: ITypeCode): ITypeCode; virtual; abstract;
    function bar2(const rtype: IAny): IAny; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): Ifoo;
    class function _narrow(const srv : IServant): Ifoo;
  end;

  Tfoo_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  function S1_to_any(const val: TS1): IAny;
  function any_to_S1(const a: IAny; var val: TS1): Boolean;

  function S2_to_any(const val: TS2): IAny;
  function any_to_S2(const a: IAny; var val: TS2): Boolean;

  function S3_to_any(const val: TS3): IAny;
  function any_to_S3(const a: IAny; var val: TS3): Boolean;

  function E_to_any(const val: TE): IAny;
  function any_to_E(const a: IAny; var val: TE): Boolean;

  function S2_seq_to_any(const val): IAny;
  function any_to_S2_seq(const a: IAny; var val): Boolean;

  function v_to_any(const val: Iv): IAny;
  function any_to_v(const a: IAny; var val: Iv): Boolean;

  function result_type_to_any(const val: Tresult_type): IAny;
  function any_to_result_type(const a: IAny; var val: Tresult_type): Boolean;

  function foo_to_any(const val: Ifoo): IAny;
  function any_to_foo(const a: IAny; var val: Ifoo): Boolean;

var
  S1_marshaller : IStaticTypeInfo;
  S2_marshaller : IStaticTypeInfo;
  S3_marshaller : IStaticTypeInfo;
  E_marshaller : IStaticTypeInfo;
  S2_seq_marshaller : IStaticTypeInfo;
  v_marshaller : IStaticTypeInfo;
  result_type_marshaller : IStaticTypeInfo;
  foo_marshaller : IStaticTypeInfo;
  _tc_S1 : ITypeCodeConst;
  _tc_S2 : ITypeCodeConst;
  _tc_S3 : ITypeCodeConst;
  _tc_E : ITypeCodeConst;
  _tc_S2_seq : ITypeCodeConst;
  _tc_v : ITypeCodeConst;
  _tc_result_type : ITypeCodeConst;
  _tc_foo : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TS1_marshaller
//***********************************************************
function TS1_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: pseudo_int.TS1;
begin
  result := false;
  if not stat_long.demarshal(dec,@struct.x) then exit;
  if not stat_char.demarshal(dec,@struct.c) then exit;
  pseudo_int.TS1(addr^) := struct;
  result := true;
end;

procedure TS1_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: pseudo_int.TS1;
begin
  struct := pseudo_int.TS1(addr^);
  stat_long.marshal(enc,@struct.x);
  stat_char.marshal(enc,@struct.c);
end;

procedure TS1_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(pseudo_int.TS1(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TS1_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(pseudo_int.TS1));
{$HINTS OFF}
  System.Initialize(pseudo_int.TS1(addr^));
{$HINTS ON}
end;

procedure TS1_marshaller._assign(dst, src: Pointer);
begin
  pseudo_int.TS1(dst^) := pseudo_int.TS1(src^);
end;

function TS1_marshaller.typecode: ITypeCode;
begin
  result := _tc_S1.typecode;
end;

//***********************************************************
// TS2_marshaller
//***********************************************************
function TS2_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: pseudo_int.TS2;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.str) then exit;
  pseudo_int.TS2(addr^) := struct;
  result := true;
end;

procedure TS2_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: pseudo_int.TS2;
begin
  struct := pseudo_int.TS2(addr^);
  stat_string.marshal(enc,@struct.str);
end;

procedure TS2_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(pseudo_int.TS2(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TS2_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(pseudo_int.TS2));
{$HINTS OFF}
  System.Initialize(pseudo_int.TS2(addr^));
{$HINTS ON}
end;

procedure TS2_marshaller._assign(dst, src: Pointer);
begin
  pseudo_int.TS2(dst^) := pseudo_int.TS2(src^);
end;

function TS2_marshaller.typecode: ITypeCode;
begin
  result := _tc_S2.typecode;
end;

//***********************************************************
// TS3_marshaller
//***********************************************************
function TS3_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: pseudo_int.TS3;
begin
  result := false;
  if not stat_char.demarshal(dec,@struct.c) then exit;
  if not stat_any.demarshal(dec,@struct.a) then exit;
  if not stat_TypeCode.demarshal(dec,@struct.tc) then exit;
  pseudo_int.TS3(addr^) := struct;
  result := true;
end;

procedure TS3_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: pseudo_int.TS3;
begin
  struct := pseudo_int.TS3(addr^);
  stat_char.marshal(enc,@struct.c);
  stat_any.marshal(enc,@struct.a);
  stat_TypeCode.marshal(enc,@struct.tc);
end;

procedure TS3_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(pseudo_int.TS3(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TS3_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(pseudo_int.TS3));
{$HINTS OFF}
  System.Initialize(pseudo_int.TS3(addr^));
{$HINTS ON}
end;

procedure TS3_marshaller._assign(dst, src: Pointer);
begin
  pseudo_int.TS3(dst^) := pseudo_int.TS3(src^);
end;

function TS3_marshaller.typecode: ITypeCode;
begin
  result := _tc_S3.typecode;
end;

//***********************************************************
// TE_marshaller
//***********************************************************
function TE_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TE_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TE_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TE_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TE_marshaller._assign(dst, src: Pointer);
begin
  TE(dst^) := TE(src^);
end;

function TE_marshaller.typecode: ITypeCode;
begin
  result := _tc_E.typecode;
end;

//***********************************************************
// TS2_seq_marshaller
//***********************************************************

function TS2_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TS2;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(S2_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not S2_marshaller.demarshal(dec,@val) then exit;
        S2_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TS2_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(S2_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      S2_marshaller.marshal(enc,@S2_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TS2_seq_marshaller._free(var addr: Pointer);
begin
  setLength(S2_seq(addr^),0);
  freemem(addr);
end;

procedure TS2_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TS2_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TS2_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_S2_seq.typecode;
end;

//***********************************************************
// Tv
//***********************************************************
function Tv.ve: TE;
begin
  result := Fv_ve;
end;

procedure Tv.ve(val : TE);
begin
  Fv_ve := val;
end;

function Tv.vs: TS1;
begin
  result := Fv_vs;
end;

procedure Tv.vs(val : TS1);
begin
  Fv_vs := val;
end;

function Tv.narrow_helper(const repoid: RepositoryID): Pointer;
begin
  if strcomp(PAnsiChar(repoid),'IDL:v:1.0') = 0 then
    result := Pointer(Self as Iv)
  else
    result := nil;
end;

class function Tv._downcast(const vb : IValueBase): Iv;
var
  ptr: pointer;
begin
  result := nil;
  if vb <> nil then
    begin
      ptr := vb.narrow_helper('IDL:v:1.0');
      if ptr <> nil then
        result := Iv(ptr);
    end;
end;

procedure Tv._get_marshal_info(const str: TStrings; out chunked: Boolean);
begin
  str.Add('IDL:v:1.0');
  chunked := false;
end;

procedure Tv._marshal_members(const enc: IEncoder);
begin
  E_marshaller.marshal(enc,@Fv_ve);
  S1_marshaller.marshal(enc,@Fv_vs);
end;

function  Tv._demarshal_members(const dec: IDecoder): Boolean;
begin
  result := false;
  if not E_marshaller.demarshal(dec,@Fv_ve) then exit;
  if not S1_marshaller.demarshal(dec,@Fv_vs) then exit;
  result := true;
end;

procedure Tv._copy_members(const v: TObject);
var
  other : Tv;
begin
  inherited _copy_members(v);
  other := v as Tv;
  ve(other.ve);
  vs(other.vs);
end;

function  Tv._copy_value: IValueBase;
var
  list: TStrings;
begin
  list := TStringList.Create;
  try
    result := _create(list,'IDL:v:1.0');
    result._copy_members(self);
  finally
    list.free;
  end;
end;

//***********************************************************
// Tv_init
//***********************************************************
class function Tv_init._downcast(const vf : IValueFactory): Iv_init;
var
  ptr: pointer;
begin
  result := nil;
  if vf <> nil then
    begin
      ptr := vf.narrow_helper('IDL:v:1.0');
      if ptr <> nil then result := Iv_init(ptr);
    end;
end;

function Tv_init.narrow_helper(const repoid: RepositoryID): Pointer;
begin
  result := nil;
  if strcomp(PAnsiChar(repoid),'IDL:v:1.0')= 0 then
    result := Pointer( self as Iv_init);
end;

//***********************************************************
// Tv_marshaller
//***********************************************************
procedure Tv_marshaller._create(var addr: Pointer);
begin
  Iv(addr^) := Tv.Create as Iv;
end;

procedure Tv_marshaller._assign(dst, src: Pointer);
begin
  Iv(dst^) := Iv(src^);
end;

procedure Tv_marshaller._free(var addr: Pointer);
begin
  Iv(addr^) := nil;
end;

function Tv_marshaller.demarshal(dec: IDecoder;
  const addr: Pointer): Boolean;
var
  vb : IValueBase;
begin
  result := TValueBase._demarshal(dec,vb,'IDL:v:1.0');
  if not result then exit;
  Iv(addr^) := Tv._downcast(vb);
  result := (vb = nil) or (vb <> nil) and (Pointer(addr^) <> nil);
end;

procedure Tv_marshaller.marshal(enc: IEncoder; const addr: Pointer);
begin
  TValueBase._marshal(enc,Iv(addr^) as IValueBase);
end;

function Tv_marshaller.typecode: ITypeCode;
begin
  result := _tc_v.typecode;
end;

//***********************************************************
// Tresult_type_marshaller
//***********************************************************
function Tresult_type_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure Tresult_type_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure Tresult_type_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure Tresult_type_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure Tresult_type_marshaller._assign(dst, src: Pointer);
begin
  Tresult_type(dst^) := Tresult_type(src^);
end;

function Tresult_type_marshaller.typecode: ITypeCode;
begin
  result := _tc_result_type.typecode;
end;

//***********************************************************
// Tfoo
//***********************************************************
function Tfoo.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:foo:1.0' then
    begin
      result := Pointer(self as Ifoo);
      exit;
    end;
end;

class function Tfoo._narrow(const obj : IORBObject): Ifoo;
var
  p: Pointer;
  stub: Tfoo_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:foo:1.0');
  if p <> nil then
    result := Ifoo(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:foo:1.0') then
        begin
          stub := Tfoo_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function Tfoo.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:foo:1.0'
end;

//***********************************************************
// Tfoo_stub
//***********************************************************
function Tfoo_stub.bar(const a1: IAny; out a2: IAny; var a3: IAny): IAny;
var
  req: IStaticRequest;
  _a1: IStaticAny;
  _a2: IStaticAny;
  _a3: IStaticAny;
  _result: IStaticAny;
begin
  _a1 := StaticAny(stat_any,@a1);
  _a2 := StaticAny(stat_any,@a2);
  _a3 := StaticAny(stat_any,@a3);
  _result := StaticAny(stat_any, @result);
  req := StaticRequest(self,'bar');
  req.add_in_arg(_a1);
  req.add_out_arg(_a2);
  req.add_inout_arg(_a3);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function Tfoo_stub.bar1(const tc1: ITypeCode; out tc2: ITypeCode; var tc3: ITypeCode): ITypeCode;
var
  req: IStaticRequest;
  _tc1: IStaticAny;
  _tc2: IStaticAny;
  _tc3: IStaticAny;
  _result: IStaticAny;
begin
  _tc1 := StaticAny(stat_TypeCode,@tc1);
  _tc2 := StaticAny(stat_TypeCode,@tc2);
  _tc3 := StaticAny(stat_TypeCode,@tc3);
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'bar1');
  req.add_in_arg(_tc1);
  req.add_out_arg(_tc2);
  req.add_inout_arg(_tc3);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function Tfoo_stub.bar2(const rtype: IAny): IAny;
var
  req: IStaticRequest;
  _rtype: IStaticAny;
  _result: IStaticAny;
begin
  _rtype := StaticAny(stat_any,@rtype);
  _result := StaticAny(stat_any, @result);
  req := StaticRequest(self,'bar2');
  req.add_in_arg(_rtype);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// Tfoo_stub_clp
//***********************************************************
function Tfoo_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:foo:1.0' then
    begin
      result := Pointer(self as Ifoo);
      exit;
  end;
end;

function Tfoo_stub_clp.bar(const a1: IAny; out a2: IAny; var a3: IAny): IAny;
var
  _srv: IServant;
  srv: Ifoo;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := Tfoo_serv._narrow(_srv);
      if srv <> nil then
        result := srv.bar(a1, a2, a3)
    end;
  _postinvoke();
end;

function Tfoo_stub_clp.bar1(const tc1: ITypeCode; out tc2: ITypeCode; var tc3: ITypeCode): ITypeCode;
var
  _srv: IServant;
  srv: Ifoo;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := Tfoo_serv._narrow(_srv);
      if srv <> nil then
        result := srv.bar1(tc1, tc2, tc3)
    end;
  _postinvoke();
end;

function Tfoo_stub_clp.bar2(const rtype: IAny): IAny;
var
  _srv: IServant;
  srv: Ifoo;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := Tfoo_serv._narrow(_srv);
      if srv <> nil then
        result := srv.bar2(rtype)
    end;
  _postinvoke();
end;

//***********************************************************
// Tfoo_serv
//***********************************************************
function Tfoo_serv._this(): Ifoo;
var
  obj: IORBObject;
begin
  obj := this();
  result := Tfoo._narrow(obj);
end;

function Tfoo_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:foo:1.0';
end;

function Tfoo_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:foo:1.0';
end;

function Tfoo_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := Tfoo_stub_clp.Create(poa,obj);
end;

procedure Tfoo_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function Tfoo_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:foo:1.0' then
    begin
      result := Pointer(Ifoo(self));
      exit;
    end;
end;

class function Tfoo_serv._narrow(const srv : IServant): Ifoo;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:foo:1.0');
  if p <> nil then
    result := Ifoo(p)
end;

function Tfoo_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  bar_result: IAny;
  bar_a1: IAny;
  bar_a2: IAny;
  bar_a3: IAny;
  bar1_result: ITypeCode;
  bar1_tc1: ITypeCode;
  bar1_tc2: ITypeCode;
  bar1_tc3: ITypeCode;
  bar2_result: IAny;
  bar2_rtype: IAny;
begin
  result := true;
  if req.op_name = 'bar' then
    begin
      req.add_in_arg(StaticAny(stat_any,@bar_a1) as IStaticAny);
      req.add_out_arg(StaticAny(stat_any,@bar_a2) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_any,@bar_a3) as IStaticAny);
      req.set_result(StaticAny(stat_any,@bar_result) as IStaticAny);
      if not req.read_args() then  exit;
      bar_result := bar(bar_a1, bar_a2, bar_a3);
      req.write_results();
      exit;
    end
  else if req.op_name = 'bar1' then
    begin
      req.add_in_arg(StaticAny(stat_TypeCode,@bar1_tc1) as IStaticAny);
      req.add_out_arg(StaticAny(stat_TypeCode,@bar1_tc2) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_TypeCode,@bar1_tc3) as IStaticAny);
      req.set_result(StaticAny(stat_TypeCode,@bar1_result) as IStaticAny);
      if not req.read_args() then  exit;
      bar1_result := bar1(bar1_tc1, bar1_tc2, bar1_tc3);
      req.write_results();
      exit;
    end
  else if req.op_name = 'bar2' then
    begin
      req.add_in_arg(StaticAny(stat_any,@bar2_rtype) as IStaticAny);
      req.set_result(StaticAny(stat_any,@bar2_result) as IStaticAny);
      if not req.read_args() then  exit;
      bar2_result := bar2(bar2_rtype);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// Tfoo_marshaller
//***********************************************************
function Tfoo_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  Ifoo(addr^) := Tfoo._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure Tfoo_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := Ifoo(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure Tfoo_marshaller._free(var addr: Pointer);
begin
  Ifoo(addr^) := nil;
end;

procedure Tfoo_marshaller._create(var addr: Pointer);
begin
  Ifoo(addr^) := Tfoo_stub.Create();
end;

procedure Tfoo_marshaller._assign(dst, src: Pointer);
begin
  Ifoo(dst^) := Ifoo(src^);
end;

function Tfoo_marshaller.typecode: ITypeCode;
begin
  result := _tc_foo.typecode;
end;

function any_to_S1(const a: IAny; var val: TS1): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(S1_marshaller,@val);
  result := a.to_static_any(stat);
end;

function S1_to_any(const val: TS1): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(S1_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_S2(const a: IAny; var val: TS2): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(S2_marshaller,@val);
  result := a.to_static_any(stat);
end;

function S2_to_any(const val: TS2): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(S2_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_S3(const a: IAny; var val: TS3): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(S3_marshaller,@val);
  result := a.to_static_any(stat);
end;

function S3_to_any(const val: TS3): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(S3_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_E(const a: IAny; var val: TE): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(E_marshaller,@val);
  result := a.to_static_any(stat);
end;

function E_to_any(const val: TE): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(E_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_S2_seq(const a: IAny; var val): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(S2_seq_marshaller,@val);
  result := a.to_static_any(stat);
end;

function S2_seq_to_any(const val): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(S2_seq_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_v(const a: IAny; var val: Iv): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(v_marshaller,@val);
  result := a.to_static_any(stat);
end;

function v_to_any(const val: Iv): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(v_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_result_type(const a: IAny; var val: Tresult_type): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(result_type_marshaller,@val);
  result := a.to_static_any(stat);
end;

function result_type_to_any(const val: Tresult_type): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(result_type_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_foo(const a: IAny; var val: Ifoo): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(foo_marshaller,@val);
  result := a.to_static_any(stat);
end;

function foo_to_any(const val: Ifoo): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(foo_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

initialization
  S1_marshaller := TS1_marshaller.Create();
  S2_marshaller := TS2_marshaller.Create();
  S3_marshaller := TS3_marshaller.Create();
  E_marshaller := TE_marshaller.Create();
  S2_seq_marshaller := TS2_seq_marshaller.Create();
  v_marshaller := Tv_marshaller.Create();
  result_type_marshaller := Tresult_type_marshaller.Create();
  foo_marshaller := Tfoo_marshaller.Create();
  _tc_S1 := CreateTypeCodeConst('010000000f00000038000000010000000b00000049444c3a53313a312e3000000300000053310000020000000200000078000000030000'+
    '00020000006300000009000000');
  _tc_S2 := CreateTypeCodeConst('010000000f00000030000000010000000b00000049444c3a53323a312e30000003000000533200000100000004000000737472001200000000000000');
  _tc_S3 := CreateTypeCodeConst('010000000f00000044000000010000000b00000049444c3a53333a312e3000000300000053330000030000000200000063000000090000'+
    '0002000000610000000b00000003000000746300000c000000');
  _tc_E := CreateTypeCodeConst('010000001100000047000000010000000a00000049444c3a453a312e300000000200000045000000050000000300000065310000030000'+
    '00653200000300000065330000030000006534000003000000653500');
  _tc_S2_seq := CreateTypeCodeConst('010000001300000040000000010000000f00000030000000010000000b00000049444c3a53323a312e3000000300000053320000010000'+
    '000400000073747200120000000000000000000000');
  _tc_v := CreateTypeCodeConst('010000001d000000ca000000010000000a00000049444c3a763a312e300000000200000076000000000000000200000003000000766500'+
    '001100000047000000010000000a00000049444c3a453a312e300000000200000045000000050000000300000065310000030000006532'+
    '00000300000065330000030000006534000003000000653500000100000003000000767300000f00000038000000010000000b00000049'+
    '444c3a53313a312e3000000300000053310000020000000200000078000000030000000200000063000000090000000100');
  _tc_result_type := CreateTypeCodeConst('010000001100000052000000010000001400000049444c3a726573756c745f747970653a312e30000c000000726573756c745f74797065'+
    '000300000007000000745f656e756d000006000000745f73657100000006000000745f76616c00');
  _tc_foo := CreateTypeCodeConst('010000000e0000001c000000010000000c00000049444c3a666f6f3a312e300004000000666f6f00');
end.
