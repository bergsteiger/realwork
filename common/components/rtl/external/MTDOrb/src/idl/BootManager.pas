// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -without-prefix -i..\..\idl ..\..\idl\BootManager.idl" 
//                                                                            
unit BootManager;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, BootManager_int, poa_int, poa;

type

  TNotFound_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/BootManager/NotFound:1.0 } 
  TNotFound = class(UserException,INotFound)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TNotFound); overload;
    constructor Create(); overload;
  end;

  TAlreadyExists_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/BootManager/AlreadyExists:1.0 } 
  TAlreadyExists = class(UserException,IAlreadyExists)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TAlreadyExists); overload;
    constructor Create(); overload;
  end;

  {** IDL:omg.org/BootManager:1.0 } 
  TBootManager = class(TORBObject,IBootManager)
  protected
    procedure add_binding(const oid: TObjectId; const obj: IORBObject); virtual; abstract;
    procedure remove_binding(const oid: TObjectId); virtual; abstract;
    procedure set_locator(const locator: IBootLocator); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IBootManager;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/BootManager:1.0} 
  TBootManager_stub = class(TBootManager)
  protected
    procedure add_binding(const oid: TObjectId; const obj: IORBObject); override;
    procedure remove_binding(const oid: TObjectId); override;
    procedure set_locator(const locator: IBootLocator); override;
  end;

  {** POA stub for interface IDL:omg.org/BootManager:1.0} 
  TBootManager_stub_clp = class(TPOAStub,IPOAStub,IBootManager)
  protected
    procedure add_binding(const oid: TObjectId; const obj: IORBObject); virtual;
    procedure remove_binding(const oid: TObjectId); virtual;
    procedure set_locator(const locator: IBootLocator); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/BootManager:1.0} 
  TBootManager_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IBootManager)
  protected
    procedure add_binding(const oid: TObjectId; const obj: IORBObject); virtual; abstract;
    procedure remove_binding(const oid: TObjectId); virtual; abstract;
    procedure set_locator(const locator: IBootLocator); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IBootManager;
    class function _narrow(const srv : IServant): IBootManager;
  end;

  TBootManager_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/BootLocator:1.0 } 
  TBootLocator = class(TORBObject,IBootLocator)
  protected
    procedure locate(const oid: TObjectId; out obj: IORBObject; out add: Boolean); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IBootLocator;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/BootLocator:1.0} 
  TBootLocator_stub = class(TBootLocator)
  protected
    procedure locate(const oid: TObjectId; out obj: IORBObject; out add: Boolean); override;
  end;

  {** POA stub for interface IDL:omg.org/BootLocator:1.0} 
  TBootLocator_stub_clp = class(TPOAStub,IPOAStub,IBootLocator)
  protected
    procedure locate(const oid: TObjectId; out obj: IORBObject; out add: Boolean); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/BootLocator:1.0} 
  TBootLocator_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IBootLocator)
  protected
    procedure locate(const oid: TObjectId; out obj: IORBObject; out add: Boolean); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IBootLocator;
    class function _narrow(const srv : IServant): IBootLocator;
  end;

  TBootLocator_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  NotFound_marshaller : IStaticTypeInfo;
  AlreadyExists_marshaller : IStaticTypeInfo;
  BootManager_marshaller : IStaticTypeInfo;
  BootLocator_marshaller : IStaticTypeInfo;
  _tc_NotFound : ITypeCodeConst;
  _tc_AlreadyExists : ITypeCodeConst;
  _tc_BootManager : ITypeCodeConst;
  _tc_BootLocator : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TNotFound_marshaller
//***********************************************************
function TNotFound_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TNotFound_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/BootManager/NotFound:1.0');
  enc.except_end;
end;

procedure TNotFound_marshaller._free(var addr: Pointer);
begin
  INotFound(addr^) := nil;
end;

procedure TNotFound_marshaller._create(var addr: Pointer);
begin
  INotFound(addr^) := TNotFound.Create();
end;

procedure TNotFound_marshaller._assign(dst, src: Pointer);
begin
  INotFound(dst^) := INotFound(src^);
end;

function TNotFound_marshaller.typecode: ITypeCode;
begin
  result := _tc_NotFound.typecode;
end;

//***********************************************************
// TNotFound
//***********************************************************
constructor TNotFound.Create(ex: TNotFound);
begin
  inherited Create();
end;

procedure TNotFound.throw;
begin
  raise TNotFound.Create(self);
end;

function TNotFound.clone(): IORBException;
begin
  result := TNotFound.Create(self);
end;

procedure TNotFound.encode(const enc: IEncoder);
var
  int : INotFound;
begin
  int := self;
  NotFound_marshaller.marshal(enc,@int);
end;

procedure TNotFound.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotFound_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TNotFound.Create();
begin
  inherited Create();
end;

function TNotFound.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/BootManager/NotFound:1.0';
end;

//***********************************************************
// TAlreadyExists_marshaller
//***********************************************************
function TAlreadyExists_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TAlreadyExists_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/BootManager/AlreadyExists:1.0');
  enc.except_end;
end;

procedure TAlreadyExists_marshaller._free(var addr: Pointer);
begin
  IAlreadyExists(addr^) := nil;
end;

procedure TAlreadyExists_marshaller._create(var addr: Pointer);
begin
  IAlreadyExists(addr^) := TAlreadyExists.Create();
end;

procedure TAlreadyExists_marshaller._assign(dst, src: Pointer);
begin
  IAlreadyExists(dst^) := IAlreadyExists(src^);
end;

function TAlreadyExists_marshaller.typecode: ITypeCode;
begin
  result := _tc_AlreadyExists.typecode;
end;

//***********************************************************
// TAlreadyExists
//***********************************************************
constructor TAlreadyExists.Create(ex: TAlreadyExists);
begin
  inherited Create();
end;

procedure TAlreadyExists.throw;
begin
  raise TAlreadyExists.Create(self);
end;

function TAlreadyExists.clone(): IORBException;
begin
  result := TAlreadyExists.Create(self);
end;

procedure TAlreadyExists.encode(const enc: IEncoder);
var
  int : IAlreadyExists;
begin
  int := self;
  AlreadyExists_marshaller.marshal(enc,@int);
end;

procedure TAlreadyExists.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(AlreadyExists_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TAlreadyExists.Create();
begin
  inherited Create();
end;

function TAlreadyExists.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/BootManager/AlreadyExists:1.0';
end;

//***********************************************************
// TBootManager
//***********************************************************
function TBootManager.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/BootManager:1.0' then
    begin
      result := Pointer(self as IBootManager);
      exit;
    end;
end;

class function TBootManager._narrow(const obj : IORBObject): IBootManager;
var
  p: Pointer;
  stub: TBootManager_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/BootManager:1.0');
  if p <> nil then
    result := IBootManager(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/BootManager:1.0') then
        begin
          stub := TBootManager_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TBootManager.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/BootManager:1.0'
end;

//***********************************************************
// TBootManager_stub
//***********************************************************
procedure TBootManager_stub.add_binding(const oid: TObjectId; const obj: IORBObject);
var
  req: IStaticRequest;
  _oid: IStaticAny;
  _obj: IStaticAny;
begin
  _oid := StaticAny(stat_string,@oid);
  _obj := StaticAny(stat_object,@obj);
  req := StaticRequest(self,'add_binding');
  req.add_in_arg(_oid);
  req.add_in_arg(_obj);
  req.set_exceptions_tc([_tc_AlreadyExists.typecode]);
  req.invoke;
  dorb_static_throw(req,[AlreadyExists_marshaller, 'IDL:omg.org/BootManager/AlreadyExists:1.0']);
end;

procedure TBootManager_stub.remove_binding(const oid: TObjectId);
var
  req: IStaticRequest;
  _oid: IStaticAny;
begin
  _oid := StaticAny(stat_string,@oid);
  req := StaticRequest(self,'remove_binding');
  req.add_in_arg(_oid);
  req.set_exceptions_tc([_tc_NotFound.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/BootManager/NotFound:1.0']);
end;

procedure TBootManager_stub.set_locator(const locator: IBootLocator);
var
  req: IStaticRequest;
  _locator: IStaticAny;
begin
  _locator := StaticAny(BootLocator_marshaller,@locator);
  req := StaticRequest(self,'set_locator');
  req.add_in_arg(_locator);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TBootManager_stub_clp
//***********************************************************
function TBootManager_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/BootManager:1.0' then
    begin
      result := Pointer(self as IBootManager);
      exit;
  end;
end;

procedure TBootManager_stub_clp.add_binding(const oid: TObjectId; const obj: IORBObject);
var
  _srv: IServant;
  srv: IBootManager;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBootManager_serv._narrow(_srv);
      if srv <> nil then
        srv.add_binding(oid, obj)
    end;
  _postinvoke();
end;

procedure TBootManager_stub_clp.remove_binding(const oid: TObjectId);
var
  _srv: IServant;
  srv: IBootManager;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBootManager_serv._narrow(_srv);
      if srv <> nil then
        srv.remove_binding(oid)
    end;
  _postinvoke();
end;

procedure TBootManager_stub_clp.set_locator(const locator: IBootLocator);
var
  _srv: IServant;
  srv: IBootManager;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBootManager_serv._narrow(_srv);
      if srv <> nil then
        srv.set_locator(locator)
    end;
  _postinvoke();
end;

//***********************************************************
// TBootManager_serv
//***********************************************************
function TBootManager_serv._this(): IBootManager;
var
  obj: IORBObject;
begin
  obj := this();
  result := TBootManager._narrow(obj);
end;

function TBootManager_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/BootManager:1.0';
end;

function TBootManager_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/BootManager:1.0';
end;

function TBootManager_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TBootManager_stub_clp.Create(poa,obj);
end;

procedure TBootManager_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TBootManager_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/BootManager:1.0' then
    begin
      result := Pointer(IBootManager(self));
      exit;
    end;
end;

class function TBootManager_serv._narrow(const srv : IServant): IBootManager;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/BootManager:1.0');
  if p <> nil then
    result := IBootManager(p)
end;

function TBootManager_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  add_binding_oid: TObjectId;
  add_binding_obj: IORBObject;
  remove_binding_oid: TObjectId;
  set_locator_locator: IBootLocator;
begin
  result := true;
  if req.op_name = 'add_binding' then
    begin
      req.add_in_arg(StaticAny(stat_string,@add_binding_oid) as IStaticAny);
      req.add_in_arg(StaticAny(stat_object,@add_binding_obj) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_AlreadyExists.typecode]);
      try
        add_binding(add_binding_oid, add_binding_obj);
      except
        on AlreadyExists: TAlreadyExists do
          req.set_exception(TAlreadyExists.Create(AlreadyExists) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'remove_binding' then
    begin
      req.add_in_arg(StaticAny(stat_string,@remove_binding_oid) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode]);
      try
        remove_binding(remove_binding_oid);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'set_locator' then
    begin
      req.add_in_arg(StaticAny(BootLocator_marshaller,@set_locator_locator) as IStaticAny);
      if not req.read_args() then  exit;
      set_locator(set_locator_locator);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TBootManager_marshaller
//***********************************************************
function TBootManager_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IBootManager(addr^) := TBootManager._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TBootManager_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IBootManager(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TBootManager_marshaller._free(var addr: Pointer);
begin
  IBootManager(addr^) := nil;
end;

procedure TBootManager_marshaller._create(var addr: Pointer);
begin
  IBootManager(addr^) := TBootManager_stub.Create();
end;

procedure TBootManager_marshaller._assign(dst, src: Pointer);
begin
  IBootManager(dst^) := IBootManager(src^);
end;

function TBootManager_marshaller.typecode: ITypeCode;
begin
  result := _tc_BootManager.typecode;
end;

//***********************************************************
// TBootLocator
//***********************************************************
function TBootLocator.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/BootLocator:1.0' then
    begin
      result := Pointer(self as IBootLocator);
      exit;
    end;
end;

class function TBootLocator._narrow(const obj : IORBObject): IBootLocator;
var
  p: Pointer;
  stub: TBootLocator_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/BootLocator:1.0');
  if p <> nil then
    result := IBootLocator(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/BootLocator:1.0') then
        begin
          stub := TBootLocator_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TBootLocator.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/BootLocator:1.0'
end;

//***********************************************************
// TBootLocator_stub
//***********************************************************
procedure TBootLocator_stub.locate(const oid: TObjectId; out obj: IORBObject; out add: Boolean);
var
  req: IStaticRequest;
  _oid: IStaticAny;
  _obj: IStaticAny;
  _add: IStaticAny;
begin
  _oid := StaticAny(stat_string,@oid);
  _obj := StaticAny(stat_object,@obj);
  _add := StaticAny(stat_boolean,@add);
  req := StaticRequest(self,'locate');
  req.add_in_arg(_oid);
  req.add_out_arg(_obj);
  req.add_out_arg(_add);
  req.set_exceptions_tc([_tc_NotFound.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/BootManager/NotFound:1.0']);
end;

//***********************************************************
// TBootLocator_stub_clp
//***********************************************************
function TBootLocator_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/BootLocator:1.0' then
    begin
      result := Pointer(self as IBootLocator);
      exit;
  end;
end;

procedure TBootLocator_stub_clp.locate(const oid: TObjectId; out obj: IORBObject; out add: Boolean);
var
  _srv: IServant;
  srv: IBootLocator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBootLocator_serv._narrow(_srv);
      if srv <> nil then
        srv.locate(oid, obj, add)
    end;
  _postinvoke();
end;

//***********************************************************
// TBootLocator_serv
//***********************************************************
function TBootLocator_serv._this(): IBootLocator;
var
  obj: IORBObject;
begin
  obj := this();
  result := TBootLocator._narrow(obj);
end;

function TBootLocator_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/BootLocator:1.0';
end;

function TBootLocator_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/BootLocator:1.0';
end;

function TBootLocator_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TBootLocator_stub_clp.Create(poa,obj);
end;

procedure TBootLocator_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TBootLocator_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/BootLocator:1.0' then
    begin
      result := Pointer(IBootLocator(self));
      exit;
    end;
end;

class function TBootLocator_serv._narrow(const srv : IServant): IBootLocator;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/BootLocator:1.0');
  if p <> nil then
    result := IBootLocator(p)
end;

function TBootLocator_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  locate_oid: TObjectId;
  locate_obj: IORBObject;
  locate_add: Boolean;
begin
  result := true;
  if req.op_name = 'locate' then
    begin
      req.add_in_arg(StaticAny(stat_string,@locate_oid) as IStaticAny);
      req.add_out_arg(StaticAny(stat_object,@locate_obj) as IStaticAny);
      req.add_out_arg(StaticAny(stat_boolean,@locate_add) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode]);
      try
        locate(locate_oid, locate_obj, locate_add);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TBootLocator_marshaller
//***********************************************************
function TBootLocator_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IBootLocator(addr^) := TBootLocator._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TBootLocator_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IBootLocator(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TBootLocator_marshaller._free(var addr: Pointer);
begin
  IBootLocator(addr^) := nil;
end;

procedure TBootLocator_marshaller._create(var addr: Pointer);
begin
  IBootLocator(addr^) := TBootLocator_stub.Create();
end;

procedure TBootLocator_marshaller._assign(dst, src: Pointer);
begin
  IBootLocator(dst^) := IBootLocator(src^);
end;

function TBootLocator_marshaller.typecode: ITypeCode;
begin
  result := _tc_BootLocator.typecode;
end;

initialization
  NotFound_marshaller := TNotFound_marshaller.Create();
  AlreadyExists_marshaller := TAlreadyExists_marshaller.Create();
  BootManager_marshaller := TBootManager_marshaller.Create();
  BootLocator_marshaller := TBootLocator_marshaller.Create();
  _tc_NotFound := CreateTypeCodeConst('010000001600000044000000010000002500000049444c3a6f6d672e6f72672f426f6f744d616e616765722f4e6f74466f756e643a312e'+
    '3000000000090000004e6f74466f756e640000000000000000');
  _tc_AlreadyExists := CreateTypeCodeConst('01000000160000004c000000010000002a00000049444c3a6f6d672e6f72672f426f6f744d616e616765722f416c726561647945786973'+
    '74733a312e300000000e000000416c726561647945786973747300000000000000');
  _tc_BootManager := CreateTypeCodeConst('010000000e00000034000000010000001c00000049444c3a6f6d672e6f72672f426f6f744d616e616765723a312e30000c000000426f6f'+
    '744d616e6167657200');
  _tc_BootLocator := CreateTypeCodeConst('010000000e00000034000000010000001c00000049444c3a6f6d672e6f72672f426f6f744c6f6361746f723a312e30000c000000426f6f'+
    '744c6f6361746f7200');
end.
