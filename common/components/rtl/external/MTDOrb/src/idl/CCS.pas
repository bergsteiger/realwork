// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -without-prefix -i..\..\idl ..\..\idl\CCS.idl" 
//                                                                            
unit CCS;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, CCS_int, value_int, value, CosTransactions_int,
  CosTransactions, poa_int, poa;

type

  Tlock_mode_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TLockNotHeld_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosConcurrencyControl/LockNotHeld:1.0 } 
  TLockNotHeld = class(UserException,ILockNotHeld)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TLockNotHeld); overload;
    constructor Create(); overload;
  end;

  {** IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0 } 
  TLockCoordinator = class(TORBObject,ILockCoordinator)
  protected
    procedure drop_locks; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ILockCoordinator;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0} 
  TLockCoordinator_stub = class(TLockCoordinator)
  protected
    procedure drop_locks; override;
  end;

  {** POA stub for interface IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0} 
  TLockCoordinator_stub_clp = class(TPOAStub,IPOAStub,ILockCoordinator)
  protected
    procedure drop_locks; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0} 
  TLockCoordinator_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ILockCoordinator)
  protected
    procedure drop_locks; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ILockCoordinator;
    class function _narrow(const srv : IServant): ILockCoordinator;
  end;

  TLockCoordinator_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosConcurrencyControl/LockSet:1.0 } 
  TLockSet = class(TORBObject,ILockSet)
  protected
    procedure lock(const mode: Tlock_mode); virtual; abstract;
    function try_lock(const mode: Tlock_mode): Boolean; virtual; abstract;
    procedure unlock(const mode: Tlock_mode); virtual; abstract;
    procedure change_mode(const held_mode: Tlock_mode; const new_mode: Tlock_mode); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ILockSet;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosConcurrencyControl/LockSet:1.0} 
  TLockSet_stub = class(TLockSet)
  protected
    procedure lock(const mode: Tlock_mode); override;
    function try_lock(const mode: Tlock_mode): Boolean; override;
    procedure unlock(const mode: Tlock_mode); override;
    procedure change_mode(const held_mode: Tlock_mode; const new_mode: Tlock_mode); override;
  end;

  {** POA stub for interface IDL:omg.org/CosConcurrencyControl/LockSet:1.0} 
  TLockSet_stub_clp = class(TPOAStub,IPOAStub,ILockSet)
  protected
    procedure lock(const mode: Tlock_mode); virtual;
    function try_lock(const mode: Tlock_mode): Boolean; virtual;
    procedure unlock(const mode: Tlock_mode); virtual;
    procedure change_mode(const held_mode: Tlock_mode; const new_mode: Tlock_mode); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosConcurrencyControl/LockSet:1.0} 
  TLockSet_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ILockSet)
  protected
    procedure lock(const mode: Tlock_mode); virtual; abstract;
    function try_lock(const mode: Tlock_mode): Boolean; virtual; abstract;
    procedure unlock(const mode: Tlock_mode); virtual; abstract;
    procedure change_mode(const held_mode: Tlock_mode; const new_mode: Tlock_mode); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ILockSet;
    class function _narrow(const srv : IServant): ILockSet;
  end;

  TLockSet_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0 } 
  TTransactionalLockSet = class(TORBObject,ITransactionalLockSet)
  protected
    procedure lock(const current: ICoordinator; const mode: Tlock_mode); virtual; abstract;
    function try_lock(const current: ICoordinator; const mode: Tlock_mode): Boolean; virtual; abstract;
    procedure unlock(const current: ICoordinator; const mode: Tlock_mode); virtual; abstract;
    procedure change_mode(const current: ICoordinator; const held_mode: Tlock_mode; const new_mode: Tlock_mode); virtual; abstract;
    function get_coordinator(const which: ICoordinator): ILockCoordinator; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ITransactionalLockSet;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0} 
  TTransactionalLockSet_stub = class(TTransactionalLockSet)
  protected
    procedure lock(const current: ICoordinator; const mode: Tlock_mode); override;
    function try_lock(const current: ICoordinator; const mode: Tlock_mode): Boolean; override;
    procedure unlock(const current: ICoordinator; const mode: Tlock_mode); override;
    procedure change_mode(const current: ICoordinator; const held_mode: Tlock_mode; const new_mode: Tlock_mode); override;
    function get_coordinator(const which: ICoordinator): ILockCoordinator; override;
  end;

  {** POA stub for interface IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0} 
  TTransactionalLockSet_stub_clp = class(TPOAStub,IPOAStub,ITransactionalLockSet)
  protected
    procedure lock(const current: ICoordinator; const mode: Tlock_mode); virtual;
    function try_lock(const current: ICoordinator; const mode: Tlock_mode): Boolean; virtual;
    procedure unlock(const current: ICoordinator; const mode: Tlock_mode); virtual;
    procedure change_mode(const current: ICoordinator; const held_mode: Tlock_mode; const new_mode: Tlock_mode); virtual;
    function get_coordinator(const which: ICoordinator): ILockCoordinator; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0} 
  TTransactionalLockSet_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ITransactionalLockSet)
  protected
    procedure lock(const current: ICoordinator; const mode: Tlock_mode); virtual; abstract;
    function try_lock(const current: ICoordinator; const mode: Tlock_mode): Boolean; virtual; abstract;
    procedure unlock(const current: ICoordinator; const mode: Tlock_mode); virtual; abstract;
    procedure change_mode(const current: ICoordinator; const held_mode: Tlock_mode; const new_mode: Tlock_mode); virtual; abstract;
    function get_coordinator(const which: ICoordinator): ILockCoordinator; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ITransactionalLockSet;
    class function _narrow(const srv : IServant): ITransactionalLockSet;
  end;

  TTransactionalLockSet_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0 } 
  TLockSetFactory = class(TORBObject,ILockSetFactory)
  protected
    function _create: ILockSet; virtual; abstract;
    function create_related(const which: ILockSet): ILockSet; virtual; abstract;
    function create_transactional: ITransactionalLockSet; virtual; abstract;
    function create_transactional_related(const which: ITransactionalLockSet): ITransactionalLockSet; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ILockSetFactory;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0} 
  TLockSetFactory_stub = class(TLockSetFactory)
  protected
    function _create: ILockSet; override;
    function create_related(const which: ILockSet): ILockSet; override;
    function create_transactional: ITransactionalLockSet; override;
    function create_transactional_related(const which: ITransactionalLockSet): ITransactionalLockSet; override;
  end;

  {** POA stub for interface IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0} 
  TLockSetFactory_stub_clp = class(TPOAStub,IPOAStub,ILockSetFactory)
  protected
    function _create: ILockSet; virtual;
    function create_related(const which: ILockSet): ILockSet; virtual;
    function create_transactional: ITransactionalLockSet; virtual;
    function create_transactional_related(const which: ITransactionalLockSet): ITransactionalLockSet; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0} 
  TLockSetFactory_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ILockSetFactory)
  protected
    function _create: ILockSet; virtual; abstract;
    function create_related(const which: ILockSet): ILockSet; virtual; abstract;
    function create_transactional: ITransactionalLockSet; virtual; abstract;
    function create_transactional_related(const which: ITransactionalLockSet): ITransactionalLockSet; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ILockSetFactory;
    class function _narrow(const srv : IServant): ILockSetFactory;
  end;

  TLockSetFactory_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  lock_mode_marshaller : IStaticTypeInfo;
  LockNotHeld_marshaller : IStaticTypeInfo;
  LockCoordinator_marshaller : IStaticTypeInfo;
  LockSet_marshaller : IStaticTypeInfo;
  TransactionalLockSet_marshaller : IStaticTypeInfo;
  LockSetFactory_marshaller : IStaticTypeInfo;
  _tc_lock_mode : ITypeCodeConst;
  _tc_LockNotHeld : ITypeCodeConst;
  _tc_LockCoordinator : ITypeCodeConst;
  _tc_LockSet : ITypeCodeConst;
  _tc_TransactionalLockSet : ITypeCodeConst;
  _tc_LockSetFactory : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// Tlock_mode_marshaller
//***********************************************************
function Tlock_mode_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure Tlock_mode_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure Tlock_mode_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure Tlock_mode_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure Tlock_mode_marshaller._assign(dst, src: Pointer);
begin
  Tlock_mode(dst^) := Tlock_mode(src^);
end;

function Tlock_mode_marshaller.typecode: ITypeCode;
begin
  result := _tc_lock_mode.typecode;
end;

//***********************************************************
// TLockNotHeld_marshaller
//***********************************************************
function TLockNotHeld_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TLockNotHeld_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosConcurrencyControl/LockNotHeld:1.0');
  enc.except_end;
end;

procedure TLockNotHeld_marshaller._free(var addr: Pointer);
begin
  ILockNotHeld(addr^) := nil;
end;

procedure TLockNotHeld_marshaller._create(var addr: Pointer);
begin
  ILockNotHeld(addr^) := TLockNotHeld.Create();
end;

procedure TLockNotHeld_marshaller._assign(dst, src: Pointer);
begin
  ILockNotHeld(dst^) := ILockNotHeld(src^);
end;

function TLockNotHeld_marshaller.typecode: ITypeCode;
begin
  result := _tc_LockNotHeld.typecode;
end;

//***********************************************************
// TLockNotHeld
//***********************************************************
constructor TLockNotHeld.Create(ex: TLockNotHeld);
begin
  inherited Create();
end;

procedure TLockNotHeld.throw;
begin
  raise TLockNotHeld.Create(self);
end;

function TLockNotHeld.clone(): IORBException;
begin
  result := TLockNotHeld.Create(self);
end;

procedure TLockNotHeld.encode(const enc: IEncoder);
var
  int : ILockNotHeld;
begin
  int := self;
  LockNotHeld_marshaller.marshal(enc,@int);
end;

procedure TLockNotHeld.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(LockNotHeld_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TLockNotHeld.Create();
begin
  inherited Create();
end;

function TLockNotHeld.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosConcurrencyControl/LockNotHeld:1.0';
end;

//***********************************************************
// TLockCoordinator
//***********************************************************
function TLockCoordinator.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0' then
    begin
      result := Pointer(self as ILockCoordinator);
      exit;
    end;
end;

class function TLockCoordinator._narrow(const obj : IORBObject): ILockCoordinator;
var
  p: Pointer;
  stub: TLockCoordinator_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0');
  if p <> nil then
    result := ILockCoordinator(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0') then
        begin
          stub := TLockCoordinator_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TLockCoordinator.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0'
end;

//***********************************************************
// TLockCoordinator_stub
//***********************************************************
procedure TLockCoordinator_stub.drop_locks;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'drop_locks');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TLockCoordinator_stub_clp
//***********************************************************
function TLockCoordinator_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0' then
    begin
      result := Pointer(self as ILockCoordinator);
      exit;
  end;
end;

procedure TLockCoordinator_stub_clp.drop_locks;
var
  _srv: IServant;
  srv: ILockCoordinator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockCoordinator_serv._narrow(_srv);
      if srv <> nil then
        srv.drop_locks
    end;
  _postinvoke();
end;

//***********************************************************
// TLockCoordinator_serv
//***********************************************************
function TLockCoordinator_serv._this(): ILockCoordinator;
var
  obj: IORBObject;
begin
  obj := this();
  result := TLockCoordinator._narrow(obj);
end;

function TLockCoordinator_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0';
end;

function TLockCoordinator_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0';
end;

function TLockCoordinator_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TLockCoordinator_stub_clp.Create(poa,obj);
end;

procedure TLockCoordinator_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TLockCoordinator_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0' then
    begin
      result := Pointer(ILockCoordinator(self));
      exit;
    end;
end;

class function TLockCoordinator_serv._narrow(const srv : IServant): ILockCoordinator;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosConcurrencyControl/LockCoordinator:1.0');
  if p <> nil then
    result := ILockCoordinator(p)
end;

function TLockCoordinator_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if req.op_name = 'drop_locks' then
    begin
      if not req.read_args() then  exit;
      drop_locks;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TLockCoordinator_marshaller
//***********************************************************
function TLockCoordinator_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ILockCoordinator(addr^) := TLockCoordinator._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TLockCoordinator_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ILockCoordinator(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TLockCoordinator_marshaller._free(var addr: Pointer);
begin
  ILockCoordinator(addr^) := nil;
end;

procedure TLockCoordinator_marshaller._create(var addr: Pointer);
begin
  ILockCoordinator(addr^) := TLockCoordinator_stub.Create();
end;

procedure TLockCoordinator_marshaller._assign(dst, src: Pointer);
begin
  ILockCoordinator(dst^) := ILockCoordinator(src^);
end;

function TLockCoordinator_marshaller.typecode: ITypeCode;
begin
  result := _tc_LockCoordinator.typecode;
end;

//***********************************************************
// TLockSet
//***********************************************************
function TLockSet.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockSet:1.0' then
    begin
      result := Pointer(self as ILockSet);
      exit;
    end;
end;

class function TLockSet._narrow(const obj : IORBObject): ILockSet;
var
  p: Pointer;
  stub: TLockSet_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosConcurrencyControl/LockSet:1.0');
  if p <> nil then
    result := ILockSet(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosConcurrencyControl/LockSet:1.0') then
        begin
          stub := TLockSet_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TLockSet.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosConcurrencyControl/LockSet:1.0'
end;

//***********************************************************
// TLockSet_stub
//***********************************************************
procedure TLockSet_stub.lock(const mode: Tlock_mode);
var
  req: IStaticRequest;
  _mode: IStaticAny;
begin
  _mode := StaticAny(lock_mode_marshaller,@mode);
  req := StaticRequest(self,'lock');
  req.add_in_arg(_mode);
  req.invoke;
  dorb_static_throw(req);
end;

function TLockSet_stub.try_lock(const mode: Tlock_mode): Boolean;
var
  req: IStaticRequest;
  _mode: IStaticAny;
  _result: IStaticAny;
begin
  _mode := StaticAny(lock_mode_marshaller,@mode);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'try_lock');
  req.add_in_arg(_mode);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLockSet_stub.unlock(const mode: Tlock_mode);
var
  req: IStaticRequest;
  _mode: IStaticAny;
begin
  _mode := StaticAny(lock_mode_marshaller,@mode);
  req := StaticRequest(self,'unlock');
  req.add_in_arg(_mode);
  req.set_exceptions_tc([_tc_LockNotHeld.typecode]);
  req.invoke;
  dorb_static_throw(req,[LockNotHeld_marshaller, 'IDL:omg.org/CosConcurrencyControl/LockNotHeld:1.0']);
end;

procedure TLockSet_stub.change_mode(const held_mode: Tlock_mode; const new_mode: Tlock_mode);
var
  req: IStaticRequest;
  _held_mode: IStaticAny;
  _new_mode: IStaticAny;
begin
  _held_mode := StaticAny(lock_mode_marshaller,@held_mode);
  _new_mode := StaticAny(lock_mode_marshaller,@new_mode);
  req := StaticRequest(self,'change_mode');
  req.add_in_arg(_held_mode);
  req.add_in_arg(_new_mode);
  req.set_exceptions_tc([_tc_LockNotHeld.typecode]);
  req.invoke;
  dorb_static_throw(req,[LockNotHeld_marshaller, 'IDL:omg.org/CosConcurrencyControl/LockNotHeld:1.0']);
end;

//***********************************************************
// TLockSet_stub_clp
//***********************************************************
function TLockSet_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockSet:1.0' then
    begin
      result := Pointer(self as ILockSet);
      exit;
  end;
end;

procedure TLockSet_stub_clp.lock(const mode: Tlock_mode);
var
  _srv: IServant;
  srv: ILockSet;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockSet_serv._narrow(_srv);
      if srv <> nil then
        srv.lock(mode)
    end;
  _postinvoke();
end;

function TLockSet_stub_clp.try_lock(const mode: Tlock_mode): Boolean;
var
  _srv: IServant;
  srv: ILockSet;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockSet_serv._narrow(_srv);
      if srv <> nil then
        result := srv.try_lock(mode)
    end;
  _postinvoke();
end;

procedure TLockSet_stub_clp.unlock(const mode: Tlock_mode);
var
  _srv: IServant;
  srv: ILockSet;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockSet_serv._narrow(_srv);
      if srv <> nil then
        srv.unlock(mode)
    end;
  _postinvoke();
end;

procedure TLockSet_stub_clp.change_mode(const held_mode: Tlock_mode; const new_mode: Tlock_mode);
var
  _srv: IServant;
  srv: ILockSet;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockSet_serv._narrow(_srv);
      if srv <> nil then
        srv.change_mode(held_mode, new_mode)
    end;
  _postinvoke();
end;

//***********************************************************
// TLockSet_serv
//***********************************************************
function TLockSet_serv._this(): ILockSet;
var
  obj: IORBObject;
begin
  obj := this();
  result := TLockSet._narrow(obj);
end;

function TLockSet_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosConcurrencyControl/LockSet:1.0';
end;

function TLockSet_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosConcurrencyControl/LockSet:1.0';
end;

function TLockSet_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TLockSet_stub_clp.Create(poa,obj);
end;

procedure TLockSet_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TLockSet_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockSet:1.0' then
    begin
      result := Pointer(ILockSet(self));
      exit;
    end;
end;

class function TLockSet_serv._narrow(const srv : IServant): ILockSet;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosConcurrencyControl/LockSet:1.0');
  if p <> nil then
    result := ILockSet(p)
end;

function TLockSet_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  lock_mode: Tlock_mode;
  try_lock_result: Boolean;
  try_lock_mode: Tlock_mode;
  unlock_mode: Tlock_mode;
  change_mode_held_mode: Tlock_mode;
  change_mode_new_mode: Tlock_mode;
begin
  result := true;
  if req.op_name = 'lock' then
    begin
      req.add_in_arg(StaticAny(lock_mode_marshaller,@lock_mode) as IStaticAny);
      if not req.read_args() then  exit;
      lock(lock_mode);
      req.write_results();
      exit;
    end
  else if req.op_name = 'try_lock' then
    begin
      req.add_in_arg(StaticAny(lock_mode_marshaller,@try_lock_mode) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@try_lock_result) as IStaticAny);
      if not req.read_args() then  exit;
      try_lock_result := try_lock(try_lock_mode);
      req.write_results();
      exit;
    end
  else if req.op_name = 'unlock' then
    begin
      req.add_in_arg(StaticAny(lock_mode_marshaller,@unlock_mode) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_LockNotHeld.typecode]);
      try
        unlock(unlock_mode);
      except
        on LockNotHeld: TLockNotHeld do
          req.set_exception(TLockNotHeld.Create(LockNotHeld) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'change_mode' then
    begin
      req.add_in_arg(StaticAny(lock_mode_marshaller,@change_mode_held_mode) as IStaticAny);
      req.add_in_arg(StaticAny(lock_mode_marshaller,@change_mode_new_mode) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_LockNotHeld.typecode]);
      try
        change_mode(change_mode_held_mode, change_mode_new_mode);
      except
        on LockNotHeld: TLockNotHeld do
          req.set_exception(TLockNotHeld.Create(LockNotHeld) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TLockSet_marshaller
//***********************************************************
function TLockSet_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ILockSet(addr^) := TLockSet._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TLockSet_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ILockSet(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TLockSet_marshaller._free(var addr: Pointer);
begin
  ILockSet(addr^) := nil;
end;

procedure TLockSet_marshaller._create(var addr: Pointer);
begin
  ILockSet(addr^) := TLockSet_stub.Create();
end;

procedure TLockSet_marshaller._assign(dst, src: Pointer);
begin
  ILockSet(dst^) := ILockSet(src^);
end;

function TLockSet_marshaller.typecode: ITypeCode;
begin
  result := _tc_LockSet.typecode;
end;

//***********************************************************
// TTransactionalLockSet
//***********************************************************
function TTransactionalLockSet.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0' then
    begin
      result := Pointer(self as ITransactionalLockSet);
      exit;
    end;
end;

class function TTransactionalLockSet._narrow(const obj : IORBObject): ITransactionalLockSet;
var
  p: Pointer;
  stub: TTransactionalLockSet_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0');
  if p <> nil then
    result := ITransactionalLockSet(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0') then
        begin
          stub := TTransactionalLockSet_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TTransactionalLockSet.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0'
end;

//***********************************************************
// TTransactionalLockSet_stub
//***********************************************************
procedure TTransactionalLockSet_stub.lock(const current: ICoordinator; const mode: Tlock_mode);
var
  req: IStaticRequest;
  _current: IStaticAny;
  _mode: IStaticAny;
begin
  _current := StaticAny(Coordinator_marshaller,@current);
  _mode := StaticAny(lock_mode_marshaller,@mode);
  req := StaticRequest(self,'lock');
  req.add_in_arg(_current);
  req.add_in_arg(_mode);
  req.invoke;
  dorb_static_throw(req);
end;

function TTransactionalLockSet_stub.try_lock(const current: ICoordinator; const mode: Tlock_mode): Boolean;
var
  req: IStaticRequest;
  _current: IStaticAny;
  _mode: IStaticAny;
  _result: IStaticAny;
begin
  _current := StaticAny(Coordinator_marshaller,@current);
  _mode := StaticAny(lock_mode_marshaller,@mode);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'try_lock');
  req.add_in_arg(_current);
  req.add_in_arg(_mode);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TTransactionalLockSet_stub.unlock(const current: ICoordinator; const mode: Tlock_mode);
var
  req: IStaticRequest;
  _current: IStaticAny;
  _mode: IStaticAny;
begin
  _current := StaticAny(Coordinator_marshaller,@current);
  _mode := StaticAny(lock_mode_marshaller,@mode);
  req := StaticRequest(self,'unlock');
  req.add_in_arg(_current);
  req.add_in_arg(_mode);
  req.set_exceptions_tc([_tc_LockNotHeld.typecode]);
  req.invoke;
  dorb_static_throw(req,[LockNotHeld_marshaller, 'IDL:omg.org/CosConcurrencyControl/LockNotHeld:1.0']);
end;

procedure TTransactionalLockSet_stub.change_mode(const current: ICoordinator; const held_mode: Tlock_mode; const new_mode: Tlock_mode);
var
  req: IStaticRequest;
  _current: IStaticAny;
  _held_mode: IStaticAny;
  _new_mode: IStaticAny;
begin
  _current := StaticAny(Coordinator_marshaller,@current);
  _held_mode := StaticAny(lock_mode_marshaller,@held_mode);
  _new_mode := StaticAny(lock_mode_marshaller,@new_mode);
  req := StaticRequest(self,'change_mode');
  req.add_in_arg(_current);
  req.add_in_arg(_held_mode);
  req.add_in_arg(_new_mode);
  req.set_exceptions_tc([_tc_LockNotHeld.typecode]);
  req.invoke;
  dorb_static_throw(req,[LockNotHeld_marshaller, 'IDL:omg.org/CosConcurrencyControl/LockNotHeld:1.0']);
end;

function TTransactionalLockSet_stub.get_coordinator(const which: ICoordinator): ILockCoordinator;
var
  req: IStaticRequest;
  _which: IStaticAny;
  _result: IStaticAny;
begin
  _which := StaticAny(Coordinator_marshaller,@which);
  _result := StaticAny(LockCoordinator_marshaller, @result);
  req := StaticRequest(self,'get_coordinator');
  req.add_in_arg(_which);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TTransactionalLockSet_stub_clp
//***********************************************************
function TTransactionalLockSet_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0' then
    begin
      result := Pointer(self as ITransactionalLockSet);
      exit;
  end;
end;

procedure TTransactionalLockSet_stub_clp.lock(const current: ICoordinator; const mode: Tlock_mode);
var
  _srv: IServant;
  srv: ITransactionalLockSet;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTransactionalLockSet_serv._narrow(_srv);
      if srv <> nil then
        srv.lock(current, mode)
    end;
  _postinvoke();
end;

function TTransactionalLockSet_stub_clp.try_lock(const current: ICoordinator; const mode: Tlock_mode): Boolean;
var
  _srv: IServant;
  srv: ITransactionalLockSet;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTransactionalLockSet_serv._narrow(_srv);
      if srv <> nil then
        result := srv.try_lock(current, mode)
    end;
  _postinvoke();
end;

procedure TTransactionalLockSet_stub_clp.unlock(const current: ICoordinator; const mode: Tlock_mode);
var
  _srv: IServant;
  srv: ITransactionalLockSet;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTransactionalLockSet_serv._narrow(_srv);
      if srv <> nil then
        srv.unlock(current, mode)
    end;
  _postinvoke();
end;

procedure TTransactionalLockSet_stub_clp.change_mode(const current: ICoordinator; const held_mode: Tlock_mode; const new_mode: Tlock_mode);
var
  _srv: IServant;
  srv: ITransactionalLockSet;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTransactionalLockSet_serv._narrow(_srv);
      if srv <> nil then
        srv.change_mode(current, held_mode, new_mode)
    end;
  _postinvoke();
end;

function TTransactionalLockSet_stub_clp.get_coordinator(const which: ICoordinator): ILockCoordinator;
var
  _srv: IServant;
  srv: ITransactionalLockSet;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTransactionalLockSet_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_coordinator(which)
    end;
  _postinvoke();
end;

//***********************************************************
// TTransactionalLockSet_serv
//***********************************************************
function TTransactionalLockSet_serv._this(): ITransactionalLockSet;
var
  obj: IORBObject;
begin
  obj := this();
  result := TTransactionalLockSet._narrow(obj);
end;

function TTransactionalLockSet_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0';
end;

function TTransactionalLockSet_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0';
end;

function TTransactionalLockSet_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TTransactionalLockSet_stub_clp.Create(poa,obj);
end;

procedure TTransactionalLockSet_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TTransactionalLockSet_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0' then
    begin
      result := Pointer(ITransactionalLockSet(self));
      exit;
    end;
end;

class function TTransactionalLockSet_serv._narrow(const srv : IServant): ITransactionalLockSet;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosConcurrencyControl/TransactionalLockSet:1.0');
  if p <> nil then
    result := ITransactionalLockSet(p)
end;

function TTransactionalLockSet_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  lock_current: ICoordinator;
  lock_mode: Tlock_mode;
  try_lock_result: Boolean;
  try_lock_current: ICoordinator;
  try_lock_mode: Tlock_mode;
  unlock_current: ICoordinator;
  unlock_mode: Tlock_mode;
  change_mode_current: ICoordinator;
  change_mode_held_mode: Tlock_mode;
  change_mode_new_mode: Tlock_mode;
  get_coordinator_result: ILockCoordinator;
  get_coordinator_which: ICoordinator;
begin
  result := true;
  if req.op_name = 'lock' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@lock_current) as IStaticAny);
      req.add_in_arg(StaticAny(lock_mode_marshaller,@lock_mode) as IStaticAny);
      if not req.read_args() then  exit;
      lock(lock_current, lock_mode);
      req.write_results();
      exit;
    end
  else if req.op_name = 'try_lock' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@try_lock_current) as IStaticAny);
      req.add_in_arg(StaticAny(lock_mode_marshaller,@try_lock_mode) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@try_lock_result) as IStaticAny);
      if not req.read_args() then  exit;
      try_lock_result := try_lock(try_lock_current, try_lock_mode);
      req.write_results();
      exit;
    end
  else if req.op_name = 'unlock' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@unlock_current) as IStaticAny);
      req.add_in_arg(StaticAny(lock_mode_marshaller,@unlock_mode) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_LockNotHeld.typecode]);
      try
        unlock(unlock_current, unlock_mode);
      except
        on LockNotHeld: TLockNotHeld do
          req.set_exception(TLockNotHeld.Create(LockNotHeld) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'change_mode' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@change_mode_current) as IStaticAny);
      req.add_in_arg(StaticAny(lock_mode_marshaller,@change_mode_held_mode) as IStaticAny);
      req.add_in_arg(StaticAny(lock_mode_marshaller,@change_mode_new_mode) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_LockNotHeld.typecode]);
      try
        change_mode(change_mode_current, change_mode_held_mode, change_mode_new_mode);
      except
        on LockNotHeld: TLockNotHeld do
          req.set_exception(TLockNotHeld.Create(LockNotHeld) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_coordinator' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@get_coordinator_which) as IStaticAny);
      req.set_result(StaticAny(LockCoordinator_marshaller,@get_coordinator_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_coordinator_result := get_coordinator(get_coordinator_which);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TTransactionalLockSet_marshaller
//***********************************************************
function TTransactionalLockSet_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ITransactionalLockSet(addr^) := TTransactionalLockSet._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TTransactionalLockSet_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ITransactionalLockSet(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TTransactionalLockSet_marshaller._free(var addr: Pointer);
begin
  ITransactionalLockSet(addr^) := nil;
end;

procedure TTransactionalLockSet_marshaller._create(var addr: Pointer);
begin
  ITransactionalLockSet(addr^) := TTransactionalLockSet_stub.Create();
end;

procedure TTransactionalLockSet_marshaller._assign(dst, src: Pointer);
begin
  ITransactionalLockSet(dst^) := ITransactionalLockSet(src^);
end;

function TTransactionalLockSet_marshaller.typecode: ITypeCode;
begin
  result := _tc_TransactionalLockSet.typecode;
end;

//***********************************************************
// TLockSetFactory
//***********************************************************
function TLockSetFactory.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0' then
    begin
      result := Pointer(self as ILockSetFactory);
      exit;
    end;
end;

class function TLockSetFactory._narrow(const obj : IORBObject): ILockSetFactory;
var
  p: Pointer;
  stub: TLockSetFactory_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0');
  if p <> nil then
    result := ILockSetFactory(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0') then
        begin
          stub := TLockSetFactory_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TLockSetFactory.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0'
end;

//***********************************************************
// TLockSetFactory_stub
//***********************************************************
function TLockSetFactory_stub._create: ILockSet;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(LockSet_marshaller, @result);
  req := StaticRequest(self,'create');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLockSetFactory_stub.create_related(const which: ILockSet): ILockSet;
var
  req: IStaticRequest;
  _which: IStaticAny;
  _result: IStaticAny;
begin
  _which := StaticAny(LockSet_marshaller,@which);
  _result := StaticAny(LockSet_marshaller, @result);
  req := StaticRequest(self,'create_related');
  req.add_in_arg(_which);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLockSetFactory_stub.create_transactional: ITransactionalLockSet;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(TransactionalLockSet_marshaller, @result);
  req := StaticRequest(self,'create_transactional');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLockSetFactory_stub.create_transactional_related(const which: ITransactionalLockSet): ITransactionalLockSet;
var
  req: IStaticRequest;
  _which: IStaticAny;
  _result: IStaticAny;
begin
  _which := StaticAny(TransactionalLockSet_marshaller,@which);
  _result := StaticAny(TransactionalLockSet_marshaller, @result);
  req := StaticRequest(self,'create_transactional_related');
  req.add_in_arg(_which);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TLockSetFactory_stub_clp
//***********************************************************
function TLockSetFactory_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0' then
    begin
      result := Pointer(self as ILockSetFactory);
      exit;
  end;
end;

function TLockSetFactory_stub_clp._create: ILockSet;
var
  _srv: IServant;
  srv: ILockSetFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockSetFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv._create
    end;
  _postinvoke();
end;

function TLockSetFactory_stub_clp.create_related(const which: ILockSet): ILockSet;
var
  _srv: IServant;
  srv: ILockSetFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockSetFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_related(which)
    end;
  _postinvoke();
end;

function TLockSetFactory_stub_clp.create_transactional: ITransactionalLockSet;
var
  _srv: IServant;
  srv: ILockSetFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockSetFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_transactional
    end;
  _postinvoke();
end;

function TLockSetFactory_stub_clp.create_transactional_related(const which: ITransactionalLockSet): ITransactionalLockSet;
var
  _srv: IServant;
  srv: ILockSetFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TLockSetFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_transactional_related(which)
    end;
  _postinvoke();
end;

//***********************************************************
// TLockSetFactory_serv
//***********************************************************
function TLockSetFactory_serv._this(): ILockSetFactory;
var
  obj: IORBObject;
begin
  obj := this();
  result := TLockSetFactory._narrow(obj);
end;

function TLockSetFactory_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0';
end;

function TLockSetFactory_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0';
end;

function TLockSetFactory_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TLockSetFactory_stub_clp.Create(poa,obj);
end;

procedure TLockSetFactory_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TLockSetFactory_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0' then
    begin
      result := Pointer(ILockSetFactory(self));
      exit;
    end;
end;

class function TLockSetFactory_serv._narrow(const srv : IServant): ILockSetFactory;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosConcurrencyControl/LockSetFactory:1.0');
  if p <> nil then
    result := ILockSetFactory(p)
end;

function TLockSetFactory_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  _create_result: ILockSet;
  create_related_result: ILockSet;
  create_related_which: ILockSet;
  create_transactional_result: ITransactionalLockSet;
  create_transactional_related_result: ITransactionalLockSet;
  create_transactional_related_which: ITransactionalLockSet;
begin
  result := true;
  if req.op_name = 'create' then
    begin
      req.set_result(StaticAny(LockSet_marshaller,@_create_result) as IStaticAny);
      if not req.read_args() then  exit;
      _create_result := _create;
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_related' then
    begin
      req.add_in_arg(StaticAny(LockSet_marshaller,@create_related_which) as IStaticAny);
      req.set_result(StaticAny(LockSet_marshaller,@create_related_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_related_result := create_related(create_related_which);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_transactional' then
    begin
      req.set_result(StaticAny(TransactionalLockSet_marshaller,@create_transactional_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_transactional_result := create_transactional;
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_transactional_related' then
    begin
      req.add_in_arg(StaticAny(TransactionalLockSet_marshaller,@create_transactional_related_which) as IStaticAny);
      req.set_result(StaticAny(TransactionalLockSet_marshaller,@create_transactional_related_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_transactional_related_result := create_transactional_related(create_transactional_related_which);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TLockSetFactory_marshaller
//***********************************************************
function TLockSetFactory_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ILockSetFactory(addr^) := TLockSetFactory._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TLockSetFactory_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ILockSetFactory(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TLockSetFactory_marshaller._free(var addr: Pointer);
begin
  ILockSetFactory(addr^) := nil;
end;

procedure TLockSetFactory_marshaller._create(var addr: Pointer);
begin
  ILockSetFactory(addr^) := TLockSetFactory_stub.Create();
end;

procedure TLockSetFactory_marshaller._assign(dst, src: Pointer);
begin
  ILockSetFactory(dst^) := ILockSetFactory(src^);
end;

function TLockSetFactory_marshaller.typecode: ITypeCode;
begin
  result := _tc_LockSetFactory.typecode;
end;

initialization
  lock_mode_marshaller := Tlock_mode_marshaller.Create();
  LockNotHeld_marshaller := TLockNotHeld_marshaller.Create();
  LockCoordinator_marshaller := TLockCoordinator_marshaller.Create();
  LockSet_marshaller := TLockSet_marshaller.Create();
  TransactionalLockSet_marshaller := TTransactionalLockSet_marshaller.Create();
  LockSetFactory_marshaller := TLockSetFactory_marshaller.Create();
  _tc_lock_mode := CreateTypeCodeConst('010000001100000098000000010000003000000049444c3a6f6d672e6f72672f436f73436f6e63757272656e6379436f6e74726f6c2f6c'+
    '6f636b5f6d6f64653a312e30000a0000006c6f636b5f6d6f64650000000500000005000000726561640000000006000000777269746500'+
    '00000800000075706772616465000f000000696e74656e74696f6e5f72656164000010000000696e74656e74696f6e5f777269746500');
  _tc_LockNotHeld := CreateTypeCodeConst('010000001600000050000000010000003200000049444c3a6f6d672e6f72672f436f73436f6e63757272656e6379436f6e74726f6c2f4c'+
    '6f636b4e6f7448656c643a312e300000000c0000004c6f636b4e6f7448656c640000000000');
  _tc_LockCoordinator := CreateTypeCodeConst('010000000e00000054000000010000003600000049444c3a6f6d672e6f72672f436f73436f6e63757272656e6379436f6e74726f6c2f4c'+
    '6f636b436f6f7264696e61746f723a312e30000000100000004c6f636b436f6f7264696e61746f7200');
  _tc_LockSet := CreateTypeCodeConst('010000000e00000044000000010000002e00000049444c3a6f6d672e6f72672f436f73436f6e63757272656e6379436f6e74726f6c2f4c'+
    '6f636b5365743a312e30000000080000004c6f636b53657400');
  _tc_TransactionalLockSet := CreateTypeCodeConst('010000000e0000005d000000010000003b00000049444c3a6f6d672e6f72672f436f73436f6e63757272656e6379436f6e74726f6c2f54'+
    '72616e73616374696f6e616c4c6f636b5365743a312e300000150000005472616e73616374696f6e616c4c6f636b53657400');
  _tc_LockSetFactory := CreateTypeCodeConst('010000000e00000053000000010000003500000049444c3a6f6d672e6f72672f436f73436f6e63757272656e6379436f6e74726f6c2f4c'+
    '6f636b536574466163746f72793a312e30000000000f0000004c6f636b536574466163746f727900');
end.
