// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -without-prefix -i..\..\idl ..\..\idl\CosEventChannelAdmin.idl" 
//                                                                            
unit CosEventChannelAdmin;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, CosEventChannelAdmin_int, CosEventComm_int, CosEventComm,
  poa_int, poa;

type

  TAlreadyConnected_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/AlreadyConnected:1.0 } 
  TAlreadyConnected = class(UserException,IAlreadyConnected)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TAlreadyConnected); overload;
    constructor Create(); overload;
  end;

  TTypeError_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/TypeError:1.0 } 
  TTypeError = class(UserException,ITypeError)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TTypeError); overload;
    constructor Create(); overload;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0 } 
  TProxyPushConsumer = class(TPushConsumer,IProxyPushConsumer)
  protected
    procedure connect_push_supplier(const push_supplier: IPushSupplier); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IProxyPushConsumer;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0} 
  TProxyPushConsumer_stub = class(TProxyPushConsumer)
  protected
    procedure push(const data: IAny); override;
    procedure disconnect_push_consumer; override;
    procedure connect_push_supplier(const push_supplier: IPushSupplier); override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0} 
  TProxyPushConsumer_stub_clp = class(TPushConsumer_stub_clp,IProxyPushConsumer)
  protected
    procedure connect_push_supplier(const push_supplier: IPushSupplier); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0} 
  TProxyPushConsumer_serv = class(TPushConsumer_serv,IProxyPushConsumer)
  protected
    procedure connect_push_supplier(const push_supplier: IPushSupplier); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IProxyPushConsumer;
    class function _narrow(const srv : IServant): IProxyPushConsumer;
  end;

  TProxyPushConsumer_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0 } 
  TProxyPullSupplier = class(TPullSupplier,IProxyPullSupplier)
  protected
    procedure connect_pull_consumer(const pull_consumer: IPullConsumer); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IProxyPullSupplier;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0} 
  TProxyPullSupplier_stub = class(TProxyPullSupplier)
  protected
    function pull: IAny; override;
    function try_pull(out has_event: Boolean): IAny; override;
    procedure disconnect_pull_supplier; override;
    procedure connect_pull_consumer(const pull_consumer: IPullConsumer); override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0} 
  TProxyPullSupplier_stub_clp = class(TPullSupplier_stub_clp,IProxyPullSupplier)
  protected
    procedure connect_pull_consumer(const pull_consumer: IPullConsumer); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0} 
  TProxyPullSupplier_serv = class(TPullSupplier_serv,IProxyPullSupplier)
  protected
    procedure connect_pull_consumer(const pull_consumer: IPullConsumer); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IProxyPullSupplier;
    class function _narrow(const srv : IServant): IProxyPullSupplier;
  end;

  TProxyPullSupplier_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0 } 
  TProxyPullConsumer = class(TPullConsumer,IProxyPullConsumer)
  protected
    procedure connect_pull_supplier(const pull_supplier: IPullSupplier); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IProxyPullConsumer;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0} 
  TProxyPullConsumer_stub = class(TProxyPullConsumer)
  protected
    procedure disconnect_pull_consumer; override;
    procedure connect_pull_supplier(const pull_supplier: IPullSupplier); override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0} 
  TProxyPullConsumer_stub_clp = class(TPullConsumer_stub_clp,IProxyPullConsumer)
  protected
    procedure connect_pull_supplier(const pull_supplier: IPullSupplier); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0} 
  TProxyPullConsumer_serv = class(TPullConsumer_serv,IProxyPullConsumer)
  protected
    procedure connect_pull_supplier(const pull_supplier: IPullSupplier); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IProxyPullConsumer;
    class function _narrow(const srv : IServant): IProxyPullConsumer;
  end;

  TProxyPullConsumer_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0 } 
  TProxyPushSupplier = class(TPushSupplier,IProxyPushSupplier)
  protected
    procedure connect_push_consumer(const push_consumer: IPushConsumer); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IProxyPushSupplier;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0} 
  TProxyPushSupplier_stub = class(TProxyPushSupplier)
  protected
    procedure disconnect_push_supplier; override;
    procedure connect_push_consumer(const push_consumer: IPushConsumer); override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0} 
  TProxyPushSupplier_stub_clp = class(TPushSupplier_stub_clp,IProxyPushSupplier)
  protected
    procedure connect_push_consumer(const push_consumer: IPushConsumer); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0} 
  TProxyPushSupplier_serv = class(TPushSupplier_serv,IProxyPushSupplier)
  protected
    procedure connect_push_consumer(const push_consumer: IPushConsumer); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IProxyPushSupplier;
    class function _narrow(const srv : IServant): IProxyPushSupplier;
  end;

  TProxyPushSupplier_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0 } 
  TConsumerAdmin = class(TORBObject,IConsumerAdmin)
  protected
    function obtain_push_supplier: IProxyPushSupplier; virtual; abstract;
    function obtain_pull_supplier: IProxyPullSupplier; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IConsumerAdmin;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0} 
  TConsumerAdmin_stub = class(TConsumerAdmin)
  protected
    function obtain_push_supplier: IProxyPushSupplier; override;
    function obtain_pull_supplier: IProxyPullSupplier; override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0} 
  TConsumerAdmin_stub_clp = class(TPOAStub,IPOAStub,IConsumerAdmin)
  protected
    function obtain_push_supplier: IProxyPushSupplier; virtual;
    function obtain_pull_supplier: IProxyPullSupplier; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0} 
  TConsumerAdmin_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IConsumerAdmin)
  protected
    function obtain_push_supplier: IProxyPushSupplier; virtual; abstract;
    function obtain_pull_supplier: IProxyPullSupplier; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IConsumerAdmin;
    class function _narrow(const srv : IServant): IConsumerAdmin;
  end;

  TConsumerAdmin_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0 } 
  TSupplierAdmin = class(TORBObject,ISupplierAdmin)
  protected
    function obtain_push_consumer: IProxyPushConsumer; virtual; abstract;
    function obtain_pull_consumer: IProxyPullConsumer; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ISupplierAdmin;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0} 
  TSupplierAdmin_stub = class(TSupplierAdmin)
  protected
    function obtain_push_consumer: IProxyPushConsumer; override;
    function obtain_pull_consumer: IProxyPullConsumer; override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0} 
  TSupplierAdmin_stub_clp = class(TPOAStub,IPOAStub,ISupplierAdmin)
  protected
    function obtain_push_consumer: IProxyPushConsumer; virtual;
    function obtain_pull_consumer: IProxyPullConsumer; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0} 
  TSupplierAdmin_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ISupplierAdmin)
  protected
    function obtain_push_consumer: IProxyPushConsumer; virtual; abstract;
    function obtain_pull_consumer: IProxyPullConsumer; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ISupplierAdmin;
    class function _narrow(const srv : IServant): ISupplierAdmin;
  end;

  TSupplierAdmin_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0 } 
  TEventChannel = class(TORBObject,IEventChannel)
  protected
    function for_consumers: IConsumerAdmin; virtual; abstract;
    function for_suppliers: ISupplierAdmin; virtual; abstract;
    procedure _destroy; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IEventChannel;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0} 
  TEventChannel_stub = class(TEventChannel)
  protected
    function for_consumers: IConsumerAdmin; override;
    function for_suppliers: ISupplierAdmin; override;
    procedure _destroy; override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0} 
  TEventChannel_stub_clp = class(TPOAStub,IPOAStub,IEventChannel)
  protected
    function for_consumers: IConsumerAdmin; virtual;
    function for_suppliers: ISupplierAdmin; virtual;
    procedure _destroy; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0} 
  TEventChannel_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IEventChannel)
  protected
    function for_consumers: IConsumerAdmin; virtual; abstract;
    function for_suppliers: ISupplierAdmin; virtual; abstract;
    procedure _destroy; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IEventChannel;
    class function _narrow(const srv : IServant): IEventChannel;
  end;

  TEventChannel_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0 } 
  TEventChannelFactory = class(TORBObject,IEventChannelFactory)
  protected
    function create_eventchannel: IEventChannel; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IEventChannelFactory;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0} 
  TEventChannelFactory_stub = class(TEventChannelFactory)
  protected
    function create_eventchannel: IEventChannel; override;
  end;

  {** POA stub for interface IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0} 
  TEventChannelFactory_stub_clp = class(TPOAStub,IPOAStub,IEventChannelFactory)
  protected
    function create_eventchannel: IEventChannel; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0} 
  TEventChannelFactory_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IEventChannelFactory)
  protected
    function create_eventchannel: IEventChannel; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IEventChannelFactory;
    class function _narrow(const srv : IServant): IEventChannelFactory;
  end;

  TEventChannelFactory_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  AlreadyConnected_marshaller : IStaticTypeInfo;
  TypeError_marshaller : IStaticTypeInfo;
  ProxyPushConsumer_marshaller : IStaticTypeInfo;
  ProxyPullSupplier_marshaller : IStaticTypeInfo;
  ProxyPullConsumer_marshaller : IStaticTypeInfo;
  ProxyPushSupplier_marshaller : IStaticTypeInfo;
  ConsumerAdmin_marshaller : IStaticTypeInfo;
  SupplierAdmin_marshaller : IStaticTypeInfo;
  EventChannel_marshaller : IStaticTypeInfo;
  EventChannelFactory_marshaller : IStaticTypeInfo;
  _tc_AlreadyConnected : ITypeCodeConst;
  _tc_TypeError : ITypeCodeConst;
  _tc_ProxyPushConsumer : ITypeCodeConst;
  _tc_ProxyPullSupplier : ITypeCodeConst;
  _tc_ProxyPullConsumer : ITypeCodeConst;
  _tc_ProxyPushSupplier : ITypeCodeConst;
  _tc_ConsumerAdmin : ITypeCodeConst;
  _tc_SupplierAdmin : ITypeCodeConst;
  _tc_EventChannel : ITypeCodeConst;
  _tc_EventChannelFactory : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TAlreadyConnected_marshaller
//***********************************************************
function TAlreadyConnected_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TAlreadyConnected_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosEventChannelAdmin/AlreadyConnected:1.0');
  enc.except_end;
end;

procedure TAlreadyConnected_marshaller._free(var addr: Pointer);
begin
  IAlreadyConnected(addr^) := nil;
end;

procedure TAlreadyConnected_marshaller._create(var addr: Pointer);
begin
  IAlreadyConnected(addr^) := TAlreadyConnected.Create();
end;

procedure TAlreadyConnected_marshaller._assign(dst, src: Pointer);
begin
  IAlreadyConnected(dst^) := IAlreadyConnected(src^);
end;

function TAlreadyConnected_marshaller.typecode: ITypeCode;
begin
  result := _tc_AlreadyConnected.typecode;
end;

//***********************************************************
// TAlreadyConnected
//***********************************************************
constructor TAlreadyConnected.Create(ex: TAlreadyConnected);
begin
  inherited Create();
end;

procedure TAlreadyConnected.throw;
begin
  raise TAlreadyConnected.Create(self);
end;

function TAlreadyConnected.clone(): IORBException;
begin
  result := TAlreadyConnected.Create(self);
end;

procedure TAlreadyConnected.encode(const enc: IEncoder);
var
  int : IAlreadyConnected;
begin
  int := self;
  AlreadyConnected_marshaller.marshal(enc,@int);
end;

procedure TAlreadyConnected.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(AlreadyConnected_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TAlreadyConnected.Create();
begin
  inherited Create();
end;

function TAlreadyConnected.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/AlreadyConnected:1.0';
end;

//***********************************************************
// TTypeError_marshaller
//***********************************************************
function TTypeError_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TTypeError_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosEventChannelAdmin/TypeError:1.0');
  enc.except_end;
end;

procedure TTypeError_marshaller._free(var addr: Pointer);
begin
  ITypeError(addr^) := nil;
end;

procedure TTypeError_marshaller._create(var addr: Pointer);
begin
  ITypeError(addr^) := TTypeError.Create();
end;

procedure TTypeError_marshaller._assign(dst, src: Pointer);
begin
  ITypeError(dst^) := ITypeError(src^);
end;

function TTypeError_marshaller.typecode: ITypeCode;
begin
  result := _tc_TypeError.typecode;
end;

//***********************************************************
// TTypeError
//***********************************************************
constructor TTypeError.Create(ex: TTypeError);
begin
  inherited Create();
end;

procedure TTypeError.throw;
begin
  raise TTypeError.Create(self);
end;

function TTypeError.clone(): IORBException;
begin
  result := TTypeError.Create(self);
end;

procedure TTypeError.encode(const enc: IEncoder);
var
  int : ITypeError;
begin
  int := self;
  TypeError_marshaller.marshal(enc,@int);
end;

procedure TTypeError.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(TypeError_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TTypeError.Create();
begin
  inherited Create();
end;

function TTypeError.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/TypeError:1.0';
end;

//***********************************************************
// TProxyPushConsumer
//***********************************************************
function TProxyPushConsumer.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0' then
    begin
      result := Pointer(self as IProxyPushConsumer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TProxyPushConsumer._narrow(const obj : IORBObject): IProxyPushConsumer;
var
  p: Pointer;
  stub: TProxyPushConsumer_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0');
  if p <> nil then
    result := IProxyPushConsumer(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0') then
        begin
          stub := TProxyPushConsumer_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TProxyPushConsumer.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0'
end;

//***********************************************************
// TProxyPushConsumer_stub
//***********************************************************
procedure TProxyPushConsumer_stub.push(const data: IAny);
var
  req: IStaticRequest;
  _data: IStaticAny;
begin
  _data := StaticAny(stat_any,@data);
  req := StaticRequest(self,'push');
  req.add_in_arg(_data);
  req.set_exceptions_tc([_tc_Disconnected.typecode]);
  req.invoke;
  dorb_static_throw(req,[Disconnected_marshaller, 'IDL:omg.org/CosEventComm/Disconnected:1.0']);
end;

procedure TProxyPushConsumer_stub.disconnect_push_consumer;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'disconnect_push_consumer');
  req.invoke;
  dorb_static_throw(req);
end;

procedure TProxyPushConsumer_stub.connect_push_supplier(const push_supplier: IPushSupplier);
var
  req: IStaticRequest;
  _push_supplier: IStaticAny;
begin
  _push_supplier := StaticAny(PushSupplier_marshaller,@push_supplier);
  req := StaticRequest(self,'connect_push_supplier');
  req.add_in_arg(_push_supplier);
  req.set_exceptions_tc([_tc_AlreadyConnected.typecode]);
  req.invoke;
  dorb_static_throw(req,[AlreadyConnected_marshaller, 'IDL:omg.org/CosEventChannelAdmin/AlreadyConnected:1.0']);
end;

//***********************************************************
// TProxyPushConsumer_stub_clp
//***********************************************************
function TProxyPushConsumer_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0' then
    begin
      result := Pointer(self as IProxyPushConsumer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TProxyPushConsumer_stub_clp.connect_push_supplier(const push_supplier: IPushSupplier);
var
  _srv: IServant;
  srv: IProxyPushConsumer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TProxyPushConsumer_serv._narrow(_srv);
      if srv <> nil then
        srv.connect_push_supplier(push_supplier)
    end;
  _postinvoke();
end;

//***********************************************************
// TProxyPushConsumer_serv
//***********************************************************
function TProxyPushConsumer_serv._this(): IProxyPushConsumer;
var
  obj: IORBObject;
begin
  obj := this();
  result := TProxyPushConsumer._narrow(obj);
end;

function TProxyPushConsumer_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TProxyPushConsumer_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0';
end;

function TProxyPushConsumer_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TProxyPushConsumer_stub_clp.Create(poa,obj);
end;

procedure TProxyPushConsumer_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TProxyPushConsumer_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0' then
    begin
      result := Pointer(IProxyPushConsumer(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TProxyPushConsumer_serv._narrow(const srv : IServant): IProxyPushConsumer;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ProxyPushConsumer:1.0');
  if p <> nil then
    result := IProxyPushConsumer(p)
end;

function TProxyPushConsumer_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  connect_push_supplier_push_supplier: IPushSupplier;
begin
  result := true;
  if req.op_name = 'connect_push_supplier' then
    begin
      req.add_in_arg(StaticAny(PushSupplier_marshaller,@connect_push_supplier_push_supplier) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_AlreadyConnected.typecode]);
      try
        connect_push_supplier(connect_push_supplier_push_supplier);
      except
        on AlreadyConnected: TAlreadyConnected do
          req.set_exception(TAlreadyConnected.Create(AlreadyConnected) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TProxyPushConsumer_marshaller
//***********************************************************
function TProxyPushConsumer_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IProxyPushConsumer(addr^) := TProxyPushConsumer._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TProxyPushConsumer_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IProxyPushConsumer(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TProxyPushConsumer_marshaller._free(var addr: Pointer);
begin
  IProxyPushConsumer(addr^) := nil;
end;

procedure TProxyPushConsumer_marshaller._create(var addr: Pointer);
begin
  IProxyPushConsumer(addr^) := TProxyPushConsumer_stub.Create();
end;

procedure TProxyPushConsumer_marshaller._assign(dst, src: Pointer);
begin
  IProxyPushConsumer(dst^) := IProxyPushConsumer(src^);
end;

function TProxyPushConsumer_marshaller.typecode: ITypeCode;
begin
  result := _tc_ProxyPushConsumer.typecode;
end;

//***********************************************************
// TProxyPullSupplier
//***********************************************************
function TProxyPullSupplier.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0' then
    begin
      result := Pointer(self as IProxyPullSupplier);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TProxyPullSupplier._narrow(const obj : IORBObject): IProxyPullSupplier;
var
  p: Pointer;
  stub: TProxyPullSupplier_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0');
  if p <> nil then
    result := IProxyPullSupplier(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0') then
        begin
          stub := TProxyPullSupplier_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TProxyPullSupplier.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0'
end;

//***********************************************************
// TProxyPullSupplier_stub
//***********************************************************
function TProxyPullSupplier_stub.pull: IAny;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_any, @result);
  req := StaticRequest(self,'pull');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_Disconnected.typecode]);
  req.invoke;
  dorb_static_throw(req,[Disconnected_marshaller, 'IDL:omg.org/CosEventComm/Disconnected:1.0']);
end;

function TProxyPullSupplier_stub.try_pull(out has_event: Boolean): IAny;
var
  req: IStaticRequest;
  _has_event: IStaticAny;
  _result: IStaticAny;
begin
  _has_event := StaticAny(stat_boolean,@has_event);
  _result := StaticAny(stat_any, @result);
  req := StaticRequest(self,'try_pull');
  req.add_out_arg(_has_event);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_Disconnected.typecode]);
  req.invoke;
  dorb_static_throw(req,[Disconnected_marshaller, 'IDL:omg.org/CosEventComm/Disconnected:1.0']);
end;

procedure TProxyPullSupplier_stub.disconnect_pull_supplier;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'disconnect_pull_supplier');
  req.invoke;
  dorb_static_throw(req);
end;

procedure TProxyPullSupplier_stub.connect_pull_consumer(const pull_consumer: IPullConsumer);
var
  req: IStaticRequest;
  _pull_consumer: IStaticAny;
begin
  _pull_consumer := StaticAny(PullConsumer_marshaller,@pull_consumer);
  req := StaticRequest(self,'connect_pull_consumer');
  req.add_in_arg(_pull_consumer);
  req.set_exceptions_tc([_tc_AlreadyConnected.typecode]);
  req.invoke;
  dorb_static_throw(req,[AlreadyConnected_marshaller, 'IDL:omg.org/CosEventChannelAdmin/AlreadyConnected:1.0']);
end;

//***********************************************************
// TProxyPullSupplier_stub_clp
//***********************************************************
function TProxyPullSupplier_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0' then
    begin
      result := Pointer(self as IProxyPullSupplier);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TProxyPullSupplier_stub_clp.connect_pull_consumer(const pull_consumer: IPullConsumer);
var
  _srv: IServant;
  srv: IProxyPullSupplier;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TProxyPullSupplier_serv._narrow(_srv);
      if srv <> nil then
        srv.connect_pull_consumer(pull_consumer)
    end;
  _postinvoke();
end;

//***********************************************************
// TProxyPullSupplier_serv
//***********************************************************
function TProxyPullSupplier_serv._this(): IProxyPullSupplier;
var
  obj: IORBObject;
begin
  obj := this();
  result := TProxyPullSupplier._narrow(obj);
end;

function TProxyPullSupplier_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TProxyPullSupplier_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0';
end;

function TProxyPullSupplier_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TProxyPullSupplier_stub_clp.Create(poa,obj);
end;

procedure TProxyPullSupplier_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TProxyPullSupplier_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0' then
    begin
      result := Pointer(IProxyPullSupplier(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TProxyPullSupplier_serv._narrow(const srv : IServant): IProxyPullSupplier;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ProxyPullSupplier:1.0');
  if p <> nil then
    result := IProxyPullSupplier(p)
end;

function TProxyPullSupplier_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  connect_pull_consumer_pull_consumer: IPullConsumer;
begin
  result := true;
  if req.op_name = 'connect_pull_consumer' then
    begin
      req.add_in_arg(StaticAny(PullConsumer_marshaller,@connect_pull_consumer_pull_consumer) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_AlreadyConnected.typecode]);
      try
        connect_pull_consumer(connect_pull_consumer_pull_consumer);
      except
        on AlreadyConnected: TAlreadyConnected do
          req.set_exception(TAlreadyConnected.Create(AlreadyConnected) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TProxyPullSupplier_marshaller
//***********************************************************
function TProxyPullSupplier_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IProxyPullSupplier(addr^) := TProxyPullSupplier._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TProxyPullSupplier_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IProxyPullSupplier(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TProxyPullSupplier_marshaller._free(var addr: Pointer);
begin
  IProxyPullSupplier(addr^) := nil;
end;

procedure TProxyPullSupplier_marshaller._create(var addr: Pointer);
begin
  IProxyPullSupplier(addr^) := TProxyPullSupplier_stub.Create();
end;

procedure TProxyPullSupplier_marshaller._assign(dst, src: Pointer);
begin
  IProxyPullSupplier(dst^) := IProxyPullSupplier(src^);
end;

function TProxyPullSupplier_marshaller.typecode: ITypeCode;
begin
  result := _tc_ProxyPullSupplier.typecode;
end;

//***********************************************************
// TProxyPullConsumer
//***********************************************************
function TProxyPullConsumer.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0' then
    begin
      result := Pointer(self as IProxyPullConsumer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TProxyPullConsumer._narrow(const obj : IORBObject): IProxyPullConsumer;
var
  p: Pointer;
  stub: TProxyPullConsumer_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0');
  if p <> nil then
    result := IProxyPullConsumer(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0') then
        begin
          stub := TProxyPullConsumer_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TProxyPullConsumer.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0'
end;

//***********************************************************
// TProxyPullConsumer_stub
//***********************************************************
procedure TProxyPullConsumer_stub.disconnect_pull_consumer;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'disconnect_pull_consumer');
  req.invoke;
  dorb_static_throw(req);
end;

procedure TProxyPullConsumer_stub.connect_pull_supplier(const pull_supplier: IPullSupplier);
var
  req: IStaticRequest;
  _pull_supplier: IStaticAny;
begin
  _pull_supplier := StaticAny(PullSupplier_marshaller,@pull_supplier);
  req := StaticRequest(self,'connect_pull_supplier');
  req.add_in_arg(_pull_supplier);
  req.set_exceptions_tc([_tc_AlreadyConnected.typecode, _tc_TypeError.typecode]);
  req.invoke;
  dorb_static_throw(req,[AlreadyConnected_marshaller, 'IDL:omg.org/CosEventChannelAdmin/AlreadyConnected:1.0', TypeError_marshaller, 'IDL:omg.org/CosEventChannelAdmin/TypeError:1.0']);
end;

//***********************************************************
// TProxyPullConsumer_stub_clp
//***********************************************************
function TProxyPullConsumer_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0' then
    begin
      result := Pointer(self as IProxyPullConsumer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TProxyPullConsumer_stub_clp.connect_pull_supplier(const pull_supplier: IPullSupplier);
var
  _srv: IServant;
  srv: IProxyPullConsumer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TProxyPullConsumer_serv._narrow(_srv);
      if srv <> nil then
        srv.connect_pull_supplier(pull_supplier)
    end;
  _postinvoke();
end;

//***********************************************************
// TProxyPullConsumer_serv
//***********************************************************
function TProxyPullConsumer_serv._this(): IProxyPullConsumer;
var
  obj: IORBObject;
begin
  obj := this();
  result := TProxyPullConsumer._narrow(obj);
end;

function TProxyPullConsumer_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TProxyPullConsumer_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0';
end;

function TProxyPullConsumer_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TProxyPullConsumer_stub_clp.Create(poa,obj);
end;

procedure TProxyPullConsumer_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TProxyPullConsumer_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0' then
    begin
      result := Pointer(IProxyPullConsumer(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TProxyPullConsumer_serv._narrow(const srv : IServant): IProxyPullConsumer;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ProxyPullConsumer:1.0');
  if p <> nil then
    result := IProxyPullConsumer(p)
end;

function TProxyPullConsumer_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  connect_pull_supplier_pull_supplier: IPullSupplier;
begin
  result := true;
  if req.op_name = 'connect_pull_supplier' then
    begin
      req.add_in_arg(StaticAny(PullSupplier_marshaller,@connect_pull_supplier_pull_supplier) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_AlreadyConnected.typecode, _tc_TypeError.typecode]);
      try
        connect_pull_supplier(connect_pull_supplier_pull_supplier);
      except
        on AlreadyConnected: TAlreadyConnected do
          req.set_exception(TAlreadyConnected.Create(AlreadyConnected) as IORBException);
        on TypeError: TTypeError do
          req.set_exception(TTypeError.Create(TypeError) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TProxyPullConsumer_marshaller
//***********************************************************
function TProxyPullConsumer_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IProxyPullConsumer(addr^) := TProxyPullConsumer._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TProxyPullConsumer_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IProxyPullConsumer(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TProxyPullConsumer_marshaller._free(var addr: Pointer);
begin
  IProxyPullConsumer(addr^) := nil;
end;

procedure TProxyPullConsumer_marshaller._create(var addr: Pointer);
begin
  IProxyPullConsumer(addr^) := TProxyPullConsumer_stub.Create();
end;

procedure TProxyPullConsumer_marshaller._assign(dst, src: Pointer);
begin
  IProxyPullConsumer(dst^) := IProxyPullConsumer(src^);
end;

function TProxyPullConsumer_marshaller.typecode: ITypeCode;
begin
  result := _tc_ProxyPullConsumer.typecode;
end;

//***********************************************************
// TProxyPushSupplier
//***********************************************************
function TProxyPushSupplier.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0' then
    begin
      result := Pointer(self as IProxyPushSupplier);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TProxyPushSupplier._narrow(const obj : IORBObject): IProxyPushSupplier;
var
  p: Pointer;
  stub: TProxyPushSupplier_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0');
  if p <> nil then
    result := IProxyPushSupplier(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0') then
        begin
          stub := TProxyPushSupplier_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TProxyPushSupplier.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0'
end;

//***********************************************************
// TProxyPushSupplier_stub
//***********************************************************
procedure TProxyPushSupplier_stub.disconnect_push_supplier;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'disconnect_push_supplier');
  req.invoke;
  dorb_static_throw(req);
end;

procedure TProxyPushSupplier_stub.connect_push_consumer(const push_consumer: IPushConsumer);
var
  req: IStaticRequest;
  _push_consumer: IStaticAny;
begin
  _push_consumer := StaticAny(PushConsumer_marshaller,@push_consumer);
  req := StaticRequest(self,'connect_push_consumer');
  req.add_in_arg(_push_consumer);
  req.set_exceptions_tc([_tc_AlreadyConnected.typecode, _tc_TypeError.typecode]);
  req.invoke;
  dorb_static_throw(req,[AlreadyConnected_marshaller, 'IDL:omg.org/CosEventChannelAdmin/AlreadyConnected:1.0', TypeError_marshaller, 'IDL:omg.org/CosEventChannelAdmin/TypeError:1.0']);
end;

//***********************************************************
// TProxyPushSupplier_stub_clp
//***********************************************************
function TProxyPushSupplier_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0' then
    begin
      result := Pointer(self as IProxyPushSupplier);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TProxyPushSupplier_stub_clp.connect_push_consumer(const push_consumer: IPushConsumer);
var
  _srv: IServant;
  srv: IProxyPushSupplier;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TProxyPushSupplier_serv._narrow(_srv);
      if srv <> nil then
        srv.connect_push_consumer(push_consumer)
    end;
  _postinvoke();
end;

//***********************************************************
// TProxyPushSupplier_serv
//***********************************************************
function TProxyPushSupplier_serv._this(): IProxyPushSupplier;
var
  obj: IORBObject;
begin
  obj := this();
  result := TProxyPushSupplier._narrow(obj);
end;

function TProxyPushSupplier_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TProxyPushSupplier_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0';
end;

function TProxyPushSupplier_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TProxyPushSupplier_stub_clp.Create(poa,obj);
end;

procedure TProxyPushSupplier_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TProxyPushSupplier_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0' then
    begin
      result := Pointer(IProxyPushSupplier(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TProxyPushSupplier_serv._narrow(const srv : IServant): IProxyPushSupplier;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ProxyPushSupplier:1.0');
  if p <> nil then
    result := IProxyPushSupplier(p)
end;

function TProxyPushSupplier_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  connect_push_consumer_push_consumer: IPushConsumer;
begin
  result := true;
  if req.op_name = 'connect_push_consumer' then
    begin
      req.add_in_arg(StaticAny(PushConsumer_marshaller,@connect_push_consumer_push_consumer) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_AlreadyConnected.typecode, _tc_TypeError.typecode]);
      try
        connect_push_consumer(connect_push_consumer_push_consumer);
      except
        on AlreadyConnected: TAlreadyConnected do
          req.set_exception(TAlreadyConnected.Create(AlreadyConnected) as IORBException);
        on TypeError: TTypeError do
          req.set_exception(TTypeError.Create(TypeError) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TProxyPushSupplier_marshaller
//***********************************************************
function TProxyPushSupplier_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IProxyPushSupplier(addr^) := TProxyPushSupplier._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TProxyPushSupplier_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IProxyPushSupplier(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TProxyPushSupplier_marshaller._free(var addr: Pointer);
begin
  IProxyPushSupplier(addr^) := nil;
end;

procedure TProxyPushSupplier_marshaller._create(var addr: Pointer);
begin
  IProxyPushSupplier(addr^) := TProxyPushSupplier_stub.Create();
end;

procedure TProxyPushSupplier_marshaller._assign(dst, src: Pointer);
begin
  IProxyPushSupplier(dst^) := IProxyPushSupplier(src^);
end;

function TProxyPushSupplier_marshaller.typecode: ITypeCode;
begin
  result := _tc_ProxyPushSupplier.typecode;
end;

//***********************************************************
// TConsumerAdmin
//***********************************************************
function TConsumerAdmin.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0' then
    begin
      result := Pointer(self as IConsumerAdmin);
      exit;
    end;
end;

class function TConsumerAdmin._narrow(const obj : IORBObject): IConsumerAdmin;
var
  p: Pointer;
  stub: TConsumerAdmin_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0');
  if p <> nil then
    result := IConsumerAdmin(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0') then
        begin
          stub := TConsumerAdmin_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TConsumerAdmin.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0'
end;

//***********************************************************
// TConsumerAdmin_stub
//***********************************************************
function TConsumerAdmin_stub.obtain_push_supplier: IProxyPushSupplier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ProxyPushSupplier_marshaller, @result);
  req := StaticRequest(self,'obtain_push_supplier');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TConsumerAdmin_stub.obtain_pull_supplier: IProxyPullSupplier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ProxyPullSupplier_marshaller, @result);
  req := StaticRequest(self,'obtain_pull_supplier');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TConsumerAdmin_stub_clp
//***********************************************************
function TConsumerAdmin_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0' then
    begin
      result := Pointer(self as IConsumerAdmin);
      exit;
  end;
end;

function TConsumerAdmin_stub_clp.obtain_push_supplier: IProxyPushSupplier;
var
  _srv: IServant;
  srv: IConsumerAdmin;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TConsumerAdmin_serv._narrow(_srv);
      if srv <> nil then
        result := srv.obtain_push_supplier
    end;
  _postinvoke();
end;

function TConsumerAdmin_stub_clp.obtain_pull_supplier: IProxyPullSupplier;
var
  _srv: IServant;
  srv: IConsumerAdmin;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TConsumerAdmin_serv._narrow(_srv);
      if srv <> nil then
        result := srv.obtain_pull_supplier
    end;
  _postinvoke();
end;

//***********************************************************
// TConsumerAdmin_serv
//***********************************************************
function TConsumerAdmin_serv._this(): IConsumerAdmin;
var
  obj: IORBObject;
begin
  obj := this();
  result := TConsumerAdmin._narrow(obj);
end;

function TConsumerAdmin_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0';
end;

function TConsumerAdmin_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0';
end;

function TConsumerAdmin_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TConsumerAdmin_stub_clp.Create(poa,obj);
end;

procedure TConsumerAdmin_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TConsumerAdmin_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0' then
    begin
      result := Pointer(IConsumerAdmin(self));
      exit;
    end;
end;

class function TConsumerAdmin_serv._narrow(const srv : IServant): IConsumerAdmin;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventChannelAdmin/ConsumerAdmin:1.0');
  if p <> nil then
    result := IConsumerAdmin(p)
end;

function TConsumerAdmin_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  obtain_push_supplier_result: IProxyPushSupplier;
  obtain_pull_supplier_result: IProxyPullSupplier;
begin
  result := true;
  if req.op_name = 'obtain_push_supplier' then
    begin
      req.set_result(StaticAny(ProxyPushSupplier_marshaller,@obtain_push_supplier_result) as IStaticAny);
      if not req.read_args() then  exit;
      obtain_push_supplier_result := obtain_push_supplier;
      req.write_results();
      exit;
    end
  else if req.op_name = 'obtain_pull_supplier' then
    begin
      req.set_result(StaticAny(ProxyPullSupplier_marshaller,@obtain_pull_supplier_result) as IStaticAny);
      if not req.read_args() then  exit;
      obtain_pull_supplier_result := obtain_pull_supplier;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TConsumerAdmin_marshaller
//***********************************************************
function TConsumerAdmin_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IConsumerAdmin(addr^) := TConsumerAdmin._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TConsumerAdmin_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IConsumerAdmin(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TConsumerAdmin_marshaller._free(var addr: Pointer);
begin
  IConsumerAdmin(addr^) := nil;
end;

procedure TConsumerAdmin_marshaller._create(var addr: Pointer);
begin
  IConsumerAdmin(addr^) := TConsumerAdmin_stub.Create();
end;

procedure TConsumerAdmin_marshaller._assign(dst, src: Pointer);
begin
  IConsumerAdmin(dst^) := IConsumerAdmin(src^);
end;

function TConsumerAdmin_marshaller.typecode: ITypeCode;
begin
  result := _tc_ConsumerAdmin.typecode;
end;

//***********************************************************
// TSupplierAdmin
//***********************************************************
function TSupplierAdmin.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0' then
    begin
      result := Pointer(self as ISupplierAdmin);
      exit;
    end;
end;

class function TSupplierAdmin._narrow(const obj : IORBObject): ISupplierAdmin;
var
  p: Pointer;
  stub: TSupplierAdmin_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0');
  if p <> nil then
    result := ISupplierAdmin(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0') then
        begin
          stub := TSupplierAdmin_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TSupplierAdmin.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0'
end;

//***********************************************************
// TSupplierAdmin_stub
//***********************************************************
function TSupplierAdmin_stub.obtain_push_consumer: IProxyPushConsumer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ProxyPushConsumer_marshaller, @result);
  req := StaticRequest(self,'obtain_push_consumer');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TSupplierAdmin_stub.obtain_pull_consumer: IProxyPullConsumer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ProxyPullConsumer_marshaller, @result);
  req := StaticRequest(self,'obtain_pull_consumer');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TSupplierAdmin_stub_clp
//***********************************************************
function TSupplierAdmin_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0' then
    begin
      result := Pointer(self as ISupplierAdmin);
      exit;
  end;
end;

function TSupplierAdmin_stub_clp.obtain_push_consumer: IProxyPushConsumer;
var
  _srv: IServant;
  srv: ISupplierAdmin;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSupplierAdmin_serv._narrow(_srv);
      if srv <> nil then
        result := srv.obtain_push_consumer
    end;
  _postinvoke();
end;

function TSupplierAdmin_stub_clp.obtain_pull_consumer: IProxyPullConsumer;
var
  _srv: IServant;
  srv: ISupplierAdmin;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSupplierAdmin_serv._narrow(_srv);
      if srv <> nil then
        result := srv.obtain_pull_consumer
    end;
  _postinvoke();
end;

//***********************************************************
// TSupplierAdmin_serv
//***********************************************************
function TSupplierAdmin_serv._this(): ISupplierAdmin;
var
  obj: IORBObject;
begin
  obj := this();
  result := TSupplierAdmin._narrow(obj);
end;

function TSupplierAdmin_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0';
end;

function TSupplierAdmin_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0';
end;

function TSupplierAdmin_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TSupplierAdmin_stub_clp.Create(poa,obj);
end;

procedure TSupplierAdmin_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TSupplierAdmin_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0' then
    begin
      result := Pointer(ISupplierAdmin(self));
      exit;
    end;
end;

class function TSupplierAdmin_serv._narrow(const srv : IServant): ISupplierAdmin;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventChannelAdmin/SupplierAdmin:1.0');
  if p <> nil then
    result := ISupplierAdmin(p)
end;

function TSupplierAdmin_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  obtain_push_consumer_result: IProxyPushConsumer;
  obtain_pull_consumer_result: IProxyPullConsumer;
begin
  result := true;
  if req.op_name = 'obtain_push_consumer' then
    begin
      req.set_result(StaticAny(ProxyPushConsumer_marshaller,@obtain_push_consumer_result) as IStaticAny);
      if not req.read_args() then  exit;
      obtain_push_consumer_result := obtain_push_consumer;
      req.write_results();
      exit;
    end
  else if req.op_name = 'obtain_pull_consumer' then
    begin
      req.set_result(StaticAny(ProxyPullConsumer_marshaller,@obtain_pull_consumer_result) as IStaticAny);
      if not req.read_args() then  exit;
      obtain_pull_consumer_result := obtain_pull_consumer;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TSupplierAdmin_marshaller
//***********************************************************
function TSupplierAdmin_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ISupplierAdmin(addr^) := TSupplierAdmin._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TSupplierAdmin_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ISupplierAdmin(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TSupplierAdmin_marshaller._free(var addr: Pointer);
begin
  ISupplierAdmin(addr^) := nil;
end;

procedure TSupplierAdmin_marshaller._create(var addr: Pointer);
begin
  ISupplierAdmin(addr^) := TSupplierAdmin_stub.Create();
end;

procedure TSupplierAdmin_marshaller._assign(dst, src: Pointer);
begin
  ISupplierAdmin(dst^) := ISupplierAdmin(src^);
end;

function TSupplierAdmin_marshaller.typecode: ITypeCode;
begin
  result := _tc_SupplierAdmin.typecode;
end;

//***********************************************************
// TEventChannel
//***********************************************************
function TEventChannel.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0' then
    begin
      result := Pointer(self as IEventChannel);
      exit;
    end;
end;

class function TEventChannel._narrow(const obj : IORBObject): IEventChannel;
var
  p: Pointer;
  stub: TEventChannel_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0');
  if p <> nil then
    result := IEventChannel(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0') then
        begin
          stub := TEventChannel_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TEventChannel.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0'
end;

//***********************************************************
// TEventChannel_stub
//***********************************************************
function TEventChannel_stub.for_consumers: IConsumerAdmin;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ConsumerAdmin_marshaller, @result);
  req := StaticRequest(self,'for_consumers');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TEventChannel_stub.for_suppliers: ISupplierAdmin;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(SupplierAdmin_marshaller, @result);
  req := StaticRequest(self,'for_suppliers');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TEventChannel_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TEventChannel_stub_clp
//***********************************************************
function TEventChannel_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0' then
    begin
      result := Pointer(self as IEventChannel);
      exit;
  end;
end;

function TEventChannel_stub_clp.for_consumers: IConsumerAdmin;
var
  _srv: IServant;
  srv: IEventChannel;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TEventChannel_serv._narrow(_srv);
      if srv <> nil then
        result := srv.for_consumers
    end;
  _postinvoke();
end;

function TEventChannel_stub_clp.for_suppliers: ISupplierAdmin;
var
  _srv: IServant;
  srv: IEventChannel;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TEventChannel_serv._narrow(_srv);
      if srv <> nil then
        result := srv.for_suppliers
    end;
  _postinvoke();
end;

procedure TEventChannel_stub_clp._destroy;
var
  _srv: IServant;
  srv: IEventChannel;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TEventChannel_serv._narrow(_srv);
      if srv <> nil then
        srv._destroy
    end;
  _postinvoke();
end;

//***********************************************************
// TEventChannel_serv
//***********************************************************
function TEventChannel_serv._this(): IEventChannel;
var
  obj: IORBObject;
begin
  obj := this();
  result := TEventChannel._narrow(obj);
end;

function TEventChannel_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0';
end;

function TEventChannel_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0';
end;

function TEventChannel_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TEventChannel_stub_clp.Create(poa,obj);
end;

procedure TEventChannel_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TEventChannel_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0' then
    begin
      result := Pointer(IEventChannel(self));
      exit;
    end;
end;

class function TEventChannel_serv._narrow(const srv : IServant): IEventChannel;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventChannelAdmin/EventChannel:1.0');
  if p <> nil then
    result := IEventChannel(p)
end;

function TEventChannel_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  for_consumers_result: IConsumerAdmin;
  for_suppliers_result: ISupplierAdmin;
begin
  result := true;
  if req.op_name = 'for_consumers' then
    begin
      req.set_result(StaticAny(ConsumerAdmin_marshaller,@for_consumers_result) as IStaticAny);
      if not req.read_args() then  exit;
      for_consumers_result := for_consumers;
      req.write_results();
      exit;
    end
  else if req.op_name = 'for_suppliers' then
    begin
      req.set_result(StaticAny(SupplierAdmin_marshaller,@for_suppliers_result) as IStaticAny);
      if not req.read_args() then  exit;
      for_suppliers_result := for_suppliers;
      req.write_results();
      exit;
    end
  else if req.op_name = 'destroy' then
    begin
      if not req.read_args() then  exit;
      _destroy;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TEventChannel_marshaller
//***********************************************************
function TEventChannel_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IEventChannel(addr^) := TEventChannel._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TEventChannel_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IEventChannel(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TEventChannel_marshaller._free(var addr: Pointer);
begin
  IEventChannel(addr^) := nil;
end;

procedure TEventChannel_marshaller._create(var addr: Pointer);
begin
  IEventChannel(addr^) := TEventChannel_stub.Create();
end;

procedure TEventChannel_marshaller._assign(dst, src: Pointer);
begin
  IEventChannel(dst^) := IEventChannel(src^);
end;

function TEventChannel_marshaller.typecode: ITypeCode;
begin
  result := _tc_EventChannel.typecode;
end;

//***********************************************************
// TEventChannelFactory
//***********************************************************
function TEventChannelFactory.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0' then
    begin
      result := Pointer(self as IEventChannelFactory);
      exit;
    end;
end;

class function TEventChannelFactory._narrow(const obj : IORBObject): IEventChannelFactory;
var
  p: Pointer;
  stub: TEventChannelFactory_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0');
  if p <> nil then
    result := IEventChannelFactory(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0') then
        begin
          stub := TEventChannelFactory_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TEventChannelFactory.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0'
end;

//***********************************************************
// TEventChannelFactory_stub
//***********************************************************
function TEventChannelFactory_stub.create_eventchannel: IEventChannel;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(EventChannel_marshaller, @result);
  req := StaticRequest(self,'create_eventchannel');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TEventChannelFactory_stub_clp
//***********************************************************
function TEventChannelFactory_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0' then
    begin
      result := Pointer(self as IEventChannelFactory);
      exit;
  end;
end;

function TEventChannelFactory_stub_clp.create_eventchannel: IEventChannel;
var
  _srv: IServant;
  srv: IEventChannelFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TEventChannelFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_eventchannel
    end;
  _postinvoke();
end;

//***********************************************************
// TEventChannelFactory_serv
//***********************************************************
function TEventChannelFactory_serv._this(): IEventChannelFactory;
var
  obj: IORBObject;
begin
  obj := this();
  result := TEventChannelFactory._narrow(obj);
end;

function TEventChannelFactory_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0';
end;

function TEventChannelFactory_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0';
end;

function TEventChannelFactory_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TEventChannelFactory_stub_clp.Create(poa,obj);
end;

procedure TEventChannelFactory_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TEventChannelFactory_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0' then
    begin
      result := Pointer(IEventChannelFactory(self));
      exit;
    end;
end;

class function TEventChannelFactory_serv._narrow(const srv : IServant): IEventChannelFactory;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/SimpleEventChannelAdmin/EventChannelFactory:1.0');
  if p <> nil then
    result := IEventChannelFactory(p)
end;

function TEventChannelFactory_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  create_eventchannel_result: IEventChannel;
begin
  result := true;
  if req.op_name = 'create_eventchannel' then
    begin
      req.set_result(StaticAny(EventChannel_marshaller,@create_eventchannel_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_eventchannel_result := create_eventchannel;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TEventChannelFactory_marshaller
//***********************************************************
function TEventChannelFactory_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IEventChannelFactory(addr^) := TEventChannelFactory._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TEventChannelFactory_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IEventChannelFactory(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TEventChannelFactory_marshaller._free(var addr: Pointer);
begin
  IEventChannelFactory(addr^) := nil;
end;

procedure TEventChannelFactory_marshaller._create(var addr: Pointer);
begin
  IEventChannelFactory(addr^) := TEventChannelFactory_stub.Create();
end;

procedure TEventChannelFactory_marshaller._assign(dst, src: Pointer);
begin
  IEventChannelFactory(dst^) := IEventChannelFactory(src^);
end;

function TEventChannelFactory_marshaller.typecode: ITypeCode;
begin
  result := _tc_EventChannelFactory.typecode;
end;

initialization
  AlreadyConnected_marshaller := TAlreadyConnected_marshaller.Create();
  TypeError_marshaller := TTypeError_marshaller.Create();
  ProxyPushConsumer_marshaller := TProxyPushConsumer_marshaller.Create();
  ProxyPullSupplier_marshaller := TProxyPullSupplier_marshaller.Create();
  ProxyPullConsumer_marshaller := TProxyPullConsumer_marshaller.Create();
  ProxyPushSupplier_marshaller := TProxyPushSupplier_marshaller.Create();
  ConsumerAdmin_marshaller := TConsumerAdmin_marshaller.Create();
  SupplierAdmin_marshaller := TSupplierAdmin_marshaller.Create();
  EventChannel_marshaller := TEventChannel_marshaller.Create();
  EventChannelFactory_marshaller := TEventChannelFactory_marshaller.Create();
  _tc_AlreadyConnected := CreateTypeCodeConst('01000000160000005c000000010000003600000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f416c'+
    '7265616479436f6e6e65637465643a312e3000000011000000416c7265616479436f6e6e65637465640000000000000000');
  _tc_TypeError := CreateTypeCodeConst('01000000160000004c000000010000002f00000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f5479'+
    '70654572726f723a312e3000000a000000547970654572726f7200000000000000');
  _tc_ProxyPushConsumer := CreateTypeCodeConst('010000000e00000056000000010000003700000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f5072'+
    '6f787950757368436f6e73756d65723a312e3000001200000050726f787950757368436f6e73756d657200');
  _tc_ProxyPullSupplier := CreateTypeCodeConst('010000000e00000056000000010000003700000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f5072'+
    '6f787950756c6c537570706c6965723a312e3000001200000050726f787950756c6c537570706c69657200');
  _tc_ProxyPullConsumer := CreateTypeCodeConst('010000000e00000056000000010000003700000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f5072'+
    '6f787950756c6c436f6e73756d65723a312e3000001200000050726f787950756c6c436f6e73756d657200');
  _tc_ProxyPushSupplier := CreateTypeCodeConst('010000000e00000056000000010000003700000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f5072'+
    '6f787950757368537570706c6965723a312e3000001200000050726f787950757368537570706c69657200');
  _tc_ConsumerAdmin := CreateTypeCodeConst('010000000e0000004e000000010000003300000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f436f'+
    '6e73756d657241646d696e3a312e3000000e000000436f6e73756d657241646d696e00');
  _tc_SupplierAdmin := CreateTypeCodeConst('010000000e0000004e000000010000003300000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f5375'+
    '70706c69657241646d696e3a312e3000000e000000537570706c69657241646d696e00');
  _tc_EventChannel := CreateTypeCodeConst('010000000e0000004d000000010000003200000049444c3a6f6d672e6f72672f436f734576656e744368616e6e656c41646d696e2f4576'+
    '656e744368616e6e656c3a312e300000000d0000004576656e744368616e6e656c00');
  _tc_EventChannelFactory := CreateTypeCodeConst('010000000e0000005c000000010000003c00000049444c3a6f6d672e6f72672f53696d706c654576656e744368616e6e656c41646d696e'+
    '2f4576656e744368616e6e656c466163746f72793a312e3000140000004576656e744368616e6e656c466163746f727900');
end.
