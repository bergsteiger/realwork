// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -without-prefix -i..\..\idl ..\..\idl\CosEventComm.idl" 
//                                                                            
unit CosEventComm;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, CosEventComm_int, poa_int, poa;

type

  TDisconnected_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventComm/Disconnected:1.0 } 
  TDisconnected = class(UserException,IDisconnected)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TDisconnected); overload;
    constructor Create(); overload;
  end;

  {** IDL:omg.org/CosEventComm/PushConsumer:1.0 } 
  TPushConsumer = class(TORBObject,IPushConsumer)
  protected
    procedure push(const data: IAny); virtual; abstract;
    procedure disconnect_push_consumer; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IPushConsumer;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventComm/PushConsumer:1.0} 
  TPushConsumer_stub = class(TPushConsumer)
  protected
    procedure push(const data: IAny); override;
    procedure disconnect_push_consumer; override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventComm/PushConsumer:1.0} 
  TPushConsumer_stub_clp = class(TPOAStub,IPOAStub,IPushConsumer)
  protected
    procedure push(const data: IAny); virtual;
    procedure disconnect_push_consumer; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventComm/PushConsumer:1.0} 
  TPushConsumer_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IPushConsumer)
  protected
    procedure push(const data: IAny); virtual; abstract;
    procedure disconnect_push_consumer; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IPushConsumer;
    class function _narrow(const srv : IServant): IPushConsumer;
  end;

  TPushConsumer_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventComm/PushSupplier:1.0 } 
  TPushSupplier = class(TORBObject,IPushSupplier)
  protected
    procedure disconnect_push_supplier; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IPushSupplier;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventComm/PushSupplier:1.0} 
  TPushSupplier_stub = class(TPushSupplier)
  protected
    procedure disconnect_push_supplier; override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventComm/PushSupplier:1.0} 
  TPushSupplier_stub_clp = class(TPOAStub,IPOAStub,IPushSupplier)
  protected
    procedure disconnect_push_supplier; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventComm/PushSupplier:1.0} 
  TPushSupplier_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IPushSupplier)
  protected
    procedure disconnect_push_supplier; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IPushSupplier;
    class function _narrow(const srv : IServant): IPushSupplier;
  end;

  TPushSupplier_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventComm/PullSupplier:1.0 } 
  TPullSupplier = class(TORBObject,IPullSupplier)
  protected
    function pull: IAny; virtual; abstract;
    function try_pull(out has_event: Boolean): IAny; virtual; abstract;
    procedure disconnect_pull_supplier; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IPullSupplier;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventComm/PullSupplier:1.0} 
  TPullSupplier_stub = class(TPullSupplier)
  protected
    function pull: IAny; override;
    function try_pull(out has_event: Boolean): IAny; override;
    procedure disconnect_pull_supplier; override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventComm/PullSupplier:1.0} 
  TPullSupplier_stub_clp = class(TPOAStub,IPOAStub,IPullSupplier)
  protected
    function pull: IAny; virtual;
    function try_pull(out has_event: Boolean): IAny; virtual;
    procedure disconnect_pull_supplier; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventComm/PullSupplier:1.0} 
  TPullSupplier_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IPullSupplier)
  protected
    function pull: IAny; virtual; abstract;
    function try_pull(out has_event: Boolean): IAny; virtual; abstract;
    procedure disconnect_pull_supplier; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IPullSupplier;
    class function _narrow(const srv : IServant): IPullSupplier;
  end;

  TPullSupplier_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosEventComm/PullConsumer:1.0 } 
  TPullConsumer = class(TORBObject,IPullConsumer)
  protected
    procedure disconnect_pull_consumer; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IPullConsumer;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosEventComm/PullConsumer:1.0} 
  TPullConsumer_stub = class(TPullConsumer)
  protected
    procedure disconnect_pull_consumer; override;
  end;

  {** POA stub for interface IDL:omg.org/CosEventComm/PullConsumer:1.0} 
  TPullConsumer_stub_clp = class(TPOAStub,IPOAStub,IPullConsumer)
  protected
    procedure disconnect_pull_consumer; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosEventComm/PullConsumer:1.0} 
  TPullConsumer_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IPullConsumer)
  protected
    procedure disconnect_pull_consumer; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IPullConsumer;
    class function _narrow(const srv : IServant): IPullConsumer;
  end;

  TPullConsumer_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  Disconnected_marshaller : IStaticTypeInfo;
  PushConsumer_marshaller : IStaticTypeInfo;
  PushSupplier_marshaller : IStaticTypeInfo;
  PullSupplier_marshaller : IStaticTypeInfo;
  PullConsumer_marshaller : IStaticTypeInfo;
  _tc_Disconnected : ITypeCodeConst;
  _tc_PushConsumer : ITypeCodeConst;
  _tc_PushSupplier : ITypeCodeConst;
  _tc_PullSupplier : ITypeCodeConst;
  _tc_PullConsumer : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TDisconnected_marshaller
//***********************************************************
function TDisconnected_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TDisconnected_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosEventComm/Disconnected:1.0');
  enc.except_end;
end;

procedure TDisconnected_marshaller._free(var addr: Pointer);
begin
  IDisconnected(addr^) := nil;
end;

procedure TDisconnected_marshaller._create(var addr: Pointer);
begin
  IDisconnected(addr^) := TDisconnected.Create();
end;

procedure TDisconnected_marshaller._assign(dst, src: Pointer);
begin
  IDisconnected(dst^) := IDisconnected(src^);
end;

function TDisconnected_marshaller.typecode: ITypeCode;
begin
  result := _tc_Disconnected.typecode;
end;

//***********************************************************
// TDisconnected
//***********************************************************
constructor TDisconnected.Create(ex: TDisconnected);
begin
  inherited Create();
end;

procedure TDisconnected.throw;
begin
  raise TDisconnected.Create(self);
end;

function TDisconnected.clone(): IORBException;
begin
  result := TDisconnected.Create(self);
end;

procedure TDisconnected.encode(const enc: IEncoder);
var
  int : IDisconnected;
begin
  int := self;
  Disconnected_marshaller.marshal(enc,@int);
end;

procedure TDisconnected.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(Disconnected_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TDisconnected.Create();
begin
  inherited Create();
end;

function TDisconnected.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventComm/Disconnected:1.0';
end;

//***********************************************************
// TPushConsumer
//***********************************************************
function TPushConsumer.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PushConsumer:1.0' then
    begin
      result := Pointer(self as IPushConsumer);
      exit;
    end;
end;

class function TPushConsumer._narrow(const obj : IORBObject): IPushConsumer;
var
  p: Pointer;
  stub: TPushConsumer_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventComm/PushConsumer:1.0');
  if p <> nil then
    result := IPushConsumer(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventComm/PushConsumer:1.0') then
        begin
          stub := TPushConsumer_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TPushConsumer.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventComm/PushConsumer:1.0'
end;

//***********************************************************
// TPushConsumer_stub
//***********************************************************
procedure TPushConsumer_stub.push(const data: IAny);
var
  req: IStaticRequest;
  _data: IStaticAny;
begin
  _data := StaticAny(stat_any,@data);
  req := StaticRequest(self,'push');
  req.add_in_arg(_data);
  req.set_exceptions_tc([_tc_Disconnected.typecode]);
  req.invoke;
  dorb_static_throw(req,[Disconnected_marshaller, 'IDL:omg.org/CosEventComm/Disconnected:1.0']);
end;

procedure TPushConsumer_stub.disconnect_push_consumer;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'disconnect_push_consumer');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TPushConsumer_stub_clp
//***********************************************************
function TPushConsumer_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PushConsumer:1.0' then
    begin
      result := Pointer(self as IPushConsumer);
      exit;
  end;
end;

procedure TPushConsumer_stub_clp.push(const data: IAny);
var
  _srv: IServant;
  srv: IPushConsumer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPushConsumer_serv._narrow(_srv);
      if srv <> nil then
        srv.push(data)
    end;
  _postinvoke();
end;

procedure TPushConsumer_stub_clp.disconnect_push_consumer;
var
  _srv: IServant;
  srv: IPushConsumer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPushConsumer_serv._narrow(_srv);
      if srv <> nil then
        srv.disconnect_push_consumer
    end;
  _postinvoke();
end;

//***********************************************************
// TPushConsumer_serv
//***********************************************************
function TPushConsumer_serv._this(): IPushConsumer;
var
  obj: IORBObject;
begin
  obj := this();
  result := TPushConsumer._narrow(obj);
end;

function TPushConsumer_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventComm/PushConsumer:1.0';
end;

function TPushConsumer_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventComm/PushConsumer:1.0';
end;

function TPushConsumer_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TPushConsumer_stub_clp.Create(poa,obj);
end;

procedure TPushConsumer_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TPushConsumer_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PushConsumer:1.0' then
    begin
      result := Pointer(IPushConsumer(self));
      exit;
    end;
end;

class function TPushConsumer_serv._narrow(const srv : IServant): IPushConsumer;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventComm/PushConsumer:1.0');
  if p <> nil then
    result := IPushConsumer(p)
end;

function TPushConsumer_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  push_data: IAny;
begin
  result := true;
  if req.op_name = 'push' then
    begin
      req.add_in_arg(StaticAny(stat_any,@push_data) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Disconnected.typecode]);
      try
        push(push_data);
      except
        on Disconnected: TDisconnected do
          req.set_exception(TDisconnected.Create(Disconnected) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'disconnect_push_consumer' then
    begin
      if not req.read_args() then  exit;
      disconnect_push_consumer;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TPushConsumer_marshaller
//***********************************************************
function TPushConsumer_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IPushConsumer(addr^) := TPushConsumer._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TPushConsumer_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IPushConsumer(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TPushConsumer_marshaller._free(var addr: Pointer);
begin
  IPushConsumer(addr^) := nil;
end;

procedure TPushConsumer_marshaller._create(var addr: Pointer);
begin
  IPushConsumer(addr^) := TPushConsumer_stub.Create();
end;

procedure TPushConsumer_marshaller._assign(dst, src: Pointer);
begin
  IPushConsumer(dst^) := IPushConsumer(src^);
end;

function TPushConsumer_marshaller.typecode: ITypeCode;
begin
  result := _tc_PushConsumer.typecode;
end;

//***********************************************************
// TPushSupplier
//***********************************************************
function TPushSupplier.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PushSupplier:1.0' then
    begin
      result := Pointer(self as IPushSupplier);
      exit;
    end;
end;

class function TPushSupplier._narrow(const obj : IORBObject): IPushSupplier;
var
  p: Pointer;
  stub: TPushSupplier_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventComm/PushSupplier:1.0');
  if p <> nil then
    result := IPushSupplier(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventComm/PushSupplier:1.0') then
        begin
          stub := TPushSupplier_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TPushSupplier.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventComm/PushSupplier:1.0'
end;

//***********************************************************
// TPushSupplier_stub
//***********************************************************
procedure TPushSupplier_stub.disconnect_push_supplier;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'disconnect_push_supplier');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TPushSupplier_stub_clp
//***********************************************************
function TPushSupplier_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PushSupplier:1.0' then
    begin
      result := Pointer(self as IPushSupplier);
      exit;
  end;
end;

procedure TPushSupplier_stub_clp.disconnect_push_supplier;
var
  _srv: IServant;
  srv: IPushSupplier;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPushSupplier_serv._narrow(_srv);
      if srv <> nil then
        srv.disconnect_push_supplier
    end;
  _postinvoke();
end;

//***********************************************************
// TPushSupplier_serv
//***********************************************************
function TPushSupplier_serv._this(): IPushSupplier;
var
  obj: IORBObject;
begin
  obj := this();
  result := TPushSupplier._narrow(obj);
end;

function TPushSupplier_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventComm/PushSupplier:1.0';
end;

function TPushSupplier_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventComm/PushSupplier:1.0';
end;

function TPushSupplier_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TPushSupplier_stub_clp.Create(poa,obj);
end;

procedure TPushSupplier_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TPushSupplier_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PushSupplier:1.0' then
    begin
      result := Pointer(IPushSupplier(self));
      exit;
    end;
end;

class function TPushSupplier_serv._narrow(const srv : IServant): IPushSupplier;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventComm/PushSupplier:1.0');
  if p <> nil then
    result := IPushSupplier(p)
end;

function TPushSupplier_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if req.op_name = 'disconnect_push_supplier' then
    begin
      if not req.read_args() then  exit;
      disconnect_push_supplier;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TPushSupplier_marshaller
//***********************************************************
function TPushSupplier_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IPushSupplier(addr^) := TPushSupplier._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TPushSupplier_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IPushSupplier(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TPushSupplier_marshaller._free(var addr: Pointer);
begin
  IPushSupplier(addr^) := nil;
end;

procedure TPushSupplier_marshaller._create(var addr: Pointer);
begin
  IPushSupplier(addr^) := TPushSupplier_stub.Create();
end;

procedure TPushSupplier_marshaller._assign(dst, src: Pointer);
begin
  IPushSupplier(dst^) := IPushSupplier(src^);
end;

function TPushSupplier_marshaller.typecode: ITypeCode;
begin
  result := _tc_PushSupplier.typecode;
end;

//***********************************************************
// TPullSupplier
//***********************************************************
function TPullSupplier.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PullSupplier:1.0' then
    begin
      result := Pointer(self as IPullSupplier);
      exit;
    end;
end;

class function TPullSupplier._narrow(const obj : IORBObject): IPullSupplier;
var
  p: Pointer;
  stub: TPullSupplier_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventComm/PullSupplier:1.0');
  if p <> nil then
    result := IPullSupplier(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventComm/PullSupplier:1.0') then
        begin
          stub := TPullSupplier_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TPullSupplier.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventComm/PullSupplier:1.0'
end;

//***********************************************************
// TPullSupplier_stub
//***********************************************************
function TPullSupplier_stub.pull: IAny;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_any, @result);
  req := StaticRequest(self,'pull');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_Disconnected.typecode]);
  req.invoke;
  dorb_static_throw(req,[Disconnected_marshaller, 'IDL:omg.org/CosEventComm/Disconnected:1.0']);
end;

function TPullSupplier_stub.try_pull(out has_event: Boolean): IAny;
var
  req: IStaticRequest;
  _has_event: IStaticAny;
  _result: IStaticAny;
begin
  _has_event := StaticAny(stat_boolean,@has_event);
  _result := StaticAny(stat_any, @result);
  req := StaticRequest(self,'try_pull');
  req.add_out_arg(_has_event);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_Disconnected.typecode]);
  req.invoke;
  dorb_static_throw(req,[Disconnected_marshaller, 'IDL:omg.org/CosEventComm/Disconnected:1.0']);
end;

procedure TPullSupplier_stub.disconnect_pull_supplier;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'disconnect_pull_supplier');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TPullSupplier_stub_clp
//***********************************************************
function TPullSupplier_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PullSupplier:1.0' then
    begin
      result := Pointer(self as IPullSupplier);
      exit;
  end;
end;

function TPullSupplier_stub_clp.pull: IAny;
var
  _srv: IServant;
  srv: IPullSupplier;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPullSupplier_serv._narrow(_srv);
      if srv <> nil then
        result := srv.pull
    end;
  _postinvoke();
end;

function TPullSupplier_stub_clp.try_pull(out has_event: Boolean): IAny;
var
  _srv: IServant;
  srv: IPullSupplier;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPullSupplier_serv._narrow(_srv);
      if srv <> nil then
        result := srv.try_pull(has_event)
    end;
  _postinvoke();
end;

procedure TPullSupplier_stub_clp.disconnect_pull_supplier;
var
  _srv: IServant;
  srv: IPullSupplier;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPullSupplier_serv._narrow(_srv);
      if srv <> nil then
        srv.disconnect_pull_supplier
    end;
  _postinvoke();
end;

//***********************************************************
// TPullSupplier_serv
//***********************************************************
function TPullSupplier_serv._this(): IPullSupplier;
var
  obj: IORBObject;
begin
  obj := this();
  result := TPullSupplier._narrow(obj);
end;

function TPullSupplier_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventComm/PullSupplier:1.0';
end;

function TPullSupplier_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventComm/PullSupplier:1.0';
end;

function TPullSupplier_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TPullSupplier_stub_clp.Create(poa,obj);
end;

procedure TPullSupplier_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TPullSupplier_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PullSupplier:1.0' then
    begin
      result := Pointer(IPullSupplier(self));
      exit;
    end;
end;

class function TPullSupplier_serv._narrow(const srv : IServant): IPullSupplier;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventComm/PullSupplier:1.0');
  if p <> nil then
    result := IPullSupplier(p)
end;

function TPullSupplier_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  pull_result: IAny;
  try_pull_result: IAny;
  try_pull_has_event: Boolean;
begin
  result := true;
  if req.op_name = 'pull' then
    begin
      req.set_result(StaticAny(stat_any,@pull_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Disconnected.typecode]);
      try
        pull_result := pull;
      except
        on Disconnected: TDisconnected do
          req.set_exception(TDisconnected.Create(Disconnected) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'try_pull' then
    begin
      req.add_out_arg(StaticAny(stat_boolean,@try_pull_has_event) as IStaticAny);
      req.set_result(StaticAny(stat_any,@try_pull_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Disconnected.typecode]);
      try
        try_pull_result := try_pull(try_pull_has_event);
      except
        on Disconnected: TDisconnected do
          req.set_exception(TDisconnected.Create(Disconnected) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'disconnect_pull_supplier' then
    begin
      if not req.read_args() then  exit;
      disconnect_pull_supplier;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TPullSupplier_marshaller
//***********************************************************
function TPullSupplier_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IPullSupplier(addr^) := TPullSupplier._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TPullSupplier_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IPullSupplier(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TPullSupplier_marshaller._free(var addr: Pointer);
begin
  IPullSupplier(addr^) := nil;
end;

procedure TPullSupplier_marshaller._create(var addr: Pointer);
begin
  IPullSupplier(addr^) := TPullSupplier_stub.Create();
end;

procedure TPullSupplier_marshaller._assign(dst, src: Pointer);
begin
  IPullSupplier(dst^) := IPullSupplier(src^);
end;

function TPullSupplier_marshaller.typecode: ITypeCode;
begin
  result := _tc_PullSupplier.typecode;
end;

//***********************************************************
// TPullConsumer
//***********************************************************
function TPullConsumer.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PullConsumer:1.0' then
    begin
      result := Pointer(self as IPullConsumer);
      exit;
    end;
end;

class function TPullConsumer._narrow(const obj : IORBObject): IPullConsumer;
var
  p: Pointer;
  stub: TPullConsumer_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosEventComm/PullConsumer:1.0');
  if p <> nil then
    result := IPullConsumer(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosEventComm/PullConsumer:1.0') then
        begin
          stub := TPullConsumer_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TPullConsumer.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosEventComm/PullConsumer:1.0'
end;

//***********************************************************
// TPullConsumer_stub
//***********************************************************
procedure TPullConsumer_stub.disconnect_pull_consumer;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'disconnect_pull_consumer');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TPullConsumer_stub_clp
//***********************************************************
function TPullConsumer_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PullConsumer:1.0' then
    begin
      result := Pointer(self as IPullConsumer);
      exit;
  end;
end;

procedure TPullConsumer_stub_clp.disconnect_pull_consumer;
var
  _srv: IServant;
  srv: IPullConsumer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPullConsumer_serv._narrow(_srv);
      if srv <> nil then
        srv.disconnect_pull_consumer
    end;
  _postinvoke();
end;

//***********************************************************
// TPullConsumer_serv
//***********************************************************
function TPullConsumer_serv._this(): IPullConsumer;
var
  obj: IORBObject;
begin
  obj := this();
  result := TPullConsumer._narrow(obj);
end;

function TPullConsumer_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosEventComm/PullConsumer:1.0';
end;

function TPullConsumer_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosEventComm/PullConsumer:1.0';
end;

function TPullConsumer_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TPullConsumer_stub_clp.Create(poa,obj);
end;

procedure TPullConsumer_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TPullConsumer_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosEventComm/PullConsumer:1.0' then
    begin
      result := Pointer(IPullConsumer(self));
      exit;
    end;
end;

class function TPullConsumer_serv._narrow(const srv : IServant): IPullConsumer;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosEventComm/PullConsumer:1.0');
  if p <> nil then
    result := IPullConsumer(p)
end;

function TPullConsumer_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if req.op_name = 'disconnect_pull_consumer' then
    begin
      if not req.read_args() then  exit;
      disconnect_pull_consumer;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TPullConsumer_marshaller
//***********************************************************
function TPullConsumer_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IPullConsumer(addr^) := TPullConsumer._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TPullConsumer_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IPullConsumer(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TPullConsumer_marshaller._free(var addr: Pointer);
begin
  IPullConsumer(addr^) := nil;
end;

procedure TPullConsumer_marshaller._create(var addr: Pointer);
begin
  IPullConsumer(addr^) := TPullConsumer_stub.Create();
end;

procedure TPullConsumer_marshaller._assign(dst, src: Pointer);
begin
  IPullConsumer(dst^) := IPullConsumer(src^);
end;

function TPullConsumer_marshaller.typecode: ITypeCode;
begin
  result := _tc_PullConsumer.typecode;
end;

initialization
  Disconnected_marshaller := TDisconnected_marshaller.Create();
  PushConsumer_marshaller := TPushConsumer_marshaller.Create();
  PushSupplier_marshaller := TPushSupplier_marshaller.Create();
  PullSupplier_marshaller := TPullSupplier_marshaller.Create();
  PullConsumer_marshaller := TPullConsumer_marshaller.Create();
  _tc_Disconnected := CreateTypeCodeConst('01000000160000004c000000010000002a00000049444c3a6f6d672e6f72672f436f734576656e74436f6d6d2f446973636f6e6e656374'+
    '65643a312e300000000d000000446973636f6e6e65637465640000000000000000');
  _tc_PushConsumer := CreateTypeCodeConst('010000000e00000045000000010000002a00000049444c3a6f6d672e6f72672f436f734576656e74436f6d6d2f50757368436f6e73756d'+
    '65723a312e300000000d00000050757368436f6e73756d657200');
  _tc_PushSupplier := CreateTypeCodeConst('010000000e00000045000000010000002a00000049444c3a6f6d672e6f72672f436f734576656e74436f6d6d2f50757368537570706c69'+
    '65723a312e300000000d00000050757368537570706c69657200');
  _tc_PullSupplier := CreateTypeCodeConst('010000000e00000045000000010000002a00000049444c3a6f6d672e6f72672f436f734576656e74436f6d6d2f50756c6c537570706c69'+
    '65723a312e300000000d00000050756c6c537570706c69657200');
  _tc_PullConsumer := CreateTypeCodeConst('010000000e00000045000000010000002a00000049444c3a6f6d672e6f72672f436f734576656e74436f6d6d2f50756c6c436f6e73756d'+
    '65723a312e300000000d00000050756c6c436f6e73756d657200');
end.
