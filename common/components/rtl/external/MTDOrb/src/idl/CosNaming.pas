// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -without-prefix -i..\..\idl ..\..\idl\CosNaming.idl" 
//                                                                            
unit CosNaming;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, CosNaming_int, poa_int, poa;

type

  TNameComponent_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  NameComponent_seq = Array of TNameComponent;
  PNameComponent_seq = ^NameComponent_seq;

  TNameComponent_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TBindingType_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TBinding_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  Binding_seq = Array of TBinding;
  PBinding_seq = ^Binding_seq;

  TBinding_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TNotFoundReason_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TNotFound_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosNaming/NamingContext/NotFound:1.0 } 
  TNotFound = class(UserException,INotFound)
  private
    Fwhy : TNotFoundReason;
    Frest_of_name : TName;
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
    procedure why(const val : TNotFoundReason); overload;
    procedure rest_of_name(const val : TName); overload;
  public
    function why: TNotFoundReason; overload;
    function rest_of_name: TName; overload;
    constructor Create(ex: TNotFound); overload;
    constructor Create(_why: TNotFoundReason = missing_node;_rest_of_name: TName = nil); overload;
  end;

  TCannotProceed_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0 } 
  TCannotProceed = class(UserException,ICannotProceed)
  private
    Fcxt : INamingContext;
    Frest_of_name : TName;
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
    procedure cxt(const val : INamingContext); overload;
    procedure rest_of_name(const val : TName); overload;
  public
    function cxt: INamingContext; overload;
    function rest_of_name: TName; overload;
    constructor Create(ex: TCannotProceed); overload;
    constructor Create(_cxt: INamingContext = nil;_rest_of_name: TName = nil); overload;
  end;

  TInvalidName_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0 } 
  TInvalidName = class(UserException,IInvalidName)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TInvalidName); overload;
    constructor Create(); overload;
  end;

  TAlreadyBound_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0 } 
  TAlreadyBound = class(UserException,IAlreadyBound)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TAlreadyBound); overload;
    constructor Create(); overload;
  end;

  TNotEmpty_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosNaming/NamingContext/NotEmpty:1.0 } 
  TNotEmpty = class(UserException,INotEmpty)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TNotEmpty); overload;
    constructor Create(); overload;
  end;

  {** IDL:omg.org/CosNaming/NamingContext:1.0 } 
  TNamingContext = class(TORBObject,INamingContext)
  protected
    procedure bind(const n: TName; const obj: IORBObject); virtual; abstract;
    procedure rebind(const n: TName; const obj: IORBObject); virtual; abstract;
    procedure bind_context(const n: TName; const nc: INamingContext); virtual; abstract;
    procedure rebind_context(const n: TName; const nc: INamingContext); virtual; abstract;
    function resolve(const n: TName): IORBObject; virtual; abstract;
    procedure unbind(const n: TName); virtual; abstract;
    function new_context: INamingContext; virtual; abstract;
    function bind_new_context(const n: TName): INamingContext; virtual; abstract;
    procedure _destroy; virtual; abstract;
    procedure list(const how_many: _ulong; out bl: TBindingList; out bi: IBindingIterator); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): INamingContext;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosNaming/NamingContext:1.0} 
  TNamingContext_stub = class(TNamingContext)
  protected
    procedure bind(const n: TName; const obj: IORBObject); override;
    procedure rebind(const n: TName; const obj: IORBObject); override;
    procedure bind_context(const n: TName; const nc: INamingContext); override;
    procedure rebind_context(const n: TName; const nc: INamingContext); override;
    function resolve(const n: TName): IORBObject; override;
    procedure unbind(const n: TName); override;
    function new_context: INamingContext; override;
    function bind_new_context(const n: TName): INamingContext; override;
    procedure _destroy; override;
    procedure list(const how_many: _ulong; out bl: TBindingList; out bi: IBindingIterator); override;
  end;

  {** POA stub for interface IDL:omg.org/CosNaming/NamingContext:1.0} 
  TNamingContext_stub_clp = class(TPOAStub,IPOAStub,INamingContext)
  protected
    procedure bind(const n: TName; const obj: IORBObject); virtual;
    procedure rebind(const n: TName; const obj: IORBObject); virtual;
    procedure bind_context(const n: TName; const nc: INamingContext); virtual;
    procedure rebind_context(const n: TName; const nc: INamingContext); virtual;
    function resolve(const n: TName): IORBObject; virtual;
    procedure unbind(const n: TName); virtual;
    function new_context: INamingContext; virtual;
    function bind_new_context(const n: TName): INamingContext; virtual;
    procedure _destroy; virtual;
    procedure list(const how_many: _ulong; out bl: TBindingList; out bi: IBindingIterator); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosNaming/NamingContext:1.0} 
  TNamingContext_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,INamingContext)
  protected
    procedure bind(const n: TName; const obj: IORBObject); virtual; abstract;
    procedure rebind(const n: TName; const obj: IORBObject); virtual; abstract;
    procedure bind_context(const n: TName; const nc: INamingContext); virtual; abstract;
    procedure rebind_context(const n: TName; const nc: INamingContext); virtual; abstract;
    function resolve(const n: TName): IORBObject; virtual; abstract;
    procedure unbind(const n: TName); virtual; abstract;
    function new_context: INamingContext; virtual; abstract;
    function bind_new_context(const n: TName): INamingContext; virtual; abstract;
    procedure _destroy; virtual; abstract;
    procedure list(const how_many: _ulong; out bl: TBindingList; out bi: IBindingIterator); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): INamingContext;
    class function _narrow(const srv : IServant): INamingContext;
  end;

  TNamingContext_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosNaming/BindingIterator:1.0 } 
  TBindingIterator = class(TORBObject,IBindingIterator)
  protected
    function next_one(out b: TBinding): Boolean; virtual; abstract;
    function next_n(const how_many: _ulong; out bl: TBindingList): Boolean; virtual; abstract;
    procedure _destroy; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IBindingIterator;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosNaming/BindingIterator:1.0} 
  TBindingIterator_stub = class(TBindingIterator)
  protected
    function next_one(out b: TBinding): Boolean; override;
    function next_n(const how_many: _ulong; out bl: TBindingList): Boolean; override;
    procedure _destroy; override;
  end;

  {** POA stub for interface IDL:omg.org/CosNaming/BindingIterator:1.0} 
  TBindingIterator_stub_clp = class(TPOAStub,IPOAStub,IBindingIterator)
  protected
    function next_one(out b: TBinding): Boolean; virtual;
    function next_n(const how_many: _ulong; out bl: TBindingList): Boolean; virtual;
    procedure _destroy; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosNaming/BindingIterator:1.0} 
  TBindingIterator_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IBindingIterator)
  protected
    function next_one(out b: TBinding): Boolean; virtual; abstract;
    function next_n(const how_many: _ulong; out bl: TBindingList): Boolean; virtual; abstract;
    procedure _destroy; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IBindingIterator;
    class function _narrow(const srv : IServant): IBindingIterator;
  end;

  TBindingIterator_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TInvalidAddress_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosNaming/NamingContextExt/InvalidAddress:1.0 } 
  TInvalidAddress = class(UserException,IInvalidAddress)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TInvalidAddress); overload;
    constructor Create(); overload;
  end;

  {** IDL:omg.org/CosNaming/NamingContextExt:1.0 } 
  TNamingContextExt = class(TNamingContext,INamingContextExt)
  protected
    function to_string(const n: TName): TStringName; virtual; abstract;
    function to_name(const sn: TStringName): TName; virtual; abstract;
    function to_url(const addr: TAddress; const sn: TStringName): TURLString; virtual; abstract;
    function resolve_str(const n: TStringName): IORBObject; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): INamingContextExt;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosNaming/NamingContextExt:1.0} 
  TNamingContextExt_stub = class(TNamingContextExt)
  protected
    procedure bind(const n: TName; const obj: IORBObject); override;
    procedure rebind(const n: TName; const obj: IORBObject); override;
    procedure bind_context(const n: TName; const nc: INamingContext); override;
    procedure rebind_context(const n: TName; const nc: INamingContext); override;
    function resolve(const n: TName): IORBObject; override;
    procedure unbind(const n: TName); override;
    function new_context: INamingContext; override;
    function bind_new_context(const n: TName): INamingContext; override;
    procedure _destroy; override;
    procedure list(const how_many: _ulong; out bl: TBindingList; out bi: IBindingIterator); override;
    function to_string(const n: TName): TStringName; override;
    function to_name(const sn: TStringName): TName; override;
    function to_url(const addr: TAddress; const sn: TStringName): TURLString; override;
    function resolve_str(const n: TStringName): IORBObject; override;
  end;

  {** POA stub for interface IDL:omg.org/CosNaming/NamingContextExt:1.0} 
  TNamingContextExt_stub_clp = class(TNamingContext_stub_clp,INamingContextExt)
  protected
    function to_string(const n: TName): TStringName; virtual;
    function to_name(const sn: TStringName): TName; virtual;
    function to_url(const addr: TAddress; const sn: TStringName): TURLString; virtual;
    function resolve_str(const n: TStringName): IORBObject; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosNaming/NamingContextExt:1.0} 
  TNamingContextExt_serv = class(TNamingContext_serv,INamingContextExt)
  protected
    function to_string(const n: TName): TStringName; virtual; abstract;
    function to_name(const sn: TStringName): TName; virtual; abstract;
    function to_url(const addr: TAddress; const sn: TStringName): TURLString; virtual; abstract;
    function resolve_str(const n: TStringName): IORBObject; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): INamingContextExt;
    class function _narrow(const srv : IServant): INamingContextExt;
  end;

  TNamingContextExt_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  NameComponent_marshaller : IStaticTypeInfo;
  NameComponent_seq_marshaller : IStaticTypeInfo;
  BindingType_marshaller : IStaticTypeInfo;
  Binding_marshaller : IStaticTypeInfo;
  Binding_seq_marshaller : IStaticTypeInfo;
  NotFoundReason_marshaller : IStaticTypeInfo;
  NotFound_marshaller : IStaticTypeInfo;
  CannotProceed_marshaller : IStaticTypeInfo;
  InvalidName_marshaller : IStaticTypeInfo;
  AlreadyBound_marshaller : IStaticTypeInfo;
  NotEmpty_marshaller : IStaticTypeInfo;
  NamingContext_marshaller : IStaticTypeInfo;
  BindingIterator_marshaller : IStaticTypeInfo;
  InvalidAddress_marshaller : IStaticTypeInfo;
  NamingContextExt_marshaller : IStaticTypeInfo;
  _tc_NameComponent : ITypeCodeConst;
  _tc_NameComponent_seq : ITypeCodeConst;
  _tc_BindingType : ITypeCodeConst;
  _tc_Binding : ITypeCodeConst;
  _tc_Binding_seq : ITypeCodeConst;
  _tc_NotFoundReason : ITypeCodeConst;
  _tc_NotFound : ITypeCodeConst;
  _tc_CannotProceed : ITypeCodeConst;
  _tc_InvalidName : ITypeCodeConst;
  _tc_AlreadyBound : ITypeCodeConst;
  _tc_NotEmpty : ITypeCodeConst;
  _tc_NamingContext : ITypeCodeConst;
  _tc_BindingIterator : ITypeCodeConst;
  _tc_InvalidAddress : ITypeCodeConst;
  _tc_NamingContextExt : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TNameComponent_marshaller
//***********************************************************
function TNameComponent_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: CosNaming_int.TNameComponent;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.kind) then exit;
  CosNaming_int.TNameComponent(addr^) := struct;
  result := true;
end;

procedure TNameComponent_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: CosNaming_int.TNameComponent;
begin
  struct := CosNaming_int.TNameComponent(addr^);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.kind);
end;

procedure TNameComponent_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(CosNaming_int.TNameComponent(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TNameComponent_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(CosNaming_int.TNameComponent));
{$HINTS OFF}
  System.Initialize(CosNaming_int.TNameComponent(addr^));
{$HINTS ON}
end;

procedure TNameComponent_marshaller._assign(dst, src: Pointer);
begin
  CosNaming_int.TNameComponent(dst^) := CosNaming_int.TNameComponent(src^);
end;

function TNameComponent_marshaller.typecode: ITypeCode;
begin
  result := _tc_NameComponent.typecode;
end;

//***********************************************************
// TNameComponent_seq_marshaller
//***********************************************************

function TNameComponent_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TNameComponent;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(NameComponent_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not NameComponent_marshaller.demarshal(dec,@val) then exit;
        NameComponent_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TNameComponent_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(NameComponent_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      NameComponent_marshaller.marshal(enc,@NameComponent_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TNameComponent_seq_marshaller._free(var addr: Pointer);
begin
  setLength(NameComponent_seq(addr^),0);
  freemem(addr);
end;

procedure TNameComponent_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TNameComponent_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TNameComponent_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_NameComponent_seq.typecode;
end;

//***********************************************************
// TBindingType_marshaller
//***********************************************************
function TBindingType_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TBindingType_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TBindingType_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TBindingType_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TBindingType_marshaller._assign(dst, src: Pointer);
begin
  TBindingType(dst^) := TBindingType(src^);
end;

function TBindingType_marshaller.typecode: ITypeCode;
begin
  result := _tc_BindingType.typecode;
end;

//***********************************************************
// TBinding_marshaller
//***********************************************************
function TBinding_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: CosNaming_int.TBinding;
begin
  result := false;
  if not NameComponent_seq_marshaller.demarshal(dec,@struct.binding_name) then exit;
  if not BindingType_marshaller.demarshal(dec,@struct.binding_type) then exit;
  CosNaming_int.TBinding(addr^) := struct;
  result := true;
end;

procedure TBinding_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: CosNaming_int.TBinding;
begin
  struct := CosNaming_int.TBinding(addr^);
  NameComponent_seq_marshaller.marshal(enc,@struct.binding_name);
  BindingType_marshaller.marshal(enc,@struct.binding_type);
end;

procedure TBinding_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(CosNaming_int.TBinding(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TBinding_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(CosNaming_int.TBinding));
{$HINTS OFF}
  System.Initialize(CosNaming_int.TBinding(addr^));
{$HINTS ON}
end;

procedure TBinding_marshaller._assign(dst, src: Pointer);
begin
  CosNaming_int.TBinding(dst^) := CosNaming_int.TBinding(src^);
end;

function TBinding_marshaller.typecode: ITypeCode;
begin
  result := _tc_Binding.typecode;
end;

//***********************************************************
// TBinding_seq_marshaller
//***********************************************************

function TBinding_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TBinding;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(Binding_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not Binding_marshaller.demarshal(dec,@val) then exit;
        Binding_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TBinding_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(Binding_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      Binding_marshaller.marshal(enc,@Binding_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TBinding_seq_marshaller._free(var addr: Pointer);
begin
  setLength(Binding_seq(addr^),0);
  freemem(addr);
end;

procedure TBinding_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TBinding_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TBinding_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_Binding_seq.typecode;
end;

//***********************************************************
// TNotFoundReason_marshaller
//***********************************************************
function TNotFoundReason_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TNotFoundReason_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TNotFoundReason_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TNotFoundReason_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TNotFoundReason_marshaller._assign(dst, src: Pointer);
begin
  TNotFoundReason(dst^) := TNotFoundReason(src^);
end;

function TNotFoundReason_marshaller.typecode: ITypeCode;
begin
  result := _tc_NotFoundReason.typecode;
end;

//***********************************************************
// TNotFound_marshaller
//***********************************************************
function TNotFound_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
  _why: TNotFoundReason;
  _rest_of_name: TName;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not NotFoundReason_marshaller.demarshal(dec,@_why) then exit;
  INotFound(addr^).why(_why);
  if not NameComponent_seq_marshaller.demarshal(dec,@_rest_of_name) then exit;
  INotFound(addr^).rest_of_name(_rest_of_name);
  if not dec.except_end then exit;
  result := true;
end;

procedure TNotFound_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  _why: TNotFoundReason;
  _rest_of_name: TName;
begin
  enc.except_begin('IDL:omg.org/CosNaming/NamingContext/NotFound:1.0');
  _why:= INotFound(addr^).why;
  NotFoundReason_marshaller.marshal(enc,@_why);
  _rest_of_name:= INotFound(addr^).rest_of_name;
  NameComponent_seq_marshaller.marshal(enc,@_rest_of_name);
  enc.except_end;
end;

procedure TNotFound_marshaller._free(var addr: Pointer);
begin
  INotFound(addr^) := nil;
end;

procedure TNotFound_marshaller._create(var addr: Pointer);
begin
  INotFound(addr^) := TNotFound.Create();
end;

procedure TNotFound_marshaller._assign(dst, src: Pointer);
begin
  INotFound(dst^) := INotFound(src^);
end;

function TNotFound_marshaller.typecode: ITypeCode;
begin
  result := _tc_NotFound.typecode;
end;

//***********************************************************
// TNotFound
//***********************************************************
constructor TNotFound.Create(ex: TNotFound);
begin
  Fwhy:= ex.why;
  Frest_of_name:= ex.rest_of_name;
  inherited Create();
end;

procedure TNotFound.throw;
begin
  raise TNotFound.Create(self);
end;

function TNotFound.clone(): IORBException;
begin
  result := TNotFound.Create(self);
end;

procedure TNotFound.encode(const enc: IEncoder);
var
  int : INotFound;
begin
  int := self;
  NotFound_marshaller.marshal(enc,@int);
end;

procedure TNotFound.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotFound_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TNotFound.Create(_why: TNotFoundReason;_rest_of_name: TName);
begin
  Fwhy := _why;
  Frest_of_name := _rest_of_name;
  inherited Create();
end;

function TNotFound.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0';
end;

procedure TNotFound.why(const val: TNotFoundReason);
begin
  Fwhy := val;
end;

function TNotFound.why: TNotFoundReason;
begin
  result := Fwhy;
end;

procedure TNotFound.rest_of_name(const val: TName);
begin
  Frest_of_name := val;
end;

function TNotFound.rest_of_name: TName;
begin
  result := Frest_of_name;
end;

//***********************************************************
// TCannotProceed_marshaller
//***********************************************************
function TCannotProceed_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
  _cxt: INamingContext;
  _rest_of_name: TName;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not NamingContext_marshaller.demarshal(dec,@_cxt) then exit;
  ICannotProceed(addr^).cxt(_cxt);
  if not NameComponent_seq_marshaller.demarshal(dec,@_rest_of_name) then exit;
  ICannotProceed(addr^).rest_of_name(_rest_of_name);
  if not dec.except_end then exit;
  result := true;
end;

procedure TCannotProceed_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  _cxt: INamingContext;
  _rest_of_name: TName;
begin
  enc.except_begin('IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0');
  _cxt:= ICannotProceed(addr^).cxt;
  NamingContext_marshaller.marshal(enc,@_cxt);
  _rest_of_name:= ICannotProceed(addr^).rest_of_name;
  NameComponent_seq_marshaller.marshal(enc,@_rest_of_name);
  enc.except_end;
end;

procedure TCannotProceed_marshaller._free(var addr: Pointer);
begin
  ICannotProceed(addr^) := nil;
end;

procedure TCannotProceed_marshaller._create(var addr: Pointer);
begin
  ICannotProceed(addr^) := TCannotProceed.Create();
end;

procedure TCannotProceed_marshaller._assign(dst, src: Pointer);
begin
  ICannotProceed(dst^) := ICannotProceed(src^);
end;

function TCannotProceed_marshaller.typecode: ITypeCode;
begin
  result := _tc_CannotProceed.typecode;
end;

//***********************************************************
// TCannotProceed
//***********************************************************
constructor TCannotProceed.Create(ex: TCannotProceed);
begin
  Fcxt:= ex.cxt;
  Frest_of_name:= ex.rest_of_name;
  inherited Create();
end;

procedure TCannotProceed.throw;
begin
  raise TCannotProceed.Create(self);
end;

function TCannotProceed.clone(): IORBException;
begin
  result := TCannotProceed.Create(self);
end;

procedure TCannotProceed.encode(const enc: IEncoder);
var
  int : ICannotProceed;
begin
  int := self;
  CannotProceed_marshaller.marshal(enc,@int);
end;

procedure TCannotProceed.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(CannotProceed_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TCannotProceed.Create(_cxt: INamingContext;_rest_of_name: TName);
begin
  Fcxt := _cxt;
  Frest_of_name := _rest_of_name;
  inherited Create();
end;

function TCannotProceed.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0';
end;

procedure TCannotProceed.cxt(const val: INamingContext);
begin
  Fcxt := val;
end;

function TCannotProceed.cxt: INamingContext;
begin
  result := Fcxt;
end;

procedure TCannotProceed.rest_of_name(const val: TName);
begin
  Frest_of_name := val;
end;

function TCannotProceed.rest_of_name: TName;
begin
  result := Frest_of_name;
end;

//***********************************************************
// TInvalidName_marshaller
//***********************************************************
function TInvalidName_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TInvalidName_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0');
  enc.except_end;
end;

procedure TInvalidName_marshaller._free(var addr: Pointer);
begin
  IInvalidName(addr^) := nil;
end;

procedure TInvalidName_marshaller._create(var addr: Pointer);
begin
  IInvalidName(addr^) := TInvalidName.Create();
end;

procedure TInvalidName_marshaller._assign(dst, src: Pointer);
begin
  IInvalidName(dst^) := IInvalidName(src^);
end;

function TInvalidName_marshaller.typecode: ITypeCode;
begin
  result := _tc_InvalidName.typecode;
end;

//***********************************************************
// TInvalidName
//***********************************************************
constructor TInvalidName.Create(ex: TInvalidName);
begin
  inherited Create();
end;

procedure TInvalidName.throw;
begin
  raise TInvalidName.Create(self);
end;

function TInvalidName.clone(): IORBException;
begin
  result := TInvalidName.Create(self);
end;

procedure TInvalidName.encode(const enc: IEncoder);
var
  int : IInvalidName;
begin
  int := self;
  InvalidName_marshaller.marshal(enc,@int);
end;

procedure TInvalidName.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(InvalidName_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TInvalidName.Create();
begin
  inherited Create();
end;

function TInvalidName.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0';
end;

//***********************************************************
// TAlreadyBound_marshaller
//***********************************************************
function TAlreadyBound_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TAlreadyBound_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0');
  enc.except_end;
end;

procedure TAlreadyBound_marshaller._free(var addr: Pointer);
begin
  IAlreadyBound(addr^) := nil;
end;

procedure TAlreadyBound_marshaller._create(var addr: Pointer);
begin
  IAlreadyBound(addr^) := TAlreadyBound.Create();
end;

procedure TAlreadyBound_marshaller._assign(dst, src: Pointer);
begin
  IAlreadyBound(dst^) := IAlreadyBound(src^);
end;

function TAlreadyBound_marshaller.typecode: ITypeCode;
begin
  result := _tc_AlreadyBound.typecode;
end;

//***********************************************************
// TAlreadyBound
//***********************************************************
constructor TAlreadyBound.Create(ex: TAlreadyBound);
begin
  inherited Create();
end;

procedure TAlreadyBound.throw;
begin
  raise TAlreadyBound.Create(self);
end;

function TAlreadyBound.clone(): IORBException;
begin
  result := TAlreadyBound.Create(self);
end;

procedure TAlreadyBound.encode(const enc: IEncoder);
var
  int : IAlreadyBound;
begin
  int := self;
  AlreadyBound_marshaller.marshal(enc,@int);
end;

procedure TAlreadyBound.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(AlreadyBound_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TAlreadyBound.Create();
begin
  inherited Create();
end;

function TAlreadyBound.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0';
end;

//***********************************************************
// TNotEmpty_marshaller
//***********************************************************
function TNotEmpty_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TNotEmpty_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosNaming/NamingContext/NotEmpty:1.0');
  enc.except_end;
end;

procedure TNotEmpty_marshaller._free(var addr: Pointer);
begin
  INotEmpty(addr^) := nil;
end;

procedure TNotEmpty_marshaller._create(var addr: Pointer);
begin
  INotEmpty(addr^) := TNotEmpty.Create();
end;

procedure TNotEmpty_marshaller._assign(dst, src: Pointer);
begin
  INotEmpty(dst^) := INotEmpty(src^);
end;

function TNotEmpty_marshaller.typecode: ITypeCode;
begin
  result := _tc_NotEmpty.typecode;
end;

//***********************************************************
// TNotEmpty
//***********************************************************
constructor TNotEmpty.Create(ex: TNotEmpty);
begin
  inherited Create();
end;

procedure TNotEmpty.throw;
begin
  raise TNotEmpty.Create(self);
end;

function TNotEmpty.clone(): IORBException;
begin
  result := TNotEmpty.Create(self);
end;

procedure TNotEmpty.encode(const enc: IEncoder);
var
  int : INotEmpty;
begin
  int := self;
  NotEmpty_marshaller.marshal(enc,@int);
end;

procedure TNotEmpty.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotEmpty_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TNotEmpty.Create();
begin
  inherited Create();
end;

function TNotEmpty.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/NamingContext/NotEmpty:1.0';
end;

//***********************************************************
// TNamingContext
//***********************************************************
function TNamingContext.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosNaming/NamingContext:1.0' then
    begin
      result := Pointer(self as INamingContext);
      exit;
    end;
end;

class function TNamingContext._narrow(const obj : IORBObject): INamingContext;
var
  p: Pointer;
  stub: TNamingContext_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosNaming/NamingContext:1.0');
  if p <> nil then
    result := INamingContext(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosNaming/NamingContext:1.0') then
        begin
          stub := TNamingContext_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TNamingContext.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosNaming/NamingContext:1.0'
end;

//***********************************************************
// TNamingContext_stub
//***********************************************************
procedure TNamingContext_stub.bind(const n: TName; const obj: IORBObject);
var
  req: IStaticRequest;
  _n: IStaticAny;
  _obj: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _obj := StaticAny(stat_object,@obj);
  req := StaticRequest(self,'bind');
  req.add_in_arg(_n);
  req.add_in_arg(_obj);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode, _tc_AlreadyBound.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0', AlreadyBound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0']);
end;

procedure TNamingContext_stub.rebind(const n: TName; const obj: IORBObject);
var
  req: IStaticRequest;
  _n: IStaticAny;
  _obj: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _obj := StaticAny(stat_object,@obj);
  req := StaticRequest(self,'rebind');
  req.add_in_arg(_n);
  req.add_in_arg(_obj);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

procedure TNamingContext_stub.bind_context(const n: TName; const nc: INamingContext);
var
  req: IStaticRequest;
  _n: IStaticAny;
  _nc: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _nc := StaticAny(NamingContext_marshaller,@nc);
  req := StaticRequest(self,'bind_context');
  req.add_in_arg(_n);
  req.add_in_arg(_nc);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode, _tc_AlreadyBound.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0', AlreadyBound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0']);
end;

procedure TNamingContext_stub.rebind_context(const n: TName; const nc: INamingContext);
var
  req: IStaticRequest;
  _n: IStaticAny;
  _nc: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _nc := StaticAny(NamingContext_marshaller,@nc);
  req := StaticRequest(self,'rebind_context');
  req.add_in_arg(_n);
  req.add_in_arg(_nc);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

function TNamingContext_stub.resolve(const n: TName): IORBObject;
var
  req: IStaticRequest;
  _n: IStaticAny;
  _result: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _result := StaticAny(stat_object, @result);
  req := StaticRequest(self,'resolve');
  req.add_in_arg(_n);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

procedure TNamingContext_stub.unbind(const n: TName);
var
  req: IStaticRequest;
  _n: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  req := StaticRequest(self,'unbind');
  req.add_in_arg(_n);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

function TNamingContext_stub.new_context: INamingContext;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(NamingContext_marshaller, @result);
  req := StaticRequest(self,'new_context');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TNamingContext_stub.bind_new_context(const n: TName): INamingContext;
var
  req: IStaticRequest;
  _n: IStaticAny;
  _result: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _result := StaticAny(NamingContext_marshaller, @result);
  req := StaticRequest(self,'bind_new_context');
  req.add_in_arg(_n);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_AlreadyBound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', AlreadyBound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

procedure TNamingContext_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.set_exceptions_tc([_tc_NotEmpty.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotEmpty_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotEmpty:1.0']);
end;

procedure TNamingContext_stub.list(const how_many: _ulong; out bl: TBindingList; out bi: IBindingIterator);
var
  req: IStaticRequest;
  _how_many: IStaticAny;
  _bl: IStaticAny;
  _bi: IStaticAny;
begin
  _how_many := StaticAny(stat_ulong,@how_many);
  _bl := StaticAny(Binding_seq_marshaller,@bl);
  _bi := StaticAny(BindingIterator_marshaller,@bi);
  req := StaticRequest(self,'list');
  req.add_in_arg(_how_many);
  req.add_out_arg(_bl);
  req.add_out_arg(_bi);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TNamingContext_stub_clp
//***********************************************************
function TNamingContext_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosNaming/NamingContext:1.0' then
    begin
      result := Pointer(self as INamingContext);
      exit;
  end;
end;

procedure TNamingContext_stub_clp.bind(const n: TName; const obj: IORBObject);
var
  _srv: IServant;
  srv: INamingContext;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        srv.bind(n, obj)
    end;
  _postinvoke();
end;

procedure TNamingContext_stub_clp.rebind(const n: TName; const obj: IORBObject);
var
  _srv: IServant;
  srv: INamingContext;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        srv.rebind(n, obj)
    end;
  _postinvoke();
end;

procedure TNamingContext_stub_clp.bind_context(const n: TName; const nc: INamingContext);
var
  _srv: IServant;
  srv: INamingContext;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        srv.bind_context(n, nc)
    end;
  _postinvoke();
end;

procedure TNamingContext_stub_clp.rebind_context(const n: TName; const nc: INamingContext);
var
  _srv: IServant;
  srv: INamingContext;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        srv.rebind_context(n, nc)
    end;
  _postinvoke();
end;

function TNamingContext_stub_clp.resolve(const n: TName): IORBObject;
var
  _srv: IServant;
  srv: INamingContext;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        result := srv.resolve(n)
    end;
  _postinvoke();
end;

procedure TNamingContext_stub_clp.unbind(const n: TName);
var
  _srv: IServant;
  srv: INamingContext;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        srv.unbind(n)
    end;
  _postinvoke();
end;

function TNamingContext_stub_clp.new_context: INamingContext;
var
  _srv: IServant;
  srv: INamingContext;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        result := srv.new_context
    end;
  _postinvoke();
end;

function TNamingContext_stub_clp.bind_new_context(const n: TName): INamingContext;
var
  _srv: IServant;
  srv: INamingContext;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        result := srv.bind_new_context(n)
    end;
  _postinvoke();
end;

procedure TNamingContext_stub_clp._destroy;
var
  _srv: IServant;
  srv: INamingContext;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        srv._destroy
    end;
  _postinvoke();
end;

procedure TNamingContext_stub_clp.list(const how_many: _ulong; out bl: TBindingList; out bi: IBindingIterator);
var
  _srv: IServant;
  srv: INamingContext;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContext_serv._narrow(_srv);
      if srv <> nil then
        srv.list(how_many, bl, bi)
    end;
  _postinvoke();
end;

//***********************************************************
// TNamingContext_serv
//***********************************************************
function TNamingContext_serv._this(): INamingContext;
var
  obj: IORBObject;
begin
  obj := this();
  result := TNamingContext._narrow(obj);
end;

function TNamingContext_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosNaming/NamingContext:1.0';
end;

function TNamingContext_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/NamingContext:1.0';
end;

function TNamingContext_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TNamingContext_stub_clp.Create(poa,obj);
end;

procedure TNamingContext_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TNamingContext_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosNaming/NamingContext:1.0' then
    begin
      result := Pointer(INamingContext(self));
      exit;
    end;
end;

class function TNamingContext_serv._narrow(const srv : IServant): INamingContext;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosNaming/NamingContext:1.0');
  if p <> nil then
    result := INamingContext(p)
end;

function TNamingContext_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  bind_n: TName;
  bind_obj: IORBObject;
  rebind_n: TName;
  rebind_obj: IORBObject;
  bind_context_n: TName;
  bind_context_nc: INamingContext;
  rebind_context_n: TName;
  rebind_context_nc: INamingContext;
  resolve_result: IORBObject;
  resolve_n: TName;
  unbind_n: TName;
  new_context_result: INamingContext;
  bind_new_context_result: INamingContext;
  bind_new_context_n: TName;
  list_how_many: _ulong;
  list_bl: TBindingList;
  list_bi: IBindingIterator;
begin
  result := true;
  if req.op_name = 'bind' then
    begin
      req.add_in_arg(StaticAny(NameComponent_seq_marshaller,@bind_n) as IStaticAny);
      req.add_in_arg(StaticAny(stat_object,@bind_obj) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode, _tc_AlreadyBound.typecode]);
      try
        bind(bind_n, bind_obj);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
        on CannotProceed: TCannotProceed do
          req.set_exception(TCannotProceed.Create(CannotProceed) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
        on AlreadyBound: TAlreadyBound do
          req.set_exception(TAlreadyBound.Create(AlreadyBound) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'rebind' then
    begin
      req.add_in_arg(StaticAny(NameComponent_seq_marshaller,@rebind_n) as IStaticAny);
      req.add_in_arg(StaticAny(stat_object,@rebind_obj) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
      try
        rebind(rebind_n, rebind_obj);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
        on CannotProceed: TCannotProceed do
          req.set_exception(TCannotProceed.Create(CannotProceed) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'bind_context' then
    begin
      req.add_in_arg(StaticAny(NameComponent_seq_marshaller,@bind_context_n) as IStaticAny);
      req.add_in_arg(StaticAny(NamingContext_marshaller,@bind_context_nc) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode, _tc_AlreadyBound.typecode]);
      try
        bind_context(bind_context_n, bind_context_nc);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
        on CannotProceed: TCannotProceed do
          req.set_exception(TCannotProceed.Create(CannotProceed) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
        on AlreadyBound: TAlreadyBound do
          req.set_exception(TAlreadyBound.Create(AlreadyBound) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'rebind_context' then
    begin
      req.add_in_arg(StaticAny(NameComponent_seq_marshaller,@rebind_context_n) as IStaticAny);
      req.add_in_arg(StaticAny(NamingContext_marshaller,@rebind_context_nc) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
      try
        rebind_context(rebind_context_n, rebind_context_nc);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
        on CannotProceed: TCannotProceed do
          req.set_exception(TCannotProceed.Create(CannotProceed) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'resolve' then
    begin
      req.add_in_arg(StaticAny(NameComponent_seq_marshaller,@resolve_n) as IStaticAny);
      req.set_result(StaticAny(stat_object,@resolve_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
      try
        resolve_result := resolve(resolve_n);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
        on CannotProceed: TCannotProceed do
          req.set_exception(TCannotProceed.Create(CannotProceed) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'unbind' then
    begin
      req.add_in_arg(StaticAny(NameComponent_seq_marshaller,@unbind_n) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
      try
        unbind(unbind_n);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
        on CannotProceed: TCannotProceed do
          req.set_exception(TCannotProceed.Create(CannotProceed) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'new_context' then
    begin
      req.set_result(StaticAny(NamingContext_marshaller,@new_context_result) as IStaticAny);
      if not req.read_args() then  exit;
      new_context_result := new_context;
      req.write_results();
      exit;
    end
  else if req.op_name = 'bind_new_context' then
    begin
      req.add_in_arg(StaticAny(NameComponent_seq_marshaller,@bind_new_context_n) as IStaticAny);
      req.set_result(StaticAny(NamingContext_marshaller,@bind_new_context_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode, _tc_AlreadyBound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
      try
        bind_new_context_result := bind_new_context(bind_new_context_n);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
        on AlreadyBound: TAlreadyBound do
          req.set_exception(TAlreadyBound.Create(AlreadyBound) as IORBException);
        on CannotProceed: TCannotProceed do
          req.set_exception(TCannotProceed.Create(CannotProceed) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'destroy' then
    begin
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotEmpty.typecode]);
      try
        _destroy;
      except
        on NotEmpty: TNotEmpty do
          req.set_exception(TNotEmpty.Create(NotEmpty) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'list' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@list_how_many) as IStaticAny);
      req.add_out_arg(StaticAny(Binding_seq_marshaller,@list_bl) as IStaticAny);
      req.add_out_arg(StaticAny(BindingIterator_marshaller,@list_bi) as IStaticAny);
      if not req.read_args() then  exit;
      list(list_how_many, list_bl, list_bi);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TNamingContext_marshaller
//***********************************************************
function TNamingContext_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  INamingContext(addr^) := TNamingContext._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TNamingContext_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := INamingContext(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TNamingContext_marshaller._free(var addr: Pointer);
begin
  INamingContext(addr^) := nil;
end;

procedure TNamingContext_marshaller._create(var addr: Pointer);
begin
  INamingContext(addr^) := TNamingContext_stub.Create();
end;

procedure TNamingContext_marshaller._assign(dst, src: Pointer);
begin
  INamingContext(dst^) := INamingContext(src^);
end;

function TNamingContext_marshaller.typecode: ITypeCode;
begin
  result := _tc_NamingContext.typecode;
end;

//***********************************************************
// TBindingIterator
//***********************************************************
function TBindingIterator.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosNaming/BindingIterator:1.0' then
    begin
      result := Pointer(self as IBindingIterator);
      exit;
    end;
end;

class function TBindingIterator._narrow(const obj : IORBObject): IBindingIterator;
var
  p: Pointer;
  stub: TBindingIterator_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosNaming/BindingIterator:1.0');
  if p <> nil then
    result := IBindingIterator(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosNaming/BindingIterator:1.0') then
        begin
          stub := TBindingIterator_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TBindingIterator.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosNaming/BindingIterator:1.0'
end;

//***********************************************************
// TBindingIterator_stub
//***********************************************************
function TBindingIterator_stub.next_one(out b: TBinding): Boolean;
var
  req: IStaticRequest;
  _b: IStaticAny;
  _result: IStaticAny;
begin
  _b := StaticAny(Binding_marshaller,@b);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'next_one');
  req.add_out_arg(_b);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TBindingIterator_stub.next_n(const how_many: _ulong; out bl: TBindingList): Boolean;
var
  req: IStaticRequest;
  _how_many: IStaticAny;
  _bl: IStaticAny;
  _result: IStaticAny;
begin
  _how_many := StaticAny(stat_ulong,@how_many);
  _bl := StaticAny(Binding_seq_marshaller,@bl);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'next_n');
  req.add_in_arg(_how_many);
  req.add_out_arg(_bl);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TBindingIterator_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TBindingIterator_stub_clp
//***********************************************************
function TBindingIterator_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosNaming/BindingIterator:1.0' then
    begin
      result := Pointer(self as IBindingIterator);
      exit;
  end;
end;

function TBindingIterator_stub_clp.next_one(out b: TBinding): Boolean;
var
  _srv: IServant;
  srv: IBindingIterator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBindingIterator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.next_one(b)
    end;
  _postinvoke();
end;

function TBindingIterator_stub_clp.next_n(const how_many: _ulong; out bl: TBindingList): Boolean;
var
  _srv: IServant;
  srv: IBindingIterator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBindingIterator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.next_n(how_many, bl)
    end;
  _postinvoke();
end;

procedure TBindingIterator_stub_clp._destroy;
var
  _srv: IServant;
  srv: IBindingIterator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TBindingIterator_serv._narrow(_srv);
      if srv <> nil then
        srv._destroy
    end;
  _postinvoke();
end;

//***********************************************************
// TBindingIterator_serv
//***********************************************************
function TBindingIterator_serv._this(): IBindingIterator;
var
  obj: IORBObject;
begin
  obj := this();
  result := TBindingIterator._narrow(obj);
end;

function TBindingIterator_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosNaming/BindingIterator:1.0';
end;

function TBindingIterator_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/BindingIterator:1.0';
end;

function TBindingIterator_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TBindingIterator_stub_clp.Create(poa,obj);
end;

procedure TBindingIterator_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TBindingIterator_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosNaming/BindingIterator:1.0' then
    begin
      result := Pointer(IBindingIterator(self));
      exit;
    end;
end;

class function TBindingIterator_serv._narrow(const srv : IServant): IBindingIterator;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosNaming/BindingIterator:1.0');
  if p <> nil then
    result := IBindingIterator(p)
end;

function TBindingIterator_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  next_one_result: Boolean;
  next_one_b: TBinding;
  next_n_result: Boolean;
  next_n_how_many: _ulong;
  next_n_bl: TBindingList;
begin
  result := true;
  if req.op_name = 'next_one' then
    begin
      req.add_out_arg(StaticAny(Binding_marshaller,@next_one_b) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@next_one_result) as IStaticAny);
      if not req.read_args() then  exit;
      next_one_result := next_one(next_one_b);
      req.write_results();
      exit;
    end
  else if req.op_name = 'next_n' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@next_n_how_many) as IStaticAny);
      req.add_out_arg(StaticAny(Binding_seq_marshaller,@next_n_bl) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@next_n_result) as IStaticAny);
      if not req.read_args() then  exit;
      next_n_result := next_n(next_n_how_many, next_n_bl);
      req.write_results();
      exit;
    end
  else if req.op_name = 'destroy' then
    begin
      if not req.read_args() then  exit;
      _destroy;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TBindingIterator_marshaller
//***********************************************************
function TBindingIterator_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IBindingIterator(addr^) := TBindingIterator._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TBindingIterator_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IBindingIterator(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TBindingIterator_marshaller._free(var addr: Pointer);
begin
  IBindingIterator(addr^) := nil;
end;

procedure TBindingIterator_marshaller._create(var addr: Pointer);
begin
  IBindingIterator(addr^) := TBindingIterator_stub.Create();
end;

procedure TBindingIterator_marshaller._assign(dst, src: Pointer);
begin
  IBindingIterator(dst^) := IBindingIterator(src^);
end;

function TBindingIterator_marshaller.typecode: ITypeCode;
begin
  result := _tc_BindingIterator.typecode;
end;

//***********************************************************
// TInvalidAddress_marshaller
//***********************************************************
function TInvalidAddress_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TInvalidAddress_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosNaming/NamingContextExt/InvalidAddress:1.0');
  enc.except_end;
end;

procedure TInvalidAddress_marshaller._free(var addr: Pointer);
begin
  IInvalidAddress(addr^) := nil;
end;

procedure TInvalidAddress_marshaller._create(var addr: Pointer);
begin
  IInvalidAddress(addr^) := TInvalidAddress.Create();
end;

procedure TInvalidAddress_marshaller._assign(dst, src: Pointer);
begin
  IInvalidAddress(dst^) := IInvalidAddress(src^);
end;

function TInvalidAddress_marshaller.typecode: ITypeCode;
begin
  result := _tc_InvalidAddress.typecode;
end;

//***********************************************************
// TInvalidAddress
//***********************************************************
constructor TInvalidAddress.Create(ex: TInvalidAddress);
begin
  inherited Create();
end;

procedure TInvalidAddress.throw;
begin
  raise TInvalidAddress.Create(self);
end;

function TInvalidAddress.clone(): IORBException;
begin
  result := TInvalidAddress.Create(self);
end;

procedure TInvalidAddress.encode(const enc: IEncoder);
var
  int : IInvalidAddress;
begin
  int := self;
  InvalidAddress_marshaller.marshal(enc,@int);
end;

procedure TInvalidAddress.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(InvalidAddress_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TInvalidAddress.Create();
begin
  inherited Create();
end;

function TInvalidAddress.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/NamingContextExt/InvalidAddress:1.0';
end;

//***********************************************************
// TNamingContextExt
//***********************************************************
function TNamingContextExt.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosNaming/NamingContextExt:1.0' then
    begin
      result := Pointer(self as INamingContextExt);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TNamingContextExt._narrow(const obj : IORBObject): INamingContextExt;
var
  p: Pointer;
  stub: TNamingContextExt_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosNaming/NamingContextExt:1.0');
  if p <> nil then
    result := INamingContextExt(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosNaming/NamingContextExt:1.0') then
        begin
          stub := TNamingContextExt_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TNamingContextExt.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosNaming/NamingContextExt:1.0'
end;

//***********************************************************
// TNamingContextExt_stub
//***********************************************************
procedure TNamingContextExt_stub.bind(const n: TName; const obj: IORBObject);
var
  req: IStaticRequest;
  _n: IStaticAny;
  _obj: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _obj := StaticAny(stat_object,@obj);
  req := StaticRequest(self,'bind');
  req.add_in_arg(_n);
  req.add_in_arg(_obj);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode, _tc_AlreadyBound.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0', AlreadyBound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0']);
end;

procedure TNamingContextExt_stub.rebind(const n: TName; const obj: IORBObject);
var
  req: IStaticRequest;
  _n: IStaticAny;
  _obj: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _obj := StaticAny(stat_object,@obj);
  req := StaticRequest(self,'rebind');
  req.add_in_arg(_n);
  req.add_in_arg(_obj);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

procedure TNamingContextExt_stub.bind_context(const n: TName; const nc: INamingContext);
var
  req: IStaticRequest;
  _n: IStaticAny;
  _nc: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _nc := StaticAny(NamingContext_marshaller,@nc);
  req := StaticRequest(self,'bind_context');
  req.add_in_arg(_n);
  req.add_in_arg(_nc);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode, _tc_AlreadyBound.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0', AlreadyBound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0']);
end;

procedure TNamingContextExt_stub.rebind_context(const n: TName; const nc: INamingContext);
var
  req: IStaticRequest;
  _n: IStaticAny;
  _nc: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _nc := StaticAny(NamingContext_marshaller,@nc);
  req := StaticRequest(self,'rebind_context');
  req.add_in_arg(_n);
  req.add_in_arg(_nc);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

function TNamingContextExt_stub.resolve(const n: TName): IORBObject;
var
  req: IStaticRequest;
  _n: IStaticAny;
  _result: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _result := StaticAny(stat_object, @result);
  req := StaticRequest(self,'resolve');
  req.add_in_arg(_n);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

procedure TNamingContextExt_stub.unbind(const n: TName);
var
  req: IStaticRequest;
  _n: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  req := StaticRequest(self,'unbind');
  req.add_in_arg(_n);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

function TNamingContextExt_stub.new_context: INamingContext;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(NamingContext_marshaller, @result);
  req := StaticRequest(self,'new_context');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TNamingContextExt_stub.bind_new_context(const n: TName): INamingContext;
var
  req: IStaticRequest;
  _n: IStaticAny;
  _result: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _result := StaticAny(NamingContext_marshaller, @result);
  req := StaticRequest(self,'bind_new_context');
  req.add_in_arg(_n);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_AlreadyBound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', AlreadyBound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

procedure TNamingContextExt_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.set_exceptions_tc([_tc_NotEmpty.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotEmpty_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotEmpty:1.0']);
end;

procedure TNamingContextExt_stub.list(const how_many: _ulong; out bl: TBindingList; out bi: IBindingIterator);
var
  req: IStaticRequest;
  _how_many: IStaticAny;
  _bl: IStaticAny;
  _bi: IStaticAny;
begin
  _how_many := StaticAny(stat_ulong,@how_many);
  _bl := StaticAny(Binding_seq_marshaller,@bl);
  _bi := StaticAny(BindingIterator_marshaller,@bi);
  req := StaticRequest(self,'list');
  req.add_in_arg(_how_many);
  req.add_out_arg(_bl);
  req.add_out_arg(_bi);
  req.invoke;
  dorb_static_throw(req);
end;

function TNamingContextExt_stub.to_string(const n: TName): TStringName;
var
  req: IStaticRequest;
  _n: IStaticAny;
  _result: IStaticAny;
begin
  _n := StaticAny(NameComponent_seq_marshaller,@n);
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'to_string');
  req.add_in_arg(_n);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

function TNamingContextExt_stub.to_name(const sn: TStringName): TName;
var
  req: IStaticRequest;
  _sn: IStaticAny;
  _result: IStaticAny;
begin
  _sn := StaticAny(stat_string,@sn);
  _result := StaticAny(NameComponent_seq_marshaller, @result);
  req := StaticRequest(self,'to_name');
  req.add_in_arg(_sn);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

function TNamingContextExt_stub.to_url(const addr: TAddress; const sn: TStringName): TURLString;
var
  req: IStaticRequest;
  _addr: IStaticAny;
  _sn: IStaticAny;
  _result: IStaticAny;
begin
  _addr := StaticAny(stat_string,@addr);
  _sn := StaticAny(stat_string,@sn);
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'to_url');
  req.add_in_arg(_addr);
  req.add_in_arg(_sn);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_InvalidAddress.typecode, _tc_InvalidName.typecode]);
  req.invoke;
  dorb_static_throw(req,[InvalidAddress_marshaller, 'IDL:omg.org/CosNaming/NamingContextExt/InvalidAddress:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0']);
end;

function TNamingContextExt_stub.resolve_str(const n: TStringName): IORBObject;
var
  req: IStaticRequest;
  _n: IStaticAny;
  _result: IStaticAny;
begin
  _n := StaticAny(stat_string,@n);
  _result := StaticAny(stat_object, @result);
  req := StaticRequest(self,'resolve_str');
  req.add_in_arg(_n);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode, _tc_AlreadyBound.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotFound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/NotFound:1.0', CannotProceed_marshaller, 'IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0', InvalidName_marshaller, 'IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0', AlreadyBound_marshaller, 'IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0']);
end;

//***********************************************************
// TNamingContextExt_stub_clp
//***********************************************************
function TNamingContextExt_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosNaming/NamingContextExt:1.0' then
    begin
      result := Pointer(self as INamingContextExt);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TNamingContextExt_stub_clp.to_string(const n: TName): TStringName;
var
  _srv: IServant;
  srv: INamingContextExt;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContextExt_serv._narrow(_srv);
      if srv <> nil then
        result := srv.to_string(n)
    end;
  _postinvoke();
end;

function TNamingContextExt_stub_clp.to_name(const sn: TStringName): TName;
var
  _srv: IServant;
  srv: INamingContextExt;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContextExt_serv._narrow(_srv);
      if srv <> nil then
        result := srv.to_name(sn)
    end;
  _postinvoke();
end;

function TNamingContextExt_stub_clp.to_url(const addr: TAddress; const sn: TStringName): TURLString;
var
  _srv: IServant;
  srv: INamingContextExt;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContextExt_serv._narrow(_srv);
      if srv <> nil then
        result := srv.to_url(addr, sn)
    end;
  _postinvoke();
end;

function TNamingContextExt_stub_clp.resolve_str(const n: TStringName): IORBObject;
var
  _srv: IServant;
  srv: INamingContextExt;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TNamingContextExt_serv._narrow(_srv);
      if srv <> nil then
        result := srv.resolve_str(n)
    end;
  _postinvoke();
end;

//***********************************************************
// TNamingContextExt_serv
//***********************************************************
function TNamingContextExt_serv._this(): INamingContextExt;
var
  obj: IORBObject;
begin
  obj := this();
  result := TNamingContextExt._narrow(obj);
end;

function TNamingContextExt_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosNaming/NamingContextExt:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TNamingContextExt_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosNaming/NamingContextExt:1.0';
end;

function TNamingContextExt_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TNamingContextExt_stub_clp.Create(poa,obj);
end;

procedure TNamingContextExt_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TNamingContextExt_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosNaming/NamingContextExt:1.0' then
    begin
      result := Pointer(INamingContextExt(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TNamingContextExt_serv._narrow(const srv : IServant): INamingContextExt;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosNaming/NamingContextExt:1.0');
  if p <> nil then
    result := INamingContextExt(p)
end;

function TNamingContextExt_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  to_string_result: TStringName;
  to_string_n: TName;
  to_name_result: TName;
  to_name_sn: TStringName;
  to_url_result: TURLString;
  to_url_addr: TAddress;
  to_url_sn: TStringName;
  resolve_str_result: IORBObject;
  resolve_str_n: TStringName;
begin
  result := true;
  if req.op_name = 'to_string' then
    begin
      req.add_in_arg(StaticAny(NameComponent_seq_marshaller,@to_string_n) as IStaticAny);
      req.set_result(StaticAny(stat_string,@to_string_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_InvalidName.typecode]);
      try
        to_string_result := to_string(to_string_n);
      except
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'to_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@to_name_sn) as IStaticAny);
      req.set_result(StaticAny(NameComponent_seq_marshaller,@to_name_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_InvalidName.typecode]);
      try
        to_name_result := to_name(to_name_sn);
      except
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'to_url' then
    begin
      req.add_in_arg(StaticAny(stat_string,@to_url_addr) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@to_url_sn) as IStaticAny);
      req.set_result(StaticAny(stat_string,@to_url_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_InvalidAddress.typecode, _tc_InvalidName.typecode]);
      try
        to_url_result := to_url(to_url_addr, to_url_sn);
      except
        on InvalidAddress: TInvalidAddress do
          req.set_exception(TInvalidAddress.Create(InvalidAddress) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'resolve_str' then
    begin
      req.add_in_arg(StaticAny(stat_string,@resolve_str_n) as IStaticAny);
      req.set_result(StaticAny(stat_object,@resolve_str_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotFound.typecode, _tc_CannotProceed.typecode, _tc_InvalidName.typecode, _tc_AlreadyBound.typecode]);
      try
        resolve_str_result := resolve_str(resolve_str_n);
      except
        on NotFound: TNotFound do
          req.set_exception(TNotFound.Create(NotFound) as IORBException);
        on CannotProceed: TCannotProceed do
          req.set_exception(TCannotProceed.Create(CannotProceed) as IORBException);
        on InvalidName: TInvalidName do
          req.set_exception(TInvalidName.Create(InvalidName) as IORBException);
        on AlreadyBound: TAlreadyBound do
          req.set_exception(TAlreadyBound.Create(AlreadyBound) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TNamingContextExt_marshaller
//***********************************************************
function TNamingContextExt_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  INamingContextExt(addr^) := TNamingContextExt._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TNamingContextExt_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := INamingContextExt(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TNamingContextExt_marshaller._free(var addr: Pointer);
begin
  INamingContextExt(addr^) := nil;
end;

procedure TNamingContextExt_marshaller._create(var addr: Pointer);
begin
  INamingContextExt(addr^) := TNamingContextExt_stub.Create();
end;

procedure TNamingContextExt_marshaller._assign(dst, src: Pointer);
begin
  INamingContextExt(dst^) := INamingContextExt(src^);
end;

function TNamingContextExt_marshaller.typecode: ITypeCode;
begin
  result := _tc_NamingContextExt.typecode;
end;

initialization
  NameComponent_marshaller := TNameComponent_marshaller.Create();
  NameComponent_seq_marshaller := TNameComponent_seq_marshaller.Create();
  BindingType_marshaller := TBindingType_marshaller.Create();
  Binding_marshaller := TBinding_marshaller.Create();
  Binding_seq_marshaller := TBinding_seq_marshaller.Create();
  NotFoundReason_marshaller := TNotFoundReason_marshaller.Create();
  NotFound_marshaller := TNotFound_marshaller.Create();
  CannotProceed_marshaller := TCannotProceed_marshaller.Create();
  InvalidName_marshaller := TInvalidName_marshaller.Create();
  AlreadyBound_marshaller := TAlreadyBound_marshaller.Create();
  NotEmpty_marshaller := TNotEmpty_marshaller.Create();
  NamingContext_marshaller := TNamingContext_marshaller.Create();
  BindingIterator_marshaller := TBindingIterator_marshaller.Create();
  InvalidAddress_marshaller := TInvalidAddress_marshaller.Create();
  NamingContextExt_marshaller := TNamingContextExt_marshaller.Create();
  _tc_NameComponent := CreateTypeCodeConst('010000000f000000ec000000010000002800000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d65436f6d706f6e656e74'+
    '3a312e30000e0000004e616d65436f6d706f6e656e74000000020000000300000069640000150000004000000001000000220000004944'+
    '4c3a6f6d672e6f72672f436f734e616d696e672f49737472696e673a312e300000000800000049737472696e6700120000000000000005'+
    '0000006b696e64000000001500000040000000010000002200000049444c3a6f6d672e6f72672f436f734e616d696e672f49737472696e'+
    '673a312e300000000800000049737472696e67001200000000000000');
  _tc_NameComponent_seq := CreateTypeCodeConst('0100000013000000fc000000010000000f000000ec000000010000002800000049444c3a6f6d672e6f72672f436f734e616d696e672f4e'+
    '616d65436f6d706f6e656e743a312e30000e0000004e616d65436f6d706f6e656e74000000020000000300000069640000150000004000'+
    '0000010000002200000049444c3a6f6d672e6f72672f436f734e616d696e672f49737472696e673a312e30000000080000004973747269'+
    '6e67001200000000000000050000006b696e64000000001500000040000000010000002200000049444c3a6f6d672e6f72672f436f734e'+
    '616d696e672f49737472696e673a312e300000000800000049737472696e6700120000000000000000000000');
  _tc_BindingType := CreateTypeCodeConst('01000000110000005d000000010000002600000049444c3a6f6d672e6f72672f436f734e616d696e672f42696e64696e67547970653a31'+
    '2e300000000c00000042696e64696e67547970650002000000080000006e6f626a65637400090000006e636f6e7465787400');
  _tc_Binding := CreateTypeCodeConst('010000000f00000009020000010000002200000049444c3a6f6d672e6f72672f436f734e616d696e672f42696e64696e673a312e300000'+
    '000800000042696e64696e6700020000000d00000062696e64696e675f6e616d65000000001500000038010000010000001f0000004944'+
    '4c3a6f6d672e6f72672f436f734e616d696e672f4e616d653a312e300000050000004e616d650000000013000000fc000000010000000f'+
    '000000ec000000010000002800000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d65436f6d706f6e656e743a312e3000'+
    '0e0000004e616d65436f6d706f6e656e740000000200000003000000696400001500000040000000010000002200000049444c3a6f6d67'+
    '2e6f72672f436f734e616d696e672f49737472696e673a312e300000000800000049737472696e67001200000000000000050000006b69'+
    '6e64000000001500000040000000010000002200000049444c3a6f6d672e6f72672f436f734e616d696e672f49737472696e673a312e30'+
    '0000000800000049737472696e67001200000000000000000000000d00000062696e64696e675f7479706500000000110000005d000000'+
    '010000002600000049444c3a6f6d672e6f72672f436f734e616d696e672f42696e64696e67547970653a312e300000000c00000042696e'+
    '64696e67547970650002000000080000006e6f626a65637400090000006e636f6e7465787400');
  _tc_Binding_seq := CreateTypeCodeConst('01000000130000001c020000010000000f00000009020000010000002200000049444c3a6f6d672e6f72672f436f734e616d696e672f42'+
    '696e64696e673a312e300000000800000042696e64696e6700020000000d00000062696e64696e675f6e616d6500000000150000003801'+
    '0000010000001f00000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d653a312e300000050000004e616d650000000013'+
    '000000fc000000010000000f000000ec000000010000002800000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d65436f'+
    '6d706f6e656e743a312e30000e0000004e616d65436f6d706f6e656e740000000200000003000000696400001500000040000000010000'+
    '002200000049444c3a6f6d672e6f72672f436f734e616d696e672f49737472696e673a312e300000000800000049737472696e67001200'+
    '000000000000050000006b696e64000000001500000040000000010000002200000049444c3a6f6d672e6f72672f436f734e616d696e67'+
    '2f49737472696e673a312e300000000800000049737472696e67001200000000000000000000000d00000062696e64696e675f74797065'+
    '00000000110000005d000000010000002600000049444c3a6f6d672e6f72672f436f734e616d696e672f42696e64696e67547970653a31'+
    '2e300000000c00000042696e64696e67547970650002000000080000006e6f626a65637400090000006e636f6e746578740000000000000000');
  _tc_NotFoundReason := CreateTypeCodeConst('01000000110000008b000000010000003700000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '2f4e6f74466f756e64526561736f6e3a312e3000000f0000004e6f74466f756e64526561736f6e0000030000000d0000006d697373696e'+
    '675f6e6f6465000000000c0000006e6f745f636f6e74657874000b0000006e6f745f6f626a65637400');
  _tc_NotFound := CreateTypeCodeConst('010000001600000050000000010000003100000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '2f4e6f74466f756e643a312e3000000000090000004e6f74466f756e640000000000000000');
  _tc_CannotProceed := CreateTypeCodeConst('010000001600000058000000010000003600000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '2f43616e6e6f7450726f636565643a312e300000000e00000043616e6e6f7450726f6365656400000000000000');
  _tc_InvalidName := CreateTypeCodeConst('010000001600000050000000010000003400000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '2f496e76616c69644e616d653a312e30000c000000496e76616c69644e616d650000000000');
  _tc_AlreadyBound := CreateTypeCodeConst('010000001600000058000000010000003500000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '2f416c7265616479426f756e643a312e30000000000d000000416c7265616479426f756e640000000000000000');
  _tc_NotEmpty := CreateTypeCodeConst('010000001600000050000000010000003100000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '2f4e6f74456d7074793a312e3000000000090000004e6f74456d7074790000000000000000');
  _tc_NamingContext := CreateTypeCodeConst('010000000e00000042000000010000002800000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '3a312e30000e0000004e616d696e67436f6e7465787400');
  _tc_BindingIterator := CreateTypeCodeConst('010000000e00000048000000010000002a00000049444c3a6f6d672e6f72672f436f734e616d696e672f42696e64696e67497465726174'+
    '6f723a312e300000001000000042696e64696e674974657261746f7200');
  _tc_InvalidAddress := CreateTypeCodeConst('01000000160000005c000000010000003a00000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '4578742f496e76616c6964416464726573733a312e300000000f000000496e76616c696441646472657373000000000000');
  _tc_NamingContextExt := CreateTypeCodeConst('010000000e00000049000000010000002b00000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e74657874'+
    '4578743a312e300000110000004e616d696e67436f6e7465787445787400');
end.
