// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -i..\..\idl ..\..\idl\CosTime.idl" 
//                                                                            
unit CosTime;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, CosTime_int, TimeBase_int, TimeBase, poa_int, poa;

type

  TCosTime_TimeComparison_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TCosTime_ComparisonType_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TCosTime_OverlapType_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TCosTime_TimeUnavailable_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTime/TimeUnavailable:1.0 } 
  TCosTime_TimeUnavailable = class(UserException,ICosTime_TimeUnavailable)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TCosTime_TimeUnavailable); overload;
    constructor Create(); overload;
  end;

  {** IDL:omg.org/CosTime/UTO:1.0 } 
  TCosTime_UTO = class(TORBObject,ICosTime_UTO)
  protected
    function absolute_time: ICosTime_UTO; virtual; abstract;
    function compare_time(const comparison_type: TCosTime_ComparisonType; const uto: ICosTime_UTO): TCosTime_TimeComparison; virtual; abstract;
    function time_to_interval(const uto: ICosTime_UTO): ICosTime_TIO; virtual; abstract;
    function interval: ICosTime_TIO; virtual; abstract;
    function _get_time: TTimeBase_TimeT; virtual; abstract;
    function _get_inaccuracy: TTimeBase_InaccuracyT; virtual; abstract;
    function _get_tdf: TTimeBase_TdfT; virtual; abstract;
    function _get_utc_time: TTimeBase_UtcT; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICosTime_UTO;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTime/UTO:1.0} 
  TCosTime_UTO_stub = class(TCosTime_UTO)
  protected
    function absolute_time: ICosTime_UTO; override;
    function compare_time(const comparison_type: TCosTime_ComparisonType; const uto: ICosTime_UTO): TCosTime_TimeComparison; override;
    function time_to_interval(const uto: ICosTime_UTO): ICosTime_TIO; override;
    function interval: ICosTime_TIO; override;
    function _get_time: TTimeBase_TimeT; override;
    function _get_inaccuracy: TTimeBase_InaccuracyT; override;
    function _get_tdf: TTimeBase_TdfT; override;
    function _get_utc_time: TTimeBase_UtcT; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTime/UTO:1.0} 
  TCosTime_UTO_stub_clp = class(TPOAStub,IPOAStub,ICosTime_UTO)
  protected
    function absolute_time: ICosTime_UTO; virtual;
    function compare_time(const comparison_type: TCosTime_ComparisonType; const uto: ICosTime_UTO): TCosTime_TimeComparison; virtual;
    function time_to_interval(const uto: ICosTime_UTO): ICosTime_TIO; virtual;
    function interval: ICosTime_TIO; virtual;
    function _get_time: TTimeBase_TimeT; virtual;
    function _get_inaccuracy: TTimeBase_InaccuracyT; virtual;
    function _get_tdf: TTimeBase_TdfT; virtual;
    function _get_utc_time: TTimeBase_UtcT; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTime/UTO:1.0} 
  TCosTime_UTO_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICosTime_UTO)
  protected
    function absolute_time: ICosTime_UTO; virtual; abstract;
    function compare_time(const comparison_type: TCosTime_ComparisonType; const uto: ICosTime_UTO): TCosTime_TimeComparison; virtual; abstract;
    function time_to_interval(const uto: ICosTime_UTO): ICosTime_TIO; virtual; abstract;
    function interval: ICosTime_TIO; virtual; abstract;
    function _get_time: TTimeBase_TimeT; virtual; abstract;
    function _get_inaccuracy: TTimeBase_InaccuracyT; virtual; abstract;
    function _get_tdf: TTimeBase_TdfT; virtual; abstract;
    function _get_utc_time: TTimeBase_UtcT; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICosTime_UTO;
    class function _narrow(const srv : IServant): ICosTime_UTO;
  end;

  TCosTime_UTO_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTime/TIO:1.0 } 
  TCosTime_TIO = class(TORBObject,ICosTime_TIO)
  protected
    function spans(const time: ICosTime_UTO; out overlap: ICosTime_TIO): TCosTime_OverlapType; virtual; abstract;
    function overlaps(const interval: ICosTime_TIO; out overlap: ICosTime_TIO): TCosTime_OverlapType; virtual; abstract;
    function time: ICosTime_UTO; virtual; abstract;
    function _get_time_interval: TTimeBase_IntervalT; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICosTime_TIO;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTime/TIO:1.0} 
  TCosTime_TIO_stub = class(TCosTime_TIO)
  protected
    function spans(const time: ICosTime_UTO; out overlap: ICosTime_TIO): TCosTime_OverlapType; override;
    function overlaps(const interval: ICosTime_TIO; out overlap: ICosTime_TIO): TCosTime_OverlapType; override;
    function time: ICosTime_UTO; override;
    function _get_time_interval: TTimeBase_IntervalT; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTime/TIO:1.0} 
  TCosTime_TIO_stub_clp = class(TPOAStub,IPOAStub,ICosTime_TIO)
  protected
    function spans(const time: ICosTime_UTO; out overlap: ICosTime_TIO): TCosTime_OverlapType; virtual;
    function overlaps(const interval: ICosTime_TIO; out overlap: ICosTime_TIO): TCosTime_OverlapType; virtual;
    function time: ICosTime_UTO; virtual;
    function _get_time_interval: TTimeBase_IntervalT; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTime/TIO:1.0} 
  TCosTime_TIO_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICosTime_TIO)
  protected
    function spans(const time: ICosTime_UTO; out overlap: ICosTime_TIO): TCosTime_OverlapType; virtual; abstract;
    function overlaps(const interval: ICosTime_TIO; out overlap: ICosTime_TIO): TCosTime_OverlapType; virtual; abstract;
    function time: ICosTime_UTO; virtual; abstract;
    function _get_time_interval: TTimeBase_IntervalT; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICosTime_TIO;
    class function _narrow(const srv : IServant): ICosTime_TIO;
  end;

  TCosTime_TIO_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTime/TimeService:1.0 } 
  TCosTime_TimeService = class(TORBObject,ICosTime_TimeService)
  protected
    function universal_time: ICosTime_UTO; virtual; abstract;
    function secure_universal_time: ICosTime_UTO; virtual; abstract;
    function new_universal_time(const time: TTimeBase_TimeT; const inaccuracy: TTimeBase_InaccuracyT; const tdf: TTimeBase_TdfT): ICosTime_UTO; virtual; abstract;
    function uto_from_utc(const utc: TTimeBase_UtcT): ICosTime_UTO; virtual; abstract;
    function new_interval(const lower: TTimeBase_TimeT; const upper: TTimeBase_TimeT): ICosTime_TIO; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICosTime_TimeService;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTime/TimeService:1.0} 
  TCosTime_TimeService_stub = class(TCosTime_TimeService)
  protected
    function universal_time: ICosTime_UTO; override;
    function secure_universal_time: ICosTime_UTO; override;
    function new_universal_time(const time: TTimeBase_TimeT; const inaccuracy: TTimeBase_InaccuracyT; const tdf: TTimeBase_TdfT): ICosTime_UTO; override;
    function uto_from_utc(const utc: TTimeBase_UtcT): ICosTime_UTO; override;
    function new_interval(const lower: TTimeBase_TimeT; const upper: TTimeBase_TimeT): ICosTime_TIO; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTime/TimeService:1.0} 
  TCosTime_TimeService_stub_clp = class(TPOAStub,IPOAStub,ICosTime_TimeService)
  protected
    function universal_time: ICosTime_UTO; virtual;
    function secure_universal_time: ICosTime_UTO; virtual;
    function new_universal_time(const time: TTimeBase_TimeT; const inaccuracy: TTimeBase_InaccuracyT; const tdf: TTimeBase_TdfT): ICosTime_UTO; virtual;
    function uto_from_utc(const utc: TTimeBase_UtcT): ICosTime_UTO; virtual;
    function new_interval(const lower: TTimeBase_TimeT; const upper: TTimeBase_TimeT): ICosTime_TIO; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTime/TimeService:1.0} 
  TCosTime_TimeService_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICosTime_TimeService)
  protected
    function universal_time: ICosTime_UTO; virtual; abstract;
    function secure_universal_time: ICosTime_UTO; virtual; abstract;
    function new_universal_time(const time: TTimeBase_TimeT; const inaccuracy: TTimeBase_InaccuracyT; const tdf: TTimeBase_TdfT): ICosTime_UTO; virtual; abstract;
    function uto_from_utc(const utc: TTimeBase_UtcT): ICosTime_UTO; virtual; abstract;
    function new_interval(const lower: TTimeBase_TimeT; const upper: TTimeBase_TimeT): ICosTime_TIO; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICosTime_TimeService;
    class function _narrow(const srv : IServant): ICosTime_TimeService;
  end;

  TCosTime_TimeService_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  CosTime_TimeComparison_marshaller : IStaticTypeInfo;
  CosTime_ComparisonType_marshaller : IStaticTypeInfo;
  CosTime_OverlapType_marshaller : IStaticTypeInfo;
  CosTime_TimeUnavailable_marshaller : IStaticTypeInfo;
  CosTime_UTO_marshaller : IStaticTypeInfo;
  CosTime_TIO_marshaller : IStaticTypeInfo;
  CosTime_TimeService_marshaller : IStaticTypeInfo;
  _tc_CosTime_TimeComparison : ITypeCodeConst;
  _tc_CosTime_ComparisonType : ITypeCodeConst;
  _tc_CosTime_OverlapType : ITypeCodeConst;
  _tc_CosTime_TimeUnavailable : ITypeCodeConst;
  _tc_CosTime_UTO : ITypeCodeConst;
  _tc_CosTime_TIO : ITypeCodeConst;
  _tc_CosTime_TimeService : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TCosTime_TimeComparison_marshaller
//***********************************************************
function TCosTime_TimeComparison_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TCosTime_TimeComparison_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TCosTime_TimeComparison_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TCosTime_TimeComparison_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TCosTime_TimeComparison_marshaller._assign(dst, src: Pointer);
begin
  TCosTime_TimeComparison(dst^) := TCosTime_TimeComparison(src^);
end;

function TCosTime_TimeComparison_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTime_TimeComparison.typecode;
end;

//***********************************************************
// TCosTime_ComparisonType_marshaller
//***********************************************************
function TCosTime_ComparisonType_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TCosTime_ComparisonType_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TCosTime_ComparisonType_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TCosTime_ComparisonType_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TCosTime_ComparisonType_marshaller._assign(dst, src: Pointer);
begin
  TCosTime_ComparisonType(dst^) := TCosTime_ComparisonType(src^);
end;

function TCosTime_ComparisonType_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTime_ComparisonType.typecode;
end;

//***********************************************************
// TCosTime_OverlapType_marshaller
//***********************************************************
function TCosTime_OverlapType_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TCosTime_OverlapType_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TCosTime_OverlapType_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TCosTime_OverlapType_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TCosTime_OverlapType_marshaller._assign(dst, src: Pointer);
begin
  TCosTime_OverlapType(dst^) := TCosTime_OverlapType(src^);
end;

function TCosTime_OverlapType_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTime_OverlapType.typecode;
end;

//***********************************************************
// TCosTime_TimeUnavailable_marshaller
//***********************************************************
function TCosTime_TimeUnavailable_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TCosTime_TimeUnavailable_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTime/TimeUnavailable:1.0');
  enc.except_end;
end;

procedure TCosTime_TimeUnavailable_marshaller._free(var addr: Pointer);
begin
  ICosTime_TimeUnavailable(addr^) := nil;
end;

procedure TCosTime_TimeUnavailable_marshaller._create(var addr: Pointer);
begin
  ICosTime_TimeUnavailable(addr^) := TCosTime_TimeUnavailable.Create();
end;

procedure TCosTime_TimeUnavailable_marshaller._assign(dst, src: Pointer);
begin
  ICosTime_TimeUnavailable(dst^) := ICosTime_TimeUnavailable(src^);
end;

function TCosTime_TimeUnavailable_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTime_TimeUnavailable.typecode;
end;

//***********************************************************
// TCosTime_TimeUnavailable
//***********************************************************
constructor TCosTime_TimeUnavailable.Create(ex: TCosTime_TimeUnavailable);
begin
  inherited Create();
end;

procedure TCosTime_TimeUnavailable.throw;
begin
  raise TCosTime_TimeUnavailable.Create(self);
end;

function TCosTime_TimeUnavailable.clone(): IORBException;
begin
  result := TCosTime_TimeUnavailable.Create(self);
end;

procedure TCosTime_TimeUnavailable.encode(const enc: IEncoder);
var
  int : ICosTime_TimeUnavailable;
begin
  int := self;
  CosTime_TimeUnavailable_marshaller.marshal(enc,@int);
end;

procedure TCosTime_TimeUnavailable.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTime_TimeUnavailable_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TCosTime_TimeUnavailable.Create();
begin
  inherited Create();
end;

function TCosTime_TimeUnavailable.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTime/TimeUnavailable:1.0';
end;

//***********************************************************
// TCosTime_UTO
//***********************************************************
function TCosTime_UTO.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/UTO:1.0' then
    begin
      result := Pointer(self as ICosTime_UTO);
      exit;
    end;
end;

class function TCosTime_UTO._narrow(const obj : IORBObject): ICosTime_UTO;
var
  p: Pointer;
  stub: TCosTime_UTO_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTime/UTO:1.0');
  if p <> nil then
    result := ICosTime_UTO(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTime/UTO:1.0') then
        begin
          stub := TCosTime_UTO_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCosTime_UTO.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTime/UTO:1.0'
end;

//***********************************************************
// TCosTime_UTO_stub
//***********************************************************
function TCosTime_UTO_stub.absolute_time: ICosTime_UTO;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(CosTime_UTO_marshaller, @result);
  req := StaticRequest(self,'absolute_time');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_UTO_stub.compare_time(const comparison_type: TCosTime_ComparisonType; const uto: ICosTime_UTO): TCosTime_TimeComparison;
var
  req: IStaticRequest;
  _comparison_type: IStaticAny;
  _uto: IStaticAny;
  _result: IStaticAny;
begin
  _comparison_type := StaticAny(CosTime_ComparisonType_marshaller,@comparison_type);
  _uto := StaticAny(CosTime_UTO_marshaller,@uto);
  _result := StaticAny(CosTime_TimeComparison_marshaller, @result);
  req := StaticRequest(self,'compare_time');
  req.add_in_arg(_comparison_type);
  req.add_in_arg(_uto);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_UTO_stub.time_to_interval(const uto: ICosTime_UTO): ICosTime_TIO;
var
  req: IStaticRequest;
  _uto: IStaticAny;
  _result: IStaticAny;
begin
  _uto := StaticAny(CosTime_UTO_marshaller,@uto);
  _result := StaticAny(CosTime_TIO_marshaller, @result);
  req := StaticRequest(self,'time_to_interval');
  req.add_in_arg(_uto);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_UTO_stub.interval: ICosTime_TIO;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(CosTime_TIO_marshaller, @result);
  req := StaticRequest(self,'interval');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_UTO_stub._get_time: TTimeBase_TimeT;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulonglong, @result);
  req := StaticRequest(self,'_get_time');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_UTO_stub._get_inaccuracy: TTimeBase_InaccuracyT;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulonglong, @result);
  req := StaticRequest(self,'_get_inaccuracy');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_UTO_stub._get_tdf: TTimeBase_TdfT;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_short, @result);
  req := StaticRequest(self,'_get_tdf');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_UTO_stub._get_utc_time: TTimeBase_UtcT;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(TimeBase_UtcT_marshaller, @result);
  req := StaticRequest(self,'_get_utc_time');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TCosTime_UTO_stub_clp
//***********************************************************
function TCosTime_UTO_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/UTO:1.0' then
    begin
      result := Pointer(self as ICosTime_UTO);
      exit;
  end;
end;

function TCosTime_UTO_stub_clp.absolute_time: ICosTime_UTO;
var
  _srv: IServant;
  srv: ICosTime_UTO;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_UTO_serv._narrow(_srv);
      if srv <> nil then
        result := srv.absolute_time
    end;
  _postinvoke();
end;

function TCosTime_UTO_stub_clp.compare_time(const comparison_type: TCosTime_ComparisonType; const uto: ICosTime_UTO): TCosTime_TimeComparison;
var
  _srv: IServant;
  srv: ICosTime_UTO;
begin
  result := TCEqualTo;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_UTO_serv._narrow(_srv);
      if srv <> nil then
        result := srv.compare_time(comparison_type, uto)
    end;
  _postinvoke();
end;

function TCosTime_UTO_stub_clp.time_to_interval(const uto: ICosTime_UTO): ICosTime_TIO;
var
  _srv: IServant;
  srv: ICosTime_UTO;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_UTO_serv._narrow(_srv);
      if srv <> nil then
        result := srv.time_to_interval(uto)
    end;
  _postinvoke();
end;

function TCosTime_UTO_stub_clp.interval: ICosTime_TIO;
var
  _srv: IServant;
  srv: ICosTime_UTO;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_UTO_serv._narrow(_srv);
      if srv <> nil then
        result := srv.interval
    end;
  _postinvoke();
end;

function TCosTime_UTO_stub_clp._get_time: TTimeBase_TimeT;
var
  _srv: IServant;
  srv: ICosTime_UTO;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_UTO_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_time
    end;
  _postinvoke();
end;

function TCosTime_UTO_stub_clp._get_inaccuracy: TTimeBase_InaccuracyT;
var
  _srv: IServant;
  srv: ICosTime_UTO;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_UTO_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_inaccuracy
    end;
  _postinvoke();
end;

function TCosTime_UTO_stub_clp._get_tdf: TTimeBase_TdfT;
var
  _srv: IServant;
  srv: ICosTime_UTO;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_UTO_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_tdf
    end;
  _postinvoke();
end;

function TCosTime_UTO_stub_clp._get_utc_time: TTimeBase_UtcT;
var
  _srv: IServant;
  srv: ICosTime_UTO;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_UTO_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_utc_time
    end;
  _postinvoke();
end;

//***********************************************************
// TCosTime_UTO_serv
//***********************************************************
function TCosTime_UTO_serv._this(): ICosTime_UTO;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCosTime_UTO._narrow(obj);
end;

function TCosTime_UTO_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTime/UTO:1.0';
end;

function TCosTime_UTO_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTime/UTO:1.0';
end;

function TCosTime_UTO_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCosTime_UTO_stub_clp.Create(poa,obj);
end;

procedure TCosTime_UTO_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCosTime_UTO_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/UTO:1.0' then
    begin
      result := Pointer(ICosTime_UTO(self));
      exit;
    end;
end;

class function TCosTime_UTO_serv._narrow(const srv : IServant): ICosTime_UTO;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTime/UTO:1.0');
  if p <> nil then
    result := ICosTime_UTO(p)
end;

function TCosTime_UTO_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  absolute_time_result: ICosTime_UTO;
  compare_time_result: TCosTime_TimeComparison;
  compare_time_comparison_type: TCosTime_ComparisonType;
  compare_time_uto: ICosTime_UTO;
  time_to_interval_result: ICosTime_TIO;
  time_to_interval_uto: ICosTime_UTO;
  interval_result: ICosTime_TIO;
  time_get_value: TTimeBase_TimeT;
  inaccuracy_get_value: TTimeBase_InaccuracyT;
  tdf_get_value: TTimeBase_TdfT;
  utc_time_get_value: TTimeBase_UtcT;
begin
  result := true;
  if req.op_name = 'absolute_time' then
    begin
      req.set_result(StaticAny(CosTime_UTO_marshaller,@absolute_time_result) as IStaticAny);
      if not req.read_args() then  exit;
      absolute_time_result := absolute_time;
      req.write_results();
      exit;
    end
  else if req.op_name = 'compare_time' then
    begin
      req.add_in_arg(StaticAny(CosTime_ComparisonType_marshaller,@compare_time_comparison_type) as IStaticAny);
      req.add_in_arg(StaticAny(CosTime_UTO_marshaller,@compare_time_uto) as IStaticAny);
      req.set_result(StaticAny(CosTime_TimeComparison_marshaller,@compare_time_result) as IStaticAny);
      if not req.read_args() then  exit;
      compare_time_result := compare_time(compare_time_comparison_type, compare_time_uto);
      req.write_results();
      exit;
    end
  else if req.op_name = 'time_to_interval' then
    begin
      req.add_in_arg(StaticAny(CosTime_UTO_marshaller,@time_to_interval_uto) as IStaticAny);
      req.set_result(StaticAny(CosTime_TIO_marshaller,@time_to_interval_result) as IStaticAny);
      if not req.read_args() then  exit;
      time_to_interval_result := time_to_interval(time_to_interval_uto);
      req.write_results();
      exit;
    end
  else if req.op_name = 'interval' then
    begin
      req.set_result(StaticAny(CosTime_TIO_marshaller,@interval_result) as IStaticAny);
      if not req.read_args() then  exit;
      interval_result := interval;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_time' then
    begin
      req.set_result(StaticAny(stat_ulonglong,@time_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      time_get_value := _get_time;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_inaccuracy' then
    begin
      req.set_result(StaticAny(stat_ulonglong,@inaccuracy_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      inaccuracy_get_value := _get_inaccuracy;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_tdf' then
    begin
      req.set_result(StaticAny(stat_short,@tdf_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      tdf_get_value := _get_tdf;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_utc_time' then
    begin
      req.set_result(StaticAny(TimeBase_UtcT_marshaller,@utc_time_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      utc_time_get_value := _get_utc_time;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCosTime_UTO_marshaller
//***********************************************************
function TCosTime_UTO_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICosTime_UTO(addr^) := TCosTime_UTO._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCosTime_UTO_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICosTime_UTO(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCosTime_UTO_marshaller._free(var addr: Pointer);
begin
  ICosTime_UTO(addr^) := nil;
end;

procedure TCosTime_UTO_marshaller._create(var addr: Pointer);
begin
  ICosTime_UTO(addr^) := TCosTime_UTO_stub.Create();
end;

procedure TCosTime_UTO_marshaller._assign(dst, src: Pointer);
begin
  ICosTime_UTO(dst^) := ICosTime_UTO(src^);
end;

function TCosTime_UTO_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTime_UTO.typecode;
end;

//***********************************************************
// TCosTime_TIO
//***********************************************************
function TCosTime_TIO.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/TIO:1.0' then
    begin
      result := Pointer(self as ICosTime_TIO);
      exit;
    end;
end;

class function TCosTime_TIO._narrow(const obj : IORBObject): ICosTime_TIO;
var
  p: Pointer;
  stub: TCosTime_TIO_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTime/TIO:1.0');
  if p <> nil then
    result := ICosTime_TIO(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTime/TIO:1.0') then
        begin
          stub := TCosTime_TIO_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCosTime_TIO.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTime/TIO:1.0'
end;

//***********************************************************
// TCosTime_TIO_stub
//***********************************************************
function TCosTime_TIO_stub.spans(const time: ICosTime_UTO; out overlap: ICosTime_TIO): TCosTime_OverlapType;
var
  req: IStaticRequest;
  _time: IStaticAny;
  _overlap: IStaticAny;
  _result: IStaticAny;
begin
  _time := StaticAny(CosTime_UTO_marshaller,@time);
  _overlap := StaticAny(CosTime_TIO_marshaller,@overlap);
  _result := StaticAny(CosTime_OverlapType_marshaller, @result);
  req := StaticRequest(self,'spans');
  req.add_in_arg(_time);
  req.add_out_arg(_overlap);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_TIO_stub.overlaps(const interval: ICosTime_TIO; out overlap: ICosTime_TIO): TCosTime_OverlapType;
var
  req: IStaticRequest;
  _interval: IStaticAny;
  _overlap: IStaticAny;
  _result: IStaticAny;
begin
  _interval := StaticAny(CosTime_TIO_marshaller,@interval);
  _overlap := StaticAny(CosTime_TIO_marshaller,@overlap);
  _result := StaticAny(CosTime_OverlapType_marshaller, @result);
  req := StaticRequest(self,'overlaps');
  req.add_in_arg(_interval);
  req.add_out_arg(_overlap);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_TIO_stub.time: ICosTime_UTO;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(CosTime_UTO_marshaller, @result);
  req := StaticRequest(self,'time');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_TIO_stub._get_time_interval: TTimeBase_IntervalT;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(TimeBase_IntervalT_marshaller, @result);
  req := StaticRequest(self,'_get_time_interval');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TCosTime_TIO_stub_clp
//***********************************************************
function TCosTime_TIO_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/TIO:1.0' then
    begin
      result := Pointer(self as ICosTime_TIO);
      exit;
  end;
end;

function TCosTime_TIO_stub_clp.spans(const time: ICosTime_UTO; out overlap: ICosTime_TIO): TCosTime_OverlapType;
var
  _srv: IServant;
  srv: ICosTime_TIO;
begin
  result := OTContainer;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TIO_serv._narrow(_srv);
      if srv <> nil then
        result := srv.spans(time, overlap)
    end;
  _postinvoke();
end;

function TCosTime_TIO_stub_clp.overlaps(const interval: ICosTime_TIO; out overlap: ICosTime_TIO): TCosTime_OverlapType;
var
  _srv: IServant;
  srv: ICosTime_TIO;
begin
  result := OTContainer;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TIO_serv._narrow(_srv);
      if srv <> nil then
        result := srv.overlaps(interval, overlap)
    end;
  _postinvoke();
end;

function TCosTime_TIO_stub_clp.time: ICosTime_UTO;
var
  _srv: IServant;
  srv: ICosTime_TIO;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TIO_serv._narrow(_srv);
      if srv <> nil then
        result := srv.time
    end;
  _postinvoke();
end;

function TCosTime_TIO_stub_clp._get_time_interval: TTimeBase_IntervalT;
var
  _srv: IServant;
  srv: ICosTime_TIO;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TIO_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_time_interval
    end;
  _postinvoke();
end;

//***********************************************************
// TCosTime_TIO_serv
//***********************************************************
function TCosTime_TIO_serv._this(): ICosTime_TIO;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCosTime_TIO._narrow(obj);
end;

function TCosTime_TIO_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTime/TIO:1.0';
end;

function TCosTime_TIO_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTime/TIO:1.0';
end;

function TCosTime_TIO_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCosTime_TIO_stub_clp.Create(poa,obj);
end;

procedure TCosTime_TIO_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCosTime_TIO_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/TIO:1.0' then
    begin
      result := Pointer(ICosTime_TIO(self));
      exit;
    end;
end;

class function TCosTime_TIO_serv._narrow(const srv : IServant): ICosTime_TIO;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTime/TIO:1.0');
  if p <> nil then
    result := ICosTime_TIO(p)
end;

function TCosTime_TIO_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  spans_result: TCosTime_OverlapType;
  spans_time: ICosTime_UTO;
  spans_overlap: ICosTime_TIO;
  overlaps_result: TCosTime_OverlapType;
  overlaps_interval: ICosTime_TIO;
  overlaps_overlap: ICosTime_TIO;
  time_result: ICosTime_UTO;
  time_interval_get_value: TTimeBase_IntervalT;
begin
  result := true;
  if req.op_name = 'spans' then
    begin
      req.add_in_arg(StaticAny(CosTime_UTO_marshaller,@spans_time) as IStaticAny);
      req.add_out_arg(StaticAny(CosTime_TIO_marshaller,@spans_overlap) as IStaticAny);
      req.set_result(StaticAny(CosTime_OverlapType_marshaller,@spans_result) as IStaticAny);
      if not req.read_args() then  exit;
      spans_result := spans(spans_time, spans_overlap);
      req.write_results();
      exit;
    end
  else if req.op_name = 'overlaps' then
    begin
      req.add_in_arg(StaticAny(CosTime_TIO_marshaller,@overlaps_interval) as IStaticAny);
      req.add_out_arg(StaticAny(CosTime_TIO_marshaller,@overlaps_overlap) as IStaticAny);
      req.set_result(StaticAny(CosTime_OverlapType_marshaller,@overlaps_result) as IStaticAny);
      if not req.read_args() then  exit;
      overlaps_result := overlaps(overlaps_interval, overlaps_overlap);
      req.write_results();
      exit;
    end
  else if req.op_name = 'time' then
    begin
      req.set_result(StaticAny(CosTime_UTO_marshaller,@time_result) as IStaticAny);
      if not req.read_args() then  exit;
      time_result := time;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_time_interval' then
    begin
      req.set_result(StaticAny(TimeBase_IntervalT_marshaller,@time_interval_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      time_interval_get_value := _get_time_interval;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCosTime_TIO_marshaller
//***********************************************************
function TCosTime_TIO_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICosTime_TIO(addr^) := TCosTime_TIO._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCosTime_TIO_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICosTime_TIO(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCosTime_TIO_marshaller._free(var addr: Pointer);
begin
  ICosTime_TIO(addr^) := nil;
end;

procedure TCosTime_TIO_marshaller._create(var addr: Pointer);
begin
  ICosTime_TIO(addr^) := TCosTime_TIO_stub.Create();
end;

procedure TCosTime_TIO_marshaller._assign(dst, src: Pointer);
begin
  ICosTime_TIO(dst^) := ICosTime_TIO(src^);
end;

function TCosTime_TIO_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTime_TIO.typecode;
end;

//***********************************************************
// TCosTime_TimeService
//***********************************************************
function TCosTime_TimeService.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/TimeService:1.0' then
    begin
      result := Pointer(self as ICosTime_TimeService);
      exit;
    end;
end;

class function TCosTime_TimeService._narrow(const obj : IORBObject): ICosTime_TimeService;
var
  p: Pointer;
  stub: TCosTime_TimeService_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTime/TimeService:1.0');
  if p <> nil then
    result := ICosTime_TimeService(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTime/TimeService:1.0') then
        begin
          stub := TCosTime_TimeService_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCosTime_TimeService.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTime/TimeService:1.0'
end;

//***********************************************************
// TCosTime_TimeService_stub
//***********************************************************
function TCosTime_TimeService_stub.universal_time: ICosTime_UTO;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(CosTime_UTO_marshaller, @result);
  req := StaticRequest(self,'universal_time');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_CosTime_TimeUnavailable.typecode]);
  req.invoke;
  dorb_static_throw(req,[CosTime_TimeUnavailable_marshaller, 'IDL:omg.org/CosTime/TimeUnavailable:1.0']);
end;

function TCosTime_TimeService_stub.secure_universal_time: ICosTime_UTO;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(CosTime_UTO_marshaller, @result);
  req := StaticRequest(self,'secure_universal_time');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_CosTime_TimeUnavailable.typecode]);
  req.invoke;
  dorb_static_throw(req,[CosTime_TimeUnavailable_marshaller, 'IDL:omg.org/CosTime/TimeUnavailable:1.0']);
end;

function TCosTime_TimeService_stub.new_universal_time(const time: TTimeBase_TimeT; const inaccuracy: TTimeBase_InaccuracyT; const tdf: TTimeBase_TdfT): ICosTime_UTO;
var
  req: IStaticRequest;
  _time: IStaticAny;
  _inaccuracy: IStaticAny;
  _tdf: IStaticAny;
  _result: IStaticAny;
begin
  _time := StaticAny(stat_ulonglong,@time);
  _inaccuracy := StaticAny(stat_ulonglong,@inaccuracy);
  _tdf := StaticAny(stat_short,@tdf);
  _result := StaticAny(CosTime_UTO_marshaller, @result);
  req := StaticRequest(self,'new_universal_time');
  req.add_in_arg(_time);
  req.add_in_arg(_inaccuracy);
  req.add_in_arg(_tdf);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_TimeService_stub.uto_from_utc(const utc: TTimeBase_UtcT): ICosTime_UTO;
var
  req: IStaticRequest;
  _utc: IStaticAny;
  _result: IStaticAny;
begin
  _utc := StaticAny(TimeBase_UtcT_marshaller,@utc);
  _result := StaticAny(CosTime_UTO_marshaller, @result);
  req := StaticRequest(self,'uto_from_utc');
  req.add_in_arg(_utc);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTime_TimeService_stub.new_interval(const lower: TTimeBase_TimeT; const upper: TTimeBase_TimeT): ICosTime_TIO;
var
  req: IStaticRequest;
  _lower: IStaticAny;
  _upper: IStaticAny;
  _result: IStaticAny;
begin
  _lower := StaticAny(stat_ulonglong,@lower);
  _upper := StaticAny(stat_ulonglong,@upper);
  _result := StaticAny(CosTime_TIO_marshaller, @result);
  req := StaticRequest(self,'new_interval');
  req.add_in_arg(_lower);
  req.add_in_arg(_upper);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TCosTime_TimeService_stub_clp
//***********************************************************
function TCosTime_TimeService_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/TimeService:1.0' then
    begin
      result := Pointer(self as ICosTime_TimeService);
      exit;
  end;
end;

function TCosTime_TimeService_stub_clp.universal_time: ICosTime_UTO;
var
  _srv: IServant;
  srv: ICosTime_TimeService;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TimeService_serv._narrow(_srv);
      if srv <> nil then
        result := srv.universal_time
    end;
  _postinvoke();
end;

function TCosTime_TimeService_stub_clp.secure_universal_time: ICosTime_UTO;
var
  _srv: IServant;
  srv: ICosTime_TimeService;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TimeService_serv._narrow(_srv);
      if srv <> nil then
        result := srv.secure_universal_time
    end;
  _postinvoke();
end;

function TCosTime_TimeService_stub_clp.new_universal_time(const time: TTimeBase_TimeT; const inaccuracy: TTimeBase_InaccuracyT; const tdf: TTimeBase_TdfT): ICosTime_UTO;
var
  _srv: IServant;
  srv: ICosTime_TimeService;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TimeService_serv._narrow(_srv);
      if srv <> nil then
        result := srv.new_universal_time(time, inaccuracy, tdf)
    end;
  _postinvoke();
end;

function TCosTime_TimeService_stub_clp.uto_from_utc(const utc: TTimeBase_UtcT): ICosTime_UTO;
var
  _srv: IServant;
  srv: ICosTime_TimeService;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TimeService_serv._narrow(_srv);
      if srv <> nil then
        result := srv.uto_from_utc(utc)
    end;
  _postinvoke();
end;

function TCosTime_TimeService_stub_clp.new_interval(const lower: TTimeBase_TimeT; const upper: TTimeBase_TimeT): ICosTime_TIO;
var
  _srv: IServant;
  srv: ICosTime_TimeService;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTime_TimeService_serv._narrow(_srv);
      if srv <> nil then
        result := srv.new_interval(lower, upper)
    end;
  _postinvoke();
end;

//***********************************************************
// TCosTime_TimeService_serv
//***********************************************************
function TCosTime_TimeService_serv._this(): ICosTime_TimeService;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCosTime_TimeService._narrow(obj);
end;

function TCosTime_TimeService_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTime/TimeService:1.0';
end;

function TCosTime_TimeService_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTime/TimeService:1.0';
end;

function TCosTime_TimeService_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCosTime_TimeService_stub_clp.Create(poa,obj);
end;

procedure TCosTime_TimeService_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCosTime_TimeService_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTime/TimeService:1.0' then
    begin
      result := Pointer(ICosTime_TimeService(self));
      exit;
    end;
end;

class function TCosTime_TimeService_serv._narrow(const srv : IServant): ICosTime_TimeService;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTime/TimeService:1.0');
  if p <> nil then
    result := ICosTime_TimeService(p)
end;

function TCosTime_TimeService_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  universal_time_result: ICosTime_UTO;
  secure_universal_time_result: ICosTime_UTO;
  new_universal_time_result: ICosTime_UTO;
  new_universal_time_time: TTimeBase_TimeT;
  new_universal_time_inaccuracy: TTimeBase_InaccuracyT;
  new_universal_time_tdf: TTimeBase_TdfT;
  uto_from_utc_result: ICosTime_UTO;
  uto_from_utc_utc: TTimeBase_UtcT;
  new_interval_result: ICosTime_TIO;
  new_interval_lower: TTimeBase_TimeT;
  new_interval_upper: TTimeBase_TimeT;
begin
  result := true;
  if req.op_name = 'universal_time' then
    begin
      req.set_result(StaticAny(CosTime_UTO_marshaller,@universal_time_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_CosTime_TimeUnavailable.typecode]);
      try
        universal_time_result := universal_time;
      except
        on TimeUnavailable: TCosTime_TimeUnavailable do
          req.set_exception(TCosTime_TimeUnavailable.Create(TimeUnavailable) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'secure_universal_time' then
    begin
      req.set_result(StaticAny(CosTime_UTO_marshaller,@secure_universal_time_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_CosTime_TimeUnavailable.typecode]);
      try
        secure_universal_time_result := secure_universal_time;
      except
        on TimeUnavailable: TCosTime_TimeUnavailable do
          req.set_exception(TCosTime_TimeUnavailable.Create(TimeUnavailable) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'new_universal_time' then
    begin
      req.add_in_arg(StaticAny(stat_ulonglong,@new_universal_time_time) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulonglong,@new_universal_time_inaccuracy) as IStaticAny);
      req.add_in_arg(StaticAny(stat_short,@new_universal_time_tdf) as IStaticAny);
      req.set_result(StaticAny(CosTime_UTO_marshaller,@new_universal_time_result) as IStaticAny);
      if not req.read_args() then  exit;
      new_universal_time_result := new_universal_time(new_universal_time_time, new_universal_time_inaccuracy, new_universal_time_tdf);
      req.write_results();
      exit;
    end
  else if req.op_name = 'uto_from_utc' then
    begin
      req.add_in_arg(StaticAny(TimeBase_UtcT_marshaller,@uto_from_utc_utc) as IStaticAny);
      req.set_result(StaticAny(CosTime_UTO_marshaller,@uto_from_utc_result) as IStaticAny);
      if not req.read_args() then  exit;
      uto_from_utc_result := uto_from_utc(uto_from_utc_utc);
      req.write_results();
      exit;
    end
  else if req.op_name = 'new_interval' then
    begin
      req.add_in_arg(StaticAny(stat_ulonglong,@new_interval_lower) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulonglong,@new_interval_upper) as IStaticAny);
      req.set_result(StaticAny(CosTime_TIO_marshaller,@new_interval_result) as IStaticAny);
      if not req.read_args() then  exit;
      new_interval_result := new_interval(new_interval_lower, new_interval_upper);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCosTime_TimeService_marshaller
//***********************************************************
function TCosTime_TimeService_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICosTime_TimeService(addr^) := TCosTime_TimeService._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCosTime_TimeService_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICosTime_TimeService(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCosTime_TimeService_marshaller._free(var addr: Pointer);
begin
  ICosTime_TimeService(addr^) := nil;
end;

procedure TCosTime_TimeService_marshaller._create(var addr: Pointer);
begin
  ICosTime_TimeService(addr^) := TCosTime_TimeService_stub.Create();
end;

procedure TCosTime_TimeService_marshaller._assign(dst, src: Pointer);
begin
  ICosTime_TimeService(dst^) := ICosTime_TimeService(src^);
end;

function TCosTime_TimeService_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTime_TimeService.typecode;
end;

initialization
  CosTime_TimeComparison_marshaller := TCosTime_TimeComparison_marshaller.Create();
  CosTime_ComparisonType_marshaller := TCosTime_ComparisonType_marshaller.Create();
  CosTime_OverlapType_marshaller := TCosTime_OverlapType_marshaller.Create();
  CosTime_TimeUnavailable_marshaller := TCosTime_TimeUnavailable_marshaller.Create();
  CosTime_UTO_marshaller := TCosTime_UTO_marshaller.Create();
  CosTime_TIO_marshaller := TCosTime_TIO_marshaller.Create();
  CosTime_TimeService_marshaller := TCosTime_TimeService_marshaller.Create();
  _tc_CosTime_TimeComparison := CreateTypeCodeConst('010000001100000090000000010000002700000049444c3a6f6d672e6f72672f436f7354696d652f54696d65436f6d70617269736f6e3a'+
    '312e3000000f00000054696d65436f6d70617269736f6e0000040000000a0000005443457175616c546f0000000b00000054434c657373'+
    '5468616e00000e0000005443477265617465725468616e000000100000005443496e64657465726d696e61746500');
  _tc_CosTime_ComparisonType := CreateTypeCodeConst('010000001100000061000000010000002700000049444c3a6f6d672e6f72672f436f7354696d652f436f6d70617269736f6e547970653a'+
    '312e3000000f000000436f6d70617269736f6e547970650000020000000a000000496e74657276616c43000000050000004d69644300');
  _tc_CosTime_OverlapType := CreateTypeCodeConst('010000001100000080000000010000002400000049444c3a6f6d672e6f72672f436f7354696d652f4f7665726c6170547970653a312e30'+
    '000c0000004f7665726c61705479706500040000000c0000004f54436f6e7461696e6572000c0000004f54436f6e7461696e6564000a00'+
    '00004f544f7665726c61700000000c0000004f544e6f4f7665726c617000');
  _tc_CosTime_TimeUnavailable := CreateTypeCodeConst('010000001600000048000000010000002800000049444c3a6f6d672e6f72672f436f7354696d652f54696d65556e617661696c61626c65'+
    '3a312e30001000000054696d65556e617661696c61626c650000000000');
  _tc_CosTime_UTO := CreateTypeCodeConst('010000000e0000002c000000010000001c00000049444c3a6f6d672e6f72672f436f7354696d652f55544f3a312e30000400000055544f00');
  _tc_CosTime_TIO := CreateTypeCodeConst('010000000e0000002c000000010000001c00000049444c3a6f6d672e6f72672f436f7354696d652f54494f3a312e30000400000054494f00');
  _tc_CosTime_TimeService := CreateTypeCodeConst('010000000e0000003c000000010000002400000049444c3a6f6d672e6f72672f436f7354696d652f54696d65536572766963653a312e30'+
    '000c00000054696d655365727669636500');
end.
