// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -any -wpCosEventComm -i..\..\idl ..\..\idl\CosTimerEvent.idl" 
//                                                                            
unit CosTimerEvent;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, CosTimerEvent_int, TimeBase_int, TimeBase, CosTime_int,
  CosTime, CosEventComm_int, CosEventComm, poa_int, poa;

type

  TCosTimerEvent_TimeType_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TCosTimerEvent_EventStatus_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TCosTimerEvent_TimerEventT_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0 } 
  TCosTimerEvent_TimerEventHandler = class(TORBObject,ICosTimerEvent_TimerEventHandler)
  protected
    function time_set(out uto: ICosTime_UTO): Boolean; virtual; abstract;
    procedure SetTimer(const time_type: TCosTimerEvent_TimeType; const trigger_time: ICosTime_UTO); virtual; abstract;
    function cancel_timer: Boolean; virtual; abstract;
    procedure set_data(const event_data: IAny); virtual; abstract;
    function _get_status: TCosTimerEvent_EventStatus; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICosTimerEvent_TimerEventHandler;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0} 
  TCosTimerEvent_TimerEventHandler_stub = class(TCosTimerEvent_TimerEventHandler)
  protected
    function time_set(out uto: ICosTime_UTO): Boolean; override;
    procedure SetTimer(const time_type: TCosTimerEvent_TimeType; const trigger_time: ICosTime_UTO); override;
    function cancel_timer: Boolean; override;
    procedure set_data(const event_data: IAny); override;
    function _get_status: TCosTimerEvent_EventStatus; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0} 
  TCosTimerEvent_TimerEventHandler_stub_clp = class(TPOAStub,IPOAStub,ICosTimerEvent_TimerEventHandler)
  protected
    function time_set(out uto: ICosTime_UTO): Boolean; virtual;
    procedure SetTimer(const time_type: TCosTimerEvent_TimeType; const trigger_time: ICosTime_UTO); virtual;
    function cancel_timer: Boolean; virtual;
    procedure set_data(const event_data: IAny); virtual;
    function _get_status: TCosTimerEvent_EventStatus; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0} 
  TCosTimerEvent_TimerEventHandler_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICosTimerEvent_TimerEventHandler)
  protected
    function time_set(out uto: ICosTime_UTO): Boolean; virtual; abstract;
    procedure SetTimer(const time_type: TCosTimerEvent_TimeType; const trigger_time: ICosTime_UTO); virtual; abstract;
    function cancel_timer: Boolean; virtual; abstract;
    procedure set_data(const event_data: IAny); virtual; abstract;
    function _get_status: TCosTimerEvent_EventStatus; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICosTimerEvent_TimerEventHandler;
    class function _narrow(const srv : IServant): ICosTimerEvent_TimerEventHandler;
  end;

  TCosTimerEvent_TimerEventHandler_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTimerEvent/TimerEventService:1.0 } 
  TCosTimerEvent_TimerEventService = class(TORBObject,ICosTimerEvent_TimerEventService)
  protected
    function register(const event_interface: IPushConsumer; const data: IAny): ICosTimerEvent_TimerEventHandler; virtual; abstract;
    procedure unregister(const timer_event_handler: ICosTimerEvent_TimerEventHandler); virtual; abstract;
    function event_time(const timer_event: TCosTimerEvent_TimerEventT): ICosTime_UTO; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICosTimerEvent_TimerEventService;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTimerEvent/TimerEventService:1.0} 
  TCosTimerEvent_TimerEventService_stub = class(TCosTimerEvent_TimerEventService)
  protected
    function register(const event_interface: IPushConsumer; const data: IAny): ICosTimerEvent_TimerEventHandler; override;
    procedure unregister(const timer_event_handler: ICosTimerEvent_TimerEventHandler); override;
    function event_time(const timer_event: TCosTimerEvent_TimerEventT): ICosTime_UTO; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTimerEvent/TimerEventService:1.0} 
  TCosTimerEvent_TimerEventService_stub_clp = class(TPOAStub,IPOAStub,ICosTimerEvent_TimerEventService)
  protected
    function register(const event_interface: IPushConsumer; const data: IAny): ICosTimerEvent_TimerEventHandler; virtual;
    procedure unregister(const timer_event_handler: ICosTimerEvent_TimerEventHandler); virtual;
    function event_time(const timer_event: TCosTimerEvent_TimerEventT): ICosTime_UTO; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTimerEvent/TimerEventService:1.0} 
  TCosTimerEvent_TimerEventService_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICosTimerEvent_TimerEventService)
  protected
    function register(const event_interface: IPushConsumer; const data: IAny): ICosTimerEvent_TimerEventHandler; virtual; abstract;
    procedure unregister(const timer_event_handler: ICosTimerEvent_TimerEventHandler); virtual; abstract;
    function event_time(const timer_event: TCosTimerEvent_TimerEventT): ICosTime_UTO; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICosTimerEvent_TimerEventService;
    class function _narrow(const srv : IServant): ICosTimerEvent_TimerEventService;
  end;

  TCosTimerEvent_TimerEventService_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  function CosTimerEvent_TimeType_to_any(const val: TCosTimerEvent_TimeType): IAny;
  function any_to_CosTimerEvent_TimeType(const a: IAny; var val: TCosTimerEvent_TimeType): Boolean;

  function CosTimerEvent_EventStatus_to_any(const val: TCosTimerEvent_EventStatus): IAny;
  function any_to_CosTimerEvent_EventStatus(const a: IAny; var val: TCosTimerEvent_EventStatus): Boolean;

  function CosTimerEvent_TimerEventT_to_any(const val: TCosTimerEvent_TimerEventT): IAny;
  function any_to_CosTimerEvent_TimerEventT(const a: IAny; var val: TCosTimerEvent_TimerEventT): Boolean;

  function CosTimerEvent_TimerEventHandler_to_any(const val: ICosTimerEvent_TimerEventHandler): IAny;
  function any_to_CosTimerEvent_TimerEventHandler(const a: IAny; var val: ICosTimerEvent_TimerEventHandler): Boolean;

  function CosTimerEvent_TimerEventService_to_any(const val: ICosTimerEvent_TimerEventService): IAny;
  function any_to_CosTimerEvent_TimerEventService(const a: IAny; var val: ICosTimerEvent_TimerEventService): Boolean;

var
  CosTimerEvent_TimeType_marshaller : IStaticTypeInfo;
  CosTimerEvent_EventStatus_marshaller : IStaticTypeInfo;
  CosTimerEvent_TimerEventT_marshaller : IStaticTypeInfo;
  CosTimerEvent_TimerEventHandler_marshaller : IStaticTypeInfo;
  CosTimerEvent_TimerEventService_marshaller : IStaticTypeInfo;
  _tc_CosTimerEvent_TimeType : ITypeCodeConst;
  _tc_CosTimerEvent_EventStatus : ITypeCodeConst;
  _tc_CosTimerEvent_TimerEventT : ITypeCodeConst;
  _tc_CosTimerEvent_TimerEventHandler : ITypeCodeConst;
  _tc_CosTimerEvent_TimerEventService : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TCosTimerEvent_TimeType_marshaller
//***********************************************************
function TCosTimerEvent_TimeType_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TCosTimerEvent_TimeType_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TCosTimerEvent_TimeType_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TCosTimerEvent_TimeType_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TCosTimerEvent_TimeType_marshaller._assign(dst, src: Pointer);
begin
  TCosTimerEvent_TimeType(dst^) := TCosTimerEvent_TimeType(src^);
end;

function TCosTimerEvent_TimeType_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTimerEvent_TimeType.typecode;
end;

//***********************************************************
// TCosTimerEvent_EventStatus_marshaller
//***********************************************************
function TCosTimerEvent_EventStatus_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TCosTimerEvent_EventStatus_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TCosTimerEvent_EventStatus_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TCosTimerEvent_EventStatus_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TCosTimerEvent_EventStatus_marshaller._assign(dst, src: Pointer);
begin
  TCosTimerEvent_EventStatus(dst^) := TCosTimerEvent_EventStatus(src^);
end;

function TCosTimerEvent_EventStatus_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTimerEvent_EventStatus.typecode;
end;

//***********************************************************
// TCosTimerEvent_TimerEventT_marshaller
//***********************************************************
function TCosTimerEvent_TimerEventT_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: CosTimerEvent_int.TCosTimerEvent_TimerEventT;
begin
  result := false;
  if not TimeBase_UtcT_marshaller.demarshal(dec,@struct.utc) then exit;
  if not stat_any.demarshal(dec,@struct.event_data) then exit;
  CosTimerEvent_int.TCosTimerEvent_TimerEventT(addr^) := struct;
  result := true;
end;

procedure TCosTimerEvent_TimerEventT_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: CosTimerEvent_int.TCosTimerEvent_TimerEventT;
begin
  struct := CosTimerEvent_int.TCosTimerEvent_TimerEventT(addr^);
  TimeBase_UtcT_marshaller.marshal(enc,@struct.utc);
  stat_any.marshal(enc,@struct.event_data);
end;

procedure TCosTimerEvent_TimerEventT_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(CosTimerEvent_int.TCosTimerEvent_TimerEventT(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TCosTimerEvent_TimerEventT_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(CosTimerEvent_int.TCosTimerEvent_TimerEventT));
{$HINTS OFF}
  System.Initialize(CosTimerEvent_int.TCosTimerEvent_TimerEventT(addr^));
{$HINTS ON}
end;

procedure TCosTimerEvent_TimerEventT_marshaller._assign(dst, src: Pointer);
begin
  CosTimerEvent_int.TCosTimerEvent_TimerEventT(dst^) := CosTimerEvent_int.TCosTimerEvent_TimerEventT(src^);
end;

function TCosTimerEvent_TimerEventT_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTimerEvent_TimerEventT.typecode;
end;

//***********************************************************
// TCosTimerEvent_TimerEventHandler
//***********************************************************
function TCosTimerEvent_TimerEventHandler.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0' then
    begin
      result := Pointer(self as ICosTimerEvent_TimerEventHandler);
      exit;
    end;
end;

class function TCosTimerEvent_TimerEventHandler._narrow(const obj : IORBObject): ICosTimerEvent_TimerEventHandler;
var
  p: Pointer;
  stub: TCosTimerEvent_TimerEventHandler_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0');
  if p <> nil then
    result := ICosTimerEvent_TimerEventHandler(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0') then
        begin
          stub := TCosTimerEvent_TimerEventHandler_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCosTimerEvent_TimerEventHandler.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0'
end;

//***********************************************************
// TCosTimerEvent_TimerEventHandler_stub
//***********************************************************
function TCosTimerEvent_TimerEventHandler_stub.time_set(out uto: ICosTime_UTO): Boolean;
var
  req: IStaticRequest;
  _uto: IStaticAny;
  _result: IStaticAny;
begin
  _uto := StaticAny(CosTime_UTO_marshaller,@uto);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'time_set');
  req.add_out_arg(_uto);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TCosTimerEvent_TimerEventHandler_stub.SetTimer(const time_type: TCosTimerEvent_TimeType; const trigger_time: ICosTime_UTO);
var
  req: IStaticRequest;
  _time_type: IStaticAny;
  _trigger_time: IStaticAny;
begin
  _time_type := StaticAny(CosTimerEvent_TimeType_marshaller,@time_type);
  _trigger_time := StaticAny(CosTime_UTO_marshaller,@trigger_time);
  req := StaticRequest(self,'SetTimer');
  req.add_in_arg(_time_type);
  req.add_in_arg(_trigger_time);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTimerEvent_TimerEventHandler_stub.cancel_timer: Boolean;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'cancel_timer');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TCosTimerEvent_TimerEventHandler_stub.set_data(const event_data: IAny);
var
  req: IStaticRequest;
  _event_data: IStaticAny;
begin
  _event_data := StaticAny(stat_any,@event_data);
  req := StaticRequest(self,'set_data');
  req.add_in_arg(_event_data);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTimerEvent_TimerEventHandler_stub._get_status: TCosTimerEvent_EventStatus;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(CosTimerEvent_EventStatus_marshaller, @result);
  req := StaticRequest(self,'_get_status');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TCosTimerEvent_TimerEventHandler_stub_clp
//***********************************************************
function TCosTimerEvent_TimerEventHandler_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0' then
    begin
      result := Pointer(self as ICosTimerEvent_TimerEventHandler);
      exit;
  end;
end;

function TCosTimerEvent_TimerEventHandler_stub_clp.time_set(out uto: ICosTime_UTO): Boolean;
var
  _srv: IServant;
  srv: ICosTimerEvent_TimerEventHandler;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTimerEvent_TimerEventHandler_serv._narrow(_srv);
      if srv <> nil then
        result := srv.time_set(uto)
    end;
  _postinvoke();
end;

procedure TCosTimerEvent_TimerEventHandler_stub_clp.SetTimer(const time_type: TCosTimerEvent_TimeType; const trigger_time: ICosTime_UTO);
var
  _srv: IServant;
  srv: ICosTimerEvent_TimerEventHandler;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTimerEvent_TimerEventHandler_serv._narrow(_srv);
      if srv <> nil then
        srv.SetTimer(time_type, trigger_time)
    end;
  _postinvoke();
end;

function TCosTimerEvent_TimerEventHandler_stub_clp.cancel_timer: Boolean;
var
  _srv: IServant;
  srv: ICosTimerEvent_TimerEventHandler;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTimerEvent_TimerEventHandler_serv._narrow(_srv);
      if srv <> nil then
        result := srv.cancel_timer
    end;
  _postinvoke();
end;

procedure TCosTimerEvent_TimerEventHandler_stub_clp.set_data(const event_data: IAny);
var
  _srv: IServant;
  srv: ICosTimerEvent_TimerEventHandler;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTimerEvent_TimerEventHandler_serv._narrow(_srv);
      if srv <> nil then
        srv.set_data(event_data)
    end;
  _postinvoke();
end;

function TCosTimerEvent_TimerEventHandler_stub_clp._get_status: TCosTimerEvent_EventStatus;
var
  _srv: IServant;
  srv: ICosTimerEvent_TimerEventHandler;
begin
  result := ESTimeSet;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTimerEvent_TimerEventHandler_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_status
    end;
  _postinvoke();
end;

//***********************************************************
// TCosTimerEvent_TimerEventHandler_serv
//***********************************************************
function TCosTimerEvent_TimerEventHandler_serv._this(): ICosTimerEvent_TimerEventHandler;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCosTimerEvent_TimerEventHandler._narrow(obj);
end;

function TCosTimerEvent_TimerEventHandler_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0';
end;

function TCosTimerEvent_TimerEventHandler_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0';
end;

function TCosTimerEvent_TimerEventHandler_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCosTimerEvent_TimerEventHandler_stub_clp.Create(poa,obj);
end;

procedure TCosTimerEvent_TimerEventHandler_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCosTimerEvent_TimerEventHandler_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0' then
    begin
      result := Pointer(ICosTimerEvent_TimerEventHandler(self));
      exit;
    end;
end;

class function TCosTimerEvent_TimerEventHandler_serv._narrow(const srv : IServant): ICosTimerEvent_TimerEventHandler;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTimerEvent/TimerEventHandler:1.0');
  if p <> nil then
    result := ICosTimerEvent_TimerEventHandler(p)
end;

function TCosTimerEvent_TimerEventHandler_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  time_set_result: Boolean;
  time_set_uto: ICosTime_UTO;
  SetTimer_time_type: TCosTimerEvent_TimeType;
  SetTimer_trigger_time: ICosTime_UTO;
  cancel_timer_result: Boolean;
  set_data_event_data: IAny;
  status_get_value: TCosTimerEvent_EventStatus;
begin
  result := true;
  if req.op_name = 'time_set' then
    begin
      req.add_out_arg(StaticAny(CosTime_UTO_marshaller,@time_set_uto) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@time_set_result) as IStaticAny);
      if not req.read_args() then  exit;
      time_set_result := time_set(time_set_uto);
      req.write_results();
      exit;
    end
  else if req.op_name = 'SetTimer' then
    begin
      req.add_in_arg(StaticAny(CosTimerEvent_TimeType_marshaller,@SetTimer_time_type) as IStaticAny);
      req.add_in_arg(StaticAny(CosTime_UTO_marshaller,@SetTimer_trigger_time) as IStaticAny);
      if not req.read_args() then  exit;
      SetTimer(SetTimer_time_type, SetTimer_trigger_time);
      req.write_results();
      exit;
    end
  else if req.op_name = 'cancel_timer' then
    begin
      req.set_result(StaticAny(stat_boolean,@cancel_timer_result) as IStaticAny);
      if not req.read_args() then  exit;
      cancel_timer_result := cancel_timer;
      req.write_results();
      exit;
    end
  else if req.op_name = 'set_data' then
    begin
      req.add_in_arg(StaticAny(stat_any,@set_data_event_data) as IStaticAny);
      if not req.read_args() then  exit;
      set_data(set_data_event_data);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_status' then
    begin
      req.set_result(StaticAny(CosTimerEvent_EventStatus_marshaller,@status_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      status_get_value := _get_status;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCosTimerEvent_TimerEventHandler_marshaller
//***********************************************************
function TCosTimerEvent_TimerEventHandler_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICosTimerEvent_TimerEventHandler(addr^) := TCosTimerEvent_TimerEventHandler._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCosTimerEvent_TimerEventHandler_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICosTimerEvent_TimerEventHandler(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCosTimerEvent_TimerEventHandler_marshaller._free(var addr: Pointer);
begin
  ICosTimerEvent_TimerEventHandler(addr^) := nil;
end;

procedure TCosTimerEvent_TimerEventHandler_marshaller._create(var addr: Pointer);
begin
  ICosTimerEvent_TimerEventHandler(addr^) := TCosTimerEvent_TimerEventHandler_stub.Create();
end;

procedure TCosTimerEvent_TimerEventHandler_marshaller._assign(dst, src: Pointer);
begin
  ICosTimerEvent_TimerEventHandler(dst^) := ICosTimerEvent_TimerEventHandler(src^);
end;

function TCosTimerEvent_TimerEventHandler_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTimerEvent_TimerEventHandler.typecode;
end;

//***********************************************************
// TCosTimerEvent_TimerEventService
//***********************************************************
function TCosTimerEvent_TimerEventService.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTimerEvent/TimerEventService:1.0' then
    begin
      result := Pointer(self as ICosTimerEvent_TimerEventService);
      exit;
    end;
end;

class function TCosTimerEvent_TimerEventService._narrow(const obj : IORBObject): ICosTimerEvent_TimerEventService;
var
  p: Pointer;
  stub: TCosTimerEvent_TimerEventService_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTimerEvent/TimerEventService:1.0');
  if p <> nil then
    result := ICosTimerEvent_TimerEventService(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTimerEvent/TimerEventService:1.0') then
        begin
          stub := TCosTimerEvent_TimerEventService_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCosTimerEvent_TimerEventService.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTimerEvent/TimerEventService:1.0'
end;

//***********************************************************
// TCosTimerEvent_TimerEventService_stub
//***********************************************************
function TCosTimerEvent_TimerEventService_stub.register(const event_interface: IPushConsumer; const data: IAny): ICosTimerEvent_TimerEventHandler;
var
  req: IStaticRequest;
  _event_interface: IStaticAny;
  _data: IStaticAny;
  _result: IStaticAny;
begin
  _event_interface := StaticAny(PushConsumer_marshaller,@event_interface);
  _data := StaticAny(stat_any,@data);
  _result := StaticAny(CosTimerEvent_TimerEventHandler_marshaller, @result);
  req := StaticRequest(self,'register');
  req.add_in_arg(_event_interface);
  req.add_in_arg(_data);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TCosTimerEvent_TimerEventService_stub.unregister(const timer_event_handler: ICosTimerEvent_TimerEventHandler);
var
  req: IStaticRequest;
  _timer_event_handler: IStaticAny;
begin
  _timer_event_handler := StaticAny(CosTimerEvent_TimerEventHandler_marshaller,@timer_event_handler);
  req := StaticRequest(self,'unregister');
  req.add_in_arg(_timer_event_handler);
  req.invoke;
  dorb_static_throw(req);
end;

function TCosTimerEvent_TimerEventService_stub.event_time(const timer_event: TCosTimerEvent_TimerEventT): ICosTime_UTO;
var
  req: IStaticRequest;
  _timer_event: IStaticAny;
  _result: IStaticAny;
begin
  _timer_event := StaticAny(CosTimerEvent_TimerEventT_marshaller,@timer_event);
  _result := StaticAny(CosTime_UTO_marshaller, @result);
  req := StaticRequest(self,'event_time');
  req.add_in_arg(_timer_event);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TCosTimerEvent_TimerEventService_stub_clp
//***********************************************************
function TCosTimerEvent_TimerEventService_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTimerEvent/TimerEventService:1.0' then
    begin
      result := Pointer(self as ICosTimerEvent_TimerEventService);
      exit;
  end;
end;

function TCosTimerEvent_TimerEventService_stub_clp.register(const event_interface: IPushConsumer; const data: IAny): ICosTimerEvent_TimerEventHandler;
var
  _srv: IServant;
  srv: ICosTimerEvent_TimerEventService;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTimerEvent_TimerEventService_serv._narrow(_srv);
      if srv <> nil then
        result := srv.register(event_interface, data)
    end;
  _postinvoke();
end;

procedure TCosTimerEvent_TimerEventService_stub_clp.unregister(const timer_event_handler: ICosTimerEvent_TimerEventHandler);
var
  _srv: IServant;
  srv: ICosTimerEvent_TimerEventService;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTimerEvent_TimerEventService_serv._narrow(_srv);
      if srv <> nil then
        srv.unregister(timer_event_handler)
    end;
  _postinvoke();
end;

function TCosTimerEvent_TimerEventService_stub_clp.event_time(const timer_event: TCosTimerEvent_TimerEventT): ICosTime_UTO;
var
  _srv: IServant;
  srv: ICosTimerEvent_TimerEventService;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCosTimerEvent_TimerEventService_serv._narrow(_srv);
      if srv <> nil then
        result := srv.event_time(timer_event)
    end;
  _postinvoke();
end;

//***********************************************************
// TCosTimerEvent_TimerEventService_serv
//***********************************************************
function TCosTimerEvent_TimerEventService_serv._this(): ICosTimerEvent_TimerEventService;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCosTimerEvent_TimerEventService._narrow(obj);
end;

function TCosTimerEvent_TimerEventService_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTimerEvent/TimerEventService:1.0';
end;

function TCosTimerEvent_TimerEventService_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTimerEvent/TimerEventService:1.0';
end;

function TCosTimerEvent_TimerEventService_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCosTimerEvent_TimerEventService_stub_clp.Create(poa,obj);
end;

procedure TCosTimerEvent_TimerEventService_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCosTimerEvent_TimerEventService_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTimerEvent/TimerEventService:1.0' then
    begin
      result := Pointer(ICosTimerEvent_TimerEventService(self));
      exit;
    end;
end;

class function TCosTimerEvent_TimerEventService_serv._narrow(const srv : IServant): ICosTimerEvent_TimerEventService;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTimerEvent/TimerEventService:1.0');
  if p <> nil then
    result := ICosTimerEvent_TimerEventService(p)
end;

function TCosTimerEvent_TimerEventService_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  register_result: ICosTimerEvent_TimerEventHandler;
  register_event_interface: IPushConsumer;
  register_data: IAny;
  unregister_timer_event_handler: ICosTimerEvent_TimerEventHandler;
  event_time_result: ICosTime_UTO;
  event_time_timer_event: TCosTimerEvent_TimerEventT;
begin
  result := true;
  if req.op_name = 'register' then
    begin
      req.add_in_arg(StaticAny(PushConsumer_marshaller,@register_event_interface) as IStaticAny);
      req.add_in_arg(StaticAny(stat_any,@register_data) as IStaticAny);
      req.set_result(StaticAny(CosTimerEvent_TimerEventHandler_marshaller,@register_result) as IStaticAny);
      if not req.read_args() then  exit;
      register_result := register(register_event_interface, register_data);
      req.write_results();
      exit;
    end
  else if req.op_name = 'unregister' then
    begin
      req.add_in_arg(StaticAny(CosTimerEvent_TimerEventHandler_marshaller,@unregister_timer_event_handler) as IStaticAny);
      if not req.read_args() then  exit;
      unregister(unregister_timer_event_handler);
      req.write_results();
      exit;
    end
  else if req.op_name = 'event_time' then
    begin
      req.add_in_arg(StaticAny(CosTimerEvent_TimerEventT_marshaller,@event_time_timer_event) as IStaticAny);
      req.set_result(StaticAny(CosTime_UTO_marshaller,@event_time_result) as IStaticAny);
      if not req.read_args() then  exit;
      event_time_result := event_time(event_time_timer_event);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCosTimerEvent_TimerEventService_marshaller
//***********************************************************
function TCosTimerEvent_TimerEventService_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICosTimerEvent_TimerEventService(addr^) := TCosTimerEvent_TimerEventService._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCosTimerEvent_TimerEventService_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICosTimerEvent_TimerEventService(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCosTimerEvent_TimerEventService_marshaller._free(var addr: Pointer);
begin
  ICosTimerEvent_TimerEventService(addr^) := nil;
end;

procedure TCosTimerEvent_TimerEventService_marshaller._create(var addr: Pointer);
begin
  ICosTimerEvent_TimerEventService(addr^) := TCosTimerEvent_TimerEventService_stub.Create();
end;

procedure TCosTimerEvent_TimerEventService_marshaller._assign(dst, src: Pointer);
begin
  ICosTimerEvent_TimerEventService(dst^) := ICosTimerEvent_TimerEventService(src^);
end;

function TCosTimerEvent_TimerEventService_marshaller.typecode: ITypeCode;
begin
  result := _tc_CosTimerEvent_TimerEventService.typecode;
end;

function any_to_CosTimerEvent_TimeType(const a: IAny; var val: TCosTimerEvent_TimeType): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_TimeType_marshaller,@val);
  result := a.to_static_any(stat);
end;

function CosTimerEvent_TimeType_to_any(const val: TCosTimerEvent_TimeType): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_TimeType_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_CosTimerEvent_EventStatus(const a: IAny; var val: TCosTimerEvent_EventStatus): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_EventStatus_marshaller,@val);
  result := a.to_static_any(stat);
end;

function CosTimerEvent_EventStatus_to_any(const val: TCosTimerEvent_EventStatus): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_EventStatus_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_CosTimerEvent_TimerEventT(const a: IAny; var val: TCosTimerEvent_TimerEventT): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_TimerEventT_marshaller,@val);
  result := a.to_static_any(stat);
end;

function CosTimerEvent_TimerEventT_to_any(const val: TCosTimerEvent_TimerEventT): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_TimerEventT_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_CosTimerEvent_TimerEventHandler(const a: IAny; var val: ICosTimerEvent_TimerEventHandler): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_TimerEventHandler_marshaller,@val);
  result := a.to_static_any(stat);
end;

function CosTimerEvent_TimerEventHandler_to_any(const val: ICosTimerEvent_TimerEventHandler): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_TimerEventHandler_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_CosTimerEvent_TimerEventService(const a: IAny; var val: ICosTimerEvent_TimerEventService): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_TimerEventService_marshaller,@val);
  result := a.to_static_any(stat);
end;

function CosTimerEvent_TimerEventService_to_any(const val: ICosTimerEvent_TimerEventService): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(CosTimerEvent_TimerEventService_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

initialization
  CosTimerEvent_TimeType_marshaller := TCosTimerEvent_TimeType_marshaller.Create();
  CosTimerEvent_EventStatus_marshaller := TCosTimerEvent_EventStatus_marshaller.Create();
  CosTimerEvent_TimerEventT_marshaller := TCosTimerEvent_TimerEventT_marshaller.Create();
  CosTimerEvent_TimerEventHandler_marshaller := TCosTimerEvent_TimerEventHandler_marshaller.Create();
  CosTimerEvent_TimerEventService_marshaller := TCosTimerEvent_TimerEventService_marshaller.Create();
  _tc_CosTimerEvent_TimeType := CreateTypeCodeConst('010000001100000073000000010000002700000049444c3a6f6d672e6f72672f436f7354696d65724576656e742f54696d65547970653a'+
    '312e3000000900000054696d655479706500000000030000000b00000054544162736f6c75746500000b000000545452656c6174697665'+
    '00000b0000005454506572696f64696300');
  _tc_CosTimerEvent_EventStatus := CreateTypeCodeConst('010000001100000090000000010000002a00000049444c3a6f6d672e6f72672f436f7354696d65724576656e742f4576656e7453746174'+
    '75733a312e300000000c0000004576656e7453746174757300040000000a000000455354696d655365740000000e000000455354696d65'+
    '436c65617265640000000c0000004553547269676765726564001000000045534661696c65645472696767657200');
  _tc_CosTimerEvent_TimerEventT := CreateTypeCodeConst('010000000f00000058010000010000002a00000049444c3a6f6d672e6f72672f436f7354696d65724576656e742f54696d65724576656e'+
    '74543a312e300000000c00000054696d65724576656e7454000200000004000000757463000f000000ec000000010000001e0000004944'+
    '4c3a6f6d672e6f72672f54696d65426173652f557463543a312e30000000050000005574635400000000040000000500000074696d6500'+
    '0000001500000038000000010000001f00000049444c3a6f6d672e6f72672f54696d65426173652f54696d65543a312e30000006000000'+
    '54696d65540000001800000008000000696e6163636c6f000500000008000000696e616363686900040000000400000074646600150000'+
    '0038000000010000001e00000049444c3a6f6d672e6f72672f54696d65426173652f546466543a312e3000000005000000546466540000'+
    '0000020000000b0000006576656e745f6461746100000b000000');
  _tc_CosTimerEvent_TimerEventHandler := CreateTypeCodeConst('010000000e0000004e000000010000003000000049444c3a6f6d672e6f72672f436f7354696d65724576656e742f54696d65724576656e'+
    '7448616e646c65723a312e30001200000054696d65724576656e7448616e646c657200');
  _tc_CosTimerEvent_TimerEventService := CreateTypeCodeConst('010000000e0000004e000000010000003000000049444c3a6f6d672e6f72672f436f7354696d65724576656e742f54696d65724576656e'+
    '74536572766963653a312e30001200000054696d65724576656e745365727669636500');
end.
