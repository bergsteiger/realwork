// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -any -wpCosTransactions -i..\..\idl ..\..\idl\CosTransactions.idl" 
//                                                                            
unit CosTransactions;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, CosTransactions_int, value_int, value, poa_int, poa;

type

  TStatus_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TVote_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  Totid_t_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TTransIdentity_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TransIdentity_seq = Array of TTransIdentity;
  PTransIdentity_seq = ^TransIdentity_seq;

  TTransIdentity_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TPropagationContext_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  THeuristicRollback_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/HeuristicRollback:1.0 } 
  THeuristicRollback = class(UserException,IHeuristicRollback)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: THeuristicRollback); overload;
    constructor Create(); overload;
  end;

  THeuristicCommit_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/HeuristicCommit:1.0 } 
  THeuristicCommit = class(UserException,IHeuristicCommit)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: THeuristicCommit); overload;
    constructor Create(); overload;
  end;

  THeuristicMixed_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/HeuristicMixed:1.0 } 
  THeuristicMixed = class(UserException,IHeuristicMixed)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: THeuristicMixed); overload;
    constructor Create(); overload;
  end;

  THeuristicHazard_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/HeuristicHazard:1.0 } 
  THeuristicHazard = class(UserException,IHeuristicHazard)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: THeuristicHazard); overload;
    constructor Create(); overload;
  end;

  TSubtransactionsUnavailable_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/SubtransactionsUnavailable:1.0 } 
  TSubtransactionsUnavailable = class(UserException,ISubtransactionsUnavailable)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TSubtransactionsUnavailable); overload;
    constructor Create(); overload;
  end;

  TNotSubtransaction_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/NotSubtransaction:1.0 } 
  TNotSubtransaction = class(UserException,INotSubtransaction)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TNotSubtransaction); overload;
    constructor Create(); overload;
  end;

  TInactive_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/Inactive:1.0 } 
  TInactive = class(UserException,IInactive)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TInactive); overload;
    constructor Create(); overload;
  end;

  TNotPrepared_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/NotPrepared:1.0 } 
  TNotPrepared = class(UserException,INotPrepared)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TNotPrepared); overload;
    constructor Create(); overload;
  end;

  TNoTransaction_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/NoTransaction:1.0 } 
  TNoTransaction = class(UserException,INoTransaction)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TNoTransaction); overload;
    constructor Create(); overload;
  end;

  TInvalidControl_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/InvalidControl:1.0 } 
  TInvalidControl = class(UserException,IInvalidControl)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TInvalidControl); overload;
    constructor Create(); overload;
  end;

  TUnavailable_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/Unavailable:1.0 } 
  TUnavailable = class(UserException,IUnavailable)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TUnavailable); overload;
    constructor Create(); overload;
  end;

  TSynchronizationUnavailable_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/SynchronizationUnavailable:1.0 } 
  TSynchronizationUnavailable = class(UserException,ISynchronizationUnavailable)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TSynchronizationUnavailable); overload;
    constructor Create(); overload;
  end;

  {** IDL:omg.org/CosTransactions/Current:1.0 } 
  TCurrent = class(TCORBA_Current,ICurrent)
  protected
    procedure _begin; virtual; abstract;
    procedure commit(const report_heuristics: Boolean); virtual; abstract;
    procedure rollback; virtual; abstract;
    procedure rollback_only; virtual; abstract;
    function get_status: TStatus; virtual; abstract;
    function get_transaction_name: AnsiString; virtual; abstract;
    procedure set_timeout(const seconds: _ulong); virtual; abstract;
    function get_control: IControl; virtual; abstract;
    function suspend: IControl; virtual; abstract;
    procedure resume(const which: IControl); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICurrent;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** IDL:omg.org/CosTransactions/TransactionFactory:1.0 } 
  TTransactionFactory = class(TORBObject,ITransactionFactory)
  protected
    function _create(const time_out: _ulong): IControl; virtual; abstract;
    function recreate(const ctx: TPropagationContext): IControl; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ITransactionFactory;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/TransactionFactory:1.0} 
  TTransactionFactory_stub = class(TTransactionFactory)
  protected
    function _create(const time_out: _ulong): IControl; override;
    function recreate(const ctx: TPropagationContext): IControl; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/TransactionFactory:1.0} 
  TTransactionFactory_stub_clp = class(TPOAStub,IPOAStub,ITransactionFactory)
  protected
    function _create(const time_out: _ulong): IControl; virtual;
    function recreate(const ctx: TPropagationContext): IControl; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/TransactionFactory:1.0} 
  TTransactionFactory_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ITransactionFactory)
  protected
    function _create(const time_out: _ulong): IControl; virtual; abstract;
    function recreate(const ctx: TPropagationContext): IControl; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ITransactionFactory;
    class function _narrow(const srv : IServant): ITransactionFactory;
  end;

  TTransactionFactory_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/Control:1.0 } 
  TControl = class(TORBObject,IControl)
  protected
    function get_terminator: ITerminator; virtual; abstract;
    function get_coordinator: ICoordinator; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IControl;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/Control:1.0} 
  TControl_stub = class(TControl)
  protected
    function get_terminator: ITerminator; override;
    function get_coordinator: ICoordinator; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/Control:1.0} 
  TControl_stub_clp = class(TPOAStub,IPOAStub,IControl)
  protected
    function get_terminator: ITerminator; virtual;
    function get_coordinator: ICoordinator; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/Control:1.0} 
  TControl_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IControl)
  protected
    function get_terminator: ITerminator; virtual; abstract;
    function get_coordinator: ICoordinator; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IControl;
    class function _narrow(const srv : IServant): IControl;
  end;

  TControl_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/Terminator:1.0 } 
  TTerminator = class(TORBObject,ITerminator)
  protected
    procedure commit(const report_heuristics: Boolean); virtual; abstract;
    procedure rollback; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ITerminator;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/Terminator:1.0} 
  TTerminator_stub = class(TTerminator)
  protected
    procedure commit(const report_heuristics: Boolean); override;
    procedure rollback; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/Terminator:1.0} 
  TTerminator_stub_clp = class(TPOAStub,IPOAStub,ITerminator)
  protected
    procedure commit(const report_heuristics: Boolean); virtual;
    procedure rollback; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/Terminator:1.0} 
  TTerminator_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ITerminator)
  protected
    procedure commit(const report_heuristics: Boolean); virtual; abstract;
    procedure rollback; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ITerminator;
    class function _narrow(const srv : IServant): ITerminator;
  end;

  TTerminator_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/Coordinator:1.0 } 
  TCoordinator = class(TORBObject,ICoordinator)
  protected
    function get_status: TStatus; virtual; abstract;
    function get_parent_status: TStatus; virtual; abstract;
    function get_top_level_status: TStatus; virtual; abstract;
    function is_same_transaction(const tc: ICoordinator): Boolean; virtual; abstract;
    function is_related_transaction(const tc: ICoordinator): Boolean; virtual; abstract;
    function is_ancestor_transaction(const tc: ICoordinator): Boolean; virtual; abstract;
    function is_descendant_transaction(const tc: ICoordinator): Boolean; virtual; abstract;
    function is_top_level_transaction: Boolean; virtual; abstract;
    function hash_transaction: _ulong; virtual; abstract;
    function hash_top_level_tran: _ulong; virtual; abstract;
    function register_resource(const r: IResource): IRecoveryCoordinator; virtual; abstract;
    procedure register_synchronization(const sync: ISynchronization); virtual; abstract;
    procedure register_subtran_aware(const r: ISubtransactionAwareResource); virtual; abstract;
    procedure rollback_only; virtual; abstract;
    function get_transaction_name: AnsiString; virtual; abstract;
    function create_subtransaction: IControl; virtual; abstract;
    function get_txcontext: TPropagationContext; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICoordinator;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/Coordinator:1.0} 
  TCoordinator_stub = class(TCoordinator)
  protected
    function get_status: TStatus; override;
    function get_parent_status: TStatus; override;
    function get_top_level_status: TStatus; override;
    function is_same_transaction(const tc: ICoordinator): Boolean; override;
    function is_related_transaction(const tc: ICoordinator): Boolean; override;
    function is_ancestor_transaction(const tc: ICoordinator): Boolean; override;
    function is_descendant_transaction(const tc: ICoordinator): Boolean; override;
    function is_top_level_transaction: Boolean; override;
    function hash_transaction: _ulong; override;
    function hash_top_level_tran: _ulong; override;
    function register_resource(const r: IResource): IRecoveryCoordinator; override;
    procedure register_synchronization(const sync: ISynchronization); override;
    procedure register_subtran_aware(const r: ISubtransactionAwareResource); override;
    procedure rollback_only; override;
    function get_transaction_name: AnsiString; override;
    function create_subtransaction: IControl; override;
    function get_txcontext: TPropagationContext; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/Coordinator:1.0} 
  TCoordinator_stub_clp = class(TPOAStub,IPOAStub,ICoordinator)
  protected
    function get_status: TStatus; virtual;
    function get_parent_status: TStatus; virtual;
    function get_top_level_status: TStatus; virtual;
    function is_same_transaction(const tc: ICoordinator): Boolean; virtual;
    function is_related_transaction(const tc: ICoordinator): Boolean; virtual;
    function is_ancestor_transaction(const tc: ICoordinator): Boolean; virtual;
    function is_descendant_transaction(const tc: ICoordinator): Boolean; virtual;
    function is_top_level_transaction: Boolean; virtual;
    function hash_transaction: _ulong; virtual;
    function hash_top_level_tran: _ulong; virtual;
    function register_resource(const r: IResource): IRecoveryCoordinator; virtual;
    procedure register_synchronization(const sync: ISynchronization); virtual;
    procedure register_subtran_aware(const r: ISubtransactionAwareResource); virtual;
    procedure rollback_only; virtual;
    function get_transaction_name: AnsiString; virtual;
    function create_subtransaction: IControl; virtual;
    function get_txcontext: TPropagationContext; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/Coordinator:1.0} 
  TCoordinator_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ICoordinator)
  protected
    function get_status: TStatus; virtual; abstract;
    function get_parent_status: TStatus; virtual; abstract;
    function get_top_level_status: TStatus; virtual; abstract;
    function is_same_transaction(const tc: ICoordinator): Boolean; virtual; abstract;
    function is_related_transaction(const tc: ICoordinator): Boolean; virtual; abstract;
    function is_ancestor_transaction(const tc: ICoordinator): Boolean; virtual; abstract;
    function is_descendant_transaction(const tc: ICoordinator): Boolean; virtual; abstract;
    function is_top_level_transaction: Boolean; virtual; abstract;
    function hash_transaction: _ulong; virtual; abstract;
    function hash_top_level_tran: _ulong; virtual; abstract;
    function register_resource(const r: IResource): IRecoveryCoordinator; virtual; abstract;
    procedure register_synchronization(const sync: ISynchronization); virtual; abstract;
    procedure register_subtran_aware(const r: ISubtransactionAwareResource); virtual; abstract;
    procedure rollback_only; virtual; abstract;
    function get_transaction_name: AnsiString; virtual; abstract;
    function create_subtransaction: IControl; virtual; abstract;
    function get_txcontext: TPropagationContext; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICoordinator;
    class function _narrow(const srv : IServant): ICoordinator;
  end;

  TCoordinator_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0 } 
  TRecoveryCoordinator = class(TORBObject,IRecoveryCoordinator)
  protected
    function replay_completion(const r: IResource): TStatus; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IRecoveryCoordinator;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0} 
  TRecoveryCoordinator_stub = class(TRecoveryCoordinator)
  protected
    function replay_completion(const r: IResource): TStatus; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0} 
  TRecoveryCoordinator_stub_clp = class(TPOAStub,IPOAStub,IRecoveryCoordinator)
  protected
    function replay_completion(const r: IResource): TStatus; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0} 
  TRecoveryCoordinator_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IRecoveryCoordinator)
  protected
    function replay_completion(const r: IResource): TStatus; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IRecoveryCoordinator;
    class function _narrow(const srv : IServant): IRecoveryCoordinator;
  end;

  TRecoveryCoordinator_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/Resource:1.0 } 
  TResource = class(TORBObject,IResource)
  protected
    function prepare: TVote; virtual; abstract;
    procedure rollback; virtual; abstract;
    procedure commit; virtual; abstract;
    procedure commit_one_phase; virtual; abstract;
    procedure forget; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IResource;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/Resource:1.0} 
  TResource_stub = class(TResource)
  protected
    function prepare: TVote; override;
    procedure rollback; override;
    procedure commit; override;
    procedure commit_one_phase; override;
    procedure forget; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/Resource:1.0} 
  TResource_stub_clp = class(TPOAStub,IPOAStub,IResource)
  protected
    function prepare: TVote; virtual;
    procedure rollback; virtual;
    procedure commit; virtual;
    procedure commit_one_phase; virtual;
    procedure forget; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/Resource:1.0} 
  TResource_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IResource)
  protected
    function prepare: TVote; virtual; abstract;
    procedure rollback; virtual; abstract;
    procedure commit; virtual; abstract;
    procedure commit_one_phase; virtual; abstract;
    procedure forget; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IResource;
    class function _narrow(const srv : IServant): IResource;
  end;

  TResource_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/TransactionalObject:1.0 } 
  TTransactionalObject = class(TORBObject,ITransactionalObject)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ITransactionalObject;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/TransactionalObject:1.0} 
  TTransactionalObject_stub = class(TTransactionalObject)
  protected
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/TransactionalObject:1.0} 
  TTransactionalObject_stub_clp = class(TPOAStub,IPOAStub,ITransactionalObject)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/TransactionalObject:1.0} 
  TTransactionalObject_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,ITransactionalObject)
  protected
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ITransactionalObject;
    class function _narrow(const srv : IServant): ITransactionalObject;
  end;

  TTransactionalObject_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/Synchronization:1.0 } 
  TSynchronization = class(TTransactionalObject,ISynchronization)
  protected
    procedure before_completion; virtual; abstract;
    procedure after_completion(const status: TStatus); virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ISynchronization;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/Synchronization:1.0} 
  TSynchronization_stub = class(TSynchronization)
  protected
    procedure before_completion; override;
    procedure after_completion(const status: TStatus); override;
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/Synchronization:1.0} 
  TSynchronization_stub_clp = class(TTransactionalObject_stub_clp,ISynchronization)
  protected
    procedure before_completion; virtual;
    procedure after_completion(const status: TStatus); virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/Synchronization:1.0} 
  TSynchronization_serv = class(TTransactionalObject_serv,ISynchronization)
  protected
    procedure before_completion; virtual; abstract;
    procedure after_completion(const status: TStatus); virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ISynchronization;
    class function _narrow(const srv : IServant): ISynchronization;
  end;

  TSynchronization_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0 } 
  TSubtransactionAwareResource = class(TResource,ISubtransactionAwareResource)
  protected
    procedure commit_subtransaction(const parent: ICoordinator); virtual; abstract;
    procedure rollback_subtransaction; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ISubtransactionAwareResource;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0} 
  TSubtransactionAwareResource_stub = class(TSubtransactionAwareResource)
  protected
    function prepare: TVote; override;
    procedure rollback; override;
    procedure commit; override;
    procedure commit_one_phase; override;
    procedure forget; override;
    procedure commit_subtransaction(const parent: ICoordinator); override;
    procedure rollback_subtransaction; override;
  end;

  {** POA stub for interface IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0} 
  TSubtransactionAwareResource_stub_clp = class(TResource_stub_clp,ISubtransactionAwareResource)
  protected
    procedure commit_subtransaction(const parent: ICoordinator); virtual;
    procedure rollback_subtransaction; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0} 
  TSubtransactionAwareResource_serv = class(TResource_serv,ISubtransactionAwareResource)
  protected
    procedure commit_subtransaction(const parent: ICoordinator); virtual; abstract;
    procedure rollback_subtransaction; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ISubtransactionAwareResource;
    class function _narrow(const srv : IServant): ISubtransactionAwareResource;
  end;

  TSubtransactionAwareResource_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  function Status_to_any(const val: TStatus): IAny;
  function any_to_Status(const a: IAny; var val: TStatus): Boolean;

  function Vote_to_any(const val: TVote): IAny;
  function any_to_Vote(const a: IAny; var val: TVote): Boolean;

  function otid_t_to_any(const val: Totid_t): IAny;
  function any_to_otid_t(const a: IAny; var val: Totid_t): Boolean;

  function TransIdentity_to_any(const val: TTransIdentity): IAny;
  function any_to_TransIdentity(const a: IAny; var val: TTransIdentity): Boolean;

  function TransIdentity_seq_to_any(const val): IAny;
  function any_to_TransIdentity_seq(const a: IAny; var val): Boolean;

  function PropagationContext_to_any(const val: TPropagationContext): IAny;
  function any_to_PropagationContext(const a: IAny; var val: TPropagationContext): Boolean;

  function HeuristicRollback_to_any(const val: IHeuristicRollback): IAny;
  function any_to_HeuristicRollback(const a: IAny; var val: IHeuristicRollback): Boolean;

  function HeuristicCommit_to_any(const val: IHeuristicCommit): IAny;
  function any_to_HeuristicCommit(const a: IAny; var val: IHeuristicCommit): Boolean;

  function HeuristicMixed_to_any(const val: IHeuristicMixed): IAny;
  function any_to_HeuristicMixed(const a: IAny; var val: IHeuristicMixed): Boolean;

  function HeuristicHazard_to_any(const val: IHeuristicHazard): IAny;
  function any_to_HeuristicHazard(const a: IAny; var val: IHeuristicHazard): Boolean;

  function SubtransactionsUnavailable_to_any(const val: ISubtransactionsUnavailable): IAny;
  function any_to_SubtransactionsUnavailable(const a: IAny; var val: ISubtransactionsUnavailable): Boolean;

  function NotSubtransaction_to_any(const val: INotSubtransaction): IAny;
  function any_to_NotSubtransaction(const a: IAny; var val: INotSubtransaction): Boolean;

  function Inactive_to_any(const val: IInactive): IAny;
  function any_to_Inactive(const a: IAny; var val: IInactive): Boolean;

  function NotPrepared_to_any(const val: INotPrepared): IAny;
  function any_to_NotPrepared(const a: IAny; var val: INotPrepared): Boolean;

  function NoTransaction_to_any(const val: INoTransaction): IAny;
  function any_to_NoTransaction(const a: IAny; var val: INoTransaction): Boolean;

  function InvalidControl_to_any(const val: IInvalidControl): IAny;
  function any_to_InvalidControl(const a: IAny; var val: IInvalidControl): Boolean;

  function Unavailable_to_any(const val: IUnavailable): IAny;
  function any_to_Unavailable(const a: IAny; var val: IUnavailable): Boolean;

  function SynchronizationUnavailable_to_any(const val: ISynchronizationUnavailable): IAny;
  function any_to_SynchronizationUnavailable(const a: IAny; var val: ISynchronizationUnavailable): Boolean;

  function TransactionFactory_to_any(const val: ITransactionFactory): IAny;
  function any_to_TransactionFactory(const a: IAny; var val: ITransactionFactory): Boolean;

  function Control_to_any(const val: IControl): IAny;
  function any_to_Control(const a: IAny; var val: IControl): Boolean;

  function Terminator_to_any(const val: ITerminator): IAny;
  function any_to_Terminator(const a: IAny; var val: ITerminator): Boolean;

  function Coordinator_to_any(const val: ICoordinator): IAny;
  function any_to_Coordinator(const a: IAny; var val: ICoordinator): Boolean;

  function RecoveryCoordinator_to_any(const val: IRecoveryCoordinator): IAny;
  function any_to_RecoveryCoordinator(const a: IAny; var val: IRecoveryCoordinator): Boolean;

  function Resource_to_any(const val: IResource): IAny;
  function any_to_Resource(const a: IAny; var val: IResource): Boolean;

  function TransactionalObject_to_any(const val: ITransactionalObject): IAny;
  function any_to_TransactionalObject(const a: IAny; var val: ITransactionalObject): Boolean;

  function Synchronization_to_any(const val: ISynchronization): IAny;
  function any_to_Synchronization(const a: IAny; var val: ISynchronization): Boolean;

  function SubtransactionAwareResource_to_any(const val: ISubtransactionAwareResource): IAny;
  function any_to_SubtransactionAwareResource(const a: IAny; var val: ISubtransactionAwareResource): Boolean;

var
  Status_marshaller : IStaticTypeInfo;
  Vote_marshaller : IStaticTypeInfo;
  otid_t_marshaller : IStaticTypeInfo;
  TransIdentity_marshaller : IStaticTypeInfo;
  TransIdentity_seq_marshaller : IStaticTypeInfo;
  PropagationContext_marshaller : IStaticTypeInfo;
  HeuristicRollback_marshaller : IStaticTypeInfo;
  HeuristicCommit_marshaller : IStaticTypeInfo;
  HeuristicMixed_marshaller : IStaticTypeInfo;
  HeuristicHazard_marshaller : IStaticTypeInfo;
  SubtransactionsUnavailable_marshaller : IStaticTypeInfo;
  NotSubtransaction_marshaller : IStaticTypeInfo;
  Inactive_marshaller : IStaticTypeInfo;
  NotPrepared_marshaller : IStaticTypeInfo;
  NoTransaction_marshaller : IStaticTypeInfo;
  InvalidControl_marshaller : IStaticTypeInfo;
  Unavailable_marshaller : IStaticTypeInfo;
  SynchronizationUnavailable_marshaller : IStaticTypeInfo;
  TransactionFactory_marshaller : IStaticTypeInfo;
  Control_marshaller : IStaticTypeInfo;
  Terminator_marshaller : IStaticTypeInfo;
  Coordinator_marshaller : IStaticTypeInfo;
  RecoveryCoordinator_marshaller : IStaticTypeInfo;
  Resource_marshaller : IStaticTypeInfo;
  TransactionalObject_marshaller : IStaticTypeInfo;
  Synchronization_marshaller : IStaticTypeInfo;
  SubtransactionAwareResource_marshaller : IStaticTypeInfo;
  _tc_Status : ITypeCodeConst;
  _tc_Vote : ITypeCodeConst;
  _tc_otid_t : ITypeCodeConst;
  _tc_TransIdentity : ITypeCodeConst;
  _tc_TransIdentity_seq : ITypeCodeConst;
  _tc_PropagationContext : ITypeCodeConst;
  _tc_HeuristicRollback : ITypeCodeConst;
  _tc_HeuristicCommit : ITypeCodeConst;
  _tc_HeuristicMixed : ITypeCodeConst;
  _tc_HeuristicHazard : ITypeCodeConst;
  _tc_SubtransactionsUnavailable : ITypeCodeConst;
  _tc_NotSubtransaction : ITypeCodeConst;
  _tc_Inactive : ITypeCodeConst;
  _tc_NotPrepared : ITypeCodeConst;
  _tc_NoTransaction : ITypeCodeConst;
  _tc_InvalidControl : ITypeCodeConst;
  _tc_Unavailable : ITypeCodeConst;
  _tc_SynchronizationUnavailable : ITypeCodeConst;
  _tc_TransactionFactory : ITypeCodeConst;
  _tc_Control : ITypeCodeConst;
  _tc_Terminator : ITypeCodeConst;
  _tc_Coordinator : ITypeCodeConst;
  _tc_RecoveryCoordinator : ITypeCodeConst;
  _tc_Resource : ITypeCodeConst;
  _tc_TransactionalObject : ITypeCodeConst;
  _tc_Synchronization : ITypeCodeConst;
  _tc_SubtransactionAwareResource : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TStatus_marshaller
//***********************************************************
function TStatus_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TStatus_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TStatus_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TStatus_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TStatus_marshaller._assign(dst, src: Pointer);
begin
  TStatus(dst^) := TStatus(src^);
end;

function TStatus_marshaller.typecode: ITypeCode;
begin
  result := _tc_Status.typecode;
end;

//***********************************************************
// TVote_marshaller
//***********************************************************
function TVote_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TVote_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TVote_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TVote_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TVote_marshaller._assign(dst, src: Pointer);
begin
  TVote(dst^) := TVote(src^);
end;

function TVote_marshaller.typecode: ITypeCode;
begin
  result := _tc_Vote.typecode;
end;

//***********************************************************
// Totid_t_marshaller
//***********************************************************
function Totid_t_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: CosTransactions_int.Totid_t;
begin
  result := false;
  if not stat_long.demarshal(dec,@struct.formatID) then exit;
  if not stat_long.demarshal(dec,@struct.bqual_length) then exit;
  if not stat_seq_octet.demarshal(dec,@struct.tid) then exit;
  CosTransactions_int.Totid_t(addr^) := struct;
  result := true;
end;

procedure Totid_t_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: CosTransactions_int.Totid_t;
begin
  struct := CosTransactions_int.Totid_t(addr^);
  stat_long.marshal(enc,@struct.formatID);
  stat_long.marshal(enc,@struct.bqual_length);
  stat_seq_octet.marshal(enc,@struct.tid);
end;

procedure Totid_t_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(CosTransactions_int.Totid_t(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure Totid_t_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(CosTransactions_int.Totid_t));
{$HINTS OFF}
  System.Initialize(CosTransactions_int.Totid_t(addr^));
{$HINTS ON}
end;

procedure Totid_t_marshaller._assign(dst, src: Pointer);
begin
  CosTransactions_int.Totid_t(dst^) := CosTransactions_int.Totid_t(src^);
end;

function Totid_t_marshaller.typecode: ITypeCode;
begin
  result := _tc_otid_t.typecode;
end;

//***********************************************************
// TTransIdentity_marshaller
//***********************************************************
function TTransIdentity_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: CosTransactions_int.TTransIdentity;
begin
  result := false;
  if not Coordinator_marshaller.demarshal(dec,@struct.coord) then exit;
  if not Terminator_marshaller.demarshal(dec,@struct.term) then exit;
  if not otid_t_marshaller.demarshal(dec,@struct.otid) then exit;
  CosTransactions_int.TTransIdentity(addr^) := struct;
  result := true;
end;

procedure TTransIdentity_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: CosTransactions_int.TTransIdentity;
begin
  struct := CosTransactions_int.TTransIdentity(addr^);
  Coordinator_marshaller.marshal(enc,@struct.coord);
  Terminator_marshaller.marshal(enc,@struct.term);
  otid_t_marshaller.marshal(enc,@struct.otid);
end;

procedure TTransIdentity_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(CosTransactions_int.TTransIdentity(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TTransIdentity_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(CosTransactions_int.TTransIdentity));
{$HINTS OFF}
  System.Initialize(CosTransactions_int.TTransIdentity(addr^));
{$HINTS ON}
end;

procedure TTransIdentity_marshaller._assign(dst, src: Pointer);
begin
  CosTransactions_int.TTransIdentity(dst^) := CosTransactions_int.TTransIdentity(src^);
end;

function TTransIdentity_marshaller.typecode: ITypeCode;
begin
  result := _tc_TransIdentity.typecode;
end;

//***********************************************************
// TTransIdentity_seq_marshaller
//***********************************************************

function TTransIdentity_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TTransIdentity;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(TransIdentity_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not TransIdentity_marshaller.demarshal(dec,@val) then exit;
        TransIdentity_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TTransIdentity_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(TransIdentity_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      TransIdentity_marshaller.marshal(enc,@TransIdentity_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TTransIdentity_seq_marshaller._free(var addr: Pointer);
begin
  setLength(TransIdentity_seq(addr^),0);
  freemem(addr);
end;

procedure TTransIdentity_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TTransIdentity_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TTransIdentity_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_TransIdentity_seq.typecode;
end;

//***********************************************************
// TPropagationContext_marshaller
//***********************************************************
function TPropagationContext_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: CosTransactions_int.TPropagationContext;
begin
  result := false;
  if not stat_ulong.demarshal(dec,@struct.timeout) then exit;
  if not TransIdentity_marshaller.demarshal(dec,@struct.current) then exit;
  if not TransIdentity_seq_marshaller.demarshal(dec,@struct.parents) then exit;
  if not stat_any.demarshal(dec,@struct.implementation_specific_data) then exit;
  CosTransactions_int.TPropagationContext(addr^) := struct;
  result := true;
end;

procedure TPropagationContext_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: CosTransactions_int.TPropagationContext;
begin
  struct := CosTransactions_int.TPropagationContext(addr^);
  stat_ulong.marshal(enc,@struct.timeout);
  TransIdentity_marshaller.marshal(enc,@struct.current);
  TransIdentity_seq_marshaller.marshal(enc,@struct.parents);
  stat_any.marshal(enc,@struct.implementation_specific_data);
end;

procedure TPropagationContext_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(CosTransactions_int.TPropagationContext(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TPropagationContext_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(CosTransactions_int.TPropagationContext));
{$HINTS OFF}
  System.Initialize(CosTransactions_int.TPropagationContext(addr^));
{$HINTS ON}
end;

procedure TPropagationContext_marshaller._assign(dst, src: Pointer);
begin
  CosTransactions_int.TPropagationContext(dst^) := CosTransactions_int.TPropagationContext(src^);
end;

function TPropagationContext_marshaller.typecode: ITypeCode;
begin
  result := _tc_PropagationContext.typecode;
end;

//***********************************************************
// THeuristicRollback_marshaller
//***********************************************************
function THeuristicRollback_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure THeuristicRollback_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/HeuristicRollback:1.0');
  enc.except_end;
end;

procedure THeuristicRollback_marshaller._free(var addr: Pointer);
begin
  IHeuristicRollback(addr^) := nil;
end;

procedure THeuristicRollback_marshaller._create(var addr: Pointer);
begin
  IHeuristicRollback(addr^) := THeuristicRollback.Create();
end;

procedure THeuristicRollback_marshaller._assign(dst, src: Pointer);
begin
  IHeuristicRollback(dst^) := IHeuristicRollback(src^);
end;

function THeuristicRollback_marshaller.typecode: ITypeCode;
begin
  result := _tc_HeuristicRollback.typecode;
end;

//***********************************************************
// THeuristicRollback
//***********************************************************
constructor THeuristicRollback.Create(ex: THeuristicRollback);
begin
  inherited Create();
end;

procedure THeuristicRollback.throw;
begin
  raise THeuristicRollback.Create(self);
end;

function THeuristicRollback.clone(): IORBException;
begin
  result := THeuristicRollback.Create(self);
end;

procedure THeuristicRollback.encode(const enc: IEncoder);
var
  int : IHeuristicRollback;
begin
  int := self;
  HeuristicRollback_marshaller.marshal(enc,@int);
end;

procedure THeuristicRollback.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicRollback_marshaller, Self);
  a.from_static_any(stat);
end;

constructor THeuristicRollback.Create();
begin
  inherited Create();
end;

function THeuristicRollback.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/HeuristicRollback:1.0';
end;

//***********************************************************
// THeuristicCommit_marshaller
//***********************************************************
function THeuristicCommit_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure THeuristicCommit_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/HeuristicCommit:1.0');
  enc.except_end;
end;

procedure THeuristicCommit_marshaller._free(var addr: Pointer);
begin
  IHeuristicCommit(addr^) := nil;
end;

procedure THeuristicCommit_marshaller._create(var addr: Pointer);
begin
  IHeuristicCommit(addr^) := THeuristicCommit.Create();
end;

procedure THeuristicCommit_marshaller._assign(dst, src: Pointer);
begin
  IHeuristicCommit(dst^) := IHeuristicCommit(src^);
end;

function THeuristicCommit_marshaller.typecode: ITypeCode;
begin
  result := _tc_HeuristicCommit.typecode;
end;

//***********************************************************
// THeuristicCommit
//***********************************************************
constructor THeuristicCommit.Create(ex: THeuristicCommit);
begin
  inherited Create();
end;

procedure THeuristicCommit.throw;
begin
  raise THeuristicCommit.Create(self);
end;

function THeuristicCommit.clone(): IORBException;
begin
  result := THeuristicCommit.Create(self);
end;

procedure THeuristicCommit.encode(const enc: IEncoder);
var
  int : IHeuristicCommit;
begin
  int := self;
  HeuristicCommit_marshaller.marshal(enc,@int);
end;

procedure THeuristicCommit.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicCommit_marshaller, Self);
  a.from_static_any(stat);
end;

constructor THeuristicCommit.Create();
begin
  inherited Create();
end;

function THeuristicCommit.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/HeuristicCommit:1.0';
end;

//***********************************************************
// THeuristicMixed_marshaller
//***********************************************************
function THeuristicMixed_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure THeuristicMixed_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/HeuristicMixed:1.0');
  enc.except_end;
end;

procedure THeuristicMixed_marshaller._free(var addr: Pointer);
begin
  IHeuristicMixed(addr^) := nil;
end;

procedure THeuristicMixed_marshaller._create(var addr: Pointer);
begin
  IHeuristicMixed(addr^) := THeuristicMixed.Create();
end;

procedure THeuristicMixed_marshaller._assign(dst, src: Pointer);
begin
  IHeuristicMixed(dst^) := IHeuristicMixed(src^);
end;

function THeuristicMixed_marshaller.typecode: ITypeCode;
begin
  result := _tc_HeuristicMixed.typecode;
end;

//***********************************************************
// THeuristicMixed
//***********************************************************
constructor THeuristicMixed.Create(ex: THeuristicMixed);
begin
  inherited Create();
end;

procedure THeuristicMixed.throw;
begin
  raise THeuristicMixed.Create(self);
end;

function THeuristicMixed.clone(): IORBException;
begin
  result := THeuristicMixed.Create(self);
end;

procedure THeuristicMixed.encode(const enc: IEncoder);
var
  int : IHeuristicMixed;
begin
  int := self;
  HeuristicMixed_marshaller.marshal(enc,@int);
end;

procedure THeuristicMixed.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicMixed_marshaller, Self);
  a.from_static_any(stat);
end;

constructor THeuristicMixed.Create();
begin
  inherited Create();
end;

function THeuristicMixed.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/HeuristicMixed:1.0';
end;

//***********************************************************
// THeuristicHazard_marshaller
//***********************************************************
function THeuristicHazard_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure THeuristicHazard_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/HeuristicHazard:1.0');
  enc.except_end;
end;

procedure THeuristicHazard_marshaller._free(var addr: Pointer);
begin
  IHeuristicHazard(addr^) := nil;
end;

procedure THeuristicHazard_marshaller._create(var addr: Pointer);
begin
  IHeuristicHazard(addr^) := THeuristicHazard.Create();
end;

procedure THeuristicHazard_marshaller._assign(dst, src: Pointer);
begin
  IHeuristicHazard(dst^) := IHeuristicHazard(src^);
end;

function THeuristicHazard_marshaller.typecode: ITypeCode;
begin
  result := _tc_HeuristicHazard.typecode;
end;

//***********************************************************
// THeuristicHazard
//***********************************************************
constructor THeuristicHazard.Create(ex: THeuristicHazard);
begin
  inherited Create();
end;

procedure THeuristicHazard.throw;
begin
  raise THeuristicHazard.Create(self);
end;

function THeuristicHazard.clone(): IORBException;
begin
  result := THeuristicHazard.Create(self);
end;

procedure THeuristicHazard.encode(const enc: IEncoder);
var
  int : IHeuristicHazard;
begin
  int := self;
  HeuristicHazard_marshaller.marshal(enc,@int);
end;

procedure THeuristicHazard.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicHazard_marshaller, Self);
  a.from_static_any(stat);
end;

constructor THeuristicHazard.Create();
begin
  inherited Create();
end;

function THeuristicHazard.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0';
end;

//***********************************************************
// TSubtransactionsUnavailable_marshaller
//***********************************************************
function TSubtransactionsUnavailable_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TSubtransactionsUnavailable_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/SubtransactionsUnavailable:1.0');
  enc.except_end;
end;

procedure TSubtransactionsUnavailable_marshaller._free(var addr: Pointer);
begin
  ISubtransactionsUnavailable(addr^) := nil;
end;

procedure TSubtransactionsUnavailable_marshaller._create(var addr: Pointer);
begin
  ISubtransactionsUnavailable(addr^) := TSubtransactionsUnavailable.Create();
end;

procedure TSubtransactionsUnavailable_marshaller._assign(dst, src: Pointer);
begin
  ISubtransactionsUnavailable(dst^) := ISubtransactionsUnavailable(src^);
end;

function TSubtransactionsUnavailable_marshaller.typecode: ITypeCode;
begin
  result := _tc_SubtransactionsUnavailable.typecode;
end;

//***********************************************************
// TSubtransactionsUnavailable
//***********************************************************
constructor TSubtransactionsUnavailable.Create(ex: TSubtransactionsUnavailable);
begin
  inherited Create();
end;

procedure TSubtransactionsUnavailable.throw;
begin
  raise TSubtransactionsUnavailable.Create(self);
end;

function TSubtransactionsUnavailable.clone(): IORBException;
begin
  result := TSubtransactionsUnavailable.Create(self);
end;

procedure TSubtransactionsUnavailable.encode(const enc: IEncoder);
var
  int : ISubtransactionsUnavailable;
begin
  int := self;
  SubtransactionsUnavailable_marshaller.marshal(enc,@int);
end;

procedure TSubtransactionsUnavailable.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(SubtransactionsUnavailable_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TSubtransactionsUnavailable.Create();
begin
  inherited Create();
end;

function TSubtransactionsUnavailable.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/SubtransactionsUnavailable:1.0';
end;

//***********************************************************
// TNotSubtransaction_marshaller
//***********************************************************
function TNotSubtransaction_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TNotSubtransaction_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/NotSubtransaction:1.0');
  enc.except_end;
end;

procedure TNotSubtransaction_marshaller._free(var addr: Pointer);
begin
  INotSubtransaction(addr^) := nil;
end;

procedure TNotSubtransaction_marshaller._create(var addr: Pointer);
begin
  INotSubtransaction(addr^) := TNotSubtransaction.Create();
end;

procedure TNotSubtransaction_marshaller._assign(dst, src: Pointer);
begin
  INotSubtransaction(dst^) := INotSubtransaction(src^);
end;

function TNotSubtransaction_marshaller.typecode: ITypeCode;
begin
  result := _tc_NotSubtransaction.typecode;
end;

//***********************************************************
// TNotSubtransaction
//***********************************************************
constructor TNotSubtransaction.Create(ex: TNotSubtransaction);
begin
  inherited Create();
end;

procedure TNotSubtransaction.throw;
begin
  raise TNotSubtransaction.Create(self);
end;

function TNotSubtransaction.clone(): IORBException;
begin
  result := TNotSubtransaction.Create(self);
end;

procedure TNotSubtransaction.encode(const enc: IEncoder);
var
  int : INotSubtransaction;
begin
  int := self;
  NotSubtransaction_marshaller.marshal(enc,@int);
end;

procedure TNotSubtransaction.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotSubtransaction_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TNotSubtransaction.Create();
begin
  inherited Create();
end;

function TNotSubtransaction.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/NotSubtransaction:1.0';
end;

//***********************************************************
// TInactive_marshaller
//***********************************************************
function TInactive_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TInactive_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/Inactive:1.0');
  enc.except_end;
end;

procedure TInactive_marshaller._free(var addr: Pointer);
begin
  IInactive(addr^) := nil;
end;

procedure TInactive_marshaller._create(var addr: Pointer);
begin
  IInactive(addr^) := TInactive.Create();
end;

procedure TInactive_marshaller._assign(dst, src: Pointer);
begin
  IInactive(dst^) := IInactive(src^);
end;

function TInactive_marshaller.typecode: ITypeCode;
begin
  result := _tc_Inactive.typecode;
end;

//***********************************************************
// TInactive
//***********************************************************
constructor TInactive.Create(ex: TInactive);
begin
  inherited Create();
end;

procedure TInactive.throw;
begin
  raise TInactive.Create(self);
end;

function TInactive.clone(): IORBException;
begin
  result := TInactive.Create(self);
end;

procedure TInactive.encode(const enc: IEncoder);
var
  int : IInactive;
begin
  int := self;
  Inactive_marshaller.marshal(enc,@int);
end;

procedure TInactive.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(Inactive_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TInactive.Create();
begin
  inherited Create();
end;

function TInactive.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/Inactive:1.0';
end;

//***********************************************************
// TNotPrepared_marshaller
//***********************************************************
function TNotPrepared_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TNotPrepared_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/NotPrepared:1.0');
  enc.except_end;
end;

procedure TNotPrepared_marshaller._free(var addr: Pointer);
begin
  INotPrepared(addr^) := nil;
end;

procedure TNotPrepared_marshaller._create(var addr: Pointer);
begin
  INotPrepared(addr^) := TNotPrepared.Create();
end;

procedure TNotPrepared_marshaller._assign(dst, src: Pointer);
begin
  INotPrepared(dst^) := INotPrepared(src^);
end;

function TNotPrepared_marshaller.typecode: ITypeCode;
begin
  result := _tc_NotPrepared.typecode;
end;

//***********************************************************
// TNotPrepared
//***********************************************************
constructor TNotPrepared.Create(ex: TNotPrepared);
begin
  inherited Create();
end;

procedure TNotPrepared.throw;
begin
  raise TNotPrepared.Create(self);
end;

function TNotPrepared.clone(): IORBException;
begin
  result := TNotPrepared.Create(self);
end;

procedure TNotPrepared.encode(const enc: IEncoder);
var
  int : INotPrepared;
begin
  int := self;
  NotPrepared_marshaller.marshal(enc,@int);
end;

procedure TNotPrepared.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotPrepared_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TNotPrepared.Create();
begin
  inherited Create();
end;

function TNotPrepared.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/NotPrepared:1.0';
end;

//***********************************************************
// TNoTransaction_marshaller
//***********************************************************
function TNoTransaction_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TNoTransaction_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/NoTransaction:1.0');
  enc.except_end;
end;

procedure TNoTransaction_marshaller._free(var addr: Pointer);
begin
  INoTransaction(addr^) := nil;
end;

procedure TNoTransaction_marshaller._create(var addr: Pointer);
begin
  INoTransaction(addr^) := TNoTransaction.Create();
end;

procedure TNoTransaction_marshaller._assign(dst, src: Pointer);
begin
  INoTransaction(dst^) := INoTransaction(src^);
end;

function TNoTransaction_marshaller.typecode: ITypeCode;
begin
  result := _tc_NoTransaction.typecode;
end;

//***********************************************************
// TNoTransaction
//***********************************************************
constructor TNoTransaction.Create(ex: TNoTransaction);
begin
  inherited Create();
end;

procedure TNoTransaction.throw;
begin
  raise TNoTransaction.Create(self);
end;

function TNoTransaction.clone(): IORBException;
begin
  result := TNoTransaction.Create(self);
end;

procedure TNoTransaction.encode(const enc: IEncoder);
var
  int : INoTransaction;
begin
  int := self;
  NoTransaction_marshaller.marshal(enc,@int);
end;

procedure TNoTransaction.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(NoTransaction_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TNoTransaction.Create();
begin
  inherited Create();
end;

function TNoTransaction.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/NoTransaction:1.0';
end;

//***********************************************************
// TInvalidControl_marshaller
//***********************************************************
function TInvalidControl_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TInvalidControl_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/InvalidControl:1.0');
  enc.except_end;
end;

procedure TInvalidControl_marshaller._free(var addr: Pointer);
begin
  IInvalidControl(addr^) := nil;
end;

procedure TInvalidControl_marshaller._create(var addr: Pointer);
begin
  IInvalidControl(addr^) := TInvalidControl.Create();
end;

procedure TInvalidControl_marshaller._assign(dst, src: Pointer);
begin
  IInvalidControl(dst^) := IInvalidControl(src^);
end;

function TInvalidControl_marshaller.typecode: ITypeCode;
begin
  result := _tc_InvalidControl.typecode;
end;

//***********************************************************
// TInvalidControl
//***********************************************************
constructor TInvalidControl.Create(ex: TInvalidControl);
begin
  inherited Create();
end;

procedure TInvalidControl.throw;
begin
  raise TInvalidControl.Create(self);
end;

function TInvalidControl.clone(): IORBException;
begin
  result := TInvalidControl.Create(self);
end;

procedure TInvalidControl.encode(const enc: IEncoder);
var
  int : IInvalidControl;
begin
  int := self;
  InvalidControl_marshaller.marshal(enc,@int);
end;

procedure TInvalidControl.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(InvalidControl_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TInvalidControl.Create();
begin
  inherited Create();
end;

function TInvalidControl.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/InvalidControl:1.0';
end;

//***********************************************************
// TUnavailable_marshaller
//***********************************************************
function TUnavailable_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TUnavailable_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/Unavailable:1.0');
  enc.except_end;
end;

procedure TUnavailable_marshaller._free(var addr: Pointer);
begin
  IUnavailable(addr^) := nil;
end;

procedure TUnavailable_marshaller._create(var addr: Pointer);
begin
  IUnavailable(addr^) := TUnavailable.Create();
end;

procedure TUnavailable_marshaller._assign(dst, src: Pointer);
begin
  IUnavailable(dst^) := IUnavailable(src^);
end;

function TUnavailable_marshaller.typecode: ITypeCode;
begin
  result := _tc_Unavailable.typecode;
end;

//***********************************************************
// TUnavailable
//***********************************************************
constructor TUnavailable.Create(ex: TUnavailable);
begin
  inherited Create();
end;

procedure TUnavailable.throw;
begin
  raise TUnavailable.Create(self);
end;

function TUnavailable.clone(): IORBException;
begin
  result := TUnavailable.Create(self);
end;

procedure TUnavailable.encode(const enc: IEncoder);
var
  int : IUnavailable;
begin
  int := self;
  Unavailable_marshaller.marshal(enc,@int);
end;

procedure TUnavailable.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(Unavailable_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TUnavailable.Create();
begin
  inherited Create();
end;

function TUnavailable.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/Unavailable:1.0';
end;

//***********************************************************
// TSynchronizationUnavailable_marshaller
//***********************************************************
function TSynchronizationUnavailable_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TSynchronizationUnavailable_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:omg.org/CosTransactions/SynchronizationUnavailable:1.0');
  enc.except_end;
end;

procedure TSynchronizationUnavailable_marshaller._free(var addr: Pointer);
begin
  ISynchronizationUnavailable(addr^) := nil;
end;

procedure TSynchronizationUnavailable_marshaller._create(var addr: Pointer);
begin
  ISynchronizationUnavailable(addr^) := TSynchronizationUnavailable.Create();
end;

procedure TSynchronizationUnavailable_marshaller._assign(dst, src: Pointer);
begin
  ISynchronizationUnavailable(dst^) := ISynchronizationUnavailable(src^);
end;

function TSynchronizationUnavailable_marshaller.typecode: ITypeCode;
begin
  result := _tc_SynchronizationUnavailable.typecode;
end;

//***********************************************************
// TSynchronizationUnavailable
//***********************************************************
constructor TSynchronizationUnavailable.Create(ex: TSynchronizationUnavailable);
begin
  inherited Create();
end;

procedure TSynchronizationUnavailable.throw;
begin
  raise TSynchronizationUnavailable.Create(self);
end;

function TSynchronizationUnavailable.clone(): IORBException;
begin
  result := TSynchronizationUnavailable.Create(self);
end;

procedure TSynchronizationUnavailable.encode(const enc: IEncoder);
var
  int : ISynchronizationUnavailable;
begin
  int := self;
  SynchronizationUnavailable_marshaller.marshal(enc,@int);
end;

procedure TSynchronizationUnavailable.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(SynchronizationUnavailable_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TSynchronizationUnavailable.Create();
begin
  inherited Create();
end;

function TSynchronizationUnavailable.repoid(): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/SynchronizationUnavailable:1.0';
end;

//***********************************************************
// TCurrent
//***********************************************************
function TCurrent.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosTransactions/Current:1.0' then
    begin
      result := Pointer(self as ICurrent);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TCurrent._narrow(const obj : IORBObject): ICurrent;
var
  p: Pointer;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/Current:1.0');
  if p <> nil then
    result := ICurrent(p)
end;

class function TCurrent.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/Current:1.0'
end;

//***********************************************************
// TTransactionFactory
//***********************************************************
function TTransactionFactory.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/TransactionFactory:1.0' then
    begin
      result := Pointer(self as ITransactionFactory);
      exit;
    end;
end;

class function TTransactionFactory._narrow(const obj : IORBObject): ITransactionFactory;
var
  p: Pointer;
  stub: TTransactionFactory_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/TransactionFactory:1.0');
  if p <> nil then
    result := ITransactionFactory(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/TransactionFactory:1.0') then
        begin
          stub := TTransactionFactory_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TTransactionFactory.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/TransactionFactory:1.0'
end;

//***********************************************************
// TTransactionFactory_stub
//***********************************************************
function TTransactionFactory_stub._create(const time_out: _ulong): IControl;
var
  req: IStaticRequest;
  _time_out: IStaticAny;
  _result: IStaticAny;
begin
  _time_out := StaticAny(stat_ulong,@time_out);
  _result := StaticAny(Control_marshaller, @result);
  req := StaticRequest(self,'create');
  req.add_in_arg(_time_out);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTransactionFactory_stub.recreate(const ctx: TPropagationContext): IControl;
var
  req: IStaticRequest;
  _ctx: IStaticAny;
  _result: IStaticAny;
begin
  _ctx := StaticAny(PropagationContext_marshaller,@ctx);
  _result := StaticAny(Control_marshaller, @result);
  req := StaticRequest(self,'recreate');
  req.add_in_arg(_ctx);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TTransactionFactory_stub_clp
//***********************************************************
function TTransactionFactory_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/TransactionFactory:1.0' then
    begin
      result := Pointer(self as ITransactionFactory);
      exit;
  end;
end;

function TTransactionFactory_stub_clp._create(const time_out: _ulong): IControl;
var
  _srv: IServant;
  srv: ITransactionFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTransactionFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv._create(time_out)
    end;
  _postinvoke();
end;

function TTransactionFactory_stub_clp.recreate(const ctx: TPropagationContext): IControl;
var
  _srv: IServant;
  srv: ITransactionFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTransactionFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv.recreate(ctx)
    end;
  _postinvoke();
end;

//***********************************************************
// TTransactionFactory_serv
//***********************************************************
function TTransactionFactory_serv._this(): ITransactionFactory;
var
  obj: IORBObject;
begin
  obj := this();
  result := TTransactionFactory._narrow(obj);
end;

function TTransactionFactory_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/TransactionFactory:1.0';
end;

function TTransactionFactory_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/TransactionFactory:1.0';
end;

function TTransactionFactory_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TTransactionFactory_stub_clp.Create(poa,obj);
end;

procedure TTransactionFactory_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TTransactionFactory_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/TransactionFactory:1.0' then
    begin
      result := Pointer(ITransactionFactory(self));
      exit;
    end;
end;

class function TTransactionFactory_serv._narrow(const srv : IServant): ITransactionFactory;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/TransactionFactory:1.0');
  if p <> nil then
    result := ITransactionFactory(p)
end;

function TTransactionFactory_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  _create_result: IControl;
  _create_time_out: _ulong;
  recreate_result: IControl;
  recreate_ctx: TPropagationContext;
begin
  result := true;
  if req.op_name = 'create' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@_create_time_out) as IStaticAny);
      req.set_result(StaticAny(Control_marshaller,@_create_result) as IStaticAny);
      if not req.read_args() then  exit;
      _create_result := _create(_create_time_out);
      req.write_results();
      exit;
    end
  else if req.op_name = 'recreate' then
    begin
      req.add_in_arg(StaticAny(PropagationContext_marshaller,@recreate_ctx) as IStaticAny);
      req.set_result(StaticAny(Control_marshaller,@recreate_result) as IStaticAny);
      if not req.read_args() then  exit;
      recreate_result := recreate(recreate_ctx);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TTransactionFactory_marshaller
//***********************************************************
function TTransactionFactory_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ITransactionFactory(addr^) := TTransactionFactory._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TTransactionFactory_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ITransactionFactory(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TTransactionFactory_marshaller._free(var addr: Pointer);
begin
  ITransactionFactory(addr^) := nil;
end;

procedure TTransactionFactory_marshaller._create(var addr: Pointer);
begin
  ITransactionFactory(addr^) := TTransactionFactory_stub.Create();
end;

procedure TTransactionFactory_marshaller._assign(dst, src: Pointer);
begin
  ITransactionFactory(dst^) := ITransactionFactory(src^);
end;

function TTransactionFactory_marshaller.typecode: ITypeCode;
begin
  result := _tc_TransactionFactory.typecode;
end;

//***********************************************************
// TControl
//***********************************************************
function TControl.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Control:1.0' then
    begin
      result := Pointer(self as IControl);
      exit;
    end;
end;

class function TControl._narrow(const obj : IORBObject): IControl;
var
  p: Pointer;
  stub: TControl_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/Control:1.0');
  if p <> nil then
    result := IControl(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/Control:1.0') then
        begin
          stub := TControl_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TControl.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/Control:1.0'
end;

//***********************************************************
// TControl_stub
//***********************************************************
function TControl_stub.get_terminator: ITerminator;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Terminator_marshaller, @result);
  req := StaticRequest(self,'get_terminator');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_Unavailable.typecode]);
  req.invoke;
  dorb_static_throw(req,[Unavailable_marshaller, 'IDL:omg.org/CosTransactions/Unavailable:1.0']);
end;

function TControl_stub.get_coordinator: ICoordinator;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Coordinator_marshaller, @result);
  req := StaticRequest(self,'get_coordinator');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_Unavailable.typecode]);
  req.invoke;
  dorb_static_throw(req,[Unavailable_marshaller, 'IDL:omg.org/CosTransactions/Unavailable:1.0']);
end;

//***********************************************************
// TControl_stub_clp
//***********************************************************
function TControl_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Control:1.0' then
    begin
      result := Pointer(self as IControl);
      exit;
  end;
end;

function TControl_stub_clp.get_terminator: ITerminator;
var
  _srv: IServant;
  srv: IControl;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TControl_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_terminator
    end;
  _postinvoke();
end;

function TControl_stub_clp.get_coordinator: ICoordinator;
var
  _srv: IServant;
  srv: IControl;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TControl_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_coordinator
    end;
  _postinvoke();
end;

//***********************************************************
// TControl_serv
//***********************************************************
function TControl_serv._this(): IControl;
var
  obj: IORBObject;
begin
  obj := this();
  result := TControl._narrow(obj);
end;

function TControl_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/Control:1.0';
end;

function TControl_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/Control:1.0';
end;

function TControl_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TControl_stub_clp.Create(poa,obj);
end;

procedure TControl_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TControl_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Control:1.0' then
    begin
      result := Pointer(IControl(self));
      exit;
    end;
end;

class function TControl_serv._narrow(const srv : IServant): IControl;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/Control:1.0');
  if p <> nil then
    result := IControl(p)
end;

function TControl_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  get_terminator_result: ITerminator;
  get_coordinator_result: ICoordinator;
begin
  result := true;
  if req.op_name = 'get_terminator' then
    begin
      req.set_result(StaticAny(Terminator_marshaller,@get_terminator_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Unavailable.typecode]);
      try
        get_terminator_result := get_terminator;
      except
        on Unavailable: TUnavailable do
          req.set_exception(TUnavailable.Create(Unavailable) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_coordinator' then
    begin
      req.set_result(StaticAny(Coordinator_marshaller,@get_coordinator_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Unavailable.typecode]);
      try
        get_coordinator_result := get_coordinator;
      except
        on Unavailable: TUnavailable do
          req.set_exception(TUnavailable.Create(Unavailable) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TControl_marshaller
//***********************************************************
function TControl_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IControl(addr^) := TControl._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TControl_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IControl(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TControl_marshaller._free(var addr: Pointer);
begin
  IControl(addr^) := nil;
end;

procedure TControl_marshaller._create(var addr: Pointer);
begin
  IControl(addr^) := TControl_stub.Create();
end;

procedure TControl_marshaller._assign(dst, src: Pointer);
begin
  IControl(dst^) := IControl(src^);
end;

function TControl_marshaller.typecode: ITypeCode;
begin
  result := _tc_Control.typecode;
end;

//***********************************************************
// TTerminator
//***********************************************************
function TTerminator.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Terminator:1.0' then
    begin
      result := Pointer(self as ITerminator);
      exit;
    end;
end;

class function TTerminator._narrow(const obj : IORBObject): ITerminator;
var
  p: Pointer;
  stub: TTerminator_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/Terminator:1.0');
  if p <> nil then
    result := ITerminator(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/Terminator:1.0') then
        begin
          stub := TTerminator_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TTerminator.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/Terminator:1.0'
end;

//***********************************************************
// TTerminator_stub
//***********************************************************
procedure TTerminator_stub.commit(const report_heuristics: Boolean);
var
  req: IStaticRequest;
  _report_heuristics: IStaticAny;
begin
  _report_heuristics := StaticAny(stat_boolean,@report_heuristics);
  req := StaticRequest(self,'commit');
  req.add_in_arg(_report_heuristics);
  req.set_exceptions_tc([_tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[HeuristicMixed_marshaller, 'IDL:omg.org/CosTransactions/HeuristicMixed:1.0', HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TTerminator_stub.rollback;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'rollback');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TTerminator_stub_clp
//***********************************************************
function TTerminator_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Terminator:1.0' then
    begin
      result := Pointer(self as ITerminator);
      exit;
  end;
end;

procedure TTerminator_stub_clp.commit(const report_heuristics: Boolean);
var
  _srv: IServant;
  srv: ITerminator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTerminator_serv._narrow(_srv);
      if srv <> nil then
        srv.commit(report_heuristics)
    end;
  _postinvoke();
end;

procedure TTerminator_stub_clp.rollback;
var
  _srv: IServant;
  srv: ITerminator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TTerminator_serv._narrow(_srv);
      if srv <> nil then
        srv.rollback
    end;
  _postinvoke();
end;

//***********************************************************
// TTerminator_serv
//***********************************************************
function TTerminator_serv._this(): ITerminator;
var
  obj: IORBObject;
begin
  obj := this();
  result := TTerminator._narrow(obj);
end;

function TTerminator_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/Terminator:1.0';
end;

function TTerminator_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/Terminator:1.0';
end;

function TTerminator_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TTerminator_stub_clp.Create(poa,obj);
end;

procedure TTerminator_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TTerminator_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Terminator:1.0' then
    begin
      result := Pointer(ITerminator(self));
      exit;
    end;
end;

class function TTerminator_serv._narrow(const srv : IServant): ITerminator;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/Terminator:1.0');
  if p <> nil then
    result := ITerminator(p)
end;

function TTerminator_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  commit_report_heuristics: Boolean;
begin
  result := true;
  if req.op_name = 'commit' then
    begin
      req.add_in_arg(StaticAny(stat_boolean,@commit_report_heuristics) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
      try
        commit(commit_report_heuristics);
      except
        on HeuristicMixed: THeuristicMixed do
          req.set_exception(THeuristicMixed.Create(HeuristicMixed) as IORBException);
        on HeuristicHazard: THeuristicHazard do
          req.set_exception(THeuristicHazard.Create(HeuristicHazard) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'rollback' then
    begin
      if not req.read_args() then  exit;
      rollback;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TTerminator_marshaller
//***********************************************************
function TTerminator_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ITerminator(addr^) := TTerminator._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TTerminator_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ITerminator(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TTerminator_marshaller._free(var addr: Pointer);
begin
  ITerminator(addr^) := nil;
end;

procedure TTerminator_marshaller._create(var addr: Pointer);
begin
  ITerminator(addr^) := TTerminator_stub.Create();
end;

procedure TTerminator_marshaller._assign(dst, src: Pointer);
begin
  ITerminator(dst^) := ITerminator(src^);
end;

function TTerminator_marshaller.typecode: ITypeCode;
begin
  result := _tc_Terminator.typecode;
end;

//***********************************************************
// TCoordinator
//***********************************************************
function TCoordinator.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Coordinator:1.0' then
    begin
      result := Pointer(self as ICoordinator);
      exit;
    end;
end;

class function TCoordinator._narrow(const obj : IORBObject): ICoordinator;
var
  p: Pointer;
  stub: TCoordinator_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/Coordinator:1.0');
  if p <> nil then
    result := ICoordinator(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/Coordinator:1.0') then
        begin
          stub := TCoordinator_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCoordinator.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/Coordinator:1.0'
end;

//***********************************************************
// TCoordinator_stub
//***********************************************************
function TCoordinator_stub.get_status: TStatus;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Status_marshaller, @result);
  req := StaticRequest(self,'get_status');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.get_parent_status: TStatus;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Status_marshaller, @result);
  req := StaticRequest(self,'get_parent_status');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.get_top_level_status: TStatus;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Status_marshaller, @result);
  req := StaticRequest(self,'get_top_level_status');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.is_same_transaction(const tc: ICoordinator): Boolean;
var
  req: IStaticRequest;
  _tc: IStaticAny;
  _result: IStaticAny;
begin
  _tc := StaticAny(Coordinator_marshaller,@tc);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_same_transaction');
  req.add_in_arg(_tc);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.is_related_transaction(const tc: ICoordinator): Boolean;
var
  req: IStaticRequest;
  _tc: IStaticAny;
  _result: IStaticAny;
begin
  _tc := StaticAny(Coordinator_marshaller,@tc);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_related_transaction');
  req.add_in_arg(_tc);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.is_ancestor_transaction(const tc: ICoordinator): Boolean;
var
  req: IStaticRequest;
  _tc: IStaticAny;
  _result: IStaticAny;
begin
  _tc := StaticAny(Coordinator_marshaller,@tc);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_ancestor_transaction');
  req.add_in_arg(_tc);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.is_descendant_transaction(const tc: ICoordinator): Boolean;
var
  req: IStaticRequest;
  _tc: IStaticAny;
  _result: IStaticAny;
begin
  _tc := StaticAny(Coordinator_marshaller,@tc);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_descendant_transaction');
  req.add_in_arg(_tc);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.is_top_level_transaction: Boolean;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_top_level_transaction');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.hash_transaction: _ulong;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulong, @result);
  req := StaticRequest(self,'hash_transaction');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.hash_top_level_tran: _ulong;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulong, @result);
  req := StaticRequest(self,'hash_top_level_tran');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.register_resource(const r: IResource): IRecoveryCoordinator;
var
  req: IStaticRequest;
  _r: IStaticAny;
  _result: IStaticAny;
begin
  _r := StaticAny(Resource_marshaller,@r);
  _result := StaticAny(RecoveryCoordinator_marshaller, @result);
  req := StaticRequest(self,'register_resource');
  req.add_in_arg(_r);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_Inactive.typecode]);
  req.invoke;
  dorb_static_throw(req,[Inactive_marshaller, 'IDL:omg.org/CosTransactions/Inactive:1.0']);
end;

procedure TCoordinator_stub.register_synchronization(const sync: ISynchronization);
var
  req: IStaticRequest;
  _sync: IStaticAny;
begin
  _sync := StaticAny(Synchronization_marshaller,@sync);
  req := StaticRequest(self,'register_synchronization');
  req.add_in_arg(_sync);
  req.set_exceptions_tc([_tc_Inactive.typecode, _tc_SynchronizationUnavailable.typecode]);
  req.invoke;
  dorb_static_throw(req,[Inactive_marshaller, 'IDL:omg.org/CosTransactions/Inactive:1.0', SynchronizationUnavailable_marshaller, 'IDL:omg.org/CosTransactions/SynchronizationUnavailable:1.0']);
end;

procedure TCoordinator_stub.register_subtran_aware(const r: ISubtransactionAwareResource);
var
  req: IStaticRequest;
  _r: IStaticAny;
begin
  _r := StaticAny(SubtransactionAwareResource_marshaller,@r);
  req := StaticRequest(self,'register_subtran_aware');
  req.add_in_arg(_r);
  req.set_exceptions_tc([_tc_Inactive.typecode, _tc_NotSubtransaction.typecode]);
  req.invoke;
  dorb_static_throw(req,[Inactive_marshaller, 'IDL:omg.org/CosTransactions/Inactive:1.0', NotSubtransaction_marshaller, 'IDL:omg.org/CosTransactions/NotSubtransaction:1.0']);
end;

procedure TCoordinator_stub.rollback_only;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'rollback_only');
  req.set_exceptions_tc([_tc_Inactive.typecode]);
  req.invoke;
  dorb_static_throw(req,[Inactive_marshaller, 'IDL:omg.org/CosTransactions/Inactive:1.0']);
end;

function TCoordinator_stub.get_transaction_name: AnsiString;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'get_transaction_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCoordinator_stub.create_subtransaction: IControl;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Control_marshaller, @result);
  req := StaticRequest(self,'create_subtransaction');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_SubtransactionsUnavailable.typecode, _tc_Inactive.typecode]);
  req.invoke;
  dorb_static_throw(req,[SubtransactionsUnavailable_marshaller, 'IDL:omg.org/CosTransactions/SubtransactionsUnavailable:1.0', Inactive_marshaller, 'IDL:omg.org/CosTransactions/Inactive:1.0']);
end;

function TCoordinator_stub.get_txcontext: TPropagationContext;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(PropagationContext_marshaller, @result);
  req := StaticRequest(self,'get_txcontext');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_Unavailable.typecode]);
  req.invoke;
  dorb_static_throw(req,[Unavailable_marshaller, 'IDL:omg.org/CosTransactions/Unavailable:1.0']);
end;

//***********************************************************
// TCoordinator_stub_clp
//***********************************************************
function TCoordinator_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Coordinator:1.0' then
    begin
      result := Pointer(self as ICoordinator);
      exit;
  end;
end;

function TCoordinator_stub_clp.get_status: TStatus;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := StatusActive;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_status
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.get_parent_status: TStatus;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := StatusActive;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_parent_status
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.get_top_level_status: TStatus;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := StatusActive;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_top_level_status
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.is_same_transaction(const tc: ICoordinator): Boolean;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.is_same_transaction(tc)
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.is_related_transaction(const tc: ICoordinator): Boolean;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.is_related_transaction(tc)
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.is_ancestor_transaction(const tc: ICoordinator): Boolean;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.is_ancestor_transaction(tc)
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.is_descendant_transaction(const tc: ICoordinator): Boolean;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.is_descendant_transaction(tc)
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.is_top_level_transaction: Boolean;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.is_top_level_transaction
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.hash_transaction: _ulong;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.hash_transaction
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.hash_top_level_tran: _ulong;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.hash_top_level_tran
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.register_resource(const r: IResource): IRecoveryCoordinator;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.register_resource(r)
    end;
  _postinvoke();
end;

procedure TCoordinator_stub_clp.register_synchronization(const sync: ISynchronization);
var
  _srv: IServant;
  srv: ICoordinator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        srv.register_synchronization(sync)
    end;
  _postinvoke();
end;

procedure TCoordinator_stub_clp.register_subtran_aware(const r: ISubtransactionAwareResource);
var
  _srv: IServant;
  srv: ICoordinator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        srv.register_subtran_aware(r)
    end;
  _postinvoke();
end;

procedure TCoordinator_stub_clp.rollback_only;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        srv.rollback_only
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.get_transaction_name: AnsiString;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_transaction_name
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.create_subtransaction: IControl;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_subtransaction
    end;
  _postinvoke();
end;

function TCoordinator_stub_clp.get_txcontext: TPropagationContext;
var
  _srv: IServant;
  srv: ICoordinator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_txcontext
    end;
  _postinvoke();
end;

//***********************************************************
// TCoordinator_serv
//***********************************************************
function TCoordinator_serv._this(): ICoordinator;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCoordinator._narrow(obj);
end;

function TCoordinator_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/Coordinator:1.0';
end;

function TCoordinator_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/Coordinator:1.0';
end;

function TCoordinator_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCoordinator_stub_clp.Create(poa,obj);
end;

procedure TCoordinator_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCoordinator_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Coordinator:1.0' then
    begin
      result := Pointer(ICoordinator(self));
      exit;
    end;
end;

class function TCoordinator_serv._narrow(const srv : IServant): ICoordinator;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/Coordinator:1.0');
  if p <> nil then
    result := ICoordinator(p)
end;

function TCoordinator_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  get_status_result: TStatus;
  get_parent_status_result: TStatus;
  get_top_level_status_result: TStatus;
  is_same_transaction_result: Boolean;
  is_same_transaction_tc: ICoordinator;
  is_related_transaction_result: Boolean;
  is_related_transaction_tc: ICoordinator;
  is_ancestor_transaction_result: Boolean;
  is_ancestor_transaction_tc: ICoordinator;
  is_descendant_transaction_result: Boolean;
  is_descendant_transaction_tc: ICoordinator;
  is_top_level_transaction_result: Boolean;
  hash_transaction_result: _ulong;
  hash_top_level_tran_result: _ulong;
  register_resource_result: IRecoveryCoordinator;
  register_resource_r: IResource;
  register_synchronization_sync: ISynchronization;
  register_subtran_aware_r: ISubtransactionAwareResource;
  get_transaction_name_result: AnsiString;
  create_subtransaction_result: IControl;
  get_txcontext_result: TPropagationContext;
begin
  result := true;
  if req.op_name = 'get_status' then
    begin
      req.set_result(StaticAny(Status_marshaller,@get_status_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_status_result := get_status;
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_parent_status' then
    begin
      req.set_result(StaticAny(Status_marshaller,@get_parent_status_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_parent_status_result := get_parent_status;
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_top_level_status' then
    begin
      req.set_result(StaticAny(Status_marshaller,@get_top_level_status_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_top_level_status_result := get_top_level_status;
      req.write_results();
      exit;
    end
  else if req.op_name = 'is_same_transaction' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@is_same_transaction_tc) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@is_same_transaction_result) as IStaticAny);
      if not req.read_args() then  exit;
      is_same_transaction_result := is_same_transaction(is_same_transaction_tc);
      req.write_results();
      exit;
    end
  else if req.op_name = 'is_related_transaction' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@is_related_transaction_tc) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@is_related_transaction_result) as IStaticAny);
      if not req.read_args() then  exit;
      is_related_transaction_result := is_related_transaction(is_related_transaction_tc);
      req.write_results();
      exit;
    end
  else if req.op_name = 'is_ancestor_transaction' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@is_ancestor_transaction_tc) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@is_ancestor_transaction_result) as IStaticAny);
      if not req.read_args() then  exit;
      is_ancestor_transaction_result := is_ancestor_transaction(is_ancestor_transaction_tc);
      req.write_results();
      exit;
    end
  else if req.op_name = 'is_descendant_transaction' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@is_descendant_transaction_tc) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@is_descendant_transaction_result) as IStaticAny);
      if not req.read_args() then  exit;
      is_descendant_transaction_result := is_descendant_transaction(is_descendant_transaction_tc);
      req.write_results();
      exit;
    end
  else if req.op_name = 'is_top_level_transaction' then
    begin
      req.set_result(StaticAny(stat_boolean,@is_top_level_transaction_result) as IStaticAny);
      if not req.read_args() then  exit;
      is_top_level_transaction_result := is_top_level_transaction;
      req.write_results();
      exit;
    end
  else if req.op_name = 'hash_transaction' then
    begin
      req.set_result(StaticAny(stat_ulong,@hash_transaction_result) as IStaticAny);
      if not req.read_args() then  exit;
      hash_transaction_result := hash_transaction;
      req.write_results();
      exit;
    end
  else if req.op_name = 'hash_top_level_tran' then
    begin
      req.set_result(StaticAny(stat_ulong,@hash_top_level_tran_result) as IStaticAny);
      if not req.read_args() then  exit;
      hash_top_level_tran_result := hash_top_level_tran;
      req.write_results();
      exit;
    end
  else if req.op_name = 'register_resource' then
    begin
      req.add_in_arg(StaticAny(Resource_marshaller,@register_resource_r) as IStaticAny);
      req.set_result(StaticAny(RecoveryCoordinator_marshaller,@register_resource_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Inactive.typecode]);
      try
        register_resource_result := register_resource(register_resource_r);
      except
        on Inactive: TInactive do
          req.set_exception(TInactive.Create(Inactive) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'register_synchronization' then
    begin
      req.add_in_arg(StaticAny(Synchronization_marshaller,@register_synchronization_sync) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Inactive.typecode, _tc_SynchronizationUnavailable.typecode]);
      try
        register_synchronization(register_synchronization_sync);
      except
        on Inactive: TInactive do
          req.set_exception(TInactive.Create(Inactive) as IORBException);
        on SynchronizationUnavailable: TSynchronizationUnavailable do
          req.set_exception(TSynchronizationUnavailable.Create(SynchronizationUnavailable) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'register_subtran_aware' then
    begin
      req.add_in_arg(StaticAny(SubtransactionAwareResource_marshaller,@register_subtran_aware_r) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Inactive.typecode, _tc_NotSubtransaction.typecode]);
      try
        register_subtran_aware(register_subtran_aware_r);
      except
        on Inactive: TInactive do
          req.set_exception(TInactive.Create(Inactive) as IORBException);
        on NotSubtransaction: TNotSubtransaction do
          req.set_exception(TNotSubtransaction.Create(NotSubtransaction) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'rollback_only' then
    begin
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Inactive.typecode]);
      try
        rollback_only;
      except
        on Inactive: TInactive do
          req.set_exception(TInactive.Create(Inactive) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_transaction_name' then
    begin
      req.set_result(StaticAny(stat_string,@get_transaction_name_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_transaction_name_result := get_transaction_name;
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_subtransaction' then
    begin
      req.set_result(StaticAny(Control_marshaller,@create_subtransaction_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_SubtransactionsUnavailable.typecode, _tc_Inactive.typecode]);
      try
        create_subtransaction_result := create_subtransaction;
      except
        on SubtransactionsUnavailable: TSubtransactionsUnavailable do
          req.set_exception(TSubtransactionsUnavailable.Create(SubtransactionsUnavailable) as IORBException);
        on Inactive: TInactive do
          req.set_exception(TInactive.Create(Inactive) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_txcontext' then
    begin
      req.set_result(StaticAny(PropagationContext_marshaller,@get_txcontext_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_Unavailable.typecode]);
      try
        get_txcontext_result := get_txcontext;
      except
        on Unavailable: TUnavailable do
          req.set_exception(TUnavailable.Create(Unavailable) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TCoordinator_marshaller
//***********************************************************
function TCoordinator_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICoordinator(addr^) := TCoordinator._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCoordinator_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICoordinator(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCoordinator_marshaller._free(var addr: Pointer);
begin
  ICoordinator(addr^) := nil;
end;

procedure TCoordinator_marshaller._create(var addr: Pointer);
begin
  ICoordinator(addr^) := TCoordinator_stub.Create();
end;

procedure TCoordinator_marshaller._assign(dst, src: Pointer);
begin
  ICoordinator(dst^) := ICoordinator(src^);
end;

function TCoordinator_marshaller.typecode: ITypeCode;
begin
  result := _tc_Coordinator.typecode;
end;

//***********************************************************
// TRecoveryCoordinator
//***********************************************************
function TRecoveryCoordinator.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0' then
    begin
      result := Pointer(self as IRecoveryCoordinator);
      exit;
    end;
end;

class function TRecoveryCoordinator._narrow(const obj : IORBObject): IRecoveryCoordinator;
var
  p: Pointer;
  stub: TRecoveryCoordinator_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0');
  if p <> nil then
    result := IRecoveryCoordinator(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0') then
        begin
          stub := TRecoveryCoordinator_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TRecoveryCoordinator.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0'
end;

//***********************************************************
// TRecoveryCoordinator_stub
//***********************************************************
function TRecoveryCoordinator_stub.replay_completion(const r: IResource): TStatus;
var
  req: IStaticRequest;
  _r: IStaticAny;
  _result: IStaticAny;
begin
  _r := StaticAny(Resource_marshaller,@r);
  _result := StaticAny(Status_marshaller, @result);
  req := StaticRequest(self,'replay_completion');
  req.add_in_arg(_r);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_NotPrepared.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotPrepared_marshaller, 'IDL:omg.org/CosTransactions/NotPrepared:1.0']);
end;

//***********************************************************
// TRecoveryCoordinator_stub_clp
//***********************************************************
function TRecoveryCoordinator_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0' then
    begin
      result := Pointer(self as IRecoveryCoordinator);
      exit;
  end;
end;

function TRecoveryCoordinator_stub_clp.replay_completion(const r: IResource): TStatus;
var
  _srv: IServant;
  srv: IRecoveryCoordinator;
begin
  result := StatusActive;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRecoveryCoordinator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.replay_completion(r)
    end;
  _postinvoke();
end;

//***********************************************************
// TRecoveryCoordinator_serv
//***********************************************************
function TRecoveryCoordinator_serv._this(): IRecoveryCoordinator;
var
  obj: IORBObject;
begin
  obj := this();
  result := TRecoveryCoordinator._narrow(obj);
end;

function TRecoveryCoordinator_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0';
end;

function TRecoveryCoordinator_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0';
end;

function TRecoveryCoordinator_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TRecoveryCoordinator_stub_clp.Create(poa,obj);
end;

procedure TRecoveryCoordinator_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TRecoveryCoordinator_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0' then
    begin
      result := Pointer(IRecoveryCoordinator(self));
      exit;
    end;
end;

class function TRecoveryCoordinator_serv._narrow(const srv : IServant): IRecoveryCoordinator;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/RecoveryCoordinator:1.0');
  if p <> nil then
    result := IRecoveryCoordinator(p)
end;

function TRecoveryCoordinator_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  replay_completion_result: TStatus;
  replay_completion_r: IResource;
begin
  result := true;
  if req.op_name = 'replay_completion' then
    begin
      req.add_in_arg(StaticAny(Resource_marshaller,@replay_completion_r) as IStaticAny);
      req.set_result(StaticAny(Status_marshaller,@replay_completion_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotPrepared.typecode]);
      try
        replay_completion_result := replay_completion(replay_completion_r);
      except
        on NotPrepared: TNotPrepared do
          req.set_exception(TNotPrepared.Create(NotPrepared) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TRecoveryCoordinator_marshaller
//***********************************************************
function TRecoveryCoordinator_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IRecoveryCoordinator(addr^) := TRecoveryCoordinator._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TRecoveryCoordinator_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IRecoveryCoordinator(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TRecoveryCoordinator_marshaller._free(var addr: Pointer);
begin
  IRecoveryCoordinator(addr^) := nil;
end;

procedure TRecoveryCoordinator_marshaller._create(var addr: Pointer);
begin
  IRecoveryCoordinator(addr^) := TRecoveryCoordinator_stub.Create();
end;

procedure TRecoveryCoordinator_marshaller._assign(dst, src: Pointer);
begin
  IRecoveryCoordinator(dst^) := IRecoveryCoordinator(src^);
end;

function TRecoveryCoordinator_marshaller.typecode: ITypeCode;
begin
  result := _tc_RecoveryCoordinator.typecode;
end;

//***********************************************************
// TResource
//***********************************************************
function TResource.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Resource:1.0' then
    begin
      result := Pointer(self as IResource);
      exit;
    end;
end;

class function TResource._narrow(const obj : IORBObject): IResource;
var
  p: Pointer;
  stub: TResource_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/Resource:1.0');
  if p <> nil then
    result := IResource(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/Resource:1.0') then
        begin
          stub := TResource_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TResource.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/Resource:1.0'
end;

//***********************************************************
// TResource_stub
//***********************************************************
function TResource_stub.prepare: TVote;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Vote_marshaller, @result);
  req := StaticRequest(self,'prepare');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[HeuristicMixed_marshaller, 'IDL:omg.org/CosTransactions/HeuristicMixed:1.0', HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TResource_stub.rollback;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'rollback');
  req.set_exceptions_tc([_tc_HeuristicCommit.typecode, _tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[HeuristicCommit_marshaller, 'IDL:omg.org/CosTransactions/HeuristicCommit:1.0', HeuristicMixed_marshaller, 'IDL:omg.org/CosTransactions/HeuristicMixed:1.0', HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TResource_stub.commit;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'commit');
  req.set_exceptions_tc([_tc_NotPrepared.typecode, _tc_HeuristicRollback.typecode, _tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotPrepared_marshaller, 'IDL:omg.org/CosTransactions/NotPrepared:1.0', HeuristicRollback_marshaller, 'IDL:omg.org/CosTransactions/HeuristicRollback:1.0', HeuristicMixed_marshaller, 'IDL:omg.org/CosTransactions/HeuristicMixed:1.0', HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TResource_stub.commit_one_phase;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'commit_one_phase');
  req.set_exceptions_tc([_tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TResource_stub.forget;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'forget');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TResource_stub_clp
//***********************************************************
function TResource_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Resource:1.0' then
    begin
      result := Pointer(self as IResource);
      exit;
  end;
end;

function TResource_stub_clp.prepare: TVote;
var
  _srv: IServant;
  srv: IResource;
begin
  result := VoteCommit;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TResource_serv._narrow(_srv);
      if srv <> nil then
        result := srv.prepare
    end;
  _postinvoke();
end;

procedure TResource_stub_clp.rollback;
var
  _srv: IServant;
  srv: IResource;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TResource_serv._narrow(_srv);
      if srv <> nil then
        srv.rollback
    end;
  _postinvoke();
end;

procedure TResource_stub_clp.commit;
var
  _srv: IServant;
  srv: IResource;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TResource_serv._narrow(_srv);
      if srv <> nil then
        srv.commit
    end;
  _postinvoke();
end;

procedure TResource_stub_clp.commit_one_phase;
var
  _srv: IServant;
  srv: IResource;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TResource_serv._narrow(_srv);
      if srv <> nil then
        srv.commit_one_phase
    end;
  _postinvoke();
end;

procedure TResource_stub_clp.forget;
var
  _srv: IServant;
  srv: IResource;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TResource_serv._narrow(_srv);
      if srv <> nil then
        srv.forget
    end;
  _postinvoke();
end;

//***********************************************************
// TResource_serv
//***********************************************************
function TResource_serv._this(): IResource;
var
  obj: IORBObject;
begin
  obj := this();
  result := TResource._narrow(obj);
end;

function TResource_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/Resource:1.0';
end;

function TResource_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/Resource:1.0';
end;

function TResource_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TResource_stub_clp.Create(poa,obj);
end;

procedure TResource_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TResource_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/Resource:1.0' then
    begin
      result := Pointer(IResource(self));
      exit;
    end;
end;

class function TResource_serv._narrow(const srv : IServant): IResource;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/Resource:1.0');
  if p <> nil then
    result := IResource(p)
end;

function TResource_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  prepare_result: TVote;
begin
  result := true;
  if req.op_name = 'prepare' then
    begin
      req.set_result(StaticAny(Vote_marshaller,@prepare_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
      try
        prepare_result := prepare;
      except
        on HeuristicMixed: THeuristicMixed do
          req.set_exception(THeuristicMixed.Create(HeuristicMixed) as IORBException);
        on HeuristicHazard: THeuristicHazard do
          req.set_exception(THeuristicHazard.Create(HeuristicHazard) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'rollback' then
    begin
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_HeuristicCommit.typecode, _tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
      try
        rollback;
      except
        on HeuristicCommit: THeuristicCommit do
          req.set_exception(THeuristicCommit.Create(HeuristicCommit) as IORBException);
        on HeuristicMixed: THeuristicMixed do
          req.set_exception(THeuristicMixed.Create(HeuristicMixed) as IORBException);
        on HeuristicHazard: THeuristicHazard do
          req.set_exception(THeuristicHazard.Create(HeuristicHazard) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'commit' then
    begin
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_NotPrepared.typecode, _tc_HeuristicRollback.typecode, _tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
      try
        commit;
      except
        on NotPrepared: TNotPrepared do
          req.set_exception(TNotPrepared.Create(NotPrepared) as IORBException);
        on HeuristicRollback: THeuristicRollback do
          req.set_exception(THeuristicRollback.Create(HeuristicRollback) as IORBException);
        on HeuristicMixed: THeuristicMixed do
          req.set_exception(THeuristicMixed.Create(HeuristicMixed) as IORBException);
        on HeuristicHazard: THeuristicHazard do
          req.set_exception(THeuristicHazard.Create(HeuristicHazard) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'commit_one_phase' then
    begin
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_HeuristicHazard.typecode]);
      try
        commit_one_phase;
      except
        on HeuristicHazard: THeuristicHazard do
          req.set_exception(THeuristicHazard.Create(HeuristicHazard) as IORBException);
      end;
      req.write_results();
      exit;
    end
  else if req.op_name = 'forget' then
    begin
      if not req.read_args() then  exit;
      forget;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TResource_marshaller
//***********************************************************
function TResource_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IResource(addr^) := TResource._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TResource_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IResource(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TResource_marshaller._free(var addr: Pointer);
begin
  IResource(addr^) := nil;
end;

procedure TResource_marshaller._create(var addr: Pointer);
begin
  IResource(addr^) := TResource_stub.Create();
end;

procedure TResource_marshaller._assign(dst, src: Pointer);
begin
  IResource(dst^) := IResource(src^);
end;

function TResource_marshaller.typecode: ITypeCode;
begin
  result := _tc_Resource.typecode;
end;

//***********************************************************
// TTransactionalObject
//***********************************************************
function TTransactionalObject.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/TransactionalObject:1.0' then
    begin
      result := Pointer(self as ITransactionalObject);
      exit;
    end;
end;

class function TTransactionalObject._narrow(const obj : IORBObject): ITransactionalObject;
var
  p: Pointer;
  stub: TTransactionalObject_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/TransactionalObject:1.0');
  if p <> nil then
    result := ITransactionalObject(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/TransactionalObject:1.0') then
        begin
          stub := TTransactionalObject_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TTransactionalObject.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/TransactionalObject:1.0'
end;

//***********************************************************
// TTransactionalObject_stub
//***********************************************************
//***********************************************************
// TTransactionalObject_stub_clp
//***********************************************************
function TTransactionalObject_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/TransactionalObject:1.0' then
    begin
      result := Pointer(self as ITransactionalObject);
      exit;
  end;
end;

//***********************************************************
// TTransactionalObject_serv
//***********************************************************
function TTransactionalObject_serv._this(): ITransactionalObject;
var
  obj: IORBObject;
begin
  obj := this();
  result := TTransactionalObject._narrow(obj);
end;

function TTransactionalObject_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/TransactionalObject:1.0';
end;

function TTransactionalObject_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/TransactionalObject:1.0';
end;

function TTransactionalObject_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TTransactionalObject_stub_clp.Create(poa,obj);
end;

procedure TTransactionalObject_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TTransactionalObject_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CosTransactions/TransactionalObject:1.0' then
    begin
      result := Pointer(ITransactionalObject(self));
      exit;
    end;
end;

class function TTransactionalObject_serv._narrow(const srv : IServant): ITransactionalObject;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/TransactionalObject:1.0');
  if p <> nil then
    result := ITransactionalObject(p)
end;

function TTransactionalObject_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
end;

//***********************************************************
// TTransactionalObject_marshaller
//***********************************************************
function TTransactionalObject_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ITransactionalObject(addr^) := TTransactionalObject._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TTransactionalObject_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ITransactionalObject(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TTransactionalObject_marshaller._free(var addr: Pointer);
begin
  ITransactionalObject(addr^) := nil;
end;

procedure TTransactionalObject_marshaller._create(var addr: Pointer);
begin
  ITransactionalObject(addr^) := TTransactionalObject_stub.Create();
end;

procedure TTransactionalObject_marshaller._assign(dst, src: Pointer);
begin
  ITransactionalObject(dst^) := ITransactionalObject(src^);
end;

function TTransactionalObject_marshaller.typecode: ITypeCode;
begin
  result := _tc_TransactionalObject.typecode;
end;

//***********************************************************
// TSynchronization
//***********************************************************
function TSynchronization.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosTransactions/Synchronization:1.0' then
    begin
      result := Pointer(self as ISynchronization);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TSynchronization._narrow(const obj : IORBObject): ISynchronization;
var
  p: Pointer;
  stub: TSynchronization_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/Synchronization:1.0');
  if p <> nil then
    result := ISynchronization(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/Synchronization:1.0') then
        begin
          stub := TSynchronization_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TSynchronization.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/Synchronization:1.0'
end;

//***********************************************************
// TSynchronization_stub
//***********************************************************
procedure TSynchronization_stub.before_completion;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'before_completion');
  req.invoke;
  dorb_static_throw(req);
end;

procedure TSynchronization_stub.after_completion(const status: TStatus);
var
  req: IStaticRequest;
  _status: IStaticAny;
begin
  _status := StaticAny(Status_marshaller,@status);
  req := StaticRequest(self,'after_completion');
  req.add_in_arg(_status);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TSynchronization_stub_clp
//***********************************************************
function TSynchronization_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosTransactions/Synchronization:1.0' then
    begin
      result := Pointer(self as ISynchronization);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TSynchronization_stub_clp.before_completion;
var
  _srv: IServant;
  srv: ISynchronization;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSynchronization_serv._narrow(_srv);
      if srv <> nil then
        srv.before_completion
    end;
  _postinvoke();
end;

procedure TSynchronization_stub_clp.after_completion(const status: TStatus);
var
  _srv: IServant;
  srv: ISynchronization;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSynchronization_serv._narrow(_srv);
      if srv <> nil then
        srv.after_completion(status)
    end;
  _postinvoke();
end;

//***********************************************************
// TSynchronization_serv
//***********************************************************
function TSynchronization_serv._this(): ISynchronization;
var
  obj: IORBObject;
begin
  obj := this();
  result := TSynchronization._narrow(obj);
end;

function TSynchronization_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/Synchronization:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TSynchronization_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/Synchronization:1.0';
end;

function TSynchronization_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TSynchronization_stub_clp.Create(poa,obj);
end;

procedure TSynchronization_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TSynchronization_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosTransactions/Synchronization:1.0' then
    begin
      result := Pointer(ISynchronization(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TSynchronization_serv._narrow(const srv : IServant): ISynchronization;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/Synchronization:1.0');
  if p <> nil then
    result := ISynchronization(p)
end;

function TSynchronization_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  after_completion_status: TStatus;
begin
  result := true;
  if req.op_name = 'before_completion' then
    begin
      if not req.read_args() then  exit;
      before_completion;
      req.write_results();
      exit;
    end
  else if req.op_name = 'after_completion' then
    begin
      req.add_in_arg(StaticAny(Status_marshaller,@after_completion_status) as IStaticAny);
      if not req.read_args() then  exit;
      after_completion(after_completion_status);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TSynchronization_marshaller
//***********************************************************
function TSynchronization_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ISynchronization(addr^) := TSynchronization._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TSynchronization_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ISynchronization(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TSynchronization_marshaller._free(var addr: Pointer);
begin
  ISynchronization(addr^) := nil;
end;

procedure TSynchronization_marshaller._create(var addr: Pointer);
begin
  ISynchronization(addr^) := TSynchronization_stub.Create();
end;

procedure TSynchronization_marshaller._assign(dst, src: Pointer);
begin
  ISynchronization(dst^) := ISynchronization(src^);
end;

function TSynchronization_marshaller.typecode: ITypeCode;
begin
  result := _tc_Synchronization.typecode;
end;

//***********************************************************
// TSubtransactionAwareResource
//***********************************************************
function TSubtransactionAwareResource.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0' then
    begin
      result := Pointer(self as ISubtransactionAwareResource);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TSubtransactionAwareResource._narrow(const obj : IORBObject): ISubtransactionAwareResource;
var
  p: Pointer;
  stub: TSubtransactionAwareResource_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0');
  if p <> nil then
    result := ISubtransactionAwareResource(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0') then
        begin
          stub := TSubtransactionAwareResource_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TSubtransactionAwareResource.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0'
end;

//***********************************************************
// TSubtransactionAwareResource_stub
//***********************************************************
function TSubtransactionAwareResource_stub.prepare: TVote;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Vote_marshaller, @result);
  req := StaticRequest(self,'prepare');
  req.set_result(_result);
  req.set_exceptions_tc([_tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[HeuristicMixed_marshaller, 'IDL:omg.org/CosTransactions/HeuristicMixed:1.0', HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TSubtransactionAwareResource_stub.rollback;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'rollback');
  req.set_exceptions_tc([_tc_HeuristicCommit.typecode, _tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[HeuristicCommit_marshaller, 'IDL:omg.org/CosTransactions/HeuristicCommit:1.0', HeuristicMixed_marshaller, 'IDL:omg.org/CosTransactions/HeuristicMixed:1.0', HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TSubtransactionAwareResource_stub.commit;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'commit');
  req.set_exceptions_tc([_tc_NotPrepared.typecode, _tc_HeuristicRollback.typecode, _tc_HeuristicMixed.typecode, _tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[NotPrepared_marshaller, 'IDL:omg.org/CosTransactions/NotPrepared:1.0', HeuristicRollback_marshaller, 'IDL:omg.org/CosTransactions/HeuristicRollback:1.0', HeuristicMixed_marshaller, 'IDL:omg.org/CosTransactions/HeuristicMixed:1.0', HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TSubtransactionAwareResource_stub.commit_one_phase;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'commit_one_phase');
  req.set_exceptions_tc([_tc_HeuristicHazard.typecode]);
  req.invoke;
  dorb_static_throw(req,[HeuristicHazard_marshaller, 'IDL:omg.org/CosTransactions/HeuristicHazard:1.0']);
end;

procedure TSubtransactionAwareResource_stub.forget;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'forget');
  req.invoke;
  dorb_static_throw(req);
end;

procedure TSubtransactionAwareResource_stub.commit_subtransaction(const parent: ICoordinator);
var
  req: IStaticRequest;
  _parent: IStaticAny;
begin
  _parent := StaticAny(Coordinator_marshaller,@parent);
  req := StaticRequest(self,'commit_subtransaction');
  req.add_in_arg(_parent);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TSubtransactionAwareResource_stub.rollback_subtransaction;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'rollback_subtransaction');
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TSubtransactionAwareResource_stub_clp
//***********************************************************
function TSubtransactionAwareResource_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0' then
    begin
      result := Pointer(self as ISubtransactionAwareResource);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TSubtransactionAwareResource_stub_clp.commit_subtransaction(const parent: ICoordinator);
var
  _srv: IServant;
  srv: ISubtransactionAwareResource;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSubtransactionAwareResource_serv._narrow(_srv);
      if srv <> nil then
        srv.commit_subtransaction(parent)
    end;
  _postinvoke();
end;

procedure TSubtransactionAwareResource_stub_clp.rollback_subtransaction;
var
  _srv: IServant;
  srv: ISubtransactionAwareResource;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSubtransactionAwareResource_serv._narrow(_srv);
      if srv <> nil then
        srv.rollback_subtransaction
    end;
  _postinvoke();
end;

//***********************************************************
// TSubtransactionAwareResource_serv
//***********************************************************
function TSubtransactionAwareResource_serv._this(): ISubtransactionAwareResource;
var
  obj: IORBObject;
begin
  obj := this();
  result := TSubtransactionAwareResource._narrow(obj);
end;

function TSubtransactionAwareResource_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TSubtransactionAwareResource_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0';
end;

function TSubtransactionAwareResource_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TSubtransactionAwareResource_stub_clp.Create(poa,obj);
end;

procedure TSubtransactionAwareResource_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TSubtransactionAwareResource_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0' then
    begin
      result := Pointer(ISubtransactionAwareResource(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TSubtransactionAwareResource_serv._narrow(const srv : IServant): ISubtransactionAwareResource;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CosTransactions/SubtransactionAwareResource:1.0');
  if p <> nil then
    result := ISubtransactionAwareResource(p)
end;

function TSubtransactionAwareResource_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  commit_subtransaction_parent: ICoordinator;
begin
  result := true;
  if req.op_name = 'commit_subtransaction' then
    begin
      req.add_in_arg(StaticAny(Coordinator_marshaller,@commit_subtransaction_parent) as IStaticAny);
      if not req.read_args() then  exit;
      commit_subtransaction(commit_subtransaction_parent);
      req.write_results();
      exit;
    end
  else if req.op_name = 'rollback_subtransaction' then
    begin
      if not req.read_args() then  exit;
      rollback_subtransaction;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TSubtransactionAwareResource_marshaller
//***********************************************************
function TSubtransactionAwareResource_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ISubtransactionAwareResource(addr^) := TSubtransactionAwareResource._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TSubtransactionAwareResource_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ISubtransactionAwareResource(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TSubtransactionAwareResource_marshaller._free(var addr: Pointer);
begin
  ISubtransactionAwareResource(addr^) := nil;
end;

procedure TSubtransactionAwareResource_marshaller._create(var addr: Pointer);
begin
  ISubtransactionAwareResource(addr^) := TSubtransactionAwareResource_stub.Create();
end;

procedure TSubtransactionAwareResource_marshaller._assign(dst, src: Pointer);
begin
  ISubtransactionAwareResource(dst^) := ISubtransactionAwareResource(src^);
end;

function TSubtransactionAwareResource_marshaller.typecode: ITypeCode;
begin
  result := _tc_SubtransactionAwareResource.typecode;
end;

function any_to_Status(const a: IAny; var val: TStatus): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Status_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Status_to_any(const val: TStatus): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Status_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_Vote(const a: IAny; var val: TVote): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Vote_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Vote_to_any(const val: TVote): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Vote_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_otid_t(const a: IAny; var val: Totid_t): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(otid_t_marshaller,@val);
  result := a.to_static_any(stat);
end;

function otid_t_to_any(const val: Totid_t): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(otid_t_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_TransIdentity(const a: IAny; var val: TTransIdentity): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(TransIdentity_marshaller,@val);
  result := a.to_static_any(stat);
end;

function TransIdentity_to_any(const val: TTransIdentity): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(TransIdentity_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_TransIdentity_seq(const a: IAny; var val): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(TransIdentity_seq_marshaller,@val);
  result := a.to_static_any(stat);
end;

function TransIdentity_seq_to_any(const val): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(TransIdentity_seq_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_PropagationContext(const a: IAny; var val: TPropagationContext): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(PropagationContext_marshaller,@val);
  result := a.to_static_any(stat);
end;

function PropagationContext_to_any(const val: TPropagationContext): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(PropagationContext_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_HeuristicRollback(const a: IAny; var val: IHeuristicRollback): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicRollback_marshaller,@val);
  result := a.to_static_any(stat);
end;

function HeuristicRollback_to_any(const val: IHeuristicRollback): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicRollback_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_HeuristicCommit(const a: IAny; var val: IHeuristicCommit): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicCommit_marshaller,@val);
  result := a.to_static_any(stat);
end;

function HeuristicCommit_to_any(const val: IHeuristicCommit): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicCommit_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_HeuristicMixed(const a: IAny; var val: IHeuristicMixed): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicMixed_marshaller,@val);
  result := a.to_static_any(stat);
end;

function HeuristicMixed_to_any(const val: IHeuristicMixed): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicMixed_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_HeuristicHazard(const a: IAny; var val: IHeuristicHazard): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicHazard_marshaller,@val);
  result := a.to_static_any(stat);
end;

function HeuristicHazard_to_any(const val: IHeuristicHazard): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(HeuristicHazard_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_SubtransactionsUnavailable(const a: IAny; var val: ISubtransactionsUnavailable): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(SubtransactionsUnavailable_marshaller,@val);
  result := a.to_static_any(stat);
end;

function SubtransactionsUnavailable_to_any(const val: ISubtransactionsUnavailable): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(SubtransactionsUnavailable_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_NotSubtransaction(const a: IAny; var val: INotSubtransaction): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotSubtransaction_marshaller,@val);
  result := a.to_static_any(stat);
end;

function NotSubtransaction_to_any(const val: INotSubtransaction): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotSubtransaction_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_Inactive(const a: IAny; var val: IInactive): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Inactive_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Inactive_to_any(const val: IInactive): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Inactive_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_NotPrepared(const a: IAny; var val: INotPrepared): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotPrepared_marshaller,@val);
  result := a.to_static_any(stat);
end;

function NotPrepared_to_any(const val: INotPrepared): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(NotPrepared_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_NoTransaction(const a: IAny; var val: INoTransaction): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(NoTransaction_marshaller,@val);
  result := a.to_static_any(stat);
end;

function NoTransaction_to_any(const val: INoTransaction): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(NoTransaction_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_InvalidControl(const a: IAny; var val: IInvalidControl): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(InvalidControl_marshaller,@val);
  result := a.to_static_any(stat);
end;

function InvalidControl_to_any(const val: IInvalidControl): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(InvalidControl_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_Unavailable(const a: IAny; var val: IUnavailable): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Unavailable_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Unavailable_to_any(const val: IUnavailable): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Unavailable_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_SynchronizationUnavailable(const a: IAny; var val: ISynchronizationUnavailable): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(SynchronizationUnavailable_marshaller,@val);
  result := a.to_static_any(stat);
end;

function SynchronizationUnavailable_to_any(const val: ISynchronizationUnavailable): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(SynchronizationUnavailable_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_TransactionFactory(const a: IAny; var val: ITransactionFactory): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(TransactionFactory_marshaller,@val);
  result := a.to_static_any(stat);
end;

function TransactionFactory_to_any(const val: ITransactionFactory): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(TransactionFactory_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_Control(const a: IAny; var val: IControl): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Control_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Control_to_any(const val: IControl): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Control_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_Terminator(const a: IAny; var val: ITerminator): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Terminator_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Terminator_to_any(const val: ITerminator): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Terminator_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_Coordinator(const a: IAny; var val: ICoordinator): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Coordinator_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Coordinator_to_any(const val: ICoordinator): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Coordinator_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_RecoveryCoordinator(const a: IAny; var val: IRecoveryCoordinator): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(RecoveryCoordinator_marshaller,@val);
  result := a.to_static_any(stat);
end;

function RecoveryCoordinator_to_any(const val: IRecoveryCoordinator): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(RecoveryCoordinator_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_Resource(const a: IAny; var val: IResource): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Resource_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Resource_to_any(const val: IResource): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Resource_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_TransactionalObject(const a: IAny; var val: ITransactionalObject): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(TransactionalObject_marshaller,@val);
  result := a.to_static_any(stat);
end;

function TransactionalObject_to_any(const val: ITransactionalObject): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(TransactionalObject_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_Synchronization(const a: IAny; var val: ISynchronization): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Synchronization_marshaller,@val);
  result := a.to_static_any(stat);
end;

function Synchronization_to_any(const val: ISynchronization): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(Synchronization_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

function any_to_SubtransactionAwareResource(const a: IAny; var val: ISubtransactionAwareResource): Boolean;
var
  stat: IStaticAny;
begin
  stat := StaticAny(SubtransactionAwareResource_marshaller,@val);
  result := a.to_static_any(stat);
end;

function SubtransactionAwareResource_to_any(const val: ISubtransactionAwareResource): IAny;
var
  stat: IStaticAny;
begin
  stat := StaticAny(SubtransactionAwareResource_marshaller,@val);
  result := CreateAny;
  result.from_static_any(stat);
end;

initialization
  Status_marshaller := TStatus_marshaller.Create();
  Vote_marshaller := TVote_marshaller.Create();
  otid_t_marshaller := Totid_t_marshaller.Create();
  TransIdentity_marshaller := TTransIdentity_marshaller.Create();
  TransIdentity_seq_marshaller := TTransIdentity_seq_marshaller.Create();
  PropagationContext_marshaller := TPropagationContext_marshaller.Create();
  HeuristicRollback_marshaller := THeuristicRollback_marshaller.Create();
  HeuristicCommit_marshaller := THeuristicCommit_marshaller.Create();
  HeuristicMixed_marshaller := THeuristicMixed_marshaller.Create();
  HeuristicHazard_marshaller := THeuristicHazard_marshaller.Create();
  SubtransactionsUnavailable_marshaller := TSubtransactionsUnavailable_marshaller.Create();
  NotSubtransaction_marshaller := TNotSubtransaction_marshaller.Create();
  Inactive_marshaller := TInactive_marshaller.Create();
  NotPrepared_marshaller := TNotPrepared_marshaller.Create();
  NoTransaction_marshaller := TNoTransaction_marshaller.Create();
  InvalidControl_marshaller := TInvalidControl_marshaller.Create();
  Unavailable_marshaller := TUnavailable_marshaller.Create();
  SynchronizationUnavailable_marshaller := TSynchronizationUnavailable_marshaller.Create();
  TransactionFactory_marshaller := TTransactionFactory_marshaller.Create();
  Control_marshaller := TControl_marshaller.Create();
  Terminator_marshaller := TTerminator_marshaller.Create();
  Coordinator_marshaller := TCoordinator_marshaller.Create();
  RecoveryCoordinator_marshaller := TRecoveryCoordinator_marshaller.Create();
  Resource_marshaller := TResource_marshaller.Create();
  TransactionalObject_marshaller := TTransactionalObject_marshaller.Create();
  Synchronization_marshaller := TSynchronization_marshaller.Create();
  SubtransactionAwareResource_marshaller := TSubtransactionAwareResource_marshaller.Create();
  _tc_Status := CreateTypeCodeConst('01000000110000001e010000010000002700000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5374617475733a'+
    '312e3000000700000053746174757300000a0000000d00000053746174757341637469766500000000150000005374617475734d61726b'+
    '6564526f6c6c6261636b000000000f0000005374617475735072657061726564000010000000537461747573436f6d6d69747465640011'+
    '000000537461747573526f6c6c65644261636b000000000e000000537461747573556e6b6e6f776e000000140000005374617475734e6f'+
    '5472616e73616374696f6e0010000000537461747573507265706172696e670011000000537461747573436f6d6d697474696e67000000'+
    '0012000000537461747573526f6c6c696e674261636b00');
  _tc_Vote := CreateTypeCodeConst('010000001100000075000000010000002500000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f566f74653a312e'+
    '300000000005000000566f746500000000030000000b000000566f7465436f6d6d697400000d000000566f7465526f6c6c6261636b0000'+
    '00000d000000566f7465526561644f6e6c7900');
  _tc_otid_t := CreateTypeCodeConst('010000000f000000d4000000010000002700000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f6f7469645f743a'+
    '312e300000070000006f7469645f7400000300000009000000666f726d6174494400000000030000000d000000627175616c5f6c656e67'+
    '7468000000000300000004000000746964001500000058000000010000002900000049444c3a6f6d672e6f72672f436f735472616e7361'+
    '6374696f6e732f4f637465745365713a312e3000000000090000004f6374657453657100000000130000000c000000010000000a00000000000000');
  _tc_TransIdentity := CreateTypeCodeConst('010000000f000000e8010000010000002e00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5472616e734964'+
    '656e746974793a312e300000000e0000005472616e734964656e746974790000000300000006000000636f6f72640000000e0000004400'+
    '0000010000002c00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f436f6f7264696e61746f723a312e30000c'+
    '000000436f6f7264696e61746f7200050000007465726d000000000e00000043000000010000002b00000049444c3a6f6d672e6f72672f'+
    '436f735472616e73616374696f6e732f5465726d696e61746f723a312e3000000b0000005465726d696e61746f720000050000006f7469'+
    '64000000000f000000d4000000010000002700000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f6f7469645f74'+
    '3a312e300000070000006f7469645f7400000300000009000000666f726d6174494400000000030000000d000000627175616c5f6c656e'+
    '677468000000000300000004000000746964001500000058000000010000002900000049444c3a6f6d672e6f72672f436f735472616e73'+
    '616374696f6e732f4f637465745365713a312e3000000000090000004f6374657453657100000000130000000c000000010000000a00000000000000');
  _tc_TransIdentity_seq := CreateTypeCodeConst('0100000013000000f8010000010000000f000000e8010000010000002e00000049444c3a6f6d672e6f72672f436f735472616e73616374'+
    '696f6e732f5472616e734964656e746974793a312e300000000e0000005472616e734964656e746974790000000300000006000000636f'+
    '6f72640000000e00000044000000010000002c00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f436f6f7264'+
    '696e61746f723a312e30000c000000436f6f7264696e61746f7200050000007465726d000000000e00000043000000010000002b000000'+
    '49444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5465726d696e61746f723a312e3000000b0000005465726d696e61'+
    '746f720000050000006f746964000000000f000000d4000000010000002700000049444c3a6f6d672e6f72672f436f735472616e736163'+
    '74696f6e732f6f7469645f743a312e300000070000006f7469645f7400000300000009000000666f726d6174494400000000030000000d'+
    '000000627175616c5f6c656e677468000000000300000004000000746964001500000058000000010000002900000049444c3a6f6d672e'+
    '6f72672f436f735472616e73616374696f6e732f4f637465745365713a312e3000000000090000004f6374657453657100000000130000'+
    '000c000000010000000a0000000000000000000000');
  _tc_PropagationContext := CreateTypeCodeConst('010000000f000000f4040000010000003300000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f50726f70616761'+
    '74696f6e436f6e746578743a312e3000001300000050726f7061676174696f6e436f6e746578740000040000000800000074696d656f75'+
    '7400050000000800000063757272656e74000f000000e8010000010000002e00000049444c3a6f6d672e6f72672f436f735472616e7361'+
    '6374696f6e732f5472616e734964656e746974793a312e300000000e0000005472616e734964656e746974790000000300000006000000'+
    '636f6f72640000000e00000044000000010000002c00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f436f6f'+
    '7264696e61746f723a312e30000c000000436f6f7264696e61746f7200050000007465726d000000000e00000043000000010000002b00'+
    '000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5465726d696e61746f723a312e3000000b0000005465726d69'+
    '6e61746f720000050000006f746964000000000f000000d4000000010000002700000049444c3a6f6d672e6f72672f436f735472616e73'+
    '616374696f6e732f6f7469645f743a312e300000070000006f7469645f7400000300000009000000666f726d6174494400000000030000'+
    '000d000000627175616c5f6c656e677468000000000300000004000000746964001500000058000000010000002900000049444c3a6f6d'+
    '672e6f72672f436f735472616e73616374696f6e732f4f637465745365713a312e3000000000090000004f637465745365710000000013'+
    '0000000c000000010000000a0000000000000008000000706172656e7473001500000054020000010000003100000049444c3a6f6d672e'+
    '6f72672f436f735472616e73616374696f6e732f5472616e734964656e746974795365713a312e3000000000110000005472616e734964'+
    '656e746974795365710000000013000000f8010000010000000f000000e8010000010000002e00000049444c3a6f6d672e6f72672f436f'+
    '735472616e73616374696f6e732f5472616e734964656e746974793a312e300000000e0000005472616e734964656e7469747900000003'+
    '00000006000000636f6f72640000000e00000044000000010000002c00000049444c3a6f6d672e6f72672f436f735472616e7361637469'+
    '6f6e732f436f6f7264696e61746f723a312e30000c000000436f6f7264696e61746f7200050000007465726d000000000e000000430000'+
    '00010000002b00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5465726d696e61746f723a312e3000000b00'+
    '00005465726d696e61746f720000050000006f746964000000000f000000d4000000010000002700000049444c3a6f6d672e6f72672f43'+
    '6f735472616e73616374696f6e732f6f7469645f743a312e300000070000006f7469645f7400000300000009000000666f726d61744944'+
    '00000000030000000d000000627175616c5f6c656e67746800000000030000000400000074696400150000005800000001000000290000'+
    '0049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f4f637465745365713a312e3000000000090000004f6374657453'+
    '657100000000130000000c000000010000000a00000000000000000000001d000000696d706c656d656e746174696f6e5f737065636966'+
    '69635f64617461000000000b000000');
  _tc_HeuristicRollback := CreateTypeCodeConst('010000001600000058000000010000003200000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f48657572697374'+
    '6963526f6c6c6261636b3a312e3000000012000000486575726973746963526f6c6c6261636b00000000000000');
  _tc_HeuristicCommit := CreateTypeCodeConst('010000001600000050000000010000003000000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f48657572697374'+
    '6963436f6d6d69743a312e300010000000486575726973746963436f6d6d69740000000000');
  _tc_HeuristicMixed := CreateTypeCodeConst('010000001600000050000000010000002f00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f48657572697374'+
    '69634d697865643a312e3000000f0000004865757269737469634d69786564000000000000');
  _tc_HeuristicHazard := CreateTypeCodeConst('010000001600000050000000010000003000000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f48657572697374'+
    '696348617a6172643a312e30001000000048657572697374696348617a6172640000000000');
  _tc_SubtransactionsUnavailable := CreateTypeCodeConst('010000001600000068000000010000003b00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5375627472616e'+
    '73616374696f6e73556e617661696c61626c653a312e3000001b0000005375627472616e73616374696f6e73556e617661696c61626c65'+
    '000000000000');
  _tc_NotSubtransaction := CreateTypeCodeConst('010000001600000058000000010000003200000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f4e6f7453756274'+
    '72616e73616374696f6e3a312e30000000120000004e6f745375627472616e73616374696f6e00000000000000');
  _tc_Inactive := CreateTypeCodeConst('010000001600000048000000010000002900000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f496e6163746976'+
    '653a312e300000000009000000496e6163746976650000000000000000');
  _tc_NotPrepared := CreateTypeCodeConst('010000001600000048000000010000002c00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f4e6f7450726570'+
    '617265643a312e30000c0000004e6f7450726570617265640000000000');
  _tc_NoTransaction := CreateTypeCodeConst('010000001600000050000000010000002e00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f4e6f5472616e73'+
    '616374696f6e3a312e300000000e0000004e6f5472616e73616374696f6e00000000000000');
  _tc_InvalidControl := CreateTypeCodeConst('010000001600000050000000010000002f00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f496e76616c6964'+
    '436f6e74726f6c3a312e3000000f000000496e76616c6964436f6e74726f6c000000000000');
  _tc_Unavailable := CreateTypeCodeConst('010000001600000048000000010000002c00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f556e617661696c'+
    '61626c653a312e30000c000000556e617661696c61626c650000000000');
  _tc_SynchronizationUnavailable := CreateTypeCodeConst('010000001600000068000000010000003b00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f53796e6368726f'+
    '6e697a6174696f6e556e617661696c61626c653a312e3000001b00000053796e6368726f6e697a6174696f6e556e617661696c61626c65'+
    '000000000000');
  _tc_TransactionFactory := CreateTypeCodeConst('010000000e00000053000000010000003300000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5472616e736163'+
    '74696f6e466163746f72793a312e300000130000005472616e73616374696f6e466163746f727900');
  _tc_Control := CreateTypeCodeConst('010000000e0000003c000000010000002800000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f436f6e74726f6c'+
    '3a312e300008000000436f6e74726f6c00');
  _tc_Terminator := CreateTypeCodeConst('010000000e00000043000000010000002b00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5465726d696e61'+
    '746f723a312e3000000b0000005465726d696e61746f7200');
  _tc_Coordinator := CreateTypeCodeConst('010000000e00000044000000010000002c00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f436f6f7264696e'+
    '61746f723a312e30000c000000436f6f7264696e61746f7200');
  _tc_RecoveryCoordinator := CreateTypeCodeConst('010000000e00000054000000010000003400000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5265636f766572'+
    '79436f6f7264696e61746f723a312e3000140000005265636f76657279436f6f7264696e61746f7200');
  _tc_Resource := CreateTypeCodeConst('010000000e00000041000000010000002900000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5265736f757263'+
    '653a312e3000000000090000005265736f7572636500');
  _tc_TransactionalObject := CreateTypeCodeConst('010000000e00000054000000010000003400000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5472616e736163'+
    '74696f6e616c4f626a6563743a312e3000140000005472616e73616374696f6e616c4f626a65637400');
  _tc_Synchronization := CreateTypeCodeConst('010000000e0000004c000000010000003000000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f53796e6368726f'+
    '6e697a6174696f6e3a312e30001000000053796e6368726f6e697a6174696f6e00');
  _tc_SubtransactionAwareResource := CreateTypeCodeConst('010000000e00000064000000010000003c00000049444c3a6f6d672e6f72672f436f735472616e73616374696f6e732f5375627472616e'+
    '73616374696f6e41776172655265736f757263653a312e30001c0000005375627472616e73616374696f6e41776172655265736f7572636500');
end.
