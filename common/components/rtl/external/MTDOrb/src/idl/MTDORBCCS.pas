// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -wpMTDORBCCS;CosConcurrencyControl -i..\..\idl ..\..\idl\MTDORBCCS.idl" 
//                                                                            
unit MTDORBCCS;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, MTDORBCCS_int, value_int, value, CosTransactions_int,
  CosTransactions, CCS_int, CCS, poa_int, poa;

type

  TCCS_LockSetNotFound_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:mtdorb.org/CCS/LockSetNotFound:1.0 } 
  TCCS_LockSetNotFound = class(UserException,ICCS_LockSetNotFound)
  protected
    procedure throw; override;
    function clone(): IORBException; override;
    function repoid(): RepositoryID; override;
    procedure encode(const enc: IEncoder); override;
    procedure encode_any(const a: IAny); override;
  public
    constructor Create(ex: TCCS_LockSetNotFound); overload;
    constructor Create(); overload;
  end;

  {** IDL:mtdorb.org/CCS/LockSetFactory:1.0 } 
  TCCS_LockSetFactory = class(TLockSetFactory,ICCS_LockSetFactory)
  protected
    function create_lockset(const object_name: AnsiString): ILockSet; virtual; abstract;
    function get_lockset(const object_name: AnsiString; const _create: Boolean): ILockSet; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ICCS_LockSetFactory;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:mtdorb.org/CCS/LockSetFactory:1.0} 
  TCCS_LockSetFactory_stub = class(TCCS_LockSetFactory)
  protected
    function _create: ILockSet; override;
    function create_related(const which: ILockSet): ILockSet; override;
    function create_transactional: ITransactionalLockSet; override;
    function create_transactional_related(const which: ITransactionalLockSet): ITransactionalLockSet; override;
    function create_lockset(const object_name: AnsiString): ILockSet; override;
    function get_lockset(const object_name: AnsiString; const _create: Boolean): ILockSet; override;
  end;

  {** POA stub for interface IDL:mtdorb.org/CCS/LockSetFactory:1.0} 
  TCCS_LockSetFactory_stub_clp = class(TLockSetFactory_stub_clp,ICCS_LockSetFactory)
  protected
    function create_lockset(const object_name: AnsiString): ILockSet; virtual;
    function get_lockset(const object_name: AnsiString; const _create: Boolean): ILockSet; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:mtdorb.org/CCS/LockSetFactory:1.0} 
  TCCS_LockSetFactory_serv = class(TLockSetFactory_serv,ICCS_LockSetFactory)
  protected
    function create_lockset(const object_name: AnsiString): ILockSet; virtual; abstract;
    function get_lockset(const object_name: AnsiString; const _create: Boolean): ILockSet; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ICCS_LockSetFactory;
    class function _narrow(const srv : IServant): ICCS_LockSetFactory;
  end;

  TCCS_LockSetFactory_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  CCS_LockSetNotFound_marshaller : IStaticTypeInfo;
  CCS_LockSetFactory_marshaller : IStaticTypeInfo;
  _tc_CCS_LockSetNotFound : ITypeCodeConst;
  _tc_CCS_LockSetFactory : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TCCS_LockSetNotFound_marshaller
//***********************************************************
function TCCS_LockSetNotFound_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  repoid: RepositoryId;
begin
  result := false;
  if not dec.except_begin(repoid) then exit;
  if not dec.except_end then exit;
  result := true;
end;

procedure TCCS_LockSetNotFound_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.except_begin('IDL:mtdorb.org/CCS/LockSetNotFound:1.0');
  enc.except_end;
end;

procedure TCCS_LockSetNotFound_marshaller._free(var addr: Pointer);
begin
  ICCS_LockSetNotFound(addr^) := nil;
end;

procedure TCCS_LockSetNotFound_marshaller._create(var addr: Pointer);
begin
  ICCS_LockSetNotFound(addr^) := TCCS_LockSetNotFound.Create();
end;

procedure TCCS_LockSetNotFound_marshaller._assign(dst, src: Pointer);
begin
  ICCS_LockSetNotFound(dst^) := ICCS_LockSetNotFound(src^);
end;

function TCCS_LockSetNotFound_marshaller.typecode: ITypeCode;
begin
  result := _tc_CCS_LockSetNotFound.typecode;
end;

//***********************************************************
// TCCS_LockSetNotFound
//***********************************************************
constructor TCCS_LockSetNotFound.Create(ex: TCCS_LockSetNotFound);
begin
  inherited Create();
end;

procedure TCCS_LockSetNotFound.throw;
begin
  raise TCCS_LockSetNotFound.Create(self);
end;

function TCCS_LockSetNotFound.clone(): IORBException;
begin
  result := TCCS_LockSetNotFound.Create(self);
end;

procedure TCCS_LockSetNotFound.encode(const enc: IEncoder);
var
  int : ICCS_LockSetNotFound;
begin
  int := self;
  CCS_LockSetNotFound_marshaller.marshal(enc,@int);
end;

procedure TCCS_LockSetNotFound.encode_any(const a: IAny);
var
  stat: IStaticAny;
begin
  stat := StaticAny(CCS_LockSetNotFound_marshaller, Self);
  a.from_static_any(stat);
end;

constructor TCCS_LockSetNotFound.Create();
begin
  inherited Create();
end;

function TCCS_LockSetNotFound.repoid(): RepositoryID;
begin
  result := 'IDL:mtdorb.org/CCS/LockSetNotFound:1.0';
end;

//***********************************************************
// TCCS_LockSetFactory
//***********************************************************
function TCCS_LockSetFactory.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:mtdorb.org/CCS/LockSetFactory:1.0' then
    begin
      result := Pointer(self as ICCS_LockSetFactory);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TCCS_LockSetFactory._narrow(const obj : IORBObject): ICCS_LockSetFactory;
var
  p: Pointer;
  stub: TCCS_LockSetFactory_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:mtdorb.org/CCS/LockSetFactory:1.0');
  if p <> nil then
    result := ICCS_LockSetFactory(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:mtdorb.org/CCS/LockSetFactory:1.0') then
        begin
          stub := TCCS_LockSetFactory_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TCCS_LockSetFactory.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:mtdorb.org/CCS/LockSetFactory:1.0'
end;

//***********************************************************
// TCCS_LockSetFactory_stub
//***********************************************************
function TCCS_LockSetFactory_stub._create: ILockSet;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(LockSet_marshaller, @result);
  req := StaticRequest(self,'create');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCCS_LockSetFactory_stub.create_related(const which: ILockSet): ILockSet;
var
  req: IStaticRequest;
  _which: IStaticAny;
  _result: IStaticAny;
begin
  _which := StaticAny(LockSet_marshaller,@which);
  _result := StaticAny(LockSet_marshaller, @result);
  req := StaticRequest(self,'create_related');
  req.add_in_arg(_which);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCCS_LockSetFactory_stub.create_transactional: ITransactionalLockSet;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(TransactionalLockSet_marshaller, @result);
  req := StaticRequest(self,'create_transactional');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCCS_LockSetFactory_stub.create_transactional_related(const which: ITransactionalLockSet): ITransactionalLockSet;
var
  req: IStaticRequest;
  _which: IStaticAny;
  _result: IStaticAny;
begin
  _which := StaticAny(TransactionalLockSet_marshaller,@which);
  _result := StaticAny(TransactionalLockSet_marshaller, @result);
  req := StaticRequest(self,'create_transactional_related');
  req.add_in_arg(_which);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCCS_LockSetFactory_stub.create_lockset(const object_name: AnsiString): ILockSet;
var
  req: IStaticRequest;
  _object_name: IStaticAny;
  _result: IStaticAny;
begin
  _object_name := StaticAny(stat_string,@object_name);
  _result := StaticAny(LockSet_marshaller, @result);
  req := StaticRequest(self,'create_lockset');
  req.add_in_arg(_object_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TCCS_LockSetFactory_stub.get_lockset(const object_name: AnsiString; const _create: Boolean): ILockSet;
var
  req: IStaticRequest;
  _object_name: IStaticAny;
  __create: IStaticAny;
  _result: IStaticAny;
begin
  _object_name := StaticAny(stat_string,@object_name);
  __create := StaticAny(stat_boolean,@_create);
  _result := StaticAny(LockSet_marshaller, @result);
  req := StaticRequest(self,'get_lockset');
  req.add_in_arg(_object_name);
  req.add_in_arg(__create);
  req.set_result(_result);
  req.set_exceptions_tc([_tc_CCS_LockSetNotFound.typecode]);
  req.invoke;
  dorb_static_throw(req,[CCS_LockSetNotFound_marshaller, 'IDL:mtdorb.org/CCS/LockSetNotFound:1.0']);
end;

//***********************************************************
// TCCS_LockSetFactory_stub_clp
//***********************************************************
function TCCS_LockSetFactory_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:mtdorb.org/CCS/LockSetFactory:1.0' then
    begin
      result := Pointer(self as ICCS_LockSetFactory);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TCCS_LockSetFactory_stub_clp.create_lockset(const object_name: AnsiString): ILockSet;
var
  _srv: IServant;
  srv: ICCS_LockSetFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCCS_LockSetFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_lockset(object_name)
    end;
  _postinvoke();
end;

function TCCS_LockSetFactory_stub_clp.get_lockset(const object_name: AnsiString; const _create: Boolean): ILockSet;
var
  _srv: IServant;
  srv: ICCS_LockSetFactory;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TCCS_LockSetFactory_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_lockset(object_name, _create)
    end;
  _postinvoke();
end;

//***********************************************************
// TCCS_LockSetFactory_serv
//***********************************************************
function TCCS_LockSetFactory_serv._this(): ICCS_LockSetFactory;
var
  obj: IORBObject;
begin
  obj := this();
  result := TCCS_LockSetFactory._narrow(obj);
end;

function TCCS_LockSetFactory_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:mtdorb.org/CCS/LockSetFactory:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TCCS_LockSetFactory_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:mtdorb.org/CCS/LockSetFactory:1.0';
end;

function TCCS_LockSetFactory_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TCCS_LockSetFactory_stub_clp.Create(poa,obj);
end;

procedure TCCS_LockSetFactory_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TCCS_LockSetFactory_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:mtdorb.org/CCS/LockSetFactory:1.0' then
    begin
      result := Pointer(ICCS_LockSetFactory(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TCCS_LockSetFactory_serv._narrow(const srv : IServant): ICCS_LockSetFactory;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:mtdorb.org/CCS/LockSetFactory:1.0');
  if p <> nil then
    result := ICCS_LockSetFactory(p)
end;

function TCCS_LockSetFactory_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  create_lockset_result: ILockSet;
  create_lockset_object_name: AnsiString;
  get_lockset_result: ILockSet;
  get_lockset_object_name: AnsiString;
  get_lockset_create: Boolean;
begin
  result := true;
  if req.op_name = 'create_lockset' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_lockset_object_name) as IStaticAny);
      req.set_result(StaticAny(LockSet_marshaller,@create_lockset_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_lockset_result := create_lockset(create_lockset_object_name);
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_lockset' then
    begin
      req.add_in_arg(StaticAny(stat_string,@get_lockset_object_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@get_lockset_create) as IStaticAny);
      req.set_result(StaticAny(LockSet_marshaller,@get_lockset_result) as IStaticAny);
      if not req.read_args() then  exit;
      req.set_exceptions_tc([_tc_CCS_LockSetNotFound.typecode]);
      try
        get_lockset_result := get_lockset(get_lockset_object_name, get_lockset_create);
      except
        on LockSetNotFound: TCCS_LockSetNotFound do
          req.set_exception(TCCS_LockSetNotFound.Create(LockSetNotFound) as IORBException);
      end;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TCCS_LockSetFactory_marshaller
//***********************************************************
function TCCS_LockSetFactory_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ICCS_LockSetFactory(addr^) := TCCS_LockSetFactory._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TCCS_LockSetFactory_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ICCS_LockSetFactory(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TCCS_LockSetFactory_marshaller._free(var addr: Pointer);
begin
  ICCS_LockSetFactory(addr^) := nil;
end;

procedure TCCS_LockSetFactory_marshaller._create(var addr: Pointer);
begin
  ICCS_LockSetFactory(addr^) := TCCS_LockSetFactory_stub.Create();
end;

procedure TCCS_LockSetFactory_marshaller._assign(dst, src: Pointer);
begin
  ICCS_LockSetFactory(dst^) := ICCS_LockSetFactory(src^);
end;

function TCCS_LockSetFactory_marshaller.typecode: ITypeCode;
begin
  result := _tc_CCS_LockSetFactory.typecode;
end;

initialization
  CCS_LockSetNotFound_marshaller := TCCS_LockSetNotFound_marshaller.Create();
  CCS_LockSetFactory_marshaller := TCCS_LockSetFactory_marshaller.Create();
  _tc_CCS_LockSetNotFound := CreateTypeCodeConst('010000001600000048000000010000002700000049444c3a6d74646f72622e6f72672f4343532f4c6f636b5365744e6f74466f756e643a'+
    '312e300000100000004c6f636b5365744e6f74466f756e640000000000');
  _tc_CCS_LockSetFactory := CreateTypeCodeConst('010000000e00000043000000010000002600000049444c3a6d74646f72622e6f72672f4343532f4c6f636b536574466163746f72793a31'+
    '2e300000000f0000004c6f636b536574466163746f727900');
end.
