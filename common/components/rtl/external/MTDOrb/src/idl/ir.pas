// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -nuorb_int -without-prefix -i..\..\idl ..\..\idl\ir.idl" 
//                                                                            
unit ir;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, ir_int, ir_base_int, ir_base, poa_int, poa;

type

  TDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/Contained:1.0 } 
  TContained = class(TIRObject,IContained)
  protected
    function describe: TDescription; virtual; abstract;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual; abstract;
    procedure _set_id(const val: TRepositoryId); virtual; abstract;
    function _get_id: TRepositoryId; virtual; abstract;
    procedure _set_name(const val: TIdentifier); virtual; abstract;
    function _get_name: TIdentifier; virtual; abstract;
    procedure _set_version(const val: TVersionSpec); virtual; abstract;
    function _get_version: TVersionSpec; virtual; abstract;
    function _get_defined_in: IContainer; virtual; abstract;
    function _get_absolute_name: TScopedName; virtual; abstract;
    function _get_containing_repository: IRepository; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IContained;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/Contained:1.0} 
  TContained_stub = class(TContained)
  protected
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/Contained:1.0} 
  TContained_stub_clp = class(TIRObject_stub_clp,IContained)
  protected
    function describe: TDescription; virtual;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual;
    procedure _set_id(const val: TRepositoryId); virtual;
    function _get_id: TRepositoryId; virtual;
    procedure _set_name(const val: TIdentifier); virtual;
    function _get_name: TIdentifier; virtual;
    procedure _set_version(const val: TVersionSpec); virtual;
    function _get_version: TVersionSpec; virtual;
    function _get_defined_in: IContainer; virtual;
    function _get_absolute_name: TScopedName; virtual;
    function _get_containing_repository: IRepository; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/Contained:1.0} 
  TContained_serv = class(TIRObject_serv,IContained)
  protected
    function describe: TDescription; virtual; abstract;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual; abstract;
    procedure _set_id(const val: TRepositoryId); virtual; abstract;
    function _get_id: TRepositoryId; virtual; abstract;
    procedure _set_name(const val: TIdentifier); virtual; abstract;
    function _get_name: TIdentifier; virtual; abstract;
    procedure _set_version(const val: TVersionSpec); virtual; abstract;
    function _get_version: TVersionSpec; virtual; abstract;
    function _get_defined_in: IContainer; virtual; abstract;
    function _get_absolute_name: TScopedName; virtual; abstract;
    function _get_containing_repository: IRepository; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IContained;
    class function _narrow(const srv : IServant): IContained;
  end;

  TContained_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  Contained_seq = Array of IContained;
  PContained_seq = ^Contained_seq;

  TContained_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  InterfaceDef_seq = Array of IInterfaceDef;
  PInterfaceDef_seq = ^InterfaceDef_seq;

  TInterfaceDef_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  AbstractInterfaceDef_seq = Array of IAbstractInterfaceDef;
  PAbstractInterfaceDef_seq = ^AbstractInterfaceDef_seq;

  TAbstractInterfaceDef_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  LocalInterfaceDef_seq = Array of ILocalInterfaceDef;
  PLocalInterfaceDef_seq = ^LocalInterfaceDef_seq;

  TLocalInterfaceDef_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  ValueDef_seq = Array of IValueDef;
  PValueDef_seq = ^ValueDef_seq;

  TValueDef_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TInitializer_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  Initializer_seq = Array of TInitializer;
  PInitializer_seq = ^Initializer_seq;

  TInitializer_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  Description_seq = Array of TDescription;
  PDescription_seq = ^Description_seq;

  TDescription_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/Container:1.0 } 
  TContainer = class(TIRObject,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual; abstract;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual; abstract;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual; abstract;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual; abstract;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual; abstract;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual; abstract;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual; abstract;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual; abstract;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual; abstract;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual; abstract;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual; abstract;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual; abstract;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual; abstract;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual; abstract;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IContainer;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/Container:1.0} 
  TContainer_stub = class(TContainer)
  protected
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/Container:1.0} 
  TContainer_stub_clp = class(TIRObject_stub_clp,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/Container:1.0} 
  TContainer_serv = class(TIRObject_serv,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual; abstract;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual; abstract;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual; abstract;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual; abstract;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual; abstract;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual; abstract;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual; abstract;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual; abstract;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual; abstract;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual; abstract;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual; abstract;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual; abstract;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual; abstract;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual; abstract;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IContainer;
    class function _narrow(const srv : IServant): IContainer;
  end;

  TContainer_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TPrimitiveKind_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/Repository:1.0 } 
  TRepository = class(TContainer,IRepository)
  protected
    function lookup_id(const search_id: TRepositoryId): IContained; virtual; abstract;
    function get_primitive(const kind: TPrimitiveKind): IPrimitiveDef; virtual; abstract;
    function create_string(const bound: _ulong): IStringDef; virtual; abstract;
    function create_wstring(const bound: _ulong): IWstringDef; virtual; abstract;
    function create_sequence(const bound: _ulong; const element_type: IIDLType): ISequenceDef; virtual; abstract;
    function create_array(const length: _ulong; const element_type: IIDLType): IArrayDef; virtual; abstract;
    function create_fixed(const digits: _ushort; const scale: Short): IFixedDef; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IRepository;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/Repository:1.0} 
  TRepository_stub = class(TRepository)
  protected
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function lookup_id(const search_id: TRepositoryId): IContained; override;
    function get_primitive(const kind: TPrimitiveKind): IPrimitiveDef; override;
    function create_string(const bound: _ulong): IStringDef; override;
    function create_wstring(const bound: _ulong): IWstringDef; override;
    function create_sequence(const bound: _ulong; const element_type: IIDLType): ISequenceDef; override;
    function create_array(const length: _ulong; const element_type: IIDLType): IArrayDef; override;
    function create_fixed(const digits: _ushort; const scale: Short): IFixedDef; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/Repository:1.0} 
  TRepository_stub_clp = class(TContainer_stub_clp,IRepository)
  protected
    function lookup_id(const search_id: TRepositoryId): IContained; virtual;
    function get_primitive(const kind: TPrimitiveKind): IPrimitiveDef; virtual;
    function create_string(const bound: _ulong): IStringDef; virtual;
    function create_wstring(const bound: _ulong): IWstringDef; virtual;
    function create_sequence(const bound: _ulong; const element_type: IIDLType): ISequenceDef; virtual;
    function create_array(const length: _ulong; const element_type: IIDLType): IArrayDef; virtual;
    function create_fixed(const digits: _ushort; const scale: Short): IFixedDef; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/Repository:1.0} 
  TRepository_serv = class(TContainer_serv,IRepository)
  protected
    function lookup_id(const search_id: TRepositoryId): IContained; virtual; abstract;
    function get_primitive(const kind: TPrimitiveKind): IPrimitiveDef; virtual; abstract;
    function create_string(const bound: _ulong): IStringDef; virtual; abstract;
    function create_wstring(const bound: _ulong): IWstringDef; virtual; abstract;
    function create_sequence(const bound: _ulong; const element_type: IIDLType): ISequenceDef; virtual; abstract;
    function create_array(const length: _ulong; const element_type: IIDLType): IArrayDef; virtual; abstract;
    function create_fixed(const digits: _ushort; const scale: Short): IFixedDef; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IRepository;
    class function _narrow(const srv : IServant): IRepository;
  end;

  TRepository_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/ModuleDef:1.0 } 
  TModuleDef = class(TContainer,IModuleDef,IContained)
  protected
    function describe: TDescription; virtual; abstract;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual; abstract;
    procedure _set_id(const val: TRepositoryId); virtual; abstract;
    function _get_id: TRepositoryId; virtual; abstract;
    procedure _set_name(const val: TIdentifier); virtual; abstract;
    function _get_name: TIdentifier; virtual; abstract;
    procedure _set_version(const val: TVersionSpec); virtual; abstract;
    function _get_version: TVersionSpec; virtual; abstract;
    function _get_defined_in: IContainer; virtual; abstract;
    function _get_absolute_name: TScopedName; virtual; abstract;
    function _get_containing_repository: IRepository; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IModuleDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/ModuleDef:1.0} 
  TModuleDef_stub = class(TModuleDef,IContained)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/ModuleDef:1.0} 
  TModuleDef_stub_clp = class(TContainer_stub_clp,IModuleDef,IContained)
  protected
    function describe: TDescription; virtual;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual;
    procedure _set_id(const val: TRepositoryId); virtual;
    function _get_id: TRepositoryId; virtual;
    procedure _set_name(const val: TIdentifier); virtual;
    function _get_name: TIdentifier; virtual;
    procedure _set_version(const val: TVersionSpec); virtual;
    function _get_version: TVersionSpec; virtual;
    function _get_defined_in: IContainer; virtual;
    function _get_absolute_name: TScopedName; virtual;
    function _get_containing_repository: IRepository; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/ModuleDef:1.0} 
  TModuleDef_serv = class(TContainer_serv,IModuleDef,IContained)
  protected
    function describe: TDescription; virtual; abstract;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual; abstract;
    procedure _set_id(const val: TRepositoryId); virtual; abstract;
    function _get_id: TRepositoryId; virtual; abstract;
    procedure _set_name(const val: TIdentifier); virtual; abstract;
    function _get_name: TIdentifier; virtual; abstract;
    procedure _set_version(const val: TVersionSpec); virtual; abstract;
    function _get_version: TVersionSpec; virtual; abstract;
    function _get_defined_in: IContainer; virtual; abstract;
    function _get_absolute_name: TScopedName; virtual; abstract;
    function _get_containing_repository: IRepository; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IModuleDef;
    class function _narrow(const srv : IServant): IModuleDef;
  end;

  TModuleDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TModuleDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/ConstantDef:1.0 } 
  TConstantDef = class(TContained,IConstantDef)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    procedure _set_type_def(const val: IIDLType); virtual; abstract;
    function _get_type_def: IIDLType; virtual; abstract;
    procedure _set_value(const val: IAny); virtual; abstract;
    function _get_value: IAny; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IConstantDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/ConstantDef:1.0} 
  TConstantDef_stub = class(TConstantDef)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _set_type_def(const val: IIDLType); override;
    function _get_type_def: IIDLType; override;
    procedure _set_value(const val: IAny); override;
    function _get_value: IAny; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/ConstantDef:1.0} 
  TConstantDef_stub_clp = class(TContained_stub_clp,IConstantDef)
  protected
    function _get_type: ITypeCode; virtual;
    procedure _set_type_def(const val: IIDLType); virtual;
    function _get_type_def: IIDLType; virtual;
    procedure _set_value(const val: IAny); virtual;
    function _get_value: IAny; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/ConstantDef:1.0} 
  TConstantDef_serv = class(TContained_serv,IConstantDef)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    procedure _set_type_def(const val: IIDLType); virtual; abstract;
    function _get_type_def: IIDLType; virtual; abstract;
    procedure _set_value(const val: IAny); virtual; abstract;
    function _get_value: IAny; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IConstantDef;
    class function _narrow(const srv : IServant): IConstantDef;
  end;

  TConstantDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TConstantDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/TypedefDef:1.0 } 
  TTypedefDef = class(TContained,ITypedefDef,IIDLType)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ITypedefDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/TypedefDef:1.0} 
  TTypedefDef_stub = class(TTypedefDef,IIDLType)
  protected
    function _get_type: ITypeCode; override;
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/TypedefDef:1.0} 
  TTypedefDef_stub_clp = class(TContained_stub_clp,ITypedefDef,IIDLType)
  protected
    function _get_type: ITypeCode; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/TypedefDef:1.0} 
  TTypedefDef_serv = class(TContained_serv,ITypedefDef,IIDLType)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ITypedefDef;
    class function _narrow(const srv : IServant): ITypedefDef;
  end;

  TTypedefDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TTypeDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/StructDef:1.0 } 
  TStructDef = class(TTypedefDef,IStructDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual; abstract;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual; abstract;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual; abstract;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual; abstract;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual; abstract;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual; abstract;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual; abstract;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual; abstract;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual; abstract;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual; abstract;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual; abstract;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual; abstract;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual; abstract;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual; abstract;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual; abstract;
    procedure _set_members(const val: TStructMemberSeq); virtual; abstract;
    function _get_members: TStructMemberSeq; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IStructDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/StructDef:1.0} 
  TStructDef_stub = class(TStructDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_members(const val: TStructMemberSeq); override;
    function _get_members: TStructMemberSeq; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/StructDef:1.0} 
  TStructDef_stub_clp = class(TTypedefDef_stub_clp,IStructDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual;
    procedure _set_members(const val: TStructMemberSeq); virtual;
    function _get_members: TStructMemberSeq; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/StructDef:1.0} 
  TStructDef_serv = class(TTypedefDef_serv,IStructDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual; abstract;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual; abstract;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual; abstract;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual; abstract;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual; abstract;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual; abstract;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual; abstract;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual; abstract;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual; abstract;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual; abstract;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual; abstract;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual; abstract;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual; abstract;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual; abstract;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual; abstract;
    procedure _set_members(const val: TStructMemberSeq); virtual; abstract;
    function _get_members: TStructMemberSeq; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IStructDef;
    class function _narrow(const srv : IServant): IStructDef;
  end;

  TStructDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/UnionDef:1.0 } 
  TUnionDef = class(TTypedefDef,IUnionDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual; abstract;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual; abstract;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual; abstract;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual; abstract;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual; abstract;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual; abstract;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual; abstract;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual; abstract;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual; abstract;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual; abstract;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual; abstract;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual; abstract;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual; abstract;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual; abstract;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual; abstract;
    function _get_discriminator_type: ITypeCode; virtual; abstract;
    procedure _set_discriminator_type_def(const val: IIDLType); virtual; abstract;
    function _get_discriminator_type_def: IIDLType; virtual; abstract;
    procedure _set_members(const val: TUnionMemberSeq); virtual; abstract;
    function _get_members: TUnionMemberSeq; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IUnionDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/UnionDef:1.0} 
  TUnionDef_stub = class(TUnionDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_discriminator_type: ITypeCode; override;
    procedure _set_discriminator_type_def(const val: IIDLType); override;
    function _get_discriminator_type_def: IIDLType; override;
    procedure _set_members(const val: TUnionMemberSeq); override;
    function _get_members: TUnionMemberSeq; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/UnionDef:1.0} 
  TUnionDef_stub_clp = class(TTypedefDef_stub_clp,IUnionDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual;
    function _get_discriminator_type: ITypeCode; virtual;
    procedure _set_discriminator_type_def(const val: IIDLType); virtual;
    function _get_discriminator_type_def: IIDLType; virtual;
    procedure _set_members(const val: TUnionMemberSeq); virtual;
    function _get_members: TUnionMemberSeq; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/UnionDef:1.0} 
  TUnionDef_serv = class(TTypedefDef_serv,IUnionDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual; abstract;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual; abstract;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual; abstract;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual; abstract;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual; abstract;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual; abstract;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual; abstract;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual; abstract;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual; abstract;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual; abstract;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual; abstract;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual; abstract;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual; abstract;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual; abstract;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual; abstract;
    function _get_discriminator_type: ITypeCode; virtual; abstract;
    procedure _set_discriminator_type_def(const val: IIDLType); virtual; abstract;
    function _get_discriminator_type_def: IIDLType; virtual; abstract;
    procedure _set_members(const val: TUnionMemberSeq); virtual; abstract;
    function _get_members: TUnionMemberSeq; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IUnionDef;
    class function _narrow(const srv : IServant): IUnionDef;
  end;

  TUnionDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/EnumDef:1.0 } 
  TEnumDef = class(TTypedefDef,IEnumDef)
  protected
    procedure _set_members(const val: TEnumMemberSeq); virtual; abstract;
    function _get_members: TEnumMemberSeq; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IEnumDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/EnumDef:1.0} 
  TEnumDef_stub = class(TEnumDef)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_members(const val: TEnumMemberSeq); override;
    function _get_members: TEnumMemberSeq; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/EnumDef:1.0} 
  TEnumDef_stub_clp = class(TTypedefDef_stub_clp,IEnumDef)
  protected
    procedure _set_members(const val: TEnumMemberSeq); virtual;
    function _get_members: TEnumMemberSeq; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/EnumDef:1.0} 
  TEnumDef_serv = class(TTypedefDef_serv,IEnumDef)
  protected
    procedure _set_members(const val: TEnumMemberSeq); virtual; abstract;
    function _get_members: TEnumMemberSeq; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IEnumDef;
    class function _narrow(const srv : IServant): IEnumDef;
  end;

  TEnumDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/AliasDef:1.0 } 
  TAliasDef = class(TTypedefDef,IAliasDef)
  protected
    procedure _set_original_type_def(const val: IIDLType); virtual; abstract;
    function _get_original_type_def: IIDLType; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IAliasDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/AliasDef:1.0} 
  TAliasDef_stub = class(TAliasDef)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_original_type_def(const val: IIDLType); override;
    function _get_original_type_def: IIDLType; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/AliasDef:1.0} 
  TAliasDef_stub_clp = class(TTypedefDef_stub_clp,IAliasDef)
  protected
    procedure _set_original_type_def(const val: IIDLType); virtual;
    function _get_original_type_def: IIDLType; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/AliasDef:1.0} 
  TAliasDef_serv = class(TTypedefDef_serv,IAliasDef)
  protected
    procedure _set_original_type_def(const val: IIDLType); virtual; abstract;
    function _get_original_type_def: IIDLType; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IAliasDef;
    class function _narrow(const srv : IServant): IAliasDef;
  end;

  TAliasDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/NativeDef:1.0 } 
  TNativeDef = class(TTypedefDef,INativeDef)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): INativeDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/NativeDef:1.0} 
  TNativeDef_stub = class(TNativeDef)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/NativeDef:1.0} 
  TNativeDef_stub_clp = class(TTypedefDef_stub_clp,INativeDef)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/NativeDef:1.0} 
  TNativeDef_serv = class(TTypedefDef_serv,INativeDef)
  protected
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): INativeDef;
    class function _narrow(const srv : IServant): INativeDef;
  end;

  TNativeDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/PrimitiveDef:1.0 } 
  TPrimitiveDef = class(TIDLType,IPrimitiveDef)
  protected
    function _get_kind: TPrimitiveKind; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IPrimitiveDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/PrimitiveDef:1.0} 
  TPrimitiveDef_stub = class(TPrimitiveDef)
  protected
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_kind: TPrimitiveKind; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/PrimitiveDef:1.0} 
  TPrimitiveDef_stub_clp = class(TIDLType_stub_clp,IPrimitiveDef)
  protected
    function _get_kind: TPrimitiveKind; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/PrimitiveDef:1.0} 
  TPrimitiveDef_serv = class(TIDLType_serv,IPrimitiveDef)
  protected
    function _get_kind: TPrimitiveKind; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IPrimitiveDef;
    class function _narrow(const srv : IServant): IPrimitiveDef;
  end;

  TPrimitiveDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/StringDef:1.0 } 
  TStringDef = class(TIDLType,IStringDef)
  protected
    procedure _set_bound(const val: _ulong); virtual; abstract;
    function _get_bound: _ulong; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IStringDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/StringDef:1.0} 
  TStringDef_stub = class(TStringDef)
  protected
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_bound(const val: _ulong); override;
    function _get_bound: _ulong; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/StringDef:1.0} 
  TStringDef_stub_clp = class(TIDLType_stub_clp,IStringDef)
  protected
    procedure _set_bound(const val: _ulong); virtual;
    function _get_bound: _ulong; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/StringDef:1.0} 
  TStringDef_serv = class(TIDLType_serv,IStringDef)
  protected
    procedure _set_bound(const val: _ulong); virtual; abstract;
    function _get_bound: _ulong; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IStringDef;
    class function _narrow(const srv : IServant): IStringDef;
  end;

  TStringDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/WstringDef:1.0 } 
  TWstringDef = class(TIDLType,IWstringDef)
  protected
    procedure _set_bound(const val: _ulong); virtual; abstract;
    function _get_bound: _ulong; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IWstringDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/WstringDef:1.0} 
  TWstringDef_stub = class(TWstringDef)
  protected
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_bound(const val: _ulong); override;
    function _get_bound: _ulong; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/WstringDef:1.0} 
  TWstringDef_stub_clp = class(TIDLType_stub_clp,IWstringDef)
  protected
    procedure _set_bound(const val: _ulong); virtual;
    function _get_bound: _ulong; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/WstringDef:1.0} 
  TWstringDef_serv = class(TIDLType_serv,IWstringDef)
  protected
    procedure _set_bound(const val: _ulong); virtual; abstract;
    function _get_bound: _ulong; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IWstringDef;
    class function _narrow(const srv : IServant): IWstringDef;
  end;

  TWstringDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/FixedDef:1.0 } 
  TFixedDef = class(TIDLType,IFixedDef)
  protected
    procedure _set_digits(const val: _ushort); virtual; abstract;
    function _get_digits: _ushort; virtual; abstract;
    procedure _set_scale(const val: Short); virtual; abstract;
    function _get_scale: Short; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IFixedDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/FixedDef:1.0} 
  TFixedDef_stub = class(TFixedDef)
  protected
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_digits(const val: _ushort); override;
    function _get_digits: _ushort; override;
    procedure _set_scale(const val: Short); override;
    function _get_scale: Short; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/FixedDef:1.0} 
  TFixedDef_stub_clp = class(TIDLType_stub_clp,IFixedDef)
  protected
    procedure _set_digits(const val: _ushort); virtual;
    function _get_digits: _ushort; virtual;
    procedure _set_scale(const val: Short); virtual;
    function _get_scale: Short; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/FixedDef:1.0} 
  TFixedDef_serv = class(TIDLType_serv,IFixedDef)
  protected
    procedure _set_digits(const val: _ushort); virtual; abstract;
    function _get_digits: _ushort; virtual; abstract;
    procedure _set_scale(const val: Short); virtual; abstract;
    function _get_scale: Short; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IFixedDef;
    class function _narrow(const srv : IServant): IFixedDef;
  end;

  TFixedDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/SequenceDef:1.0 } 
  TSequenceDef = class(TIDLType,ISequenceDef)
  protected
    procedure _set_bound(const val: _ulong); virtual; abstract;
    function _get_bound: _ulong; virtual; abstract;
    function _get_element_type: ITypeCode; virtual; abstract;
    procedure _set_element_type_def(const val: IIDLType); virtual; abstract;
    function _get_element_type_def: IIDLType; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ISequenceDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/SequenceDef:1.0} 
  TSequenceDef_stub = class(TSequenceDef)
  protected
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_bound(const val: _ulong); override;
    function _get_bound: _ulong; override;
    function _get_element_type: ITypeCode; override;
    procedure _set_element_type_def(const val: IIDLType); override;
    function _get_element_type_def: IIDLType; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/SequenceDef:1.0} 
  TSequenceDef_stub_clp = class(TIDLType_stub_clp,ISequenceDef)
  protected
    procedure _set_bound(const val: _ulong); virtual;
    function _get_bound: _ulong; virtual;
    function _get_element_type: ITypeCode; virtual;
    procedure _set_element_type_def(const val: IIDLType); virtual;
    function _get_element_type_def: IIDLType; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/SequenceDef:1.0} 
  TSequenceDef_serv = class(TIDLType_serv,ISequenceDef)
  protected
    procedure _set_bound(const val: _ulong); virtual; abstract;
    function _get_bound: _ulong; virtual; abstract;
    function _get_element_type: ITypeCode; virtual; abstract;
    procedure _set_element_type_def(const val: IIDLType); virtual; abstract;
    function _get_element_type_def: IIDLType; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ISequenceDef;
    class function _narrow(const srv : IServant): ISequenceDef;
  end;

  TSequenceDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/ArrayDef:1.0 } 
  TArrayDef = class(TIDLType,IArrayDef)
  protected
    procedure _set_length(const val: _ulong); virtual; abstract;
    function _get_length: _ulong; virtual; abstract;
    function _get_element_type: ITypeCode; virtual; abstract;
    procedure _set_element_type_def(const val: IIDLType); virtual; abstract;
    function _get_element_type_def: IIDLType; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IArrayDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/ArrayDef:1.0} 
  TArrayDef_stub = class(TArrayDef)
  protected
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_length(const val: _ulong); override;
    function _get_length: _ulong; override;
    function _get_element_type: ITypeCode; override;
    procedure _set_element_type_def(const val: IIDLType); override;
    function _get_element_type_def: IIDLType; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/ArrayDef:1.0} 
  TArrayDef_stub_clp = class(TIDLType_stub_clp,IArrayDef)
  protected
    procedure _set_length(const val: _ulong); virtual;
    function _get_length: _ulong; virtual;
    function _get_element_type: ITypeCode; virtual;
    procedure _set_element_type_def(const val: IIDLType); virtual;
    function _get_element_type_def: IIDLType; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/ArrayDef:1.0} 
  TArrayDef_serv = class(TIDLType_serv,IArrayDef)
  protected
    procedure _set_length(const val: _ulong); virtual; abstract;
    function _get_length: _ulong; virtual; abstract;
    function _get_element_type: ITypeCode; virtual; abstract;
    procedure _set_element_type_def(const val: IIDLType); virtual; abstract;
    function _get_element_type_def: IIDLType; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IArrayDef;
    class function _narrow(const srv : IServant): IArrayDef;
  end;

  TArrayDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/ExceptionDef:1.0 } 
  TExceptionDef = class(TContained,IExceptionDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual; abstract;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual; abstract;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual; abstract;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual; abstract;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual; abstract;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual; abstract;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual; abstract;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual; abstract;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual; abstract;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual; abstract;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual; abstract;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual; abstract;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual; abstract;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual; abstract;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual; abstract;
    function _get_type: ITypeCode; virtual; abstract;
    procedure _set_members(const val: TStructMemberSeq); virtual; abstract;
    function _get_members: TStructMemberSeq; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IExceptionDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/ExceptionDef:1.0} 
  TExceptionDef_stub = class(TExceptionDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _set_members(const val: TStructMemberSeq); override;
    function _get_members: TStructMemberSeq; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/ExceptionDef:1.0} 
  TExceptionDef_stub_clp = class(TContained_stub_clp,IExceptionDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual;
    function _get_type: ITypeCode; virtual;
    procedure _set_members(const val: TStructMemberSeq); virtual;
    function _get_members: TStructMemberSeq; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/ExceptionDef:1.0} 
  TExceptionDef_serv = class(TContained_serv,IExceptionDef,IContainer)
  protected
    function lookup(const search_name: TScopedName): IContained; virtual; abstract;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; virtual; abstract;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; virtual; abstract;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; virtual; abstract;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; virtual; abstract;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; virtual; abstract;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; virtual; abstract;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; virtual; abstract;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; virtual; abstract;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; virtual; abstract;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; virtual; abstract;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; virtual; abstract;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; virtual; abstract;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; virtual; abstract;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; virtual; abstract;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; virtual; abstract;
    function _get_type: ITypeCode; virtual; abstract;
    procedure _set_members(const val: TStructMemberSeq); virtual; abstract;
    function _get_members: TStructMemberSeq; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IExceptionDef;
    class function _narrow(const srv : IServant): IExceptionDef;
  end;

  TExceptionDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TExceptionDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  ExceptionDef_seq = Array of IExceptionDef;
  PExceptionDef_seq = ^ExceptionDef_seq;

  TExceptionDef_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  ExceptionDescription_seq = Array of TExceptionDescription;
  PExceptionDescription_seq = ^ExceptionDescription_seq;

  TExceptionDescription_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TAttributeMode_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/AttributeDef:1.0 } 
  TAttributeDef = class(TContained,IAttributeDef)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    procedure _set_type_def(const val: IIDLType); virtual; abstract;
    function _get_type_def: IIDLType; virtual; abstract;
    procedure _set_mode(const val: TAttributeMode); virtual; abstract;
    function _get_mode: TAttributeMode; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IAttributeDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/AttributeDef:1.0} 
  TAttributeDef_stub = class(TAttributeDef)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _set_type_def(const val: IIDLType); override;
    function _get_type_def: IIDLType; override;
    procedure _set_mode(const val: TAttributeMode); override;
    function _get_mode: TAttributeMode; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/AttributeDef:1.0} 
  TAttributeDef_stub_clp = class(TContained_stub_clp,IAttributeDef)
  protected
    function _get_type: ITypeCode; virtual;
    procedure _set_type_def(const val: IIDLType); virtual;
    function _get_type_def: IIDLType; virtual;
    procedure _set_mode(const val: TAttributeMode); virtual;
    function _get_mode: TAttributeMode; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/AttributeDef:1.0} 
  TAttributeDef_serv = class(TContained_serv,IAttributeDef)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    procedure _set_type_def(const val: IIDLType); virtual; abstract;
    function _get_type_def: IIDLType; virtual; abstract;
    procedure _set_mode(const val: TAttributeMode); virtual; abstract;
    function _get_mode: TAttributeMode; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IAttributeDef;
    class function _narrow(const srv : IServant): IAttributeDef;
  end;

  TAttributeDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TAttributeDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TOperationMode_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TParameterMode_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TParameterDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  ParameterDescription_seq = Array of TParameterDescription;
  PParameterDescription_seq = ^ParameterDescription_seq;

  TParameterDescription_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/OperationDef:1.0 } 
  TOperationDef = class(TContained,IOperationDef)
  protected
    function _get_result: ITypeCode; virtual; abstract;
    procedure _set_result_def(const val: IIDLType); virtual; abstract;
    function _get_result_def: IIDLType; virtual; abstract;
    procedure _set_params(const val: TParDescriptionSeq); virtual; abstract;
    function _get_params: TParDescriptionSeq; virtual; abstract;
    procedure _set_mode(const val: TOperationMode); virtual; abstract;
    function _get_mode: TOperationMode; virtual; abstract;
    procedure _set_contexts(const val: TContextIdSeq); virtual; abstract;
    function _get_contexts: TContextIdSeq; virtual; abstract;
    procedure _set_exceptions(const val: TExceptionDefSeq); virtual; abstract;
    function _get_exceptions: TExceptionDefSeq; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IOperationDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/OperationDef:1.0} 
  TOperationDef_stub = class(TOperationDef)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_result: ITypeCode; override;
    procedure _set_result_def(const val: IIDLType); override;
    function _get_result_def: IIDLType; override;
    procedure _set_params(const val: TParDescriptionSeq); override;
    function _get_params: TParDescriptionSeq; override;
    procedure _set_mode(const val: TOperationMode); override;
    function _get_mode: TOperationMode; override;
    procedure _set_contexts(const val: TContextIdSeq); override;
    function _get_contexts: TContextIdSeq; override;
    procedure _set_exceptions(const val: TExceptionDefSeq); override;
    function _get_exceptions: TExceptionDefSeq; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/OperationDef:1.0} 
  TOperationDef_stub_clp = class(TContained_stub_clp,IOperationDef)
  protected
    function _get_result: ITypeCode; virtual;
    procedure _set_result_def(const val: IIDLType); virtual;
    function _get_result_def: IIDLType; virtual;
    procedure _set_params(const val: TParDescriptionSeq); virtual;
    function _get_params: TParDescriptionSeq; virtual;
    procedure _set_mode(const val: TOperationMode); virtual;
    function _get_mode: TOperationMode; virtual;
    procedure _set_contexts(const val: TContextIdSeq); virtual;
    function _get_contexts: TContextIdSeq; virtual;
    procedure _set_exceptions(const val: TExceptionDefSeq); virtual;
    function _get_exceptions: TExceptionDefSeq; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/OperationDef:1.0} 
  TOperationDef_serv = class(TContained_serv,IOperationDef)
  protected
    function _get_result: ITypeCode; virtual; abstract;
    procedure _set_result_def(const val: IIDLType); virtual; abstract;
    function _get_result_def: IIDLType; virtual; abstract;
    procedure _set_params(const val: TParDescriptionSeq); virtual; abstract;
    function _get_params: TParDescriptionSeq; virtual; abstract;
    procedure _set_mode(const val: TOperationMode); virtual; abstract;
    function _get_mode: TOperationMode; virtual; abstract;
    procedure _set_contexts(const val: TContextIdSeq); virtual; abstract;
    function _get_contexts: TContextIdSeq; virtual; abstract;
    procedure _set_exceptions(const val: TExceptionDefSeq); virtual; abstract;
    function _get_exceptions: TExceptionDefSeq; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IOperationDef;
    class function _narrow(const srv : IServant): IOperationDef;
  end;

  TOperationDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TOperationDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  OperationDescription_seq = Array of TOperationDescription;
  POperationDescription_seq = ^OperationDescription_seq;

  TOperationDescription_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  AttributeDescription_seq = Array of TAttributeDescription;
  PAttributeDescription_seq = ^AttributeDescription_seq;

  TAttributeDescription_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TFullInterfaceDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/InterfaceDef:1.0 } 
  TInterfaceDef = class(TContainer,IInterfaceDef,IContained,IIDLType)
  protected
    function describe: TDescription; virtual; abstract;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual; abstract;
    procedure _set_id(const val: TRepositoryId); virtual; abstract;
    function _get_id: TRepositoryId; virtual; abstract;
    procedure _set_name(const val: TIdentifier); virtual; abstract;
    function _get_name: TIdentifier; virtual; abstract;
    procedure _set_version(const val: TVersionSpec); virtual; abstract;
    function _get_version: TVersionSpec; virtual; abstract;
    function _get_defined_in: IContainer; virtual; abstract;
    function _get_absolute_name: TScopedName; virtual; abstract;
    function _get_containing_repository: IRepository; virtual; abstract;
    function _get_type: ITypeCode; virtual; abstract;
    function is_a(const interface_id: TRepositoryId): Boolean; virtual; abstract;
    function describe_interface: TFullInterfaceDescription; virtual; abstract;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; virtual; abstract;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; virtual; abstract;
    procedure _set_base_interfaces(const val: TInterfaceDefSeq); virtual; abstract;
    function _get_base_interfaces: TInterfaceDefSeq; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IInterfaceDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/InterfaceDef:1.0} 
  TInterfaceDef_stub = class(TInterfaceDef,IContained,IIDLType)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    function _get_type: ITypeCode; override;
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function is_a(const interface_id: TRepositoryId): Boolean; override;
    function describe_interface: TFullInterfaceDescription; override;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; override;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; override;
    procedure _set_base_interfaces(const val: TInterfaceDefSeq); override;
    function _get_base_interfaces: TInterfaceDefSeq; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/InterfaceDef:1.0} 
  TInterfaceDef_stub_clp = class(TContainer_stub_clp,IInterfaceDef,IContained,IIDLType)
  protected
    function describe: TDescription; virtual;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual;
    procedure _set_id(const val: TRepositoryId); virtual;
    function _get_id: TRepositoryId; virtual;
    procedure _set_name(const val: TIdentifier); virtual;
    function _get_name: TIdentifier; virtual;
    procedure _set_version(const val: TVersionSpec); virtual;
    function _get_version: TVersionSpec; virtual;
    function _get_defined_in: IContainer; virtual;
    function _get_absolute_name: TScopedName; virtual;
    function _get_containing_repository: IRepository; virtual;
    function _get_type: ITypeCode; virtual;
    function is_a(const interface_id: TRepositoryId): Boolean; virtual;
    function describe_interface: TFullInterfaceDescription; virtual;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; virtual;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; virtual;
    procedure _set_base_interfaces(const val: TInterfaceDefSeq); virtual;
    function _get_base_interfaces: TInterfaceDefSeq; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/InterfaceDef:1.0} 
  TInterfaceDef_serv = class(TContainer_serv,IInterfaceDef,IContained,IIDLType)
  protected
    function describe: TDescription; virtual; abstract;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual; abstract;
    procedure _set_id(const val: TRepositoryId); virtual; abstract;
    function _get_id: TRepositoryId; virtual; abstract;
    procedure _set_name(const val: TIdentifier); virtual; abstract;
    function _get_name: TIdentifier; virtual; abstract;
    procedure _set_version(const val: TVersionSpec); virtual; abstract;
    function _get_version: TVersionSpec; virtual; abstract;
    function _get_defined_in: IContainer; virtual; abstract;
    function _get_absolute_name: TScopedName; virtual; abstract;
    function _get_containing_repository: IRepository; virtual; abstract;
    function _get_type: ITypeCode; virtual; abstract;
    function is_a(const interface_id: TRepositoryId): Boolean; virtual; abstract;
    function describe_interface: TFullInterfaceDescription; virtual; abstract;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; virtual; abstract;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; virtual; abstract;
    procedure _set_base_interfaces(const val: TInterfaceDefSeq); virtual; abstract;
    function _get_base_interfaces: TInterfaceDefSeq; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IInterfaceDef;
    class function _narrow(const srv : IServant): IInterfaceDef;
  end;

  TInterfaceDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TInterfaceDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/AbstractInterfaceDef:1.0 } 
  TAbstractInterfaceDef = class(TInterfaceDef,IAbstractInterfaceDef)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IAbstractInterfaceDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/AbstractInterfaceDef:1.0} 
  TAbstractInterfaceDef_stub = class(TAbstractInterfaceDef)
  protected
    function is_a(const interface_id: TRepositoryId): Boolean; override;
    function describe_interface: TFullInterfaceDescription; override;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; override;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; override;
    procedure _set_base_interfaces(const val: TInterfaceDefSeq); override;
    function _get_base_interfaces: TInterfaceDefSeq; override;
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/AbstractInterfaceDef:1.0} 
  TAbstractInterfaceDef_stub_clp = class(TInterfaceDef_stub_clp,IAbstractInterfaceDef)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/AbstractInterfaceDef:1.0} 
  TAbstractInterfaceDef_serv = class(TInterfaceDef_serv,IAbstractInterfaceDef)
  protected
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IAbstractInterfaceDef;
    class function _narrow(const srv : IServant): IAbstractInterfaceDef;
  end;

  TAbstractInterfaceDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/LocalInterfaceDef:1.0 } 
  TLocalInterfaceDef = class(TInterfaceDef,ILocalInterfaceDef)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): ILocalInterfaceDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/LocalInterfaceDef:1.0} 
  TLocalInterfaceDef_stub = class(TLocalInterfaceDef)
  protected
    function is_a(const interface_id: TRepositoryId): Boolean; override;
    function describe_interface: TFullInterfaceDescription; override;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; override;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; override;
    procedure _set_base_interfaces(const val: TInterfaceDefSeq); override;
    function _get_base_interfaces: TInterfaceDefSeq; override;
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/LocalInterfaceDef:1.0} 
  TLocalInterfaceDef_stub_clp = class(TInterfaceDef_stub_clp,ILocalInterfaceDef)
  protected
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/LocalInterfaceDef:1.0} 
  TLocalInterfaceDef_serv = class(TInterfaceDef_serv,ILocalInterfaceDef)
  protected
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): ILocalInterfaceDef;
    class function _narrow(const srv : IServant): ILocalInterfaceDef;
  end;

  TLocalInterfaceDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/ValueMemberDef:1.0 } 
  TValueMemberDef = class(TContained,IValueMemberDef)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    procedure _set_type_def(const val: IIDLType); virtual; abstract;
    function _get_type_def: IIDLType; virtual; abstract;
    procedure _set_access(const val: TVisibility); virtual; abstract;
    function _get_access: TVisibility; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IValueMemberDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/ValueMemberDef:1.0} 
  TValueMemberDef_stub = class(TValueMemberDef)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _set_type_def(const val: IIDLType); override;
    function _get_type_def: IIDLType; override;
    procedure _set_access(const val: TVisibility); override;
    function _get_access: TVisibility; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/ValueMemberDef:1.0} 
  TValueMemberDef_stub_clp = class(TContained_stub_clp,IValueMemberDef)
  protected
    function _get_type: ITypeCode; virtual;
    procedure _set_type_def(const val: IIDLType); virtual;
    function _get_type_def: IIDLType; virtual;
    procedure _set_access(const val: TVisibility); virtual;
    function _get_access: TVisibility; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/ValueMemberDef:1.0} 
  TValueMemberDef_serv = class(TContained_serv,IValueMemberDef)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    procedure _set_type_def(const val: IIDLType); virtual; abstract;
    function _get_type_def: IIDLType; virtual; abstract;
    procedure _set_access(const val: TVisibility); virtual; abstract;
    function _get_access: TVisibility; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IValueMemberDef;
    class function _narrow(const srv : IServant): IValueMemberDef;
  end;

  TValueMemberDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TFullValueDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/ValueDef:1.0 } 
  TValueDef = class(TContainer,IValueDef,IContained,IIDLType)
  protected
    function describe: TDescription; virtual; abstract;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual; abstract;
    procedure _set_id(const val: TRepositoryId); virtual; abstract;
    function _get_id: TRepositoryId; virtual; abstract;
    procedure _set_name(const val: TIdentifier); virtual; abstract;
    function _get_name: TIdentifier; virtual; abstract;
    procedure _set_version(const val: TVersionSpec); virtual; abstract;
    function _get_version: TVersionSpec; virtual; abstract;
    function _get_defined_in: IContainer; virtual; abstract;
    function _get_absolute_name: TScopedName; virtual; abstract;
    function _get_containing_repository: IRepository; virtual; abstract;
    function _get_type: ITypeCode; virtual; abstract;
    function is_a(const value_id: TRepositoryId): Boolean; virtual; abstract;
    function describe_value: TFullValueDescription; virtual; abstract;
    function create_value_member(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const access: TVisibility): IValueMemberDef; virtual; abstract;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; virtual; abstract;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; virtual; abstract;
    procedure _set_supported_interfaces(const val: TInterfaceDefSeq); virtual; abstract;
    function _get_supported_interfaces: TInterfaceDefSeq; virtual; abstract;
    procedure _set_initializers(const val: TInitializerSeq); virtual; abstract;
    function _get_initializers: TInitializerSeq; virtual; abstract;
    procedure _set_base_value(const val: IValueDef); virtual; abstract;
    function _get_base_value: IValueDef; virtual; abstract;
    procedure _set_abstract_base_values(const val: TValueDefSeq); virtual; abstract;
    function _get_abstract_base_values: TValueDefSeq; virtual; abstract;
    procedure _set_is_abstract(const val: Boolean); virtual; abstract;
    function _get_is_abstract: Boolean; virtual; abstract;
    procedure _set_is_custom(const val: Boolean); virtual; abstract;
    function _get_is_custom: Boolean; virtual; abstract;
    procedure _set_is_truncatable(const val: Boolean); virtual; abstract;
    function _get_is_truncatable: Boolean; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IValueDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/ValueDef:1.0} 
  TValueDef_stub = class(TValueDef,IContained,IIDLType)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    function _get_type: ITypeCode; override;
    function lookup(const search_name: TScopedName): IContained; override;
    function contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq; override;
    function describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq; override;
    function create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef; override;
    function create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef; override;
    function create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef; override;
    function create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef; override;
    function create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef; override;
    function create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef; override;
    function create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef; override;
    function create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef; override;
    function create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef; override;
    function create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef; override;
    function create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef; override;
    function create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef; override;
    function create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function is_a(const value_id: TRepositoryId): Boolean; override;
    function describe_value: TFullValueDescription; override;
    function create_value_member(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const access: TVisibility): IValueMemberDef; override;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; override;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; override;
    procedure _set_supported_interfaces(const val: TInterfaceDefSeq); override;
    function _get_supported_interfaces: TInterfaceDefSeq; override;
    procedure _set_initializers(const val: TInitializerSeq); override;
    function _get_initializers: TInitializerSeq; override;
    procedure _set_base_value(const val: IValueDef); override;
    function _get_base_value: IValueDef; override;
    procedure _set_abstract_base_values(const val: TValueDefSeq); override;
    function _get_abstract_base_values: TValueDefSeq; override;
    procedure _set_is_abstract(const val: Boolean); override;
    function _get_is_abstract: Boolean; override;
    procedure _set_is_custom(const val: Boolean); override;
    function _get_is_custom: Boolean; override;
    procedure _set_is_truncatable(const val: Boolean); override;
    function _get_is_truncatable: Boolean; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/ValueDef:1.0} 
  TValueDef_stub_clp = class(TContainer_stub_clp,IValueDef,IContained,IIDLType)
  protected
    function describe: TDescription; virtual;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual;
    procedure _set_id(const val: TRepositoryId); virtual;
    function _get_id: TRepositoryId; virtual;
    procedure _set_name(const val: TIdentifier); virtual;
    function _get_name: TIdentifier; virtual;
    procedure _set_version(const val: TVersionSpec); virtual;
    function _get_version: TVersionSpec; virtual;
    function _get_defined_in: IContainer; virtual;
    function _get_absolute_name: TScopedName; virtual;
    function _get_containing_repository: IRepository; virtual;
    function _get_type: ITypeCode; virtual;
    function is_a(const value_id: TRepositoryId): Boolean; virtual;
    function describe_value: TFullValueDescription; virtual;
    function create_value_member(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const access: TVisibility): IValueMemberDef; virtual;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; virtual;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; virtual;
    procedure _set_supported_interfaces(const val: TInterfaceDefSeq); virtual;
    function _get_supported_interfaces: TInterfaceDefSeq; virtual;
    procedure _set_initializers(const val: TInitializerSeq); virtual;
    function _get_initializers: TInitializerSeq; virtual;
    procedure _set_base_value(const val: IValueDef); virtual;
    function _get_base_value: IValueDef; virtual;
    procedure _set_abstract_base_values(const val: TValueDefSeq); virtual;
    function _get_abstract_base_values: TValueDefSeq; virtual;
    procedure _set_is_abstract(const val: Boolean); virtual;
    function _get_is_abstract: Boolean; virtual;
    procedure _set_is_custom(const val: Boolean); virtual;
    function _get_is_custom: Boolean; virtual;
    procedure _set_is_truncatable(const val: Boolean); virtual;
    function _get_is_truncatable: Boolean; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/ValueDef:1.0} 
  TValueDef_serv = class(TContainer_serv,IValueDef,IContained,IIDLType)
  protected
    function describe: TDescription; virtual; abstract;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); virtual; abstract;
    procedure _set_id(const val: TRepositoryId); virtual; abstract;
    function _get_id: TRepositoryId; virtual; abstract;
    procedure _set_name(const val: TIdentifier); virtual; abstract;
    function _get_name: TIdentifier; virtual; abstract;
    procedure _set_version(const val: TVersionSpec); virtual; abstract;
    function _get_version: TVersionSpec; virtual; abstract;
    function _get_defined_in: IContainer; virtual; abstract;
    function _get_absolute_name: TScopedName; virtual; abstract;
    function _get_containing_repository: IRepository; virtual; abstract;
    function _get_type: ITypeCode; virtual; abstract;
    function is_a(const value_id: TRepositoryId): Boolean; virtual; abstract;
    function describe_value: TFullValueDescription; virtual; abstract;
    function create_value_member(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const access: TVisibility): IValueMemberDef; virtual; abstract;
    function create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef; virtual; abstract;
    function create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef; virtual; abstract;
    procedure _set_supported_interfaces(const val: TInterfaceDefSeq); virtual; abstract;
    function _get_supported_interfaces: TInterfaceDefSeq; virtual; abstract;
    procedure _set_initializers(const val: TInitializerSeq); virtual; abstract;
    function _get_initializers: TInitializerSeq; virtual; abstract;
    procedure _set_base_value(const val: IValueDef); virtual; abstract;
    function _get_base_value: IValueDef; virtual; abstract;
    procedure _set_abstract_base_values(const val: TValueDefSeq); virtual; abstract;
    function _get_abstract_base_values: TValueDefSeq; virtual; abstract;
    procedure _set_is_abstract(const val: Boolean); virtual; abstract;
    function _get_is_abstract: Boolean; virtual; abstract;
    procedure _set_is_custom(const val: Boolean); virtual; abstract;
    function _get_is_custom: Boolean; virtual; abstract;
    procedure _set_is_truncatable(const val: Boolean); virtual; abstract;
    function _get_is_truncatable: Boolean; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IValueDef;
    class function _narrow(const srv : IServant): IValueDef;
  end;

  TValueDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TValueDescription_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/ValueBoxDef:1.0 } 
  TValueBoxDef = class(TTypedefDef,IValueBoxDef)
  protected
    procedure _set_original_type_def(const val: IIDLType); virtual; abstract;
    function _get_original_type_def: IIDLType; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IValueBoxDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/ValueBoxDef:1.0} 
  TValueBoxDef_stub = class(TValueBoxDef)
  protected
    function describe: TDescription; override;
    procedure move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec); override;
    procedure _set_id(const val: TRepositoryId); override;
    function _get_id: TRepositoryId; override;
    procedure _set_name(const val: TIdentifier); override;
    function _get_name: TIdentifier; override;
    procedure _set_version(const val: TVersionSpec); override;
    function _get_version: TVersionSpec; override;
    function _get_defined_in: IContainer; override;
    function _get_absolute_name: TScopedName; override;
    function _get_containing_repository: IRepository; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    procedure _set_original_type_def(const val: IIDLType); override;
    function _get_original_type_def: IIDLType; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/ValueBoxDef:1.0} 
  TValueBoxDef_stub_clp = class(TTypedefDef_stub_clp,IValueBoxDef)
  protected
    procedure _set_original_type_def(const val: IIDLType); virtual;
    function _get_original_type_def: IIDLType; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/ValueBoxDef:1.0} 
  TValueBoxDef_serv = class(TTypedefDef_serv,IValueBoxDef)
  protected
    procedure _set_original_type_def(const val: IIDLType); virtual; abstract;
    function _get_original_type_def: IIDLType; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IValueBoxDef;
    class function _narrow(const srv : IServant): IValueBoxDef;
  end;

  TValueBoxDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  Description_marshaller : IStaticTypeInfo;
  Contained_marshaller : IStaticTypeInfo;
  Contained_seq_marshaller : IStaticTypeInfo;
  InterfaceDef_seq_marshaller : IStaticTypeInfo;
  AbstractInterfaceDef_seq_marshaller : IStaticTypeInfo;
  LocalInterfaceDef_seq_marshaller : IStaticTypeInfo;
  ValueDef_seq_marshaller : IStaticTypeInfo;
  Initializer_marshaller : IStaticTypeInfo;
  Initializer_seq_marshaller : IStaticTypeInfo;
  Description_seq_marshaller : IStaticTypeInfo;
  Container_marshaller : IStaticTypeInfo;
  PrimitiveKind_marshaller : IStaticTypeInfo;
  Repository_marshaller : IStaticTypeInfo;
  ModuleDef_marshaller : IStaticTypeInfo;
  ModuleDescription_marshaller : IStaticTypeInfo;
  ConstantDef_marshaller : IStaticTypeInfo;
  ConstantDescription_marshaller : IStaticTypeInfo;
  TypedefDef_marshaller : IStaticTypeInfo;
  TypeDescription_marshaller : IStaticTypeInfo;
  StructDef_marshaller : IStaticTypeInfo;
  UnionDef_marshaller : IStaticTypeInfo;
  EnumDef_marshaller : IStaticTypeInfo;
  AliasDef_marshaller : IStaticTypeInfo;
  NativeDef_marshaller : IStaticTypeInfo;
  PrimitiveDef_marshaller : IStaticTypeInfo;
  StringDef_marshaller : IStaticTypeInfo;
  WstringDef_marshaller : IStaticTypeInfo;
  FixedDef_marshaller : IStaticTypeInfo;
  SequenceDef_marshaller : IStaticTypeInfo;
  ArrayDef_marshaller : IStaticTypeInfo;
  ExceptionDef_marshaller : IStaticTypeInfo;
  ExceptionDescription_marshaller : IStaticTypeInfo;
  ExceptionDef_seq_marshaller : IStaticTypeInfo;
  ExceptionDescription_seq_marshaller : IStaticTypeInfo;
  AttributeMode_marshaller : IStaticTypeInfo;
  AttributeDef_marshaller : IStaticTypeInfo;
  AttributeDescription_marshaller : IStaticTypeInfo;
  OperationMode_marshaller : IStaticTypeInfo;
  ParameterMode_marshaller : IStaticTypeInfo;
  ParameterDescription_marshaller : IStaticTypeInfo;
  ParameterDescription_seq_marshaller : IStaticTypeInfo;
  OperationDef_marshaller : IStaticTypeInfo;
  OperationDescription_marshaller : IStaticTypeInfo;
  OperationDescription_seq_marshaller : IStaticTypeInfo;
  AttributeDescription_seq_marshaller : IStaticTypeInfo;
  FullInterfaceDescription_marshaller : IStaticTypeInfo;
  InterfaceDef_marshaller : IStaticTypeInfo;
  InterfaceDescription_marshaller : IStaticTypeInfo;
  AbstractInterfaceDef_marshaller : IStaticTypeInfo;
  LocalInterfaceDef_marshaller : IStaticTypeInfo;
  ValueMemberDef_marshaller : IStaticTypeInfo;
  FullValueDescription_marshaller : IStaticTypeInfo;
  ValueDef_marshaller : IStaticTypeInfo;
  ValueDescription_marshaller : IStaticTypeInfo;
  ValueBoxDef_marshaller : IStaticTypeInfo;
  _tc_Description : ITypeCodeConst;
  _tc_Contained : ITypeCodeConst;
  _tc_Contained_seq : ITypeCodeConst;
  _tc_InterfaceDef_seq : ITypeCodeConst;
  _tc_AbstractInterfaceDef_seq : ITypeCodeConst;
  _tc_LocalInterfaceDef_seq : ITypeCodeConst;
  _tc_ValueDef_seq : ITypeCodeConst;
  _tc_Initializer : ITypeCodeConst;
  _tc_Initializer_seq : ITypeCodeConst;
  _tc_Description_seq : ITypeCodeConst;
  _tc_Container : ITypeCodeConst;
  _tc_PrimitiveKind : ITypeCodeConst;
  _tc_Repository : ITypeCodeConst;
  _tc_ModuleDef : ITypeCodeConst;
  _tc_ModuleDescription : ITypeCodeConst;
  _tc_ConstantDef : ITypeCodeConst;
  _tc_ConstantDescription : ITypeCodeConst;
  _tc_TypedefDef : ITypeCodeConst;
  _tc_TypeDescription : ITypeCodeConst;
  _tc_StructDef : ITypeCodeConst;
  _tc_UnionDef : ITypeCodeConst;
  _tc_EnumDef : ITypeCodeConst;
  _tc_AliasDef : ITypeCodeConst;
  _tc_NativeDef : ITypeCodeConst;
  _tc_PrimitiveDef : ITypeCodeConst;
  _tc_StringDef : ITypeCodeConst;
  _tc_WstringDef : ITypeCodeConst;
  _tc_FixedDef : ITypeCodeConst;
  _tc_SequenceDef : ITypeCodeConst;
  _tc_ArrayDef : ITypeCodeConst;
  _tc_ExceptionDef : ITypeCodeConst;
  _tc_ExceptionDescription : ITypeCodeConst;
  _tc_ExceptionDef_seq : ITypeCodeConst;
  _tc_ExceptionDescription_seq : ITypeCodeConst;
  _tc_AttributeMode : ITypeCodeConst;
  _tc_AttributeDef : ITypeCodeConst;
  _tc_AttributeDescription : ITypeCodeConst;
  _tc_OperationMode : ITypeCodeConst;
  _tc_ParameterMode : ITypeCodeConst;
  _tc_ParameterDescription : ITypeCodeConst;
  _tc_ParameterDescription_seq : ITypeCodeConst;
  _tc_OperationDef : ITypeCodeConst;
  _tc_OperationDescription : ITypeCodeConst;
  _tc_OperationDescription_seq : ITypeCodeConst;
  _tc_AttributeDescription_seq : ITypeCodeConst;
  _tc_FullInterfaceDescription : ITypeCodeConst;
  _tc_InterfaceDef : ITypeCodeConst;
  _tc_InterfaceDescription : ITypeCodeConst;
  _tc_AbstractInterfaceDef : ITypeCodeConst;
  _tc_LocalInterfaceDef : ITypeCodeConst;
  _tc_ValueMemberDef : ITypeCodeConst;
  _tc_FullValueDescription : ITypeCodeConst;
  _tc_ValueDef : ITypeCodeConst;
  _tc_ValueDescription : ITypeCodeConst;
  _tc_ValueBoxDef : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TDescription_marshaller
//***********************************************************
function TDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TDescription;
begin
  result := false;
  if not DefinitionKind_marshaller.demarshal(dec,@struct.kind) then exit;
  if not stat_any.demarshal(dec,@struct.value) then exit;
  ir_int.TDescription(addr^) := struct;
  result := true;
end;

procedure TDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TDescription;
begin
  struct := ir_int.TDescription(addr^);
  DefinitionKind_marshaller.marshal(enc,@struct.kind);
  stat_any.marshal(enc,@struct.value);
end;

procedure TDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TDescription(addr^));
{$HINTS ON}
end;

procedure TDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TDescription(dst^) := ir_int.TDescription(src^);
end;

function TDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_Description.typecode;
end;

//***********************************************************
// TContained
//***********************************************************
function TContained.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TContained._narrow(const obj : IORBObject): IContained;
var
  p: Pointer;
  stub: TContained_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/Contained:1.0');
  if p <> nil then
    result := IContained(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/Contained:1.0') then
        begin
          stub := TContained_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TContained.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/Contained:1.0'
end;

//***********************************************************
// TContained_stub
//***********************************************************
procedure TContained_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TContained_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContained_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TContained_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TContained_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TContained_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TContained_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TContained_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TContained_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TContained_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContained_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContained_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContained_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TContained_stub_clp
//***********************************************************
function TContained_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TContained_stub_clp.describe: TDescription;
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe
    end;
  _postinvoke();
end;

procedure TContained_stub_clp.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv.move(new_container, new_name, new_version)
    end;
  _postinvoke();
end;

procedure TContained_stub_clp._set_id(const val: TRepositoryId);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_id(val);
    end;
  _postinvoke();
end;

function TContained_stub_clp._get_id: TRepositoryId;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_id
    end;
  _postinvoke();
end;

procedure TContained_stub_clp._set_name(const val: TIdentifier);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_name(val);
    end;
  _postinvoke();
end;

function TContained_stub_clp._get_name: TIdentifier;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_name
    end;
  _postinvoke();
end;

procedure TContained_stub_clp._set_version(const val: TVersionSpec);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_version(val);
    end;
  _postinvoke();
end;

function TContained_stub_clp._get_version: TVersionSpec;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_version
    end;
  _postinvoke();
end;

function TContained_stub_clp._get_defined_in: IContainer;
var
  _srv: IServant;
  srv: IContained;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_defined_in
    end;
  _postinvoke();
end;

function TContained_stub_clp._get_absolute_name: TScopedName;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_absolute_name
    end;
  _postinvoke();
end;

function TContained_stub_clp._get_containing_repository: IRepository;
var
  _srv: IServant;
  srv: IContained;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_containing_repository
    end;
  _postinvoke();
end;

//***********************************************************
// TContained_serv
//***********************************************************
function TContained_serv._this(): IContained;
var
  obj: IORBObject;
begin
  obj := this();
  result := TContained._narrow(obj);
end;

function TContained_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/Contained:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TContained_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/Contained:1.0';
end;

function TContained_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TContained_stub_clp.Create(poa,obj);
end;

procedure TContained_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TContained_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(IContained(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TContained_serv._narrow(const srv : IServant): IContained;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/Contained:1.0');
  if p <> nil then
    result := IContained(p)
end;

function TContained_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  describe_result: TDescription;
  move_new_container: IContainer;
  move_new_name: TIdentifier;
  move_new_version: TVersionSpec;
  id_get_value: TRepositoryId;
  id_set_value: TRepositoryId;
  name_get_value: TIdentifier;
  name_set_value: TIdentifier;
  version_get_value: TVersionSpec;
  version_set_value: TVersionSpec;
  defined_in_get_value: IContainer;
  absolute_name_get_value: TScopedName;
  containing_repository_get_value: IRepository;
begin
  result := true;
  if req.op_name = 'describe' then
    begin
      req.set_result(StaticAny(Description_marshaller,@describe_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_result := describe;
      req.write_results();
      exit;
    end
  else if req.op_name = 'move' then
    begin
      req.add_in_arg(StaticAny(Container_marshaller,@move_new_container) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@move_new_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@move_new_version) as IStaticAny);
      if not req.read_args() then  exit;
      move(move_new_container, move_new_name, move_new_version);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_id' then
    begin
      req.set_result(StaticAny(stat_string,@id_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      id_get_value := _get_id;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_id' then
    begin
      req.add_in_arg(StaticAny(stat_string,@id_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_id(id_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_name' then
    begin
      req.set_result(StaticAny(stat_string,@name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      name_get_value := _get_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@name_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_name(name_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_version' then
    begin
      req.set_result(StaticAny(stat_string,@version_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      version_get_value := _get_version;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_version' then
    begin
      req.add_in_arg(StaticAny(stat_string,@version_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_version(version_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_defined_in' then
    begin
      req.set_result(StaticAny(Container_marshaller,@defined_in_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      defined_in_get_value := _get_defined_in;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_absolute_name' then
    begin
      req.set_result(StaticAny(stat_string,@absolute_name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      absolute_name_get_value := _get_absolute_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_containing_repository' then
    begin
      req.set_result(StaticAny(Repository_marshaller,@containing_repository_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      containing_repository_get_value := _get_containing_repository;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TContained_marshaller
//***********************************************************
function TContained_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IContained(addr^) := TContained._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TContained_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IContained(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TContained_marshaller._free(var addr: Pointer);
begin
  IContained(addr^) := nil;
end;

procedure TContained_marshaller._create(var addr: Pointer);
begin
  IContained(addr^) := TContained_stub.Create();
end;

procedure TContained_marshaller._assign(dst, src: Pointer);
begin
  IContained(dst^) := IContained(src^);
end;

function TContained_marshaller.typecode: ITypeCode;
begin
  result := _tc_Contained.typecode;
end;

//***********************************************************
// TContained_seq_marshaller
//***********************************************************

function TContained_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: IContained;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(Contained_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not Contained_marshaller.demarshal(dec,@val) then exit;
        Contained_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TContained_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(Contained_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      Contained_marshaller.marshal(enc,@Contained_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TContained_seq_marshaller._free(var addr: Pointer);
begin
  setLength(Contained_seq(addr^),0);
  freemem(addr);
end;

procedure TContained_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TContained_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TContained_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_Contained_seq.typecode;
end;

//***********************************************************
// TInterfaceDef_seq_marshaller
//***********************************************************

function TInterfaceDef_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: IInterfaceDef;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(InterfaceDef_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not InterfaceDef_marshaller.demarshal(dec,@val) then exit;
        InterfaceDef_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TInterfaceDef_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(InterfaceDef_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      InterfaceDef_marshaller.marshal(enc,@InterfaceDef_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TInterfaceDef_seq_marshaller._free(var addr: Pointer);
begin
  setLength(InterfaceDef_seq(addr^),0);
  freemem(addr);
end;

procedure TInterfaceDef_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TInterfaceDef_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TInterfaceDef_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_InterfaceDef_seq.typecode;
end;

//***********************************************************
// TAbstractInterfaceDef_seq_marshaller
//***********************************************************

function TAbstractInterfaceDef_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: IAbstractInterfaceDef;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(AbstractInterfaceDef_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not AbstractInterfaceDef_marshaller.demarshal(dec,@val) then exit;
        AbstractInterfaceDef_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TAbstractInterfaceDef_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(AbstractInterfaceDef_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      AbstractInterfaceDef_marshaller.marshal(enc,@AbstractInterfaceDef_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TAbstractInterfaceDef_seq_marshaller._free(var addr: Pointer);
begin
  setLength(AbstractInterfaceDef_seq(addr^),0);
  freemem(addr);
end;

procedure TAbstractInterfaceDef_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TAbstractInterfaceDef_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TAbstractInterfaceDef_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_AbstractInterfaceDef_seq.typecode;
end;

//***********************************************************
// TLocalInterfaceDef_seq_marshaller
//***********************************************************

function TLocalInterfaceDef_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: ILocalInterfaceDef;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(LocalInterfaceDef_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not LocalInterfaceDef_marshaller.demarshal(dec,@val) then exit;
        LocalInterfaceDef_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TLocalInterfaceDef_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(LocalInterfaceDef_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      LocalInterfaceDef_marshaller.marshal(enc,@LocalInterfaceDef_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TLocalInterfaceDef_seq_marshaller._free(var addr: Pointer);
begin
  setLength(LocalInterfaceDef_seq(addr^),0);
  freemem(addr);
end;

procedure TLocalInterfaceDef_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TLocalInterfaceDef_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TLocalInterfaceDef_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_LocalInterfaceDef_seq.typecode;
end;

//***********************************************************
// TValueDef_seq_marshaller
//***********************************************************

function TValueDef_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: IValueDef;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(ValueDef_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not ValueDef_marshaller.demarshal(dec,@val) then exit;
        ValueDef_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TValueDef_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(ValueDef_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      ValueDef_marshaller.marshal(enc,@ValueDef_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TValueDef_seq_marshaller._free(var addr: Pointer);
begin
  setLength(ValueDef_seq(addr^),0);
  freemem(addr);
end;

procedure TValueDef_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TValueDef_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TValueDef_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_ValueDef_seq.typecode;
end;

//***********************************************************
// TInitializer_marshaller
//***********************************************************
function TInitializer_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TInitializer;
begin
  result := false;
  if not StructMember_seq_marshaller.demarshal(dec,@struct.members) then exit;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  ir_int.TInitializer(addr^) := struct;
  result := true;
end;

procedure TInitializer_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TInitializer;
begin
  struct := ir_int.TInitializer(addr^);
  StructMember_seq_marshaller.marshal(enc,@struct.members);
  stat_string.marshal(enc,@struct.name);
end;

procedure TInitializer_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TInitializer(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TInitializer_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TInitializer));
{$HINTS OFF}
  System.Initialize(ir_int.TInitializer(addr^));
{$HINTS ON}
end;

procedure TInitializer_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TInitializer(dst^) := ir_int.TInitializer(src^);
end;

function TInitializer_marshaller.typecode: ITypeCode;
begin
  result := _tc_Initializer.typecode;
end;

//***********************************************************
// TInitializer_seq_marshaller
//***********************************************************

function TInitializer_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TInitializer;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(Initializer_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not Initializer_marshaller.demarshal(dec,@val) then exit;
        Initializer_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TInitializer_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(Initializer_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      Initializer_marshaller.marshal(enc,@Initializer_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TInitializer_seq_marshaller._free(var addr: Pointer);
begin
  setLength(Initializer_seq(addr^),0);
  freemem(addr);
end;

procedure TInitializer_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TInitializer_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TInitializer_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_Initializer_seq.typecode;
end;

//***********************************************************
// TDescription_seq_marshaller
//***********************************************************

function TDescription_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TDescription;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(Description_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not Description_marshaller.demarshal(dec,@val) then exit;
        Description_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TDescription_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(Description_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      Description_marshaller.marshal(enc,@Description_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TDescription_seq_marshaller._free(var addr: Pointer);
begin
  setLength(Description_seq(addr^),0);
  freemem(addr);
end;

procedure TDescription_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TDescription_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TDescription_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_Description_seq.typecode;
end;

//***********************************************************
// TContainer
//***********************************************************
function TContainer.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TContainer._narrow(const obj : IORBObject): IContainer;
var
  p: Pointer;
  stub: TContainer_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/Container:1.0');
  if p <> nil then
    result := IContainer(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/Container:1.0') then
        begin
          stub := TContainer_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TContainer.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/Container:1.0'
end;

//***********************************************************
// TContainer_stub
//***********************************************************
procedure TContainer_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TContainer_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TContainer_stub_clp
//***********************************************************
function TContainer_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TContainer_stub_clp.lookup(const search_name: TScopedName): IContained;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup(search_name)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.contents(limit_type, exclude_inherited)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup_name(search_name, levels_to_search, limit_type, exclude_inherited)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe_contents(limit_type, exclude_inherited, max_returned_objs)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_module(id, name, version)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_constant(id, name, version, _type, value)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_struct(id, name, version, members)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_exception(id, name, version, members)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_union(id, name, version, discriminator_type, members)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_enum(id, name, version, members)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_alias(id, name, version, original_type)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_abstract_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_local_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value(id, name, version, is_custom, is_abstract, base_value, is_truncatable, abstract_base_values, supported_interfaces, initializers)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value_box(id, name, version, original_type_def)
    end;
  _postinvoke();
end;

function TContainer_stub_clp.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_native(id, name, version)
    end;
  _postinvoke();
end;

//***********************************************************
// TContainer_serv
//***********************************************************
function TContainer_serv._this(): IContainer;
var
  obj: IORBObject;
begin
  obj := this();
  result := TContainer._narrow(obj);
end;

function TContainer_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/Container:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TContainer_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/Container:1.0';
end;

function TContainer_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TContainer_stub_clp.Create(poa,obj);
end;

procedure TContainer_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TContainer_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(IContainer(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TContainer_serv._narrow(const srv : IServant): IContainer;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/Container:1.0');
  if p <> nil then
    result := IContainer(p)
end;

function TContainer_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  lookup_result: IContained;
  lookup_search_name: TScopedName;
  contents_result: TContainedSeq;
  contents_limit_type: TDefinitionKind;
  contents_exclude_inherited: Boolean;
  lookup_name_result: TContainedSeq;
  lookup_name_search_name: TIdentifier;
  lookup_name_levels_to_search: long;
  lookup_name_limit_type: TDefinitionKind;
  lookup_name_exclude_inherited: Boolean;
  describe_contents_result: TDescriptionSeq;
  describe_contents_limit_type: TDefinitionKind;
  describe_contents_exclude_inherited: Boolean;
  describe_contents_max_returned_objs: long;
  create_module_result: IModuleDef;
  create_module_id: TRepositoryId;
  create_module_name: TIdentifier;
  create_module_version: TVersionSpec;
  create_constant_result: IConstantDef;
  create_constant_id: TRepositoryId;
  create_constant_name: TIdentifier;
  create_constant_version: TVersionSpec;
  create_constant_type: IIDLType;
  create_constant_value: IAny;
  create_struct_result: IStructDef;
  create_struct_id: TRepositoryId;
  create_struct_name: TIdentifier;
  create_struct_version: TVersionSpec;
  create_struct_members: TStructMemberSeq;
  create_exception_result: IExceptionDef;
  create_exception_id: TRepositoryId;
  create_exception_name: TIdentifier;
  create_exception_version: TVersionSpec;
  create_exception_members: TStructMemberSeq;
  create_union_result: IUnionDef;
  create_union_id: TRepositoryId;
  create_union_name: TIdentifier;
  create_union_version: TVersionSpec;
  create_union_discriminator_type: IIDLType;
  create_union_members: TUnionMemberSeq;
  create_enum_result: IEnumDef;
  create_enum_id: TRepositoryId;
  create_enum_name: TIdentifier;
  create_enum_version: TVersionSpec;
  create_enum_members: TEnumMemberSeq;
  create_alias_result: IAliasDef;
  create_alias_id: TRepositoryId;
  create_alias_name: TIdentifier;
  create_alias_version: TVersionSpec;
  create_alias_original_type: IIDLType;
  create_interface_result: IInterfaceDef;
  create_interface_id: TRepositoryId;
  create_interface_name: TIdentifier;
  create_interface_version: TVersionSpec;
  create_interface_base_interfaces: TInterfaceDefSeq;
  create_abstract_interface_result: IAbstractInterfaceDef;
  create_abstract_interface_id: TRepositoryId;
  create_abstract_interface_name: TIdentifier;
  create_abstract_interface_version: TVersionSpec;
  create_abstract_interface_base_interfaces: TAbstractInterfaceDefSeq;
  create_local_interface_result: ILocalInterfaceDef;
  create_local_interface_id: TRepositoryId;
  create_local_interface_name: TIdentifier;
  create_local_interface_version: TVersionSpec;
  create_local_interface_base_interfaces: TInterfaceDefSeq;
  create_value_result: IValueDef;
  create_value_id: TRepositoryId;
  create_value_name: TIdentifier;
  create_value_version: TVersionSpec;
  create_value_is_custom: Boolean;
  create_value_is_abstract: Boolean;
  create_value_base_value: IValueDef;
  create_value_is_truncatable: Boolean;
  create_value_abstract_base_values: TValueDefSeq;
  create_value_supported_interfaces: TInterfaceDefSeq;
  create_value_initializers: TInitializerSeq;
  create_value_box_result: IValueBoxDef;
  create_value_box_id: TRepositoryId;
  create_value_box_name: TIdentifier;
  create_value_box_version: TVersionSpec;
  create_value_box_original_type_def: IIDLType;
  create_native_result: INativeDef;
  create_native_id: TRepositoryId;
  create_native_name: TIdentifier;
  create_native_version: TVersionSpec;
begin
  result := true;
  if req.op_name = 'lookup' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_search_name) as IStaticAny);
      req.set_result(StaticAny(Contained_marshaller,@lookup_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_result := lookup(lookup_search_name);
      req.write_results();
      exit;
    end
  else if req.op_name = 'contents' then
    begin
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@contents_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@contents_exclude_inherited) as IStaticAny);
      req.set_result(StaticAny(Contained_seq_marshaller,@contents_result) as IStaticAny);
      if not req.read_args() then  exit;
      contents_result := contents(contents_limit_type, contents_exclude_inherited);
      req.write_results();
      exit;
    end
  else if req.op_name = 'lookup_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_name_search_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_long,@lookup_name_levels_to_search) as IStaticAny);
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@lookup_name_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@lookup_name_exclude_inherited) as IStaticAny);
      req.set_result(StaticAny(Contained_seq_marshaller,@lookup_name_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_name_result := lookup_name(lookup_name_search_name, lookup_name_levels_to_search, lookup_name_limit_type, lookup_name_exclude_inherited);
      req.write_results();
      exit;
    end
  else if req.op_name = 'describe_contents' then
    begin
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@describe_contents_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@describe_contents_exclude_inherited) as IStaticAny);
      req.add_in_arg(StaticAny(stat_long,@describe_contents_max_returned_objs) as IStaticAny);
      req.set_result(StaticAny(Description_seq_marshaller,@describe_contents_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_contents_result := describe_contents(describe_contents_limit_type, describe_contents_exclude_inherited, describe_contents_max_returned_objs);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_module' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_module_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_module_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_module_version) as IStaticAny);
      req.set_result(StaticAny(ModuleDef_marshaller,@create_module_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_module_result := create_module(create_module_id, create_module_name, create_module_version);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_constant' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_constant_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_constant_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_constant_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_constant_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_any,@create_constant_value) as IStaticAny);
      req.set_result(StaticAny(ConstantDef_marshaller,@create_constant_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_constant_result := create_constant(create_constant_id, create_constant_name, create_constant_version, create_constant_type, create_constant_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_struct' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_struct_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_struct_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_struct_version) as IStaticAny);
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@create_struct_members) as IStaticAny);
      req.set_result(StaticAny(StructDef_marshaller,@create_struct_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_struct_result := create_struct(create_struct_id, create_struct_name, create_struct_version, create_struct_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_exception' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_exception_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_exception_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_exception_version) as IStaticAny);
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@create_exception_members) as IStaticAny);
      req.set_result(StaticAny(ExceptionDef_marshaller,@create_exception_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_exception_result := create_exception(create_exception_id, create_exception_name, create_exception_version, create_exception_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_union' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_union_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_union_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_union_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_union_discriminator_type) as IStaticAny);
      req.add_in_arg(StaticAny(UnionMember_seq_marshaller,@create_union_members) as IStaticAny);
      req.set_result(StaticAny(UnionDef_marshaller,@create_union_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_union_result := create_union(create_union_id, create_union_name, create_union_version, create_union_discriminator_type, create_union_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_enum' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_enum_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_enum_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_enum_version) as IStaticAny);
      req.add_in_arg(StaticAny(stat_seq_string,@create_enum_members) as IStaticAny);
      req.set_result(StaticAny(EnumDef_marshaller,@create_enum_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_enum_result := create_enum(create_enum_id, create_enum_name, create_enum_version, create_enum_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_alias' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_alias_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_alias_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_alias_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_alias_original_type) as IStaticAny);
      req.set_result(StaticAny(AliasDef_marshaller,@create_alias_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_alias_result := create_alias(create_alias_id, create_alias_name, create_alias_version, create_alias_original_type);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(InterfaceDef_marshaller,@create_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_interface_result := create_interface(create_interface_id, create_interface_name, create_interface_version, create_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_abstract_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(AbstractInterfaceDef_seq_marshaller,@create_abstract_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(AbstractInterfaceDef_marshaller,@create_abstract_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_abstract_interface_result := create_abstract_interface(create_abstract_interface_id, create_abstract_interface_name, create_abstract_interface_version, create_abstract_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_local_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_local_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(LocalInterfaceDef_marshaller,@create_local_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_local_interface_result := create_local_interface(create_local_interface_id, create_local_interface_name, create_local_interface_version, create_local_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_version) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_custom) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_abstract) as IStaticAny);
      req.add_in_arg(StaticAny(ValueDef_marshaller,@create_value_base_value) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_truncatable) as IStaticAny);
      req.add_in_arg(StaticAny(ValueDef_seq_marshaller,@create_value_abstract_base_values) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_value_supported_interfaces) as IStaticAny);
      req.add_in_arg(StaticAny(Initializer_seq_marshaller,@create_value_initializers) as IStaticAny);
      req.set_result(StaticAny(ValueDef_marshaller,@create_value_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_result := create_value(create_value_id, create_value_name, create_value_version, create_value_is_custom, create_value_is_abstract, create_value_base_value, create_value_is_truncatable, create_value_abstract_base_values, create_value_supported_interfaces, create_value_initializers);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value_box' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_box_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_box_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_box_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_value_box_original_type_def) as IStaticAny);
      req.set_result(StaticAny(ValueBoxDef_marshaller,@create_value_box_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_box_result := create_value_box(create_value_box_id, create_value_box_name, create_value_box_version, create_value_box_original_type_def);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_native' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_native_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_native_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_native_version) as IStaticAny);
      req.set_result(StaticAny(NativeDef_marshaller,@create_native_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_native_result := create_native(create_native_id, create_native_name, create_native_version);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TContainer_marshaller
//***********************************************************
function TContainer_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IContainer(addr^) := TContainer._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TContainer_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IContainer(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TContainer_marshaller._free(var addr: Pointer);
begin
  IContainer(addr^) := nil;
end;

procedure TContainer_marshaller._create(var addr: Pointer);
begin
  IContainer(addr^) := TContainer_stub.Create();
end;

procedure TContainer_marshaller._assign(dst, src: Pointer);
begin
  IContainer(dst^) := IContainer(src^);
end;

function TContainer_marshaller.typecode: ITypeCode;
begin
  result := _tc_Container.typecode;
end;

//***********************************************************
// TPrimitiveKind_marshaller
//***********************************************************
function TPrimitiveKind_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TPrimitiveKind_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TPrimitiveKind_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TPrimitiveKind_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TPrimitiveKind_marshaller._assign(dst, src: Pointer);
begin
  TPrimitiveKind(dst^) := TPrimitiveKind(src^);
end;

function TPrimitiveKind_marshaller.typecode: ITypeCode;
begin
  result := _tc_PrimitiveKind.typecode;
end;

//***********************************************************
// TRepository
//***********************************************************
function TRepository.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Repository:1.0' then
    begin
      result := Pointer(self as IRepository);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TRepository._narrow(const obj : IORBObject): IRepository;
var
  p: Pointer;
  stub: TRepository_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/Repository:1.0');
  if p <> nil then
    result := IRepository(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/Repository:1.0') then
        begin
          stub := TRepository_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TRepository.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/Repository:1.0'
end;

//***********************************************************
// TRepository_stub
//***********************************************************
function TRepository_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TRepository_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.lookup_id(const search_id: TRepositoryId): IContained;
var
  req: IStaticRequest;
  _search_id: IStaticAny;
  _result: IStaticAny;
begin
  _search_id := StaticAny(stat_string,@search_id);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup_id');
  req.add_in_arg(_search_id);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.get_primitive(const kind: TPrimitiveKind): IPrimitiveDef;
var
  req: IStaticRequest;
  _kind: IStaticAny;
  _result: IStaticAny;
begin
  _kind := StaticAny(PrimitiveKind_marshaller,@kind);
  _result := StaticAny(PrimitiveDef_marshaller, @result);
  req := StaticRequest(self,'get_primitive');
  req.add_in_arg(_kind);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_string(const bound: _ulong): IStringDef;
var
  req: IStaticRequest;
  _bound: IStaticAny;
  _result: IStaticAny;
begin
  _bound := StaticAny(stat_ulong,@bound);
  _result := StaticAny(StringDef_marshaller, @result);
  req := StaticRequest(self,'create_string');
  req.add_in_arg(_bound);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_wstring(const bound: _ulong): IWstringDef;
var
  req: IStaticRequest;
  _bound: IStaticAny;
  _result: IStaticAny;
begin
  _bound := StaticAny(stat_ulong,@bound);
  _result := StaticAny(WstringDef_marshaller, @result);
  req := StaticRequest(self,'create_wstring');
  req.add_in_arg(_bound);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_sequence(const bound: _ulong; const element_type: IIDLType): ISequenceDef;
var
  req: IStaticRequest;
  _bound: IStaticAny;
  _element_type: IStaticAny;
  _result: IStaticAny;
begin
  _bound := StaticAny(stat_ulong,@bound);
  _element_type := StaticAny(IDLType_marshaller,@element_type);
  _result := StaticAny(SequenceDef_marshaller, @result);
  req := StaticRequest(self,'create_sequence');
  req.add_in_arg(_bound);
  req.add_in_arg(_element_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_array(const length: _ulong; const element_type: IIDLType): IArrayDef;
var
  req: IStaticRequest;
  _length: IStaticAny;
  _element_type: IStaticAny;
  _result: IStaticAny;
begin
  _length := StaticAny(stat_ulong,@length);
  _element_type := StaticAny(IDLType_marshaller,@element_type);
  _result := StaticAny(ArrayDef_marshaller, @result);
  req := StaticRequest(self,'create_array');
  req.add_in_arg(_length);
  req.add_in_arg(_element_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TRepository_stub.create_fixed(const digits: _ushort; const scale: Short): IFixedDef;
var
  req: IStaticRequest;
  _digits: IStaticAny;
  _scale: IStaticAny;
  _result: IStaticAny;
begin
  _digits := StaticAny(stat_ushort,@digits);
  _scale := StaticAny(stat_short,@scale);
  _result := StaticAny(FixedDef_marshaller, @result);
  req := StaticRequest(self,'create_fixed');
  req.add_in_arg(_digits);
  req.add_in_arg(_scale);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TRepository_stub_clp
//***********************************************************
function TRepository_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Repository:1.0' then
    begin
      result := Pointer(self as IRepository);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TRepository_stub_clp.lookup_id(const search_id: TRepositoryId): IContained;
var
  _srv: IServant;
  srv: IRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup_id(search_id)
    end;
  _postinvoke();
end;

function TRepository_stub_clp.get_primitive(const kind: TPrimitiveKind): IPrimitiveDef;
var
  _srv: IServant;
  srv: IRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_primitive(kind)
    end;
  _postinvoke();
end;

function TRepository_stub_clp.create_string(const bound: _ulong): IStringDef;
var
  _srv: IServant;
  srv: IRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_string(bound)
    end;
  _postinvoke();
end;

function TRepository_stub_clp.create_wstring(const bound: _ulong): IWstringDef;
var
  _srv: IServant;
  srv: IRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_wstring(bound)
    end;
  _postinvoke();
end;

function TRepository_stub_clp.create_sequence(const bound: _ulong; const element_type: IIDLType): ISequenceDef;
var
  _srv: IServant;
  srv: IRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_sequence(bound, element_type)
    end;
  _postinvoke();
end;

function TRepository_stub_clp.create_array(const length: _ulong; const element_type: IIDLType): IArrayDef;
var
  _srv: IServant;
  srv: IRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_array(length, element_type)
    end;
  _postinvoke();
end;

function TRepository_stub_clp.create_fixed(const digits: _ushort; const scale: Short): IFixedDef;
var
  _srv: IServant;
  srv: IRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_fixed(digits, scale)
    end;
  _postinvoke();
end;

//***********************************************************
// TRepository_serv
//***********************************************************
function TRepository_serv._this(): IRepository;
var
  obj: IORBObject;
begin
  obj := this();
  result := TRepository._narrow(obj);
end;

function TRepository_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/Repository:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TRepository_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/Repository:1.0';
end;

function TRepository_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TRepository_stub_clp.Create(poa,obj);
end;

procedure TRepository_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TRepository_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/Repository:1.0' then
    begin
      result := Pointer(IRepository(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TRepository_serv._narrow(const srv : IServant): IRepository;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/Repository:1.0');
  if p <> nil then
    result := IRepository(p)
end;

function TRepository_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  lookup_id_result: IContained;
  lookup_id_search_id: TRepositoryId;
  get_primitive_result: IPrimitiveDef;
  get_primitive_kind: TPrimitiveKind;
  create_string_result: IStringDef;
  create_string_bound: _ulong;
  create_wstring_result: IWstringDef;
  create_wstring_bound: _ulong;
  create_sequence_result: ISequenceDef;
  create_sequence_bound: _ulong;
  create_sequence_element_type: IIDLType;
  create_array_result: IArrayDef;
  create_array_length: _ulong;
  create_array_element_type: IIDLType;
  create_fixed_result: IFixedDef;
  create_fixed_digits: _ushort;
  create_fixed_scale: Short;
begin
  result := true;
  if req.op_name = 'lookup_id' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_id_search_id) as IStaticAny);
      req.set_result(StaticAny(Contained_marshaller,@lookup_id_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_id_result := lookup_id(lookup_id_search_id);
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_primitive' then
    begin
      req.add_in_arg(StaticAny(PrimitiveKind_marshaller,@get_primitive_kind) as IStaticAny);
      req.set_result(StaticAny(PrimitiveDef_marshaller,@get_primitive_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_primitive_result := get_primitive(get_primitive_kind);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_string' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@create_string_bound) as IStaticAny);
      req.set_result(StaticAny(StringDef_marshaller,@create_string_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_string_result := create_string(create_string_bound);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_wstring' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@create_wstring_bound) as IStaticAny);
      req.set_result(StaticAny(WstringDef_marshaller,@create_wstring_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_wstring_result := create_wstring(create_wstring_bound);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_sequence' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@create_sequence_bound) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_sequence_element_type) as IStaticAny);
      req.set_result(StaticAny(SequenceDef_marshaller,@create_sequence_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_sequence_result := create_sequence(create_sequence_bound, create_sequence_element_type);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_array' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@create_array_length) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_array_element_type) as IStaticAny);
      req.set_result(StaticAny(ArrayDef_marshaller,@create_array_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_array_result := create_array(create_array_length, create_array_element_type);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_fixed' then
    begin
      req.add_in_arg(StaticAny(stat_ushort,@create_fixed_digits) as IStaticAny);
      req.add_in_arg(StaticAny(stat_short,@create_fixed_scale) as IStaticAny);
      req.set_result(StaticAny(FixedDef_marshaller,@create_fixed_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_fixed_result := create_fixed(create_fixed_digits, create_fixed_scale);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TRepository_marshaller
//***********************************************************
function TRepository_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IRepository(addr^) := TRepository._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TRepository_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IRepository(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TRepository_marshaller._free(var addr: Pointer);
begin
  IRepository(addr^) := nil;
end;

procedure TRepository_marshaller._create(var addr: Pointer);
begin
  IRepository(addr^) := TRepository_stub.Create();
end;

procedure TRepository_marshaller._assign(dst, src: Pointer);
begin
  IRepository(dst^) := IRepository(src^);
end;

function TRepository_marshaller.typecode: ITypeCode;
begin
  result := _tc_Repository.typecode;
end;

//***********************************************************
// TModuleDef
//***********************************************************
function TModuleDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ModuleDef:1.0' then
    begin
      result := Pointer(self as IModuleDef);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TModuleDef._narrow(const obj : IORBObject): IModuleDef;
var
  p: Pointer;
  stub: TModuleDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/ModuleDef:1.0');
  if p <> nil then
    result := IModuleDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/ModuleDef:1.0') then
        begin
          stub := TModuleDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TModuleDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/ModuleDef:1.0'
end;

//***********************************************************
// TModuleDef_stub
//***********************************************************
function TModuleDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TModuleDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TModuleDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TModuleDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TModuleDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TModuleDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TModuleDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TModuleDef_stub_clp
//***********************************************************
function TModuleDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ModuleDef:1.0' then
    begin
      result := Pointer(self as IModuleDef);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TModuleDef_stub_clp.describe: TDescription;
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe
    end;
  _postinvoke();
end;

procedure TModuleDef_stub_clp.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv.move(new_container, new_name, new_version)
    end;
  _postinvoke();
end;

procedure TModuleDef_stub_clp._set_id(const val: TRepositoryId);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_id(val);
    end;
  _postinvoke();
end;

function TModuleDef_stub_clp._get_id: TRepositoryId;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_id
    end;
  _postinvoke();
end;

procedure TModuleDef_stub_clp._set_name(const val: TIdentifier);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_name(val);
    end;
  _postinvoke();
end;

function TModuleDef_stub_clp._get_name: TIdentifier;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_name
    end;
  _postinvoke();
end;

procedure TModuleDef_stub_clp._set_version(const val: TVersionSpec);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_version(val);
    end;
  _postinvoke();
end;

function TModuleDef_stub_clp._get_version: TVersionSpec;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_version
    end;
  _postinvoke();
end;

function TModuleDef_stub_clp._get_defined_in: IContainer;
var
  _srv: IServant;
  srv: IContained;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_defined_in
    end;
  _postinvoke();
end;

function TModuleDef_stub_clp._get_absolute_name: TScopedName;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_absolute_name
    end;
  _postinvoke();
end;

function TModuleDef_stub_clp._get_containing_repository: IRepository;
var
  _srv: IServant;
  srv: IContained;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_containing_repository
    end;
  _postinvoke();
end;

//***********************************************************
// TModuleDef_serv
//***********************************************************
function TModuleDef_serv._this(): IModuleDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TModuleDef._narrow(obj);
end;

function TModuleDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/ModuleDef:1.0';
  if repoid = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := true;
      exit;
    end;
  if not result then
    result := inherited _is_a(repoid);
end;

function TModuleDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/ModuleDef:1.0';
end;

function TModuleDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TModuleDef_stub_clp.Create(poa,obj);
end;

procedure TModuleDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TModuleDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ModuleDef:1.0' then
    begin
      result := Pointer(IModuleDef(self));
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TModuleDef_serv._narrow(const srv : IServant): IModuleDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/ModuleDef:1.0');
  if p <> nil then
    result := IModuleDef(p)
end;

function TModuleDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  describe_result: TDescription;
  move_new_container: IContainer;
  move_new_name: TIdentifier;
  move_new_version: TVersionSpec;
  id_get_value: TRepositoryId;
  id_set_value: TRepositoryId;
  name_get_value: TIdentifier;
  name_set_value: TIdentifier;
  version_get_value: TVersionSpec;
  version_set_value: TVersionSpec;
  defined_in_get_value: IContainer;
  absolute_name_get_value: TScopedName;
  containing_repository_get_value: IRepository;
begin
  result := true;
  if req.op_name = 'describe' then
    begin
      req.set_result(StaticAny(Description_marshaller,@describe_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_result := describe;
      req.write_results();
      exit;
    end
  else if req.op_name = 'move' then
    begin
      req.add_in_arg(StaticAny(Container_marshaller,@move_new_container) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@move_new_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@move_new_version) as IStaticAny);
      if not req.read_args() then  exit;
      move(move_new_container, move_new_name, move_new_version);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_id' then
    begin
      req.set_result(StaticAny(stat_string,@id_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      id_get_value := _get_id;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_id' then
    begin
      req.add_in_arg(StaticAny(stat_string,@id_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_id(id_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_name' then
    begin
      req.set_result(StaticAny(stat_string,@name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      name_get_value := _get_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@name_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_name(name_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_version' then
    begin
      req.set_result(StaticAny(stat_string,@version_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      version_get_value := _get_version;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_version' then
    begin
      req.add_in_arg(StaticAny(stat_string,@version_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_version(version_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_defined_in' then
    begin
      req.set_result(StaticAny(Container_marshaller,@defined_in_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      defined_in_get_value := _get_defined_in;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_absolute_name' then
    begin
      req.set_result(StaticAny(stat_string,@absolute_name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      absolute_name_get_value := _get_absolute_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_containing_repository' then
    begin
      req.set_result(StaticAny(Repository_marshaller,@containing_repository_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      containing_repository_get_value := _get_containing_repository;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TModuleDef_marshaller
//***********************************************************
function TModuleDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IModuleDef(addr^) := TModuleDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TModuleDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IModuleDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TModuleDef_marshaller._free(var addr: Pointer);
begin
  IModuleDef(addr^) := nil;
end;

procedure TModuleDef_marshaller._create(var addr: Pointer);
begin
  IModuleDef(addr^) := TModuleDef_stub.Create();
end;

procedure TModuleDef_marshaller._assign(dst, src: Pointer);
begin
  IModuleDef(dst^) := IModuleDef(src^);
end;

function TModuleDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_ModuleDef.typecode;
end;

//***********************************************************
// TModuleDescription_marshaller
//***********************************************************
function TModuleDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TModuleDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  ir_int.TModuleDescription(addr^) := struct;
  result := true;
end;

procedure TModuleDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TModuleDescription;
begin
  struct := ir_int.TModuleDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
end;

procedure TModuleDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TModuleDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TModuleDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TModuleDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TModuleDescription(addr^));
{$HINTS ON}
end;

procedure TModuleDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TModuleDescription(dst^) := ir_int.TModuleDescription(src^);
end;

function TModuleDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_ModuleDescription.typecode;
end;

//***********************************************************
// TConstantDef
//***********************************************************
function TConstantDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ConstantDef:1.0' then
    begin
      result := Pointer(self as IConstantDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TConstantDef._narrow(const obj : IORBObject): IConstantDef;
var
  p: Pointer;
  stub: TConstantDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/ConstantDef:1.0');
  if p <> nil then
    result := IConstantDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/ConstantDef:1.0') then
        begin
          stub := TConstantDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TConstantDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/ConstantDef:1.0'
end;

//***********************************************************
// TConstantDef_stub
//***********************************************************
function TConstantDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TConstantDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TConstantDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TConstantDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TConstantDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TConstantDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TConstantDef_stub._set_type_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_type_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_type_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_type_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TConstantDef_stub._set_value(const val: IAny);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_any,@val);
  req := StaticRequest(self,'_set_value');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TConstantDef_stub._get_value: IAny;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_any, @result);
  req := StaticRequest(self,'_get_value');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TConstantDef_stub_clp
//***********************************************************
function TConstantDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ConstantDef:1.0' then
    begin
      result := Pointer(self as IConstantDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TConstantDef_stub_clp._get_type: ITypeCode;
var
  _srv: IServant;
  srv: IConstantDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TConstantDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type
    end;
  _postinvoke();
end;

procedure TConstantDef_stub_clp._set_type_def(const val: IIDLType);
var
  _srv: IServant;
  srv: IConstantDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TConstantDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_type_def(val);
    end;
  _postinvoke();
end;

function TConstantDef_stub_clp._get_type_def: IIDLType;
var
  _srv: IServant;
  srv: IConstantDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TConstantDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type_def
    end;
  _postinvoke();
end;

procedure TConstantDef_stub_clp._set_value(const val: IAny);
var
  _srv: IServant;
  srv: IConstantDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TConstantDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_value(val);
    end;
  _postinvoke();
end;

function TConstantDef_stub_clp._get_value: IAny;
var
  _srv: IServant;
  srv: IConstantDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TConstantDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_value
    end;
  _postinvoke();
end;

//***********************************************************
// TConstantDef_serv
//***********************************************************
function TConstantDef_serv._this(): IConstantDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TConstantDef._narrow(obj);
end;

function TConstantDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/ConstantDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TConstantDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/ConstantDef:1.0';
end;

function TConstantDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TConstantDef_stub_clp.Create(poa,obj);
end;

procedure TConstantDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TConstantDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ConstantDef:1.0' then
    begin
      result := Pointer(IConstantDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TConstantDef_serv._narrow(const srv : IServant): IConstantDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/ConstantDef:1.0');
  if p <> nil then
    result := IConstantDef(p)
end;

function TConstantDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  type_get_value: ITypeCode;
  type_def_get_value: IIDLType;
  type_def_set_value: IIDLType;
  value_get_value: IAny;
  value_set_value: IAny;
begin
  result := true;
  if req.op_name = '_get_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_get_value := _get_type;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_type_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@type_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_def_get_value := _get_type_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_type_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@type_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_type_def(type_def_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_value' then
    begin
      req.set_result(StaticAny(stat_any,@value_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      value_get_value := _get_value;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_value' then
    begin
      req.add_in_arg(StaticAny(stat_any,@value_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_value(value_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TConstantDef_marshaller
//***********************************************************
function TConstantDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IConstantDef(addr^) := TConstantDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TConstantDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IConstantDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TConstantDef_marshaller._free(var addr: Pointer);
begin
  IConstantDef(addr^) := nil;
end;

procedure TConstantDef_marshaller._create(var addr: Pointer);
begin
  IConstantDef(addr^) := TConstantDef_stub.Create();
end;

procedure TConstantDef_marshaller._assign(dst, src: Pointer);
begin
  IConstantDef(dst^) := IConstantDef(src^);
end;

function TConstantDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_ConstantDef.typecode;
end;

//***********************************************************
// TConstantDescription_marshaller
//***********************************************************
function TConstantDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TConstantDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  if not stat_any.demarshal(dec,@struct.value) then exit;
  ir_int.TConstantDescription(addr^) := struct;
  result := true;
end;

procedure TConstantDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TConstantDescription;
begin
  struct := ir_int.TConstantDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  stat_TypeCode.marshal(enc,@struct._type);
  stat_any.marshal(enc,@struct.value);
end;

procedure TConstantDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TConstantDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TConstantDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TConstantDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TConstantDescription(addr^));
{$HINTS ON}
end;

procedure TConstantDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TConstantDescription(dst^) := ir_int.TConstantDescription(src^);
end;

function TConstantDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_ConstantDescription.typecode;
end;

//***********************************************************
// TTypedefDef
//***********************************************************
function TTypedefDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/TypedefDef:1.0' then
    begin
      result := Pointer(self as ITypedefDef);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TTypedefDef._narrow(const obj : IORBObject): ITypedefDef;
var
  p: Pointer;
  stub: TTypedefDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/TypedefDef:1.0');
  if p <> nil then
    result := ITypedefDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/TypedefDef:1.0') then
        begin
          stub := TTypedefDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TTypedefDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/TypedefDef:1.0'
end;

//***********************************************************
// TTypedefDef_stub
//***********************************************************
function TTypedefDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTypedefDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TTypedefDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TTypedefDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TTypedefDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TTypedefDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TTypedefDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TTypedefDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TTypedefDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTypedefDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTypedefDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TTypedefDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TTypedefDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TTypedefDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TTypedefDef_stub_clp
//***********************************************************
function TTypedefDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/TypedefDef:1.0' then
    begin
      result := Pointer(self as ITypedefDef);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TTypedefDef_stub_clp._get_type: ITypeCode;
var
  _srv: IServant;
  srv: IIDLType;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TIDLType_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type
    end;
  _postinvoke();
end;

//***********************************************************
// TTypedefDef_serv
//***********************************************************
function TTypedefDef_serv._this(): ITypedefDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TTypedefDef._narrow(obj);
end;

function TTypedefDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/TypedefDef:1.0';
  if repoid = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := true;
      exit;
    end;
  if not result then
    result := inherited _is_a(repoid);
end;

function TTypedefDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/TypedefDef:1.0';
end;

function TTypedefDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TTypedefDef_stub_clp.Create(poa,obj);
end;

procedure TTypedefDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TTypedefDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/TypedefDef:1.0' then
    begin
      result := Pointer(ITypedefDef(self));
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TTypedefDef_serv._narrow(const srv : IServant): ITypedefDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/TypedefDef:1.0');
  if p <> nil then
    result := ITypedefDef(p)
end;

function TTypedefDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  type_get_value: ITypeCode;
begin
  result := true;
  if req.op_name = '_get_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_get_value := _get_type;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TTypedefDef_marshaller
//***********************************************************
function TTypedefDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ITypedefDef(addr^) := TTypedefDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TTypedefDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ITypedefDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TTypedefDef_marshaller._free(var addr: Pointer);
begin
  ITypedefDef(addr^) := nil;
end;

procedure TTypedefDef_marshaller._create(var addr: Pointer);
begin
  ITypedefDef(addr^) := TTypedefDef_stub.Create();
end;

procedure TTypedefDef_marshaller._assign(dst, src: Pointer);
begin
  ITypedefDef(dst^) := ITypedefDef(src^);
end;

function TTypedefDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_TypedefDef.typecode;
end;

//***********************************************************
// TTypeDescription_marshaller
//***********************************************************
function TTypeDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TTypeDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  ir_int.TTypeDescription(addr^) := struct;
  result := true;
end;

procedure TTypeDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TTypeDescription;
begin
  struct := ir_int.TTypeDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  stat_TypeCode.marshal(enc,@struct._type);
end;

procedure TTypeDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TTypeDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TTypeDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TTypeDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TTypeDescription(addr^));
{$HINTS ON}
end;

procedure TTypeDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TTypeDescription(dst^) := ir_int.TTypeDescription(src^);
end;

function TTypeDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_TypeDescription.typecode;
end;

//***********************************************************
// TStructDef
//***********************************************************
function TStructDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/StructDef:1.0' then
    begin
      result := Pointer(self as IStructDef);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TStructDef._narrow(const obj : IORBObject): IStructDef;
var
  p: Pointer;
  stub: TStructDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/StructDef:1.0');
  if p <> nil then
    result := IStructDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/StructDef:1.0') then
        begin
          stub := TStructDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TStructDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/StructDef:1.0'
end;

//***********************************************************
// TStructDef_stub
//***********************************************************
function TStructDef_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStructDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStructDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStructDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStructDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStructDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStructDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStructDef_stub._set_members(const val: TStructMemberSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(StructMember_seq_marshaller,@val);
  req := StaticRequest(self,'_set_members');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TStructDef_stub._get_members: TStructMemberSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(StructMember_seq_marshaller, @result);
  req := StaticRequest(self,'_get_members');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TStructDef_stub_clp
//***********************************************************
function TStructDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/StructDef:1.0' then
    begin
      result := Pointer(self as IStructDef);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TStructDef_stub_clp.lookup(const search_name: TScopedName): IContained;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup(search_name)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.contents(limit_type, exclude_inherited)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup_name(search_name, levels_to_search, limit_type, exclude_inherited)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe_contents(limit_type, exclude_inherited, max_returned_objs)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_module(id, name, version)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_constant(id, name, version, _type, value)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_struct(id, name, version, members)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_exception(id, name, version, members)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_union(id, name, version, discriminator_type, members)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_enum(id, name, version, members)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_alias(id, name, version, original_type)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_abstract_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_local_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value(id, name, version, is_custom, is_abstract, base_value, is_truncatable, abstract_base_values, supported_interfaces, initializers)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value_box(id, name, version, original_type_def)
    end;
  _postinvoke();
end;

function TStructDef_stub_clp.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_native(id, name, version)
    end;
  _postinvoke();
end;

procedure TStructDef_stub_clp._set_members(const val: TStructMemberSeq);
var
  _srv: IServant;
  srv: IStructDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TStructDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_members(val);
    end;
  _postinvoke();
end;

function TStructDef_stub_clp._get_members: TStructMemberSeq;
var
  _srv: IServant;
  srv: IStructDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TStructDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_members
    end;
  _postinvoke();
end;

//***********************************************************
// TStructDef_serv
//***********************************************************
function TStructDef_serv._this(): IStructDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TStructDef._narrow(obj);
end;

function TStructDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/StructDef:1.0';
  if repoid = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := true;
      exit;
    end;
  if not result then
    result := inherited _is_a(repoid);
end;

function TStructDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/StructDef:1.0';
end;

function TStructDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TStructDef_stub_clp.Create(poa,obj);
end;

procedure TStructDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TStructDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/StructDef:1.0' then
    begin
      result := Pointer(IStructDef(self));
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TStructDef_serv._narrow(const srv : IServant): IStructDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/StructDef:1.0');
  if p <> nil then
    result := IStructDef(p)
end;

function TStructDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  members_get_value: TStructMemberSeq;
  members_set_value: TStructMemberSeq;
  lookup_result: IContained;
  lookup_search_name: TScopedName;
  contents_result: TContainedSeq;
  contents_limit_type: TDefinitionKind;
  contents_exclude_inherited: Boolean;
  lookup_name_result: TContainedSeq;
  lookup_name_search_name: TIdentifier;
  lookup_name_levels_to_search: long;
  lookup_name_limit_type: TDefinitionKind;
  lookup_name_exclude_inherited: Boolean;
  describe_contents_result: TDescriptionSeq;
  describe_contents_limit_type: TDefinitionKind;
  describe_contents_exclude_inherited: Boolean;
  describe_contents_max_returned_objs: long;
  create_module_result: IModuleDef;
  create_module_id: TRepositoryId;
  create_module_name: TIdentifier;
  create_module_version: TVersionSpec;
  create_constant_result: IConstantDef;
  create_constant_id: TRepositoryId;
  create_constant_name: TIdentifier;
  create_constant_version: TVersionSpec;
  create_constant_type: IIDLType;
  create_constant_value: IAny;
  create_struct_result: IStructDef;
  create_struct_id: TRepositoryId;
  create_struct_name: TIdentifier;
  create_struct_version: TVersionSpec;
  create_struct_members: TStructMemberSeq;
  create_exception_result: IExceptionDef;
  create_exception_id: TRepositoryId;
  create_exception_name: TIdentifier;
  create_exception_version: TVersionSpec;
  create_exception_members: TStructMemberSeq;
  create_union_result: IUnionDef;
  create_union_id: TRepositoryId;
  create_union_name: TIdentifier;
  create_union_version: TVersionSpec;
  create_union_discriminator_type: IIDLType;
  create_union_members: TUnionMemberSeq;
  create_enum_result: IEnumDef;
  create_enum_id: TRepositoryId;
  create_enum_name: TIdentifier;
  create_enum_version: TVersionSpec;
  create_enum_members: TEnumMemberSeq;
  create_alias_result: IAliasDef;
  create_alias_id: TRepositoryId;
  create_alias_name: TIdentifier;
  create_alias_version: TVersionSpec;
  create_alias_original_type: IIDLType;
  create_interface_result: IInterfaceDef;
  create_interface_id: TRepositoryId;
  create_interface_name: TIdentifier;
  create_interface_version: TVersionSpec;
  create_interface_base_interfaces: TInterfaceDefSeq;
  create_abstract_interface_result: IAbstractInterfaceDef;
  create_abstract_interface_id: TRepositoryId;
  create_abstract_interface_name: TIdentifier;
  create_abstract_interface_version: TVersionSpec;
  create_abstract_interface_base_interfaces: TAbstractInterfaceDefSeq;
  create_local_interface_result: ILocalInterfaceDef;
  create_local_interface_id: TRepositoryId;
  create_local_interface_name: TIdentifier;
  create_local_interface_version: TVersionSpec;
  create_local_interface_base_interfaces: TInterfaceDefSeq;
  create_value_result: IValueDef;
  create_value_id: TRepositoryId;
  create_value_name: TIdentifier;
  create_value_version: TVersionSpec;
  create_value_is_custom: Boolean;
  create_value_is_abstract: Boolean;
  create_value_base_value: IValueDef;
  create_value_is_truncatable: Boolean;
  create_value_abstract_base_values: TValueDefSeq;
  create_value_supported_interfaces: TInterfaceDefSeq;
  create_value_initializers: TInitializerSeq;
  create_value_box_result: IValueBoxDef;
  create_value_box_id: TRepositoryId;
  create_value_box_name: TIdentifier;
  create_value_box_version: TVersionSpec;
  create_value_box_original_type_def: IIDLType;
  create_native_result: INativeDef;
  create_native_id: TRepositoryId;
  create_native_name: TIdentifier;
  create_native_version: TVersionSpec;
begin
  result := true;
  if req.op_name = '_get_members' then
    begin
      req.set_result(StaticAny(StructMember_seq_marshaller,@members_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      members_get_value := _get_members;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_members' then
    begin
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@members_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_members(members_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'lookup' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_search_name) as IStaticAny);
      req.set_result(StaticAny(Contained_marshaller,@lookup_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_result := lookup(lookup_search_name);
      req.write_results();
      exit;
    end
  else if req.op_name = 'contents' then
    begin
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@contents_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@contents_exclude_inherited) as IStaticAny);
      req.set_result(StaticAny(Contained_seq_marshaller,@contents_result) as IStaticAny);
      if not req.read_args() then  exit;
      contents_result := contents(contents_limit_type, contents_exclude_inherited);
      req.write_results();
      exit;
    end
  else if req.op_name = 'lookup_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_name_search_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_long,@lookup_name_levels_to_search) as IStaticAny);
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@lookup_name_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@lookup_name_exclude_inherited) as IStaticAny);
      req.set_result(StaticAny(Contained_seq_marshaller,@lookup_name_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_name_result := lookup_name(lookup_name_search_name, lookup_name_levels_to_search, lookup_name_limit_type, lookup_name_exclude_inherited);
      req.write_results();
      exit;
    end
  else if req.op_name = 'describe_contents' then
    begin
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@describe_contents_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@describe_contents_exclude_inherited) as IStaticAny);
      req.add_in_arg(StaticAny(stat_long,@describe_contents_max_returned_objs) as IStaticAny);
      req.set_result(StaticAny(Description_seq_marshaller,@describe_contents_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_contents_result := describe_contents(describe_contents_limit_type, describe_contents_exclude_inherited, describe_contents_max_returned_objs);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_module' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_module_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_module_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_module_version) as IStaticAny);
      req.set_result(StaticAny(ModuleDef_marshaller,@create_module_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_module_result := create_module(create_module_id, create_module_name, create_module_version);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_constant' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_constant_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_constant_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_constant_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_constant_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_any,@create_constant_value) as IStaticAny);
      req.set_result(StaticAny(ConstantDef_marshaller,@create_constant_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_constant_result := create_constant(create_constant_id, create_constant_name, create_constant_version, create_constant_type, create_constant_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_struct' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_struct_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_struct_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_struct_version) as IStaticAny);
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@create_struct_members) as IStaticAny);
      req.set_result(StaticAny(StructDef_marshaller,@create_struct_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_struct_result := create_struct(create_struct_id, create_struct_name, create_struct_version, create_struct_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_exception' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_exception_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_exception_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_exception_version) as IStaticAny);
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@create_exception_members) as IStaticAny);
      req.set_result(StaticAny(ExceptionDef_marshaller,@create_exception_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_exception_result := create_exception(create_exception_id, create_exception_name, create_exception_version, create_exception_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_union' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_union_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_union_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_union_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_union_discriminator_type) as IStaticAny);
      req.add_in_arg(StaticAny(UnionMember_seq_marshaller,@create_union_members) as IStaticAny);
      req.set_result(StaticAny(UnionDef_marshaller,@create_union_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_union_result := create_union(create_union_id, create_union_name, create_union_version, create_union_discriminator_type, create_union_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_enum' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_enum_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_enum_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_enum_version) as IStaticAny);
      req.add_in_arg(StaticAny(stat_seq_string,@create_enum_members) as IStaticAny);
      req.set_result(StaticAny(EnumDef_marshaller,@create_enum_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_enum_result := create_enum(create_enum_id, create_enum_name, create_enum_version, create_enum_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_alias' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_alias_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_alias_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_alias_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_alias_original_type) as IStaticAny);
      req.set_result(StaticAny(AliasDef_marshaller,@create_alias_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_alias_result := create_alias(create_alias_id, create_alias_name, create_alias_version, create_alias_original_type);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(InterfaceDef_marshaller,@create_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_interface_result := create_interface(create_interface_id, create_interface_name, create_interface_version, create_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_abstract_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(AbstractInterfaceDef_seq_marshaller,@create_abstract_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(AbstractInterfaceDef_marshaller,@create_abstract_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_abstract_interface_result := create_abstract_interface(create_abstract_interface_id, create_abstract_interface_name, create_abstract_interface_version, create_abstract_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_local_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_local_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(LocalInterfaceDef_marshaller,@create_local_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_local_interface_result := create_local_interface(create_local_interface_id, create_local_interface_name, create_local_interface_version, create_local_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_version) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_custom) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_abstract) as IStaticAny);
      req.add_in_arg(StaticAny(ValueDef_marshaller,@create_value_base_value) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_truncatable) as IStaticAny);
      req.add_in_arg(StaticAny(ValueDef_seq_marshaller,@create_value_abstract_base_values) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_value_supported_interfaces) as IStaticAny);
      req.add_in_arg(StaticAny(Initializer_seq_marshaller,@create_value_initializers) as IStaticAny);
      req.set_result(StaticAny(ValueDef_marshaller,@create_value_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_result := create_value(create_value_id, create_value_name, create_value_version, create_value_is_custom, create_value_is_abstract, create_value_base_value, create_value_is_truncatable, create_value_abstract_base_values, create_value_supported_interfaces, create_value_initializers);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value_box' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_box_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_box_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_box_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_value_box_original_type_def) as IStaticAny);
      req.set_result(StaticAny(ValueBoxDef_marshaller,@create_value_box_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_box_result := create_value_box(create_value_box_id, create_value_box_name, create_value_box_version, create_value_box_original_type_def);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_native' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_native_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_native_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_native_version) as IStaticAny);
      req.set_result(StaticAny(NativeDef_marshaller,@create_native_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_native_result := create_native(create_native_id, create_native_name, create_native_version);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TStructDef_marshaller
//***********************************************************
function TStructDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IStructDef(addr^) := TStructDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TStructDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IStructDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TStructDef_marshaller._free(var addr: Pointer);
begin
  IStructDef(addr^) := nil;
end;

procedure TStructDef_marshaller._create(var addr: Pointer);
begin
  IStructDef(addr^) := TStructDef_stub.Create();
end;

procedure TStructDef_marshaller._assign(dst, src: Pointer);
begin
  IStructDef(dst^) := IStructDef(src^);
end;

function TStructDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_StructDef.typecode;
end;

//***********************************************************
// TUnionDef
//***********************************************************
function TUnionDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/UnionDef:1.0' then
    begin
      result := Pointer(self as IUnionDef);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TUnionDef._narrow(const obj : IORBObject): IUnionDef;
var
  p: Pointer;
  stub: TUnionDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/UnionDef:1.0');
  if p <> nil then
    result := IUnionDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/UnionDef:1.0') then
        begin
          stub := TUnionDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TUnionDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/UnionDef:1.0'
end;

//***********************************************************
// TUnionDef_stub
//***********************************************************
function TUnionDef_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TUnionDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TUnionDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TUnionDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TUnionDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TUnionDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TUnionDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_discriminator_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_discriminator_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TUnionDef_stub._set_discriminator_type_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_discriminator_type_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_discriminator_type_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_discriminator_type_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TUnionDef_stub._set_members(const val: TUnionMemberSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(UnionMember_seq_marshaller,@val);
  req := StaticRequest(self,'_set_members');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TUnionDef_stub._get_members: TUnionMemberSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(UnionMember_seq_marshaller, @result);
  req := StaticRequest(self,'_get_members');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TUnionDef_stub_clp
//***********************************************************
function TUnionDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/UnionDef:1.0' then
    begin
      result := Pointer(self as IUnionDef);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TUnionDef_stub_clp.lookup(const search_name: TScopedName): IContained;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup(search_name)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.contents(limit_type, exclude_inherited)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup_name(search_name, levels_to_search, limit_type, exclude_inherited)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe_contents(limit_type, exclude_inherited, max_returned_objs)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_module(id, name, version)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_constant(id, name, version, _type, value)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_struct(id, name, version, members)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_exception(id, name, version, members)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_union(id, name, version, discriminator_type, members)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_enum(id, name, version, members)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_alias(id, name, version, original_type)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_abstract_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_local_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value(id, name, version, is_custom, is_abstract, base_value, is_truncatable, abstract_base_values, supported_interfaces, initializers)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value_box(id, name, version, original_type_def)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_native(id, name, version)
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp._get_discriminator_type: ITypeCode;
var
  _srv: IServant;
  srv: IUnionDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TUnionDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_discriminator_type
    end;
  _postinvoke();
end;

procedure TUnionDef_stub_clp._set_discriminator_type_def(const val: IIDLType);
var
  _srv: IServant;
  srv: IUnionDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TUnionDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_discriminator_type_def(val);
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp._get_discriminator_type_def: IIDLType;
var
  _srv: IServant;
  srv: IUnionDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TUnionDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_discriminator_type_def
    end;
  _postinvoke();
end;

procedure TUnionDef_stub_clp._set_members(const val: TUnionMemberSeq);
var
  _srv: IServant;
  srv: IUnionDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TUnionDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_members(val);
    end;
  _postinvoke();
end;

function TUnionDef_stub_clp._get_members: TUnionMemberSeq;
var
  _srv: IServant;
  srv: IUnionDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TUnionDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_members
    end;
  _postinvoke();
end;

//***********************************************************
// TUnionDef_serv
//***********************************************************
function TUnionDef_serv._this(): IUnionDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TUnionDef._narrow(obj);
end;

function TUnionDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/UnionDef:1.0';
  if repoid = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := true;
      exit;
    end;
  if not result then
    result := inherited _is_a(repoid);
end;

function TUnionDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/UnionDef:1.0';
end;

function TUnionDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TUnionDef_stub_clp.Create(poa,obj);
end;

procedure TUnionDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TUnionDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/UnionDef:1.0' then
    begin
      result := Pointer(IUnionDef(self));
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TUnionDef_serv._narrow(const srv : IServant): IUnionDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/UnionDef:1.0');
  if p <> nil then
    result := IUnionDef(p)
end;

function TUnionDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  discriminator_type_get_value: ITypeCode;
  discriminator_type_def_get_value: IIDLType;
  discriminator_type_def_set_value: IIDLType;
  members_get_value: TUnionMemberSeq;
  members_set_value: TUnionMemberSeq;
  lookup_result: IContained;
  lookup_search_name: TScopedName;
  contents_result: TContainedSeq;
  contents_limit_type: TDefinitionKind;
  contents_exclude_inherited: Boolean;
  lookup_name_result: TContainedSeq;
  lookup_name_search_name: TIdentifier;
  lookup_name_levels_to_search: long;
  lookup_name_limit_type: TDefinitionKind;
  lookup_name_exclude_inherited: Boolean;
  describe_contents_result: TDescriptionSeq;
  describe_contents_limit_type: TDefinitionKind;
  describe_contents_exclude_inherited: Boolean;
  describe_contents_max_returned_objs: long;
  create_module_result: IModuleDef;
  create_module_id: TRepositoryId;
  create_module_name: TIdentifier;
  create_module_version: TVersionSpec;
  create_constant_result: IConstantDef;
  create_constant_id: TRepositoryId;
  create_constant_name: TIdentifier;
  create_constant_version: TVersionSpec;
  create_constant_type: IIDLType;
  create_constant_value: IAny;
  create_struct_result: IStructDef;
  create_struct_id: TRepositoryId;
  create_struct_name: TIdentifier;
  create_struct_version: TVersionSpec;
  create_struct_members: TStructMemberSeq;
  create_exception_result: IExceptionDef;
  create_exception_id: TRepositoryId;
  create_exception_name: TIdentifier;
  create_exception_version: TVersionSpec;
  create_exception_members: TStructMemberSeq;
  create_union_result: IUnionDef;
  create_union_id: TRepositoryId;
  create_union_name: TIdentifier;
  create_union_version: TVersionSpec;
  create_union_discriminator_type: IIDLType;
  create_union_members: TUnionMemberSeq;
  create_enum_result: IEnumDef;
  create_enum_id: TRepositoryId;
  create_enum_name: TIdentifier;
  create_enum_version: TVersionSpec;
  create_enum_members: TEnumMemberSeq;
  create_alias_result: IAliasDef;
  create_alias_id: TRepositoryId;
  create_alias_name: TIdentifier;
  create_alias_version: TVersionSpec;
  create_alias_original_type: IIDLType;
  create_interface_result: IInterfaceDef;
  create_interface_id: TRepositoryId;
  create_interface_name: TIdentifier;
  create_interface_version: TVersionSpec;
  create_interface_base_interfaces: TInterfaceDefSeq;
  create_abstract_interface_result: IAbstractInterfaceDef;
  create_abstract_interface_id: TRepositoryId;
  create_abstract_interface_name: TIdentifier;
  create_abstract_interface_version: TVersionSpec;
  create_abstract_interface_base_interfaces: TAbstractInterfaceDefSeq;
  create_local_interface_result: ILocalInterfaceDef;
  create_local_interface_id: TRepositoryId;
  create_local_interface_name: TIdentifier;
  create_local_interface_version: TVersionSpec;
  create_local_interface_base_interfaces: TInterfaceDefSeq;
  create_value_result: IValueDef;
  create_value_id: TRepositoryId;
  create_value_name: TIdentifier;
  create_value_version: TVersionSpec;
  create_value_is_custom: Boolean;
  create_value_is_abstract: Boolean;
  create_value_base_value: IValueDef;
  create_value_is_truncatable: Boolean;
  create_value_abstract_base_values: TValueDefSeq;
  create_value_supported_interfaces: TInterfaceDefSeq;
  create_value_initializers: TInitializerSeq;
  create_value_box_result: IValueBoxDef;
  create_value_box_id: TRepositoryId;
  create_value_box_name: TIdentifier;
  create_value_box_version: TVersionSpec;
  create_value_box_original_type_def: IIDLType;
  create_native_result: INativeDef;
  create_native_id: TRepositoryId;
  create_native_name: TIdentifier;
  create_native_version: TVersionSpec;
begin
  result := true;
  if req.op_name = '_get_discriminator_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@discriminator_type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      discriminator_type_get_value := _get_discriminator_type;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_discriminator_type_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@discriminator_type_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      discriminator_type_def_get_value := _get_discriminator_type_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_discriminator_type_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@discriminator_type_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_discriminator_type_def(discriminator_type_def_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_members' then
    begin
      req.set_result(StaticAny(UnionMember_seq_marshaller,@members_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      members_get_value := _get_members;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_members' then
    begin
      req.add_in_arg(StaticAny(UnionMember_seq_marshaller,@members_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_members(members_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'lookup' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_search_name) as IStaticAny);
      req.set_result(StaticAny(Contained_marshaller,@lookup_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_result := lookup(lookup_search_name);
      req.write_results();
      exit;
    end
  else if req.op_name = 'contents' then
    begin
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@contents_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@contents_exclude_inherited) as IStaticAny);
      req.set_result(StaticAny(Contained_seq_marshaller,@contents_result) as IStaticAny);
      if not req.read_args() then  exit;
      contents_result := contents(contents_limit_type, contents_exclude_inherited);
      req.write_results();
      exit;
    end
  else if req.op_name = 'lookup_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_name_search_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_long,@lookup_name_levels_to_search) as IStaticAny);
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@lookup_name_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@lookup_name_exclude_inherited) as IStaticAny);
      req.set_result(StaticAny(Contained_seq_marshaller,@lookup_name_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_name_result := lookup_name(lookup_name_search_name, lookup_name_levels_to_search, lookup_name_limit_type, lookup_name_exclude_inherited);
      req.write_results();
      exit;
    end
  else if req.op_name = 'describe_contents' then
    begin
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@describe_contents_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@describe_contents_exclude_inherited) as IStaticAny);
      req.add_in_arg(StaticAny(stat_long,@describe_contents_max_returned_objs) as IStaticAny);
      req.set_result(StaticAny(Description_seq_marshaller,@describe_contents_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_contents_result := describe_contents(describe_contents_limit_type, describe_contents_exclude_inherited, describe_contents_max_returned_objs);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_module' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_module_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_module_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_module_version) as IStaticAny);
      req.set_result(StaticAny(ModuleDef_marshaller,@create_module_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_module_result := create_module(create_module_id, create_module_name, create_module_version);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_constant' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_constant_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_constant_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_constant_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_constant_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_any,@create_constant_value) as IStaticAny);
      req.set_result(StaticAny(ConstantDef_marshaller,@create_constant_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_constant_result := create_constant(create_constant_id, create_constant_name, create_constant_version, create_constant_type, create_constant_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_struct' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_struct_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_struct_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_struct_version) as IStaticAny);
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@create_struct_members) as IStaticAny);
      req.set_result(StaticAny(StructDef_marshaller,@create_struct_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_struct_result := create_struct(create_struct_id, create_struct_name, create_struct_version, create_struct_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_exception' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_exception_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_exception_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_exception_version) as IStaticAny);
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@create_exception_members) as IStaticAny);
      req.set_result(StaticAny(ExceptionDef_marshaller,@create_exception_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_exception_result := create_exception(create_exception_id, create_exception_name, create_exception_version, create_exception_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_union' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_union_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_union_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_union_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_union_discriminator_type) as IStaticAny);
      req.add_in_arg(StaticAny(UnionMember_seq_marshaller,@create_union_members) as IStaticAny);
      req.set_result(StaticAny(UnionDef_marshaller,@create_union_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_union_result := create_union(create_union_id, create_union_name, create_union_version, create_union_discriminator_type, create_union_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_enum' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_enum_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_enum_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_enum_version) as IStaticAny);
      req.add_in_arg(StaticAny(stat_seq_string,@create_enum_members) as IStaticAny);
      req.set_result(StaticAny(EnumDef_marshaller,@create_enum_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_enum_result := create_enum(create_enum_id, create_enum_name, create_enum_version, create_enum_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_alias' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_alias_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_alias_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_alias_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_alias_original_type) as IStaticAny);
      req.set_result(StaticAny(AliasDef_marshaller,@create_alias_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_alias_result := create_alias(create_alias_id, create_alias_name, create_alias_version, create_alias_original_type);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(InterfaceDef_marshaller,@create_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_interface_result := create_interface(create_interface_id, create_interface_name, create_interface_version, create_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_abstract_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(AbstractInterfaceDef_seq_marshaller,@create_abstract_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(AbstractInterfaceDef_marshaller,@create_abstract_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_abstract_interface_result := create_abstract_interface(create_abstract_interface_id, create_abstract_interface_name, create_abstract_interface_version, create_abstract_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_local_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_local_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(LocalInterfaceDef_marshaller,@create_local_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_local_interface_result := create_local_interface(create_local_interface_id, create_local_interface_name, create_local_interface_version, create_local_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_version) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_custom) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_abstract) as IStaticAny);
      req.add_in_arg(StaticAny(ValueDef_marshaller,@create_value_base_value) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_truncatable) as IStaticAny);
      req.add_in_arg(StaticAny(ValueDef_seq_marshaller,@create_value_abstract_base_values) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_value_supported_interfaces) as IStaticAny);
      req.add_in_arg(StaticAny(Initializer_seq_marshaller,@create_value_initializers) as IStaticAny);
      req.set_result(StaticAny(ValueDef_marshaller,@create_value_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_result := create_value(create_value_id, create_value_name, create_value_version, create_value_is_custom, create_value_is_abstract, create_value_base_value, create_value_is_truncatable, create_value_abstract_base_values, create_value_supported_interfaces, create_value_initializers);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value_box' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_box_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_box_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_box_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_value_box_original_type_def) as IStaticAny);
      req.set_result(StaticAny(ValueBoxDef_marshaller,@create_value_box_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_box_result := create_value_box(create_value_box_id, create_value_box_name, create_value_box_version, create_value_box_original_type_def);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_native' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_native_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_native_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_native_version) as IStaticAny);
      req.set_result(StaticAny(NativeDef_marshaller,@create_native_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_native_result := create_native(create_native_id, create_native_name, create_native_version);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TUnionDef_marshaller
//***********************************************************
function TUnionDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IUnionDef(addr^) := TUnionDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TUnionDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IUnionDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TUnionDef_marshaller._free(var addr: Pointer);
begin
  IUnionDef(addr^) := nil;
end;

procedure TUnionDef_marshaller._create(var addr: Pointer);
begin
  IUnionDef(addr^) := TUnionDef_stub.Create();
end;

procedure TUnionDef_marshaller._assign(dst, src: Pointer);
begin
  IUnionDef(dst^) := IUnionDef(src^);
end;

function TUnionDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_UnionDef.typecode;
end;

//***********************************************************
// TEnumDef
//***********************************************************
function TEnumDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/EnumDef:1.0' then
    begin
      result := Pointer(self as IEnumDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TEnumDef._narrow(const obj : IORBObject): IEnumDef;
var
  p: Pointer;
  stub: TEnumDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/EnumDef:1.0');
  if p <> nil then
    result := IEnumDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/EnumDef:1.0') then
        begin
          stub := TEnumDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TEnumDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/EnumDef:1.0'
end;

//***********************************************************
// TEnumDef_stub
//***********************************************************
function TEnumDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TEnumDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TEnumDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TEnumDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TEnumDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TEnumDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TEnumDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TEnumDef_stub._set_members(const val: TEnumMemberSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_seq_string,@val);
  req := StaticRequest(self,'_set_members');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TEnumDef_stub._get_members: TEnumMemberSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_seq_string, @result);
  req := StaticRequest(self,'_get_members');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TEnumDef_stub_clp
//***********************************************************
function TEnumDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/EnumDef:1.0' then
    begin
      result := Pointer(self as IEnumDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TEnumDef_stub_clp._set_members(const val: TEnumMemberSeq);
var
  _srv: IServant;
  srv: IEnumDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TEnumDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_members(val);
    end;
  _postinvoke();
end;

function TEnumDef_stub_clp._get_members: TEnumMemberSeq;
var
  _srv: IServant;
  srv: IEnumDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TEnumDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_members
    end;
  _postinvoke();
end;

//***********************************************************
// TEnumDef_serv
//***********************************************************
function TEnumDef_serv._this(): IEnumDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TEnumDef._narrow(obj);
end;

function TEnumDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/EnumDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TEnumDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/EnumDef:1.0';
end;

function TEnumDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TEnumDef_stub_clp.Create(poa,obj);
end;

procedure TEnumDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TEnumDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/EnumDef:1.0' then
    begin
      result := Pointer(IEnumDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TEnumDef_serv._narrow(const srv : IServant): IEnumDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/EnumDef:1.0');
  if p <> nil then
    result := IEnumDef(p)
end;

function TEnumDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  members_get_value: TEnumMemberSeq;
  members_set_value: TEnumMemberSeq;
begin
  result := true;
  if req.op_name = '_get_members' then
    begin
      req.set_result(StaticAny(stat_seq_string,@members_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      members_get_value := _get_members;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_members' then
    begin
      req.add_in_arg(StaticAny(stat_seq_string,@members_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_members(members_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TEnumDef_marshaller
//***********************************************************
function TEnumDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IEnumDef(addr^) := TEnumDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TEnumDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IEnumDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TEnumDef_marshaller._free(var addr: Pointer);
begin
  IEnumDef(addr^) := nil;
end;

procedure TEnumDef_marshaller._create(var addr: Pointer);
begin
  IEnumDef(addr^) := TEnumDef_stub.Create();
end;

procedure TEnumDef_marshaller._assign(dst, src: Pointer);
begin
  IEnumDef(dst^) := IEnumDef(src^);
end;

function TEnumDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_EnumDef.typecode;
end;

//***********************************************************
// TAliasDef
//***********************************************************
function TAliasDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AliasDef:1.0' then
    begin
      result := Pointer(self as IAliasDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TAliasDef._narrow(const obj : IORBObject): IAliasDef;
var
  p: Pointer;
  stub: TAliasDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/AliasDef:1.0');
  if p <> nil then
    result := IAliasDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/AliasDef:1.0') then
        begin
          stub := TAliasDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TAliasDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/AliasDef:1.0'
end;

//***********************************************************
// TAliasDef_stub
//***********************************************************
function TAliasDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAliasDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAliasDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAliasDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAliasDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAliasDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAliasDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAliasDef_stub._set_original_type_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_original_type_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAliasDef_stub._get_original_type_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_original_type_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TAliasDef_stub_clp
//***********************************************************
function TAliasDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AliasDef:1.0' then
    begin
      result := Pointer(self as IAliasDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TAliasDef_stub_clp._set_original_type_def(const val: IIDLType);
var
  _srv: IServant;
  srv: IAliasDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TAliasDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_original_type_def(val);
    end;
  _postinvoke();
end;

function TAliasDef_stub_clp._get_original_type_def: IIDLType;
var
  _srv: IServant;
  srv: IAliasDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TAliasDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_original_type_def
    end;
  _postinvoke();
end;

//***********************************************************
// TAliasDef_serv
//***********************************************************
function TAliasDef_serv._this(): IAliasDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TAliasDef._narrow(obj);
end;

function TAliasDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/AliasDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TAliasDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/AliasDef:1.0';
end;

function TAliasDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TAliasDef_stub_clp.Create(poa,obj);
end;

procedure TAliasDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TAliasDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AliasDef:1.0' then
    begin
      result := Pointer(IAliasDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TAliasDef_serv._narrow(const srv : IServant): IAliasDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/AliasDef:1.0');
  if p <> nil then
    result := IAliasDef(p)
end;

function TAliasDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  original_type_def_get_value: IIDLType;
  original_type_def_set_value: IIDLType;
begin
  result := true;
  if req.op_name = '_get_original_type_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@original_type_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      original_type_def_get_value := _get_original_type_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_original_type_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@original_type_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_original_type_def(original_type_def_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TAliasDef_marshaller
//***********************************************************
function TAliasDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IAliasDef(addr^) := TAliasDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TAliasDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IAliasDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TAliasDef_marshaller._free(var addr: Pointer);
begin
  IAliasDef(addr^) := nil;
end;

procedure TAliasDef_marshaller._create(var addr: Pointer);
begin
  IAliasDef(addr^) := TAliasDef_stub.Create();
end;

procedure TAliasDef_marshaller._assign(dst, src: Pointer);
begin
  IAliasDef(dst^) := IAliasDef(src^);
end;

function TAliasDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_AliasDef.typecode;
end;

//***********************************************************
// TNativeDef
//***********************************************************
function TNativeDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/NativeDef:1.0' then
    begin
      result := Pointer(self as INativeDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TNativeDef._narrow(const obj : IORBObject): INativeDef;
var
  p: Pointer;
  stub: TNativeDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/NativeDef:1.0');
  if p <> nil then
    result := INativeDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/NativeDef:1.0') then
        begin
          stub := TNativeDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TNativeDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/NativeDef:1.0'
end;

//***********************************************************
// TNativeDef_stub
//***********************************************************
function TNativeDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TNativeDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TNativeDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TNativeDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TNativeDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TNativeDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TNativeDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TNativeDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TNativeDef_stub_clp
//***********************************************************
function TNativeDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/NativeDef:1.0' then
    begin
      result := Pointer(self as INativeDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

//***********************************************************
// TNativeDef_serv
//***********************************************************
function TNativeDef_serv._this(): INativeDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TNativeDef._narrow(obj);
end;

function TNativeDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/NativeDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TNativeDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/NativeDef:1.0';
end;

function TNativeDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TNativeDef_stub_clp.Create(poa,obj);
end;

procedure TNativeDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TNativeDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/NativeDef:1.0' then
    begin
      result := Pointer(INativeDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TNativeDef_serv._narrow(const srv : IServant): INativeDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/NativeDef:1.0');
  if p <> nil then
    result := INativeDef(p)
end;

function TNativeDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TNativeDef_marshaller
//***********************************************************
function TNativeDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  INativeDef(addr^) := TNativeDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TNativeDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := INativeDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TNativeDef_marshaller._free(var addr: Pointer);
begin
  INativeDef(addr^) := nil;
end;

procedure TNativeDef_marshaller._create(var addr: Pointer);
begin
  INativeDef(addr^) := TNativeDef_stub.Create();
end;

procedure TNativeDef_marshaller._assign(dst, src: Pointer);
begin
  INativeDef(dst^) := INativeDef(src^);
end;

function TNativeDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_NativeDef.typecode;
end;

//***********************************************************
// TPrimitiveDef
//***********************************************************
function TPrimitiveDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/PrimitiveDef:1.0' then
    begin
      result := Pointer(self as IPrimitiveDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TPrimitiveDef._narrow(const obj : IORBObject): IPrimitiveDef;
var
  p: Pointer;
  stub: TPrimitiveDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/PrimitiveDef:1.0');
  if p <> nil then
    result := IPrimitiveDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/PrimitiveDef:1.0') then
        begin
          stub := TPrimitiveDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TPrimitiveDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/PrimitiveDef:1.0'
end;

//***********************************************************
// TPrimitiveDef_stub
//***********************************************************
function TPrimitiveDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TPrimitiveDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TPrimitiveDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TPrimitiveDef_stub._get_kind: TPrimitiveKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(PrimitiveKind_marshaller, @result);
  req := StaticRequest(self,'_get_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TPrimitiveDef_stub_clp
//***********************************************************
function TPrimitiveDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/PrimitiveDef:1.0' then
    begin
      result := Pointer(self as IPrimitiveDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TPrimitiveDef_stub_clp._get_kind: TPrimitiveKind;
var
  _srv: IServant;
  srv: IPrimitiveDef;
begin
  result := pk_null;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPrimitiveDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_kind
    end;
  _postinvoke();
end;

//***********************************************************
// TPrimitiveDef_serv
//***********************************************************
function TPrimitiveDef_serv._this(): IPrimitiveDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TPrimitiveDef._narrow(obj);
end;

function TPrimitiveDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/PrimitiveDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TPrimitiveDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/PrimitiveDef:1.0';
end;

function TPrimitiveDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TPrimitiveDef_stub_clp.Create(poa,obj);
end;

procedure TPrimitiveDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TPrimitiveDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/PrimitiveDef:1.0' then
    begin
      result := Pointer(IPrimitiveDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TPrimitiveDef_serv._narrow(const srv : IServant): IPrimitiveDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/PrimitiveDef:1.0');
  if p <> nil then
    result := IPrimitiveDef(p)
end;

function TPrimitiveDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  kind_get_value: TPrimitiveKind;
begin
  result := true;
  if req.op_name = '_get_kind' then
    begin
      req.set_result(StaticAny(PrimitiveKind_marshaller,@kind_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      kind_get_value := _get_kind;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TPrimitiveDef_marshaller
//***********************************************************
function TPrimitiveDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IPrimitiveDef(addr^) := TPrimitiveDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TPrimitiveDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IPrimitiveDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TPrimitiveDef_marshaller._free(var addr: Pointer);
begin
  IPrimitiveDef(addr^) := nil;
end;

procedure TPrimitiveDef_marshaller._create(var addr: Pointer);
begin
  IPrimitiveDef(addr^) := TPrimitiveDef_stub.Create();
end;

procedure TPrimitiveDef_marshaller._assign(dst, src: Pointer);
begin
  IPrimitiveDef(dst^) := IPrimitiveDef(src^);
end;

function TPrimitiveDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_PrimitiveDef.typecode;
end;

//***********************************************************
// TStringDef
//***********************************************************
function TStringDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/StringDef:1.0' then
    begin
      result := Pointer(self as IStringDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TStringDef._narrow(const obj : IORBObject): IStringDef;
var
  p: Pointer;
  stub: TStringDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/StringDef:1.0');
  if p <> nil then
    result := IStringDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/StringDef:1.0') then
        begin
          stub := TStringDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TStringDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/StringDef:1.0'
end;

//***********************************************************
// TStringDef_stub
//***********************************************************
function TStringDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStringDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TStringDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TStringDef_stub._set_bound(const val: _ulong);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_ulong,@val);
  req := StaticRequest(self,'_set_bound');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TStringDef_stub._get_bound: _ulong;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulong, @result);
  req := StaticRequest(self,'_get_bound');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TStringDef_stub_clp
//***********************************************************
function TStringDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/StringDef:1.0' then
    begin
      result := Pointer(self as IStringDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TStringDef_stub_clp._set_bound(const val: _ulong);
var
  _srv: IServant;
  srv: IStringDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TStringDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_bound(val);
    end;
  _postinvoke();
end;

function TStringDef_stub_clp._get_bound: _ulong;
var
  _srv: IServant;
  srv: IStringDef;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TStringDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_bound
    end;
  _postinvoke();
end;

//***********************************************************
// TStringDef_serv
//***********************************************************
function TStringDef_serv._this(): IStringDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TStringDef._narrow(obj);
end;

function TStringDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/StringDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TStringDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/StringDef:1.0';
end;

function TStringDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TStringDef_stub_clp.Create(poa,obj);
end;

procedure TStringDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TStringDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/StringDef:1.0' then
    begin
      result := Pointer(IStringDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TStringDef_serv._narrow(const srv : IServant): IStringDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/StringDef:1.0');
  if p <> nil then
    result := IStringDef(p)
end;

function TStringDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  bound_get_value: _ulong;
  bound_set_value: _ulong;
begin
  result := true;
  if req.op_name = '_get_bound' then
    begin
      req.set_result(StaticAny(stat_ulong,@bound_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      bound_get_value := _get_bound;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_bound' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@bound_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_bound(bound_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TStringDef_marshaller
//***********************************************************
function TStringDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IStringDef(addr^) := TStringDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TStringDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IStringDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TStringDef_marshaller._free(var addr: Pointer);
begin
  IStringDef(addr^) := nil;
end;

procedure TStringDef_marshaller._create(var addr: Pointer);
begin
  IStringDef(addr^) := TStringDef_stub.Create();
end;

procedure TStringDef_marshaller._assign(dst, src: Pointer);
begin
  IStringDef(dst^) := IStringDef(src^);
end;

function TStringDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_StringDef.typecode;
end;

//***********************************************************
// TWstringDef
//***********************************************************
function TWstringDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/WstringDef:1.0' then
    begin
      result := Pointer(self as IWstringDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TWstringDef._narrow(const obj : IORBObject): IWstringDef;
var
  p: Pointer;
  stub: TWstringDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/WstringDef:1.0');
  if p <> nil then
    result := IWstringDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/WstringDef:1.0') then
        begin
          stub := TWstringDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TWstringDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/WstringDef:1.0'
end;

//***********************************************************
// TWstringDef_stub
//***********************************************************
function TWstringDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TWstringDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TWstringDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TWstringDef_stub._set_bound(const val: _ulong);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_ulong,@val);
  req := StaticRequest(self,'_set_bound');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TWstringDef_stub._get_bound: _ulong;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulong, @result);
  req := StaticRequest(self,'_get_bound');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TWstringDef_stub_clp
//***********************************************************
function TWstringDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/WstringDef:1.0' then
    begin
      result := Pointer(self as IWstringDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TWstringDef_stub_clp._set_bound(const val: _ulong);
var
  _srv: IServant;
  srv: IWstringDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TWstringDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_bound(val);
    end;
  _postinvoke();
end;

function TWstringDef_stub_clp._get_bound: _ulong;
var
  _srv: IServant;
  srv: IWstringDef;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TWstringDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_bound
    end;
  _postinvoke();
end;

//***********************************************************
// TWstringDef_serv
//***********************************************************
function TWstringDef_serv._this(): IWstringDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TWstringDef._narrow(obj);
end;

function TWstringDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/WstringDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TWstringDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/WstringDef:1.0';
end;

function TWstringDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TWstringDef_stub_clp.Create(poa,obj);
end;

procedure TWstringDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TWstringDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/WstringDef:1.0' then
    begin
      result := Pointer(IWstringDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TWstringDef_serv._narrow(const srv : IServant): IWstringDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/WstringDef:1.0');
  if p <> nil then
    result := IWstringDef(p)
end;

function TWstringDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  bound_get_value: _ulong;
  bound_set_value: _ulong;
begin
  result := true;
  if req.op_name = '_get_bound' then
    begin
      req.set_result(StaticAny(stat_ulong,@bound_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      bound_get_value := _get_bound;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_bound' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@bound_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_bound(bound_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TWstringDef_marshaller
//***********************************************************
function TWstringDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IWstringDef(addr^) := TWstringDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TWstringDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IWstringDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TWstringDef_marshaller._free(var addr: Pointer);
begin
  IWstringDef(addr^) := nil;
end;

procedure TWstringDef_marshaller._create(var addr: Pointer);
begin
  IWstringDef(addr^) := TWstringDef_stub.Create();
end;

procedure TWstringDef_marshaller._assign(dst, src: Pointer);
begin
  IWstringDef(dst^) := IWstringDef(src^);
end;

function TWstringDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_WstringDef.typecode;
end;

//***********************************************************
// TFixedDef
//***********************************************************
function TFixedDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/FixedDef:1.0' then
    begin
      result := Pointer(self as IFixedDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TFixedDef._narrow(const obj : IORBObject): IFixedDef;
var
  p: Pointer;
  stub: TFixedDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/FixedDef:1.0');
  if p <> nil then
    result := IFixedDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/FixedDef:1.0') then
        begin
          stub := TFixedDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TFixedDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/FixedDef:1.0'
end;

//***********************************************************
// TFixedDef_stub
//***********************************************************
function TFixedDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TFixedDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TFixedDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TFixedDef_stub._set_digits(const val: _ushort);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_ushort,@val);
  req := StaticRequest(self,'_set_digits');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TFixedDef_stub._get_digits: _ushort;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ushort, @result);
  req := StaticRequest(self,'_get_digits');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TFixedDef_stub._set_scale(const val: Short);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_short,@val);
  req := StaticRequest(self,'_set_scale');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TFixedDef_stub._get_scale: Short;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_short, @result);
  req := StaticRequest(self,'_get_scale');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TFixedDef_stub_clp
//***********************************************************
function TFixedDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/FixedDef:1.0' then
    begin
      result := Pointer(self as IFixedDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TFixedDef_stub_clp._set_digits(const val: _ushort);
var
  _srv: IServant;
  srv: IFixedDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TFixedDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_digits(val);
    end;
  _postinvoke();
end;

function TFixedDef_stub_clp._get_digits: _ushort;
var
  _srv: IServant;
  srv: IFixedDef;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TFixedDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_digits
    end;
  _postinvoke();
end;

procedure TFixedDef_stub_clp._set_scale(const val: Short);
var
  _srv: IServant;
  srv: IFixedDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TFixedDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_scale(val);
    end;
  _postinvoke();
end;

function TFixedDef_stub_clp._get_scale: Short;
var
  _srv: IServant;
  srv: IFixedDef;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TFixedDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_scale
    end;
  _postinvoke();
end;

//***********************************************************
// TFixedDef_serv
//***********************************************************
function TFixedDef_serv._this(): IFixedDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TFixedDef._narrow(obj);
end;

function TFixedDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/FixedDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TFixedDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/FixedDef:1.0';
end;

function TFixedDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TFixedDef_stub_clp.Create(poa,obj);
end;

procedure TFixedDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TFixedDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/FixedDef:1.0' then
    begin
      result := Pointer(IFixedDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TFixedDef_serv._narrow(const srv : IServant): IFixedDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/FixedDef:1.0');
  if p <> nil then
    result := IFixedDef(p)
end;

function TFixedDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  digits_get_value: _ushort;
  digits_set_value: _ushort;
  scale_get_value: Short;
  scale_set_value: Short;
begin
  result := true;
  if req.op_name = '_get_digits' then
    begin
      req.set_result(StaticAny(stat_ushort,@digits_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      digits_get_value := _get_digits;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_digits' then
    begin
      req.add_in_arg(StaticAny(stat_ushort,@digits_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_digits(digits_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_scale' then
    begin
      req.set_result(StaticAny(stat_short,@scale_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      scale_get_value := _get_scale;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_scale' then
    begin
      req.add_in_arg(StaticAny(stat_short,@scale_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_scale(scale_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TFixedDef_marshaller
//***********************************************************
function TFixedDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IFixedDef(addr^) := TFixedDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TFixedDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IFixedDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TFixedDef_marshaller._free(var addr: Pointer);
begin
  IFixedDef(addr^) := nil;
end;

procedure TFixedDef_marshaller._create(var addr: Pointer);
begin
  IFixedDef(addr^) := TFixedDef_stub.Create();
end;

procedure TFixedDef_marshaller._assign(dst, src: Pointer);
begin
  IFixedDef(dst^) := IFixedDef(src^);
end;

function TFixedDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_FixedDef.typecode;
end;

//***********************************************************
// TSequenceDef
//***********************************************************
function TSequenceDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/SequenceDef:1.0' then
    begin
      result := Pointer(self as ISequenceDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TSequenceDef._narrow(const obj : IORBObject): ISequenceDef;
var
  p: Pointer;
  stub: TSequenceDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/SequenceDef:1.0');
  if p <> nil then
    result := ISequenceDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/SequenceDef:1.0') then
        begin
          stub := TSequenceDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TSequenceDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/SequenceDef:1.0'
end;

//***********************************************************
// TSequenceDef_stub
//***********************************************************
function TSequenceDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TSequenceDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TSequenceDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TSequenceDef_stub._set_bound(const val: _ulong);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_ulong,@val);
  req := StaticRequest(self,'_set_bound');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TSequenceDef_stub._get_bound: _ulong;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulong, @result);
  req := StaticRequest(self,'_get_bound');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TSequenceDef_stub._get_element_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_element_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TSequenceDef_stub._set_element_type_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_element_type_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TSequenceDef_stub._get_element_type_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_element_type_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TSequenceDef_stub_clp
//***********************************************************
function TSequenceDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/SequenceDef:1.0' then
    begin
      result := Pointer(self as ISequenceDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TSequenceDef_stub_clp._set_bound(const val: _ulong);
var
  _srv: IServant;
  srv: ISequenceDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSequenceDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_bound(val);
    end;
  _postinvoke();
end;

function TSequenceDef_stub_clp._get_bound: _ulong;
var
  _srv: IServant;
  srv: ISequenceDef;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSequenceDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_bound
    end;
  _postinvoke();
end;

function TSequenceDef_stub_clp._get_element_type: ITypeCode;
var
  _srv: IServant;
  srv: ISequenceDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSequenceDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_element_type
    end;
  _postinvoke();
end;

procedure TSequenceDef_stub_clp._set_element_type_def(const val: IIDLType);
var
  _srv: IServant;
  srv: ISequenceDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSequenceDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_element_type_def(val);
    end;
  _postinvoke();
end;

function TSequenceDef_stub_clp._get_element_type_def: IIDLType;
var
  _srv: IServant;
  srv: ISequenceDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TSequenceDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_element_type_def
    end;
  _postinvoke();
end;

//***********************************************************
// TSequenceDef_serv
//***********************************************************
function TSequenceDef_serv._this(): ISequenceDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TSequenceDef._narrow(obj);
end;

function TSequenceDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/SequenceDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TSequenceDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/SequenceDef:1.0';
end;

function TSequenceDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TSequenceDef_stub_clp.Create(poa,obj);
end;

procedure TSequenceDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TSequenceDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/SequenceDef:1.0' then
    begin
      result := Pointer(ISequenceDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TSequenceDef_serv._narrow(const srv : IServant): ISequenceDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/SequenceDef:1.0');
  if p <> nil then
    result := ISequenceDef(p)
end;

function TSequenceDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  bound_get_value: _ulong;
  bound_set_value: _ulong;
  element_type_get_value: ITypeCode;
  element_type_def_get_value: IIDLType;
  element_type_def_set_value: IIDLType;
begin
  result := true;
  if req.op_name = '_get_bound' then
    begin
      req.set_result(StaticAny(stat_ulong,@bound_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      bound_get_value := _get_bound;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_bound' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@bound_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_bound(bound_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_element_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@element_type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      element_type_get_value := _get_element_type;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_element_type_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@element_type_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      element_type_def_get_value := _get_element_type_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_element_type_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@element_type_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_element_type_def(element_type_def_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TSequenceDef_marshaller
//***********************************************************
function TSequenceDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ISequenceDef(addr^) := TSequenceDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TSequenceDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ISequenceDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TSequenceDef_marshaller._free(var addr: Pointer);
begin
  ISequenceDef(addr^) := nil;
end;

procedure TSequenceDef_marshaller._create(var addr: Pointer);
begin
  ISequenceDef(addr^) := TSequenceDef_stub.Create();
end;

procedure TSequenceDef_marshaller._assign(dst, src: Pointer);
begin
  ISequenceDef(dst^) := ISequenceDef(src^);
end;

function TSequenceDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_SequenceDef.typecode;
end;

//***********************************************************
// TArrayDef
//***********************************************************
function TArrayDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ArrayDef:1.0' then
    begin
      result := Pointer(self as IArrayDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TArrayDef._narrow(const obj : IORBObject): IArrayDef;
var
  p: Pointer;
  stub: TArrayDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/ArrayDef:1.0');
  if p <> nil then
    result := IArrayDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/ArrayDef:1.0') then
        begin
          stub := TArrayDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TArrayDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/ArrayDef:1.0'
end;

//***********************************************************
// TArrayDef_stub
//***********************************************************
function TArrayDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TArrayDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TArrayDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TArrayDef_stub._set_length(const val: _ulong);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_ulong,@val);
  req := StaticRequest(self,'_set_length');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TArrayDef_stub._get_length: _ulong;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_ulong, @result);
  req := StaticRequest(self,'_get_length');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TArrayDef_stub._get_element_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_element_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TArrayDef_stub._set_element_type_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_element_type_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TArrayDef_stub._get_element_type_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_element_type_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TArrayDef_stub_clp
//***********************************************************
function TArrayDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ArrayDef:1.0' then
    begin
      result := Pointer(self as IArrayDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TArrayDef_stub_clp._set_length(const val: _ulong);
var
  _srv: IServant;
  srv: IArrayDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TArrayDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_length(val);
    end;
  _postinvoke();
end;

function TArrayDef_stub_clp._get_length: _ulong;
var
  _srv: IServant;
  srv: IArrayDef;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TArrayDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_length
    end;
  _postinvoke();
end;

function TArrayDef_stub_clp._get_element_type: ITypeCode;
var
  _srv: IServant;
  srv: IArrayDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TArrayDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_element_type
    end;
  _postinvoke();
end;

procedure TArrayDef_stub_clp._set_element_type_def(const val: IIDLType);
var
  _srv: IServant;
  srv: IArrayDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TArrayDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_element_type_def(val);
    end;
  _postinvoke();
end;

function TArrayDef_stub_clp._get_element_type_def: IIDLType;
var
  _srv: IServant;
  srv: IArrayDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TArrayDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_element_type_def
    end;
  _postinvoke();
end;

//***********************************************************
// TArrayDef_serv
//***********************************************************
function TArrayDef_serv._this(): IArrayDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TArrayDef._narrow(obj);
end;

function TArrayDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/ArrayDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TArrayDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/ArrayDef:1.0';
end;

function TArrayDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TArrayDef_stub_clp.Create(poa,obj);
end;

procedure TArrayDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TArrayDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ArrayDef:1.0' then
    begin
      result := Pointer(IArrayDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TArrayDef_serv._narrow(const srv : IServant): IArrayDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/ArrayDef:1.0');
  if p <> nil then
    result := IArrayDef(p)
end;

function TArrayDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  length_get_value: _ulong;
  length_set_value: _ulong;
  element_type_get_value: ITypeCode;
  element_type_def_get_value: IIDLType;
  element_type_def_set_value: IIDLType;
begin
  result := true;
  if req.op_name = '_get_length' then
    begin
      req.set_result(StaticAny(stat_ulong,@length_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      length_get_value := _get_length;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_length' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@length_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_length(length_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_element_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@element_type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      element_type_get_value := _get_element_type;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_element_type_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@element_type_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      element_type_def_get_value := _get_element_type_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_element_type_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@element_type_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_element_type_def(element_type_def_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TArrayDef_marshaller
//***********************************************************
function TArrayDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IArrayDef(addr^) := TArrayDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TArrayDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IArrayDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TArrayDef_marshaller._free(var addr: Pointer);
begin
  IArrayDef(addr^) := nil;
end;

procedure TArrayDef_marshaller._create(var addr: Pointer);
begin
  IArrayDef(addr^) := TArrayDef_stub.Create();
end;

procedure TArrayDef_marshaller._assign(dst, src: Pointer);
begin
  IArrayDef(dst^) := IArrayDef(src^);
end;

function TArrayDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_ArrayDef.typecode;
end;

//***********************************************************
// TExceptionDef
//***********************************************************
function TExceptionDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ExceptionDef:1.0' then
    begin
      result := Pointer(self as IExceptionDef);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TExceptionDef._narrow(const obj : IORBObject): IExceptionDef;
var
  p: Pointer;
  stub: TExceptionDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/ExceptionDef:1.0');
  if p <> nil then
    result := IExceptionDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/ExceptionDef:1.0') then
        begin
          stub := TExceptionDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TExceptionDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/ExceptionDef:1.0'
end;

//***********************************************************
// TExceptionDef_stub
//***********************************************************
function TExceptionDef_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TExceptionDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TExceptionDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TExceptionDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TExceptionDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TExceptionDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TExceptionDef_stub._set_members(const val: TStructMemberSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(StructMember_seq_marshaller,@val);
  req := StaticRequest(self,'_set_members');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TExceptionDef_stub._get_members: TStructMemberSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(StructMember_seq_marshaller, @result);
  req := StaticRequest(self,'_get_members');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TExceptionDef_stub_clp
//***********************************************************
function TExceptionDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ExceptionDef:1.0' then
    begin
      result := Pointer(self as IExceptionDef);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TExceptionDef_stub_clp.lookup(const search_name: TScopedName): IContained;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup(search_name)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.contents(limit_type, exclude_inherited)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.lookup_name(search_name, levels_to_search, limit_type, exclude_inherited)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe_contents(limit_type, exclude_inherited, max_returned_objs)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_module(id, name, version)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_constant(id, name, version, _type, value)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_struct(id, name, version, members)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_exception(id, name, version, members)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_union(id, name, version, discriminator_type, members)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_enum(id, name, version, members)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_alias(id, name, version, original_type)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_abstract_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_local_interface(id, name, version, base_interfaces)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value(id, name, version, is_custom, is_abstract, base_value, is_truncatable, abstract_base_values, supported_interfaces, initializers)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value_box(id, name, version, original_type_def)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  _srv: IServant;
  srv: IContainer;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContainer_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_native(id, name, version)
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp._get_type: ITypeCode;
var
  _srv: IServant;
  srv: IExceptionDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TExceptionDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type
    end;
  _postinvoke();
end;

procedure TExceptionDef_stub_clp._set_members(const val: TStructMemberSeq);
var
  _srv: IServant;
  srv: IExceptionDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TExceptionDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_members(val);
    end;
  _postinvoke();
end;

function TExceptionDef_stub_clp._get_members: TStructMemberSeq;
var
  _srv: IServant;
  srv: IExceptionDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TExceptionDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_members
    end;
  _postinvoke();
end;

//***********************************************************
// TExceptionDef_serv
//***********************************************************
function TExceptionDef_serv._this(): IExceptionDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TExceptionDef._narrow(obj);
end;

function TExceptionDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/ExceptionDef:1.0';
  if repoid = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := true;
      exit;
    end;
  if not result then
    result := inherited _is_a(repoid);
end;

function TExceptionDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/ExceptionDef:1.0';
end;

function TExceptionDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TExceptionDef_stub_clp.Create(poa,obj);
end;

procedure TExceptionDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TExceptionDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ExceptionDef:1.0' then
    begin
      result := Pointer(IExceptionDef(self));
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Container:1.0' then
    begin
      result := Pointer(self as IContainer);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TExceptionDef_serv._narrow(const srv : IServant): IExceptionDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/ExceptionDef:1.0');
  if p <> nil then
    result := IExceptionDef(p)
end;

function TExceptionDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  type_get_value: ITypeCode;
  members_get_value: TStructMemberSeq;
  members_set_value: TStructMemberSeq;
  lookup_result: IContained;
  lookup_search_name: TScopedName;
  contents_result: TContainedSeq;
  contents_limit_type: TDefinitionKind;
  contents_exclude_inherited: Boolean;
  lookup_name_result: TContainedSeq;
  lookup_name_search_name: TIdentifier;
  lookup_name_levels_to_search: long;
  lookup_name_limit_type: TDefinitionKind;
  lookup_name_exclude_inherited: Boolean;
  describe_contents_result: TDescriptionSeq;
  describe_contents_limit_type: TDefinitionKind;
  describe_contents_exclude_inherited: Boolean;
  describe_contents_max_returned_objs: long;
  create_module_result: IModuleDef;
  create_module_id: TRepositoryId;
  create_module_name: TIdentifier;
  create_module_version: TVersionSpec;
  create_constant_result: IConstantDef;
  create_constant_id: TRepositoryId;
  create_constant_name: TIdentifier;
  create_constant_version: TVersionSpec;
  create_constant_type: IIDLType;
  create_constant_value: IAny;
  create_struct_result: IStructDef;
  create_struct_id: TRepositoryId;
  create_struct_name: TIdentifier;
  create_struct_version: TVersionSpec;
  create_struct_members: TStructMemberSeq;
  create_exception_result: IExceptionDef;
  create_exception_id: TRepositoryId;
  create_exception_name: TIdentifier;
  create_exception_version: TVersionSpec;
  create_exception_members: TStructMemberSeq;
  create_union_result: IUnionDef;
  create_union_id: TRepositoryId;
  create_union_name: TIdentifier;
  create_union_version: TVersionSpec;
  create_union_discriminator_type: IIDLType;
  create_union_members: TUnionMemberSeq;
  create_enum_result: IEnumDef;
  create_enum_id: TRepositoryId;
  create_enum_name: TIdentifier;
  create_enum_version: TVersionSpec;
  create_enum_members: TEnumMemberSeq;
  create_alias_result: IAliasDef;
  create_alias_id: TRepositoryId;
  create_alias_name: TIdentifier;
  create_alias_version: TVersionSpec;
  create_alias_original_type: IIDLType;
  create_interface_result: IInterfaceDef;
  create_interface_id: TRepositoryId;
  create_interface_name: TIdentifier;
  create_interface_version: TVersionSpec;
  create_interface_base_interfaces: TInterfaceDefSeq;
  create_abstract_interface_result: IAbstractInterfaceDef;
  create_abstract_interface_id: TRepositoryId;
  create_abstract_interface_name: TIdentifier;
  create_abstract_interface_version: TVersionSpec;
  create_abstract_interface_base_interfaces: TAbstractInterfaceDefSeq;
  create_local_interface_result: ILocalInterfaceDef;
  create_local_interface_id: TRepositoryId;
  create_local_interface_name: TIdentifier;
  create_local_interface_version: TVersionSpec;
  create_local_interface_base_interfaces: TInterfaceDefSeq;
  create_value_result: IValueDef;
  create_value_id: TRepositoryId;
  create_value_name: TIdentifier;
  create_value_version: TVersionSpec;
  create_value_is_custom: Boolean;
  create_value_is_abstract: Boolean;
  create_value_base_value: IValueDef;
  create_value_is_truncatable: Boolean;
  create_value_abstract_base_values: TValueDefSeq;
  create_value_supported_interfaces: TInterfaceDefSeq;
  create_value_initializers: TInitializerSeq;
  create_value_box_result: IValueBoxDef;
  create_value_box_id: TRepositoryId;
  create_value_box_name: TIdentifier;
  create_value_box_version: TVersionSpec;
  create_value_box_original_type_def: IIDLType;
  create_native_result: INativeDef;
  create_native_id: TRepositoryId;
  create_native_name: TIdentifier;
  create_native_version: TVersionSpec;
begin
  result := true;
  if req.op_name = '_get_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_get_value := _get_type;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_members' then
    begin
      req.set_result(StaticAny(StructMember_seq_marshaller,@members_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      members_get_value := _get_members;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_members' then
    begin
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@members_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_members(members_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'lookup' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_search_name) as IStaticAny);
      req.set_result(StaticAny(Contained_marshaller,@lookup_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_result := lookup(lookup_search_name);
      req.write_results();
      exit;
    end
  else if req.op_name = 'contents' then
    begin
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@contents_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@contents_exclude_inherited) as IStaticAny);
      req.set_result(StaticAny(Contained_seq_marshaller,@contents_result) as IStaticAny);
      if not req.read_args() then  exit;
      contents_result := contents(contents_limit_type, contents_exclude_inherited);
      req.write_results();
      exit;
    end
  else if req.op_name = 'lookup_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@lookup_name_search_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_long,@lookup_name_levels_to_search) as IStaticAny);
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@lookup_name_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@lookup_name_exclude_inherited) as IStaticAny);
      req.set_result(StaticAny(Contained_seq_marshaller,@lookup_name_result) as IStaticAny);
      if not req.read_args() then  exit;
      lookup_name_result := lookup_name(lookup_name_search_name, lookup_name_levels_to_search, lookup_name_limit_type, lookup_name_exclude_inherited);
      req.write_results();
      exit;
    end
  else if req.op_name = 'describe_contents' then
    begin
      req.add_in_arg(StaticAny(DefinitionKind_marshaller,@describe_contents_limit_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@describe_contents_exclude_inherited) as IStaticAny);
      req.add_in_arg(StaticAny(stat_long,@describe_contents_max_returned_objs) as IStaticAny);
      req.set_result(StaticAny(Description_seq_marshaller,@describe_contents_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_contents_result := describe_contents(describe_contents_limit_type, describe_contents_exclude_inherited, describe_contents_max_returned_objs);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_module' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_module_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_module_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_module_version) as IStaticAny);
      req.set_result(StaticAny(ModuleDef_marshaller,@create_module_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_module_result := create_module(create_module_id, create_module_name, create_module_version);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_constant' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_constant_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_constant_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_constant_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_constant_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_any,@create_constant_value) as IStaticAny);
      req.set_result(StaticAny(ConstantDef_marshaller,@create_constant_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_constant_result := create_constant(create_constant_id, create_constant_name, create_constant_version, create_constant_type, create_constant_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_struct' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_struct_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_struct_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_struct_version) as IStaticAny);
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@create_struct_members) as IStaticAny);
      req.set_result(StaticAny(StructDef_marshaller,@create_struct_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_struct_result := create_struct(create_struct_id, create_struct_name, create_struct_version, create_struct_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_exception' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_exception_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_exception_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_exception_version) as IStaticAny);
      req.add_in_arg(StaticAny(StructMember_seq_marshaller,@create_exception_members) as IStaticAny);
      req.set_result(StaticAny(ExceptionDef_marshaller,@create_exception_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_exception_result := create_exception(create_exception_id, create_exception_name, create_exception_version, create_exception_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_union' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_union_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_union_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_union_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_union_discriminator_type) as IStaticAny);
      req.add_in_arg(StaticAny(UnionMember_seq_marshaller,@create_union_members) as IStaticAny);
      req.set_result(StaticAny(UnionDef_marshaller,@create_union_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_union_result := create_union(create_union_id, create_union_name, create_union_version, create_union_discriminator_type, create_union_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_enum' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_enum_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_enum_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_enum_version) as IStaticAny);
      req.add_in_arg(StaticAny(stat_seq_string,@create_enum_members) as IStaticAny);
      req.set_result(StaticAny(EnumDef_marshaller,@create_enum_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_enum_result := create_enum(create_enum_id, create_enum_name, create_enum_version, create_enum_members);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_alias' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_alias_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_alias_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_alias_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_alias_original_type) as IStaticAny);
      req.set_result(StaticAny(AliasDef_marshaller,@create_alias_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_alias_result := create_alias(create_alias_id, create_alias_name, create_alias_version, create_alias_original_type);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(InterfaceDef_marshaller,@create_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_interface_result := create_interface(create_interface_id, create_interface_name, create_interface_version, create_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_abstract_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_abstract_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(AbstractInterfaceDef_seq_marshaller,@create_abstract_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(AbstractInterfaceDef_marshaller,@create_abstract_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_abstract_interface_result := create_abstract_interface(create_abstract_interface_id, create_abstract_interface_name, create_abstract_interface_version, create_abstract_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_local_interface' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_local_interface_version) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_local_interface_base_interfaces) as IStaticAny);
      req.set_result(StaticAny(LocalInterfaceDef_marshaller,@create_local_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_local_interface_result := create_local_interface(create_local_interface_id, create_local_interface_name, create_local_interface_version, create_local_interface_base_interfaces);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_version) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_custom) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_abstract) as IStaticAny);
      req.add_in_arg(StaticAny(ValueDef_marshaller,@create_value_base_value) as IStaticAny);
      req.add_in_arg(StaticAny(stat_boolean,@create_value_is_truncatable) as IStaticAny);
      req.add_in_arg(StaticAny(ValueDef_seq_marshaller,@create_value_abstract_base_values) as IStaticAny);
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@create_value_supported_interfaces) as IStaticAny);
      req.add_in_arg(StaticAny(Initializer_seq_marshaller,@create_value_initializers) as IStaticAny);
      req.set_result(StaticAny(ValueDef_marshaller,@create_value_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_result := create_value(create_value_id, create_value_name, create_value_version, create_value_is_custom, create_value_is_abstract, create_value_base_value, create_value_is_truncatable, create_value_abstract_base_values, create_value_supported_interfaces, create_value_initializers);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value_box' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_box_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_box_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_box_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_value_box_original_type_def) as IStaticAny);
      req.set_result(StaticAny(ValueBoxDef_marshaller,@create_value_box_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_box_result := create_value_box(create_value_box_id, create_value_box_name, create_value_box_version, create_value_box_original_type_def);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_native' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_native_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_native_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_native_version) as IStaticAny);
      req.set_result(StaticAny(NativeDef_marshaller,@create_native_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_native_result := create_native(create_native_id, create_native_name, create_native_version);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TExceptionDef_marshaller
//***********************************************************
function TExceptionDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IExceptionDef(addr^) := TExceptionDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TExceptionDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IExceptionDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TExceptionDef_marshaller._free(var addr: Pointer);
begin
  IExceptionDef(addr^) := nil;
end;

procedure TExceptionDef_marshaller._create(var addr: Pointer);
begin
  IExceptionDef(addr^) := TExceptionDef_stub.Create();
end;

procedure TExceptionDef_marshaller._assign(dst, src: Pointer);
begin
  IExceptionDef(dst^) := IExceptionDef(src^);
end;

function TExceptionDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_ExceptionDef.typecode;
end;

//***********************************************************
// TExceptionDescription_marshaller
//***********************************************************
function TExceptionDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TExceptionDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  ir_int.TExceptionDescription(addr^) := struct;
  result := true;
end;

procedure TExceptionDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TExceptionDescription;
begin
  struct := ir_int.TExceptionDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  stat_TypeCode.marshal(enc,@struct._type);
end;

procedure TExceptionDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TExceptionDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TExceptionDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TExceptionDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TExceptionDescription(addr^));
{$HINTS ON}
end;

procedure TExceptionDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TExceptionDescription(dst^) := ir_int.TExceptionDescription(src^);
end;

function TExceptionDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_ExceptionDescription.typecode;
end;

//***********************************************************
// TExceptionDef_seq_marshaller
//***********************************************************

function TExceptionDef_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: IExceptionDef;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(ExceptionDef_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not ExceptionDef_marshaller.demarshal(dec,@val) then exit;
        ExceptionDef_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TExceptionDef_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(ExceptionDef_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      ExceptionDef_marshaller.marshal(enc,@ExceptionDef_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TExceptionDef_seq_marshaller._free(var addr: Pointer);
begin
  setLength(ExceptionDef_seq(addr^),0);
  freemem(addr);
end;

procedure TExceptionDef_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TExceptionDef_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TExceptionDef_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_ExceptionDef_seq.typecode;
end;

//***********************************************************
// TExceptionDescription_seq_marshaller
//***********************************************************

function TExceptionDescription_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TExceptionDescription;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(ExceptionDescription_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not ExceptionDescription_marshaller.demarshal(dec,@val) then exit;
        ExceptionDescription_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TExceptionDescription_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(ExceptionDescription_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      ExceptionDescription_marshaller.marshal(enc,@ExceptionDescription_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TExceptionDescription_seq_marshaller._free(var addr: Pointer);
begin
  setLength(ExceptionDescription_seq(addr^),0);
  freemem(addr);
end;

procedure TExceptionDescription_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TExceptionDescription_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TExceptionDescription_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_ExceptionDescription_seq.typecode;
end;

//***********************************************************
// TAttributeMode_marshaller
//***********************************************************
function TAttributeMode_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TAttributeMode_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TAttributeMode_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TAttributeMode_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TAttributeMode_marshaller._assign(dst, src: Pointer);
begin
  TAttributeMode(dst^) := TAttributeMode(src^);
end;

function TAttributeMode_marshaller.typecode: ITypeCode;
begin
  result := _tc_AttributeMode.typecode;
end;

//***********************************************************
// TAttributeDef
//***********************************************************
function TAttributeDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AttributeDef:1.0' then
    begin
      result := Pointer(self as IAttributeDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TAttributeDef._narrow(const obj : IORBObject): IAttributeDef;
var
  p: Pointer;
  stub: TAttributeDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/AttributeDef:1.0');
  if p <> nil then
    result := IAttributeDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/AttributeDef:1.0') then
        begin
          stub := TAttributeDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TAttributeDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/AttributeDef:1.0'
end;

//***********************************************************
// TAttributeDef_stub
//***********************************************************
function TAttributeDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAttributeDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAttributeDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAttributeDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAttributeDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAttributeDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAttributeDef_stub._set_type_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_type_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_type_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_type_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAttributeDef_stub._set_mode(const val: TAttributeMode);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(AttributeMode_marshaller,@val);
  req := StaticRequest(self,'_set_mode');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAttributeDef_stub._get_mode: TAttributeMode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(AttributeMode_marshaller, @result);
  req := StaticRequest(self,'_get_mode');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TAttributeDef_stub_clp
//***********************************************************
function TAttributeDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AttributeDef:1.0' then
    begin
      result := Pointer(self as IAttributeDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TAttributeDef_stub_clp._get_type: ITypeCode;
var
  _srv: IServant;
  srv: IAttributeDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TAttributeDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type
    end;
  _postinvoke();
end;

procedure TAttributeDef_stub_clp._set_type_def(const val: IIDLType);
var
  _srv: IServant;
  srv: IAttributeDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TAttributeDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_type_def(val);
    end;
  _postinvoke();
end;

function TAttributeDef_stub_clp._get_type_def: IIDLType;
var
  _srv: IServant;
  srv: IAttributeDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TAttributeDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type_def
    end;
  _postinvoke();
end;

procedure TAttributeDef_stub_clp._set_mode(const val: TAttributeMode);
var
  _srv: IServant;
  srv: IAttributeDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TAttributeDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_mode(val);
    end;
  _postinvoke();
end;

function TAttributeDef_stub_clp._get_mode: TAttributeMode;
var
  _srv: IServant;
  srv: IAttributeDef;
begin
  result := ATTR_NORMAL;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TAttributeDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_mode
    end;
  _postinvoke();
end;

//***********************************************************
// TAttributeDef_serv
//***********************************************************
function TAttributeDef_serv._this(): IAttributeDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TAttributeDef._narrow(obj);
end;

function TAttributeDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/AttributeDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TAttributeDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/AttributeDef:1.0';
end;

function TAttributeDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TAttributeDef_stub_clp.Create(poa,obj);
end;

procedure TAttributeDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TAttributeDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AttributeDef:1.0' then
    begin
      result := Pointer(IAttributeDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TAttributeDef_serv._narrow(const srv : IServant): IAttributeDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/AttributeDef:1.0');
  if p <> nil then
    result := IAttributeDef(p)
end;

function TAttributeDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  type_get_value: ITypeCode;
  type_def_get_value: IIDLType;
  type_def_set_value: IIDLType;
  mode_get_value: TAttributeMode;
  mode_set_value: TAttributeMode;
begin
  result := true;
  if req.op_name = '_get_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_get_value := _get_type;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_type_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@type_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_def_get_value := _get_type_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_type_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@type_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_type_def(type_def_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_mode' then
    begin
      req.set_result(StaticAny(AttributeMode_marshaller,@mode_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      mode_get_value := _get_mode;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_mode' then
    begin
      req.add_in_arg(StaticAny(AttributeMode_marshaller,@mode_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_mode(mode_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TAttributeDef_marshaller
//***********************************************************
function TAttributeDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IAttributeDef(addr^) := TAttributeDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TAttributeDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IAttributeDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TAttributeDef_marshaller._free(var addr: Pointer);
begin
  IAttributeDef(addr^) := nil;
end;

procedure TAttributeDef_marshaller._create(var addr: Pointer);
begin
  IAttributeDef(addr^) := TAttributeDef_stub.Create();
end;

procedure TAttributeDef_marshaller._assign(dst, src: Pointer);
begin
  IAttributeDef(dst^) := IAttributeDef(src^);
end;

function TAttributeDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_AttributeDef.typecode;
end;

//***********************************************************
// TAttributeDescription_marshaller
//***********************************************************
function TAttributeDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TAttributeDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  if not AttributeMode_marshaller.demarshal(dec,@struct.mode) then exit;
  ir_int.TAttributeDescription(addr^) := struct;
  result := true;
end;

procedure TAttributeDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TAttributeDescription;
begin
  struct := ir_int.TAttributeDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  stat_TypeCode.marshal(enc,@struct._type);
  AttributeMode_marshaller.marshal(enc,@struct.mode);
end;

procedure TAttributeDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TAttributeDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TAttributeDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TAttributeDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TAttributeDescription(addr^));
{$HINTS ON}
end;

procedure TAttributeDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TAttributeDescription(dst^) := ir_int.TAttributeDescription(src^);
end;

function TAttributeDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_AttributeDescription.typecode;
end;

//***********************************************************
// TOperationMode_marshaller
//***********************************************************
function TOperationMode_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TOperationMode_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TOperationMode_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TOperationMode_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TOperationMode_marshaller._assign(dst, src: Pointer);
begin
  TOperationMode(dst^) := TOperationMode(src^);
end;

function TOperationMode_marshaller.typecode: ITypeCode;
begin
  result := _tc_OperationMode.typecode;
end;

//***********************************************************
// TParameterMode_marshaller
//***********************************************************
function TParameterMode_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TParameterMode_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TParameterMode_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TParameterMode_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TParameterMode_marshaller._assign(dst, src: Pointer);
begin
  TParameterMode(dst^) := TParameterMode(src^);
end;

function TParameterMode_marshaller.typecode: ITypeCode;
begin
  result := _tc_ParameterMode.typecode;
end;

//***********************************************************
// TParameterDescription_marshaller
//***********************************************************
function TParameterDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TParameterDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  if not IDLType_marshaller.demarshal(dec,@struct.type_def) then exit;
  if not ParameterMode_marshaller.demarshal(dec,@struct.mode) then exit;
  ir_int.TParameterDescription(addr^) := struct;
  result := true;
end;

procedure TParameterDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TParameterDescription;
begin
  struct := ir_int.TParameterDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_TypeCode.marshal(enc,@struct._type);
  IDLType_marshaller.marshal(enc,@struct.type_def);
  ParameterMode_marshaller.marshal(enc,@struct.mode);
end;

procedure TParameterDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TParameterDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TParameterDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TParameterDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TParameterDescription(addr^));
{$HINTS ON}
end;

procedure TParameterDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TParameterDescription(dst^) := ir_int.TParameterDescription(src^);
end;

function TParameterDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_ParameterDescription.typecode;
end;

//***********************************************************
// TParameterDescription_seq_marshaller
//***********************************************************

function TParameterDescription_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TParameterDescription;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(ParameterDescription_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not ParameterDescription_marshaller.demarshal(dec,@val) then exit;
        ParameterDescription_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TParameterDescription_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(ParameterDescription_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      ParameterDescription_marshaller.marshal(enc,@ParameterDescription_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TParameterDescription_seq_marshaller._free(var addr: Pointer);
begin
  setLength(ParameterDescription_seq(addr^),0);
  freemem(addr);
end;

procedure TParameterDescription_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TParameterDescription_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TParameterDescription_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_ParameterDescription_seq.typecode;
end;

//***********************************************************
// TOperationDef
//***********************************************************
function TOperationDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/OperationDef:1.0' then
    begin
      result := Pointer(self as IOperationDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TOperationDef._narrow(const obj : IORBObject): IOperationDef;
var
  p: Pointer;
  stub: TOperationDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/OperationDef:1.0');
  if p <> nil then
    result := IOperationDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/OperationDef:1.0') then
        begin
          stub := TOperationDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TOperationDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/OperationDef:1.0'
end;

//***********************************************************
// TOperationDef_stub
//***********************************************************
function TOperationDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_result: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_result');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._set_result_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_result_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_result_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_result_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._set_params(const val: TParDescriptionSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(ParameterDescription_seq_marshaller,@val);
  req := StaticRequest(self,'_set_params');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_params: TParDescriptionSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ParameterDescription_seq_marshaller, @result);
  req := StaticRequest(self,'_get_params');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._set_mode(const val: TOperationMode);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(OperationMode_marshaller,@val);
  req := StaticRequest(self,'_set_mode');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_mode: TOperationMode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(OperationMode_marshaller, @result);
  req := StaticRequest(self,'_get_mode');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._set_contexts(const val: TContextIdSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_seq_string,@val);
  req := StaticRequest(self,'_set_contexts');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_contexts: TContextIdSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_seq_string, @result);
  req := StaticRequest(self,'_get_contexts');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOperationDef_stub._set_exceptions(const val: TExceptionDefSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(ExceptionDef_seq_marshaller,@val);
  req := StaticRequest(self,'_set_exceptions');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TOperationDef_stub._get_exceptions: TExceptionDefSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ExceptionDef_seq_marshaller, @result);
  req := StaticRequest(self,'_get_exceptions');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TOperationDef_stub_clp
//***********************************************************
function TOperationDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/OperationDef:1.0' then
    begin
      result := Pointer(self as IOperationDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TOperationDef_stub_clp._get_result: ITypeCode;
var
  _srv: IServant;
  srv: IOperationDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_result
    end;
  _postinvoke();
end;

procedure TOperationDef_stub_clp._set_result_def(const val: IIDLType);
var
  _srv: IServant;
  srv: IOperationDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_result_def(val);
    end;
  _postinvoke();
end;

function TOperationDef_stub_clp._get_result_def: IIDLType;
var
  _srv: IServant;
  srv: IOperationDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_result_def
    end;
  _postinvoke();
end;

procedure TOperationDef_stub_clp._set_params(const val: TParDescriptionSeq);
var
  _srv: IServant;
  srv: IOperationDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_params(val);
    end;
  _postinvoke();
end;

function TOperationDef_stub_clp._get_params: TParDescriptionSeq;
var
  _srv: IServant;
  srv: IOperationDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_params
    end;
  _postinvoke();
end;

procedure TOperationDef_stub_clp._set_mode(const val: TOperationMode);
var
  _srv: IServant;
  srv: IOperationDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_mode(val);
    end;
  _postinvoke();
end;

function TOperationDef_stub_clp._get_mode: TOperationMode;
var
  _srv: IServant;
  srv: IOperationDef;
begin
  result := OP_NORMAL;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_mode
    end;
  _postinvoke();
end;

procedure TOperationDef_stub_clp._set_contexts(const val: TContextIdSeq);
var
  _srv: IServant;
  srv: IOperationDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_contexts(val);
    end;
  _postinvoke();
end;

function TOperationDef_stub_clp._get_contexts: TContextIdSeq;
var
  _srv: IServant;
  srv: IOperationDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_contexts
    end;
  _postinvoke();
end;

procedure TOperationDef_stub_clp._set_exceptions(const val: TExceptionDefSeq);
var
  _srv: IServant;
  srv: IOperationDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_exceptions(val);
    end;
  _postinvoke();
end;

function TOperationDef_stub_clp._get_exceptions: TExceptionDefSeq;
var
  _srv: IServant;
  srv: IOperationDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOperationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_exceptions
    end;
  _postinvoke();
end;

//***********************************************************
// TOperationDef_serv
//***********************************************************
function TOperationDef_serv._this(): IOperationDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TOperationDef._narrow(obj);
end;

function TOperationDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/OperationDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TOperationDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/OperationDef:1.0';
end;

function TOperationDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TOperationDef_stub_clp.Create(poa,obj);
end;

procedure TOperationDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TOperationDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/OperationDef:1.0' then
    begin
      result := Pointer(IOperationDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TOperationDef_serv._narrow(const srv : IServant): IOperationDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/OperationDef:1.0');
  if p <> nil then
    result := IOperationDef(p)
end;

function TOperationDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  result_get_value: ITypeCode;
  result_def_get_value: IIDLType;
  result_def_set_value: IIDLType;
  params_get_value: TParDescriptionSeq;
  params_set_value: TParDescriptionSeq;
  mode_get_value: TOperationMode;
  mode_set_value: TOperationMode;
  contexts_get_value: TContextIdSeq;
  contexts_set_value: TContextIdSeq;
  exceptions_get_value: TExceptionDefSeq;
  exceptions_set_value: TExceptionDefSeq;
begin
  result := true;
  if req.op_name = '_get_result' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@result_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      result_get_value := _get_result;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_result_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@result_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      result_def_get_value := _get_result_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_result_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@result_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_result_def(result_def_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_params' then
    begin
      req.set_result(StaticAny(ParameterDescription_seq_marshaller,@params_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      params_get_value := _get_params;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_params' then
    begin
      req.add_in_arg(StaticAny(ParameterDescription_seq_marshaller,@params_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_params(params_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_mode' then
    begin
      req.set_result(StaticAny(OperationMode_marshaller,@mode_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      mode_get_value := _get_mode;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_mode' then
    begin
      req.add_in_arg(StaticAny(OperationMode_marshaller,@mode_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_mode(mode_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_contexts' then
    begin
      req.set_result(StaticAny(stat_seq_string,@contexts_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      contexts_get_value := _get_contexts;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_contexts' then
    begin
      req.add_in_arg(StaticAny(stat_seq_string,@contexts_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_contexts(contexts_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_exceptions' then
    begin
      req.set_result(StaticAny(ExceptionDef_seq_marshaller,@exceptions_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      exceptions_get_value := _get_exceptions;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_exceptions' then
    begin
      req.add_in_arg(StaticAny(ExceptionDef_seq_marshaller,@exceptions_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_exceptions(exceptions_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TOperationDef_marshaller
//***********************************************************
function TOperationDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IOperationDef(addr^) := TOperationDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TOperationDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IOperationDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TOperationDef_marshaller._free(var addr: Pointer);
begin
  IOperationDef(addr^) := nil;
end;

procedure TOperationDef_marshaller._create(var addr: Pointer);
begin
  IOperationDef(addr^) := TOperationDef_stub.Create();
end;

procedure TOperationDef_marshaller._assign(dst, src: Pointer);
begin
  IOperationDef(dst^) := IOperationDef(src^);
end;

function TOperationDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_OperationDef.typecode;
end;

//***********************************************************
// TOperationDescription_marshaller
//***********************************************************
function TOperationDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TOperationDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._result) then exit;
  if not OperationMode_marshaller.demarshal(dec,@struct.mode) then exit;
  if not stat_seq_string.demarshal(dec,@struct.contexts) then exit;
  if not ParameterDescription_seq_marshaller.demarshal(dec,@struct.parameters) then exit;
  if not ExceptionDescription_seq_marshaller.demarshal(dec,@struct.exceptions) then exit;
  ir_int.TOperationDescription(addr^) := struct;
  result := true;
end;

procedure TOperationDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TOperationDescription;
begin
  struct := ir_int.TOperationDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  stat_TypeCode.marshal(enc,@struct._result);
  OperationMode_marshaller.marshal(enc,@struct.mode);
  stat_seq_string.marshal(enc,@struct.contexts);
  ParameterDescription_seq_marshaller.marshal(enc,@struct.parameters);
  ExceptionDescription_seq_marshaller.marshal(enc,@struct.exceptions);
end;

procedure TOperationDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TOperationDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TOperationDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TOperationDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TOperationDescription(addr^));
{$HINTS ON}
end;

procedure TOperationDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TOperationDescription(dst^) := ir_int.TOperationDescription(src^);
end;

function TOperationDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_OperationDescription.typecode;
end;

//***********************************************************
// TOperationDescription_seq_marshaller
//***********************************************************

function TOperationDescription_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TOperationDescription;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(OperationDescription_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not OperationDescription_marshaller.demarshal(dec,@val) then exit;
        OperationDescription_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TOperationDescription_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(OperationDescription_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      OperationDescription_marshaller.marshal(enc,@OperationDescription_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TOperationDescription_seq_marshaller._free(var addr: Pointer);
begin
  setLength(OperationDescription_seq(addr^),0);
  freemem(addr);
end;

procedure TOperationDescription_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TOperationDescription_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TOperationDescription_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_OperationDescription_seq.typecode;
end;

//***********************************************************
// TAttributeDescription_seq_marshaller
//***********************************************************

function TAttributeDescription_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TAttributeDescription;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(AttributeDescription_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not AttributeDescription_marshaller.demarshal(dec,@val) then exit;
        AttributeDescription_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TAttributeDescription_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(AttributeDescription_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      AttributeDescription_marshaller.marshal(enc,@AttributeDescription_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TAttributeDescription_seq_marshaller._free(var addr: Pointer);
begin
  setLength(AttributeDescription_seq(addr^),0);
  freemem(addr);
end;

procedure TAttributeDescription_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TAttributeDescription_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TAttributeDescription_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_AttributeDescription_seq.typecode;
end;

//***********************************************************
// TFullInterfaceDescription_marshaller
//***********************************************************
function TFullInterfaceDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TFullInterfaceDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not OperationDescription_seq_marshaller.demarshal(dec,@struct.operations) then exit;
  if not AttributeDescription_seq_marshaller.demarshal(dec,@struct.attributes) then exit;
  if not stat_seq_string.demarshal(dec,@struct.base_interfaces) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  ir_int.TFullInterfaceDescription(addr^) := struct;
  result := true;
end;

procedure TFullInterfaceDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TFullInterfaceDescription;
begin
  struct := ir_int.TFullInterfaceDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  OperationDescription_seq_marshaller.marshal(enc,@struct.operations);
  AttributeDescription_seq_marshaller.marshal(enc,@struct.attributes);
  stat_seq_string.marshal(enc,@struct.base_interfaces);
  stat_TypeCode.marshal(enc,@struct._type);
end;

procedure TFullInterfaceDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TFullInterfaceDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TFullInterfaceDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TFullInterfaceDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TFullInterfaceDescription(addr^));
{$HINTS ON}
end;

procedure TFullInterfaceDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TFullInterfaceDescription(dst^) := ir_int.TFullInterfaceDescription(src^);
end;

function TFullInterfaceDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_FullInterfaceDescription.typecode;
end;

//***********************************************************
// TInterfaceDef
//***********************************************************
function TInterfaceDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/InterfaceDef:1.0' then
    begin
      result := Pointer(self as IInterfaceDef);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TInterfaceDef._narrow(const obj : IORBObject): IInterfaceDef;
var
  p: Pointer;
  stub: TInterfaceDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/InterfaceDef:1.0');
  if p <> nil then
    result := IInterfaceDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/InterfaceDef:1.0') then
        begin
          stub := TInterfaceDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TInterfaceDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/InterfaceDef:1.0'
end;

//***********************************************************
// TInterfaceDef_stub
//***********************************************************
function TInterfaceDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TInterfaceDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TInterfaceDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TInterfaceDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TInterfaceDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TInterfaceDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.is_a(const interface_id: TRepositoryId): Boolean;
var
  req: IStaticRequest;
  _interface_id: IStaticAny;
  _result: IStaticAny;
begin
  _interface_id := StaticAny(stat_string,@interface_id);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_a');
  req.add_in_arg(_interface_id);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.describe_interface: TFullInterfaceDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(FullInterfaceDescription_marshaller, @result);
  req := StaticRequest(self,'describe_interface');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _mode: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _mode := StaticAny(AttributeMode_marshaller,@mode);
  _result := StaticAny(AttributeDef_marshaller, @result);
  req := StaticRequest(self,'create_attribute');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_mode);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub.create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __result: IStaticAny;
  _mode: IStaticAny;
  _params: IStaticAny;
  _exceptions: IStaticAny;
  _contexts: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __result := StaticAny(IDLType_marshaller,@_result);
  _mode := StaticAny(OperationMode_marshaller,@mode);
  _params := StaticAny(ParameterDescription_seq_marshaller,@params);
  _exceptions := StaticAny(ExceptionDef_seq_marshaller,@exceptions);
  _contexts := StaticAny(stat_seq_string,@contexts);
  _result := StaticAny(OperationDef_marshaller, @result);
  req := StaticRequest(self,'create_operation');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__result);
  req.add_in_arg(_mode);
  req.add_in_arg(_params);
  req.add_in_arg(_exceptions);
  req.add_in_arg(_contexts);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TInterfaceDef_stub._set_base_interfaces(const val: TInterfaceDefSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(InterfaceDef_seq_marshaller,@val);
  req := StaticRequest(self,'_set_base_interfaces');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TInterfaceDef_stub._get_base_interfaces: TInterfaceDefSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(InterfaceDef_seq_marshaller, @result);
  req := StaticRequest(self,'_get_base_interfaces');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TInterfaceDef_stub_clp
//***********************************************************
function TInterfaceDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/InterfaceDef:1.0' then
    begin
      result := Pointer(self as IInterfaceDef);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TInterfaceDef_stub_clp.is_a(const interface_id: TRepositoryId): Boolean;
var
  _srv: IServant;
  srv: IInterfaceDef;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TInterfaceDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.is_a(interface_id)
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp.describe_interface: TFullInterfaceDescription;
var
  _srv: IServant;
  srv: IInterfaceDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TInterfaceDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe_interface
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp.create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef;
var
  _srv: IServant;
  srv: IInterfaceDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TInterfaceDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_attribute(id, name, version, _type, mode)
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp.create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef;
var
  _srv: IServant;
  srv: IInterfaceDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TInterfaceDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_operation(id, name, version, _result, mode, params, exceptions, contexts)
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp.describe: TDescription;
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe
    end;
  _postinvoke();
end;

procedure TInterfaceDef_stub_clp.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv.move(new_container, new_name, new_version)
    end;
  _postinvoke();
end;

procedure TInterfaceDef_stub_clp._set_id(const val: TRepositoryId);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_id(val);
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp._get_id: TRepositoryId;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_id
    end;
  _postinvoke();
end;

procedure TInterfaceDef_stub_clp._set_name(const val: TIdentifier);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_name(val);
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp._get_name: TIdentifier;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_name
    end;
  _postinvoke();
end;

procedure TInterfaceDef_stub_clp._set_version(const val: TVersionSpec);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_version(val);
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp._get_version: TVersionSpec;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_version
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp._get_defined_in: IContainer;
var
  _srv: IServant;
  srv: IContained;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_defined_in
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp._get_absolute_name: TScopedName;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_absolute_name
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp._get_containing_repository: IRepository;
var
  _srv: IServant;
  srv: IContained;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_containing_repository
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp._get_type: ITypeCode;
var
  _srv: IServant;
  srv: IIDLType;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TIDLType_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type
    end;
  _postinvoke();
end;

procedure TInterfaceDef_stub_clp._set_base_interfaces(const val: TInterfaceDefSeq);
var
  _srv: IServant;
  srv: IInterfaceDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TInterfaceDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_base_interfaces(val);
    end;
  _postinvoke();
end;

function TInterfaceDef_stub_clp._get_base_interfaces: TInterfaceDefSeq;
var
  _srv: IServant;
  srv: IInterfaceDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TInterfaceDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_base_interfaces
    end;
  _postinvoke();
end;

//***********************************************************
// TInterfaceDef_serv
//***********************************************************
function TInterfaceDef_serv._this(): IInterfaceDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TInterfaceDef._narrow(obj);
end;

function TInterfaceDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/InterfaceDef:1.0';
  if repoid = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := true;
      exit;
    end;
  if repoid = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := true;
      exit;
    end;
  if not result then
    result := inherited _is_a(repoid);
end;

function TInterfaceDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/InterfaceDef:1.0';
end;

function TInterfaceDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TInterfaceDef_stub_clp.Create(poa,obj);
end;

procedure TInterfaceDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TInterfaceDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/InterfaceDef:1.0' then
    begin
      result := Pointer(IInterfaceDef(self));
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TInterfaceDef_serv._narrow(const srv : IServant): IInterfaceDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/InterfaceDef:1.0');
  if p <> nil then
    result := IInterfaceDef(p)
end;

function TInterfaceDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  is_a_result: Boolean;
  is_a_interface_id: TRepositoryId;
  describe_interface_result: TFullInterfaceDescription;
  create_attribute_result: IAttributeDef;
  create_attribute_id: TRepositoryId;
  create_attribute_name: TIdentifier;
  create_attribute_version: TVersionSpec;
  create_attribute_type: IIDLType;
  create_attribute_mode: TAttributeMode;
  create_operation_result: IOperationDef;
  create_operation_id: TRepositoryId;
  create_operation_name: TIdentifier;
  create_operation_version: TVersionSpec;
  create_operation_result: IIDLType;
  create_operation_mode: TOperationMode;
  create_operation_params: TParDescriptionSeq;
  create_operation_exceptions: TExceptionDefSeq;
  create_operation_contexts: TContextIdSeq;
  base_interfaces_get_value: TInterfaceDefSeq;
  base_interfaces_set_value: TInterfaceDefSeq;
  describe_result: TDescription;
  move_new_container: IContainer;
  move_new_name: TIdentifier;
  move_new_version: TVersionSpec;
  id_get_value: TRepositoryId;
  id_set_value: TRepositoryId;
  name_get_value: TIdentifier;
  name_set_value: TIdentifier;
  version_get_value: TVersionSpec;
  version_set_value: TVersionSpec;
  defined_in_get_value: IContainer;
  absolute_name_get_value: TScopedName;
  containing_repository_get_value: IRepository;
  type_get_value: ITypeCode;
begin
  result := true;
  if req.op_name = 'is_a' then
    begin
      req.add_in_arg(StaticAny(stat_string,@is_a_interface_id) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@is_a_result) as IStaticAny);
      if not req.read_args() then  exit;
      is_a_result := is_a(is_a_interface_id);
      req.write_results();
      exit;
    end
  else if req.op_name = 'describe_interface' then
    begin
      req.set_result(StaticAny(FullInterfaceDescription_marshaller,@describe_interface_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_interface_result := describe_interface;
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_attribute' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_attribute_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_attribute_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_attribute_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_attribute_type) as IStaticAny);
      req.add_in_arg(StaticAny(AttributeMode_marshaller,@create_attribute_mode) as IStaticAny);
      req.set_result(StaticAny(AttributeDef_marshaller,@create_attribute_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_attribute_result := create_attribute(create_attribute_id, create_attribute_name, create_attribute_version, create_attribute_type, create_attribute_mode);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_operation' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_operation_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_operation_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_operation_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_operation_result) as IStaticAny);
      req.add_in_arg(StaticAny(OperationMode_marshaller,@create_operation_mode) as IStaticAny);
      req.add_in_arg(StaticAny(ParameterDescription_seq_marshaller,@create_operation_params) as IStaticAny);
      req.add_in_arg(StaticAny(ExceptionDef_seq_marshaller,@create_operation_exceptions) as IStaticAny);
      req.add_in_arg(StaticAny(stat_seq_string,@create_operation_contexts) as IStaticAny);
      req.set_result(StaticAny(OperationDef_marshaller,@create_operation_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_operation_result := create_operation(create_operation_id, create_operation_name, create_operation_version, create_operation_result, create_operation_mode, create_operation_params, create_operation_exceptions, create_operation_contexts);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_base_interfaces' then
    begin
      req.set_result(StaticAny(InterfaceDef_seq_marshaller,@base_interfaces_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      base_interfaces_get_value := _get_base_interfaces;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_base_interfaces' then
    begin
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@base_interfaces_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_base_interfaces(base_interfaces_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'describe' then
    begin
      req.set_result(StaticAny(Description_marshaller,@describe_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_result := describe;
      req.write_results();
      exit;
    end
  else if req.op_name = 'move' then
    begin
      req.add_in_arg(StaticAny(Container_marshaller,@move_new_container) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@move_new_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@move_new_version) as IStaticAny);
      if not req.read_args() then  exit;
      move(move_new_container, move_new_name, move_new_version);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_id' then
    begin
      req.set_result(StaticAny(stat_string,@id_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      id_get_value := _get_id;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_id' then
    begin
      req.add_in_arg(StaticAny(stat_string,@id_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_id(id_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_name' then
    begin
      req.set_result(StaticAny(stat_string,@name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      name_get_value := _get_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@name_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_name(name_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_version' then
    begin
      req.set_result(StaticAny(stat_string,@version_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      version_get_value := _get_version;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_version' then
    begin
      req.add_in_arg(StaticAny(stat_string,@version_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_version(version_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_defined_in' then
    begin
      req.set_result(StaticAny(Container_marshaller,@defined_in_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      defined_in_get_value := _get_defined_in;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_absolute_name' then
    begin
      req.set_result(StaticAny(stat_string,@absolute_name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      absolute_name_get_value := _get_absolute_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_containing_repository' then
    begin
      req.set_result(StaticAny(Repository_marshaller,@containing_repository_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      containing_repository_get_value := _get_containing_repository;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_get_value := _get_type;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TInterfaceDef_marshaller
//***********************************************************
function TInterfaceDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IInterfaceDef(addr^) := TInterfaceDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TInterfaceDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IInterfaceDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TInterfaceDef_marshaller._free(var addr: Pointer);
begin
  IInterfaceDef(addr^) := nil;
end;

procedure TInterfaceDef_marshaller._create(var addr: Pointer);
begin
  IInterfaceDef(addr^) := TInterfaceDef_stub.Create();
end;

procedure TInterfaceDef_marshaller._assign(dst, src: Pointer);
begin
  IInterfaceDef(dst^) := IInterfaceDef(src^);
end;

function TInterfaceDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_InterfaceDef.typecode;
end;

//***********************************************************
// TInterfaceDescription_marshaller
//***********************************************************
function TInterfaceDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TInterfaceDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not stat_seq_string.demarshal(dec,@struct.base_interfaces) then exit;
  ir_int.TInterfaceDescription(addr^) := struct;
  result := true;
end;

procedure TInterfaceDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TInterfaceDescription;
begin
  struct := ir_int.TInterfaceDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  stat_seq_string.marshal(enc,@struct.base_interfaces);
end;

procedure TInterfaceDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TInterfaceDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TInterfaceDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TInterfaceDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TInterfaceDescription(addr^));
{$HINTS ON}
end;

procedure TInterfaceDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TInterfaceDescription(dst^) := ir_int.TInterfaceDescription(src^);
end;

function TInterfaceDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_InterfaceDescription.typecode;
end;

//***********************************************************
// TAbstractInterfaceDef
//***********************************************************
function TAbstractInterfaceDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AbstractInterfaceDef:1.0' then
    begin
      result := Pointer(self as IAbstractInterfaceDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TAbstractInterfaceDef._narrow(const obj : IORBObject): IAbstractInterfaceDef;
var
  p: Pointer;
  stub: TAbstractInterfaceDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/AbstractInterfaceDef:1.0');
  if p <> nil then
    result := IAbstractInterfaceDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/AbstractInterfaceDef:1.0') then
        begin
          stub := TAbstractInterfaceDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TAbstractInterfaceDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/AbstractInterfaceDef:1.0'
end;

//***********************************************************
// TAbstractInterfaceDef_stub
//***********************************************************
function TAbstractInterfaceDef_stub.is_a(const interface_id: TRepositoryId): Boolean;
var
  req: IStaticRequest;
  _interface_id: IStaticAny;
  _result: IStaticAny;
begin
  _interface_id := StaticAny(stat_string,@interface_id);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_a');
  req.add_in_arg(_interface_id);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.describe_interface: TFullInterfaceDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(FullInterfaceDescription_marshaller, @result);
  req := StaticRequest(self,'describe_interface');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _mode: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _mode := StaticAny(AttributeMode_marshaller,@mode);
  _result := StaticAny(AttributeDef_marshaller, @result);
  req := StaticRequest(self,'create_attribute');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_mode);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __result: IStaticAny;
  _mode: IStaticAny;
  _params: IStaticAny;
  _exceptions: IStaticAny;
  _contexts: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __result := StaticAny(IDLType_marshaller,@_result);
  _mode := StaticAny(OperationMode_marshaller,@mode);
  _params := StaticAny(ParameterDescription_seq_marshaller,@params);
  _exceptions := StaticAny(ExceptionDef_seq_marshaller,@exceptions);
  _contexts := StaticAny(stat_seq_string,@contexts);
  _result := StaticAny(OperationDef_marshaller, @result);
  req := StaticRequest(self,'create_operation');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__result);
  req.add_in_arg(_mode);
  req.add_in_arg(_params);
  req.add_in_arg(_exceptions);
  req.add_in_arg(_contexts);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAbstractInterfaceDef_stub._set_base_interfaces(const val: TInterfaceDefSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(InterfaceDef_seq_marshaller,@val);
  req := StaticRequest(self,'_set_base_interfaces');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_base_interfaces: TInterfaceDefSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(InterfaceDef_seq_marshaller, @result);
  req := StaticRequest(self,'_get_base_interfaces');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAbstractInterfaceDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAbstractInterfaceDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAbstractInterfaceDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAbstractInterfaceDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAbstractInterfaceDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAbstractInterfaceDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TAbstractInterfaceDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TAbstractInterfaceDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TAbstractInterfaceDef_stub_clp
//***********************************************************
function TAbstractInterfaceDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AbstractInterfaceDef:1.0' then
    begin
      result := Pointer(self as IAbstractInterfaceDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

//***********************************************************
// TAbstractInterfaceDef_serv
//***********************************************************
function TAbstractInterfaceDef_serv._this(): IAbstractInterfaceDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TAbstractInterfaceDef._narrow(obj);
end;

function TAbstractInterfaceDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/AbstractInterfaceDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TAbstractInterfaceDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/AbstractInterfaceDef:1.0';
end;

function TAbstractInterfaceDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TAbstractInterfaceDef_stub_clp.Create(poa,obj);
end;

procedure TAbstractInterfaceDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TAbstractInterfaceDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/AbstractInterfaceDef:1.0' then
    begin
      result := Pointer(IAbstractInterfaceDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TAbstractInterfaceDef_serv._narrow(const srv : IServant): IAbstractInterfaceDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/AbstractInterfaceDef:1.0');
  if p <> nil then
    result := IAbstractInterfaceDef(p)
end;

function TAbstractInterfaceDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TAbstractInterfaceDef_marshaller
//***********************************************************
function TAbstractInterfaceDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IAbstractInterfaceDef(addr^) := TAbstractInterfaceDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TAbstractInterfaceDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IAbstractInterfaceDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TAbstractInterfaceDef_marshaller._free(var addr: Pointer);
begin
  IAbstractInterfaceDef(addr^) := nil;
end;

procedure TAbstractInterfaceDef_marshaller._create(var addr: Pointer);
begin
  IAbstractInterfaceDef(addr^) := TAbstractInterfaceDef_stub.Create();
end;

procedure TAbstractInterfaceDef_marshaller._assign(dst, src: Pointer);
begin
  IAbstractInterfaceDef(dst^) := IAbstractInterfaceDef(src^);
end;

function TAbstractInterfaceDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_AbstractInterfaceDef.typecode;
end;

//***********************************************************
// TLocalInterfaceDef
//***********************************************************
function TLocalInterfaceDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/LocalInterfaceDef:1.0' then
    begin
      result := Pointer(self as ILocalInterfaceDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TLocalInterfaceDef._narrow(const obj : IORBObject): ILocalInterfaceDef;
var
  p: Pointer;
  stub: TLocalInterfaceDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/LocalInterfaceDef:1.0');
  if p <> nil then
    result := ILocalInterfaceDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/LocalInterfaceDef:1.0') then
        begin
          stub := TLocalInterfaceDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TLocalInterfaceDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/LocalInterfaceDef:1.0'
end;

//***********************************************************
// TLocalInterfaceDef_stub
//***********************************************************
function TLocalInterfaceDef_stub.is_a(const interface_id: TRepositoryId): Boolean;
var
  req: IStaticRequest;
  _interface_id: IStaticAny;
  _result: IStaticAny;
begin
  _interface_id := StaticAny(stat_string,@interface_id);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_a');
  req.add_in_arg(_interface_id);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.describe_interface: TFullInterfaceDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(FullInterfaceDescription_marshaller, @result);
  req := StaticRequest(self,'describe_interface');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _mode: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _mode := StaticAny(AttributeMode_marshaller,@mode);
  _result := StaticAny(AttributeDef_marshaller, @result);
  req := StaticRequest(self,'create_attribute');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_mode);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __result: IStaticAny;
  _mode: IStaticAny;
  _params: IStaticAny;
  _exceptions: IStaticAny;
  _contexts: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __result := StaticAny(IDLType_marshaller,@_result);
  _mode := StaticAny(OperationMode_marshaller,@mode);
  _params := StaticAny(ParameterDescription_seq_marshaller,@params);
  _exceptions := StaticAny(ExceptionDef_seq_marshaller,@exceptions);
  _contexts := StaticAny(stat_seq_string,@contexts);
  _result := StaticAny(OperationDef_marshaller, @result);
  req := StaticRequest(self,'create_operation');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__result);
  req.add_in_arg(_mode);
  req.add_in_arg(_params);
  req.add_in_arg(_exceptions);
  req.add_in_arg(_contexts);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLocalInterfaceDef_stub._set_base_interfaces(const val: TInterfaceDefSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(InterfaceDef_seq_marshaller,@val);
  req := StaticRequest(self,'_set_base_interfaces');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_base_interfaces: TInterfaceDefSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(InterfaceDef_seq_marshaller, @result);
  req := StaticRequest(self,'_get_base_interfaces');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLocalInterfaceDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLocalInterfaceDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLocalInterfaceDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLocalInterfaceDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLocalInterfaceDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLocalInterfaceDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TLocalInterfaceDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TLocalInterfaceDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TLocalInterfaceDef_stub_clp
//***********************************************************
function TLocalInterfaceDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/LocalInterfaceDef:1.0' then
    begin
      result := Pointer(self as ILocalInterfaceDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

//***********************************************************
// TLocalInterfaceDef_serv
//***********************************************************
function TLocalInterfaceDef_serv._this(): ILocalInterfaceDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TLocalInterfaceDef._narrow(obj);
end;

function TLocalInterfaceDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/LocalInterfaceDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TLocalInterfaceDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/LocalInterfaceDef:1.0';
end;

function TLocalInterfaceDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TLocalInterfaceDef_stub_clp.Create(poa,obj);
end;

procedure TLocalInterfaceDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TLocalInterfaceDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/LocalInterfaceDef:1.0' then
    begin
      result := Pointer(ILocalInterfaceDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TLocalInterfaceDef_serv._narrow(const srv : IServant): ILocalInterfaceDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/LocalInterfaceDef:1.0');
  if p <> nil then
    result := ILocalInterfaceDef(p)
end;

function TLocalInterfaceDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
begin
  result := true;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TLocalInterfaceDef_marshaller
//***********************************************************
function TLocalInterfaceDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  ILocalInterfaceDef(addr^) := TLocalInterfaceDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TLocalInterfaceDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := ILocalInterfaceDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TLocalInterfaceDef_marshaller._free(var addr: Pointer);
begin
  ILocalInterfaceDef(addr^) := nil;
end;

procedure TLocalInterfaceDef_marshaller._create(var addr: Pointer);
begin
  ILocalInterfaceDef(addr^) := TLocalInterfaceDef_stub.Create();
end;

procedure TLocalInterfaceDef_marshaller._assign(dst, src: Pointer);
begin
  ILocalInterfaceDef(dst^) := ILocalInterfaceDef(src^);
end;

function TLocalInterfaceDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_LocalInterfaceDef.typecode;
end;

//***********************************************************
// TValueMemberDef
//***********************************************************
function TValueMemberDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueMemberDef:1.0' then
    begin
      result := Pointer(self as IValueMemberDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TValueMemberDef._narrow(const obj : IORBObject): IValueMemberDef;
var
  p: Pointer;
  stub: TValueMemberDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/ValueMemberDef:1.0');
  if p <> nil then
    result := IValueMemberDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/ValueMemberDef:1.0') then
        begin
          stub := TValueMemberDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TValueMemberDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/ValueMemberDef:1.0'
end;

//***********************************************************
// TValueMemberDef_stub
//***********************************************************
function TValueMemberDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueMemberDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueMemberDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueMemberDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueMemberDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueMemberDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueMemberDef_stub._set_type_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_type_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_type_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_type_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueMemberDef_stub._set_access(const val: TVisibility);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_short,@val);
  req := StaticRequest(self,'_set_access');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueMemberDef_stub._get_access: TVisibility;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_short, @result);
  req := StaticRequest(self,'_get_access');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TValueMemberDef_stub_clp
//***********************************************************
function TValueMemberDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueMemberDef:1.0' then
    begin
      result := Pointer(self as IValueMemberDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TValueMemberDef_stub_clp._get_type: ITypeCode;
var
  _srv: IServant;
  srv: IValueMemberDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueMemberDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type
    end;
  _postinvoke();
end;

procedure TValueMemberDef_stub_clp._set_type_def(const val: IIDLType);
var
  _srv: IServant;
  srv: IValueMemberDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueMemberDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_type_def(val);
    end;
  _postinvoke();
end;

function TValueMemberDef_stub_clp._get_type_def: IIDLType;
var
  _srv: IServant;
  srv: IValueMemberDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueMemberDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type_def
    end;
  _postinvoke();
end;

procedure TValueMemberDef_stub_clp._set_access(const val: TVisibility);
var
  _srv: IServant;
  srv: IValueMemberDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueMemberDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_access(val);
    end;
  _postinvoke();
end;

function TValueMemberDef_stub_clp._get_access: TVisibility;
var
  _srv: IServant;
  srv: IValueMemberDef;
begin
  result := 0;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueMemberDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_access
    end;
  _postinvoke();
end;

//***********************************************************
// TValueMemberDef_serv
//***********************************************************
function TValueMemberDef_serv._this(): IValueMemberDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TValueMemberDef._narrow(obj);
end;

function TValueMemberDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/ValueMemberDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TValueMemberDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/ValueMemberDef:1.0';
end;

function TValueMemberDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TValueMemberDef_stub_clp.Create(poa,obj);
end;

procedure TValueMemberDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TValueMemberDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueMemberDef:1.0' then
    begin
      result := Pointer(IValueMemberDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TValueMemberDef_serv._narrow(const srv : IServant): IValueMemberDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/ValueMemberDef:1.0');
  if p <> nil then
    result := IValueMemberDef(p)
end;

function TValueMemberDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  type_get_value: ITypeCode;
  type_def_get_value: IIDLType;
  type_def_set_value: IIDLType;
  access_get_value: TVisibility;
  access_set_value: TVisibility;
begin
  result := true;
  if req.op_name = '_get_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_get_value := _get_type;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_type_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@type_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_def_get_value := _get_type_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_type_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@type_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_type_def(type_def_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_access' then
    begin
      req.set_result(StaticAny(stat_short,@access_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      access_get_value := _get_access;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_access' then
    begin
      req.add_in_arg(StaticAny(stat_short,@access_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_access(access_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TValueMemberDef_marshaller
//***********************************************************
function TValueMemberDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IValueMemberDef(addr^) := TValueMemberDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TValueMemberDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IValueMemberDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TValueMemberDef_marshaller._free(var addr: Pointer);
begin
  IValueMemberDef(addr^) := nil;
end;

procedure TValueMemberDef_marshaller._create(var addr: Pointer);
begin
  IValueMemberDef(addr^) := TValueMemberDef_stub.Create();
end;

procedure TValueMemberDef_marshaller._assign(dst, src: Pointer);
begin
  IValueMemberDef(dst^) := IValueMemberDef(src^);
end;

function TValueMemberDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_ValueMemberDef.typecode;
end;

//***********************************************************
// TFullValueDescription_marshaller
//***********************************************************
function TFullValueDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TFullValueDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_boolean.demarshal(dec,@struct.is_abstract) then exit;
  if not stat_boolean.demarshal(dec,@struct.is_custom) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not OperationDescription_seq_marshaller.demarshal(dec,@struct.operations) then exit;
  if not AttributeDescription_seq_marshaller.demarshal(dec,@struct.attributes) then exit;
  if not ValueMember_seq_marshaller.demarshal(dec,@struct.members) then exit;
  if not Initializer_seq_marshaller.demarshal(dec,@struct.initializers) then exit;
  if not stat_seq_string.demarshal(dec,@struct.supported_interfaces) then exit;
  if not stat_seq_string.demarshal(dec,@struct.abstract_base_values) then exit;
  if not stat_boolean.demarshal(dec,@struct.is_truncatable) then exit;
  if not stat_string.demarshal(dec,@struct.base_value) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  ir_int.TFullValueDescription(addr^) := struct;
  result := true;
end;

procedure TFullValueDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TFullValueDescription;
begin
  struct := ir_int.TFullValueDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_boolean.marshal(enc,@struct.is_abstract);
  stat_boolean.marshal(enc,@struct.is_custom);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  OperationDescription_seq_marshaller.marshal(enc,@struct.operations);
  AttributeDescription_seq_marshaller.marshal(enc,@struct.attributes);
  ValueMember_seq_marshaller.marshal(enc,@struct.members);
  Initializer_seq_marshaller.marshal(enc,@struct.initializers);
  stat_seq_string.marshal(enc,@struct.supported_interfaces);
  stat_seq_string.marshal(enc,@struct.abstract_base_values);
  stat_boolean.marshal(enc,@struct.is_truncatable);
  stat_string.marshal(enc,@struct.base_value);
  stat_TypeCode.marshal(enc,@struct._type);
end;

procedure TFullValueDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TFullValueDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TFullValueDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TFullValueDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TFullValueDescription(addr^));
{$HINTS ON}
end;

procedure TFullValueDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TFullValueDescription(dst^) := ir_int.TFullValueDescription(src^);
end;

function TFullValueDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_FullValueDescription.typecode;
end;

//***********************************************************
// TValueDef
//***********************************************************
function TValueDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueDef:1.0' then
    begin
      result := Pointer(self as IValueDef);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TValueDef._narrow(const obj : IORBObject): IValueDef;
var
  p: Pointer;
  stub: TValueDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/ValueDef:1.0');
  if p <> nil then
    result := IValueDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/ValueDef:1.0') then
        begin
          stub := TValueDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TValueDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/ValueDef:1.0'
end;

//***********************************************************
// TValueDef_stub
//***********************************************************
function TValueDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.lookup(const search_name: TScopedName): IContained;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _result := StaticAny(Contained_marshaller, @result);
  req := StaticRequest(self,'lookup');
  req.add_in_arg(_search_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.lookup_name(const search_name: TIdentifier; const levels_to_search: long; const limit_type: TDefinitionKind; const exclude_inherited: Boolean): TContainedSeq;
var
  req: IStaticRequest;
  _search_name: IStaticAny;
  _levels_to_search: IStaticAny;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _result: IStaticAny;
begin
  _search_name := StaticAny(stat_string,@search_name);
  _levels_to_search := StaticAny(stat_long,@levels_to_search);
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _result := StaticAny(Contained_seq_marshaller, @result);
  req := StaticRequest(self,'lookup_name');
  req.add_in_arg(_search_name);
  req.add_in_arg(_levels_to_search);
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.describe_contents(const limit_type: TDefinitionKind; const exclude_inherited: Boolean; const max_returned_objs: long): TDescriptionSeq;
var
  req: IStaticRequest;
  _limit_type: IStaticAny;
  _exclude_inherited: IStaticAny;
  _max_returned_objs: IStaticAny;
  _result: IStaticAny;
begin
  _limit_type := StaticAny(DefinitionKind_marshaller,@limit_type);
  _exclude_inherited := StaticAny(stat_boolean,@exclude_inherited);
  _max_returned_objs := StaticAny(stat_long,@max_returned_objs);
  _result := StaticAny(Description_seq_marshaller, @result);
  req := StaticRequest(self,'describe_contents');
  req.add_in_arg(_limit_type);
  req.add_in_arg(_exclude_inherited);
  req.add_in_arg(_max_returned_objs);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_module(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): IModuleDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(ModuleDef_marshaller, @result);
  req := StaticRequest(self,'create_module');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_constant(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const value: IAny): IConstantDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _value: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _value := StaticAny(stat_any,@value);
  _result := StaticAny(ConstantDef_marshaller, @result);
  req := StaticRequest(self,'create_constant');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_value);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_struct(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IStructDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(StructDef_marshaller, @result);
  req := StaticRequest(self,'create_struct');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_exception(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TStructMemberSeq): IExceptionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(StructMember_seq_marshaller,@members);
  _result := StaticAny(ExceptionDef_marshaller, @result);
  req := StaticRequest(self,'create_exception');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_union(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const discriminator_type: IIDLType; const members: TUnionMemberSeq): IUnionDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _discriminator_type: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _discriminator_type := StaticAny(IDLType_marshaller,@discriminator_type);
  _members := StaticAny(UnionMember_seq_marshaller,@members);
  _result := StaticAny(UnionDef_marshaller, @result);
  req := StaticRequest(self,'create_union');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_discriminator_type);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_enum(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const members: TEnumMemberSeq): IEnumDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _members: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _members := StaticAny(stat_seq_string,@members);
  _result := StaticAny(EnumDef_marshaller, @result);
  req := StaticRequest(self,'create_enum');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_members);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_alias(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type: IIDLType): IAliasDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type := StaticAny(IDLType_marshaller,@original_type);
  _result := StaticAny(AliasDef_marshaller, @result);
  req := StaticRequest(self,'create_alias');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): IInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(InterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_abstract_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TAbstractInterfaceDefSeq): IAbstractInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(AbstractInterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(AbstractInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_abstract_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_local_interface(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const base_interfaces: TInterfaceDefSeq): ILocalInterfaceDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _base_interfaces: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _base_interfaces := StaticAny(InterfaceDef_seq_marshaller,@base_interfaces);
  _result := StaticAny(LocalInterfaceDef_marshaller, @result);
  req := StaticRequest(self,'create_local_interface');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_base_interfaces);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_value(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const is_custom: Boolean; const is_abstract: Boolean; const base_value: IValueDef; const is_truncatable: Boolean; const abstract_base_values: TValueDefSeq; const supported_interfaces: TInterfaceDefSeq; const initializers: TInitializerSeq): IValueDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _is_custom: IStaticAny;
  _is_abstract: IStaticAny;
  _base_value: IStaticAny;
  _is_truncatable: IStaticAny;
  _abstract_base_values: IStaticAny;
  _supported_interfaces: IStaticAny;
  _initializers: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _is_custom := StaticAny(stat_boolean,@is_custom);
  _is_abstract := StaticAny(stat_boolean,@is_abstract);
  _base_value := StaticAny(ValueDef_marshaller,@base_value);
  _is_truncatable := StaticAny(stat_boolean,@is_truncatable);
  _abstract_base_values := StaticAny(ValueDef_seq_marshaller,@abstract_base_values);
  _supported_interfaces := StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces);
  _initializers := StaticAny(Initializer_seq_marshaller,@initializers);
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'create_value');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_is_custom);
  req.add_in_arg(_is_abstract);
  req.add_in_arg(_base_value);
  req.add_in_arg(_is_truncatable);
  req.add_in_arg(_abstract_base_values);
  req.add_in_arg(_supported_interfaces);
  req.add_in_arg(_initializers);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_value_box(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const original_type_def: IIDLType): IValueBoxDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _original_type_def: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _original_type_def := StaticAny(IDLType_marshaller,@original_type_def);
  _result := StaticAny(ValueBoxDef_marshaller, @result);
  req := StaticRequest(self,'create_value_box');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(_original_type_def);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_native(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec): INativeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  _result := StaticAny(NativeDef_marshaller, @result);
  req := StaticRequest(self,'create_native');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.is_a(const value_id: TRepositoryId): Boolean;
var
  req: IStaticRequest;
  _value_id: IStaticAny;
  _result: IStaticAny;
begin
  _value_id := StaticAny(stat_string,@value_id);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'is_a');
  req.add_in_arg(_value_id);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.describe_value: TFullValueDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(FullValueDescription_marshaller, @result);
  req := StaticRequest(self,'describe_value');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_value_member(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const access: TVisibility): IValueMemberDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _access: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _access := StaticAny(stat_short,@access);
  _result := StaticAny(ValueMemberDef_marshaller, @result);
  req := StaticRequest(self,'create_value_member');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_access);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __type: IStaticAny;
  _mode: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __type := StaticAny(IDLType_marshaller,@_type);
  _mode := StaticAny(AttributeMode_marshaller,@mode);
  _result := StaticAny(AttributeDef_marshaller, @result);
  req := StaticRequest(self,'create_attribute');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__type);
  req.add_in_arg(_mode);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub.create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _name: IStaticAny;
  _version: IStaticAny;
  __result: IStaticAny;
  _mode: IStaticAny;
  _params: IStaticAny;
  _exceptions: IStaticAny;
  _contexts: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_string,@id);
  _name := StaticAny(stat_string,@name);
  _version := StaticAny(stat_string,@version);
  __result := StaticAny(IDLType_marshaller,@_result);
  _mode := StaticAny(OperationMode_marshaller,@mode);
  _params := StaticAny(ParameterDescription_seq_marshaller,@params);
  _exceptions := StaticAny(ExceptionDef_seq_marshaller,@exceptions);
  _contexts := StaticAny(stat_seq_string,@contexts);
  _result := StaticAny(OperationDef_marshaller, @result);
  req := StaticRequest(self,'create_operation');
  req.add_in_arg(_id);
  req.add_in_arg(_name);
  req.add_in_arg(_version);
  req.add_in_arg(__result);
  req.add_in_arg(_mode);
  req.add_in_arg(_params);
  req.add_in_arg(_exceptions);
  req.add_in_arg(_contexts);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_supported_interfaces(const val: TInterfaceDefSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(InterfaceDef_seq_marshaller,@val);
  req := StaticRequest(self,'_set_supported_interfaces');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_supported_interfaces: TInterfaceDefSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(InterfaceDef_seq_marshaller, @result);
  req := StaticRequest(self,'_get_supported_interfaces');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_initializers(const val: TInitializerSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(Initializer_seq_marshaller,@val);
  req := StaticRequest(self,'_set_initializers');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_initializers: TInitializerSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Initializer_seq_marshaller, @result);
  req := StaticRequest(self,'_get_initializers');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_base_value(const val: IValueDef);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(ValueDef_marshaller,@val);
  req := StaticRequest(self,'_set_base_value');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_base_value: IValueDef;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ValueDef_marshaller, @result);
  req := StaticRequest(self,'_get_base_value');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_abstract_base_values(const val: TValueDefSeq);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(ValueDef_seq_marshaller,@val);
  req := StaticRequest(self,'_set_abstract_base_values');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_abstract_base_values: TValueDefSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ValueDef_seq_marshaller, @result);
  req := StaticRequest(self,'_get_abstract_base_values');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_is_abstract(const val: Boolean);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_boolean,@val);
  req := StaticRequest(self,'_set_is_abstract');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_is_abstract: Boolean;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'_get_is_abstract');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_is_custom(const val: Boolean);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_boolean,@val);
  req := StaticRequest(self,'_set_is_custom');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_is_custom: Boolean;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'_get_is_custom');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueDef_stub._set_is_truncatable(const val: Boolean);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_boolean,@val);
  req := StaticRequest(self,'_set_is_truncatable');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueDef_stub._get_is_truncatable: Boolean;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'_get_is_truncatable');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TValueDef_stub_clp
//***********************************************************
function TValueDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueDef:1.0' then
    begin
      result := Pointer(self as IValueDef);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end
  else if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TValueDef_stub_clp.is_a(const value_id: TRepositoryId): Boolean;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.is_a(value_id)
    end;
  _postinvoke();
end;

function TValueDef_stub_clp.describe_value: TFullValueDescription;
var
  _srv: IServant;
  srv: IValueDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe_value
    end;
  _postinvoke();
end;

function TValueDef_stub_clp.create_value_member(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const access: TVisibility): IValueMemberDef;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_value_member(id, name, version, _type, access)
    end;
  _postinvoke();
end;

function TValueDef_stub_clp.create_attribute(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _type: IIDLType; const mode: TAttributeMode): IAttributeDef;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_attribute(id, name, version, _type, mode)
    end;
  _postinvoke();
end;

function TValueDef_stub_clp.create_operation(const id: TRepositoryId; const name: TIdentifier; const version: TVersionSpec; const _result: IIDLType; const mode: TOperationMode; const params: TParDescriptionSeq; const exceptions: TExceptionDefSeq; const contexts: TContextIdSeq): IOperationDef;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_operation(id, name, version, _result, mode, params, exceptions, contexts)
    end;
  _postinvoke();
end;

function TValueDef_stub_clp.describe: TDescription;
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv.describe
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv.move(new_container, new_name, new_version)
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_id(const val: TRepositoryId);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_id(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_id: TRepositoryId;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_id
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_name(const val: TIdentifier);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_name(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_name: TIdentifier;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_name
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_version(const val: TVersionSpec);
var
  _srv: IServant;
  srv: IContained;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        srv._set_version(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_version: TVersionSpec;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_version
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_defined_in: IContainer;
var
  _srv: IServant;
  srv: IContained;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_defined_in
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_absolute_name: TScopedName;
var
  _srv: IServant;
  srv: IContained;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_absolute_name
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_containing_repository: IRepository;
var
  _srv: IServant;
  srv: IContained;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TContained_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_containing_repository
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_type: ITypeCode;
var
  _srv: IServant;
  srv: IIDLType;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TIDLType_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_supported_interfaces(const val: TInterfaceDefSeq);
var
  _srv: IServant;
  srv: IValueDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_supported_interfaces(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_supported_interfaces: TInterfaceDefSeq;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_supported_interfaces
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_initializers(const val: TInitializerSeq);
var
  _srv: IServant;
  srv: IValueDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_initializers(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_initializers: TInitializerSeq;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_initializers
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_base_value(const val: IValueDef);
var
  _srv: IServant;
  srv: IValueDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_base_value(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_base_value: IValueDef;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_base_value
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_abstract_base_values(const val: TValueDefSeq);
var
  _srv: IServant;
  srv: IValueDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_abstract_base_values(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_abstract_base_values: TValueDefSeq;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_abstract_base_values
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_is_abstract(const val: Boolean);
var
  _srv: IServant;
  srv: IValueDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_is_abstract(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_is_abstract: Boolean;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_is_abstract
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_is_custom(const val: Boolean);
var
  _srv: IServant;
  srv: IValueDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_is_custom(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_is_custom: Boolean;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_is_custom
    end;
  _postinvoke();
end;

procedure TValueDef_stub_clp._set_is_truncatable(const val: Boolean);
var
  _srv: IServant;
  srv: IValueDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_is_truncatable(val);
    end;
  _postinvoke();
end;

function TValueDef_stub_clp._get_is_truncatable: Boolean;
var
  _srv: IServant;
  srv: IValueDef;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_is_truncatable
    end;
  _postinvoke();
end;

//***********************************************************
// TValueDef_serv
//***********************************************************
function TValueDef_serv._this(): IValueDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TValueDef._narrow(obj);
end;

function TValueDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/ValueDef:1.0';
  if repoid = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := true;
      exit;
    end;
  if repoid = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := true;
      exit;
    end;
  if not result then
    result := inherited _is_a(repoid);
end;

function TValueDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/ValueDef:1.0';
end;

function TValueDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TValueDef_stub_clp.Create(poa,obj);
end;

procedure TValueDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TValueDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueDef:1.0' then
    begin
      result := Pointer(IValueDef(self));
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/Contained:1.0' then
    begin
      result := Pointer(self as IContained);
      exit;
    end;
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TValueDef_serv._narrow(const srv : IServant): IValueDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/ValueDef:1.0');
  if p <> nil then
    result := IValueDef(p)
end;

function TValueDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  is_a_result: Boolean;
  is_a_value_id: TRepositoryId;
  describe_value_result: TFullValueDescription;
  create_value_member_result: IValueMemberDef;
  create_value_member_id: TRepositoryId;
  create_value_member_name: TIdentifier;
  create_value_member_version: TVersionSpec;
  create_value_member_type: IIDLType;
  create_value_member_access: TVisibility;
  create_attribute_result: IAttributeDef;
  create_attribute_id: TRepositoryId;
  create_attribute_name: TIdentifier;
  create_attribute_version: TVersionSpec;
  create_attribute_type: IIDLType;
  create_attribute_mode: TAttributeMode;
  create_operation_result: IOperationDef;
  create_operation_id: TRepositoryId;
  create_operation_name: TIdentifier;
  create_operation_version: TVersionSpec;
  create_operation_result: IIDLType;
  create_operation_mode: TOperationMode;
  create_operation_params: TParDescriptionSeq;
  create_operation_exceptions: TExceptionDefSeq;
  create_operation_contexts: TContextIdSeq;
  supported_interfaces_get_value: TInterfaceDefSeq;
  supported_interfaces_set_value: TInterfaceDefSeq;
  initializers_get_value: TInitializerSeq;
  initializers_set_value: TInitializerSeq;
  base_value_get_value: IValueDef;
  base_value_set_value: IValueDef;
  abstract_base_values_get_value: TValueDefSeq;
  abstract_base_values_set_value: TValueDefSeq;
  is_abstract_get_value: Boolean;
  is_abstract_set_value: Boolean;
  is_custom_get_value: Boolean;
  is_custom_set_value: Boolean;
  is_truncatable_get_value: Boolean;
  is_truncatable_set_value: Boolean;
  describe_result: TDescription;
  move_new_container: IContainer;
  move_new_name: TIdentifier;
  move_new_version: TVersionSpec;
  id_get_value: TRepositoryId;
  id_set_value: TRepositoryId;
  name_get_value: TIdentifier;
  name_set_value: TIdentifier;
  version_get_value: TVersionSpec;
  version_set_value: TVersionSpec;
  defined_in_get_value: IContainer;
  absolute_name_get_value: TScopedName;
  containing_repository_get_value: IRepository;
  type_get_value: ITypeCode;
begin
  result := true;
  if req.op_name = 'is_a' then
    begin
      req.add_in_arg(StaticAny(stat_string,@is_a_value_id) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@is_a_result) as IStaticAny);
      if not req.read_args() then  exit;
      is_a_result := is_a(is_a_value_id);
      req.write_results();
      exit;
    end
  else if req.op_name = 'describe_value' then
    begin
      req.set_result(StaticAny(FullValueDescription_marshaller,@describe_value_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_value_result := describe_value;
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_value_member' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_value_member_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_member_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_value_member_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_value_member_type) as IStaticAny);
      req.add_in_arg(StaticAny(stat_short,@create_value_member_access) as IStaticAny);
      req.set_result(StaticAny(ValueMemberDef_marshaller,@create_value_member_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_value_member_result := create_value_member(create_value_member_id, create_value_member_name, create_value_member_version, create_value_member_type, create_value_member_access);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_attribute' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_attribute_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_attribute_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_attribute_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_attribute_type) as IStaticAny);
      req.add_in_arg(StaticAny(AttributeMode_marshaller,@create_attribute_mode) as IStaticAny);
      req.set_result(StaticAny(AttributeDef_marshaller,@create_attribute_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_attribute_result := create_attribute(create_attribute_id, create_attribute_name, create_attribute_version, create_attribute_type, create_attribute_mode);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_operation' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_operation_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_operation_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_operation_version) as IStaticAny);
      req.add_in_arg(StaticAny(IDLType_marshaller,@create_operation_result) as IStaticAny);
      req.add_in_arg(StaticAny(OperationMode_marshaller,@create_operation_mode) as IStaticAny);
      req.add_in_arg(StaticAny(ParameterDescription_seq_marshaller,@create_operation_params) as IStaticAny);
      req.add_in_arg(StaticAny(ExceptionDef_seq_marshaller,@create_operation_exceptions) as IStaticAny);
      req.add_in_arg(StaticAny(stat_seq_string,@create_operation_contexts) as IStaticAny);
      req.set_result(StaticAny(OperationDef_marshaller,@create_operation_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_operation_result := create_operation(create_operation_id, create_operation_name, create_operation_version, create_operation_result, create_operation_mode, create_operation_params, create_operation_exceptions, create_operation_contexts);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_supported_interfaces' then
    begin
      req.set_result(StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      supported_interfaces_get_value := _get_supported_interfaces;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_supported_interfaces' then
    begin
      req.add_in_arg(StaticAny(InterfaceDef_seq_marshaller,@supported_interfaces_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_supported_interfaces(supported_interfaces_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_initializers' then
    begin
      req.set_result(StaticAny(Initializer_seq_marshaller,@initializers_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      initializers_get_value := _get_initializers;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_initializers' then
    begin
      req.add_in_arg(StaticAny(Initializer_seq_marshaller,@initializers_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_initializers(initializers_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_base_value' then
    begin
      req.set_result(StaticAny(ValueDef_marshaller,@base_value_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      base_value_get_value := _get_base_value;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_base_value' then
    begin
      req.add_in_arg(StaticAny(ValueDef_marshaller,@base_value_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_base_value(base_value_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_abstract_base_values' then
    begin
      req.set_result(StaticAny(ValueDef_seq_marshaller,@abstract_base_values_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      abstract_base_values_get_value := _get_abstract_base_values;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_abstract_base_values' then
    begin
      req.add_in_arg(StaticAny(ValueDef_seq_marshaller,@abstract_base_values_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_abstract_base_values(abstract_base_values_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_is_abstract' then
    begin
      req.set_result(StaticAny(stat_boolean,@is_abstract_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      is_abstract_get_value := _get_is_abstract;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_is_abstract' then
    begin
      req.add_in_arg(StaticAny(stat_boolean,@is_abstract_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_is_abstract(is_abstract_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_is_custom' then
    begin
      req.set_result(StaticAny(stat_boolean,@is_custom_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      is_custom_get_value := _get_is_custom;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_is_custom' then
    begin
      req.add_in_arg(StaticAny(stat_boolean,@is_custom_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_is_custom(is_custom_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_is_truncatable' then
    begin
      req.set_result(StaticAny(stat_boolean,@is_truncatable_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      is_truncatable_get_value := _get_is_truncatable;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_is_truncatable' then
    begin
      req.add_in_arg(StaticAny(stat_boolean,@is_truncatable_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_is_truncatable(is_truncatable_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = 'describe' then
    begin
      req.set_result(StaticAny(Description_marshaller,@describe_result) as IStaticAny);
      if not req.read_args() then  exit;
      describe_result := describe;
      req.write_results();
      exit;
    end
  else if req.op_name = 'move' then
    begin
      req.add_in_arg(StaticAny(Container_marshaller,@move_new_container) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@move_new_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@move_new_version) as IStaticAny);
      if not req.read_args() then  exit;
      move(move_new_container, move_new_name, move_new_version);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_id' then
    begin
      req.set_result(StaticAny(stat_string,@id_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      id_get_value := _get_id;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_id' then
    begin
      req.add_in_arg(StaticAny(stat_string,@id_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_id(id_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_name' then
    begin
      req.set_result(StaticAny(stat_string,@name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      name_get_value := _get_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@name_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_name(name_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_version' then
    begin
      req.set_result(StaticAny(stat_string,@version_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      version_get_value := _get_version;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_version' then
    begin
      req.add_in_arg(StaticAny(stat_string,@version_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_version(version_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_defined_in' then
    begin
      req.set_result(StaticAny(Container_marshaller,@defined_in_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      defined_in_get_value := _get_defined_in;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_absolute_name' then
    begin
      req.set_result(StaticAny(stat_string,@absolute_name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      absolute_name_get_value := _get_absolute_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_containing_repository' then
    begin
      req.set_result(StaticAny(Repository_marshaller,@containing_repository_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      containing_repository_get_value := _get_containing_repository;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_get_value := _get_type;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TValueDef_marshaller
//***********************************************************
function TValueDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IValueDef(addr^) := TValueDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TValueDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IValueDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TValueDef_marshaller._free(var addr: Pointer);
begin
  IValueDef(addr^) := nil;
end;

procedure TValueDef_marshaller._create(var addr: Pointer);
begin
  IValueDef(addr^) := TValueDef_stub.Create();
end;

procedure TValueDef_marshaller._assign(dst, src: Pointer);
begin
  IValueDef(dst^) := IValueDef(src^);
end;

function TValueDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_ValueDef.typecode;
end;

//***********************************************************
// TValueDescription_marshaller
//***********************************************************
function TValueDescription_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_int.TValueDescription;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_boolean.demarshal(dec,@struct.is_abstract) then exit;
  if not stat_boolean.demarshal(dec,@struct.is_custom) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not stat_seq_string.demarshal(dec,@struct.supported_interfaces) then exit;
  if not stat_seq_string.demarshal(dec,@struct.abstract_base_values) then exit;
  if not stat_boolean.demarshal(dec,@struct.is_truncatable) then exit;
  if not stat_string.demarshal(dec,@struct.base_value) then exit;
  ir_int.TValueDescription(addr^) := struct;
  result := true;
end;

procedure TValueDescription_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_int.TValueDescription;
begin
  struct := ir_int.TValueDescription(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_boolean.marshal(enc,@struct.is_abstract);
  stat_boolean.marshal(enc,@struct.is_custom);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  stat_seq_string.marshal(enc,@struct.supported_interfaces);
  stat_seq_string.marshal(enc,@struct.abstract_base_values);
  stat_boolean.marshal(enc,@struct.is_truncatable);
  stat_string.marshal(enc,@struct.base_value);
end;

procedure TValueDescription_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_int.TValueDescription(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TValueDescription_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_int.TValueDescription));
{$HINTS OFF}
  System.Initialize(ir_int.TValueDescription(addr^));
{$HINTS ON}
end;

procedure TValueDescription_marshaller._assign(dst, src: Pointer);
begin
  ir_int.TValueDescription(dst^) := ir_int.TValueDescription(src^);
end;

function TValueDescription_marshaller.typecode: ITypeCode;
begin
  result := _tc_ValueDescription.typecode;
end;

//***********************************************************
// TValueBoxDef
//***********************************************************
function TValueBoxDef.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueBoxDef:1.0' then
    begin
      result := Pointer(self as IValueBoxDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TValueBoxDef._narrow(const obj : IORBObject): IValueBoxDef;
var
  p: Pointer;
  stub: TValueBoxDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/ValueBoxDef:1.0');
  if p <> nil then
    result := IValueBoxDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/ValueBoxDef:1.0') then
        begin
          stub := TValueBoxDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TValueBoxDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/ValueBoxDef:1.0'
end;

//***********************************************************
// TValueBoxDef_stub
//***********************************************************
function TValueBoxDef_stub.describe: TDescription;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Description_marshaller, @result);
  req := StaticRequest(self,'describe');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueBoxDef_stub.move(const new_container: IContainer; const new_name: TIdentifier; const new_version: TVersionSpec);
var
  req: IStaticRequest;
  _new_container: IStaticAny;
  _new_name: IStaticAny;
  _new_version: IStaticAny;
begin
  _new_container := StaticAny(Container_marshaller,@new_container);
  _new_name := StaticAny(stat_string,@new_name);
  _new_version := StaticAny(stat_string,@new_version);
  req := StaticRequest(self,'move');
  req.add_in_arg(_new_container);
  req.add_in_arg(_new_name);
  req.add_in_arg(_new_version);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueBoxDef_stub._set_id(const val: TRepositoryId);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_id');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_id: TRepositoryId;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_id');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueBoxDef_stub._set_name(const val: TIdentifier);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_name');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_name: TIdentifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueBoxDef_stub._set_version(const val: TVersionSpec);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_version');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_version: TVersionSpec;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_version');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_defined_in: IContainer;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Container_marshaller, @result);
  req := StaticRequest(self,'_get_defined_in');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_absolute_name: TScopedName;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_absolute_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_containing_repository: IRepository;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(Repository_marshaller, @result);
  req := StaticRequest(self,'_get_containing_repository');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueBoxDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueBoxDef_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TValueBoxDef_stub._set_original_type_def(const val: IIDLType);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(IDLType_marshaller,@val);
  req := StaticRequest(self,'_set_original_type_def');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TValueBoxDef_stub._get_original_type_def: IIDLType;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(IDLType_marshaller, @result);
  req := StaticRequest(self,'_get_original_type_def');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TValueBoxDef_stub_clp
//***********************************************************
function TValueBoxDef_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueBoxDef:1.0' then
    begin
      result := Pointer(self as IValueBoxDef);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

procedure TValueBoxDef_stub_clp._set_original_type_def(const val: IIDLType);
var
  _srv: IServant;
  srv: IValueBoxDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueBoxDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_original_type_def(val);
    end;
  _postinvoke();
end;

function TValueBoxDef_stub_clp._get_original_type_def: IIDLType;
var
  _srv: IServant;
  srv: IValueBoxDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TValueBoxDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_original_type_def
    end;
  _postinvoke();
end;

//***********************************************************
// TValueBoxDef_serv
//***********************************************************
function TValueBoxDef_serv._this(): IValueBoxDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TValueBoxDef._narrow(obj);
end;

function TValueBoxDef_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/ValueBoxDef:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TValueBoxDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/ValueBoxDef:1.0';
end;

function TValueBoxDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TValueBoxDef_stub_clp.Create(poa,obj);
end;

procedure TValueBoxDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TValueBoxDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/ValueBoxDef:1.0' then
    begin
      result := Pointer(IValueBoxDef(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TValueBoxDef_serv._narrow(const srv : IServant): IValueBoxDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/ValueBoxDef:1.0');
  if p <> nil then
    result := IValueBoxDef(p)
end;

function TValueBoxDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  original_type_def_get_value: IIDLType;
  original_type_def_set_value: IIDLType;
begin
  result := true;
  if req.op_name = '_get_original_type_def' then
    begin
      req.set_result(StaticAny(IDLType_marshaller,@original_type_def_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      original_type_def_get_value := _get_original_type_def;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_original_type_def' then
    begin
      req.add_in_arg(StaticAny(IDLType_marshaller,@original_type_def_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_original_type_def(original_type_def_set_value);
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TValueBoxDef_marshaller
//***********************************************************
function TValueBoxDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IValueBoxDef(addr^) := TValueBoxDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TValueBoxDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IValueBoxDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TValueBoxDef_marshaller._free(var addr: Pointer);
begin
  IValueBoxDef(addr^) := nil;
end;

procedure TValueBoxDef_marshaller._create(var addr: Pointer);
begin
  IValueBoxDef(addr^) := TValueBoxDef_stub.Create();
end;

procedure TValueBoxDef_marshaller._assign(dst, src: Pointer);
begin
  IValueBoxDef(dst^) := IValueBoxDef(src^);
end;

function TValueBoxDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_ValueBoxDef.typecode;
end;

initialization
  Description_marshaller := TDescription_marshaller.Create();
  Contained_marshaller := TContained_marshaller.Create();
  Contained_seq_marshaller := TContained_seq_marshaller.Create();
  InterfaceDef_seq_marshaller := TInterfaceDef_seq_marshaller.Create();
  AbstractInterfaceDef_seq_marshaller := TAbstractInterfaceDef_seq_marshaller.Create();
  LocalInterfaceDef_seq_marshaller := TLocalInterfaceDef_seq_marshaller.Create();
  ValueDef_seq_marshaller := TValueDef_seq_marshaller.Create();
  Initializer_marshaller := TInitializer_marshaller.Create();
  Initializer_seq_marshaller := TInitializer_seq_marshaller.Create();
  Description_seq_marshaller := TDescription_seq_marshaller.Create();
  Container_marshaller := TContainer_marshaller.Create();
  PrimitiveKind_marshaller := TPrimitiveKind_marshaller.Create();
  Repository_marshaller := TRepository_marshaller.Create();
  ModuleDef_marshaller := TModuleDef_marshaller.Create();
  ModuleDescription_marshaller := TModuleDescription_marshaller.Create();
  ConstantDef_marshaller := TConstantDef_marshaller.Create();
  ConstantDescription_marshaller := TConstantDescription_marshaller.Create();
  TypedefDef_marshaller := TTypedefDef_marshaller.Create();
  TypeDescription_marshaller := TTypeDescription_marshaller.Create();
  StructDef_marshaller := TStructDef_marshaller.Create();
  UnionDef_marshaller := TUnionDef_marshaller.Create();
  EnumDef_marshaller := TEnumDef_marshaller.Create();
  AliasDef_marshaller := TAliasDef_marshaller.Create();
  NativeDef_marshaller := TNativeDef_marshaller.Create();
  PrimitiveDef_marshaller := TPrimitiveDef_marshaller.Create();
  StringDef_marshaller := TStringDef_marshaller.Create();
  WstringDef_marshaller := TWstringDef_marshaller.Create();
  FixedDef_marshaller := TFixedDef_marshaller.Create();
  SequenceDef_marshaller := TSequenceDef_marshaller.Create();
  ArrayDef_marshaller := TArrayDef_marshaller.Create();
  ExceptionDef_marshaller := TExceptionDef_marshaller.Create();
  ExceptionDescription_marshaller := TExceptionDescription_marshaller.Create();
  ExceptionDef_seq_marshaller := TExceptionDef_seq_marshaller.Create();
  ExceptionDescription_seq_marshaller := TExceptionDescription_seq_marshaller.Create();
  AttributeMode_marshaller := TAttributeMode_marshaller.Create();
  AttributeDef_marshaller := TAttributeDef_marshaller.Create();
  AttributeDescription_marshaller := TAttributeDescription_marshaller.Create();
  OperationMode_marshaller := TOperationMode_marshaller.Create();
  ParameterMode_marshaller := TParameterMode_marshaller.Create();
  ParameterDescription_marshaller := TParameterDescription_marshaller.Create();
  ParameterDescription_seq_marshaller := TParameterDescription_seq_marshaller.Create();
  OperationDef_marshaller := TOperationDef_marshaller.Create();
  OperationDescription_marshaller := TOperationDescription_marshaller.Create();
  OperationDescription_seq_marshaller := TOperationDescription_seq_marshaller.Create();
  AttributeDescription_seq_marshaller := TAttributeDescription_seq_marshaller.Create();
  FullInterfaceDescription_marshaller := TFullInterfaceDescription_marshaller.Create();
  InterfaceDef_marshaller := TInterfaceDef_marshaller.Create();
  InterfaceDescription_marshaller := TInterfaceDescription_marshaller.Create();
  AbstractInterfaceDef_marshaller := TAbstractInterfaceDef_marshaller.Create();
  LocalInterfaceDef_marshaller := TLocalInterfaceDef_marshaller.Create();
  ValueMemberDef_marshaller := TValueMemberDef_marshaller.Create();
  FullValueDescription_marshaller := TFullValueDescription_marshaller.Create();
  ValueDef_marshaller := TValueDef_marshaller.Create();
  ValueDescription_marshaller := TValueDescription_marshaller.Create();
  ValueBoxDef_marshaller := TValueBoxDef_marshaller.Create();
  _tc_Description := CreateTypeCodeConst('010000000f0000001c030000010000002c00000049444c3a6f6d672e6f72672f434f5242412f436f6e7461696e65642f44657363726970'+
    '74696f6e3a312e30000c0000004465736372697074696f6e0002000000050000006b696e640000000011000000b0020000010000002500'+
    '000049444c3a6f6d672e6f72672f434f5242412f446566696e6974696f6e4b696e643a312e30000000000f000000446566696e6974696f'+
    '6e4b696e6400002400000008000000646b5f6e6f6e650007000000646b5f616c6c00000d000000646b5f41747472696275746500000000'+
    '0c000000646b5f436f6e7374616e74000d000000646b5f457863657074696f6e000000000d000000646b5f496e74657266616365000000'+
    '000a000000646b5f4d6f64756c650000000d000000646b5f4f7065726174696f6e000000000b000000646b5f5479706564656600000900'+
    '0000646b5f416c696173000000000a000000646b5f53747275637400000009000000646b5f556e696f6e0000000008000000646b5f456e'+
    '756d000d000000646b5f5072696d6974697665000000000a000000646b5f537472696e670000000c000000646b5f53657175656e636500'+
    '09000000646b5f4172726179000000000e000000646b5f5265706f7369746f72790000000b000000646b5f57737472696e670000090000'+
    '00646b5f46697865640000000009000000646b5f56616c7565000000000c000000646b5f56616c7565426f78000f000000646b5f56616c'+
    '75654d656d62657200000a000000646b5f4e617469766500000015000000646b5f4162737472616374496e746572666163650000000012'+
    '000000646b5f4c6f63616c496e746572666163650000000d000000646b5f436f6d706f6e656e740000000008000000646b5f486f6d6500'+
    '0b000000646b5f466163746f727900000a000000646b5f46696e6465720000000e000000646b5f5072696d6172794b6579000000090000'+
    '00646b5f456d697473000000000d000000646b5f5075626c6973686573000000000c000000646b5f436f6e73756d6573000c000000646b'+
    '5f50726f76696465730008000000646b5f55736573000600000076616c75650000000b000000');
  _tc_Contained := CreateTypeCodeConst('010000000e00000036000000010000002000000049444c3a6f6d672e6f72672f434f5242412f436f6e7461696e65643a312e30000a0000'+
    '00436f6e7461696e656400');
  _tc_Contained_seq := CreateTypeCodeConst('010000001300000048000000010000000e00000036000000010000002000000049444c3a6f6d672e6f72672f434f5242412f436f6e7461'+
    '696e65643a312e30000a000000436f6e7461696e656400000000000000');
  _tc_InterfaceDef_seq := CreateTypeCodeConst('010000001300000050000000010000000e0000003d000000010000002300000049444c3a6f6d672e6f72672f434f5242412f496e746572'+
    '666163654465663a312e3000000d000000496e746572666163654465660000000000000000');
  _tc_AbstractInterfaceDef_seq := CreateTypeCodeConst('010000001300000060000000010000000e0000004d000000010000002b00000049444c3a6f6d672e6f72672f434f5242412f4162737472'+
    '616374496e746572666163654465663a312e300000150000004162737472616374496e746572666163654465660000000000000000');
  _tc_LocalInterfaceDef_seq := CreateTypeCodeConst('010000001300000058000000010000000e00000046000000010000002800000049444c3a6f6d672e6f72672f434f5242412f4c6f63616c'+
    '496e746572666163654465663a312e3000120000004c6f63616c496e7465726661636544656600000000000000');
  _tc_ValueDef_seq := CreateTypeCodeConst('010000001300000048000000010000000e00000035000000010000001f00000049444c3a6f6d672e6f72672f434f5242412f56616c7565'+
    '4465663a312e3000000900000056616c75654465660000000000000000');
  _tc_Initializer := CreateTypeCodeConst('010000000f00000000020000010000002200000049444c3a6f6d672e6f72672f434f5242412f496e697469616c697a65723a312e300000'+
    '000c000000496e697469616c697a65720002000000080000006d656d62657273001500000054010000010000002600000049444c3a6f6d'+
    '672e6f72672f434f5242412f5374727563744d656d6265725365713a312e30000000100000005374727563744d656d6265725365710013'+
    '00000008010000010000000f000000f8000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5374727563744d656d62'+
    '65723a312e3000000d0000005374727563744d656d6265720000000003000000050000006e616d65000000001500000044000000010000'+
    '002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e746966696572'+
    '000012000000000000000500000074797065000000000c00000009000000747970655f646566000000000e00000034000000010000001e'+
    '00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c54797065000000000005000000'+
    '6e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e'+
    '30000000000b0000004964656e74696669657200001200000000000000');
  _tc_Initializer_seq := CreateTypeCodeConst('010000001300000010020000010000000f00000000020000010000002200000049444c3a6f6d672e6f72672f434f5242412f496e697469'+
    '616c697a65723a312e300000000c000000496e697469616c697a65720002000000080000006d656d626572730015000000540100000100'+
    '00002600000049444c3a6f6d672e6f72672f434f5242412f5374727563744d656d6265725365713a312e30000000100000005374727563'+
    '744d656d626572536571001300000008010000010000000f000000f8000000010000002300000049444c3a6f6d672e6f72672f434f5242'+
    '412f5374727563744d656d6265723a312e3000000d0000005374727563744d656d6265720000000003000000050000006e616d65000000'+
    '001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b00'+
    '00004964656e746966696572000012000000000000000500000074797065000000000c00000009000000747970655f646566000000000e'+
    '00000034000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c54'+
    '7970650000000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f49'+
    '64656e7469666965723a312e30000000000b0000004964656e7469666965720000120000000000000000000000');
  _tc_Description_seq := CreateTypeCodeConst('010000001300000084030000010000000f00000074030000010000002c00000049444c3a6f6d672e6f72672f434f5242412f436f6e7461'+
    '696e65722f4465736372697074696f6e3a312e30000c0000004465736372697074696f6e000300000011000000636f6e7461696e65645f'+
    '6f626a656374000000000e00000036000000010000002000000049444c3a6f6d672e6f72672f434f5242412f436f6e7461696e65643a31'+
    '2e30000a000000436f6e7461696e6564000000050000006b696e640000000011000000b0020000010000002500000049444c3a6f6d672e'+
    '6f72672f434f5242412f446566696e6974696f6e4b696e643a312e30000000000f000000446566696e6974696f6e4b696e640000240000'+
    '0008000000646b5f6e6f6e650007000000646b5f616c6c00000d000000646b5f417474726962757465000000000c000000646b5f436f6e'+
    '7374616e74000d000000646b5f457863657074696f6e000000000d000000646b5f496e74657266616365000000000a000000646b5f4d6f'+
    '64756c650000000d000000646b5f4f7065726174696f6e000000000b000000646b5f54797065646566000009000000646b5f416c696173'+
    '000000000a000000646b5f53747275637400000009000000646b5f556e696f6e0000000008000000646b5f456e756d000d000000646b5f'+
    '5072696d6974697665000000000a000000646b5f537472696e670000000c000000646b5f53657175656e63650009000000646b5f417272'+
    '6179000000000e000000646b5f5265706f7369746f72790000000b000000646b5f57737472696e67000009000000646b5f466978656400'+
    '00000009000000646b5f56616c7565000000000c000000646b5f56616c7565426f78000f000000646b5f56616c75654d656d6265720000'+
    '0a000000646b5f4e617469766500000015000000646b5f4162737472616374496e746572666163650000000012000000646b5f4c6f6361'+
    '6c496e746572666163650000000d000000646b5f436f6d706f6e656e740000000008000000646b5f486f6d65000b000000646b5f466163'+
    '746f727900000a000000646b5f46696e6465720000000e000000646b5f5072696d6172794b657900000009000000646b5f456d69747300'+
    '0000000d000000646b5f5075626c6973686573000000000c000000646b5f436f6e73756d6573000c000000646b5f50726f766964657300'+
    '08000000646b5f55736573000600000076616c75650000000b00000000000000');
  _tc_Container := CreateTypeCodeConst('010000000e00000036000000010000002000000049444c3a6f6d672e6f72672f434f5242412f436f6e7461696e65723a312e30000a0000'+
    '00436f6e7461696e657200');
  _tc_PrimitiveKind := CreateTypeCodeConst('01000000110000009e010000010000002400000049444c3a6f6d672e6f72672f434f5242412f5072696d69746976654b696e643a312e30'+
    '000e0000005072696d69746976654b696e640000001600000008000000706b5f6e756c6c0008000000706b5f766f69640009000000706b'+
    '5f73686f72740000000008000000706b5f6c6f6e67000a000000706b5f7573686f727400000009000000706b5f756c6f6e670000000009'+
    '000000706b5f666c6f6174000000000a000000706b5f646f75626c650000000b000000706b5f626f6f6c65616e000008000000706b5f63'+
    '6861720009000000706b5f6f637465740000000007000000706b5f616e7900000c000000706b5f54797065436f6465000d000000706b5f'+
    '5072696e636970616c000000000a000000706b5f737472696e670000000a000000706b5f6f626a7265660000000c000000706b5f6c6f6e'+
    '676c6f6e67000d000000706b5f756c6f6e676c6f6e67000000000e000000706b5f6c6f6e67646f75626c6500000009000000706b5f7763'+
    '686172000000000b000000706b5f77737472696e6700000e000000706b5f76616c75655f6261736500');
  _tc_Repository := CreateTypeCodeConst('010000000e0000003b000000010000002100000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f72793a312e30000000'+
    '000b0000005265706f7369746f727900');
  _tc_ModuleDef := CreateTypeCodeConst('010000000e00000036000000010000002000000049444c3a6f6d672e6f72672f434f5242412f4d6f64756c654465663a312e30000a0000'+
    '004d6f64756c6544656600');
  _tc_ModuleDescription := CreateTypeCodeConst('010000000f000000b4010000010000002800000049444c3a6f6d672e6f72672f434f5242412f4d6f64756c654465736372697074696f6e'+
    '3a312e3000120000004d6f64756c654465736372697074696f6e00000004000000050000006e616d650000000015000000440000000100'+
    '00002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e7469666965'+
    '720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265'+
    '706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b000000646566696e6564'+
    '5f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e30'+
    '00000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e0015000000440000000100000022'+
    '00000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e5370656300'+
    '1200000000000000');
  _tc_ConstantDef := CreateTypeCodeConst('010000000e0000003c000000010000002200000049444c3a6f6d672e6f72672f434f5242412f436f6e7374616e744465663a312e300000'+
    '000c000000436f6e7374616e7444656600');
  _tc_ConstantDescription := CreateTypeCodeConst('010000000f000000d8010000010000002a00000049444c3a6f6d672e6f72672f434f5242412f436f6e7374616e74446573637269707469'+
    '6f6e3a312e3000000014000000436f6e7374616e744465736372697074696f6e0006000000050000006e616d6500000000150000004400'+
    '0000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e74'+
    '69666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242'+
    '412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b000000646566'+
    '696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f72794964'+
    '3a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e00150000004400000001'+
    '0000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e53'+
    '7065630012000000000000000500000074797065000000000c0000000600000076616c75650000000b000000');
  _tc_TypedefDef := CreateTypeCodeConst('010000000e0000003b000000010000002100000049444c3a6f6d672e6f72672f434f5242412f547970656465664465663a312e30000000'+
    '000b0000005479706564656644656600');
  _tc_TypeDescription := CreateTypeCodeConst('010000000f000000c0010000010000002600000049444c3a6f6d672e6f72672f434f5242412f547970654465736372697074696f6e3a31'+
    '2e3000000010000000547970654465736372697074696f6e0005000000050000006e616d65000000001500000044000000010000002100'+
    '000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e746966696572000012'+
    '0000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369'+
    '746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b000000646566696e65645f696e00'+
    '001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d00'+
    '00005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500000044000000010000002200000049'+
    '444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e537065630012000000'+
    '000000000500000074797065000000000c000000');
  _tc_StructDef := CreateTypeCodeConst('010000000e00000036000000010000002000000049444c3a6f6d672e6f72672f434f5242412f5374727563744465663a312e30000a0000'+
    '0053747275637444656600');
  _tc_UnionDef := CreateTypeCodeConst('010000000e00000035000000010000001f00000049444c3a6f6d672e6f72672f434f5242412f556e696f6e4465663a312e300000090000'+
    '00556e696f6e44656600');
  _tc_EnumDef := CreateTypeCodeConst('010000000e00000034000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f456e756d4465663a312e30000000080000'+
    '00456e756d44656600');
  _tc_AliasDef := CreateTypeCodeConst('010000000e00000035000000010000001f00000049444c3a6f6d672e6f72672f434f5242412f416c6961734465663a312e300000090000'+
    '00416c69617344656600');
  _tc_NativeDef := CreateTypeCodeConst('010000000e00000036000000010000002000000049444c3a6f6d672e6f72672f434f5242412f4e61746976654465663a312e30000a0000'+
    '004e617469766544656600');
  _tc_PrimitiveDef := CreateTypeCodeConst('010000000e0000003d000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5072696d69746976654465663a312e3000'+
    '000d0000005072696d697469766544656600');
  _tc_StringDef := CreateTypeCodeConst('010000000e00000036000000010000002000000049444c3a6f6d672e6f72672f434f5242412f537472696e674465663a312e30000a0000'+
    '00537472696e6744656600');
  _tc_WstringDef := CreateTypeCodeConst('010000000e0000003b000000010000002100000049444c3a6f6d672e6f72672f434f5242412f57737472696e674465663a312e30000000'+
    '000b00000057737472696e6744656600');
  _tc_FixedDef := CreateTypeCodeConst('010000000e00000035000000010000001f00000049444c3a6f6d672e6f72672f434f5242412f46697865644465663a312e300000090000'+
    '00466978656444656600');
  _tc_SequenceDef := CreateTypeCodeConst('010000000e0000003c000000010000002200000049444c3a6f6d672e6f72672f434f5242412f53657175656e63654465663a312e300000'+
    '000c00000053657175656e636544656600');
  _tc_ArrayDef := CreateTypeCodeConst('010000000e00000035000000010000001f00000049444c3a6f6d672e6f72672f434f5242412f41727261794465663a312e300000090000'+
    '00417272617944656600');
  _tc_ExceptionDef := CreateTypeCodeConst('010000000e0000003d000000010000002300000049444c3a6f6d672e6f72672f434f5242412f457863657074696f6e4465663a312e3000'+
    '000d000000457863657074696f6e44656600');
  _tc_ExceptionDescription := CreateTypeCodeConst('010000000f000000cc010000010000002b00000049444c3a6f6d672e6f72672f434f5242412f457863657074696f6e4465736372697074'+
    '696f6e3a312e30000015000000457863657074696f6e4465736372697074696f6e0000000005000000050000006e616d65000000001500'+
    '000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b00000049'+
    '64656e7469666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f'+
    '434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b0000'+
    '00646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f'+
    '727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500000044'+
    '000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273'+
    '696f6e537065630012000000000000000500000074797065000000000c000000');
  _tc_ExceptionDef_seq := CreateTypeCodeConst('010000001300000050000000010000000e0000003d000000010000002300000049444c3a6f6d672e6f72672f434f5242412f4578636570'+
    '74696f6e4465663a312e3000000d000000457863657074696f6e4465660000000000000000');
  _tc_ExceptionDescription_seq := CreateTypeCodeConst('0100000013000000dc010000010000000f000000cc010000010000002b00000049444c3a6f6d672e6f72672f434f5242412f4578636570'+
    '74696f6e4465736372697074696f6e3a312e30000015000000457863657074696f6e4465736372697074696f6e00000000050000000500'+
    '00006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a'+
    '312e30000000000b0000004964656e74696669657200001200000000000000030000006964000015000000480000000100000023000000'+
    '49444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f72794964000000'+
    '0012000000000000000b000000646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f'+
    '5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076'+
    '657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e'+
    '300000000c00000056657273696f6e537065630012000000000000000500000074797065000000000c00000000000000');
  _tc_AttributeMode := CreateTypeCodeConst('010000001100000066000000010000002400000049444c3a6f6d672e6f72672f434f5242412f4174747269627574654d6f64653a312e30'+
    '000e0000004174747269627574654d6f6465000000020000000c000000415454525f4e4f524d414c000e000000415454525f524541444f4e4c5900');
  _tc_AttributeDef := CreateTypeCodeConst('010000000e0000003d000000010000002300000049444c3a6f6d672e6f72672f434f5242412f4174747269627574654465663a312e3000'+
    '000d00000041747472696275746544656600');
  _tc_AttributeDescription := CreateTypeCodeConst('010000000f00000046020000010000002b00000049444c3a6f6d672e6f72672f434f5242412f4174747269627574654465736372697074'+
    '696f6e3a312e300000150000004174747269627574654465736372697074696f6e0000000006000000050000006e616d65000000001500'+
    '000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b00000049'+
    '64656e7469666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f'+
    '434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b0000'+
    '00646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f'+
    '727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500000044'+
    '000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273'+
    '696f6e537065630012000000000000000500000074797065000000000c000000050000006d6f6465000000001100000066000000010000'+
    '002400000049444c3a6f6d672e6f72672f434f5242412f4174747269627574654d6f64653a312e30000e0000004174747269627574654d'+
    '6f6465000000020000000c000000415454525f4e4f524d414c000e000000415454525f524541444f4e4c5900');
  _tc_OperationMode := CreateTypeCodeConst('010000001100000062000000010000002400000049444c3a6f6d672e6f72672f434f5242412f4f7065726174696f6e4d6f64653a312e30'+
    '000e0000004f7065726174696f6e4d6f6465000000020000000a0000004f505f4e4f524d414c0000000a0000004f505f4f4e4557415900');
  _tc_ParameterMode := CreateTypeCodeConst('010000001100000074000000010000002400000049444c3a6f6d672e6f72672f434f5242412f506172616d657465724d6f64653a312e30'+
    '000e000000506172616d657465724d6f64650000000300000009000000504152414d5f494e000000000a000000504152414d5f4f555400'+
    '00000c000000504152414d5f494e4f555400');
  _tc_ParameterDescription := CreateTypeCodeConst('010000000f00000090010000010000002b00000049444c3a6f6d672e6f72672f434f5242412f506172616d657465724465736372697074'+
    '696f6e3a312e30000015000000506172616d657465724465736372697074696f6e0000000004000000050000006e616d65000000001500'+
    '000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b00000049'+
    '64656e746966696572000012000000000000000500000074797065000000000c00000009000000747970655f646566000000000e000000'+
    '34000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c54797065'+
    '00050000006d6f6465000000001100000074000000010000002400000049444c3a6f6d672e6f72672f434f5242412f506172616d657465'+
    '724d6f64653a312e30000e000000506172616d657465724d6f64650000000300000009000000504152414d5f494e000000000a00000050'+
    '4152414d5f4f55540000000c000000504152414d5f494e4f555400');
  _tc_ParameterDescription_seq := CreateTypeCodeConst('0100000013000000a0010000010000000f00000090010000010000002b00000049444c3a6f6d672e6f72672f434f5242412f506172616d'+
    '657465724465736372697074696f6e3a312e30000015000000506172616d657465724465736372697074696f6e00000000040000000500'+
    '00006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a'+
    '312e30000000000b0000004964656e746966696572000012000000000000000500000074797065000000000c0000000900000074797065'+
    '5f646566000000000e00000034000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000'+
    '000800000049444c5479706500050000006d6f6465000000001100000074000000010000002400000049444c3a6f6d672e6f72672f434f'+
    '5242412f506172616d657465724d6f64653a312e30000e000000506172616d657465724d6f64650000000300000009000000504152414d'+
    '5f494e000000000a000000504152414d5f4f55540000000c000000504152414d5f494e4f55540000000000');
  _tc_OperationDef := CreateTypeCodeConst('010000000e0000003d000000010000002300000049444c3a6f6d672e6f72672f434f5242412f4f7065726174696f6e4465663a312e3000'+
    '000d0000004f7065726174696f6e44656600');
  _tc_OperationDescription := CreateTypeCodeConst('010000000f00000094070000010000002b00000049444c3a6f6d672e6f72672f434f5242412f4f7065726174696f6e4465736372697074'+
    '696f6e3a312e300000150000004f7065726174696f6e4465736372697074696f6e0000000009000000050000006e616d65000000001500'+
    '000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b00000049'+
    '64656e7469666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f'+
    '434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b0000'+
    '00646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f'+
    '727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500000044'+
    '000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273'+
    '696f6e5370656300120000000000000007000000726573756c7400000c000000050000006d6f6465000000001100000062000000010000'+
    '002400000049444c3a6f6d672e6f72672f434f5242412f4f7065726174696f6e4d6f64653a312e30000e0000004f7065726174696f6e4d'+
    '6f6465000000020000000a0000004f505f4e4f524d414c0000000a0000004f505f4f4e4557415900000009000000636f6e746578747300'+
    '00000015000000ec000000010000002300000049444c3a6f6d672e6f72672f434f5242412f436f6e7465787449645365713a312e300000'+
    '0d000000436f6e7465787449645365710000000013000000a4000000010000001500000094000000010000002800000049444c3a6f6d67'+
    '2e6f72672f434f5242412f436f6e746578744964656e7469666965723a312e300012000000436f6e746578744964656e74696669657200'+
    '00001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b'+
    '0000004964656e74696669657200001200000000000000000000000b000000706172616d6574657273000015000000f001000001000000'+
    '2800000049444c3a6f6d672e6f72672f434f5242412f5061724465736372697074696f6e5365713a312e30001200000050617244657363'+
    '72697074696f6e53657100000013000000a0010000010000000f00000090010000010000002b00000049444c3a6f6d672e6f72672f434f'+
    '5242412f506172616d657465724465736372697074696f6e3a312e30000015000000506172616d657465724465736372697074696f6e00'+
    '00000004000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964'+
    '656e7469666965723a312e30000000000b0000004964656e746966696572000012000000000000000500000074797065000000000c0000'+
    '0009000000747970655f646566000000000e00000034000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c54'+
    '7970653a312e300000000800000049444c5479706500050000006d6f6465000000001100000074000000010000002400000049444c3a6f'+
    '6d672e6f72672f434f5242412f506172616d657465724d6f64653a312e30000e000000506172616d657465724d6f646500000003000000'+
    '09000000504152414d5f494e000000000a000000504152414d5f4f55540000000c000000504152414d5f494e4f555400000000000b0000'+
    '00657863657074696f6e730000150000002c020000010000002800000049444c3a6f6d672e6f72672f434f5242412f4578634465736372'+
    '697074696f6e5365713a312e3000120000004578634465736372697074696f6e53657100000013000000dc010000010000000f000000cc'+
    '010000010000002b00000049444c3a6f6d672e6f72672f434f5242412f457863657074696f6e4465736372697074696f6e3a312e300000'+
    '15000000457863657074696f6e4465736372697074696f6e0000000005000000050000006e616d65000000001500000044000000010000'+
    '002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e746966696572'+
    '0000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f526570'+
    '6f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b000000646566696e65645f'+
    '696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000'+
    '000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500000044000000010000002200'+
    '000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e537065630012'+
    '000000000000000500000074797065000000000c00000000000000');
  _tc_OperationDescription_seq := CreateTypeCodeConst('0100000013000000a4070000010000000f00000094070000010000002b00000049444c3a6f6d672e6f72672f434f5242412f4f70657261'+
    '74696f6e4465736372697074696f6e3a312e300000150000004f7065726174696f6e4465736372697074696f6e00000000090000000500'+
    '00006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a'+
    '312e30000000000b0000004964656e74696669657200001200000000000000030000006964000015000000480000000100000023000000'+
    '49444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f72794964000000'+
    '0012000000000000000b000000646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f'+
    '5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076'+
    '657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e'+
    '300000000c00000056657273696f6e5370656300120000000000000007000000726573756c7400000c000000050000006d6f6465000000'+
    '001100000062000000010000002400000049444c3a6f6d672e6f72672f434f5242412f4f7065726174696f6e4d6f64653a312e30000e00'+
    '00004f7065726174696f6e4d6f6465000000020000000a0000004f505f4e4f524d414c0000000a0000004f505f4f4e4557415900000009'+
    '000000636f6e74657874730000000015000000ec000000010000002300000049444c3a6f6d672e6f72672f434f5242412f436f6e746578'+
    '7449645365713a312e3000000d000000436f6e7465787449645365710000000013000000a4000000010000001500000094000000010000'+
    '002800000049444c3a6f6d672e6f72672f434f5242412f436f6e746578744964656e7469666965723a312e300012000000436f6e746578'+
    '744964656e7469666965720000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e746966'+
    '6965723a312e30000000000b0000004964656e74696669657200001200000000000000000000000b000000706172616d65746572730000'+
    '15000000f0010000010000002800000049444c3a6f6d672e6f72672f434f5242412f5061724465736372697074696f6e5365713a312e30'+
    '00120000005061724465736372697074696f6e53657100000013000000a0010000010000000f00000090010000010000002b0000004944'+
    '4c3a6f6d672e6f72672f434f5242412f506172616d657465724465736372697074696f6e3a312e30000015000000506172616d65746572'+
    '4465736372697074696f6e0000000004000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e'+
    '6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e74696669657200001200000000000000050000'+
    '0074797065000000000c00000009000000747970655f646566000000000e00000034000000010000001e00000049444c3a6f6d672e6f72'+
    '672f434f5242412f49444c547970653a312e300000000800000049444c5479706500050000006d6f646500000000110000007400000001'+
    '0000002400000049444c3a6f6d672e6f72672f434f5242412f506172616d657465724d6f64653a312e30000e000000506172616d657465'+
    '724d6f64650000000300000009000000504152414d5f494e000000000a000000504152414d5f4f55540000000c000000504152414d5f49'+
    '4e4f555400000000000b000000657863657074696f6e730000150000002c020000010000002800000049444c3a6f6d672e6f72672f434f'+
    '5242412f4578634465736372697074696f6e5365713a312e3000120000004578634465736372697074696f6e53657100000013000000dc'+
    '010000010000000f000000cc010000010000002b00000049444c3a6f6d672e6f72672f434f5242412f457863657074696f6e4465736372'+
    '697074696f6e3a312e30000015000000457863657074696f6e4465736372697074696f6e0000000005000000050000006e616d65000000'+
    '001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b00'+
    '00004964656e7469666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f'+
    '72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f72794964000000001200000000000000'+
    '0b000000646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f73'+
    '69746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500'+
    '000044000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056'+
    '657273696f6e537065630012000000000000000500000074797065000000000c0000000000000000000000');
  _tc_AttributeDescription_seq := CreateTypeCodeConst('010000001300000058020000010000000f00000046020000010000002b00000049444c3a6f6d672e6f72672f434f5242412f4174747269'+
    '627574654465736372697074696f6e3a312e300000150000004174747269627574654465736372697074696f6e00000000060000000500'+
    '00006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a'+
    '312e30000000000b0000004964656e74696669657200001200000000000000030000006964000015000000480000000100000023000000'+
    '49444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f72794964000000'+
    '0012000000000000000b000000646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f'+
    '5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076'+
    '657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e'+
    '300000000c00000056657273696f6e537065630012000000000000000500000074797065000000000c000000050000006d6f6465000000'+
    '001100000066000000010000002400000049444c3a6f6d672e6f72672f434f5242412f4174747269627574654d6f64653a312e30000e00'+
    '00004174747269627574654d6f6465000000020000000c000000415454525f4e4f524d414c000e000000415454525f524541444f4e4c59'+
    '00000000000000');
  _tc_FullInterfaceDescription := CreateTypeCodeConst('010000000f000000700d0000010000003c00000049444c3a6f6d672e6f72672f434f5242412f496e746572666163654465662f46756c6c'+
    '496e746572666163654465736372697074696f6e3a312e30001900000046756c6c496e746572666163654465736372697074696f6e0000'+
    '000008000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f496465'+
    '6e7469666965723a312e30000000000b0000004964656e7469666965720000120000000000000003000000696400001500000048000000'+
    '010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f736974'+
    '6f727949640000000012000000000000000b000000646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d'+
    '672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f72794964000000001200000000'+
    '0000000800000076657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f'+
    '6e537065633a312e300000000c00000056657273696f6e537065630012000000000000000b0000006f7065726174696f6e730000150000'+
    '00f4070000010000002700000049444c3a6f6d672e6f72672f434f5242412f4f704465736372697074696f6e5365713a312e3000001100'+
    '00004f704465736372697074696f6e5365710000000013000000a4070000010000000f00000094070000010000002b00000049444c3a6f'+
    '6d672e6f72672f434f5242412f4f7065726174696f6e4465736372697074696f6e3a312e300000150000004f7065726174696f6e446573'+
    '6372697074696f6e0000000009000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f7267'+
    '2f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e74696669657200001200000000000000030000006964'+
    '00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d'+
    '0000005265706f7369746f727949640000000012000000000000000b000000646566696e65645f696e0000150000004800000001000000'+
    '2300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949'+
    '640000000012000000000000000800000076657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f72672f434f'+
    '5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e5370656300120000000000000007000000726573756c'+
    '7400000c000000050000006d6f6465000000001100000062000000010000002400000049444c3a6f6d672e6f72672f434f5242412f4f70'+
    '65726174696f6e4d6f64653a312e30000e0000004f7065726174696f6e4d6f6465000000020000000a0000004f505f4e4f524d414c0000'+
    '000a0000004f505f4f4e4557415900000009000000636f6e74657874730000000015000000ec000000010000002300000049444c3a6f6d'+
    '672e6f72672f434f5242412f436f6e7465787449645365713a312e3000000d000000436f6e7465787449645365710000000013000000a4'+
    '000000010000001500000094000000010000002800000049444c3a6f6d672e6f72672f434f5242412f436f6e746578744964656e746966'+
    '6965723a312e300012000000436f6e746578744964656e7469666965720000001500000044000000010000002100000049444c3a6f6d67'+
    '2e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e746966696572000012000000000000000000'+
    '00000b000000706172616d6574657273000015000000f0010000010000002800000049444c3a6f6d672e6f72672f434f5242412f506172'+
    '4465736372697074696f6e5365713a312e3000120000005061724465736372697074696f6e53657100000013000000a001000001000000'+
    '0f00000090010000010000002b00000049444c3a6f6d672e6f72672f434f5242412f506172616d657465724465736372697074696f6e3a'+
    '312e30000015000000506172616d657465724465736372697074696f6e0000000004000000050000006e616d6500000000150000004400'+
    '0000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e74'+
    '6966696572000012000000000000000500000074797065000000000c00000009000000747970655f646566000000000e00000034000000'+
    '010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c5479706500050000'+
    '006d6f6465000000001100000074000000010000002400000049444c3a6f6d672e6f72672f434f5242412f506172616d657465724d6f64'+
    '653a312e30000e000000506172616d657465724d6f64650000000300000009000000504152414d5f494e000000000a000000504152414d'+
    '5f4f55540000000c000000504152414d5f494e4f555400000000000b000000657863657074696f6e730000150000002c02000001000000'+
    '2800000049444c3a6f6d672e6f72672f434f5242412f4578634465736372697074696f6e5365713a312e30001200000045786344657363'+
    '72697074696f6e53657100000013000000dc010000010000000f000000cc010000010000002b00000049444c3a6f6d672e6f72672f434f'+
    '5242412f457863657074696f6e4465736372697074696f6e3a312e30000015000000457863657074696f6e4465736372697074696f6e00'+
    '00000005000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964'+
    '656e7469666965723a312e30000000000b0000004964656e74696669657200001200000000000000030000006964000015000000480000'+
    '00010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369'+
    '746f727949640000000012000000000000000b000000646566696e65645f696e00001500000048000000010000002300000049444c3a6f'+
    '6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000'+
    '000000000800000076657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f72672f434f5242412f5665727369'+
    '6f6e537065633a312e300000000c00000056657273696f6e537065630012000000000000000500000074797065000000000c0000000000'+
    '0000000000000b00000061747472696275746573000015000000ac020000010000002900000049444c3a6f6d672e6f72672f434f524241'+
    '2f417474724465736372697074696f6e5365713a312e300000000013000000417474724465736372697074696f6e536571000013000000'+
    '58020000010000000f00000046020000010000002b00000049444c3a6f6d672e6f72672f434f5242412f41747472696275746544657363'+
    '72697074696f6e3a312e300000150000004174747269627574654465736372697074696f6e0000000006000000050000006e616d650000'+
    '00001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b'+
    '0000004964656e7469666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e'+
    '6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000'+
    '000b000000646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f'+
    '7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e0015'+
    '00000044000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c000000'+
    '56657273696f6e537065630012000000000000000500000074797065000000000c000000050000006d6f64650000000011000000660000'+
    '00010000002400000049444c3a6f6d672e6f72672f434f5242412f4174747269627574654d6f64653a312e30000e000000417474726962'+
    '7574654d6f6465000000020000000c000000415454525f4e4f524d414c000e000000415454525f524541444f4e4c590000000000000010'+
    '000000626173655f696e74657266616365730015000000a4000000010000002600000049444c3a6f6d672e6f72672f434f5242412f5265'+
    '706f7369746f727949645365713a312e30000000100000005265706f7369746f7279496453657100130000005800000001000000150000'+
    '0048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265'+
    '706f7369746f72794964000000001200000000000000000000000500000074797065000000000c000000');
  _tc_InterfaceDef := CreateTypeCodeConst('010000000e0000003d000000010000002300000049444c3a6f6d672e6f72672f434f5242412f496e746572666163654465663a312e3000'+
    '000d000000496e7465726661636544656600');
  _tc_InterfaceDescription := CreateTypeCodeConst('010000000f0000007c020000010000002b00000049444c3a6f6d672e6f72672f434f5242412f496e746572666163654465736372697074'+
    '696f6e3a312e30000015000000496e746572666163654465736372697074696f6e0000000005000000050000006e616d65000000001500'+
    '000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b00000049'+
    '64656e7469666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f'+
    '434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b0000'+
    '00646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f'+
    '727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500000044'+
    '000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273'+
    '696f6e5370656300120000000000000010000000626173655f696e74657266616365730015000000a4000000010000002600000049444c'+
    '3a6f6d672e6f72672f434f5242412f5265706f7369746f727949645365713a312e30000000100000005265706f7369746f727949645365'+
    '71001300000058000000010000001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f736974'+
    '6f727949643a312e3000000d0000005265706f7369746f7279496400000000120000000000000000000000');
  _tc_AbstractInterfaceDef := CreateTypeCodeConst('010000000e0000004d000000010000002b00000049444c3a6f6d672e6f72672f434f5242412f4162737472616374496e74657266616365'+
    '4465663a312e300000150000004162737472616374496e7465726661636544656600');
  _tc_LocalInterfaceDef := CreateTypeCodeConst('010000000e00000046000000010000002800000049444c3a6f6d672e6f72672f434f5242412f4c6f63616c496e74657266616365446566'+
    '3a312e3000120000004c6f63616c496e7465726661636544656600');
  _tc_ValueMemberDef := CreateTypeCodeConst('010000000e00000043000000010000002500000049444c3a6f6d672e6f72672f434f5242412f56616c75654d656d6265724465663a312e'+
    '30000000000f00000056616c75654d656d62657244656600');
  _tc_FullValueDescription := CreateTypeCodeConst('010000000f00000014140000010000003400000049444c3a6f6d672e6f72672f434f5242412f56616c75654465662f46756c6c56616c75'+
    '654465736372697074696f6e3a312e30001500000046756c6c56616c75654465736372697074696f6e000000000f000000050000006e61'+
    '6d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e3000'+
    '0000000b0000004964656e7469666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a'+
    '6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f7279496400000000120000'+
    '00000000000c00000069735f616273747261637400080000000a00000069735f637573746f6d000000080000000b000000646566696e65'+
    '645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e'+
    '3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e00150000004400000001000000'+
    '2200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e53706563'+
    '0012000000000000000b0000006f7065726174696f6e73000015000000f4070000010000002700000049444c3a6f6d672e6f72672f434f'+
    '5242412f4f704465736372697074696f6e5365713a312e300000110000004f704465736372697074696f6e5365710000000013000000a4'+
    '070000010000000f00000094070000010000002b00000049444c3a6f6d672e6f72672f434f5242412f4f7065726174696f6e4465736372'+
    '697074696f6e3a312e300000150000004f7065726174696f6e4465736372697074696f6e0000000009000000050000006e616d65000000'+
    '001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b00'+
    '00004964656e7469666965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f'+
    '72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f72794964000000001200000000000000'+
    '0b000000646566696e65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f73'+
    '69746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500'+
    '000044000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056'+
    '657273696f6e5370656300120000000000000007000000726573756c7400000c000000050000006d6f6465000000001100000062000000'+
    '010000002400000049444c3a6f6d672e6f72672f434f5242412f4f7065726174696f6e4d6f64653a312e30000e0000004f706572617469'+
    '6f6e4d6f6465000000020000000a0000004f505f4e4f524d414c0000000a0000004f505f4f4e4557415900000009000000636f6e746578'+
    '74730000000015000000ec000000010000002300000049444c3a6f6d672e6f72672f434f5242412f436f6e7465787449645365713a312e'+
    '3000000d000000436f6e7465787449645365710000000013000000a4000000010000001500000094000000010000002800000049444c3a'+
    '6f6d672e6f72672f434f5242412f436f6e746578744964656e7469666965723a312e300012000000436f6e746578744964656e74696669'+
    '65720000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e300000'+
    '00000b0000004964656e74696669657200001200000000000000000000000b000000706172616d6574657273000015000000f001000001'+
    '0000002800000049444c3a6f6d672e6f72672f434f5242412f5061724465736372697074696f6e5365713a312e30001200000050617244'+
    '65736372697074696f6e53657100000013000000a0010000010000000f00000090010000010000002b00000049444c3a6f6d672e6f7267'+
    '2f434f5242412f506172616d657465724465736372697074696f6e3a312e30000015000000506172616d65746572446573637269707469'+
    '6f6e0000000004000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f524241'+
    '2f4964656e7469666965723a312e30000000000b0000004964656e74696669657200001200000000000000050000007479706500000000'+
    '0c00000009000000747970655f646566000000000e00000034000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f49'+
    '444c547970653a312e300000000800000049444c5479706500050000006d6f646500000000110000007400000001000000240000004944'+
    '4c3a6f6d672e6f72672f434f5242412f506172616d657465724d6f64653a312e30000e000000506172616d657465724d6f646500000003'+
    '00000009000000504152414d5f494e000000000a000000504152414d5f4f55540000000c000000504152414d5f494e4f55540000000000'+
    '0b000000657863657074696f6e730000150000002c020000010000002800000049444c3a6f6d672e6f72672f434f5242412f4578634465'+
    '736372697074696f6e5365713a312e3000120000004578634465736372697074696f6e53657100000013000000dc010000010000000f00'+
    '0000cc010000010000002b00000049444c3a6f6d672e6f72672f434f5242412f457863657074696f6e4465736372697074696f6e3a312e'+
    '30000015000000457863657074696f6e4465736372697074696f6e0000000005000000050000006e616d65000000001500000044000000'+
    '010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e746966'+
    '6965720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f'+
    '5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b000000646566696e'+
    '65645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a31'+
    '2e3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e001500000044000000010000'+
    '002200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e537065'+
    '630012000000000000000500000074797065000000000c00000000000000000000000b00000061747472696275746573000015000000ac'+
    '020000010000002900000049444c3a6f6d672e6f72672f434f5242412f417474724465736372697074696f6e5365713a312e3000000000'+
    '13000000417474724465736372697074696f6e53657100001300000058020000010000000f00000046020000010000002b00000049444c'+
    '3a6f6d672e6f72672f434f5242412f4174747269627574654465736372697074696f6e3a312e3000001500000041747472696275746544'+
    '65736372697074696f6e0000000006000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f'+
    '72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e7469666965720000120000000000000003000000'+
    '696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000'+
    '000d0000005265706f7369746f727949640000000012000000000000000b000000646566696e65645f696e000015000000480000000100'+
    '00002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f72'+
    '7949640000000012000000000000000800000076657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f72672f'+
    '434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e5370656300120000000000000005000000747970'+
    '65000000000c000000050000006d6f6465000000001100000066000000010000002400000049444c3a6f6d672e6f72672f434f5242412f'+
    '4174747269627574654d6f64653a312e30000e0000004174747269627574654d6f6465000000020000000c000000415454525f4e4f524d'+
    '414c000e000000415454525f524541444f4e4c5900000000000000080000006d656d626572730015000000b40200000100000025000000'+
    '49444c3a6f6d672e6f72672f434f5242412f56616c75654d656d6265725365713a312e30000000000f00000056616c75654d656d626572'+
    '53657100001300000068020000010000000f00000058020000010000002200000049444c3a6f6d672e6f72672f434f5242412f56616c75'+
    '654d656d6265723a312e300000000c00000056616c75654d656d6265720007000000050000006e616d6500000000150000004400000001'+
    '0000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e74696669'+
    '65720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f52'+
    '65706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b000000646566696e65'+
    '645f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e'+
    '3000000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e00150000004400000001000000'+
    '2200000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e53706563'+
    '0012000000000000000500000074797065000000000c00000009000000747970655f646566000000000e00000034000000010000001e00'+
    '000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c5479706500070000006163636573'+
    '7300001500000040000000010000002100000049444c3a6f6d672e6f72672f434f5242412f5669736962696c6974793a312e3000000000'+
    '0b0000005669736962696c697479000002000000000000000d000000696e697469616c697a65727300000000150000005c020000010000'+
    '002500000049444c3a6f6d672e6f72672f434f5242412f496e697469616c697a65725365713a312e30000000000f000000496e69746961'+
    '6c697a657253657100001300000010020000010000000f00000000020000010000002200000049444c3a6f6d672e6f72672f434f524241'+
    '2f496e697469616c697a65723a312e300000000c000000496e697469616c697a65720002000000080000006d656d626572730015000000'+
    '54010000010000002600000049444c3a6f6d672e6f72672f434f5242412f5374727563744d656d6265725365713a312e30000000100000'+
    '005374727563744d656d626572536571001300000008010000010000000f000000f8000000010000002300000049444c3a6f6d672e6f72'+
    '672f434f5242412f5374727563744d656d6265723a312e3000000d0000005374727563744d656d6265720000000003000000050000006e'+
    '616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30'+
    '000000000b0000004964656e746966696572000012000000000000000500000074797065000000000c00000009000000747970655f6465'+
    '66000000000e00000034000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800'+
    '000049444c547970650000000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d672e6f72672f43'+
    '4f5242412f4964656e7469666965723a312e30000000000b0000004964656e746966696572000012000000000000000000000015000000'+
    '737570706f727465645f696e74657266616365730000000015000000a4000000010000002600000049444c3a6f6d672e6f72672f434f52'+
    '42412f5265706f7369746f727949645365713a312e30000000100000005265706f7369746f727949645365710013000000580000000100'+
    '00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d'+
    '0000005265706f7369746f72794964000000001200000000000000000000001500000061627374726163745f626173655f76616c756573'+
    '0000000015000000a4000000010000002600000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949645365713a31'+
    '2e30000000100000005265706f7369746f7279496453657100130000005800000001000000150000004800000001000000230000004944'+
    '4c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012'+
    '00000000000000000000000f00000069735f7472756e63617461626c650000080000000b000000626173655f76616c7565000015000000'+
    '48000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d000000526570'+
    '6f7369746f727949640000000012000000000000000500000074797065000000000c000000');
  _tc_ValueDef := CreateTypeCodeConst('010000000e00000035000000010000001f00000049444c3a6f6d672e6f72672f434f5242412f56616c75654465663a312e300000090000'+
    '0056616c756544656600');
  _tc_ValueDescription := CreateTypeCodeConst('010000000f000000e4030000010000002700000049444c3a6f6d672e6f72672f434f5242412f56616c75654465736372697074696f6e3a'+
    '312e3000001100000056616c75654465736372697074696f6e000000000a000000050000006e616d650000000015000000440000000100'+
    '00002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e7469666965'+
    '720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265'+
    '706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000c00000069735f61627374'+
    '7261637400080000000a00000069735f637573746f6d000000080000000b000000646566696e65645f696e000015000000480000000100'+
    '00002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f72'+
    '7949640000000012000000000000000800000076657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f72672f'+
    '434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e5370656300120000000000000015000000737570'+
    '706f727465645f696e74657266616365730000000015000000a4000000010000002600000049444c3a6f6d672e6f72672f434f5242412f'+
    '5265706f7369746f727949645365713a312e30000000100000005265706f7369746f727949645365710013000000580000000100000015'+
    '00000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d000000'+
    '5265706f7369746f72794964000000001200000000000000000000001500000061627374726163745f626173655f76616c756573000000'+
    '0015000000a4000000010000002600000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949645365713a312e3000'+
    '0000100000005265706f7369746f72794964536571001300000058000000010000001500000048000000010000002300000049444c3a6f'+
    '6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000'+
    '00000000000000000f00000069735f7472756e63617461626c650000080000000b000000626173655f76616c7565000015000000480000'+
    '00010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369'+
    '746f72794964000000001200000000000000');
  _tc_ValueBoxDef := CreateTypeCodeConst('010000000e0000003c000000010000002200000049444c3a6f6d672e6f72672f434f5242412f56616c7565426f784465663a312e300000'+
    '000c00000056616c7565426f7844656600');
end.
