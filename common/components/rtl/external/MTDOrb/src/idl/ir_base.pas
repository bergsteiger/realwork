// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.1b1), 21.09.2010 13:25
//                                                                            
// Copyright (c) 2002 - 2004                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
// Compiled with parameters: " -nuorb_int -without-prefix -i..\..\idl ..\..\idl\ir_base.idl" 
//                                                                            
unit ir_base;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,imr, imr_int, 
  orbtypes, exceptions, except_int, ir_base_int, poa_int, poa;

type

  TDefinitionKind_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/IRObject:1.0 } 
  TIRObject = class(TORBObject,IIRObject)
  protected
    procedure _destroy; virtual; abstract;
    function _get_def_kind: TDefinitionKind; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IIRObject;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/IRObject:1.0} 
  TIRObject_stub = class(TIRObject)
  protected
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/IRObject:1.0} 
  TIRObject_stub_clp = class(TPOAStub,IPOAStub,IIRObject)
  protected
    procedure _destroy; virtual;
    function _get_def_kind: TDefinitionKind; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/IRObject:1.0} 
  TIRObject_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IIRObject)
  protected
    procedure _destroy; virtual; abstract;
    function _get_def_kind: TDefinitionKind; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IIRObject;
    class function _narrow(const srv : IServant): IIRObject;
  end;

  TIRObject_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:omg.org/CORBA/IDLType:1.0 } 
  TIDLType = class(TIRObject,IIDLType)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IIDLType;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:omg.org/CORBA/IDLType:1.0} 
  TIDLType_stub = class(TIDLType)
  protected
    procedure _destroy; override;
    function _get_def_kind: TDefinitionKind; override;
    function _get_type: ITypeCode; override;
  end;

  {** POA stub for interface IDL:omg.org/CORBA/IDLType:1.0} 
  TIDLType_stub_clp = class(TIRObject_stub_clp,IIDLType)
  protected
    function _get_type: ITypeCode; virtual;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  end;

  {** servant for interface IDL:omg.org/CORBA/IDLType:1.0} 
  TIDLType_serv = class(TIRObject_serv,IIDLType)
  protected
    function _get_type: ITypeCode; virtual; abstract;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    function _this(): IIDLType;
    class function _narrow(const srv : IServant): IIDLType;
  end;

  TIDLType_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TStructMember_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  StructMember_seq = Array of TStructMember;
  PStructMember_seq = ^StructMember_seq;

  TStructMember_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TUnionMember_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  UnionMember_seq = Array of TUnionMember;
  PUnionMember_seq = ^UnionMember_seq;

  TUnionMember_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TValueMember_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  ValueMember_seq = Array of TValueMember;
  PValueMember_seq = ^ValueMember_seq;

  TValueMember_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  DefinitionKind_marshaller : IStaticTypeInfo;
  IRObject_marshaller : IStaticTypeInfo;
  IDLType_marshaller : IStaticTypeInfo;
  StructMember_marshaller : IStaticTypeInfo;
  StructMember_seq_marshaller : IStaticTypeInfo;
  UnionMember_marshaller : IStaticTypeInfo;
  UnionMember_seq_marshaller : IStaticTypeInfo;
  ValueMember_marshaller : IStaticTypeInfo;
  ValueMember_seq_marshaller : IStaticTypeInfo;
  _tc_DefinitionKind : ITypeCodeConst;
  _tc_IRObject : ITypeCodeConst;
  _tc_IDLType : ITypeCodeConst;
  _tc_StructMember : ITypeCodeConst;
  _tc_StructMember_seq : ITypeCodeConst;
  _tc_UnionMember : ITypeCodeConst;
  _tc_UnionMember_seq : ITypeCodeConst;
  _tc_ValueMember : ITypeCodeConst;
  _tc_ValueMember_seq : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TDefinitionKind_marshaller
//***********************************************************
function TDefinitionKind_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TDefinitionKind_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TDefinitionKind_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TDefinitionKind_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TDefinitionKind_marshaller._assign(dst, src: Pointer);
begin
  TDefinitionKind(dst^) := TDefinitionKind(src^);
end;

function TDefinitionKind_marshaller.typecode: ITypeCode;
begin
  result := _tc_DefinitionKind.typecode;
end;

//***********************************************************
// TIRObject
//***********************************************************
function TIRObject.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
    end;
end;

class function TIRObject._narrow(const obj : IORBObject): IIRObject;
var
  p: Pointer;
  stub: TIRObject_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/IRObject:1.0');
  if p <> nil then
    result := IIRObject(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/IRObject:1.0') then
        begin
          stub := TIRObject_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TIRObject.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/IRObject:1.0'
end;

//***********************************************************
// TIRObject_stub
//***********************************************************
procedure TIRObject_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TIRObject_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TIRObject_stub_clp
//***********************************************************
function TIRObject_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(self as IIRObject);
      exit;
  end;
end;

procedure TIRObject_stub_clp._destroy;
var
  _srv: IServant;
  srv: IIRObject;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TIRObject_serv._narrow(_srv);
      if srv <> nil then
        srv._destroy
    end;
  _postinvoke();
end;

function TIRObject_stub_clp._get_def_kind: TDefinitionKind;
var
  _srv: IServant;
  srv: IIRObject;
begin
  result := dk_none;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TIRObject_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_def_kind
    end;
  _postinvoke();
end;

//***********************************************************
// TIRObject_serv
//***********************************************************
function TIRObject_serv._this(): IIRObject;
var
  obj: IORBObject;
begin
  obj := this();
  result := TIRObject._narrow(obj);
end;

function TIRObject_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/IRObject:1.0';
end;

function TIRObject_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/IRObject:1.0';
end;

function TIRObject_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TIRObject_stub_clp.Create(poa,obj);
end;

procedure TIRObject_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TIRObject_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:omg.org/CORBA/IRObject:1.0' then
    begin
      result := Pointer(IIRObject(self));
      exit;
    end;
end;

class function TIRObject_serv._narrow(const srv : IServant): IIRObject;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/IRObject:1.0');
  if p <> nil then
    result := IIRObject(p)
end;

function TIRObject_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  def_kind_get_value: TDefinitionKind;
begin
  result := true;
  if req.op_name = 'destroy' then
    begin
      if not req.read_args() then  exit;
      _destroy;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_def_kind' then
    begin
      req.set_result(StaticAny(DefinitionKind_marshaller,@def_kind_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      def_kind_get_value := _get_def_kind;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TIRObject_marshaller
//***********************************************************
function TIRObject_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IIRObject(addr^) := TIRObject._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TIRObject_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IIRObject(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TIRObject_marshaller._free(var addr: Pointer);
begin
  IIRObject(addr^) := nil;
end;

procedure TIRObject_marshaller._create(var addr: Pointer);
begin
  IIRObject(addr^) := TIRObject_stub.Create();
end;

procedure TIRObject_marshaller._assign(dst, src: Pointer);
begin
  IIRObject(dst^) := IIRObject(src^);
end;

function TIRObject_marshaller.typecode: ITypeCode;
begin
  result := _tc_IRObject.typecode;
end;

//***********************************************************
// TIDLType
//***********************************************************
function TIDLType.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TIDLType._narrow(const obj : IORBObject): IIDLType;
var
  p: Pointer;
  stub: TIDLType_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:omg.org/CORBA/IDLType:1.0');
  if p <> nil then
    result := IIDLType(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:omg.org/CORBA/IDLType:1.0') then
        begin
          stub := TIDLType_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TIDLType.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:omg.org/CORBA/IDLType:1.0'
end;

//***********************************************************
// TIDLType_stub
//***********************************************************
procedure TIDLType_stub._destroy;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'destroy');
  req.invoke;
  dorb_static_throw(req);
end;

function TIDLType_stub._get_def_kind: TDefinitionKind;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(DefinitionKind_marshaller, @result);
  req := StaticRequest(self,'_get_def_kind');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TIDLType_stub._get_type: ITypeCode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_TypeCode, @result);
  req := StaticRequest(self,'_get_type');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TIDLType_stub_clp
//***********************************************************
function TIDLType_stub_clp.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(self as IIDLType);
      exit;
    end;
  result := inherited narrow_helper(str);
end;

function TIDLType_stub_clp._get_type: ITypeCode;
var
  _srv: IServant;
  srv: IIDLType;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TIDLType_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_type
    end;
  _postinvoke();
end;

//***********************************************************
// TIDLType_serv
//***********************************************************
function TIDLType_serv._this(): IIDLType;
var
  obj: IORBObject;
begin
  obj := this();
  result := TIDLType._narrow(obj);
end;

function TIDLType_serv._is_a(const repoid: RepositoryID): Boolean;
begin
  result := repoid = 'IDL:omg.org/CORBA/IDLType:1.0';
  if not result then
    result := inherited _is_a(repoid);
end;

function TIDLType_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryID;
begin
  result := 'IDL:omg.org/CORBA/IDLType:1.0';
end;

function TIDLType_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TIDLType_stub_clp.Create(poa,obj);
end;

procedure TIDLType_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TIDLType_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  if str = 'IDL:omg.org/CORBA/IDLType:1.0' then
    begin
      result := Pointer(IIDLType(self));
      exit;
    end;
  result := inherited narrow_helper(str);
end;

class function TIDLType_serv._narrow(const srv : IServant): IIDLType;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:omg.org/CORBA/IDLType:1.0');
  if p <> nil then
    result := IIDLType(p)
end;

function TIDLType_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  type_get_value: ITypeCode;
begin
  result := true;
  if req.op_name = '_get_type' then
    begin
      req.set_result(StaticAny(stat_TypeCode,@type_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      type_get_value := _get_type;
      req.write_results();
      exit;
    end;
  if not inherited _dispatch(req) then
    result := false;
end;

//***********************************************************
// TIDLType_marshaller
//***********************************************************
function TIDLType_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IIDLType(addr^) := TIDLType._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TIDLType_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IIDLType(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TIDLType_marshaller._free(var addr: Pointer);
begin
  IIDLType(addr^) := nil;
end;

procedure TIDLType_marshaller._create(var addr: Pointer);
begin
  IIDLType(addr^) := TIDLType_stub.Create();
end;

procedure TIDLType_marshaller._assign(dst, src: Pointer);
begin
  IIDLType(dst^) := IIDLType(src^);
end;

function TIDLType_marshaller.typecode: ITypeCode;
begin
  result := _tc_IDLType.typecode;
end;

//***********************************************************
// TStructMember_marshaller
//***********************************************************
function TStructMember_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_base_int.TStructMember;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  if not IDLType_marshaller.demarshal(dec,@struct.type_def) then exit;
  ir_base_int.TStructMember(addr^) := struct;
  result := true;
end;

procedure TStructMember_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_base_int.TStructMember;
begin
  struct := ir_base_int.TStructMember(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_TypeCode.marshal(enc,@struct._type);
  IDLType_marshaller.marshal(enc,@struct.type_def);
end;

procedure TStructMember_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_base_int.TStructMember(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TStructMember_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_base_int.TStructMember));
{$HINTS OFF}
  System.Initialize(ir_base_int.TStructMember(addr^));
{$HINTS ON}
end;

procedure TStructMember_marshaller._assign(dst, src: Pointer);
begin
  ir_base_int.TStructMember(dst^) := ir_base_int.TStructMember(src^);
end;

function TStructMember_marshaller.typecode: ITypeCode;
begin
  result := _tc_StructMember.typecode;
end;

//***********************************************************
// TStructMember_seq_marshaller
//***********************************************************

function TStructMember_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TStructMember;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(StructMember_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not StructMember_marshaller.demarshal(dec,@val) then exit;
        StructMember_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TStructMember_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(StructMember_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      StructMember_marshaller.marshal(enc,@StructMember_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TStructMember_seq_marshaller._free(var addr: Pointer);
begin
  setLength(StructMember_seq(addr^),0);
  freemem(addr);
end;

procedure TStructMember_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TStructMember_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TStructMember_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_StructMember_seq.typecode;
end;

//***********************************************************
// TUnionMember_marshaller
//***********************************************************
function TUnionMember_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_base_int.TUnionMember;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_any.demarshal(dec,@struct._label) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  if not IDLType_marshaller.demarshal(dec,@struct.type_def) then exit;
  ir_base_int.TUnionMember(addr^) := struct;
  result := true;
end;

procedure TUnionMember_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_base_int.TUnionMember;
begin
  struct := ir_base_int.TUnionMember(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_any.marshal(enc,@struct._label);
  stat_TypeCode.marshal(enc,@struct._type);
  IDLType_marshaller.marshal(enc,@struct.type_def);
end;

procedure TUnionMember_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_base_int.TUnionMember(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TUnionMember_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_base_int.TUnionMember));
{$HINTS OFF}
  System.Initialize(ir_base_int.TUnionMember(addr^));
{$HINTS ON}
end;

procedure TUnionMember_marshaller._assign(dst, src: Pointer);
begin
  ir_base_int.TUnionMember(dst^) := ir_base_int.TUnionMember(src^);
end;

function TUnionMember_marshaller.typecode: ITypeCode;
begin
  result := _tc_UnionMember.typecode;
end;

//***********************************************************
// TUnionMember_seq_marshaller
//***********************************************************

function TUnionMember_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TUnionMember;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(UnionMember_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not UnionMember_marshaller.demarshal(dec,@val) then exit;
        UnionMember_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TUnionMember_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(UnionMember_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      UnionMember_marshaller.marshal(enc,@UnionMember_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TUnionMember_seq_marshaller._free(var addr: Pointer);
begin
  setLength(UnionMember_seq(addr^),0);
  freemem(addr);
end;

procedure TUnionMember_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TUnionMember_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TUnionMember_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_UnionMember_seq.typecode;
end;

//***********************************************************
// TValueMember_marshaller
//***********************************************************
function TValueMember_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: ir_base_int.TValueMember;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.name) then exit;
  if not stat_string.demarshal(dec,@struct.id) then exit;
  if not stat_string.demarshal(dec,@struct.defined_in) then exit;
  if not stat_string.demarshal(dec,@struct.version) then exit;
  if not stat_TypeCode.demarshal(dec,@struct._type) then exit;
  if not IDLType_marshaller.demarshal(dec,@struct.type_def) then exit;
  if not stat_short.demarshal(dec,@struct.access) then exit;
  ir_base_int.TValueMember(addr^) := struct;
  result := true;
end;

procedure TValueMember_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: ir_base_int.TValueMember;
begin
  struct := ir_base_int.TValueMember(addr^);
  stat_string.marshal(enc,@struct.name);
  stat_string.marshal(enc,@struct.id);
  stat_string.marshal(enc,@struct.defined_in);
  stat_string.marshal(enc,@struct.version);
  stat_TypeCode.marshal(enc,@struct._type);
  IDLType_marshaller.marshal(enc,@struct.type_def);
  stat_short.marshal(enc,@struct.access);
end;

procedure TValueMember_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(ir_base_int.TValueMember(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TValueMember_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(ir_base_int.TValueMember));
{$HINTS OFF}
  System.Initialize(ir_base_int.TValueMember(addr^));
{$HINTS ON}
end;

procedure TValueMember_marshaller._assign(dst, src: Pointer);
begin
  ir_base_int.TValueMember(dst^) := ir_base_int.TValueMember(src^);
end;

function TValueMember_marshaller.typecode: ITypeCode;
begin
  result := _tc_ValueMember.typecode;
end;

//***********************************************************
// TValueMember_seq_marshaller
//***********************************************************

function TValueMember_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TValueMember;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(ValueMember_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not ValueMember_marshaller.demarshal(dec,@val) then exit;
        ValueMember_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TValueMember_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(ValueMember_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      ValueMember_marshaller.marshal(enc,@ValueMember_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TValueMember_seq_marshaller._free(var addr: Pointer);
begin
  setLength(ValueMember_seq(addr^),0);
  freemem(addr);
end;

procedure TValueMember_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TValueMember_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TValueMember_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_ValueMember_seq.typecode;
end;

initialization
  DefinitionKind_marshaller := TDefinitionKind_marshaller.Create();
  IRObject_marshaller := TIRObject_marshaller.Create();
  IDLType_marshaller := TIDLType_marshaller.Create();
  StructMember_marshaller := TStructMember_marshaller.Create();
  StructMember_seq_marshaller := TStructMember_seq_marshaller.Create();
  UnionMember_marshaller := TUnionMember_marshaller.Create();
  UnionMember_seq_marshaller := TUnionMember_seq_marshaller.Create();
  ValueMember_marshaller := TValueMember_marshaller.Create();
  ValueMember_seq_marshaller := TValueMember_seq_marshaller.Create();
  _tc_DefinitionKind := CreateTypeCodeConst('0100000011000000b0020000010000002500000049444c3a6f6d672e6f72672f434f5242412f446566696e6974696f6e4b696e643a312e'+
    '30000000000f000000446566696e6974696f6e4b696e6400002400000008000000646b5f6e6f6e650007000000646b5f616c6c00000d00'+
    '0000646b5f417474726962757465000000000c000000646b5f436f6e7374616e74000d000000646b5f457863657074696f6e000000000d'+
    '000000646b5f496e74657266616365000000000a000000646b5f4d6f64756c650000000d000000646b5f4f7065726174696f6e00000000'+
    '0b000000646b5f54797065646566000009000000646b5f416c696173000000000a000000646b5f53747275637400000009000000646b5f'+
    '556e696f6e0000000008000000646b5f456e756d000d000000646b5f5072696d6974697665000000000a000000646b5f537472696e6700'+
    '00000c000000646b5f53657175656e63650009000000646b5f4172726179000000000e000000646b5f5265706f7369746f72790000000b'+
    '000000646b5f57737472696e67000009000000646b5f46697865640000000009000000646b5f56616c7565000000000c000000646b5f56'+
    '616c7565426f78000f000000646b5f56616c75654d656d62657200000a000000646b5f4e617469766500000015000000646b5f41627374'+
    '72616374496e746572666163650000000012000000646b5f4c6f63616c496e746572666163650000000d000000646b5f436f6d706f6e65'+
    '6e740000000008000000646b5f486f6d65000b000000646b5f466163746f727900000a000000646b5f46696e6465720000000e00000064'+
    '6b5f5072696d6172794b657900000009000000646b5f456d697473000000000d000000646b5f5075626c6973686573000000000c000000'+
    '646b5f436f6e73756d6573000c000000646b5f50726f76696465730008000000646b5f5573657300');
  _tc_IRObject := CreateTypeCodeConst('010000000e00000035000000010000001f00000049444c3a6f6d672e6f72672f434f5242412f49524f626a6563743a312e300000090000'+
    '0049524f626a65637400');
  _tc_IDLType := CreateTypeCodeConst('010000000e00000034000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e30000000080000'+
    '0049444c5479706500');
  _tc_StructMember := CreateTypeCodeConst('010000000f000000f8000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5374727563744d656d6265723a312e3000'+
    '000d0000005374727563744d656d6265720000000003000000050000006e616d6500000000150000004400000001000000210000004944'+
    '4c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e74696669657200001200000000'+
    '0000000500000074797065000000000c00000009000000747970655f646566000000000e00000034000000010000001e00000049444c3a'+
    '6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c5479706500');
  _tc_StructMember_seq := CreateTypeCodeConst('010000001300000008010000010000000f000000f8000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5374727563'+
    '744d656d6265723a312e3000000d0000005374727563744d656d6265720000000003000000050000006e616d6500000000150000004400'+
    '0000010000002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e74'+
    '6966696572000012000000000000000500000074797065000000000c00000009000000747970655f646566000000000e00000034000000'+
    '010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c547970650000000000');
  _tc_UnionMember := CreateTypeCodeConst('010000000f00000004010000010000002200000049444c3a6f6d672e6f72672f434f5242412f556e696f6e4d656d6265723a312e300000'+
    '000c000000556e696f6e4d656d6265720004000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d'+
    '672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e7469666965720000120000000000000006'+
    '0000006c6162656c0000000b0000000500000074797065000000000c00000009000000747970655f646566000000000e00000034000000'+
    '010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c5479706500');
  _tc_UnionMember_seq := CreateTypeCodeConst('010000001300000014010000010000000f00000004010000010000002200000049444c3a6f6d672e6f72672f434f5242412f556e696f6e'+
    '4d656d6265723a312e300000000c000000556e696f6e4d656d6265720004000000050000006e616d650000000015000000440000000100'+
    '00002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e7469666965'+
    '7200001200000000000000060000006c6162656c0000000b0000000500000074797065000000000c00000009000000747970655f646566'+
    '000000000e00000034000000010000001e00000049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e30000000080000'+
    '0049444c547970650000000000');
  _tc_ValueMember := CreateTypeCodeConst('010000000f00000058020000010000002200000049444c3a6f6d672e6f72672f434f5242412f56616c75654d656d6265723a312e300000'+
    '000c00000056616c75654d656d6265720007000000050000006e616d65000000001500000044000000010000002100000049444c3a6f6d'+
    '672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e7469666965720000120000000000000003'+
    '000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a31'+
    '2e3000000d0000005265706f7369746f727949640000000012000000000000000b000000646566696e65645f696e000015000000480000'+
    '00010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e3000000d0000005265706f7369'+
    '746f727949640000000012000000000000000800000076657273696f6e001500000044000000010000002200000049444c3a6f6d672e6f'+
    '72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e5370656300120000000000000005000000'+
    '74797065000000000c00000009000000747970655f646566000000000e00000034000000010000001e00000049444c3a6f6d672e6f7267'+
    '2f434f5242412f49444c547970653a312e300000000800000049444c547970650007000000616363657373000015000000400000000100'+
    '00002100000049444c3a6f6d672e6f72672f434f5242412f5669736962696c6974793a312e30000000000b0000005669736962696c6974'+
    '79000002000000');
  _tc_ValueMember_seq := CreateTypeCodeConst('010000001300000068020000010000000f00000058020000010000002200000049444c3a6f6d672e6f72672f434f5242412f56616c7565'+
    '4d656d6265723a312e300000000c00000056616c75654d656d6265720007000000050000006e616d650000000015000000440000000100'+
    '00002100000049444c3a6f6d672e6f72672f434f5242412f4964656e7469666965723a312e30000000000b0000004964656e7469666965'+
    '720000120000000000000003000000696400001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265'+
    '706f7369746f727949643a312e3000000d0000005265706f7369746f727949640000000012000000000000000b000000646566696e6564'+
    '5f696e00001500000048000000010000002300000049444c3a6f6d672e6f72672f434f5242412f5265706f7369746f727949643a312e30'+
    '00000d0000005265706f7369746f727949640000000012000000000000000800000076657273696f6e0015000000440000000100000022'+
    '00000049444c3a6f6d672e6f72672f434f5242412f56657273696f6e537065633a312e300000000c00000056657273696f6e5370656300'+
    '12000000000000000500000074797065000000000c00000009000000747970655f646566000000000e00000034000000010000001e0000'+
    '0049444c3a6f6d672e6f72672f434f5242412f49444c547970653a312e300000000800000049444c547970650007000000616363657373'+
    '00001500000040000000010000002100000049444c3a6f6d672e6f72672f434f5242412f5669736962696c6974793a312e30000000000b'+
    '0000005669736962696c69747900000200000000000000');
end.
