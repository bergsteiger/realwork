// ***************************************************************************
//                                                                            
// Generated by the MTDORB IDL-to-Pascal Translator (1.0.b5), 27.04.2004 15:52
//                                                                            
// Copyright (c) 2002 - 2003                                                  
// Millennium Group.                                                          
// Samara, Russia                                                             
//                                                                            
// All Rights Reserved                                                        
//                                                                            
// ***************************************************************************
unit imr;

interface

uses
  Classes, orb_int, orb, req_int, code_int, env_int, stdstat, std_seq,
  orbtypes, exceptions, except_int, imr_int, poa_int, poa;

type

  TActivationMode_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  TObjectInfo_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  ObjectInfo_seq = array of TObjectInfo;
  PObjectInfo_seq = ^ObjectInfo_seq;

  TObjectInfo_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:mg.org/CORBA/ImplementationDef:1.0 } 
  TImplementationDef = class(TORBObject,IImplementationDef)
  protected
    procedure _set_mode(const val: TActivationMode); virtual; abstract;
    function _get_mode: TActivationMode; virtual; abstract;
    procedure _set_objs(const val: TObjectInfoList); virtual; abstract;
    function _get_objs: TObjectInfoList; virtual; abstract;
    function _get_name: Identifier; virtual; abstract;
    procedure _set_command(const val: string); virtual; abstract;
    function _get_command: string; virtual; abstract;
    function _get_tostring: string; virtual; abstract;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IImplementationDef;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:mg.org/CORBA/ImplementationDef:1.0} 
  TImplementationDef_stub = class(TImplementationDef)
  protected
    procedure _set_mode(const val: TActivationMode); override;
    function _get_mode: TActivationMode; override;
    procedure _set_objs(const val: TObjectInfoList); override;
    function _get_objs: TObjectInfoList; override;
    function _get_name: Identifier; override;
    procedure _set_command(const val: string); override;
    function _get_command: string; override;
    function _get_tostring: string; override;
  end;

  {** POA stub for interface IDL:mg.org/CORBA/ImplementationDef:1.0} 
  TImplementationDef_stub_clp = class(TPOAStub,IPOAStub,IImplementationDef)
  protected
    procedure _set_mode(const val: TActivationMode); virtual;
    function _get_mode: TActivationMode; virtual;
    procedure _set_objs(const val: TObjectInfoList); virtual;
    function _get_objs: TObjectInfoList; virtual;
    function _get_name: Identifier; virtual;
    procedure _set_command(const val: string); virtual;
    function _get_command: string; virtual;
    function _get_tostring: string; virtual;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  end;

  {** servant for interface IDL:mg.org/CORBA/ImplementationDef:1.0} 
  TImplementationDef_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IImplementationDef)
  private
    FImplementation: IImplementationDef;
  protected
    procedure _set_mode(const val: TActivationMode); virtual;
    function _get_mode: TActivationMode; virtual;
    procedure _set_objs(const val: TObjectInfoList); virtual;
    function _get_objs: TObjectInfoList; virtual;
    function _get_name: Identifier; virtual;
    procedure _set_command(const val: string); virtual;
    function _get_command: string; virtual;
    function _get_tostring: string; virtual;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    constructor Create(const AImpl: IImplementationDef = nil);
    function _this(): IImplementationDef;
    class function _narrow(const srv : IServant): IImplementationDef;
  end;

  TImplementationDef_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  ImplementationDef_seq = array of IImplementationDef;
  PImplementationDef_seq = ^ImplementationDef_seq;

  TImplementationDef_seq_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:mg.org/CORBA/ImplRepository:1.0 } 
  TImplRepository = class(TORBObject,IImplRepository)
  protected
    function restore(const asstring: string): IImplementationDef; virtual; abstract;
    function _create(const mode: TActivationMode; const objs: TObjectInfoList; const name: Identifier; const command: string): IImplementationDef; virtual; abstract;
    procedure _destroy(const impl_def: IImplementationDef); virtual; abstract;
    function find_by_name(const name: Identifier): TImplDefSeq; virtual; abstract;
    function find_by_repoid(const repoid: RepositoryId): TImplDefSeq; virtual; abstract;
    function find_by_repoid_tag(const repoid: RepositoryId; const tag: TObjectTag): TImplDefSeq; virtual; abstract;
    function find_all: TImplDefSeq; virtual; abstract;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IImplRepository;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:mg.org/CORBA/ImplRepository:1.0} 
  TImplRepository_stub = class(TImplRepository)
  protected
    function restore(const asstring: string): IImplementationDef; override;
    function _create(const mode: TActivationMode; const objs: TObjectInfoList; const name: Identifier; const command: string): IImplementationDef; override;
    procedure _destroy(const impl_def: IImplementationDef); override;
    function find_by_name(const name: Identifier): TImplDefSeq; override;
    function find_by_repoid(const repoid: RepositoryId): TImplDefSeq; override;
    function find_by_repoid_tag(const repoid: RepositoryId; const tag: TObjectTag): TImplDefSeq; override;
    function find_all: TImplDefSeq; override;
  end;

  {** POA stub for interface IDL:mg.org/CORBA/ImplRepository:1.0} 
  TImplRepository_stub_clp = class(TPOAStub,IPOAStub,IImplRepository)
  protected
    function restore(const asstring: string): IImplementationDef; virtual;
    function _create(const mode: TActivationMode; const objs: TObjectInfoList; const name: Identifier; const command: string): IImplementationDef; virtual;
    procedure _destroy(const impl_def: IImplementationDef); virtual;
    function find_by_name(const name: Identifier): TImplDefSeq; virtual;
    function find_by_repoid(const repoid: RepositoryId): TImplDefSeq; virtual;
    function find_by_repoid_tag(const repoid: RepositoryId; const tag: TObjectTag): TImplDefSeq; virtual;
    function find_all: TImplDefSeq; virtual;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  end;

  {** servant for interface IDL:mg.org/CORBA/ImplRepository:1.0} 
  TImplRepository_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IImplRepository)
  private
    FImplementation: IImplRepository;
  protected
    function restore(const asstring: string): IImplementationDef; virtual;
    function _create(const mode: TActivationMode; const objs: TObjectInfoList; const name: Identifier; const command: string): IImplementationDef; virtual;
    procedure _destroy(const impl_def: IImplementationDef); virtual;
    function find_by_name(const name: Identifier): TImplDefSeq; virtual;
    function find_by_repoid(const repoid: RepositoryId): TImplDefSeq; virtual;
    function find_by_repoid_tag(const repoid: RepositoryId; const tag: TObjectTag): TImplDefSeq; virtual;
    function find_all: TImplDefSeq; virtual;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    constructor Create(const AImpl: IImplRepository = nil);
    function _this(): IImplRepository;
    class function _narrow(const srv : IServant): IImplRepository;
  end;

  TImplRepository_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:mg.org/CORBA/OAServer:1.0 } 
  TOAServer = class(TORBObject,IOAServer)
  protected
    procedure restore_request(const objs: TObjSeq); virtual; abstract;
    procedure obj_inactive(const obj: IORBObject); virtual; abstract;
    procedure impl_inactive; virtual; abstract;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IOAServer;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:mg.org/CORBA/OAServer:1.0} 
  TOAServer_stub = class(TOAServer)
  protected
    procedure restore_request(const objs: TObjSeq); override;
    procedure obj_inactive(const obj: IORBObject); override;
    procedure impl_inactive; override;
  end;

  {** POA stub for interface IDL:mg.org/CORBA/OAServer:1.0} 
  TOAServer_stub_clp = class(TPOAStub,IPOAStub,IOAServer)
  protected
    procedure restore_request(const objs: TObjSeq); virtual;
    procedure obj_inactive(const obj: IORBObject); virtual;
    procedure impl_inactive; virtual;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  end;

  {** servant for interface IDL:mg.org/CORBA/OAServer:1.0} 
  TOAServer_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IOAServer)
  private
    FImplementation: IOAServer;
  protected
    procedure restore_request(const objs: TObjSeq); virtual;
    procedure obj_inactive(const obj: IORBObject); virtual;
    procedure impl_inactive; virtual;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    constructor Create(const AImpl: IOAServer = nil);
    function _this(): IOAServer;
    class function _narrow(const srv : IServant): IOAServer;
  end;

  TOAServer_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:mg.org/CORBA/OAMediator:1.0 } 
  TOAMediator = class(TORBObject,IOAMediator)
  protected
    procedure create_obj(const objref: IORBObject; const id: TRefData; out remote_objref: IORBObject; const svid: TServerId); virtual; abstract;
    procedure restore_obj(const objref: IORBObject; var remote_objref: IORBObject; out id: TRefData; const svid: TServerId); virtual; abstract;
    procedure activate_obj(const objref: IORBObject; const svid: TServerId); virtual; abstract;
    procedure deactivate_obj(const objref: IORBObject; const svid: TServerId); virtual; abstract;
    procedure migrate_obj(const objref: IORBObject; const svid: TServerId; const impl: IImplementationDef); virtual; abstract;
    procedure orphan_obj(const objref: IORBObject; const svid: TServerId); virtual; abstract;
    procedure dispose_obj(const objref: IORBObject; const svid: TServerId); virtual; abstract;
    procedure create_impl(const impl: IImplementationDef; const server: IOAServer; var id: TServerId); virtual; abstract;
    procedure activate_impl(const id: TServerId); virtual; abstract;
    procedure deactivate_impl(const id: TServerId); virtual; abstract;
    function get_remote_object(const key: TRefData): IORBObject; virtual; abstract;
    procedure dispose_impl(const id: TServerId); virtual; abstract;
    function get_restore_objs(const id: TServerId): TObjSeq; virtual; abstract;
    function force_activation(const impl: IImplementationDef): boolean; virtual; abstract;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IOAMediator;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:mg.org/CORBA/OAMediator:1.0} 
  TOAMediator_stub = class(TOAMediator)
  protected
    procedure create_obj(const objref: IORBObject; const id: TRefData; out remote_objref: IORBObject; const svid: TServerId); override;
    procedure restore_obj(const objref: IORBObject; var remote_objref: IORBObject; out id: TRefData; const svid: TServerId); override;
    procedure activate_obj(const objref: IORBObject; const svid: TServerId); override;
    procedure deactivate_obj(const objref: IORBObject; const svid: TServerId); override;
    procedure migrate_obj(const objref: IORBObject; const svid: TServerId; const impl: IImplementationDef); override;
    procedure orphan_obj(const objref: IORBObject; const svid: TServerId); override;
    procedure dispose_obj(const objref: IORBObject; const svid: TServerId); override;
    procedure create_impl(const impl: IImplementationDef; const server: IOAServer; var id: TServerId); override;
    procedure activate_impl(const id: TServerId); override;
    procedure deactivate_impl(const id: TServerId); override;
    function get_remote_object(const key: TRefData): IORBObject; override;
    procedure dispose_impl(const id: TServerId); override;
    function get_restore_objs(const id: TServerId): TObjSeq; override;
    function force_activation(const impl: IImplementationDef): boolean; override;
  end;

  {** POA stub for interface IDL:mg.org/CORBA/OAMediator:1.0} 
  TOAMediator_stub_clp = class(TPOAStub,IPOAStub,IOAMediator)
  protected
    procedure create_obj(const objref: IORBObject; const id: TRefData; out remote_objref: IORBObject; const svid: TServerId); virtual;
    procedure restore_obj(const objref: IORBObject; var remote_objref: IORBObject; out id: TRefData; const svid: TServerId); virtual;
    procedure activate_obj(const objref: IORBObject; const svid: TServerId); virtual;
    procedure deactivate_obj(const objref: IORBObject; const svid: TServerId); virtual;
    procedure migrate_obj(const objref: IORBObject; const svid: TServerId; const impl: IImplementationDef); virtual;
    procedure orphan_obj(const objref: IORBObject; const svid: TServerId); virtual;
    procedure dispose_obj(const objref: IORBObject; const svid: TServerId); virtual;
    procedure create_impl(const impl: IImplementationDef; const server: IOAServer; var id: TServerId); virtual;
    procedure activate_impl(const id: TServerId); virtual;
    procedure deactivate_impl(const id: TServerId); virtual;
    function get_remote_object(const key: TRefData): IORBObject; virtual;
    procedure dispose_impl(const id: TServerId); virtual;
    function get_restore_objs(const id: TServerId): TObjSeq; virtual;
    function force_activation(const impl: IImplementationDef): boolean; virtual;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  end;

  {** servant for interface IDL:mg.org/CORBA/OAMediator:1.0} 
  TOAMediator_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IOAMediator)
  private
    FImplementation: IOAMediator;
  protected
    procedure create_obj(const objref: IORBObject; const id: TRefData; out remote_objref: IORBObject; const svid: TServerId); virtual;
    procedure restore_obj(const objref: IORBObject; var remote_objref: IORBObject; out id: TRefData; const svid: TServerId); virtual;
    procedure activate_obj(const objref: IORBObject; const svid: TServerId); virtual;
    procedure deactivate_obj(const objref: IORBObject; const svid: TServerId); virtual;
    procedure migrate_obj(const objref: IORBObject; const svid: TServerId; const impl: IImplementationDef); virtual;
    procedure orphan_obj(const objref: IORBObject; const svid: TServerId); virtual;
    procedure dispose_obj(const objref: IORBObject; const svid: TServerId); virtual;
    procedure create_impl(const impl: IImplementationDef; const server: IOAServer; var id: TServerId); virtual;
    procedure activate_impl(const id: TServerId); virtual;
    procedure deactivate_impl(const id: TServerId); virtual;
    function get_remote_object(const key: TRefData): IORBObject; virtual;
    procedure dispose_impl(const id: TServerId); virtual;
    function get_restore_objs(const id: TServerId): TObjSeq; virtual;
    function force_activation(const impl: IImplementationDef): boolean; virtual;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    constructor Create(const AImpl: IOAMediator = nil);
    function _this(): IOAMediator;
    class function _narrow(const srv : IServant): IOAMediator;
  end;

  TOAMediator_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

  {** IDL:mg.org/CORBA/POAMediator:1.0 } 
  TPOAMediator = class(TORBObject,IPOAMediator)
  protected
    function create_impl(const svid: AnsiString; const ior: AnsiString): AnsiString; virtual; abstract;
    procedure activate_impl(const svid: AnsiString); virtual; abstract;
    procedure deactivate_impl(const svid: AnsiString); virtual; abstract;
    function force_activation(const impl: IImplementationDef): boolean; virtual; abstract;
    function hold(const impl: IImplementationDef): boolean; virtual; abstract;
    function stop(const impl: IImplementationDef): boolean; virtual; abstract;
    function continue(const impl: IImplementationDef): boolean; virtual; abstract;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  public
    class function _narrow(const obj : IORBObject): IPOAMediator;
    class function narrow_helper2(const obj: IORBObject): Boolean;
  end;

  {** stub for interface IDL:mg.org/CORBA/POAMediator:1.0} 
  TPOAMediator_stub = class(TPOAMediator)
  protected
    function create_impl(const svid: AnsiString; const ior: AnsiString): AnsiString; override;
    procedure activate_impl(const svid: AnsiString); override;
    procedure deactivate_impl(const svid: AnsiString); override;
    function force_activation(const impl: IImplementationDef): boolean; override;
    function hold(const impl: IImplementationDef): boolean; override;
    function stop(const impl: IImplementationDef): boolean; override;
    function continue(const impl: IImplementationDef): boolean; override;
  end;

  {** POA stub for interface IDL:mg.org/CORBA/POAMediator:1.0} 
  TPOAMediator_stub_clp = class(TPOAStub,IPOAStub,IPOAMediator)
  protected
    function create_impl(const svid: AnsiString; const ior: AnsiString): AnsiString; virtual;
    procedure activate_impl(const svid: AnsiString); virtual;
    procedure deactivate_impl(const svid: AnsiString); virtual;
    function force_activation(const impl: IImplementationDef): boolean; virtual;
    function hold(const impl: IImplementationDef): boolean; virtual;
    function stop(const impl: IImplementationDef): boolean; virtual;
    function continue(const impl: IImplementationDef): boolean; virtual;
    function narrow_helper(const str: RepositoryId): Pointer; override;
  end;

  {** servant for interface IDL:mg.org/CORBA/POAMediator:1.0} 
  TPOAMediator_serv = class(TPOAStaticImplementation,IPOAStaticImplementation,IServant,IPOAMediator)
  private
    FImplementation: IPOAMediator;
  protected
    function create_impl(const svid: AnsiString; const ior: AnsiString): AnsiString; virtual;
    procedure activate_impl(const svid: AnsiString); virtual;
    procedure deactivate_impl(const svid: AnsiString); virtual;
    function force_activation(const impl: IImplementationDef): boolean; virtual;
    function hold(const impl: IImplementationDef): boolean; virtual;
    function stop(const impl: IImplementationDef): boolean; virtual;
    function continue(const impl: IImplementationDef): boolean; virtual;
    function _primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId; override;
    function _make_stub(const poa: IPOA; const obj : IORBObject): IORBObject; override;
    function _is_a(const repoid: RepositoryID): Boolean; override;
    procedure invoke(const serv: IStaticServerRequest); override;
    function _dispatch(const req: IStaticServerRequest): Boolean;
    function narrow_helper(const str: RepositoryID): Pointer; override;
  public
    constructor Create(const AImpl: IPOAMediator = nil);
    function _this(): IPOAMediator;
    class function _narrow(const srv : IServant): IPOAMediator;
  end;

  TPOAMediator_marshaller = class(TAbstractStat,IStaticTypeInfo)
  protected
    procedure _assign(dst,src: Pointer); override;
    function demarshal(dec: IDecoder;const addr : Pointer): Boolean;
    procedure marshal(enc: IEncoder; const addr : Pointer);
    procedure _create(var addr: Pointer); override;
    procedure _free(var addr: Pointer);
    function typecode: ITypeCode; override;
  end;

var
  ActivationMode_marshaller : IStaticTypeInfo;
  ObjectInfo_marshaller : IStaticTypeInfo;
  ObjectInfo_seq_marshaller : IStaticTypeInfo;
  ImplementationDef_marshaller : IStaticTypeInfo;
  ImplementationDef_seq_marshaller : IStaticTypeInfo;
  ImplRepository_marshaller : IStaticTypeInfo;
  OAServer_marshaller : IStaticTypeInfo;
  OAMediator_marshaller : IStaticTypeInfo;
  POAMediator_marshaller : IStaticTypeInfo;
  _tc_ActivationMode : ITypeCodeConst;
  _tc_ObjectInfo : ITypeCodeConst;
  _tc_ObjectInfo_seq : ITypeCodeConst;
  _tc_ImplementationDef : ITypeCodeConst;
  _tc_ImplementationDef_seq : ITypeCodeConst;
  _tc_ImplRepository : ITypeCodeConst;
  _tc_OAServer : ITypeCodeConst;
  _tc_OAMediator : ITypeCodeConst;
  _tc_POAMediator : ITypeCodeConst;

implementation

uses
  SysUtils, any, tcode, static, throw;

//***********************************************************
// TActivationMode_marshaller
//***********************************************************
function TActivationMode_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
begin
  result := dec.get_ulong(_ulong(addr^));
end;

procedure TActivationMode_marshaller.marshal(enc: IEncoder;const addr : Pointer);
begin
  enc.put_ulong(_ulong(addr^));
end;

procedure TActivationMode_marshaller._free(var addr: Pointer);
begin
  freemem(addr);
end;

procedure TActivationMode_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TActivationMode_marshaller._assign(dst, src: Pointer);
begin
  TActivationMode(dst^) := TActivationMode(src^);
end;

function TActivationMode_marshaller.typecode: ITypeCode;
begin
  result := _tc_ActivationMode.typecode;
end;

//***********************************************************
// TObjectInfo_marshaller
//***********************************************************
function TObjectInfo_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  struct: TObjectInfo;
begin
  result := false;
  if not stat_string.demarshal(dec,@struct.repoid) then exit;
  if not stat_seq_octet.demarshal(dec,@struct.tag) then exit;
  TObjectInfo(addr^) := struct;
  result := true;
end;

procedure TObjectInfo_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  struct: TObjectInfo;
begin
  struct := TObjectInfo(addr^);
  stat_string.marshal(enc,@struct.repoid);
  stat_seq_octet.marshal(enc,@struct.tag);
end;

procedure TObjectInfo_marshaller._free(var addr: Pointer);
begin
{$HINTS OFF}
  System.Finalize(TObjectInfo(addr^));
{$HINTS ON}
  FreeMem(addr);
end;

procedure TObjectInfo_marshaller._create(var addr: Pointer);
begin
  addr := AllocMem(sizeOf(TObjectInfo));
{$HINTS OFF}
  System.Initialize(TObjectInfo(addr^));
{$HINTS ON}
end;

procedure TObjectInfo_marshaller._assign(dst, src: Pointer);
begin
  TObjectInfo(dst^) := TObjectInfo(src^);
end;

function TObjectInfo_marshaller.typecode: ITypeCode;
begin
  result := _tc_ObjectInfo.typecode;
end;

//***********************************************************
// TObjectInfo_seq_marshaller
//***********************************************************

function TObjectInfo_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: TObjectInfo;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(ObjectInfo_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not ObjectInfo_marshaller.demarshal(dec,@val) then exit;
        ObjectInfo_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TObjectInfo_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(ObjectInfo_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      ObjectInfo_marshaller.marshal(enc,@ObjectInfo_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TObjectInfo_seq_marshaller._free(var addr: Pointer);
begin
  setLength(ObjectInfo_seq(addr^),0);
  freemem(addr);
end;

procedure TObjectInfo_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TObjectInfo_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TObjectInfo_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_ObjectInfo_seq.typecode;
end;

//***********************************************************
// TImplementationDef
//***********************************************************
function TImplementationDef.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/ImplementationDef:1.0' then
    begin
      result := Pointer(self as IImplementationDef);
      exit;
    end;
end;

class function TImplementationDef._narrow(const obj : IORBObject): IImplementationDef;
var
  p: Pointer;
  stub: TImplementationDef_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:mg.org/CORBA/ImplementationDef:1.0');
  if p <> nil then
    result := IImplementationDef(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:mg.org/CORBA/ImplementationDef:1.0') then
        begin
          stub := TImplementationDef_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TImplementationDef.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:mg.org/CORBA/ImplementationDef:1.0'
end;

//***********************************************************
// TImplementationDef_stub
//***********************************************************
procedure TImplementationDef_stub._set_mode(const val: TActivationMode);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(ActivationMode_marshaller,@val);
  req := StaticRequest(self,'_set_mode');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplementationDef_stub._get_mode: TActivationMode;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ActivationMode_marshaller, @result);
  req := StaticRequest(self,'_get_mode');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TImplementationDef_stub._set_objs(const val: TObjectInfoList);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(ObjectInfo_seq_marshaller,@val);
  req := StaticRequest(self,'_set_objs');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplementationDef_stub._get_objs: TObjectInfoList;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ObjectInfo_seq_marshaller, @result);
  req := StaticRequest(self,'_get_objs');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplementationDef_stub._get_name: Identifier;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_name');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TImplementationDef_stub._set_command(const val: string);
var
  req: IStaticRequest;
  _val: IStaticAny;
begin
  _val := StaticAny(stat_string,@val);
  req := StaticRequest(self,'_set_command');
  req.add_in_arg(_val);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplementationDef_stub._get_command: string;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_command');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplementationDef_stub._get_tostring: string;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'_get_tostring');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TImplementationDef_stub_clp
//***********************************************************
function TImplementationDef_stub_clp.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/ImplementationDef:1.0' then
    begin
      result := Pointer(self as IImplementationDef);
      exit;
  end;
end;

procedure TImplementationDef_stub_clp._set_mode(const val: TActivationMode);
var
  _srv: IServant;
  srv: IImplementationDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplementationDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_mode(val);
    end;
  _postinvoke();
end;

function TImplementationDef_stub_clp._get_mode: TActivationMode;
var
  _srv: IServant;
  srv: IImplementationDef;
begin
  result := ActivateShared;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplementationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_mode
    end;
  _postinvoke();
end;

procedure TImplementationDef_stub_clp._set_objs(const val: TObjectInfoList);
var
  _srv: IServant;
  srv: IImplementationDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplementationDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_objs(val);
    end;
  _postinvoke();
end;

function TImplementationDef_stub_clp._get_objs: TObjectInfoList;
var
  _srv: IServant;
  srv: IImplementationDef;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplementationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_objs
    end;
  _postinvoke();
end;

function TImplementationDef_stub_clp._get_name: Identifier;
var
  _srv: IServant;
  srv: IImplementationDef;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplementationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_name
    end;
  _postinvoke();
end;

procedure TImplementationDef_stub_clp._set_command(const val: string);
var
  _srv: IServant;
  srv: IImplementationDef;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplementationDef_serv._narrow(_srv);
      if srv <> nil then
        srv._set_command(val);
    end;
  _postinvoke();
end;

function TImplementationDef_stub_clp._get_command: string;
var
  _srv: IServant;
  srv: IImplementationDef;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplementationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_command
    end;
  _postinvoke();
end;

function TImplementationDef_stub_clp._get_tostring: string;
var
  _srv: IServant;
  srv: IImplementationDef;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplementationDef_serv._narrow(_srv);
      if srv <> nil then
        result := srv._get_tostring
    end;
  _postinvoke();
end;

//***********************************************************
// TImplementationDef_serv
//***********************************************************
constructor TImplementationDef_serv.Create(const AImpl: IImplementationDef);
begin
  inherited Create();
  FImplementation := AImpl;
end;

function TImplementationDef_serv._get_mode: TActivationMode;
begin
  result := FImplementation.mode;
end;

procedure TImplementationDef_serv._set_mode(const val: TActivationMode);
begin
  FImplementation.mode := val
end;

function TImplementationDef_serv._get_objs: TObjectInfoList;
begin
  result := FImplementation.objs;
end;

procedure TImplementationDef_serv._set_objs(const val: TObjectInfoList);
begin
  FImplementation.objs := val
end;

function TImplementationDef_serv._get_name: Identifier;
begin
  result := FImplementation.name;
end;

function TImplementationDef_serv._get_command: string;
begin
  result := FImplementation.command;
end;

procedure TImplementationDef_serv._set_command(const val: string);
begin
  FImplementation.command := val
end;

function TImplementationDef_serv._get_tostring: string;
begin
  result := FImplementation.tostring;
end;

function TImplementationDef_serv._this(): IImplementationDef;
var
  obj: IORBObject;
begin
  obj := this();
  result := TImplementationDef._narrow(obj);
end;

function TImplementationDef_serv._is_a(const repoid: RepositoryId): Boolean;
begin
  result := repoid = 'IDL:mg.org/CORBA/ImplementationDef:1.0';
end;

function TImplementationDef_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId;
begin
  result := 'IDL:mg.org/CORBA/ImplementationDef:1.0';
end;

function TImplementationDef_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TImplementationDef_stub_clp.Create(poa,obj);
end;

procedure TImplementationDef_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TImplementationDef_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/ImplementationDef:1.0' then
    begin
      result := Pointer(IImplementationDef(self));
      exit;
    end;
end;

class function TImplementationDef_serv._narrow(const srv : IServant): IImplementationDef;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:mg.org/CORBA/ImplementationDef:1.0');
  if p <> nil then
    result := IImplementationDef(p)
end;

function TImplementationDef_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  mode_get_value: TActivationMode;
  mode_set_value: TActivationMode;
  objs_get_value: TObjectInfoList;
  objs_set_value: TObjectInfoList;
  name_get_value: Identifier;
  command_get_value: string;
  command_set_value: string;
  tostring_get_value: string;
begin
  result := true;
  if req.op_name = '_get_mode' then
    begin
      req.set_result(StaticAny(ActivationMode_marshaller,@mode_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      mode_get_value := _get_mode;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_mode' then
    begin
      req.add_in_arg(StaticAny(ActivationMode_marshaller,@mode_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_mode(mode_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_objs' then
    begin
      req.set_result(StaticAny(ObjectInfo_seq_marshaller,@objs_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      objs_get_value := _get_objs;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_objs' then
    begin
      req.add_in_arg(StaticAny(ObjectInfo_seq_marshaller,@objs_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_objs(objs_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_name' then
    begin
      req.set_result(StaticAny(stat_string,@name_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      name_get_value := _get_name;
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_command' then
    begin
      req.set_result(StaticAny(stat_string,@command_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      command_get_value := _get_command;
      req.write_results();
      exit;
    end
  else if req.op_name = '_set_command' then
    begin
      req.add_in_arg(StaticAny(stat_string,@command_set_value) as IStaticAny);
      if not req.read_args() then  exit;
      _set_command(command_set_value);
      req.write_results();
      exit;
    end
  else if req.op_name = '_get_tostring' then
    begin
      req.set_result(StaticAny(stat_string,@tostring_get_value) as IStaticAny);
      if not req.read_args() then  exit;
      tostring_get_value := _get_tostring;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TImplementationDef_marshaller
//***********************************************************
function TImplementationDef_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IImplementationDef(addr^) := TImplementationDef._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TImplementationDef_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IImplementationDef(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TImplementationDef_marshaller._free(var addr: Pointer);
begin
  IImplementationDef(addr^) := nil;
end;

procedure TImplementationDef_marshaller._create(var addr: Pointer);
begin
  IImplementationDef(addr^) := TImplementationDef_stub.Create();
end;

procedure TImplementationDef_marshaller._assign(dst, src: Pointer);
begin
  IImplementationDef(dst^) := IImplementationDef(src^);
end;

function TImplementationDef_marshaller.typecode: ITypeCode;
begin
  result := _tc_ImplementationDef.typecode;
end;

//***********************************************************
// TImplementationDef_seq_marshaller
//***********************************************************

function TImplementationDef_seq_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  len: _ulong;
  i: integer;
  val: IImplementationDef;
begin
  result := false;
  if not dec.seq_begin(len) then exit;
  SetLength(ImplementationDef_seq(addr^),len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      begin
        if not ImplementationDef_marshaller.demarshal(dec,@val) then exit;
        ImplementationDef_seq(addr^)[i] := val; 
      end;
  if not dec.seq_end() then exit;
  result := true;
end;

procedure TImplementationDef_seq_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  len: _ulong;
  i: integer;
begin
  len := Length(ImplementationDef_seq(addr^));
  enc.seq_begin(len);
  if len <> 0 then
    for i := 0 to Pred(len) do
      ImplementationDef_marshaller.marshal(enc,@ImplementationDef_seq(addr^)[i]);
  enc.seq_end;
end;

procedure TImplementationDef_seq_marshaller._free(var addr: Pointer);
begin
  setLength(ImplementationDef_seq(addr^),0);
  freemem(addr);
end;

procedure TImplementationDef_seq_marshaller._create(var addr: Pointer);
begin
  addr := allocmem(sizeOf(_ulong));
end;

procedure TImplementationDef_seq_marshaller._assign(dst, src: Pointer);
begin
  _ulong(dst^) := _ulong(src^);
end;

function TImplementationDef_seq_marshaller.typecode: ITypeCode;
begin
  result := _tc_ImplementationDef_seq.typecode;
end;

//***********************************************************
// TImplRepository
//***********************************************************
function TImplRepository.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/ImplRepository:1.0' then
    begin
      result := Pointer(self as IImplRepository);
      exit;
    end;
end;

class function TImplRepository._narrow(const obj : IORBObject): IImplRepository;
var
  p: Pointer;
  stub: TImplRepository_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:mg.org/CORBA/ImplRepository:1.0');
  if p <> nil then
    result := IImplRepository(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:mg.org/CORBA/ImplRepository:1.0') then
        begin
          stub := TImplRepository_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TImplRepository.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:mg.org/CORBA/ImplRepository:1.0'
end;

//***********************************************************
// TImplRepository_stub
//***********************************************************
function TImplRepository_stub.restore(const asstring: string): IImplementationDef;
var
  req: IStaticRequest;
  _asstring: IStaticAny;
  _result: IStaticAny;
begin
  _asstring := StaticAny(stat_string,@asstring);
  _result := StaticAny(ImplementationDef_marshaller, @result);
  req := StaticRequest(self,'restore');
  req.add_in_arg(_asstring);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplRepository_stub._create(const mode: TActivationMode; const objs: TObjectInfoList; const name: Identifier; const command: string): IImplementationDef;
var
  req: IStaticRequest;
  _mode: IStaticAny;
  _objs: IStaticAny;
  _name: IStaticAny;
  _command: IStaticAny;
  _result: IStaticAny;
begin
  _mode := StaticAny(ActivationMode_marshaller,@mode);
  _objs := StaticAny(ObjectInfo_seq_marshaller,@objs);
  _name := StaticAny(stat_string,@name);
  _command := StaticAny(stat_string,@command);
  _result := StaticAny(ImplementationDef_marshaller, @result);
  req := StaticRequest(self,'create');
  req.add_in_arg(_mode);
  req.add_in_arg(_objs);
  req.add_in_arg(_name);
  req.add_in_arg(_command);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TImplRepository_stub._destroy(const impl_def: IImplementationDef);
var
  req: IStaticRequest;
  _impl_def: IStaticAny;
begin
  _impl_def := StaticAny(ImplementationDef_marshaller,@impl_def);
  req := StaticRequest(self,'destroy');
  req.add_in_arg(_impl_def);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplRepository_stub.find_by_name(const name: Identifier): TImplDefSeq;
var
  req: IStaticRequest;
  _name: IStaticAny;
  _result: IStaticAny;
begin
  _name := StaticAny(stat_string,@name);
  _result := StaticAny(ImplementationDef_seq_marshaller, @result);
  req := StaticRequest(self,'find_by_name');
  req.add_in_arg(_name);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplRepository_stub.find_by_repoid(const repoid: RepositoryId): TImplDefSeq;
var
  req: IStaticRequest;
  _repoid: IStaticAny;
  _result: IStaticAny;
begin
  _repoid := StaticAny(stat_string,@repoid);
  _result := StaticAny(ImplementationDef_seq_marshaller, @result);
  req := StaticRequest(self,'find_by_repoid');
  req.add_in_arg(_repoid);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplRepository_stub.find_by_repoid_tag(const repoid: RepositoryId; const tag: TObjectTag): TImplDefSeq;
var
  req: IStaticRequest;
  _repoid: IStaticAny;
  _tag: IStaticAny;
  _result: IStaticAny;
begin
  _repoid := StaticAny(stat_string,@repoid);
  _tag := StaticAny(stat_seq_octet,@tag);
  _result := StaticAny(ImplementationDef_seq_marshaller, @result);
  req := StaticRequest(self,'find_by_repoid_tag');
  req.add_in_arg(_repoid);
  req.add_in_arg(_tag);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TImplRepository_stub.find_all: TImplDefSeq;
var
  req: IStaticRequest;
  _result: IStaticAny;
begin
  _result := StaticAny(ImplementationDef_seq_marshaller, @result);
  req := StaticRequest(self,'find_all');
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TImplRepository_stub_clp
//***********************************************************
function TImplRepository_stub_clp.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/ImplRepository:1.0' then
    begin
      result := Pointer(self as IImplRepository);
      exit;
  end;
end;

function TImplRepository_stub_clp.restore(const asstring: string): IImplementationDef;
var
  _srv: IServant;
  srv: IImplRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.restore(asstring)
    end;
  _postinvoke();
end;

function TImplRepository_stub_clp._create(const mode: TActivationMode; const objs: TObjectInfoList; const name: Identifier; const command: string): IImplementationDef;
var
  _srv: IServant;
  srv: IImplRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv._create(mode, objs, name, command)
    end;
  _postinvoke();
end;

procedure TImplRepository_stub_clp._destroy(const impl_def: IImplementationDef);
var
  _srv: IServant;
  srv: IImplRepository;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplRepository_serv._narrow(_srv);
      if srv <> nil then
        srv._destroy(impl_def)
    end;
  _postinvoke();
end;

function TImplRepository_stub_clp.find_by_name(const name: Identifier): TImplDefSeq;
var
  _srv: IServant;
  srv: IImplRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.find_by_name(name)
    end;
  _postinvoke();
end;

function TImplRepository_stub_clp.find_by_repoid(const repoid: RepositoryId): TImplDefSeq;
var
  _srv: IServant;
  srv: IImplRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.find_by_repoid(repoid)
    end;
  _postinvoke();
end;

function TImplRepository_stub_clp.find_by_repoid_tag(const repoid: RepositoryId; const tag: TObjectTag): TImplDefSeq;
var
  _srv: IServant;
  srv: IImplRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.find_by_repoid_tag(repoid, tag)
    end;
  _postinvoke();
end;

function TImplRepository_stub_clp.find_all: TImplDefSeq;
var
  _srv: IServant;
  srv: IImplRepository;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TImplRepository_serv._narrow(_srv);
      if srv <> nil then
        result := srv.find_all
    end;
  _postinvoke();
end;

//***********************************************************
// TImplRepository_serv
//***********************************************************
constructor TImplRepository_serv.Create(const AImpl: IImplRepository);
begin
  inherited Create();
  FImplementation := AImpl;
end;

function TImplRepository_serv.restore(const asstring: string): IImplementationDef;
begin
  result := FImplementation.restore(asstring);
end;

function TImplRepository_serv._create(const mode: TActivationMode; const objs: TObjectInfoList; const name: Identifier; const command: string): IImplementationDef;
begin
  result := FImplementation._create(mode, objs, name, command);
end;

procedure TImplRepository_serv._destroy(const impl_def: IImplementationDef);
begin
  FImplementation._destroy(impl_def);
end;

function TImplRepository_serv.find_by_name(const name: Identifier): TImplDefSeq;
begin
  result := FImplementation.find_by_name(name);
end;

function TImplRepository_serv.find_by_repoid(const repoid: RepositoryId): TImplDefSeq;
begin
  result := FImplementation.find_by_repoid(repoid);
end;

function TImplRepository_serv.find_by_repoid_tag(const repoid: RepositoryId; const tag: TObjectTag): TImplDefSeq;
begin
  result := FImplementation.find_by_repoid_tag(repoid, tag);
end;

function TImplRepository_serv.find_all: TImplDefSeq;
begin
  result := FImplementation.find_all;
end;

function TImplRepository_serv._this(): IImplRepository;
var
  obj: IORBObject;
begin
  obj := this();
  result := TImplRepository._narrow(obj);
end;

function TImplRepository_serv._is_a(const repoid: RepositoryId): Boolean;
begin
  result := repoid = 'IDL:mg.org/CORBA/ImplRepository:1.0';
end;

function TImplRepository_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId;
begin
  result := 'IDL:mg.org/CORBA/ImplRepository:1.0';
end;

function TImplRepository_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TImplRepository_stub_clp.Create(poa,obj);
end;

procedure TImplRepository_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TImplRepository_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/ImplRepository:1.0' then
    begin
      result := Pointer(IImplRepository(self));
      exit;
    end;
end;

class function TImplRepository_serv._narrow(const srv : IServant): IImplRepository;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:mg.org/CORBA/ImplRepository:1.0');
  if p <> nil then
    result := IImplRepository(p)
end;

function TImplRepository_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  restore_result: IImplementationDef;
  restore_asstring: string;
  _create_result: IImplementationDef;
  _create_mode: TActivationMode;
  _create_objs: TObjectInfoList;
  _create_name: Identifier;
  _create_command: string;
  _destroy_impl_def: IImplementationDef;
  find_by_name_result: TImplDefSeq;
  find_by_name_name: Identifier;
  find_by_repoid_result: TImplDefSeq;
  find_by_repoid_repoid: RepositoryId;
  find_by_repoid_tag_result: TImplDefSeq;
  find_by_repoid_tag_repoid: RepositoryId;
  find_by_repoid_tag_tag: TObjectTag;
  find_all_result: TImplDefSeq;
begin
  result := true;
  if req.op_name = 'restore' then
    begin
      req.add_in_arg(StaticAny(stat_string,@restore_asstring) as IStaticAny);
      req.set_result(StaticAny(ImplementationDef_marshaller,@restore_result) as IStaticAny);
      if not req.read_args() then  exit;
      restore_result := restore(restore_asstring);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create' then
    begin
      req.add_in_arg(StaticAny(ActivationMode_marshaller,@_create_mode) as IStaticAny);
      req.add_in_arg(StaticAny(ObjectInfo_seq_marshaller,@_create_objs) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@_create_name) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@_create_command) as IStaticAny);
      req.set_result(StaticAny(ImplementationDef_marshaller,@_create_result) as IStaticAny);
      if not req.read_args() then  exit;
      _create_result := _create(_create_mode, _create_objs, _create_name, _create_command);
      req.write_results();
      exit;
    end
  else if req.op_name = 'destroy' then
    begin
      req.add_in_arg(StaticAny(ImplementationDef_marshaller,@_destroy_impl_def) as IStaticAny);
      if not req.read_args() then  exit;
      _destroy(_destroy_impl_def);
      req.write_results();
      exit;
    end
  else if req.op_name = 'find_by_name' then
    begin
      req.add_in_arg(StaticAny(stat_string,@find_by_name_name) as IStaticAny);
      req.set_result(StaticAny(ImplementationDef_seq_marshaller,@find_by_name_result) as IStaticAny);
      if not req.read_args() then  exit;
      find_by_name_result := find_by_name(find_by_name_name);
      req.write_results();
      exit;
    end
  else if req.op_name = 'find_by_repoid' then
    begin
      req.add_in_arg(StaticAny(stat_string,@find_by_repoid_repoid) as IStaticAny);
      req.set_result(StaticAny(ImplementationDef_seq_marshaller,@find_by_repoid_result) as IStaticAny);
      if not req.read_args() then  exit;
      find_by_repoid_result := find_by_repoid(find_by_repoid_repoid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'find_by_repoid_tag' then
    begin
      req.add_in_arg(StaticAny(stat_string,@find_by_repoid_tag_repoid) as IStaticAny);
      req.add_in_arg(StaticAny(stat_seq_octet,@find_by_repoid_tag_tag) as IStaticAny);
      req.set_result(StaticAny(ImplementationDef_seq_marshaller,@find_by_repoid_tag_result) as IStaticAny);
      if not req.read_args() then  exit;
      find_by_repoid_tag_result := find_by_repoid_tag(find_by_repoid_tag_repoid, find_by_repoid_tag_tag);
      req.write_results();
      exit;
    end
  else if req.op_name = 'find_all' then
    begin
      req.set_result(StaticAny(ImplementationDef_seq_marshaller,@find_all_result) as IStaticAny);
      if not req.read_args() then  exit;
      find_all_result := find_all;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TImplRepository_marshaller
//***********************************************************
function TImplRepository_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IImplRepository(addr^) := TImplRepository._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TImplRepository_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IImplRepository(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TImplRepository_marshaller._free(var addr: Pointer);
begin
  IImplRepository(addr^) := nil;
end;

procedure TImplRepository_marshaller._create(var addr: Pointer);
begin
  IImplRepository(addr^) := TImplRepository_stub.Create();
end;

procedure TImplRepository_marshaller._assign(dst, src: Pointer);
begin
  IImplRepository(dst^) := IImplRepository(src^);
end;

function TImplRepository_marshaller.typecode: ITypeCode;
begin
  result := _tc_ImplRepository.typecode;
end;

//***********************************************************
// TOAServer
//***********************************************************
function TOAServer.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/OAServer:1.0' then
    begin
      result := Pointer(self as IOAServer);
      exit;
    end;
end;

class function TOAServer._narrow(const obj : IORBObject): IOAServer;
var
  p: Pointer;
  stub: TOAServer_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:mg.org/CORBA/OAServer:1.0');
  if p <> nil then
    result := IOAServer(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:mg.org/CORBA/OAServer:1.0') then
        begin
          stub := TOAServer_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TOAServer.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:mg.org/CORBA/OAServer:1.0'
end;

//***********************************************************
// TOAServer_stub
//***********************************************************
procedure TOAServer_stub.restore_request(const objs: TObjSeq);
var
  req: IStaticRequest;
  _objs: IStaticAny;
begin
  _objs := StaticAny(stat_seq_object,@objs);
  req := StaticRequest(self,'restore_request');
  req.add_in_arg(_objs);
  req.oneway;
  dorb_static_throw(req);
end;

procedure TOAServer_stub.obj_inactive(const obj: IORBObject);
var
  req: IStaticRequest;
  _obj: IStaticAny;
begin
  _obj := StaticAny(stat_object,@obj);
  req := StaticRequest(self,'obj_inactive');
  req.add_in_arg(_obj);
  req.oneway;
  dorb_static_throw(req);
end;

procedure TOAServer_stub.impl_inactive;
var
  req: IStaticRequest;
begin
  req := StaticRequest(self,'impl_inactive');
  req.oneway;
  dorb_static_throw(req);
end;

//***********************************************************
// TOAServer_stub_clp
//***********************************************************
function TOAServer_stub_clp.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/OAServer:1.0' then
    begin
      result := Pointer(self as IOAServer);
      exit;
  end;
end;

procedure TOAServer_stub_clp.restore_request(const objs: TObjSeq);
var
  _srv: IServant;
  srv: IOAServer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAServer_serv._narrow(_srv);
      if srv <> nil then
        srv.restore_request(objs)
    end;
  _postinvoke();
end;

procedure TOAServer_stub_clp.obj_inactive(const obj: IORBObject);
var
  _srv: IServant;
  srv: IOAServer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAServer_serv._narrow(_srv);
      if srv <> nil then
        srv.obj_inactive(obj)
    end;
  _postinvoke();
end;

procedure TOAServer_stub_clp.impl_inactive;
var
  _srv: IServant;
  srv: IOAServer;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAServer_serv._narrow(_srv);
      if srv <> nil then
        srv.impl_inactive
    end;
  _postinvoke();
end;

//***********************************************************
// TOAServer_serv
//***********************************************************
constructor TOAServer_serv.Create(const AImpl: IOAServer);
begin
  inherited Create();
  FImplementation := AImpl;
end;

procedure TOAServer_serv.restore_request(const objs: TObjSeq);
begin
  FImplementation.restore_request(objs);
end;

procedure TOAServer_serv.obj_inactive(const obj: IORBObject);
begin
  FImplementation.obj_inactive(obj);
end;

procedure TOAServer_serv.impl_inactive;
begin
  FImplementation.impl_inactive;
end;

function TOAServer_serv._this(): IOAServer;
var
  obj: IORBObject;
begin
  obj := this();
  result := TOAServer._narrow(obj);
end;

function TOAServer_serv._is_a(const repoid: RepositoryId): Boolean;
begin
  result := repoid = 'IDL:mg.org/CORBA/OAServer:1.0';
end;

function TOAServer_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId;
begin
  result := 'IDL:mg.org/CORBA/OAServer:1.0';
end;

function TOAServer_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TOAServer_stub_clp.Create(poa,obj);
end;

procedure TOAServer_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TOAServer_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/OAServer:1.0' then
    begin
      result := Pointer(IOAServer(self));
      exit;
    end;
end;

class function TOAServer_serv._narrow(const srv : IServant): IOAServer;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:mg.org/CORBA/OAServer:1.0');
  if p <> nil then
    result := IOAServer(p)
end;

function TOAServer_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  restore_request_objs: TObjSeq;
  obj_inactive_obj: IORBObject;
begin
  result := true;
  if req.op_name = 'restore_request' then
    begin
      req.add_in_arg(StaticAny(stat_seq_object,@restore_request_objs) as IStaticAny);
      if not req.read_args() then  exit;
      restore_request(restore_request_objs);
      req.write_results();
      exit;
    end
  else if req.op_name = 'obj_inactive' then
    begin
      req.add_in_arg(StaticAny(stat_object,@obj_inactive_obj) as IStaticAny);
      if not req.read_args() then  exit;
      obj_inactive(obj_inactive_obj);
      req.write_results();
      exit;
    end
  else if req.op_name = 'impl_inactive' then
    begin
      if not req.read_args() then  exit;
      impl_inactive;
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TOAServer_marshaller
//***********************************************************
function TOAServer_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IOAServer(addr^) := TOAServer._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TOAServer_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IOAServer(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TOAServer_marshaller._free(var addr: Pointer);
begin
  IOAServer(addr^) := nil;
end;

procedure TOAServer_marshaller._create(var addr: Pointer);
begin
  IOAServer(addr^) := TOAServer_stub.Create();
end;

procedure TOAServer_marshaller._assign(dst, src: Pointer);
begin
  IOAServer(dst^) := IOAServer(src^);
end;

function TOAServer_marshaller.typecode: ITypeCode;
begin
  result := _tc_OAServer.typecode;
end;

//***********************************************************
// TOAMediator
//***********************************************************
function TOAMediator.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/OAMediator:1.0' then
    begin
      result := Pointer(self as IOAMediator);
      exit;
    end;
end;

class function TOAMediator._narrow(const obj : IORBObject): IOAMediator;
var
  p: Pointer;
  stub: TOAMediator_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:mg.org/CORBA/OAMediator:1.0');
  if p <> nil then
    result := IOAMediator(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:mg.org/CORBA/OAMediator:1.0') then
        begin
          stub := TOAMediator_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TOAMediator.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:mg.org/CORBA/OAMediator:1.0'
end;

//***********************************************************
// TOAMediator_stub
//***********************************************************
procedure TOAMediator_stub.create_obj(const objref: IORBObject; const id: TRefData; out remote_objref: IORBObject; const svid: TServerId);
var
  req: IStaticRequest;
  _objref: IStaticAny;
  _id: IStaticAny;
  _remote_objref: IStaticAny;
  _svid: IStaticAny;
begin
  _objref := StaticAny(stat_object,@objref);
  _id := StaticAny(stat_seq_octet,@id);
  _remote_objref := StaticAny(stat_object,@remote_objref);
  _svid := StaticAny(stat_ulong,@svid);
  req := StaticRequest(self,'create_obj');
  req.add_in_arg(_objref);
  req.add_in_arg(_id);
  req.add_out_arg(_remote_objref);
  req.add_in_arg(_svid);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.restore_obj(const objref: IORBObject; var remote_objref: IORBObject; out id: TRefData; const svid: TServerId);
var
  req: IStaticRequest;
  _objref: IStaticAny;
  _remote_objref: IStaticAny;
  _id: IStaticAny;
  _svid: IStaticAny;
begin
  _objref := StaticAny(stat_object,@objref);
  _remote_objref := StaticAny(stat_object,@remote_objref);
  _id := StaticAny(stat_seq_octet,@id);
  _svid := StaticAny(stat_ulong,@svid);
  req := StaticRequest(self,'restore_obj');
  req.add_in_arg(_objref);
  req.add_inout_arg(_remote_objref);
  req.add_out_arg(_id);
  req.add_in_arg(_svid);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.activate_obj(const objref: IORBObject; const svid: TServerId);
var
  req: IStaticRequest;
  _objref: IStaticAny;
  _svid: IStaticAny;
begin
  _objref := StaticAny(stat_object,@objref);
  _svid := StaticAny(stat_ulong,@svid);
  req := StaticRequest(self,'activate_obj');
  req.add_in_arg(_objref);
  req.add_in_arg(_svid);
  req.oneway;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.deactivate_obj(const objref: IORBObject; const svid: TServerId);
var
  req: IStaticRequest;
  _objref: IStaticAny;
  _svid: IStaticAny;
begin
  _objref := StaticAny(stat_object,@objref);
  _svid := StaticAny(stat_ulong,@svid);
  req := StaticRequest(self,'deactivate_obj');
  req.add_in_arg(_objref);
  req.add_in_arg(_svid);
  req.oneway;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.migrate_obj(const objref: IORBObject; const svid: TServerId; const impl: IImplementationDef);
var
  req: IStaticRequest;
  _objref: IStaticAny;
  _svid: IStaticAny;
  _impl: IStaticAny;
begin
  _objref := StaticAny(stat_object,@objref);
  _svid := StaticAny(stat_ulong,@svid);
  _impl := StaticAny(ImplementationDef_marshaller,@impl);
  req := StaticRequest(self,'migrate_obj');
  req.add_in_arg(_objref);
  req.add_in_arg(_svid);
  req.add_in_arg(_impl);
  req.oneway;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.orphan_obj(const objref: IORBObject; const svid: TServerId);
var
  req: IStaticRequest;
  _objref: IStaticAny;
  _svid: IStaticAny;
begin
  _objref := StaticAny(stat_object,@objref);
  _svid := StaticAny(stat_ulong,@svid);
  req := StaticRequest(self,'orphan_obj');
  req.add_in_arg(_objref);
  req.add_in_arg(_svid);
  req.oneway;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.dispose_obj(const objref: IORBObject; const svid: TServerId);
var
  req: IStaticRequest;
  _objref: IStaticAny;
  _svid: IStaticAny;
begin
  _objref := StaticAny(stat_object,@objref);
  _svid := StaticAny(stat_ulong,@svid);
  req := StaticRequest(self,'dispose_obj');
  req.add_in_arg(_objref);
  req.add_in_arg(_svid);
  req.oneway;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.create_impl(const impl: IImplementationDef; const server: IOAServer; var id: TServerId);
var
  req: IStaticRequest;
  _impl: IStaticAny;
  _server: IStaticAny;
  _id: IStaticAny;
begin
  _impl := StaticAny(ImplementationDef_marshaller,@impl);
  _server := StaticAny(OAServer_marshaller,@server);
  _id := StaticAny(stat_ulong,@id);
  req := StaticRequest(self,'create_impl');
  req.add_in_arg(_impl);
  req.add_in_arg(_server);
  req.add_inout_arg(_id);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.activate_impl(const id: TServerId);
var
  req: IStaticRequest;
  _id: IStaticAny;
begin
  _id := StaticAny(stat_ulong,@id);
  req := StaticRequest(self,'activate_impl');
  req.add_in_arg(_id);
  req.oneway;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.deactivate_impl(const id: TServerId);
var
  req: IStaticRequest;
  _id: IStaticAny;
begin
  _id := StaticAny(stat_ulong,@id);
  req := StaticRequest(self,'deactivate_impl');
  req.add_in_arg(_id);
  req.oneway;
  dorb_static_throw(req);
end;

function TOAMediator_stub.get_remote_object(const key: TRefData): IORBObject;
var
  req: IStaticRequest;
  _key: IStaticAny;
  _result: IStaticAny;
begin
  _key := StaticAny(stat_seq_octet,@key);
  _result := StaticAny(stat_object, @result);
  req := StaticRequest(self,'get_remote_object');
  req.add_in_arg(_key);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TOAMediator_stub.dispose_impl(const id: TServerId);
var
  req: IStaticRequest;
  _id: IStaticAny;
begin
  _id := StaticAny(stat_ulong,@id);
  req := StaticRequest(self,'dispose_impl');
  req.add_in_arg(_id);
  req.invoke;
  dorb_static_throw(req);
end;

function TOAMediator_stub.get_restore_objs(const id: TServerId): TObjSeq;
var
  req: IStaticRequest;
  _id: IStaticAny;
  _result: IStaticAny;
begin
  _id := StaticAny(stat_ulong,@id);
  _result := StaticAny(stat_seq_object, @result);
  req := StaticRequest(self,'get_restore_objs');
  req.add_in_arg(_id);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TOAMediator_stub.force_activation(const impl: IImplementationDef): boolean;
var
  req: IStaticRequest;
  _impl: IStaticAny;
  _result: IStaticAny;
begin
  _impl := StaticAny(ImplementationDef_marshaller,@impl);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'force_activation');
  req.add_in_arg(_impl);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TOAMediator_stub_clp
//***********************************************************
function TOAMediator_stub_clp.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/OAMediator:1.0' then
    begin
      result := Pointer(self as IOAMediator);
      exit;
  end;
end;

procedure TOAMediator_stub_clp.create_obj(const objref: IORBObject; const id: TRefData; out remote_objref: IORBObject; const svid: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.create_obj(objref, id, remote_objref, svid)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.restore_obj(const objref: IORBObject; var remote_objref: IORBObject; out id: TRefData; const svid: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.restore_obj(objref, remote_objref, id, svid)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.activate_obj(const objref: IORBObject; const svid: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.activate_obj(objref, svid)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.deactivate_obj(const objref: IORBObject; const svid: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.deactivate_obj(objref, svid)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.migrate_obj(const objref: IORBObject; const svid: TServerId; const impl: IImplementationDef);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.migrate_obj(objref, svid, impl)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.orphan_obj(const objref: IORBObject; const svid: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.orphan_obj(objref, svid)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.dispose_obj(const objref: IORBObject; const svid: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.dispose_obj(objref, svid)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.create_impl(const impl: IImplementationDef; const server: IOAServer; var id: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.create_impl(impl, server, id)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.activate_impl(const id: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.activate_impl(id)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.deactivate_impl(const id: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.deactivate_impl(id)
    end;
  _postinvoke();
end;

function TOAMediator_stub_clp.get_remote_object(const key: TRefData): IORBObject;
var
  _srv: IServant;
  srv: IOAMediator;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_remote_object(key)
    end;
  _postinvoke();
end;

procedure TOAMediator_stub_clp.dispose_impl(const id: TServerId);
var
  _srv: IServant;
  srv: IOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.dispose_impl(id)
    end;
  _postinvoke();
end;

function TOAMediator_stub_clp.get_restore_objs(const id: TServerId): TObjSeq;
var
  _srv: IServant;
  srv: IOAMediator;
begin
  result := nil;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.get_restore_objs(id)
    end;
  _postinvoke();
end;

function TOAMediator_stub_clp.force_activation(const impl: IImplementationDef): boolean;
var
  _srv: IServant;
  srv: IOAMediator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TOAMediator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.force_activation(impl)
    end;
  _postinvoke();
end;

//***********************************************************
// TOAMediator_serv
//***********************************************************
constructor TOAMediator_serv.Create(const AImpl: IOAMediator);
begin
  inherited Create();
  FImplementation := AImpl;
end;

procedure TOAMediator_serv.create_obj(const objref: IORBObject; const id: TRefData; out remote_objref: IORBObject; const svid: TServerId);
begin
  FImplementation.create_obj(objref, id, remote_objref, svid);
end;

procedure TOAMediator_serv.restore_obj(const objref: IORBObject; var remote_objref: IORBObject; out id: TRefData; const svid: TServerId);
begin
  FImplementation.restore_obj(objref, remote_objref, id, svid);
end;

procedure TOAMediator_serv.activate_obj(const objref: IORBObject; const svid: TServerId);
begin
  FImplementation.activate_obj(objref, svid);
end;

procedure TOAMediator_serv.deactivate_obj(const objref: IORBObject; const svid: TServerId);
begin
  FImplementation.deactivate_obj(objref, svid);
end;

procedure TOAMediator_serv.migrate_obj(const objref: IORBObject; const svid: TServerId; const impl: IImplementationDef);
begin
  FImplementation.migrate_obj(objref, svid, impl);
end;

procedure TOAMediator_serv.orphan_obj(const objref: IORBObject; const svid: TServerId);
begin
  FImplementation.orphan_obj(objref, svid);
end;

procedure TOAMediator_serv.dispose_obj(const objref: IORBObject; const svid: TServerId);
begin
  FImplementation.dispose_obj(objref, svid);
end;

procedure TOAMediator_serv.create_impl(const impl: IImplementationDef; const server: IOAServer; var id: TServerId);
begin
  FImplementation.create_impl(impl, server, id);
end;

procedure TOAMediator_serv.activate_impl(const id: TServerId);
begin
  FImplementation.activate_impl(id);
end;

procedure TOAMediator_serv.deactivate_impl(const id: TServerId);
begin
  FImplementation.deactivate_impl(id);
end;

function TOAMediator_serv.get_remote_object(const key: TRefData): IORBObject;
begin
  result := FImplementation.get_remote_object(key);
end;

procedure TOAMediator_serv.dispose_impl(const id: TServerId);
begin
  FImplementation.dispose_impl(id);
end;

function TOAMediator_serv.get_restore_objs(const id: TServerId): TObjSeq;
begin
  result := FImplementation.get_restore_objs(id);
end;

function TOAMediator_serv.force_activation(const impl: IImplementationDef): boolean;
begin
  result := FImplementation.force_activation(impl);
end;

function TOAMediator_serv._this(): IOAMediator;
var
  obj: IORBObject;
begin
  obj := this();
  result := TOAMediator._narrow(obj);
end;

function TOAMediator_serv._is_a(const repoid: RepositoryId): Boolean;
begin
  result := repoid = 'IDL:mg.org/CORBA/OAMediator:1.0';
end;

function TOAMediator_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId;
begin
  result := 'IDL:mg.org/CORBA/OAMediator:1.0';
end;

function TOAMediator_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TOAMediator_stub_clp.Create(poa,obj);
end;

procedure TOAMediator_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TOAMediator_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/OAMediator:1.0' then
    begin
      result := Pointer(IOAMediator(self));
      exit;
    end;
end;

class function TOAMediator_serv._narrow(const srv : IServant): IOAMediator;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:mg.org/CORBA/OAMediator:1.0');
  if p <> nil then
    result := IOAMediator(p)
end;

function TOAMediator_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  create_obj_objref: IORBObject;
  create_obj_id: TRefData;
  create_obj_remote_objref: IORBObject;
  create_obj_svid: TServerId;
  restore_obj_objref: IORBObject;
  restore_obj_remote_objref: IORBObject;
  restore_obj_id: TRefData;
  restore_obj_svid: TServerId;
  activate_obj_objref: IORBObject;
  activate_obj_svid: TServerId;
  deactivate_obj_objref: IORBObject;
  deactivate_obj_svid: TServerId;
  migrate_obj_objref: IORBObject;
  migrate_obj_svid: TServerId;
  migrate_obj_impl: IImplementationDef;
  orphan_obj_objref: IORBObject;
  orphan_obj_svid: TServerId;
  dispose_obj_objref: IORBObject;
  dispose_obj_svid: TServerId;
  create_impl_impl: IImplementationDef;
  create_impl_server: IOAServer;
  create_impl_id: TServerId;
  activate_impl_id: TServerId;
  deactivate_impl_id: TServerId;
  get_remote_object_result: IORBObject;
  get_remote_object_key: TRefData;
  dispose_impl_id: TServerId;
  get_restore_objs_result: TObjSeq;
  get_restore_objs_id: TServerId;
  force_activation_result: boolean;
  force_activation_impl: IImplementationDef;
begin
  result := true;
  if req.op_name = 'create_obj' then
    begin
      req.add_in_arg(StaticAny(stat_object,@create_obj_objref) as IStaticAny);
      req.add_in_arg(StaticAny(stat_seq_octet,@create_obj_id) as IStaticAny);
      req.add_out_arg(StaticAny(stat_object,@create_obj_remote_objref) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@create_obj_svid) as IStaticAny);
      if not req.read_args() then  exit;
      create_obj(create_obj_objref, create_obj_id, create_obj_remote_objref, create_obj_svid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'restore_obj' then
    begin
      req.add_in_arg(StaticAny(stat_object,@restore_obj_objref) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_object,@restore_obj_remote_objref) as IStaticAny);
      req.add_out_arg(StaticAny(stat_seq_octet,@restore_obj_id) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@restore_obj_svid) as IStaticAny);
      if not req.read_args() then  exit;
      restore_obj(restore_obj_objref, restore_obj_remote_objref, restore_obj_id, restore_obj_svid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'activate_obj' then
    begin
      req.add_in_arg(StaticAny(stat_object,@activate_obj_objref) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@activate_obj_svid) as IStaticAny);
      if not req.read_args() then  exit;
      activate_obj(activate_obj_objref, activate_obj_svid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'deactivate_obj' then
    begin
      req.add_in_arg(StaticAny(stat_object,@deactivate_obj_objref) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@deactivate_obj_svid) as IStaticAny);
      if not req.read_args() then  exit;
      deactivate_obj(deactivate_obj_objref, deactivate_obj_svid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'migrate_obj' then
    begin
      req.add_in_arg(StaticAny(stat_object,@migrate_obj_objref) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@migrate_obj_svid) as IStaticAny);
      req.add_in_arg(StaticAny(ImplementationDef_marshaller,@migrate_obj_impl) as IStaticAny);
      if not req.read_args() then  exit;
      migrate_obj(migrate_obj_objref, migrate_obj_svid, migrate_obj_impl);
      req.write_results();
      exit;
    end
  else if req.op_name = 'orphan_obj' then
    begin
      req.add_in_arg(StaticAny(stat_object,@orphan_obj_objref) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@orphan_obj_svid) as IStaticAny);
      if not req.read_args() then  exit;
      orphan_obj(orphan_obj_objref, orphan_obj_svid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'dispose_obj' then
    begin
      req.add_in_arg(StaticAny(stat_object,@dispose_obj_objref) as IStaticAny);
      req.add_in_arg(StaticAny(stat_ulong,@dispose_obj_svid) as IStaticAny);
      if not req.read_args() then  exit;
      dispose_obj(dispose_obj_objref, dispose_obj_svid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'create_impl' then
    begin
      req.add_in_arg(StaticAny(ImplementationDef_marshaller,@create_impl_impl) as IStaticAny);
      req.add_in_arg(StaticAny(OAServer_marshaller,@create_impl_server) as IStaticAny);
      req.add_inout_arg(StaticAny(stat_ulong,@create_impl_id) as IStaticAny);
      if not req.read_args() then  exit;
      create_impl(create_impl_impl, create_impl_server, create_impl_id);
      req.write_results();
      exit;
    end
  else if req.op_name = 'activate_impl' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@activate_impl_id) as IStaticAny);
      if not req.read_args() then  exit;
      activate_impl(activate_impl_id);
      req.write_results();
      exit;
    end
  else if req.op_name = 'deactivate_impl' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@deactivate_impl_id) as IStaticAny);
      if not req.read_args() then  exit;
      deactivate_impl(deactivate_impl_id);
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_remote_object' then
    begin
      req.add_in_arg(StaticAny(stat_seq_octet,@get_remote_object_key) as IStaticAny);
      req.set_result(StaticAny(stat_object,@get_remote_object_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_remote_object_result := get_remote_object(get_remote_object_key);
      req.write_results();
      exit;
    end
  else if req.op_name = 'dispose_impl' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@dispose_impl_id) as IStaticAny);
      if not req.read_args() then  exit;
      dispose_impl(dispose_impl_id);
      req.write_results();
      exit;
    end
  else if req.op_name = 'get_restore_objs' then
    begin
      req.add_in_arg(StaticAny(stat_ulong,@get_restore_objs_id) as IStaticAny);
      req.set_result(StaticAny(stat_seq_object,@get_restore_objs_result) as IStaticAny);
      if not req.read_args() then  exit;
      get_restore_objs_result := get_restore_objs(get_restore_objs_id);
      req.write_results();
      exit;
    end
  else if req.op_name = 'force_activation' then
    begin
      req.add_in_arg(StaticAny(ImplementationDef_marshaller,@force_activation_impl) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@force_activation_result) as IStaticAny);
      if not req.read_args() then  exit;
      force_activation_result := force_activation(force_activation_impl);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TOAMediator_marshaller
//***********************************************************
function TOAMediator_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IOAMediator(addr^) := TOAMediator._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TOAMediator_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IOAMediator(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TOAMediator_marshaller._free(var addr: Pointer);
begin
  IOAMediator(addr^) := nil;
end;

procedure TOAMediator_marshaller._create(var addr: Pointer);
begin
  IOAMediator(addr^) := TOAMediator_stub.Create();
end;

procedure TOAMediator_marshaller._assign(dst, src: Pointer);
begin
  IOAMediator(dst^) := IOAMediator(src^);
end;

function TOAMediator_marshaller.typecode: ITypeCode;
begin
  result := _tc_OAMediator.typecode;
end;

//***********************************************************
// TPOAMediator
//***********************************************************
function TPOAMediator.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/POAMediator:1.0' then
    begin
      result := Pointer(self as IPOAMediator);
      exit;
    end;
end;

class function TPOAMediator._narrow(const obj : IORBObject): IPOAMediator;
var
  p: Pointer;
  stub: TPOAMediator_stub;
begin
  result := nil;
  if obj = nil then exit;
  p := obj.narrow_helper('IDL:mg.org/CORBA/POAMediator:1.0');
  if p <> nil then
    result := IPOAMediator(p)
  else
    begin
      if narrow_helper2(obj) or obj._is_a_remote('IDL:mg.org/CORBA/POAMediator:1.0') then
        begin
          stub := TPOAMediator_stub.Create();
          stub.assign(obj);
          result := stub;
        end;
    end;
end;

class function TPOAMediator.narrow_helper2(const obj: IORBObject): Boolean;
begin
  result := obj._repoid = 'IDL:mg.org/CORBA/POAMediator:1.0'
end;

//***********************************************************
// TPOAMediator_stub
//***********************************************************
function TPOAMediator_stub.create_impl(const svid: AnsiString; const ior: AnsiString): AnsiString;
var
  req: IStaticRequest;
  _svid: IStaticAny;
  _ior: IStaticAny;
  _result: IStaticAny;
begin
  _svid := StaticAny(stat_string,@svid);
  _ior := StaticAny(stat_string,@ior);
  _result := StaticAny(stat_string, @result);
  req := StaticRequest(self,'create_impl');
  req.add_in_arg(_svid);
  req.add_in_arg(_ior);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TPOAMediator_stub.activate_impl(const svid: AnsiString);
var
  req: IStaticRequest;
  _svid: IStaticAny;
begin
  _svid := StaticAny(stat_string,@svid);
  req := StaticRequest(self,'activate_impl');
  req.add_in_arg(_svid);
  req.invoke;
  dorb_static_throw(req);
end;

procedure TPOAMediator_stub.deactivate_impl(const svid: AnsiString);
var
  req: IStaticRequest;
  _svid: IStaticAny;
begin
  _svid := StaticAny(stat_string,@svid);
  req := StaticRequest(self,'deactivate_impl');
  req.add_in_arg(_svid);
  req.invoke;
  dorb_static_throw(req);
end;

function TPOAMediator_stub.force_activation(const impl: IImplementationDef): boolean;
var
  req: IStaticRequest;
  _impl: IStaticAny;
  _result: IStaticAny;
begin
  _impl := StaticAny(ImplementationDef_marshaller,@impl);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'force_activation');
  req.add_in_arg(_impl);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TPOAMediator_stub.hold(const impl: IImplementationDef): boolean;
var
  req: IStaticRequest;
  _impl: IStaticAny;
  _result: IStaticAny;
begin
  _impl := StaticAny(ImplementationDef_marshaller,@impl);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'hold');
  req.add_in_arg(_impl);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TPOAMediator_stub.stop(const impl: IImplementationDef): boolean;
var
  req: IStaticRequest;
  _impl: IStaticAny;
  _result: IStaticAny;
begin
  _impl := StaticAny(ImplementationDef_marshaller,@impl);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'stop');
  req.add_in_arg(_impl);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

function TPOAMediator_stub.continue(const impl: IImplementationDef): boolean;
var
  req: IStaticRequest;
  _impl: IStaticAny;
  _result: IStaticAny;
begin
  _impl := StaticAny(ImplementationDef_marshaller,@impl);
  _result := StaticAny(stat_boolean, @result);
  req := StaticRequest(self,'continue');
  req.add_in_arg(_impl);
  req.set_result(_result);
  req.invoke;
  dorb_static_throw(req);
end;

//***********************************************************
// TPOAMediator_stub_clp
//***********************************************************
function TPOAMediator_stub_clp.narrow_helper(const str: RepositoryId): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/POAMediator:1.0' then
    begin
      result := Pointer(self as IPOAMediator);
      exit;
  end;
end;

function TPOAMediator_stub_clp.create_impl(const svid: AnsiString; const ior: AnsiString): AnsiString;
var
  _srv: IServant;
  srv: IPOAMediator;
begin
  result := '';
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPOAMediator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.create_impl(svid, ior)
    end;
  _postinvoke();
end;

procedure TPOAMediator_stub_clp.activate_impl(const svid: AnsiString);
var
  _srv: IServant;
  srv: IPOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.activate_impl(svid)
    end;
  _postinvoke();
end;

procedure TPOAMediator_stub_clp.deactivate_impl(const svid: AnsiString);
var
  _srv: IServant;
  srv: IPOAMediator;
begin
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPOAMediator_serv._narrow(_srv);
      if srv <> nil then
        srv.deactivate_impl(svid)
    end;
  _postinvoke();
end;

function TPOAMediator_stub_clp.force_activation(const impl: IImplementationDef): boolean;
var
  _srv: IServant;
  srv: IPOAMediator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPOAMediator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.force_activation(impl)
    end;
  _postinvoke();
end;

function TPOAMediator_stub_clp.hold(const impl: IImplementationDef): boolean;
var
  _srv: IServant;
  srv: IPOAMediator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPOAMediator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.hold(impl)
    end;
  _postinvoke();
end;

function TPOAMediator_stub_clp.stop(const impl: IImplementationDef): boolean;
var
  _srv: IServant;
  srv: IPOAMediator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPOAMediator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.stop(impl)
    end;
  _postinvoke();
end;

function TPOAMediator_stub_clp.continue(const impl: IImplementationDef): boolean;
var
  _srv: IServant;
  srv: IPOAMediator;
begin
  result := false;
  _srv := _preinvoke();
  if _srv <> nil then
    begin
      srv := TPOAMediator_serv._narrow(_srv);
      if srv <> nil then
        result := srv.continue(impl)
    end;
  _postinvoke();
end;

//***********************************************************
// TPOAMediator_serv
//***********************************************************
constructor TPOAMediator_serv.Create(const AImpl: IPOAMediator);
begin
  inherited Create();
  FImplementation := AImpl;
end;

function TPOAMediator_serv.create_impl(const svid: AnsiString; const ior: AnsiString): AnsiString;
begin
  result := FImplementation.create_impl(svid, ior);
end;

procedure TPOAMediator_serv.activate_impl(const svid: AnsiString);
begin
  FImplementation.activate_impl(svid);
end;

procedure TPOAMediator_serv.deactivate_impl(const svid: AnsiString);
begin
  FImplementation.deactivate_impl(svid);
end;

function TPOAMediator_serv.force_activation(const impl: IImplementationDef): boolean;
begin
  result := FImplementation.force_activation(impl);
end;

function TPOAMediator_serv.hold(const impl: IImplementationDef): boolean;
begin
  result := FImplementation.hold(impl);
end;

function TPOAMediator_serv.stop(const impl: IImplementationDef): boolean;
begin
  result := FImplementation.stop(impl);
end;

function TPOAMediator_serv.continue(const impl: IImplementationDef): boolean;
begin
  result := FImplementation.continue(impl);
end;

function TPOAMediator_serv._this(): IPOAMediator;
var
  obj: IORBObject;
begin
  obj := this();
  result := TPOAMediator._narrow(obj);
end;

function TPOAMediator_serv._is_a(const repoid: RepositoryId): Boolean;
begin
  result := repoid = 'IDL:mg.org/CORBA/POAMediator:1.0';
end;

function TPOAMediator_serv._primary_interface(const objid: ObjectID; const poa: IPOA): RepositoryId;
begin
  result := 'IDL:mg.org/CORBA/POAMediator:1.0';
end;

function TPOAMediator_serv._make_stub(const poa: IPOA; const obj : IORBObject): IORBObject;
begin
  result := TPOAMediator_stub_clp.Create(poa,obj);
end;

procedure TPOAMediator_serv.invoke(const serv: IStaticServerRequest);
begin
  if not _dispatch(serv) then
    begin
      serv.set_exception(BAD_OPERATION.Create(0, COMPLETED_NO) as IORBException);
      serv.write_results();
    end;
end;

function TPOAMediator_serv.narrow_helper(const str: RepositoryID): Pointer;
begin
  result := nil;
  if str = 'IDL:mg.org/CORBA/POAMediator:1.0' then
    begin
      result := Pointer(IPOAMediator(self));
      exit;
    end;
end;

class function TPOAMediator_serv._narrow(const srv : IServant): IPOAMediator;
var
  p: Pointer;
begin
  result := nil;
  if srv = nil then exit;
  p := srv.narrow_helper('IDL:mg.org/CORBA/POAMediator:1.0');
  if p <> nil then
    result := IPOAMediator(p)
end;

function TPOAMediator_serv._dispatch(const req: IStaticServerRequest): Boolean;
var
  create_impl_result: AnsiString;
  create_impl_svid: AnsiString;
  create_impl_ior: AnsiString;
  activate_impl_svid: AnsiString;
  deactivate_impl_svid: AnsiString;
  force_activation_result: boolean;
  force_activation_impl: IImplementationDef;
  hold_result: boolean;
  hold_impl: IImplementationDef;
  stop_result: boolean;
  stop_impl: IImplementationDef;
  continue_result: boolean;
  continue_impl: IImplementationDef;
begin
  result := true;
  if req.op_name = 'create_impl' then
    begin
      req.add_in_arg(StaticAny(stat_string,@create_impl_svid) as IStaticAny);
      req.add_in_arg(StaticAny(stat_string,@create_impl_ior) as IStaticAny);
      req.set_result(StaticAny(stat_string,@create_impl_result) as IStaticAny);
      if not req.read_args() then  exit;
      create_impl_result := create_impl(create_impl_svid, create_impl_ior);
      req.write_results();
      exit;
    end
  else if req.op_name = 'activate_impl' then
    begin
      req.add_in_arg(StaticAny(stat_string,@activate_impl_svid) as IStaticAny);
      if not req.read_args() then  exit;
      activate_impl(activate_impl_svid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'deactivate_impl' then
    begin
      req.add_in_arg(StaticAny(stat_string,@deactivate_impl_svid) as IStaticAny);
      if not req.read_args() then  exit;
      deactivate_impl(deactivate_impl_svid);
      req.write_results();
      exit;
    end
  else if req.op_name = 'force_activation' then
    begin
      req.add_in_arg(StaticAny(ImplementationDef_marshaller,@force_activation_impl) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@force_activation_result) as IStaticAny);
      if not req.read_args() then  exit;
      force_activation_result := force_activation(force_activation_impl);
      req.write_results();
      exit;
    end
  else if req.op_name = 'hold' then
    begin
      req.add_in_arg(StaticAny(ImplementationDef_marshaller,@hold_impl) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@hold_result) as IStaticAny);
      if not req.read_args() then  exit;
      hold_result := hold(hold_impl);
      req.write_results();
      exit;
    end
  else if req.op_name = 'stop' then
    begin
      req.add_in_arg(StaticAny(ImplementationDef_marshaller,@stop_impl) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@stop_result) as IStaticAny);
      if not req.read_args() then  exit;
      stop_result := stop(stop_impl);
      req.write_results();
      exit;
    end
  else if req.op_name = 'continue' then
    begin
      req.add_in_arg(StaticAny(ImplementationDef_marshaller,@continue_impl) as IStaticAny);
      req.set_result(StaticAny(stat_boolean,@continue_result) as IStaticAny);
      if not req.read_args() then  exit;
      continue_result := continue(continue_impl);
      req.write_results();
      exit;
    end;
  result := false;
end;

//***********************************************************
// TPOAMediator_marshaller
//***********************************************************
function TPOAMediator_marshaller.demarshal(dec: IDecoder;const addr : Pointer): Boolean;
var
  obj: IORBObject;
begin
  result := false;
  if not stat_Object.demarshal(dec,@obj) then exit;
  IPOAMediator(addr^) := TPOAMediator._narrow(obj);
  result := (obj = nil) or (Pointer(addr^) <> nil);
end;

procedure TPOAMediator_marshaller.marshal(enc: IEncoder;const addr : Pointer);
var
  obj: IORBObject;
begin
  obj := IPOAMediator(addr^) as IORBObject;
  stat_Object.marshal(enc,@Pointer(obj));
end;

procedure TPOAMediator_marshaller._free(var addr: Pointer);
begin
  IPOAMediator(addr^) := nil;
end;

procedure TPOAMediator_marshaller._create(var addr: Pointer);
begin
  IPOAMediator(addr^) := TPOAMediator_stub.Create();
end;

procedure TPOAMediator_marshaller._assign(dst, src: Pointer);
begin
  IPOAMediator(dst^) := IPOAMediator(src^);
end;

function TPOAMediator_marshaller.typecode: ITypeCode;
begin
  result := _tc_POAMediator.typecode;
end;

initialization
  ActivationMode_marshaller := TActivationMode_marshaller.Create();
  ObjectInfo_marshaller := TObjectInfo_marshaller.Create();
  ObjectInfo_seq_marshaller := TObjectInfo_seq_marshaller.Create();
  ImplementationDef_marshaller := TImplementationDef_marshaller.Create();
  ImplementationDef_seq_marshaller := TImplementationDef_seq_marshaller.Create();
  ImplRepository_marshaller := TImplRepository_marshaller.Create();
  OAServer_marshaller := TOAServer_marshaller.Create();
  OAMediator_marshaller := TOAMediator_marshaller.Create();
  POAMediator_marshaller := TPOAMediator_marshaller.Create();
  _tc_ActivationMode := CreateTypeCodeConst('0100000011000000d8000000010000003600000049444c3a6d672e6f72672f434f5242412f496d706c656d656e746174696f6e4465662f'+
    '41637469766174696f6e4d6f64653a312e300000000f00000041637469766174696f6e4d6f64650000060000000f000000416374697661'+
    '74655368617265640000110000004163746976617465556e736861726564000000001200000041637469766174655065724d6574686f64'+
    '00000013000000416374697661746550657273697374656e7400001000000041637469766174654c696272617279000c00000041637469'+
    '76617465504f4100');
  _tc_ObjectInfo := CreateTypeCodeConst('010000000f000000d4000000010000003200000049444c3a6d672e6f72672f434f5242412f496d706c656d656e746174696f6e4465662f'+
    '4f626a656374496e666f3a312e300000000b0000004f626a656374496e666f000002000000070000007265706f69640000120000000000'+
    '000004000000746167001500000060000000010000003100000049444c3a6d672e6f72672f434f5242412f496d706c656d656e74617469'+
    '6f6e4465662f4f626a6563745461673a312e30000000000a0000004f626a656374546167000000130000000c000000010000000a00000000000000');
  _tc_ObjectInfo_seq := CreateTypeCodeConst('0100000013000000e4000000010000000f000000d4000000010000003200000049444c3a6d672e6f72672f434f5242412f496d706c656d'+
    '656e746174696f6e4465662f4f626a656374496e666f3a312e300000000b0000004f626a656374496e666f000002000000070000007265'+
    '706f69640000120000000000000004000000746167001500000060000000010000003100000049444c3a6d672e6f72672f434f5242412f'+
    '496d706c656d656e746174696f6e4465662f4f626a6563745461673a312e30000000000a0000004f626a65637454616700000013000000'+
    '0c000000010000000a0000000000000000000000');
  _tc_ImplementationDef := CreateTypeCodeConst('010000000e00000046000000010000002700000049444c3a6d672e6f72672f434f5242412f496d706c656d656e746174696f6e4465663a'+
    '312e30000012000000496d706c656d656e746174696f6e44656600');
  _tc_ImplementationDef_seq := CreateTypeCodeConst('010000001300000058000000010000000e00000046000000010000002700000049444c3a6d672e6f72672f434f5242412f496d706c656d'+
    '656e746174696f6e4465663a312e30000012000000496d706c656d656e746174696f6e44656600000000000000');
  _tc_ImplRepository := CreateTypeCodeConst('010000000e0000003f000000010000002400000049444c3a6d672e6f72672f434f5242412f496d706c5265706f7369746f72793a312e30'+
    '000f000000496d706c5265706f7369746f727900');
  _tc_OAServer := CreateTypeCodeConst('010000000e00000035000000010000001e00000049444c3a6d672e6f72672f434f5242412f4f415365727665723a312e30000000090000'+
    '004f4153657276657200');
  _tc_OAMediator := CreateTypeCodeConst('010000000e00000037000000010000002000000049444c3a6d672e6f72672f434f5242412f4f414d65646961746f723a312e30000b0000'+
    '004f414d65646961746f7200');
  _tc_POAMediator := CreateTypeCodeConst('010000000e0000003c000000010000002100000049444c3a6d672e6f72672f434f5242412f504f414d65646961746f723a312e30000000'+
    '000c000000504f414d65646961746f7200');
end.
