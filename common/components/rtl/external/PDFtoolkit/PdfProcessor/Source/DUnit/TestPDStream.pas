unit TestPDStream;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Stream, PDDictionary, gtObject, Classes, gtTypes, PDBaseObject, PDStream,
  SysUtils, DUnitAssert, Dialogs, FileStream, PDInteger, PDBoolean, PDName, PDString;

type
  // Test methods for class TgtPDStream
  
  TestTgtPDStream = class(TAssertTestCase)
  strict private
    FgtPDStream: TgtPDStream;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestClone;
    procedure TestSaveToStream;
    procedure TestIsStream;
    procedure TestGetDict;
    procedure TestSetDict;
    procedure TestIsof;
    procedure TestReset;
    procedure TestClose;
    procedure TestGetChar;
    procedure TestLookChar;
    procedure TestReadLine;
    procedure TestGetPosition;
    procedure TestSetPosition;
    procedure TestMakeSubStream;
    procedure TestGetStart;
    procedure TestMoveStart;
    procedure TestAssign;
    procedure TestRead;
    procedure TestRead1;
    procedure TestWrite;
    procedure TestWrite1;
    procedure TestGetStream;
  end;

implementation
var
  ADict: TgtPDDictionary;
  FInFile: TFileStream;
  FgtInFile: TgtStream;
//  FgtPDStream: TgtPDStream;

procedure TestTgtPDStream.SetUp;
begin
  Adict := TgtPDDictionary.Create(TgtObject(nil));   //Length 384/C 535/Filter/FlateDecode/I 557/S 227
  Adict.Add('Length', TgtPDInteger.Create(384));
  ADict.Add('C', TgtPDInteger.Create(535));
  Adict.Add('Filter', TgtPDName.Create('FlateDecode'));
  Adict.Add('I', TgtPDInteger.Create(557));
  ADict.Add('S', TgtPDInteger.Create(227));
  Adict.Add('Type', TgtPDName.Create('Flate'));  // Not in the stream, only for the testing.

  FInFile := TFileStream.Create('Filters\CollectionTest.txt', fmOpenReadWrite);
  FgtInFile := TgtFileStream.Create(FInFile, 0, 0, False);

  FgtPDStream := TgtPDStream.Create(FgtInfile, ADict);
end;

procedure TestTgtPDStream.TearDown;
begin
  //FgtPDStream.Free;
  //FreeAndNil(FgtPDStream);
  FreeAndNil(FInFile);
  FreeAndNil(FgtInFile);
 end;

procedure TestTgtPDStream.TestClone;
var
  ReturnValue: TgtPDBaseObject;
begin
  ReturnValue := FgtPDStream.Clone;
  Assert.IsTrue(ReturnValue.IsStream);
  FreeAndNil(ReturnValue);
end;

procedure TestTgtPDStream.TestSaveToStream;
var
  ReturnValue: Cardinal;
  XRef: TgtObject;
  OnlyChanged: Boolean;
  Stream: TgtStream;
begin
  // TODO: Setup method call parameters
  ReturnValue := FgtPDStream.SaveToStream(Stream, OnlyChanged, XRef);
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestIsStream;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FgtPDStream.IsStream;
  Assert.IsTrue(ReturnValue);
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestGetDict;
var
  ReturnValue: TgtPDBaseObject;
begin
  ReturnValue := FgtPDStream.GetDict;
  Assert.IsTrue(ReturnValue.IsDict);
  Assert.AreEqual(TgtPDDictionary(ReturnValue).GetKey(2), 'Filter');
  //FreeAndNil(ReturnValue);
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestSetDict;
Var
  ReturnValue: TgtPDBaseObject;
begin
  FreeAndNil(ADict);
  Adict := TgtPDDictionary.Create(TgtObject(nil));   //Length 384/C 535/Filter/FlateDecode/I 557/S 227
  Adict.Add('Length', TgtPDInteger.Create(384));
  ADict.Add('C', TgtPDInteger.Create(535));
  Adict.Add('I', TgtPDInteger.Create(557));
  Adict.Add('Filter', TgtPDName.Create('FlateDecode'));
  ADict.Add('S', TgtPDInteger.Create(227));


  FgtPDStream.SetDict(ADict);
  
  ReturnValue := FgtPDStream.GetDict;
  Assert.AreEqual(TgtPDDictionary(ReturnValue).GetKey(3) ,'Filter');

  FreeAndNil(ReturnValue);
 // FreeAndNil(ADict);

  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestIsof;
var
  ReturnValue: Boolean;
//  ADictType: string;
begin
  // TODO: Setup method call parameters
  ReturnValue := FgtPDStream.Isof('Flate');
  Assert.IsTrue(ReturnValue);
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestReset;
begin
  FgtPDStream.Reset;
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestClose;
begin
  FgtPDStream.Close;
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestGetChar;
var
  I: Integer;
begin
//  ReturnValue := FgtPDStream.GetChar;
  for I := 0 to 9 do
  begin
    Assert.AreEqual(FgtInFile.LookChar, FgtPDStream.GetChar);
  end;

  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestLookChar;
var
  ReturnValue, I : Integer;
begin
  ReturnValue := FgtInFile.LookChar;
  for I := 0 to 9 do
  begin
    Assert.AreEqual(FgtPDStream.LookChar, ReturnValue);
  end;
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestReadLine;                    // Range Check Error
var
  ReturnValue, FileValue: string;
  Count: System.Integer;
begin
  // TODO: Setup method call parameters
  ReturnValue := FgtPDStream.ReadLine(5);
  ShowMessage(ReturnValue);
  FgtPDStream.Reset;
  FileValue := '';
  for count := 0 to 9 do
    FileValue := FileValue + Char(FgtPDStream.GetChar);

  assert.AreEqual(ReturnValue, FileValue);
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestGetPosition;
var
  ReturnValue: Cardinal;
  I: Integer;
begin
  for I := 0 to 9 do
    FgtPDStream.GetChar;

  ReturnValue := FgtPDStream.GetPosition;
  
  Assert.AreEqual(ReturnValue, 10);
    
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestSetPosition;
var
  Origin: TSeekOrigin;
  Offset: Int64;
  I: Integer;
begin
  // TODO: Setup method call parameters
  Origin := soBeginning;
  Offset := 30;

  FgtPDStream.SetPosition(Offset, Origin);

  for I := 0 to 9 do
    FgtPDStream.GetChar;

  Assert.AreEqual(FgtPDStream.GetPosition, 40);
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestMakeSubStream;
var
  ReturnValue: TgtPDStream;
  ADict: TgtPDBaseObject;
  ALimited: Boolean;
  ALength: System.Integer;
  AStart: System.Integer;
begin
  // TODO: Setup method call parameters
  ReturnValue := FgtPDStream.MakeSubStream(AStart, ALength, ALimited, ADict);
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestGetStart;
var
  ReturnValue: System.Integer;
begin
  FgtPDStream.Reset;
  FgtPDStream.MoveStart(50);

  ReturnValue := FgtPDStream.GetStart;
  Assert.AreEqual(ReturnValue, 50);
  // TODO: Validate method results
end;

procedure TestTgtPDStream.TestMoveStart;
var
  I: Integer;
begin
  // TODO: Setup method call parameters
  FgtPDStream.Reset;

  FgtPDStream.MoveStart(50);

  Assert.AreEqual(FgtPDStream.GetStart, 50);

end;

procedure TestTgtPDStream.TestAssign;                          // Have to be stream only
var
  ASourceObj: TgtPDStream;
  ReturnValue : TgtPDBaseObject;
begin
  FreeAndNil(ADict);
  FreeAndNil(FInFile);
  FreeAndNil(FgtInFile);

  Adict := TgtPDDictionary.Create(TgtObject(nil));   //Length 384/C 535/Filter/FlateDecode/I 557/S 227
  Adict.Add('Length', TgtPDInteger.Create(384));
  ADict.Add('C', TgtPDInteger.Create(535));
  Adict.Add('I', TgtPDInteger.Create(557));
  Adict.Add('Filter', TgtPDName.Create('FlateDecode'));
  ADict.Add('S', TgtPDInteger.Create(227));

  FInFile := TFileStream.Create('Filters\CollectionTest1.txt', fmOpenRead);
  FgtInFile := TgtFileStream.Create(FInFile, 0, 0, False);

  ASourceObj := TgtPDStream.Create(FgtInfile, ADict);

  FgtPDStream.Assign(ASourceObj);

  ReturnValue := FgtPDStream.GetDict;
  Assert.AreEqual(TgtPDDictionary(ReturnValue).GetKey(3) ,'Filter');

  Assert.IsFalse(FgtPDStream.Isof('Flate'));

  FreeAndNil(ReturnValue);
end;

procedure TestTgtPDStream.TestRead;
var
  ReturnValue, I: System.Integer;
  Buffer, Buffer1: Bytes;
begin
  SetLength(Buffer, 20);
  SetLength(Buffer1, 20);
  
  ReturnValue := FgtPDStream.Read(Buffer, 20);
  Assert.AreEqual(ReturnValue, 20);
  FgtPDStream.Reset;

  for I := 0 to 19 do
    Buffer1[I] := Byte(FgtPDStream.GetChar);

  Assert.AreEqual(String(Buffer), String(Buffer1));

  Finalize(Buffer);
  Finalize(Buffer1);

end;

procedure TestTgtPDStream.TestRead1;
var
  ReturnValue: System.Integer;
  Count: System.Integer;
  Buffer, Buffer1: string;
begin
  SetLength(Buffer, 20);

  ReturnValue := FgtPDStream.Read(Buffer, 20);

  FgtPDStream.Reset;

  Assert.AreEqual(ReturnValue, 20);
  Buffer1 := '';

  for Count := 0 to 19 do
    Buffer1 := Buffer1 + Char(FgtPDStream.GetChar);

  Assert.AreEqual(Buffer, Buffer1);

  Finalize(Buffer);
end;

procedure TestTgtPDStream.TestWrite;
var
  ReturnValue: System.Integer;
  Count: System.Integer;
  Buffer: Bytes;
  Str, Str2 : String;
begin
  try
  SetLength(Buffer, 20);
  String(Buffer) := 'Test Data 0123456789';
  FgtPDStream.Reset;
  ReturnValue := FgtPDStream.Write(Buffer, 20);
  Str := '';
  FgtPDStream.Reset;
  for Count := 0 to 19 do
  begin
    Str := Str + char(FgtPDStream.GetChar());
    Str2 := Str2 + Char(buffer[count]);
  end;

  Assert.AreEqual(Str2, Str);
  except
    on e: Exception do
      ShowMessage(e.Message);

  end;

  //Finalize(Buffer);

end;

procedure TestTgtPDStream.TestWrite1;
var
  ReturnValue, Count: System.Integer;
  Buffer, Str: string;
begin
  Buffer := 'Test Data 1234567890';
  FgtPDStream.Reset;
  ReturnValue := FgtPDStream.Write(Buffer);

  FgtPDStream.Reset;
  for Count := 0 to 19 do
    Str := Str + char(FgtPDStream.GetChar());

  Assert.AreEqual(Buffer, Str);
end;

procedure TestTgtPDStream.TestGetStream;
var
  ReturnValue: TgtStream;
begin
  ReturnValue := FgtPDStream.GetStream;

  Assert.AreEqual(ReturnValue.ClassName, 'TgtFileStream');

  // TODO: Validate method results
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTgtPDStream.Suite);
end.

