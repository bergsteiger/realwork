
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Overview of the Zeos Database Objects Architecture</title><link rel="stylesheet" href="ede.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.66.0"></head><body><div xmlns="" id="customheader"><a href="http://zeos.firmos.at/portal.php" style="color: #fff; font-weight: bold;">ZeosLib</a><b> - open source tools for your database solutions</b></div><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="d4e1"></a>Overview of the Zeos Database Objects Architecture</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Sergey</span> <span class="surname">Seroukhov</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Merlin</span> <span class="surname">Moncure</span></h3></div></div><div><p class="pubdate">26 November 2003 (Updated 29/5/2008 by Mark Daems)</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d4e28">1. General Overview</a></span></dt><dt><span class="sect1"><a href="#d4e44">2. Plain API Layer</a></span></dt><dt><span class="sect1"><a href="#d4e58">3. Database Connectivity Layer</a></span></dt><dt><span class="sect1"><a href="#d4e92">4. Component Layer</a></span></dt><dt><span class="sect1"><a href="#d4e134">5. Epilog</a></span></dt></dl></div><p>Direct access to SQL databases continues to be a vital technology even in today's enterprise environment. Thousands of two-tier client server applications are developed and maintained in the international business community. Most of them are built off of specially designed application programming interfaces (APIs) to retrieve relational data and execute SQL statements.</p><p>Currently, there is several standardized and widely used APIs to access SQL databases, such as ODBC, JDBC, and ADO. Borland also released their proprietary database middleware interface for its development tools, called the Borland Database Engine (BDE). Despite being freely distributed with Borland's popular line of application development tools, the BDE was unpopular because of complexities in installation and poor performance. As Delphi became one of the leading application development tools for the Windows platform, individuals and companies proposed alternative interfaces to the BDE. These &#8220;<span class="quote">BDE Alternatives</span>&#8221; optimized access to the database by directly using the native database driver, providing performance and feature advantages with respect to the BDE.</p><p>Realizing the limitations of the BDE, Borland proposed a new type of database interface called dbExpress. This interface was designed to broker access between Delphi and virtually any relational database through 3rd party drivers. Borland significantly improved the performance of dbExpress with respect to the BDE, but the implementation was buggy and supported only a limited subset of SQL that hampered functionality.</p><p>The Zeos Database Object component library (ZeosLib) is one of the best-known BDE alternatives. Originally the library was developed for MySQL and PostgreSQL databases, but support for other vendors was soon added. During the development process, certain limitations of the original design became more and more apparent. These limitations began to put a strain on the overall architecture and the development team decided a ground up rewrite was the best way to proceed. The new design was built to handle an extended feature list with several new requirements:

		<div class="orderedlist"><ol type="1"><li>Support for different compilers</li><li>Versioning database driver system</li><li>&#8220;<span class="quote">Database Insensitive</span>&#8221; design for cross-database development</li><li>Support for multiple high level interfaces (TDataset, dbExpress, Midas)</li><li>Extensible feature system for server specific support</li></ol></div></p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d4e28"></a>1.&nbsp;General Overview</h2></div></div></div><p>To address multiple and sometimes inconsistent requirements the development team had to completely rethink the new architecture. It is complex with respect to previous designs but not over-designed. Each module put into the new design was carefully considered and carries special unique features. In this article we'll try to present you the new architecture and explain its purpose.</p><p>From a top-down view the library is separated into three logical layers:

			<div class="orderedlist"><ol type="1"><li>Plain API Layer</li><li>Database Connectivity Layer</li><li>Component Layer</li></ol></div></p><div class="mediaobject"><img src="images/Overview001.gif"></div><p>The Plain API implements low-level functions specific to each SQL server. The Component API encapsulates the main library interface that is utilized by application developers. The DBC API is the middleware that retrieves, stores and modifies data for the high level components.</p><p>Each layer has several horizontal and/or vertical sub-layers semi-independently from each other (see picture 1). Let's go through each layer and look how all that works.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d4e44"></a>2.&nbsp;Plain API Layer</h2></div></div></div><p>ZeosDBO components do not communicate directly with SQL servers. Instead they use native client libraries provided with SQL databases. The Plain API layer provides an access to functions of native client libraries, constants and data structures (usually written in plain C) from the Object Pascal language or C++.</p><p>That functionality was the original basis for ZeosDBO. Support for multiple versions of client libraries and SQL servers was the main deficiency of earlier designs...</p><p>Native library calls (dynamic libraries in Windows and shared libraries in Unix) are represented in programming language as regular functions. For example:

<pre class="programlisting">ZPlainMySql323.pas:

function mysql_init(Handle: PMYSQL): PMYSQL; external 'libmysql.dll';</pre></p><p>Usually database APIs do not significantly change between versions. But because function calls do not allow polymorphism adding support for new versions of the Plain API is coding intensive. Hard coded approaches are inflexible and error-prone, which limit long term feasibility.

<pre class="programlisting">if Version = 'mysql-3.23' then
  ZPlainMySql323.mysql_init(...)
else ZPlainMySql40.mysql_init(...);</pre></p><p>To implement polymorphism, simplify source code, and provide insulation from changes in SQL server protocols a new extremely thin interface layer was added into ZeosDBO. That layer is called &#8220;<span class="quote">Plain Drivers</span>&#8221; and implemented as follows:

<pre class="programlisting">// Generic MySQL driver interface
IZMySQLDriver = interface ...
  function mysql_init(...)
end;

// MySQL driver for version 3.23
TZMySQL323Driver = class (TInterfacedObject, IZMySQLDriver)
  function mysql_init(...)
end;

// MySQL driver for version 4.0
TZMySQL40Driver = class (TInterfacedObject, IZMySQLDriver)
  function mysql_init(...)
end;

function TZMySQL323Driver.mysql_init(...)
begin
  Result := ZPlainMySql323.mysql_init(...);
end;

function TZMySQL40Driver.mysql_init(...)
begin
  Result := ZPlainMySql40.mysql_init(...);
end;</pre></p><p>Using such thin class wrapper allows easy addition of new client interfaces. The specific functionality that requires overriding is encapsulated in the Plain driver. The rest of the code now has a uniform method of providing native database calls, without requiring specific knowledge about the database server.

<pre class="programlisting">// Initialize plain driver
PlainDriver: IZMySqlDriver;

if Version = 'mysql-3.23' then
  PlainDriver := TZMySQL323Driver.Create()
else PlainDriver := TZMySQL40Driver.Create();

// Use plain driver
PlainDriver.mysql_init(...)</pre></p><p>With this approach it is possible to use the same API for different SQL servers, independently of version.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d4e58"></a>3.&nbsp;Database Connectivity Layer</h2></div></div></div><p>With native access provided to the database, Delphi database aware components can now expect database specific functionality in a uniform manner. However, each SQL server has different semantics that must be designed into the components to provide a universal generic interface. The main goal of the Zeos Database Objects is to provide this generic interface to the application developer.</p><p>In older versions of ZeosDBO, the intermediate interface was implemented as a class wrapper to the MySQL and PostgreSQL connection objects. These two databases have very similar capabilities so design of intermediate API was not complex. However, support for other SQL servers added new and very specific features. After several extensions to support these features the class architecture became was not clearly defined. Ultimately, the interface broke its encapsulation rules and the high level components were forced to make low level database calls.</p><p>To overcome this difficulty in the new version, the overall design was an abstract approach with an intermediate interface. Design of such an interface is not trivial. So to avoid new mistakes it was decided to avoid a proprietary design, and instead draw inspiration from a well-known database API.</p><p>As a prototype for the intermediate interface the development team chose JDBC 2.0. JDBC is one of the latest and more popular APIs in that database community. It covers various abstractions such as statements, result sets, stored procedures, blobs, and very rich metadata definitions.</p><p>JDBC API is implemented in Java through set of interfaces. Borland compilers support interfaces, so porting JDBC from Java to Object Pascal was straightforward. Data types and method names were generally preserved. Overloaded methods were avoided because of poor support in the C++ Builder family of compilers.</p><p>The main DBC interfaces are presented on picture 2.

			<div class="mediaobject"><img src="images/Overview002.gif"></div></p><p>Standard JDBC interfaces provide a uniform client API. To address functionality specific to different SQL servers, two general approaches were chosen.</p><p>1. Developers may initialize database connection object with list of string parameters. Each parameter switches server specific settings. For JDBC that method is not new.</p><p>Example: parameters can be defined in Connection URL -

<pre class="programlisting">zdbc:mysql://localhost/database?compress=true</pre>

or parameters can be passed to connection factory method

<pre class="programlisting">Params.Values['compress'] := 'true';
Connection := DriverManager.CreateConnectionWithParams(Url, Params);</pre></p><p>Additionally in ZeosDBO developers extended other DBC interfaces to initialize other object with specific parameters, particularly Statement object:

<pre class="programlisting">Params.Values['oidasblod'] := 'true';
Statement := Connection.CreateStatementWithParams(Params);</pre></p><p> 2. In Object Pascal each class is able to implement multiple interfaces simultaneously.
We used that to extend standard JDBC interfaces with new methods specific for each particular SQL server. Now each class known not only a standard interface but a server specific interface as well:

<pre class="programlisting">IZMySQLConnection = interface (IZConnection)
  function Ping(...);
  function Kill(..);
end;

TZMySQLConnection = class (TInterfacedObject, IZConnection, IZMySQLConnection);
...
end;</pre></p><p>The next step in porting JDBC to Object Pascal was an implementation of cached data access. Actually, many servers provide support for sequential data access only. Caching data on the client side is the important element to implement random data access for the retrieved result sets. On the other hand, many high-level database interfaces use even more sophisticated caching algorithms. So implementation of universal caching algorithms in one place can be a compact and efficient solution.</p><p>Cached DBC layer has only few classes:

			<div class="orderedlist"><ol type="1"><li><tt class="classname">TZRowAccessor</tt> - organize storage and access to fields of one single cached record in result set (pattern Flyweight).</li><li><tt class="classname">TZCachedResultSet</tt> - is a cached result set with random data access. It works on the top of another native non-cached result set with sequencial data access (pattern Decorator).</li><li><tt class="classname">IZCachedResolver</tt> - is an interface to handle special logic to post modified data back to SQL server (pattern Delegator).</li></ol></div></p><p>The good thing about DBC interfaces that they are so generic, that additionally to regular SQL drivers it's easy to implement special adapters to other database interfaces such as Active Data Objects (ADO) for example.</p><p>DBC interfaces are generic, so providing support for additional databases or connectivity layers such as ADO is trivial.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d4e92"></a>4.&nbsp;Component Layer</h2></div></div></div><p>The last top layer in ZeosDBO library implements dbware components. These components are used for development in Delphi, C++ Builder or Kylix. Currently Borland compilers support several standards for dbware components:

			<div class="orderedlist"><ol type="1"><li><tt class="classname">TDataset</tt> descendent components</li><li>DbExpress drivers</li><li>Data providers for multi-tier Midas technology</li></ol></div></p><p>At the time of this writing this article ZeosDBO library only supported TDataset descendent components. Implementation of other component types is scheduled for future versions.</p><p>The component class diagram is presented on picture 3:

			<div class="mediaobject"><img src="images/Overview003.gif"></div><div class="orderedlist"><ol type="1"><li><tt class="classname">TZAbstractRODataset</tt>, <tt class="classname">TZAbstractDataset</tt>, <tt class="classname">TZAbstractStoredProc</tt> - abstract classes for <tt class="classname">TDataset</tt> descendant components</li><li><tt class="classname">TZReadOnlyQuery</tt>, <tt class="classname">TZQuery</tt>, <tt class="classname">TZStoredProc</tt> - universal <tt class="classname">TDataset</tt> descendant components</li><li><tt class="classname">TZReadOnlyXXSQLQuery</tt>, <tt class="classname">TZXXSQLQuery</tt>, <tt class="classname">TZXXSQLStoredProc</tt> - <tt class="classname">TDatasets</tt> specific for each supported SQL server. The way how they are propagating server specific functions is described in the previous chapter about DBC Layer.</li><li><tt class="classname">TZSQLMonitor</tt>, <tt class="classname">TZUpdateSQL</tt>, <tt class="classname">TZSQLProcessor</tt> - generic auxiliary components</li></ol></div></p><p><tt class="classname">TDataset</tt> uses maximum the DBC layer functionality to read, modify and store data. Additionally it implements extra functions to filter, search and sort data, connect to visual components and many other things.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d4e134"></a>5.&nbsp;Epilog</h2></div></div></div><p>In this article we described the main ideas of the new architecture of Zeos Database Objects component library for native database access. This architecture was introduced in version 6.0 and demonstrated high flexibility and effectiveness. In version 6.1 the code was seriously revised and optimized, but the main principles of the architecture was not changed.</p><p>Functionality and flexibility incorporated in the architecture will meet adapt to new requirements in the future. Support for new SQL servers will be added as well as access to SQL specific functionality and support for other high level interfaces like dbExpress and Midas.</p><p>To familiarize with the library you may visit the project website at <a href="http://zeos.firmos.at" target="_top">http://zeos.firmos.at</a> or the development page on SourceForge at<a href="http://www.sourceforge.net/projects/zeoslib" target="_top">http://www.sourceforge.net/projects/zeoslib</a></p></div></div><div xmlns="" id="customfooter">
(c) 1999 - 2006 The Zeos Development Group
</div></body></html>