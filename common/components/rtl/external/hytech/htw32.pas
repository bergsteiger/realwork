(*
   DLL HyTech для Win95/NT

   HyTech 2.56  Copyright (c) 1993, 99 by SKAZ_M Ltd
*)
  Unit HTW32;

  INTERFACE

  {$A-}

(* Эти переменные носят только информационный характер, менять их нельзя *)
Const   FNAME_LEN      = 10;     (* Длина имени поля в таблице               *)
Const   TFULL_LEN      = 140;    (* Длина буфера для полного имени таблицы   *)
Const   TNAME_LEN      = 8;      (* Длина имени таблицы                      *)
Const   TPATH_LEN      = 128;    (* Длина полного пути на таблицу            *)
Const   MAX_BUF_LEN    = $FFF0;  (* Максимальная длина буфера для чтения     *)
Const   MAX_REC_LEN    = $FFED;  (* Максимальная длина записи в таблице      *)
Const   MAX_REC_NUM    = $FFFFFE;(* Максимальное число записей в таблице     *)
Const   MAX_SORT_LEN   = $FFED;  (* Максимальная длина элемента сортировки   *)
Const   MAX_SORT_ORDER = 63;     (* Максимальное число полей сортировки      *)
Const   MAX_TAB_ELEM   = 4095;   (* Максимальное число элементов в таблице   *)
Const   MAX_TAB_LINK   = 64;     (* Максимальное число связанных таблиц      *)
Const   MAX_TAB_NUM    = 96;     (* Максимальное число обрабатываемых таблиц *)
Const   CODE_LEN       = 8;      (* Максимальная длина ключа в кодификаторе  *)
Const   MAX_CODER_CNT  = 255;    (* Максимальное число кодификаторов *)

(* Возможные значения класса элементов *)
Const  EC_FIELD  = 0; (* Элемент - поле      *)
Const  EC_GROUP  = 1; (* Элемент - группа    *)
Const  EC_SUBSTR = 2; (* Элемент - подстрока *)

(* Возможные значения типов ключа для элементов *)
Const  EK_NOTKEY = 0; (* Элемент не ключ  *)
Const  EK_COMMON = 1; (* Обычный ключ     *)
Const  EK_UNIQUE = 2; (* Уникальный ключ  *)
Const  EK_SURRGT = 3; (* Суррогатный ключ *)

(* Модификаторы атрибутов ключа (допустимы только для полей) *)
Const  EK_MASK = $C0; (* Маска для отделения модификаторов ключа от типа *)
Const  EK_AUTO = $40; (* Уникальный ключ является автоинкрементным *)
Const  EK_NULL = $80; (* Поле (не только ключ) допускает NULL значения *)

(* Возможные значения типа элементов *)
Const  ET_CHAR = 0;   (* Массив символов длиной не более заданной *)
Const  ET_ARRA = 1;   (* Массив байтов заданной длины *)
Const  ET_BYTE = 2;   (* Элемент - короткое целое (1 байт) без знака *)
Const  ET_INTR = 3;   (* Элемент - целое со знаком *)
Const  ET_WORD = 4;   (* Элемент - целое без знака *)
Const  ET_DATE = 5;   (* Дата    - целое без знака *)
Const  ET_NMBR = 6;   (* Номер   - 3-х байтовое целое без знака *)
Const  ET_LONG = 7;   (* Элемент - длинное целое со знаком *)
Const  ET_DWRD = 8;   (* Элемент - длинное целое без знака *)
Const  ET_FLOA = 9;   (* Элемент - single *)
Const  ET_CURR =10;   (* Деньги  - double *)
Const  ET_DFLT =11;   (* Элемент - double *)

(*======================== Новые типы ====================*)
Type

CHANDLE  = SmallInt;           (* Обработчик кодификатора *)
RHANDLE  = LongInt;            (* Обработчик для записи   *)
LPRHANDLE=^RHANDLE;            (* Указатель на обработчик *)
THANDLE  = SmallInt;           (* Обработчик для таблицы  *)
LPTHANDLE=^THANDLE;            (* Указатель на обработчик *)
PSmallInt=^SmallInt;           (* Указатель на SmallInt   *)
NameStr  = Array[0..TNAME_LEN] of Char;(* Для хранения имени файла или станции *)
PathStr  = Array[0..TPATH_LEN] of Char;(* Для хранения пути на файлы *)

(* Блок Доступа к Сервису (БДС) *)
SAB=Record
  gFoundCnt:LongInt;               (* Число элементов в результате *)
  nRetCode :SmallInt;              (* Код завершения операции *)
  mPrivate :Array[1..110] of Char; (* Системные пеpеменные *)
End;
PSAB=^SAB;                         (* Ссылка на БДС *)
LPSAB=^SAB;                        (* Ссылка на БДС *)
LPPSAB=^LPSAB;                     (* Адрес ссылки на БДС *)

(* Описатель атрибута таблицы (поля, группы или подстроки *)
(* Эта структура заполняется функцией htTableElement *)
ELEMENT=Record
  wLength: Word;              (* Длина элемента *)
  wOffset: Word;              (* Смещение элемента в записи *)
  cClass : Byte;              (* Класс элемента *)
  cType  : Byte;              (* Тип элемента   *)
  cKey   : Byte;              (* Пpизнак ключа  *)
  mName  : Array[0..FNAME_LEN] of Char; (* Имя элемента (ASCIIZ строка) *)
End;
LPELEMENT =^ELEMENT;

(* Далее следует описание call-back процедур, адреса которых *)
(* могут быть заданы при инициализации СУБД в качестве последних *)
(* членов структуры INIT. Коды сообщений для функций описаны в HTERRS.PAS *)

(* Сообщение об ошибке при выполнении операции *)
  UFERM=Procedure(
    nMessID:SmallInt  (* Номер сообщения (код завершения) *)
  );
  LPUFERM=^UFERM;
(* Информационное сообщение об ошибке или завершении операции *)
  UFINF=Procedure(
    nInfoID: SmallInt;  (* Номер информационного сообщения *)
    gParm1:  LongInt; (* Первый числовой параметр *)
    gParm2:  LongInt; (* Второй числовой параметр *)
    fpStr:   PChar  (* Символьный параметр (ASCIIZ строка) *)
  );
  LPUFINF=^UFINF;
(* Сообщение об ошибке В/В *)
  UFIOM=Procedure(
    fpFileName: PChar;   (* Имя файла (ASCIIZ строка), вызвавшего ошибку *)
    nIoCode:    SmallInt;(* Код операции В/В, вызвавшей ошибку *)
    nDosError:  SmallInt (* Код ошибки, сообщенный DOS *)
  );
  LPUFIOM=^UFIOM;

(* Пользовательские процедуры работы с прогресс-индикатором *)
(* Будут вызываться СУБД при выполнении длительных операций *)

(* Инициализация прогресс-индикатора *)
  UFPIS=Procedure(
  nPindID: SmallInt;(* Номер сообщения прогресс-индикатора *)
  dwLimit: Cardinal;(* Предельное число элементов индикатора *)
  fpName:  PChar    (* Строковый (ASCIIZ) параметр *)
  );
  LPUFPIS=^UFPIS;
(* Продвижение прогресс-индикатора *)
  UFPID=Procedure(
  wDelta: Word      (* Очередное число обработанных элементов *)
  );
  LPUFPID=^UFPID;
(* Снятие прогресс-индикатора *)
  UFPIP=Procedure;
  LPUFPIP=^UFPIP;
(* Активизация других процессов *)
  UFYLD=Procedure;
  LPUFYLD=^UFYLD;

(* Call-back функции инициализации по умолчанию *)
(* Для вызова встроенных call-back функций следует *)
(* Задать вместо адресов Nil *)

(* Игнорирование соответствующих call-back функций инициализации *)
(* Для полного запрещения вызова call-back функций следует *)
(* задать вместо адресов Pointer(LongInt(-1)) *)

(* Описатель параметров функции инициализации *)
(* Заполняется до вызова htInit *)
  INIT=Record
    nTableCnt:SmallInt;     (* Число таблиц, с которыми будут работать (1-64) *)
    nTaskCnt:SmallInt;      (* Число файлов, которые может открыть задача *)
    nHtCnt:SmallInt;      (* Число файлов, которые может открыть СУБД *)
    nLockTimeOut:SmallInt;  (* Таймаут разделения ресурсов сети *)
    nPollDelay:SmallInt;    (* Задержка опроса сети (тиков) *)
    nTransTimeOut:SmallInt; (* Таймаут выполнения транзакций *)
    nTrsMode:SmallInt;      (* Режимы механизма транзакций *)
    fpTmpPath: PChar;       (* Каталог для создания временных файлов *)
    fpNetPath: PChar;       (* Каталог для сетевых замков *)
    fpNetName: PChar;       (* Имя станции в сети (до 8 символов) *)
    fpTrtPath: PChar;       (* Каталог журнала транзакций *)
    fpfInfo:   LPUFINF;     (* Функция информационного сообщения *)
    fpfIoMess: LPUFIOM;     (* Функция сообщения об ошибке В/В *)
    fpfErrMess:LPUFERM;     (* Функция сообщения об ошибке *)
    fpfPiStart:LPUFPIS;     (* Функция инициализации прогресс-индикатора *)
    fpfPiDraw: LPUFPID;     (* Функция продвижения прогресс-индикатора *)
    fpfPiStop: LPUFPIP;     (* Функция снятия прогресс-индикатора *)
    fpfYield:  LPUFYLD;     (* Функция активации других процессов *)
    gHeapCtrl: LongInt;     (* <0 - размер кучи пользователя (остальное - СУБД) *)
          (* =0 - обе кучи по умолчанию *)
          (* >0 - размер кучи СУБД (остальное - пользователю) *)
    gHeapTask: LongInt;     (* Куча экземпляра СУБД для внутреннего использования *)
  End;
  LPINIT = ^INIT;

(* Описатель основных характеристик открытой таблицы *)
(* Эта структура заполняется функцией htTableInfo    *)
TABLE=Record
  mPath      : PathStr;   (* Полный путь на таблицу *)
  mName      : NameStr;   (* Имя таблицы (без расширения) *)
  nFieldCnt  : SmallInt;  (* Число полей    *)
  nGroupCnt  : SmallInt;  (* Число групп    *)
  nSubstrCnt : SmallInt;  (* Число подстрок *)
  wRecordLen : Cardinal;  (* Длина записи таблицы *)
  nFlags     : Integer;   (* Флаги таблицы (см.константы TAB_????) *)
End;
LPTABLE=^TABLE;

(* Состояние открытой таблицы *)
(* Эта структура заполняется функцией htTableState() *)
STATT=Record
  gConstCnt  : LongInt;   (* Число записей в постоянной части таблицы *)
  gAddedCnt  : LongInt;   (* Число добавленных записей  *)
  gChangedCnt: LongInt;   (* Число измененных записей   *)
  gDeletedCnt: LongInt;   (* Число удаленных записей    *)
End;
LPSTATT=^STATT;

(* Константы, определяющие реакцию на ошибку *)
(* при пакетных операциях. *)
ERROR_MODE=(
  ERROR_ABORT,     (* Прервать операцию *)
  ERROR_REPEAT,    (* Повторить обработку *)
  ERROR_DELETE     (* Удалить запись *)
);

(* Прототип пользовательской функции, вызываемой при     *)
(* обнаружении ошибки в процессе обработки пачки записей *)
(* (добавление, модификация, вывод в таблицу).           *)
EFUNC=Function(
  nErrCode: SmallInt;    (* Код ошибки *)
  fpRecord: Pointer;     (* Тело "плохой" записи для анализа *)
  fpUser  : Pointer      (* Доп.параметр пользователя *)
):ERROR_MODE;
LPEFUNC=^EFUNC;

(*======================== Функции СУБД =======================*)

(*-------------------- Инициализация и завершение -------------*)

(* Первичная инициализация библиотеки API - одна на все приложения *)
  Function  htGlobalInit( hInstance: Integer ):Integer; Pascal;
(* Первичное завершение библиотеки API - одно на все приложения *)
  Procedure htGlobalShut;

(* Инициализация СУБД. Выполняется один раз в начале программы. *)
(* Эта функция должна быть вызвана ДО первого обращения к СУБД *)
  Function htInit(
      fpInit:LPINIT;  (* Параметры для функции или Nil *)
      nSize:SmallInt  (* Размер заполненной части записи *)
  ):Integer;Pascal;

(* Завершение работы СУБД             *)
(* Эта процедура вызывается последней *)
  Procedure htShut;

(*------------------ Работа с таблицами ------------------*)

(* Константы, используемые при задании режима доступа к таблице *)
Const TAB_PRIVATE =  0;    (* Таблица используется в монопольном режиме *)
Const TAB_SHARE   =  1;    (* Таблица используется в совместном режиме  *)
Const TAB_READ    =  2;    (* Таблица не допускает операций модификации *)
Const TAB_CONST   =  4;    (* Работа только с постоянной частью таблицы *)
Const TAB_FLUSH   =  8;    (* Немедленная запись данных на диск         *)
Const TAB_WRITE   = 16;    (* Спец.режим записи (не допускает поисков)  *)
Const TAB_APPEND  = 32;    (* Таблица допускает только добавление       *)
Const TAB_ANSI    = 64;    (* Таблица в ANSI-кодировке (при создании)   *)
Const TAB_CREATE  =128;    (* Безусловное создание новой таблицы        *)

(* Закрыть все открытые таблицы *)
  Procedure htCloseAllTables;

(* Сравнить обработчики таблиц *)
(* =0 - обработчика указывают на одну и ту же таблицу *)
  Function htCompareTabHandles(
      hTable1 : THANDLE;  (* Обработчик таблицы *)
      hTable2 : THANDLE   (* Другой обработчик таблицы *)
  ):SmallInt;Pascal;

(* Дублировать обработчик таблицы       *)
(* Дубли не входят в общее число таблиц *)
  Function htDupTableHandle(
      hTable     : THANDLE;  (* Исходный обработчик *)
      Var fpTable: THANDLE   (* Дубль обработчика   *)
  ):SmallInt;Pascal;

(* Удалить таблицу и связанные с ней файлы *)
(* Таблица должна быть закрыта             *)
  Function htDropTable(
      fpTableName: PChar;  (* Имя таблицы (можно без расширения) *)
      fpReadPswd : PChar;  (* Пароль для доступа на чтение *)
      fpWritePswd: PChar   (* Пароль для доступа на запись *)
  ):SmallInt;Pascal;


(* Удалить изменения, выполненные для таблицы *)
(* Таблица должна быть закрыта                *)
  Function htDropTableChanges(
      fpTableName: PChar; (* Имя таблицы (можно без расширения) *)
      fpReadPswd : PChar; (* Пароль для доступа на чтение       *)
      fpWritePswd: PChar  (* Пароль для доступа на запись       *)
  ):SmallInt;Pascal;

(* Удалить все данные таблицы (оставить один описатель) *)
(* Таблица должна быть закрыта *)
  Function htDropTableData(
      fpTableName: PChar; (* Имя таблицы (можно без расширения) *)
      fpReadPswd : PChar; (* Пароль для доступа на чтение       *)
      fpWritePswd: PChar  (* Пароль для доступа на запись       *)
  ):SmallInt;Pascal;

(* Сброс буферов В/В таблицы на диск *)
(* Полезна после операций обновления *)
  Function htFlushTable(
      hTable: THANDLE     (* Обработчик для таблицы *)
  ):SmallInt;Pascal;

(* Закрыть открытую таблицу *)
  Function htTableClose(
      hTable: THANDLE     (* Обработчик для таблицы *)
  ):SmallInt;Pascal;

(* Копировать таблицу в другую *)
(* Если таблица с заданным именем существует, она будет уничтожена *)
(* Исходная таблица должна быть закрыта *)
  Function htTableCopy(
      fpDstTable: PChar;     (* Имя таблицы-копии (можно без расширения) *)
      fpSrcTable: PChar;     (* Имя исходной таблицы (можно без расширения) *)
      fpSrcRdPswd:PChar;     (* Пароль для доступа на чтение *)
      nSrcOpenMode: SmallInt (* Режим открытия исходной таблицы *)
  ):SmallInt;Pascal;

(* Создать новую таблицу и получить к ней доступ *)
  Function htTableCreate(
      fpTableName: PChar;      (* Имя таблицы (можно без расширения) *)
      fpElems     : LPELEMENT; (* Описатели элементов таблицы        *)
      nElemCnt    : SmallInt;  (* Число описателей элементов         *)
      fpCryptoKey : PChar;     (* Ключ для крипто-закрытия данных    *)
      fpReadPswd  : PChar;     (* Пароль для доступа на чтение       *)
      fpWritePswd : PChar;     (* Пароль для доступа на запись       *)
      nOpenMode   : SmallInt;  (* Режим открытия (константы TAB_????)*)
      Var fpHandle: THANDLE    (* Для приема обработчика таблицы     *)
  ):SmallInt;Pascal;

(* Добавление агрегатов (групп и/или подстрок) в таблицу *)
(* Таблица должна быть закрыта *)
  Function htTableAgregateAppend(
  fpTableName: PChar;    (* Имя таблицы (можно без расширения) *)
  fpReadPswd:  PChar;    (* Пароль для доступа на чтение *)
  fpWritePswd: PChar;    (* Пароль для доступа на запись *)
  fpAgres:     LPELEMENT;(* Массив структур описаний агрегатов *)
  nAgreCnt:    SmallInt  (* Число элементов *)
  ):SmallInt;Pascal;

(* Удаление агрегатов (групп и/или подстрок) из таблицы *)
(* Таблица должна быть закрыта *)
  Function htTableAgregateDelete(
  fpTableName: PChar;    (* Имя таблицы (можно без расширения) *)
  fpReadPswd:  PChar;    (* Пароль для доступа на чтение *)
  fpWritePswd: PChar;    (* Пароль для доступа на запись *)
  nPos:      SmallInt; (* Номер первого агрегата из группы *)
  nDelCnt:     SmallInt  (* Число удалемых элементов *)
  ):SmallInt;Pascal;

(* Модификация агрегатов (групп и/или подстрок) в таблице *)
(* Таблица должна быть закрыта *)
  Function htTableAgregateModify(
  fpTableName: PChar;    (* Имя таблицы (можно без расширения) *)
  fpReadPswd:  PChar;    (* Пароль для доступа на чтение *)
  fpWritePswd: PChar;    (* Пароль для доступа на запись *)
  fpAgres:     LPELEMENT;(* Массив структур описаний агрегатов *)
  nAgreCnt:    SmallInt; (* Число элементов *)
  nFirstNo:    SmallInt  (* Номер первого агрегата из группы *)
  ):SmallInt;Pascal;

(* Получить описание элемента открытой таблицы.             *)
(* Первый элемент таблицы имеет номер 1, второй - 2 и т.п.  *)
(* Характеристики элемента берутся из системных переменных. *)
(* Имя элемента считывается из файла описания таблицы, если *)
(* задан флаг чтения, иначе поле имени ничего не содержит.  *)
  Function htTableElement(
     hTable   : THANDLE;   (* Обработчик для таблицы                *)
     nElemNo  : SmallInt;  (* Номер элемента таблицы (от 1)         *)
     Var sElem: ELEMENT;   (* Структура для описания элемента       *)
     bReadName: Boolean    (* Для true читать имя элемента из файла *)
  ):SmallInt;Pascal;

(* Получить описание всех элементов открытой таблицы.      *)
(* Первый элемент таблицы имеет номер 1, второй - 2 и т.п. *)
(* Необходимо выделить массив структур длиной по числу     *)
(* элементов таблицы. Число можно узнать из htTableInfo    *)
  Function htTableElementList(
      hTable   : THANDLE;   (* Обработчик для таблицы             *)
      fpElement: LPELEMENT  (* Массив структур описаний элементов *)
  ):SmallInt;Pascal;

(* Определить обработчик для открытой таблицы по имени *)
  Function htTableHandleByName(
      fpTabName    : PChar;   (* Имя таблицы (можно без расширения) *)
      Var fpHandle : THANDLE  (* Для приема обработчика таблицы     *)
  ):SmallInt;Pascal;

(* Получить параметры открытой таблицы *)
  Function htTableInfo(
      hTable    : THANDLE;   (* Обработчик для таблицы         *)
      Var sTable: TABLE      (* Структура для описания таблицы *)
  ):SmallInt;Pascal;

(* Получить состояние открытой таблицы *)
  Function htTableState(
      hTable    : THANDLE;   (* Обработчик для таблицы         *)
      Var sStat : STATT      (* Структура для описания таблицы *)
  ):SmallInt;Pascal;

(* Открыть доступ к таблице    *)
(* Таблица должна быть закрыта *)
  Function htTableOpen(
      fpTableName : PChar;    (* Имя таблицы (можно без расширения)  *)
      fpReadPswd  : PChar;    (* Пароль доступа на чтение            *)
      fpWritePswd : PChar;    (* Пароль доступа на запись            *)
      nOpenMode   : SmallInt; (* Режим открытия (константы TAB_????) *)
      Var fpHandle: THANDLE   (* Для приема обработчика таблицы      *)
  ):SmallInt;Pascal;

(* Переименовать таблицу                              *)
(* Таблица должна быть закрыта                        *)
(* Переименование возможно лишь в пределах устройства *)
  Function htTableRename(
      fpTableName: PChar;   (* Имя таблицы (можно без расширения)          *)
      fpReadPswd : PChar;   (* Пароль доступа на чтение                    *)
      fpWritePswd: PChar;   (* Пароль доступа на запись                    *)
      fpNewName  : PChar    (* Новое имя таблицы (можно в другом каталоге) *)
  ):SmallInt;Pascal;

(* Режимы проверки таблицы *)
  Const  HTVF_INDEX = 1;      (* Проверка целостности индексов ключей *)
  Const  HTVF_DUPS  = 2;      (* Анализ дублей для уникальных ключей  *)
(* Проверить таблицу *)
(* Таблица должна быть закрыта *)
  Function htTableVerify(
      fpTableName: PChar;   (* Имя таблицы (можно без расширения) *)
      fpReadPswd : PChar;   (* Пароль доступа на чтение           *)
      fpWritePswd: PChar;   (* Пароль доступа на запись           *)
      nMode      : SmallInt (* Режим проверки (HTVF_????)         *)
  ):SmallInt;Pascal;

(* Восстановить таблицу адресов постоянной части *)
(* Таблица должна быть закрыта                   *)
  Function htRepairTable(
      fpTableName: PChar;   (* Имя таблицы (можно без расширения)          *)
      fpReadPswd : PChar;   (* Пароль доступа на чтение                    *)
      fpWritePswd: PChar    (* Пароль доступа на запись                    *)
  ):LongInt;Pascal;

(* Восстановить журнал изменений таблицы *)
(* Таблица должна быть закрыта           *)
  Function htRepairTableLog(
      fpTableName: PChar;   (* Имя таблицы (можно без расширения) *)
      fpReadPswd : PChar;   (* Пароль доступа на чтение           *)
      fpWritePswd: PChar;   (* Пароль доступа на запись           *)
      gItemCnt   : LongInt  (* Число элементов к восстановлению   *)
          (*   <0 - число элементов из HDN      *)
          (*   =0 - по умолчанию                *)
          (*   >0 - число элементов из HDR      *)
  ):SmallInt;Pascal;

(* Перенести изменения в постоянную часть таблицы *)
(* Таблица должна быть закрыта                    *)
  Function htUpdateTable(
      fpTableName: PChar;   (* Имя таблицы (можно без расширения)  *)
      fpReadPswd : PChar;   (* Пароль доступа на чтение            *)
      fpWritePswd: PChar;   (* Пароль доступа на запись            *)
      bReIndex   : Boolean; (* Для true перепостроение индексов    *)
      bTestSpace : Boolean  (* Для true проверка места на диске    *)
  ):SmallInt;Pascal;

(*------------- Работа с индексами таблицы ------------*)

(* Построение индексов для ключевых элементов *)
(* Таблица должна быть закрыта                *)
(* Возвращает число отвергнутых записей или код ошибки *)
  Function htBuildIndexes(
      fpTableName: PChar;    (* Имя таблицы (можно без расширения)  *)
      fpReadPswd : PChar;    (* Пароль доступа на чтение            *)
      fpWritePswd: PChar;    (* Пароль доступа на запись            *)
      bTestSpace : Boolean;  (* Проверка пространства на диске      *)
      bDenyOut   : Boolean   (* Для true вывод отвергнутых записей в таблицу *)
  ):LongInt;Pascal;

(* Сменить тип ключа для элемента таблицы *)
(* Таблица должна быть закрыта            *)
(* Возвращает число отвергнутых записей или код ошибки *)
  Function htChangeKeyType(
      fpTableName: PChar;    (* Имя таблицы (можно без расширения)           *)
      fpReadPswd : PChar;    (* Пароль доступа на чтение                     *)
      fpWritePswd: PChar;    (* Пароль доступа на запись                     *)
      nElemNo    : SmallInt; (* Номер элемента таблицы (от 1)                *)
      nNewKeyType: SmallInt; (* Новый тип ключа                              *)
      bTestSpace : Boolean;  (* Проверка пространства на диске               *)
      bDenyOut   : Boolean   (* Для true вывод отвергнутых записей в таблицу *)
  ):LongInt;Pascal;

(* Удаление индексов           *)
(* Таблица должна быть закрыта *)
  Function htDropIndexes(
      fpTableName: PChar;  (* Имя таблицы (можно без расширения)  *)
      fpReadPswd : PChar;  (* Пароль доступа на чтение            *)
      fpWritePswd: PChar   (* Пароль доступа на запись            *)
  ):SmallInt;Pascal;

(*------------- Операции модификации таблицы -------------*)

(* Добавление записи в таблицу                    *)
(* Возвращает физический номер добавленной записи *)
  Function htRecordAdd(
      hTable  : THANDLE;    (* Обработчик для таблицы *)
      fpRecord: Pointer     (* Тело записи            *)
  ):LongInt;Pascal;

(* Удаление записи из таблицы *)
  Function htRecordDelete(
      hTable    : THANDLE;  (* Обработчик для таблицы            *)
      gRecordNo : LongInt   (* Физический номер удаляемой записи *)
  ):SmallInt;Pascal;

(* Модификация записи в таблице *)
  Function htRecordModify(
      hTable    : THANDLE;  (* Обработчик для таблицы                 *)
      gRecordNo : LongInt;  (* Физический номер модифицируемой записи *)
      fpRecord  : Pointer   (* Тело записи                            *)
  ):SmallInt;Pascal;

(*----------- Пакетные операции модификации ------------*)

(* Константы, определяющие порядок вызова пользовательской    *)
(* функции подготовки данных. При последнем вызове подготовка *)
(* данных не выполняется, это сигнал к завершению обработки   *)
Type ADD_MODE=(
  ADD_FIRST,         (* Первый вызов (сигнал к инициализации) *)
  ADD_NEXT,          (* Очередной вызов *)
  ADD_LAST           (* Последний вызов (завершение обработки) *)
);

(* Описатель автоинекрементного ключа *)
(* для доступа к данным в сборке значений *)
AUTO=Record
    nType:   SmallInt;    (* Тип данных *)
    nLength: SmallInt;    (* Длина ключа *)
    nKeyNum: SmallInt;    (* Номер ключа (от 1) *)
    wOffset: Cardinal;    (* Смещение в сборке значений *)
    acResrvd: Array[1..12] of Byte;
End;
Type LPAUTO=^AUTO;

(* Описатель, используемый при добавлении пачки записей *)
(* Эта структура передается как параметр при вызове     *)
(* пользовательской функции из функции htAddRecords     *)
Type APARM=Record
  fpBuf     : Pointer;      (* Буфер для записей *)
  wBufLen   : Cardinal;     (* Длина буфера *)
  wRecordLen: Cardinal;     (* Длина записи *)
(* Следующие члены заполняются для первой записи пачки *)
  gFirstRecNum: LongInt;    (* Номер для первой записи пачки *)
  dFirstSurrogate:Cardinal; (* Значение суррогатного ключа для первой записи *)
  nAutoCnt: SmallInt;       (* Число автоинкрементных ключей *)
  fpAuto: LPAUTO;     (* Описатели автоинкрементных ключей *)
  pFirstAuto: Pointer;      (* Сборка значений автоинкрементных ключей *)
End;
LPAPARM = ^APARM;

(* Прототип пользовательской функции, вызываемой для *)
(* подготовки очередной пачки добавляемых записей.   *)
(* Функция должна заполнить предоставленный буфер    *)
(* добавляемыми записями. Длина буфера задана.       *)
(* Функция должна возвращать:                        *)
(*   длину заполненной части буфера (в байтах);      *)
(*   0 при необходимости прервать процесс обработки. *)
Type AFUNC=Function(
  nOrder: ADD_MODE;  (* Порядок вызова *)
  fpParm: LPAPARM;   (* Параметры пачки записей *)
  fpUser: Pointer    (* Доп.параметр пользователя *)
):Cardinal;
LPAFUNC = ^AFUNC;

(* Добавление группы записей в таблицу *)
(* Возвращает число отвергнутых записей или код ошибки *)
  Function htAddRecords(
      hTable    : THANDLE;  (* Обработчик для таблицы                     *)
      gAppendLim: LongInt;  (* Максимальное число записей для добавления  *)
      fpfAddProc: LPAFUNC;  (* Пользовательская функция подготовки данных *)
      fpfErrProc: LPEFUNC;  (* Пользовательская функция обработки ошибок  *)
          (* Nil - ошибки отменяют операцию *)
      fpUser    : Pointer;  (* Доп.параметр пользователя *)
      bDenyOut  : Boolean   (* True - вывод отвергнутых записей в таблицу *)
  ):LongInt;Pascal;

(* Добавление пачки записей в постоянную часть таблицы *)
(* Возвращает число отвергнутых записей или код ошибки *)
    Function htLoadRecords(
      fpTableName: PChar;   (* Имя таблицы *)
      fpReadPswd : PChar;   (* Пароль доступа на чтение *)
      fpWritePswd: PChar;   (* Пароль доступа на запись *)
      gLoadLim   : LongInt; (* Максимальное число записей для добавления  *)
      fpfAddProc : LPAFUNC; (* Пользовательская функция подготовки данных *)
      fpfErrProc : LPEFUNC; (* Пользовательская функция обработки ошибок  *)
          (* Nil - ошибки отменяют операцию *)
      fpUser     : Pointer; (* Доп.параметр пользователя *)
      bDenyOut   : Boolean  (* Для true вывод отвергнутых записей в таблицу *)
    ):LongInt;Pascal;

(* Удаление подмножества записей из таблицы *)
  Function htDeleteRecords(
      Var fpSrc: SAB    (* Адрес БДС, содержащего подмножество записей *)
  ):LongInt;Pascal;

(* Прототип пользовательской функции, вызываемой для каждой *)
(* записи. Функция должна выполнить требуемые действия по   *)
(* модификации записи. Функция возвращает значения:         *)
(*  false - прервать процесс модификации                    *)
(*  true  - запись модифицирована                           *)
Type MFUNC=Function(
  gRecNo  : LongInt;     (* Номер модифицируемой записи *)
  fpRecord: Pointer;     (* Тело модифицируемой записи *)
  fpUser  : Pointer      (* Доп.параметр пользователя *)
):Boolean;
LPMFUNC = ^MFUNC;

(* Модификация подмножества записей из таблицы *)
(* Возвращает число отвергнутых записей или код ошибки *)
  Function htModifyRecords(
      Var fpSrc : SAB;      (* Адрес БДС, содержащего подмножество записей *)
      fpfMdfProc: LPMFUNC;  (* Функция модификации записей                 *)
      fpfErrProc: LPEFUNC;  (* Пользовательская функция обработки ошибок   *)
          (* Nil - ошибки отменяют операцию *)
      fpUser    : Pointer;  (* Доп.параметр пользователя *)
      bDenyOut  : Boolean   (* Для true вывод отвергнутых записей в таблицу *)
  ):LongInt;Pascal;

(* Безусловное добавление группы записей в таблицу *)
(* Добавляются либо все заданные записи, либо ничего *)
(* Появление проблемных записей приводит к отказу от операции *)
  Function htPureAddRecords(
      hTable    : THANDLE;  (* Обработчик для таблицы                     *)
      gAppendLim: LongInt;  (* Максимальное число записей для добавления  *)
      fpfAddProc: LPAFUNC;  (* Пользовательская функция подготовки данных *)
      fpUser    : Pointer   (* Доп.параметр пользователя *)
  ):SmallInt;Pascal;

(* Безусловная модификация подмножества записей из таблицы *)
(* Модифицируются либо все заданные записи, либо ничего *)
(* Появление проблемных записей приводит к отказу от операции *)
  Function htPureModifyRecords(
      Var fpSrc : SAB;      (* Адрес БДС, содержащего подмножество записей *)
      fpfMdfProc: LPMFUNC;  (* Функция модификации записей                 *)
      fpUser    : Pointer   (* Доп.параметр пользователя *)
  ):SmallInt;Pascal;

(*============== Поисковые операции в таблице ===============*)

(*----------------------- Атомарный поиск ------------------------*)
(* Элементы таблицы (поля, группы и подстроки) имеют сквозную     *)
(* нумерацию от 1. Номер 0 отведен для доступа по физическому     *)
(* номеру записи (значение задается как LongInt).                 *)

(* Прототип пользовательской функции, вызываемой для каждого       *)
(* значения искомого элемента записи. Функция возвращает значения: *)
(*  1 - элемент подходит *)
(*  0 - элемент не подходит *)
Type CFUNC=Function(
  fpItem: Pointer;   (* Тело проверяемого элемента записи *)
  fpUser: Pointer    (* Доп.параметр пользователя *)
):Boolean;
LPCFUNC = ^CFUNC;

(* Константы, определяющие условие поиска по одному элементу записи *)
(* (2) - требуется два пороговых значения                           *)
Type CONDITION=(
  EMPTY_COND,   (* Такого условия нет - незначащий код *)
  BETWEEN,      (* (2) Значения элемента лежат в диапазоне (исключающее)  *)
  EQUAL,        (* Значения элемента равны заданному                      *)
  GREAT,        (* Значения элемента больше заданного                     *)
  GREAT_EQUAL,  (* Значения элемента больше или равны заданному           *)
  IN_RANGE,     (* (2) Значения элемента лежат в диапазоне (включающее)   *)
  LESS,         (* Значения элемента меньше заданного                     *)
  LESS_EQUAL,   (* Значения элемента меньше или равны заданному           *)
  NOT_BETWEEN,  (* (2) Значения элемента лежат вне диапазона (включающее) *)
  NOT_EQUAL,    (* Значения элемента не равны заданному                   *)
  NOT_GREAT,    (*  Значения элемента не больше заданного                 *)
  NOT_IN_RANGE, (* (2) Значения элемента лежат вне диапазона (исключающее)*)
  NOT_LESS,     (* Значения элемента не меньше заданного                  *)
  WILDCARD,     (* Значения символьного элемента совпадают с шаблоном     *)
  WILDCASE,     (* Значения элемента совпадают с шаблоном без учета регистра *)
  USER_DEF      (* Значения элемента удовлетворяют критерию пользователя *)
);

(* Поиск по условию для элемента таблицы (поля, группы, подстроки) *)
(* Поиск производится в заданном временном снимке таблицы *)
  Function htSearch(
      fpPhoto   : LPSAB;    (* БДС "снимка" (Nil - если первый запрос) *)
      Var fpSave: SAB;      (* БДС для сохранения результата *)
      hTable    : THANDLE;  (* Обработчик для таблицы *)
      nElemNum  : SmallInt;  (* Номер элемента таблицы         *)
          (* (0-физ.номер, 1-первый и т.п.) *)
      nCond     : CONDITION;(* Условие, см. константы условий *)
      fpValue1  : Pointer;  (* Пеpвое пороговое значение или функция *)
      fpValue2  : Pointer   (* Второе пороговое значение или параметр функции *)
          (* Nil, если не нужно    *)
  ):LPSAB;Pascal;

(* Поиск по условию для элемента таблицы (поля, группы, подстроки) *)
(* Поиск производится в заданном множествев записей таблицы *)
  Function htSubSearch(
      Var fpSet : SAB;      (* БДС множества записей *)
      Var fpSave: SAB;      (* БДС для сохранения результата *)
      hTable    : THANDLE;  (* Обработчик для таблицы *)
      nElemNum  : SmallInt;  (* Номер элемента таблицы         *)
          (* (0-физ.номер, 1-первый и т.п.) *)
      nCond     : CONDITION;(* Условие, см. константы условий *)
      fpValue1  : Pointer;  (* Пеpвое пороговое значение или функция *)
      fpValue2  : Pointer   (* Второе пороговое значение или параметр функции *)
          (* Nil, если не нужно    *)
  ):LPSAB;Pascal;


(*---------------- Сложные поиски записей ---------------*)

(* Получить записи по списку значений элемента *)
(* Отбираются записи, для которых элемент принимает значения из списка *)
  Function htRecordsByKey(
      Var fpDst : SAB;    (* Для приема результата *)
      Var fpList: SAB     (* Адрес БДС, содержащего список значений *)
  ):LPSAB;Pascal;

(* Найти запись по значению уникального ключа *)
(* Возвращает физ.номер записи с заданным значением ключа *)
(* 0 нет таких записей, <0 - код ошибки *)
  Function htRecordByUniq(
  fpPHO:     LPSAB; (* БДС "снимка" *)
  hTable:    THANDLE; (* Обработчик таблицы *)
  nKeyNo:    SmallInt;  (* Номер ключа (0-физ.номер, 1-первое поле и т.д.) *)
  fpValue:   Pointer; (* Искомоме значение уникального ключа *)
  fphRecord: LPRHANDLE  (* Для обработчика записи *)
  ):LongInt;Pascal;

(* Получить записи для заданного соотношения значений двух элементов *)
(* Отбираются записи, для которых значения элемента nElemNo1 и  *)
(* nElemNo2 удовлетворяют заданному соотношению на подмножестве *)
(* записей fpSrc.  *)
  Function htRecordsForTwoKeys(
      Var fpDst: SAB;       (* Для приема результата *)
      Var fpSrc: SAB;       (* Адрес БДС, содержащего список записей таблицы *)
      nElemNo1 : SmallInt;   (* Номер первого элемента записи *)
      nCond    : CONDITION; (* Условие сравнения (пока только EQUAL) *)
      nElemNo2 : SmallInt    (* Номер второго элемента записи *)
  ):LPSAB;Pascal;

(* Определить подмножество записей таблицы, попавших в результат сортировки *)
  Function htSortedRecords(
      Var fpDst : SAB;    (* Блок для приема результата *)
      Var fpSort: SAB     (* Результат сортировки       *)
  ):LPSAB;Pascal;

(* Определить подмножество записей таблицы, попавших в результат сортировки, *)
(* для заданного снимка *)
  Function htSortedRecordsEx(
      Var fpDst : SAB;    (* Блок для приема результата *)
      Var fpSort: SAB;    (* Результат сортировки       *)
      Var fpPhoto:SAB     (* Снимок для множества       *)
  ):LPSAB;Pascal;


(*------------ Операции над значениями элемента записи -------------*)

(* Импликация (деление) столбцов таблицы *)
  Function htDivision(
      Var fpDst: SAB;     (* Для приема результата *)
      Var fpSET: SAB;     (* Подмножество записей *)
      nElemNo  : SmallInt;(* Номер поля делимого *)
      Var fpLST: SAB      (* Список значений делителя *)
  ):LPSAB;Pascal;

(* Получить гистограмму значений элемента для подмножества записей *)
  Function htHistogramOfKey(
      Var fpDst: SAB;     (* Для приема результата *)
      nElemNo  : SmallInt;(* Номер элемента записи *)
      Var fpSrc: SAB      (* Подмножество записей *)
  ):SmallInt;Pascal;

(* Получить гистограмму значений элемента с заданным числом повторов *)
  Function htHistogramByCount(
      Var  fpDst: SAB;     (* Для приема результата *)
      nElemNo   : SmallInt;(* Номер элемента записи *)
      Var fpSrc : SAB;     (* Подмножество записей  *)
      gMin      : LongInt; (* Минимальное число повторов (не менее 1) *)
      gMax      : LongInt  (* Максимальное число повтоpов             *)
  ):SmallInt;Pascal;


(* Перенести список значений элемента в другую таблицу *)
(* Может быть использована для смены номера элемента *)
  Function htTransferToTable(
      Var fpSrc: SAB;     (* Адpес БДС, содержащего список значений *)
      hTable   : THANDLE; (* Обработчик для другой таблицы          *)
      nElemNo  : SmallInt (* Номер элемента в другой таблице        *)
  ):LPSAB;Pascal;

(* Перенести список значений элемента в заданный "снимок" другой таблицы *)
  Function htTransferToPhoto(
      Var fpSrc  : SAB;    (* Адpес БДС, содержащего список значений *)
      Var fpPhoto: SAB;    (* Адрес БДС, содержащего снимок другой таблицы *)
      nElemNo    : SmallInt (* Номер элемента в другой таблице              *)
  ):LPSAB;Pascal;

(* Получить список значений элемента для подмножества записей *)
  Function htValuesOfKey(
      Var fpDst: SAB;     (* Для приема результата *)
      nElemNo  : SmallInt;(* Номер элемента записи *)
      Var fpSrc: SAB      (* Подмножество записей *)
  ):LPSAB;Pascal;

(* Получить список значений элемента с заданным числом повторов *)
  Function htValuesByCount(
      Var  fpDst: SAB;     (* Для приема результата *)
      nElemNo   : SmallInt;(* Номер элемента записи *)
      Var fpSrc : SAB;     (* Подмножество записей *)
      gMin      : LongInt; (* Минимальное число повторов (не менее 1) *)
      gMax      : LongInt  (* Максимальное число повтоpов             *)
  ):LPSAB;Pascal;


(*----------------- Обработка значений элемента -------------------*)

(* Получить среднее значение элемента для подмножества записей *)
  Function htAverageOfKeyValues(
      Var fpSrc: SAB;     (* Адрес БДС, содержащего подмножество записей *)
      nElemNo  : SmallInt; (* Номер элемента записи *)
      fpAverage: Pointer  (* Сюда поместят среднее значение *)
       (* LongInt для - целочисленных, Double - для действительных *)
  ):SmallInt;Pascal;

(* Получить максимальное значение элемента для подмножества записей *)
  Function htKeyMaximum(
      Var fpSrc: SAB;     (* Адрес БДС, содержащего подмножество записей *)
      nElemNo  : SmallInt; (* Номер элемента записи *)
      fpMax    : Pointer  (* Сюда поместят максимальное значение *)
  ):SmallInt;Pascal;

(* Получить минимальное значение элемента для подмножества записей *)
  Function htKeyMinimum(
     Var fpSrc: SAB;     (* Адрес БДС, содержащего подмножество записей *)
     nElemNo  : SmallInt; (* Номер элемента записи *)
      fpMin   : Pointer  (* Сюда поместят минимальное значение *)
  ):SmallInt;Pascal;

(* Получить сумму значений элемента для подмножества записей *)
  Function htSumOfKeyValues(
      Var fpSrc: SAB;     (* Адрес БДС, содержащего подмножество записей *)
      nElemNo  : SmallInt; (* Номер элемента записи *)
      fpSum    : Pointer  (* Сюда поместят сумму значений элемента *)
     (* LongInt для - целочисленных, Double - для действительных *)
  ):SmallInt;Pascal;

(*--------- Логические операции над результатами поиска ---------*)

(* Уточнение результата условием *)
  Function htAndResults(
      Var fpDst : SAB;    (* Блок для приема результата *)
      Var fpSrc1: SAB;    (* Блок с первым результатом  *)
      Var fpSrc2: SAB     (* Блок со вторым результатом *)
  ):LPSAB;Pascal;

(* Расширение результата условием *)
  Function htOrResults(
     Var fpDst : SAB;    (* Блок для приема результата *)
     Var fpSrc1: SAB;    (* Блок с первым результатом  *)
     Var fpSrc2: SAB     (* Блок со вторым результатом *)
  ):LPSAB;Pascal;

(* Отрицание результата *)
  Function htNotResults(
     Var fpDst: SAB;    (* Блок для приема результата    *)
     Var fpSrc: SAB     (* Блок с отрицаемым результатом *)
  ):LPSAB;Pascal;

(* Исключение результата *)
  Function htXorResults(
     Var fpDst : SAB;    (* Блок для приема результата    *)
     Var fpSrc1: SAB;    (* Блок с первым операндом       *)
     Var fpSrc2: SAB     (* Блок со вторым операндом      *)
  ):LPSAB;Pascal;

(*---------------- Операции над группами  -----------------*)
(* В результате выполнения операции образуется массив элементов. *)
(* Каждый элемент содержит значения полей, входящих в группу, за *)
(* которыми следуют значения функционалов для заданных полей.    *)

(* Константы, определяющие функции для полей, вычисляемых *)
(* для каждого экземпляра сгруппированных полей.          *)
(* Длина функционала указана в скобках                    *)
Const GROUP_AVERAGE =0; (* Среднее значение (LongInt/Double)       *)
Const GROUP_COUNT   =1; (* Подсчет числа значений (всегда LongInt) *)
Const GROUP_MAX     =2; (* Максимальное значение (по типу поля)    *)
Const GROUP_MIN     =3; (* Минимальное значение (по типу поля)     *)
Const GROUP_SUM     =4; (* Сумма значений (LongInt/Double)         *)
Const GROUP_DISTINCT=5; (* Подсчет числа уникальных значений (всегда LongInt) *)
Const GROUP_FIRST   =6; (* Первое значение (по типу поля)    *)
Const GROUP_LAST    =7; (* Последнее значение (по типу поля) *)

(* Прототип пользовательской функции-фильтра   *)
(* для реализации HAVING_TO групповой операции *)
(* Возвращает:                                 *)
(*     true  - элемент подходит                *)
(*     false - элемент не подходит             *)
Type HAVING = Function(
  fpGroupBody: Pointer; (* Тело группы и функционалов *)
  fpUser     : Pointer (* Доп.параметр пользователя  *)
):Boolean;
LPHAVING = ^HAVING;

(* Описатель поля для групповой операции               *)
(* Используется при вызове функции htGroupByHavingTo   *)
Type GROUP=Record
  nField : SmallInt;              (* Номер поля                *)
  nType  : SmallInt;              (* Тип функции для поля GROUP_??? *)
  mSystem: Array [1..36] of Char; (* Будет использоваться СУБД *)
End;
LPGROUP = ^GROUP;

(* Отработка групповой операции на подмножестве записей таблицы *)
(* На каждое сформированное значение группы вызывается функция  *)
(* fpfHavingTo, которая может выполнить обработку значения и    *)
(* примет решению о выводе данного элемента группы. *)
  Function htGroupByHavingTo(
      Var fpDst  : SAB;      (* Блок для приема результата              *)
      Var fpSrc  : SAB;      (* БДС, задающий подмножество записей      *)
      fpnGroup   : PSmallInt;(* Номера полей, образующих группу         *)
      nGroupCnt  : SmallInt; (* Число таких полей (до MAX_SORT_ORDER+1) *)
      fpsFunc    : LPGROUP;  (* Описатели вычислимых выражений          *)
      nFuncCnt   : SmallInt; (* Их число                                *)
      fpfHavingTo: LPHAVING; (* Функция, реализующая условие HavingTo   *)
      fpUser     : Pointer   (* Доп.параметр пользователя *)
  ):SmallInt;Pascal;

(* Прототип пользовательской функции, вызываемой для сравнения *)
(* пары элементов. Функция возвращает значения:                *)
(*  <0 - первый элемент меньше второго *)
(*  =0 - элементы равны                *)
(*  >0 - первый элемент больше второго *)
Type OFUNC=Function(
  fpFirst : Pointer;     (* Адрес первого элемента *)
  fpSecond: Pointer;     (* Адрес второго элемента *)
  fpUser  : Pointer      (* Доп.параметр пользователя *)
):SmallInt;
LPOFUNC = ^OFUNC;

(* Отработка групповой операции на подмножестве записей таблицы *)
(* контролируемая пользователем *)
    Function htGroupByUser(
      Var fpDst  : SAB;      (* Блок для приема результата              *)
      Var fpSrc  : SAB;      (* БДС, задающий подмножество записей      *)
      fpnGroup   : PSmallInt;(* Номера полей, образующих группу         *)
      nGroupCnt  : SmallInt; (* Число таких полей (до MAX_SORT_ORDER+1) *)
      fpsFunc    : LPGROUP;  (* Описатели вычислимых выражений          *)
      nFuncCnt   : SmallInt; (* Их число                                *)
      fpfSort  : LPOFUNC;  (* Функция сравнения для сортировки        *)
      fpfDiff  : LPOFUNC;  (* Функция сравнения для группировки       *)
      fpfHavingTo: LPHAVING; (* Функция, реализующая условие HavingTo   *)
      fpUser     : Pointer   (* Доп.параметр пользователя *)
    ):SmallInt;Pascal;

(* Построение списка значений ключа по результатам группировки *)
(* Доступ к исходным результатам должен быть закрыт *)
  Function htValuesFromGroup(
      Var fpDst  : SAB;      (* Блок для приема списка значений ключа    *)
      nKeyNo     : SmallInt; (* Номер поля, значения которого собираются *)
      wOffset    : Word;     (* Смещение начала поля в группе            *)
      Var fpSrc  : SAB       (* БДС, задающий результаты группировки     *)
  ):LPSAB;Pascal;

(*---------------- Межтабличные операции  -----------------*)

(* Константы, определяющие режимы обработки неполных пар или групп таблиц *)
Const DRAFT_ZERO = 0;  (* Сбор несопадающих групп запрещен *)
Const DRAFT_LEFT = 1;  (* Сбор несопадающих групп из левого операнда *)
Const DRAFT_RIGHT= 2;  (* Сбор несопадающих групп из правого операнда *)
Const DRAFT_ALL  = 3;  (* Сбор несопадающих групп обеих операндов *)

(* Слияние двух таблиц через общий элемент *)
  Function htTablesJoin(
      Var fpDst : SAB;       (* Блок для приема результата               *)
      Var fpFRST: SAB;       (* Условие для первой таблицы               *)
      nFiElNo   : SmallInt;  (* Номер элемента-связки в первой таблице   *)
      nCond     : CONDITION; (* Тип слияния (пока только EQUAL)          *)
      Var fpSCND: SAB;       (* Условие для второй таблицы               *)
      nScElNo   : SmallInt;  (* Номер элемента-связки во второй таблице  *)
      fpCOND    : LPSAB;     (* Если не Nil, выполняется отбор  записей, *)
           (* попавших в JOIN, для одной из таблиц     *)
      bFirst    : Boolean;   (* Если true, то отбор записей из первой    *)
           (* таблицы                                  *)
      nMode     : SmallInt   (* Режим отобра неполных пар *)
  ):LPSAB;Pascal;

Const LINK_AUTO = 0;  (* Автоматическое определение типа связи *)
Const LINK_MULY = 4;  (* Всегда "декартовое" произведение *)
(* Объединение/слияние нескольких связанных таблиц *)
  Function htTablesLink(
      Var fpDst: SAB;    (* Блок для приема результата         *)
      Var fpGroup: SAB;  (* Группа связанных таблиц            *)
      Var fpPair: SAB;   (* Пара связанных таблиц              *)
      bSkipLink: Boolean;(* Для true выходная группа будет без *)
       (* таблицы-связки                     *)
      nMode: SmallInt     (* Режим работы (DRAFT_??? Or LINK_???*)
  ):LPSAB;Pascal;


(* Определить подмножество записей таблицы, попавших в слияние *)
  Function htJoinedRecords(
      fpStart    : LPSAB;  (* "Снимок" таблицы для подмножества *)
      Var fpDst  : SAB;    (* Блок для приема результата        *)
      Var fpGroup: SAB;    (* Группа связанных таблиц           *)
      nTabNo     : SmallInt (* Номер таблицы группе таблиц (отсчет от 0) *)
  ):LPSAB;Pascal;

(* Определить число таблиц в выходной группе таблиц и *)
(* порядок их расположения. Возвращает число таблиц и *)
(* заполняет массив обработчиками таблиц в порядке их *)
(* расположения в выходной группе. Размер массива для *)
(* приема обработчиков подсхе должен быть не менее    *)
(* константы MAX_TAB_LINK                             *)
(* Если обработчики не нужны, можно задать Nil        *)
  Function htTellJoinOrder(
      Var fpSrc: SAB;       (* Результат связи                 *)
      fpHandles: LPTHANDLE  (* Сюда занесут обработчики таблиц *)
  ):SmallInt;Pascal;

(* Определить характеристики элемента одной из таблиц,  *)
(* входящих в группу слияния. Смещение элемента будет   *)
(* определено от начала обобщенной записи, т.е. записи, *)
(* состоящей из записей всех таблиц группы.             *)
  Function htJoinElement(
      Var fpSrc: SAB;       (* Результат связи                       *)
      nTableNo : SmallInt;   (* Номер таблицы в группе таблиц (от 1)  *)
      nElemNo  : SmallInt;   (* Номер элемента в таблице (от 0, включая физ.номер) *)
      fpElement: LPELEMENT; (* Структура для описания элемента       *)
      bReadName: Boolean    (* Для true читать имя элемента из файла *)
  ):SmallInt;Pascal;

(*----------------------- Кластеры ----------------------*/

(* Создать кластерную таблицу для связки таблиц *)
  Function htCreateClusterTable(
      Var fpLink:  SAB;       (* БДС со связкой таблиц *)
      fpTableName: PChar;     (* Имя таблицы кластеров *)
      fpCryptoKey: PChar;     (* Ключ для крипто-закрытия данных *)
      fpReadPswd : PChar;     (* Пароль для доступа на чтение *)
      fpWritePswd: PChar;     (* Пароль для доступа на запись *)
      bIndex:    Boolean    (* True - индексировать таблицу кластеров *)
  ):SmallInt;Pascal;

(* Преобразовать запись кластерной таблицы в результат связи таблиц *)
  Function htClusterItemToLink(
      Var fpDst: SAB;     (* Для приема результата *)
      hTable:  THANDLE;     (* Таблица кластеров *)
      hRecord: RHANDLE;     (* Запись таблицы кластеров *)
      fpHandles: LPTHANDLE  (* Обработчики связываемых таблиц *)
  ):LPSAB;Pascal;

(* Преобразовать записи кластерной таблицы в результат связи таблиц *)
  Function htClusterRecsToLink(
      Var fpDst: SAB;     (* Для приема результата *)
      Var fpSrc: SAB;     (* Записи таблицы кластеров *)
      fpHandles: LPTHANDLE  (* Обработчики связываемых таблиц *)
  ):LPSAB;Pascal;

(*----------------------- Фильтры ----------------------*)

(* Прототип пользовательской функции, вызываемой   *)
(* при фильтрации подмножества записей.            *)
(* Функция должна возвращать:                      *)
(*  1 - запись удовлетовряет условию фильтрации    *)
(*  0 - запись не удовлетворяет условию фильтрации *)
(* -1 - прекратить фильтрацию на текущем элементе  *)
Type SFUNC = Function(
   gRecNo : LongInt;  (* Номер анализируемой записи или элемента *)
   fpField: Pointer;  (* Значения отобранных полей для анализа *)
   fpUser : Pointer   (* Доп.параметр пользователя *)
): SmallInt;
LPSFUNC = ^SFUNC;

(* Фильтрация списка записей пользователем *)
(* Можно заказать выборку некоторых полей записи *)
  Function htFilterRecords(
      Var fpDst: SAB;      (* Для приема результата *)
      Var fpSrc: SAB;      (* Адрес БДС, содержащего список записей *)
      fpFieldNo: PSmallInt;(* Номера полей, подлежащих выборке из записи *)
         (* Nil - все поля записи *)
      nFieldCnt: SmallInt; (* Число выбираемых полей *)
      fpfFilter: LPSFUNC;  (* Адрес пользовательской функции фильтрации *)
      fpUser   : Pointer   (* Доп.параметр пользователя *)
  ):LPSAB;Pascal;

(* Описатель связи пары таблиц *)
Type LINK=Record
    nFiTab :SmallInt; (* Индекс первой таблицы в группе (от 0) *)
    nFiKey :SmallInt; (* Номер элемента-связки в первой таблице *)
    nScTab :SmallInt; (* Индекс второй таблицы в группе (от 0) *)
    nScKey :SmallInt; (* Номер элемента-связки во второй таблице *)
  End;
LPLINK = ^LINK;

(* Режимы выполнения операции *)
Const FLT_AUTO = 0; (* Автоматическое определение типа связки *)
Const FLT_MULT = 1; (* Всегда "декартовое" произведение таблиц *)
Const FLT_DRAFT= 2; (* Допустимо "черновое" связывание таблиц *)
(* Фильтрация записей группы связаных таблиц *)
  Function htFilterTables(
      Var fpDst: SAB;      (* Для приема результата *)
      fppSABs:   LPPSAB;   (* Группа таблиц и подмножества записей в них *)
      nTableCnt: SmallInt; (* Число таблиц (БДС'ов) *)
      fpFieldNo: PSmallInt;(* Номера полей таблиц для анализа *)
      nFieldCnt: SmallInt; (* Число выбираемых полей *)
      fpLinks:   LPLINK;   (* Описатели связей таблиц *)
      nLinkCnt:  SmallInt; (* Число связей *)
      fpfFilter: LPSFUNC;  (* Адрес пользовательской функции фильтрации *)
      fpUser   : Pointer;  (* Доп.параметр пользователя *)
      nMode    : SmallInt  (* Режимы связывания таблиц *)
  ):LPSAB;Pascal;

(*------------ Работа с результатами поиска ------------*)

(* Удалить результаты поиска для БДС {HTCOD2] *)
  Procedure htClearResults( Var fpSrc: SAB );Pascal;

(* Закрыть доступ к результатам поиска в БДС *)
  Procedure htCloseResults( Var fpSrc: SAB );Pascal;

(* Скопировать результаты поиска                    *)
(* Доступ к исходным результатам должен быть закрыт *)
  Function htCopyResults(
      Var fpDst: SAB;      (* Адрес БДС для приема копии *)
      Var fpSrc: SAB       (* Адрес исходного БДС        *)
  ):SmallInt;Pascal;

(* Уникализовать результаты поиска по заданным полям *)
(* Доступ к исходным результатам должен быть закрыт  *)
  Function htDistinctResults(
      Var fpDst: SAB;      (* Для приема уникализованных результатов *)
      Var fpSrc: SAB;      (* Неуникализованные результаты поиска    *)
      fpFieldNo: PSmallInt;(* Список полей - критериев уникализации  *)
			   (* Nil - по всей записи в совокупности    *)
      nFieldCnt: SmallInt  (* Число полей-критериев                  *)
  ):SmallInt;Pascal;

(* Уникализовать результаты поиска по счетчику повторов *)
(* Оставляет те результаты, число повторов которых по   *)
(* заданному критерию попадает в определенный диапазон  *)
(* Доступ к исходным результатам должен быть закрыт *)
  Function htDistinctResultsByCount(
      Var fpDst: SAB;      (* Для приема уникализованных результатов *)
      Var fpSrc: SAB;      (* Неуникализованные результаты поиска    *)
      fpFieldNo: PSmallInt;(* Список полей - критериев уникализации  *)
			   (* Nil - по всей записи в совокупности    *)
      nFieldCnt: SmallInt; (* Число полей-критериев                  *)
      gMin:	 LongInt;  (* Минимальное число повторов *)
      gMax:	 LongInt   (* Максимальное число повторов *)
  ):SmallInt;Pascal;

(* Константы, определяющие режим открытия       *)
(* доступа к результатам поиска htOpenResults   *)
(* Могут комбинироваться операцией OR           *)
Const ROPEN_READ = 0;    (* Чтение результатов *)
Const ROPEN_BODY = 2;    (* Чтение тела записи (без номера) *)
Const ROPEN_HNDL = 4;    (* Чтение обработчика вместо физ.номера *)

(* Открыть доступ к результатам поиска в БДС *)
  Function htOpenResults(
      Var fpSrc: SAB;      (* Адрес исходного БДС                       *)
      (* Следующие параметры имеют смысл только для результатов-записей *)
      nMode   : SmallInt;  (* Режим открытия (см.ROPEN_????)            *)
      fpElemNo: PSmallInt; (* Номера читаемых элементов записи          *)
         (* Если Nil - выводятся все элементы записи  *)
      nElemCnt: SmallInt   (* Число выводимых элементов                 *)
  ):SmallInt;Pascal;

(* Читать результаты поиска из БДС                      *)
(* Возвращает число считанных байтов.                   *)
(* Размер читаемого блока не более MAX_BUF_LEN байтов.  *)
(* Коды возврата от MAX_BUF_LEN до $FFFF - коды ошибок *)
  Function htReadResults(
      Var fpSrc: SAB;        (* Адрес исходного БДС     *)
      fpBuff   : Pointer;    (* Буфер для чтения данных *)
      wLen     : Cardinal    (* Длина буфера            *)
  ):Word;Pascal;

(* Определить длину одного элемента результата *)
(* Доступ к результатам должен быть открыт     *)
  Function htResultsItemLen(
      Var fpSrc   : SAB;     (* Адрес исходного БДС *)
      Var wItemLen: Cardinal (* Длина элемента      *)
  ):SmallInt;Pascal;

(* Определить число полей отбора в открытом результате *)
  Function htResultsItemCnt(
  Var fpSAB: SAB    (* Адрес открытого БДС *)
  ): SmallInt;Pascal;

(* Описатель поля отбора в открытом результате *)
 Type OPEL=record
  nType:  SmallInt; (* Тип поля *)
  nNum:   SmallInt; (* Номер поля *)
  wLen:   Cardinal; (* Длина поля *)
  wOff:   Cardinal; (* Место вывода среди других полей *)
  hCoder: CHANDLE;  (* Кодификатор поля *)
 End;
 LPOPEL=^OPEL;

(* Получить описатели полей отбора в открытом результате *)
  Function htResultsItemParm(
  Var fpSAB: SAB;   (* Адрес открытого БДС *)
  fpParm: LPOPEL          (* Для приема параметров *)
  ): SmallInt;Pascal;

(* Константы, определяющие режим перемещения логического *)
(* указателя по результатам поиска htSeekResults         *)
Type RSEEK_MODE=(
  RSEEK_SET,     (* От начала                                    *)
  RSEEK_CUR,     (* От текущей позиции                           *)
  RSEEK_END,     (* От конца                                     *)
  RSEEK_REC      (* Установиться на запись, заданную физ.номеpом *)
);

(* Перемещение логического указателя по результатам поиска *)
  Function htSeekResults(
      Var fpSrc : SAB;        (* Адрес исходного БДС  *)
      gOffset   : LongInt;    (* Величина перемещения *)
      nFromWhere: RSEEK_MODE  (* Режим перемещения    *)
  ):LongInt;Pascal;

(* Получить порядковый номер записи по ее физическому номеру. *)
(* Отсчет от 0. Доступ к результатам должен быть открыт. *)
(* Имеет смысл для результатов типа RES_RCRD *)
  Function htRecordOrdinalNumber(
      Var fpSrc : SAB;        (* Адрес исходного БДС *)
      gNumber   : LongInt     (* Физический номер *)
  ):LongInt;Pascal;

(* Описатель маркера записи в открытом результате *)
Type MARKER=Record
  hTable: THANDLE;  (* Таблица, которой принадлежит запись *)
  hRecord:RHANDLE;  (* Обработчик помеченной записи *)
End;
LPMARK=^MARKER;

(* Установить маркер на текущую запись открытого результата поиска *)
  Function htMarkRecord(
  Var fpSrc   : SAB;   (* Адрес открытого для чтения БДС *)
  Var fpMark  : MARKER     (* Маркер записи *)
  ):SmallInt;Pascal;

(* Установить маркер на текущую запись одной из таблиц слияния *)
  Function htMarkJoinedRecord(
  Var fpSrc   : SAB;   (* Адрес открытого для чтения БДС *)
  nTabNo      : SmallInt;  (* Номер таблицы группе таблиц (отсчет от 0) *)
  Var fpMark  : MARKER     (* Маркер записи *)
  ):SmallInt;Pascal;

(* Установить маркер на текущую запись слияния таблиц *)
  Function htMarkJoinedRecordEx(
  Var fpSrc   : SAB;   (* Адрес открытого для чтения БДС *)
  fpMark   : LPMARK    (* Массив маркеров (по числу таблиц) *)
  ):SmallInt;Pascal;

(* Перемещение логического указателя на установленный ранее маркер *)
  Function htSeekMarkedJoin(
  Var fpSrc   : SAB;   (* Адрес открытого для чтения БДС *)
  nTabNo      : SmallInt;  (* Номер таблицы группе таблиц (отсчет от 0) *)
  Var fpMark  : MARKER     (* Маркер записи *)
  ):SmallInt;Pascal;

(* Перемещение логического указателя на маркированную связку *)
  Function htSeekMarkedJoinEx(
  Var fpSrc   : SAB;   (* Адрес открытого для чтения БДС *)
  fpMark   : LPMARK    (* Массив маркеров (по числу таблиц) *)
  ):SmallInt;Pascal;

(* Перемещение логического указателя на установленный ранее маркер *)
  Function htSeekMarkedRecord(
  Var fpSrc   : SAB;   (* Адрес открытого для чтения БДС *)
  Var fpMark  : MARKER     (* Маркер записи *)
  ):SmallInt;Pascal;

(* Сортировка результатов поиска (если это записи)       *)
(* Положительный номер ключа - сортировка по возрастанию *)
(* Отрицательный номер ключа - сортировка по убыванию    *)
  Function htSortResults(
      Var fpDst: SAB;        (* Для приема результата        *)
      Var fpSrc: SAB;        (* Адрес исходного БДС          *)
      mOrder   : PSmallInt;  (* Номера ключей упорядочивания *)
      nOrderCnt: SmallInt    (* Число ключей упорядочивания  *)
  ):SmallInt;Pascal;

(* Сортировка результатов поиска под контролем пользователя *)
   Function htSortResultsByUser(
      Var fpDst: SAB;        (* Для приема результата        *)
      Var fpSrc: SAB;        (* Адрес исходного БДС          *)
      mOrder   : PSmallInt;  (* Номера ключей упорядочивания *)
      nOrderCnt: SmallInt;   (* Число ключей упорядочивания  *)
      fpfComp  : LPOFUNC;    (* Функция сравнения элементов  *)
      fpUser   : Pointer     (* Параметр пользователя для функции *)
   ):SmallInt;Pascal;

(* Проверить адекватность результатов поиска.        *)
(* Имеет смысл для всех результатов, кроме RES_JOIN. *)
  Function htIsResultObsolete(
      Var fpSrc   : SAB     (* Результаты поиска  *)
  ):LPSAB;Pascal;

(* "Сравнять" результаты поиска (записи), привести  *)
(* их в соответствие с заданным состоянием таблицы. *)
(* Доступ к исходным результатам должен быть закрыт *)
  Function htSyncResults(
      Var fpFresh : SAB;    (* Блок для приема "свежего" результата *)
      Var fpPhoto : SAB;    (* Блок с заданным снимком *)
      Var fpOld   : SAB     (* Блок со старым результатом  *)
  ):LPSAB;Pascal;

(* "Освежить" результаты поиска (записи), привести  *)
(* их в соответствие с текущим состоянием таблицы.  *)
(* Доступ к исходным результатам должен быть закрыт *)
  Function htTouchResults(
      Var fpFresh : SAB;    (* Блок для приема "свежего" результата *)
      Var fpOld   : SAB     (* Блок со старым результатом  *)
  ):LPSAB;Pascal;

(* Константы, определяющие тип результатов, хранимых в БДС *)
(* Возвращаются функцией htResultsType                     *)
Const RES_NPROC   = -1;  (* БДС не обработан, или результаты удалены    *)
Const RES_RECORD   = 0;  (* БДС содержит список записей                 *)
Const RES_VALUE    = 1;  (* БДС содержит список значений ключа          *)
Const RES_HISTO    = 2;  (* БДС содержит гистограмму                    *)
Const RES_JOIN     = 3;  (* БДС содержит результат слияния таблиц       *)
Const RES_SORTED   = 4;  (* БДС содержит отсортированный список записей *)
Const RES_GROUP    = 5;  (* БДС содержит результаты операции GROUP_BY   *)
Const RES_SORTJOIN = 6;  (* БДС содержит сортированное слияние таблиц   *)

(* Определить номер элемента, для которого получен результат в БДС *)
(* Имеет смысл для результатов типа RES_VALUE и RES_HISTO.         *)
  Function htResultsElement(
      Var fpSrc   : SAB;     (* Адрес исходного БДС  *)
      Var fpElemNo: SmallInt  (* Номер элемента *)
  ):SmallInt;Pascal;

(* Определить таблицу, для которой получен результат в БДС *)
(* Имеет смысл для всех результатов, кроме RES_JOIN.       *)
  Function htResultsTable(
      Var fpSrc   : SAB;    (* Адрес исходного БДС                    *)
      Var fpHandle: THANDLE (* Таблица, для которой получен результат *)
  ):SmallInt;Pascal;

(* Определить тип результата для БДС     *)
(* Возвращает одну из констант RES_????? *)
  Function htResultsType( Var fpSrc: SAB ):SmallInt;Pascal;

(* Освободить память из-под результата   *)
(* Переносит результаты из памяти в файл *)
  Function htResultsToHard( Var fpSrc: SAB ):SmallInt;Pascal;

(* Проверить, открыт ли доступ к результатам поиска *)
(* 0 - нет, !=0 - да *)
  Function htIsResultOpen( Var fpSrc: SAB ):Boolean;Pascal;

(* Подменить обработчик таблицы в результатах на дубль *)
(* Результаты должны быть закрыты *)
  Function htReplaceResultsTable(
      Var fpSrc : SAB;     (* Адрес исходного БДС       *)
      hTable    : THANDLE; (* Другой обработчик таблицы *)
      nTabNo    : SmallInt (* Порядковый номер таблицы для JOIN (от 0) *)
  ):SmallInt;Pascal;


(*---------- Работа с отдельными записями ----------*)

(* Определить обработчик записи по физ.номеру и снимку *)
(* Если снимок пуст (Nil), берется последнее состояние таблицы *)
  Function htHandleFromRecNo(
  fpPHO: LPSAB;   (* Снимок для записи *)
  hTable: THANDLE;  (* Обработчик таблицы *)
  gRecNo:LongInt;   (* Номер записи *)
  Var fphHandle:RHANDLE (* Для приема обработчика *)
  ):SmallInt;Pascal;

(* Определить номер записи по обработчику *)
  Function htRecNoFromHandle(
  hTable: THANDLE;  (* Обработчик таблицы *)
  hHandle: RHANDLE  (* Обработчик записи *)
  ):LongInt;Pascal;

(* Добавление записи в таблицу. Аналогична htRecordAdd, *)
(* но возвращает также обработчик добавленной записи. *)
  Function htHandleAdd(
  hTable: THANDLE;  (* Обработчик для таблицы *)
  fpRecord: Pointer;  (* Тело записи *)
  Var fphRecord: RHANDLE  (* Обработчик добавленной записи *)
  ):LongInt;Pascal;

(* Модификация записи в таблице. Аналогична htRecordModify, *)
(* но возвращает также обработчик модифицированной записи. *)
  Function htHandleModify(
  hTable: THANDLE;  (* Дескриптор таблицы *)
  gRecNumber: LongInt;  (* Номер модифицируемой записи *)
  fpRecord: Pointer;  (* Тело записи *)
  Var fphRecord: RHANDLE  (* Обработчик измененной записи *)
  ):SmallInt;Pascal;

(* Считать тело записи по ее номеру в пределах "снимка" *)
(* Если снимка нет (Nill), читает последнее состояние записи *)
  Function htReadRecord(
  fpPHO: LPSAB;   (* Снимок для записи *)
  hTable: THANDLE;  (* Дескриптор таблицы *)
  gRecNo: LongInt;  (* Номер читаемой записи *)
  fpBody: Pointer   (* Для приема тела записи *)
  ):SmallInt;Pascal;

(* Считать запись по ее обработчику *)
(* Проверки корректности обработчика не производится *)
  Function htReadRecordByHandle(
  hTable: THANDLE;  (* Обработчик таблицы *)
  hHandle: RHANDLE; (* Обработчик читаемой записи *)
  fpRecord: Pointer (* Для приема тела записи C НОМЕРОМ *)
  ):SmallInt;Pascal;

(*---------- Редактирование результатов поиска ----------*)

(* Создать пустой результат для таблицы *)
  Function htCreateEmptySAB(
  fpPHO: LPSAB;   (* Снимок таблицы *)
  Var fpSAB: SAB;   (* Адрес БДС *)
  hTable: THANDLE;  (* Обработчик таблицы *)
  nItemNo: SmallInt;  (* Номер элемента *)
  nType: SmallInt   (* Тип БДС (см.RES_????) *)
  ):LPSAB;Pascal;

(* Создать пустой результат для связки таблиц *)
  Function htCreateEmptyJoin(
  Var fpSAB: SAB;   (* БДС *)
  fphTabs: LPTHANDLE; (* Обработчики таблиц *)
  nTabCnt: SmallInt (* Число таблиц *)
  ):LPSAB;Pascal;

(* Исключить элемент из результатов поиска *)
(* Доступ к исходным результатам должен быть открыт *)
  Function htExcludeResultsItem(
  Var fpSrc: SAB;   (* Адрес исходного БДС *)
  gItemNo: LongInt  (* Порядковый номер элемента (от 0) *)
        (* RES_RECORD - физ.номер записи *)
  ):SmallInt;Pascal;

(* Считать элемент результата поиска - обработчик записи(ей) *)
(* Доступ к исходным результатам должен быть открыт *)
(* Допустим для результатов RES_SORTED и RES_JOIN *)
  Function htGetResultsItem(
  Var fpSrc: SAB;   (* Адрес исходного БДС *)
  gItemNo: LongInt; (* Порядковый номер элемента (от 0) *)
  fpItem: LPRHANDLE       (* Для чтения элемента результата *)
  (* Длина элемента определяется типом результата: *)
  (* RES_SORTED - sizeof(RHANDLE) *)
  (* RES_JOIN - sizeof(RHANDLE) * число_таблиц_слияния *)
  ):SmallInt;Pascal;

(* Добавить пачку элементов в результаты поиска *)
(* Доступ к исходным результатам должен быть открыт *)
  Function htIncludeResultsBlock(
  Var fpSrc: SAB;         (* Адрес исходного БДС *)
  gInsPos: LongInt;       (* Позиция вставки элемента (отсчет от 0) *)
                          (* RES_RECORD - не имеет смысла *)
  fpBlock: Pointer;       (* Пачка новых элементов результата *)
  wBlockLen: Cardinal     (* Длина пачки в байтах *)
  ):SmallInt;Pascal;


(* Добавить элемент в результаты поиска *)
(* Доступ к исходным результатам должен быть открыт *)
  Function htIncludeResultsItem(
  Var fpSrc: SAB;   (* Адрес исходного БДС *)
  gItemNo: LongInt; (* Позиция вставки элемента (отсчет от 0) *)
        (* RES_RECORD - физ.номер записи *)
  fpNewItem: Pointer  (* Новый элемент результата: *)
    (* RES_SORTED - обработчик записи *)
    (* RES_JOIN - группа обработчиков записей для таблиц слияния *)
    (* RES_VALUE, RES_HISTO, RES_GROUP - тело элемента *)
  ):SmallInt;Pascal;

(* Заменить элемент в результатах поиска *)
(* Доступ к исходным результатам должен быть открыт *)
  Function htReplaceResultsItem(
  Var fpSrc: SAB;   (* Адрес исходного БДС *)
  gItemNo: LongInt; (* Позиция элемента (отсчет от 0) *)
  fpNewItem: Pointer  (* Новый элемент результата: *)
    (* RES_SORTED - обработчик записи *)
    (* RES_JOIN - группа обработчиков записей для таблиц слияния *)
    (* RES_VALUE, RES_HISTO, RES_GROUP - тело элемента *)
  ):SmallInt;Pascal;

(*---------- Вывод результатов поиска в таблицу ----------*)
(* Описатель, используемый при обработке записей        *)
(* Эта структура передается как параметр при вызове     *)
(* пользовательской функции из функции htResultsToTable *)
Type RPARM=Record
  gDstRecNum : LongInt; (* Номер текущей образуемой записи   *)
  gSrcItemNum: LongInt; (* Номер текущего исходного элемента *)
  wDstRecLen : Cardinal;(* Длина образуемой записи  *)
  wSrcItemLen: Cardinal;(* Длина исходного элемента *)
  fpSrcItem  : Pointer; (* Тело исходного элемента  *)
  fpDstRec   : Pointer; (* Буфер для приема образуемой записи *)
End;

(* Прототип пользовательской функции, вызываемой   *)
(* при обработке результатов для каждой записи.    *)
(* Функция должна возвращать:     *)
(* >0 - преобразование выполнено  *)
(* =0 - прекратить процесс вывода *)
(* <0 - пропустить данную запись  *)
Type RFUNC=Function(
  Var fpParm: RPARM;  (* Параметры вывода *)
  fpUser    : Pointer (* Доп.параметр пользователя *)
):SmallInt;
LPRFUNC=^RFUNC;

(* Преобразование результатов в таблицу                                 *)
(* Выполняется чтение результатов и запись их в таблицу hOutTable.      *)
(* На каждый элемент результата выполняется вызов fpfRecProc(), которая *)
(* может произвести необходимую доработку элемента результата по прев-  *)
(* ращению его в запись таблицы hOutTable. Каждая запись этой таблицы   *)
(* проверяется на допустимость значений. В случае ошибки вызывается     *)
(* функция fpfErrProc. Для результатов-записей (RES_RECORD, RES_SORTED, *)
(* RES_JOIN) могут быть заданы номера полей, которые будут отбираться   *)
(* для формирования выходной записи.                                    *)
(* Возвращает число отвергнутых записей или код ошибки *)
  Function htResultsToTable(
      Var fpSrc : SAB;      (* Адрес исходного БДС                       *)
      hOutTable : THANDLE;  (* Обработчик для заполняемой таблицы        *)
      fpfRecProc: LPRFUNC;  (* Пользовательская функция обработки записи *)
          (* Nil - обработка не нужна (все готово)     *)
      fpfErrProc: LPEFUNC;  (* Пользовательская функция обработки ошибок *)
          (* Nil - ошибки прерывают ввод               *)
      fpUser    : Pointer;  (* Доп.параметр пользователя                 *)
      (* Следующие имеют смысл для результатов - записей *)
      fpElemNo  : PSmallInt;(* Номера выводимых элементов исх.записи     *)
      nElemCnt  : SmallInt; (* Число выводимых элементов                 *)
      bDenyOut  : Boolean;  (* Для true вывод отвергнутых записей в таблицу  *)
      bCorrect  : Boolean   (* Для true коррекция суррогатного и авто-ключей *)
  ):LongInt;Pascal;

(*------------------- Управление доступом ------------------*)

(* Сменить крипто-ключ закрытия данных *)
(* Таблица должна быть закрыта         *)
  Function htChangeCryptoKey(
      fpTableName: PChar;   (* Имя таблицы (можно без расширения) *)
      fpReadPswd : PChar;   (* Пароль доступа на чтение           *)
      fpWritePswd: PChar;   (* Пароль доступа на запись           *)
      fpOldCrypto: PChar;   (* Старый крипто-ключ закрытия данных *)
      fpNewCrypto: PChar;   (* Новый крипто-ключ закрытия данных  *)
      bReIndex   : Boolean  (* Перепостроить индексы *)
  ):SmallInt;Pascal;

(* Сменить пароль доступа на чтение *)
(* Таблица должна быть закрыта      *)
  Function htChangeReadPassword(
      fpTableName  : PChar; (* Имя таблицы (можно без расширения) *)
      fpWritePswd  : PChar; (* Пароль доступа на запись           *)
      fpOldReadPswd: PChar; (* Старый пароль доступа на чтение    *)
      fpNewReadPswd: PChar  (* Новый пароль доступа на чтение     *)
  ):SmallInt;Pascal;

(* Сменить пароль доступа на запись *)
(* Таблица должна быть закрыта      *)
  Function htChangeWritePassword(
      fpTableName   : PChar;  (* Имя таблицы (можно без расширения) *)
      fpReadPswd    : PChar;  (* Пароль доступа на чтение           *)
      fpOldWritePswd: PChar;  (* Старый пароль доступа на запись    *)
      fpNewWritePswd: PChar   (* Новый пароль доступа на запись     *)
  ):SmallInt;Pascal;

(*-------------------- Сетевая поддержка -------------------*)

(* Определить свободные от захвата записи и захватить их *)
  Function htHoldFreeRecords(
      hTable   : THANDLE;  (* Обработчик таблицы                           *)
      Var fdDst: SAB       (* Блок для списка свободных от захвата записей *)
  ):LPSAB;Pascal;

(* Захватить запись таблицы *)
  Function htHoldRecord(
      hTable: THANDLE;   (* Обработчик таблицы         *)
      gRecNo: LongInt    (* Номер захватываемой записи *)
  ):SmallInt;Pascal;

(* Захватить запись таблицы и считать ее тело *)
  Function htHoldReadRecord(
      hTable  : THANDLE; (* Обработчик таблицы         *)
      gRecNo  : LongInt; (* Номер захватываемой записи *)
      fpRecord: Pointer  (* Для приема тела записи *)
  ):SmallInt;Pascal;

(* Захватить результаты поиска - множество записей *)
  Function htHoldResults( Var fpSrc: SAB ):SmallInt;Pascal;

(* Захватить таблицу целиком *)
  Function htHoldTable( hTable: THANDLE ):SmallInt;Pascal;

(* Освободить захваченную запись таблицы *)
  Function htReleaseRecord(
      hTable: THANDLE;   (* Обработчик таблицы         *)
      gRecNo: LongInt    (* Номер захватываемой записи *)
  ):SmallInt;Pascal;

(* Освободить захваченные результаты поиска - множество записей *)
  Function htReleaseResults( Var fpSrc: SAB ):SmallInt;Pascal;

(* Освободить захваченную таблицу *)
  Function htReleaseTable( hTable: THANDLE ):SmallInt;Pascal;

(* Установить таймаут для сетевых операций *)
  Procedure htSetLockTimeOut(
      Second:Word             (* Величина таймаута в секундах *)
  );Pascal;

(*------------------- Поддержка транзакций -----------------*)

(* Флаги задания режимов системы транзакций *)
(* Устанавливаются в переменной HTCOD1.htTrsMode *)
(* Могут комбинироваться операцией OR *)
Const  TRS_OFF   =0;  (* Выключить систему транзакций *)
Const  TRS_ON    =1;  (* Включить систему транзакций *)
Const  TRS_PREP  =2;  (* Предварительное распределение ресурсов *)
Const  TRS_FLUSH =4;  (* Немедленная запись журнала транзакции на диск *)
Const  TRS_ALONE =8;  (* Транзакции на одной локальной машине *)
Const  TRS_EASY  =1;  (* "Облегченный" режим работы системы транзакций *)
Const  TRS_HARD  =7;  (* "Полный" режим работы системы транзакций *)

(* Описатель идентифкатора транзакции *)
(* Эта запись используется функциями управления транзакциями *)
Type TRID=Record
  mTrID: Array [1..6] of Byte;  (* Идентификатор транзакции *)
End;

(* Установить таймаут для транзакций *)
  Procedure htSetTransTimeOut(
      Second:Word             (* Величина таймаута в секундах *)
  );Pascal;

(* Начать транзакцию на группе таблиц *)
  Function htStartTransaction(
      fpTables:   LPTHANDLE;  (* Список обработчиков таблиц *)
      nTabCnt :   SmallInt;   (* Число таблиц в списке *)
      Var fpTrans:TRID        (* Для приема идентификатора транзакции *)
  ):SmallInt;Pascal;

(* Успешное завершение транзакции *)
  Function htCommitTransaction(
      Var fpTrans:TRID        (* Идентификатор транзакции *)
  ):SmallInt;Pascal;

(* Аварийное завершение транзакции *)
  Function htRollBackTransaction(
      Var fpTrans:TRID        (* Идентификатор транзакции *)
  ):SmallInt;Pascal;

(* Проверить необходимость отката транзакции для таблицы *)
(* Можно вызывать после получения ошибки HT_ERR_TRT_ROLLED *)
(* при поиске таблиц, вызвавших эту ошибку и их транзакции *)
  Function htIsNeedToRoll(
      hTable     : THANDLE;   (* Обработчик таблицы *)
      Var fpTrans:TRID        (* Идентификатор транзакции *)
  ):SmallInt;Pascal;

(* Проверить принадлежность таблицы какой-либо транзакции *)
  Function htIsTransactionalTable(
      hTable     : THANDLE    (* Обработчик таблицы *)
  ):SmallInt;Pascal;

(*--------------------- Кодификаторы ----------------------*)
(* Кодификатор - упорядоченные пары {ключ:толкование}.     *)
(* Используются для расширенного толкования значений ключа *)
(* при операциях чтения результатов.                       *)
(* Длина толкования ключа не может быть короче ключа.      *)
(* Перед использованием кодификатор должен быть загружен   *)
(* в память.   *)

(* Описатель поля чтения *)
(* Используется при открытии доступа к кодированным записям *)
(* для указания отбираемых полей и порядка их расположения. *)
Type CDF=Record
  nFieldNum :SmallInt;     (* Номер поля *)
  hCoder    :CHANDLE;    (* Кодификатор для поля (0 - нет кодификатора) *)
End;
Type LPCDF=^CDF;           (* Длинная ссылка на описатель *)

(* Информация о кодификаторе *)
Type CODINF=Record
  wItemCnt :Cardinal; (* Число элементов в кодификаторе *)
  nItemLen :SmallInt; (* Длина элемента в кодификаторе *)
  nKeyType :SmallInt; (* Тип ключа кодификатора *)
  nKeyLen  :SmallInt; (* Длина ключа кодификатора *)
  nNameLen :SmallInt; (* Длина толкования *)
  pArray   :Pointer;    (* Массив ключ-толкование *)
End;

(* Получить информацию о кодификаторе *)
  Function htCoderInfo(
      hCoder    : CHANDLE;      (* Обработчик кодификатора *)
      Var fpInfo: CODINF        (* Структура для заполнения *)
  ):SmallInt;Pascal;

(* Найти ключ для заданного толкования *)
  Function htFindCoderKey(
      hCoder : CHANDLE;      (* Обработчик кодификатора *)
      fpKey  : Pointer;      (* Для приема значения ключа *)
      fpValue: Pointer       (* Тестируемое значение толкования *)
  ):SmallInt;Pascal;

(* Найти для заданного ключа его толкование *)
  Function htFindCoderValue(
      hCoder : CHANDLE;      (* Обработчик кодификатора *)
      fpKey  : Pointer;      (* Тестируемое значение ключа *)
      fpValue: Pointer       (* Для приема значения толкования *)
  ):SmallInt;Pascal;

(* Загрузить кодификатор в память *)
(* Таблица может быть уже открыта *)
  Function htLoadCoder(
      fpTableName : PChar;    (* Имя таблицы (можно без расширения) *)
      fpReadPswd  : PChar;    (* Пароль доступа на чтение           *)
      nOpenMode   : SmallInt; (* Режим ее открытия (если еще не открыта) *)
      anFieldsNum : PSmallInt;(* Задействованные номера полей таблицы *)
      (* Первый номер - номер ключа для кодификатора *)
      (* Последующие номера задают поля, образующие толкование ключа *)
      nFieldCnt   : SmallInt; (* Число полей в массиве *)
      Var fpCoder : CHANDLE   (* Для приема обработчика кодификатора *)
  ):SmallInt;Pascal;

(* Удалить кодификатор из памяти *)
  Procedure htPurgeCoder(
      hCoder : CHANDLE        (* Обработчик кодификатора *)
  );Pascal;

(* Считать кодификатор в прямом или обратном порядке *)
(* Прямой порядок - сортировка по значению кода *)
(* Буфер содержит пары {ключ:толкование} *)
(* Обратный порядок - сортировка по значению толкования *)
(* Буфер содержит пары {толкование:ключ} *)
  Function htReadCoder(
      hCoder  : CHANDLE;     (* Обработчик кодификатора *)
      fpBuf   : Pointer;     (* Буфер для чтения *)
      bInverse: Boolean      (* true - вывод в обратном порядке *)
  ):SmallInt;Pascal;

(* Открыть доступ к результатам поиска в БДС *)
(* в случае, если поля записей имеют кодификаторы *)
  Function htOpenCodedResults(
      Var fpSrc : SAB;       (* Адрес исходного БДС *)
      fpFields  : LPCDF;     (* Описатели читаемых элементов *)
      nFieldCnt : SmallInt   (* Число читаемых элементов *)
  ):SmallInt;Pascal;

(* Преобразование кодированных результатов в таблицу *)
(* Функция аналогична htResultsToTable, но позволяет выполнить *)
(* декодирование полей.  *)
  Function htCodedResultsToTable(
      Var fpSrc : SAB;      (* Адрес исходного БДС                       *)
      hOutTable : THANDLE;  (* Обработчик для заполняемой таблицы        *)
      fpfRecProc: LPRFUNC;  (* Пользовательская функция обработки записи *)
          (* Nil - обработка не нужна (все готово)     *)
      fpfErrProc: LPEFUNC;  (* Пользовательская функция обработки ошибок *)
          (* Nil - ошибки прерывают ввод               *)
      fpUser    : Pointer;  (* Доп.параметр пользователя                 *)
      fpElemNo  : LPCDF;    (* Номера выводимых элементов исх.записи     *)
      nElemCnt  : SmallInt; (* Число выводимых элементов                 *)
      bDenyOut  : Boolean;  (* Для true вывод отвергнутых записей в таблицу *)
      bCorrect  : Boolean   (* Для true коррекция суррогатного и авто-ключей *)
  ):LongInt;Pascal;

(*------------------------ Импорт/экспорт --------------------------*)

(* Варианты отображения даты в символьном виде *)
(* Используются в описателе формата при операциях импорта/экспорта *)
  Type DATES=(
  DATE1,  (* дд мм гг - Израиль *)
  DATE2,  (* дд-мм-гг - Великобритания *)
  DATE3,  (* дд.мм.гг - Германия *)
  DATE4,  (* дд/мм/гг - Россия *)
  DATE5,  (* мм-дд-гг - Америка *)
  DATE6,  (* гг-мм-дд - Азия *)
  DATE7 (* ггггммдд - dBase *)
  );

(* Варианты выходных файлов экспорта *)
  EXPMODE=(
  EXP_ASCII,  (* Выходный файл - текстовый файл *)
  EXP_DBASE   (* Выходный файл - файл dBaseIII  *)
  );

(* Варианты исходных файлов импорта *)
  IMPMODE=(
  IMP_ASCII,  (* Исходный файл - регулярный текстовый файл *)
  IMP_DBASE,  (* Исходный файл - файл dBaseIII   *)
  IMP_HYTECH  (* Исходный файл - файл HyTech 1.6 *)
  );

(* Формат вывода FLOAT (например '%- 10.2f') *)
(* '%' - признак форматирования *)
(* '-' - выравнивание вправо (иначе - влево)      *)
(* ' ' - заполнитель при выравнивании (можно '0') *)
(* '10' - общая ширина вывода числа - 10 символов *)
(* '.2' - точность (число десятичных разрядов)    *)
(* 'f'  - вывод с фиксированной точкой *)
  FLOAT_FMT = Array [0..8] Of Char;
(* Формат вывода DOUBLE (например '%- 12.6lE') *)
(* '%' - признак форматирования *)
(* '-' - выравнивание вправо (иначе - влево)      *)
(* ' ' - заполнитель при выравнивании (можно '0') *)
(* '12' - общая ширина вывода числа - 12 символов *)
(* '.6' - точность (число десятичных разрядов)    *)
(* 'l'  - числой двойной точности (double)        *)
(* 'E'  - число будет иметь десятичный порядок (можно 'e') *)
  DOUBLE_FMT = Array [0..9] Of Char;

(* Описатель параметров преобразования символьных и цифровых *)
(* данных при импорте/экспорте *)
  FORMAT=Record
    nDateType : SmallInt; (* Тип даты (DATES) *)
    bCentury  : SmallInt; (* Полный год, если TRUE *)
    mFloatFormat:FLOAT_FMT;     (* Формат вывода float *)
    mDoubleFormat:DOUBLE_FMT;   (* Формат вывода double *)
    mCurrencyFormat:DOUBLE_FMT; (* Формат вывода currency *)
  End;
  LPFORMAT = ^FORMAT;

(* Операция экспорта данных таблицы в файлы других форматов *)
(* Таблица может быть открыта *)
  Function htExport(
  nMode:       EXPMODE;   (* Тип экспорта *)
  fpSrcTabName:PChar; (* Имя таблицы исходного файла *)
  fpReadPswd:  PChar;     (* Пароль чтения *)
  nOpenMode:   SmallInt;  (* Режим открытия исходной таблицы *)
  fpDstName:   PChar;     (* Имя порождаемого файла *)
  fpFmt:       LPFORMAT (* Описатель форматов *)
  ):SmallInt;Pascal;

(* Операция импорта данных таблицы из файлов других форматов *)
(* Таблица должна быть закрыта *)
  Function htImport(
  nMode:       IMPMODE;   (* Тип импорта *)
  fpDstTabName:PChar;     (* Имя таблицы, образуемой при импорте *)
  fpReadPswd:  PChar;     (* Пароль доступа на чтение *)
  fpWritePswd: PChar;     (* Пароль доступа на запись *)
  nOpenMode:   SmallInt;  (* Режим открытия образуемой таблицы *)
  fpSrcName:   PChar;     (* Имя исходного файла *)
  fpSrcTabName:PChar;     (* Имя таблицы для исходного ASCII файла *)
  fpFmt:       LPFORMAT;  (* Описатель форматов *)
  bLogFile:    Boolean;   (* !=0 вести журнал импорта *)
  bToConst:    Boolean    (* !=0 вывод в постоянную часть таблицы *)
  ):LongInt;Pascal;

(* Операция импорта описателя таблицы из файлов других форматов *)
(* Допустимы только типы dBase и HyTech1.6 *)
  Function htImportTitle(
  fpSrcName  : PChar;    (* Имя исходного файла dBase или HyTech 1.6 *)
  fpTableName: PChar;    (* Имя таблицы, образуемой при импорте *)
  fpCryptoKey: PChar;    (* Пароль шифрования данных *)
  fpReadPswd : PChar;    (* Пароль доступа на чтение *)
  fpWritePswd: PChar;    (* Пароль доступа на запись *)
  bAnsi      : Boolean   (* Образуем ANSI-таблицу    *)
  ):SmallInt;Pascal;

(* Операция вывода данных таблицы в другую таблицу *)
(* Исходная таблица может быть открыта, *)
(* таблица-приемник - должна быть закрыта *)
  Function htOutTo(
  fpSrcTabName:  PChar; (* Имя таблицы исходного файла *)
  fpReadPswd:    PChar; (* Пароль чтения *)
  nOpenMode:     SmallInt;(* Режим открытия исходной таблицы *)
  fpDstTabName:  PChar; (* Имя таблицы, образуемой при выводе *)
  fpDstReadPswd: PChar; (* Пароль доступа на чтение *)
  fpDstWritePswd:PChar; (* Пароль доступа на запись *)
  fpFmt:         LPFORMAT;(* Описатель форматов *)
  bLogFile:      Boolean; (* TRUE - вести журнал вывода *)
  bCorrect:      Boolean  (* TRUE - коррекция суррогатного и авто-ключей *)
  ):LongInt;Pascal;

(*------------- Поддержка распределенных таблиц ------------*)

(* Типы регистрируемых в журнале операций *)
Const LOG_ADD = 0;   (* Добавление записи  *)
Const LOG_DEL = 1;   (* Удаление записи    *)
Const LOG_MDF = 2;   (* Модификация записи *)

(* Описатель доступа к журналу изменений *)
Type LOGON=Record
  wItemLen: Cardinal;        (* Длина читаемого элемента журнала *)
  gItemCnt: LongInt;       (* Число элементов в журнале *)
  mSystem: Array [1..128] of Char; (* Будет использоваться СУБД *)
End;

(* Закрыть доступ к журналу изменений *)
  Procedure htLogClose(
  Var sLog:LOGON          (* Описатель доступа к журналу *)
  );Pascal;

(* Открыть доступ к журналу изменений *)
  Function htLogOpen(
      fpTableName: PChar;      (* Имя таблицы (можно без расширения)*)
      fpReadPswd : PChar;      (* Пароль доступа на чтение          *)
      fpWritePswd: PChar;      (* Пароль доступа на запись          *)
      fpElemNo:    PSmallInt;  (* Номера читаемых элементов записи  *)
             (* Если Nil - читаются все элементы записи *)
      nElemCnt:    SmallInt;   (* Число читаемых элементов *)
      Var sLog:    LOGON       (* Описатель доступа к журналу *)
  ):SmallInt;Pascal;

(* Считать пачку записей (или их полей) из журнала изменений *)
(* Читаются элементы журнала изменений таблицы, начиная с заданного.   *)
(* Каждый элемент предваряется байтом с признаком операции (LOG_???).  *)
(* Под элементом понимается вся запись с номером или ее заданнные поля.*)
  Function htLogRead(
  Var sLog: LOGON;  (* Описатель доступа к журналу *)
  gStart:   LongInt;  (* Номер первого читаемого элемента журнала (от 0) *)
  fpBuf:    Pointer;      (* Буфер для чтения записей *)
  wBufLen:  Cardinal      (* Длина буфера *)
  ):Word;Pascal;

(*------------ Резервное копирование/восстановление таблицы -----------*)

(* Сделать резервную копию таблицы от заданного снимка. *)
(* Копия представляет собой неиндексированную постоянную часть. *)
  Function htBackupTable(
	cpPhoto: LPSAB;       (* Снимок таблицы *)
	hTable: THANDLE;      (* Таблица *)
	cpNewName: PChar      (* Имя резервной копии *)
  ):SmallInt;Pascal;

(* Восстановить таблицу с резервной копии (копирует и индексирует). *)
(* Требуется совпадение паролей у копии и существующей таблицы.     *)
(* Возвращает: число отвергнутых при индексировании записей или код ошибки. *)
  Function htRestoreTable(
	pBackName :  PChar;  (* Имя резервной копии *)
	pReadPswd :  PChar;  (* Пароль доступа на чтение к резервной копии *)
	pWritePswd : PChar;  (* Пароль доступа на запись к исходной таблице *)
	pTabName :   PChar   (* Имя восстанавливаемой таблицы *)
  ):LongInt;Pascal;

(*------------------------ Прочее --------------------------*)

(* Прервать выполнение текущей операции HyTech         *)
(* Не меняет содержимое регистров и флагов процессора. *)
(* Можно вызывать, например, из обработчика Ctrl-Break *)
  Procedure htBreak;Pascal;

(* Установить задержку опроса сети *)
  Procedure htSetPollDelay( wMSec: Word );Pascal;

(* Получить "снимок" таблицы без выполнения поиска *)
  Function htMakePhoto(
  Var fpPhoto : SAB;  (* БДС для "снимка" *)
  hTable : THANDLE  (* Обработчик для таблицы *)
  ):LPSAB;Pascal;

(* Получить "снимки" нескольких таблиц одномоментно *)
  Function htMakeGroupPhoto(
  fpPhotos :  LPSAB;  (* БДС'ы для "снимков" *)
  fphTables : LPTHANDLE;  (* Обработчики таблиц *)
  nTabCnt:    SmallInt  (* Число таблиц в группе *)
  ):SmallInt;Pascal;

(* Получить текстовую строку по коду завершения функции *)
(* Возвращает сообщение типа 'Нет памяти для работы'.   *)
  Function htErrorMessage(
      nCode: SmallInt;    (* Код завершения *)
      lpszBuff80: PChar  (* Буфер для приема текста сообщения *)
  ):PChar;Pascal;

(* Получить дополнительную информацию о последней ошибке HyTech *)
(* Возвращает имя файла, при работе с которым произошла ошибка, *)
(* а также код ошибки ДОС и код операции, приведшей к ошибке.   *)
(* Последующие ошибки переписывают данные о предыдущей.         *)
  Function htExtError(
      Var nDosError : SmallInt; (* Сюда занесут код, возвращенный ДОС            *)
      Var nOperation: SmallInt; (* Сюда занесут код операции, приведшей /к ошибке *)
      lpszBuff140: PChar       (* Буфер для приема имени файла *)
  ):PChar;Pascal;

(* Получить дополнительную информацию о последней ошибке HyTech *)
(* Возвращает текстовую строку, содержащую название операции, *)
(* имя файла и возможную причину ошибки. *)
(* Последующие ошибки переписывают данные о предыдущей.         *)
  Function htIOMessage(
    lpszBuff220: PChar   (* Буфер для приема текста сообщения *)
  ):PChar;Pascal;

(* Функция возвращает указатель на строку содержащую сообщение *)
(* в зависимости от типа ошибки (В/В или прочие), например:    *)
(*  "Нет памяти для работы" или                                *)
(*  "Ошибка открытия d:\xxxx файл не найден".                  *)
  Function  htMessage(
    nRetCode:  SmallInt; (* Код сообщения *)
    lpszBuff220: PChar   (* Буфер для приема текста сообщения *)
  ):PChar;Pascal;

(* Очистить информацию о предыдущей ошибке СУБД *)
  Procedure htPurgeError;Pascal;

(* Определить каталог сетевых замков              *)
(* Имя каталога имеет замыкающий '\'              *)
  Procedure htNetPath( Var stBuf: PathStr );Pascal;

(* Определить каталог временных файлов            *)
(* Имя каталога имеет замыкающий '\'              *)
  Procedure htTmpPath( Var stBuf: PathStr );Pascal;

(* Дата и время инициализации HyTech *)
(* Формат даты и времени как принято в ДОС для файлов *)
(* Младшее слово возврата - время, старшее - дата     *)
  Function htStartTimeDate: LongInt;Pascal;

(* Проверка установки поля в "пустое" значение *)
  Function htIsFieldNull(
      nType  :SmallInt;         (* Тип поля *)
      wLen   :Cardinal;         (* Длина поля *)
      pField :Pointer   (* Тело проверямого поля *)
  ):SmallInt;Pascal;

(* Установка поля в "пустое" значение *)
  Function htNullField(
      nType   :SmallInt;        (* Тип поля *)
      nKeyType:SmallInt;  (* Тип ключа *)
      wLen    :Cardinal;  (* Длина поля *)
      fpField :Pointer    (* Тело ключа *)
  ):SmallInt;Pascal;

(* Установка записи в "пустое" значение *)
  Function htNullRecord(
      hTable:THANDLE;   (* Обработчик таблицы *)
      fpRec :Pointer    (* Адрес тела записи *)
  ):SmallInt;Pascal;

(* Преобразование строки в массив байтов *)
(* Копирует строку в массив и дополняет символами #0 *)
  Procedure htStringToArray(
      fpArray : Pointer;    (* Адрес массива-приемника *)
      fpString: PChar;      (* Адрес исходной строки *)
      wDimens : Cardinal    (* Длина массива *)
  );Pascal;

(* Преобразование строки в массив символов *)
(* Копирует строку в массив и дополняет пробелами *)
  Procedure htStringToChars(
      fpChars : Pointer;    (* Адрес массива символов *)
      fpString: PChar;      (* Адрес исходной строки *)
      wDimens : Cardinal    (* Длина массива *)
  );Pascal;

(* Режимы капитализации регистра симоволов строки *)
Type CASE_MODE = (
  CASE_NATIVE,  (* Сохранить исходный регистр символов *)
  CASE_ANSI_UP,   (* Капитализировать в ANSI *)
  CASE_OEM_UP   (* Капитализировать в OEM *)
);

(* Сравнить массив символов с шаблоном *)
(* =0 - равны, <>0 - не равны *)
  Function htWildCmp(
      fpArray : PChar;      (* Адрес сканируемого массива *)
      wDimens : Word;       (* Длина массива *)
      fpWild  : PChar;      (* Адрес шаблона (ASCIIZ-строки) *)
      nCaseMode: CASE_MODE  (* Режим капитализации регистра *)
  ):SmallInt;Pascal;

(* Для преобразования даты в/из внутреннего представления.     *)
(* Дата хранится в записи в виде целого числа без знака,       *)
(* определяющего номер дня, считая от 01.01.1900 (понедельник).*)
(* Для получения дня недели - взять остаток от деления даты на *)
(* 7 (0-воскресенье, 1 - понедельник и т.п.).                  *)
Type DATE=Record
  Day  : Byte;     (* День  - отсчет от 1 *)
  Month: Byte;     (* Месяц - отсчет от 1 *)
  Year : SmallInt;  (* Год   - в виде 1993 *)
End;

(* Преобразование даты во внутренний формат (целое без знака) *)
(* Неверно заданные даты дают на выходе 0.                    *)
  Function htDateToWord( sDate: DATE ):Word;Pascal;

(* Преобразование даты из внутреннего формата в структуру *)
  Procedure htWordToDate( wWord: Word; Var sDate: DATE);Pascal;

 Type
(* Одно изменение таблицы *)
  CHANGER=Record
    gNumber:LongInt;  (* Физ.номер *)
    hRecord:RHANDLE;  (* Обработчик записи *)
  End;
  LPCHANGER=^CHANGER;

(* Получить состояние таблицы (снимок) для БДС *)
  Function htTableSABStat(
  Var pSAB: SAB;          (* Результат поиска *)
  Var pStat: STATT  (* Состояние таблицы *)
  ):SmallInt;Pascal;

(* Определить длину диф.части для БДС на момент поиска *)
  Function htGetDiffLength(Var fpSAB:SAB):LongInt;Pascal;

(* Считать пачку описателей изменений БДС с заданной позиции журнала *)
  Function htReadSABChanges(
  Var fpSAB:SAB;
  fpBuf:LPCHANGER;
  nCnt:SmallInt;
  Var gPos:LongInt
  ):SmallInt;Pascal;

(* Считать пачку описателей изменений с заданной позиции журнала *)
  Function htReadTableChanges(
  hTable:THANDLE;
  gStart:LongInt;
  fpBuf:LPCHANGER;
  nCnt:SmallInt;
  Var gPos:LongInt
  ):SmallInt;Pascal;

 Type
(* Описатель хозяина таблицы или ее части *)
  OWNER=Record
    nOrdinal:SmallInt;   (* Порядковый номер экземпляра *)
    szUser:  NameStr;   (* Имя станции в сети *)
  End;

(* Определить захватчика записи *)
  Function htWhoLockRecord(
  fpTabName:PChar;
  gRecNo:LongInt;
  Var sOwner:OWNER
  ):SmallInt;Pascal;

(* Определить захватчика множества записей *)
  Function htWhoLockSet(Var sSAB:SAB;Var sOwner:OWNER):SmallInt;Pascal;

(* Определить захватчика таблицы *)
  Function htWhoLockTable(fpTabName:PChar;Var sOwner:OWNER):SmallInt;Pascal;

(* Управление флагом подмены обработчика CtrlBreak (вызов SetConsoleCtrlHandler) *)
(* Возвращает старое состояние флаги и проставляет новое *)
(* Ненулевой флаг запрещает подмену обработчика в функциях HyTech *)
  Function htCtrlCtrl(NewState: Integer):Integer;Pascal;

(* Свободная память в заданной куче процесса *)
  Function htMemoAvailByTask(hTask : LongWord;bGlobal : ShortInt) : LongInt;Pascal;
(* Печать заданной кучи процесса *)
  Procedure htPrintHytechHeap(hTask : LongWord;bGlobal : ShortInt);Pascal;

  IMPLEMENTATION

  Function  htAddRecords;                external 'HTW32PAS.DLL' name 'HTADDRECORDS'          ;
  Function  htAndResults;                external 'HTW32PAS.DLL' name 'HTANDRESULTS'          ;
  Function  htAverageOfKeyValues;        external 'HTW32PAS.DLL' name 'HTAVERAGEOFKEYVALUES'  ;
  Function  htBuildIndexes;              external 'HTW32PAS.DLL' name 'HTBUILDINDEXES'        ;
  Function  htBackupTable;               external 'HTW32PAS.DLL' name 'HTBACKUPTABLE'         ;
  Function  htChangeCryptoKey;           external 'HTW32PAS.DLL' name 'HTCHANGECRYPTOKEY'     ;
  Function  htChangeKeyType;             external 'HTW32PAS.DLL' name 'HTCHANGEKEYTYPE'       ;
  Function  htChangeReadPassword;        external 'HTW32PAS.DLL' name 'HTCHANGEREADPASSWORD'  ;
  Function  htChangeWritePassword;       external 'HTW32PAS.DLL' name 'HTCHANGEWRITEPASSWORD' ;
  Procedure htCloseResults;              external 'HTW32PAS.DLL' name 'HTCLOSERESULTS'        ;
  Function  htClusterItemToLink;         external 'HTW32PAS.DLL' name 'HTCLUSTERITEMTOLINK'   ;
  Function  htClusterRecsToLink;         external 'HTW32PAS.DLL' name 'HTCLUSTERRECSTOLINK'   ;
  Function  htCodedResultsToTable;       external 'HTW32PAS.DLL' name 'HTCODEDRESULTSTOTABLE' ;
  Function  htCoderInfo;                 external 'HTW32PAS.DLL' name 'HTCODERINFO'           ;
  Function  htCommitTransaction;         external 'HTW32PAS.DLL' name 'HTCOMMITTRANSACTION'   ;
  Function  htCompareTabHandles;         external 'HTW32PAS.DLL' name 'HTCOMPARETABHANDLES'   ;
  Function  htCopyResults;               external 'HTW32PAS.DLL' name 'HTCOPYRESULTS'         ;
  Function  htCreateClusterTable;        external 'HTW32PAS.DLL' name 'HTCREATECLUSTERTABLE'  ;
  Function  htCreateEmptySAB;            external 'HTW32PAS.DLL' name 'HTCREATEEMPTYSAB'      ;
  Function  htCreateEmptyJoin;           external 'HTW32PAS.DLL' name 'HTCREATEEMPTYJOIN'     ;
  Function  htDateToWord;                external 'HTW32PAS.DLL' name 'HTDATETOWORD'          ;
  Function  htDeleteRecords;             external 'HTW32PAS.DLL' name 'HTDELETERECORDS'       ;
  Function  htDistinctResults;           external 'HTW32PAS.DLL' name 'HTDISTINCTRESULTS'     ;
  Function  htDistinctResultsByCount;    external 'HTW32PAS.DLL' name 'HTDISTINCTRESULTSBYCOUNT';
  Function  htDivision;                  external 'HTW32PAS.DLL' name 'HTDIVISION'            ;
  Function  htDropIndexes;               external 'HTW32PAS.DLL' name 'HTDROPINDEXES'         ;
  Function  htDropTable;                 external 'HTW32PAS.DLL' name 'HTDROPTABLE'           ;
  Function  htDropTableChanges;          external 'HTW32PAS.DLL' name 'HTDROPTABLECHANGES'    ;
  Function  htDropTableData;             external 'HTW32PAS.DLL' name 'HTDROPTABLEDATA'       ;
  Function  htDupTableHandle;            external 'HTW32PAS.DLL' name 'HTDUPTABLEHANDLE'      ;
  Function  htErrorMessage;              external 'HTW32PAS.DLL' name 'HTERRORMESSAGE'        ;
  Function  htExcludeResultsItem;        external 'HTW32PAS.DLL' name 'HTEXCLUDERESULTSITEM'  ;
  Function  htExport;                    external 'HTW32PAS.DLL' name 'HTEXPORT'              ;
  Function  htExtError;                  external 'HTW32PAS.DLL' name 'HTEXTERROR'            ;
  Function  htFilterRecords;             external 'HTW32PAS.DLL' name 'HTFILTERRECORDS'       ;
  Function  htFilterTables;              external 'HTW32PAS.DLL' name 'HTFILTERTABLES'        ;
  Function  htFindCoderKey;              external 'HTW32PAS.DLL' name 'HTFINDCODERKEY'        ;
  Function  htFindCoderValue;            external 'HTW32PAS.DLL' name 'HTFINDCODERVALUE'      ;
  Function  htFlushTable;                external 'HTW32PAS.DLL' name 'HTFLUSHTABLE'          ;
  Function  htGetDiffLength;             external 'HTW32PAS.DLL' name 'HTGETDIFFLENGTH'       ;
  Function  htGetResultsItem;            external 'HTW32PAS.DLL' name 'HTGETRESULTSITEM'      ;
  Function  htGlobalInit;                external 'HTW32PAS.DLL' name 'HTGLOBALINIT'          ;
  Procedure htGlobalShut;                external 'HTW32PAS.DLL' name 'HTGLOBALSHUT'          ;
  Function  htGroupByHavingTo;           external 'HTW32PAS.DLL' name 'HTGROUPBYHAVINGTO'     ;
  Function  htGroupByUser;               external 'HTW32PAS.DLL' name 'HTGROUPBYUSER'         ;
  Function  htHandleAdd;                 external 'HTW32PAS.DLL' name 'HTHANDLEADD'           ;
  Function  htHandleFromRecNo;           external 'HTW32PAS.DLL' name 'HTHANDLEFROMRECNO'     ;
  Function  htHandleModify;              external 'HTW32PAS.DLL' name 'HTHANDLEMODIFY'        ;
  Function  htHistogramByCount;          external 'HTW32PAS.DLL' name 'HTHISTOGRAMBYCOUNT'    ;
  Function  htHistogramOfKey;            external 'HTW32PAS.DLL' name 'HTHISTOGRAMOFKEY'      ;
  Function  htHoldFreeRecords;           external 'HTW32PAS.DLL' name 'HTHOLDFREERECORDS'     ;
  Function  htHoldReadRecord;            external 'HTW32PAS.DLL' name 'HTHOLDREADRECORD'      ;
  Function  htHoldRecord;                external 'HTW32PAS.DLL' name 'HTHOLDRECORD'          ;
  Function  htHoldResults;               external 'HTW32PAS.DLL' name 'HTHOLDRESULTS'         ;
  Function  htHoldTable;                 external 'HTW32PAS.DLL' name 'HTHOLDTABLE'           ;
  Function  htImport;                    external 'HTW32PAS.DLL' name 'HTIMPORT'              ;
  Function  htImportTitle;               external 'HTW32PAS.DLL' name 'HTIMPORTTITLE'         ;
  Function  htIncludeResultsBlock;       external 'HTW32PAS.DLL' name 'HTINCLUDERESULTSBLOCK' ;
  Function  htIncludeResultsItem;        external 'HTW32PAS.DLL' name 'HTINCLUDERESULTSITEM'  ;
  Function  htInit;                      external 'HTW32PAS.DLL' name 'HTINIT'                ;
  Function  htIOMessage;                 external 'HTW32PAS.DLL' name 'HTIOMESSAGE'           ;
  Function  htIsNeedToRoll;              external 'HTW32PAS.DLL' name 'HTISNEEDTOROLL'        ;
  Function  htIsResultObsolete;          external 'HTW32PAS.DLL' name 'HTISRESULTOBSOLETE'    ;
  Function  htIsResultOpen;              external 'HTW32PAS.DLL' name 'HTISRESULTOPEN'        ;
  Function  htIsTransactionalTable;      external 'HTW32PAS.DLL' name 'HTISTRANSACTIONALTABLE';
  Function  htJoinedRecords;             external 'HTW32PAS.DLL' name 'HTJOINEDRECORDS'       ;
  Function  htJoinElement;               external 'HTW32PAS.DLL' name 'HTJOINELEMENT'         ;
  Function  htKeyMaximum;                external 'HTW32PAS.DLL' name 'HTKEYMAXIMUM'          ;
  Function  htKeyMinimum;                external 'HTW32PAS.DLL' name 'HTKEYMINIMUM'          ;
  Function  htLoadCoder;                 external 'HTW32PAS.DLL' name 'HTLOADCODER'           ;
  Function  htLoadRecords;               external 'HTW32PAS.DLL' name 'HTLOADRECORDS'         ;
  Procedure htLogClose;                  external 'HTW32PAS.DLL' name 'HTLOGCLOSE'            ;
  Function  htLogOpen;                   external 'HTW32PAS.DLL' name 'HTLOGOPEN'             ;
  Function  htLogRead;                   external 'HTW32PAS.DLL' name 'HTLOGREAD'             ;
  Function  htMakeGroupPhoto;            external 'HTW32PAS.DLL' name 'HTMAKEGROUPPHOTO'      ;
  Function  htMakePhoto;                 external 'HTW32PAS.DLL' name 'HTMAKEPHOTO'           ;
  Function  htMarkJoinedRecord;          external 'HTW32PAS.DLL' name 'HTMARKJOINEDRECORD'    ;
  Function  htMarkJoinedRecordEx;        external 'HTW32PAS.DLL' name 'HTMARKJOINEDRECORDEX'  ;
  Function  htMarkRecord;                external 'HTW32PAS.DLL' name 'HTMARKRECORD'          ;
  Function  htMemoAvailByTask;           external 'HTW32PAS.DLL' name 'HTMEMOAVAILBYTASK'     ;
  Function  htMessage;                   external 'HTW32PAS.DLL' name 'HTMESSAGE'             ;
  Function  htModifyRecords;             external 'HTW32PAS.DLL' name 'HTMODIFYRECORDS'       ;
  Function  htNotResults;                external 'HTW32PAS.DLL' name 'HTNOTRESULTS'          ;
  Function  htNullField;                 external 'HTW32PAS.DLL' name 'HTNULLFIELD'           ;
  Function  htNullRecord;                external 'HTW32PAS.DLL' name 'HTNULLRECORD'          ;
  Function  htOpenCodedResults;          external 'HTW32PAS.DLL' name 'HTOPENCODEDRESULTS'    ;
  Function  htOpenResults;               external 'HTW32PAS.DLL' name 'HTOPENRESULTS'         ;
  Function  htOrResults;                 external 'HTW32PAS.DLL' name 'HTORRESULTS'           ;
  Function  htOutTo;                     external 'HTW32PAS.DLL' name 'HTOUTTO'               ;
  Procedure htPrintHytechHeap;           external 'HTW32PAS.DLL' name 'HTPRINTHYTECHHEAP'     ;
  Function  htPureAddRecords;            external 'HTW32PAS.DLL' name 'HTPUREADDRECORDS'      ;
  Function  htPureModifyRecords;         external 'HTW32PAS.DLL' name 'HTPUREMODIFYRECORDS'   ;
  Function  htReadCoder;                 external 'HTW32PAS.DLL' name 'HTREADCODER'           ;
  Function  htReadRecord;                external 'HTW32PAS.DLL' name 'HTREADRECORD'          ;
  Function  htReadRecordByHandle;        external 'HTW32PAS.DLL' name 'HTREADRECORDBYHANDLE'  ;
  Function  htReadResults;               external 'HTW32PAS.DLL' name 'HTREADRESULTS'         ;
  Function  htReadSABChanges;            external 'HTW32PAS.DLL' name 'HTREADSABCHANGES'      ;
  Function  htReadTableChanges;          external 'HTW32PAS.DLL' name 'HTREADTABLECHANGES'    ;
  Function  htRecNoFromHandle;           external 'HTW32PAS.DLL' name 'HTRECNOFROMHANDLE'     ;
  Function  htRecordAdd;                 external 'HTW32PAS.DLL' name 'HTRECORDADD'           ;
  Function  htRecordByUniq;              external 'HTW32PAS.DLL' name 'HTRECORDBYUNIQ'        ;
  Function  htRecordDelete;              external 'HTW32PAS.DLL' name 'HTRECORDDELETE'        ;
  Function  htRecordModify;              external 'HTW32PAS.DLL' name 'HTRECORDMODIFY'        ;
  Function  htRecordOrdinalNumber;       external 'HTW32PAS.DLL' name 'HTRECORDORDINALNUMBER' ;
  Function  htRecordsByKey;              external 'HTW32PAS.DLL' name 'HTRECORDSBYKEY'        ;
  Function  htRecordsForTwoKeys;         external 'HTW32PAS.DLL' name 'HTRECORDSFORTWOKEYS'   ;
  Function  htReleaseRecord;             external 'HTW32PAS.DLL' name 'HTRELEASERECORD'       ;
  Function  htReleaseResults;            external 'HTW32PAS.DLL' name 'HTRELEASERESULTS'      ;
  Function  htReleaseTable;              external 'HTW32PAS.DLL' name 'HTRELEASETABLE'        ;
  Function  htRepairTable;               external 'HTW32PAS.DLL' name 'HTREPAIRTABLE'         ;
  Function  htRepairTableLog;            external 'HTW32PAS.DLL' name 'HTREPAIRTABLELOG'      ;
  Function  htReplaceResultsItem;        external 'HTW32PAS.DLL' name 'HTREPLACERESULTSITEM'  ;
  Function  htReplaceResultsTable;       external 'HTW32PAS.DLL' name 'HTREPLACERESULTSTABLE' ;
  Function  htRestoreTable;              external 'HTW32PAS.DLL' name 'HTRESTORETABLE'        ;
  Function  htResultsElement;            external 'HTW32PAS.DLL' name 'HTRESULTSELEMENT'      ;
  Function  htResultsItemCnt;            external 'HTW32PAS.DLL' name 'HTRESULTSITEMCNT'      ;
  Function  htResultsItemLen;            external 'HTW32PAS.DLL' name 'HTRESULTSITEMLEN'      ;
  Function  htResultsItemParm;           external 'HTW32PAS.DLL' name 'HTRESULTSITEMPARM'     ;
  Function  htResultsTable;              external 'HTW32PAS.DLL' name 'HTRESULTSTABLE'        ;
  Function  htResultsToHard;             external 'HTW32PAS.DLL' name 'HTRESULTSTOHARD'       ;
  Function  htResultsToTable;            external 'HTW32PAS.DLL' name 'HTRESULTSTOTABLE'      ;
  Function  htResultsType;               external 'HTW32PAS.DLL' name 'HTRESULTSTYPE'         ;
  Function  htRollBackTransaction;       external 'HTW32PAS.DLL' name 'HTROLLBACKTRANSACTION' ;
  Function  htSearch;                    external 'HTW32PAS.DLL' name 'HTSEARCH'              ;
  Function  htSeekMarkedJoin;            external 'HTW32PAS.DLL' name 'HTSEEKMARKEDJOIN'      ;
  Function  htSeekMarkedJoinEx;          external 'HTW32PAS.DLL' name 'HTSEEKMARKEDJOINEX'    ;
  Function  htSeekMarkedRecord;          external 'HTW32PAS.DLL' name 'HTSEEKMARKEDRECORD'    ;
  Function  htSeekResults;               external 'HTW32PAS.DLL' name 'HTSEEKRESULTS'         ;
  Function  htSortedRecords;             external 'HTW32PAS.DLL' name 'HTSORTEDRECORDS'       ;
  Function  htSortedRecordsEx;           external 'HTW32PAS.DLL' name 'HTSORTEDRECORDSEX'     ;
  Function  htSortResults;               external 'HTW32PAS.DLL' name 'HTSORTRESULTS'         ;
  Function  htSortResultsByUser;         external 'HTW32PAS.DLL' name 'HTSORTRESULTSBYUSER'   ;
  Function  htStartTimeDate;             external 'HTW32PAS.DLL' name 'HTSTARTTIMEDATE'       ;
  Function  htStartTransaction;          external 'HTW32PAS.DLL' name 'HTSTARTTRANSACTION'    ;
  Function  htSubSearch;                 external 'HTW32PAS.DLL' name 'HTSUBSEARCH'           ;
  Function  htSumOfKeyValues;            external 'HTW32PAS.DLL' name 'HTSUMOFKEYVALUES'      ;
  Function  htSyncResults;               external 'HTW32PAS.DLL' name 'HTSYNCRESULTS'         ;
  Function  htTableClose;                external 'HTW32PAS.DLL' name 'HTTABLECLOSE'          ;
  Function  htTableCopy;                 external 'HTW32PAS.DLL' name 'HTTABLECOPY'           ;
  Function  htTableCreate;               external 'HTW32PAS.DLL' name 'HTTABLECREATE'         ;
  Function  htTableElement;              external 'HTW32PAS.DLL' name 'HTTABLEELEMENT'        ;
  Function  htTableElementList;          external 'HTW32PAS.DLL' name 'HTTABLEELEMENTLIST'    ;
  Function  htTableHandleByName;         external 'HTW32PAS.DLL' name 'HTTABLEHANDLEBYNAME'   ;
  Function  htTableInfo;                 external 'HTW32PAS.DLL' name 'HTTABLEINFO'           ;
  Function  htTableOpen;                 external 'HTW32PAS.DLL' name 'HTTABLEOPEN'           ;
  Function  htTableRename;               external 'HTW32PAS.DLL' name 'HTTABLERENAME'         ;
  Function  htTableVerify;               external 'HTW32PAS.DLL' name 'HTTABLEVERIFY'         ;
  Function  htTellJoinOrder;             external 'HTW32PAS.DLL' name 'HTTELLJOINORDER'       ;
  Function  htTouchResults;              external 'HTW32PAS.DLL' name 'HTTOUCHRESULTS'        ;
  Function  htTransferToPhoto;           external 'HTW32PAS.DLL' name 'HTTRANSFERTOPHOTO'     ;
  Function  htTransferToTable;           external 'HTW32PAS.DLL' name 'HTTRANSFERTOTABLE'     ;
  Function  htUpdateTable;               external 'HTW32PAS.DLL' name 'HTUPDATETABLE'         ;
  Function  htValuesByCount;             external 'HTW32PAS.DLL' name 'HTVALUESBYCOUNT'       ;
  Function  htValuesFromGroup;           external 'HTW32PAS.DLL' name 'HTVALUESFROMGROUP'     ;
  Function  htValuesOfKey;               external 'HTW32PAS.DLL' name 'HTVALUESOFKEY'         ;
  Function  htXorResults;                external 'HTW32PAS.DLL' name 'HTXORRESULTS'          ;
  Procedure htBreak;                     external 'HTW32PAS.DLL' name 'HTBREAK'               ;
  Procedure htClearResults;              external 'HTW32PAS.DLL' name 'HTCLEARRESULTS'        ;
  Procedure htCloseAllTables;            external 'HTW32PAS.DLL' name 'HTCLOSEALLTABLES'      ;
  Procedure htNetPath;                   external 'HTW32PAS.DLL' name 'HTNETPATH'             ;
  Procedure htPurgeCoder;                external 'HTW32PAS.DLL' name 'HTPURGECODER'          ;
  Procedure htPurgeError;                external 'HTW32PAS.DLL' name 'HTPURGEERROR'          ;
  Procedure htSetLockTimeOut;            external 'HTW32PAS.DLL' name 'HTSETLOCKTIMEOUT'      ;
  Procedure htSetPollDelay;              external 'HTW32PAS.DLL' name 'HTSETPOLLDELAY'        ;
  Procedure htSetTransTimeOut;           external 'HTW32PAS.DLL' name 'HTSETTRANSTIMEOUT'     ;
  Procedure htShut;                      external 'HTW32PAS.DLL' name 'HTSHUT'                ;
  Procedure htStringToArray;             external 'HTW32PAS.DLL' name 'HTSTRINGTOARRAY'       ;
  Procedure htStringToChars;             external 'HTW32PAS.DLL' name 'HTSTRINGTOCHARS'       ;
  Function  htTableSABStat;              external 'HTW32PAS.DLL' name 'HTTABLESABSTAT'        ;
  Function  htTablesJoin;                external 'HTW32PAS.DLL' name 'HTTABLESJOIN'          ;
  Function  htTablesLink;                external 'HTW32PAS.DLL' name 'HTTABLESLINK'          ;
  Procedure htTmpPath;                   external 'HTW32PAS.DLL' name 'HTTMPPATH'             ;
  Function  htWhoLockRecord;             external 'HTW32PAS.DLL' name 'HTWHOLOCKRECORD'       ;
  Function  htWhoLockSet;                external 'HTW32PAS.DLL' name 'HTWHOLOCKSET'          ;
  Function  htWhoLockTable;              external 'HTW32PAS.DLL' name 'HTWHOLOCKTABLE'        ;
  Function  htWildCmp;                   external 'HTW32PAS.DLL' name 'HTWILDCMP'             ;
  Procedure htWordToDate;                external 'HTW32PAS.DLL' name 'HTWORDTODATE'          ;
  Function  htTableState;                external 'HTW32PAS.DLL' name 'HTTABLESTATE'          ;
  Function  htTableAgregateModify;       external 'HTW32PAS.DLL' name 'HTTABLEAGREGATEMODIFY' ;
  Function  htTableAgregateDelete;       external 'HTW32PAS.DLL' name 'HTTABLEAGREGATEDELETE' ;
  Function  htTableAgregateAppend;       external 'HTW32PAS.DLL' name 'HTTABLEAGREGATEAPPEND' ;
  Function  htIsFieldNull;               external 'HTW32PAS.DLL' name 'HTISFIELDNULL'         ;

  Function  htCtrlCtrl;			 external 'HTW32PAS.DLL' name 'AMCTRLCTRL'            ;

End.
