unit DataAdapter;

// $Id: DataAdapter.pas,v 1.85 2016/01/13 06:43:03 morozov Exp $

// $Log: DataAdapter.pas,v $
// Revision 1.85  2016/01/13 06:43:03  morozov
// не собралось
//
// Revision 1.84  2016/01/12 16:49:59  kostitsin
// {requestlink: 614228264 }
//
// Revision 1.83  2015/07/13 13:54:31  kostitsin
// {requestlink: 127042272 }
//
// Revision 1.82  2015/03/18 09:22:51  lulin
// - перетряхиваем зависимости.
//
// Revision 1.81  2015/02/02 14:10:20  kostitsin
// рисуем l3Nodes
//
// Revision 1.80  2014/03/04 13:11:49  lulin
// - переводим идентификаторы Sub'ов и сегментов на нормальные Enum'ы.
//
// Revision 1.79  2014/01/15 12:57:28  kostitsin
// {requestlink: 451251129}
//
// Revision 1.78  2013/12/16 08:20:12  morozov
// {RequestLink: 508825964}
//
// Revision 1.77  2013/10/15 13:34:17  kostitsin
// [$377169452] - RememberPassword
//
// Revision 1.76  2013/10/14 14:19:26  kostitsin
// [$377169452] - Registration
//
// Revision 1.75  2013/09/19 12:46:30  kostitsin
// [$377169452] - LongProcess
//
// Revision 1.74  2013/09/17 10:30:35  morozov
// {RequestLink: 449026721}
//
// Revision 1.73  2013/09/12 13:36:24  morozov
// {RequestLink: 481813781}
//
// Revision 1.72  2013/08/14 14:10:31  kostitsin
// [$377169452] - LoginForm
//
// Revision 1.71  2013/06/06 11:34:51  morozov
// {RequestLink:449026895}
//
// Revision 1.70  2013/04/24 09:35:55  lulin
// - портируем.
//
// Revision 1.69  2013/03/11 11:40:01  morozov
// {RequestLink:424410282}
//
// Revision 1.68  2013/02/19 17:02:53  lulin
// {RequestLink:358352192}
//
// Revision 1.67  2012/10/22 17:49:38  lulin
// {RequestLink:405475133}
//
// Revision 1.66  2012/10/19 18:39:41  lulin
// {RequestLink:381878950}
//
// Revision 1.65  2012/08/03 12:36:27  kostitsin
// [$380616604]
//
// Revision 1.64  2012/07/24 18:01:24  lulin
// {RequestLink:378540022}.
//
// Revision 1.63  2012/05/30 12:30:27  lulin
// {RequestLink:290264810}
//
// Revision 1.62  2012/04/28 13:10:29  lulin
// {RequestLink:361404275}
//
// Revision 1.61  2012/04/28 10:38:49  lulin
// {RequestLink:361404275}
//
// Revision 1.60  2012/04/11 09:44:46  kostitsin
// - Новое скриптовое слово WindowFromPoint
// - перегенерация
//
// Revision 1.59  2012/04/02 13:49:37  lulin
// {RequestLink:237994598}
//
// Revision 1.58  2012/04/02 10:05:34  kostitsin
// - объединяем nsHooks и nsShutdownSupport
// - (+) перегенерация
//
// Revision 1.57  2012/01/19 17:43:06  lulin
// {RequestLink:328859674}
//
// Revision 1.56  2011/10/26 14:18:21  lulin
// {RequestLink:294597335}
//
// Revision 1.55  2011/10/13 18:16:02  lulin
// {RequestLink:270666581}
//
// Revision 1.54  2011/08/09 12:02:04  migel
// - change: меняем картинки для стартовой заставки.
//
// Revision 1.53  2011/08/02 13:00:04  lulin
// {RequestLink:275775785}.
//
// Revision 1.52  2011/07/27 10:47:41  dinishev
// TryActivateKeyboardLayout переместился в afw
//
// Revision 1.51  2011/06/28 19:19:47  lulin
// {RequestLink:254944102}.
//
// Revision 1.50  2011/06/28 17:54:51  lulin
// {RequestLink:254944102}.
//
// Revision 1.49  2011/06/27 14:56:20  lulin
// {RequestLink:254944102}.
// [$271749095].
//
// Revision 1.48  2011/06/23 15:30:00  lulin
// {RequestLink:254944102}.
//
// Revision 1.47  2011/06/07 10:25:23  lulin
// {RequestLink:266425900}.
//
// Revision 1.46  2011/04/12 17:19:50  lulin
// {RequestLink:233013564}.
// №8.
//
// Revision 1.45  2011/03/24 14:42:54  lulin
// {RequestLink:258608185}.
//
// Revision 1.44  2011/01/27 12:14:15  lulin
// {RequestLink:248195582}.
// - избавляемся от развесистых макарон.
//
// Revision 1.43  2011/01/24 17:01:34  lulin
// {RequestLink:248195582}.
// - восстанавливаем возможность удаления только что поставленной закладки.
//
// Revision 1.42  2011/01/14 17:21:30  lulin
// {RequestLink:248195582}.
// - синхронизируем удаление закладки.
//
// Revision 1.41  2010/12/22 18:24:19  lulin
// {RequestLink:242845936}.
//
// Revision 1.40  2010/12/21 09:38:14  lulin
// [$248190726].
//
// Revision 1.39  2010/12/16 12:41:47  lulin
// {RequestLink:247793596}.
//
// Revision 1.38  2010/12/16 12:23:21  lulin
// {RequestLink:247793596}.
//
// Revision 1.37  2010/11/01 17:20:06  lulin
// {RequestLink:237994238}.
// - передаём ссылку на "модель".
// - делаем, чтобы собирались другие проекты.
//
// Revision 1.36  2010/11/01 13:20:41  lulin
// {RequestLink:237994238}.
//
// Revision 1.35  2010/10/07 14:12:48  oman
// - new: Переносим заглушки на модель {RequestLink:235057812}
//
// Revision 1.34  2010/09/22 10:27:36  oman
// - new: {RequestLink:234366672}
//
// Revision 1.33  2010/09/09 10:28:39  dolgop
// -chg: вычищаем predefined_data для мониторингов
// (http://mdp.garant.ru/x/KIxPCg)
//
// Revision 1.32  2010/07/30 09:19:35  oman
// - fix: Чтоб отладчику VC мозг не срывало {RequestLink:227972114}
//
// Revision 1.31  2010/06/25 13:09:02  lulin
// {RequestLink:219124975}.
//
// Revision 1.30  2010/06/02 12:10:05  oman
// - fix: {RequestLink:217154357}
//
// Revision 1.29  2010/06/01 08:45:36  migel
// - fix: перехватываем исключение `ENOServer`, если определен соответсвующий дефайн.
//
// Revision 1.28  2010/06/01 08:36:13  migel
// - change: перехватываем исключение `ENOServer`, если определен соответсвующий дефайн.
//
// Revision 1.27  2010/05/27 05:53:39  oman
// - new: {RequestLink:197493008}
//
// Revision 1.26  2010/05/26 12:09:57  oman
// - new: {RequestLink:197493008}
//
// Revision 1.25  2010/05/14 13:02:14  oman
// - new: {RequestLink:213254373}
//
// Revision 1.24  2010/05/14 09:14:06  migel
// - add: глобальный обработчик исключения `ENoServer`.
//
// Revision 1.23  2010/04/23 10:03:06  oman
// - new: {RequestLink:185205006}
//
// Revision 1.22  2010/04/23 07:54:21  oman
// Жизнь поменялась
//
// Revision 1.21  2010/04/20 14:34:05  oman
// - new: {RequestLink:185205022}
//
// Revision 1.20  2010/04/20 12:09:09  oman
// - new: {RequestLink:185205022}
//
// Revision 1.19  2010/04/13 09:09:55  oman
// - new: Показываем медаль {RequestLink:185205058}
//
// Revision 1.18  2010/03/31 11:54:17  oman
// - new: {RequestLink:200083417}
//
// Revision 1.17  2010/03/19 18:36:19  lulin
// {RequestLink:197497243}.
// - подчищаем за Ромой то, что не компилировалось.
//
// Revision 1.16  2010/03/19 13:39:10  oman
// - new: {RequestLink:197497742}
//
// Revision 1.15  2010/01/29 08:46:39  oman
// - new: {RequestLink:182452843}
//
// Revision 1.14  2009/12/03 14:32:59  lulin
// {RequestLink:172986031}.
//
// Revision 1.13  2009/11/25 13:03:32  oman
// - new: {RequestLink:172362068}
//
// Revision 1.12  2009/10/23 12:00:18  oman
// - fix: {RequestLink:121160631}
//
// Revision 1.11  2009/10/22 08:46:02  oman
// - fix: {RequestLink:167351973}
//
// Revision 1.10  2009/10/15 09:02:37  lulin
// - добавляем условную компиляцию.
//
// Revision 1.9  2009/10/15 08:50:41  oman
// - new: Чистим устаревшие методы доступа {RequestLink:122652464}
//
// Revision 1.8  2009/10/15 08:47:56  oman
// - new: Чистим устаревшие методы доступа {RequestLink:122652464}
//
// Revision 1.7  2009/10/12 11:27:11  lulin
// - коммитим после падения CVS.
//
// Revision 1.6  2009/10/05 12:08:34  oman
// - new:  {RequestLink:163067325}
//
// Revision 1.5  2009/10/01 16:28:19  lulin
// - вычистил ненужный параметр.
//
// Revision 1.4  2009/09/29 16:34:51  lulin
// {RequestLink:159360578}. №39.
// Поправил использование пакетов.
//
// Revision 1.3  2009/09/25 10:29:15  lulin
// {RequestLink:164596150}.
//
// Revision 1.2  2009/09/24 14:48:14  lulin
// - продолжаем переносить на модель модуль Common.
//
// Revision 1.1  2009/09/14 11:28:52  lulin
// - выводим пути и для незавершённых модулей.
//
// Revision 1.437  2009/09/10 13:33:43  lulin
// - генерируем проект Немезис.
//
// Revision 1.436  2009/09/10 11:33:33  migel
// - change: возможность запуска дочерних утилит, даже, если отсутствует база.
//
// Revision 1.435  2009/09/09 18:55:08  lulin
// - переносим на модель код проектов.
//
// Revision 1.434  2009/09/09 13:55:48  lulin
// - все модули и сборки так или иначе присутствуют на модели.
//
// Revision 1.433  2009/08/25 11:24:53  oman
// - new: {RequestLink:140285854}
//
// Revision 1.432  2009/08/14 14:57:40  lulin
// {RequestLink:129240934}. №42.
//
// Revision 1.431  2009/08/13 17:34:49  lulin
// - bug fix: не компилировался админ и мониторинги.
//
// Revision 1.430  2009/08/13 07:12:20  oman
// - new: Более правильная нотификация - {RequestLink:159355458}
//
// Revision 1.429  2009/07/31 17:29:48  lulin
// - убираем мусор.
//
// Revision 1.428  2009/07/31 12:10:35  lulin
// [$158796097].
//
// Revision 1.427  2009/06/24 12:45:38  oman
// - new: Получаем дерево из правильного места - [$152408792]
//
// Revision 1.426  2009/06/24 12:22:51  oman
// - new: Показываем контакты - [$152408792]
//
// Revision 1.425  2009/06/04 06:45:15  oman
// - new: Логин - [$148014435]
//
// Revision 1.424  2009/06/04 06:26:34  oman
// - new: Логин - [$148014435]
//
// Revision 1.423  2009/06/03 12:27:43  oman
// - new: компилируемся - [$148014435]
//
// Revision 1.422  2009/06/03 12:04:38  oman
// - new: компилируемся - [$148014435]
//
// Revision 1.421  2009/06/03 11:08:52  oman
// - new: запрещаем оболочку для админа - [$148014435]
//
// Revision 1.420  2009/06/03 10:43:13  oman
// - new: Готовим проекты к отпилу - [$148014435]
//
// Revision 1.419  2009/05/22 14:19:52  migel
// - add: возможность отключения Интернет-Агента.
//
// Revision 1.418  2009/05/14 12:48:25  oman
// - new: Готовим потроха - [$125404858]
//
// Revision 1.417  2009/04/16 12:46:06  oman
// - new: В первом приближении переводим папки на новое дерево - [$127762671]
//
// Revision 1.416  2009/04/14 09:24:49  oman
// - new: Новые деревья пользователей - [$140280776]
//
// Revision 1.415  2009/04/14 09:20:39  oman
// - new: Готовимся к пользованию другим деревом - [$140280776]
//
// Revision 1.414  2009/04/10 09:36:00  oman
// - fix: Аккуратней подписываемся на нотификацию - [$142613480]
//
// Revision 1.413  2009/03/06 13:36:25  oman
// - fix: Раз адаптер немногопоточный - жестко сериализуем вычитывание деревьев в отцепленных потоках (К-138548909)
//
// Revision 1.412  2009/02/27 13:36:03  oman
// - fix: Разруливаем дедлоки (К-135595449)
//
// Revision 1.411  2009/02/27 06:33:46  oman
// Не собирались
//
// Revision 1.410  2009/02/26 10:44:35  oman
// - fix: Выносим логику отдельно (К-137465839)
//
// Revision 1.409  2009/02/20 12:25:09  lulin
// - <K>: 136941122.
//
// Revision 1.408  2009/02/20 10:08:24  lulin
// - чистка комментариев.
//
// Revision 1.407  2009/02/20 07:36:22  oman
// - fix: Передаем пока только картинку (К-136254180)
//
// Revision 1.406  2009/02/19 19:04:56  lulin
// - переносим идентификаторы сообщений.
//
// Revision 1.405  2009/02/16 13:33:44  demon
// - new: завершаем работу приложения через exit, а не через terminate, при обработке исключений InvalidBase и NoMorphoExist
//
// Revision 1.404  2009/02/10 19:03:08  lulin
// - <K>: 133891247. Вычищаем морально устаревший модуль.
//
// Revision 1.403  2009/02/10 18:47:16  lulin
// - <K>: 133891247. Выделяем интерфейсы работы с адаптером и советами дня.
//
// Revision 1.402  2009/02/09 14:52:22  lulin
// - <K>: 133891247. Выделяем интерфейсы администратора.
//
// Revision 1.401  2009/02/09 13:20:52  lulin
// - <K>: 133891247.
//
// Revision 1.400  2009/01/30 12:04:58  oman
// - fix: В случае превышения коннекций возвращаемся в форму логина (К-136254154)
//
// Revision 1.399  2009/01/30 08:45:26  oman
// - fix: В случае превышения коннекций возвращаемся в форму логина (К-136254154)
//
// Revision 1.398  2009/01/30 07:34:32  lulin
// - <K>: 136255137.
// - bug fix: не собирались мониторинги.
//
// Revision 1.397  2009/01/14 14:08:00  oman
// Вычищаем 5x
//
// Revision 1.396  2009/01/14 13:54:56  oman
// Вычищаем 5x
//
// Revision 1.395  2008/12/25 12:19:26  lulin
// - <K>: 121153186.
//
// Revision 1.394  2008/11/20 18:40:17  lulin
// - используем кошерный шаблон.
//
// Revision 1.393  2008/11/20 18:35:22  lulin
// - <K>: 125403437.
//
// Revision 1.392  2008/11/05 16:26:35  lulin
// - <K>: 121167571.
//
// Revision 1.391  2008/10/30 15:08:59  lulin
// - <K>: 121159648.
//
// Revision 1.390  2008/10/29 11:28:45  oman
// - fix: Забыли подписаться на нотификацию (К-121165239)
//
// Revision 1.389  2008/10/01 11:54:01  oman
// - fix: Меняем раскладку клавиатуры (К-120718336)
//
// Revision 1.388  2008/09/02 08:41:19  migel
// - fix: AV при переключении баз? если это у нас десктоп и уже начали шатдаунится (К: 112722728).
//
// Revision 1.387  2008/08/28 12:12:51  lulin
// - <K>: 89100161.
//
// Revision 1.386  2008/08/18 11:54:50  mmorozov
// - bugfix: обновление текущего выбраного типа КР после переключения базы (<K>: 96483875);
//
// Revision 1.385  2008/08/07 13:15:11  oman
// - new: Отрубаем ЭНО (K-106594448)
//
// Revision 1.384  2008/08/07 13:03:19  oman
// - fix: В висте сп1 заголовки групповых кнопок пишутся в другое место
//
// Revision 1.383  2008/08/06 11:46:42  migel
// - fix: зависание при "запуске нескольких копий оболочки" (К: 104434556).
//
// Revision 1.382  2008/07/04 07:45:50  mmorozov
// - change: сообщение о работающих пользователях (K<96484527>);
//
// Revision 1.381  2008/07/04 06:33:29  mmorozov
// - change: сообщение о работающих пользователях (K<96484527>);
//
// Revision 1.380  2008/07/03 12:21:31  mmorozov
// - new: информация о работающих пользователях (K<96484527>).
//
// Revision 1.379  2008/06/23 12:57:56  oman
// - fix: Не было реакции на исключение в нужном месте (cq29367)
//
// Revision 1.378  2008/06/09 12:16:11  lulin
// - bug fix: не собирался Немезис.
//
// Revision 1.377  2008/06/09 11:39:48  demon
// - new: функция ISearch.CorrectContext получила дополнительный параметр - для Инфарм или нет
//
// Revision 1.376  2008/06/02 07:14:30  demon
// - fix: не верно возвращался результат _CorrectMistakes при отсутствии опечаток
//
// Revision 1.375  2008/05/27 09:04:18  lulin
// - удалена старая проверка валидности контекста.
//
// Revision 1.374  2008/05/22 10:44:58  oman
// - fix: Исправляем опечатки в БП (cq29024)
//
// Revision 1.373  2008/05/22 09:37:15  oman
// - fix: Данные для исправления опечаток (cq29024)
//
// Revision 1.372  2008/04/29 06:29:19  oman
// - new: Обрабатываем исключение (cq28822)
//
// Revision 1.371  2008/04/22 07:50:50  oman
// - new: Обрабатываем исключение о невозможности авторизоваться
//  на почтовом сервере (cq28438)
//
// Revision 1.370  2008/03/21 14:45:07  oman
// - fix: Не падаем в случае отсутствия значений
//
// Revision 1.369  2008/03/20 09:11:37  oman
// - fix: Не падаем в случае отсутствия значений
//
// Revision 1.368  2008/03/19 11:45:54  oman
// Опечатка
//
// Revision 1.367  2008/03/11 11:25:26  oman
// - fix: Пытаемся жить на кривых базах (cq28563)
//
// Revision 1.366  2008/03/07 08:18:09  oman
// - new: Словарь медицинских терминов - включили детектирование инфарма
//
// Revision 1.365  2008/03/06 10:02:55  oman
// - new: Заготовка для словаря медицинских терминов
//
// Revision 1.364  2008/02/29 05:28:46  mmorozov
// - new: перенос запросов ПРАЙМ с папок в отдельное хранилище;
//
// Revision 1.363  2008/02/07 19:14:16  lulin
// - избавляемся от излишне универсальных методов базовых списков.
//
// Revision 1.362  2008/02/06 09:17:14  oman
// - new: Обрабатываем исключение об отсутствии файла помощи (cq28369)
//
// Revision 1.361  2008/02/05 12:21:04  oman
// - fix: получение SplashScreen и SettingsManager перенесено в более
//  правильное место (cq28276)
//
// Revision 1.360  2008/02/04 12:16:09  mmorozov
// - bugfix: пытались работать с нулевым адаптером (CQ: OIT5-28327);
//
// Revision 1.359  2008/01/28 11:11:26  mmorozov
// - new: для однопользовательской версии в случае если есть работающий пользователь ссобщаем, что за пользователь уже работает (CQ: OIT5-20353);
//
// Revision 1.358  2008/01/15 14:56:38  oman
// - new: Получаем SettingsManager более кошерно
//
// Revision 1.357  2008/01/14 09:58:45  oman
// - new: На выходе дожидаемся загрузки отложенных деревьев (cq27842)
//
// Revision 1.356  2008/01/10 08:26:46  mmorozov
// - change: сначала уведомляем об обновлении данных адаптер, потом всех остальных слушателей (CQ: OIT5-28184);
//
// Revision 1.355  2008/01/10 07:23:10  oman
// Переход на новый адаптер
//
// Revision 1.348.2.20  2007/12/26 12:42:51  mmorozov
// - MERGE WITH HEAD;
//
// Revision 1.348.2.19  2007/12/25 12:27:59  oman
// - fix: Не отдает интерфейс раньше времени
//
// Revision 1.348.2.18  2007/12/13 08:47:06  oman
// Перепиливаем на новый адаптер - Фабрики могут кидаться CannotFindData
//
// Revision 1.348.2.17  2007/12/06 12:59:37  oman
// Убивали раньше отпускания
//
// Revision 1.348.2.16  2007/12/04 08:01:53  oman
// - fix: Опечатка
//
// Revision 1.348.2.15  2007/11/30 13:05:12  oman
// Перепиливаем на новый адаптер - фабрики нод
//
// Revision 1.348.2.14  2007/11/29 12:44:43  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.13  2007/11/29 11:06:53  oman
// Перепиливаем на новый адаптер - фабрики нод
//
// Revision 1.348.2.12  2007/11/29 10:11:13  oman
// Убираем вывод в лог верисй DLL (ожидаемой и реальной)
//
// Revision 1.348.2.11  2007/11/29 08:48:32  oman
// Cleanup
//
// Revision 1.348.2.10  2007/11/29 08:26:36  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.9  2007/11/26 12:29:37  oman
// Привилегированные пользователи
//
// Revision 1.348.2.8  2007/11/23 11:39:49  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.7  2007/11/23 10:46:13  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.6  2007/11/23 09:03:07  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.5  2007/11/22 15:06:14  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.4  2007/11/22 13:20:28  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.3  2007/11/21 15:07:41  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.2  2007/11/19 14:07:21  oman
// Перепиливаем на новый адаптер
//
// Revision 1.348.2.1  2007/11/19 09:17:17  oman
// - new: Привилегированные пользователи (cq27255)
//
// Revision 1.354  2007/12/25 15:21:12  mmorozov
// - new: DataAdapter уведомляет о своём обновлении, а базовый поиск слушает, чтобы перечитать типы поиска (в рамках CQ: OIT5-27823);
//
// Revision 1.353  2007/12/25 11:31:36  mmorozov
// - new: подписка на обновление данных приложения (CQ: OIT5-27823);
//
// Revision 1.352  2007/12/21 07:12:16  mmorozov
// - new: подписка на уведомление об обновлении данных (CQ: OIT5-27823);
//
// Revision 1.351  2007/12/19 10:59:38  mmorozov
// - подписываемся на уведомления данных приложения (CQ: OIT5-27823);
//
// Revision 1.350  2007/11/15 12:33:28  oman
// - new: Групповые операции для привилегированных пользователей  (cq27255)
//
// Revision 1.349  2007/11/13 14:03:07  migel
// - fix: при отсутсвии морфоиндекса - даем запустить бридер (CQ: 27309).
//
// Revision 1.348  2007/10/26 06:36:35  oman
// - fix: Для групповой кнопки берем заголовок приложения (cq27072)
//
// Revision 1.347  2007/10/19 09:23:37  oman
// - fix: При разборе контекста выдаем сообщение - более
//  структурный вариант (К-57051004)
//
// Revision 1.346  2007/10/17 14:03:50  oman
// - fix: При разборе контекста выдаем сообщение (К-57051004)
//
// Revision 1.345  2007/10/16 09:34:33  oman
// - fix: Насильно разрешаем обзор изменений законодательства для
//  внутренней версии (cq27081)
//
// Revision 1.344  2007/09/25 13:47:22  oman
// - new: Дерево СКР теперь одно (cq26792)
//
// Revision 1.343  2007/09/21 13:36:46  lulin
// - bug fix: пытались проверить контекст пустой строки (CQ OIT5-26779).
//
// Revision 1.342  2007/09/20 13:00:59  oman
// - new: Поддержка WER для Vista (cq26750)
//
// Revision 1.341  2007/08/17 13:49:37  oman
// - new: Новое исключение (cq24285)
//
// Revision 1.340  2007/08/14 14:29:46  lulin
// - оптимизируем перемещение блоков памяти.
//
// Revision 1.339  2007/08/10 05:57:54  oman
// - fix: Убеждаемся, что в адаптер передается действительно PAnsiChar
//  (cq25680)
//
// Revision 1.338  2007/08/07 12:51:35  oman
// - fix: Избавляемся от прямых приведений к PAnsiChar строк,
//  передаваемых в адаптер (cq25680)
//
// Revision 1.337  2007/08/01 10:38:32  oman
// - new: Выделяем процедуру проверки контекста на распознаваемость
//
// Revision 1.336  2007/07/27 13:12:46  oman
// - fix: Неверная передача строки в адаптер (cq25869)
//
// Revision 1.335  2007/07/17 09:19:21  oman
// - fix: Обрабатываем ситуацию с запретом авторегистрации
//  во время оной (cq25797)
//
// Revision 1.334  2007/06/27 15:02:51  lulin
// - cleanup.
//
// Revision 1.333  2007/06/21 14:50:30  demon
// - new: рассчет и чтение первого индекса для БП из настроек
//
// Revision 1.332  2007/06/21 12:00:44  mmorozov
// - new: запрет авторегистрации (CQ: OIT5-25328);
//
// Revision 1.331  2007/06/13 07:28:02  oman
// - fix: Пользовательские флаги для дерева берем с адаптера
//
// Revision 1.330  2007/06/07 13:04:00  oman
// - new: Реакция на исключение (cq25124)
//
// Revision 1.329  2007/05/25 13:47:14  oman
// - fix: В случае ошибок обновляем статусбар - чтоб лишнего не
//  светилось (cq25420)
//
// Revision 1.328  2007/05/17 12:40:06  lulin
// - удаляем контекст из комментариев.
//
// Revision 1.327  2007/04/05 11:56:14  oman
// - fix: Неправильно передавали параметры (cq24906)
//
// Revision 1.326  2007/04/03 14:36:38  oman
// - fix: После заливки настроек пытаемся выводить сообщение об
//  актуализации настроек. Для этого пытаемся всега создавать
//  TDataAdapter (cq24791)
//
// Revision 1.325  2007/03/16 16:56:55  lulin
// - избавляемся от излишнего копирования и преобразования строк.
//
// Revision 1.324  2007/03/16 15:47:07  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.323  2007/03/16 13:58:21  lulin
// - переходим на собственную функцию форматирования строк.
//
// Revision 1.322  2007/03/12 15:31:54  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.321  2007/02/28 16:17:01  lulin
// - корректнее обрабатываем юникодные строки.
//
// Revision 1.320  2007/02/28 14:17:43  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.319  2007/02/14 14:24:03  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.318  2007/02/13 14:33:08  lulin
// - cleanup.
//
// Revision 1.317  2007/02/13 13:44:18  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.316  2007/02/12 18:44:25  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.315  2007/02/12 09:58:38  lulin
// - bug fix: искажались входные строковые параметры адаптера.
//
// Revision 1.314  2007/02/09 14:51:16  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.313  2007/02/09 12:58:18  lulin
// - выделена функция преобразования к входной строке адаптера.
//
// Revision 1.312  2007/02/07 14:30:30  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.311  2007/02/06 11:45:24  lulin
// - bug fix: не собирались мониторинги.
//
// Revision 1.310  2007/02/05 09:45:14  lulin
// - cleanup.
//
// Revision 1.309  2007/02/05 09:40:03  lulin
// - две функции объединены в одну.
//
// Revision 1.308  2007/02/02 13:23:48  lulin
// - упрощаем преобразование строк.
//
// Revision 1.307  2007/01/29 13:33:42  lulin
// - cleanup.
//
// Revision 1.306  2007/01/20 18:46:01  lulin
// - запрещаем модифицировать константы.
//
// Revision 1.305  2007/01/18 12:57:11  mmorozov
// - new: Простое основное меню (CQ: OIT5-23939);
//
// Revision 1.304  2007/01/12 08:07:28  oman
// - fix: Прячем операцию "Поиск с Правовой поддержкой" (cq24101) - merge
//
// Revision 1.303  2007/01/10 13:49:46  oman
// - fix: Текст сообщения (cq24061)
//
// Revision 1.302  2007/01/05 16:32:24  lulin
// - cleanup.
//
// Revision 1.301  2006/12/22 15:06:16  lulin
// - текст ноды - теперь структура с длиной и кодовой страницей.
//
// Revision 1.300  2006/12/14 15:47:07  demon
// - new: при вызове GblAdapterInit отработано исключение ENoMoreConnections
//
// Revision 1.299  2006/12/06 12:25:13  oman
// - fix: Централизованно ловим исключение о слишком больших
//  колонтитулах - текст сообщения (cq23103)
//
// Revision 1.298  2006/12/04 13:47:33  oman
// - fix: Централизованно ловим исключение о слишком больших
//  колонтитулах (cq23103)
//
// Revision 1.297  2006/11/16 14:29:40  mmorozov
// MERGE WITH B_NEMESIS_6_4 (new: обновление заголовка окна при переключении базы (CQ: OIT5-23663));
//
// Revision 1.296  2006/11/13 15:13:53  mmorozov
// - MERGE WITH 6_4 (- new: возможность задания иконки для диалога длительного процесса; для инициализации диалога выделен отдельный интерфейс (CQ: OIT5-23597));
//
// Revision 1.295  2006/11/07 14:28:29  oman
// Merge from B_NEMESIS_6_4
//
// Revision 1.294  2006/11/03 09:42:44  oman
// Merge with B_NEMESIS_6_4_0
//
// Revision 1.293.2.4.2.1  2006/11/07 14:22:40  oman
// - fix: Потенциальная утечка
//
// Revision 1.293.2.4  2006/10/25 10:01:12  mmorozov
// - new behaviour: не кешируем значение HasChild на _TnsINodeWrap, всегда спрашиваем значение у адаптерной ноды;
//
// Revision 1.293.2.3  2006/10/24 08:12:24  oman
// - new: Локализация заголовка приложения (cq23159)
//
// Revision 1.293.2.2  2006/10/23 13:55:48  oman
// - fix: Экспорт списка в XML не только для внутренней версии (cq23149)
//
// Revision 1.293.2.1  2006/10/18 12:17:10  oman
// - Передаем локаль в адаптер
//
// Revision 1.293  2006/10/03 13:29:28  mmorozov
// - new: сообщаем пользовалю об отключенном доступе к консультациям (CQ: OIT500022637);
//
// Revision 1.292  2006/09/27 13:42:27  mmorozov
// В рамках работы над CQ: OIT500022679.
//
// - remove: TTagSearch, TTagSearchList, TAvailableTags. В списки были не работоспособны, в единственном месте где списки использовались, можно было обойтись _IAttributeInfo;
// - remove: неиспользуемые операции в enSelectedAttributesForm (enSelectedList: opAdd, opDelete, opChangeOperation);
// - new: TnsTaggedTreeInfo наделен логикой;
//
// Revision 1.291  2006/09/22 09:40:45  mmorozov
// - new: использование интерфейсов адаптера в рамках работы над журналом работы пользователя;
//
// Revision 1.290  2006/07/28 14:23:49  mmorozov
// - new: обработка открытия запросов из папки "Исходящие запросы";
// - new: обработка нотификации при отправке консультаций (не прошла валидацию, нет связи с сервером);
//
// Revision 1.289  2006/07/18 11:59:08  mmorozov
// - new: реакция оболочки на установку значений по умолчанию (CQ: OIT500021888);
//
// Revision 1.288  2006/07/14 14:53:00  mmorozov
// - new: установка настройк по умолчанию;
//
// Revision 1.287  2006/06/29 11:56:28  mmorozov
// - change: изменения в связи с поялением типа GblAdapter.TDateTime;
//
// Revision 1.286  2006/06/22 13:06:18  mmorozov
// - change: вернул использование CheckConsulatationAvailable, т.к. оказалось, что вызов не идет дальше хранилища;
// - небольшой рефакторинг (появились методы DefDataAdapter: HasSearchMachine, HasConsultations; "Логические поля" типа Integer заменены на Tl3Bool; выделена процедура для определения наличия тага, тем самым процедуры IsExists... стали легче);
//
// Revision 1.285  2006/05/22 10:15:30  dinishev
// Cleanup
//
// Revision 1.284  2006/05/18 13:48:10  oman
// - fix: afw.application._IsInternal может поменятся в любой момент =>
//  кэшировать его нельзя
//
// Revision 1.283  2006/05/12 10:40:08  oman
// - fix: Утечка адаптерных интерфейсов при выходе по отключению от сервера
//
// Revision 1.282  2006/05/12 07:14:29  mmorozov
// - изменения накопившиеся за время отсутствия CVS;
//
// Revision 1.281  2006/05/06 14:13:57  lulin
// - разрешена опция "Искать в выделенном". Пока не работает.
//
// Revision 1.280  2006/05/06 11:59:10  oman
// - new beh: Поддержка начала библиотеки интеграции со стороны
//  оболочки (cq20796)
//
// Revision 1.279  2006/04/21 10:16:34  mmorozov
// - new: идентификаторы тегов запроса;
//
// Revision 1.278  2006/04/18 08:21:47  oman
// - new beh: перекладываем StdStr в _StdRes
//
// Revision 1.277  2006/04/17 12:08:51  oman
// - change: Избавляем бизнес-объекты (слой модели) от обязательств
//  контроллера (хинты, imageindex)
// - new beh: перекладываем StdStr в _StdRes
//
// Revision 1.276  2006/04/05 13:48:47  dinishev
// Проверка на наличие консультаций
//
// Revision 1.275  2006/03/31 09:55:42  lulin
// - bug fix: форма поиска закрывала найденный фрагмент.
// - new behavior: не показываем кнопку показа дополнительных параметров, если используется поиск по релевантности.
//
// Revision 1.274  2006/03/30 11:49:23  lulin
// - cleanup: вытираем код для редактирования комментариев не в виде дерева.
//
// Revision 1.273  2006/03/20 15:12:14  dinishev
// Проверка необходимости создания папки в журнале для новой КЗ
//
// Revision 1.272  2006/03/16 15:05:35  oman
// - new beh: Перекладываем все текстовые константы в три места (StdStr, DebugStr и SystemStr)
//
// Revision 1.271  2005/12/12 16:16:50  demon
// - new behavior: обработан exception EShutdownInited
//
// Revision 1.270  2005/12/07 15:09:42  demon
// - fix: logout происходил раньше, чем отпускались другие интерфейсы адаптера
//
// Revision 1.269  2005/11/25 13:50:52  demon
// - new behavior: в журнале создаем папки только для тех поисков, атрибуты которых реально есть в базе
//
// Revision 1.268  2005/11/22 10:20:12  demon
// - new behavior: удалена старая нотификация об обновлении списка пользователей и все сопутствующие ей операции перечитывания этого дерева
//
// Revision 1.267  2005/11/18 14:16:18  oman
// - new behavior: избавление от старых интерфейсов IUserManager, IPublicProfile
//
// Revision 1.266  2005/10/14 15:03:19  demon
// - fix: при авторегистрации простому пользователю могли дать права администрирования
//
// Revision 1.265  2005/10/12 09:27:40  demon
// - new behavior: переименованы корреспонденты/респонденты в сообщениях
//
// Revision 1.264  2005/10/12 06:25:38  demon
// - fix: rename const
//
// Revision 1.263  2005/10/11 16:31:43  demon
// - new behavior: изменено сообщение при достижении Лимта соединений с сервером
//
// Revision 1.262  2005/10/04 13:57:33  demon
// - new behavior: новый заголовок окна для версии с морфологией
//
// Revision 1.261  2005/10/04 13:26:46  demon
// - new behavior: перевели реализацию на IEntityBase
//
// Revision 1.260  2005/09/26 10:11:45  demon
// - new property: IsMorfoIndexExist
//
// Revision 1.259  2005/09/22 13:49:20  migel
// - fix: выдаем ошибку защиты, если поврежден `*.org` файл, а не сообщение о том, что ознакомительная версия проэкспарилась.
//
// Revision 1.258  2005/09/22 08:12:41  lulin
// - убрана ненужная переменная.
//
// Revision 1.257  2005/09/22 08:06:31  lulin
// - поправлена грамматика.
//
// Revision 1.256  2005/09/22 07:55:44  lulin
// - при определении возможности печати учитываем триальный режим или нет.
//
// Revision 1.255  2005/09/21 14:10:38  migel
// - new: обрабатываем исключение об окончании триального срока.
//
// Revision 1.254  2005/09/21 11:38:06  migel
// - new: свойство, показывающее, что мы работаем с ознакомительной версией.
//
// Revision 1.253  2005/09/21 11:17:53  migel
// - change: кешируем информацию об оставшемся триальном периоде.
//
// Revision 1.252  2005/09/21 08:34:55  dolgop
// - change: изменения, связанные с появлением IString в Settings
//
// Revision 1.251  2005/09/16 09:12:45  demon
// - new behavior: overload операция _GetMissingBlocksForCR
//
// Revision 1.250  2005/09/13 15:09:48  lulin
// - по умолчанию получаем документ в виде дерева.
// - попытался прикрутить позиционирование на Sub из оглавления - не получилось - завтра продолжу.
//
// Revision 1.249  2005/09/02 12:35:27  demon
// - new behavior: Отработана нотификация о Logout'е
//
// Revision 1.248  2005/08/29 16:05:51  demon
// - new behavior: Операция Open на ноде теперь возвращает _IUnknown
//
// Revision 1.247  2005/08/26 09:52:20  mmorozov
// change: TnsLanguage стал TbsLanguage и переехал в bsTypes;
//
// Revision 1.246  2005/08/26 07:44:49  mmorozov
// bugfix: оказалось, что GetMissingBlocksByType может вернуть пустой список;
//
// Revision 1.245  2005/08/23 11:35:49  migel
// - fix: синхронизация запуска нескольких копий.
//
// Revision 1.244  2005/08/22 11:24:17  mmorozov
// change: _GetMissingBlocksForCR возвращает список строк;
//
// Revision 1.243  2005/08/18 16:17:26  demon
// - formating
//
// Revision 1.242  2005/08/18 15:00:23  demon
// - new behavior: Разрешен вод в систему под логином ADMIN
//
// Revision 1.241  2005/08/16 13:28:28  demon
// - new behavior: обработана нотификация об изменении списка пользователей
//
// Revision 1.240  2005/08/16 08:16:09  demon
// - new behavior: получаем дерево пользователей с адаптера
//
// Revision 1.239  2005/08/10 16:15:07  demon
// - new behavior: операция получения списка отсутствующих блоков для предупреждений в СКР
//
// Revision 1.238  2005/08/08 16:09:13  demon
// - new: типы для пользовательских вкладок в документе
//
// Revision 1.237  2005/08/05 13:24:09  mmorozov
// new: property Monitoring;
//
// Revision 1.236  2005/08/04 13:50:00  mmorozov
// - _format code;
//
// Revision 1.235  2005/08/04 08:48:15  demon
// - new message: Обработан exception EBadSMTPReply
//
// Revision 1.234  2005/07/29 16:05:59  mmorozov
// new: method IsExistTag;
//
// Revision 1.233  2005/07/19 07:09:06  demon
// - change message text: Сообщение о недоступности сервера приложений
//
// Revision 1.232  2005/07/18 08:33:03  lulin
// - раскомментирован код, проверяющий версию адаптера.
//
// Revision 1.231  2005/07/11 06:08:38  lulin
// - упорядочены названия интерфейсов.
//
// Revision 1.230  2005/06/30 07:48:03  cyberz
// READY FOR TIE-TEMPLATE GENERATION
//
// Revision 1.229  2005/06/23 16:14:02  mmorozov
// bugfix: обращение к неинициализированной переменной;
//
// Revision 1.228  2005/06/23 15:47:53  lulin
// - new behavior: сделана возможность указывать, что хотим получать документы в виде деревьев.
//
// Revision 1.227  2005/06/06 12:09:15  demon
// - new behavior: оптимизирован код присвоения нотификаторов
//
// Revision 1.226  2005/06/03 14:08:28  demon
// - new behavior: Нотификаторы об обновлении, смерти сервера присваиваются еще до инициализации адаптера.
//
// Revision 1.225  2005/06/02 07:42:21  mmorozov
// - _format code;
//
// Revision 1.224  2005/05/16 11:58:08  demon
// - new behavior: выделен метод ShowMessageWithDealerInfo для вывода сообщений с информацией о диллере
// - fix: AV в методе _AbnormalTermination. если g_Dispatcher = nil
//
// Revision 1.223  2005/05/14 10:35:19  migel
// - change: показываем сообщение об импорте настроек только после третьего раза, как нас "отшили".
//
// Revision 1.222  2005/05/14 10:25:32  migel
// - change: показываем сообщение об импорте настроек только после второго раза, как нас "отшили".
//
// Revision 1.221  2005/05/14 08:30:08  demon
// - sintax fix: упрощено возвращение булевского результата.
//
// Revision 1.220  2005/05/12 09:30:58  demon
// - new: несколько комментариев к не прозрачному коду.
//
// Revision 1.219  2005/05/11 14:06:52  demon
// - fix: при обновлении делаем ресет закэшированной даты ревизии базы
//
// Revision 1.218  2005/05/04 13:29:36  migel
// - fix: обработка параметров коммандной строки `-F1ShellLogin` и `-F1ShellPassword`.
//
// Revision 1.217  2005/04/27 08:47:31  migel
// - change: алгоритм "дерганья" сервера, когда идет операция импорта настроек из XML (сначала ждем 1 секунду, потом 2 ... и так увеличиваем интервал ожидания до 30 секунд).
//
// Revision 1.216  2005/04/20 07:35:52  migel
// - fix: если получили исключение `EXMLImportRunning` все таки в логине - выводим сообщение, а не просто "молча" заканчиваем работу.
//
// Revision 1.215  2005/04/19 15:42:30  lulin
// - переходим на "правильный" ProcessMessages.
//
// Revision 1.214  2005/04/18 16:28:45  migel
// - fix: перенесли показ диалога о конвертации настроек с вызова логина на получение интерфейса авторизации.
//
// Revision 1.213  2005/04/18 15:17:41  migel
// - change: перенесли показ диалога о конвертации настроек с вызова логина на получение интерфейса авторизации.
// - change: `f_Autorization` -> `_f_Authorization`.
//
// Revision 1.212  2005/04/18 14:11:27  migel
// - fix: нашли еще места, где вместо сообщения при конвертации настроек на сервере показываем диалог с прогрессбаром (CQ:13424).
//
// Revision 1.211  2005/04/18 09:21:24  migel
// - fix: "дергаем" адаптер 1 раз в 30 секунд, чтобы узнать не прекратился ли процесс импорта пользователей из XML.
//
// Revision 1.210  2005/04/14 12:42:38  migel
// - change: вместо сообщения при конвертации настроек на сервере показываем диалог с прогрессбаром (CQ:13424).
//
// Revision 1.209  2005/04/11 13:11:19  migel
// - change: синхронизация при "быстром" запуске нескольких копий оболочки (CQ12897).
//
// Revision 1.208  2005/04/11 12:08:04  dinishev
// Обернул в скобки {IFNDEF Monitorings} часть кода в _GlobalInit, в частности показ сплеша.
//
// Revision 1.207  2005/04/11 06:59:38  mmorozov
// new: обработка исключения при иннициализации адаптера (ESettingsRestoreFails);
//
// Revision 1.206  2005/04/08 14:43:05  demon
// - new behavior: обработан exception при авторизации XMLImportRunning
//
// Revision 1.205  2005/04/07 10:55:08  migel
// - change: не позволяем запускать вторую копию оболочки, если из-под первой копии мы запустили утилиту работы с данными и стоим перед логин диалогом.
//
// Revision 1.204  2005/04/07 10:35:02  demon
// - new behavior: обработана нотификация об изменении Prdefined_Data
//
// Revision 1.203  2005/04/06 13:55:09  migel
// - change: не даем одновременно запускать утилиту мониторингов и оболочку.
//
// Revision 1.202  2005/03/28 11:39:36  demon
// - cleanup (remove warnings)
//
// Revision 1.201  2005/03/25 13:31:19  demon
// - new behavior: получение NotifyManager и регистрация OnLongProcessNotifier
//
// Revision 1.200  2005/03/24 13:39:25  mmorozov
// new: использование функций модуля nsVerifyValue;
//
// Revision 1.199  2005/03/23 17:34:19  dinishev
// Попытка уменьшения размера кода с помощью директивы Monitorings.
//
// Revision 1.198  2005/03/22 15:15:06  dinishev
// Борьба с попыткой запросить пароль при максимальном числе пользователей.
//
// Revision 1.197  2005/03/21 17:31:43  dinishev
// Обработка типа комплекта.
//
// Revision 1.196  2005/03/21 16:49:43  dinishev
// Новый модуль nsLoginUtils
//
// Revision 1.195  2005/03/18 13:58:10  am
// new: _TnsStartupSupport.IsAnotherCopyRunning - проверка на существование другой запущенной копии
// change: если в процессе инициализации обнаруживается другая запущенная копия - выходим
//
// Revision 1.194  2005/03/17 15:22:08  dinishev
// Подправлена работа с паролем
//
// Revision 1.193  2005/03/17 12:24:34  am
// change: кешируем IsMonitoringsAvailable
//
// Revision 1.192  2005/03/11 12:42:52  mmorozov
// new: список реквизитов с метаинформацией для "Заказа рассылки";
//
// Revision 1.191  2005/03/09 10:44:47  demon
// - new behavior: смаппировано исключение EStorageLocked при GblAdapterInit.
//
// Revision 1.190  2005/03/04 13:54:12  demon
// - new behavior: обработано исключение о неправильной версии сервера.
//
// Revision 1.189  2005/03/04 13:36:26  am
// bugfix: по приходу обновления не сбрасывалась дата базы
//
// Revision 1.188  2005/03/02 14:18:57  demon
// - new behavior: используем реальный вызов метода проверки наличия мониторингов
//
// Revision 1.187  2005/03/02 11:31:22  demon
// - new behavior: обработано исключение ENoMoreConnections при авторегистрации
//
// Revision 1.186  2005/02/28 09:34:00  demon
// - new behavior: При создании пустого _IQuery на адаптере нужно указывать его тип
// - new behavior: поле _IQuery.Type стало readonly
//
// Revision 1.185  2005/02/25 15:17:00  demon
// - new behavior: написана реализация показа списка дат "Моя новостная лента", исходя из ТЗ на интерфейсы адаптера (пока не отлажено, т.к. интерфейсов нет)
//
// Revision 1.184  2005/02/24 15:52:22  am
// bugfix: автологин с пустым паролем не проходил
//
// Revision 1.183  2005/02/24 11:03:25  am
// change: вкрутил галку "запомнить пароль"
//
// Revision 1.182  2005/02/21 12:32:07  demon
// - new behavior: свойство на defDataAdapter - IsMonitoringsAvailable, доступность работы с мониторингами.
//
// Revision 1.181  2005/02/17 15:41:15  demon
// - new behavior: расширена область обработки параметра PureInitialization в методе _GlobalInit
//
// Revision 1.180  2005/02/17 12:24:53  am
// change: перенёс присвоение "ранних" нотифаеров после проверки параметров запуска (и соотв. запуска из оболочки бридера и т.д.)
//
// Revision 1.179  2005/02/17 10:16:40  demon
// - new behavior: обработаны исключения LicenceViolation и InternalApplicationError для метода GblAdapterInit
//
// Revision 1.178  2005/02/16 17:07:43  demon
// - fix: сравнение ClassName заменено на приведение классов (Is) при обработке глобальных exception'ов
//
// Revision 1.177  2005/02/14 13:52:50  migel
// - fix: вторая копия оболочки некорректно завершала работу, если первая копия в этот момент медленно выгружалась (проявляется на медленной машине с небольшим объемом ОЗУ).
//
// Revision 1.176  2005/02/11 14:34:08  am
// change: InitEarlyNotifiers - установка нотифаеров до процесса логина
//
// Revision 1.175  2005/02/03 11:28:58  demon
// - new behavior: обработан exception о сбое в работе сервера.
//
// Revision 1.174  2005/01/28 13:02:49  fireton
// - add: вкручиваем обработку исключения XercesAdapterNotFound
//
// Revision 1.173  2005/01/26 13:48:59  demon
// - new behavior: в операцию _DocumentCacheSinchronize добавлена возможность передачи типа закладки
//
// Revision 1.172  2005/01/26 12:35:42  lulin
// - в нотификацию о добавлении Sub'а добавлена обработка флагов.
//
// Revision 1.171  2005/01/20 12:49:44  am
// change: перетащил GlobalExceptionRaised в public
// bugfix: в _AbnormalTermination _GetDealerInfo может поднимать exception
//
// Revision 1.170  2005/01/19 15:04:13  migel
// - new: поддержка для однопользовательского рабочего CD/DVD (спец. заказа от Шаманова).
//
// Revision 1.169  2005/01/18 15:35:48  migel
// - fix: ошибка при повторном запуске оболочки, когда первая копия находиться в диалоге ввода логина/пароля.
// - fix: убрали некоторые предупреждения и хинты компилятора.
//
// Revision 1.168  2005/01/18 10:54:37  fireton
// - добавляем исключение WorkingParamsNotFound
//
// Revision 1.167  2005/01/17 13:45:28  fireton
// - add: добавляем реакцию оболочки на ошибки при обновлении
//
// Revision 1.166  2004/12/11 17:30:07  lulin
// - управление Print-preview теперь живет на контейнере.
//
// Revision 1.165  2004/12/08 09:16:42  migel
// - fix: не всегда срабатывал код, проверяющий, что нажата клавиша `SHIFT`.
//
// Revision 1.164  2004/12/01 12:19:37  demon
// - new behavior: операция IStringToString
//
// Revision 1.163  2004/11/30 12:24:39  migel
// - remove: неиспользуемая переменная.
//
// Revision 1.162  2004/11/30 12:17:26  migel
// - fix: проверяем (дополнительно) ошибки защиты при возникновении исключений, связанных с лицензионными настройками.
//
// Revision 1.161  2004/11/25 15:03:44  am
// bugfix: обработка EStorageLocked при автологине
//
// Revision 1.160  2004/11/24 11:06:43  am
// change: поменялась семантика TLoginForm.Create
//
// Revision 1.159  2004/11/23 15:04:08  demon
// - new behavior: на клиенте обработан exception ENoMoreProfiles
//
// Revision 1.158  2004/11/18 10:54:15  am
// change: по приходу EStorageLocked подымаем информационное сообщение и закрываем приложение
//
// Revision 1.157  2004/11/17 13:52:13  am
// change: формы логина\регистрации\высылки забытого пароля переехали на vcm.
// bugfix: при последовательности действий: форма логина -> новый пользователь -> выход с нажатием Cancel - имели AV
//
// Revision 1.156  2004/11/15 12:05:38  migel
// - fix: завершаем работу приложения, если обнаружено нарушение ошибок защиты.
//
// Revision 1.155  2004/11/12 14:53:00  am
// change: если при вызове _GetDealerInfo в обработке exception'а ( GlobalExceptionRaised) происходит исключение - гасим его. Вместо DealerInfo выводим пустую строку.
//
// Revision 1.154  2004/11/09 14:43:50  am
// change: без автологина не читаем пароль пользователя из реестра и не показываем его в окошке логина
// change: если при выходе из приложения автологин выключен - чистим пароль пользователя в реестре
//
// Revision 1.153  2004/11/02 14:59:38  zakharov
// added shutdown notifier
//
// Revision 1.152  2004/11/01 14:39:52  fireton
// - bug fix: после регистрации нового пользователя фокус уходил в никуда
//
// Revision 1.151  2004/10/28 14:54:01  fireton
// - change: скрытие floating окон при показе сообщений перенесено в
//        _vcmMessageDlg (vcmForm)
//
// Revision 1.150  2004/10/28 14:40:05  fireton
// - bug fix: сообщения об ошибках теперь скрывают все floating формы
//             чтобы они не заслоняли само сообщение
//
// Revision 1.149  2004/10/28 09:49:57  migel
// - change: рассширенная обработка ошибок защиты.
//
// Revision 1.148  2004/10/25 14:12:06  demon
// - new behavior: при попытке получения пароля по почте обрабатываем exception'ы.
//
// Revision 1.147  2004/10/21 16:28:41  am
// change: перетащил IsExists_PublishSourceTag, IsExists_KeyWordTag из moSearch на DataAdapter, чтобы иметь возможность сбрасывать их во время обновления. Также сбрасываются набранные тэги (AvailableTags)
//
// Revision 1.146  2004/10/20 13:02:19  am
// new: g_MenuTypeCache - признаки того, что ветки рубрикатора в меню уже набраны. Сбрасывается при обновлении.
//
// Revision 1.145  2004/10/20 13:01:54  am
// new: g_MenuTypeCache - признаки того, что ветки рубрикатора в меню уже набраны. Сбрасывается при обновлении.
//
// Revision 1.144  2004/10/19 15:19:39  am
// change: деревья корр\респ. набираются, когда спрашивается рут
//
// Revision 1.143  2004/10/14 13:49:27  demon
// - new behavior: отработана нотификация о добавлении закладки.
//
// Revision 1.142  2004/10/14 11:06:43  demon
// - new behavior: _DocumentCacheSinchronize - операция синхронизации кэша документов с изменениями в папках (пока отработано удаление закладки)
//
// Revision 1.141  2004/10/13 18:54:22  demon
// - new behavior: вывод зашитого в базе предупреждения об отсутствующем документе.
//
// Revision 1.140  2004/10/12 11:54:57  mmorozov
// change: при выводе информации о дилере удаляем управляющие символы и ставим точку;
//
// Revision 1.139  2004/10/12 10:33:47  migel
// - change: название ветки реестра `Garant-Nemesis` -> `Garant.F1`.
//
// Revision 1.138  2004/10/12 10:12:51  mmorozov
// change: в err_NotHandledException добавился параметр;
//
// Revision 1.137  2004/10/11 13:00:32  migel
// - change: "переезжаем" на новые имена файлов.
// - fix: не происходила отрисовка лого, если нет сплеша и мы показывали лого снова.
//
// Revision 1.136  2004/10/08 15:55:30  demon
// - new behavior: переделана работа с документом (состояния) и Машиной времени (она стала глобальной)
//
// Revision 1.135  2004/09/30 14:17:08  demon
// - new behavior: в списке пользователей при авторегистрации убран Новый пользователь.
//
// Revision 1.134  2004/09/27 12:13:16  migel
// - add: реализация метода для получения информации о дилере.
//
// Revision 1.133  2004/09/24 09:41:57  demon
// - new behavior: обработано исключение EInvalidBase
//
// Revision 1.132  2004/09/20 12:46:53  fireton
// - bug fix: не переключалась раскладка на Win98
//
// Revision 1.131  2004/09/17 09:22:24  mmorozov
// remove: g_Common;
//
// Revision 1.130  2004/09/17 07:32:51  am
// change: чистка
//
// Revision 1.129  2004/09/14 09:50:12  am
// change: вычистил ExplanatoryList
//
// Revision 1.128  2004/09/14 08:15:01  am
// bugfix: упушенный not в RememberPassword
//
// Revision 1.127  2004/09/10 13:58:03  demon
// - fix: удалены избыточные сообщения
//
// Revision 1.126  2004/09/09 12:46:29  demon
// - fix: при экспорте профиля пользователя "Administrator" даем имя = имени текущего пользователя Windows
//
// Revision 1.125  2004/09/07 16:22:02  law
// - перевел Nemesis на кешированные обьекты.
//
// Revision 1.124  2004/09/07 13:17:48  demon
// - fix: изменено имя пользователя при авторегистрации при отсутствии старых профилей
//
// Revision 1.123  2004/09/03 11:50:42  demon
// - cleanup: remove Warnings
//
// Revision 1.122  2004/08/31 11:59:39  am
// change: чистка старых интерфейсов
//
// Revision 1.121  2004/08/30 06:02:58  demon
// - new behavior: запрет регистрации в системе под логином ADMIN
//
// Revision 1.120  2004/08/27 14:36:33  demon
// - fix: при обработке exceptionэов о неправильной конфигурации IP сразу "гасим" (terminate) приложение
//
// Revision 1.119  2004/08/26 14:16:52  demon
// - new behavior: обработаны исключения при неправильной конфигурации сетевых соединений.
//
// Revision 1.118  2004/08/12 14:23:52  am
// change: если сплеша нет - показываем лого (косвенным образом это помогает избавиться от CQ8755)
//
// Revision 1.117  2004/08/11 13:56:27  demon
// - fix: не обрабатывался ELicenceViolation при авторегистрации
//
// Revision 1.116  2004/08/03 12:33:21  migel
// - fix: ошибка в алгоритме шифрования пароля (теперь этот алгоритм совместим с аналогичным алгоритмом, который будет использоваться в сервере).
//
// Revision 1.115  2004/08/03 10:14:14  migel
// - fix: делаем `FreeLibrary` через `ExitProc` механизм, а не через секцию финализации.
//
// Revision 1.114  2004/07/29 13:30:25  demon
// - fix: при отсутствии старых пользователей показывался список
//
// Revision 1.113  2004/07/29 13:08:58  demon
// - fix: если из реестра вытерли login и/или пароль то автологин даже не  пытается запускаться
//
// Revision 1.112  2004/07/28 12:48:27  demon
// - new behavior: автоматический запуск регистрации при первом старте системы (для desktop - полная автоматика)
//
// Revision 1.111  2004/07/27 13:45:55  demon
// - new behavior: форма авторегистрации может расширяться деревом старых профилей Гарант.
// - fix: AV при выходе, если нет сервера.
// - fix: не гасился Logo при запуске breeder'а и ошибках.
//
// Revision 1.110  2004/07/26 15:02:00  law
// - используем AddExitProc из l3.
//
// Revision 1.109  2004/07/26 09:33:39  am
// change: новые деревья типизированных корр\респ.
//
// Revision 1.108  2004/07/23 08:39:44  mmorozov
// change: GetTagSearchFromName to FindTag;
//
// Revision 1.107  2004/07/22 13:53:53  nikitin75
// переход на новые деревья типизации респондентов/корреспондентов
//
// Revision 1.106  2004/07/22 10:01:30  mmorozov
// new behaviour: установка идентификатора пользователя при загрузке системы обрамлено дефайном "nsSing1";
//
// Revision 1.105  2004/07/22 09:31:52  mmorozov
// new: TDataAdapter properties (AttributeSearchList, PublishSourceSearchList, SituationSearchList, AvailableTags);
// new: method TDataAdapter.GetAttributeSearch;
// change: вычитываем списки поисковых атрибутов по первому требованию (не при загрузке системы);
//
// Revision 1.104  2004/07/18 01:27:32  migel
// - change: переименовали `FreeInstance` в `DestroyInstance` (по совету Шуры).
//
// Revision 1.103  2004/07/15 10:54:08  demon
// - new behavior: При старте приложения сразу запускаем Logo
//
// Revision 1.102  2004/07/10 16:19:36  migel
// - new: деинициализируем адаптер, если во время работы оболочки пользователь перегрузил систему.
//
// Revision 1.101  2004/07/05 08:52:12  demon
// - new: обработан exception NoServer
//
// Revision 1.100  2004/06/29 08:29:27  nikitin75
// +get_folders may throw FoldersNotAvailable
//
// Revision 1.99  2004/06/10 14:28:41  mmorozov
// new: если не установлено ни одной конфигурации, то приложение закрывается;
//
// Revision 1.98  2004/05/26 10:37:50  demon
// - new behavior: Обработано исключение возникающее при аварийном закрытии сервера.
//
// Revision 1.97  2004/05/24 10:06:52  demon
// - new behavior: обработаны нарушения лицензионных настроек при логине.
//
// Revision 1.96  2004/05/17 09:48:00  law
// no message
//
// Revision 1.95  2004/04/30 15:47:49  law
// - new directive.
//
// Revision 1.94  2004/04/30 08:25:12  mmorozov
// new: property TDataAdapter.CurrentUserID;
//
// Revision 1.93  2004/04/28 11:00:07  demon
// - fix: динамическая загрузка FlashWindowEx (для совместимости с NT)
//
// Revision 1.92  2004/04/28 08:13:14  demon
// - new define: nsAutoLoginDisable, для полного отключения использования Автологина, Авторегистрации и запоминания пароля в реестре (для Экстранет-версии).
//
// Revision 1.91  2004/04/26 11:45:02  demon
// - new behavior: проверка при старте версии Dll GblAdapter.
//
// Revision 1.90  2004/04/23 12:29:00  dk3
// add Dynamic Load of GblAdapter
//
// Revision 1.89  2004/04/22 10:58:34  demon
// - fix: Перестали сохранять старый обработчик Application.OnException, т.к. обработчик в библиотеке m0exclib работает некорректно и сбрасывает наш обработчик
// - new: запись exception в лог
//
// Revision 1.88  2004/04/22 08:54:38  demon
// - new behavior: обработаны исключения при отсутствии библиотеки GblAdapter.
//
// Revision 1.87  2004/04/21 12:44:42  demon
// - fix: запоминаем старый обработчик Application.OnException и вызываем его перед своей обработкой.
//
// Revision 1.86  2004/04/21 12:02:03  demon
// - new: Перекрыто событие Application.OnException (сейчас там выводится сообщение с некоторым количеством дополнительной информации)
//
// Revision 1.85  2004/04/21 07:11:45  nikitin75
// вызов финального splash'а перенесен в GlobalDone;
//
// Revision 1.84  2004/04/12 09:33:16  demon
// - new: вместо полуения даты версии из Машины времени используем прямой вызов адаптера
//
// Revision 1.83  2004/04/09 13:51:43  demon
// - new: свойство TimeMachine заменено на CurrentBaseDate
//
// Revision 1.82  2004/04/05 13:54:16  nikitin75
// - переходим на IStringOld;
//
// Revision 1.81  2004/04/05 08:43:05  demon
// - fix: лишний вызов GlobalDone при отказе от процедуры Логин.
//
// Revision 1.80  2004/03/29 17:28:07  am
// new: property TDataAdapter.IsExplanatoryExists;
//
// Revision 1.79  2004/03/22 13:28:32  migel
// - fix: сбрасываем дерево, типизирующее респондентов/корреспондентов, при получении нотификации об обновлении.
//
// Revision 1.78  2004/03/22 13:26:40  demon
// - _move: объекты TTagSearch и TTagSearchList перенесены в nsSearchClasses
//
// Revision 1.77  2004/03/12 12:02:03  demon
// - cleanup
//
// Revision 1.76  2004/03/09 15:07:55  demon
// - new: функция GetOldBaseWarning
//
// Revision 1.75  2004/03/03 10:25:01  demon
// - fix: не правильно работало свойство IsDesktop
//
// Revision 1.74  2004/02/26 18:26:48  migel
// - fix: некорректно устанавливались значения по умолчанию, при чтении строк из реестра.
//
// Revision 1.73  2004/02/26 16:28:46  law
// - new behavior: освобождаем f_ControlMgr.
//
// Revision 1.72  2004/02/25 15:26:10  am
// change: getRubricator.
//
// Revision 1.71  2004/02/25 15:16:28  am
// new: свойство Rubricator.
//
// Revision 1.70  2004/02/25 12:32:54  demon
// - new: добавлен объект реализующий прием нотификации об Обновлении.
//
// Revision 1.69  2004/02/24 11:51:33  migel
// - new: первая реализация запуска утилит обновляющих базу из под однопользовательской оболочки.
//
// Revision 1.68  2004/02/20 13:24:15  am
// change: убраны группы из настроек.
//
// Revision 1.67  2004/02/20 10:16:28  nikitin75
// + err_UnexpectedError: "Неожиданная ошибка";
//
// Revision 1.66  2004/02/20 09:31:39  nikitin75
// + обновлена логика показа login-форм (_MessageDlg показывем ДО отдачи ModalResult);
// + добавлены префиксы;
//
// Revision 1.65  2004/02/20 08:36:33  demon
// - new: DataAdapter.ExplanatoryList[Language];
//
// Revision 1.64  2004/02/19 18:34:46  demon
// - fix: TLang переименован в TnsLanguage & Remove лишние операции преобразования типов
//
// Revision 1.63  2004/02/19 16:42:51  nikitin75
// + login/autoregistration/rememberpassword loop;
//
// Revision 1.62  2004/02/19 13:39:39  demon
// - new behavior: установлен нотификатор для обновления папок
//
// Revision 1.61  2004/02/19 12:08:01  nikitin75
// + поднимаем splash сразу после login'а;
// + default login;
//
// Revision 1.60  2004/02/18 14:38:44  nikitin75
// + в первом приближении добавлена регистрация нового пользователя;
//
// Revision 1.59  2004/02/18 09:38:45  nikitin75
// + убиваем форму с заставкой перед логином;
//
// Revision 1.58  2004/02/17 14:36:26  migel
// - change: новый диалог логина.
//
// Revision 1.57  2004/02/17 12:57:55  demon
// - new: подключен нотификатор об изменении содержимого папок (временно не работает см <!!!>)
//
// Revision 1.56  2004/02/17 10:23:19  am
// new: настройки.
//
// Revision 1.55  2004/02/11 13:38:52  demon
// - new: свойство ControlMgr
//
// Revision 1.54  2004/02/11 12:51:25  nikitin75
// + читаем из настроек надо ли активизировать на старте "язык по-умолчанию";
//
// Revision 1.53  2004/02/11 12:40:08  migel
// - add: новые настройка `Aктивировать язык по умолчанию`.
// - change: настройка `Язык по умолчанию` перенесена в группу `Локализация`.
//
// Revision 1.52  2004/02/11 10:35:34  am
// *** empty log message ***
//
// Revision 1.51  2004/02/11 10:33:56  am
// change: DataAdapter.DefaultLang -> DataAdapter.DocDefaultLang
//
// Revision 1.50  2004/02/11 10:19:21  nikitin75
// + активизируем на старте "язык по-умолчанию";
//
// Revision 1.49  2004/02/09 15:18:08  am
// *** empty log message ***
//
// Revision 1.48  2004/02/09 15:04:28  am
// new: Словарь толкований
//
// Revision 1.47  2004/02/09 13:46:16  demon
// - new: операция инициализации нотификаторов (пока только для "На контроле")
//
// Revision 1.46  2004/01/28 12:27:36  law
// - change: переходим от строк к идентификаторам.
//
// Revision 1.45  2004/01/28 09:36:47  law
// - change: изменил префиксы сообщений.
//
// Revision 1.44  2004/01/28 08:23:33  law
// - change: при использовании идентификатора сообщения берем кнопки и тип диалога у сообщения, описанного в MenuManager.
//
// Revision 1.43  2004/01/27 17:50:10  law
// - change: переходим от строк к константам.
//
// Revision 1.42  2004/01/27 14:30:55  law
// - rename proc: _MessageDlg -> _vcmMessageDlg.
//
// Revision 1.41  2004/01/27 14:11:08  law
// - change: переходим на _MessageDlg.
//
// Revision 1.40  2004/01/15 12:27:08  demon
// - new: добавлено свойство для получения интерфейса "Машины времени".
//
// Revision 1.39  2003/12/26 14:12:58  mmorozov
// new: при инициализации читаем список доступных поисковых атрибутов ( свойство TDataAdapter.TagSearchList );
//
// Revision 1.38  2003/12/17 14:36:11  dk3
// new settings
//
// Revision 1.37  2003/12/16 16:21:34  law
// - new behavior: для Desktop-версии документ генерируется "напрямую" в редактор.
//
// Revision 1.36  2003/12/15 09:34:01  migel
// - fix: не показываем заголовок окна в таскбаре, пока не загрузиться основная форма.
//
// Revision 1.35  2003/12/08 14:58:40  migel
// - fix: выбор типа СКР.
//
// Revision 1.34  2003/12/05 14:36:18  migel
// - change: дампим еще владельцев, предыдущую/следующую ноду.
//
// Revision 1.33  2003/12/04 14:46:30  migel
// - add: код для показа (дампа) информации о нодах.
//
// Revision 1.32  2003/12/03 18:04:44  migel
// - change: новый алгоритм типизации респондентов/корреспондентов.
//
// Revision 1.31  2003/11/18 16:42:02  law
// - bug fix: не освобождался список типизированных СКР.
//
// Revision 1.30  2003/11/18 13:54:11  migel
// - change: меняем кнопку респондентов/корреспондентов (пока не корректно работает, но меню уже формируется).
//
// Revision 1.29  2003/09/19 12:33:53  demon
// - add: В процедуру _GlobalInit добавлена опция для запуска сервера в тестовом режиме.
//
// Revision 1.28  2003/09/19 10:22:59  migel
// - fix: AV при нажатии `cancel` в логин диалоге (многопользовательская версия).
//
// Revision 1.27  2003/09/18 15:15:53  demon
// - new: переделан принцип авторизации (внесен отдельный метод Login)
// - new: В операцию Login добавлена обработка exception'ов авторизации.
//
// Revision 1.26  2003/09/16 13:13:37  nikitin75
// + если пользователь отменил логин: пробрасываем исключение, ловим его, завершаем приложение;
//
// Revision 1.25  2003/09/16 10:32:50  nikitin75
// используем f_Autorization.GetIsDesktop;
//
// Revision 1.24  2003/09/16 10:31:11  nikitin75
// + новое поведение enLoginForm;
//
// Revision 1.23  2003/09/16 08:45:31  demon
// - fix: После логина вновь не включается Splash
//
// Revision 1.22  2003/09/16 08:31:14  dk3
// - add: Login form
//
// Revision 1.21  2003/09/04 12:53:55  demon
// - fix: rkfc стал наследником от vcmBase
//
// Revision 1.20  2003/08/18 11:13:44  demon
// - new: создано свойство для работы с ISearch.
//
// Revision 1.19  2003/08/12 11:09:31  demon
// - new: Закеширован интерфейс IFolders
//
// Revision 1.18  2003/08/11 18:20:43  demon
// - new: получение интерфейса IFolders.
//
// Revision 1.17  2003/08/08 13:15:52  demon
// - bug fix
//
// Revision 1.16  2003/08/06 16:38:26  demon
// - new: получение root для папок
//
// Revision 1.15  2003/08/04 17:31:58  demon
// - new: Добавлена операция создать пустой запрос.
//
// Revision 1.14  2003/07/31 09:38:37  migel
// change user name from `ADMIN` to `DESKTOP`
//
// Revision 1.13  2003/07/30 17:14:29  demon
// - new: Добавлено свойство, возвращающее ISettings
//
// Revision 1.12  2003/07/30 15:48:50  demon
// - new: Операция получения значения настроек минуя интерфейсы ISettings и IProperty.
//
// Revision 1.11  2003/07/18 11:55:17  kool
// method chaged
//
// Revision 1.10  2003/07/16 09:54:37  demon
// - fix: во все процедуры, где в качестве параметра передавался _String добавлена декларация const.
//
// Revision 1.9  2003/07/16 09:22:43  demon
// - fix: во все процедуры, где в качестве параметра передавался интерфейс добавлена декларация const.
//
// Revision 1.8  2003/07/11 20:23:22  migel
// remark sleep delay
//
// Revision 1.7  2003/07/08 14:33:55  demon
// - new: сделал показ типизированных респондентов-корреспондентов в документе.
// - new: убрал дополнительную информацию (hasRespond и т.п.) в TextSource
//
// Revision 1.6  2003/06/24 14:45:26  demon
// - new: вынесен наружу интерфейс IAuthorization для возможности
// получения информации о комплекте.
//
// Revision 1.5  2003/06/19 09:42:36  migel
// undo of `authorization context changed`
//
// Revision 1.4  2003/06/19 09:02:45  migel
// authorization context changed
//
// Revision 1.3  2003/05/28 09:18:21  demon
// - bug fix
//
// Revision 1.2  2003/05/23 14:19:14  demon
// - new behavior: добавлены коментарии и полностью реализовано
// "начало/завершение работы с системой".
//

{$Include nsDefine.inc}

interface

uses
  Windows,
  Classes,
  Registry,
  Controls,
  Forms,
  SysUtils,

  vcmBase,
  vcmExternalInterfaces,
  vcmInterfaces,

  l3Interfaces,
  l3Base,
  l3Nodes,
  l3Tree_TLB,
  l3TreeInterfaces,
  l3Types,
  l3LongintList,

  afwInterfaces,

  bsTypes,

  nsNodes,
  {$IfNDef Admin}
  nsSearchClasses,
  {$EndIf  Admin}
  nsTypes,
  nsTreeStruct,
  SplashInterfaces,
  {$If not (defined(Monitorings) or defined(Admin))}
  nsTimeMachine,
  nsFiltersInterfaces,
  {$IfEnd not (defined(Monitorings) or defined(Admin))}

  BaseTreeSupportUnit,
  BaseTypesUnit,
  ComplectUnit,
  ConsultingUnit,
  DynamicTreeUnit,
  FoldersUnit,
  GBLAdapter,
  IntegrationProjectUnit,
  LoggingUnit,
  MonitoringUnit,
  NotifyUnit,
  SearchUnit,
  SettingsUnit,
  StartUnit,
  UnderControlUnit,
  PrimeUnit,
  ChatInterfacesUnit,

  {$If not (defined(Monitorings) or defined(Admin))}
  Registration_Form,
  //enRememberPassword,
  RememberPassword_Form,
  {$IfEnd not (defined(Monitorings) or defined(Admin))}
  //enLogin,
  Login_Form,

  l3NotifyPtrList,
  bsInterfaces,

  FoldersDomainInterfaces,
  AdminDomainInterfaces,
  DataAdapterInterfaces,
  vcmGUI,
  {$If not (defined(Monitorings) or defined(Admin))}
  nsDeferredTreeList,
  {$IfEnd}
  DataAdapterRes
  ;

type
  TNavigatorMenuItemTypeSet = set of TNavigatorMenuItemType;

  PIl3CString = ^Il3CString;

  _l3Notifier_Parent_ = TvcmCacheableBase;
  {$Include l3Notifier.imp.pas}
  TDataAdapter = class(_l3Notifier_)
   {* Объект для связи всех главных форм с адаптером сервера приложений.}
  private
    {$IfNDef nsWithoutLogin}
    f_Authorization              : IAuthorization;
    {$EndIf nsWithoutLogin}
    f_CommonInterfaces           : ICommon;
    f_NativeAdapter              : IGblAdapterDll;
    f_Folders                    : IFolders;
    f_Search                     : ISearch;
    {$If not (defined(Monitorings) or defined(Admin))}
    f_ControlMgr                 : IControlManager;
    {$IfEnd}
    f_AssemblyInfo               : IAssemblyInfo;
    f_ConsultationManager        : IConsultationManager;
    f_NotifyManager              : INotifyManager;
    f_LogManager                 : ILogManager;
    f_CRSimpleListTypeRootNode   : Il3Node;
    f_ShellType                  : TnsShellType;
    f_CurBaseDate                : BaseTypesUnit.TDate;
    f_CurrentUserID              : Integer;
    f_InTerminateProcess         : Boolean;
    {$If not defined(Admin)}
    f_PrimeManager               : IPrimeManager;
    {$IfEnd}
    {$If not (defined(Monitorings) or defined(Admin))}
    f_TimeMachine                : InsTimeMachine;
    {$IfEnd not (defined(Monitorings) or defined(Admin))}
    f_MenuTypeCache              : TNavigatorMenuItemTypeSet;
    f_HasPublishSourceTag        : Tl3Bool;
    f_HasKeyWordTag              : Tl3Bool;
    f_IsInternal                 : Tl3Bool;
    f_PrivelegedUsersAllowed     : Tl3Bool;
    f_Monitoring                 : IMonitoring;
    f_AdministratorLogin         : Boolean;
    f_TrialDaysLeft              : Longint;
    {$IfNDef nsWithoutLogin}
    f_InstallDefaultSettingsInfo : IDefaultValuesChangesIndicator;
    {$EndIf  nsWithoutLogin}
    f_RegListXMLExportEnabled    : Boolean;
    f_UserFlagShift              : Byte;
    f_BaseSearchFirstExampleIndex: LongInt;
    f_AdminInfo                  : InsAdminInfo;
    f_Integration                : IIntegration;
    f_ShutDowning                : Boolean;
    {$If not (defined(Monitorings) or defined(Admin))}
    f_BuildingDefferedTreesList  : TnsDeferredTreeList;
    {$IfEnd}
    f_LockHelpException          : Boolean;
    //f_UseUserATPrefix            : Tl3Bool;
    //f_UserATPrefixName           : Il3CString;
    f_ChatManager                : IChatManager;
    f_MessageManager             : IMessagesManager;
    f_IntergationExportEnabled   : Tl3Bool;
    f_RevisionCheckEnabled       : Tl3Bool;
    f_InStartUpProcess           : Boolean;
    f_FatalExceptionRaised      : Boolean;
 // Сейчас не востребовано, т.к. обработчик в библиотеке m0exclib работает
 // некорректно и сбрасывает наш обработчик!!!
 //
 //   f_OldOnExceptionEvent : TExceptionEvent;
  private
  // property methods
    {$If not defined(Admin)}
    function pm_GetPrimeManager: IPrimeManager;
      {-}
    {$IfEnd}
    function pm_GetAdminInfo: InsAdminInfo;
      {-}
    function pm_GetComplectName: Il3CString;
      {-}
    function pm_LogManager: ILogManager;
      {-}
    function pm_GetNativeAdapter: IGblAdapterDll;
      {-}
    function pm_GetSettings : ISettingsManager;
      {-}
    function pm_GetPermanentSettings : IBaseSettingsManager;
      {-}
    function pm_GetMonitoring: IMonitoring;
      {-}
    function pm_GetSearch : ISearch;
      {-}
    function pm_GetFolders : IFolders;
      {-}
    function pm_GetFoldersRoot : INode;
      {-}
    function pm_GetCurrentBaseDate : BaseTypesUnit.TDate;
      {-}
    {$If not (defined(Monitorings) or defined(Admin))}
    function pm_GetControlMgr  : IControlManager;
      {-}
    {$IfEnd}  
    function pm_GetAssemblyInfo : IAssemblyInfo;
      {-}
    function pm_GetNotifyManager: INotifyManager;
      {-}
    function pm_GetDocDefaultLang : TbsLanguage;
      {-}
    function pm_GetIsExplanatoryExists : boolean;
      {-}
    function pm_GetIsInpharmExists : boolean;
      {-}
    function pm_GetIsENOEnabled : boolean;
      {-}
    {$If not Defined(Admin) AND not Defined(Monitorings) }
    function pm_GetTimeMachine: InsTimeMachine;
      {-}
    {$IfEnd}  
    function  pm_GetRegistryLogin: AnsiString;
    procedure pm_SetRegistryLogin(const aValue: AnsiString);
      {-}
    function  pm_GetRegistryPassword: AnsiString;
    procedure pm_SetRegistryPassword(const aValue: AnsiString);
      {-}
    function pm_GetRegistryPasswordExists: Boolean;
      {-}
    function pm_GetRegistryIsAutoLogin: Boolean;
      {-}
    procedure pm_SetRegistryIsAutoLogin(const aValue: Boolean);
      {-}
    function pm_getIsDesktop: Boolean;
      {-}
    function pm_GetCurrentUserID : Integer;
      {-}
    function pm_GetCRSimpleListTypeRootNode : Il3Node;
      {-}
    function pm_GetAdministratorLogin: Boolean;
      {-}
    function pm_GetIsExists_PublishSourceTag : Boolean;
      {-}
    function pm_GetIsExists_KeyWordTag : Boolean;
      {-}
    function pm_GetIsInternal: Boolean;
      {-}
    function pm_GetTrialDaysLeft: Longint;
      {-}
    function pm_GetIsTrialMode: Boolean;
      {-}
    function pm_GetIsMorfoIndexExist: Boolean;
      {-}
    function pm_GetConsultationManager: IConsultationManager;
      {* - менеджер консультаций. }
    function pm_GetChatManager: IChatManager;
      {-}
    function pm_GetMessagesManager: IMessagesManager;
      {-}
    function pm_GetHasSearchMachine: Boolean;
      {* - наличие интеллектуального поиска (поисковой машины). }
    function pm_GetHasConsultations: Boolean;
      {* - наличие консультаций. }
    function pm_GetBaseSearchFirstExampleIndex: LongInt;
      {* - Индекс первого примера для показа в Базовом поиске. }
    function pm_GetListXMLExportEnabled: Boolean;
      {-}
    function pm_GetPrivelegedUsersAllowed: Boolean;
      {-}
    function pm_GetIntegration: IIntegration;
      {-}
(*    function pm_UseUserATPrefix: Boolean;
      {-}
    function pm_UserATPrefixName: Il3CString;
      {-}*)
    function pm_GetIsInternetAgentEnabled: Boolean;
      {-}
    function pm_IntergationExportEnabled: Boolean;
      {-}
    function pm_RevisionCheckEnabled: Boolean;
      {-}
  public
   procedure FinishDataUpdate;
     {* - вызывается по окончании обновления. }
  private
  // internal methods
    procedure UpdatedNotify;
      {* - уведомляет об обновлении адаптера. }
    function MakeCRTree(const aRootNode: INodeBase): Il3Node;
      {-}
    procedure InitNotifiers;
      {-}
    procedure InitCurrentUserID;
      {-}
    function HasTag(out aValue : Tl3Bool;
                    const aTag : Tl3WString): Boolean;
      {-}
    function IsExistTag(const aTagName : Tl3WString) : Boolean;
      {-}
    {$If not Defined(nsWithoutLogin)}
    function LoginAction(aSender: TCustomForm): TModalResult;
      {-}
    {$IfEnd not Defined(nsWithoutLogin) }
    {$If not (defined(Monitorings) or defined(Admin))}
    function RememberPassword(aSender: TCustomForm): TModalResult;
      {-}
    function RegisterAction(aSender: TCustomForm): TModalResult;
      {-}
    procedure SendPassword;
      {-}
    function Registration(const aLogin, aPassword : Il3CString;
                          aIsAutoLogin            : Boolean;
                          CanRelogin: Boolean = False;
                          const aNewLogin: PIl3CString = nil;
                          const aNewPassword: PIl3CString = nil;
                          const aNewAutoLogin: PBoolean = nil;
                          const aNeedTryRelogin: PBoolean = nil): Boolean;
      {-}
    {$IfEnd not (defined(Monitorings) or defined(Admin))}
    {$If not Defined(nsWithoutLogin)}
    function TestLoginName(const aName: Il3CString): Boolean;
      {-}
    function DesktopAutoRegistration: Boolean;
      {-}
    function AutoLogin(const aLogin, aPassword: Il3CString): Boolean;
      {-}
    function Login(const aLogin  : Il3CString;
                   anIsAutoLogin : Boolean): Boolean;
      {-}
    {$IfEnd not Defined(nsWithoutLogin)}
    function SayWithProtectionCheck(const aMessageID: TvcmMessageID): Boolean;
      overload;
      {-}
    function SayWithProtectionCheck(const aMessageID : TvcmMessageID;
                                    const aData      : array of const): Boolean;
      overload;
      {-}
    procedure InstallDefaultSettings;
      {* - установить настройки по умолчанию. }
    procedure WaitForBuildingDeferredTrees;
      {-}
    {$If not (defined(Monitorings) or defined(Admin))}
    function MakeSplashData(aIsStart: Boolean): InsSplashClient;
      {-}
    {$IfEnd}  
  protected
  // protected methods
    procedure InitFields;
      override;
      {-}
    procedure Cleanup;
      override;
      {-}
  public
  // public methods
    constructor Create(const aNativeAdapter: IGblAdapterDll);
      reintroduce;
      {-}
    procedure GlobalExceptionRaised(aSender: TObject; anException: Exception);
      {-}
    function HandleGlobalException(aSender: TObject; anException: Exception): Boolean;
      {-}
    procedure ShowMessageWithDealerInfo(const aMsg: TvcmMessageID);
      {-}
    procedure ShowAutoregistrationDisabledMessage;
      {-}
    procedure AbnormalTermination(const aMsg: TvcmMessageID; aShowDealerInfo: Boolean = True);
     overload;
      {-}
    procedure AbnormalTermination(aTerminateProcess: Boolean = True);
     overload;
      {-}
   // pubic methods
    {$If not Defined(nsWithoutLogin)}
    procedure   LoginSequence;
      {* Операция авторизации на сервере - обязательна для начала нормальной работы }
    {$Else}  
    procedure InitCommon;
    {$IfEnd not Defined(nsWithoutLogin)}
    function    CreateEmptyQuery(aType: TQueryType): IQuery;
      {* Операция создает пустой запрос }
    function GetType: TComplectType;
      {* - Возвращает тип базы. }
    function GetOldBaseWarning: Il3CString;
      {-}
(*    function GetMissingBlocksForCR(const aCRType: INodeBase): Il3CString;
      {-}*)
    function GetDealerInfo: Il3CString;
      {-}
    function GetUnexistDocMessage: Il3CString;
      {-}
    procedure ActivateDefKeyboardLayout;
      {-}
    procedure ResetBooleans;
      {* - сбросить трех позиционные логические флаги. }
    procedure ClearCache;
      {-}
    function  GetUsersTree: INodeBase;
      {-}
    function  GetGroupsTree: INodeBase;
      {-}
    function GetChatUsersTree: INodeBase;
      {-}
    {$If not Defined(Admin) AND not Defined(Monitorings) }
    procedure DocumentCacheSinchronize(anOperation: TFolderOperationType;
                                       anEntity: IUnknown;
                                       aFlags: TDocumentBookmarkTypes = dbtUsual);
      {* - нотификация кэшу документов об изменении объектов в папках. }
    procedure OpenIntranet;
      {-}
    procedure OpenIntranetDocument(aDocID, aParaID: Longword; aNeedCheck : Boolean);
      {-}
    {$IfEnd}
    procedure DefineApplicationTitle;
      {* - определяем название приложения. }
    {$If not (defined(Monitorings) or defined(Admin))}
    function CorrectMistakes(const aContext: Il3StringsEx; aForInpharm: Boolean;
     out aCorrectedContext: Il3StringsEx; out aMistakesList: Il3StringsEx): Boolean;
      {-}
    {$IfEnd}
    function LegislationReviewAvailable: Boolean;
      {-}
    {$If not defined(Admin) AND not defined(Monitorings)}
    procedure RegisterBuildingDefferedTree(const aTree: InsDeferredTree);
      {-}
    procedure RegisterBuildedDefferedTree(const aTree: InsDeferredTree);
      {-}
    {$IfEnd}
    procedure BeginLoadFolders;
      {-}
    procedure EndLoadFolders;
      {-}
{$If not (defined(Monitorings) or defined(Admin))}
    function FiltersContainer(aListType: TbsListType): InsFiltersContainer;
      {-}
{$IfEnd not (defined(Monitorings) or defined(Admin))}
  public
  // public properties
    {$IfNDef nsWithoutLogin}
    property Authorization: IAuthorization
      read f_Authorization;
      {* Интерфейс для авторизации пользователей на сервере и получения информации о комплекте.}
    {$EndIf  nsWithoutLogin}  
    property CommonInterfaces: ICommon
      read f_CommonInterfaces;
      {* Интерфейс для получения базовых объектов системы.}
    property NativeAdapter: IGblAdapterDll
      read pm_GetNativeAdapter;
      {* Интерфейс для получения базовых объектов системы в новом шаблоне.}
    property CRSimpleListTypeRootNode: Il3Node
      read pm_GetCRSimpleListTypeRootNode;
      (* Корневой узел для списка типов респондентов/корреспондентов для комбобокса*)
    property Settings: ISettingsManager
      read pm_GetSettings;
      {-}
    property PermanentSettings: IBaseSettingsManager
      read pm_GetPermanentSettings;
      {-}
    property Monitoring: IMonitoring
      read pm_GetMonitoring;
      {-}
    property Search: ISearch
      read pm_GetSearch;
      {-}
    property Folders: IFolders
      read pm_GetFolders;
      {-}
    property FoldersRoot: INode
      read pm_GetFoldersRoot;
      {-}
    {$If not (defined(Monitorings) or defined(Admin))}
    property ControlMgr: IControlManager
      read pm_GetControlMgr;
      {-}
    {$IfEnd}
    property AssemblyInfo: IAssemblyInfo
      read pm_GetAssemblyInfo;
      {-}
    property NotifyManager: INotifyManager
      read pm_GetNotifyManager;
      {-}
    property CurrentBaseDate: BaseTypesUnit.TDate
      read pm_GetCurrentBaseDate;
      {-}
    property IsExplanatoryExists : Boolean
      read pm_GetIsExplanatoryExists;
      {-}
    property IsInpharmExists : Boolean
      read pm_GetIsInpharmExists;
      {-}
    property IsENOEnabled : Boolean
      read pm_GetIsENOEnabled;
      {-}
    property IsExists_PublishSourceTag: Boolean
      read pm_GetIsExists_PublishSourceTag;
      {-}
    property IsExists_KeyWordTag: Boolean
      read pm_GetIsExists_KeyWordTag;
      {-}
    property IsInternal: Boolean
      read pm_GetIsInternal;
      {-}
    property IsDesktop: Boolean
      read pm_getIsDesktop;
      {-}
    property DocDefaultLang: TbsLanguage
      read pm_GetDocDefaultLang;
      {-}
    property RegistryLogin: AnsiString
      read pm_GetRegistryLogin
      write pm_SetRegistryLogin;
      {-}
    property RegistryPassword: AnsiString
      read pm_GetRegistryPassword
      write pm_SetRegistryPassword;
      {-}
    property RegistryPasswordExists: Boolean
      read pm_GetRegistryPasswordExists;
      {-}
    property RegistryIsAutoLogin: Boolean
      read pm_GetRegistryIsAutoLogin
      write pm_SetRegistryIsAutoLogin;
      {-}
    property CurrentUserID: Integer
      read pm_GetCurrentUserID;
      {* - идентификатор пользователя зарегистрировавшего в системе. }
    property InTerminateProcess: Boolean
      read f_InTerminateProcess;
      {-}
    {$If not Defined(Admin) AND not Defined(Monitorings) }
    property TimeMachine: InsTimeMachine
      read pm_GetTimeMachine;
      {* - Машина времени}
    {$IfEnd}  
    property AdministratorLogin: Boolean
      read pm_GetAdministratorLogin;
      {-}
    property MenuTypeCache: TNavigatorMenuItemTypeSet
      read f_MenuTypeCache
      write f_MenuTypeCache;
      {-}
    property TrialDaysLeft: Longint
      read pm_GetTrialDaysLeft;
      {-}
    property IsTrialMode: Boolean
      read pm_GetIsTrialMode;
      {-}
    property IsMorfoIndexExist: Boolean
      read pm_GetIsMorfoIndexExist;
      {-}
    property ConsultationManager: IConsultationManager
      read pm_GetConsultationManager;
      {* - менеджер консультаций. }
    property HasSearchMachine: Boolean
      read pm_GetHasSearchMachine;
      {* - наличие интеллектуального поиска (поисковой машины). }
    property HasConsultations: Boolean
      read pm_GetHasConsultations;
      {* - наличие консультаций. }
    {$IfNDef nsWithoutLogin}
    property InstallDefaultSettingsInfo: IDefaultValuesChangesIndicator
      read f_InstallDefaultSettingsInfo
      write f_InstallDefaultSettingsInfo;
      {* - результаты установки настроек по умолчанию. }
    {$EndIf  nsWithoutLogin}  
    property LogManager: ILogManager
      read pm_LogManager;
      {-}
    property ListXMLExportEnabled: Boolean
      read pm_GetListXMLExportEnabled;
      {-}
    property ComplectName: Il3CString
      read pm_GetComplectName;
      {-}
    property UserFlagShift: Byte
      read f_UserFlagShift;
      {* - Насколько надо сдвигать состояния (shl,shr) для пребразования во
           флаги на дереве }
    property BaseSearchFirstExampleIndex: LongInt
      read pm_GetBaseSearchFirstExampleIndex;
      {* - Индекс первого примера для показа в Базовом поиске. }
    property AdminInfo: InsAdminInfo
      read pm_GetAdminInfo;
      {* - контактные данные администратора. }
    property PrivelegedUsersAllowed: Boolean
      read pm_GetPrivelegedUsersAllowed;
      {-}
    property Integration: IIntegration
     read pm_GetIntegration;
      {-}
    {$If not defined(Admin)}
    property PrimeManager: IPrimeManager
      read pm_GetPrimeManager;
      {-}
    {$IfEnd}  
(*    property UseUserATPrefix: Boolean
      read pm_UseUserATPrefix;
      {-}
    property UserATPrefixName: Il3CString
      read pm_UserATPrefixName;
      {-}*)
    property IsInternetAgentEnabled: Boolean
      read pm_GetIsInternetAgentEnabled;
      {-}
    property ChatManager: IChatManager
      read pm_GetChatManager;
      {-}
    property MessagesManager: IMessagesManager
      read pm_GetMessagesManager;
      {-}
    property IntergationExportEnabled: Boolean
      read pm_IntergationExportEnabled;
      {-}
    property RevisionCheckEnabled: Boolean
      read pm_RevisionCheckEnabled;
      {-}
    property InStartUpProcess: Boolean
      read f_InStartUpProcess
      write f_InStartUpProcess;
    property FatalExceptionRaised: Boolean
      read f_FatalExceptionRaised;
  end;//TDataAdapter

function DecodePassword(const aPassword: AnsiString): AnsiString;
  {-}
function EncodePassword(const aPassword: AnsiString): AnsiString;
  {-}
function StringExistsInRegistry(const aRootKey   : HKEY;
                                const aPathKey   : AnsiString;
                                const aValueName : AnsiString): Boolean;
  {-}
procedure PutStringToRegistry(const aRootKey   : HKEY;
                              const aPathKey   : AnsiString;
                              const aValueName : AnsiString;
                              const aValue     : AnsiString;
                              CanCreate: Boolean = true);
  {-}
function GetBooleanFromRegistry(const aRootKey      : HKEY;
                                const aPathKey      : AnsiString;
                                const aValueName    : AnsiString;
                                const aDefaultValue : Boolean = False): Boolean;
  {-}
procedure PutBooleanToRegistry(const aRootKey   : HKEY;
                               const aPathKey   : AnsiString;
                               const aValueName : AnsiString;
                               const aValue     : Boolean);
  {-}
function GlobalInit(aLogo               : TCustomForm;
                     const aLocale      : AnsiString;
                     PureInitialization : Boolean = False;
                     aForceNoSplash     : Boolean = False):
                     {$If not defined(Admin) AND not defined(Monitorings)}
                     InsSplashClient
                     {$Else}
                     IUnknown
                     {$IfEnd};
  {-}
procedure GlobalDone; far;
  {-}
procedure GlobalCrashCleanup;
  {* Очистка мусора при аварийном завершении программы}
procedure GetProcedureAddress(var P: Pointer; const aModule: AnsiString; const ProcName: AnsiString);
  {-}

var
 g_ShowFinalSplash: Boolean = True; // показывать ли финальный сплеш (модифицируется ТОЛЬКО при логофе или перезагрузке системы)

var
 DefDataAdapter: TDataAdapter;

const
 c_MainMenu_NodeClass = 'MainMenu';
 c_Diction_NodeClass = 'ExplanatoryDiction';
 c_CR_NodeClass = 'CRTree';
 c_MedDiction_NodeClass = 'MedExplanatoryDiction';

implementation

uses
  {$IfDef nsSign1}
  Graphics,
  {$EndIf nsSign1}

  Dialogs,
  HelpIntfs,

  l3Utils,
  l3String,

  afwFacade,

  k2Base,

  evdTypes,
  
  evTypes,
  evDocumentsCache,
  evExcept,

  vcmForm,
  vcmBaseMenuManager,
  vcmMessagesCollectionItem,
  vcmStringList,

  StdRes,
  DebugStr,

  DocumentUnit,
  DynamicTreeDefinesUnit,
  IOUnit,
  SecurityUnit,

  {$If not (defined(Monitorings) or defined(Admin))}
  ExternalObjectUnit,
  nsExternalObject,
  nsExternalObjectPrim,
  FlashUtils,
  l3Memory,
  Math,
  nsSplashVisualizer,
  nsFiltersContainer,
  {$IfEnd not (defined(Monitorings) or defined(Admin))}
  {$IfDef nsSign}
  nsSign,
  {$EndIf nsSign}
  nsVerifyValue,
  nsConst,
  nsLoginUtils,
  nsStartupSupport,
  nsNotifiers,
  nsDocumenttools,
  nsAdminInfo,
  nsErrorReport,
  //enLongProcessForm,
  LongProcess_Form,
  nsINodeWrap,
  PrimLongProcess_Form,

  vcmMessagesSupport,

  l3MessageID,

  PrimF1Res,
  nsQuestionsWithChoices,
  nsRegistryTools,
  Search_FormDefinitions_Controls
  ;

{$Include l3Notifier.imp.pas}

const
 {$Include RegPath.inc}

 cRegListXMLExportEnabledName = 'ListXMLExportEnable';
 cRegListXMLExportEnabledValue = '1';

 CLoginValueName = 'Login';
 CPasswordValueName = 'Password';
 CIsAutoLoginValueName = 'IsAutoLogin';

 CCryptPrefixChar = Char($01);
 CCryptPrefixCharSize = SizeOf(CCryptPrefixChar);

 CCryptSuffixChar = Char($1F);
 CCryptSuffixCharSize = SizeOf(CCryptSuffixChar);

 CCryptSoldLength = SizeOf(Word);
 CCryptSoldSize = 2*CCryptSoldLength;

 CCryptTailLength = 32*SizeOf(Char);
 CCryptTailSize = 2*CCryptTailLength;

 cMonitoringLogin = '_predefined_data';
 cMonitoringPassword = '_predefined_data';
 cSystemLogin = 'ADMIN';


function NoMoreConnectionsMessage(out aData: Il3CString): TvcmMessageId;
  {* - сообщение о достижении лимита соединей с сервером. }
var
 l_ActiveUsers : IStringList;
 l_Login       : IString;
 l_Index       : Integer;

 function lp_MakeLogin: Il3CString;
 begin
  Result := l3Cat('- ', nsCStr(l_Login));
 end;

begin
 if (defDataAdapter <> nil) and (defDataAdapter.NativeAdapter <> nil) then
 begin
  try
   defDataAdapter.NativeAdapter.MakeUserManager.
    GetActiveUsersListForNetOneUserVersion(l_ActiveUsers);
   try
    aData := nil;
    for l_Index := 0 to Pred(l_ActiveUsers.Count) do
    begin
     l_Login := nil;
     l_ActiveUsers.pm_GetItem(l_Index, l_Login);
     if l3IsNil(aData) then
      aData := lp_MakeLogin
     else
      aData := l3Cat([l3Cat(aData, #10), lp_MakeLogin]);
    end;
    Result := war_NoMoreConnectionsOneUserNet;
    Exit;
   finally
    l_ActiveUsers := nil;
   end;//try..finally
  except
   on ECanNotFindData do
  end;//try..except
 end;//if defDataAdapter.NativeAdapter <> nil then
 aData := nil;
 Result := war_NoMoreConnections;
end;//NoMoreConnectionsMessage

{$IF DEFINED(UseNoServerExceptionEvent)}
procedure ENoServerExceptionEvent(var a_Exception: Exception);
begin
 if Assigned(DefDataAdapter) then
  DefDataAdapter.GlobalExceptionRaised(nil, a_Exception);
end;
{$IFEND} // UseNoServerExceptionEvent

function GlobalInit(aLogo              : TCustomForm;
                    const aLocale      : AnsiString;
                    PureInitialization : Boolean;
                    aForceNoSplash     : Boolean):
                    {$If not defined(Admin) AND not defined(Monitorings)}
                    InsSplashClient
                    {$Else}
                    IUnknown
                    {$IfEnd};

var
 l_Adapter: IGblAdapterDll;

 procedure InitEarlyNotifiers;
 var
  l_SynchronizeNotifier: IListener;
  l_NotifyManager: INotifyManager;
 begin
  l_NotifyManager := l_Adapter.MakeNotifyManager;
  if Assigned(l_NotifyManager) then
  begin
   l_SynchronizeNotifier := TnsSynchronizedNotification.Make;
   try
    l_NotifyManager.RegisterListenerForNotify(NT_SHUTDOWN,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_BASE_UPDATE_START,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_BASE_UPDATE_END,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_BASE_UPDATE_FAILED,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_MONITORING_UPDATE,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_LOGOUT,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_CONSULTATION_RECEIVED,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_CONSULTATION_NOT_SENT,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_NO_SUBSCRIPTION,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_INTERNET_AVAILABLE,
                                              l_SynchronizeNotifier);
    l_NotifyManager.RegisterListenerForNotify(NT_INTERNET_NOT_AVAILABLE,
                                              l_SynchronizeNotifier);
   finally
    l_SynchronizeNotifier := nil;
   end;
  end;
 end;

var
 l_Data: Il3CString;
begin
 Result := nil;
 try
  l_Adapter := TGblAdapterDll.Make(nsAStr(aLocale));
 except
  on ELoadLibraryError do
  begin
   vcmSay(err_LoadLibraryError, [BaseTypesUnit.LIBRARY_NAME]);
   raise;
  end;
  on EGetProcAddressError do
  begin
   aLogo.Hide;
   vcmSay(err_LibraryVersionError, [BaseTypesUnit.LIBRARY_NAME]);
   raise;
  end;
  on E: EWrongVersion do
  begin
   l3System.Msg2Log(caWrongDllVersion);
   vcmSay(err_LibraryVersionError, [BaseTypesUnit.LIBRARY_NAME]);
   raise Exception.Create(vcmConstString(str_aeWrongDLL));
  end;
 end;
 // Добавляем процедуру деинициализации:
 l3System.AddExitProc(GlobalDone);

 {$IF DEFINED(UseNoServerExceptionEvent)}
 g_NoServerExceptionEvent := ENoServerExceptionEvent; // глобальный перехват исключения `ENoServer`
 {$IFEND} // UseNoServerExceptionEvent

 // Инициализация объектов нотификаторов:
 InitEarlyNotifiers;

 // Инициализируем адаптер сервера приложений:
 try
  l_Adapter.MakeComponentManager.Start;
 except
  on ESettingsRestoreFails do
  // Ошибка при восстановлении настроек
  begin
   vcmSay(err_SettingsRestoreFailed);
   raise;
  end;
  on EInvalidBase do
  // Файлы данных отсутствуют или повреждены
  begin
   if not TnsStartupSupport.IsRunParamExist then
   begin
    aLogo.Hide;
    vcmSay(err_InvalidBase);
    l_Adapter.MakeComponentManager.Stop;
    raise;
   end;
  end;
  on EMorphoNotExists do
  // Отсутсвует морфоиндекс
  begin
   if not TnsStartupSupport.IsRunParamExist then
   begin
    aLogo.Hide;
    vcmSay(err_MorphoNotExists);
    l_Adapter.MakeComponentManager.Stop;
    raise;
   end;
  end;
  on ENoServer do
  // Сервер не доступен
  begin
   aLogo.Hide;
   vcmSay(inf_ServerShutDown);
   raise;
  end;
  on EServerIsStarting do
  begin
   aLogo.Hide;
   vcmSay(inf_ServerIsStarting);
   raise;
  end;
  on ELoadLibraryError do
  begin
   aLogo.Hide;
   vcmSay(err_LoadLibraryError, [BaseTypesUnit.LIBRARY_NAME]);
   raise;
  end;
  on EGetProcAddressError do
  begin
   aLogo.Hide;
   vcmSay(err_LibraryVersionError, [BaseTypesUnit.LIBRARY_NAME]);
   raise;
  end;
  on EConfigurationsNotDefined do
  // В системе не определена ни одна конфигурация
  begin
   aLogo.Hide;
   vcmSay(err_ConfigurationsNotDefined);
   raise;
  end;
  on EIPAddressNotFound do
  begin
   aLogo.Hide;
   vcmSay(err_IPAddressNotFound);
   raise;
  end;
  on EBadNetworkConfig do
  begin
   aLogo.Hide;
   vcmSay(err_BadNetworkConfig);
   raise;
  end;
  on EWorkingParamsNotFound do
  begin
   aLogo.Hide;
   vcmSay(err_WorkingParamsNotFound);
   raise;
  end;
  on ELicenceViolation do
  begin
   aLogo.Hide;
   vcmSay(err_ConnectionsLicenceViolation);
   raise;
  end;
  on ENoMoreConnections do
  begin
   aLogo.Hide;
   vcmSay(NoMoreConnectionsMessage(l_Data), [l_Data]);
   raise;
  end;
  on EInternalApplicationError do
  begin
   aLogo.Hide;
   vcmSay(err_InternalApplicationError);
   raise;
  end;
  on EServerVersionNotValid do
  begin
   aLogo.Hide;
   vcmSay(err_WrongServerVersion);
   raise;
  end;
  on EStorageLocked do
  begin
   aLogo.Hide;
   vcmSay(inf_UpdateInProgress);
   raise;
  end;
  on EInvalidUserDatastore do
  begin
   aLogo.Hide;
   vcmSay(war_InvalidUserDatastore);
   raise;
  end;
 end;

 // Гасим заставку
 aLogo.Hide;

 try
  while (TnsStartupSupport.Instance.CheckAndRunSupportProcessesIfNeed) do
   vcmSay(inf_UpdateInProgress);
 finally
  // Создаем объект для работы с аддаптером:
  // в любом случае, чтобы дождаться получения интерфейса авторизации (окончания
  // заливки настроек) (ЦК24716)
  DefDataAdapter := TDataAdapter.Create(l_Adapter);
  DefDataAdapter.InStartUpProcess := True;
 end;

 {$If not defined(nsWithoutLogin)}
 DefDataAdapter.LoginSequence;
 {$Else}
 DefDataAdapter.InitCommon;
 {$IfEnd not defined(nsWithoutLogin)}

 {$If not (defined(Monitorings) or defined(Admin))}
 if not PureInitialization then
 begin
  // http://mdp.garant.ru/pages/viewpage.action?pageId=481813781
  if aForceNoSplash then
   Result := nil
  else
   Result := DefDataAdapter.MakeSplashData(true);
  if Result = nil then
  begin
   aLogo.Show;
   // Это нужно! без этого в отсутствие сплеша CQ8755
   Application.BringToFront;
   afw.ProcessMessages;
  end;
 end;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}

 try
  DefDataAdapter.ActivateDefKeyboardLayout;
  if not PureInitialization then
  begin
   with DefDataAdapter do
   begin
    InitNotifiers;
    {$IfDef nsSign1}
    InitCurrentUserID;
    {$EndIf nsSign1}
   end;
  end;
 except
  {$If not (defined(Monitorings) or defined(Admin))}
  if not PureInitialization then
   Result := nil;
  {$IfEnd not (defined(Monitorings) or defined(Admin))}
  raise;
 end;
end;

procedure GlobalDone;

 {$IfNDef nsWithoutLogin}
 function CheckAutorizationInterfaceRefCount: Boolean;
 var
  l_Authorization: IAuthorization;
 begin
  Result := True;
  //
  if (DefDataAdapter <> nil) then
  begin
   l_Authorization := DefDataAdapter.Authorization;
   if (l_Authorization <> nil) then
    try
     l_Authorization._AddRef;
     //
     Result := (l_Authorization._Release = 2); // если адаптер не держит этот интерфейс, то счетчик ссылок здесь должен быть равен 2
    finally
     l_Authorization := nil;
    end;
  end;
 end;
 {$EndIf  nsWithoutLogin}
 
var
 {$If not (defined(Monitorings) or defined(Admin))}
 l_Splash: InsSplashClient;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}
 l_Adapter: IGblAdapterDll;
 l_Mgr: IComponentManager;
 {$If defined(nsWithoutLogin)}
 l_Prime: IPrimeManager;
 {$IfEnd defined(nsWithoutLogin)}
begin
 {$If not (defined(Monitorings) or defined(Admin))}
 // Показываем финальный Splash
 if g_ShowFinalSplash and Assigned(DefDataAdapter) then
  l_Splash := DefDataAdapter.MakeSplashData(False)
 else
  l_Splash := nil;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}

 Tk2TypeTable.CheckAndCleanupReferences;

 // Сигнализируем, что начали процесс "остановки" сервера приложений
 TnsStartupSupport.ShutdownPendingNotify;
 try
  if Assigned(DefDataAdapter) then
  begin
   l_Adapter := DefDataAdapter.f_NativeAdapter;
   try
    try
     // Специальная проверка на то, что только одна ссылка существует на интерфейс авторизации.
     // Если это не так - то пользователь не отлогинется от сервера (т.к. логаут происходит в диструкторе класса, реализующего этот интерфейс).
     DefDataAdapter.f_AdminInfo := nil;
     {$IfNDef nsWithoutLogin}
     Assert(CheckAutorizationInterfaceRefCount);
     {$EndIf  nsWithoutLogin}
     // Освобождаем объект поддерживающий переключение на уже запущенное приложение, запуск бридера/апдейтера и т.п.
     TnsStartupSupport.DestroyInstance;
     // Освобождаем объект для работы с аддаптером:
     vcmFree(DefDataAdapter);
    finally
     {$If not (defined(Monitorings) or defined(Admin))}
         l_Splash := nil;
     {$IfEnd not (defined(Monitorings) or defined(Admin))}
    end;
   finally
 {$If defined(nsWithoutLogin)}
    try
     l_Prime := l_Adapter.MakePrimeManager;
     try
      l_Prime.Update;
     finally
      l_Prime := nil;
     end;
    except
     on E: Exception do
      l3System.Exception2Log(E);
    end; 
 {$IfEnd defined(nsWithoutLogin)}

    // Деинициализируем адаптер сервера приложений:
    try
     l_Mgr := l_Adapter.MakeComponentManager;
     try
      l_Mgr.Stop;
     finally
      l_Mgr := nil;
     end;
    except
     on E: Exception do
      l3System.Exception2Log(E);
    end;

    try
     l_Adapter := nil;
    except
     on E: Exception do
      l3System.Exception2Log(E);
    end;
   end;
  end;
 finally
  // Сигнализируем, что закончили процесс "остановки" сервера приложений
  TnsStartupSupport.ShutdownCompletedNotify;
 end;
end;

procedure GlobalCrashCleanup;
 {* Очистка мусора при аварийном завершении программы}
begin
 // Пока ничего не чистим!!!
end;

constructor TDataAdapter.Create(const aNativeAdapter: IGblAdapterDll);

 function MessageIDToString(const aMsg: TvcmMessageID): Il3CString;
 begin//MessageIDToString
  with TvcmMessagesCollectionItem(g_MenuManager.Messages.Items[aMsg.rM]) do
   Result := vcmGetVisibleName(l3CStr(Caption), {Choices}nil, DlgType);
 end;//MessageIDToString

var
 {$IfNDef nsWithoutLogin}
 l_Break: Boolean;
 l_LongProcessMessage: TLongProcessForm;//TenLongProcessMessage;
 l_Now: System.TDateTime;
 l_NowDelta: System.TDateTime;
 l_NowDeltaMax: System.TDateTime;
 l_NowDeltaStep: System.TDateTime;
 l_ShowCount: Integer;
 l_ShowCountMin: Integer;
 {$EndIf nsWithoutLogin}
 l_UserFlag: TFlagMask;
begin
 inherited Create;
 f_NativeAdapter := aNativeAdapter;
// Сейчас не востребовано, т.к. обработчик в библиотеке m0exclib работает некорректно и сбрасывает наш обработчик!!!
// if Assigned(Application.OnException) then
//  f_OldOnExceptionEvent := Application.OnException
// else
//  f_OldOnExceptionEvent := nil;
 Application.OnException := GlobalExceptionRaised;

 {$IfNDef nsWithoutLogin}
 // Получаем интерфейс для авторизации и выводим окно ожидания, если идет конвертация настроек
 l_LongProcessMessage := TLongProcessForm{TenLongProcessMessage}.Create(
  TnsLongProcessData_C(MessageIDToString(inf_XMLImportRunning),
                       lptProcessWithoutExit,
                       {$IfDef XE}PAnsiChar(32516){$Else}IDI_INFORMATION{$EndIf}));
 try
  try
   l_NowDelta := EncodeTime(0, 0, 0, 0);     // 00 seconds
   l_NowDeltaMax := EncodeTime(0, 0, 30, 0); // 30 seconds
   l_NowDeltaStep := EncodeTime(0, 0, 1, 0); // 01 seconds
   //
   l_ShowCount := 0;
   l_ShowCountMin := 3;
   repeat
    l_Break := True;
    try
     f_Authorization := NativeAdapter.MakeAuthorization;
    except
     on EXMLImportRunning do
     begin
      Inc(l_ShowCount);
      if (l_ShowCount > l_ShowCountMin) then
       l_ShowCount := l_ShowCountMin;
      //
      if (l_ShowCount = l_ShowCountMin) then
       l_LongProcessMessage.Show;
      //
      l_NowDelta := l_NowDelta+l_NowDeltaStep;
      if (l_NowDelta > l_NowDeltaMax) then
       l_NowDelta := l_NowDeltaMax;
      //
      l_Now := Now;
      while ((Now-l_Now) <= l_NowDelta) do
      begin
       afw.ProcessMessages;
       Sleep(0);
      end;
      //
      l_Break := False;
     end;
    end;
   until l_Break;
  finally
   l_LongProcessMessage.Hide;
  end;
 finally
  vcmFree(l_LongProcessMessage);
 end;//try..finally
 {$EndIf nsWithoutLogin}

 // Получаем идентификатор по первому требованию
 ResetBooleans;
 f_CurrentUserID := -1;
 f_BaseSearchFirstExampleIndex := -1;
 f_TrialDaysLeft := 0;
 f_RegListXMLExportEnabled := GetStringFromRegistry(CDefaultRootKey, CDefaultPathKey,
  cRegListXMLExportEnabledName) = cRegListXMLExportEnabledValue;
 l_UserFlag := FM_FIRST_USER_FLAG;
 f_UserFlagShift := 0;
 while l_UserFlag <> 0 do
 begin
  l_UserFlag := l_UserFlag shr 1;
  Inc(f_UserFlagShift);
 end;
 if f_UserFlagShift > 0 then
  Dec(f_UserFlagShift);
end;

function TDataAdapter.HandleGlobalException(aSender: TObject; anException: Exception): Boolean;
begin
 Result := (anException is EevInvalidPrintMargins);
 if Result then
 begin
  if Assigned(g_Dispatcher) then
  begin
   g_Dispatcher.UpdateStatus;
   {$If not (defined(Monitorings) or defined(Admin))}
   if g_Dispatcher.FormDispatcher.CurrentMainForm.AsContainer.HasForm(fm_efPreviewForm.rFormID) then
    g_Dispatcher.History.Back;
   {$IfEnd not (defined(Monitorings) or defined(Admin))}
  end;//g_Dispatcher
  // http://mdp.garant.ru/pages/viewpage.action?pageId=508825964
  vcmShowMessageDlg(Tl3Message_C(str_warInvalidMargins,
                                 mtWarning));
 end;//Result
end;

procedure TDataAdapter.GlobalExceptionRaised(aSender: TObject; anException: Exception);
var
 lTemp : Il3CString;
begin
// Сейчас не востребовано, т.к. обработчик в библиотеке m0exclib работает
// некорректно и сбрасывает наш обработчик!!!
//
// if Assigned(f_OldOnExceptionEvent) then
//  f_OldOnExceptionEvent(aSender, anException);

 // Запись в Log
 if not f_InTerminateProcess then
 begin
  if HandleGlobalException(aSender, anException) then exit;
  l3System.Exception2Log(anException);

  if anException is ENoServer then
   // Если пытаться показать данные дилера, если сервер недоступен
   // Иначе летит еще одно исключение
   // http://mdp.garant.ru/pages/viewpage.action?pageId=449026895
   AbnormalTermination(inf_ServerShutDown, False)
  else
  if anException is EServerIsStarting then
   AbnormalTermination(inf_ServerIsStarting)
  else
  if anException is EInvalidUserDatastore then
   AbnormalTermination(war_InvalidUserDatastore)
  else
  if anException is EInternalServerError then
   AbnormalTermination(err_InternalServerError)
  else
  if (anException is EIPAddressNotFound) or
     (anException is EBadNetworkConfig) then
   AbnormalTermination(inf_NoInformation)
  else
  if anException is EStorageLocked then
   AbnormalTermination(inf_UpdateInProgress)
  else
  if (anException is EShutdownInited) then
   AbnormalTermination(inf_ShutdownInProgress)
  else
  if (anException is EInternalDatabaseError) then
  begin
   AbnormalTermination(err_InternalDatabaseError)
  end
  else
  if anException is EHelpSystemException then
  begin
   // Флажок от рекурсивного вхождения нужен поскольку
   // винда все равно откудато отрывает F1 и превращает
   // его в WM_HELP. При назначенном на операцию шорткате
   // имеем двойной вложенный вызов хелпа
   // и соответственно удвоенное сообщения об ошибке
   if not f_LockHelpException then
   begin
    f_LockHelpException := True;
    try
     vcmSay(war_HelpNotFound)
    finally
     f_LockHelpException := False;
    end;//try..finally
   end;//not f_LockHelpException
  end//anException is EHelpSystemException
  else
  begin
   // Для висты показываем WER диалог и отваливаем
   if nsReportError(anException) then
     AbnormalTermination;
   // Информация на экран
   try
    lTemp := l3Trim(GetDealerInfo);
   except
    // если исключение произошло при получении DealerInfo, то значит совсем всё плохо.
    on E: Exception do
    begin
     l3System.Exception2Log(E);
     lTemp := nil;
    end;
   end;//try..except
   if not l3IsNil(lTemp) and not l3IsChar(lTemp, l3Len(lTemp)-1, [';', '.']) then
    lTemp := l3Cat(lTemp, '.');
   vcmSay(err_NotHandledException, [anException.Message, lTemp]);
  end;//anException is EShutdownInited
 end;//not f_InTerminateProcess
end;

function GetModuleHandle(lpModuleName: LPCSTR): HMODULE; stdcall; external kernel32 name 'GetModuleHandleA';
function LoadLibrary(lpLibFileName: LPCSTR): HMODULE; stdcall; external kernel32 name 'LoadLibraryA';
function GetProcAddress(hModule: HMODULE; lpProcName: LPCSTR): FARPROC; stdcall; external kernel32 name 'GetProcAddress';

procedure GetProcedureAddress(var P: Pointer; const aModule: AnsiString;
                              const ProcName: AnsiString);
var
 ModuleHandle: HMODULE;
begin
 if not Assigned(P) then
 begin
  ModuleHandle := GetModuleHandle(PAnsiChar(aModule));
  if ModuleHandle = 0 then
  begin
   ModuleHandle := LoadLibrary(PAnsiChar(aModule));
   if ModuleHandle = 0 then
    raise ELoadLibraryError.CreateFmt(vcmConstString(str_aeDLLNotFound),[aModule]);
  end;
  P := GetProcAddress(ModuleHandle, PAnsiChar(ProcName));
  if not Assigned(P) then
   raise EGetProcAddressError.CreateFmt(vcmConstString(str_aeDLLOperationNotFound),[aModule, ProcName]);
 end;
end;

procedure TDataAdapter.ShowMessageWithDealerInfo(const aMsg: TvcmMessageID);
var
 l_Info : Il3CString;
begin
 l_Info := nil;
 try
  l_Info := GetDealerInfo;
 except
  // может так случиться, что info получить не удастся. Это не повод молча закрываться.
  on E: Exception do
   l3System.Exception2Log(E);
 end;//try..except
 if (aMsg.rM <> inf_NoInformation.rM) then
  vcmSay(aMsg, [l_Info]);
end;

procedure TDataAdapter.AbnormalTermination(const aMsg: TvcmMessageID;
 aShowDealerInfo: Boolean = True);
begin
 f_InTerminateProcess := True;
 // http://mdp.garant.ru/pages/viewpage.action?pageId=449021721
 try
  if aShowDealerInfo then
   ShowMessageWithDealerInfo(aMsg)
  else
   vcmSay(aMsg);
 // Если оболочка срубается на этапе загрузки - не убиваемся здесь, а делаем
 // это выше, чтобы закрыть сплэш
 // http://mdp.garant.ru/pages/viewpage.action?pageId=449026895
 finally
  AbnormalTermination(not f_InStartUpProcess);
 end;
end;

function TDataAdapter.pm_GetRegistryLogin: AnsiString;
begin
 Result := GetStringFromRegistry(CDefaultRootKey, CDefaultPathKey, CLoginValueName);
end;

procedure TDataAdapter.pm_SetRegistryLogin(const aValue: AnsiString);
begin
 if (RegistryLogin <> aValue) then
  PutStringToRegistry(CDefaultRootKey, CDefaultPathKey, CLoginValueName, aValue);
end;

function TDataAdapter.pm_GetRegistryPasswordExists: Boolean;
begin
 Result := StringExistsInRegistry(CDefaultRootKey, CDefaultPathKey, CPasswordValueName);
end;

function TDataAdapter.pm_GetRegistryPassword: AnsiString;
begin
 Result := DecodePassword(GetStringFromRegistry(CDefaultRootKey, CDefaultPathKey, CPasswordValueName));
end;

procedure TDataAdapter.pm_SetRegistryPassword(const aValue: AnsiString);
begin
 if not RegistryPasswordExists or (RegistryPassword <> aValue) then
  PutStringToRegistry(CDefaultRootKey, CDefaultPathKey, CPasswordValueName, EncodePassword(aValue));
end;

function TDataAdapter.pm_GetRegistryIsAutoLogin: Boolean;
begin
 Result := GetBooleanFromRegistry(CDefaultRootKey, CDefaultPathKey, CIsAutoLoginValueName);
end;

procedure TDataAdapter.pm_SetRegistryIsAutoLogin(const aValue: Boolean);
begin
 if (RegistryIsAutoLogin <> aValue) then
  PutBooleanToRegistry(CDefaultRootKey, CDefaultPathKey, CIsAutoLoginValueName, aValue);
end;

{$If not Defined(nsWithoutLogin)}
function TDataAdapter.TestLoginName(const aName: Il3CString): Boolean;
begin
 f_AdministratorLogin := l3Same(aName, cSystemLogin);
 if f_AdministratorLogin then
  {$IFNDEF Admin}
  begin
   Result := False;
   vcmSay(err_AdminLoginDenied);
  end
  {$ELSE}
   Result := True
  {$ENDIF}
 else
  Result := True;
end;

function TDataAdapter.LoginAction(aSender: TCustomForm): TModalResult;
var
 l_Data: Il3CString;
 l_Form: TLoginForm;
begin
 Result := mrNone;
 //
 if Assigned(aSender) and (aSender is TLoginForm) then
 begin
  l_Form := aSender as TLoginForm;
  if TestLoginName(l_Form.Login) then
  try
   try
    f_Authorization.Login(nsAStr(l_Form.Login).S,
                          nsAStr(l_Form.Password).S);
    f_CommonInterfaces := NativeAdapter.MakeCommon;
   except
    on E: EStorageLocked do
    begin
     l_Form.Hide;
     AbnormalTermination(inf_UpdateInProgress);
    end;//on E: EStorageLocked
   end;//try..except
   {$IfDef nsAutoLoginDisable}
   {$else}
   RegistryLogin := l3Str(l_Form.Login);
   RegistryPassword := l3Str(l_Form.Password);
   RegistryIsAutoLogin := l_Form.IsAutoLogin;
   {$EndIf}
   //
   Result := mrOk;
  except
   on EAccountDisabled do
    vcmSay(err_AccountDisabled, [l_Form.Login]);
   on EAlreadyLogged do
    {$IfDef InsiderTest}
    {$IfNDef Admin}
    if TdmStdRes.IsBatchMode then
    begin
     while true do
     begin
      try
       l_Form.edUserName.Text := l3CStr('tester' + IntToStr(Random(65535)));
       Assert(f_Authorization <> nil);
       f_Authorization.
         Autoregistration(nsAStr(l_Form.Login).S,
                          nsAStr(l_Form.Login).S,
                          nsAStr(l_Form.Password).S,
                          nsAStr(''));
       f_CommonInterfaces := NativeAdapter.MakeCommon;
       Result := mrOk;
      except
       on ELoginDuplicate do
        continue;
      end;//try..except
      break;
     end;//while true
    end//TdmStdRes.IsBatchMode
    else
    {$EndIf Admin}
    {$EndIf InsiderTest}
     vcmSay(err_UserAlreadyWorks, [l_Form.Login]);
   on EWrongAuthentication do
    {$IfDef InsiderTest}
    if TdmStdRes.IsBatchMode then
    begin
     //aSender.NewUserLabelClick(aSender.NewUserLabel);
      Assert(f_Authorization <> nil);
      f_Authorization.
        Autoregistration(nsAStr(l_Form.Login).S,
                         nsAStr(l_Form.Login).S,
                         nsAStr(l_Form.Password).S,
                         nsAStr(''));
      f_CommonInterfaces := NativeAdapter.MakeCommon;
     Result := mrOk;
    end//TdmStdRes.IsBatchMode
    else
    {$EndIf InsiderTest}
     vcmSay(err_BadLoginOrPassword);
   on EXMLImportRunning do
    vcmSay(inf_XMLImportRunning);
   on ELicenceViolation do
    {$If defined(Monitorings) or defined(Admin)}
    begin
     SayWithProtectionCheck(err_ConnectionsLicenceViolation);
     Result := mrAbort;
    end;//on ELicenceViolation
    {$ELSE}
    if SayWithProtectionCheck(err_ConnectionsLicenceViolation) then
     Result := mrCancel;
    {$IfEnd defined(Monitorings) or defined(Admin)}
   on ENoMoreConnections do
   {$If defined(Monitorings) or defined(Admin)}
    begin
     SayWithProtectionCheck(NoMoreConnectionsMessage(l_Data), [l_Data]);
     Result := mrAbort;
    end;//on ENoMoreConnections
   {$ELSE}
    if SayWithProtectionCheck(NoMoreConnectionsMessage(l_Data), [l_Data]) then
     Result := mrCancel;
   {$IfEnd defined(Monitorings) or defined(Admin)}
   on ETrialPeriodExpired do
   begin
    {$If defined(Monitorings) or defined(Admin)}
    SayWithProtectionCheck(err_TrialPeriodExpired);
    Result := mrAbort;
    {$ELSE}
    SayWithProtectionCheck(err_TrialPeriodExpired);
    Result := mrCancel;
    {$IfEnd defined(Monitorings) or defined(Admin)}
   end;//on ETrialPeriodExpired
  end;//try..except
 end;
end;
{$IfEnd not Defined(nsWithoutLogin)}

{$If not (defined(Monitorings) or defined(Admin))}
function TDataAdapter.RememberPassword(aSender: TCustomForm): TModalResult;
begin
 Result := mrNone;
 if not Assigned(aSender) then
  Exit;

 if aSender is TRememberPasswordForm then
 try
  f_Authorization.SendUserInfoByEmail(nsAStr(TRememberPasswordForm(aSender).EMail).S);
  vcmSay(inf_AutorisationDataSent);
  Result := mrOk;
 except
  on ESMTPServerAddressNotDefined do
   vcmSay(war_SMTPServerNotDefined, [GetDealerInfo]);
  on ESMTPServerNotFound do
   vcmSay(war_SMTPServerNotFound);
  on EUserNotFound do
   vcmSay(war_UserNotExist);
  on EBadSMTPReply do
   vcmSay(war_BadSMTPReply);
  on ESMTPAuthorizationFailed do
   vcmSay(war_SMTPAuthorizationFailed, [GetDealerInfo]);
  on E: EStorageLocked do
  begin
   aSender.Hide;
   AbnormalTermination(inf_UpdateInProgress);
  end;//on E: EStorageLocked
 end;//try..except
end;

function TDataAdapter.RegisterAction(aSender: TCustomForm): TModalResult;
var
 l_Data: Il3CString;
 l_Form: TnsRegistrationForm;
begin
 Result := mrNone;
 //
 if not Assigned(aSender) or
    not (aSender is TnsRegistrationForm) then
  Exit;

 l_Form := (aSender as TnsRegistrationForm);
 if not TestLoginName(l_Form.Login) then
  Exit;
 //

 if not f_Authorization.GetAutoregistrationStatus then
 begin
  ShowAutoregistrationDisabledMessage;
  Exit;
 end;

 try
  try
   f_Authorization.Autoregistration(nsAStr(l_Form.UserName).S,
                                    nsAStr(l_Form.Login).S,
                                    nsAStr(l_Form.Password).S,
                                    nsAStr(l_Form.EMail).S);
   f_CommonInterfaces := NativeAdapter.MakeCommon;
  except
   on E: EStorageLocked do
   begin
    l_Form.Hide;
    AbnormalTermination(inf_UpdateInProgress);
   end;
   on E: EAccessDenied do
   begin
    ShowAutoregistrationDisabledMessage;
    Exit;
   end;
  end;
 {$IfDef nsAutoLoginDisable}
 if (l_Form.Login = cMonitoringLogin) and
   (l_Form.Password = cMonitoringPassword) then
 begin
  RegistryLogin := l_Form.Login;
  RegistryPassword := l_Form.Password;
  RegistryIsAutoLogin := True;
 end;  //if (l_Form.Login = cMonitoringLogin)...
 {$else}
  RegistryLogin := l3Str(l_Form.Login);
  RegistryPassword := l3Str(l_Form.Password);
  RegistryIsAutoLogin := l_Form.IsAutoLogin;
 {$EndIf}
  Result := mrOk;

 except
  on ELoginDuplicate do
   case vcmMessageDlg(str_AutologinDuplicate, []) of
   -1: l_Form.IncreaseLogin;
   -2:
    begin
     Result := mrAbort;
    end;
   end;
  on EWrongAuthentication do
   vcmSay(err_WrongAuthentification);
  on EXMLImportRunning do
   vcmSay(inf_XMLImportRunning);
  on ELicenceViolation do
   if SayWithProtectionCheck(err_ConnectionsLicenceViolation) then
    Result := mrCancel;
  on ENoMoreProfiles do
   if SayWithProtectionCheck(err_UsersLicenceViolation) then
    Result := mrCancel;
  on ENoMoreConnections do
  begin
   if SayWithProtectionCheck(NoMoreConnectionsMessage(l_Data), [l_Data]) then
    Result := mrCancel;
   if l_Form.CanRelogin then
    Result := mrRetry;
  end;
  on ETrialPeriodExpired do
  begin
   SayWithProtectionCheck(err_TrialPeriodExpired);
   Result := mrCancel;
  end; 
 end;
end;

procedure TDataAdapter.SendPassword;
var
 l_Form: IvcmEntityForm;
 l_RememberPasswordForm: TRememberPasswordForm;
begin
 l_Form := TRememberPasswordForm.Make;
 Assert(l_Form.VCLWinControl is TRememberPasswordForm);
 l_RememberPasswordForm := l_Form.VCLWinControl as TRememberPasswordForm; //TRememberPasswordForm.Create(nil);
 try
  l_RememberPasswordForm.SendAction := RememberPassword;
  l_RememberPasswordForm.ShowModal;
 finally
  //vcmFree(l_RememberPasswordForm);
  l_Form := nil;
 end;
end;
{$IfEnd not (defined(Monitorings) or defined(Admin))}

{$If not Defined(nsWithoutLogin)}
function TDataAdapter.DesktopAutoRegistration: Boolean;
const
 cDesktopLogin = 'ADMINISTRATOR';
 cDesktopPassword = 'ADMINISTRATOR';
var
 l_CurName : Il3CString;
 l_Data    : Il3CString;
begin
 Result := False;
 l_CurName := GetCurrentUserName;

 try
  f_Authorization.Autoregistration(nsAStr(l_CurName).S,
                                   nsAStr(cDesktopLogin),
                                   nsAStr(cDesktopPassword),
                                   nsAStr(''));
  f_CommonInterfaces := NativeAdapter.MakeCommon;
 {$IfDef nsAutoLoginDisable}
 {$else}
  RegistryLogin := cDesktopLogin;
  RegistryPassword := cDesktopPassword;
  RegistryIsAutoLogin := true;
 {$EndIf}
  Result := True;
 except
  on ELoginDuplicate do
   vcmSay(war_LoginDuplicate, [cDesktopLogin]);
  on EWrongAuthentication do
   vcmSay(err_WrongAuthentification);
  on EXMLImportRunning do
   vcmSay(inf_XMLImportRunning);
  on ELicenceViolation do
   if SayWithProtectionCheck(err_ConnectionsLicenceViolation) then
    Abort;
  on ENoMoreProfiles do
   if SayWithProtectionCheck(err_UsersLicenceViolation) then
    Abort;
  on ENoMoreConnections do
   if SayWithProtectionCheck(NoMoreConnectionsMessage(l_Data), [l_Data]) then
    Abort;
  on ETrialPeriodExpired do
  begin
   SayWithProtectionCheck(err_TrialPeriodExpired);
   Abort;
  end;
 end;
end;

function TDataAdapter.AutoLogin(const aLogin, aPassword: Il3CString): Boolean;
var
 l_Data: Il3CString;
begin
 Result := False;
 //
 if not TestLoginName(aLogin) then
  Exit;
 //
 try
  f_Authorization.Login(nsAStr(aLogin).S,
                        nsAStr(aPassword).S);
  f_CommonInterfaces := NativeAdapter.MakeCommon;
  Result := True;
 except
  on EAccountDisabled do
   vcmSay(err_AccountDisabled, [aLogin]);
  on EAlreadyLogged do
  {$If defined(Monitorings) or defined(Admin)}
  begin
    vcmSay(err_UserAlreadyWorks, [aLogin]);
    Abort;
  end;
  {$ELSE  defined(Monitorings) or defined(Admin)}
   vcmSay(err_UserAlreadyWorks, [aLogin]);
  {$IfEnd defined(Monitorings) or defined(Admin)}
  on EWrongAuthentication do
   vcmSay(err_BadLoginOrPassword);
  on EXMLImportRunning do
   vcmSay(inf_XMLImportRunning);
  on ELicenceViolation do
   if SayWithProtectionCheck(err_ConnectionsLicenceViolation) then
    Abort;
  on ENoMoreConnections do
   if SayWithProtectionCheck(NoMoreConnectionsMessage(l_Data), [l_Data]) then
    Abort;
  on ETrialPeriodExpired do
  begin
   SayWithProtectionCheck(err_TrialPeriodExpired);
   Abort;
  end;
  on E: EStorageLocked do
   AbnormalTermination(inf_UpdateInProgress);
 end;
end;

function TDataAdapter.Login(const aLogin: Il3CString;
                            anIsAutoLogin: Boolean): Boolean;
var
 l_Password    : Il3CString;
 l_Login       : Il3CString;
 l_LoginForm   : TLoginForm;
 l_NewLogin : Il3CString;
 {$If not (defined(Monitorings) or defined(Admin))}
 l_NewPassword: Il3CString;
 l_NewAutoLogin: Boolean;
 l_NeedTryRelogin: Boolean;
 l_IsAutoLogin : Boolean;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}
begin
 Result := False;
 l_NewLogin := aLogin;
 l_LoginForm := nil;
 repeat
  {$If not (defined(Monitorings) or defined(Admin))}
  l_NeedTryRelogin := False;
  {$IfEnd not (defined(Monitorings) or defined(Admin))}
  if l_LoginForm = nil then
   l_LoginForm := TLoginForm.Create(nil, l_NewLogin, anIsAutoLogin);
  try
   l_LoginForm.LoginAction := LoginAction;
   case l_LoginForm.ShowModal of
    mrOk:
     begin
      AssemblyInfo.SetFirstStart(False);
      Result := True;
      break;
     end;
    mrCancel:
     if l_LoginForm.ForgetPasswordChosen then // `Забыли пароль?`
     begin
      vcmFree(l_LoginForm);
      {$If not (defined(Monitorings) or defined(Admin))}
      SendPassword
      {$IfEnd not (defined(Monitorings) or defined(Admin))}
     end
     else
      if l_LoginForm.NewUserChosen then // `Новый пользователь`
      begin
       // Этот шаманский кусок нужен здесь потому, что в противном случае
       // мы имеем фокус, ушедший в никуда
       l_Login := l_LoginForm.Login;
       l_Password := l_LoginForm.Password;
       {$If not (defined(Monitorings) or defined(Admin))}
       l_IsAutoLogin := l_LoginForm.IsAutoLogin;
       {$IfEnd not (defined(Monitorings) or defined(Admin))}
       vcmFree(l_LoginForm);
       {$If not (defined(Monitorings) or defined(Admin))}
       if Registration(l_Login, l_Password, l_IsAutoLogin, True, @l_NewLogin, @l_NewPassword, @l_NewAutoLogin, @l_NeedTryRelogin) then
       begin
        AssemblyInfo.SetFirstStart(False);
        Result := True;
        break;
       end
       else
        if l_NeedTryRelogin then
         l_LoginForm := TLoginForm.CreateForRelogin(nil, l_NewLogin, l_NewPassword, l_NewAutoLogin);
       {$IfEnd not (defined(Monitorings) or defined(Admin))}
      end
      else
       break;
    {$If defined(Monitorings) or defined(Admin)}
    mrAbort: break;
    {$IfEnd defined(Monitorings) or defined(Admin)}
   end;
  finally
   {$If not (defined(Monitorings) or defined(Admin))}
   if not l_NeedTryRelogin and Assigned(l_LoginForm) then
   {$IfEnd not (defined(Monitorings) or defined(Admin))}
    vcmFree(l_LoginForm);
  end;//try..finally
 until False;
end;
{$IfEnd not Defined(nsWithoutLogin)}

{$If not (defined(Monitorings) or defined(Admin))}
function TDataAdapter.Registration(const aLogin, aPassword : Il3CString;
                                   aIsAutoLogin            : Boolean;
                                   CanRelogin: Boolean = False;
                                   const aNewLogin: PIl3CString = nil;
                                   const aNewPassword: PIl3CString = nil;
                                   const aNewAutoLogin: PBoolean = nil;
                                   const aNeedTryRelogin: PBoolean = nil): Boolean;
var
 l_RegistrationForm: TnsRegistrationForm;
 l_Form: IvcmEntityForm;
begin
 l_Form := TnsRegistrationForm.Make(aIsAutoLogin, CanRelogin);
 l_RegistrationForm := l_Form.VCLWinControl as TnsRegistrationForm; //TnsRegistrationForm.Create(nil, aIsAutoLogin, CanRelogin);
 try
  if Assigned(aNeedTryReLogin) then
   aNeedTryReLogin^ := False;

  l_RegistrationForm.RegisterAction := RegisterAction;

  if l3IsNil(aLogin) and
     l3IsNil(aPassword) then
   l_RegistrationForm.Login := GetCurrentUserName
  else
  begin
   l_RegistrationForm.Login := aLogin;
   l_RegistrationForm.Password := aPassword;
  end;

  Result := l_RegistrationForm.ShowModal = mrOk;
  if Assigned(aNewLogin) and (l_RegistrationForm.ModalResult = mrRetry) then
   aNewLogin^ := l_RegistrationForm.Login;
  if (l_RegistrationForm.ModalResult = mrAbort) and Assigned(aNewLogin) and
     Assigned(aNewPassword) and Assigned(aNewAutoLogin) and Assigned(aNeedTryReLogin) then
  begin
   aNewLogin^ := l_RegistrationForm.Login;
   aNewPassword^ := l_RegistrationForm.Password;
   aNewAutoLogin^ := l_RegistrationForm.IsAutoLogin;
   aNeedTryReLogin^ := True;
  end;
 finally
  l_Form := nil;
  //vcmFree(l_RegistrationForm);
 end;
end;

procedure TDataAdapter.OpenIntranet;
var
 l_Str: IString;
begin
 with NativeAdapter.MakeInternetSupport do
  if RevisionCheckEnabled then
  begin
   GetUrlForInternetVersion(l_Str);
   nsDoShellExecute(nsCStr(l_Str), False, nil, True);
  end;
end;

procedure TDataAdapter.OpenIntranetDocument(aDocID, aParaID: Longword; aNeedCheck : Boolean);
var
 l_Str: IString;
begin
 with NativeAdapter.MakeInternetSupport do
  if not aNeedCheck OR RevisionCheckEnabled then
  begin
   GetUrlForDocument(aDocID, aParaID, l_Str);
   nsDoShellExecute(nsCStr(l_Str), False, nil, True);
  end;//not aNeedCheck OR RevisionCheckEnabled
end;
{$IfEnd not (defined(Monitorings) or defined(Admin))}

function TDataAdapter.SayWithProtectionCheck(const aMessageID: TvcmMessageID): Boolean;
  // overload;
  {-}
begin
 Result := SayWithProtectionCheck(aMessageId, []);
end;//SayWithProtectionCheck

function TDataAdapter.SayWithProtectionCheck(const aMessageID : TvcmMessageID;
                                             const aData      : array of const): Boolean;
var
 l_ProtectionError: Longint;
begin
 Result := False;
 {$IfNDef nsWithoutLogin}
 if (f_Authorization <> nil) then
 begin
  l_ProtectionError := f_Authorization.GetProtectionError;
  if (l_ProtectionError = 0) then
   vcmSay(aMessageID, aData)
  else
  begin
   Result := True;
   vcmSay(err_ProtectionError, [l_ProtectionError]);
  end;
 end
 else
 {$EndIf  nsWithoutLogin}
  vcmSay(aMessageID, aData);
end;

{$If not Defined(nsWithoutLogin)}
procedure TDataAdapter.LoginSequence;

 function GetCommandLineLoginPassword(out aLogin    : Il3CString;
                                      out aPassword : Il3CString): Boolean;

  function GetCommandLineParamValue(const aParamName: string): Il3CString;
  var
   l_Index: Integer;
  begin
   Result := nil;
   //
   for l_Index := 1 to ParamCount do
    if (StrIComp(PChar(ParamStr(l_Index)), PChar(aParamName)) = 0) then
    begin
     Result := nsCStr(ParamStr(Succ(l_Index)));
     Break;
    end;
  end;

 begin
  Result := False;
  //
  aLogin := GetCommandLineParamValue('-F1ShellLogin');
  if not l3IsNil(aLogin) then
  begin
   aPassword := GetCommandLineParamValue('-F1ShellPassword');
   Result := True;
  end
  else
   aPassword := nil;
 end;
 //
 function IsMagicKeyPressed: Boolean;
 begin
  Result := (GetAsyncKeyState(VK_SHIFT) < 0); // здесь нужно использовать асинхронный опрос статуса клавиатуры (CQ:10898)
 end;
var
 l_Login,
 l_Password: Il3CString;
 l_NeedLoginForm,
 l_FirstStart,
 l_Desktop,
 l_IsAutoLogin: Boolean;
 l_PasswordExists: Boolean;
begin
 l_NeedLoginForm := False;

{$IFDEF nsAutoLoginDisable}
{$If defined(Monitorings)}
 l_Login := nsCStr(cMonitoringLogin);
 l_Password := nsCStr(cMonitoringPassword);
 l_IsAutoLogin := True;
 l_PasswordExists := True;
{$ELSEIf defined(Admin)}
 l_Login := nsCStr(cSystemLogin);
 l_Password := nil;
 l_IsAutoLogin := False;
 l_PasswordExists := False;
{$ELSE}
 l_Login := nil;
 l_Password := nil;
 l_IsAutoLogin := False;
{$IFEnd defined(Monitorings) or defined(Admin)}
 l_FirstStart := False;
{$ELSE  nsAutoLoginDisable}

 if GetCommandLineLoginPassword(l_Login, l_Password) then
 begin
  if (f_Authorization <> nil) then
   with f_Authorization do
    try
     Autoregistration(nsAStr(l_Login).S,
                      nsAStr(l_Login).S,
                      nsAStr(l_Password).S,
                      nsAStr(''));
     f_CommonInterfaces := NativeAdapter.MakeCommon;
     Exit;
    except
     on E: Exception do
      l3System.Exception2Log(E);
     // авторегистрация не прошла - будем пытаться делать обычный авто-логин
    end;
  //
  l_PasswordExists := True;
  l_IsAutoLogin := True;
  l_FirstStart := False;
 end
 else
 begin
  l_Login := nsCStr(RegistryLogin);
  l_Password := nsCStr(RegistryPassword);
  l_PasswordExists := RegistryPasswordExists;
  l_IsAutoLogin := RegistryIsAutoLogin;

  l_FirstStart := AssemblyInfo.GetFirstStart;
 end;
{$ENDIF nsAutoLoginDisable}

 if l_FirstStart then
 begin
  // Первый запуск оболочки
  l_Desktop := AssemblyInfo.GetIsDesktop;
  if l_Desktop then
  begin
   if DesktopAutoRegistration then
    AssemblyInfo.SetFirstStart(False)
   else
    // Регистрация не прошла
    l_NeedLoginForm := True;
  end
  else // l_Desktop and (GetOldUsersCount <= 1)
  {$If not (defined(Monitorings) or defined(Admin))}
   if Registration(nil, nil, False) then
    AssemblyInfo.SetFirstStart(False)
   else
    // Регистрация не прошла
  {$IfEnd not (defined(Monitorings) or defined(Admin))}
    l_NeedLoginForm := True;
 end
 else // l_FirstStart
 begin
  if l_IsAutoLogin and
     (not IsMagicKeyPressed) and
     not l3IsNil(l_Login) and
     l_PasswordExists then
  begin
   // Автологин
   if not AutoLogin(l_Login, l_Password) then
    l_NeedLoginForm := True;
  end
  else
   l_NeedLoginForm := True;
 end;

 if l_NeedLoginForm then
 begin
  // Обычный логин
  if not Login(l_Login, {l_Password, }l_IsAutoLogin) then
   Abort;
 end;
end;
{$Else}
procedure TDataAdapter.InitCommon;
begin
 f_CommonInterfaces := NativeAdapter.MakeCommon;
end;
{$IfEnd not Defined(nsWithoutLogin)}

procedure TDataAdapter.InitFields;
  //override;
  {-}
begin
 inherited;
end;

procedure TDataAdapter.Cleanup;
begin
// Сейчас не востребовано, т.к. обработчик в библиотеке m0exclib работает некорректно и сбрасывает наш обработчик!!!
// if Assigned(f_OldOnExceptionEvent) then
//  Application.OnException := f_OldOnExceptionEvent;
 f_ShutDowning := True;
 f_AdminInfo := nil;
 WaitForBuildingDeferredTrees;
 {$If not (defined(Monitorings) or defined(Admin))}
 vcmFree(f_BuildingDefferedTreesList);
 {$IfEnd}
 f_BaseSearchFirstExampleIndex := -1;
 {$IfNDef nsWithoutLogin}
 f_InstallDefaultSettingsInfo := nil;
 {$EndIf  nsWithoutLogin}
 f_CRSimpleListTypeRootNode := nil;
 f_Integration := nil;
 f_Search := nil;
 f_Folders := nil;
 {$If not (defined(Monitorings) or defined(Admin))}
 f_ControlMgr := nil;
 {$IfEnd}
 f_NativeAdapter := nil;
 f_AssemblyInfo := nil;
 {$If not (defined(Monitorings) or defined(Admin))}
 f_TimeMachine := nil;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}
 f_CommonInterfaces := nil;
 f_Monitoring := nil;
 f_NotifyManager := nil;
 f_ConsultationManager := nil;
 f_LogManager := nil;
 //f_UserATPrefixName := nil;
 f_ChatManager := nil;
 f_MessageManager := nil;
 {$If defined(nsWithoutLogin)}
 {$IfNDef nsWithoutLogin}
 Assert(f_Authorization = nil);
 {$EndIf  nsWithoutLogin}
 {$IfEnd not defined(nsWithoutLogin)}
 {$IfNDef nsWithoutLogin}
 f_Authorization := nil; // !!! Это освобождение должно быть последним, т.к. в нем происходит Logout пользователя
 {$EndIf  nsWithoutLogin}
 inherited;
end;

function TDataAdapter.CreateEmptyQuery(aType: TQueryType): IQuery;
var
 l_Search : ISearch;
begin
 Result := nil;
 l_Search := NativeAdapter.MakeSearch;
 try
  if (l_Search <> nil) then
   l_Search.CreateQuery(aType, Result);
 finally
  l_Search := nil;
 end;
end;

function TDataAdapter.GetOldBaseWarning: Il3CString;
var
 l_CI      : IComplectInfo;
 l_Warning : IString;
begin
 l_CI := NativeAdapter.MakeComplectInfo;
 try
  l_CI.GetOldBaseWarning(l_Warning);
  try
   Result := nsCStr(l_Warning);
  finally
   l_Warning := nil;
  end;//try..finally
 finally
  l_CI := nil;
 end;//try..finally
end;

(*function TDataAdapter.GetMissingBlocksForCR(const aCRType: INodeBase): Il3CString;
 // overload;
var
 l_CI     : IComplectInfo;
 l_Values : IStringList;
 l_Value  : IString;
 l_Index  : Integer;
begin
 Result := nil;
 l_CI := NativeAdapter.MakeComplectInfo;
 try
  l_CI.GetMissingBlocksByType(aCRType, l_Values);
  if Assigned(l_Values) then
  try
   for l_Index := 0 to Pred(l_Values.Count) do
   begin
    l_Values.pm_GetItem(l_Index, l_Value);
     if l3IsNil(Result) then
     Result := nsCStr(l_Value)
     else
     Result := l3Cat([l3Cat(Result, #13), nsCStr(l_Value)]);
   end;
  finally
   l_Values := nil;
  end;//try..finally
 finally
  l_CI := nil;
 end;//try..finally
end;*)

function TDataAdapter.GetDealerInfo: Il3CString;
var
 l_ComplectInfo : IComplectInfo;
 l_DealerInfo   : IString;
begin
 l_ComplectInfo := NativeAdapter.MakeComplectInfo;
 try
  try
   l_ComplectInfo.GetDealerInfo(l_DealerInfo);
  except
   on EStorageLocked do
   // http://mdp.garant.ru/pages/viewpage.action?pageId=294597335
   begin
    Result := l3CStr('');
    Exit;
   end;//EStorageLocked
  end;//try..except
  try
   Result := nsCStr(l_DealerInfo);
  finally
   l_DealerInfo := nil;
  end;//try..finally
 finally
  l_ComplectInfo := nil;
 end;//try..finally
end;

function TDataAdapter.GetUnexistDocMessage: Il3CString;
var
 l_CI      : IComplectInfo;
 l_Warning : IString;
begin
 l_CI := NativeAdapter.MakeComplectInfo;
 try
  l_CI.GetUnexistDocMessage(l_Warning);
  try
   Result := nsCStr(l_Warning);
  finally
   l_Warning := nil;
  end;//try..finally
 finally
  l_CI := nil;
 end;//try..finally
end;

function TDataAdapter.pm_GetMonitoring: IMonitoring;
  {-}
begin
 if not Assigned(f_Monitoring) then
  f_Monitoring := NativeAdapter.MakeMonitoring;
 Result := f_Monitoring;
end;

function TDataAdapter.pm_GetNativeAdapter: IGblAdapterDll;
begin
 Assert(Assigned(f_NativeAdapter));
 Result := f_NativeAdapter;
end;

function TDataAdapter.pm_GetSettings : ISettingsManager;
begin
 {$If not defined(nsWithoutLogin)}
 if Assigned(f_CommonInterfaces) then
  CommonInterfaces.GetSettingsManager(Result)
 else
  Result := nil;
 {$Else}
  Result := nil;
 {$IfEnd not defined(nsWithoutLogin)}
end;

function TDataAdapter.pm_GetPermanentSettings : IBaseSettingsManager;
begin
 {$If not defined(nsWithoutLogin)}
  Result := NativeAdapter.MakePermanentSettingsManager;
 {$Else}
  Result := NativeAdapter.MakePrimeSettingsManager;
 {$IfEnd not defined(nsWithoutLogin)}
end;

function TDataAdapter.pm_GetFolders : IFolders;
begin
 if (f_Folders = nil) and
    not f_AdministratorLogin then
  f_Folders := NativeAdapter.MakeFolders;
 Result := f_Folders;
end;

function TDataAdapter.pm_GetFoldersRoot : INode;
begin
 if not f_AdministratorLogin then
  Folders.GetRoot(Result)
 else
  Result := nil; 
end;

function TDataAdapter.pm_GetCurrentBaseDate: BaseTypesUnit.TDate;
begin
 if IsDateEqual(f_CurBaseDate, cNullDate) and
    Assigned(f_CommonInterfaces) then
  f_CommonInterfaces.GetBaseDate(f_CurBaseDate);
 Result := f_CurBaseDate;
end;

{$If not Defined(Admin) AND not Defined(Monitorings) }
function TDataAdapter.pm_GetTimeMachine: InsTimeMachine;
begin
{$If not (defined(Monitorings) or defined(Admin))}
 if not Assigned(f_TimeMachine) then
  f_TimeMachine := TnsTimeMachine.Make(cNullDate);

 Result := f_TimeMachine;
{$Else not (defined(Monitorings) or defined(Admin))}
 Result := nil;
{$IfEnd not (defined(Monitorings) or defined(Admin))}
end;
{$IfEnd}

function TDataAdapter.pm_GetSearch: ISearch;
begin
 if f_Search = nil then
  f_Search := NativeAdapter.MakeSearch;
 Result := f_Search;
end;

function TDataAdapter.pm_GetDocDefaultLang: TbsLanguage;
begin
 Result := StrToLang(afw.Settings.LoadString(pi_DefaultDocLanguage, dv_IfaceLanguage));
end;

{$If not (defined(Monitorings) or defined(Admin))}
function TDataAdapter.pm_GetControlMgr : IControlManager;
begin
 if f_ControlMgr = nil then
  f_ControlMgr := NativeAdapter.MakeControlManager;
 Result := f_ControlMgr;
end;
{$IfEnd}

function TDataAdapter.pm_GetAssemblyInfo : IAssemblyInfo;
begin
 if f_AssemblyInfo = nil then
  f_AssemblyInfo := NativeAdapter.MakeAssemblyInfo;
 Result := f_AssemblyInfo;
end;

function TDataAdapter.pm_GetNotifyManager: INotifyManager;
begin
 if f_NotifyManager = nil then
  f_NotifyManager := NativeAdapter.MakeNotifyManager;
 Result := f_NotifyManager;
end;

procedure TDataAdapter.ActivateDefKeyboardLayout;
begin
 if afw.Settings.LoadBoolean(pi_ActivateDefaultLanguage, dv_ActivateDefaultLanguage) then
  afw.TryActivateKeyboardLayout;
end;

procedure TDataAdapter.ResetBooleans;
  {* - сбросить трех позиционные логические флаги. }
begin
 l3BoolReset(f_HasPublishSourceTag);
 l3BoolReset(f_HasKeyWordTag);
 l3BoolReset(f_IsInternal);
 l3BoolReset(f_PrivelegedUsersAllowed);
 //l3BoolReset(f_UseUserATPrefix);
 l3BoolReset(f_IntergationExportEnabled);
 l3BoolReset(f_RevisionCheckEnabled);
end;

procedure TDataAdapter.ClearCache;
begin
 f_CRSimpleListTypeRootNode := nil;
 //f_UserATPrefixName := nil;
 f_MenuTypeCache := [];
 ResetBooleans;
 f_CurBaseDate := cNullDate;
 f_TrialDaysLeft := 0;
end;

procedure TDataAdapter.InstallDefaultSettings;
  {* - установить настройки по умолчанию. }
{$IfNDef nsWithoutLogin}
var
 l_List   : IConfigurationManager;
{$EndIf  nsWithoutLogin}
begin
 {$IfNDef nsWithoutLogin}
 l_List := NativeAdapter.MakeConfigurationManager;
 if Assigned(l_List) then
 try
  l_List.DefaultValuesUpdateCheck(f_InstallDefaultSettingsInfo);
 finally
  l_List := nil;
 end;//try..finally
 {$EndIf  nsWithoutLogin}
end;

procedure TDataAdapter.InitNotifiers;
var
 l_OnLongProcess: IListener;
 {$If not (defined(Monitorings) or defined(Admin))}
var
 l_OnControlledChange: TnsOnControlledChange;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}
begin
 l_OnLongProcess := TnsOnLongProcess.Make;
 try
  NotifyManager.RegisterListenerForNotify(NT_LONG_OPERATION_START,
                                          l_OnLongProcess);
  NotifyManager.RegisterListenerForNotify(NT_LONG_OPERATION_END,
                                          l_OnLongProcess);
 finally
  l_OnLongProcess := nil;
 end;

 InstallDefaultSettings;

 {$If not (defined(Monitorings) or defined(Admin))}
 l_OnControlledChange := TnsOnControlledChange.Create;
 try
  ControlMgr.SetControlledChangeNotifier(l_OnControlledChange as IControlledChangeNotifier);
 finally
  vcmFree(l_OnControlledChange);
 end;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}
end;

function TDataAdapter.pm_getIsDesktop: Boolean;
begin
 if f_ShellType = shltNone then
 begin
  if AssemblyInfo.GetIsDesktop then
   f_ShellType := shltDesktop
  else
   f_ShellType := shltNetwork
 end;

 Result := f_ShellType = shltDesktop;
end;

function TDataAdapter.pm_GetIsExplanatoryExists: boolean;
begin
 Result := CommonInterfaces.IsExplanatoryDictionaryExist;
end;

procedure TDataAdapter.InitCurrentUserID;
var
 lUserManager : IUserManager;
 lProfile     : IUserProfile;
begin
 (* выходим идентификатор получен *)
 if f_CurrentUserID <> -1 then
  Exit;
 lUserManager := NativeAdapter.MakeUserManager;
 try
  lUserManager.GetSelfProfile(lProfile);
  try
   f_CurrentUserID := lProfile.GetUid;
   {$IfDef nsSign1}
   Graphics.g_uid := f_CurrentUserID;
   {$EndIf nsSign1}
  finally
   lProfile := nil;
  end;
 finally
  lUserManager := nil;
 end;
end;

function TDataAdapter.pm_GetCurrentUserID: Integer;
begin
 if f_CurrentUserID = -1 then
  InitCurrentUserID;
 Result := f_CurrentUserID;
end;

function TDataAdapter.MakeCRTree(const aRootNode: INodeBase): Il3Node;
Var
 l_NewRoot : Tl3CacheableNode;

 function MakeNode(const aOriginNode: INodeBase): Il3SimpleNode;
 Var
  l_Node : TnsINodeWrap;
 begin
  l_Node := TnsINodeWrap.Create(aOriginNode);
  try
   Supports(l_Node, Il3SimpleNode, Result); 
  finally
   l3Free(l_Node);
  end;
 end;

 procedure MakeNodes(aNode: Tl3CacheableNode; const aRootNode: INodeBase);
 var
  l_CacheNode: Tl3CacheableNode;
  l_AdapterNode,
  l_NextNode: INodeBase;
 begin
  aRootNode.GetFirstChild(l_AdapterNode);
  try
   while l_AdapterNode <> nil do
   begin
    l_CacheNode := Tl3CacheableNode.Create(MakeNode(l_AdapterNode));
    try
     Il3Node(aNode).InsertChild(l_CacheNode);
     MakeNodes(l_CacheNode, l_AdapterNode);
    finally
     l3Free(l_CacheNode);
    end;
    l_AdapterNode.GetNext(l_NextNode);
    try
     l_AdapterNode := nil;
     l_AdapterNode := l_NextNode;
    finally
     l_NextNode := nil;
    end;
   end;
  finally
   l_AdapterNode := nil;
  end;
 end;

begin
 Result := nil;
 begin
  l_NewRoot := Tl3CacheableNode.Create(MakeNode(aRootNode));
  try
   MakeNodes(l_NewRoot, aRootNode);
   Supports(l_NewRoot, Il3Node, Result);
  finally
   l3Free(l_NewRoot);
  end;
 end;
end;

function TDataAdapter.pm_GetCRSimpleListTypeRootNode: Il3Node;

  procedure lp_Notify;
  var
   l_Index    : Integer;
   l_Listener : InsCRSimpleListTypeRootNodeListener;
   l_Item     : IUnknown;
  begin
   if NotifiedObjList <> nil then
    for l_Index := 0 to Pred(NotifiedObjList.Count) do
    begin
     l_Item := NotifiedObjList.Items[l_Index];
     if Supports(l_Item, InsCRSimpleListTypeRootNodeListener, l_Listener) and
       (l_Item = l_Listener) then
      l_Listener.Updated;
    end;//for l_Index := 0 to Pred(NotifiedObjList.Count) do
  end;//lp_Notify

var
 l_CRSimpleListTypeRootNode: INodeBase;
begin
 if f_CRSimpleListTypeRootNode = nil then
 begin
  try
   l_CRSimpleListTypeRootNode := DefDataAdapter.NativeAdapter.MakeNodeBase(nsAStr(c_CR_NodeClass));
  except
   on ECanNotFindData do
    l_CRSimpleListTypeRootNode := nil;
  end;
  if (l_CRSimpleListTypeRootNode <> nil) then
  try
   f_CRSimpleListTypeRootNode := MakeCRTree(l_CRSimpleListTypeRootNode);
   lp_Notify;
  finally
   l_CRSimpleListTypeRootNode := nil;
  end;
 end;
 Result := f_CRSimpleListTypeRootNode;
end;

function TDataAdapter.pm_GetAdministratorLogin: Boolean;
begin
 Result := f_AdministratorLogin;
end;

{$If not Defined(Admin) AND not Defined(Monitorings) }
procedure TDataAdapter.DocumentCacheSinchronize(anOperation: TFolderOperationType;
                                                anEntity: IUnknown;
                                                aFlags: TDocumentBookmarkTypes);
 {* - нотификация кэшу документов об изменении закладок. }
var
 l_Bookmark: IBookmark;
 l_Entity: IEntityBase;
begin
 if Supports(anEntity, IBookmark, l_Bookmark) and
    Supports(anEntity, IEntityBase, l_Entity) then
  try
   case anOperation of
    fotAdd:
     begin
      TevDocumentsCache.NotifySubAdded(l_Bookmark,
                                       l_Bookmark.GetParagraph,
                                       l_Bookmark.GetEid,
                                       Ord(ev_sbtBookmark),
                                       nsGetBookmarkName(l_Bookmark).AsWStr,
                                       Integer(aFlags));
     end;//fotAdd
    fotModify: ; //!Stub!
    fotDelete:
     TevDocumentsCache.NotifySubDeleted(l_Bookmark,
                                        l_Bookmark.GetParagraph,
                                        Ord(ev_sbtBookmark));
    fotOverride:
     begin
      TevDocumentsCache.NotifySubDeleted(l_Bookmark,
                                         l_Bookmark.GetParagraph,
                                         Ord(ev_sbtBookmark));
      TevDocumentsCache.NotifySubAdded(l_Bookmark,
                                       l_Bookmark.GetParagraph,
                                       l_Bookmark.GetEid,
                                       Ord(ev_sbtBookmark),
                                       nsGetBookmarkName(l_Bookmark).AsWStr,
                                       Integer(aFlags));
     end;//fotOverride
   end;//case anOperation
  finally
   l_Bookmark := nil;
   l_Entity := nil;
  end;
end;
{$IfEnd}

procedure TDataAdapter.DefineApplicationTitle;
begin
 Application.Title := str_NemesisTitle.AsStr;
 PutStringToRegistry(HKEY_CURRENT_USER,
                     'Software\Microsoft\Windows\ShellNoRoam\MUICache',
                     ParamStr(0),
                     Application.Title,
                     False);
 PutStringToRegistry(HKEY_CURRENT_USER,
                     'Software\Classes\Local Settings\Software\Microsoft\Windows\Shell',
                     ParamStr(0),
                     Application.Title,
                     False);
end;

function TDataAdapter.HasTag(out aValue : Tl3Bool;
                             const aTag : Tl3WString): Boolean;
  {* - возвращает наличие тага, если тага нет, то определяет его. }
begin
 Result := false;
 if not l3BoolCheck(aValue, Result) then
  Result := l3BoolSet(IsExistTag(aTag), aValue);
end;

function TDataAdapter.IsExistTag(const aTagName : Tl3WString) : Boolean;
  {-}
var
 l_AttrInfo : IAttributeInfo;
begin
 Search.GetAttributeInfo(nsAStr(aTagName).S, l_AttrInfo);
 try
  Result := l_AttrInfo.GetIsExist;
 finally
  l_AttrInfo := nil;
 end;
end;

function TDataAdapter.pm_GetIsInternal: Boolean;
begin
 Result := False;
 if not l3BoolCheck(f_IsInternal, Result) then
  Result := l3BoolSet(not AssemblyInfo.GetIsCommerce, f_IsInternal);
end;

function TDataAdapter.pm_GetIsExists_KeyWordTag: Boolean;
begin
 Result := HasTag(f_HasKeyWordTag, nsWStr(AT_KW));
end;

function TDataAdapter.pm_GetIsExists_PublishSourceTag: Boolean;
begin
 Result := HasTag(f_HasPublishSourceTag, nsWStr(AT_PUBLISH_SOURCE));
end;

function TDataAdapter.pm_GetTrialDaysLeft: Longint;
begin
 if (f_TrialDaysLeft = 0) then
  {$IfNDef nsWithoutLogin}
  f_TrialDaysLeft := f_Authorization.GetRestTrialDaysCount;
  {$Else   nsWithoutLogin}
  f_TrialDaysLeft := -1;
  {$EndIf  nsWithoutLogin}

 Result := f_TrialDaysLeft;
end;

function TDataAdapter.pm_GetIsTrialMode: Boolean;
begin
 Result := TrialDaysLeft >= 0;
end;

function TDataAdapter.pm_GetIsMorfoIndexExist: Boolean;
begin
 Result := False;
 if Assigned(Search) then
  Result := Search.GetIsMorphoExist; 
end;

function MakeCryptMask(const aIndex: Integer; const aCryptSold: Word): Byte;
begin
 Result := not(Byte(aIndex)) xor Byte(aCryptSold shr (8*(aIndex mod 2)));
end;

function DecodePassword(const aPassword: AnsiString): AnsiString;
var
 l_CryptSold: Word;
 l_CryptTail: AnsiString;
 l_Index: Integer;
 l_Length: Integer;
begin
 if ((Length(aPassword) = (CCryptPrefixCharSize+CCryptSoldSize+CCryptTailSize)) and (aPassword[1] = CCryptPrefixChar)) then
 begin
  Result := '';
  try
   l_CryptSold := Swap(Word(StrToInt('$'+Copy(aPassword, Succ(CCryptPrefixCharSize), CCryptSoldSize))));
   l_CryptTail := Copy(aPassword, Succ(CCryptPrefixCharSize)+CCryptSoldSize, CCryptTailSize);
   //
   l_Index := 1;
   while (l_Index < Length(l_CryptTail)) do
   begin
    Result := Result+Char(Byte(StrToInt('$'+Copy(l_CryptTail, l_Index, 2))) xor MakeCryptMask(Succ(l_Index) div 2, l_CryptSold));
    Inc(l_Index, 2);
   end;
   //
   repeat
    l_Length := Length(Result);
    if (l_Length < CCryptSuffixCharSize) or (Result[Succ(l_Length-CCryptSuffixCharSize)] <> CCryptSuffixChar) then
     Break;
    //
    SetLength(Result, l_Length-CCryptSuffixCharSize);
   until False;
  except
   on EConvertError do;
  end;
 end
 else
  Result := aPassword;
end;

function EncodePassword(const aPassword: AnsiString): AnsiString;
var
 l_CryptSold: Word;
 l_CryptTail: AnsiString;
 l_Index: Integer;
begin
 l_CryptSold := Random(Integer($FFFF));
 l_CryptTail := aPassword;
 //
 while (Length(l_CryptTail) < CCryptTailLength) do
  l_CryptTail := l_CryptTail+CCryptSuffixChar;
 //
 SetLength(l_CryptTail, CCryptTailLength);
 //
 Result := CCryptPrefixChar+IntToHex(Swap(l_CryptSold), CCryptSoldSize);
 for l_Index := 1 to CCryptTailLength do
  Result := Result+IntToHex(Byte(l_CryptTail[l_Index]) xor MakeCryptMask(l_Index, l_CryptSold), 2);
end;

function StringExistsInRegistry(const aRootKey: HKEY; const aPathKey: AnsiString; const aValueName: AnsiString): Boolean;
begin
 Result := False;
 try
  with TRegistry.Create do
   try
    RootKey := aRootKey;
    if OpenKey(aPathKey, False) then
     try
      if ValueExists(aValueName) then
       Result := True;
     finally
      CloseKey;
     end;
   finally
    Free;
   end;
 except
  on ERegistryException do;
 end;
end;

procedure PutStringToRegistry(const aRootKey   : HKEY;
                              const aPathKey   : AnsiString;
                              const aValueName : AnsiString;
                              const aValue     : AnsiString;
                              CanCreate: Boolean = true);
begin
 with TRegistry.Create do
  try
   RootKey := aRootKey;
   if OpenKey(aPathKey, CanCreate) then
    try
     WriteString(aValueName, aValue);
    finally
     CloseKey;
    end
  finally
   Free;
  end;
end;

function GetBooleanFromRegistry(const aRootKey: HKEY; const aPathKey: AnsiString; const aValueName: AnsiString; const aDefaultValue: Boolean): Boolean;
begin
 Result := aDefaultValue;
 try
  with TRegistry.Create do
   try
    RootKey := aRootKey;
    if OpenKey(aPathKey, False) then
     try
      if ValueExists(aValueName) then
       Result := ReadBool(aValueName);
     finally
      CloseKey;
     end;
   finally
    Free;
   end;
 except
  on ERegistryException do;
 end;
end;

procedure PutBooleanToRegistry(const aRootKey: HKEY; const aPathKey: AnsiString; const aValueName: AnsiString; const aValue: Boolean);
begin
 with TRegistry.Create do
  try
   RootKey := aRootKey;
   if OpenKey(aPathKey, True) then
    try
     WriteBool(aValueName, aValue);
    finally
     CloseKey;
    end
  finally
   Free;
  end;
end;

procedure DeletePasswordIfAutoLogin;
begin
 if TnsStartupSupport.IsEqualCopyRunning then
   Exit;
 if not GetBooleanFromRegistry(CDefaultRootKey, CDefaultPathKey, CIsAutoLoginValueName, False) then
  with TRegistry.Create do
   try
    RootKey := CDefaultRootKey;
    OpenKey(CDefaultPathKey, false);
    try
     DeleteValue(CPasswordValueName);
    finally
     CloseKey;
    end;
   finally
    Free;
   end;
end;

function TDataAdapter.GetType: TComplectType;
var
 l_CI: IComplectInfo;
begin
 l_CI := NativeAdapter.MakeComplectInfo;
 try
  Result := l_CI.GetType;
 finally
  l_CI := nil;
 end;
end;

function TDataAdapter.pm_GetHasConsultations: Boolean;
  {* - наличие консультаций. }
begin
 Result := ConsultationManager.CheckConsultingAvailable;
end;

function TDataAdapter.pm_GetHasSearchMachine: Boolean;
  {* - наличие консультаций. }
begin
 Result := false and afw.Application.IsInternal and HasConsultations;
end;

function TDataAdapter.pm_GetConsultationManager: IConsultationManager;
  {* - менеджер консультаций. }
begin
 if not Assigned(f_ConsultationManager) then
  f_ConsultationManager := NativeAdapter.MakeConsultationManager;
 Result := f_ConsultationManager;
end;

function TDataAdapter.pm_LogManager: ILogManager;
begin
 if not Assigned(f_LogManager) then
  f_LogManager := NativeAdapter.MakeLogManager;
 Result := f_LogManager;
end;

function TDataAdapter.pm_GetListXMLExportEnabled: Boolean;
begin
 Result := afw.Application.IsInternal or f_RegListXMLExportEnabled;
end;

function TDataAdapter.pm_GetComplectName: Il3CString;
var
 l_CompName : IString;
begin
 CommonInterfaces.GetComplectName(l_CompName);
 try
  Result := nsCStr(l_CompName);
 finally
  l_CompName := nil;
 end;//try..finally
end;//pm_GetComplectName

function TDataAdapter.pm_GetBaseSearchFirstExampleIndex: LongInt;
{* - Индекс первого примера для показа в Базовом поиске. }
var
 l_StartCounter,
 l_ExampleIndex: LongInt;
 l_ExampleCount: LongWord;
const
 cChangeExampleStartCount = 10;
begin
 if f_BaseSearchFirstExampleIndex = -1 then
 begin
  { Чтение настроек }
  l_StartCounter := afw.Settings.LoadInteger(pi_BaseSearch_StartCounter,
                               dv_BaseSearch_StartCounter);
  l_ExampleIndex := afw.Settings.LoadInteger(pi_BaseSearch_ExampleIndex,
                               dv_BaseSearch_ExampleIndex);

  Inc(l_StartCounter);

  if l_StartCounter = cChangeExampleStartCount then
  begin
   l_StartCounter := 0;
   Inc(l_ExampleIndex);

   l_ExampleCount := DefDataAdapter.Search.GetExampleTextCount;
   if l_ExampleIndex >= l_ExampleCount then
    l_ExampleIndex := 0;
   f_BaseSearchFirstExampleIndex := l_ExampleIndex;

   { Запись индекса примера }
   afw.Settings.SaveInteger(pi_BaseSearch_ExampleIndex, l_ExampleIndex);
  end
  else
   f_BaseSearchFirstExampleIndex := l_ExampleIndex;

  { Запись счетчика запусков }
  afw.Settings.SaveInteger(pi_BaseSearch_StartCounter, l_StartCounter);
 end;

 Result := f_BaseSearchFirstExampleIndex;
end;

function TDataAdapter.pm_GetAdminInfo: InsAdminInfo;
begin
 {$IfNDef nsWithoutLogin}
 if f_AdminInfo = nil then
  f_AdminInfo := TnsAdminInfo.Make(Authorization);
 {$EndIf  nsWithoutLogin} 
 Result := f_AdminInfo;
end;//pm_GetAdminInfo

procedure TDataAdapter.ShowAutoregistrationDisabledMessage;
var
 l_AdminInfo: Il3CString;
begin
 with AdminInfo do
 begin
  Assert(HasEmail or HasPhone, 'Admin info undefined!');
  l_AdminInfo := nil;
  if HasEmail and HasPhone then
   l_AdminInfo := l3Fmt(vcmConstString(str_AdminPhoneAndEmail), [Phone, Email])
  else
   if HasEmail then
    l_AdminInfo := l3Fmt(vcmConstString(str_AdminEmail), [Email])
   else
    if HasPhone then
     l_AdminInfo := l3Fmt(vcmConstString(str_AdminPhone), [Phone]);
  vcmSay(inf_UserAutoregistrationForbad, [l_AdminInfo]);
 end//with DefDataAdapter.AdminInfo do
end;

procedure TDataAdapter.AbnormalTermination(aTerminateProcess: Boolean = True);
begin
 f_InTerminateProcess := True;
 // !ToDo! Этот код сейчас нужен для того, чтобы погасить все окна, но оставить работающее приложение
 // для завершения работ бридера/апдейтера и т.п.

 // !Потенциально опасно! т.к. при вызове g_Dispatcher.CloseAllWindows может опять возникнуть тот же exception
 // по которому мы провалились в вызов AbnormalTermination и возникнет зацикливание.
 try
  if Assigned(g_Dispatcher) then
   g_Dispatcher.CloseAllWindows;
 except
  on E: Exception do
   l3System.Exception2Log(E);
 end;

 TnsStartupSupport.DestroyInstance; // Освобождаем объект поддерживающий переключение на уже запущенное приложение, запуск бридера/апдейтера и т.п.

 GlobalCrashCleanup;
 // На этапе загрузки перед срубанием оболочки нужно закрыть сплэш и, может быть,
 // сделать что-то еще. Поэтому - не убиваемся, а выставляем флаг f_FatalExceptionRaised
 //http://mdp.garant.ru/pages/viewpage.action?pageId=449026895
 if aTerminateProcess then
  TerminateProcess(GetCurrentProcess, 255);
 f_FatalExceptionRaised := True;
end;

function TDataAdapter.LegislationReviewAvailable: Boolean;
begin
 Result := afw.Application.IsInternal or Monitoring.IsExist;
end;

function TDataAdapter.pm_GetPrivelegedUsersAllowed: Boolean;
var
 l_UserManager: IUserManager;
begin
 Result := False;
 if not l3BoolCheck(f_PrivelegedUsersAllowed, Result) then
 begin
  l_UserManager := NativeAdapter.MakeUserManager;
  try
   Result := l3BoolSet(l_UserManager.CanCreatePrivilegedUser, f_PrivelegedUsersAllowed);
  finally
   l_UserManager := nil;
  end; // try
 end;
end;

function TDataAdapter.pm_GetIntegration: IIntegration;
begin
 if not Assigned(f_Integration) then
  f_Integration := NativeAdapter.MakeIntegration;
 Result := f_Integration;
end;

procedure TDataAdapter.UpdatedNotify;
{$If not (defined(Monitorings) or defined(Admin))}
var
 l_Index    : Integer;
 l_Item     : IUnknown;
 l_Listener : InsDataAdapterListener;
{$IfEnd}
begin
 {$If not (defined(Monitorings) or defined(Admin))}
 if (NotifiedObjList <> nil) then
  for l_Index := NotifiedObjList.Hi downto 0 do
  begin
   l_Item := NotifiedObjList[l_Index];
   if Supports(l_Item, InsDataAdapterListener, l_Listener) AND
     (l_Item = l_Listener) then
    l_Listener.Updated;
  end;//for l_Index := f_NotifiedObjList.Hi downto 0 do
 {$IfEnd} 
end;//UpdatedNotify

procedure TDataAdapter.FinishDataUpdate;
begin
 ClearCache;
 {$If not (defined(Monitorings) or defined(Admin))}
 if ControlMgr <> nil then
  ControlMgr.UpdateStatus(False);
 {$IfEnd} 
 UpdatedNotify;
 {$If not (defined(Monitorings) or defined(Admin))}
 TdmStdRes.MakeWorkJournal.NotifyJournalShrinked;
 {$IfEnd}
end;//FinishDataUpdate

{$If not defined(Admin) AND not defined(Monitorings)}
procedure TDataAdapter.RegisterBuildedDefferedTree(
  const aTree: InsDeferredTree);
begin
 Assert(Assigned(f_BuildingDefferedTreesList));
 f_BuildingDefferedTreesList.Remove(aTree);
end;

procedure TDataAdapter.RegisterBuildingDefferedTree(
  const aTree: InsDeferredTree);
begin
 Assert(Assigned(aTree));
 if f_ShutDowning then
  aTree.WaitForReady
 else
 begin
  if f_BuildingDefferedTreesList = nil then
  begin
   f_BuildingDefferedTreesList := TnsDeferredTreeList.Create;
   f_BuildingDefferedTreesList.Duplicates := l3_dupIgnore;
  end;
  WaitForBuildingDeferredTrees;
  f_BuildingDefferedTreesList.Add(aTree);
 end;
end;
{$IfEnd}

procedure TDataAdapter.WaitForBuildingDeferredTrees;
begin
 {$If not (defined(Monitorings) or defined(Admin))}
 if Assigned(f_BuildingDefferedTreesList) then
  while f_BuildingDefferedTreesList.Count > 0 do
   f_BuildingDefferedTreesList[0].WaitForReady;
 {$IfEnd}  
end;

{$If not defined(Admin)}
function TDataAdapter.pm_GetPrimeManager: IPrimeManager;
begin
 if f_PrimeManager = nil then
  f_PrimeManager := NativeAdapter.MakePrimeManager;
 Result := f_PrimeManager;
end;//pm_GetPrimeManager
{$ifEnd}

function TDataAdapter.pm_GetIsInpharmExists: boolean;
begin
 Result := CommonInterfaces.IsPharmExist;
end;

{$If not (defined(Monitorings) or defined(Admin))}
function TDataAdapter.CorrectMistakes(const aContext: Il3StringsEx;
  aForInpharm: Boolean;
  out aCorrectedContext: Il3StringsEx;
  out aMistakesList: Il3StringsEx): Boolean;

 function lp_AllNil(const aList: IvcmStrings): Boolean;
 var
  l_IDX: Integer;
 begin
  Result := True;
  for l_IDX := 0 to aList.Count - 1 do
   if not l3IsNil(aList[l_IDX]) then
   begin
    Result := False;
    Exit;
   end;
 end;

 function lp_AllocContext(const aList: IvcmStrings): IContextWordList;
 var
  l_IDX: Integer;
 begin
  Result := NativeAdapter.MakeContextWordList;
  for l_IDX := 0 to aList.Count - 1 do
   Result.Add(nsIStr(aList[l_IDX]));
 end;

 function lp_ConvertContext(const aList: IContextWordList): IvcmStrings;
 var
  l_IDX: Integer;
  l_String: IString;
  l_CStr : Il3CString;
 begin
  Result := TvcmStringList.Make;
  if Assigned(aList) then
   for l_IDX := 0 to aList.Count - 1 do
   begin
    aList.pm_GetItem(l_IDX, l_String);
    l_CStr := nsCStr(l_String);
    //if not l3IsNil(l_CStr) then
     Result.Add(l_CStr);
   end;
  if Result.Count = 0 then
   Result.Add('');
 end;

 function lp_EqualContext(const aContext, aCorrectedContext: Il3StringsEx): Boolean;
 var
  l_IDX: Integer;
 begin
  Result := aContext.Count = aCorrectedContext.Count;
  if Result then
   for l_IDX := 0 to aContext.Count - 1 do
    if not l3Same(aContext[l_IDX], aCorrectedContext[l_IDX]) then
    begin
     Result := False;
     Exit;
    end;
 end;

var
 l_AdapterCorrectedContext: IContextWordList;
 l_AdapterMistakes: IContextWordList;
begin
 Result := False;
 if Assigned(aContext) and (aContext.Count > 0) and not lp_AllNil(aContext) then
 begin
  Search.CorrectContext(lp_AllocContext(aContext), aForInpharm, l_AdapterCorrectedContext, l_AdapterMistakes);
  aCorrectedContext := lp_ConvertContext(l_AdapterCorrectedContext);
  Result := not lp_EqualContext(aContext, aCorrectedContext);
  if Assigned(l_AdapterMistakes) and (l_AdapterMistakes.Count > 0) then
  begin
   Result := True;
   aMistakesList := lp_ConvertContext(l_AdapterMistakes);
  end
  else
   aMistakesList := nil;
 end
 else
 begin
  Result := False;
  aCorrectedContext := TvcmStringList.Make;
  aMistakesList := nil;
 end;
end;
{$IfEnd}

function TDataAdapter.pm_GetIsENOEnabled: boolean;
begin
 Result := CommonInterfaces.IsEOEnabled;
end;

{$If not (defined(Monitorings) or defined(Admin))}
function TDataAdapter.MakeSplashData(aIsStart: Boolean): InsSplashClient;
var
 l_SplashScreen: ISplashScreen;
 l_PictureStream: TnsExternalObjectStream;
 l_Warning: Il3CString;
 l_UserInfo: Il3CString;
 l_ApplicationTitle: AnsiString;
 l_Logo: Tl3MemoryStream;
 l_MinShowTime: Cardinal;

const
 cMagic = 5000;

 function lp_UserInfo(const aSplash: ISplashScreen): Il3CString;
 var
  l_AdapterString: IString;
  l_MainOwner: Il3CString;
  l_AdditionalOwner: Il3CString;
 begin
  aSplash.GetOwner(l_AdapterString);
  if Assigned(l_AdapterString) then
   try
    l_MainOwner := nsCStr(l_AdapterString);
   finally
    l_AdapterString := nil;
   end
  else
   l_MainOwner := nil;
  if not l3IsNil(l_MainOwner) then
  begin
   aSplash.GetOwnerCaption(l_AdapterString);
   if Assigned(l_AdapterString) then
   try
    l_AdditionalOwner := nsCStr(l_AdapterString);
    if not l3IsNil(l_AdditionalOwner) then
     Result := l3Cat([l3Cat(l_AdditionalOwner, #13#10), l_MainOwner])
    else
     Result := vcmFmt(str_SplashUserText, [l_MainOwner]);
   finally
    l_AdapterString := nil;
   end//try..finally
   else
    Result := vcmFmt(str_SplashUserText, [l_MainOwner]);
  end
  else
   Result := nil;
 end;
begin
 Result := nil;
 if CommonInterfaces = nil then
  Exit;
 try
  CommonInterfaces.GetSplashScreen(
   aIsStart,
   Screen.Width,
   Screen.Height,
   nsCanMakeFlashActiveX,
   l_SplashScreen);
 except
  Exit;
 end;
 l_PictureStream := TnsExternalObjectStream.Create(l_SplashScreen as IExternalObject);
 try
  l_ApplicationTitle := Application.Title;
  l_UserInfo := lp_UserInfo(l_SplashScreen);
  l_Warning := vcmCStr(str_SplashWarning);
  l_Logo := Tl3MemoryStream.Make;
  try
   l_Logo.WriteComponent(dmStdRes.ilSplahLogo);
   l_Logo.Position := 0;
   {$IfOpt D+}
   l_MinShowTime := 0;
   {$Else}
   l_MinShowTime := Max(cMagic, l_SplashScreen.GetShowTime);
   {$EndIf}
   Result := TnsSplashVisualizer.Make(l_PictureStream, l_Logo, l_MinShowTime,
     Application.Handle, l_ApplicationTitle, l_UserInfo, l_Warning);
  finally
   FreeAndNil(l_Logo);
  end;
 finally
  FreeAndNil(l_PictureStream);
 end;
end;
{$IfEnd not (defined(Monitorings) or defined(Admin))}

procedure TDataAdapter.BeginLoadFolders;
begin
 {$If not (defined(Monitorings) or defined(Admin))}
 CommonInterfaces.CreateFolderNotificationQueue;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}
end;

procedure TDataAdapter.EndLoadFolders;
 {$If not (defined(Monitorings) or defined(Admin))}
var
 l_OnExternalFolderChange: TnsOnExternalFolderChange;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}
begin
 {$If not (defined(Monitorings) or defined(Admin))}
 l_OnExternalFolderChange := TnsOnExternalFolderChange.Create;
 try
  try
   CommonInterfaces.StartProcessingFolderNotification(l_OnExternalFolderChange as IExternalFoldersChangeNotifier);
  except
   on EFoldersNotAvailable do
    ; //TODO: гасим EFoldersNotAvailable (for Demon)
   else
    raise;
  end;
 finally
  vcmFree(l_OnExternalFolderChange);
 end;
 {$IfEnd not (defined(Monitorings) or defined(Admin))}
end;

{$If not (defined(Monitorings) or defined(Admin))}
function TDataAdapter.FiltersContainer(aListType: TbsListType): InsFiltersContainer;
begin
 Result := TnsFiltersContainer.Instance.Filters[aListType];
end;
{$IfEnd not (defined(Monitorings) or defined(Admin))}

function TDataAdapter.GetGroupsTree: INodeBase;
var
 l_UserManager: IUserManager;
begin
 Result := nil;
 l_UserManager := NativeAdapter.MakeUserManager;
 try
  l_UserManager.GetGroupsTree(Result);
 finally
  l_UserManager := nil;
 end;
end;

function TDataAdapter.GetUsersTree: INodeBase;
var
 l_UserManager: IUserManager;
begin
 Result := nil;
 l_UserManager := NativeAdapter.MakeUserManager;
 try
  l_UserManager.GetUsersTree(Result);
 finally
  l_UserManager := nil;
 end;
end;

(*function TDataAdapter.pm_UseUserATPrefix: Boolean;
begin
 Result := False;
 if not l3BoolCheck(f_UseUserATPrefix, Result) then
  Result := l3BoolSet(NativeAdapter.MakeBaseSearchManager.GetIsUserPaneEnabled, f_UseUserATPrefix);
end;*)

function TDataAdapter.pm_IntergationExportEnabled: Boolean;
begin
 Result := False;
 if not l3BoolCheck(f_IntergationExportEnabled, Result) then
  Result := l3BoolSet(IsInternal or NativeAdapter.MakeIntegration.GetIntegrationEnabled, f_IntergationExportEnabled);
end;

function TDataAdapter.pm_RevisionCheckEnabled: Boolean;
begin
 Result := False;
 if not l3BoolCheck(f_RevisionCheckEnabled, Result) then
  Result := l3BoolSet(NativeAdapter.MakeInternetSupport.RevisionCheckEnabled, f_RevisionCheckEnabled);
end;

(*function TDataAdapter.pm_UserATPrefixName: Il3CString;
var
 l_Name : IString;
begin
 if f_UserATPrefixName = nil then
 begin
  NativeAdapter.MakeBaseSearchManager.GetUserPaneName(l_Name);
  try
   f_UserATPrefixName := nsCStr(l_Name);
  finally
   l_Name := nil;
  end;
 end;
 Result := f_UserATPrefixName;
end;*)

function TDataAdapter.pm_GetIsInternetAgentEnabled: Boolean;
begin
 Result := NativeAdapter.MakeInternetSupport.IsInternetAgentEnabled;
end;

function TDataAdapter.pm_GetChatManager: IChatManager;
begin
 if not Assigned(f_ChatManager) then
  f_ChatManager := NativeAdapter.MakeChatManager;
 Result := f_ChatManager;
end;

function TDataAdapter.pm_GetMessagesManager: IMessagesManager;
begin
 if not Assigned(f_MessageManager) then
  f_MessageManager := NativeAdapter.MakeMessagesManager;
 Result := f_MessageManager;
end;

function TDataAdapter.GetChatUsersTree: INodeBase;
begin
 ChatManager.GetContactsTree(Result);
end;

initialization
 Randomize;
finalization
 DeletePasswordIfAutoLogin;

end.
