
(object Petal
    version    	50
    _written   	"Rose 8.5.0503.xxx"
    charSet    	204)

(object Class_Category "XMLUtils"
    is_unit    	TRUE
    is_loaded  	TRUE
    attributes 	(list Attribute_Set
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"IsNative"
	    value      	"false")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"fctr.cpp:*442D450B03B9_CUSTOM_INCLUDES*"
	    value      	"//#UC START# *442D450B03B9_CUSTOM_INCLUDES*¤//#UC END# *442D450B03B9_CUSTOM_INCLUDES*")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"h:*442D450B03B9_CUSTOM_INCLUDE*"
	    value      	(value Text 
|//#UC START# *442D450B03B9_CUSTOM_INCLUDE*¤#include "Garant/HCAdapter/GCLPacket/GCLPacket.h"¤¤class IXercesAdapter;¤//#UC END# *442D450B03B9_CUSTOM_INCLUDE*
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"ApplyedGens"
	    value      	"C++ èíòåğôåéñû è ğåàëèçàöèÿ|mpc"))
    quid       	"442D450B03B9"
    documentation 	"Èíòåğôåéñ äëÿ ÷òåíèÿ XML îò âíåøíèõ ñèñòåì."
    stereotype 	"Interface"
    visible_categories 	(list visibility_relationship_list
	(object Visibility_Relationship
	    quid       	"443141C901C5"
	    supplier   	"Logical View::garant6x::DSMAdapter::GCLPacket"
	    quidu      	"4423F94903C8")
	(object Visibility_Relationship
	    quid       	"445B7B560363"
	    supplier   	"Logical View::garantPIL::GbaPilot::GblConsultingDef"
	    quidu      	"445B5C600373")
	(object Visibility_Relationship
	    quid       	"445C6EA3035B"
	    supplier   	"Logical View::common::utils::Xerces"
	    quidu      	"445B7FA10094"))
    exportControl 	"Public"
    logical_models 	(list unit_reference_list
	(object Class "XMLReader"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*442D453501E4_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *442D453501E4_CUSTOM_INCLUDES*¤//#UC END# *442D453501E4_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*442D453501E4*"
		    value      	"//#UC START# *442D453501E4*¤//#UC END# *442D453501E4*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*442D453501E4_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *442D453501E4_CUSTOM_INCLUDES*¤#include "utils/XERCES_Adapter/xerces/xercesadapter.h"¤#include "Garant/HCAdapter/HCAdapterRoot.h"¤//#UC END# *442D453501E4_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*442D453501E4*"
		    value      	"//#UC START# *442D453501E4*¤//#UC END# *442D453501E4*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*442D453501E4_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *442D453501E4_DESTR_BODY*¤	//#UC END# *442D453501E4_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"fctr.cpp:*442D453501E4_44313715007D*"
		    value      	(value Text 
|//#UC START# *442D453501E4_44313715007D*¤		assert (0);¤		return 0;¤	//#UC END# *442D453501E4_44313715007D*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"call way"
		    value      	"forth")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"native definition"
		    value      	"none")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"fctr.cpp:*442D453501E4_443CDC2F037A*"
		    value      	(value Text 
|//#UC START# *442D453501E4_443CDC2F037A*¤	XMLReader* reader = XMLUtils_i::XMLReader_i::Singleton::instance ();¤	reader->addref ();¤¤	return reader;¤	//#UC END# *442D453501E4_443CDC2F037A*
		    )))
	    quid       	"442D453501E4"
	    documentation 	"Èíòåğôåéñ äëÿ  ÷òåíèÿ XML îò âíåøíèõ ñèñòåì"
	    stereotype 	"Interface"
	    operations 	(list Operations
		(object Operation "read_result"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4430E42C03A9_443136380271*"
			    value      	(value Text 
|//#UC START# *4430E42C03A9_443136380271*¤	static const char* const list_tag_string = "list";¤	static const char* const consulting_tag_string = "consulting";¤	bool is_dsm_search = false;¤¤	GblConsultingDef::ConsultationData_var reply = new OBV_GblConsultingDef::ConsultationData ();¤¤	const size_t block_size = 512;¤	static char buffer[block_size];¤	std::vector<char> xml_data;¤	size_t len; // Number of received bytes¤	for (bool eof = result->eof (); !eof; eof = result->eof ()) {¤		len = result->read (buffer, block_size);¤		if (len) {¤			std::copy (buffer, &(buffer[len]), std::back_inserter (xml_data));¤		}¤	}¤	if (xml_data.size () == 0) {¤		LOG_E (("XMLReader_i::read_result: zero length of xml stream"));¤		throw XMLUtils::BadXMLFormat ();¤	}¤¤	DocumentManager doc_manager (xerces_adapter);¤	XERCES_CPP_NAMESPACE::DOMElement *root;¤	try {¤		XERCES_CPP_NAMESPACE::DOMDocument* doc = doc_manager.get_doc (&xml_data[0], xml_data.size ());¤		root = xerces_adapter->get_root (doc);¤	} catch (...) {¤		LOG_E (("XMLReader_i::read_result: can't create DOM tree from received stream"));¤		throw XMLUtils::BadXMLFormat ();¤	}¤¤	// Check root tag.¤	DOMNodeEx root_node (xerces_adapter, root);¤	const XMLCh* root_name_unicode = root_node.get_node_name ();¤¤	class AutoXercesString {¤	public:¤		AutoXercesString (char* data, IXercesAdapter* xerces_adapter)¤			: m_data (data), m_xerces_adapter (xerces_adapter) {}¤¤		operator const char* () const {¤			return m_data;¤		}¤¤		~AutoXercesString () {¤			m_xerces_adapter->release_string (m_data);¤		}¤	private:¤		IXercesAdapter* m_xerces_adapter;¤		char* m_data;¤	};¤	AutoXercesString root_name (xerces_adapter->get_string (root_name_unicode), xerces_adapter);¤	if (¤			(std::strlen (consulting_tag_string) == std::strlen (root_name))¤			&& !std::memcmp (consulting_tag_string, root_name, std::strlen (consulting_tag_string))¤		) {¤		// Extended data must be read from xml.¤¤		// Create ConsultationID¤		XMLStr query_id_attr (xerces_adapter, root_node.get_attribute ("query_id"));¤		if (!std::strlen (query_id_attr.data ())) {¤			LOG_E (("XMLReader_i::read_result: can't find attribute query_id in tag <consulting>"));¤			throw XMLUtils::BadXMLFormat ();¤		}¤		reply->consultation_id (CORBA::string_dup (query_id_attr.data ()));¤¤		//reply->consultation_id.consultation_id = CORBA::string_dup (query_id_attr.data ());¤		//long complect_id_attr = root_node.get_long_attribute ("complect_id");¤		//if (complect_id_attr) {¤		//	reply->consultation_id.client_id.complect_id = complect_id_attr;¤		//} else {¤		//	LOG_W (("XMLReader_i::read_result: zero complect_id in xml!"));¤		//}¤		//long user_id_attr = root_node.get_long_attribute ("user_id");¤		//if (user_id_attr) {¤		//	reply->consultation_id.user_id = user_id_attr;¤		//} else {¤		//	LOG_W (("XMLReader_i::read_result: zero complect_id in xml!"));¤		//}¤¤		// Create HC consutation¤		GblConsultingDef::HCConsultationData_var hc_consultation = new OBV_GblConsultingDef::HCConsultationData ();¤		XMLStrUnicode consultation_tag (xerces_adapter, "consultation");¤		XERCES_CPP_NAMESPACE::DOMNodeList* consultation_list = root->getElementsByTagName (consultation_tag.data ());¤		if (consultation_list->getLength () == 1) {¤			// Create consultation type¤			static const char* const type_reply = "REPLY";¤			static const char* const type_notification = "NOTIFICATION";¤			DOMNodeEx consultation_tag (xerces_adapter, consultation_list->item (0));¤			XMLStr type_attr (xerces_adapter, consultation_tag.get_attribute ("type"));¤			const char* type_attr_data = type_attr.data ();¤			if (¤					(std::strlen (type_reply) == std::strlen (type_attr_data))¤					&& !std::memcmp (type_reply, type_attr_data, std::strlen (type_reply))¤			) {¤				hc_consultation->type (GblConsultingDef::HCDT_REPLY);¤			} else if (¤					(std::strlen (type_notification) == std::strlen (type_attr_data))¤					&& !std::memcmp (type_notification, type_attr_data, std::strlen (type_notification))¤			) {¤				hc_consultation->type (GblConsultingDef::HCDT_NOTIFICATION);¤			} else {¤				LOG_E (("XMLReader_i::read_result: wrang consultation type attibute: %s", type_attr_data));¤				throw XMLUtils::BadXMLFormat ();¤			}¤¤			// Create consultation author¤			XMLStr name_attr (xerces_adapter, consultation_tag.get_attribute ("author"));¤			if (!std::strlen (name_attr.data ())) {¤				LOG_E (("XMLReader_i::read_result: consultation author not defined"));¤				throw XMLUtils::BadXMLFormat ();¤			}¤			XMLStr email_attr (xerces_adapter, consultation_tag.get_attribute ("email"));¤			GblConsultingDef::ConsultationAuthor author;¤			author.name = CORBA::string_dup (name_attr.data ());¤			author.email = CORBA::string_dup (email_attr.data ());¤			hc_consultation->author (author);¤¤			// Create info from reply_text¤			XMLStrUnicode reply_text_tag_string (xerces_adapter, "reply_text");¤			XERCES_CPP_NAMESPACE::DOMNodeList* reply_text_list = root->getElementsByTagName (reply_text_tag_string.data ());¤			if (reply_text_list->getLength () == 1) {¤				DOMNodeEx reply_text_tag (xerces_adapter, reply_text_list->item (0));¤¤				// Create consultation text¤				XMLStrUnicode para_tag_string (xerces_adapter, "para");¤				XERCES_CPP_NAMESPACE::DOMNodeList* para_list = ¤					reply_text_tag.get_element ()->getElementsByTagName (para_tag_string.data ());¤				XMLSize_t para_list_length = para_list->getLength ();¤				if (!para_list_length) {¤					LOG_E (("XMLReader_i::read_result: reply text must have para's!"));¤					throw XMLUtils::BadXMLFormat ();¤				}¤				GblConsultingDef::ParaList reply_text;¤				reply_text.length (para_list_length);¤				XMLSize_t bad_paras = 0;¤				for (XMLSize_t i = 0; i < para_list_length; ++i) {¤					DOMNodeEx para (xerces_adapter, para_list->item (i));¤					if (para.is_valid ()) {¤						XMLStr text (xerces_adapter, para.get_text ());¤						reply_text[i - bad_paras] = CORBA::string_dup (text.data ());¤					} else {¤						++bad_paras;¤					}¤				}¤				if (bad_paras) {¤					LOG_W (("XMLReader_i::read_result: bad paras found (bad paras count: %d", bad_paras));¤					reply_text.length (para_list_length - bad_paras);¤				}¤				hc_consultation->text (reply_text);¤			} else if (reply_text_list->getLength ()) {¤				LOG_E (("XMLReader_i::read_result: too many tags <reply_text> inside <consultation>!"));¤				throw XMLUtils::BadXMLFormat ();¤			}¤¤			// Create consultation date¤			XMLStrUnicode date_tag_string (xerces_adapter, "date");¤			XERCES_CPP_NAMESPACE::DOMNodeList* date_list = ¤				consultation_tag.get_element ()->getElementsByTagName (date_tag_string.data ());¤			if (date_list->getLength () == 1) {¤				DOMNodeEx date_tag (xerces_adapter, date_list->item (0));¤¤				long day = date_tag.get_long_attribute ("day");¤				long month = date_tag.get_long_attribute ("month");¤				long year = date_tag.get_long_attribute ("year");¤				// TODO: create full check for correct date¤				if (day && month && year) {¤					GCD::Date request_date;¤					request_date.day = static_cast<CORBA::Short> (day);¤					request_date.month = static_cast<CORBA::Short> (month);¤					request_date.year = static_cast<CORBA::Short> (year);¤					hc_consultation->date (request_date);¤				} else {¤					LOG_E (("Bad date: %d.%d.%d", day, month, year));¤					throw XMLUtils::BadXMLFormat ();¤				}¤			} else if (date_list->getLength ()) {¤				LOG_E (("XMLReader_i::read_result: too many tags <date> inside <reply_text>"));¤				throw XMLUtils::BadXMLFormat ();¤			} else {¤				LOG_E (("XMLReader_i::read_result: can't find tag <date> inside <reply_text>"));¤				throw XMLUtils::BadXMLFormat ();¤			}¤¤			// Create consultation time¤			XMLStrUnicode time_tag_string (xerces_adapter, "time");¤			XERCES_CPP_NAMESPACE::DOMNodeList* time_list = ¤				consultation_tag.get_element ()->getElementsByTagName (time_tag_string.data ());¤			if (time_list->getLength () == 1) {¤				DOMNodeEx time_tag (xerces_adapter, time_list->item (0));¤¤				long hours = time_tag.get_long_attribute ("hours");¤				long minutes = time_tag.get_long_attribute ("minutes");¤				long seconds = time_tag.get_long_attribute ("seconds");¤				// TODO: create full check for correct date¤				GCD::Time request_time;¤				request_time.hour = static_cast<CORBA::Short> (hours);¤				request_time.min = static_cast<CORBA::Short> (minutes);¤				request_time.sec = static_cast<CORBA::Short> (seconds);¤				hc_consultation->time (request_time);¤			} else if (time_list->getLength ()) {¤				LOG_E (("XMLReader_i::read_result: too many tags <time> inside <reply_text>"));¤				throw XMLUtils::BadXMLFormat ();¤			} else {¤				LOG_E (("XMLReader_i::read_result: can't find tag <time> inside <reply_text>"));¤				throw XMLUtils::BadXMLFormat ();¤			}¤¤			// Create account info¤			XMLStrUnicode account_info_tag_string (xerces_adapter, "account_info");¤			XERCES_CPP_NAMESPACE::DOMNodeList* account_info_list = ¤				consultation_tag.get_element ()->getElementsByTagName (account_info_tag_string.data ());¤			if (account_info_list->getLength () == 1) {¤				DOMNodeEx account_info_tag (xerces_adapter, account_info_list->item (0));¤¤				static const char* const rub_type = "RUB";¤				static const char* const hours_type = "HOURS";¤				XMLStr money_type_attr (xerces_adapter, account_info_tag.get_attribute ("money_type"));¤¤				GblConsultingDef::PriceUnit unit = GblConsultingDef::PU_HOUR;¤				if (std::strlen (money_type_attr.data ()) == 0) {¤					unit = GblConsultingDef::PU_HOUR;¤				} else if (¤						(std::strlen (rub_type) == std::strlen (money_type_attr.data ()))¤						&& !std::memcmp (rub_type, money_type_attr.data (), std::strlen (rub_type))¤				) {¤					unit = GblConsultingDef::PU_RUB;¤				} else if (¤						(std::strlen (hours_type) == std::strlen (money_type_attr.data ()))¤						&& !std::memcmp (hours_type, money_type_attr.data (), std::strlen (hours_type))¤				) {¤					unit = GblConsultingDef::PU_HOUR;¤				} else {¤					LOG_E (("XMLReader_i::read_result: bad money type: %s", money_type_attr.data ()));¤					throw XMLUtils::BadXMLFormat ();¤				}¤				long price = account_info_tag.get_long_attribute ("consulting_price");¤				long balance = account_info_tag.get_long_attribute ("balance");¤				// TODO: must i check those values?¤				GblConsultingDef::AccountInfo account_info;¤				account_info.consultation_price = price;¤				account_info.balance = balance;¤				account_info.price_unit = unit;¤				hc_consultation->price (account_info);¤			} else if (account_info_list->getLength ()) {¤				LOG_E (("XMLReader_i::read_result: too many tags <account_info> inside <consultation>"));¤				throw XMLUtils::BadXMLFormat ();¤			}¤¤			reply->consultation (hc_consultation);¤		} else if (consultation_list->getLength ()) {¤			LOG_E (("XMLReader_i::read_result: too many tags <consultation> in xml"));¤			throw XMLUtils::BadXMLFormat ();¤		} else {¤			LOG_E (("XMLReader_i::read_result: can't find tag <consultation> in xml"));¤			throw XMLUtils::BadXMLFormat ();¤		}¤	} else if (¤		(std::strlen (list_tag_string) != std::strlen (root_name))¤		|| std::memcmp (list_tag_string, root_name, std::strlen (list_tag_string))¤	) {¤		LOG_E (("XMLReader_i::read_result: bad root tag in xml - %s", root_name));¤		throw XMLUtils::BadXMLFormat ();¤	} else {¤		is_dsm_search = true;¤	}¤¤	XMLStrUnicode lst_tag_string (xerces_adapter, "list");¤	XERCES_CPP_NAMESPACE::DOMNodeList* list_list = root->getElementsByTagName (lst_tag_string.data ());¤	if (list_list->getLength () == 1) {¤		static const char* const type_sub = "SUB";¤		static const char* const type_para = "PARA";¤		XMLStrUnicode document_tag_string (xerces_adapter, "document");¤		XERCES_CPP_NAMESPACE::DOMNodeList* document_list = root->getElementsByTagName (document_tag_string.data ());¤¤		XMLSize_t document_list_length = document_list->getLength ();¤		GblConsultingDef::DocList doc_list;¤		doc_list.length (document_list_length);¤		XMLSize_t bad_documents = 0;¤		for (XMLSize_t i = 0; i < document_list_length; ++i) {¤			DOMNodeEx document (xerces_adapter, document_list->item (i));¤			if (document.is_valid ()) {¤				GblConsultingDef::ListItem li;¤				XMLStr type (xerces_adapter, document.get_attribute ("point_type"));¤				const char* type_data = type.data ();¤				if (¤						(std::strlen (type_sub) == std::strlen (type_data))¤						&& !std::memcmp (type_sub, type_data, std::strlen (type_sub))¤				) {¤					li.point.type = GblConsultingDef::DPT_SUB;¤				} else if (¤						(std::strlen (type_para) == std::strlen (type_data))¤						&& !std::memcmp (type_para, type_data, std::strlen (type_para))¤				) {¤					li.point.type = GblConsultingDef::DPT_PARA;¤				} else {¤					// Don't throw exception :)¤					LOG_E (("XMLReader_i::read_result: wrang point_type attibute: %s", type_data));¤					++bad_documents;¤					continue;¤				}¤				li.doc_id = document.get_long_attribute ("id");¤				li.point.point = document.get_long_attribute ("point");¤				li.relevance = document.get_long_attribute ("relevance");¤				doc_list[i - bad_documents] = li;¤			} else {¤				++bad_documents;¤			}¤		}¤		if (bad_documents) {¤			LOG_W (("XMLReader_i::read_result: bad documents found (bad documents count: %d", bad_documents));¤			doc_list.length (document_list_length - bad_documents);¤		}¤		reply->doc_list (doc_list);¤	} else if (list_list->getLength ()) {¤		LOG_E (("XMLReader_i::read_result: too many tags <list> in xml"));¤		throw XMLUtils::BadXMLFormat ();¤	} else if (!list_list->getLength () && is_dsm_search) {¤		LOG_E (("XMLReader_i::read_result: must be list from DSM"));¤		throw XMLUtils::BadXMLFormat ();¤	}¤¤	return reply._retn ();¤	//#UC END# *4430E42C03A9_443136380271*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"GetRaises"
			    value      	"443CFC3703B9"))
		    quid       	"4430E42C03A9"
		    parameters 	(list Parameters
			(object Parameter "inout result"
			    quid       	"443E1299008C"
			    type       	"IStream"
			    quidu      	"4423FB5903D8")
			(object Parameter "inout xerces_adapter"
			    quid       	"4432771001F4"
			    type       	"IXercesAdapter"
			    quidu      	"443271180119"))
		    result     	"ConsultationData"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"443CB5FF038A")
		(object Operation "make"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false"))
		    quid       	"443CDC2F037A"
		    stereotype 	"factory"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0))
	    language   	"MDA Generator")
	(object Class "BadXMLFormat"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"OS_GUID"
		    value      	"4D709E6C-C465-4167-9AA0-1BEC4989CE32"))
	    quid       	"443CFC3703B9"
	    documentation 	"Èñêëş÷åíèå èíèöèèğóåòñÿ, åñëè íå óäà¸òñÿ ğàçîáğàòü xml"
	    stereotype 	"Exception"
	    language   	"MDA Generator"))
    logical_presentations 	(list unit_reference_list
	(object ClassDiagram "Main"
	    quid       	"442D452E0271"
	    title      	"Main"
	    zoom       	100
	    max_height 	28350
	    max_width  	21600
	    origin_x   	0
	    origin_y   	859
	    items      	(list diagram_item_list
		(object ClassView "Class" "Logical View::garant6x::DSMAdapter::XMLUtils::XMLReader" @1
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(986, 228)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@1
			location   	(850, 200)
			fill_color 	13434879
			nlines     	1
			max_width  	272
			justify    	0
			label      	"XMLReader")
		    stereotype 	(object ItemLabel
			Parent_View 	@1
			location   	(850, 150)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	269
			justify    	0
			label      	"<<Interface>>")
		    icon       	"Interface"
		    icon_style 	"Label"
		    fill_color 	16766935
		    quidu      	"442D453501E4"
		    width      	290
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::garant6x::DSMAdapter::XMLUtils::BadXMLFormat" @2
		    ShowCompartmentStereotypes 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(259, 565)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@2
			location   	(101, 537)
			fill_color 	13434879
			nlines     	1
			max_width  	316
			justify    	0
			label      	"BadXMLFormat")
		    stereotype 	(object ItemLabel
			Parent_View 	@2
			location   	(101, 487)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	313
			justify    	0
			label      	"<<Exception>>")
		    icon_style 	"Label"
		    fill_color 	9869055
		    quidu      	"443CFC3703B9"
		    width      	334
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)))))
