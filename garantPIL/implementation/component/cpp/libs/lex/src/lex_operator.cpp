///////////////////////////////////////////////////////////////////////////////

#include "lex_operator.h"

///////////////////////////////////////////////////////////////////////////////

Sequence::Sequence(Parser &prev, Parser &next)
{
	m_prev = &prev;
	m_next = &next;
}

///////////////////////////////////////////////////////////////////////////////

Sequence::~Sequence()
{
}

///////////////////////////////////////////////////////////////////////////////

Match	Sequence::Parse(const char *buf)
{
	Match	retv, prev, next;

	if( (prev = m_prev->Parse(buf)) &&
		(next = m_next->Parse(buf + prev.length())) ) {
		retv.length(prev.length() + next.length());
		retv.ok(true);
	}

	return retv;
}

///////////////////////////////////////////////////////////////////////////////

Or::Or(Parser &a, Parser &b)
{
	m_a = &a;
	m_b = &b;
}

///////////////////////////////////////////////////////////////////////////////

Or::~Or()
{
}

///////////////////////////////////////////////////////////////////////////////

Match	Or::Parse(const char *buf)
{
	Match	retv, aMatch, bMatch;

	aMatch = m_a->Parse(buf);
	bMatch = m_b->Parse(buf);

	retv.length((aMatch.length() > bMatch.length()) ? aMatch.length() : bMatch.length());
	retv.ok(aMatch.ok() | bMatch.ok());

	return retv;
}

///////////////////////////////////////////////////////////////////////////////

Not::Not(Parser &yes, Parser &no)
{
	m_yes = &yes;
	m_no  = &no;
}

///////////////////////////////////////////////////////////////////////////////

Not::~Not()
{
}

///////////////////////////////////////////////////////////////////////////////

Match	Not::Parse(const char *buf)
{
	Match	retv;

	retv = m_yes->Parse(buf);

	if( retv == m_no->Parse(buf) ) {
		retv.ok(false);
	}

	return retv;
}

///////////////////////////////////////////////////////////////////////////////

Repeat::Repeat(Parser &parser, long minCount, long maxCount)
{
	m_parser = &parser;
	m_min = minCount;
	m_max = maxCount;
}

///////////////////////////////////////////////////////////////////////////////

Repeat::~Repeat()
{
}

///////////////////////////////////////////////////////////////////////////////

Match	Repeat::Parse(const char *buf)
{
	Match	retv, match;
	long	i;

	retv.ok(true);

	for( i = 0; (i < m_max) || (m_max == -1); i ++ ) {
		match = m_parser->Parse(buf + retv.length());

		if( match ) {
			retv.length(retv.length() + match.length());
		} else {
			if( i < m_min ) {
				retv.ok(false);
			}
			break;
		}
	}

	return retv;
}

///////////////////////////////////////////////////////////////////////////////

Parser	&operator >> (Parser &prev, Parser &next)
{
	return *(new Sequence(prev, next));
}

///////////////////////////////////////////////////////////////////////////////

Parser	&operator | (Parser &a, Parser &b)
{
	return *(new Or(a, b));
}

///////////////////////////////////////////////////////////////////////////////

Parser	&operator + (Parser &a)
{
	return *(new Repeat(a, 1, -1));
}

///////////////////////////////////////////////////////////////////////////////

Parser	&operator * (Parser &a)
{
	return *(new Repeat(a, 0, -1));
}

///////////////////////////////////////////////////////////////////////////////

Parser	&operator ! (Parser &a)
{
	return *(new Repeat(a, 0, 1));
}

///////////////////////////////////////////////////////////////////////////////

Parser	&operator - (Parser &yes, Parser &no)
{
	return *(new Not(yes, no));
}

///////////////////////////////////////////////////////////////////////////////

Action::Action(Parser &parser, CallAction callAction)
{
	m_parser = &parser;
	m_callAction = callAction;
}

///////////////////////////////////////////////////////////////////////////////
Action::~Action()
{
}

///////////////////////////////////////////////////////////////////////////////

Match	Action::Parse(const char *buf)
{
	Match	retv;

	retv = m_parser->Parse(buf);

	if( retv ) {
		m_callAction(buf, retv.length());
	}

	return retv;
}

///////////////////////////////////////////////////////////////////////////////
