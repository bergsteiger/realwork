// This file is generated by omniidl (C++ backend)- omniORB_3_0. Do not edit.

#include "strings_struct.h"
#include <omniORB3/tcDescriptor.h>

static const char* _0RL_library_version = omniORB_3_0;

static CORBA::TypeCode_ptr _0RL_tc_StrDate = CORBA::TypeCode::PR_alias_tc("IDL:StrDate:1.0", "StrDate", CORBA::TypeCode::PR_string_tc(0));

const CORBA::TypeCode_ptr _tc_StrDate = _0RL_tc_StrDate;

static CORBA::TypeCode_ptr _0RL_tc_StrTime = CORBA::TypeCode::PR_alias_tc("IDL:StrTime:1.0", "StrTime", CORBA::TypeCode::PR_string_tc(0));

const CORBA::TypeCode_ptr _tc_StrTime = _0RL_tc_StrTime;

static CORBA::PR_structMember _0RL_structmember_StrRevision[] = {
  {"date", _0RL_tc_StrDate},
  {"time", _0RL_tc_StrTime}
};

static CORBA::TypeCode_ptr _0RL_tc_StrRevision = CORBA::TypeCode::PR_struct_tc("IDL:StrRevision:1.0", "StrRevision", _0RL_structmember_StrRevision, 2);
const CORBA::TypeCode_ptr _tc_StrRevision = _0RL_tc_StrRevision;

static CORBA::PR_structMember _0RL_structmember_StrPeriod[] = {
  {"old_date", _0RL_tc_StrRevision},
  {"new_date", _0RL_tc_StrRevision}
};

static CORBA::TypeCode_ptr _0RL_tc_StrPeriod = CORBA::TypeCode::PR_struct_tc("IDL:StrPeriod:1.0", "StrPeriod", _0RL_structmember_StrPeriod, 2);

const CORBA::TypeCode_ptr _tc_StrPeriod = _0RL_tc_StrPeriod;

static CORBA::TypeCode_ptr _0RL_tc_ShortArr = CORBA::TypeCode::PR_alias_tc("IDL:ShortArr:1.0", "ShortArr", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ushort_tc()));

const CORBA::TypeCode_ptr _tc_ShortArr = _0RL_tc_ShortArr;

static CORBA::TypeCode_ptr _0RL_tc_StringArr = CORBA::TypeCode::PR_alias_tc("IDL:StringArr:1.0", "StringArr", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0)));

const CORBA::TypeCode_ptr _tc_StringArr = _0RL_tc_StringArr;

static CORBA::TypeCode_ptr _0RL_tc_StrPeriodArr = CORBA::TypeCode::PR_alias_tc("IDL:StrPeriodArr:1.0", "StrPeriodArr", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_StrPeriod));

const CORBA::TypeCode_ptr _tc_StrPeriodArr = _0RL_tc_StrPeriodArr;

static CORBA::TypeCode_ptr _0RL_tc_StrName = CORBA::TypeCode::PR_alias_tc("IDL:StrName:1.0", "StrName", CORBA::TypeCode::PR_string_tc(0));

const CORBA::TypeCode_ptr _tc_StrName = _0RL_tc_StrName;

static CORBA::PR_structMember _0RL_structmember_StrSettings[] = {
  {"out_name", _0RL_tc_StrName},
  {"pic_enable", CORBA::TypeCode::PR_short_tc()},
  {"rtf_enable", CORBA::TypeCode::PR_short_tc()},
  {"mrg_segs", _0RL_tc_ShortArr},
  {"period", _0RL_tc_StrPeriod}
};

static CORBA::TypeCode_ptr _0RL_tc_StrSettings = CORBA::TypeCode::PR_struct_tc("IDL:StrSettings:1.0", "StrSettings", _0RL_structmember_StrSettings, 5);

const CORBA::TypeCode_ptr _tc_StrSettings = _0RL_tc_StrSettings;

void _0RL_delete_StrRevision(void* _data) {
  StrRevision* _0RL_t = (StrRevision*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_StrRevision(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((StrRevision*)_desc->opq_struct)->date);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((StrRevision*)_desc->opq_struct)->time);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_StrRevision(tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cStrRevision(tcDescriptor &_desc, const StrRevision& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_StrRevision;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_StrRevision;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const StrRevision& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cStrRevision(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_StrRevision, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, StrRevision* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cStrRevision(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_StrRevision, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, StrRevision*& _sp) {
  return _a >>= (const StrRevision*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const StrRevision*& _sp) {
  _sp = (StrRevision *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new StrRevision;
    _0RL_buildDesc_cStrRevision(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_StrRevision, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_StrRevision);
      return 1;
    } else {
      delete (StrRevision *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_StrRevision)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_StrPeriod(void* _data) {
  StrPeriod* _0RL_t = (StrPeriod*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_StrPeriod(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cStrRevision(_newdesc, ((StrPeriod*)_desc->opq_struct)->old_date);
    return 1;
  case 1:
    _0RL_buildDesc_cStrRevision(_newdesc, ((StrPeriod*)_desc->opq_struct)->new_date);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_StrPeriod(tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cStrPeriod(tcDescriptor &_desc, const StrPeriod& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_StrPeriod;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_StrPeriod;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const StrPeriod& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cStrPeriod(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_StrPeriod, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, StrPeriod* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cStrPeriod(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_StrPeriod, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, StrPeriod*& _sp) {
  return _a >>= (const StrPeriod*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const StrPeriod*& _sp) {
  _sp = (StrPeriod *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new StrPeriod;
    _0RL_buildDesc_cStrPeriod(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_StrPeriod, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_StrPeriod);
      return 1;
    } else {
      delete (StrPeriod *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_StrPeriod)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cunsigned_pshort__
#define __0RL_tcParser_buildDesc_s0_cunsigned_pshort__
static void
_0RL_tcParser_setElementCount_s0_cunsigned_pshort(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cunsigned_pshort(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cunsigned_pshort(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2> *)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2> *)_desc->opq_seq)->length() - _index;
  
  return 1;
}

static void
_0RL_buildDesc_s0_cunsigned_pshort(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cunsigned_pshort;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cunsigned_pshort;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cunsigned_pshort;
  }
#endif

void operator <<= (CORBA::Any& _a, const ShortArr& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cunsigned_pshort(tcdesc, _s);
  _a.PR_packFrom(_tc_ShortArr, &tcdesc);
}

void _0RL_seq_delete_ShortArr(void* _data)
{
  delete (ShortArr*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, ShortArr*& _s_out)
{
  return _a >>= (const ShortArr*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const ShortArr*& _s_out)
{
  _s_out = 0;
  ShortArr* stmp = (ShortArr*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new ShortArr;
    _0RL_buildDesc_s0_cunsigned_pshort(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_ShortArr, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_ShortArr);
      _s_out = stmp;
      return 1;
    } else {
      delete (ShortArr *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_ShortArr) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cstring__
#define __0RL_tcParser_buildDesc_s0_cstring__
static void
_0RL_tcParser_setElementCount_s0_cstring(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cstring(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cstring(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cstring(_newdesc, (*((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cstring(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence__String& _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cstring;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cstring;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cstring;
  }
#endif

void operator <<= (CORBA::Any& _a, const StringArr& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cstring(tcdesc, _s);
  _a.PR_packFrom(_tc_StringArr, &tcdesc);
}

void _0RL_seq_delete_StringArr(void* _data)
{
  delete (StringArr*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, StringArr*& _s_out)
{
  return _a >>= (const StringArr*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const StringArr*& _s_out)
{
  _s_out = 0;
  StringArr* stmp = (StringArr*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new StringArr;
    _0RL_buildDesc_s0_cstring(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_StringArr, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_StringArr);
      _s_out = stmp;
      return 1;
    } else {
      delete (StringArr *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_StringArr) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cStrPeriod__
#define __0RL_tcParser_buildDesc_s0_cStrPeriod__
static void
_0RL_tcParser_setElementCount_s0_cStrPeriod(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< StrPeriod> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cStrPeriod(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< StrPeriod> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cStrPeriod(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cStrPeriod(_newdesc, (*((_CORBA_Unbounded_Sequence< StrPeriod> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cStrPeriod(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< StrPeriod> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cStrPeriod;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cStrPeriod;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cStrPeriod;
  }
#endif

void operator <<= (CORBA::Any& _a, const StrPeriodArr& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cStrPeriod(tcdesc, _s);
  _a.PR_packFrom(_tc_StrPeriodArr, &tcdesc);
}

void _0RL_seq_delete_StrPeriodArr(void* _data)
{
  delete (StrPeriodArr*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, StrPeriodArr*& _s_out)
{
  return _a >>= (const StrPeriodArr*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const StrPeriodArr*& _s_out)
{
  _s_out = 0;
  StrPeriodArr* stmp = (StrPeriodArr*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new StrPeriodArr;
    _0RL_buildDesc_s0_cStrPeriod(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_StrPeriodArr, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_StrPeriodArr);
      _s_out = stmp;
      return 1;
    } else {
      delete (StrPeriodArr *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_StrPeriodArr) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_StrSettings(void* _data) {
  StrSettings* _0RL_t = (StrSettings*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_StrSettings(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((StrSettings*)_desc->opq_struct)->out_name);
    return 1;
  case 1:
    _0RL_buildDesc_cshort(_newdesc, ((StrSettings*)_desc->opq_struct)->pic_enable);
    return 1;
  case 2:
    _0RL_buildDesc_cshort(_newdesc, ((StrSettings*)_desc->opq_struct)->rtf_enable);
    return 1;
  case 3:
    _0RL_buildDesc_s0_cunsigned_pshort(_newdesc, ((StrSettings*)_desc->opq_struct)->mrg_segs);
    return 1;
  case 4:
    _0RL_buildDesc_cStrPeriod(_newdesc, ((StrSettings*)_desc->opq_struct)->period);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_StrSettings(tcStructDesc *_desc)
{
  return 5;
}

void _0RL_buildDesc_cStrSettings(tcDescriptor &_desc, const StrSettings& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_StrSettings;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_StrSettings;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const StrSettings& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cStrSettings(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_StrSettings, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, StrSettings* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cStrSettings(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_StrSettings, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, StrSettings*& _sp) {
  return _a >>= (const StrSettings*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const StrSettings*& _sp) {
  _sp = (StrSettings *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new StrSettings;
    _0RL_buildDesc_cStrSettings(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_StrSettings, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_StrSettings);
      return 1;
    } else {
      delete (StrSettings *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_StrSettings)) return 1;
    _sp = 0;
    return 0;
  }
}
