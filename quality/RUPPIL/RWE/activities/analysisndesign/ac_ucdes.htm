<HTML>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=WIN1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title> Активность: Спроектировать прецедент</title>
<link rel="stylesheet" href="../../css/project.css" type="text/css">
</head>
<body>

<h2 class="banner"><a name="Top"></a><a name="XE_use_case__design"></a>Активность: Спроектировать прецедент</h2>

<div align="center"><center>

<table border="1" width="85%" cellspacing="0" cellpadding="2">
  <tr>
    <td colspan="2" valign="top" bordercolor="#808080" width="645"><font face="Arial"><small><strong>Цель</strong></small></font>
    <ul>
      <li>Уточнить прецедент в терминах взаимодействий.</li>
      <li>Уточнить требования у операциям проектных классов.</li>
      <li>Уточнить требования к операциям подсистем и/или их интерфейсам.</li>
      <li class="reactive">Уточнить требования к операциям капсул</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td colspan="2" valign="top" bordercolor="#808080" width="645"><small><strong><font face="Arial">Шаги</font></strong></small>
    <ul>
      <li><a href="#Describe Interactions Between Design Objects">Описать взаимодействия между проектными объектами</a></li>
      <li><a href="#Describe Interactions Between Subsystems and/or their Interfaces (optional)">Упростить
        диаграммы последовательностей, используя подсистемы (опционально)</a></li>
      <li><a href="#Describe Persistence-Related Behaviors">Описать сохраняемо-связанное поведение</a>
        <ul>
          <li><a href="#Writing Persistent Objects">Написание сохраняемых объектов</a></li>
          <li><a href="#Reading Persistent Objects">Прочтение сохраняемых объектов</a></li>
          <li><a href="#Deleting Persistent Objects">Удаление сохраняемых объектов</a></li>
          <li><a href="#Modeling Transactions">моделирование транзакций</a></li>
          <li><a href="#Handling Error Conditions">Обработка ошиочных условий</a></li>
          <li><a href="#Handling Concurrency Control">Обработка параллельного контроля</a></li>
        </ul>
      </li>
      <li><a href="#Refine the Flow of Events Description">Уточнить описание потока событий</a></li>
      <li><a href="#Unify Classes and Subsystems">Соединить классы и подсистемы</a></li>
      <li><a href="#Evaluate Your Results">Оценить результаты</a></li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top" bordercolor="#808080" width="317"><small><font face="Arial"><strong>Входящие артефакты:</strong></font></small>
    <ul>
      <li><a href="../../artifacts/requirements/pa_supspec.htm">Дополнительные спецификации</a></li>
      <li><strong>Прецедент</strong> из <a href="../../artifacts/requirements/pa_ucmod.htm">Модели Прецедентов</a> проекта</li>
      <li><strong>Проектный класс</strong>,</li>
      <li><strong>Интерфейс</strong> и</li>
      <li><strong>Проектная подсистема</strong> в рамках <a href="../../artifacts/analysisndesign/pa_desmod.htm">Проектной модели</a></li>
    </ul>
    </td>
    <td style="text-indent: 0px" valign="top" bordercolor="#808080" width="322"><small><font face="Arial"><strong>Результирующие артефакты:</strong></font></small>
    <ul>
      <li>
        <p align="left"><strong>Реализация прецедента</strong>,
        описанная с диаграммами последовательности и уточненным потоком потоком событий в рамках <a href="../../artifacts/analysisndesign/pa_desmod.htm">Проектной модели</a></p>
      </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top" colspan="2" style="text-indent: 4px" bordercolor="#808080" width="645"><strong><font face="Arial"><small>Роль:</small>
    </font></strong><a href="../../workers/wk_dsgnr.htm">Проектировщик</a></td>
  </tr>
</table>
  </center>
</div>
</center></div>

<p>Следуйте <a href="../../library/name_rules.htm">Правилам именования</a> элементов модели при
проведении работ по проектированию.


<p><a name="XE_interaction__describing_interactions_between_design_objects"></a>
Поведение системы может описываться с использованием техники взаимодействий и коопераций.
Эта активность описывает использование взаимодействий, в частности,
диаграмм последовательности, чтобы описать поведение системы.
Диаграммы последовательности лучше всего использовать там, где поведение системы или подсистемы может быть описано 
механизмом синхронных сообщений. Асинхронные сообщения, особенно в системе, управляемой событиями,
часто более легко описываются в терминах машин состояний и коопераций, позволяя компактно описать
возможные взаимодействия между объектами.</p>

<h3><a name="Describe Interactions Between Design Objects">Описать взаимодействия между проектными объектами </a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>Взаимодействие в каждой реализации прецедента нужно иллюстрировать взаимодействиями между
участвующими проектными объектами путем созданием одной или более диаграмм последовательности.
Они начинают создаваться в <a href="ac_ucana.htm">Активности: Провести анализ прецедента</a>. 
Если они включены в <a href="../../artifacts/analysisndesign/pa_anmod.htm">Артефакт: Модель Анализа</a>, то нужно их перевести
в <a href="../../artifacts/analysisndesign/pa_desmod.htm">Артефакт: Проектная Модель</a>, где продолжится их развитие.</p>
<br>
<p>Совершенствование диаграмм последовательности заключается в следующих шагах:
<ul>
  <li>Определите участвующие в потоке прецедента объекты. Это можно сделать путем обработки
    проектных классов и подсистем, определенных в <a href="ac_iddes.htm">Активности: Определить проектные элементы</a>.
  <li>Представьте каждый участвующий объект на диаграмме последовательности. Покажите 
    линию жизни каждого участвующего объекта диаграммы активности. В случае представления подсистем, вы имеете два варианта выбора:
    <ul>
      <li>Вы можете использовать интерфейсы, предоставляемые подсистемой. Это предпочтительней в случаях, когда вы хотите 
        показать, что любой элемент модели, который реализует тот же интерфейс, может использоваться вместо интерфейса.
        Если вы показываете интерфейсы на диаграмме последовательности, знайте, что придется гарантировать, что нет 
        сообщений, посылаемых от интерфейса другим объектам. Причина этого в том, что интерфейсы полностью
        определяются внутренними реализациями их операций. Мы не можем быть уверены, что все элементы модели,
        реализующие интерфейс, будут спроектированы так же. Итак, на диаграммах последовательности не должно быть
        сообщений от интерфейсов.</li>
      <li>Вы можете использовать прокси-класс (посредника) чтобы показать подсистему на диаграммах последовательности.
        Он содержится в подсистеме и применяется для представления подсистемы в диаграммах, которые не поддерживают
        прямого использования пакетов и подсистем как элементов, задающих поведение. Прокси-класс должен использоваться
        в случаях, когда вы хотите показать, что данная подсистема отвечает на соообщение. В этом случае, вы можете
        показать события, посылаемые от прокси подсистемы другим объектам.</li>
    </ul>
    <p>Заметьте, что активные взаимодействия объектов обычно описываются при использовании подробных описаний коопераций и
    машин состояний. Они используются для отображения, как сообщения могут посылаться активным объектам от других элементов
    системы в больших реализациях прецедентов. Обычно цель активности, активные объекты размещают в подсистемах, таких как
    реализации прецедентов, состоящие из набора взаимодействующих  подсистем. В подсистемах активные объекты представляют
    параллельныу нити процесса выполнения. Подсистемы могут разделяться между командами разработчиков, с интерфейсами, 
    служащими в качестве формального соглашения между командами.</p>
    <p>Замечания по отображению сообщений, выходящие из подсистем (или их прокси-классов): ограничивая сообщения
    только к интерфейсам, вы уменьшаете связанность между элементами модели и увеличивает гибкость проектирования.
    Где возможно, попытайтесь сделать это, в случае, где сообщения от подсистем идут к неинтерфейсным элементам модели,
    вы должны найти возможности изменить их на сообщения к интерфейсу, чтобы уменьшить связанность модели.</p>
  </li>
  <li>Отобразите взаимодействие с актерами. Отобразите каждого актера и внешний объект, которые взаимодействуют друг с другом,
    и покажите линии жизни на диаграммах последовательности.</li>
  <li>Отобразите сообщения посылаемые между участвующими объектами. Поток событий начинается в верхней части диаграммы и 
    продолжается ниже, показывая хронологию вертикальными осями. Покажите стрелками сообщения между объектами, создавая их между 
    линиями жизни. Название сообщения должно быть именем операции, вызываемой сообщением.
    На ранних этапах проектирования не так много операций, назначенных объектам, и вы можете не отображать эту информацию, дать
    сообщению временное имя; такие сообщения называются &quot;неназначенными&quot;. Позже, когда вы
    найдете больше операций взаимодействующих объектов, Вам нужно будет обновить диаграмму последовательности и назначить
    сообщения этим операциям.</li>
  <li>Опишите, что делает объект, когда получае сообщение. Это делается путем прикрепления письменного описания к сообщению.
    Поместите эти описания на полях диаграммы. Используйте структурированный текст или псевдокод. Если будете использовать
    псевдокод, для упрощения дальнейшей реализации используйте конструкции языка реализации. Тому, кто отвечает
    за назначение класса объекта и задание его операций, будет обеспечена основа для его работы.</li>
</ul>

<p>Следует заметить, что в ходе <a href="ac_ucana.htm">Активности: Провести анализ прецедента</a> должны были быть построены диаграммы последовательности 
для каждой реализации прецедента. Поэтому, если класс анализа грамотно построен и преобразован в 
класс проектирования (преобразования включают в себя перенос класса из одного пакета анализа 
в другой пакет проектирования и изменение стереотипа анализа на стереотип проектирования), то 
эти диаграммы автоматически преобразуются также. Исключение из этого правила составляет, 
если класс анализа может распасться на несколько классов проектирования, и в этом случае 
необходимо согласовать (обновить) диаграммы последовательности.
<p>Для диаграмм последовательности мы допускаем, что один интерфейс, а не его реализация, 
может вызывать методы другого интерфейса

<p align="center"><img src="../images/seqdiag3.gif" border="0" width="672" height="417"></p>
<p class="picturetext">Вы документируете поведение прецедента, которое производится объектами на диаграмме последовательности.</p>
<p>Когда вы распределяете поведение между объектами, вы должны рассмотреть, как будет контролироваться поток. 
Вы найдете объекты,
зная, что они будут взаимодействовать каким-то путем в реализации прецедента и играть какую-то роль. После распределения поведения,
вы можете начать проверку таких допущений. В некоторых частях потока вы захотите децентрализовать структуру; в некоторых - 
вы предпочтете централизованную.</p>
<br>
<p>Возможно, Вам будут нужны новые объекты, например, если Вы используете централизованную структуру и нуждаетесь в объекте,
контролирующем поток. Помните, что любой объект, который Вы добавляете в Проектную модель, должен удовлетворять требованиям
объектной модели.</p>

<h4>Отработать все варианты потока событий</h4>
<p>Вы должны описать каждый вариант потока в отдельной диаграмме последовательности. Диаграммы последовательности,
вообще говоря, предпочтительней: их легче читать, когда диаграмма должна содержать тот уровень детализации, который 
обычно используется при проектировании системы.</p>
<br>
<p>Начните с описания основного потока, который или наиболее общий, или наиболее важный. Затем опишите варианты, 
такие как исключительные ситуации. Вы не сможете описать все потоки до тех пор, пока вы не назначите и не 
проиллюстрируете все операции участвующих объектов. Следуя этому, очень тривиальные потоки, например, включающие только 
один объект, могут быть опущены.</p>
<p>Изучите прецедент, чтобы увидеть, имеются ли варианты потока, не описанные в требованиях и анализах, например,
зависящие о  реализации. после определения новых потоков, опишите каждый из них в диаграмме последовательности. Примеры 
исключительных потоков подразумевают следующее.
<ul>
  <li><strong>Обработку ошибок</strong>. Если интерфейс сообщает, что ошибка случилась во взаимодействии с внешней системой,
    например, когда прецедент должен работать в ней, возможным решением является открытие нового канала связи.</li>
  <li><strong>Обработка истечения времени ожидания</strong>. Если пользователь не отвечает в течение определенного времени,
    прецедент должен предпринять специальные меры.</li>
  <li><strong>Обработка ошибочного ввода в объект, участвующий в прецеденте</strong>. Ошибки, подобные этой, можно отловить
    защитой от некорректного пользовательского ввода.</li>
</ul>

<h4>Обработка опциональных частей прецедента</h4>
<p>Вы можете описать альтернативные пути потока как опциональный поток вместо вариантного. 
Ниже перечислены 2 примера опциональных потоков.
<ul>
  <li>Посылая сигнал, актер отталкивается от числа следующих действий прецедента. Прецедент просит актера ответить на вопрос да или нет,
    или обеспечить актера рядом функций, производимыми системой в текущем состоянии прецедента.</li>
  <li>Поток выбирается в зависимости от значения атрибутов или связей. Следующий поток событий зависит от типа данных, которые 
    нужно обработать.</li>
</ul>
<p>Если вы хотите, чтобы опциональные потоки или любые комплексные подпотоки были более заметны, используйте отдельные диаграммы
последовательностей. К каждой из них должна иметься ссылка из диаграммы последовательности основного потока событий. Это
делается с помощью пояснения на основной диаграмме, на которой показывается, где начинается подпоток или опциональное 
поведение.</p>
<p>Если опциональный или исключительный поток может случаться где угодно,
например, что-то должно произойти, когда случается событие, диаграмма последовательности основного потока событий
должна пояснять, что когда это событие случается, будет произведено поведение, описанное в опциональной/исключительной диаграмме последовательности.
Как альтернатива, если есть значительное поведение, основанное на событийной лолгике, рассмотрите использование диаграмм
состояний.</p>

<h3><a name="Describe Interactions Between Subsystems and/or their Interfaces (optional)"></a>
Упростить диаграммы последовательностей, используя подсистемы (опционально) <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>Когда прецедент реализован, поток событий описывается в терминах объектов выполнения, т.е. как взаимодействие между
проектными объектами. Чтобы упростить диаграммы и выделить поведение, которое можно использовать вторично, может понадобиться
выделить подпотоки событий в  подсистеме. Когда это будет проведено, большие части диаграмм последовательности будут замещены
простым сообщением к системе. Внутри подсистемы отдельные диаграммы последовательности могут иллюстрировать внутренние 
взаимодействия подсистемы, задающие необходимое поведение. См. <a href="ac_subds.htm">Активность: Спроектировать подсистему</a>).
Подпоследовательность сообщений диаграммы последовательности должны быть включены в подсистему когда:
<ul>
  <li>Подпоследовательность повторяется в различных реализациях прецедента; то есть похожие сообщения посылаются схожим
    объектам, получается тот же результат.</li>
  <li>Подпоследовательность случается только в одной реализации прецедента, но ожидается ее периодическое использование
    в будущих итерациях или будущих системах. Можно создать хороший для вторичного использования компонент.</li>
  <li>Подпоследовательность случается только в одной реализации прецедента, но она сложна, легко выделяема, ее результат 
    хорошо проработан, ответственность за нее возложена на одного человека или команду. В этих ситуациях сложное поведение 
    обычно требует специальных тех. знаний или знаний предметной области и, как результат, хорошо его выделить в подсистеме.</li>
  <li>Подпоследовательность задается в колмпоненте модели реализации. В этом случае, подсистема соответствующим образом
    представляет компонент в проектной модели.</li>
</ul>
<p align="center"><img src="../images/seqdiag6.gif" border="0" width="409" height="121"></p>
<p class="picturetext">Реализация прецедента может описываться, если необходимо, на нескольких уровнях иерархии подсистем.
Линии жизни в центральной диаграмме представляет подсистемы; взаимодействия в кружках представляют внутреннее взаимодействие
членов подсистемы при поступлении сообщения.<br>
<p>Преимущества такого подхода:
<ul>
  <li>Реализации прецедентов менее связаны, особенно если внутренний дизайн подсистем сложен.</li>
  <li>Реализации прецедентов могут создаваться перед внутренним проектированием создаваемых подсистем; это полезно, например,
    в параллельной разработке окружения. См. &quot;<a href="#How to Work in Parallel">Как работать в параллели</a>&quot;).</li>
  <li>Реализации прецедентов становятся более общими и легко изменяются, особенно, если подсистема должна замещаться другой
    подсистемой.</li>
</ul>
<p class="exampleheading">Пример:</p>
<p class="example">Рассмотрите следующую диаграмму последовательности, которая является частью реализации
<strong>Локального Вызова</strong> прецедента:</p>

<p align="center"><img src="../images/seqdiag7.gif" width="729" height="396"></p>
<p class="example">На диаграмме серые классы принадлежат подсистеме сетевой обработки; остальные - подсистеме обработки
абонентов. Это подразумевает, что существует диаграмма последовательностей множества подсистем, т.е. диаграмма, где включены все
объекты, участвующие во взаимодействии, независимо от того, лежат ли их классы вразных подсистемах.</p>
<p class="example">Как альтернатива, мы можем показать вызов поведения на диаграмме подсистемы сетевой обработки и
использование участвующих интерфейсов в такой подсистеме. Давайте предположим, что подсистема Сетевой обработки обеспечивает
интерфейс ICoordinator, который используется подсистемой обработки абонентов</p>
<p align="center"><img src="../images/subs_if.gif" width="425" height="100"></p>
<p class="example">ICoordinator реализуется классом Coordinator в сетевой обработке. 
Следуя этому, мы можем использовать подсистему сетевой обработки и интерфейс
ICoordinator, содержащийся в ней, на диаграмме последовательности, вместо экземпляров классов в
Сетевой Обработке:</p>
<p align="center"><img src="../images/seqdiag1.gif" width="672" height="417"></p>
<p class="example">Заметьте, что экземпляры классов Coordinator, Digit Information, и Network
замещены подсистемами, в которые они входят. Все обращения к подсистеме
делаются вместо этого через интерфейс ICoordinator.</p>

<h4>Отображените интерфейсов на линиях жизни</h4>
<p>Для достижения настоящей заменяемости подсистем, реализующих одинаковые интерфейсы, 
при взаимодействиях (и вообще на диаграммах) должны показываться только их интерфейсы; 
в противном случае взаимодействия (или диаграммы) должны изменяться, когда подсистемы заменяются одна другой.</p>
<p class="exampleheading">Пример:</p>
<p align="left" class="example">Мы можем включить только интерфейс ICoordinator, но не подсистему, его обеспечивающую,
на диаграмме последовательности:</p>
<p align="center"><img src="../images/seqdiag2.gif" width="519" height="309"></p>
<p class="example">Посылка сообщения к линии жизни интерфейса означает, что любая подсистема, которая реализует
интерфейс, может быть заменена на интерфейс на диаграмме. Заметьте, что линия жизни интерфейса ICoordinator 
не имеет сообщений, идущих от нее, потому что различные подсистемы могут реализовать интерфейсы, посылающие 
разные сообщения. Однако, если вы хотите описать, какие сообщения должны посылаться (или позволено посылать) любой подсистеме,
реализующей интерфейс, такие сообщения могут идти от линий жизни интерфейса.</p>

<h4><a name="How to Work in Parallel">Как работать в параллели</a></h4>
<p>В некоторых случаях, необходимо разработать подсистему более или менее независимо и в параллели с 
разработкой других подсистем. Для этого мы должны сначала выделить зависимости подсистем, определяя интерфейсы между ними.</p>
<ol>
  <li>Сконцентрируйте внимание на требованиях, которые затрагивают интерфейсы между подсистемами.</li>
  <li>Выберите основные принципы требуемых интерфейсов, показывая сообщения, идущие через границы подсистемы.</li>
  <li>Сформируйте диаграммы последовательностей в терминах подсистем для каждого прецедента.</li>
  <li>Уточните интерфейсы, необходимые для сообщений.</li>
  <li>Разработайте каждую систему в параллели и используйте интерфейсвы как инструмент синхронизации 
    между командами разработчиков.</li>
</ol>
<p>Вы также можете выбрать, систематизировать ли диаграммы последовательностей в терминах подсистем или только в терминах их
интерфейсов. В некоторых проектах может быть даже необходимым реализовать классы, обеспечивающие интерфейсы, перед тем, как 
продолжить моделирование.</p>

<h3><a name="XE_persistent_object__describing"></a><a name="XE_persistence__describing_persistence-related_behavior"></a><a name="Describe Persistence-Related Behaviors">Описать поведение, связанное с сохранением </a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>Одной из целей объектно-ориентированной парадигмы является инкапсуляция деталей реализации.
Поэтому необходимо иметь сохраняемые объекты, выглядящие как временные.
Нам не нужно заботиться о том, сохраняемый ли объект, или нет, не искать специальных процедур для обращения с ним.
Как минимум, цель такова.
<p>На практике, есть случаи, когда приложение должно контролировать различные аспекты, связанные с сохранением:
<ul>
  <li>при записи и чтении сохраняемых объектов</li>
  <li>при удалении сохраняемых объектов</li>
  <li>при управлении транзакциями</li>
  <li>при locking и контролировании параллельности</li>
</ul>

<h4><a name="Writing Persistent Objects">Написание сохраняемых объектов </a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Есть два случая: когда объект впервые записывается в хранилище и когда приложение обновляет хранилище и 
изменяет объект.
<p>В любом случае, механизм зависит от операций, поддерживаемых средой сохранения. Обычно
используются сообщения, которые посылаются этой среде для создания объектов. 
<p><strong>Часто</strong> можно подробно не моделировать этот механизм, если только не нужно 
знать, что объект действительно сохранен в какой-то точке потока событий. Если последующие операции должны 
запрашивать объект, объект должен существовать в базе, поэтому важно знать наличие объекта в базе.
<h4><a name="Reading Persistent Objects">Чтение сохраняемых объектов</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Получение объектов из хранилища до того момента, как приложение начнет посылать сообщения объекту.
Помните, что объектно-ориентированный подход подразумевает посылку сообщений объекту. Но нельзя посылать сообщения 
чему-либо, что еще не существует.
<p>Нужно посылать сообщение объекту, который знает, как работать с хранилищем, получать корректные объекты 
и инстанциировать их. Только после этого можно посылать сообщения к конечному объекту, которое, собственно, и требуется.
Объект, который отвечает за действия с сохраняемыми объектами, во многих случаях называется 
<em>фабрикой</em> объекта.
<p><strong>Фабрика</strong> ответственна за создание экземпляров класса, включая сохраняемые объекты.
<strong>Фабрика</strong> проектируется таким образом, чтобы возвращать набор из одного или более объектов, 
которые отвечают критериям запроса. При получении объектов возникает проблема получения всех объектов, связанных  с 
данным - это следствие связанности объектов между собой.

<h4><a name="Deleting Persistent Objects">Удаление сохраняемых объектов</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Проблема сохраняемых объектов в их сохраняемости! В отличие от 
временных объектов, которые исчезают вместе с процессом, породившим их, сохраняемые объекты должны быть 
специально удалены. Важно удалять объекты, когда они больше не будут использоваться.
<p>Проблема заключается в том, что трудно определить, что уничтожать.
<p>При проектировании может стать полезным использование <strong>диаграмм состояний</strong>:
когда объект достигает конечной стадии, говорят, что он <strong>освобождается</strong>.
Проектировщики, ответственные за реализацию сохраняемых классов, могут использовать данные диаграмм состояний,
чтобы создать необходимый механизм  освобождения объекта. Ответственность проектироващика реализации прецедента в 
том, чтобы вызвать необходимые операции объекта, приводящие к достижению его конечного состояния.
<p>Если объект сильно связан с другими объектами, может быть трудным определить, может ли объект быть удален.
Получение ответа на этот вопрос зачастую возлагают на <strong>фабрики</strong>.

<h4><a name="Modeling Transactions">Моделирование транзакций</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Транзакции задают набор <strong>атомарных</strong> наборов вызовов операций, которые либо выполняются все, либо
ни одна операция из которых не выполняется. В контексте сохраняемости, транзакции задают набор изменений над набором 
объектов, либо выполняющихся &quot;все вместе&quot;, либо не выполняющихся. Транзакции обеспечивают
устойчивость, гарантируя перемещение набора объектов из одного состояния в другое.
<p>Есть следующие способы показа транзакций на реализациях прецедентов:
<ul>
  <li><strong>Текстовый</strong>. Испольуя скрипты в приложении к диаграмме последовательностей.</li>
  <li><strong>Использование прямых соообщений</strong>.</li> 
</ul>

<h4><a name="Handling Error Conditions"></a>Оперирование ошибочными условиями <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Если не все операции, определенные в транзакции, могут быть выполнены (зачастую, из-за ошибок),
транзакция прерывается, а все произведенные изменения - откатываются.
Одидаемые ошибочные условия показывают как альтернативные потоки в прецеденте. в других случаях, система находится в 
ошибочном условии из-за того, что в ней произошел сбой.
<p>Неуспешные состояния объектов могут быть показаны на диаграммах состояний.

<h4><a name="Handling Concurrency Control">Оперирование параллельными потоками</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Параллельность показывает контроль доступа к критическим системным ресурсам в ходе транзакции.
Чтобы сохранить систему в должном состоянии, транзакции может требоваться эксклюзивный доступ к 
определенным ресурсам, например, на чтение или запись набора объектов.

<p>Целью параллелизма, как и транзакций, является перемещение системы из одного приемлемого состояния в другое.
Кроме того, параллелизм гарантирует доступность ресурсов. Контроль параллелизма может быть реализован
различными способами: locking ресурсов, семафоры, захват разделяемой памяти, отдельнные рабочие пространства.</p>

<p>Чтобы избежать ограничений реализации, в проектировании просто показывают ресурсы, к которым транзакция должны 
иметь эксклюзивный доступ. Программист-реализатор затем использует эту информацию для того, чтобы определить
как лучше всего реализовать требование параллелизма. 

<h3><a name="Refine the Flow of Events Description"></a>Уточнить описание потока событий<a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>При проектировании прецедента, возможно будет необходимым внести уточнения и дополнения. Например, 
временные характеристики, поведение по условиям или прояснение поведения для облегчения понимания диаграмм
внешними обозревателями.
<p>Поток событий, описанный в  <a href="ac_ucana.htm">Активности:
Провести анализ прецедента</a>, на этом шаге уточняются и проясняются диаграммы последовательностей.</p>
<p>Часто, название операции не дает полного представления, зачем она существует. Текстовые примечания
в примечаниях могут помочь в прояснении цели диаграммы последовательности.
Текстовые описания и скрипты могут быть нужны также, чтобы представить части потока, такие как шаги принятия решений, 
циклы, ветвления. кроме того, текстовые указатели могут пригодиться при соотнесении точек расширений прецедента с 
опеределенными местами в диаграмме последовательности.</p>

<h3><a name="XE_design_subsystem__unifying"></a><a name="XE_class__unifying_design_classes"></a><a name="Unify Classes and Subsystems">Объединить классы и системы</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>Как прецедент реализован, необходимо объединить идентифицированные классы и подсистемы. Тем самым будет 
показана стройность модели.
<p>Проверьте:
<ul>
  <li>Названия элементов модели соответствуют их функциям.</li>
  <li>Избегайте похожих имен и синонимии, так как станет трудно различить элементы модели.</li>
  <li>Соедините элементы модели со схожим поведением или относящиеся к одному вопросу.</li>
  <li>Соедините классы сущностей, которые представляют одну концепцию или имеют общие атрибуты,
даже если их поведение различно.</li>
  <li>Используйте наследование для абстрагирования элементов модели для большей стройности модели.</li>
  <li>Когда изменяете элемент модели, также обновляйте описание потока событий реализации прецедента.</li>
</ul>

<h3><a name="Evaluate Your Results"></a>Оцените результаты<a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>Вы должны проверить проектную модель на этом шаге и определить, что работа ведется в правильном направлении.
Не нужно проводить глубоких ревью, но удостоверьтесь, что вы достигли всех целей.
<br>
<p><font face="Arial"><a href="../../copyrite/copyrite.htm"><small><small>Copyright&nbsp;
© 1987 - 2002 Отдел имнформационных технологий</small></small></a></font>
<!--msnavigation--></td><td valign="top" width="24"></td><td valign="top" width="1%">
<p><a href="../../index.htm"></a></p>
<script language="JavaScript">
<!--
function loadTop()
{
  if(parent.frames.length!=0 && parent.frames[1].name=="ory_toc")
  {
     alert("The Rational Unified Process is already displayed using frames");
  }
  else
  {
    if(window.name=="ory_doc")
    {
      window.name = "xyz1234";
    }
    var expires = new Date();
    expires.setTime (expires.getTime() + (1000 * 20));
    document.cookie = "rup_ory_doc=" + escape (document.URL) +
    "; expires=" + expires.toUTCString() +  "; path=/";

    var new_ory_doc_loc = null;

    for(i=document.links.length-1;i>=0;i--)
    {
       if(document.links[i].href.indexOf("index.htm")!=-1)
       {
         new_ory_doc_loc = document.links[i].href;
         break;
       }
    }

    if(new_ory_doc_loc!=null)
    {
       top.location = new_ory_doc_loc;
    }
   }
}
// -->
</script>
<script language="JavaScript">
<!--
  function getImageUrl(image)
  {
    var new_ory_doc_loc=null;
    for(i=document.links.length-1;i>=0;i--)
    {
       if(document.links[i].href.indexOf("index.htm")!=-1)
       {
         new_ory_doc_loc = document.links[i].href.substring(0,document.links[i].href.lastIndexOf("/"));
         new_ory_doc_loc = new_ory_doc_loc + "" + image;
         return new_ory_doc_loc;
       }
    }
    return null;
  }
// -->
</script>
<script
language="JavaScript">
<!--
MSFPhover =
(((navigator.appName == "Netscape") &&
  (parseInt(navigator.appVersion) >= 3 )) ||
  ((navigator.appName == "Microsoft Internet Explorer") &&
  (parseInt(navigator.appVersion) >= 4 )));

  function MSFPpreload(img)
  {
     var a=new Image();
     a.src=img;
     return a;
  }
// -->
</script>
<script language="JavaScript">
<!--
    if(MSFPhover)
    {
        RupGray=MSFPpreload(getImageUrl('/images/rup1.gif'));
        RupBlue=MSFPpreload(getImageUrl('/images/rup1_a.gif'));
    }
// -->
</script>
</body>
</html>
