<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cvs-ru.texi on 1 April 2001 -->

<TITLE>CVS -- Система Управления Параллельными Версиями</TITLE>
</HEAD>
<BODY>
<H1>CVS -- Система Управления Параллельными Версиями</H1>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="cvs-ru.html#SEC1">Обзор</A>
<UL>
<LI><A NAME="TOC2" HREF="cvs-ru.html#SEC2">Что такое CVS?</A>
<LI><A NAME="TOC3" HREF="cvs-ru.html#SEC3">Чем не является CVS?</A>
<LI><A NAME="TOC4" HREF="cvs-ru.html#SEC4">Пример работы с CVS</A>
<UL>
<LI><A NAME="TOC5" HREF="cvs-ru.html#SEC5">Получение исходного кода</A>
<LI><A NAME="TOC6" HREF="cvs-ru.html#SEC6">Фиксирование изменений</A>
<LI><A NAME="TOC7" HREF="cvs-ru.html#SEC7">Уборка за собой</A>
<LI><A NAME="TOC8" HREF="cvs-ru.html#SEC8">Просмотр изменений</A>
</UL>
</UL>
<LI><A NAME="TOC9" HREF="cvs-ru.html#SEC9">Репозиторий</A>
<UL>
<LI><A NAME="TOC10" HREF="cvs-ru.html#SEC10">Как сообщить CVS, где находится репозиторий</A>
<LI><A NAME="TOC11" HREF="cvs-ru.html#SEC11">Как данные хранятся в репозитории</A>
<UL>
<LI><A NAME="TOC12" HREF="cvs-ru.html#SEC12">Где хранятся файлы в репозитории</A>
<LI><A NAME="TOC13" HREF="cvs-ru.html#SEC13">Права доступа к файлам</A>
<LI><A NAME="TOC14" HREF="cvs-ru.html#SEC14">Специфические для Windows права доступа</A>
<LI><A NAME="TOC15" HREF="cvs-ru.html#SEC15">Чердак</A>
<LI><A NAME="TOC16" HREF="cvs-ru.html#SEC16">Каталог CVS в репозитории</A>
<LI><A NAME="TOC17" HREF="cvs-ru.html#SEC17">Блокировки в репозитории</A>
<LI><A NAME="TOC18" HREF="cvs-ru.html#SEC18">Как в каталоге CVSROOT хранятся файлы</A>
</UL>
<LI><A NAME="TOC19" HREF="cvs-ru.html#SEC19">Как данные хранятся в рабочем каталоге</A>
<LI><A NAME="TOC20" HREF="cvs-ru.html#SEC20">Административные файлы</A>
<UL>
<LI><A NAME="TOC21" HREF="cvs-ru.html#SEC21">Редактирование административных файлов</A>
</UL>
<LI><A NAME="TOC22" HREF="cvs-ru.html#SEC22">Несколько репозиториев</A>
<LI><A NAME="TOC23" HREF="cvs-ru.html#SEC23">Создание репозитория</A>
<LI><A NAME="TOC24" HREF="cvs-ru.html#SEC24">Резервное копирование репозитория</A>
<LI><A NAME="TOC25" HREF="cvs-ru.html#SEC25">Перемещение репозитория</A>
<LI><A NAME="TOC26" HREF="cvs-ru.html#SEC26">Сетевые репозитории</A>
<UL>
<LI><A NAME="TOC27" HREF="cvs-ru.html#SEC27">Требования к серверу</A>
<LI><A NAME="TOC28" HREF="cvs-ru.html#SEC28">Соединение с помощью <CODE>rsh</CODE></A>
<LI><A NAME="TOC29" HREF="cvs-ru.html#SEC29">Прямое соединение с парольной аутентификацией</A>
<UL>
<LI><A NAME="TOC30" HREF="cvs-ru.html#SEC30">Настройка сервера для парольной аутентификации</A>
<LI><A NAME="TOC31" HREF="cvs-ru.html#SEC31">Использование клиента с парольной аутентификацией</A>
<LI><A NAME="TOC32" HREF="cvs-ru.html#SEC32">Вопросы безопасности при парольной аутентификации</A>
</UL>
<LI><A NAME="TOC33" HREF="cvs-ru.html#SEC33">Прямое соединение с использованием GSSAPI</A>
<LI><A NAME="TOC34" HREF="cvs-ru.html#SEC34">Прямое соединение с помощью Kerberos</A>
<LI><A NAME="TOC35" HREF="cvs-ru.html#SEC35">Использование параллельного <CODE>cvs server</CODE> для соединения</A>
</UL>
<LI><A NAME="TOC36" HREF="cvs-ru.html#SEC36">Доступ к репозиторию только для чтения</A>
<LI><A NAME="TOC37" HREF="cvs-ru.html#SEC37">Временные каталоги на сервере</A>
</UL>
<LI><A NAME="TOC38" HREF="cvs-ru.html#SEC38">Начинаем проект под CVS</A>
<UL>
<LI><A NAME="TOC39" HREF="cvs-ru.html#SEC39">Помещение файлов в репозиторий</A>
<UL>
<LI><A NAME="TOC40" HREF="cvs-ru.html#SEC40">Создание дерева каталогов из нескольких файлов</A>
<LI><A NAME="TOC41" HREF="cvs-ru.html#SEC41">Создание файлов из других систем контроля версий</A>
<LI><A NAME="TOC42" HREF="cvs-ru.html#SEC42">Создание дерева каталогов с нуля</A>
</UL>
<LI><A NAME="TOC43" HREF="cvs-ru.html#SEC43">Определение модуля</A>
</UL>
<LI><A NAME="TOC44" HREF="cvs-ru.html#SEC44">Ревизии</A>
<UL>
<LI><A NAME="TOC45" HREF="cvs-ru.html#SEC45">Номера ревизий</A>
<LI><A NAME="TOC46" HREF="cvs-ru.html#SEC46">Версии и ревизии</A>
<LI><A NAME="TOC47" HREF="cvs-ru.html#SEC47">Назначение номеров ревизий</A>
<LI><A NAME="TOC48" HREF="cvs-ru.html#SEC48">Метки ревизий</A>
<LI><A NAME="TOC49" HREF="cvs-ru.html#SEC49">Что пометить в рабочем каталоге</A>
<LI><A NAME="TOC50" HREF="cvs-ru.html#SEC50">Как помечать по дате или ревизии</A>
<LI><A NAME="TOC51" HREF="cvs-ru.html#SEC51">Удаление, перемещение и удаление меток</A>
<LI><A NAME="TOC52" HREF="cvs-ru.html#SEC52">Пометки при добавлении и удалении файлов</A>
<LI><A NAME="TOC53" HREF="cvs-ru.html#SEC53">Липкие метки</A>
</UL>
<LI><A NAME="TOC54" HREF="cvs-ru.html#SEC54">Создание ветвей и слияние</A>
<UL>
<LI><A NAME="TOC55" HREF="cvs-ru.html#SEC55">Для чего хороши ветви?</A>
<LI><A NAME="TOC56" HREF="cvs-ru.html#SEC56">Создание ветви</A>
<LI><A NAME="TOC57" HREF="cvs-ru.html#SEC57">Доступ к веткам</A>
<LI><A NAME="TOC58" HREF="cvs-ru.html#SEC58">Ветки и ревизии</A>
<LI><A NAME="TOC59" HREF="cvs-ru.html#SEC59">Волшебные номера веток</A>
<LI><A NAME="TOC60" HREF="cvs-ru.html#SEC60">Слияние веток</A>
<LI><A NAME="TOC61" HREF="cvs-ru.html#SEC61">многократное слияние из ветки</A>
<LI><A NAME="TOC62" HREF="cvs-ru.html#SEC62">Слияние изменений между двумя ревизиями</A>
<LI><A NAME="TOC63" HREF="cvs-ru.html#SEC63">При слиянии можно добавлять и удалять файлы</A>
</UL>
<LI><A NAME="TOC64" HREF="cvs-ru.html#SEC64">Рекурсивное поведение</A>
<LI><A NAME="TOC65" HREF="cvs-ru.html#SEC65">Добавление, удаление и переименование файлов и каталогов</A>
<UL>
<LI><A NAME="TOC66" HREF="cvs-ru.html#SEC66">Добавление файлов в каталог</A>
<LI><A NAME="TOC67" HREF="cvs-ru.html#SEC67">Удаление файлов</A>
<LI><A NAME="TOC68" HREF="cvs-ru.html#SEC68">Удаление каталогов</A>
<LI><A NAME="TOC69" HREF="cvs-ru.html#SEC69">Перемещение и переименование файлов</A>
<UL>
<LI><A NAME="TOC70" HREF="cvs-ru.html#SEC70">Обычный способ переименования</A>
<LI><A NAME="TOC71" HREF="cvs-ru.html#SEC71">Перемещение файла с ревизиями</A>
<LI><A NAME="TOC72" HREF="cvs-ru.html#SEC72">Копирование файла с ревизиями</A>
</UL>
<LI><A NAME="TOC73" HREF="cvs-ru.html#SEC73">Перемещение и переименование каталогов</A>
</UL>
<LI><A NAME="TOC74" HREF="cvs-ru.html#SEC74">Просмотр истории</A>
<UL>
<LI><A NAME="TOC75" HREF="cvs-ru.html#SEC75">Журнальные записи</A>
<LI><A NAME="TOC76" HREF="cvs-ru.html#SEC76">База истории</A>
<LI><A NAME="TOC77" HREF="cvs-ru.html#SEC77">Настройка журналирования</A>
<LI><A NAME="TOC78" HREF="cvs-ru.html#SEC78">Команда annotate</A>
</UL>
<LI><A NAME="TOC79" HREF="cvs-ru.html#SEC79">Обработка двоичных файлов</A>
<UL>
<LI><A NAME="TOC80" HREF="cvs-ru.html#SEC80">Вопросы использования двоичных файлов</A>
<LI><A NAME="TOC81" HREF="cvs-ru.html#SEC81">Как хранить двоичные файлы</A>
</UL>
<LI><A NAME="TOC82" HREF="cvs-ru.html#SEC82">Несколько разработчиков</A>
<UL>
<LI><A NAME="TOC83" HREF="cvs-ru.html#SEC83">Статус файла</A>
<LI><A NAME="TOC84" HREF="cvs-ru.html#SEC84">Извлечение свежей ревизии файла</A>
<LI><A NAME="TOC85" HREF="cvs-ru.html#SEC85">Пример конфликта</A>
<LI><A NAME="TOC86" HREF="cvs-ru.html#SEC86">Информирование коллег о фиксировании ревизий</A>
<LI><A NAME="TOC87" HREF="cvs-ru.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>
<LI><A NAME="TOC88" HREF="cvs-ru.html#SEC88">Как отследить, кто редактирует файлы?</A>
<UL>
<LI><A NAME="TOC89" HREF="cvs-ru.html#SEC89">Как с помощью CVS следить за определенными файлами?</A>
<LI><A NAME="TOC90" HREF="cvs-ru.html#SEC90">CVS может посылать вам уведомления</A>
<LI><A NAME="TOC91" HREF="cvs-ru.html#SEC91">Как редактировать файлы, за которыми наблюдают?</A>
<LI><A NAME="TOC92" HREF="cvs-ru.html#SEC92">Информация о том, кто следит и кто редактирует</A>
<LI><A NAME="TOC93" HREF="cvs-ru.html#SEC93">Использование слежений со старыми версиями CVS</A>
</UL>
<LI><A NAME="TOC94" HREF="cvs-ru.html#SEC94">Выбор между блокированными и неблокированными извлечениями</A>
</UL>
<LI><A NAME="TOC95" HREF="cvs-ru.html#SEC95">Управление ревизиями</A>
<UL>
<LI><A NAME="TOC96" HREF="cvs-ru.html#SEC96">Когда фиксировать изменения?</A>
</UL>
<LI><A NAME="TOC97" HREF="cvs-ru.html#SEC97">Подстановка ключевых слов</A>
<UL>
<LI><A NAME="TOC98" HREF="cvs-ru.html#SEC98">Список ключевых слов</A>
<LI><A NAME="TOC99" HREF="cvs-ru.html#SEC99">Использование ключевых слов</A>
<LI><A NAME="TOC100" HREF="cvs-ru.html#SEC100">Как избежать подстановки</A>
<LI><A NAME="TOC101" HREF="cvs-ru.html#SEC101">Режимы подстановки</A>
<LI><A NAME="TOC102" HREF="cvs-ru.html#SEC102">Проблемы с ключевым словом $@asis{}Log$.</A>
</UL>
<LI><A NAME="TOC103" HREF="cvs-ru.html#SEC103">Слежение за чужими исходными текстами</A>
<UL>
<LI><A NAME="TOC104" HREF="cvs-ru.html#SEC104">Начальный импорт</A>
<LI><A NAME="TOC105" HREF="cvs-ru.html#SEC105">Обновление с помощью импорта</A>
<LI><A NAME="TOC106" HREF="cvs-ru.html#SEC106">Возврат к последней версии от поставщика</A>
<LI><A NAME="TOC107" HREF="cvs-ru.html#SEC107">Как обрабатывать двоичные файлы при импорте в CVS</A>
<LI><A NAME="TOC108" HREF="cvs-ru.html#SEC108">Как обрабатывать замену ключевых слов при импорте в CVS</A>
<LI><A NAME="TOC109" HREF="cvs-ru.html#SEC109">Несколько веток поставщика</A>
</UL>
<LI><A NAME="TOC110" HREF="cvs-ru.html#SEC110">Как ваша система сборки взаимодействует с CVS</A>
<LI><A NAME="TOC111" HREF="cvs-ru.html#SEC111">Специальные файлы</A>
<LI><A NAME="TOC112" HREF="cvs-ru.html#SEC112">Руководство по командам CVS</A>
<UL>
<LI><A NAME="TOC113" HREF="cvs-ru.html#SEC113">Общая структура команд CVS</A>
<LI><A NAME="TOC114" HREF="cvs-ru.html#SEC114">Код выхода CVS</A>
<LI><A NAME="TOC115" HREF="cvs-ru.html#SEC115">Ключи по умолчанию и файл ~/.cvsrc</A>
<LI><A NAME="TOC116" HREF="cvs-ru.html#SEC116">Глобальные ключи командной строки</A>
<LI><A NAME="TOC117" HREF="cvs-ru.html#SEC117">Стандартные ключи командной строки</A>
<LI><A NAME="TOC118" HREF="cvs-ru.html#SEC118">Команда admin: администрирование</A>
<UL>
<LI><A NAME="TOC119" HREF="cvs-ru.html#SEC119">Ключи команды admin</A>
</UL>
<LI><A NAME="TOC120" HREF="cvs-ru.html#SEC120">Команда checkout: извлечение исходных текстов для редактирования</A>
<UL>
<LI><A NAME="TOC121" HREF="cvs-ru.html#SEC121">Ключи команды checkout</A>
<LI><A NAME="TOC122" HREF="cvs-ru.html#SEC122">Пример использования команды <SAMP>`checkout'</SAMP></A>
</UL>
<LI><A NAME="TOC123" HREF="cvs-ru.html#SEC123">Команды commit: поместить файлы в репозиторий</A>
<UL>
<LI><A NAME="TOC124" HREF="cvs-ru.html#SEC124">Ключи команды commit</A>
<LI><A NAME="TOC125" HREF="cvs-ru.html#SEC125">Пример использования команды commit</A>
<UL>
<LI><A NAME="TOC126" HREF="cvs-ru.html#SEC126">Помещение изменений на ветку</A>
<LI><A NAME="TOC127" HREF="cvs-ru.html#SEC127">Создание ветки после редактирования</A>
</UL>
</UL>
<LI><A NAME="TOC128" HREF="cvs-ru.html#SEC128">Команда diff: показать различия между ревизиями</A>
<UL>
<LI><A NAME="TOC129" HREF="cvs-ru.html#SEC129">Ключи команды diff</A>
<LI><A NAME="TOC130" HREF="cvs-ru.html#SEC130">Примеры использования команды diff</A>
</UL>
<LI><A NAME="TOC131" HREF="cvs-ru.html#SEC131">Команда export: экспортировать исходные тексты</A>
<UL>
<LI><A NAME="TOC132" HREF="cvs-ru.html#SEC132">Ключи команды export</A>
</UL>
<LI><A NAME="TOC133" HREF="cvs-ru.html#SEC133">Команда history: показать состояние файлов и пользователей</A>
<UL>
<LI><A NAME="TOC134" HREF="cvs-ru.html#SEC134">Ключи команды history</A>
</UL>
<LI><A NAME="TOC135" HREF="cvs-ru.html#SEC135">Команда import: импортировать исходные тексты</A>
<UL>
<LI><A NAME="TOC136" HREF="cvs-ru.html#SEC136">Ключи команды import</A>
<LI><A NAME="TOC137" HREF="cvs-ru.html#SEC137">Сообщения команды output</A>
<LI><A NAME="TOC138" HREF="cvs-ru.html#SEC138">Примеры использования команды import</A>
</UL>
<LI><A NAME="TOC139" HREF="cvs-ru.html#SEC139">Команда log: напечатать информацию о файлах</A>
<UL>
<LI><A NAME="TOC140" HREF="cvs-ru.html#SEC140">Ключи команды log</A>
<LI><A NAME="TOC141" HREF="cvs-ru.html#SEC141">Примеры использования команды log</A>
</UL>
<LI><A NAME="TOC142" HREF="cvs-ru.html#SEC142">Команда rdiff: выдать изменения между версиями в формате patch</A>
<UL>
<LI><A NAME="TOC143" HREF="cvs-ru.html#SEC143">Ключи команды rdiff</A>
<LI><A NAME="TOC144" HREF="cvs-ru.html#SEC144">Примеры использования команды rdiff</A>
</UL>
<LI><A NAME="TOC145" HREF="cvs-ru.html#SEC145">Команда release: сообщить, что модуль более не используется</A>
<UL>
<LI><A NAME="TOC146" HREF="cvs-ru.html#SEC146">Ключи команды release</A>
<LI><A NAME="TOC147" HREF="cvs-ru.html#SEC147">Сообщения команды release</A>
<LI><A NAME="TOC148" HREF="cvs-ru.html#SEC148">Примеры использования команды release</A>
</UL>
<LI><A NAME="TOC149" HREF="cvs-ru.html#SEC149">Команда update: обновить рабочий каталог из репозитория</A>
<UL>
<LI><A NAME="TOC150" HREF="cvs-ru.html#SEC150">Ключи команды update</A>
<LI><A NAME="TOC151" HREF="cvs-ru.html#SEC151">Сообщения команды update</A>
</UL>
</UL>
<LI><A NAME="TOC152" HREF="cvs-ru.html#SEC152">Краткий справочник по командам CVS</A>
<LI><A NAME="TOC153" HREF="cvs-ru.html#SEC153">Справочник по административным файлам</A>
<UL>
<LI><A NAME="TOC154" HREF="cvs-ru.html#SEC154">Файл <TT>`modules'</TT></A>
<UL>
<LI><A NAME="TOC155" HREF="cvs-ru.html#SEC155">Модули-синонимы</A>
<LI><A NAME="TOC156" HREF="cvs-ru.html#SEC156">Обычные модули</A>
<LI><A NAME="TOC157" HREF="cvs-ru.html#SEC157">Амперсенд-модули</A>
<LI><A NAME="TOC158" HREF="cvs-ru.html#SEC158">Исключение каталогов из списка</A>
<LI><A NAME="TOC159" HREF="cvs-ru.html#SEC159">Флаги модулей</A>
</UL>
<LI><A NAME="TOC160" HREF="cvs-ru.html#SEC160">Файл <TT>`cvswrappers'</TT></A>
<LI><A NAME="TOC161" HREF="cvs-ru.html#SEC161">Выполнение программ на разных стадиях фиксирования</A>
<UL>
<LI><A NAME="TOC162" HREF="cvs-ru.html#SEC162">Обычный синтаксис</A>
</UL>
<LI><A NAME="TOC163" HREF="cvs-ru.html#SEC163">Файл <TT>`commitinfo'</TT></A>
<LI><A NAME="TOC164" HREF="cvs-ru.html#SEC164">Проверка журнальных записей</A>
<LI><A NAME="TOC165" HREF="cvs-ru.html#SEC165">Файл <TT>`editinfo'</TT></A>
<UL>
<LI><A NAME="TOC166" HREF="cvs-ru.html#SEC166">Пример использования Editinfo</A>
</UL>
<LI><A NAME="TOC167" HREF="cvs-ru.html#SEC167">Файл loginfo</A>
<UL>
<LI><A NAME="TOC168" HREF="cvs-ru.html#SEC168">Пример использования loginfo</A>
<LI><A NAME="TOC169" HREF="cvs-ru.html#SEC169">Обновление извлеченной копии</A>
</UL>
<LI><A NAME="TOC170" HREF="cvs-ru.html#SEC170">Файл rcsinfo</A>
<LI><A NAME="TOC171" HREF="cvs-ru.html#SEC171">Игнорирование файлов с помощью cvsignore</A>
<LI><A NAME="TOC172" HREF="cvs-ru.html#SEC172">Файл history</A>
<LI><A NAME="TOC173" HREF="cvs-ru.html#SEC173">Подстановки в административных файлах</A>
<LI><A NAME="TOC174" HREF="cvs-ru.html#SEC174">Файл конфигурации CVSROOT/config</A>
</UL>
<LI><A NAME="TOC175" HREF="cvs-ru.html#SEC175">Все переменные окружения, используемые в CVS</A>
<LI><A NAME="TOC176" HREF="cvs-ru.html#SEC176">Совместимость между версиями CVS</A>
<LI><A NAME="TOC177" HREF="cvs-ru.html#SEC177">Исправление ошибок</A>
<UL>
<LI><A NAME="TOC178" HREF="cvs-ru.html#SEC178">Частичный список сообщений CVS</A>
<LI><A NAME="TOC179" HREF="cvs-ru.html#SEC179">Ошибки при установке соединения с CVS-сервером</A>
<LI><A NAME="TOC180" HREF="cvs-ru.html#SEC180">Другие распространенные проблемы</A>
</UL>
<LI><A NAME="TOC181" HREF="cvs-ru.html#SEC181">Титры</A>
<LI><A NAME="TOC182" HREF="cvs-ru.html#SEC182">Что делать с ошибками в CVS и этом руководстве?</A>
<LI><A NAME="TOC183" HREF="cvs-ru.html#SEC183">Индекс</A>
</UL>
<P><HR><P>

<P>
@dircategory Средства разработки
* cvs-ru: (cvs-ru).  Система Управления Параллельными Версиями


<P>
Управление версиями
с помощью
CVS
для CVS 1.10.8
Per Cederqvist et al
Перевод на русский язык -- Алексей Махоткин


<P>
Copyright (C) 1992, 1993 Signum Support AB<BR>
Copyright (C) 1999-2001 Alexey Mahotkin (translation into Russian)


<P>
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.


<P>
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.


<P>
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.


<P>
Перевод того же самого уведомления на русский язык (перевод, в
отличие от уведомления на английском языке, законной силы не
имеет):


<P>
Разрешается создавать и распространять неизмененные копии этого
руководства, при условии, что на всех копиях сохраняется
уведомление о копирайте и это разрешение об использовании.


<P>
Разрешается копировать и распространять измененные версии этого
руководства на условиях копирования без изменений, а также при
условии, что вся порожденная работа распространяется с
разрешением использования, идентичному этому разрешению.


<P>
Разрешается копировать и распространять переводы этого
руководства на другой язык, с точно такими же условиями
использования измененных версий, за исключением того, что это
разрешение может быть переведено, а перевод должен быть одобрен
Фондом Свободного Программного Обеспечения.


<P>
@macro cvsver{ver}
CVS \ver\




<H1><A NAME="SEC1" HREF="cvs-ru.html#TOC1">Обзор</A></H1>
<P>
<A NAME="IDX1"></A>


<P>
Эта глава предназначена для людей, никогда ранее не
использовавших CVS и, возможно, никогда не использовавших
управление версиями. 


<P>
Если вы уже знакомы с CVS и просто хотите изучить конкретную 
возможность или вспомнить определенную команду, вы, вероятно,
можете пропустить всю главу.




<H2><A NAME="SEC2" HREF="cvs-ru.html#TOC2">Что такое CVS?</A></H2>
<P>
<A NAME="IDX2"></A>
<A NAME="IDX3"></A>
<A NAME="IDX4"></A>



<PRE>
Не помнящие прошлого обречены повторять его.

-- Джордж Сантаяна
</PRE>

<P>
CVS -- это система контроля версий.  Используя ее, вы
можете вести историю ваших файлов с исходными текстами.


<P>
Например, иногда при определенном изменении в коде могут
появиться ошибки, которые вы не сможете обнаружить в течение
длительного времени.  С помощью CVS вы легко можете
обратиться к старым версиям, чтобы точно выяснить, что именно
привело к ошибке.  Иногда это сильно помогает.


<P>
Конечно, вы можете хранить каждую версию каждого файла, которые
вы создаете.  Это будет стоить вам невероятного объема дискового
пространства.  CVS хранит все версии файла в одном файле
таким образом, что запоминаются лишь изменения между версиями.


<P>
CVS также поможет, если вы являетесь членом группы
разработчиков одного проекта.  Очень легко попортить чужие
изменения, если только вы не крайне аккуратны.  Некоторые
редакторы, такие как GNU Emacs, стараются проследить, чтобы
два человека не изменяли одновременно один и тот же файл.  К
сожалению, если кто-то использует другой редактор, эта
предосторожность не сработает.  CVS решает эту проблему,
изолируя разработчиков друг от друга.  Каждый работает в своем
собственном каталоге, а затем CVS объединяет законченные
работы.


<P>
<A NAME="IDX5"></A>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
CVS появился из набора sh-скриптов, автором которых был Dick
Grune, опубликованных в группе новостей <CODE>comp.sources.unix</CODE>
в томе 6 в декабре 1986 года.  Несмотря на то, что ни строчки
кода из тех скриптов не присутствует в CVS, основы алгоритма
устранения конфликтов взяты именно оттуда.


<P>
В апреле 1989 года Brian Berliner спроектировал и реализовал
CVS.  Jeff Polk позднее помог ему с поддержкой модулей и
ветвей поставщика.


<P>
<A NAME="IDX8"></A>
Получить CVS можно разными способами, включая свободное
получение в Интернете.  За информацией о получении и по другим
вопросам обращайтесь на:



<PRE>
http://www.cyclic.com/
http://www.loria.fr/~molli/cvs-index.html
</PRE>

<P>
<A NAME="IDX9"></A>
<A NAME="IDX10"></A>
Имеется список рассылки <CODE>info-cvs</CODE>, посвященный обсуждению
CVS.  Чтобы подписаться на него или отписаться, пишите на
<CODE>info-cvs-request@gnu.org</CODE>.


<P>
Если вы предпочитаете группы новостей usenet, найдите
<CODE>comp.software.config-mgmt</CODE>, посвященную обсуждению
разнообразных систем управления конфигурацией, не только
CVS.  В будущем возможно создание
<CODE>comp.software.config-mgmt.cvs</CODE>, если в
<CODE>comp.software.config-mgmt</CODE> будет наличествовать достаточное
количество обсуждений CVS.


<P>
Можно также подписаться на список рассылки <CODE>bug-cvs</CODE>, о
котором подробно рассказывается в section <A HREF="cvs-ru.html#SEC182">Что делать с ошибками в CVS и этом руководстве?</A>.  Чтобы
подписаться, напишите на <CODE>bug-cvs-request@gnu.org</CODE>.




<H2><A NAME="SEC3" HREF="cvs-ru.html#TOC3">Чем не является CVS?</A></H2>
<P>
<A NAME="IDX11"></A>


<P>
CVS сделает для вас множество вещей, но не пытается быть
всем сразу.


<DL COMPACT>

<DT>CVS не является системой управления сборкой.
<DD>
Несмотря на то, что структуры вашего репозитория и файла модулей
взаимодействуют с системой управления сборкой (то есть файлами
<TT>`Makefile'</TT>), они принципиально независимы.

CVS не указывает, как собирать тот или иной проект.  Она
просто хранит файлы, предоставляя возможность обращаться к ним,
используя задуманную вами структуру дерева.

CVS не указывает, как использовать дисковое пространство в
извлеченных каталогах.  Если вы создадите <TT>`Makefile'</TT> или
скрипты в каждом каталоге так, что они должны знать относительную
позицию всего остального, то дело кончится тем, что придется
извлекать весь репозиторий.

Если вы модуляризуете вашу работу и создадите систему сборки,
которая будет совместно использовать файлы, (посредством ссылок,
монтирования, <CODE>VPATH</CODE> в <TT>`Makefile'</TT>'ах и т. д.), то
сможете использовать дисковое пространство любым угодным вам
способом.

Помните только, что <EM>любая</EM> подобная система требует
серьезной работы по созданию и поддержанию.  CVS не пытается
справиться с возникающими при этом вопросами.

Конечно же, вам следует поместить средства, созданные для
поддержки системы сборки (скрипты, <TT>`Makefile'</TT>'ы, и т. д.),
под CVS.

Выяснение того, какие файлы следует перекомпилировать при
каком-либо изменении, опять же, не является задачей CVS.
Традиционным подходом является использование <CODE>make</CODE> для
сборки, и использование специальной утилиты для генерации
зависимостей, используемых программой <CODE>make</CODE>.

Дополнительная информация о сборке проектов при использовании
CVS находится в section <A HREF="cvs-ru.html#SEC110">Как ваша система сборки взаимодействует с CVS</A>.

<DT>CVS не является заменой руководителю
<DD>
Предполагается, что вы общаетесь с вашим начальником и лидером
проекта достаточно часто, чтобы знать о графике работ, точках
слияния, именах веток и датах выпуска.  Если это не так, что
CVS никак не сможет помочь.

CVS -- это инструмент, заставляющий ваш код плясать под
вашу дудку. Но вы и композитор, и исполнитель.  Ни один
инструмент не играет сам и не сочиняет собственной музыки.

<DT>CVS не является заменой общения разработчиков.
<DD>
Встретившись с конфликтом, состоящим из единственной строки,
большинство разработчиков справляются с ними без особого труда.
Однако, более общее определение <EM>конфликта</EM> включает в себя
проблемы, которые слишком трудно решить без взаимодействия
разработчиков.

CVS не может обнаружить, что синхронные изменения в одном
или нескольких файлах привели к логическому конфликту.  Понятие
<EM>конфликт</EM>, которое использует CVS, строго текстуально.
Такие конфликты появляются, когда изменения в основном файле
достаточно близки, чтобы напугать программу слияния (то есть
<CODE>diff3</CODE>).

CVS совершенно неспособна помочь в устранении нетекстуальных
или распределенных конфликтов в логике программы.

Пример: предположим, вы изменили аргументы функции <CODE>X</CODE>,
описанной в файле <TT>`A'</TT>.  В то же самое время кто-то еще
редактирует файл <TT>`B'</TT>, добавив новый вызов функции <CODE>X</CODE>,
используя старые аргументы.  CVS ничем не сможет помочь.

Возьмите привычку читать спецификации и беседовать с коллегами.

<DT>CVS не ведет контроля изменений
<DD>
Под <EM>контролем изменений</EM> имеется в виду несколько вещей.
Во-первых, это может означать <EM>отслеживание ошибок</EM>, то есть
хранение базы данных обнаруженных ошибок и состояние каждой
(исправлена ли она? в какой версии? согласился ли обнаруживший
ее, что она исправлена?).  О взаимодействии с внешней системой
отслеживания ошибок можно прочитать в файлах <TT>`rcsinfo'</TT> и
<TT>`verifymsg'</TT> (see section <A HREF="cvs-ru.html#SEC153">Справочник по административным файлам</A>).

Другим аспектом контроля изменений является отслеживание того
факта, что изменения в нескольких файлах в действительности
являются одним и тем же согласованным изменением.  Если вы
фиксируете несколько файлов одной командой <CODE>cvs commit</CODE>, то
CVS забывает, что эти файлы были зафиксированы одновременно,
и единственная вещь, их объединяющая -- это одинаковые
журнальные записи.  В данном случае может помочь ведение файла
<TT>`ChangeLog'</TT> в стиле GNU.

Еще одним аспектом контроля изменений, в некоторых системах
является возможность отслеживать статус каждого изменения.
Некоторые изменения были написаны разработчиком, некоторые были
изучены другим разработчиком, и так далее.  Обычно при работе с
CVS в этом случае создается diff-файл, (используя <CODE>cvs
diff</CODE> или <CODE>diff</CODE>), который посылается по электронной почте
кому-нибудь, кто потом применит этот diff-файл, используя
программу <CODE>patch</CODE>.  Это очень гибко, но зависит от внешних
по отношению к CVS механизмов, чтобы убедиться, что ничего
не упущено.

<DT>CVS не является системой автоматического тестирования
<DD>
Впрочем, имеется возможность принудительного выполнения серии
тестов, используя файл <TT>`commitinfo'</TT>.  Я, однако же, не очень
много знаю о проектах, использовавших эту возможность, и есть ли
в ней какие-нибудь ловушки и подводные камни.

<DT>CVS не имеет встроенной модели процесса
<DD>
Некоторые системы обеспечивают способы убедиться, что изменения и
релизы проходят через определенные ступени, получая одобрение на
каждой.  Вообще говоря, этого можно добиться с помощью CVS,
но это может потребовать немного больше работы.  В некоторых
случаях вы будете использовать файлы <TT>`commitinfo'</TT>,
<TT>`loginfo'</TT>, <TT>`rcsinfo'</TT> или <TT>`verifymsg'</TT>, чтобы
убедиться, что предприняты определенные шаги, прежде чем CVS
позволит зафиксировать изменение.  Подумайте также, должны ли
использоваться такие возможности, как ветви разработки и метки,
чтобы, скажем, поработать над новой веткой разработки, а затем
объединять определенные изменения со стабильной веткой, когда эти
изменения одобрены.

</DL>



<H2><A NAME="SEC4" HREF="cvs-ru.html#TOC4">Пример работы с CVS</A></H2>
<P>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>
<A NAME="IDX16"></A>


<P>
В качестве введения в CVS мы приведем здесь типичную сессию
работы с CVS.  Первое, что необходимо понимать, это то, что
CVS хранит все файлы в централизованном <EM>репозитории</EM>
(see section <A HREF="cvs-ru.html#SEC9">Репозиторий</A>); в этой главе предполагается, что
репозиторий настроен.


<P>
Предположим, что вы работаете над простым компилятором.  Исходный 
текст состоит из нескольких C-файлов и <TT>`Makefile'</TT>'а.
Компилятор называется <SAMP>`tc'</SAMP> (Тривиальный Компилятор), а
репозиторий настроен так, что имеется модуль <SAMP>`tc'</SAMP>.




<H3><A NAME="SEC5" HREF="cvs-ru.html#TOC5">Получение исходного кода</A></H3>
<P>
<A NAME="IDX17"></A>
<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
<A NAME="IDX20"></A>
<A NAME="IDX21"></A>


<P>
Сначала вам надо получить рабочую копию исходного кода для
<SAMP>`tc'</SAMP>.  Используйте команду



<PRE>
$ cvs checkout tc
</PRE>

<P>
при этом будет создан каталог <TT>`tc'</TT>, в который будут помещены
все файлы с исходными текстами.



<PRE>
$ cd tc
$ ls
CVS         Makefile    backend.c   driver.c    frontend.c  parser.c
</PRE>

<P>
Каталог <TT>`CVS'</TT> используется для внутренних нужд CVS.
Обычно вам не следует редактировать или удалять файлы,
находящиеся в этом каталоге.


<P>
Вы запускаете свой любимый редактор, работаете над
<TT>`backend.c'</TT> и через пару часов вы добавили фазу оптимизации
в компилятор.  Замечание для пользователей RCS и RCCS:
не требуется блокировать файлы, которые вы желаете
отредактировать.  See section <A HREF="cvs-ru.html#SEC82">Несколько разработчиков</A>, где приведены
дополнительные объяснения.




<H3><A NAME="SEC6" HREF="cvs-ru.html#TOC6">Фиксирование изменений</A></H3>
<P>
<A NAME="IDX22"></A>
<A NAME="IDX23"></A>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
<A NAME="IDX26"></A>
<A NAME="IDX27"></A>
<A NAME="IDX28"></A>


<P>
После того, как вы проверили, что компилятор все еще
компилируется, вы решили создать новую версию <TT>`backend.c'</TT>.
При этом в репозитории появится ваш новый <TT>`backend.c'</TT>,
который станет доступным всем, использующим этот репозиторий.



<PRE>
$ cvs commit backend.c
</PRE>

<P>
CVS запускает редактор, чтобы позволить вам ввести
журнальную запись.  Вы набираете "Добавлена фаза оптимизации",
сохраняете временный файл и выходите из редактора.


<P>
Переменная окружения <CODE>$CVSEDITOR</CODE> определяет, какой именно
редактор будет вызван.  Если <CODE>$CVSEDITOR</CODE> не установлена, то
используется <CODE>$EDITOR</CODE>, если она, в свою очередь,
установлена.  Если обе переменные не установлены, используется
редактор по умолчанию для вашей операционной системы, например,
<CODE>vi</CODE> под UNIX или <CODE>notepad</CODE> для Windows 95/NT.


<P>
<A NAME="IDX29"></A>
<A NAME="IDX30"></A>
Вдобавок, CVS проверяет переменную окружения <CODE>VISUAL</CODE>.
Существуют различные мнения о том, требуется ли такое поведение и
должны ли дальнейшие версии CVS проверять переменную
<CODE>VISUAL</CODE> или игнорировать её.  В любом случае, лучше всего
будет убедиться, что <CODE>VISUAL</CODE> или вообще не установлена, или
установлена в то же значение, что и <CODE>EDITOR</CODE>.


<P>
Когда CVS запускает редактор, в шаблоне для ввода журнальной
записи перечислены измененные файлы.  Для клиента CVS этот
список создается путём сравнения времени изменения файла с его
временем изменения, когда он был получен или обновлен.  Таким
образом, если время изменения файла изменилось, а его содержимое
осталось прежним, он будет считаться измененным.  Проще всего в
данном случае не обращать на это внимания -- в процессе
фиксирования изменений CVS определит, что содержимое файла
не изменилось и поведет себя должным образом.  Следующая команда
<CODE>update</CODE> сообщит CVS, что файл не был изменен, и его
время изменения будет возвращено в прежнее значение, так что этот
файл не будет мешаться при дальнейших фиксированиях.


<P>
Если вы хотите избежать запуска редактора, укажите журнальную
запись в командной строке, используя флаг <SAMP>`-m'</SAMP>, например: 



<PRE>
$ cvs commit -m "Добавлена фаза оптимизации" backend.c
</PRE>



<H3><A NAME="SEC7" HREF="cvs-ru.html#TOC7">Уборка за собой</A></H3>
<P>
<A NAME="IDX31"></A>
<A NAME="IDX32"></A>
<A NAME="IDX33"></A>
<A NAME="IDX34"></A>
<A NAME="IDX35"></A>


<P>
Перед тем, как перейти к другим занятиям, вы решаете удалить
рабочую копию <CODE>tc</CODE>.  Конечно же, это можно сделать так:



<PRE>
$ cd ..
$ rm -r tc
</PRE>

<P>
но лучшим способом будет использование команды <CODE>release</CODE>
(see section <A HREF="cvs-ru.html#SEC145">Команда release: сообщить, что модуль более не используется</A>):



<PRE>
$ cd ..
$ cvs release -d tc
M driver.c
? tc
You have [1] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': n
** `release' aborted by user choice.
</PRE>

<P>
Команда <CODE>release</CODE> проверяет, что все ваши изменения были
зафиксированы.  Если включено журналирование истории, то в файле
истории появляется соответствующая пометка.  See section <A HREF="cvs-ru.html#SEC172">Файл history</A>.


<P>
Если вы используете команду <CODE>release</CODE> с флагом <SAMP>`-d'</SAMP>, то
она удаляет вашу рабочую копию.


<P>
В вышеприведенном примере команда <CODE>release</CODE> выдала несколько
строк. <SAMP>`? tc'</SAMP> означает, что файл <TT>`tc'</TT> неизвестен
CVS.  Беспокоиться не о чем, <TT>`tc'</TT> -- это исполняемый
файл компилятора, и его не следует хранить в репозитории.
See section <A HREF="cvs-ru.html#SEC171">Игнорирование файлов с помощью cvsignore</A>, где можно найти информацию о том, как
избежать этого предупреждения.  See section <A HREF="cvs-ru.html#SEC147">Сообщения команды release</A>,
где находится полная информация о возможных сообщениях команды
<CODE>release</CODE>.


<P>
<SAMP>`M driver.c'</SAMP> -- более серьезное сообщение.  Оно означает,
что файл <TT>`driver.c'</TT> был изменен с момента последнего
получения из репозитория.


<P>
Команда <CODE>release</CODE> всегда сообщает, сколько измененных файлов 
находится в вашей рабочей копии исходных кодов, а затем
спрашивает подтверждения перед удалением файлов или внесения
пометки в файл истории.


<P>
Вы решаете перестраховаться и отвечаете <KBD>n <KBD>RET</KBD></KBD>, когда
<CODE>release</CODE> просит подтверждения.




<H3><A NAME="SEC8" HREF="cvs-ru.html#TOC8">Просмотр изменений</A></H3>
<P>
<A NAME="IDX36"></A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>


<P>
Вы не помните, что изменяли файл <TT>`driver.c'</TT>, поэтому хотите
посмотреть, что именно случилось с ним.



<PRE>
$ cd tc
$ cvs diff driver.c
</PRE>

<P>
Эта команда сравнивает версию файла <TT>`driver.c'</TT>, находящейся
в репозитории, с вашей рабочей копией.  Когда вы рассматриваете
изменения, вы вспоминаете, что добавили аргумент командной
строки, разрешающий фазу оптимизации.  Вы фиксируете это
изменение и высвобождаете модуль.



<PRE>
$ cvs commit -m "Добавлена фаза оптимизации" driver.c
Checking in driver.c;
/usr/local/cvsroot/tc/driver.c,v  &#60;--  driver.c
new revision: 1.2; previous revision: 1.1
done
$ cd ..
$ cvs release -d tc
? tc
You have [0] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': y
</PRE>



<H1><A NAME="SEC9" HREF="cvs-ru.html#TOC9">Репозиторий</A></H1>
<P>
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>
<A NAME="IDX41"></A>
<A NAME="IDX42"></A>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
<A NAME="IDX45"></A>


<P>
В <EM>репозитории</EM> CVS хранит полные копии всех файлов и
каталогов, находящихся под контролем версий.


<P>
Обычно вам никогда не придется напрямую обращаться к файлам в
репозитории.  Вместо этого вы будете использовать команды
CVS для получения вашей собственной копии файлов в вашем
<EM>рабочем каталоге</EM>, а затем будете работать с этой копией.
Когда вы внесли определенные изменения, вы помещаете (или
<EM>фиксируете</EM>) их в репозиторий.  Теперь в репозитории
хранится информация о сделанных вами изменениях: что именно и
когда было изменено и прочая подобная информация.  Заметьте, что
репозиторий не является подкаталогом рабочего каталога, и
обратное также неверно; они находятся в совершенно разных местах.


<P>
<A NAME="IDX46"></A>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
CVS может обращаться к репозиторию множеством способов.
Репозиторий может находиться на локальной машине, на соседней
машине или же на машине, находящейся на другом континенте.  Чтобы
различать способы доступа к репозиторию, его имя начинается с
<EM>метода доступа</EM>.  Например, метод доступа <SAMP>`:local:'</SAMP>
означает, что репозиторий находится в локальном каталоге.
Например, <SAMP>`:local:/usr/local/cvsroot'</SAMP> означает, что
репозиторий находится в <TT>`/usr/local/cvsroot'</TT> на компьютере,
на котором используется CVS.  Другие методы доступа описаны
в section <A HREF="cvs-ru.html#SEC26">Сетевые репозитории</A>.


<P>
Если метод доступа не указан, и имя репозитория не содержит
<SAMP>`:'</SAMP>, то предполагается метод <CODE>:local:</CODE>.  Если в имени
содержится <SAMP>`:'</SAMP>, то предполагается метод доступа <CODE>:ext:</CODE> 
или <CODE>:server:</CODE>.  Например, если ваш локальный репозиторий
находится в <TT>`/usr/local/cvsroot'</TT>, то вы можете использовать
<CODE>/usr/local/cvsroot</CODE> вместо
<CODE>:local:/usr/local/cvsroot</CODE>.  Но если, например, под
Windows NT ваш локальный репозиторий находится в
<TT>`c:\src\cvsroot'</TT>, то вы должны указать метод доступа, то
есть <CODE>:local:c:\src\cvsroot</CODE>. 


<P>
Репозиторий делится на две части.  <TT>`$CVSROOT/CVSROOT'</TT>
содержит административные файлы CVS.  Все прочие каталоги
содержат модули, определенные пользователем.




<H2><A NAME="SEC10" HREF="cvs-ru.html#TOC10">Как сообщить CVS, где находится репозиторий</A></H2>

<P>
Существует несколько способов сообщить CVS, где искать
репозиторий.  Вы можете явно задать репозиторий в командной
строке с помощью ключа <CODE>-d</CODE> ("directory", каталог):



<PRE>
cvs -d /usr/local/cvsroot checkout yoyodyne/tc
</PRE>

<P>
<A NAME="IDX49"></A>
<A NAME="IDX50"></A>
<A NAME="IDX51"></A>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>
Другим вариантом является установка переменной окружения
<CODE>$CVSROOT</CODE> в полный путь до корня репозитория, например,
<TT>`/usr/local/cvsroot'</TT>.  Чтобы установить <CODE>$CVSROOT</CODE>,
пользователи <CODE>csh</CODE> и <CODE>tcsh</CODE> должны поместить в свой
файл <TT>`~/.cshrc'</TT> или <TT>`~/.tcshrc'</TT> такую строку:



<PRE>
setenv CVSROOT /usr/local/cvsroot
</PRE>

<P>
Пользователи <CODE>sh</CODE> и <CODE>bash</CODE> должны поместить в свой файл 
<TT>`.profile'</TT> или <TT>`.bashrc'</TT> такие строки



<PRE>
CVSROOT=/usr/local/cvsroot
export CVSROOT
</PRE>

<P>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>
Имя репозитория, указанное с помощью <SAMP>`-d'</SAMP>, будет
использоваться вместо указанного в переменной окружения
<CODE>$CVSROOT</CODE>.  Когда вы извлечете рабочую копию из
репозитория, эта копия будет помнить, из какого именно
репозитория ее извлекли (эта информация хранится в файле
<TT>`CVS/Root'</TT> в рабочем каталоге).


<P>
Ключ <SAMP>`-d'</SAMP> и файл <TT>`CVS/Root'</TT> переопределяют репозиторий,
заданный в переменной окружения <CODE>$CVSROOT</CODE>.  Если
репозиторий, заданный ключом <SAMP>`-d'</SAMP>, отличается от
репозитория, указанного в файле <TT>`CVS/Root'</TT>, используется
первый из них.  Конечно же, для правильного функционирования в
обоих местах должен быть упомянут один и тот же репозиторий.




<H2><A NAME="SEC11" HREF="cvs-ru.html#TOC11">Как данные хранятся в репозитории</A></H2>
<P>
<A NAME="IDX56"></A>


<P>
В большинстве случаев неважно, <EM>как</EM> именно CVS хранит
информацию в репозитории.  В действительности, формат уже менялся
однажды и, скорее всего, изменится в будущем.  Так как в
большинстве случаев весь доступ к репозиторию происходит
посредством команд CVS, такие изменения не приводят к
каким-либо разрушениям.


<P>
Однако, в некоторых случаях необходимо знать, как именно CVS
хранит данные в репозитории, например, если вы хотите следить за
блокировками файлов, которые делает CVS (see section <A HREF="cvs-ru.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>) или если вам потребуется изменить права доступа к файлам
в репозитории.




<H3><A NAME="SEC12" HREF="cvs-ru.html#TOC12">Где хранятся файлы в репозитории</A></H3>

<P>
Общая структура репозитория -- это дерево каталогов,
соответствующее каталогам в рабочей копии.  Предположим,
например, что репозиторий находится в 



<PRE>
/usr/local/cvsroot
</PRE>

<P>
Вот возможное дерево каталогов (показаны только каталоги):



<PRE>
<TT>/usr</TT>
 |
 +--<TT>local</TT>
 |   |
 |   +--<TT>cvsroot</TT>
 |   |    |
 |   |    +--<TT>CVSROOT</TT>
          |      (административные файлы)
          |
          +--<TT>gnu</TT>
          |   |
          |   +--<TT>diff</TT>
          |   |   (исходный текст GNU diff)
          |   |
          |   +--<TT>rcs</TT>
          |   |   (исходный текст RCS)
          |   |
          |   +--<TT>cvs</TT>
          |       (исходный текст CVS)
          |
          +--<TT>yoyodyne</TT>
              |
              +--<TT>tc</TT>
              |    |
              |    +--<TT>man</TT>
              |    |
              |    +--<TT>testing</TT>
              |
              +--(другое программное обеспечение фирмы Yoyodyne)
</PRE>

<P>
Внутри каталогов находятся <EM>файлы истории</EM> для каждого файла,
находящегося под контролем версий.  Имя файла истории состоит из
имени соответствующего файла и суффикса <SAMP>`,v'</SAMP>.  Вот как
выглядит дерево каталогов для <TT>`yoyodyne/tc'</TT>:



<PRE>
  <CODE>$CVSROOT</CODE>
    |
    +--<TT>yoyodyne</TT>
    |   |
    |   +--<TT>tc</TT>
    |   |   |
            +--<TT>Makefile,v</TT>
            +--<TT>backend.c,v</TT>
            +--<TT>driver.c,v</TT>
            +--<TT>frontend.c,v</TT>
            +--<TT>parser.c,v</TT>
            +--<TT>man</TT>
            |    |
            |    +--<TT>tc.1,v</TT>
            |
            +--<TT>testing</TT>
                 |
                 +--<TT>testpgm.t,v</TT>
                 +--<TT>test2.t,v</TT>
</PRE>

<P>
<A NAME="IDX57"></A>
<A NAME="IDX58"></A>


<P>
Файл истории содержит, помимо всего прочего, достаточно
информации, чтобы воссоздать любую ревизию файла, журнал всех
зафиксированных изменений и имена всех пользователей, сделавших
эти изменения.  Файлы истории известны как <EM>RCS-файлы</EM>,
потому что первой программой, которая создавала файлы этого
формата, была система контроля версий RCS.  Полное описание
формата файлов находится на странице руководства
<CITE>rcsfile(5)</CITE>, распространяемого вместе с RCS, или в
файле <TT>`doc/RCSFILES'</TT> из комплекта исходных текстов CVS.
Этот формат файла используется повсеместно -- множество других
программ могут по меньшей мере импортировать файлы этого формата.


<P>
Файлы RCS, используемые в CVS, несколько отличаются от
стандартного формата.  Волшебные ветки -- самое большое
отличие; see section <A HREF="cvs-ru.html#SEC59">Волшебные номера веток</A>.  Имена меток, которые
позволяет использовать CVS, являются подмножеством тех, что
позволены в RCS; see section <A HREF="cvs-ru.html#SEC48">Метки ревизий</A>.




<H3><A NAME="SEC13" HREF="cvs-ru.html#TOC13">Права доступа к файлам</A></H3>
<P>
<A NAME="IDX59"></A>
<A NAME="IDX60"></A>
<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>
<A NAME="IDX64"></A>
<A NAME="IDX65"></A>
Все файлы <SAMP>`,v'</SAMP> создаются с правами "только для чтения", и
вам не следует изменять эти права доступа.  Каталоги в
репозитории должны быть доступны для записи тем, кому разрешено
изменять файлы в каждом каталоге.  Это обычно означает, что вам
нужно создать группу пользователей UNIX (см. страницу
руководства <CITE>group(5)</CITE>), состоящую из лиц, участвующих в
создании проекта, и настроить репозиторий так, чтобы эта группа
была владельцем каталога с проектом.


<P>
Это означает, что ограничивать доступ к файлам можно только на
уровне каталога.


<P>
Заметьте, что пользователи должны иметь права на запись в каталог
и для извлечения файлов, потому что CVS должна создать файлы
блокировки (see section <A HREF="cvs-ru.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>).


<P>
Заметьте также, что пользователи должны иметь права на запись в
файл <TT>`CVSROOT/val-tags'</TT>.  CVS использует этот файл,
чтобы отслеживать, какие метки разрешены (этот файл иногда
обновляется, когда используются и когда создаются метки).


<P>
Каждый RCS-файл принадлежит пользователю, который последним
зафиксировал изменения в этот файл.  Этот факт не столь важен,
главное -- кто владелец каталога.


<P>
<A NAME="IDX66"></A>
<A NAME="IDX67"></A>
<A NAME="IDX68"></A>
<A NAME="IDX69"></A>
CVS пытается установить адекватные права доступа к файлам
для новых каталогов, которые создаются в дереве, но если вам
требуется, чтобы новый каталог имел права доступа, отличающиеся
от его родительского каталога, вы должны задать это вручную.
Если вы установите переменную окружения <CODE>CVSUMASK</CODE>, то она
будет задавать, какие права доступа к файлам CVS использует
при создании каталогов и/или файлов в репозитории.
<CODE>CVSUMASK</CODE> не влияет на права доступа к файлам в рабочем
каталоге; такие файлы имеют права, обычные для новых файлов,
разве что только иногда CVS создает их с правами только для
чтения (See section <A HREF="cvs-ru.html#SEC103">Слежение за чужими исходными текстами</A>. See section <A HREF="cvs-ru.html#SEC116">Глобальные ключи командной строки</A>, где описан ключ <SAMP>`-r'</SAMP>; See section <A HREF="cvs-ru.html#SEC175">Все переменные окружения, используемые в CVS</A>,
в которой описана переменная <CODE>CVSREAD</CODE>).


<P>
Заметьте, что при использовании клиент-серверного CVS
(see section <A HREF="cvs-ru.html#SEC26">Сетевые репозитории</A>) не существует нормального способа
установить <CODE>CVSUMASK</CODE>; установка его на клиентской машине не
играет роли.  Если вы соединяетесь с помощью <CODE>rsh</CODE>, то
можете устанавливать <CODE>CVSUMASK</CODE> в файле <TT>`.bashrc'</TT> или
<TT>`.cshrc'</TT>, как описано в документации на вашу операционную
систему.  Это поведение может измениться в будущей версии
CVS; не полагайтесь на то, что установка <CODE>CVSUMASK</CODE> на
клиентской машине не играет роли.


<P>
При использовании сервера парольной аутентификации
(<SAMP>`pserver'</SAMP>) обычно требуются гораздо более жесткие права
доступа к каталогу <CODE>$CVSROOT</CODE> и каталогам, находящимся в
нём; see section <A HREF="cvs-ru.html#SEC30">Настройка сервера для парольной аутентификации</A>.


<P>
<A NAME="IDX70"></A>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>
Некоторые операционные системы позволяют определенным программам
выполнять операции, которые не может выполнять тот, кто вызывает
эти программы.  Таковы, например, возможности setuid или setgid в
UNIX или установленные образы в VMS.  CVS не
разрабатывался, чтобы использовать такие возможности, и поэтому
попытки установить CVS таким образом обеспечат защиту только
лишь от случайных ошибок; те, кто желает обойти защиту, смогут
это сделать и, в зависимости от конкретных условий, смогут
получить доступ еще куда-либо помимо CVS.  Вы можете
попробовать использовать pserver.  Эта возможность также способна
создать ложное чувство безопасности или открыть дыру, большую чем
та, которую вы пытаетесь закрыть, поэтому внимательно прочтите
главу о безопасности сервера парольной аутентификации, если вы
собираетесь его использовать. Дополнительная информация в
section <A HREF="cvs-ru.html#SEC30">Настройка сервера для парольной аутентификации</A>.




<H3><A NAME="SEC14" HREF="cvs-ru.html#TOC14">Специфические для Windows права доступа</A></H3>
<P>
<A NAME="IDX74"></A>
<A NAME="IDX75"></A>


<P>
Некоторые вопросы, связанные с правами доступа, специфичны для
операционных систем класса Window (Windows 95/98, Windows NT и,
скорее всего, будущие подобные операционные системы.  Часть
нижесказанного может быть применима к OS/2, хотя я не уверен).




<H3><A NAME="SEC15" HREF="cvs-ru.html#TOC15">Чердак</A></H3>
<P>
<A NAME="IDX76"></A>
<A NAME="IDX77"></A>


<P>
Вы заметите, что иногда CVS помещает RCS-файлы в
каталоге <CODE>Attic</CODE> ("чердак").  Например, если CVSROOT -- это
<TT>`/usr/local/cvsroot'</TT>, и мы говорим о файле <TT>`backend.c'</TT>
в каталоге <TT>`yoyodyne/tc'</TT>, то обычно этот файл находится в 



<PRE>
/usr/local/cvsroot/yoyodyne/tc/backend.c,v
</PRE>

<P>
Если же он попадает на чердак, то он будет находиться в 



<PRE>
/usr/local/cvsroot/yoyodyne/tc/Attic/backend.c,v
</PRE>

<P>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
С точки зрения пользователя неважно, находится файл на чердаке
или нет, так как CVS сам следит за этим и при необходимости
заглядывает на чердак в поисках файла.  В случае же, если вы
хотите знать точно, то RCS-файл хранится на чердаке тогда и
только тогда, когда головная ревизия ствола находится в состоянии
<CODE>dead</CODE> (<EM>мертвое</EM>).  "Мертвое" состояние означает, что
файл был удален или же никогда не добавлялся в эту ветку.
Например, если вы добавите файл в ветку, то его стволовая ревизия
будет в "мертвом" состоянии, а ревизия на ветке -- нет.




<H3><A NAME="SEC16" HREF="cvs-ru.html#TOC16">Каталог CVS в репозитории</A></H3>
<P>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>


<P>
Каталог <TT>`CVS'</TT> в каждом репозитории содержит информацию об
атрибутах файлов (в файле <TT>`CVS/fileattr'</TT>); смотри
<TT>`fileattr.h'</TT> среди исходных текстов CVS за дополнительной
информацией.  В будущем в этом каталоге могут оказать другие
дополнительные файлы, поэтому сегодняшние реализации должны
игнорировать неизвестные файлы.


<P>
Это поведение реализовано только в версиях @cvsver{1.7} и выше,
see section <A HREF="cvs-ru.html#SEC93">Использование слежений со старыми версиями CVS</A>.




<H3><A NAME="SEC17" HREF="cvs-ru.html#TOC17">Блокировки в репозитории</A></H3>

<P>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>
<A NAME="IDX87"></A>
Видимое пользователем поведение блокировок CVS описано в
section <A HREF="cvs-ru.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>.  Эта глава ориентирована на людей,
пишущих утилиты, обращающиеся к репозиторию CVS, не конфликтуя
при этом с другими программами, обращающимися к тому же
репозиторию.  Если вы запутаетесь в описываемых здесь концепциях,
как то <EM>блокировка чтения</EM>, <EM>блокировка записи</EM> и
<EM>мертвая блокировка</EM>, то обратитесь к литературе по
операционным системам или базам данных.


<P>
<A NAME="IDX88"></A>
Файлы в репозитории, чьи имена начинаются с <TT>`#cvs.rfl'</TT> ---
это блокировки чтения.  Файлы, чьи имена начинаются с
<TT>`#cvs.wfl'</TT> -- это блокировки записи.  Старые версии
CVS (до @cvsver{1.5}) создавали также файлы с именами,
начинающимися с <TT>`#cvs.tfl'</TT>, но такие файлы здесь не
обсуждаются.  Каталог <TT>`#cvs.lock'</TT> служит основной
блокировкой, то есть перед тем, как создавать какую-либо еще
блокировку, сначала необходимо создать основную блокировку.


<P>
Чтобы создать блокировку чтения, сначала создайте каталог
<TT>`#cvs.lock'</TT>.  В большинстве операционных систем операция
создания каталога является атомарной.  Если попытка создания завершилась
неудачно, значит, основная блокировка уже существует, поэтому
подождите немного и попробуйте еще.  После получения блокировки
<TT>`#cvs.lock'</TT> создайте файл, чье имя состоит из
<TT>`#cvs.rfl'</TT>, и информацией по вашему выбору, например, имя
машины и номер процесса.  Потом удалите каталог <TT>`#cvs.lock'</TT>,
чтобы снять основную блокировку.  Теперь можно читать
репозиторий.  Когда чтение окончено, удалите файл
<TT>`#cvs.rfl'</TT>, чтобы снять блокировку чтения.


<P>
Чтобы получить блокировку записи, сначала создайте каталог
<TT>`#cvs.lock'</TT>, как и в случае с блокировкой чтения.  Затем
убедитесь, что в репозитории нет файлов, чьи имена начинаются с
<TT>`#cvs.rfl'</TT>.  Если они имеются, удалите <TT>`#cvs.lock'</TT>,
подождите немного и попробуйте снова.  Если блокировок чтения
нет, создайте файл с именем, состоящим из <TT>`#cvs.wfl'</TT> и
какой-нибудь информации по вашему выбору, например, имени машины
и номера процесса.  Не удаляйте блокировку <TT>`#cvs.lock'</TT>.
Теперь вы можете писать в репозиторий.  Когда запись окончена,
сначала удалите файл <TT>`#cvs.wfl'</TT>, а затем каталог
<TT>`#cvs.lock'</TT>.  Заметьте, что в отличие от файла
<TT>`#cvs.rfl'</TT>, файл <TT>`#cvs.wfl'</TT> имеет чисто информационное
значение; он не оказывает блокирующего эффекта, который в данном
случае достигается использованием главной блокировки
(<TT>`#cvs.lock'</TT>).


<P>
Заметьте, что каждая блокировка (чтения или записи) блокирует
единственный каталог в репозитории, включая <TT>`Attic'</TT> и
<TT>`CVS'</TT>, но не включая подкаталоги, которые представляют собой 
другие каталоги, находящиеся под контролем версий.  Чтобы
заблокировать целое дерево, вам следует заблокировать каждый
каталог (заметьте, что если вы не сможете получить хотя бы одну
блокировку в этом процессе, то следует отменить все уже
полученные блокировки, затем подождать и попробовать снова, во
избежание мертвых блокировок.)


<P>
Заметьте также, что CVS ожидает, что доступ к отдельным
файлам <TT>`foo,v'</TT> контролируется блокировками записи.
RCS использует в качестве блокировок файлы <TT>`,foo,'</TT>, но 
CVS не поддерживает такую схему, поэтому рекомендуется
использование блокировки записи.  Смотри комментарии к
<CODE>rcs_internal_lockfile</CODE> в исходном коде CVS, где
находится дополнительное обсуждение и мотивация.




<H3><A NAME="SEC18" HREF="cvs-ru.html#TOC18">Как в каталоге CVSROOT хранятся файлы</A></H3>
<P>
<A NAME="IDX89"></A>


<P>
Каталог <TT>`$CVSROOT/CVSROOT'</TT> содержит различные
административные файлы.  В каком-то смысле этот каталог подобен
любому другому каталогу в репозитории; он содержит
RCS-файлы, чьи имена заканчиваются на <SAMP>`,v'</SAMP>, и многие
команды CVS оперируют с ними обычным образом.  Однако,
имеется несколько различий.


<P>
Для каждого административного файла, в дополнение к
RCS-файлу, хранится его последняя ревизия.  Например, есть
RCS-файл <TT>`loginfo,v'</TT> и файл <TT>`loginfo'</TT>, содержащий
последнюю ревизию, находящуюся в <TT>`loginfo,v'</TT>.  Когда вы
фиксируете административный файл, CVS должен написать:



<PRE>
cvs commit: Rebuilding administrative file database
</PRE>

<P>
<A NAME="IDX90"></A>
<A NAME="IDX91"></A>
и обновить его извлеченную копию в <TT>`$CVSROOT/CVSROOT'</TT>.  Если
это не так, значит, что-то случилось с CVS (see section <A HREF="cvs-ru.html#SEC182">Что делать с ошибками в CVS и этом руководстве?</A>).  Чтобы ваши CVS обращался с вашими собственными
файлами точно так же, вы можете добавить их имена в
административный файл <TT>`checkoutlist'</TT>.


<P>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>
<A NAME="IDX94"></A>
По умолчанию, файл <TT>`modules'</TT> ведет себя как описано
выше.  Если же он становится очень большим, то хранение в виде
плоского файла может привести к медленному поиску модулей (я не
уверен, что это все еще столь же важно, как и тогда, когда эта
возможность впервые появилась; я не видел расчетов
быстродействия).  Таким образом, внеся определенные изменения в
исходный код CVS, можно хранить файл модулей в базе данных,
которая имеет интерфейс с <CODE>ndbm</CODE>, например, Berkeley db или
GDBM.  Если эта опция используется, то база данных модулей
будет храниться в файлах <TT>`modules.db'</TT>, <TT>`modules.pag'</TT>
и/или <TT>`modules.dir'</TT>.


<P>
Информация о назначении разнообразных административных файлов
находится в section <A HREF="cvs-ru.html#SEC153">Справочник по административным файлам</A>.




<H2><A NAME="SEC19" HREF="cvs-ru.html#TOC19">Как данные хранятся в рабочем каталоге</A></H2>

<P>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>
Пока мы описываем внутреннюю работу CVS, которая иногда
становится видна, мы можем также поговорить о том, что CVS
хранит в каталогах <TT>`CVS'</TT> в рабочих каталогах.  Как и в
случае с репозиторием, CVS обрабатывает эту информацию, и
обычно вы обращаетесь к ней посредством команд CVS.  В
некоторых случаях, однако, бывает полезно напрямую работать с
содержимым этих каталогов, например, в графической оболочке
<CODE>jCVS</CODE> или пакете <CODE>VC</CODE> для emacs.  Такие программы
должны следовать рекомендациям в этой главе, если они желают
нормально работать совместно с другими программами, использующими 
те же самые файлы, включая будущие их версии, а также с CVS, 
работающим из командной строки.


<P>
Каталог <TT>`CVS'</TT> содержит несколько файлов.  Программы,
читающие этот каталог, должны игнорировать файлы, находящиеся в
этом каталоге, но не документированные здесь, чтобы дать
возможность развития в будущем.


<P>
Файлы хранятся в текстовом формате, соответствующем соглашениям
операционной системы.  Это означает, что рабочие каталоги не
переносимы между системами с разными форматами хранения текстовых 
файлов.  Это сделано специально, исходя из того, что сами файлы,
находящиеся под управлением CVS, вероятно, также не
переносимы между такими платформами.


<DL COMPACT>

<DT><TT>`Root'</TT>
<DD>
Этот файл содержит текущий корневой каталог CVS, как описано
в section <A HREF="cvs-ru.html#SEC10">Как сообщить CVS, где находится репозиторий</A>.

<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<A NAME="IDX100"></A>
<DT><TT>`Repository'</TT>
<DD>
Этот файл содержит каталог в репозитории, которому соответствует
текущий каталог.  Здесь может быть имя с полным или относительным 
путем; CVS способна обрабатывать оба варианта, начиная с
версии 1.3.  Относительный путь отсчитывается от корня, хотя
использование абсолютного пути довольно распространено и
программы должны уметь обрабатывать оба варианта.  Например,
после команды


<PRE>
cvs -d :local:/usr/local/cvsroot checkout yoyodyne/tc
</PRE>

<TT>`Root'</TT> будет содержать


<PRE>
:local:/usr/local/cvsroot
</PRE>

а <TT>`Repository'</TT> будет содержать или


<PRE>
/usr/local/cvsroot/yoyodyne/tc
</PRE>

или


<PRE>
yoyodyne/tc
</PRE>

Если рабочий каталог не имеет соответствующего каталога в
репозитории, то <TT>`Repository'</TT> должен содержать
<TT>`CVSROOT/Emptydir'</TT>. 

<A NAME="IDX101"></A>
<A NAME="IDX102"></A>
<A NAME="IDX103"></A>
<DT><TT>`Entries'</TT>
<DD>
В этом файле перечислены файлы и каталоги в рабочем каталоге.

Первый символ каждой строки указывает тип каждой строки.  Если
символ нераспознан, программа, читающая файл, должна спокойно
пропустить эту строку, чтобы дать возможность развития в
будущем. 

Если первый символ -- это <SAMP>`/'</SAMP>, то формат строки таков
If the first character is <SAMP>`/'</SAMP>, then the format is:


<PRE>
/<VAR>имя</VAR>/<VAR>ревизия</VAR>/<VAR>метка времени</VAR>[+<VAR>конфликт</VAR>]/<VAR>опции</VAR>/<VAR>тэг или дата</VAR>
</PRE>

где <SAMP>`['</SAMP> и <SAMP>`]'</SAMP> не являются частью строки, но указывают,
что <SAMP>`+'</SAMP> и отметка о конфликте не обязательны.  <VAR>name</VAR>
--- это имя файла в каталоге.  <VAR>ревизия</VAR> -- это номер
ревизии, на которой основан файл в рабочем каталоге, или <SAMP>`0'</SAMP>
для добавленного файла, или <SAMP>`-'</SAMP>, за которым следует номер
ревизии, для удаленного файла.  <VAR>метка времени</VAR> -- это время,
когда CVS создала этот файл; если это время отличается от
текущего времени модификации файла, значит, он был изменен.
Метка времени записывается в UTC (по Гринвичу), в формате,
используемом функцией стандарта ISO C <CODE>asctime()</CODE> (например,
<SAMP>`Sun Apr 7 01:29:26 1996'</SAMP>).  Можно написать также строку в
другом формате, например, <SAMP>`Result of merge'</SAMP>, чтобы указать,
что файл всегда должен считаться измененным.  Эта строка -- вовсе
не специальный случай: чтобы узнать, изменился ли файл, CVS
берет дату модификации файла и просто сравнивает строку со
строкой <VAR>метка времени</VAR>. <VAR>конфликт</VAR> указывает, что
произошел конфликт.  Если эта строка совпадает с действительным
временем модификации, значит, пользователь еще не справился с
конфликтом.  <VAR>опции</VAR> содержат прилипшие ключи командной
строки (например, <SAMP>`-kb'</SAMP> для двоичных файлов).  <VAR>тэг или
дата</VAR> содержит либо <SAMP>`T'</SAMP>, за которой следует имя тэга, либо
<SAMP>`D'</SAMP>, за которой следует прилипший тэг или дата.  Заметьте,
что если <VAR>метка времени</VAR> содержит пару меток времени,
разделенных пробелом, а не единственную метку времени, значит, вы
имеете дело с версией CVS ранее 1.5 (этот случай здесь не
документирован).

Если первый символ в строке в файле <TT>`Entries'</TT> -- это
<SAMP>`D'</SAMP>, это означает подкаталог.  <SAMP>`D'</SAMP> на отдельной строке
указывает, что программа, которая создала файл <TT>`Entries'</TT>,
умеет обращаться с подкаталогами (то есть, если такая строка
присутствует, и нет других строк, начинающихся с <SAMP>`D'</SAMP>,
значит, подкаталогов нет).  В противном случае строка выглядит
так:


<PRE>
D/<VAR>имя</VAR>/<VAR>заполнитель1</VAR>/<VAR>заполнитель2</VAR>/<VAR>заполнитель3</VAR>/<VAR>заполнитель4</VAR>
</PRE>

где <VAR>имя</VAR> -- это имя подкаталога, а все поля
<VAR>заполнитель</VAR> должны игнорироваться, в целях будущих
расширений.  Программы, изменяющие файлы <TT>`Entries'</TT>, должны
сохранять значения этих полей.

Строки в файле <TT>`Entries'</TT> могут быть в любом порядке. 

<A NAME="IDX104"></A>
<A NAME="IDX105"></A>
<A NAME="IDX106"></A>
<DT><TT>`Entries.Log'</TT>
<DD>
В этом файле хранится та же самая информация, что и в файле
<TT>`Entries'</TT>, и с его помощью можно обновлять эту информацию
без необходимости полностью переписывать файл <TT>`Entries'</TT>,
включая возможность сохранять информацию, даже если программа,
писавшая в <TT>`Entries'</TT> и <TT>`Entries.Log'</TT> аварийно
завершилась.  Программы, читающие файл <TT>`Entries'</TT> должны
также проверять существование файла <TT>`Entries.Log'</TT>.  Если
последний существует, то они должны прочесть файл <TT>`Entries'</TT>
и внести в него изменения из файла <TT>`Entries.Log'</TT>, после чего 
рекомендуется записать заново файл <TT>`Entries'</TT> и удалить файл 
<TT>`Entries.Log'</TT>. Формат строки файла <TT>`Entries.Log'</TT> ---
односимвольная команда, за которой следует строка, в формате
<TT>`Entries'</TT>.  Команда -- это либо <SAMP>`A'</SAMP> для указания, что
строка добавляется, либо <SAMP>`R'</SAMP> -- если строка удаляется, или
любой другой символ -- если эту строку следует проигнорировать
(для будущих расширений).  Если второй символ строки в файле
<TT>`Entries.Log'</TT> -- не пробел, значит, файл был создан старой
версией CVS (здесь не документируется).

Программы, которые пишут, но не читают, могут спокойно
игнорировать <TT>`Entries.Log'</TT>.

<A NAME="IDX107"></A>
<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<DT><TT>`Entries.Backup'</TT>
<DD>
Это временный файл.  Рекомендованное использование -- записать
новый файл <TT>`Entries'</TT> в <TT>`Entries.Backup'</TT>, затем
переименовать его (атомарно, если возможно) в <TT>`Entries'</TT>.

<A NAME="IDX110"></A>
<A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<DT><TT>`Entries.Static'</TT>
<DD>
Единственная вещь, интересующая нас об этом файле -- существует
он или нет.  Если существует, это значит, что была получена
только часть каталога и CVS не будет создавать в нем
дополнительных файлов.  Чтобы очистить этот файл, используйте
команду <CODE>update</CODE> с опцией <SAMP>`-d'</SAMP>, чтобы получить
дополнительные файлы и удалить <TT>`Entries.Static'</TT>.

<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<A NAME="IDX119"></A>
<DT><TT>`Tag'</TT>
<DD>
В этом файле находятся прилипшие тэги и даты для этого каталога.
Первый символ -- <SAMP>`T'</SAMP> для тэга ветки, <SAMP>`N'</SAMP> для обычного
тэга или <SAMP>`D'</SAMP> для даты.  Другие символы должны
игнорироваться, для будущих расширений.  За этим символом следует
тэг или дата.  Заметьте, что прилипшие тэги и даты применяются к
добавляемым файлам; они могут отличаться от тэгов и дат,
прилипших к отдельным файлам.  Общая информация о прилипших тэгах 
и датах находится в section <A HREF="cvs-ru.html#SEC53">Липкие метки</A>.

<A NAME="IDX120"></A>
<A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
<DT><TT>`Checkin.prog'</TT>
<DD>
<DT><TT>`Update.prog'</TT>
<DD>
В этих файлах хранятся имена программ, заданных опциями <SAMP>`-i'</SAMP> 
и <SAMP>`-u'</SAMP> в файле <TT>`modules'</TT>, соответственно.

<A NAME="IDX126"></A>
<A NAME="IDX127"></A>
<A NAME="IDX128"></A>
<DT><TT>`Notify'</TT>
<DD>
В этом файле хранятся уведомления (например, для <CODE>edit</CODE> или
<CODE>unedit</CODE>), которые еще не было отосланы на сервер.  Их
формат еще не документирован здесь.

<A NAME="IDX129"></A>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>
<DT><TT>`Notify.tmp'</TT>
<DD>
Этот файл по отношению к файлу <TT>`Notify'</TT> является тем же, что 
<TT>`Entries.Backup'</TT> по отношению к <TT>`Entries'</TT>.  Чтобы
создать файл <TT>`Notify'</TT>, сначала запишите его новое содержимое 
в <TT>`Notify.tmp'</TT>, затем (атомарно, если возможно),
переименуйте его в <TT>`Notify'</TT>.

<A NAME="IDX132"></A>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>
<A NAME="IDX135"></A>
<DT><TT>`Base'</TT>
<DD>
Если используются слежения, то команда <CODE>edit</CODE> сохраняет
исходную копию файла в каталоге <TT>`Base'</TT>.  Это позволяет
команде <CODE>unedit</CODE> работать, даже если нет доступа к серверу.

<A NAME="IDX136"></A>
<A NAME="IDX137"></A>
<A NAME="IDX138"></A>
<DT><TT>`Baserev'</TT>
<DD>
В этом файле перечислены ревизии каждого файла в каталоге
<TT>`Base'</TT>.  Формат таков:


<PRE>
B<VAR>имя</VAR>/<VAR>ревизия</VAR>/<VAR>расширение</VAR>
</PRE>

поле <VAR>расширение</VAR> должно быть проигнорировано, для
будущих расширений.

<A NAME="IDX139"></A>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>
<DT><TT>`Baserev.tmp'</TT>
<DD>
Этот файл по отношению к <TT>`Baserev'</TT> является тем же, чем
<TT>`Entries.Backup'</TT> по отношению к <TT>`Entries'</TT>.  Чтобы
создать записать файл <TT>`Baserev'</TT>, сначала запишите его новое
содержимое в <TT>`Baserev.tmp'</TT>, затем (атомарно, если возможно), 
переименуйте его в <TT>`Baserev'</TT>.

<A NAME="IDX142"></A>
<A NAME="IDX143"></A>
<A NAME="IDX144"></A>
<DT><TT>`Template'</TT>
<DD>
Этот файл содержит шаблон, заданный файлом <TT>`rcsinfo'</TT>
(see section <A HREF="cvs-ru.html#SEC170">Файл rcsinfo</A>).  Он используется только клиентом;
не-клиент-серверные варианты CVS напрямую обращаются к
<TT>`rcsinfo'</TT>.
</DL>



<H2><A NAME="SEC20" HREF="cvs-ru.html#TOC20">Административные файлы</A></H2>
<P>
<A NAME="IDX145"></A>
<A NAME="IDX146"></A>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>
<A NAME="IDX149"></A>


<P>
Каталог <TT>`$CVSROOT/CVSROOT'</TT> содержит несколько
<EM>административных файлов</EM>.  Полное их описание в
See section <A HREF="cvs-ru.html#SEC153">Справочник по административным файлам</A>.  Можно использовать CVS и без этих
файлов, но некоторые команды лучше работают, если хотя бы файл
<TT>`modules'</TT> должным образом настроен.  В сущности, этот файл
является наиболее важным, в нем описываются все модули в
репозитории.  Вот пример этого файла:



<PRE>
CVSROOT         CVSROOT
modules         CVSROOT modules
cvs             gnu/cvs
rcs             gnu/rcs
diff            gnu/diff
tc              yoyodyne/tc
</PRE>

<P>
Файл <TT>`modules'</TT> представляет собой текстовый файл.  В
простейшем случае каждая строка содержит имя модуля, пробел и имя 
каталога, где находится этот модуль, относительно
<CODE>$CVSROOT</CODE>.


<P>
Строка, которая определяет модуль <SAMP>`modules'</SAMP>, использует
возможности, здесь не описанные.  Полное описание всех доступных
возможностей находится в See section <A HREF="cvs-ru.html#SEC154">Файл <TT>`modules'</TT></A>.




<H3><A NAME="SEC21" HREF="cvs-ru.html#TOC21">Редактирование административных файлов</A></H3>
<P>
<A NAME="IDX150"></A>
<A NAME="IDX151"></A>


<P>
Административные файлы можно редактировать точно так же, как и
любой другой модуль.  Используйте <SAMP>`cvs checkout CVSROOT'</SAMP>,
чтобы получить рабочий каталог, редактируйте его и зафиксируйте
изменения обычным образом.


<P>
Случается, что фиксируется административный файл с ошибкой.
Обычно можно исправить ошибку и зафиксировать новую версию, но
иногда особенно серьезная ошибка может привести к невозможности
фиксирования изменений.




<H2><A NAME="SEC22" HREF="cvs-ru.html#TOC22">Несколько репозиториев</A></H2>
<P>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>


<P>
Иногда необходимо иметь много репозиториев, например, если у вас
есть две группы разработчиков, работающих над разными проектами,
у которых нет общего кода.  Все, что вам требуется, чтобы
работать с несколькими репозиториями -- указать необходимый,
используя переменную среды <CODE>CVSROOT</CODE>, опцию CVS
<SAMP>`-d'</SAMP> или (если у вас уже есть рабочий каталог) просто
работая по умолчанию с тем репозиторием, из которого был извлечен
рабочий каталог (see section <A HREF="cvs-ru.html#SEC10">Как сообщить CVS, где находится репозиторий</A>.


<P>
Серьезным преимуществом нескольких репозиториев является то, что
они могут находиться на различных серверах.  При использовании
@cvsver{1.10} единственная команда может работать с каталогами из 
разных репозиториев.  С помощью разрабатываемых версий CVS
можно извлекать исходные тексты с нескольких серверов.  CVS
сам разберется с обходом дерева каталогов и соединениями с
разными серверами при необходимости.  Вот пример создания
рабочего каталога:



<PRE>
cvs -d server1:/cvs co dir1
cd dir1
cvs -d server2:/root co sdir
cvs update
</PRE>

<P>
Команды <CODE>cvs co</CODE> создают рабочий каталог, а команда
<CODE>cvs update</CODE> соединится с <CODE>server2</CODE>, чтобы обновить
каталог <TT>`dir1/sdir'</TT>, и с <CODE>server1</CODE>, чтобы обновить все
остальное.




<H2><A NAME="SEC23" HREF="cvs-ru.html#TOC23">Создание репозитория</A></H2>

<P>
<A NAME="IDX158"></A>
<A NAME="IDX159"></A>
<A NAME="IDX160"></A>


<P>
Чтобы настроить CVS-репозиторий, сначала выберите машину и
диск, на котором будет храниться история ревизий исходных
текстов.  Требования к процессору и памяти умеренны, поэтому
подойдет практически любая машина.  Детали описаны в
section <A HREF="cvs-ru.html#SEC27">Требования к серверу</A>.


<P>
Если вы импортируете RCS-файлы из другой системы, начальное
дисковое пространство можно оценить как суммарный размер этих
файлов.  В дальнейшем можно рассчитывать на троекратный размер
исходных текстов, которые вы будете хранить под контролем
версий (когда-нибудь вы перерастете этот предел, но не слишком
скоро).  На машинах разработчики требуется дисковое пространство
для рабочего каталога каждого разработчика (все дерево или его
кусок, в зависимости от того, над чем работает программист).


<P>
К репозиторию должен быть доступ (прямой или с помощью сетевой
файловой системы) со всех машин, которые будут использовать
CVS в серверном или локальном режиме; клиентские машины не
требуют никакого доступа к репозиторию кроме протокола CVS.
Использование CVS для доступа только для чтения все равно
требует прав на запись в репозиторий для создания файлов
блокировок (see section <A HREF="cvs-ru.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>).


<P>
<A NAME="IDX161"></A>
Чтобы создать репозиторий, выполните команду <CODE>cvs init</CODE>.
Она создаст пустой репозиторий в корневом каталоге CVS,
заданном обычным образом (see section <A HREF="cvs-ru.html#SEC9">Репозиторий</A>).  Например,



<PRE>
cvs -d /usr/local/cvsroot init
</PRE>

<P>
<CODE>cvs init</CODE> следит, чтобы не перезаписать уже существующие
файлы, поэтому никакого вреда от запуска <CODE>cvs init</CODE> по уже
настроенному репозиторию не произойдет.


<P>
<CODE>cvs init</CODE> включит журналирование истории; если вы не хотите
этого, удалите файл истории после выполнения <CODE>cvs init</CODE>.
See section <A HREF="cvs-ru.html#SEC172">Файл history</A>.




<H2><A NAME="SEC24" HREF="cvs-ru.html#TOC24">Резервное копирование репозитория</A></H2>
<P>
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>


<P>
Файлы в репозитории, в сущности, не обладают никакими особыми
свойствами, в большинстве случаев можно делать их резервные копии 
как обычно.  Есть, однако, несколько аспектов, которые необходимо 
учитывать.


<P>
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>
Во-первых, с параноидальной точки зрения, следует либо не
использовать CVS во время резервного копирования, либо
сделать так, чтобы программа резервного копирования блокировала
репозиторий в процессе.  Чтобы не использовать CVS, вы
можете запретить логины на машины, которые могут иметь доступ к
репозиторию, отключить CVS-сервер или сделать что-либо
подобное.  Детали зависят от вашей операционной системы и от
настройки CVS.  Чтобы заблокировать CVS, создайте файлы 
блокировок (<TT>`#cvs.rfl'</TT>) в каждом каталоге репозитория.
See section <A HREF="cvs-ru.html#SEC87">Совместный доступ нескольких разработчиков к CVS</A>, где приводится дополнительная информация о
блокировках CVS.  Даже учитывая вышесказанное, если вы
просто скопируете файлы, ничего особенно страшного не
произойдет.  Однако, при восстановлении из резервной копии
репозиторий может находиться в неустойчивом состоянии, что,
впрочем, нетрудно исправить вручную.


<P>
Когда вы восстанавливаете репозиторий из резервной копии,
предполагая, что репозиторий изменился с момента последнего
резервного копирования, рабочие каталоги, которые не пострадали,
могут ссылаться на ревизии, не существующие более в репозитории.
Попытка выполнения CVS в таких каталогах приведет к
сообщению об ошибке.  Один из способов вернуть все изменения в
репозиторий таков:



<UL>
<LI>

Получите новый рабочий каталог.

<LI>

Скопируйте файлы из рабочего каталога, сделанного перед аварией,
поверх файлов в новом рабочем каталоге (не копируйте содержимое
каталогов <TT>`CVS'</TT>). 

<LI>

Работая в новом рабочем каталоге, используйте команды типа
<CODE>cvs update</CODE> и <CODE>cvs diff</CODE>, чтобы выяснить, что
изменилось, а затем зафиксируйте изменения в репозиторий.
</UL>



<H2><A NAME="SEC25" HREF="cvs-ru.html#TOC25">Перемещение репозитория</A></H2>
<P>
<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>


<P>
Точно так же, как и в случае с резервным копированием файлов,
перемещение репозитория с места на место сводится к перемещению
набора файлов.


<P>
Основная вещь, которую нужно учитывать -- это то, что рабочие
каталоги ссылаются на репозиторий.  Самый простой способ
справиться с этим -- получить свежий рабочий каталог после
перемещения.  Конечно, вам следует сначала убедиться, что старый
рабочий каталог был зафиксирован перед перемещением, или вы
уверены, что не потеряете своих изменений.  Если вы действительно
хотите использовать уже существующий рабочий каталог, то это
возможно с помощью хирургического вмешательства в файлы
<TT>`CVS/Repository'</TT>.  See section <A HREF="cvs-ru.html#SEC19">Как данные хранятся в рабочем каталоге</A>, где приводится дополнительная информация о файлах
<TT>`CVS/Repository'</TT> и <TT>`CVS/Root'</TT>, но если вы не уверены,
то, наверное, лучше не пытаться.




<H2><A NAME="SEC26" HREF="cvs-ru.html#TOC26">Сетевые репозитории</A></H2>
<P>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<A NAME="IDX171"></A>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>


<P>
Рабочая копия исходных текстов и репозиторий могут быть на разных
машинах.  Использование CVS таким образом известно как режим
<EM>клиент/сервер</EM>.  Вы выполняете CVS-<EM>клиент</EM> на
машине, на которой смонтирован ваш рабочий каталог, и говорите
ему общаться с машиной, на которой смонтирован репозиторий, с
CVS-<EM>сервером</EM>.  Вообще использование сетевого
репозитория похоже на использование локального, только формат
имени репозитория таков:



<PRE>
:<VAR>метод</VAR>:<VAR>пользователь</VAR>@<VAR>машина:/путь/к/репозиторию</VAR>
</PRE>

<P>
Детали зависят от того, как вы соединяетесь с сервером.


<P>
Если <VAR>метод</VAR> не указан, а имя репозитория содержит <SAMP>`:'</SAMP>,
то метод по умолчанию -- <CODE>ext</CODE> или <CODE>server</CODE>, в
зависимости от платформы; оба метода описаны в section <A HREF="cvs-ru.html#SEC28">Соединение с помощью <CODE>rsh</CODE></A>.




<H3><A NAME="SEC27" HREF="cvs-ru.html#TOC27">Требования к серверу</A></H3>

<P>
Простой ответ: требования к серверу умеренны -- если дерево
каталогов не очень большое, и активность не слишком высока, то
подойдет машина с 32Mb памяти или даже меньше.


<P>
В реальной жизни, конечно, все сложнее.  Оценка пикового
использования памяти достаточна, чтобы оценить общие требования.
Здесь документированы две такие области максимального потребления
памяти; все остальные по сравнению с ними незначительны (если вы
обнаружите, что это не так, дайте нам знать, как описано в
section <A HREF="cvs-ru.html#SEC182">Что делать с ошибками в CVS и этом руководстве?</A>, чтобы мы обновили документацию.


<P>
Первая область большого потребления памяти -- извлечения больших
рабочих каталогов.  Сервер состоит из двух процессов на каждого
обслуживаемого клиента.  Потребление памяти дочерним процессом
должно быть невелико.  Родительский процесс же, особенно когда
сетевые соединения медленны, может вырасти до размеров, чуть
больших размера исходных тестов, или до двух мегабайт, смотря что 
больше.


<P>
Умножая размер каждого CVS-сервера на количество клиентов,
которые вы ожидаете одновременно, вы оцените требуемый размер
памяти у сервера.  По большей части память, потребляемая
родительским процессом, будет находиться в файле подкачки, а не в 
физической памяти.


<P>
Вторая область большого потребления памяти -- <CODE>diff</CODE> при
фиксировании изменений в больших файлах.  Это требуется даже для
бинарных файлов.  Можно предусмотреть использование примерно
десятикратного размера самого большого файла, который только
будет фиксироваться, хотя пятикратный размер будет вполне
адекватен.  Например, если вы хотите фиксировать файл размером в
десять мегабайт, то в машине, на которой выполняется фиксирование
(сервер или локальная машина, на которой находится репозиторий),
должно быть сто мегабайт.  Скорее всего, это будет файл подкачки, 
а не физическая память.  Так как эта память требуется на
непродолжительное время, то особенной нужды выделять память под
несколько одновременных фиксирований нет.


<P>
Потребление ресурсов для клиентской машины еще более умеренны -- 
любая машина, способная выполнять соответствующую операционную
систему, будет пригодна.


<P>
Информация о требованиях к дисковому пространству находится в
section <A HREF="cvs-ru.html#SEC23">Создание репозитория</A>.




<H3><A NAME="SEC28" HREF="cvs-ru.html#TOC28">Соединение с помощью <CODE>rsh</CODE></A></H3>

<P>
<A NAME="IDX174"></A>
CVS использует протокол <CODE>rsh</CODE> для работы с сетевым
репозиторием, поэтому на сетевой машине должен быть создан файл
<TT>`.rhosts'</TT>, позволяющий доступ данному пользователю.


<P>
Например, предположим, что вы пользователь <SAMP>`mozart'</SAMP> на
локальной машине <SAMP>`toe.example.com'</SAMP>, а сервер находится на
<SAMP>`faun.example.com'</SAMP>.  На машине <SAMP>`faun'</SAMP> поместите в файл
<TT>`.rhosts'</TT> в домашнем каталоге пользователя <SAMP>`bach'</SAMP>
следующее:



<PRE>
toe.example.com  mozart
</PRE>

<P>
Потом протестируйте, что <CODE>rsh</CODE> работает, запустив



<PRE>
rsh -l bach faun.example.org 'echo $PATH'
</PRE>

<P>
<A NAME="IDX175"></A>
<A NAME="IDX176"></A>
Затем вам следует убедиться, что <CODE>rsh</CODE> найдет сервер.
Убедитесь, что путь, напечатанный в результате выполнения этого
примера содержит каталог, содержащий исполняемый файл <TT>`cvs'</TT>, 
который является серверной версией CVS.  Вы можете
установить путь в <TT>`.bashrc'</TT>, <TT>`.cshrc'</TT>, и т. п., но не
в файлах <TT>`.login'</TT> или <TT>`.profile'</TT>.  Можно также
установить переменную среды <CODE>CVS_SERVER</CODE> на клиентской
машине, чтобы указать, какой исполняемый файл вы хотите
использовать, например, <TT>`/usr/local/bin/cvs-1.6'</TT>.


<P>
Не требуется редактировать <TT>`inetd.conf'</TT>, чтобы запустить
CVS как демона.


<P>
<A NAME="IDX177"></A>
<A NAME="IDX178"></A>
<A NAME="IDX179"></A>
<A NAME="IDX180"></A>
<A NAME="IDX181"></A>
<A NAME="IDX182"></A>
<A NAME="IDX183"></A>
Вы можете использовать в <CODE>CVSROOT</CODE> два метода доступа для
<CODE>rsh</CODE>.  <CODE>:server:</CODE> задает использование внутреннего
клиента <CODE>rsh</CODE>, который поддерживается только в некоторых
портах CVS.  <CODE>:ext:</CODE> указывает внешнюю программу
<CODE>rsh</CODE>.  По умолчанию это <CODE>rsh</CODE>, но вы можете установить
переменную среды <CODE>CVS_RSH</CODE>, чтобы выполнять другую
программу, которая может соединиться с сервером (например,
<CODE>remsh</CODE> на HP-UX 9, потому что <CODE>rsh</CODE> немного
отличается.  Эта программа должна уметь пересылать данные с
сервера и на сервер, не изменяя их; например, <CODE>rsh</CODE> из
Windows NT не подходит, потому что он транслирует CR-LF в LF.
Порт CVS для OS/2 содержит хэк, который передает <CODE>rsh</CODE>
параметр <SAMP>`-b'</SAMP>, чтобы обойти это,но так как это может
привести к проблемам с программами, не являющимися стандартным
<CODE>rsh</CODE>, это может быть изменено в будущем.  Если вы
устанавливаете <CODE>CVS_RSH</CODE> в <CODE>ssh</CODE> или какую-нибудь
другую замену <CODE>rsh</CODE>, то инструкции по настройке
<TT>`.rhosts'</TT>, скорее всего, неприменимы, поэтому обратитесь к
документации по соответствующей программе.


<P>
Продолжая наш пример, предположив, что вы хотите обратиться к
модулю <TT>`foo'</TT> в репозитории <TT>`/usr/local/cvsroot'</TT> на
машине <SAMP>`faun.example.org'</SAMP>, вы набираете:



<PRE>
cvs -d :ext:bach@faun.example.org:/usr/local/cvsroot checkout foo
</PRE>

<P>
(Можно не писать <TT>`bach@'</TT>, если имена пользователей
совпадают на локальной и сетевой машинах.)




<H3><A NAME="SEC29" HREF="cvs-ru.html#TOC29">Прямое соединение с парольной аутентификацией</A></H3>

<P>
Клиент CVS также может соединяться с сервером, используя
протокол с паролем.  Это особенно полезно, когда использование
<CODE>rsh</CODE> неосуществимо, (например, если сервер находится за
файерволлом), и Kerberos также недоступен.


<P>
Чтобы использовать этот метод, необходима некоторая настройка как 
сервера, так и клиентов.




<H4><A NAME="SEC30" HREF="cvs-ru.html#TOC30">Настройка сервера для парольной аутентификации</A></H4>

<P>
Во-первых, вы, вероятно, хотите усилить права доступа к каталогам
<TT>`$CVSROOT'</TT> и <TT>`$CVSROOT/CVSROOT'</TT>.  See section <A HREF="cvs-ru.html#SEC29">Прямое соединение с парольной аутентификацией</A>, где описаны детали.


<P>
<A NAME="IDX184"></A>
<A NAME="IDX185"></A>
<A NAME="IDX186"></A>
На стороне сервера следует редактировать файл
<TT>`/etc/inetd.conf'</TT>, чтобы <CODE>inetd</CODE> знал, что следует
выполнять команду <CODE>cvs pserver</CODE>, когда кто-либо пытается
соединиться с соответствующим портом.  По умолчанию номер порта
--- 2401; это значение можно изменить, если перед компиляцией
установить параметр <CODE>CVS_AUTH_PORT</CODE> в другое значение.


<P>
Если ваш <CODE>inetd</CODE> позволяет использование номеров портов в
<TT>`/etc/inetd.conf'</TT>, то можно использовать такую строку
(отформатировано, чтобы влезло на страницу):



<PRE>
2401  stream  tcp  nowait  root  /usr/local/bin/cvs cvs -f 
--allow-root=/usr/cvsroot pserver
</PRE>

<P>
Вы можете также использовать ключ командной строки <SAMP>`-T'</SAMP>,
чтобы указать временный каталог.


<P>
Ключ командной строки <SAMP>`--allow-root'</SAMP> задает разрешенный
каталог CVSROOT.  Клиенты, пытающиеся использовать другой
каталог, не смогут соединиться.  Если вы хотите разрешить доступ
к нескольким каталогам CVSROOT, повторите эту опцию.


<P>
Если ваш <CODE>inetd</CODE> требует текстовых имен сервисов вместо
номеров портов, поместите эту строчку в <TT>`/etc/services'</TT>:



<PRE>
cvspserver      2401/tcp
</PRE>

<P>
и напишите <CODE>cvspserver</CODE> вместо <CODE>2401</CODE> в файле
<TT>`/etc/inetd.conf'</TT>. 


<P>
После всего этого перезапустите <CODE>inetd</CODE> или заставьте его
перечитать файлы конфигурации.  В случае проблем с настройкой
смотрите section <A HREF="cvs-ru.html#SEC179">Ошибки при установке соединения с CVS-сервером</A>.


<P>
<A NAME="IDX187"></A>
<A NAME="IDX188"></A>
Так как клиент хранит и пересылает пароли практически открытым
тестом (See section <A HREF="cvs-ru.html#SEC29">Прямое соединение с парольной аутентификацией</A>, где описаны детали), то может
использоваться отдельный файл паролей для CVS, чтобы
пользователи не раскрывали своих обычных паролей при доступе к
репозиторию.  Этот файл -- <TT>`$CVSROOT/CVSROOT/passwd'</TT>
(see section <A HREF="cvs-ru.html#SEC20">Административные файлы</A>).  В этом файле
используется обычный формат строк, разделенных двоеточиями, типа
того, что используется в файле <TT>`/etc/passwd'</TT> в
Unix-системах.  В этом файле несколько полей: имя пользователя
CVS, необязательный пароль и необязательное имя системного
пользователя, на правах которого будет работать CVS после
успешной аутентификации.  Вот пример файла <TT>`passwd'</TT>, в
котором находится пять строк:



<PRE>
anonymous:
bach:ULtgRLXo7NRxs
spwang:1sOp854gDF3DY
melissa:tGX1fS8sun6rY:pubcvs
qproj:XR4EZcEs0szik:pubcvs
</PRE>

<P>
(Пароли шифруются стандартной функцией UNIX <CODE>crypt()</CODE>,
поэтому можно просто перенести пароль из обычного файла
<TT>`/etc/passwd'</TT>.


<P>
Первая строка в этом примере предоставляет доступ любому
CVS-клиенту, пытающемуся аутентифицироваться с именем
<CODE>anonymous</CODE> и любым паролем, включая пустой пароль.  (Это
обычное решение для машин, предоставляющих анонимный доступ
только для чтения; информация о предоставлении доступа только для 
чтения находится в See section <A HREF="cvs-ru.html#SEC36">Доступ к репозиторию только для чтения</A>.


<P>
Вторая и третья строки предоставляют доступ пользователям
<CODE>bach</CODE> и <CODE>spwang</CODE>, если они знают соответствующий
пароль.


<P>
<A NAME="IDX189"></A>
Четвертая строка предоставляет доступ пользователю
<CODE>melissa</CODE>, если она знает правильный пароль.  При этом сама
серверная программа CVS на самом деле выполняется на правах
системного пользователя <CODE>pubcvs</CODE>.  Таким образом, в системе
не требуется заводить пользователя <CODE>melissa</CODE>, но
<EM>обязательно</EM> должен быть пользователь <CODE>pubcvs</CODE>.


<P>
Пятая строка демонстрирует, что системные пользователи могут
использоваться совместно: любой клиент, который успешно
аутентифицируется как <CODE>qproj</CODE>, будет работать на правах
системного пользователя <CODE>pubcvs</CODE>, так же, как и
<CODE>melissa</CODE>.  Таким образом, вы можете создать единственного
общего системного пользователя для каждого проекта в вашем
репозитории, и предоставить каждому разработчику свою собственную
строку в файле <TT>`$CVSROOT/CVSROOT/passwd'</TT>.  Имя
CVS-пользователя в каждой строке будет разным, но имя
системного пользователя будет одним и тем же.  Причина, по
которой нужно иметь разные имена пользователей CVS в том,
что все действия CVS будут журналироваться под этими
именами: когда <CODE>melissa</CODE> фиксирует изменения в проекте, эта
фиксация записывается в историю проекта под именем
<CODE>melissa</CODE>, а не <CODE>pubcvs</CODE>.  Причина, по которой следует
иметь одиночного системного пользователя в том, что вы сможете
задать права доступа к соответствующим каталогам репозитория так, 
что только этот системный пользователь будет иметь права на
запись.


<P>
Если в строке присутствует поле с системным пользователем, то все 
команды CVS выполняются на правах этого пользователя;  если
системное имя не задано, то CVS просто берет имя
пользователя CVS в качестве имени системного пользователя, и 
работает на его правах.  В любом случае, если в системе нет
такого пользователя, то CVS-сервер откажется работать, даже
если клиент сказал правильный пароль.


<P>
Пароль и имя системного пользователя могут отсутствовать (при
отсутствии последнего не следует писать двоеточие, которое служит 
разделителем полей).  Например, файл
<TT>`$CVSROOT/CVSROOT/passwd'</TT> может выглядеть так:



<PRE>
anonymous::pubcvs
fish:rKa5jzULzmhOo:kfogel
sussman:1sOp854gDF3DY
</PRE>

<P>
Когда пароль пропущен или пустой, то аутентификация произойдет
успешно с любым паролем, включая пустую строку.  Однако,
двоеточие после имени пользователя CVS всегда обязательно,
даже если пароль пуст.


<P>
CVS также может использовать стандартную системную
аутентификацию.  При парольной аутентификации сервер сначала
проверяет наличие пользователя в файле
<TT>`$CVSROOT/CVSROOT/passwd'</TT>.  Если пользователь обнаружен в
этом файле, то соответствующая строка будет использована для
аутентификации, как описано выше.  Если же пользователь не
найден, или файле <TT>`passwd'</TT> не существует, то сервер пытается 
аутентифицировать пользователя с помощью системных процедур (это
"резервное" поведение может быть запрещено, установив
<CODE>SystemAuth=no</CODE> в файле <TT>`config'</TT>, see section <A HREF="cvs-ru.html#SEC174">Файл конфигурации CVSROOT/config</A>).  Помните, однако, что использование системной
аутентификации может увеличить риск нарушения безопасности:
операции CVS будут аутентифицироваться его обычным паролем,
который будет передаваться по сети в текстовом виде.
См. section <A HREF="cvs-ru.html#SEC32">Вопросы безопасности при парольной аутентификации</A>, где описаны
детали.


<P>
В настоящее время единственный способ поместить пароль в
<TT>`CVSROOT/passwd'</TT> -- это вырезать его откуда-нибудь еще.
Когда-нибудь появится команда <CODE>cvs passwd</CODE>.  


<P>
В отличие от большинства файлов в <TT>`$CVSROOT/CVSROOT'</TT>, обычно 
практикуется редактирование файла <TT>`passwd'</TT> прямо в
репозитории, без использования CVS.  Это из-за риска
безопасности, связанного с извлечением этого файла в чью-нибудь
рабочую копию.  Если вы хотите, чтобы файл <TT>`passwd'</TT>
извлекался вместе с остальными файлами в <TT>`$CVSROOT/CVSROOT'</TT>, 
см. See section <A HREF="cvs-ru.html#SEC18">Как в каталоге CVSROOT хранятся файлы</A>.




<H4><A NAME="SEC31" HREF="cvs-ru.html#TOC31">Использование клиента с парольной аутентификацией</A></H4>
<P>
<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>
<A NAME="IDX193"></A>
Для того, чтобы выполнить команду CVS в сетевом репозитории
с помощью сервера парольной аутентификации, нужно задать
протокол <CODE>pserver</CODE>, имя пользователя, машину, на которой
находится репозиторий, и путь к репозиторию.  Например:



<PRE>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot checkout someproj
</PRE>

<P>
или



<PRE>
CVSROOT=:pserver:bach@faun.example.org:/usr/local/cvsroot
cvs checkout someproj
</PRE>

<P>
Однако, если только вы не работаете с публичным репозиторием (то
есть таким, где имя определенного пользователя не требует
использования пароля), вам сначала потребуется <EM>войти в
систему</EM>.  При входе в систему проверяется ваш пароль.  Это
происходит при выполнении команды <CODE>login</CODE>, которая
спрашивает у вас пароль:



<PRE>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot login
CVS password: _
</PRE>

<P>
После того, как вы ввели пароль, CVS проверяет этот пароль
на сервере.  Если результат положителен, то комбинация имени
пользователя, машины, пути к репозиторию и пароля сохраняются в
специальном файле, чтобы при дальнейшей работе с этим
репозиторием от вас не требовалось запускать <CODE>cvs login</CODE>.
(Если результат проверки отрицателен, CVS пожалуется, что
пароль неверен, и, естественно, он не будет сохранен.)


<P>
Пароли обычно хранятся в файле <TT>`$HOME/.cvspass'</TT>.  Этот файл
можно прочитать глазами, и, до какой-то степени, можно
отредактировать руками.  Заметьте, впрочем, что пароли не
хранятся в совсем открытом виде: они тривиально закодированы,
чтобы защититься от нечаянного подсматривания (например,
системным администратором или кем-либо другим, не настроенным
враждебно).


<P>
<A NAME="IDX194"></A>
<A NAME="IDX195"></A>
Изменить место расположения этого файла можно, установив
переменную окружения <CODE>CVS_PASSFILE</CODE>.  При использовании этой 
переменной не забудьте установить её <EM>перед</EM> использованием
<CODE>cvs login</CODE>.  Если вы этого не сделаете, то последующие
команды CVS не смогут найти паролей для отправки на сервер.


<P>
После того, как вы вошли в систему, все команды CVS,
использующие этот сетевой репозиторий и имя пользователя, смогут
аутентифицироваться, используя этот сохраненный пароль.  Поэтому,
например:



<PRE>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot checkout foo
</PRE>

<P>
будет работать без дополнительных вопросов (если только пароль не 
изменится на сервере, в этому случае вам нужно ещё раз выполнить
<CODE>cvs login</CODE>).


<P>
Заметьте, что если забыть про <SAMP>`:pserver:'</SAMP> в имени
репозитория, то CVS будет считать, что вы собираетесь
использовать <CODE>rsh</CODE> (see section <A HREF="cvs-ru.html#SEC28">Соединение с помощью <CODE>rsh</CODE></A>).


<P>
Конечно же, после того, как вы извлекли рабочую копию, то можно
не задавать имя репозитория при работе с ней, потому что CVS 
может и сама взять это имя из каталога <TT>`CVS/'</TT>.


<P>
<A NAME="IDX196"></A>
Пароль к определенному сетевому репозиторию можно удалить из
файла паролей с помощью команды <CODE>cvs logout</CODE>.




<H4><A NAME="SEC32" HREF="cvs-ru.html#TOC32">Вопросы безопасности при парольной аутентификации</A></H4>

<P>
<A NAME="IDX197"></A>
Пароли хранятся на стороне клиента тривиально зашифрованным
открытым текстом и передаются точно так же.  Такое шифрование
используется только для предотвращения нечаянного подсматривания
пароля (например, системный администратор, случайно заглянувший в 
файл) и не предотвращает даже самые тривиальные атаки.


<P>
Отдельный файл паролей CVS (see section <A HREF="cvs-ru.html#SEC30">Настройка сервера для парольной аутентификации</A>) позволяет использовать для доступа к репозиторию
пароль, отличающийся от пароля для доступа к машине.  С другой
стороны, если пользователь получил доступ к репозиторию для
чтения и записи, он может различными способами выполнять
программы на сервере.  Таким образом, доступ к репозиторию
означает также довольно широкий диапазон другого доступа к
системе.  Можно было бы модифицировать CVS, чтобы
предотвратить это, но до сих пор никто этого не сделал.
Более того, могут быть другие способы, которыми люди, имеющие
доступ к репозиторию, получат доступ к системе; никто не
производил тщательного аудита.


<P>
Заметьте, что из-за того, что каталог <TT>`$CVSROOT/CVSROOT'</TT>
содержит <TT>`passwd'</TT> и прочие файлы, использующиеся в целях
безопасности, нужно следить за правами доступа к этому каталогу
так же хорошо, как из правами доступа к <TT>`/etc'</TT>.  То же самое
применимо к самому каталогу <TT>`$CVSROOT'</TT> и любому каталогу,
находящему в нем.  Кто угодно, получив доступ для записи в этот
каталог, сможет стать любым пользователем в системе.  Заметьте,
что эти права доступа обычно строже при использовании pserver.


<P>
Вообще, любой, кто получает пароль, получает доступ к
репозиторию, и, до некоторой степени, доступ к самой системе.
Пароль доступен всем, кто может перехватить сетевые пакеты или
прочитать защищенный (принадлежащий пользователю) файл.  Если вы
хотите настоящей безопасности, используйте Kerberos.




<H3><A NAME="SEC33" HREF="cvs-ru.html#TOC33">Прямое соединение с использованием GSSAPI</A></H3>

<P>
<A NAME="IDX198"></A>
<A NAME="IDX199"></A>
<A NAME="IDX200"></A>
<A NAME="IDX201"></A>
GSSAPI -- это общий интерфейс к системам сетевой безопасности,
таким как Kerberos 5.


<P>
Если у вас есть рабочая библиотека GSSAPI, то ваш CVS может
совершать TCP-соединения с сервером, аутентифицируясь с
помощью GSSAPI.  Для этого CVS нужно скомпилировать с
поддержкой GSSAPI; при конфигурировании CVS пытается
определить, наличествуют ли в системе библиотеки GSSAPI,
использующие Kerberos версии 5.  Вы также можете дать
<CODE>configure</CODE> флаг <CODE>--with-gssapi</CODE>.


<P>
Соединение аутентифицируется, используя GSSAPI, но сам поток
данных <EM>не</EM> аутентифицируется по умолчанию.  Вы должны
использовать глобальный ключ командной строки <CODE>-a</CODE>, чтобы
запросить аутентификацию потока.


<P>
Передаваемые данные по умолчанию <EM>не</EM> шифруются.  Как сервер, 
так и клиент могут быть скомпилированы с поддержкой шифрования;
используйте ключ командной строки <CODE>configure</CODE>
<CODE>--enable-encrypt</CODE>.  Для включения шифрования используйте
ключ командной строки <CODE>-x</CODE>.


<P>
Соединения GSSAPI обрабатываются на стороне сервера тем же
сервером, что производит парольную аутентификацию;  смотри
section <A HREF="cvs-ru.html#SEC30">Настройка сервера для парольной аутентификации</A>.  Если вы используете,
например, Kerberos, обеспечивающий хорошую аутентификацию, вы,
вероятно, захотите также устранить возможность аутентифицироваться 
с использованием паролей открытым текстом.  Для этого создайте
пустой файл <TT>`CVSROOT/passwd'</TT> и поместите
<CODE>SystemAuth=no</CODE> в файл конфигурации <TT>`config'</TT>.


<P>
Сервер GSSAPI использует principal name cvs/<VAR>имя-машины</VAR>, где 
<VAR>имя-машины</VAR> -- это каноническое имя сервера.  Вам
потребуется настроить ваш механизм GSSAPI.


<P>
Для соединения с использованием GSSAPI, используйте
<SAMP>`:gserver:'</SAMP>.  Например,



<PRE>
cvs -d :gserver:faun.example.org:/usr/local/cvsroot checkout foo
</PRE>



<H3><A NAME="SEC34" HREF="cvs-ru.html#TOC34">Прямое соединение с помощью Kerberos</A></H3>

<P>
<A NAME="IDX202"></A>
<A NAME="IDX203"></A>
<A NAME="IDX204"></A>
Самый простой способ использования Kerberos -- это kerberos
<CODE>rsh</CODE>, что описано в section <A HREF="cvs-ru.html#SEC28">Соединение с помощью <CODE>rsh</CODE></A>.
Основной недостаток использования rsh -- тот, что все данные
должны проходить сквозь дополнительные программы, что замедляет
работу.  Поэтому если у вас установлен Kerberos, вам следует
использовать прямые TCP-соединения, аутентифицируясь с
помощью Kerberos.


<P>
Эта глава относится к системе Kerberos версии 4. Kerberos версии
5 поддерживается посредством общего интерфейса сетевой
безопасности GSSAPI, как описано в предыдущей главе.


<P>
CVS должен быть скомпилирован с поддержкой kerberos; при
конфигурировании CVS пытается определить, какая версия
Kerberos присутствует на машине.  Вы можете также использовать
ключ командной строки <CODE>configure</CODE> <CODE>--with-krb4</CODE>.


<P>
Пересылаемые данные по умолчанию <EM>не</EM> шифруются.  Как
клиент, так и сервер должны быть скомпилированы с использованием
шифрования; используйте ключ командной строки <CODE>configure</CODE>
<CODE>--enable-encryption</CODE>.  Для включения шифрования используйте
глобальный ключ командной строки <CODE>-x</CODE>.


<P>
<A NAME="IDX205"></A>
На сервере требуется отредактировать <CODE>/etc/inetd.conf</CODE>,
чтобы запустить <CODE>cvs kserver</CODE>.  Клиент по умолчанию
использует порт 1999; если вы хотите использовать другой порт,
задайте его на клиентской машине в переменной окружения
<CODE>CVS_CLIENT_PORT</CODE>.


<P>
<A NAME="IDX206"></A>
Когда вы захотите использовать CVS, сначала, как обычно,
получите билет (<CODE>kinit</CODE>); этот билет должен позволять вам
зарегистрироваться на сервере.  Затем



<PRE>
cvs -d :kserver:faun.example.org:/usr/local/cvsroot checkout foo
</PRE>

<P>
Предыдущие версии CVS могли в случае неудачи использовать
соединение с помощью <CODE>rsh</CODE>; текущие версии так не делают.




<H3><A NAME="SEC35" HREF="cvs-ru.html#TOC35">Использование параллельного <CODE>cvs server</CODE> для соединения</A></H3>

<P>
<A NAME="IDX207"></A>
<A NAME="IDX208"></A>
Этот метод доступа позволяет вам соединяться с репозиторием,
находящимся на локальном диске, используя сетевой протокол.
Другими словами, он делает то же самое, что и <CODE>:local:</CODE>, но
при этом с особенностями и ошибками, существующими у сетевого, а
нее локального CVS.


<P>
Для каждодневных операций вы, скорее всего, предпочтете
<CODE>:local:</CODE> или <CODE>:fork:</CODE>, в зависимости от ваших
предпочтений.  Конечно, <CODE>:fork:</CODE> особенно полезен при
тестировании и отладке <CODE>cvs</CODE> и сетевого протокола.  Точнее,
мы избавляемся от необходимости настройки сети, таймаутов,
проблем с аутентификацией, свойственных сетевому доступа, но при
этом пользуемся собственно сетевым протоколом.


<P>
Чтобы соединиться, используя метод доступа <CODE>:fork:</CODE>,
добавьте его к имени локального репозитория, например:



<PRE>
cvs -d :fork:/usr/local/cvsroot checkout foo
</PRE>

<P>
<A NAME="IDX209"></A>
Как и при использовании <CODE>:ext:</CODE>, сервер по умолчанию
называется <SAMP>`cvs'</SAMP>.  Если установлена переменная окружения
<CODE>CVS_SERVER</CODE>, используется ее значение.




<H2><A NAME="SEC36" HREF="cvs-ru.html#TOC36">Доступ к репозиторию только для чтения</A></H2>
<P>
<A NAME="IDX210"></A>
<A NAME="IDX211"></A>
<A NAME="IDX212"></A>
<A NAME="IDX213"></A>


<P>
Существует возможность предоставить публичный доступ к
репозиторию только для чтения, используя сервер парольной
аутентификации (see section <A HREF="cvs-ru.html#SEC29">Прямое соединение с парольной аутентификацией</A>).  (Прочие
методы доступа не имеют явной поддержки для доступа только для
чтения, потому что все эти методы подразумевают регистрацию на
машине с репозиторием, и поэтому пользователь может делать все,
что позволяют ему права доступа к файлам.)


<P>
Пользователь, имеющий доступ к репозиторию только для чтения,
может выполнять все команды CVS, не изменяющие репозиторий,
за исключением определенных "административных" файлов (таких,
как файлы блокировок и файл истории).  Может потребоваться
использовать эту возможность совместно с возможностью
использования псевдонимов пользователей (see section <A HREF="cvs-ru.html#SEC30">Настройка сервера для парольной аутентификации</A>).


<P>
В отличие от предыдущих версий CVS, пользователи с доступом
только для чтения должны быть способны только читать репозиторий,
но не выполнять программы на сервере или другим способом получать
ненужные уровни доступа.  Говоря точнее, закрыты все <EM>ранее
известные</EM> дыры в безопасности.  Так как эта возможность
появилась недавно и не подвергалась исчерпывающему анализу
безопасности, вы должны действовать с максимально необходимой
осторожностью. 


<P>
Есть два способа указать доступ пользователя только для чтения:
включающий и исключающий.


<P>
<EM>Включающий</EM> способ означает, что пользователь явно
указывается в файле <TT>`$CVSROOT/CVSROOT/readers'</TT>, в котором
просто перечисляются "в столбик" пользователи.  Вот пример:



<PRE>
melissa
splotnik
jrandom
</PRE>

<P>
(Не забудьте символ новой строки в конце файла.)


<P>
<EM>Исключающий</EM> способ означает, что все, кто имеет доступ к
репозиторию <EM>для записи</EM>, перечисляются в файле
<TT>`$CVSROOT/CVSROOT/writers'</TT>.  Если этот файл существует, то
все пользователи, не упомянутые в нем, получают доступ только для
чтения (конечно, даже пользователи только для чтения должны быть
упомянуты в файле <TT>`CVSROOT/passwd'</TT>).  Файл <TT>`writers'</TT>
имеет тот же формат, что и файл <TT>`readers'</TT>.


<P>
Замечание: если ваш файл <TT>`CVSROOT/passwd'</TT> отображает
пользователей CVS в системных пользователей (see section <A HREF="cvs-ru.html#SEC30">Настройка сервера для парольной аутентификации</A>), убедитесь, что вы предоставляете или
не предоставляете доступ только для чтения пользователям
CVS, а не системным пользователям.  Это означает, что в
файлах <TT>`readers'</TT> и <TT>`writers'</TT> должны находиться
пользователи CVS, которые могут не совпадать с системными
пользователями.


<P>
Вот полное описание поведения сервера, принимающему решение,
какой тип доступа предоставить:


<P>
Если файл <TT>`readers'</TT> существует, и данный пользователь не
упомянут в нем, он получает доступ только для чтения.  Если
существует файл <TT>`writers'</TT>, и этот пользователь НЕ упомянут в
нем, то он также получает доступ только для чтения (это так даже
если файл <TT>`readers'</TT> существует, но пользователь не упомянут
в нем).  В противном случае пользователь получает полный доступ
для чтения и записи.


<P>
Конечно, возможен конфликт, если пользователь упомянут в обоих
файлах.  Такой конфликт разрешается консервативно и такой
пользователь получает доступ только для чтения.




<H2><A NAME="SEC37" HREF="cvs-ru.html#TOC37">Временные каталоги на сервере</A></H2>
<P>
<A NAME="IDX214"></A>
<A NAME="IDX215"></A>


<P>
В процессе работы CVS-сервер создает временные каталоги.
Они называются



<PRE>
cvs-serv<VAR>pid</VAR>
</PRE>

<P>
где <VAR>pid</VAR> -- это номер процесса сервера.  Они находятся в
каталоге, указанном в переменной окружения <CODE>TMPDIR</CODE>
(see section <A HREF="cvs-ru.html#SEC175">Все переменные окружения, используемые в CVS</A>), ключом командной строки <SAMP>`-T'</SAMP> 
или в <TT>`/tmp'</TT> по умолчанию.


<P>
В большинстве случаев сервер сам удалит временный каталог в конце 
работы.  В некоторых случаях сервер может завершиться, не удалив
свой временный каталог, например:



<UL>
<LI>

если сервер аварийно завершается из-за внутренней ошибки, он
может оставить временный каталог, чтобы облегчить отладку;

<LI>

если сервер был убит так, что не смог убрать за собой (например,
<SAMP>`kill -KILL'</SAMP> под UNIX);

<LI>

система прекращает свою работу, не сообщив предварительно серверу
об этом факте.
</UL>

<P>
В таких случаях вы должны вручную удалить каталоги
<TT>`cvs-serv<VAR>pid</VAR>'</TT>.  Если нет сервера с номером процесса
<VAR>pid</VAR>, то сделать это можно совершенно безопасно.




<H1><A NAME="SEC38" HREF="cvs-ru.html#TOC38">Начинаем проект под CVS</A></H1>
<P>
<A NAME="IDX216"></A>
<A NAME="IDX217"></A>
<A NAME="IDX218"></A>
<A NAME="IDX219"></A>


<P>
Так как переименование файлов и перемещение их между каталогами
слегка неудобно, первое, что вам следует сделать, когда вы
начинаете новый проект -- продумать организацию файлов.
Собственно, перемещать и переименовывать файлы можно, но это,
во-первых, увеличивает возможность недопонимания, а во-вторых, у
CVS есть некоторые неполадки, например, при переименовании
каталогов.  See section <A HREF="cvs-ru.html#SEC69">Перемещение и переименование файлов</A>.


<P>
Дальнейшие действия зависят от конкретной ситуации.




<H2><A NAME="SEC39" HREF="cvs-ru.html#TOC39">Помещение файлов в репозиторий</A></H2>

<P>
Первым шагом будет создание файлов в репозитории.  Это может быть 
сделано несколькими различными способами.




<H3><A NAME="SEC40" HREF="cvs-ru.html#TOC40">Создание дерева каталогов из нескольких файлов</A></H3>
<P>
<A NAME="IDX220"></A>


<P>
Когда вы начнете использовать CVS, вы, скорее всего, уже
имеете несколько проектов, которые можно поместить под контроль
CVS.  В этих случаях самым простым методом будет
использование команды <CODE>import</CODE>.  Самым простым объяснением,
вероятно, будет привести пример.  Если файлы, которые вы хотите
поместить под CVS, находятся в <TT>`<VAR>wdir</VAR>'</TT>, а вы
хотите, чтобы они появились в репозитории в каталоге
<TT>`$CVSROOT/yoyodyne/<VAR>rdir</VAR>'</TT>, вы можете сказать:



<PRE>
$ cd <VAR>wdir</VAR>
$ cvs import -m "Imported sources" yoyodyne/<VAR>rdir</VAR> yoyo start
</PRE>

<P>
Если вы не укажете журнальное сообщение с помощью ключа командной
строки <SAMP>`-m'</SAMP>, то CVS запустит редактор, в котором можно
будет набрать это сообщение.  Строка <SAMP>`yoyo'</SAMP> -- это <EM>тэг
производителя</EM>, а <SAMP>`start'</SAMP> -- это <EM>тэг релиза</EM>.  В
данном контексте они могут не иметь назначения, но CVS
требует их присутствия.  See section <A HREF="cvs-ru.html#SEC103">Слежение за чужими исходными текстами</A>,
за дальнейшей информацией.


<P>
Теперь вы можете проверить, что все работает и удалить ваш
исходный каталог.



<PRE>
$ cd ..
$ mv <VAR>dir</VAR> <VAR>dir</VAR>.orig
$ cvs checkout yoyodyne/<VAR>dir</VAR>       # объяснение следует
$ diff -r <VAR>dir</VAR>.orig yoyodyne/<VAR>dir</VAR>
$ rm -r <VAR>dir</VAR>.orig
</PRE>

<P>
Было бы неплохо удалить изначальные файлы, чтобы случайно не
начать редактировать их в <VAR>dir</VAR> без использования CVS.
Конечно же, перед удалением хорошо было бы убедиться, что у вас
есть резервная копия исходных текстов.


<P>
Команда <CODE>checkout</CODE> получает в качестве аргумента имя модуля
(как в предыдущих примерах) или имя каталога относительно
<CODE>$CVSROOT</CODE>, как в вышеприведенном примере.


<P>
Хорошо было бы проверить, что права доступа на созданные CVS 
каталоги правильны, и что эти каталоги принадлежат должным
группам.  See section <A HREF="cvs-ru.html#SEC13">Права доступа к файлам</A>.


<P>
Если какие-то из файлов, которые нужно импортировать, являются
бинарными, вам потребуется использовать <EM>обертки</EM>, чтобы
указать, какие именно.  See section <A HREF="cvs-ru.html#SEC160">Файл <TT>`cvswrappers'</TT></A>.




<H3><A NAME="SEC41" HREF="cvs-ru.html#TOC41">Создание файлов из других систем контроля версий</A></H3>
<P>
<A NAME="IDX221"></A>


<P>
Если у вас есть проект, который обслуживается другой системой
контроля версий, например, RCS, вы можете захотеть поместить 
эти файлы под управление CVS и сохранить историю изменения
этих файлов.


<DL COMPACT>

<DT>Из RCS
<DD>
<A NAME="IDX222"></A>
 <A NAME="IDX223"></A>
 
Если вы использовали RCS, найдите все RCS-файлы, обычно
файлу <TT>`foo.c'</TT> будет соответствовать файл <TT>`RCS/foo.c,v'</TT>
(этот файл может также находиться в другом месте, обратитесь к
документации на RCS.  Затем создайте соответствующие
каталоги в CVS, если они еще не существуют.  Затем
скопируйте файл в соответствующие каталоги в репозитории (имя в
репозитории должно совпадать с именем исходного файла с
добавленным <SAMP>`,v'</SAMP>; файлы находятся прямо в соответствующем
каталоге репозитория, а не в подкаталоге <TT>`RCS/'</TT>.  Это ---
один из редких случаев, когда желателен прямой доступ к
репозиторию, без использования команд CVS.  Теперь вы можете
извлечь новый рабочий каталог.

RCS-файл не должен быть заблокирован, когда вы перемещаете
его под управление CVS, иначе у CVS будут проблемы при
работе с этим файлом.

<DT>Из другой системы контроля версий
<DD>
Многие системы контроля версий способны экспортировать
RCS-файлы в стандартном формате.  Если ваша система умеет
так делать, экспортируйте RCS-файлы и следуйте
вышеприведенным инструкциям.

Если это не так, вероятно, лучшим выходом будет написать скрипт,
который извлекает каждую ревизию файла, используя интерфейс
командной строки старой системы, а затем фиксирующий эти ревизии
в CVS.  Скрипт <TT>`sccs2rcs'</TT>, упомянутый ниже, является
хорошим примером.

<A NAME="IDX224"></A>
<A NAME="IDX225"></A>
<DT>Из SCCS
<DD>
В каталоге <TT>`contrib/'</TT> среди исходных текстов CVS есть
скрипт <TT>`sccs2rcs'</TT>, конвертирующий файлы SCCS в файлы
RCS.  Замечание: вы должны выполнить этот скрипт на машине,
на которой установлен как SCCS, так и RCS, и этот
скрипт не поддерживается.

<A NAME="IDX226"></A>
<A NAME="IDX227"></A>
<DT>Из PVCS
<DD>
В каталоге <TT>`contrib/'</TT> среди исходных текстов CVS есть
скрипт <TT>`pvcs_to_rcs'</TT>, конвертирующий архивы PVCS в
файлы RCS.  Вы должны выполнить этот скрипт на машине, на
которой установлены как PVCS, так и RCS, и как и все
прочее в каталоге <TT>`contrib/'</TT>, этот скрипт не
поддерживается.  Детали описаны в комментариях к скрипту.
</DL>



<H3><A NAME="SEC42" HREF="cvs-ru.html#TOC42">Создание дерева каталогов с нуля</A></H3>

<P>
Для нового проекта самым простым способом, вероятно, будет
создать пустую структуру каталогов, например:



<PRE>
$ mkdir tc
$ mkdir tc/man
$ mkdir tc/testing
</PRE>

<P>
Затем используйте команду <CODE>import</CODE>, чтобы создать
соответствующую (пустую) структуру каталогов внутри репозитория:



<PRE>
$ cd tc
$ cvs import -m "Created directory structure" yoyodyne/<VAR>dir</VAR> yoyo start
</PRE>

<P>
Затем используйте команду <CODE>add</CODE>, чтобы добавлять файлы и
новые каталог по мере их появления.


<P>
Убедитесь, что права доступа, которые CVS дает новым
каталогам в <SAMP>`$CVSROOT'</SAMP>, правильны.




<H2><A NAME="SEC43" HREF="cvs-ru.html#TOC43">Определение модуля</A></H2>
<P>
<A NAME="IDX228"></A>
<A NAME="IDX229"></A>
<A NAME="IDX230"></A>
<A NAME="IDX231"></A>
<A NAME="IDX232"></A>


<P>
Следующим шагом будет определение модуля в файле <TT>`modules'</TT>.
Это необязательно, но модули удобны для группирования связанных
файлов и каталогов.


<P>
В простых случаях нижеследующих шагов достаточно для определения
модуля. 



<OL>
<LI>

извлеките рабочую копию файла <TT>`modules'</TT>:


<PRE>
$ cvs checkout CVSROOT/modules
$ cd CVSROOT
</PRE>

<LI>

отредактируйте этот файл, вставив в него строку, определяющую
модуль.  См. See section <A HREF="cvs-ru.html#SEC20">Административные файлы</A>.  Полное
описание файла <TT>`modules'</TT> можно найти в See section <A HREF="cvs-ru.html#SEC154">Файл <TT>`modules'</TT></A>.
Например, для описания модуля <SAMP>`tc'</SAMP> можно использовать такую
строку:


<PRE>
tc   yoyodyne/tc
</PRE>

<LI>

зафиксируйте ваши изменения в файле <TT>`modules'</TT>


<PRE>
$ cvs commit -m "Added the tc module." modules
</PRE>

<LI>

Освободите модуль <CODE>CVSROOT</CODE>.


<PRE>
$ cd ..
$ cvs release -d CVSROOT
</PRE>

</OL>



<H1><A NAME="SEC44" HREF="cvs-ru.html#TOC44">Ревизии</A></H1>

<P>
В большинстве случаев использования CVS не требуется сильно
беспокоиться о номерах ревизий; CVS присваивает номера типа
<CODE>1.1</CODE>, <CODE>1.2</CODE> и т. д., и этого достаточно.  Некоторые,
однако, хотели бы иметь больше информации и лучше контролировать то, 
как CVS присваивает номера ревизий.


<P>
Если необходимо отслеживать набор ревизий, содержащих более
одного файла, например, ревизии, попавшие в конкретную версию
программы, используются <EM>метки</EM>, т. е. буквенные имена
ревизий, которые можно присвоить каждому номеру ревизии файла.




<H2><A NAME="SEC45" HREF="cvs-ru.html#TOC45">Номера ревизий</A></H2>
<P>
<A NAME="IDX233"></A>
<A NAME="IDX234"></A>
<A NAME="IDX235"></A>
<A NAME="IDX236"></A>
<A NAME="IDX237"></A>
<A NAME="IDX238"></A>
<A NAME="IDX239"></A>
<A NAME="IDX240"></A>
<A NAME="IDX241"></A>
<A NAME="IDX242"></A>


<P>
Каждая ревизия файла имеет уникальный <EM>номер ревизии</EM>.
Номера ревизий выглядят как <SAMP>`1.1'</SAMP>, <SAMP>`1.2'</SAMP>,
<SAMP>`1.3.2.2'</SAMP> или даже <SAMP>`1.3.2.2.4.5'</SAMP>.  Номер ревизии всегда
содержит четное количество десятичных чисел, разделенных точкой.
По умолчанию ревизия 1.1 -- первая ревизия файла.  В номере
каждой следующей ревизии самая правая цифра увеличивается на
единицу.  Вот пример нескольких ревизий, новые версии находятся
правее старых:



<PRE>
       +-----+    +-----+    +-----+    +-----+    +-----+
       ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
       +-----+    +-----+    +-----+    +-----+    +-----+
</PRE>

<P>
Может также оказаться, что в номерах ревизий будет больше одной
точки, например, <SAMP>`1.3.2.2'</SAMP>.  Такие номера означают ревизии,
находящиеся на ветках (see section <A HREF="cvs-ru.html#SEC54">Создание ветвей и слияние</A>); эти
номера подробно описаны в section <A HREF="cvs-ru.html#SEC58">Ветки и ревизии</A>.




<H2><A NAME="SEC46" HREF="cvs-ru.html#TOC46">Версии и ревизии</A></H2>
<P>
<A NAME="IDX243"></A>
<A NAME="IDX244"></A>


<P>
Как описано выше, у файла может быть несколько ревизий.  У
программного продукта может быть несколько версий.  Программным
продуктам обычно дают номера версий типа <SAMP>`4.1.1'</SAMP>.




<H2><A NAME="SEC47" HREF="cvs-ru.html#TOC47">Назначение номеров ревизий</A></H2>

<P>
По умолчанию, CVS назначает номер ревизии, оставляя первую
цифру и увеличивая вторую.  Например, <CODE>1.1</CODE>, <CODE>1.2</CODE>,
<CODE>1.3</CODE>. 


<P>
При добавлении нового файла вторая цифра всегда будет единицей, а
первая цифра будет равняться самой большой первой цифре номера
ревизии каждого файла в каталоге.  Например, если в каталоге
находятся файлы с ревизиями <CODE>1.7</CODE>, <CODE>3.1</CODE>, <CODE>4.12</CODE>,
то добавленный файл получит номер ревизии <CODE>4.1</CODE>.


<P>
Обычно совершенно не требуется заботиться о номерах ревизий ---
проще думать о них, как о служебных номерах, за которыми следит
CVS, а также о метках, обеспечивающих хороший способ
различать, например, версию 1 вашего продукта от версии 2
(see section <A HREF="cvs-ru.html#SEC48">Метки ревизий</A>).  Однако, если вы хотите установить номер
ревизии, вам поможет ключ командной строки <SAMP>`-r'</SAMP> команды
<CODE>cvs commit</CODE>.  Ключ <SAMP>`-r'</SAMP> подразумевает использование
ключа <SAMP>`-f'</SAMP>, в том смысле, что он приводит к фиксированию
файлов, даже если он не были изменены.


<P>
Например, для того, что задать всем вашим файлам, включая те, что
не изменились, номер ревизии 3.0, выполните команду



<PRE>
$ cvs commit -r 3.0
</PRE>

<P>
Заметьте, что номер, который вы указываете вместе с ключом
<SAMP>`-r'</SAMP>, должен быть больше любого существующего номера
ревизии.  Скажем, если существует ревизия 3.0, вы не можете
сказать <SAMP>`cvs commit -r 1.3'</SAMP>.  Если вы хотите параллельно
отслеживать несколько версий программного продукта, вам нужно
создать ветку (see section <A HREF="cvs-ru.html#SEC54">Создание ветвей и слияние</A>).




<H2><A NAME="SEC48" HREF="cvs-ru.html#TOC48">Метки ревизий</A></H2>
<P>
<A NAME="IDX245"></A>


<P>
Номера ревизий живут своей собственной жизнью.  Они могут
совершенно никак не соотноситься с номером версии вашего
программного продукта.  В зависимости от того, как вы
используете CVS, номера ревизий могут измениться несколько
раз между двумя выпусками продукта.  Например, файлы с исходными
текстами RCS 5.6 имеют такие номера ревизий:



<PRE>
ci.c            5.21
co.c            5.9
ident.c         5.3
rcs.c           5.12
rcsbase.h       5.11
rcsdiff.c       5.10
rcsedit.c       5.11
rcsfcmp.c       5.9
rcsgen.c        5.10
rcslex.c        5.11
rcsmap.c        5.2
rcsutil.c       5.10
</PRE>

<P>
<A NAME="IDX246"></A>
<A NAME="IDX247"></A>
<A NAME="IDX248"></A>
<A NAME="IDX249"></A>
<A NAME="IDX250"></A>
<A NAME="IDX251"></A>
Вы можете использовать команду <CODE>tag</CODE>, чтобы задать буквенное 
имя определенной ревизии файла.  Вы можете использовать ключ
командной строки <SAMP>`-v'</SAMP> команды <CODE>status</CODE>, чтобы увидеть
все метки, которые имеет файл, а также какие номера ревизий они
представляют.  Имена меток должны начинаться с буквы и могут
содержать буквы, цифры и знаки <SAMP>`-'</SAMP> и <SAMP>`_'</SAMP>.  Два имени
меток <CODE>BASE</CODE> и <CODE>HEAD</CODE> зарезервированы для использования
в CVS.  Предполагается, что будущие зарезервированные имена
будут иметь специальный вид, например, начинаться с символа
<SAMP>`.'</SAMP>, чтобы избежать конфликтов с действительными именами
меток. 


<P>
Вы захотите выбрать какое-либо соглашение об именах меток,
основываясь, например, на имени программы и номере ее версии.
Например, можно взять имя программы, за которым следует номер
версии, в котором символ <SAMP>`.'</SAMP> заменен на <SAMP>`-'</SAMP>, так что
CVS 1.9 будет помечен как <CODE>cvs1-9</CODE>.  Если вы выберете
стабильные правила именования, вам не придется постоянно
угадывать, называется ли метка <CODE>cvs-1-9</CODE>, <CODE>cvs1_9</CODE> или
как-то еще.  Вы можете даже принудительно задать эти правила
именования в файле <TT>`taginfo'</TT> (see section <A HREF="cvs-ru.html#SEC77">Настройка журналирования</A>).


<P>
<A NAME="IDX252"></A>
<A NAME="IDX253"></A>
В нижеследующем примере показано, как добавить метку к файлу.
Команды должны выполняться внутри вашего рабочего каталога, то
есть там, где находится файл <TT>`backend.c'</TT>.



<PRE>
$ cvs tag rel-0-4 backend.c
T backend.c
$ cvs status -v backend.c
===================================================================
File: backend.c         Status: Up-to-date

    Version:            1.4     Tue Dec  1 14:39:01 1992
    RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
    Sticky Tag:         (none)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-0-4                     (revision: 1.4)

</PRE>

<P>
Полный синтаксис команды <CODE>cvs tag</CODE>, включая разнообразные
ключи командной строки, описан в section <A HREF="cvs-ru.html#SEC152">Краткий справочник по командам CVS</A>.


<P>
Редко требуется помечать одиночные файлы.  Гораздо чаще нужно
пометить все файлы, составляющие модуль, в стратегической точке
цикла разработки, например, когда выпущена новая версия.



<PRE>
$ cvs tag rel-1-0 .
cvs tag: Tagging .
T Makefile
T backend.c
T driver.c
T frontend.c
T parser.c
</PRE>

<P>
(Если вы дадите CVS каталог в качестве параметра командной
строки, она обычно оперирует над всеми файлами в этом каталоге и, 
рекурсивно, ко всем подкаталогам, которые тот содержит.
See section <A HREF="cvs-ru.html#SEC64">Рекурсивное поведение</A>.)


<P>
<A NAME="IDX254"></A>
<A NAME="IDX255"></A>
Команда <CODE>checkout</CODE> имеет ключ командной строки <SAMP>`-r'</SAMP>,
позволяющий извлечь определенную ревизию модуля.  Этот флаг
упрощает извлечение исходного текста, из которого сделана версия
1.0 модуля <SAMP>`tc'</SAMP> в когда-нибудь в будущем.



<PRE>
$ cvs checkout -r rel-1-0 tc
</PRE>

<P>
Это полезно, например, если кто-то заявляет, что в той версии
была ошибка, но вы не можете найти ее в текущей рабочей копии.


<P>
Вы можете также извлечь модуль по состоянию на любую дату.
See section <A HREF="cvs-ru.html#SEC121">Ключи команды checkout</A>.  Задав команде <CODE>checkout</CODE>
ключ командной строки <SAMP>`-r'</SAMP>, следует остерегаться липких
меток; см. section <A HREF="cvs-ru.html#SEC53">Липкие метки</A>.


<P>
Когда вы помечаете более одного файла, вы можете думать о метке
как о кривой, проведенной по таблице имен файлов и их номеров
ревизий.  Скажем, у нас есть пять файлов со следующими ревизиями:



<PRE>
        file1   file2   file3   file4   file5

        1.1     1.1     1.1     1.1  /--1.1*      &#60;-*-  TAG
        1.2*-   1.2     1.2    -1.2*-
        1.3  \- 1.3*-   1.3   / 1.3
        1.4          \  1.4  /  1.4
                      \-1.5*-   1.5
                        1.6
</PRE>

<P>
Когда-то в прошлом, ревизии, отмеченные звездочками, были
помечены.  Вы можете думать о метке, как о ручке, приделанной к
кривой, нарисованной на помеченных ревизиях.  Когда вы тянете за
ручку, вы получаете все помеченные ревизии.  Еще одним способом
представления является прямая линия, вдоль которой вы смотрите на
набор файлов, и вдоль которой выровнены помеченные ревизии,
например:



<PRE>
        file1   file2   file3   file4   file5

                        1.1
                        1.2
                1.1     1.3                       _
        1.1     1.2     1.4     1.1              /
        1.2*----1.3*----1.5*----1.2*----1.1     (--- &#60;--- Look here
        1.3             1.6     1.3              \_
        1.4                     1.4
                                1.5
</PRE>



<H2><A NAME="SEC49" HREF="cvs-ru.html#TOC49">Что пометить в рабочем каталоге</A></H2>

<P>
<A NAME="IDX256"></A>
<A NAME="IDX257"></A>
Пример в предыдущей секции демонстрирует один из самых
распространенных способов выбрать, какие ревизии пометить, а
именно: выполнение команды <CODE>cvs tag</CODE> без параметров
заставляет CVS выбрать ревизии, которые извлечены в текущем
рабочем каталоге.  Например, если копия файла <TT>`backend.c'</TT> в
рабочем каталоге была извлечена из ревизии 1.4, то CVS
пометит ревизию 1.4.  Заметьте, что метка прилагается
непосредственно к ревизии 1.4 в репозитории.  Пометка -- это не
изменение файла, и не какая-либо операция, при которой сначала
модифицируется рабочий каталог, а затем команда <CODE>cvs commit</CODE> 
переносит изменения в репозиторий.


<P>
Возможно, неожиданным обстоятельством того факта, что <CODE>cvs
tag</CODE> оперирует с репозиторием, является то, что вы помечаете
извлеченные ревизии, которые могут отличаться от файлов,
измененных в вашем рабочем каталоге.  Если вы хотите избежать
ошибочного выполнения этой операции, укажите команде <CODE>cvs
tag</CODE> ключ командной строки <SAMP>`-c'</SAMP>.  Если в рабочем каталоге
имеются измененные файлы, CVS завершится с сообщением об
ошибке, не пометив ни одного файла:



<PRE>
$ cvs tag -c rel-0-4
cvs tag: backend.c is locally modified
cvs [tag aborted]: correct the above errors first!
</PRE>



<H2><A NAME="SEC50" HREF="cvs-ru.html#TOC50">Как помечать по дате или ревизии</A></H2>
<P>
<A NAME="IDX258"></A>


<P>
Команда <CODE>cvs rtag</CODE> помечает репозиторий по состоянию на
определенную дату и время (может использоваться для пометки
последней ревизии).  <CODE>rtag</CODE> работает прямо с содержимым
репозитория (не требуется сначала извлекать рабочий каталог).


<P>
Нижеследующие ключи командной строки указывают, по какой дате или
номеру ревизии помечать.  See section <A HREF="cvs-ru.html#SEC117">Стандартные ключи командной строки</A>, где приведено 
полное описание.


<DL COMPACT>

<DT><CODE>-D <VAR>дата</VAR></CODE>
<DD>
Помечает самую новую ревизию не позднее <VAR>даты</VAR>.

<DT><CODE>-f</CODE>
<DD>
Полезно только вместе с <SAMP>`-D <VAR>дата</VAR>'</SAMP> или <SAMP>`-r
<VAR>метка</VAR>'</SAMP>.  Если не обнаружено соответствующей ревизии, вместо
игнорирования файла используется самая новая ревизия.

<DT><CODE>-r <VAR>метка</VAR></CODE>
<DD>
Помечать только файлы, содержащие существующую метку
<VAR>метка</VAR>.
</DL>

<P>
Команда <CODE>cvs tag</CODE> также позволяет выбрать файлы по ревизии
или по дате, используя те же ключи командной строки <SAMP>`-D'</SAMP> и
<SAMP>`-f'</SAMP>.  Однако, это, скорее всего, вовсе не то, что вам
надо, потому что <CODE>cvs tag</CODE> выбирает, какие файлы помечать,
основываясь на файлах, существующих в рабочем каталоге, а не на
файлах, существовавших на заданную дату или в заданной ревизии.
Таким образом, обычно лучше использовать <CODE>cvs rtag</CODE>.
Исключением могут быть случаи типа:



<PRE>
cvs tag -r 1.4 backend.c
</PRE>



<H2><A NAME="SEC51" HREF="cvs-ru.html#TOC51">Удаление, перемещение и удаление меток</A></H2>

<P>
Обычно метки не изменяются.  Они существуют, чтобы хранить
историю репозитория, поэтому изменять и удалять их обычно не
нужно.


<P>
Однако же, могут быть случаи, в которых метки используются лишь
временно или случайно помечаются неверные ревизии.  Таким
образом, нужно удалить, переместить или переименовать метку.
Предупреждение: команды в этой секции опасны, они навсегда
уничтожают информацию об истории и восстановление после ошибок
может быть трудным или невозможным.  Если вы -- администратор
CVS, вы можете захотеть ограничить использование этих команд
с помощью файла <TT>`taginfo'</TT> (see section <A HREF="cvs-ru.html#SEC77">Настройка журналирования</A>).


<P>
<A NAME="IDX259"></A>
<A NAME="IDX260"></A>
Чтобы удалить метку, задайте ключ командной строки <SAMP>`-d'</SAMP>
команде <CODE>cvs tag</CODE> или <CODE>cvs rtag</CODE>.  Например:



<PRE>
cvs rtag -d rel-0-4 tc
</PRE>

<P>
удаляет метку <CODE>rel-0-4</CODE> из модуля <CODE>tc</CODE>.


<P>
<A NAME="IDX261"></A>
<A NAME="IDX262"></A>
Когда мы говорим <EM>перемещение</EM> метки, мы хотим, чтобы
существующее имя указывало на другие ревизии.  Например, метка
<CODE>stable</CODE> может указывать на ревизию 1.4 файла
<TT>`backend.c'</TT>, а мы хотим, чтобы она указывала на ревизию 1.6.
Чтобы переместить метку, задайте ключ командной строки <SAMP>`-F'</SAMP>
командам <CODE>cvs tag</CODE> или <CODE>cvs rtag</CODE>.  Например,
вышеупомянутая задача может быть решена так:



<PRE>
cvs tag -r 1.6 -F stable backend.c
</PRE>

<P>
<A NAME="IDX263"></A>
<A NAME="IDX264"></A>
Когда мы говорим <EM>переименовать</EM> метку, мы хотим, чтобы
другое имя указывало на те же ревизии, что и существующее.
Например, мы могли ошибиться в написании имени метки и хотим
исправить его, пока остальные не начали его использовать.  Чтобы
переименовать метку, сначала создайте новую метку, используя
ключ командной строки <SAMP>`-r'</SAMP> команды <CODE>cvs rtag</CODE>, затем
удалите старое имя.  После этого новая метка указывает на точно
те же самые файлы, что и старая.  Например:



<PRE>
cvs rtag -r old-name-0-4 rel-0-4 tc
cvs rtag -d old-name-0-4 tc
</PRE>



<H2><A NAME="SEC52" HREF="cvs-ru.html#TOC52">Пометки при добавлении и удалении файлов</A></H2>

<P>
Пометки довольно запутанно взаимодействуют с операциями
добавления и удаления файлов; в основном CVS отслеживает,
существует файл или нет, не особенно беспокоясь о пустяках.  По
умолчанию, помечаются только файлы, которые имеют ревизии,
соответствующие тому, что помечается.  Файлы, которые еще не
существуют или которые уже были удалены, просто пропускаются при
пометке, при этом CVS знает, что отсутствие метки означает,
что файл не существует в помеченном месте.


<P>
Однако, при этом можно потерять небольшое количество информации.
Например, предположим, что файл был добавлен, а затем удален.
Затем, если для этого файла отсутствует метка, нет способа
сказать, потому ли это, что метка соответствует времени перед
тем, как файл был добавлен, или после того, как он был удален.
Если вы выполните <CODE>cvs rtag</CODE> с ключом командной строки
<SAMP>`-r'</SAMP>, то CVS помечает файлы, которые были удалены,
избегая таким образом проблемы.  Например, можно указать <SAMP>`-r
HEAD'</SAMP>, чтобы пометить головную ревизию.


<P>
Команда <CODE>cvs rtag</CODE> имеет ключ командной строки <SAMP>`-a'</SAMP>,
очищающий метку с удаленных файлов, которые в противном случае не
были бы помечены.  Например, можно указать этот ключ вместе с
<SAMP>`-F'</SAMP> при перемещении метки.  Если переместить метку без
<SAMP>`-a'</SAMP>, то метка на удаленных файлах все еще ссылалась бы на
старую ревизию и не отражала бы того факта, что файл был удален.
Я не считаю, что это обязательно, если указано <SAMP>`-r'</SAMP>, как
отмечено выше.




<H2><A NAME="SEC53" HREF="cvs-ru.html#TOC53">Липкие метки</A></H2>
<P>
<A NAME="IDX265"></A>
<A NAME="IDX266"></A>


<P>
Иногда ревизия, находящаяся в рабочем каталоге, содержит также
дополнительную информацию о себе: например, она может находиться
на ветке (see section <A HREF="cvs-ru.html#SEC54">Создание ветвей и слияние</A>), или же может быть
ограничена с помощью <SAMP>`checkout -D'</SAMP> или <SAMP>`update -D'</SAMP>
версиями, созданными ранее указанной даты.  Так как эта
информация долговременно сохраняется, то есть действует на
последующие команды над рабочей копией, то мы называем ее
<EM>липкой</EM>.


<P>
В большинстве случаев липкость -- это запутанный аспект
CVS, о котором вам не следует думать.  Однако, даже если вы
не желаете использовать эту возможность, вы все же захотите
что-нибудь узнать о липких метках (например, как их избежать!).


<P>
Можно использовать команду <CODE>status</CODE>, чтобы посмотреть, какие
установлены липкие метки или даты:



<PRE>
$ cvs status driver.c
===================================================================
File: driver.c          Status: Up-to-date

    Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
    RCS Version:        1.7.2.1 /u/cvsroot/yoyodyne/tc/driver.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

</PRE>

<P>
<A NAME="IDX267"></A>
<A NAME="IDX268"></A>
<A NAME="IDX269"></A>
Липкие метки остаются на ваших рабочих файлах до тех пор, пока вы 
не удалите их с помощью <SAMP>`cvs update -A'</SAMP>.  Опция <SAMP>`-A'</SAMP>
извлекает версию файла из головной ревизии ствола и забывает обо
всех липких метках, датах и ключах командной строки.


<P>
<A NAME="IDX270"></A>
Самое распространенное использование липких меток -- указать,
над какой ветвью идет работа, что описано в section <A HREF="cvs-ru.html#SEC57">Доступ к веткам</A>.  Однако, липкие метки также используются и без веток.
Предположим, например, что вы хотите избежать обновления вашего
рабочего каталога, чтобы защититься от изменений, которые делают
ваши коллеги.  Вы, конечно, можете просто не выполнять команду
<CODE>cvs update</CODE>.  Если же вы хотите избежать обновления только
части большого дерева, то липкие метки могут помочь.  Если вы
извлечете определенную ревизию, скажем, 1.4, то она станет
липкой.  Последующие команды <CODE>cvs update</CODE> не станут
извлекать последнюю ревизию до тех пор, пока вы не очистите метку
с помощью <CODE>cvs update -A</CODE>.  Точно так же, использование
ключа командной строки <SAMP>`-D'</SAMP> команд <CODE>update</CODE> и
<CODE>checkout</CODE> задает <EM>липкую дату</EM>, которая используется
для будущих извлечений.


<P>
Люди часто хотят извлечь старую версию файла без установки липкой
метки.  Это можно сделать с помощью ключа командной строки
<SAMP>`-p'</SAMP> команд <CODE>checkout</CODE> или <CODE>update</CODE>, которая
посылает содержимое файла на стандартный вывод.  Например:



<PRE>
$ cvs update -p -r 1.1 file1 &#62;file1
===================================================================
Checking out file1
RCS:  /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
VERS: 1.1
***************
$
</PRE>

<P>
Однако, это не самый простой способ, если вы спрашиваете, как
отменить последнее фиксирование (в этом примере -- поместить
<TT>`file1'</TT> обратно в то состояние, в котором он был в ревизии
1.1). В этом случае лучше будет использовать ключ командной
строки <SAMP>`-j'</SAMP> команды <CODE>update</CODE>; дальнейшее обсуждение
находится в section <A HREF="cvs-ru.html#SEC62">Слияние изменений между двумя ревизиями</A>.




<H1><A NAME="SEC54" HREF="cvs-ru.html#TOC54">Создание ветвей и слияние</A></H1>
<P>
<A NAME="IDX271"></A>
<A NAME="IDX272"></A>
<A NAME="IDX273"></A>
<A NAME="IDX274"></A>
<A NAME="IDX275"></A>
<A NAME="IDX276"></A>
<A NAME="IDX277"></A>
<A NAME="IDX278"></A>


<P>
CVS позволяет изолировать изменения в отдельной линии
разработки, называемой <EM>веткой</EM>.  Когда вы изменяете файлы на 
ветке, эти изменения не появляются в основном стволе или на
других ветках.


<P>
Позже вы можете переместить изменения с одной ветки на другую или 
же с ветки в ствол, это называется <EM>слиянием</EM>.  Сначала
выполняется <CODE>cvs update -j</CODE>, чтобы  слить изменения в
рабочий каталог, а затем эти изменения можно зафиксировать, что
фактически приведет
к копированию изменений на другую ветку.




<H2><A NAME="SEC55" HREF="cvs-ru.html#TOC55">Для чего хороши ветви?</A></H2>
<P>
<A NAME="IDX279"></A>
<A NAME="IDX280"></A>
<A NAME="IDX281"></A>


<P>
Предположим, был выпущен <TT>tc</TT> версии 1.0.  Вы продолжаете его
разработку, планируя выпустить версию 1.1 через пару месяцев.
Через некоторое время ваши пользователи начинают жаловаться на
серьезную ошибку.  Вы извлекаете версию 1.0 (see section <A HREF="cvs-ru.html#SEC48">Метки ревизий</A>) и
находите ошибку, для исправления которой требуется всего лишь
тривиальное изменение).  Однако же, текущая версия исходников
находится в крайне нестабильном состоянии и не стабилизируется по
крайней мере еще месяц.  Вы не можете выпустить исправленную
версию, основываясь на свежих исходниках. 


<P>
В подобной ситуации имеет смысл создать <EM>ветку</EM> в дереве
ревизий, содержащую файлы, из которых состояла версия 1.0.  Затем
вы вносите изменения в ветвь без вторжения в основной ствол.
Потом вы сможете либо внести те же самые изменения в основной
ствол, либо оставить их только на ветви.




<H2><A NAME="SEC56" HREF="cvs-ru.html#TOC56">Создание ветви</A></H2>
<P>
<A NAME="IDX282"></A>
<A NAME="IDX283"></A>
<A NAME="IDX284"></A>
<A NAME="IDX285"></A>
<A NAME="IDX286"></A>
<A NAME="IDX287"></A>


<P>
Вы можете создать ветвь, используя <CODE>cvs tag -b</CODE>.  Например,
если вы находитесь в каталоге с рабочей копией:



<PRE>
$ cvs tag -b rel-1-0-patches
</PRE>

<P>
Это отщепляет ветку, основанную на текущей ревизии рабочей копии, 
и присваивает этой ветке имя <SAMP>`rel-1-0-patches'</SAMP>.


<P>
Важно понимать, что ветки создаются в репозитории, а не в рабочей 
копии.  Создание ветки, основанной на текущей ревизии, как в
вышеприведенном примере, <EM>НЕ</EM> переключает рабочую копию на
использование ветки (See section <A HREF="cvs-ru.html#SEC57">Доступ к веткам</A>, где описано, как
сделать это).


<P>
Можно также создать ветку вообще без использования рабочей копии,
используя <CODE>rtag</CODE>.



<PRE>
$ cvs rtag -b -r rel-1-0 rel-1-0-patches tc
</PRE>

<P>
<SAMP>`-r rel-1-0'</SAMP> означает, что эта ветка имеет корневую ревизию, 
соответствующую метке <SAMP>`rel-1-0'</SAMP>.  Это не обязательно должна
быть самая последняя ревизия: довольно часто бывает полезно
отщепить ветку от старой ревизии (например, для исправления
ошибки в старой версии, которая в основном стабильна).


<P>
Как и в случае с <SAMP>`tag'</SAMP>, ключ командной строки <SAMP>`-b'</SAMP>
заставляет <CODE>rtag</CODE> создать ветку (а не символьное имя
ревизии).  Заметьте, что номера ревизий, соответствующих
<SAMP>`rel-1-0'</SAMP>, скорее всего, будут разными в разных файлах.


<P>
Таким образом, полный эффект этой команды -- создать новую ветку, 
которая называется <SAMP>`rel-1-0-patches'</SAMP>, в модуле <SAMP>`tc'</SAMP>,
которая растет в дереве ревизий из точки, помеченной как
<SAMP>`rel-1-0'</SAMP>. 




<H2><A NAME="SEC57" HREF="cvs-ru.html#TOC57">Доступ к веткам</A></H2>
<P>
<A NAME="IDX288"></A>
<A NAME="IDX289"></A>
<A NAME="IDX290"></A>
<A NAME="IDX291"></A>
<A NAME="IDX292"></A>
<A NAME="IDX293"></A>


<P>
Вы можете извлечь ветку двумя способами:  извлекая ее из
репозитория в чистом каталоге или переключая существующую рабочую 
копию на ветку. 


<P>
Для того, чтобы извлечь ветку из репозитория, выполните команду
<SAMP>`checkout'</SAMP> с ключом командной строки <SAMP>`-r'</SAMP>, с именем
метки в качестве параметра (see section <A HREF="cvs-ru.html#SEC56">Создание ветви</A>). 



<PRE>
$ cvs checkout -r rel-1-0-patches tc
</PRE>

<P>
Если у вас уже есть рабочая копия, вы можете переключить ее на
нужную ветку с помощью <SAMP>`update -r'</SAMP>:



<PRE>
$ cvs update -r rel-1-0-patches tc
</PRE>

<P>
или, что то же самое:



<PRE>
$ cd tc
$ cvs update -r rel-1-0-patches
</PRE>

<P>
Неважно, что рабочая копия была извлечена из основного ствола или 
какой-нибудь другой ветки: вышеприведенная команда переключит ее
на указанную ветку.  Подобно обычной команде <SAMP>`update'</SAMP>,
<SAMP>`update -r'</SAMP> сливает сделанные изменения, уведомляя вас о
произошедших конфликтах.


<P>
Когда вы связываете рабочую копию с какой-либо веткой, она
будет оставаться связанной, пока вы не укажете обратного.  Это
означает, что изменения, которые фиксируются из рабочей копии,
будут добавлять новые ревизии на ветку, оставляя без изменений
основной ствол и другие ветки. 


<P>
<A NAME="IDX294"></A>
Чтобы узнать, на какой ветви находится рабочая копия, можно
использовать команду <SAMP>`status'</SAMP>.  В том, что она вывела на
экран, обратите внимание на поле, которое называется <SAMP>`Sticky 
tag'</SAMP> (see section <A HREF="cvs-ru.html#SEC53">Липкие метки</A>) -- здесь CVS сообщает, на какой 
ветви находятся рабочие файлы:



<PRE>
$ cvs status -v driver.c backend.c
===================================================================
File: driver.c          Status: Up-to-date

    Version:            1.7     Sat Dec  5 18:25:54 1992
    RCS Version:        1.7     /u/cvsroot/yoyodyne/tc/driver.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-1-0-patches             (branch: 1.7.2)
        rel-1-0                     (revision: 1.7)

===================================================================
File: backend.c         Status: Up-to-date

    Version:            1.4     Tue Dec  1 14:39:01 1992
    RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.4.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-1-0-patches             (branch: 1.4.2)
        rel-1-0                     (revision: 1.4)
        rel-0-4                     (revision: 1.4)

</PRE>

<P>
Не смущайтесь тем, что номера ветвей для каждого файла различны
(<SAMP>`1.7.2'</SAMP> и <SAMP>`1.4.2'</SAMP>, соответственно).  Метка ветви одна
и та же, <SAMP>`rel-1-0-patches'</SAMP>, и все файлы действительно
находятся на одной и той же ветке.  Номера лишь отражают ту точку в
истории файла, в которой появилась ветвь.  Из вышеприведенного
примера можно узнать, что перед тем, как была создана
ветка, <SAMP>`driver.c'</SAMP> претерпел больше изменений, чем
<SAMP>`backend.c'</SAMP>.


<P>
Смотри section <A HREF="cvs-ru.html#SEC58">Ветки и ревизии</A>, где подробно описано, как устроены
номера ветвей.




<H2><A NAME="SEC58" HREF="cvs-ru.html#TOC58">Ветки и ревизии</A></H2>
<P>
<A NAME="IDX295"></A>
<A NAME="IDX296"></A>
<A NAME="IDX297"></A>


<P>
Обычно история ревизий файла -- это линейная возрастающая
последовательность номеров (see section <A HREF="cvs-ru.html#SEC45">Номера ревизий</A>):



<PRE>
       +-----+    +-----+    +-----+    +-----+    +-----+
       ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
       +-----+    +-----+    +-----+    +-----+    +-----+
</PRE>

<P>
Однако же, CVS не ограничен линейной разработкой.
<EM>Дерево ревизий</EM> может быть расщеплено на <EM>ветви</EM>, где
каждая ветвь -- самостоятельная линия разработки.  Изменения,
сделанные на одной ветке, легко могут быть внесены также и в
основной ствол.


<P>
Каждая ветка имеет <EM>номер ветки</EM>, состоящий из нечетного
числа десятичных чисел, разделенных точками.  Номер ветки
создается путем добавления целого числа к номеру ревизии, от
которой была отщеплена ветка.  Номера веток позволяют отщеплять
от одной и той же ревизии несколько веток. 


<P>
Все ревизии на ветке имеют номера ревизий, образованные путем
добавления порядкового номера к номеру ветки.  Вот иллюстрация
создания веток.



<PRE>
                                                      +-------------+
                           Branch 1.2.2.3.2 -&#62;        ! 1.2.2.3.2.1 !
                                                    / +-------------+
                                                   /
                                                  /
                 +---------+    +---------+    +---------+
Branch 1.2.2 -&#62; _! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
               / +---------+    +---------+    +---------+
              /
             /
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !  &#60;- The main trunk
+-----+    +-----+    +-----+    +-----+    +-----+
                !
                !
                !   +---------+    +---------+    +---------+
Branch 1.2.4 -&#62; +---! 1.2.4.1 !----! 1.2.4.2 !----! 1.2.4.3 !
                    +---------+    +---------+    +---------+

</PRE>

<P>
Обычно не требуется задумываться о точных деталях того, как
строятся номера веток, но вот еще подробности: когда CVS
создает номер ветки, он берет первое неиспользованное четное
число, начиная с двойки.  Поэтому, если вы хотите создать ветку
от ревизии 6.4, она будет называться 6.4.2.  Номера веток,
заканчивающиеся на ноль (например, 6.4.0), используются для
внутренних нужд CVS (see section <A HREF="cvs-ru.html#SEC59">Волшебные номера веток</A>).  Ветка
1.1.1 имеет специальное значение.  See section <A HREF="cvs-ru.html#SEC103">Слежение за чужими исходными текстами</A>.




<H2><A NAME="SEC59" HREF="cvs-ru.html#TOC59">Волшебные номера веток</A></H2>

<P>
<A NAME="IDX298"></A>
<A NAME="IDX299"></A>
В этой секции описана возможность CVS, называющаяся
<EM>волшебные ветки</EM>.  В большинстве случаев вам не потребуется
беспокоиться о волшебных ветках, так как CVS сам следит за
ними.  Однако, при определенных условиях их можно увидеть, и
поэтому полезно было бы узнать, как они работают. 


<P>
Номера веток состоят из нечетного количества десятичных целых чисел,
разделенных точками.  See section <A HREF="cvs-ru.html#SEC45">Номера ревизий</A>.  Однако же, это не
полная правда.  Из соображений эффективности CVS иногда
вставляет лишний ноль во вторую справа позицию (1.2.4 становится
1.2.0.4, а 8.9.10.11.12 становится 8.9.10.11.0.12 и так далее).


<P>
CVS довольно хорошо прячет такие "волшебные" ветки, но в
нескольких местах ему это не удается:



<UL>
<LI>

Номера волшебных веток появляются в выдаче <CODE>cvs log</CODE>. 

<LI>

Вы не можете указать символическое имя ветки в команде <CODE>cvs
admin</CODE>. 

</UL>

<P>
Можно использовать команду <CODE>admin</CODE>, чтобы переназначить
символическое имя ветки на то, которое ожидает увидеть CVS.
Например, если <CODE>R4patches</CODE> присвоено ветке 1.4.2 (волшебный
номер 1.4.0.2) в файле <TT>`numbers.c'</TT>, можно сделать так:



<PRE>
$ cvs admin -NR4patches:1.4.2 numbers.c
</PRE>

<P>
Это сработает, только если хотя бы одна ревизия уже была
зафиксирована на ветке.  Будьте очень осторожны, чтобы не
присвоить метку неправильному числу, так как нет способа узнать,
чему была присвоена эта метка вчера (за исключением ежедневного
резервного копирования). 




<H2><A NAME="SEC60" HREF="cvs-ru.html#TOC60">Слияние веток</A></H2>
<P>
<A NAME="IDX300"></A>
<A NAME="IDX301"></A>


<P>
Вы можете объединить изменения, сделанные на ветке, с вашей
рабочей копией, добавив флаг <SAMP>`-j <VAR>ветка</VAR>'</SAMP> к команде
<CODE>update</CODE>.  В результате CVS внедряет в рабочую копию
изменения, сделанные между корневой ревизией ветки и
свежайшей ревизией на этой ветке.


<P>
<A NAME="IDX302"></A>
Ключ командной строки <SAMP>`-j'</SAMP> означает "объединить" (join).


<P>
<A NAME="IDX303"></A>
<A NAME="IDX304"></A>
<A NAME="IDX305"></A>
<A NAME="IDX306"></A>
Представьте себе такое дерево ревизий:



<PRE>
+-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !      &#60;- основной ствол
+-----+    +-----+    +-----+    +-----+
                !
                !
                !   +---------+    +---------+
 Ветвь R1fix -&#62; +---! 1.2.2.1 !----! 1.2.2.2 !
                    +---------+    +---------+
</PRE>

<P>
Ветке 1.2.2 была назначена метка (символьное имя)
<SAMP>`R1fix'</SAMP>.  В нижеследующем примере предполагается, что модуль 
<SAMP>`mod'</SAMP> содержит единственный файл, <TT>`m.c'</TT>.



<PRE>
$ cvs checkout mod               # Извлечь последнюю ревизию, 1.4

$ cvs update -j R1fix m.c        # Слить все изменения, сделанные на ветке,
                                 # т. е. изменения между ревизиями 1.2
                                 # и 1.2.2.2, в рабочую копию файла

$ cvs commit -m "Included R1fix" # создать ревизию 1.5.
</PRE>

<P>
В результате операции слияния может произойти конфликт.  В это
случае вам сначала надо справиться с ним перед фиксированием
изменений.  See section <A HREF="cvs-ru.html#SEC85">Пример конфликта</A>.


<P>
Команда <CODE>checkout</CODE> также поддерживает флаг <SAMP>`-j
<VAR>ветка</VAR>'</SAMP>.  Можно добиться эффекта, обсуждавшегося выше, с
помощью 



<PRE>
$ cvs checkout -j R1fix mod
$ cvs commit -m "Добавлен R1fix"
</PRE>



<H2><A NAME="SEC61" HREF="cvs-ru.html#TOC61">многократное слияние из ветки</A></H2>
<P>
<A NAME="IDX307"></A>


<P>
Мы продолжаем обсуждение примера.  Теперь дерево ревизий выглядит 
так:



<PRE>
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   &#60;- ствол
+-----+    +-----+    +-----+    +-----+    +-----+
                !                           *
                !                          *
                !   +---------+    +---------+
 Ветвь R1fix -&#62; +---! 1.2.2.1 !----! 1.2.2.2 !
                    +---------+    +---------+
</PRE>

<P>
Здесь линия из звездочек представляет собой слияние ветки
<SAMP>`R1fix'</SAMP> с основным стволом, обсуждавшееся только что. 


<P>
Предположим теперь, что разработка ветки <SAMP>`R1fix'</SAMP>
продолжается:



<PRE>
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   &#60;- ствол
+-----+    +-----+    +-----+    +-----+    +-----+
                !                           *
                !                          *
                !   +---------+    +---------+    +---------+
 Ветвь R1fix -&#62; +---! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                    +---------+    +---------+    +---------+
</PRE>

<P>
и теперь вы опять хотите слить свежайшие изменения с основным
стволом.  Если бы вы просто использовали команду <CODE>cvs update
-j R1fix m.c</CODE>, то CVS попыталась бы опять слить уже слитые
изменения, что привело бы к нежелательным результатам. 


<P>
Вместо этого вам нужно указать, что вы хотите слить только
те изменения на ветке, что еще не были объединены со стволом.  Для
этого вы указываете два ключа командной строки <SAMP>`-j'</SAMP>, и
CVS сливает изменения между первой и второй ревизиями.
Например, в этом случае самым простым способом будет 



<PRE>
cvs update -j 1.2.2.2 -j R1fix m.c    # Слить изменения между 1.2.2.2 и
                                      # головой ветки R1fix
</PRE>

<P>
Проблемой здесь является то, что вы должны вручную указать
ревизию 1.2.2.2.  Чуть лучшим подходом будет использование даты
совершения последнего слияния. 



<PRE>
cvs update -j R1fix:yesterday -j R1fix m.c
</PRE>

<P>
Еще лучше было бы помечать ветку <SAMP>`R1fix'</SAMP> после каждого
слияния со стволом, и использовать эту метку для дальнейших
слияний: 



<PRE>
cvs update -j merged_from_R1fix_to_trunk -j R1fix m.c
</PRE>



<H2><A NAME="SEC62" HREF="cvs-ru.html#TOC62">Слияние изменений между двумя ревизиями</A></H2>
<P>
<A NAME="IDX308"></A>
<A NAME="IDX309"></A>
<A NAME="IDX310"></A>


<P>
С помощью двух флагов <SAMP>`-j <VAR>ревизия</VAR>'</SAMP>, команды <CODE>update</CODE> и
<CODE>checkout</CODE> могут сливать изменения между любыми двумя ревизиями в
ваш рабочий файл. 


<P>
<A NAME="IDX311"></A>
<A NAME="IDX312"></A>
Команда



<PRE>
$ cvs update -j 1.5 -j 1.3 backend.c
</PRE>

<P>
отменит изменения, сделанные между ревизиями 1.3 и 1.5.  Обратите
внимание на порядок указания ревизий!


<P>
Если вы попробуете использовать эту опцию при работе с несколькими
файлами, помните, что номера ревизий, вероятно, будут сильно
отличаться для разных файлов.  В таких случаях почти всегда
следует использовать символьные метки, а не номера ревизий.


<P>
<A NAME="IDX313"></A>
<A NAME="IDX314"></A>
Указав два ключа командной строки <SAMP>`-j'</SAMP>, можно также отменить
удаление или добавление файла.  Например, предположим, у вас есть файл
<SAMP>`file1'</SAMP>, существовавший в ревизии 1.1.  Затем вы удалили его,
создав "мертвую" ревизию 1.2.  Теперь предположим, что вы хотите
добавить его опять, с тем же самым содержимым, что он имел ранее.  Вот
как сделать это: 



<PRE>
$ cvs update -j 1.2 -j 1.1 file1
U file1
$ cvs commit -m test
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  &#60;--  file1
new revision: 1.3; previous revision: 1.2
done
$
</PRE>



<H2><A NAME="SEC63" HREF="cvs-ru.html#TOC63">При слиянии можно добавлять и удалять файлы</A></H2>

<P>
Если изменения, которые вы сливаете, включают в себя удаление или
добавление каких-либо файлов, то команда <CODE>update -j</CODE> учтет такие
добавления и удаления. 


<P>
For example:

<PRE>
cvs update -A
touch a b c
cvs add a b c ; cvs ci -m "added" a b c
cvs tag -b branchtag
cvs update -r branchtag
touch d ; cvs add d
rm a ; cvs rm a
cvs ci -m "added d, removed a"
cvs update -A
cvs update -jbranchtag
</PRE>

<P>
После того, как эти команды выполнены, а также выполнена команда
<SAMP>`cvs commit'</SAMP>, файл <TT>`a'</TT> будет удален, а файл <TT>`d'</TT> будет
добавлен в основной ствол.




<H1><A NAME="SEC64" HREF="cvs-ru.html#TOC64">Рекурсивное поведение</A></H1>
<P>
<A NAME="IDX315"></A>
<A NAME="IDX316"></A>
<A NAME="IDX317"></A>
<A NAME="IDX318"></A>


<P>
Почти все подкоманды CVS работают рекурсивно, если вы укажете в
качестве аргумента каталог.  Например, представим себе такую структуру
каталогов: 



<PRE>
      <CODE>$HOME</CODE>
        |
        +--<TT>tc</TT>
        |   |
            +--<TT>CVS</TT>
            |      (служебные файлы CVS)
            +--<TT>Makefile</TT>
            +--<TT>backend.c</TT>
            +--<TT>driver.c</TT>
            +--<TT>frontend.c</TT>
            +--<TT>parser.c</TT>
            +--<TT>man</TT>
            |    |
            |    +--<TT>CVS</TT>
            |    |  (служебные файлы CVS)
            |    +--<TT>tc.1</TT>
            |
            +--<TT>testing</TT>
                 |
                 +--<TT>CVS</TT>
                 |  (служебные файлы CVS)
                 +--<TT>testpgm.t</TT>
                 +--<TT>test2.t</TT>
</PRE>

<P>
Если <TT>`tc'</TT> -- это текущий рабочий каталог, то верны следующие
утверждения: 



<UL>
<LI>

<SAMP>`cvs update testing'</SAMP> эквивалентно


<PRE>
cvs update testing/testpgm.t testing/test2.t
</PRE>

<LI>

<SAMP>`cvs update testing man'</SAMP> обновляет все файлы в подкаталогах 

<LI>

<SAMP>`cvs update .'</SAMP> или просто <SAMP>`cvs update'</SAMP> обновляет все файлы в
каталоге <CODE>tc</CODE>
</UL>

<P>
Если команде <CODE>update</CODE> не было дано ни одного аргумента, то она
обновит все файлы в текущем рабочем каталоге и во всех его
подкаталогах.  Другими словами, <TT>`.'</TT> является аргументом по
умолчанию для <CODE>update</CODE>.  Это также истинно для большинства
подкоманд CVS, а не только для команды <CODE>update</CODE>.


<P>
Рекурсивное поведение подкоманд CVS может быть отключено с помощью
ключа командной строки <SAMP>`-l'</SAMP>, и наоборот, ключ командной строки
<SAMP>`-R'</SAMP> может использоваться для принудительной рекурсии, если
<SAMP>`-l'</SAMP> был указан в <TT>`~/.cvsrc'</TT> (see section <A HREF="cvs-ru.html#SEC115">Ключи по умолчанию и файл ~/.cvsrc</A>). 



<PRE>
$ cvs update -l         # Не обновлять файлы в подкаталогах
</PRE>



<H1><A NAME="SEC65" HREF="cvs-ru.html#TOC65">Добавление, удаление и переименование файлов и каталогов</A></H1>

<P>
В процессе разработки проекта часто требуется добавлять, удалять
или переименовывать файлы и каталоги.  Исходя из общих принципов, 
требуется, чтобы CVS запоминала факт совершения такого
действия, вместо того, чтобы совершать необратимое изменение,
точно так же, как она обращается с изменениями файлов.  Точные
механизмы, действующие в этих случаях, зависят от конкретной
ситуации. 




<H2><A NAME="SEC66" HREF="cvs-ru.html#TOC66">Добавление файлов в каталог</A></H2>
<P>
<A NAME="IDX319"></A>


<P>
Для того, чтобы добавить новый файл в каталог, совершите
следующие шаги:



<UL>
<LI>

Сначала у вас должна быть рабочая копия каталога.
See section <A HREF="cvs-ru.html#SEC5">Получение исходного кода</A>.

<LI>

Создайте новый файл в рабочей копии каталога.

<LI>

Используйте <SAMP>`cvs add <VAR>имя_файла</VAR>'</SAMP>, чтобы сообщить
CVS, что вы хотите хранить историю изменений этого файла.
Если в файле хранятся двоичные данные, добавьте ключ командной
строки <SAMP>`-kb'</SAMP> (see section <A HREF="cvs-ru.html#SEC79">Обработка двоичных файлов</A>).

<LI>

Используйте команду <SAMP>`cvs commit <VAR>имя_файла</VAR>'</SAMP>, чтобы
поместить файл в репозиторий.  Другие разработчики не увидят этот 
файл, пока вы не выполните эту команду. 
</UL>

<P>
Можно также использовать команду <CODE>add</CODE> для добавления нового 
каталога.


<P>
В отличие от большинства других команд, команда <CODE>add</CODE> не
является рекурсивной.  Вы даже не можете сказать <SAMP>`cvs add
foo/bar'</SAMP>.  Вместо этого, вам потребуется выполнить



<PRE>
$ cd foo
$ cvs add bar
</PRE>

<P>
<A NAME="IDX320"></A>
<DL>
<DT><U>Команда:</U> <B>cvs add</B> <I>[<CODE>-k</CODE> kflag] [<CODE>-m</CODE> сообщение] файлы ...</I>
<DD><A NAME="IDX321"></A>


<P>
Добавить <VAR>файлы</VAR> в список на помещение в репозиторий.  Файлы
или каталоги, указанные в команде <CODE>add</CODE>, должны существовать 
в текущем каталоге.  Для того, чтобы добавить в репозиторий целое дерево
каталогов, например, файлы, полученные от стороннего поставщика,
используйте команду <CODE>import</CODE>. See section <A HREF="cvs-ru.html#SEC135">Команда import: импортировать исходные тексты</A>.


<P>
Добавленные файлы не помещаются в репозиторий, пока вы не
выполните команду <CODE>commit</CODE>, зафиксировав тем самым
изменения.  Выполнение команды <CODE>add</CODE> для файла, который был
удален командой <CODE>remove</CODE>, отменит действие <CODE>remove</CODE>,
если после нее еще не была выполнена команда <CODE>commit</CODE>.
See section <A HREF="cvs-ru.html#SEC67">Удаление файлов</A>, там находится пример. 


<P>
Ключ командной строки <SAMP>`-k'</SAMP> задает способ по умолчанию,
которым будут извлекаться файлы, дальнейшая информация находится
в section <A HREF="cvs-ru.html#SEC97">Подстановка ключевых слов</A>.


<P>
Ключ командной строки <SAMP>`-m'</SAMP> задает описание файла.  Описание
появляется в журнале истории, если разрешено его использование,
see section <A HREF="cvs-ru.html#SEC172">Файл history</A>.  Также это описание будет сохранено в
репозитории, когда файл будет зафиксирован.  Команда <CODE>log</CODE>
показывает это описание.  Описание может быть изменено с помощью
команды <CODE>admin -t</CODE>.  See section <A HREF="cvs-ru.html#SEC118">Команда admin: администрирование</A>.  Если вы опустите
флаг <SAMP>`-m <VAR>описание</VAR>'</SAMP>, то у вас не спросят описания, а
будет использована пустая строка.
</DL>


<P>
Например, нижеследующие команды добавляют файл <TT>`backend.c'</TT> в 
репозиторий:



<PRE>
$ cvs add backend.c
$ cvs commit -m "Early version. Not yet compilable." backend.c
</PRE>

<P>
Когда вы добавляете файл, он добавляется только на ту ветку, над
которой вы работаете (see section <A HREF="cvs-ru.html#SEC54">Создание ветвей и слияние</A>).  Вы
можете позднее поместить добавления на другую ветку, если
захотите (see section <A HREF="cvs-ru.html#SEC63">При слиянии можно добавлять и удалять файлы</A>). 




<H2><A NAME="SEC67" HREF="cvs-ru.html#TOC67">Удаление файлов</A></H2>
<P>
<A NAME="IDX322"></A>
<A NAME="IDX323"></A>


<P>
Содержимое каталогов меняется.  Добавляются новые файлы, исчезают 
старые.  Однако же, вам хотелось бы извлекать точные копии старых 
версий вашего проекта. 


<P>
Вот как можно удалить файл, сохранив доступ к его старым
ревизиям: 



<UL>
<LI>

Убедитесь, что у вас неизмененная версия этого файла.
See section <A HREF="cvs-ru.html#SEC8">Просмотр изменений</A>, там описан один из способов убедиться
в этом.  Можно также использовать команды <CODE>status</CODE> или
<CODE>update</CODE>.  Если вы удалите файл без предварительной фиксации 
изменений, вы, конечно же, не сможете извлечь этот файл в том
виде, в котором он находился перед удалением.

<LI>

Удалите файл из рабочей копии каталога.  Например, можно
использовать программу <CODE>rm</CODE>.

<LI>

Выполните <SAMP>`cvs remove <VAR>имя-файла</VAR>'</SAMP>, чтобы сообщить
CVS, что вы действительно хотите удалить этот файл.

<LI>

Выполните <SAMP>`cvs commit <VAR>имя-файла</VAR>'</SAMP>, чтобы зафиксировать
удаление файла в репозитории. 
</UL>

<P>
Когда вы фиксируете удаление файла, CVS запоминает, что
этого файла более не существует.  Впрочем, он может существовать
на одних ветках и не существовать на других, или же можно
впоследствии добавить другой файл с тем же самым именем.
CVS корректно создаст или не станет создавать файл,
основываясь на ключах командной строки <SAMP>`-r'</SAMP> или <SAMP>`-D'</SAMP>,
заданных в командах <CODE>checkout</CODE> или <CODE>update</CODE>. 


<P>
<A NAME="IDX324"></A>
<DL>
<DT><U>Команда:</U> <B>cvs remove</B> <I>[ключи] файлы ...</I>
<DD><A NAME="IDX325"></A>


<P>
Помещает файлы в список на удаление из репозитория (для того,
чтобы эта команда сработала, нужно, чтобы файлы были удалены из
рабочего каталога).  Эта команда не удаляет файлы из репозитория, 
пока вы не зафиксируете удаление.  Полный список ключей находится 
в section <A HREF="cvs-ru.html#SEC152">Краткий справочник по командам CVS</A>.
</DL>


<P>
Вот пример удаления нескольких файлов:



<PRE>
$ cd test
$ rm *.c
$ cvs remove
cvs remove: Removing .
cvs remove: scheduling a.c for removal
cvs remove: scheduling b.c for removal
cvs remove: use 'cvs commit' to remove these files permanently
$ cvs ci -m "Removed unneeded files"
cvs commit: Examining .
cvs commit: Committing .
</PRE>

<P>
Для удобства можно удалять файлы и одновременно делать <CODE>cvs
remove</CODE>, используя ключ командной строки <SAMP>`-f'</SAMP>.  Например,
вышеприведенный пример можно переписать так:



<PRE>
$ cd test
$ cvs remove -f *.c
cvs remove: scheduling a.c for removal
cvs remove: scheduling b.c for removal
cvs remove: use 'cvs commit' to remove these files permanently
$ cvs ci -m "Removed unneeded files"
cvs commit: Examining .
cvs commit: Committing .
</PRE>

<P>
Если вы выполните команду <CODE>remove</CODE>, а затем перемените свое
решение, еще не зафиксировав удаление, то команду <CODE>remove</CODE>
можно отменить с помощью команды <CODE>add</CODE>. 



<PRE>
$ ls
CVS   ja.h  oj.c
$ rm oj.c
$ cvs remove oj.c
cvs remove: scheduling oj.c for removal
cvs remove: use 'cvs commit' to remove this file permanently
$ cvs add oj.c
U oj.c
cvs add: oj.c, version 1.1.1.1, resurrected
</PRE>

<P>
Если вы осознаете свою ошибку перед выполнением команды
<CODE>remove</CODE>, можно использовать <CODE>update</CODE>, чтобы воскресить 
файлы:



<PRE>
$ rm oj.c
$ cvs update oj.c
cvs update: warning: oj.c was lost
U oj.c
</PRE>

<P>
Когда вы удаляете файл, он удаляется только с той ветки, на
которой вы работаете (see section <A HREF="cvs-ru.html#SEC54">Создание ветвей и слияние</A>).  Позже
можно слить удаления на другую ветку, если захотите
(see section <A HREF="cvs-ru.html#SEC63">При слиянии можно добавлять и удалять файлы</A>).




<H2><A NAME="SEC68" HREF="cvs-ru.html#TOC68">Удаление каталогов</A></H2>
<P>
<A NAME="IDX326"></A>
<A NAME="IDX327"></A>


<P>
В принципе удаление каталогов в чем-то подобно удалению файлов
--- вы не хотите, чтобы каталог существовал в текущем рабочем
каталоге, но вы хотите также, чтобы можно было извлекать старые
версии проекта, в которых еще существовал каталог.


<P>
Можно удалить каталог, удалив все файлы в нем.  Нет способа
удалить сам каталог.  Вместо этого вы задаете командам <CODE>cvs
update</CODE>, <CODE>cvs checkout</CODE> или <CODE>cvs export</CODE> ключ командной
строки <SAMP>`-P'</SAMP>, который заставит CVS удалять пустые
каталоги в рабочем каталоге.  Вероятно, лучше всего будет всегда
указывать <SAMP>`-P'</SAMP>, если вы хотите, чтобы существовал пустой
каталог, поместите в него пустой файл, например, <TT>`.keepme'</TT>,
чтобы не дать CVS с ключом <SAMP>`-P'</SAMP> удалить этот каталог.


<P>
Заметьте, что при использовании ключей <SAMP>`-r'</SAMP> или <SAMP>`-D'</SAMP> с
командами <CODE>checkout</CODE> и <CODE>export</CODE> подразумевается также
использование <SAMP>`-P'</SAMP>.  При этом CVS сможет создать или не
создавать каталог, в зависимости от того, находились ли в этом
каталоге какие-либо файлы в конкретной версии проекта.




<H2><A NAME="SEC69" HREF="cvs-ru.html#TOC69">Перемещение и переименование файлов</A></H2>
<P>
<A NAME="IDX328"></A>
<A NAME="IDX329"></A>
<A NAME="IDX330"></A>
<A NAME="IDX331"></A>


<P>
Перемещение файлов в другой каталог или переименование их
несложно, но некоторые аспекты могут быть неочевидными.
Перемещение и переименование каталогов еще
сложнее. See section <A HREF="cvs-ru.html#SEC73">Перемещение и переименование каталогов</A>.)


<P>
В нижеприведенных примерах предполагается, что файл <TT>`old'</TT>
переименовывается в <TT>`new'</TT>.




<H3><A NAME="SEC70" HREF="cvs-ru.html#TOC70">Обычный способ переименования</A></H3>

<P>
Обычным способом перемещения файла является копирование <VAR>old</VAR> 
в <VAR>new</VAR>, а затем выполнение команд CVS для удаления
файла <VAR>old</VAR> из репозитория и добавления туда файла <VAR>new</VAR>.



<PRE>
$ mv <VAR>old</VAR> <VAR>new</VAR>
$ cvs remove <VAR>old</VAR>
$ cvs add <VAR>new</VAR>
$ cvs commit -m "<VAR>old</VAR> переименован в <VAR>new</VAR>" <VAR>old</VAR> <VAR>new</VAR>
</PRE>

<P>
Это самый простой способ переместить файл, он не подвержен
ошибкам, и сохраняет историю совершенных действий.  Заметьте, что 
для доступа к истории файла нужно указать старое или новое имя, в 
зависимости от периода истории, к которому вы обращаетесь.
Например, <CODE>cvs log <VAR>old</VAR></CODE> выдаст журнал вплоть до
момента переименования.


<P>
Когда <VAR>new</VAR> фиксируется, нумерация его ревизий начнется с
нуля, обычно с 1.1, поэтому если это вам не нравится, используйте 
ключ командной строки <SAMP>`-r <VAR>номер</VAR>'</SAMP> команды
<CODE>commit</CODE>.  Дальнейшую информацию смотри в section <A HREF="cvs-ru.html#SEC47">Назначение номеров ревизий</A>.




<H3><A NAME="SEC71" HREF="cvs-ru.html#TOC71">Перемещение файла с ревизиями</A></H3>

<P>
Этот метод более опасен, потому что требует перемещения файлов в
репозитории.  Прочтите всю главу перед попытками применить этот
метод!



<PRE>
$ cd $CVSROOT/<VAR>dir</VAR>
$ mv <VAR>old</VAR>,v <VAR>new</VAR>,v
</PRE>

<P>
Преимущества:



<UL>
<LI>

Журнал изменений сохраняется.

<LI>

Номера ревизий не изменяются.
</UL>

<P>
Недостатки:



<UL>
<LI>

Нет простого способа извлечь старые версии проекта из
репозитория.  Файл будет извлекаться под именем <VAR>new</VAR> даже
для версий проекта, в которых он еще не был переименован.

<LI>

Не сохраняется информация о том, когда был переименован файл.

<LI>

Могут произойти неприятности, если кто-нибудь захочет поработать
с файлом ревизий, пока вы его перемещаете.  Убедитесь, что никто
более не обращается к репозиторию, пока вы выполняете операцию.
</UL>



<H3><A NAME="SEC72" HREF="cvs-ru.html#TOC72">Копирование файла с ревизиями</A></H3>

<P>
Этот способ также требует прямых изменений репозитория.  Он
безопасен, но не без подводных камней.



<PRE>
#  Копировать RCS-файл в репозитории 
$ cd $CVSROOT/<VAR>dir</VAR>
$ cp <VAR>old</VAR>,v <VAR>new</VAR>,v
#  Удалить старый файл 
$ cd ~/<VAR>dir</VAR>
$ rm <VAR>old</VAR>
$ cvs remove <VAR>old</VAR>
$ cvs commit <VAR>old</VAR>
# Удалить все метки из <VAR>new</VAR>
$ cvs update <VAR>new</VAR>
$ cvs log <VAR>new</VAR>   # Запомнить все метки, не являющиеся именами веток
$ cvs tag -d <VAR>tag1</VAR> <VAR>new</VAR>
$ cvs tag -d <VAR>tag2</VAR> <VAR>new</VAR>
...
</PRE>

<P>
Удалив метки, вы сможете извлекать старые ревизии


<P>
Преимущества:



<UL>
<LI>

Извлечение старых ревизий работает корректно, если вы используете
для извлечения ревизий ключ командной строки
<SAMP>`-r<VAR>метка</VAR>'</SAMP>, а не <SAMP>`-D<VAR>дата</VAR>'</SAMP>.

<LI>

Журнал изменений остается в целости и сохранности.

<LI>

Номера ревизий не искажаются.
</UL>

<P>
Недостатки:



<UL>
<LI>

Нет способа легко увидеть историю файла до переименования. 

</UL>



<H2><A NAME="SEC73" HREF="cvs-ru.html#TOC73">Перемещение и переименование каталогов</A></H2>
<P>
<A NAME="IDX332"></A>
<A NAME="IDX333"></A>
<A NAME="IDX334"></A>
<A NAME="IDX335"></A>


<P>
Обычный способ переименовать или переместить каталог ---
переименовать или переместить каждый файл в нем, как описано в
section <A HREF="cvs-ru.html#SEC70">Обычный способ переименования</A>.  Затем следует извлечь их заново, используя ключ
командной строки <SAMP>`-P'</SAMP>, как описано в section <A HREF="cvs-ru.html#SEC68">Удаление каталогов</A>.


<P>
Если вам действительно нужно возиться с репозиторием, чтобы
переименовать или удалить каталог в репозитории, вы можете
сделать это так:



<OL>
<LI>

Уведомить всех, у кого есть извлеченная копия каталога, что
каталог будет переименован.  Они должны зафиксировать свои
изменения и удалить рабочие копии, перед тем, как вы предпримете
дальнейшие шаги.

<LI>

Переименуйте каталог внутри репозитория.


<PRE>
$ cd $CVSROOT/<VAR>родительский-каталог</VAR>
$ mv <VAR>старый-каталог</VAR> <VAR>новый-каталог</VAR>
</PRE>

<LI>

Исправьте административные файлы CVS, если это требуется
(например, если вы переименовали целый модуль).

<LI>

Сообщите всем, что они могут извлечь свои рабочие копии опять и
продолжить работу.

</OL>

<P>
Если кто-то не удалил свою рабочую копию, команды CVS будут
отказываться работать, пока он не удалит каталог, которого больше 
не существует в репозитории.


<P>
Почти всегда гораздо лучшим способом будет переместить файлы в
каталоге, вместо того, чтобы перемещать каталог, потому что иначе
вы, скорее всего, не сможете корректно извлекать старые версии
вашего проекта, так как они, вероятно, зависят от имен каталогов.




<H1><A NAME="SEC74" HREF="cvs-ru.html#TOC74">Просмотр истории</A></H1>
<P>
<A NAME="IDX336"></A>
<A NAME="IDX337"></A>
<A NAME="IDX338"></A>


<P>
После того, как вы успели поиспользовать CVS для хранения
информации об истории изменений: какие файлы, когда, как и кто
изменил, вам потребуются разнообразные механизмы для просмотра
истории.




<H2><A NAME="SEC75" HREF="cvs-ru.html#TOC75">Журнальные записи</A></H2>

<P>
Каждый раз, когда вы фиксируете изменения в файле, вам
предлагается создать соответствующую журнальную запись.


<P>
Для того, чтобы просмотреть журнальные записи, соответствующие
каждой зафиксированной ревизии, используйте команду <CODE>cvs
log</CODE> (see section <A HREF="cvs-ru.html#SEC139">Команда log: напечатать информацию о файлах</A>). 




<H2><A NAME="SEC76" HREF="cvs-ru.html#TOC76">База истории</A></H2>

<P>
Вы можете использовать файл history (see section <A HREF="cvs-ru.html#SEC172">Файл history</A>), чтобы
журналировать разнообразные действия CVS.  Чтобы извлечь
информацию из файла history, используйте команду <CODE>cvs
history</CODE> (see section <A HREF="cvs-ru.html#SEC172">Файл history</A>).




<H2><A NAME="SEC77" HREF="cvs-ru.html#TOC77">Настройка журналирования</A></H2>

<P>
Вы можете настроить CVS для журналирования различных
действий тем способом, который вам требуется.  Это достигается
выполнением определенного скрипта в определенные моменты времени.
Скрипт может, например, добавить сообщение об изменении в конец
какого-либо файла, послать почтовое сообщение группе
разработчиков или, например, поместить сообщение в группу
новостей.  Для того, чтобы журналировать факты фиксирования,
используйте файл <TT>`loginfo'</TT> (see section <A HREF="cvs-ru.html#SEC167">Файл loginfo</A>).


<P>
Для журналирования фиксирований, извлечений, экспортов и меток
можно использовать флаги <SAMP>`-i'</SAMP>, <SAMP>`-o'</SAMP>, <SAMP>`-e'</SAMP> и
<SAMP>`-t'</SAMP> соответственно.  Эти флаги находятся в файле модулей.
Более гибким способом уведомления пользователей, требующим меньше
усилий по поддержке централизованных скриптов, является команда
<CODE>cvs watch add</CODE> (see section <A HREF="cvs-ru.html#SEC90">CVS может посылать вам уведомления</A>); эта команда
полезна, даже если вы не используете <CODE>cvs watch on</CODE>.


<P>
<A NAME="IDX339"></A>
<A NAME="IDX340"></A>
<A NAME="IDX341"></A>
В файле <TT>`taginfo'</TT> перечисляются программы, которые нужно
выполнить, когда кто-либо выполняет команды CVS <CODE>tag</CODE>
или <CODE>rtag</CODE>.  Файл <TT>`taginfo'</TT> имеет стандартный формат
административных файлов (see section <A HREF="cvs-ru.html#SEC153">Справочник по административным файлам</A>), а
каждая строка в нем содержит регулярное выражение, за которым
следует команда, которую надо выполнить.  Аргументы, которые
передаются команде, это <VAR>имя-метки</VAR>, <VAR>операция</VAR>
(<CODE>add</CODE> для <CODE>tag</CODE>, <CODE>mov</CODE> для <CODE>tag -F</CODE>,
<CODE>del</CODE> для <CODE>tag -d</CODE>), <VAR>репозиторий</VAR>, а затем следует 
серия пар <VAR>имя-файла ревизия</VAR>.  Ненулевой код завершения
программы приведет к отмене операции с метками.


<P>
Вот пример использования <TT>`taginfo'</TT> для журналирования команд
<CODE>tag</CODE> и <CODE>rtag</CODE>.  В файле <TT>`taginfo'</TT> написано:



<PRE>
ALL /usr/local/cvsroot/CVSROOT/loggit
</PRE>

<P>
Здесь <TT>`/usr/local/cvsroot/CVSROOT/loggit'</TT> является таким
скриптом:



<PRE>
#!/bin/sh
echo "$@" &#62;&#62;/home/kingdon/cvsroot/CVSROOT/taglog
</PRE>



<H2><A NAME="SEC78" HREF="cvs-ru.html#TOC78">Команда annotate</A></H2>
<P>
<A NAME="IDX342"></A>


<P>
<DL>
<DT><U>Команда:</U> <B>cvs annotate</B> <I>[<CODE>-flR</CODE>] [<CODE>-r rev</CODE>|<CODE>-D date</CODE>] files ...</I>
<DD><A NAME="IDX343"></A>


<P>
Для каждого файла в списке <VAR>files</VAR>, напечатать головную
ревизию в стволе, а также информацию о последних изменениях в
каждой строке.  Например:



<PRE>
$ cvs annotate ssfile
Annotations for ssfile
***************
1.1          (mary     27-Mar-96): ssfile line 1
1.2          (joe      28-Mar-96): ssfile line 2
</PRE>

<P>
В файле <TT>`ssfile'</TT> в настоящий момент содержит две строки.
Строка <CODE>ssfile line 1</CODE> была зафиксирована <CODE>mary</CODE>
двадцать седьмого марта.  Затем, двадцать восьмого, <CODE>joe</CODE>
добавил строки <CODE>ssfile line 2</CODE>, не изменяя строки
<CODE>ssfile line 1</CODE>.  В этом отчете ничего не сказано о том, что 
было удалено или заменено; используйте <CODE>cvs diff</CODE>, чтобы
узнать это (see section <A HREF="cvs-ru.html#SEC128">Команда diff: показать различия между ревизиями</A>).


</DL>

<P>
Ключи команды <CODE>cvs annotate</CODE> перечислены в section <A HREF="cvs-ru.html#SEC152">Краткий справочник по командам CVS</A>,
и могут использоваться для выбора файлов и их ревизий, которые
нужно аннотировать.  Ключи детально описаны в section <A HREF="cvs-ru.html#SEC117">Стандартные ключи командной строки</A>.




<H1><A NAME="SEC79" HREF="cvs-ru.html#TOC79">Обработка двоичных файлов</A></H1>
<P>
<A NAME="IDX344"></A>
<A NAME="IDX345"></A>


<P>
Основное применение для CVS -- хранить текстовые файлы.  При 
работе с текстовыми файлами CVS может объединять ревизии,
показывать различия между ревизиями в доступном для человека
формате, и совершать прочие подобные операции.  Однако, если вы
согласитесь отказаться от некоторых возможностей, то CVS
может хранить двоичные файлы.  Например, можно хранить в CVS 
целый web-сайт, причем как страницы, так и двоичные картинки.




<H2><A NAME="SEC80" HREF="cvs-ru.html#TOC80">Вопросы использования двоичных файлов</A></H2>

<P>
Если вы постоянно работаете с двоичными файлами, то необходимость 
их использования очевидна.  Если же вы хотите хранить историю
изменений таких файлов, возникают дополнительные вопросы.


<P>
Одной из основных функций контроля версий -- просмотр различий
между двумя ревизиями.  Например, если кто-то еще создает новую
ревизию файла, то вам хотелось бы взглянуть на то, что изменилось 
и выяснить, верно ли были сделаны изменения.  Для текстовых
файлов CVS обеспечивает такую функциональность с помощью
команды <CODE>cvs diff</CODE>.  Для двоичных файлов можно извлечь две
ревизии и сравнить их с помощью внешнего инструмента (например, в 
текстовых процессорах обычно имеется такая возможность.  Если
такого инструмента не существует, нужно отслеживать изменения
посредством с помощью других механизмов, например, заставляя
людей писать хорошие журнальные сообщения, надеясь при этом, что
они действительно сделали то, что намеревались сделать.


<P>
Другая возможность системы контроля версий -- объединение двух
ревизий.  Для CVS это происходит в двух контекстах.
Во-первых, пользователи редактируют файлы в различных рабочих
каталогах (see section <A HREF="cvs-ru.html#SEC82">Несколько разработчиков</A>).  Во-вторых,
объединения совершаются явно, используя команду <SAMP>`update -j'</SAMP>
(see section <A HREF="cvs-ru.html#SEC54">Создание ветвей и слияние</A>).


<P>
В случае текстовых файлов CVS может объединить изменения,
совершенные независимо друг от друга, и сигнализировать о
конфликте, если нужно.  В случае двоичных файлов лучшее, что
может сделать CVS -- выдать две различных копии файла и
предоставить пользователю справиться с конфликтом.  Пользователь
может выбрать ту или иную копию, или использовать специальный
инструмент для слияния файлов этого конкретного формата, если
таковой инструмент существует.  Заметьте, что необходимость
слияния изменений вручную полностью зависит от аккуратности
пользователя, поэтому может привести к ошибкам.


<P>
Если вышеописанный процесс нежелателен, лучшим выходом было бы
отказаться от автоматического слияния.  Чтобы избежать слияний,
являющихся результатом работы в разных рабочих каталогах,
посмотрите обсуждение блокирующих извлечений (блокировок файлов)
в section <A HREF="cvs-ru.html#SEC82">Несколько разработчиков</A>.  Чтобы избежать слияний,
образующихся в результате использования ветвей, ограничьте
использование ветвей.




<H2><A NAME="SEC81" HREF="cvs-ru.html#TOC81">Как хранить двоичные файлы</A></H2>

<P>
При хранении двоичных файлов встает два вопроса.  Первый:
CVS по умолчанию преобразует коды конца строк между
канонической формой, в которой они хранятся в репозитории (только 
символ новой строки) и формой, соответствующей операционной
системе клиента (например, возврат каретки, за которым следует
перевод строки под Windows NT).


<P>
Второй вопрос -- в двоичном файле могут оказаться данные,
похожие на ключевое слово (see section <A HREF="cvs-ru.html#SEC97">Подстановка ключевых слов</A>),
так что эта подстановка должна быть выключена.


<P>
Ключ командной строки <SAMP>`-kb'</SAMP>, доступный при использовании
некоторых команд CVS, позволяет убедиться, что ни
преобразование концов строки, ни подстановка ключевых слов не
производятся.


<P>
Вот пример создания нового файла с использование флага
<SAMP>`-kb'</SAMP>:



<PRE>
$ echo '$Id: cvs-ru.htm,v 1.1 2002/02/06 13:29:56 ax222 Exp $' &#62; kotest
$ cvs add -kb -m"A test file" kotest
$ cvs ci -m"Первое фиксирование; файл содержит ключевое слово" kotest
</PRE>

<P>
Если файл случайно будет добавлен без <SAMP>`-kb'</SAMP>, можно
использовать команду <CODE>cvs admin</CODE> для восстановления.
Например,



<PRE>
$ echo '$Id: cvs-ru.htm,v 1.1 2002/02/06 13:29:56 ax222 Exp $' &#62; kotest
$ cvs add -m"A test file" kotest
$ cvs commit -m"Первое фиксирование; содержит ключевое слово" kotest
$ cvs admin -kb kotest
$ cvs update -A kotest
# Для не-UNIX систем:
# Скопировать откуда-нибудь хорошую копию файла
$ cvs commit -m "Сделать файл двоичным" kotest
</PRE>

<P>
Когда вы извлечете файл <TT>`kotest'</TT>, он не станет двоичным,
потому что вы не зафиксировали его как двоичный.  Команда
<CODE>cvs admin -kb</CODE> устанавливает метод подстановки ключевых
слов по умолчанию для этого файла, но не изменяет рабочую копию
файла, которая у вас есть.  Если вам нужно справиться с символами
конца строки (при использовании CVS на не-UNIX
системах), вам требуется зафиксировать новую копию файла, как
показано выше в команде <CODE>cvs commit</CODE>.
Под UNIX достаточно выполнить <CODE>cvs update -A</CODE>.


<P>
Однако, используя <CODE>cvs admin -k</CODE> для изменения режима
подстановки ключевых слов, знайте, что этот режим не подчиняется
контролю версий.  Это означает, что если, скажем, в старых
версиях пакета какой-то файл был текстовым, а затем в новых
версиях появился двоичный файл с тем же именем, то CVS не
обеспечивает способа извлечь файл в двоичном или текстовом режиме
в зависимости от версии пакета, которую вы извлекаете.  Для
обхода этой проблемы хорошего решения не существует.


<P>
Вы можете установить значения по умолчанию, которые используют
команды <CODE>cvs add</CODE> и <CODE>cvs import</CODE>, для выяснения,
является ли файл текстовым или двоичным, основываясь на его
имени.  Например, можно гарантировать, что файлы, чьи имена
заканчиваются на <SAMP>`.exe'</SAMP> являются двоичными.
See section <A HREF="cvs-ru.html#SEC160">Файл <TT>`cvswrappers'</TT></A>.  В настоящий момент нет способа для определения,
является ли файл текстовым или двоичным, в зависимости от его
содержимого. Основная трудность при разработке такой возможности
--- неясно, как различить такие файлы, потому что способы сильно
различаются в разных операционных системах.




<H1><A NAME="SEC82" HREF="cvs-ru.html#TOC82">Несколько разработчиков</A></H1>

<P>
<A NAME="IDX346"></A>
<A NAME="IDX347"></A>
<A NAME="IDX348"></A>
<A NAME="IDX349"></A>
<A NAME="IDX350"></A>
<A NAME="IDX351"></A>
<A NAME="IDX352"></A>
<A NAME="IDX353"></A>
<A NAME="IDX354"></A>
<A NAME="IDX355"></A>
Когда над программным проектом работает более одного человека,
ситуация резко усложняется.  Зачастую два разработчика одновременно пытаются
редактировать один и тот же файл.  Одно из решений, известное как
<EM>блокировка файлов</EM> или <EM>блокированное извлечение</EM>, -- в
каждый момент времени позволять редактировать файл только одному
человеку.  Это -- единственное решение при использовании
некоторых систем контроля версий, включая RCS и SCCS.
В настоящее время обычным способом совершить блокированное
извлечение рабочей копии с помощью CVS -- использовать
команду <CODE>cvs admin -l</CODE> (see section <A HREF="cvs-ru.html#SEC119">Ключи команды admin</A>).  Эта возможность
не столь красиво интегрирована в CVS, как функции слежения,
описанные ниже, но кажется, что всех, кому требуется блокированное 
извлечение, эта команда устраивает.


<P>
Во избежание одновременного редактирования файла двумя
разработчиками можно также
использовать возможность слежения, описанную ниже, вместе с
соответствующими административными процедурами (не контролируемыми с помощью
программы).


<P>
Модель, используемая в CVS по умолчанию, называется
<EM>неблокированные извлечения</EM>.  В этой модели разработчики
редактируют свои собственные <EM>рабочие копии</EM> файла.  Первый,
зафиксировавший свои изменения, не может автоматически узнать,
что второй также начал редактировать файл.  Второй получит
сообщения об ошибке, когда попытается зафиксировать файл.  Он
должен использовать соответствующие команды CVS, чтобы
его рабочая копия соответствовала свежайшей ревизии, находящейся
в репозитории.  Весь этот процесс проходит почти автоматически.


<P>
CVS также поддерживает механизмы различных способов
коммуникации, никак не настаивая на выполнении каких-либо правил, 
в отличие от блокированных извлечений.


<P>
Оставшаяся часть главы описывает, как работают все эти различные
модели, а также некоторые вопросы, связанные с выбором того или
иного варианта.




<H2><A NAME="SEC83" HREF="cvs-ru.html#TOC83">Статус файла</A></H2>
<P>
<A NAME="IDX356"></A>
<A NAME="IDX357"></A>


<P>
Основываясь на операциях, которые производятся над извлеченным
файлом, а также на операциях, которые производятся над этим
файлом в репозитории, можно классифицировать несколько состояний
файла.  Команда <CODE>status</CODE> рапортует об этих состояниях.  Они
таковы: 


<DL COMPACT>

<DT>Up-to-date
<DD>
<A NAME="IDX358"></A>
 
Файл идентичен последней ревизии в репозитории, находящейся на
используемой ветке.

<DT>Locally Modified
<DD>
<A NAME="IDX359"></A>
Вы редактировали этот файл и еще не зафиксировали изменения.

<DT>Locally Added
<DD>
<A NAME="IDX360"></A>
Вы добавили этот файл с помощью <CODE>cvs add</CODE>, и еще не
зафиксировали изменения.

<DT>Locally Removed
<DD>
<A NAME="IDX361"></A>
Вы удалили файл с помощью <CODE>cvs remove</CODE> и еще не
зафиксировали изменения.

<DT>Needs Checkout
<DD>
<A NAME="IDX362"></A>
Кто-то еще поместил новую ревизию в репозиторий.  Название
немного сбивает с толку, потому что требуется использовать
команду <CODE>cvs update</CODE>, а не <CODE>cvs checkout</CODE>, чтобы
получить свежайшую версию.

<DT>Needs Patch
<DD>
<A NAME="IDX363"></A>
Похоже на "Needs Checkout", но CVS-сервер пошлет заплату, а
не целый файл.  В принципе это приведет к тому же самому
результату.

<DT>Needs Merge
<DD>
<A NAME="IDX364"></A>
Кто-то еще поместил новую ревизию в репозиторий, а вы также
изменили этот файл.

<DT>File had conflicts on merge
<DD>
<A NAME="IDX365"></A>
Похоже на "Locally Modified", только последняя выполненная
команда <CODE>cvs update</CODE> обнаружила конфликт.  Если вы еще не
исправили его, сделайте это, как описано в section <A HREF="cvs-ru.html#SEC85">Пример конфликта</A>.

<DT>Unknown
<DD>
<A NAME="IDX366"></A>
CVS ничего не знает об этом файле.  Например, вы создали
новый файл и еще не выполнили <CODE>cvs add</CODE>.
</DL>

<P>
Чтобы уточнить состояние файла, <CODE>cvs status</CODE> также сообщает
о <CODE>Working revision</CODE>, являющейся ревизией, на основе которой 
создан файл в рабочем каталоге, и <CODE>Repository revision</CODE>,
являющейся свежайшей ревизией в репозитории, находящейся на
используемой ветке.


<P>
Ключи команды <CODE>status</CODE> перечислены в section <A HREF="cvs-ru.html#SEC152">Краткий справочник по командам CVS</A>.
Информация о <CODE>Sticky tag</CODE> и <CODE>Sticky date</CODE> находится в
section <A HREF="cvs-ru.html#SEC53">Липкие метки</A>.  Информация о <CODE>Sticky options</CODE> находится 
в описании флага <SAMP>`-k'</SAMP> в section <A HREF="cvs-ru.html#SEC150">Ключи команды update</A>.


<P>
Команды <CODE>status</CODE> и <CODE>update</CODE> можно рассматривать как
соответствующие друг другу.  <CODE>update</CODE> используется для
извлечения самых свежих файлов, а <CODE>status</CODE> -- для
выяснения, что же произойдет, если выполнить <CODE>update</CODE>
(конечно, состояние репозитория может измениться до того, как вы
выполните <CODE>update</CODE>).  В действительность, если вы хотите
узнать состояние файлов в более краткой форме, выполните


<P>
<A NAME="IDX367"></A>
<A NAME="IDX368"></A>

<PRE>
$ cvs -n -q update
</PRE>

<P>
Ключ командной строки <SAMP>`-n'</SAMP> указывает не выполнять
обновление, а просто сообщить о состоянии файлов; <SAMP>`-q'</SAMP> не
печатает имена каждого каталога.  Прочую информацию о команде
<CODE>update</CODE> можно найти в section <A HREF="cvs-ru.html#SEC152">Краткий справочник по командам CVS</A>.




<H2><A NAME="SEC84" HREF="cvs-ru.html#TOC84">Извлечение свежей ревизии файла</A></H2>
<P>
<A NAME="IDX369"></A>
<A NAME="IDX370"></A>
<A NAME="IDX371"></A>
<A NAME="IDX372"></A>
<A NAME="IDX373"></A>
<A NAME="IDX374"></A>


<P>
Если вы хотите получить новую ревизию файла или объединить его с
другой ревизией, используйте команду <CODE>update</CODE>.  Если вы
имеете старую ревизию файла, то эта команда эквивалентна
<CODE>checkout</CODE>: свежая ревизия извлекается из репозитория и
помещается в рабочий каталог.


<P>
Ваши изменения в файле не теряются, когда вы используете
<CODE>update</CODE>.  Если более свежей ревизии не существует,
выполнение <CODE>update</CODE> ничего не сделает.  Если вы
редактировали файл, а в репозитории появилась его более новая
ревизия, изменения будут объединены с вашей рабочей копией.


<P>
Например, представим себе, что вы извлекли ревизию 1.4 и начали
редактировать ее.  В это время кто-то еще поместил в репозиторий
ревизию 1.5 и, вскорости, ревизию 1.6.  Если теперь вы выполните
команду <CODE>update</CODE>, CVS внедрит изменения между ревизиями
1.4 и 1.6 в ваш файл.


<P>
<A NAME="IDX375"></A>
Если изменения между ревизиями 1.4 и 1.6 случились слишком близко
к вашим изменениям, происходит <EM>пересечение</EM>.  В таких
случаях на экран выдается предупреждение, а в результирующем
файле оказываются обе версии пересекающихся строк, разделенные
специальными маркерами.  See section <A HREF="cvs-ru.html#SEC149">Команда update: обновить рабочий каталог из репозитория</A>, где полностью описана
команда <CODE>update</CODE>.




<H2><A NAME="SEC85" HREF="cvs-ru.html#TOC85">Пример конфликта</A></H2>
<P>
<A NAME="IDX376"></A>
<A NAME="IDX377"></A>
<A NAME="IDX378"></A>
<A NAME="IDX379"></A>


<P>
Предположим, что ревизия 1.4 файла <TT>`driver.c'</TT> содержит такой 
код:



<PRE>
#include &#60;stdio.h&#62;

void main()
{
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? 0 : 1);
}
</PRE>

<P>
Ревизия 1.6 файла <TT>`driver.c'</TT> содержит такой код:



<PRE>
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(!!nerr);
}
</PRE>

<P>
Ваша рабочая копия файла <TT>`driver.c'</TT>, основанная на ревизии
1.4, перед выполнением <SAMP>`cvs update'</SAMP> содержит такой код:



<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

void main()
{
    init_scanner();
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</PRE>

<P>
Вы выполняете <SAMP>`cvs update'</SAMP>:



<PRE>
$ cvs update driver.c
RCS file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
retrieving revision 1.4
retrieving revision 1.6
Merging differences between 1.4 and 1.6 into driver.c
rcsmerge warning: overlaps during merge
cvs update: conflicts found in driver.c
C driver.c
</PRE>

<P>
<A NAME="IDX380"></A>
CVS сообщает, что вы встретились с конфликтами.  Ваш
исходный рабочий файл сохранен в <TT>`.#driver.c.1.4'</TT>.  Новая
версия <TT>`driver.c'</TT> содержит такой код:



<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
&#60;&#60;&#60;&#60;&#60;&#60;&#60; driver.c
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
=======
    exit(!!nerr);
&#62;&#62;&#62;&#62;&#62;&#62;&#62; 1.6
}
</PRE>

<P>
<A NAME="IDX381"></A>
<A NAME="IDX382"></A>
<A NAME="IDX383"></A>
<A NAME="IDX384"></A>
<A NAME="IDX385"></A>
Заметьте, что непересекающиеся модификации включены в вашу
рабочую копию, а пересекающаяся секция четко обозначена строками
<SAMP>`&#60;&#60;&#60;&#60;&#60;&#60;&#60;'</SAMP>, <SAMP>`======='</SAMP> and <SAMP>`&#62;&#62;&#62;&#62;&#62;&#62;&#62;'</SAMP>.


<P>
<A NAME="IDX386"></A>
<A NAME="IDX387"></A>
Разрешить конфликт можно, отредактировав файл, удалив маркеры и
неверный вариант.  Предположим, в результате у вас получился
такой файл:

<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</PRE>

<P>
Теперь вы можете поместить этот файл в репозиторий в качестве
ревизии 1.7.



<PRE>
$ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
Checking in driver.c;
/usr/local/cvsroot/yoyodyne/tc/driver.c,v  &#60;--  driver.c
new revision: 1.7; previous revision: 1.6
done
</PRE>

<P>
Чтобы защитить вас, CVS откажется фиксировать файл, если в
нем произошел конфликт и вы с ним не справились.  В настоящий
момент для разрешения конфликта нужно изменить дату модификации
файла.  В предыдущих версиях CVS вам также требовалось
убедиться, что файл не содержит маркеров конфликта.  Так как ваш
файл действительно может содержать маркеры конфликтов (символы
<SAMP>`&#62;&#62;&#62;&#62;&#62;&#62;&#62;&#62;'</SAMP> в начале строки, не обозначающие конфликта), то в 
текущей версии CVS выдает предупреждение и фиксирует файл.


<P>
<A NAME="IDX388"></A>
Если вы используете <CODE>pcl-cvs</CODE> (оболочка к CVS для
Emacs) версии 1.04 или позже, вы можете использовать пакет
emerge, помогающий разрешать конфликты.  Смотрите документацию по 
<CODE>pcl-cvs</CODE>.




<H2><A NAME="SEC86" HREF="cvs-ru.html#TOC86">Информирование коллег о фиксировании ревизий</A></H2>
<P>
<A NAME="IDX389"></A>
<A NAME="IDX390"></A>
<A NAME="IDX391"></A>


<P>
Часто бывает полезно информировать своих коллег, когда вы
фиксируете новую ревизию файла.  Можно использовать ключ
<SAMP>`-i'</SAMP> в файле <TT>`modules'</TT> или файле <TT>`loginfo'</TT> для
автоматизации этого процесса.  See section <A HREF="cvs-ru.html#SEC154">Файл <TT>`modules'</TT></A>.  See section <A HREF="cvs-ru.html#SEC167">Файл loginfo</A>.  Можно использовать эти возможности CVS для того,
чтобы указать CVS, например, отсылать почтовые сообщения
всем разработчикам или помещать сообщение в локальную группу
новостей.




<H2><A NAME="SEC87" HREF="cvs-ru.html#TOC87">Совместный доступ нескольких разработчиков к CVS</A></H2>

<P>
<A NAME="IDX392"></A>
Если несколько разработчиков попытаются одновременно выполнить
CVS, один из них получит такое сообщение:



<PRE>
[11:43:23] waiting for bach's lock in /usr/local/cvsroot/foo
</PRE>

<P>
<A NAME="IDX393"></A>
<A NAME="IDX394"></A>
<A NAME="IDX395"></A>
CVS попытается повторить операцию каждые 30 секунд, и либо
успешно выполнит ее, либо опять напечатает сообщение, если опять
нужно ждать.  Если блокировка сохраняется слишком долго, найдите
того, кто создал ее и спросите его, что за команду он выполняет.
Если он не выполняет команд CVS, загляните в каталог
репозитория, упомянутый в сообщении, и удалите файлы, чьи имена
начинаются с <TT>`#cvs.rfl'</TT>, <TT>`#cvs.wfl'</TT>, или
<TT>`#cvs.lock'</TT>, принадлежащие указанному пользователю.


<P>
Заметьте, что эти блокировки предназначаются для защиты
внутренних структур данных CVS и не имеют никакого отношения 
к слову <EM>блокировка</EM> в том смысле, который используется в
RCS и означает блокированные извлечения (see section <A HREF="cvs-ru.html#SEC82">Несколько разработчиков</A>). 


<P>
Неограниченное количество пользователей может одновременно читать
репозиторий; только когда кто-либо пишет туда, блокировки
препятствуют прочим как читать, так и писать.


<P>
<A NAME="IDX396"></A>
<A NAME="IDX397"></A>
Можно было бы надеяться, что верно следующее утверждение:



<PRE>
Если кто-либо фиксирует несколько изменений одной командой
CVS, то команда <CODE>update</CODE>, выполненная кем-то еще,
получит либо все изменения, либо ни одно из них.
</PRE>

<P>
К сожалению, при работе с CVS это утверждение
<EM>неверно</EM>.  Например, если имеются файлы



<PRE>
a/one.c
a/two.c
b/three.c
b/four.c
</PRE>

<P>
и кто-то выполняет



<PRE>
cvs ci a/two.c b/three.c
</PRE>

<P>
а затем кто-то еще в то же самое время выполняет <CODE>cvs
update</CODE>, то он может получить изменения для <TT>`b/three.c'</TT>, и
не получить изменения в <TT>`a/two.c'</TT>.




<H2><A NAME="SEC88" HREF="cvs-ru.html#TOC88">Как отследить, кто редактирует файлы?</A></H2>
<P>
<A NAME="IDX398"></A>


<P>
Для большинства групп использования CVS в режиме по
умолчанию совершенно достаточно.  Пользователи иногда могут,
попытавшись зафиксировать изменение, обнаружить, что мешает
другое изменение, но они справятся с этим и все же зафиксируют
свое изменение.  В других группах предпочитают знать, кто какие
файлы редактирует, так что если два человека захотят
редактировать один и тот же файл, то они предпочтут договориться
друг с другом, кто что будет делать, чтобы не получать проблем
при каждом фиксировании.  Возможности, описанные в этой главе,
помогают такой координации, сохраняя возможность редактирования
одного файла двум разработчикам одновременно.


<P>
Для получения максимального преимущества разработчики должны
использовать <CODE>cvs edit</CODE> (а не <CODE>chmod</CODE>), чтобы сделать
файлы доступными для чтения/записи, и <CODE>cvs release</CODE> (а не
<CODE>rm</CODE>) для удаления рабочего каталога, который более не
используется.  CVS не может вынудить их делать так. 




<H3><A NAME="SEC89" HREF="cvs-ru.html#TOC89">Как с помощью CVS следить за определенными файлами?</A></H3>

<P>
Для того, чтобы включить использование функции слежения, сначала
укажите, за какими файлами нужно следить. 


<P>
<A NAME="IDX399"></A>
<DL>
<DT><U>Команда:</U> <B>cvs watch on</B> <I>[<CODE>-lR</CODE>] файлы ...</I>
<DD><A NAME="IDX400"></A>


<P>
<A NAME="IDX401"></A>
<A NAME="IDX402"></A>
Команда означает, что разработчикам нужно выполнить команду
<CODE>cvs edit</CODE> перед редактированием <VAR>файлов</VAR>.  Для того,
чтобы напомнить об этом разработчикам, CVS создаст рабочие
копии <VAR>файлов</VAR> в режиме только для чтения.


<P>
Если среди <VAR>файлов</VAR> есть имя каталога, CVS включает
слежение за всем файлами, находящимися в соответствующем каталоге
репозитория и автоматически включает режим слежения за всеми
файлами, которые будут в дальнейшем добавлены в каталог; это
позволяет пользователю задать стратегию уведомлений для каждого
каталога.  Содержимое каталога обрабатывается рекурсивно, если
только не задан ключ командной строки <CODE>-l</CODE>.  Ключ <CODE>-R</CODE>
позволяет включить рекурсивное поведение, если в файле
<TT>`~/.cvsrc'</TT> оно было выключено с помощью ключа <CODE>-l</CODE>
(see section <A HREF="cvs-ru.html#SEC115">Ключи по умолчанию и файл ~/.cvsrc</A>).


<P>
Если список файлов пропущен, по умолчанию обрабатывается текущий
каталог.


<P>
<A NAME="IDX403"></A>
</DL>


<P>
<DL>
<DT><U>Команда:</U> <B>cvs watch off</B> <I>[<CODE>-lR</CODE>] файлы ...</I>
<DD><A NAME="IDX404"></A>


<P>
Команда означает, что при извлечении не нужно создавать
<VAR>файлы</VAR> в режиме только для чтения; таким образом,
разработчики не будут получать напоминания о необходимости
использования <CODE>cvs edit</CODE> и <CODE>cvs unedit</CODE>.  CVS
будет извлекать <VAR>файлы</VAR> в обычном режиме, если только на
файле не установлены специальные права доступа, разрешенные с
помощью ключевого слова <CODE>PreservePermissions</CODE> в
административном файле <TT>`config'</TT>; см. section <A HREF="cvs-ru.html#SEC111">Специальные файлы</A>, а также See section <A HREF="cvs-ru.html#SEC174">Файл конфигурации CVSROOT/config</A>.


<P>
<VAR>Файлы</VAR> и ключи командной строки обрабатываются точно так же, 
как и для <CODE>cvs watch on</CODE>.


</DL>



<H3><A NAME="SEC90" HREF="cvs-ru.html#TOC90">CVS может посылать вам уведомления</A></H3>

<P>
Вы можете сказать CVS, что хотели бы получать уведомления о
разнообразных действиях, совершенных с файлом.  В принципе вы
можете сделать это без использования <CODE>cvs watch on</CODE>, но
обычно все же будете использовать как раз <CODE>cvs watch on</CODE>,
чтобы другие разработчики использовали команду <CODE>cvs edit</CODE>.


<P>
<A NAME="IDX405"></A>
<DL>
<DT><U>Команда:</U> <B>cvs watch add</B> <I>[<CODE>-a</CODE> действие] [<CODE>-lR</CODE>] файлы ...</I>
<DD><A NAME="IDX406"></A>


<P>
Добавить текущего пользователя в список лиц, которые будут
получать уведомления о действиях, совершавшихся с <VAR>файлами</VAR>.


<P>
Ключ командной строки <CODE>-a</CODE> задает тип событий, о которых
следует посылать уведомления.  <VAR>действие</VAR> -- это


<DL COMPACT>

<DT><CODE>edit</CODE>
<DD>
Другой пользователь выполнил для файла команду <CODE>cvs edit</CODE>
(описанную ниже).

<DT><CODE>unedit</CODE>
<DD>
Другой пользователь выполнил команду <CODE>cvs unedit</CODE> (описанную 
ниже) или команду <CODE>cvs release</CODE>, или удалил файл и позволил
команде <CODE>cvs update</CODE> создать его заново.

<DT><CODE>commit</CODE>
<DD>
Другой пользователь зафиксировал изменения в файле.

<DT><CODE>all</CODE>
<DD>
Все эти действия.

<DT><CODE>none</CODE>
<DD>
Ни одно из этих действий.  (Это полезно вместе с <CODE>cvs edit</CODE>, 
описанной ниже.)

</DL>

<P>
Ключ <CODE>-a</CODE> можно указать несколько раз или вообще не
указывать, в этом случае по умолчанию используется <CODE>all</CODE>.


<P>
<VAR>Файлы</VAR> и ключи командной строки обрабатываются так же, как и 
в команде <CODE>cvs watch</CODE>.


</DL>

<P>
<A NAME="IDX407"></A>
<DL>
<DT><U>Команда:</U> <B>cvs watch remove</B> <I>[<CODE>-a</CODE> действие] [<CODE>-lR</CODE>] файлы ...</I>
<DD><A NAME="IDX408"></A>


<P>
Удалить запрос на уведомление, созданный с помощью <CODE>cvs
watch add</CODE>; аргументы те же самые.  Если присутствует ключ
командной строки <CODE>-a</CODE>, то только удаляются только слежения
за указанными действиями.


</DL>

<P>
<A NAME="IDX409"></A>
Когда требуется отправить уведомление, CVS обращается к
административному файлу <TT>`notify'</TT>.  Этот файл можно
отредактировать точно так же, как и другие административные файл
(see section <A HREF="cvs-ru.html#SEC20">Административные файлы</A>).  Синтаксис этого
файла подобен другим административным файлам
(see section <A HREF="cvs-ru.html#SEC162">Обычный синтаксис</A>), где каждая строка состоит из регулярного
выражения и команды, которую надо выполнить.  Команда должна
содержать одно единственное упоминание символов <SAMP>`%s'</SAMP>,
которые будут заменены на имя пользователя, которого нужно
уведомить;  остальная информация передается этой команде на
стандартный вход.  Обычно в файл <TT>`notify'</TT> помещается такая
строка:



<PRE>
ALL mail %s -s \"CVS notification\"
</PRE>

<P>
В результате всего этого пользователи получают уведомления по
электронной почте.


<P>
<A NAME="IDX410"></A>
Заметьте, что если вы настроите все именно так, как рассказано
выше, то пользователи будут получать уведомления на сервере.
Конечно же, можно написать скрипт <TT>`notify'</TT>, который
перенаправляет уведомления на другой адрес, но, для простоты,
CVS позволяет задать адрес, по которому следует отсылать
уведомления пользователю.  Для этого создайте в <TT>`CVSROOT'</TT>
файл <TT>`users'</TT>, в котором каждая строка имеет вид
<VAR>пользователь</VAR>:<VAR>адрес</VAR>.  Тогда вместо того, чтобы
использовать имя пользователя, CVS будет использовать
<VAR>адрес</VAR>. 


<P>
CVS не уведомляет вас о ваших собственных изменениях.  В
настоящий момент проверка производится, основываясь на имени
пользователя, который совершает действия, приводящие к отсылке
уведомления.  Вообще, функция слежения каждый раз сообщает только
об одном изменении, сделанном одним пользователем.  Вероятно,
было бы более полезно, если бы отдельно отслеживались целые
рабочие каталоги, поэтому такое поведение было бы полезно
изменить.




<H3><A NAME="SEC91" HREF="cvs-ru.html#TOC91">Как редактировать файлы, за которыми наблюдают?</A></H3>

<P>
<A NAME="IDX411"></A>
Так как файл, за которым следит кто-либо, извлекается в режиме
только для чтения, то вы не можете просто взять и отредактировать
его.  Для того, чтобы сделать его доступным для записи и сообщить
остальным, что вы планируете отредактировать этот файл,
используйте команду <CODE>cvs edit</CODE>.  Некоторые системы называют
это <EM>извлечение</EM>, но пользователи CVS уже используют
этот термин в смысле "получение копии исходных текстов"
(see section <A HREF="cvs-ru.html#SEC5">Получение исходного кода</A>), а эту операцию, в свою
очередь, другие системы называют <EM>взять</EM>.


<P>
<A NAME="IDX412"></A>
<DL>
<DT><U>Команда:</U> <B>cvs edit</B> <I>[ключи] файлы ...</I>
<DD><A NAME="IDX413"></A>


<P>
Подготовить для редактирования рабочие файлы.  CVS делает
<VAR>файлы</VAR> доступными для чтения и записи и уведомляет
пользователей, которые уведомления о редактировании какого-нибудь 
из указанных файлов. 


<P>
Команда <CODE>cvs edit</CODE> принимает такие же ключи командной
строки, что и команда <CODE>cvs watch add</CODE>, и устанавливает
временное слежение за <VAR>файлами</VAR> для пользователя; CVS
прекратит слежение, когда будет выполнена команда <CODE>unedit</CODE>
или команда <CODE>commit</CODE>.  Если пользователь не хочет получать
уведомления, он должен указать ключ <CODE>-a none</CODE>.


<P>
<VAR>Файлы</VAR> и ключи командной строки обрабатываются точно так же, 
как и для команды <CODE>cvs watch</CODE>.


<P>
<STRONG>Предупреждение:</STRONG> если в репозитории разрешена опция
<CODE>PreservePermissions</CODE> (see section <A HREF="cvs-ru.html#SEC174">Файл конфигурации CVSROOT/config</A>), то CVS не
будет менять прав доступа к <VAR>файлам</VAR>.  Причина этого
изменения -- убедиться, что <CODE>cvs edit</CODE> не мешает хранению
прав доступа к файлам в CVS-репозитории.


</DL>

<P>
Обычно, когда вы закончите редактирование файлов, используйте
команду <CODE>cvs commit</CODE>, которая проверит ваши изменения и
вернет файлы, за которыми производилось слежение, в обычное
состояние только для чтения.  Если же вы вместо этого решите
отменить изменения, или просто не станете ничего менять,
используйте команду <CODE>cvs unedit</CODE>.


<P>
<A NAME="IDX414"></A>
<A NAME="IDX415"></A>
<A NAME="IDX416"></A>
<DL>
<DT><U>Command:</U> <B>cvs unedit</B> <I>[<CODE>-lR</CODE>] files ...</I>
<DD><A NAME="IDX417"></A>


<P>
Отбросить все изменения в рабочих файлах <VAR>files</VAR> и привести
их в соответствие с ревизией в репозитории.  Если кто-либо
запросил уведомление об изменениях каких-либо файлов, то CVS 
делает эти файлы доступными только для чтения.  CVS
уведомляет пользователей, которые запросили уведомление о команде 
<CODE>unedit</CODE>.


<P>
Ключи командной строки и список файлов обрабатываются точно так
же, как для команды <CODE>cvs watch</CODE>.


<P>
Если слежение не используется, команда <CODE>unedit</CODE>, вероятно,
не работает, и единственный способ вернуть файл в то состояние, в 
котором он находится в репозитории -- удалить его и использовать <CODE>cvs update</CODE> для
получения новой копии.  Семантика этой операции идентична команде 
<CODE>unedit</CODE>: удаление и обновление может внести также и 
изменения, которые были помещены в репозиторий с тех пор, как вы
в последний раз обновляли свою рабочую копию.
</DL>


<P>
При использовании сетевого CVS вы можете использовать
команды <CODE>cvs edit</CODE> и <CODE>cvs unedit</CODE>, даже если CVS
не смогла успешно соединиться с сервером.  Уведомления будут
посланы при следующем успешном выполнении какой-либо команды
CVS.




<H3><A NAME="SEC92" HREF="cvs-ru.html#TOC92">Информация о том, кто следит и кто редактирует</A></H3>

<P>
<A NAME="IDX418"></A>
<DL>
<DT><U>Команда:</U> <B>cvs watchers</B> <I>[<CODE>-lR</CODE>] files ...</I>
<DD><A NAME="IDX419"></A>


<P>
Выдает список пользователей, которые отслеживают изменения в
<VAR>files</VAR>.  Сообщаются имена файлов и почтовые адреса каждого
следящего.


<P>
Ключи командной строки и список файлов обрабатываются так же, как 
и в команде <CODE>cvs watch</CODE>.


</DL>

<P>
<A NAME="IDX420"></A>
<DL>
<DT><U>Команда:</U> <B>cvs editors</B> <I>[<CODE>-lR</CODE>] files ...</I>
<DD><A NAME="IDX421"></A>


<P>
Выдает список пользователей, которые в текущий момент работают
над файлами <VAR>files</VAR>.  Сообщаются почтовые адреса
пользователей, время, когда пользователь начал работу с файлом, а 
также машина и рабочий каталог на ней, в котором находится каждый 
файл.


<P>
Список файлов и ключи командной строки обрабатываются точно так
же, как и в команде <CODE>cvs watch</CODE>.


</DL>



<H3><A NAME="SEC93" HREF="cvs-ru.html#TOC93">Использование слежений со старыми версиями CVS</A></H3>

<P>
<A NAME="IDX422"></A>
<A NAME="IDX423"></A>
Если вы используете возможность слежения за репозиторием, то в
нем создаются каталоги <TT>`CVS/'</TT>, в которых хранится информация 
о слежениях за файлами из соответствующего каталога.  Если вы
попытаетесь использовать в этом репозитории CVS версии 1.6 и 
ранее, вы получите такое сообщение об ошибке:



<PRE>
cvs update: cannot open CVS/Entries for reading:
No such file or directory
</PRE>

<P>
Выполняемая команда, скорее всего, будет прервана.  Для
использования возможности слежения обновите все копии CVS,
которые используют этот репозиторий в локальном или серверном
режиме.  Если вы не можете совершить обновление, используйте
команды <CODE>watch off</CODE> и <CODE>watch remove</CODE>, чтобы удалить все 
слежения, а затем восстановите репозиторий в состояние, с которым 
может работать @cvsver{1.6}.




<H2><A NAME="SEC94" HREF="cvs-ru.html#TOC94">Выбор между блокированными и неблокированными извлечениями</A></H2>
<P>
<A NAME="IDX424"></A>


<P>
Блокированные и неблокированные извлечения имеют свои "за" и
"против".  Достаточно сказать, что это в основном вопрос мнения,
или же принятого в группе стиле работы.  Впрочем же, вот краткое
описание некоторых возникающих вопросов.  Существует множество
способов организовать команду разработчиков.  CVS не
пытается насильно внедрить какой-либо способ. CVS -- это
просто инструмент, который можно использовать различными
способами.


<P>
Блокированные извлечения могут оказывать отрицательное влияние на 
производительность.  Если два человека хотят отредактировать
различные части файла, какие могут быть причины помешать
кому-нибудь из них сделать это?  Обычным делом также является
заблокировать файл, предполагая поредактировать его, а затем
забыть снять блокировку.


<P>
Люди, обычно те, кто хорошо знаком с блокированными извлечениями, 
обычно спрашивают, как часто случаются конфликты при
использовании неблокированных извлечений, и сколь сложно их
разрешить.  Опыт разнообразных групп показал, что такие конфликты 
случаются редко и обычно их можно разрешить относительно
спокойно.


<P>
Редкость серьёзных конфликтов может удивить, пока не осознаешь,
что они случаются только когда два разработчика расходятся во
мнениях о должном дизайне определенного куска кода; такое
расхождение свидетельствует о том, что команда, прежде всего, не
общалась друг с другом должным образом.  Для того, чтобы
сотрудничать в условиях <EM>любой</EM> системы контроля исходных
текстов, разработчики должны не иметь разногласий по поводу
общего дизайна системы; при отсутствии таковых, пересекающиеся
изменения обычно разрешаются напрямую.


<P>
В некоторых случаях неблокированные извлечения совершенно точно
являются неподходящими.  Если для файлов, которые вы
редактируете, не существует инструмента для слияния (например,
файлы, созданные текстовым процессором, или же файлы, созданные с
помощью CAD-системы), а переход на программу, которая использует
формат файлов с возможностью слияния, нежелателен, то разрешение
конфликтов, скорее всего, будет столь неприятным, что будет проще
избежать их, используя блокированные извлечения.


<P>
Возможность слежения, описанная выше, в главе section <A HREF="cvs-ru.html#SEC88">Как отследить, кто редактирует файлы?</A>,
может считаться промежуточной моделью между блокированными и
неблокированными изменениями.  Когда вы редактируете файл, можно
узнать, кто ещё редактирует его.  Система, вместо того, чтобы
просто запретить двум людям редактировать файл, может описать
ситуацию и позволить вам самому решить, является ли этот
конкретный случай проблемой или нет.  Таким образом, для
некоторых групп механизм слежения может считаться объединением
лучших черт блокированных и неблокированных изменений.




<H1><A NAME="SEC95" HREF="cvs-ru.html#TOC95">Управление ревизиями</A></H1>
<P>
<A NAME="IDX425"></A>
<A NAME="IDX426"></A>


<P>
Если вы дочитали до этого места, вы, вероятно, уже достаточно
хорошо понимаете, что может сделать для вас CVS.  В этой
главе рассказывается ещё немного о том, что вам предстоит решить
для себя.


<P>
Если вы занимаетесь разработкой в одиночку, используя CVS,
вы, вероятно, можете пропустить эту главу.  Вопросы, поднимаемые
в этой главе, становятся важны, когда с репозиторием работает
более одного пользователя.




<H2><A NAME="SEC96" HREF="cvs-ru.html#TOC96">Когда фиксировать изменения?</A></H2>
<P>
<A NAME="IDX427"></A>
<A NAME="IDX428"></A>
<A NAME="IDX429"></A>


<P>
В вашей группе должны решить, какую политику применять по
отношению к фиксированию изменений.  Возможно несколько подходов,
и вы, вероятно, найдете тот, что устраивает вас, по мере
наращивания опыта.


<P>
Если вы фиксируете изменения слишком быстро, вы можете
зафиксировать файлы, которые даже не будут компилироваться.  Если
ваш партнер обновит свою рабочую копию, в ней появится ваш файл с
ошибкой, и он не сможет скомпилировать проект.  С другой стороны,
если вы будет фиксировать изменения очень редко, то другие
участники не смогут воспользоваться вашими улучшениями, и
конфликты станут появляться чаще.


<P>
Обычно изменения фиксируются, убедившись, по крайней мере, что
измененные файлы компилируются.  В некоторых организациях
требуют, чтобы файлы прошли серию тестов.  Подобную политику
можно вести с помощью файла <TT>`commitinfo'</TT> (see section <A HREF="cvs-ru.html#SEC163">Файл <TT>`commitinfo'</TT></A>), но следует дважды подумать, прежде чем установить
такое требование.  Чрезмерно увеличив контроль над разработкой,
можно добиться отрицательного воздействия на процесс достижения
цели, то есть написание работающего продукта.




<H1><A NAME="SEC97" HREF="cvs-ru.html#TOC97">Подстановка ключевых слов</A></H1>
<P>
<A NAME="IDX430"></A>
<A NAME="IDX431"></A>
<A NAME="IDX432"></A>
<A NAME="IDX433"></A>
<A NAME="IDX434"></A>


<P>
Пока вы редактируете исходные файлы в рабочем каталоге, вы всегда
можете узнать их статус с помощью <SAMP>`cvs status'</SAMP> и <SAMP>`cvs
log'</SAMP>.  Как только вы экспортируете файлы из вашей среды
разработки, становится гораздо сложнее узнать, какую ревизию
имеют эти файлы.


<P>
Для того, чтобы помочь в идентификации файлов, CVS может
использовать механизм, известный как <EM>подстановка ключевых
слов</EM> (или <EM>замена ключевых слов</EM>).  Строки вида
<CODE>$<VAR>ключевое_слово</VAR>$</CODE> и
<CODE>$<VAR>ключевое_слово</VAR>:...$</CODE> в файле заменяются строками
вида <CODE>$<VAR>ключевое_слово</VAR>:<VAR>значение</VAR>$</CODE> каждый раз,
когда вы получаете новую ревизию файла.




<H2><A NAME="SEC98" HREF="cvs-ru.html#TOC98">Список ключевых слов</A></H2>
<P>
<A NAME="IDX435"></A>


<P>
Вот список ключевых слов:


<DL COMPACT>

<DT><CODE>$Author: ax222 $</CODE>
<DD>
<A NAME="IDX436"></A>
 <A NAME="IDX437"></A>
 
Имя пользователя, который поместил ревизию в репозиторий.

<A NAME="IDX438"></A>
<A NAME="IDX439"></A>
<DT><CODE>$Date: 2002/02/06 13:29:56 $</CODE>
<DD>
Дата и время (в UTC), когда была зафиксирована ревизия.

<A NAME="IDX440"></A>
<A NAME="IDX441"></A>
<DT><CODE>$Header: /export/home/cvs/quality/guidelines_tools/cvs_doc/cvs-ru.htm,v 1.1 2002/02/06 13:29:56 ax222 Exp $</CODE>
<DD>
Стандартный заголовок, содержащий полное имя RCS-файла,
номер ревизии, дату в UTC, имя автора, состояние и имя
пользователя, заблокировавшего этот файл (если файл
заблокирован).  Файлы обычно не блокируются при использовании
CVS.

<A NAME="IDX442"></A>
<A NAME="IDX443"></A>
<DT><CODE>$Id: cvs-ru.htm,v 1.1 2002/02/06 13:29:56 ax222 Exp $</CODE>
<DD>
Точно так же, как <CODE>$Header: /export/home/cvs/quality/guidelines_tools/cvs_doc/cvs-ru.htm,v 1.1 2002/02/06 13:29:56 ax222 Exp $</CODE>, только имя
RCS-файла указано без полного пути.

<A NAME="IDX444"></A>
<A NAME="IDX445"></A>
<DT><CODE>$Name:  $</CODE>
<DD>
Имя метки, использованной при извлечении этого файла.  Это
ключевое слово подставляется, только если при извлечении было
явно задано имя метки.  Например, при выполнении команды
<CODE>cvs co -r first</CODE> это ключевое слово заменяется на
<SAMP>`Name: first'</SAMP>.

<A NAME="IDX446"></A>
<A NAME="IDX447"></A>
<DT><CODE>$Locker:  $</CODE>
<DD>
Имя пользователя, который заблокировал эту ревизию (пустое, если
файл не заблокирован, как обычно и бывает, если не использовалась
команда <CODE>cvs admin -l</CODE>).

<A NAME="IDX448"></A>
<A NAME="IDX449"></A>
<DT><CODE>$Log: cvs-ru.htm,v $
<DT><CODE>Revision 1.1  2002/02/06 13:29:56  ax222
<DT><CODE>Документация по CVS с http://alexm.here.ru/cvs-ru/cvs-ru.html
<DT><CODE></CODE>
<DD>
Журнальное сообщение, которое было введено во время фиксации
изменений, перед которым идет имя RCS-файла, номер ревизии,
имя автора и дата в UTC.  Существующие журнальные сообшения
<EM>не</EM> заменяются.  Вместо этого, новое журнальное сообщение
добавляется после <CODE>$Log:...$</CODE>.  Каждая новая
строка содержит в начале ту же самую строку, которая находится
перед ключевым словом <CODE>$Log$</CODE>.  Например, если в
файле находится


<PRE>
  /* Here is what people have been up to:
   *
   * $Log: cvs-ru.htm,v $
   * Revision 1.1  2002/02/06 13:29:56  ax222
   * Документация по CVS с http://alexm.here.ru/cvs-ru/cvs-ru.html
   *
   * Revision 1.1  1997/01/03 14:23:51  joe
   * Add the superfrobnicate option
   *
   */
</PRE>

то перед дополнительными строками, которые добавляются при замене
ключевого слова <CODE>$Log$</CODE>, будет находиться 
<SAMP>`   * '</SAMP>.  В отличие от предыдущих версий CVS и
RCS, <EM>префикс комментария</EM> из RCS-файла не
используется.  Ключевое слово <CODE>$</CODE>Log$ полезно при накоплении
полного журнала изменений в исходном файле, но по нескольким
причинам это может привести к определенным проблемам.
See section <A HREF="cvs-ru.html#SEC102">Проблемы с ключевым словом $Log$.</A>.

<A NAME="IDX450"></A>
<A NAME="IDX451"></A>
<DT><CODE>$RCSfile: cvs-ru.htm,v $</CODE>
<DD>
Имя RCS-файла без полного пути.

<A NAME="IDX452"></A>
<A NAME="IDX453"></A>
<DT><CODE>$Revision: 1.1 $</CODE>
<DD>
Номер ревизии.

<A NAME="IDX454"></A>
<A NAME="IDX455"></A>
<DT><CODE>$Source: /export/home/cvs/quality/guidelines_tools/cvs_doc/cvs-ru.htm,v $</CODE>
<DD>
Полное имя RCS-файла.

<A NAME="IDX456"></A>
<A NAME="IDX457"></A>
<DT><CODE>$State: Exp $</CODE>
<DD>
Состояние, присвоенное ревизии.  Состояния могут назначаться с
помощью <CODE>cvs admin -s</CODE> -- см. section <A HREF="cvs-ru.html#SEC119">Ключи команды admin</A>.

</DL>



<H2><A NAME="SEC99" HREF="cvs-ru.html#TOC99">Использование ключевых слов</A></H2>

<P>
Для того, чтобы поместить в файл ключевое слово, вы просто пишете
в нём, например, <CODE>$Id: cvs-ru.htm,v 1.1 2002/02/06 13:29:56 ax222 Exp $</CODE>, а затем фиксируете файл.
CVS автоматически заменит ключевое слово во время операции
фиксирования.


<P>
Обычной практикой является помещение строки <CODE>$</CODE>Id$ в
исходные файлы, чтобы они оказались в скомпилированных объектных
файлах.  Например, если вы управляете исходными текстами
программы, вы можете создать переменную, в которую при
инициализации попадает строка с <CODE>$</CODE>Id$.  Некоторые
компиляторы языка C поддерживают директиву <CODE>#pragma ident</CODE>.
Система управления документами может обеспечивать способ для
передачи этой строки в результирующие файлы.


<P>
<A NAME="IDX458"></A>
<A NAME="IDX459"></A>
Программа <CODE>ident</CODE>, являющаяся частью пакета RCS, может
использоваться для извлечения из файла ключевых слов и их
значений.  Это полезно и для работы с текстовыми файлами, но
особенно полезно для извлечения ключевых слов из двоичных файлов.



<PRE>
$ ident samp.c
samp.c:
     $Id: cvs-ru.htm,v 1.1 2002/02/06 13:29:56 ax222 Exp $
$ gcc samp.c
$ ident a.out
a.out:
     $Id: cvs-ru.htm,v 1.1 2002/02/06 13:29:56 ax222 Exp $
</PRE>

<P>
<A NAME="IDX460"></A>
<A NAME="IDX461"></A>
SCCS -- еще одна популярная система контроля ревизий.  В её
состав входит программа <CODE>what</CODE>, очень похожая на
<CODE>ident</CODE> и использующаяся в тех же целях.  Во многих местах,
где не установлен пакет RCS, стоит SCCS.  Так как
<CODE>what</CODE> ищет последовательность символов <CODE>@(#)</CODE>, то
можно довольно просто вставлять ключевые слова, которые
обнаруживаются обеими программами.  Просто поместите перед
ключевым словом в стиле RCS в