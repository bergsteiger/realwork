uses MenuWork, States, FileWork, RunPrograms, exceptions, DocumentWork, SettingsWork, ListWork, Clicks;

const
  PRODUCT_VERSION_BRANCH = 1;
  PRODUCT_VERSION_HEAD = 2;
  PRODUCT_VERSION_DEFAULT = PRODUCT_VERSION_HEAD;                                               

var
  gbl_ProductVersion; 
var
  OBJ_CACHE : OleVariant;

const
  EndOfLine = #13#10;
  SYMBOLS_100 = '1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890';
  DELIM_CHAR = '\';

  GRAY_PLUS   = '[X107]'; // VK_ADD
  GRAY_MINUS  = '[X109]'; // VK_SUBTRACT
  KEY_EXPAND_FOLDER = GRAY_PLUS;
  KEY_COLLAPSE_FOLDER = GRAY_MINUS;

  LOG_PRIORITY_INTERNAL = 784;
      
  MIN_RUN_DELAY = 10;
  MAX_COPY_ATTEMPTS = 10;                     // максимальное количество попыток копирования в буфер для ряда скриптов
  MAX_WINDOWS = 10;                           // максимальное количество окон оболочки
  MAX_WINDOW_TABS = 10;                       // максимальное количество оконных вкладок в оболочке
  VAR_VARIANT_ARRAY = varArray OR varVariant; 

  F1SERVICENAME = 'GARANT.Application.Server';
  LAUNCHERNAME = 'garant.exe';
  
  MAINWINDOW_CAPTION = 'ГАРАНТ аэро';
  
  SA_START_F1SHELL = 'Запускает оболочку';
  SA_CLOSE_F1SHELL = 'Закрывает оболочку';
  SA_START_F1ADMIN = 'Запускает модуль Админа';  
  SA_CLOSE_F1ADMIN = 'Закрывает модуль Админа';
  SA_KILL_F1SHELL = 'Убивает оболочку';
  SA_LOGIN_INTO_SHELL = 'Логиниться в оболочку';
  SA_START_F1SERVER = 'Запускает сервер';
  SA_STOP_F1SERVER = 'Останавливает сервер';
  SA_SWITCH_DATABASE = 'Переключает базу';
  SA_INSTALL_DATABASE = 'Устанавливает базу';
  SA_DO_PPR_SEARCH = 'Делает ППР';
  SA_DO_PPS_SEARCH = 'Делает ППС';
  SA_DO_PPIO_SEARCH = 'Делает ППИО';
  SA_USE_MSOFFICE = 'Использует MSOffice';
  SA_USE_INSTALLER = 'Использует инсталлятор';
  SA_LONG_SCRIPT = 'Длительный скрипт';       // для возможности фильтрации таковых при запуске на базе Супер
                      
//заголовки функций
function IsCheckInfoAdded(  const obj : OleVariant) : boolean;forward;
function CheckObjectParams(  const obj : OleVariant;  const propNames : OleVariant;  const propValues : OleVariant) : boolean;forward;
function DbgVarValue(  const value : OleVariant;  const varName : String;  const isStrValue : boolean = true) : String;forward;
function VarConvert(  const source : OleVariant;  const toWhat : OleVariant) : OleVariant;forward;
function IsMap( const mapObject : OleVariant) : boolean;forward;
function GetLogAttr(what : String ): OleVariant;forward;
function GetFromAttributeSelect(whatToGet : String; parent : OleVariant = nil; const addParams : String = '') : OleVariant; forward;
function ConvertArrayToString(arr : OleVariant; format : String = 'ВСЕ В ОДНУ СТРОКУ';indent : String = '') : String;forward;
function KeyPause: string;forward;
function GetValueFromEdit: string;forward;
procedure DoScreenShot ( const msg : String; const extMsg : String = ''; const localVarName : String = 'DO_FULL_SCREEN_SHOT' ) ; forward;
function IsExists ( const obj : OleVariant )  : boolean; forward;
function IsTrue ( const obj : OleVariant )  : boolean; forward;
function GetWinDirectory   : String; forward;
function GetTempDirectory   : String; forward;
function GetWindowText( wndHandle : integer ) : String; forward;
procedure ResetUserInactivity; forward;
function PosN ( const what : String; where : String; const startPos : integer = 1 )  : integer; forward;
function StringCompare ( what; where : String; options : integer = -1 )  : boolean; forward;
function RevertString ( const str: String )  : String; forward;
function GetSubStr ( const source : String; const before : String; const after : String )  : String; forward;
function PosAnyChar ( const char : String; const str : String )  : integer; forward;
function GetRandomString ( length : integer = 12 )  : String; forward;
function CompareString2Log ( const String1 : String; const String2: String; const CaseSensitive: boolean = True )  : Boolean; forward;
function PosCI ( what : String; where : String )  : integer; forward;
function UnBracket ( const str : String; const leftBracket : String = '('; const rightBracket : String = ')' )  : String; forward;
function GetValueByKey ( const inStr : String; const strKey:  String )  : String; forward;
function GetValueFromCmdLine ( const strKey: String ) : String; forward;
function GetFromContextFilterForm( whatToGet : String;  parent : OleVariant) : OleVariant; forward;
function Position_by_Text (
  focused_w: OleVariant;
  sText: String;
  isUpDirection: boolean = false;
  isUseStringCompare : boolean = false
) : OleVariant; forward;
function Position_Internal( const treeWnd : OleVariant; const path : String; const delimiter : String = '\'; const isUseStringCompare : boolean = false; const paramString : String = '' ) : boolean; forward;
function CollapseTree ( wnd: OleVariant; sText: String ): boolean; forward;
function CollapseTreeInNavigator( path: String ): boolean; forward;
function CheckContextTreeElements ( Tree: OleVariant; const Context: String ; numOfLines: Integer  = -1)  : boolean; forward;
function GetElementsFromTree ( Tree: OleVariant; const bExpand: Boolean = False; const paramString : String = '' )  : OleVariant; forward;
function CompareArray ( const Array1, Array2: OleVariant; const isReport : boolean = true; const isUseStringCompare : boolean = false )  : Boolean; forward;
function CountElementInTree ( Tree: OleVariant )  : integer; forward;
function CountElementInList ( const List: Window )  : longint; forward;
function GetCurrentElementNumberInList ( const List: Window ): longint; forward;
function GetRelevanceForCurrentElementInList ( const List: Window ): longint; forward;
function Bool2Str ( b: Boolean )  : string; forward;
function DelWithConfirm( const FromPopupMenu: Boolean = False; const wndWithMenu : OleVariant = ''): boolean; forward;
function GetObjectHintText ( targetWindow : OleVariant; pathToImage: string; dx, dy : integer = 0)  : String; forward;
function MoveMouseToObject ( targetWindow : OleVariant; pathToImage: string; dx : integer = 0; dy : integer = 0; click : boolean = false; buttonId : integer = 0; rectX: integer = 0; rectY: integer = 0)  : boolean; forward;
procedure ClipboardClean  ; forward;
procedure DeleteElementFromArray ( var InArray; const Index: integer ) ; forward;
function FindElement ( const InArray: OleVariant; const Element: OleVaraint; const isUseStringCompare : boolean = false )  : Boolean; forward;
procedure SortArray ( var InArray: OleVariant ) ; forward;
function AddArrays ( const Array1 : OleVariant; const Array2 : OleVariant )  : OleVariant; forward;
function IsArray ( const arr : OleVariant )  : boolean; forward;
function AddToArray ( var arr : OleVariant; const value : OleVariant )  : integer; forward;
function String2Array ( const sText: String; const sDelimeter: String = EndOfLine )  : OleVariant; forward;
function FindWindowByParams ( const parent : OleVariant; const paramString : String; const paramDelimiter : String = ';' )  : OleVariant; forward;
function FindWindowByPath(const parent : OleVariant; const path : String; const isThrowException : boolean = true; paramString : String = ''; const paramGroupDelimiter : String = '|'): OleVariant;forward;
function GetMainWindow ( const additionalParams : String = '' )  : OleVariant; forward;
function GetFilterTree : Window; forward;
function GetFromList( whatToGet : String; parent : OleVariant = nil; mainWnd : OleVariant = nil) : OleVariant;forward;
function GetList   : Window; forward;
function GetFromSynchroView ( whatToGet : String; parent : OleVariant = nil )  : OleVariant; forward;
function GetEditorInSynchroView   : Window; forward;
function GetFromDictionary ( whatToGet : String; const addParams : String = '' )  : OleVariant; forward;
function GetFromEditor(   whatToGet : String;   parent : OleVariant = nil;   mainWnd : OleVariant = nil) : OleVariant; forward;
function GetFromAnalyticReview ( whatToGet : String )  : OleVariant; forward;
function GetFromPPR ( whatToGet : String )  : OleVariant; forward;
function GetFromPPS ( whatToGet : String )  : OleVariant; forward;
function GetFromPPS_Light( whatToGet : String) : OleVariant;forward;
function GetFromPPIO ( whatToGet : String )  : OleVariant; forward;
function GetFromNavigator ( whatToGet : String; mainWnd : OleVariant = nil )  : OleVariant; forward;
function GetFolderTree   : Window; forward;
function GetFromMainWindow ( whatToGet : String; const addParams : String = ''; parent : OleVariant = nil )  : OleVariant; forward;
function GetToolbarButton ( const toolBarWindow : OleVariant; const buttonCaption : String; const isThrowException : boolean = true )  : boolean; forward;
function ClickToolbarButton(const toolBarWindow : OleVariant; const buttonCaption : String; const paramString : String = ''; const isThrowException : boolean = true)  : OleVariant;forward;
function SwitchToPage ( const pageControl : OleVariant; const pageName : String; const isUseTabIndex : boolean = true; const paramString : String = ''; const paramDelimiter : String = ';' )  : boolean; forward;
function SwitchToNavigatorPage ( const pageName : String; const isUseTabIndex : boolean = true; const paramString : String = ''; const paramDelimiter : String = ';' )  : boolean; forward;
function ActivatePage ( const PageName; const pageControlWnd : OleVariant = nil; const KeyNext: string = '[Right]'; const KeyPrev: string = '[Left]' )  : Boolean; forward;
function GetListOfAllDocuments   : OleVariant; forward;
function RunProcess ( exeFile : String ; comStr : String = '' ; runTimeout : integer = 60000 )  : boolean; forward;
function IsWin9x   : boolean; forward;
procedure PressKeyNCount ( key : string; count : integer ) ; forward;
function Intersection ( const arr1 : OleVariant; const arr2 : OleVariant )  : OleVariant; forward;
procedure SortArrayEx ( var inArray: OleVariant; const Criteria : String = 'y > x' ) ; forward;
function GetFromArray ( const arr : OleVariant; const index : integer )  : OleVariant; forward;
function DeleteElementFromArrayByValue ( arr : OleVariant; const value : OleVariant )  : OleVariant; forward;
function Array2String ( const arr : OleVariant; const delimiter : String = ';'; const isSubArrProcess : boolean = false )  : String; forward;
function ArrayLength ( const arr : OleVariant;  const dimension : integer = 1 )  : integer; forward;
function Difference ( arr1 : OleVariant; arr2 : OleVariant )  : OleVariant; forward;
function Map ( var mapObject : OleVariant; const whatToDo : String; const key : OleVariant; const value : OleVariant = ''; const isUsePlugin : boolean = true  )  : OleVariant; forward;
function ConfirmWindow ( const buttonName: String = '-р' )  : Boolean; forward;
function IsEmpty ( const obj : OleVariant )  : boolean; forward;
function GetUniqueArray ( arr : OleVariant )  : OleVariant; forward;
function GetNonUniqueArray ( arr : OleVariant )  : OleVariant; forward;
function GetValueFromGarantINI ( const section : String; const key : String; pathToFile : String = '' ) : String; forward;
function SetValueToGarantINI ( const section : String; const key : String; const value : String; const createIfAbsent : boolean = false; pathToFile : String = '' )  : boolean; forward;
function CloseAllProcess ( const prcName : String; const isTerminate : boolean = true; const waitTime : integer = 0 )  : integer; forward;
function GetNonEmpty ( const value1 : OleVariant; const value2 : OleVariant )  : OleVariant; forward;
function ParseParamString ( const paramString : String; const upCaseParamNames : boolean = true; const paramDelimiter : String = ';';  const paramValueDelimiter : String = ':=' )  : OleVariant; forward;
function GetParam ( paramList : OleVariant; paramName : String; const defaultValue : OleVariant = ''; const upCaseParamNames : boolean = true )  : String; forward;
function WaitForConfirmationWindow(timeOut : integer = -1; buttonName: OleVariant = 'Да'; const messageSubstring : String = ''; const setCheckbox : String = '') : String;forward;
function GetFromShell(whatToGet : String;timeOut : integer =-1; const addParams : String = '') : OleVariant;forward;
function GetToolbarObject( const toolBarWindow : OleVariant; objType : String; const objCaption : String; const isThrowException : boolean = true)  : boolean;forward;
procedure StartTimeMeasure(const opName : String; const isLogMessage : boolean = true);forward;
function EndTimeMeasure( const opName : String; const isLogMessage : boolean = true; const comment : String = ''; const csvFileName : String = '') : integer;forward;
function SetParam(var paramList : OleVariant; paramName : String; const value : OleVariant = ''; const upCaseParamNames : boolean = true ) : OleVariant;forward;
function Permissions( whatToDo : String; name : String; const value : OleVariant = false) : boolean;forward;
function IsEqual(  const var1 : OleVariant;  const var2 : OleVariant) : boolean; forward;
function IsWndEqual(  wnd1 : OleVariant;  wnd2 : OleVariant) : boolean;forward;
function NonExObj : OleVariant; forward;
function OpenItemInTasksPanel(  groupName: string;  itemName: string; const paramString : string = ''): boolean; forward;
function Sys_Desktop : OleVariant;forward;
function Sys_: OleVariant;forward;
function GetGlobalParam( const paramName : String; const defaultValue : OleVariant = '') : OleVariant;forward;
function SetGlobalParam( const paramName : String; const value : OleVariant = '') : OleVariant;forward;
function ScriptAction( whatToDo : String;  param : OleVariant = nil): OleVariant;forward;
function GetFromStyleEditor( whatToGet : string;  parent : OleVariant = nil): OleVariant;forward;
function ProductVersion( whatToDo : String = 'get'; const value : integer = PRODUCT_VERSION_DEFAULT): OleVariant; forward;
function GetFromInfarmListFirms( whatToGet : String; const addParams : String = '') : OleVariant; forward;
function GetFromAccessibleOperationTB(  whatToGet : String;  parent : OleVariant = nil) : OleVariant; forward;
function DbgVarValueEx( const values : OleVariant; const varNames : OleVariant; const isStrValue : boolean = true ) : String; forward;
function GetProcessFromWnd( const wnd : OleVariant): OleVariant;forward;
function GetFromBaseSearch( whatToGet : String;  parent : OleVariant = nil) : OleVariant; forward;
function SynchroObjectsParams( whatToDo : String;  paramName : String; value : OleVariant = '___NOT_INITIALIZED___'): OleVariant;forward;
function GetFromFolderForm( whatToGet : String;  parent : OleVariant; const addParams : String = '') : OleVariant; forward;
function CalcXYToParentVgSceneObj( const vgObj: OleVariant;  var x: integer;  var y: integer) : boolean; forward;
function FindParentVgSceneObj( const vgObj: OleVariant) : OleVariant; forward;
function ClickOnVgSceneObject( const vgObj : OleVariant; const paramString : String = '') : boolean; forward;

var
  gbl_FSO : OleVariant;

const
  FSO_FOR_READING = 1;
  FSO_FOR_WRITING = 2;
  FSO_FOR_APPENDING = 8;   
{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function FSO : OleVariant ;
  const
    FUNCTION_NAME = 'FSO';
begin
  try
    if (VarType(gbl_FSO) <> varDispatch) then
      gbl_FSO := Sys.OleObject('Scripting.FileSystemObject');
    Result := gbl_FSO;    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

var
  gbl_ShellWatchdog : OleVariant;
  gbl_IsShellWatchdogStarted : Boolean;
{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function ShellWatchdog(
  whatToDo : String
): boolean;
  const
    FUNCTION_NAME = 'ShellWatchdog';
begin
  try
    if (VarType(gbl_ShellWatchdog) <> varDispatch) then
      gbl_ShellWatchdog := QCPlugin.ShellWatchdog;
    if (VarType(gbl_IsShellWatchdogStarted) <> varBoolean) then
      gbl_IsShellWatchdogStarted := false;  
    //
    whatToDo := AnsiUpperCase(whatToDo);
    case whatToDo of
      'START':
        with gbl_ShellWatchdog do
        begin
          IsKillShell := true;
          HangTimeout := Options.Run.Timeout * 2;
          gbl_IsShellWatchdogStarted := Start;
          Result := gbl_IsShellWatchdogStarted;          
        end;
      'STOP' :
        begin
          gbl_ShellWatchdog.Stop;
          gbl_IsShellWatchdogStarted := false;
        end;
      'HAS STARTED' :
        Result := gbl_IsShellWatchdogStarted;    
      'UPDATE TIMEOUT' :
        begin
          gbl_ShellWatchdog.HangTimeout := Options.Run.Timeout * 2;
        end;  
    else
      Raise('Неизвестный whatToDo: ' + VarToString(whatToDo));  
    end;    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    //Raise;
  end; 
end;

var
  gbl_IsUseProcessKiller : boolean;  
{
  TYPE: 
  DESC: 
  RESULT:
  REMARK:
}
procedure SetProcessKillerMode(
  mode : boolean
);
  const
    FUNCTION_NAME = 'SetProcessKillerMode';
begin
  try
    gbl_IsUseProcessKiller := mode;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;  
   
  
var 
  gbl_ProcessKillerMap : OleVariant;  
{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function GetProcessKiller(
  key : String
): OleVariant;
  const
    FUNCTION_NAME = 'GetProcessKiller';
begin
  try
    key := AnsiUpperCase(key);
    Result := Map(gbl_ProcessKillerMap, 'get', key);
    if IsEmpty(Result) OR (VarType(Result) <> varDispatch) then
    begin
      Result := QCPlugin.ProcessKiller;
      Map(gbl_ProcessKillerMap, 'put', key, Result);
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValueEx([key, Result], ['key', 'Result']), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
procedure ProcessKiller(
  key : String; // уникальный ключ-идентификатор убивалки 
  opName : String; // операция
  const delay : Integer = -1; // задержка. Через это времия процесс будет убит (если убивалка не будет остановлена ранее)
  const obj : OleVariant = nil // процесс или окно, от которого потом получим процесс
);
  const
    FUNCTION_NAME = 'ProcessKiller';
  var
    procID : Integer;
    processKiller : OleVariant;  
begin
  try
    if ((VarType(gbl_IsUseProcessKiller) = varBoolean) AND gbl_IsUseProcessKiller) then
    begin
      key := AnsiUpperCase(key);
      opName := AnsiUpperCase(opName);
      processKiller := GetProcessKiller(key);        
      //  
      case opName of
        'START':  // запускаем убивалку процесса
          begin
            if NOT IsExists(obj) then Raise('obj не существует!');
            procID := GetProcessFromWnd(obj).ProcessID;
            //
            processKiller.Stop;
            //
            //processKiller.Delay := delay;
            // принудительно задаем время 30 минут, чтобы ProcessKiller не срабатывал раньше времени, а также чтобы не менять весь код  
            processKiller.Delay := 30*60*1000;
            //
            processKiller.PID := procID;
            processKiller.Start;
          end;
        'STOP' : // останавливаем убивалку процесса
          processKiller.Stop;              
      else
        Raise('Неизвестный opName!');
      end;
    end;    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));    
  end; 
end;

const
  CACHE_CHECK_INFO_ID = 'Это идентификатор структуры для проверки при возврате из кеша';
function IsCheckInfoAdded(
  const obj : OleVariant
) : boolean;
begin
  Result := IsMap(obj) AND (GetParam(obj, 'ID', '') = CACHE_CHECK_INFO_ID);
end; 

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function Cache_RootObj: OleVariant;
  const
    FUNCTION_NAME = 'Cache_RootObj';
begin
  try
    Result := Sys_;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

var gbl_CacheObject : OleVariant;

const
  CACHE_OBJ_TYPE_WINDOW = 1;
  CACHE_OBJ_TYPE_PROCESS = 2;
  CACHE_OBJ_TYPE_ROOT = 3;
  
function Cache_GetObjectID(
  const obj : OleVariant;
  var objType : OleVariant
) : OleVariant;
  const
    FUNCTION_NAME = 'Cache_GetObjectID';
begin
  try
    if IsSupported(obj, 'WindowToScreen') or IsSupported(obj, 'VCLClass') then
    begin // окно
      objType := CACHE_OBJ_TYPE_WINDOW;
      Result := 'win' + VarToStr(obj.Id);
    end // процесс
    else if IsSupported(obj, 'Terminate') then
    begin
      objType := CACHE_OBJ_TYPE_PROCESS;
      Result := 'proc' + VarToStr(obj.Id);
    end // Sys
    else if IsSupported(obj, 'CPUCount') then
    begin
      objType := CACHE_OBJ_TYPE_ROOT;
      Result := 'root' + VarToStr(obj.Id);
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end; 
end;

const
  CACHE_FIELD_ID_OBJECT = 'CACHE_ID_OBJECT';
  CACHE_FIELD_ID_OBJECT_TYPE = 'CACHE_ID_OBJECT_TYPE';
  CACHE_FIELD_ID_OBJECT_ID = 'CACHE_ID_OBJECT_ID';
  CACHE_FIELD_ID_CHILDS = 'CACHE_ID_CHILDS'; 
  CACHE_FIELD_ID_CHECKINFO = 'CACHE_ID_CHECKINFO'; 

function Cache_CreateObjectMap(
  const obj : OleVariant
): OleVariant;
  const
    FUNCTION_NAME = 'Cache_CreateObjectMap';
  var
   objID, objType, objMap : OleVariant;
begin
  try         
    objID := Cache_GetObjectID(obj, objType);
    
    // создаем мапу
    Map(objMap, 'put', CACHE_FIELD_ID_OBJECT,      obj);
    Map(objMap, 'put', CACHE_FIELD_ID_OBJECT_ID,   objID);
    Map(objMap, 'put', CACHE_FIELD_ID_OBJECT_TYPE, objType);
    
    // добавляем ее в главный кэш
    Map(gbl_CacheObject, 'put', objID, objMap);
    
    Result := objMap;             
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(obj, 'obj'),  pmNormal, GetLogAttr('EXCEPTION'));
  end; 
end;  
  
function Cache_GetObjectMap(
  const objID : OleVariant
): OleVariant;
  const
    FUNCTION_NAME = 'Cache_GetObjectMap';
begin
  try
    Result := Map(gbl_CacheObject, 'get', objID);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(objID, 'objID'),  pmNormal, GetLogAttr('EXCEPTION'));
  end; 
end;

procedure Cache_DropCacheFor(
  const objID : OleVariant
);
  const
    FUNCTION_NAME = 'Cache_DropCacheFor';
  var
    objMap, childsMap : OleVariant; 
    childsIDArr : OleVariant;
    i : integer;   
begin
  try 
    // получаем мапу для объекта
    objMap := Cache_GetObjectMap(objID);
    if NOT IsMap(objMap) then Exit; // типа если мапы нет, то выходим
    
    // получаем мапу детей    
    childsMap := Map(objMap, 'get', CACHE_FIELD_ID_CHILDS);
    
    // очищаем мапу объекта
    Map(objMap, 'clear', nil);    
    // удаляем ее из главного кэша
    Map(gbl_CacheObject, 'clear by key', objID);
    
    // теперь удаляем детей
    if IsMap(childsMap) then
    begin
      childsIDArr := Map(childsMap, 'keys array', nil); // получаем массив ID детей
      // последовательно сносим всех детей
      for i := VarArrayLowBound(childsIDArr, 1) to VarArrayHighBound(childsIDArr, 1) do
        Cache_DropCacheFor(childsIDArr[i]);
      Map(childsMap, 'clear', nil);      
    end;
            
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(objID, 'objID'),  pmNormal, GetLogAttr('EXCEPTION'));
  end; 
end;

{
  TYPE:
  DESC: Проверяет на валидность закешированный объкт по его ID.   
  RESULT:
    true - если объект с ID в кеше существует и валиден
    false - если объекта нет, или он не валиден (в этом случае объект из кеша удаляется)
  REMARK:
}  
function Cache_CheckObj(
  const objID : OleVariant;
  const obj : OleVariant = nil // если этот параметр передан, то проверяем соответствие кэшированного и переданного объекта
): boolean;
  const
    FUNCTION_NAME = 'Cache_CheckObj';
  var
    objMap, cachedObj, cacheCheckInfo, objType, propNames, propValues : OleVariant;    
begin
  try   
    Result := false;
    // получаем мапу для объекта
    objMap := Cache_GetObjectMap(objID);
    if NOT IsMap(objMap) then Exit;    
    // получаем закешированный объект    
    cachedObj := Map(objMap, 'get', CACHE_FIELD_ID_OBJECT);
    // проверяем 
    objType := Map(objMap, 'get', CACHE_FIELD_ID_OBJECT_TYPE);
    case objType of
      CACHE_OBJ_TYPE_WINDOW  : Result := ((obj = nil) AND IsExists(cachedObj)) OR ((obj <> nil) AND IsWndEqual(cachedObj, obj));
      CACHE_OBJ_TYPE_PROCESS : Result := IsValidProcess(cachedObj) AND ((obj = nil) OR ((obj <> nil) AND (cachedObj.ID=obj.ID) AND IsValidProcess(obj) ));
      CACHE_OBJ_TYPE_ROOT    : Result := true;
    else
      Raise('Неизвестный тип объекта!');
    end;
    
    if Result then
    begin
      cacheCheckInfo := Map(objMap, 'get', CACHE_FIELD_ID_CHECKINFO);
      if IsMap(cacheCheckInfo) then
      begin
        propNames :=  GetParam(cacheCheckInfo, 'PROPNAMES');
        propValues := GetParam(cacheCheckInfo, 'PROPVALUES');
        Result := Result AND CheckObjectParams(cachedObj, propNames, propValues);
      end;
    end;
    
    if NOT Result then
      Cache_DropCacheFor(objID);

  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(objID, 'objID') + DbgVarValue(obj, 'obj') ,  pmNormal, GetLogAttr('EXCEPTION'));
  end; 
end;

function Cache_Put(
  const parent : OleVariant;
  const key : OleVariant;
  const obj : OleVariant    
): OleVariant;
  const
    FUNCTION_NAME = 'Cache_Put';
  var
    parentMap, parentID, parentType, childsMap : OleVariant;
    objMap, objID, objType : OleVariant;
    cacheCheckInfo : OleVariant;
begin
  try
    if (parent = nil) then parent := Cache_RootObj;
    
    if NOT IsExists(parent) then Raise('Родителя не существует!');
      
    if IsCheckInfoAdded(obj) then
    begin
      SetParam(cacheCheckInfo, 'PROPNAMES', GetParam(obj, 'PROPNAMES'));
      SetParam(cacheCheckInfo, 'PROPVALUES', GetParam(obj, 'PROPVALUES'));
      obj := GetParam(obj, 'OBJECT');      
    end;      
    if NOT IsExists(obj) then Raise('Объект не существует!');
    
    // получаем идентификаторы  
    objID := Cache_GetObjectID(obj, objType);
    parentID := Cache_GetObjectID(parent, parentType);
    
    // получаем мапу для родителя
    if NOT Cache_CheckObj(parentID, parent) then
      parentMap := Cache_CreateObjectMap(parent)
    else
      parentMap := Cache_GetObjectMap(parentID);

    // получаем мапу для объекта
    if NOT Cache_CheckObj(objID, obj) then
      objMap := Cache_CreateObjectMap(obj)
    else
      objMap := Cache_GetObjectMap(objID);

    if IsMap(cacheCheckInfo) then
      Map(objMap, 'put', CACHE_FIELD_ID_CHECKINFO, cacheCheckInfo); 
    
    // добавляем объект к детям родителя     
    childsMap := Map(parentMap, 'get', CACHE_FIELD_ID_CHILDS);
    if NOT IsMap(childsMap) then
    begin
      Map(childsMap, 'put', objID, nil );
      Map(parentMap, 'put', CACHE_FIELD_ID_CHILDS, childsMap );
    end
    else
      Map(childsMap, 'put', objID, objMap );
    Map(parentMap, 'put', key, objMap);
    
    Result := obj;      
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(parent, 'parent') + DbgVarValue(key, 'key') + DbgVarValue(obj, 'obj'), pmNormal, GetLogAttr('EXCEPTION'));
  end; 
end;

function Cache_Check(
  const parent : OleVariant;
  const key : OleVariant;
  var obj : OleVariant  
): boolean;
  const
    FUNCTION_NAME = 'Cache_Check';
  var 
    parentID, parentType, parentMap, cachedObjID, cachedObjMap : OleVariant;      
begin
  try
    Result := false;
    if (parent = nil) then parent := Cache_RootObj;
    
    if NOT IsExists(parent) then Raise('Родителя не существует!');    

    // получаем идентификатор родителя 
    parentID := Cache_GetObjectID(parent, parentType);

    if Cache_CheckObj(parentID, parent) then
    begin // если родитель валидный
      parentMap := Cache_GetObjectMap(parentID);
      cachedObjMap := Map(parentMap, 'get', key); // получаем мапу объекта      
      if IsMap(cachedObjMap) then 
      begin // если объект есть в кеше, то получили
        cachedObjID := Map(cachedObjMap, 'get', CACHE_FIELD_ID_OBJECT_ID);
        Result := Cache_CheckObj(cachedObjID);
        if Result then
          obj := Map(cachedObjMap, 'get', CACHE_FIELD_ID_OBJECT);
      end;    
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(parent, 'parent') + DbgVarValue(key, 'key') + DbgVarValue(obj, 'obj'),  pmNormal, GetLogAttr('EXCEPTION'));
  end; 
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK: В скриптах желательно использовать ClearWindowCache
}
procedure Cache_DropAll;
  const
    FUNCTION_NAME = 'Cache_DropAll';
  var
    rootID, tmp, rootObj;
begin
  try
    rootObj := Cache_RootObj; 
    rootID := Cache_GetObjectID(rootObj, tmp);
    Cache_DropCacheFor(rootID);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK: В скриптах желательно использовать ClearWindowCache 
}
procedure Cache_DropF1ShellProcess;
  const
    FUNCTION_NAME = 'Cache_DropF1ShellProcess';
  var
    id, tmp, obj;
begin
  try
    if NOT Cache_Check(nil, 'GetF1ShellProcessF1ShellProcess', obj) then
      Cache_DropAll
    else
    begin
      id := Cache_GetObjectID(obj, tmp);
      Cache_DropCacheFor(id);
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE: 
  DESC:
  RESULT:
  REMARK: Сброс кеша для вызова в скриптовых функциях 
}
procedure ClearWindowCache(isForced: boolean = false);
const
  FUNCTION_NAME = 'ClearWindowCache';
begin
  if isForced or VarToBool(gbl_F1ShellTabsEnabled) and VarToBool(gbl_F1ShellOpenDocsInNewTab) then
  begin
    Cache_DropAll;
    Log.Message(FUNCTION_NAME + ': Оконный кэш очищен', '',  pmNormal, GetLogAttr('EXCEPTION'));
  end;
end;

{
  TYPE:
  DESC: 
  RESULT:
  REMARK:
}
function CommonExceptionHandler(
  const message : String = ''
) : boolean;
  var 
    exceptionMsg : String;
begin
  exceptionMsg := ExceptionMessage;
  if (Pos(EX_PERMISSSIONS_CHECK_FAILED_PREFIX, exceptionMsg) <> 0) OR
     (Pos(EX_CANNOT_WINDOW_GET_FOCUS, exceptionMsg) <> 0) OR
     (Pos(EX_CANNOT_FIND_F1SHELL_PROCESS, exceptionMsg) <> 0) OR
     (Pos(EX_CANNOT_FIND_F1PRIME_PROCESS, exceptionMsg) <> 0) OR
     (Pos(EX_OBJECT_NOT_EXISTS, exceptionMsg) <> 0)
     then 
    Raise;
end;

{
  TYPE:
  DESC: Функция возвращающая пустую переменную
  RESULT:
  REMARK:
}
function EmptyVar : OleVariant;
begin
  BuiltIn.VarClear(Result);
end;

{
  TYPE:
  DESC: Возвращает процесс, которому принадлежит окно
  RESULT:
  REMARK:
}
function GetProcessFromWnd(
  const wnd : OleVariant
): OleVariant ;
  const
    FUNCTION_NAME = 'GetProcessFromWnd';
begin
 try
    Result := NonExObj;
    if NOT IsExists(wnd) then Raise('Окно не существует!');
    //
    Result := wnd;
    while (NOT IsSupported(Result, 'ProcessId')) do Result := Result.Parent;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;               
end;

function GetValueIfSupported(
  const obj : OleVariant;
  const propertyName : String;
  const defaultValue : OleVariant
) : OleVariant;
begin
  try
    if IsSupported(obj, propertyName) then
      Result := GetValue(obj, propertyName)
    else
      Result := defaultValue;
  except
    Log.Message('GetValueIfSupported: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end;      
end;

{
  TYPE:
  DESC: Сранвнивает два объекта окна на совпадение 
  RESULT:
  REMARK:
}
function IsWndEqual(
  wnd1 : OleVariant;
  wnd2 : OleVariant
) : boolean;
  var
    wnd1_Id, wnd2_Id : integer;
    wnd1_FullName, wnd2_FullName : String;
begin
  try
    wnd1_id := GetValueIfSupported(wnd1, 'Id', -1);
    wnd2_id := GetValueIfSupported(wnd2, 'Id', -1);
    wnd1_FullName := GetValueIfSupported(wnd1, 'FullName', 'emptyname');
    wnd2_FullName := GetValueIfSupported(wnd2, 'FullName', 'emptyname');   
    
    Result := 
      IsExists(wnd1) AND IsExists(wnd2)
      AND (wnd1_id <> 0) AND (wnd2_id <> 0)
      AND (wnd1_Id = wnd2_Id)
      AND (wnd1_FullName = wnd2_FullName);
  except
    Log.Message('IsWndEqual: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end;                
end;

{
  TYPE:
  DESC: СДЕЛАНА ДЛЯ СОВМЕСТИМОСТИ
  RESULT:
  REMARK:
}
procedure ClientToScreen(
  const wnd : OleVariant;
  var x : integer;
  var y : integer
);
  var pointObj : OleVariant;
begin
  try
    pointObj := wnd.WindowToScreen(x, y);
    x := pointObj.X;
    y := pointObj.Y;
  except
    Log.Message('ClientToScreen: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end;          
end;

{
  TYPE:
  DESC: СДЕЛАНА ДЛЯ СОВМЕСТИМОСТИ
  RESULT:
  REMARK:
}
procedure ScreenToClient(
  const wnd : OleVariant;
  var x : integer;
  var y : integer
);
  var pointObj : OleVariant;
begin
  try
    pointObj := wnd.ScreenToWindow(x, y);
    x := pointObj.X;
    y := pointObj.Y;
  except
    Log.Message('ScreenToClient: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end;          
end;

var gbl_NonExObj73495793465823794659 : OleVariant;
function NonExObj : OleVariant;
begin
  if VarType(gbl_NonExObj73495793465823794659) = varEmpty then
    gbl_NonExObj73495793465823794659 := Utils.CreateStubObject;//Sys.WaitChild(-1);
  Result := gbl_NonExObj73495793465823794659;  
end;

const
  PATH_TO_IMPLEMENTATION = 1; // путь к папке implementation
  PATH_TO_UTILS = 2; // путь к папке с утилитами
  PATH_TO_PSTOOLS = 3; // путь к папке с комплектом утили т pstools  
  PATH_TO_CURR_PROJECT = 4; // путь к папке с текущим проектом  
  PATH_TO_USERCONVERTTEST = 5; //путь к папке userconverttests
  PATH_TO_GARANTUTILS = 6; //путь к папке, содержащий утилиты для Garant'a
  PATH_TO_KILLAFTERWAIT = 7; //путь к папке с батником, для принудительного завершения TestExecute, если он даже зависнет
  PATH_TO_LOGS_DELETED = 8; //путь к папке с удаленными логами пускача
  PATH_TO_READY_FOLDER = 9; //путь к папке с файлами готовности для определения живучести машин
  PATH_TO_READY_TOOL = 10; //путь к папке с утилитой, создающей файл готовности, если ПК после перезапуска работает меньше заданного таймаута, т.е. был перезагружен
  
{
  TYPE:
  DESC: Возврарает путь
  RESULT:
  REMARK:
}
function GetPathTo(
  const pathType : integer = PATH_TO_IMPLEMENTATION  
) : String;
begin
  case pathType of
    PATH_TO_CURR_PROJECT      : Result := IncludeTrailingBackslash(Project.Path);
    PATH_TO_IMPLEMENTATION    : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\';
    PATH_TO_UTILS             : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\Utils\';
    PATH_TO_PSTOOLS           : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\Utils\PSTools\';
    PATH_TO_GARANTUTILS       : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\Utils\GarantUtils\';
    PATH_TO_KILLAFTERWAIT     : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\Utils\KillAfterWait\';
    PATH_TO_USERCONVERTTEST   : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\..\UserConvertTest\';
    PATH_TO_LOGS_DELETED      : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\..\..\LogsDeletedFiles\';
    PATH_TO_READY_TOOL        : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\Utils\CreateFileIfPCRestarted\';
    PATH_TO_READY_FOLDER      : Result := IncludeTrailingBackslash(Project.Path) + '..\..\..\..\..\SharedPath\_StandsReadyFolder\';
  end;
end;

{
  TYPE: Общие
  DESC: Возвращает родительский объект
  RESULT:
  REMARK: Обертка вокруг ParentObject, который иногда глючит
}
function GetParentObject(
  const obj : OleVariant;
  const level : integer = 1 // на сколько уровней назад брать родителя
) : OleVariant;
  var i : integer;
begin
  Result := obj;
  for i := level downto 1 do Result := Result.Parent;
end;

{
  TYPE:
  DESC: 
  RESULT:
  REMARK:
}
function Assign(
  var left : OleVariant;  // чему присвоить
  const right : OleVariant // что присвоить
) : OleVariant;
begin
  left := right;
  Result := right;
end;

{
  TYPE:
  DESC: 
  RESULT:
  REMARK:
}
const QC_PLUGIN_NAME = 'QC Plug-In';
var gbl_IsQcPluginEnabled : OleVariant;
var gbl_QCPlugin : OleVariant;
function IsQCPluginEnabled : boolean;
begin
  if VarType(gbl_IsQcPluginEnabled) = varEmpty then 
  begin  
    gbl_IsQcPluginEnabled := IsPluginInstalled(QC_PLUGIN_NAME);
     if gbl_IsQcPluginEnabled  then 
      gbl_QCPlugin := QCPlugin; 
  end;
  Result := gbl_IsQcPluginEnabled;          
end;         


const
  LOG_FMT_BOLD = 1;
  LOG_FMT_ITALIC = 2;
  LOG_FMT_UNDERLINE = 4;
  LOG_FMT_STRIKEOUT = 8;

function LogAttr(
  fontType : integer = -1;
  fontColor : integer = -1;
  backColor : integer = -1
) : OleVariant;
begin
  Result := Log.CreateNewAttributes;
  if (fontType <> -1) then
  begin
    Result.Bold := ((fontType AND LOG_FMT_BOLD) = LOG_FMT_BOLD); 
    Result.Italic := ((fontType AND LOG_FMT_ITALIC) = LOG_FMT_ITALIC);
    Result.Underline := ((fontType AND LOG_FMT_UNDERLINE) = LOG_FMT_UNDERLINE);
    Result.Strikeout := ((fontType AND LOG_FMT_STRIKEOUT) = LOG_FMT_STRIKEOUT);
  end;
  if (fontColor <> -1) then Result.FontColor := fontColor;
  if (backColor <> -1) then Result.BackColor := backColor;  
end;

var
 gbl_GetLogAttr_Exception;
 gbl_GetLogAttr_Yellow;
 gbl_GetLogAttr_Silver;
 gbl_GetLogAttr_Blue;
 gbl_GetLogAttr_Green;
 gbl_GetLogAttr_White;
 gbl_GetLogAttr_Red;

function GetLogAttr(
  what : String
) : OleVariant;
begin
  try
    case AnsiUpperCase(what) of
      'EXCEPTION' :
        begin 
          if (VarType(gbl_GetLogAttr_Exception) = varEmpty) then
            gbl_GetLogAttr_Exception := LogAttr(-1,-1, clFuchsia);
          Result := gbl_GetLogAttr_Exception;            
        end;
      'YELLOW' :
        begin 
          if (VarType(gbl_GetLogAttr_Yellow) = varEmpty) then
            gbl_GetLogAttr_Yellow := LogAttr(-1,-1, clYellow);
          Result := gbl_GetLogAttr_Yellow;            
        end;
      'SILVER' :
        begin 
          if (VarType(gbl_GetLogAttr_Green) = varEmpty) then
            gbl_GetLogAttr_Silver := LogAttr(-1,-1, clSilver);
          Result := gbl_GetLogAttr_Silver;            
        end;  
      'GREEN' :
        begin 
          if (VarType(gbl_GetLogAttr_Green) = varEmpty) then
            gbl_GetLogAttr_Green := LogAttr(-1,-1, clGreen);
          Result := gbl_GetLogAttr_Green;            
        end;  
      'BLUE' :
        begin 
          if (VarType(gbl_GetLogAttr_Blue) = varEmpty) then
            gbl_GetLogAttr_Blue := LogAttr(-1,-1, $FF4444); //светло-синий
          Result := gbl_GetLogAttr_Blue;            
        end;
      'WHITE' :
        begin 
          if (VarType(gbl_GetLogAttr_White) = varEmpty) then
            gbl_GetLogAttr_White := LogAttr(-1,-1, clWhite);
          Result := gbl_GetLogAttr_White;            
        end;
      'RED' :
       begin 
         if (VarType(gbl_GetLogAttr_Red) = varEmpty) then
           gbl_GetLogAttr_Red := LogAttr(-1,-1, clRed);
         Result := gbl_GetLogAttr_Red;            
      end;   
    end;
  except
    Log.Message('GetLogAttr: ' + ExceptionMessage);
    Result := Log.CreateNewAttributes;
  end;    
end;

{
  TYPE:
  DESC: 
  RESULT:
  REMARK:
}
function Sign(
  number : OleVariant
) : OleVariant;
begin
  try
    if number <> 0 then Result := number/Abs(number) else Result := number;
  except
    Log.Message('Sign' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE:
  DESC: 
  RESULT:
  REMARK:
}
function Min(
  a : OleVariant;
  b : OleVariant
) : OleVariant;
begin
  try
    if a < b then Result := a else Result := b;
  except
    Log.Message('Min: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE:
  DESC: 
  RESULT:
  REMARK:
}
function Max(
  a : OleVariant;
  b : OleVariant
) : OleVariant;
begin
  try
    if a > b then Result := a else Result := b;
  except
    Log.Message('Max: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Общие
  DESC: Обертка вокруг WinAPI'шной SetSysColors
  RESULT:
  REMARK:
}
function SetSysColors(
  const cElements : integer; // число элементов
  const elements   : OleVariant; // массив типов элементов (см. справку по SetSysColors в MSDN)
  const rgbValues  : OleVariant // массив цветов
) : boolean;
  var 
    Def_DLL, Def_ArrInt, Lib, lpaElements, lpaRgbValues : OleVariant;
    i, lowBound : integer;
begin
  try
    Def_DLL := DLL.DefineDLL('USER32');
    
    Def_ArrInt := DLL.DefineType('arrInt', vt_i4, 'Value');
    
    Def_DLL.DefineProc(
      'SetSysColors',     { function name }
      vt_i4,              { int cElements }
      Def_ArrInt,         { const INT* lpaElements }
      Def_ArrInt,         { const COLORREF* lpaRgbValues }
      vt_bool             { Result }
    );
    
    lpaElements := DLL.New('arrInt', cElements);
    lpaRgbValues := DLL.New('arrInt', cElements);
    
    lowBound := VarArrayLowBound(elements,1);

    for i := lowBound to lowBound + cElements - 1 do
      lpaElements[i-lowBound].Value := elements[i];
   
    lowBound := VarArrayLowBound(rgbValues,1);
    for i := lowBound to lowBound + cElements - 1 do
      lpaRgbValues[i-lowBound].Value := rgbValues[i];
    
    Lib := DLL.Load('USER32');
    Result := Lib.SetSysColors(cElements, lpaElements, lpaRgbValues);
    if Result then
      Delay(Options.Run.Timeout div 50);
  except
    Log.Message('SetSysColors: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Обертка вокруг WinAPI'шной ShellExecute
  RESULT:
  REMARK:
}
function ShellExecute(
  const hwnd : OleVariant;
  lpOperation : OleVariant;
  lpFile : OleVariant;
  lpParameters : OleVariant;
  lpDirectory : OleVariant;
  const nShowCmd : integer
) : integer;
  var 
    Def_DLL, Lib  : OleVariant;
    sOperation, sFile, sDirectory, sParameters : OleVariant;
begin
  try
    Def_DLL := DLL.DefineDLL('SHELL32');
    
    if Length(lpOperation) > 0 then
    begin
      sOperation := DLL.New('LPSTR', Length(lpOperation)); 
      sOperation.Text := lpOperation;
    end  
    else
      sOperation := nil;
      
    if Length(lpFile) > 0 then
    begin
      sFile := DLL.New('LPSTR', Length(lpFile));
      sFile.Text := lpFile;
    end 
    else sFile := nil;
      
    if Length(lpParameters) > 0 then
    begin
      sParameters := DLL.New('LPSTR', Length(lpParameters));
      sParameters.Text := lpParameters;
    end
    else 
      sParameters := nil;

    if Length(lpDirectory) > 0 then
    begin
      sDirectory := DLL.New('LPSTR', Length(lpDirectory));
      sDirectory.Text := lpDirectory;
    end
    else 
      sDirectory := nil;
   
    Def_DLL.DefineProc(
      'ShellExecuteA',  { function name }
      vt_ui4,           { HWND hwnd }
      vt_lpstr,         { LPCTSTR lpOperation }
      vt_lpstr,         { LPCTSTR lpFile }
      vt_lpstr,         { LPCTSTR lpParameters }
      vt_lpstr,         { LPCTSTR lpDirectory }
      vt_i4,            { nShowCmd }
      vt_i4             { Result }
    );
    
    Lib := DLL.Load('SHELL32');
    
    Result := Lib.ShellExecuteA(hwnd, sOperation, sFile, sParameters, sDirectory, nShowCmd);
    if (Result <= 32) then
      Log.Warning(
        'ShellExecute: Попытка запуска не удалась.',
        'Operation: ' + lpOperation + EndOfLine +
          'File: '+ lpFile + EndOfLine +
          'Parameters: ' + lpParameters + EndOfLine + 
          'Directory: ' + lpDirectory + EndOfLine + 
          'ShowCmd: ' +  VarToString(nShowCmd)
      );
  except
    Log.Message('ShellExecute: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Глупая функция, но полезная (позволяет уменьшить размер кода).
  RESULT:
  REMARK: Типа сишной операции " ? : ". Если первый параметр true, то возвращаем value1, иначе value2.
}
function Choose(
  const bool : boolean;
  const value1 : OleVariant;
  const value2 : OleVariant
) : OleVariant;
begin
	if bool then Result := value1	else Result := value2;
end;

{ 
  TYPE: Общие
  DESC: делает скриншот ЕСЛИ определена указанная LocalVariable (не путать с локальной переменной!) (по дефолту DO_FULL_SCREEN_SHOT)
}
procedure DoScreenShot(
  const msg : String // сообщение, с которым скриншот добавиться в лог
  ; const extMsg : String = '' // расширенное сообщение
  ; const localVarName : String = 'DO_FULL_SCREEN_SHOT' // имя LocalVariable, при наличии которой бужет сниматься скриншот
 );
begin
  try
    if IsSupported(Options, 'LocalVars') then
      if IsSupported(Options.LocalVars, localVarName) then
        Log.Picture( Sys_Desktop.Picture, msg, extMsg, 1);
  except
    Log.Message('Exception в функции DoScreenShot: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;     
end;

{
  TYPE:
  DESC: проверяет, является ли указанная сущность объекта его свойством (именно свойством, а не методом)
  RESULT:
  REMARK:
}
function IsPropertySupported(
  const obj : OleVariant;
  propName : String
): boolean;
  const
    FUNCTION_NAME = 'IsPropertySupported';
  var 
    objPropIter;    
begin
  try
    Result := false;
    propName := AnsiUpperCase(propName);
    //
    objPropIter := EnumProperties(obj);
    while (objPropIter.HasNext() AND (NOT Result)) do                                                                                                                                                                   
      Result := (AnsiUpperCase(objPropIter.Next().Name) = propName);                                                            
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE: Общие
  DESC: Проверяет, есть ли объект
  RESULT:
  REMARK:
}
function IsExists(
  const obj : OleVariant // объект
) : boolean;
begin
  try
    try
      Result := (VarType(obj) <> varEmpty) AND IsSupported(obj, 'Exists') AND GetValue(obj, 'Exists');
    except
      Result := (VarType(obj) <> varEmpty) AND IsPropertySupported(obj, 'Exists') AND GetValue(obj, 'Exists');
    end;   
  except
    Log.Message('IsExists: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;    
end;

{
  TYPE: Общие
  DESC: Проверяет, true ли переменная
  RESULT:
  REMARK:
}
function IsTrue(
  const obj : OleVariant // объект
) : boolean;
begin
	Result := false;
	if BuiltIn.VarType(obj) = varBoolean then Result := obj;
end;

{
  TYPE: Работа с папками 
  DESC: возвращает путь к каталогу Windows
}
function GetWinDirectory : String;
var
  Def_DLL; Lib; LpStr;
begin
  try
    Def_DLL := DLL.DefineDLL('KERNEL32');
   
    Def_DLL.DefineProc('GetWindowsDirectoryA',
      vt_i4, //text buffer
      vt_i4, //buffer length      
      vt_i4  //result
    );   

    LpStr := DLL.New('LPSTR', 256);
    Lib := DLL.Load('KERNEL32');
    Lib.GetWindowsDirectoryA(LpStr, 256);
    Result := LpStr.Text;
  except
    Log.Message('GetWinDirectory: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с папками 
  DESC: возвращает путь к временному каталогу
}
function GetTempDirectory : String; // путь к временному каталогу
var
  Def_DLL; Lib; LpStr;
begin
  try
    // Defines the dll type
    Def_DLL := DLL.DefineDLL('KERNEL32');
   
     // Registers the function type in TestComplete
    Def_DLL.DefineProc('GetTempPathA',   // function name
      vt_i4, //buffer length

      vt_i4, //text buffer
      vt_i4 //result
    );   

    LpStr := DLL.New('LPSTR', 256);
    Lib := DLL.Load('KERNEL32');
    Lib.GetTempPathA(256, LpStr);
    Result := LpStr.Text;
  except
    Log.Message('GetTempDirectory: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с системой
  DESC: Сбрасывает неактивность пользователя
}
procedure ResetUserInactivity;
var
  Def_DLL, Lib;
begin
  try
    Def_DLL := DLL.DefineDLL('USER32');
    Def_DLL.DefineProc('mouse_event', vt_ui4, vt_ui4, vt_ui4, vt_ui4, vt_ui4, vt_empty);
    Lib := DLL.Load('USER32');
    Lib.mouse_event($8000{MOUSEEVENTF_ABSOLUTE}, 0, 0, 0, 0);
  except
    Log.Message('ResetUserInactivity: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;
                       
{
  TYPE: Работа с окнами
  DESC: посылает окну сообщение WM_TEXT и возвращает ответ
}
function GetWindowText(
  wndHandle : OleVariant // Handle окна
): String;
var
  Def_DLL, Lib, LpStr;
  BufferSize;
begin
  try
    // если передали окно
    if (VarType(wndHandle) = varDispatch) AND IsSupported(wndHandle, 'Handle') then
      wndHandle := wndHandle.Handle;    
    { Defines the dll type }
    Def_DLL := DLL.DefineDLL('USER32');
    { Registers the function type in TestComplete }
    Def_DLL.DefineProc('SendMessageA',   { function name }
                      vt_i4,       { handle }
                      vt_ui4,       { msg }

                      vt_i4,       { the string length }
                      vt_i4,   { text buffer }
                      vt_i4        { result type }
                      );
    
    Lib := DLL.Load('USER32');
                                            
    BufferSize := Lib.SendMessageA(wndHandle, 14, 0, 0);
    if BufferSize = 0 then
      Result := ''
    else
    begin 
      LpStr := DLL.New('LPSTR', BufferSize + 1);
      Lib.SendMessageA(wndHandle, 13, BufferSize + 1, LpStr);
      Result := LpStr.Text;      
    end; 
  except
    Log.Message('GetWindowText: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

procedure _____STRINGS;begin;end;
{
  TYPE: Работа со строками
  DESC: Ищет подстроку в строке с указанной позиции. Возвращает позицию.
}
function PosN(
  const what : String // что ищем
  ; where : String // где ищем
  ; const startPos : integer = 1 // с какой позиции ищем
) : integer; // позиция найденной подстроки
  var x : integer;
begin
  try
  	if startPos <> 1 then { если ищем с 1, то все эквивалентно простому Pos }
    begin
    	x := Length(where);
      if ( startPos <= x ) AND ( startPos > 0 ) then { ищем в пределах строки? }
  	  	where := Copy(where, startPos, x - startPos + 1) { да }
      else
      begin
      	Result := 0; { нет }
        Exit;
      end;
    end;
    x := Pos(what, where);
    if x <> 0 then { нашли? }
  	  Result := x + startPos - 1 { да }
    else
    	Result := 0; { нет }
  except
    Log.Message('PosN: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со строками
  DESC: Говорит, есть ли подстрока в строке.
  Можно задавать следующие опции или их комбинации:
  1 - регистроНЕчувствительность ;
  2 - использовать маску (по умолчанию '*', либо код символа берется из 2го байта
  options, например опции задаются так: (1 or 2) + 256*Ord('*') )
  4 - читать настройки из строки (ими считаются первые символы в строке what,
  отделенные `(обратный апостроф)(или разделитель в 3м байте опций) от основной
  строки, например '(1 or 2)+256*Ord(''*'')`строка'), если их там нет или они не
  вычисляются в число, то используем дефолтные.
}  
function StringCompare(
  what {  что ищем }
  , where : String {  где ищем }
  ; options : integer = -1 {  доп. опции }
) : boolean; {  нашли или нет }
const 
	DEFAULT_DELIMITER = '`'; {  разделитель настроек и строки }
	DEFAULT_WILDCARD = '*';
  DEFAULT_OPTIONS = 1 OR 2;
var
	strArr, tmp : OleVariant;
  i, y, k, nextIndex : integer;
  wildcard, delimiter : String;
begin
  try
  	{ обработка настроек }
    if options = -1 then
    	options := DEFAULT_OPTIONS;
    if ( options OR 4 ) = options then { читаем из строки? }
    begin {  да }
    	if (( options AND 16711680 ) / 65536) <> 0 then {  задан особый разделитель? }
  	  	delimiter := Chr( ( options AND 16711680 ) / 65536 ) {  да, извдекаем его }
      else
      	delimiter := DEFAULT_DELIMITER; {  нет, берем дефолтный }
    	i := Pos(delimiter, what);
    	if i <> 0 then
      begin {  если нужный разделитель найден }
      	tmp := Evaluate( Copy(what, 1, i-1) ); {  вычисляем выражение перед ним }
        y := VarType(tmp);
        if ( y = varSmallint ) OR ( y = varInteger ) OR ( y = varByte ) then
        begin {  если это число, то берем его в качестве настроек }
        	options := tmp;
          Delete(what, 1, i);
        end
        else {  если нет, то используем по умолчанию }
        	options := DEFAULT_OPTIONS;
      end;  	
    end; 
    if ( options OR 1 ) = options then {  регистронезависимость? }
    begin {  да, приводим все к одному регистру }
    	what := Utilities.AnsiLowerCase(what);
      where := Utilities.AnsiLowerCase(where);
    end;
    if ( options OR 2 ) = options then  {  юзаем маску? }
    	if (( options AND 65280 ) / 256) <> 0 then {  да. Задана особая маска? }
  	  	wildcard := Chr( ( options AND 65280 ) / 256 ) {  угу, суем в wildcard символ маски }
      else
      	wildcard := DEFAULT_WILDCARD {  нет, берем дефолтную }
    else
    begin {  нет, все сводится к простому сравнению строк }
    	Result := ( what = where ); 
      Exit;
    end;
    {  начинаем сравнивать }
    Result := true;
    strArr := common.String2Array(what, wildcard); {  разбиваем искомую строку на массив строк без масок }
    if VarArrayLowBound(strArr, 1) = VarArrayHighBound(strArr, 1) then {  если масок не задано, то это простое сравнение }
    begin 
      Result := (strArr[VarArrayLowBound(strArr, 1)] = where);
      Exit;
    end;
    if what[1] <> wildcard then {  должно ли начало строки жестко совпадать? }
    begin {  да, проверяем это }
    	y := VarArrayLowBound(strArr, 1);
    	Result := ( strArr[y] = Copy(where, 1, Length(strArr[y]) ) );
    end;
  	if ( what[Length(what)] <> wildcard ) AND Result then {  а конец? }
    begin {  да, тоже проверяем }
    	y := VarArrayHighBound(strArr, 1);
    	Result := ( strArr[y] = Copy(where, Length(where) - Length(strArr[y]) + 1, Length(strArr[y]) ) );
    end;
    y := 0; k := 0; nextIndex := 1;
    {  собственно сам поиск }
    i := VarArrayLowBound(strArr, 1);
    while (Result ) AND ( i <= VarArrayHighBound(strArr, 1) ) do {  пробегаем по массиву строк }
    begin
    	if strArr[i] <> '' then
      begin
    		k := PosN(strArr[i], where, nextIndex);
  	   	Result := ( y < k ); {  нужно, чтобы следующий кусок находился после предыдущего. смотрим, это так? }
    	  y := k;
        nextIndex := k + Length(strArr[i]); {  следующий кусок ищем после предыдущего }
      end;
      i := i + 1;
    end;
  except
    Log.Message('StringCompare: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со строками
  DESC: Функция переворачивает строки вида: "Папка 1\ Папка 2" в "Папка 2\ Папка 1"
}
function RevertString(
  const str: String // исходная строка
): String; // перевернутая строка
var
	position;
  TempStr;
  PositionOfLastDelim; //позиция последнего разделителя (\)
begin
  try
    Result := '';
    while (Pos('\', str) <> 0)  do
    begin
    	TempStr := str;
      PositionOfLastDelim := 0;
      position := 1;
    	while (position <> 0) do
      begin
        position := Pos('\', TempStr);

        if (position <> 0) then
    	    PositionOfLastDelim := PositionOfLastDelim + position;
        Delete(TempStr, 1, position);
      end;
      Result := Result + Copy(str, PositionOfLastDelim + 1, Length(str)) + '\';
      Delete(str, PositionOfLastDelim, Length(str));
    end;
  	Result := Result + str;
  except
    Log.Message('RevertString: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со строками
  DESC: Удаляет подстроку из source, заключенную между подстроками before и after. Обрабатываются все подстроки.
  RESULT:
  REMARK:
}
function DeleteAllSubStr(
  const source : String; // исходная строка
  const before : String; // подстрока, которая должна быть перед фрагментом
  const after : String // подстрока, которая должна быть после фрагмента
): string;
var
  i, j, k;
begin  
try
  i := 1;
  repeat
    j := PosN(before, source, i);
    if j > 0 then 
    begin
      k := PosN(after, source, j + length(before));
      if k > j then
        Delete(source, j + length(before), k - ( j + length(before) ) );
    end;
    i := k;
  until j = 0;

  Result := source;
  except
    Result := '';  
    Log.Message('DeleteAllSubStr: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
  end;
end;

{
  TYPE: Работа со строками
  DESC: Возвращает подстроку из source, заключенную между подстроками before и after
  RESULT:
  REMARK:
}
function GetSubStr(
  const source : String; // исходная строка
  const before : String; // подстрока, которая должна быть перед фрагментом
  const after : String // подстрока, которая должна быть после фрагмента
) : String; // искомый фрагмент
var i, j : integer;
begin
  try
    Result := '';
    if (before = '') then
      i := 1
    else
      i := Pos(before, source);
    if i > 0 then
    begin
      i := i + Length(before);
      if (after = '') then
        j := Length(source) + 1
      else
        j := PosN(after, source, i);
      if j <> 0 then
        Result := Copy(source, i, j - i);
    end;
  except
    Log.Message('GetSubStr: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со строками
  DESC: Возвращает позицию в str первого попавшегося любого символа из char
  RESULT:
  REMARK:
}
function PosAnyChar(
  const char : String; // строка, содержащая символы
  const str : String // строка, в которой производится поиск
) : integer; // позиция
var i : integer;
begin 
  try
    Result := 0;
    for i := 1 to Length(str) do
      if Pos(str[i], char) > 0 then
      begin
        Result := i;
        break;
      end;
  except
    Log.Message('PosAnyChar: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие; Работа со строками
  DESC: Генерирует случайную строку заданной длины из символов латинского алфавита и цифр
  RESULT:
  REMARK:
}
function GetRandomString(
  length : integer = 12 // длина строки
) : String;
var 
	i, x : integer;
	s : string;
begin
	Randomize;
	Result := '';
	if length <= 0 then Exit;
	for i := 1 to length do
 		case Random(3) of
			0 :	Result := Result + Chr( 65 + Random(26) );
			1 : Result := Result + Chr( 97 + Random(26) );
			2 : Result := Result + Chr( 48 + Random(10) );
		end;
end;

{
  TYPE: Работа со строками
  DESC: Сравниваем сторки, если не равны - пишем влог
  RESULT:
  REMARK:
}
function CompareString2Log (
  const String1 : String; // первая строка
  const String2: String; // вторая строка
  const CaseSensitive: boolean = True // регистронечувствительность?
): Boolean;
var
	Cmp1, Cmp2: String;
begin
try
	if (CaseSensitive) then 
  begin
  	Cmp1 := String1;
    Cmp2 := String2;
  end
  else
  begin
 		Cmp1 := Utilities.AnsiLowerCase(String1);
    Cmp2 := Utilities.AnsiLowerCase(String2);	
  end;
  Result := (Cmp1 = Cmp2);
  if not Result then
  	Log.Error('Строка "' + Cmp1 + '" не <> строке "' + Cmp2 + '"');
except
  raise (ExceptionMessage);
  CommonExceptionHandler;
end;
end;

{
  TYPE: Работа со строками
  DESC: Регистронечувствительная версия Pos
  RESULT:
  REMARK:
}
function PosCI(
  what : String; // что ищем
  where : String // где ищем
) : integer; // на какой позиции нашли
begin
  try
  	Result := Pos( Utilities.AnsiLowerCase(what), Utilities.AnsiLowerCase(where) );  
  except
    Log.Message('PosCI: ' + ExceptionMessage, 'what: "' + VarToStr(what) + '"; where : "' + VarToStr(where) + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со строками
  DESC: Возвращает выражение из скобок.
  RESULT:
  REMARK:
}
function UnBracket(
  const str : String; // исходная строка
  const leftBracket : String = '('; // открывающая скобка
  const rightBracket : String = ')' // закрывающая скобка
) : String; // выражение из скобок
  var strLen, i, y, startPos, char : integer;
begin   
  try
    strLen := Length(str);
    Result := '';
    y := 0;
    startPos := Pos(leftBracket, str);
    for i := startPos to strLen do
    begin
      char := str[i]; 
      if char = leftBracket then
      	y := y + 1
      else if char = rightBracket then
      	y := y - 1;
      if y = 0 then
      begin
      	Result := Copy(str, startPos + 1, i-2);
      	break;
      end;        
    end;
  except
    Log.Message('UnBracket: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;
 
{
  TYPE: Работа со строками
  DESC: Функция фозвращает подстроку, следующую после strKey
  RESULT:
  REMARK:
}
function GetValueByKey(
  const inStr : String; // исходная строка
  const strKey:  String // ключ
): String;
var
  FileVar, s;
  position;
begin
  try
   	Result := '';
  	position := Pos(strKey,  inStr);
    if (position <> 0)  and (inStr[position+Length(strKey)]  = '=')  then
    begin
      Result  := Copy(inStr, position+Length(strKey)+1,  Length(inStr));
    end;
  except
    Log.Message('GetValueByKey: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие; Работа со строками
  DESC: Возвращает значение параметра, заданного в командной строке
  RESULT:
  REMARK:
}
function GetValueFromCmdLine(
  const strKey:  String // имя параметра
): String;
var
  FileVar, s;
  position;
  i;
begin
  try
  	Result := '';
  	for i := 1 to ParamCount do
    begin
    	Result := GetValueByKey(ParamStr(i), strKey);
      if Result <> '' then
      	break;
    end;
  except
    Log.Message('GetValueFromCmdLine: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со строками
  DESC: Возвращает элемент из строки вида abc;defg;h по индексу
  RESULT: Элемент, или пустая строка, если не найдено ничего
  REMARK:
}
function GetCSVFieldByIndex(
  str : String; // исходная строка
  index : integer = 1; // индекс элемента
  const delimiter : String = ';' // разделитель
) : String;
  var
    startPos, endPos : integer;
begin
  try
    Result := '';
    endPos := 0;
    repeat
      startPos := endPos+1;
      endPos := PosN(delimiter, str, startPos);
      index := index - 1;
    until (endPos = 0) OR (index = 0);
    if endPos = 0 then endPos := Length(str)+1;
    if index = 0 then
      Result := Copy(str, startPos, endPos-startPos);
  except
    Log.Message('' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа со строками
  DESC: Подсчитывает количество указанных символов в строке
  RESULT:
  REMARK:
}
function CountChar(
  const char : String;
  const src : String
) : integer;
  var i : integer;
begin
  try
    Result := 0;
    for i:= 1 to Length(src) do if src[i]=char then Result := Result + 1;
  except
    Log.Message('CountChar: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа со строками
  DESC: Разбивает строку по отдельным строкам 
  RESULT:  True, пока исходная строка не пуста
  REMARK: Изменяет исходнуй строку.
}
function GetNextLine(
  var str : String;

  var res : String;
  const delimiter : String = EndOfLine
) : boolean;
  var i, j : integer;
begin
  try
    Result := false;
    j := Length(str);
    if j = 0 then Exit;

    i := Pos(delimiter, str)-1;
    if (i = -1) then i := j;
    res := Copy(str, 1, i);
    Delete(str, 1, i + Length(delimiter));
    Result := true;
  except
    Log.Message('GetNextLine: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE:
  DESC: Типа StringReplace, но может работать с массивами паттернов
  RESULT: Строка
  REMARK:
}
function StringReplaceExt(
  const str : String; // исходная строка
  const oldPattern : OleVariant; // массив искомых подстрок    !РАЗМЕРЫ МАССИВОВ ДОЛЖНЫ СОВПАДАТЬ!
  const newPattern : OleVariant; // массив подстрок для замены !РАЗМЕРЫ МАССИВОВ ДОЛЖНЫ СОВПАДАТЬ!
  const flags : byte = 1 or 2 // флаги
) : String; // результат 
  var 
    oplb, ophb, nplb, nphb, i : integer;
begin
  try
    Result := str;
    oplb := VarArrayLowBound(oldPattern,1); 
    ophb := VarArrayHighBound(oldPattern,1);        
    nplb := VarArrayLowBound(newPattern,1);
    for i := 0 to ophb-oplb do Result := StringReplace(Result, oldPattern[oplb+i], newPattern[nplb+i], flags);
  except
    Log.Message('StringReplaceExt: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := '';
  end;               
end;

procedure _____NAVIGATION_AND_SPEC_FUNCS;begin;end;

{
  TYPE: Работа с окнами;Работа со списками
  DESC: Позиционируемся на элементе в заданном окне по тексту, в пределах одного уровня.
}
function Position_by_Text (
  focused_w: OleVariant // окно, имеющее фокус ввода
  ; sText: String // по этому тексту позиционируемся
  ; isUpDirection: Boolean = false  // вверх (true) или вниз (false) перемещаемся
  ; isUseStringCompare : Boolean = false // используем для сравнения строк StringCompare (можно использовать регистронезависимость и маски)
 ): OleVariant; // спозиционировались или нет
var
  res : OleVariant;
  curr_text, end_elem, value: String;
  oldDelay, handle, prevIndex, currIndex, deadLine : integer;
  isSpecTree, isDocsList, isUseIndex : boolean;
begin
  try
    oldDelay := Options.Run.Delay;
    Options.Run.Delay := MIN_RUN_DELAY;
    try    
      if NOT IsExists(focused_w) then Raise('Окно, в котором хотим позиционироваться, не найдено!');
      
      handle := focused_w.Handle;
      isSpecTree := IsSupported(treeWnd, 'WndClass') AND (focused_w.WndClass = 'TnscSubTree');
      isDocsList := IsSupported(treeWnd, 'WndClass') AND (focused_w.WndClass = 'TnscDocumentListTreeView');
      isUseIndex := (NOT isSpecTree) AND IsSupported(focused_w, 'CurrentNodeIndex') AND (focused_w.CurrentNodeIndex <> -1);

      if isDocsList then
        value := focused_w.Text
      else
        value := common.GetWindowText(handle);
      end_elem := value;

      if isUseIndex then prevIndex := focused_w.CurrentNodeIndex;

      if not isSpecTree then
        focused_w.SetFocus;

      if isUseStringCompare then
      	res := StringCompare(sText, value)
      else
    	  res := (value = sText);
               
      while NOT res do
      begin
        if (isUpDirection) then
          Sys.Keys('[Up]')
        else
         	Sys.Keys('[Down]');

        if isDocsList then
          value := focused_w.Text
        else
          value := common.GetWindowText(handle);
        //Log.Message(value);

        if (isSpecTree AND (value = '')) then break;

        if isUseIndex then
        begin // CurrentNodeIndex доступен
          deadLine := Win32API.GetTickCount + (Options.Run.Timeout div 10);
          while (Win32API.GetTickCount < deadLine) AND (focused_w.CurrentNodeIndex = prevIndex) do Delay(Options.Run.Timeout div 150);
          currIndex := focused_w.CurrentNodeIndex;

          if (currIndex = prevIndex) then
            break
          else
            prevIndex := currIndex;
        end
        else
        begin // CurrentNodeIndex НЕдоступен
          if value = end_elem then
            break
          else
            end_elem := value;
        end;    
        
        if isUseStringCompare then
          res := StringCompare(sText, value)
        else
          res := (value = sText);
      end;
      Result := res;
    finally
      Options.Run.Delay := oldDelay;
    end;
  except
    Log.Message('Position_by_Text: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;

{
  TYPE: Работа с окнами;Работа со списками
  DESC: Позиционируемся на элементе в заданном окне по тексту, 'залезая' внутрь
}
function Position_Internal(
  const treeWnd : OleVariant; // окно
  const path : String; // по этому пути позиционируемся
  const delimiter : String = '\'; // разделитель элементов пути
  const isUseStringCompare : boolean = false; // используем для сравнения строк StringCompare (можно использовать регистронезависимость и маски)
  const paramString : String = '' // строка параметров
) : boolean; // спозиционировались или нет
  var
    paramList, pathArr : OleVariant;
    res, isUseLevel, isPressHome, isInFolder, isUseIndex, isSubTree, isFocusFolderTree, isDocsList : boolean;
    oldDelay, oldLevel, currLevel, targetLevel, i, highBound, lowBound, handle, deadLine, currIndex, prevIndex : integer;
    nextKey, expandKey, currText, oldText, targetText : String;
begin
  try
    oldDelay := Options.Run.Delay;
    Options.Run.Delay := MIN_RUN_DELAY;
    try
      // парсим строку параметров
      paramList := ParseParamString(paramString);
      nextKey := GetParam(paramList, 'NextKey', '[Down]');
      expandKey := GetParam(paramList, 'ExpandKey', '[Right]');
      isUseLevel := VarToBool( GetParam(paramList, 'IsUseLevel', 'true') );
      isUseIndex := VarToBool( GetParam(paramList, 'IsUseIndex', 'true') );
      isPressHome := VarToBool( GetParam(paramList, 'IsPressHome', 'false') );    
      isFocusFolderTree := VarToBool(GetParam(paramList, 'IsFocusFolderTree', 'true'));
      //
      if NOT IsExists(treeWnd) then Raise('Окно, в котором хотим позиционироваться, не найдено!');

      // здесь мы определяем, а не TSubTree ли это дерево. Оно отличается тем, что там нельзя раскрыть узел с клавиатуры
      isSubTree  := IsSupported(treeWnd, 'WndClass') AND (treeWnd.WndClass = 'TSubTree');
      isDocsList := IsSupported(treeWnd, 'WndClass') AND (treeWnd.WndClass = 'TnscDocumentListTreeView');

      if isFocusFolderTree then treeWnd.SetFocus;
      handle := treeWnd.Handle;
      if isPressHome then
        if isSubTree then
          treeWnd.GoToBeginNode
        else 
          Sys.Keys('[Home]');
            
      isUseLevel := isUseLevel AND IsSupported(treeWnd, 'CurrentNodeLevel');
      isUseIndex := isUseIndex AND (IsSupported(treeWnd, 'CurrentNodeIndex') AND (treeWnd.CurrentNodeIndex <> -1));
   
      pathArr := String2Array(path, delimiter);
      lowBound := VarArrayLowBound(pathArr, 1);
      highBound := VarArrayHighBound(pathArr, 1);
      if isUseLevel then currLevel := treeWnd.CurrentNodeLevel else currLevel := -1;
      if isUseIndex then currIndex := treeWnd.CurrentNodeIndex else currIndex := -1;
      { определяем уровень, на котором должен находиться искомый элемент }  
      targetLevel := currLevel;
      isInFolder := false;
      for i := lowBound to highBound do
      begin
        targetText := pathArr[i];
        { получаем параметры текущего элемента }
        if isDocsList then
          currText := treeWnd.Text
        else
          currText := common.GetWindowText(handle);

        if isUseLevel then currLevel := treeWnd.CurrentNodeLevel else currLevel := -1;
        { текущий элемент - тот который нам нужен? }
        if isUseStringCompare then
          res := StringCompare(targetText, currText )
        else
          res := ( targetText = currText );
        { "OR (currLevel = targetLevel - 1) AND (treeWnd.WndClass = 'TnscDocumentListTreeView') AND (treeWnd.CurrentNodeExpanded)"   - это необходимо после http://mdp.garant.ru/pages/viewpage.action?pageId=468656514}
        res := res AND ((isUseLevel AND ((currLevel = targetLevel) OR (currLevel = targetLevel - 1) AND (treeWnd.WndClass = 'TnscDocumentListTreeView') AND (treeWnd.CurrentNodeExpanded))) OR (NOT isUseLevel) );
        oldLevel := currLevel;
        oldText := currText;
        prevIndex := currIndex;
        { ищем нужный элемент }
        while NOT res do
        begin
          { смещаемся }
          Sys.Keys(nextKey);

          { получаем параметры текущего элемента }
          if isDocsList then
            currText := treeWnd.Text
          else
            currText := common.GetWindowText(handle);
          //Log.Message(currText);
          
          if isUseIndex then
          begin
            deadLine := Win32API.GetTickCount + (Options.Run.Timeout div 5);
            while (Win32API.GetTickCount < deadLine) AND (treeWnd.CurrentNodeIndex = prevIndex) do Delay(Options.Run.Timeout div 150);
            currIndex := treeWnd.CurrentNodeIndex;
          end;        
          if isUseLevel then currLevel := treeWnd.CurrentNodeLevel else currLevel := -1;
          {}
          if isUseLevel AND isInFolder AND (currLevel < targetLevel) then break; {это если вошли в папку, а в ней не нашли элемента, то чтобы ошибочно не найти в другой папке того же уровня}
          { список закончился? currIndex на меньше необходимо проверять, например в Структуре документа }           
          if  (isUseIndex AND (currIndex <= prevIndex))
            OR((NOT IsUseIndex) AND (currText = oldText) AND (oldLevel = currLevel))
          then
            break { да, выходим }
          else
          begin { нет, продолжаем }
            oldText := currText;
            oldLevel := currLevel;
            prevIndex := currIndex;
          end;
          { текущий элемент - тот который нам нужен? }
          if isUseStringCompare then
            res := StringCompare(targetText, currText)
          else
            res := (targetText = currText);
          res := res AND ( (isUseLevel AND ( currLevel = targetLevel)) OR (NOT isUseLevel) );
        end;
      
        Result := res;
        if NOT Result then break;
        { если элемент промежуточный (папка) то раскрываем его }
        if i <> highBound then
        begin
          if isSubTree then
          begin
            treeWnd.ExpandCurrentNode;
            Sys.Keys(nextKey);          
          end
          else
            Sys.Keys(expandKey);
          { ждем либо жестко заданный таймаут, либО. если возможно, смещения элемента}
          deadLine := Win32API.GetTickCount + Options.Run.Timeout div 100;
          if isUseLevel then
            while ((treeWnd.CurrentNodeLevel = currLevel) AND (Win32API.GetTickCount < deadLine)) do Delay(Options.Run.Delay)
          else  
            Delay(Options.Run.Timeout div 100);
          if targetLevel <> -1 then targetLevel := targetLevel + 1;
          isInFolder := true;
          res := false;
        end;
      end;
    finally
      Options.Run.Delay := oldDelay;
    end;
  except
    Log.Message('Position_Internal: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа со списками
  DESC: Cворачиваем папки начиная с последней, например, для пути: "Папка 1\ Папка 2" 
  сначала спозиционируемся на элементе с именем "Папка 2" свернём его, а потом на элементе с именем
  "Папка 1" и его свернём
}
function CollapseTree (
  wnd: OleVariant // окно со списком или деревом
  ; sText: String // путь, который надо свернуть
): boolean; // свернули или нет
var
  curr_text : String;
  position, oldDelay : integer;
  str;
begin
  try
    oldDelay := Options.Run.Delay;
    Options.Run.Delay := MIN_RUN_DELAY;
    try
      Result := False;
      position := 1;
      str := RevertString(sText);
      while (position <> 0) do
      begin
        position := Pos('\', str);
        if (position <> 0) then
          curr_text := Copy(str, 1, position-1)
        else
        begin
          curr_text := str;
        end;
        Delete(str, 1, position);
      
        if Position_by_Text(wnd, curr_text, True) then
        begin
          Sys.Keys(KEY_EXPAND_FOLDER);               
          Result := True;   
        end
        else
        begin
          Result := False;
          break;
        end;
      end;
    finally
      Options.Run.Delay := oldDelay;
    end;
  except
    Log.Message('CollapseTree: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками
  DESC: Cворачиваем ветку навигатора 
}
function CollapseTreeInNavigator(
  path: String // путь, который надо свернуть
): boolean; // свернули или нет
var
  rubricatorTree;
begin
  try
    Result := false;
    rubricatorTree:= OpenMenuTab;
    if not IsExists(rubricatorTree) then
      Raise('Не найдено меню во вкладке навигатора!');
    
    if not common.Position_Internal(rubricatorTree, path) then
      Raise('Не найден сворачиваемый путь: ' + path);    
		Result := CollapseTree(rubricatorTree, path);
  except
    Result := false;
    Log.Message('CollapseTreeInNavigator: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками
  DESC: функция бежит по дереву и проверяет содержат ли элементы дерева заданный контекст
}
function CheckContextTreeElements(
  tree: OleVariant // окно с деревом
  ; const context: String // контекст
  ;  numOfLines: Integer  = -1 // количество элементов в списке
): boolean; // содержит или нет
  var
  	currentElementName, previousElementName : String;  
    handle, oldDelay, prevIndex, currIndex, deadLine, countOfLines  : integer;
    isUseIndex : boolean;
begin
  try
  	Result := true;
    oldDelay := Options.Run.Delay;
    Options.Run.Delay := MIN_RUN_DELAY;
    try    
    	if NOT IsExists(tree) then Raise('Объект tree не найден!!!');
      isUseIndex := IsSupported(tree, 'CurrentNodeIndex') AND (tree.CurrentNodeIndex <> -1);
    
      tree.SetFocus;
      Sys.Keys('[Home]');
      handle := tree.Handle;
      countOfLines := 0;
    	repeat
      	currentElementName := common.GetWindowText(handle);
        Result := (Pos(AnsiLowerCase(context), AnsiLowerCase(currentElementName)) <> 0) AND Result;
        if (numOfLines = -1) and (NOT Result) then break;
      
        if isUseIndex then
          prevIndex := tree.CurrentNodeIndex
        else
          previousElementName := currentElementName;
        
        Sys.Keys('[Down]');
        Inc(countOfLines);
      
        if isUseIndex then
        begin
          deadLine := Win32API.GetTickCount + (Options.Run.Timeout div 10);
          while (Win32API.GetTickCount < deadLine) AND (tree.CurrentNodeIndex = prevIndex) do Delay(Options.Run.Timeout div 150);
      		currIndex := tree.CurrentNodeIndex;
        end  
        else
         	currentElementName := common.GetWindowText(handle);
      until (isUseIndex AND (currIndex = prevIndex)) OR ( (NOT isUseIndex) AND (previousElementName = currentElementName) );

      if NOT Result then 
        Log.Warning('CheckContextTreeElements: Встречаются элементы, не содержащие контекст "' + context + '"', '',  pmNormal, GetLogAttr('EXCEPTION'));

      if not isUseIndex then Dec(countOfLines);

      if (numOfLines <> -1) and (numOfLines <> countOfLines) then
      begin
        Result := false;
        Log.Warning('CheckContextTreeElements: Отличается количество элементов отфильтрованного списка, фильтр: "' + context + '", есть ' + 
                     IntToStr(numOfLines) + ', должно ' + IntToStr(countOfLines), '', 4);
      end;
    finally
      Options.Run.Delay := oldDelay;
    end;
  except
    Log.Warning('CheckContextTreeElements: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с фильтром
  DESC: Функция заполняет контекстный фильтр в навигаторе
}
function  FillTCContextFilterField(context: string; doCheck: boolean = true): boolean;
var 
  w;
begin
try
  w := GetFromContextFilterForm('КОМБОБОКС "КОНТЕКСТНЫЙ ФИЛЬТР"', GetFromDictionary('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"')); 
  if not IsExists(w) then
    Raise('Не найдено поле ввода Контекстный фильтр');
  w.Keys('[End]![Home]' + context);
  
  if doCheck then
    Result := StringCompare(context, common.GetWindowText(w.Handle))
  else
    Result := true;
    
  if not Result then
    Raise('Введенный текст "' + common.GetWindowText(w.Handle) + '" отличается от "' + context + '"');
except
  Result := false;
  Log.Error('FillTCContextFilterField: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  CommonExceptionHandler;
end;  
end;

{
  TYPE: Работа с фильтром
  DESC: Функция проверяет работу контекстного фильтра в ТС по количеству документов
}
function  CheckTCContextFilter(
  context: String;
  numOfLines: Integer  = -1 // количество элементов в списке
  ): boolean;
var w;
begin
try
  Result := FillTCContextFilterField(context) and CheckContextTreeElements(GetFromDictionary('СПИСОК ТЕРМИНОВ'), context, numOfLines);
  if NOT Result then
    Raise('Контекстный фильтр "' + context + '" отличается!');
except
	Result := False;
  Log.Error('CheckTCContextFilter: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  CommonExceptionHandler;
end;
end;

{
  TYPE: Работа со списками; Работа с массивами
  DESC: Функция возвращает массив элементов дерева
}
function GetElementsFromTree(
  Tree: OleVariant // окно с деревом
  ; const bExpand: Boolean = False // разворачивать ли элементы дерева
  ; const paramString : String = '' // строка параметров
): OleVariant; // массив
  var
    paramList : OleVariant;
    i, oldDelay, prevIndex, currIndex, deadLine : integer;  
    isSpecTree, isDocsList, isUseIndex, isAddNumber, isAddRelevance : boolean;
  	currentElementName, previousElementName, addText : String;
begin
  try
    Result := nil;
    if NOT IsExists(tree) then Raise('Объект tree не найден!!!');
    
    paramList := ParseParamString(paramString);
    isAddNumber := VarToBool( GetParam(paramList, 'IsAddNumber', 'false') );
    isAddRelevance := VarToBool( GetParam(paramList, 'IsAddRelevance', 'false') );
    isSpecTree := IsSupported(Tree, 'WndClass') AND (Tree.WndClass = 'TnscSubTree');
    isDocsList := IsSupported(Tree, 'WndClass') AND (Tree.WndClass = 'TnscDocumentListTreeView');
        
    isUseIndex := (NOT isSpecTree) AND IsSupported(tree, 'CurrentNodeIndex') AND (tree.CurrentNodeIndex <> -1);
    
  	Result := CreateVariantArray(0,0);
    oldDelay := Options.Run.Delay;
    Options.Run.Delay := MIN_RUN_DELAY;

    try
      if not isSpecTree then
      begin 
        tree.SetFocus;
        Sys.Keys('[Home]');
        Sys.Keys('[Down]'); Sys.Keys('[Up]');//rykov: иногда после того,как сделаем SetFocus окно СКР какого то фига  уходит в ступор
      end
      else
      begin
        // т.к. "Home" не работает
        if tree.Visible then
        begin
          Sys.Keys('[PageUp][PageUp][PageUp][PageUp][PageUp][PageUp][PageUp][PageUp][PageUp][PageUp]');
          {
          currentElementName := 'abra19023566738190';      
          for i := 1 to 100 do
          begin
            tree.Keys('[PageUp]');
            if currentElementName = common.GetWindowText(tree.Handle) then
              break; 
            currentElementName := common.GetWindowText(tree.Handle);          
          end;
          }
          Sys.Keys('[Down]'); Sys.Keys('[Up]');
        end;
      end;

      i := 0;
    	repeat
        if (bExpand) then 
        begin
          if not (IsSupported(tree, 'CurrentNodeExpanded') and tree.CurrentNodeExpanded) then
            Sys.Keys(KEY_EXPAND_FOLDER);
        end;
       
      	VarArrayRedim(Result, i);

        if isDocsList then
          currentElementName := tree.Text
        else
          currentElementName := common.GetWindowText(tree.Handle);
        //Log.Message(currentElementName);
        
        addText := '';
        if isAddNumber then addText := IntToStr(GetCurrentElementNumberInList(tree)) + ': ';
        if isAddRelevance then addText := addText + IntToStr(GetRelevanceForCurrentElementInList(tree)) + ' ';
        Result[i] := addText + currentElementName;
        Inc(i);
      
        if isUseIndex then prevIndex := tree.CurrentNodeIndex else previousElementName := currentElementName;
        Sys.Keys('[Down]'); 
        if isUseIndex then
        begin
          deadLine := Win32API.GetTickCount + (Options.Run.Timeout div 10);
          while (Win32API.GetTickCount < deadLine) AND (tree.CurrentNodeIndex = prevIndex) do Delay(Options.Run.Timeout div 150);
      		currIndex := tree.CurrentNodeIndex;
        end
        else
        begin
          if isDocsList then
            currentElementName := tree.Text
          else
            currentElementName := common.GetWindowText(tree.Handle);
        end;
      until (isUseIndex AND (currIndex = prevIndex)) OR 
            ((NOT isUseIndex) AND (isSpecTree AND (currentElementName = '') OR (previousElementName = currentElementName)));
    finally
      Options.Run.Delay := oldDelay;
    end;
  except
    Log.Message('GetElementsFromTree: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := nil;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками; Работа с массивами
  DESC: Функция возвращает массив элементов комбобоксов
}
function GetElementsFromCombobox(
  Tree: OleVariant // окно с комбобоксом
  ; const bExpand: Boolean = False // разворачивать ли элементы комбобокса
): OleVariant; // массив 
begin
  try
    result := GetElementsFromTree(Tree, bExpand);
  except
    Log.Message('GetElementsFromCombobox: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;


{
  TYPE: Работа с массивами
  DESC: Поэлементно сравнивает два массива
}
function CompareArray(
  const Array1: OleVariant;
  const Array2: OleVariant;
  const isReport : boolean = true;
  const isUseStringCompare : boolean = false
): boolean;
var
	i, lowBound, highBound, diff : integer;
  res: boolean;
begin
  try
  	Result := True;
  	lowBound := VarArrayLowBound(array1, 1);
    highBound := VarArrayHighBound(array1, 1);

  	if ArrayLength(array1) <> ArrayLength(array2) then
    begin
    	if isReport then
        Log.Error(
          'Массивы разных размеров. Длина первого: ' + IntToStr(ArrayLength(array1)) + ' , длина второго: ' + IntToStr(ArrayLength(array2)) 
        );
      Result := false;
    end
    else
    begin
      diff := VarArrayLowBound(array2, 1) - lowBound;
      Result := true;
  		for i := lowBound to highBound do
      begin
        if (VarType(array1[i]) = VAR_VARIANT_ARRAY) AND (VarType(array2[i+diff]) = VAR_VARIANT_ARRAY) then
        begin
          if NOT CompareArray(array1[i], array2[i+diff], isReport) then
          begin
            Result := false;
            if isReport then 
              Log.Warning('Подмассивы не совпадают.', IntToStr(i) + EndOfLine + IntToStr(i+diff));            
          end;
        end
        else
        begin
          if isUseStringCompare then
            res := StringCompare(array1[i], array2[i+diff])
          else
            res := array1[i] = array2[i+diff];
          if not res then
          begin
            Result := false;
          	if isReport then 
              Log.Warning('Элементы № ' + IntToStr(i) + ' различаются: "' + VarToString(Array1[i]) + '" <> "' + VarToString(Array2[i+diff]) + '"');
          end;              
        end; 
      end;	
    end;
    if isReport AND (NOT Result) then
      Log.Warning('CompareArray. Сравниваемые массивы', 'Первый:' + EndOfLine + ConvertArrayToString(array1) + EndOfLine + EndOfLine + EndOfLine + 'Второй:' + EndOfLine + ConvertArrayToString(array2)  );
  except
    Log.Message('CompareArray: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;


end;

{
  TYPE: Работа с о списками
  DESC: Функция подсчитывает количество элементов в дереве
}
function CountElementInTree(
  tree: OleVariant // окно с деревом
): integer; // количество элементов
  var
    currIndex, prevIndex, oldDelay, handle, deadLine : integer;
    isUseIndex : boolean;
  	currentElementName, previousElementName : String;    
begin
  try
  	Result := 0;
    oldDelay := Options.Run.Delay;
    Options.Run.Delay := MIN_RUN_DELAY;

    try
      if NOT IsExists(tree) then Raise('Объект tree не найден!!!');
      handle := tree.Handle;
      isUseIndex := IsSupported(tree, 'CurrentNodeIndex') AND (tree.CurrentNodeIndex <> -1);
      tree.SetFocus;
      Sys.Keys('[Home]');
      if ( common.GetWindowText(tree.Handle) <> '' ) then
        repeat
         	Result := Result + 1;
        
          if isUseIndex then
            prevIndex := tree.CurrentNodeIndex
          else
            previousElementName := common.GetWindowText(handle);
          
          Sys.Keys('[Down]');
        
          if isUseIndex then
          begin
            deadLine := Win32API.GetTickCount + (Options.Run.Timeout div 10);
            while (Win32API.GetTickCount < deadLine) AND (tree.CurrentNodeIndex = prevIndex) do Delay(Options.Run.Timeout div 150);
        		currIndex := tree.CurrentNodeIndex;
          end
          else
           	currentElementName := common.GetWindowText(handle);
        until (isUseIndex AND (currIndex = prevIndex)) OR ( (NOT isUseIndex) AND (previousElementName = currentElementName) );

    finally
      Options.Run.Delay := oldDelay;
    end;
  except
    Log.Message('CountElementInTree: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := 0;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками
  DESC:
    функция возвращает количество элементов в списке документов
    число берётся из статусной строки
}
function CountElementInList(
  const List: Window // окно со списком
): longint; // количество элементов в списке
begin
  try
  	Result := -1;
    if (IsExists(List) and List.Visible) then
      Result := GetCurrListElementParam(List, 'ВСЕГО ДОКУМЕНТОВ');
  except
    Log.Message('CountElementInList: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками
  DESC:
    функция возвращает количество элементов в списке документов
    число берётся из статусной строки
}
function CountSelectedElementInList(
  const List: Window // окно со списком
): longint; // количество элементов в списке
begin
  try
  	Result := -1;
    if (IsExists(List) and List.Visible) then
      Result := GetCurrListElementParam(List, 'ВЫДЕЛЕНО');
  except
    Log.Message('CountSelectedElementInList: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками
  DESC:
    Функция возвращает значение релевантности в списке документов для текущего жокумента.
    Число берётся из статусной строки
}
function GetRelevanceForCurrentElementInList(
  const List: Window // окно со списком
): longint; // количество элементов в списке
begin
  try
  	Result := -1;
    if (IsExists(List) and List.Visible) then
      Result := GetCurrListElementParam(List, 'РЕЛЕВАНТНОСТЬ');
  except
    Log.Message('GetRelevanceForCurrentElementInList: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками
  DESC:
    функция возвращает номер тукущего элемента в списке
    число берётся из статусной строки
}
function GetCurrentElementNumberInList(
  const List: Window // окно со списком
): longint; // количество элементов в списке
begin
  try
  	Result := -1;
    if (IsExists(List) and List.Visible) then
      Result := GetCurrListElementParam(List, 'ТЕКУЩИЙ ДОКУМЕНТ');    
  except
    Log.Message('GetCurrentElementNumberInList: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками
  DESC:
    функция возвращает количество число номер тукущего элемента в списке
    число берётся из статусной строки
}
function GetAnnotationsCount(
  const List: Window // окно со списком
): longint; // количество элементов в списке
begin
  try
  	Result := -1;
    if (IsExists(List) and List.Visible) then
      Result := GetCurrListElementParam(List, 'КОЛИЧЕСТВО АННОТАЦИЙ');    
  except
    Log.Message('GetAnnotationsCount: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: преобразовывает переменнуб типа bool в переменную типа string
}
function Bool2Str(
  b: Boolean
): string;
begin
  try
    if (b = True) then
      Result := 'True'
    else if (b = False) then
      Result := 'False'
    else
      Result := 'Undefine';
  except
    Log.Message('Bool2Str: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с папками
  DESC: Удаление элемента с подтверждением
  RESULT:
  REMARK:
}
function DelWithConfirm(
  const FromPopupMenu: Boolean = False; // удалять из всплывающего меню или по Del
  const wndWithMenu : OleVariant = nil
): boolean;
begin
  try
    if (FromPopupMenu) then
    begin
      if IsExists(wndWithMenu) then 
        wndWithMenu.SetFocus;
      Sys.Keys('[Apps]');
      ClickByPopupMenuItem(wndWithMenu, 'Удалить');
    end  
    else
    begin
      if IsExists(wndWithMenu) then 
        wndWithMenu.SetFocus;
      Sys.Keys('[Del]');
    end;
    Result := WaitForConfirmationWindow(Options.Run.Timeout div 10) <> '';
  except
    Result := false;
    Log.Message('DelWithConfirm: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE:
  DESC: Ставит мышку по экранным координатам, переводя ее плавно на новоей место
  RESULT: Удалось ли поставить
  REMARK:
}
function SlideMouse(
  const x : integer; // координаты экранные !!!
  const y : integer
) : boolean;
  const
    COEF = 0.07;
    MAX_COUNTS = 300;
  var 
    distX, distY, stepsCount, i, counter : integer;
    coordX, coordY, dX, dY, minStep : Real;
begin
  try
    Result := (x = Sys_Desktop.MouseX) AND (y = Sys_Desktop.MouseY);
    if Result then Exit;
    
    coordX := Sys_Desktop.MouseX;
    coordY := Sys_Desktop.MouseY;
    counter := 1; // защитный счетчик, чтобы не висеть в бесконечном цикле
     
    while (NOT Result) AND (counter < MAX_COUNTS) do
    begin
      distX := x - Sys_Desktop.MouseX;
      distY := y - Sys_Desktop.MouseY;
      minStep := Max(1, Min(Abs(distX), Abs(distY))*COEF );    
      stepsCount := Min( Abs(distX), Abs(distY) ) div minStep;
    
      dX := distX*COEF;
      dX := Sign(dX) * Max(Abs(dX), 10*COEF);
      dY := distY*COEF;
      dY := Sign(dY) * Max(Abs(dY), 10*COEF);

      coordX := coordX + dX;
      coordY := coordY + dY;
      Sys_Desktop.MouseX := coordX;
      Sys_Desktop.MouseY := coordY;
      Delay(1);
      Result := (x = Sys_Desktop.MouseX) AND (y = Sys_Desktop.MouseY);
      counter := counter + 1;
    end;
    if NOT Result then Log.Warning('SlideMouse: Не смогли переместить мышь в точку c координатами (' + IntToStr(x) + ',' + IntToStr(y) + ')' );
  except
    Log.Message('SlideMouse: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа с окнами
  DESC: Возвращает всплывающую подсказку над объектом.
  RESULT: Возвращает текст хинта или пустую строку.
  REMARK: 
   Ставит мышку по координатам, ввозвращает текст хинта или пустую строку. 
}
function GetHintTextByCoords(
  x : integer; // координата X
  y : integer; // координата Y
  const targetWindow : OleVariant = nil; // окно, если окно передаем, то координаты считаются локальными, иначе - экранными
  const isVgSceneObj : Boolean = false
) : String; // текст хинта или ''
  const
    NULL_STR = 'dummy caption';  
  var 
    i, p, w, hintWnd : OleVariant;
    sX, sY: integer;
    str : String;
begin
  try
    if (targetWindow <> nil) AND (NOT IsExists(targetWindow)) then Raise('Окно targetWindow задано, но не существует!');
  	p := GetF1ShellProcess;
    hintWnd := p.WaitWindow('TvtMultilineHint', '', 1, Options.Run.TimeOut div 5);
    if IsExists(hintWnd) then
    begin
      str := hintWnd.WndCaption;
      hintWnd.WndCaption := NULL_STR;
    end;
   	Result := '';
    SlideMouse(1, 1); // выставляем мышку в угол, чтобы она не подсвечивала объект и не меняла его таким образом

    Delay(Options.Run.TimeOut div 30);
    
    if (targetWindow <> nil) then
    begin
      if isVgSceneObj then
      begin
        if not CalcXYToParentVgSceneObj(targetWindow, sX, sY) then
          Raise('Не получилось высчитать относительные координаты объекта VgScene');
        x := x + sX + targetWindow.Width div 2;
        y := y + sY + targetWindow.Height div 2;
        common.ClientToScreen(FindParentVgSceneObj(targetWindow), x, y);        
      end
      else
        common.ClientToScreen(targetWindow, x, y);
    end; 

    SlideMouse(x, y);
    
    i := 0;
    repeat
      Inc(i);
      Delay(1000); // даем возможность хинту обновиться
      hintWnd := p.WaitWindow('TvtMultilineHint', '', 1, Options.Run.TimeOut div 5);
      if IsExists(hintWnd) then
      begin
        str := hintWnd.WndCaption;
        if str <> NULL_STR  then
        begin 
          Result := str; // если хинт обновился
          break;
        end;
      end;
    until i > 3; 

    if Result <> '' then 
      Log.Message('GetHintTextByCoords: Получили непустой хинт: ' + Result)
    else
      Log.Message('GetHintTextByCoords: Не удалось получить хинт или он пуст');
  except
    Result := '';
    Log.Message('GetHintTextByCoords: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с окнами
  DESC: Возвращает всплывающую подсказку над объектом.
  RESULT: Возвращает текст хинта или 'false'.
  REMARK: 
    Функция ищет указанный объект, ставит над ним мышку, если всплывает хинт,
    она возвращает его название. в противном случае возвращает: false. 
}
function GetObjectHintText(
  targetWindow : OleVariant; // окно, в котором будем искать картинку
  pathToImage: string; // путь к картинке, которую бужем искать
  dx, dy: integer = 0  
) : String; // текст хинта или 'false'
  const
    WINDOW_WAIT_TIMEOUT=3000;
  var 
  	p, w, w1 : OleVariant;
    str : String;
    x, y : integer;
    findRes;
begin
 	Result := 'false';
 	if Assign( findRes, Regions.Find(targetWindow, pathToImage, 0, 0, true, false, 0)) <> nil then
  begin

    x := findRes.Left;//Regions.FoundX;
    y := findRes.Top;//Regions.FoundY;
    str := GetHintTextByCoords(targetWindow, x, y);
    if str <> '' then Result := str;
  end;
end;             

{                
  TYPE: Работа с окнами
  DESC: Ищет объект (картинку) на окне
  RESULT:
    Если pathToImage не массив, то логическое значение (нашли/не нашли),
    если массив, то возвращает элемент массива, на котором найдено совпадение, или пустую строку, если совпадений не найдено.
  REMARK:
}
function FindPicture(
  const targetWindow : OleVariant; // окно, в котором ищем картинку
  const pathToImage: OleVariant; // путь к картинке (или массив путей к картинке)
  var x : integer;  // координата x найденной картинки, относительно окна
  var y : integer;  // координата y найденной картинки, относительно окна
  rectX : integer = 0;  // x-координата верхнего левого угла области поиска
  rectY : integer = 0;  // y-координата верхнего левого угла области поиска
  rectWidth : integer = -1; // ширина области поиска (-1 - вся ширина)
  rectHeight : integer = -1 // высота области поиска (-1 - вся высота)
) : OleVariant; // в зависимости от pathToImage (см. комментарий)
  var 
    i : integer;
    arrElements, arrColors, arrOldColors, searchArea  : OleVariant;
    findRes;
begin
  try
    Result := Choose(IsArray(pathToImage), '', false);
    // выставляем стандартные(наши) системные цвета 
    if IsExists(targetWindow) AND (IsSupported(targetWindow, 'Color')) then 
      targetWindow.Color := clWhite;    //-16777201
    // определяем для каких элементов какие цвета будем устанавливать
    arrElements := [
      Win32API.COLOR_HIGHLIGHT,
      Win32API.COLOR_3DDKSHADOW,
      Win32API.COLOR_3DFACE,
      Win32API.COLOR_3DHIGHLIGHT,
      Win32API.COLOR_3DHILIGHT,
      Win32API.COLOR_3DLIGHT,
      Win32API.COLOR_3DSHADOW,

      Win32API.COLOR_ACTIVEBORDER,
      Win32API.COLOR_ACTIVECAPTION,
      Win32API.COLOR_ADJ_MAX,
      Win32API.COLOR_ADJ_MIN,
      Win32API.COLOR_APPWORKSPACE,

      Win32API.COLOR_BACKGROUND,
      Win32API.COLOR_BTNFACE,
      Win32API.COLOR_BTNHIGHLIGHT,
      Win32API.COLOR_BTNSHADOW,
      Win32API.COLOR_DESKTOP,
      Win32API.COLOR_ENDCOLORS,
      Win32API.COLOR_GRADIENTACTIVECAPTION,
      Win32API.COLOR_GRADIENTINACTIVECAPTION,
      Win32API.COLOR_INACTIVEBORDER,
      Win32API.COLOR_WINDOW,
      Win32API.COLOR_WINDOWFRAME,
      Win32API.COLOR_INFOBK,
      Win32API.COLOR_MENU
    ];

    arrColors := [
      6956042,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite,
      clWhite
    ];
    
    //убираем курсор мышки
    SlideMouse(1, 1); 
        
    // запоминаем старые цвета 
    arrOldColors := CreateVariantArray( VarArrayLowBound(arrElements,1), VarArrayHighBound(arrElements,1) );
    for i := VarArrayLowBound(arrElements,1) to VarArrayHighBound(arrElements,1) do
      arrOldColors[i] := GetSysColor(arrElements[i]);
    
    // выключаем для вкладок, т.к. http://mdp.garant.ru/pages/viewpage.action?pageId=561554309
//    if not VarToBool(gbl_F1ShellTabsEnabled) then
      SetSysColors( ArrayLength(arrElements), arrElements, arrColors );
    
    Delay(Options.Run.Timeout div 30);
    
    if IsSupported(targetWindow, 'Width') AND IsSupported(targetWindow, 'Height') then
    begin // передано полноценное окно
      if (rectWidth = -1) then rectWidth := targetWindow.Width;
      if (rectHeight = -1) then rectHeight := targetWindow.Height;    
      searchArea := targetWindow.Picture(rectX, rectY, rectWidth, rectHeight);
    end
    else // в качестве окна, скорее всего, передали Rect 
      searchArea := targetWindow;
  
    // ищем
    if NOT IsArray(pathToImage) then
    begin
      Result := false;
      Indicator.Hide();
      if Assign(findRes, Regions.Find(searchArea, pathToImage, 0, 0, true, false, 0)) <> nil then
      begin
        x := {Regions.FoundLeft} findRes.Left + rectX;
        y := {Regions.FoundTop} findRes.Top + rectY;
        Result := true;
      end;
    end
    else
    begin
      Result := '';
      for i := VarArrayLowBound(pathToImage,1) to VarArrayHighBound(pathToImage,1) do
      begin
        Indicator.Hide();
        if Assign(findRes, Regions.Find(searchArea, pathToImage[i], 0, 0, true, false, 0)) <> nil then
        begin
          x := {Regions.FoundLeft} findRes.Left + rectX;
          y := {Regions.FoundLeft} findRes.Top + rectY;
          Result := pathToImage[i];
        end;
      end;
    end;    
          
  finally
    if Result = Choose(IsArray(pathToImage), '', false) then
      Log.Picture(Sys_Desktop.Picture, 'Скриншот для удобного получения эталона', '',  pmNormal, GetLogAttr('SILVER'));

    // возвращаем цвета обратно
    // выключаем для вкладок, т.к. http://mdp.garant.ru/pages/viewpage.action?pageId=561554309
//    if not VarToBool(gbl_F1ShellTabsEnabled) then
      SetSysColors( ArrayLength(arrElements), arrElements, arrOldColors );
      
    // показываем индикатор
    Indicator.Show();
  end;               
end;

{
  TYPE: Работа с окнами
  DESC: Ищет объект (картинку) на окне и перемещает мышь в его левый верхний угол.
  RESULT: Возвращает true если объект найден, false в противном случае.
  REMARK:
    Ищет объект (картинку) на окне и перемещает мышь в его левый верхний угол.
    Может кликнуть. Можно дополнительно задавать смещение.
}
var
  gbl_MoveMouseToObject_X, gbl_MoveMouseToObject_Y: Integer;
   
function MoveMouseToObject(
  targetWindow : OleVariant; // окно, в котором ищем картинку
  pathToImage: string; // путь к картинке
  dx : integer = 0; // смещение по х
  dy : integer = 0; // смещение по у
  click : boolean = false; // кликать или нет
  buttonId : integer = 0; // какой кнопкой кликать 0 - левая, 1 - средняя, 2 - правая
  rectX: integer = 0;// x-координата верхнего левого угла области поиска
  rectY: integer = 0 // y-координата верхнего левого угла области поиска 
) : boolean; // нашли или нет
  var 
    x, y, oldx, oldy : integer;
begin
  try
    if FindPicture(targetWindow, pathToImage, x, y, rectX, rectY) then
    begin
      gbl_MoveMouseToObject_X := x;
      gbl_MoveMouseToObject_Y := y;
      
      x := x + dx;
      y := y + dy;                
      oldx := x; oldy := y;
      common.ClientToScreen(targetWindow, x, y);
      SlideMouse(x, y);
      if click then
      case buttonId of
        0: targetWindow.Click(oldx, oldy);
        1: targetWindow.ClickM(oldx, oldy);
        2: targetWindow.ClickR(oldx, oldy);
        10: 
        begin
          LLPlayer.MouseDown(MK_LBUTTON, x, y, 10);
          LLPlayer.MouseUp(MK_LBUTTON, x, y, 10);    
        end; 
        11: begin
          LLPlayer.MouseDown(MK_MBUTTON, x, y, 10);
          LLPlayer.MouseUp(MK_MBUTTON, x, y, 10);    
        end; 
        12: begin
          LLPlayer.MouseDown(MK_RBUTTON, x, y, 10);
          LLPlayer.MouseUp(MK_RBUTTON, x, y, 10);    
        end; 
      end;
      Result := true;
    end
    else
    	Result := false;
  except
    Log.Message('MoveMouseToObject: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;    
end;

{
  TYPE: Общие
  DESC: Очищает буффер обмена
  RESULT:
  REMARK:
}
procedure ClipboardClean;
  const
    FUNCTION_NAME = 'ClipboardClean';
begin
  if (Win32API.OpenClipboard(0)) then
  begin
    Win32API.EmptyClipboard;
    Win32API.CloseClipboard; 
  end
  else
    Log.Error(FUNCTION_NAME + ': Не удалось открыть (и очистить) буфер обмена!');
end;

procedure _____ARRAYS_WORKS;begin;end;

{
  TYPE: Работа с массивами
  DESC: Удаляет из массива элемент по индексу
  RESULT:
  REMARK: 
    Функция удаляет из InArray элемент с номером Index и возвращает новый массив в качестве результата.
}
procedure DeleteElementFromArray(
  var InArray; // массив
  const Index: integer // индекс
);
var
	iLow, iHigh, i, j: integer;
  TempArray;
begin
  try
  	TempArray := InArray;
  	iLow := VarArrayLowBound(InArray, 1);
    iHigh := VarArrayHighBound(InArray, 1);
    if ((Index < iLow) or (Index > iHigh)) then
    	Log.Error('Индекс за границами массива')
    else
    begin
    	InArray := CreateVariantArray(iLow, iHigh -1);
      j := iLow;
    	for i:= iLow to iHigh do
      begin
      	if (i <> Index) then
        begin
        	InArray[j] := TempArray[i];
  				j := j + 1;
        end;
      end;
    end;
  except
    Log.Message('DeleteElementFromArray: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Определяет содержится ли Element в InArray
  RESULT:
  REMARK:
}
function FindElement(
  const inArray: OleVariant; // массив
  const element: OleVaraint; // искомый элемент
  const isUseStringCompare : boolean = false // используем для сравнения строк StringCompare (можно использовать регистронезависимость и маски)  
): Boolean; // нашли или нет
var
	i: integer;
  iLow, iHigh: integer;
begin                
  try
    if VarType(inArray) <> VAR_VARIANT_ARRAY{NOT IsArray(inArray)} then Raise('inArray не массив!');
  	Result := False;
    if IsQCPluginEnabled AND (NOT isUseStringCompare) then
    begin // плагин есть и можно использовать
      i := gbl_QCPlugin.FindElementInArrayByOneDimension(inArray, element, ['x']);
      Result := NOT IsEmpty(i);
    end
    else // плагина нету
    begin 
    	iLow := VarArrayLowBound(inArray, 1);
      iHigh := VarArrayHighBound(inArray, 1);
      for i:= iLow to iHigh do
      begin
        if isUseStringCompare then
        	Result := StringCompare(element, inArray[i])
        else
          Result := (inArray[i] = element);
        if Result then break;
      end;
    end;  
  except
    Log.Message('FindElement: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Сортирует массив по возрастанию
  RESULT:
  REMARK:
}
procedure SortArray(
  var InArray: OleVariant // входной/выходной массив
);
var
	temp;
  i, j, iLow, iHigh: integer;  
begin
  try
  	iLow := VarArrayLowBound(InArray, 1);
    iHigh := VarArrayHighBound(InArray, 1);
    
  	for i:= (iLow+1) to iHigh do
    begin
    	j := i;
  		temp := InArray[i];
      while ((j > iLow) and (temp < InArray[j-1])) do
      begin
      	InArray[j] := InArray[j-1];
        j := j - 1;	
      end;    
      InArray[j] := temp;
    end;
  except
    Log.Message('SortArray: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Добавление к массиву Array1 массива Array2
  RESULT: Получивщийся массив возвращает в качестве результата
  REMARK:
}
function AddArrays(
  const Array1 : OleVariant; // первый массив
  const Array2 : OleVariant // второй массив
): OleVariant; // результат
var
	temp;
  i, j, Array1Low, Array1High, Array2Low, Array2High, ResSize: integer;  
begin
  try
  	Result := nil;
  	Array1Low := VarArrayLowBound(Array1, 1);
    Array1High := VarArrayHighBound(Array1, 1);
  	Array2Low := VarArrayLowBound(Array2, 1);
    Array2High := VarArrayHighBound(Array2, 1);
    
    ResSize := (Array2High - Array2Low + 1) + (Array1High - Array1Low + 1) - 1;
    Result := CreateVariantArray(0, ResSize);  
  	for i:= Array1Low to Array1High do	Result[i - Array1Low] := Array1[i];
    
    for i:= Array2Low to Array2High do 	Result[(Array1High - Array1Low + 1) + i - Array2Low] := Array2[i];
  except
    Log.Message('AddArrays: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Проверяет, является ли объект массивом
  RESULT:
  REMARK:
}
function IsArray(const arr : OleVariant) : boolean;
begin
	Result :=  VarType(arr) = VAR_VARIANT_ARRAY;
end;

{
  TYPE: Работа с массивами
  DESC: Добавляет элемент в конец массива.
  RESULT:  Возвращает количество элементов в массиве после вставки.
  REMARK: Если объект не массив, то делает его массивом.
}
function AddToArray(
  var arr : OleVariant; // массив
  const value : OleVariant // значение
) : integer;
  var
    highBound : integer;  
begin
  try
  	if VarType(arr) <> VAR_VARIANT_ARRAY then { если не массив }
    	arr := CreateVariantArray(0, 0); { то теперь массив }
    highBound := VarArrayHighBound(arr, 1);
  	if (VarType(arr[highBound]) <> varEmpty) then { если в массиве в конце нет свободных элементов }
    begin
      highBound := highBound + 1;
  		VarArrayRedim(arr, highBound ); { то увеличиваем его размер }
    end;  
  	arr[highBound] := value; { и пишем в его конец }
    Result := highBound - VarArrayLowBound(arr, 1) + 1;
  except
    Log.Message('AddToArray: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;  
end;


{
  TYPE: Работа с массивами
  DESC: Выполняет перестановку.
  RESULT: True, пока не выполнены все перестановки. False, если выполнены.
  REMARK: При первом вызове context не должен быть массивом. 
    Первый вызов только меняет контекст, перестановку не выполняет, так что можно вызывать просто в  while GetNextPermutation(arr, context) do begin ... arr ... end;
    Количество перестановок: n!  ( n-длина массива arr, !-знак факториала )
}
function GetNextPermutation(
  var arr : OleVariant;
  var context : OleVariant
) : boolean;
  var
    i, x, k, shift, n : integer;
    tmp : OleVariant;
begin
  try
    shift := 1 - VarArrayLowBound(arr,1);
    n := VarArrayHighBound(arr,1) + shift;
    
    if NOT IsArray(context) then
    begin // если контекст не задан, то инициализируем контекст
      context := CreateVariantArray2(0, 1, 1, n );
      for i := 1 to n do
      begin
        context[0, i] := 1; // C
        context[1, i] := true; // PR
      end;
      context[0, n] := 0;
      Result := true;
      Exit;
    end;

    // выполняем перестановку. алгоритм содран из книжки "В.Липский - Комбинаторика для программистов"
    i := 1;
    x := 0;
    while (context[0, i] = n - i + 1) do
    begin
      context[1, i] := NOT context[1, i];
      context[0, i] := 1;
      if context[1, i] then x := x + 1;
      i := i + 1;
    end;
    if i < n  then
    begin
      if context[1, i] then 
        k := context[0, i] + x - shift
      else
        k := n - i + 1 - context[0, i] + x - shift; 
      tmp := arr[k+1];
      arr[k+1] := arr[k];
      arr[k] := tmp;  
      context[0, i] := context[0, i] + 1;
    end;
    Result := (i < n);
  except
    Log.Message('GetNextPermutation: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Выполняет сочетание.
  RESULT: True, пока не выполнены все сочетания.
  REMARK: При первом вызове context не должен быть массивом. 
    Первый вызов только меняет контекст, сочетание не выполняет (возвращает k элементов из arr), так что можно вызывать просто в  while GetNextCombination(arr, 1, out, context) do begin ... arr ... end;
    Количество комбинаций: n!/(k!(n-k)!)  ( n - длина массива arr, k - сколько элементов в комбинации, !-факториал )
}
function GetNextCombination(
  const arr : OleVariant; // исходный массив, не модифицируется
  const k : integer; // по скольким перестанавливать
  var outArray : String; // массив подмножества
  var context : OleVariant // контекст
) : OleVariant;
var p, i, n, shift : integer;
begin
  try
    shift := 1 - VarArrayLowBound(arr,1);
    n := VarArrayHighBound(arr,1) + shift;
    
    if NOT IsArray(context) then
    begin // если контекст не задан, то инициализируем контекст
      context := CreateVariantArray(1, n+1 );
      for i := 1 to n do context[i] := i; 
      context[n+1] := k;
      outArray := CreateVariantArray(1, k);
      for i := 1 to k do  
        outArray[i] := arr[ context[i] - shift ];
      Result := true;  
      Exit;  
    end;

    p := context[n+1];
    while p >= 1 do
    begin
      if context[k]=n then p := p - 1
                      else p := k;
      if p>=1 then
      begin
        for i := k downto p do 
          context[i] := context[p] + i - p + 1;
        for i := 1 to k do // составляем результат
          outArray[i] := arr[ context[i] - shift ];
        Result := ( p >= 1 );  
        context[n+1] := p; 
        Exit;  
      end;  
    end;
  except
    Log.Message('GetNextCombination: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end; 

{
  TYPE: Работа с массивом
  DESC: Переставляет элементы одномерного массива в случайном порядке
  RESULT: Результирующий массив
  REMARK:
}
function RandomizeArray(
  arr : OleVariant // исходный массив
) : OleVariant; // переставленный массив
  var
    lowBound, highBound, i, idx, j : integer;
    temp : OleVariant;
begin
  try
    lowBound := VarArrayLowBound(arr,1);
    highBound := VarArrayHighBound(arr,1);
    for i := lowBound to highBound do 
    begin
      for j := 0 to Random(5) do
        idx := i + Random(highBound-i+1);
      if idx <> i then
      begin
        temp := arr[i];
        arr[i] := arr[idx];
        arr[idx] := temp;
      end;
    end;
    Result := arr;
  except
    Log.Message('' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;
{
  TYPE: Работа со строками; Работа с массивами
  DESC: Функция разбивает строку по разделителям и формирует массив из подстрок
  RESULT:
  REMARK:
}
function String2Array(
  const sText: String; // исходная строка
  const sDelimeter: String = EndOfLine // разделитель, если он пустой, то срока разобъется в массив посимвольно
): OleVariant; // результирующий массив
  var
    i : longint;
    curr_text, end_elem, value: String;
    position;
    isLast: Boolean;
    TempArray: OleVariant;
begin
  try
    Result := nil;
    if (sDelimeter = '') then
    begin
      Result := CreateVariantArray(1, Length(sText));
      for i := 1 to Length(sText) do Result[i] := sText[i];
      Exit; 
    end;
    if IsQcPluginEnabled then
      Result := gbl_QCPlugin.String2Array(sText, sDelimeter)
    else
    begin  
      i := 0;
      isLast := False;
      position := 1;
      TempArray := CreateVariantArray(0, 0);
      TempArray[0] := '';
      while (position <> 0) do
      begin
        position := Pos(sDelimeter, sText);
        if (position <> 0) then
          curr_text := Copy(sText, 1, position-1)
        else
        begin
          curr_text := sText;
          isLast := True;
        end;
        Delete(sText, 1, position + Length(sDelimeter) - 1);
        if (not isLast) then
        begin
        	TempArray[i] := curr_text;
        	i := i + 1;
        	VarArrayRedim(TempArray, i);		
        end
        else
        begin
        	TempArray[i] := curr_text;
          break;
        end;    
      end;
      	Result := TempArray;
    end;        
  except
    Log.Message('String2Array: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));

    Raise;
    CommonExceptionHandler;
  end;
end;

procedure _____WINDOWS_WORKS;begin;end;

{
  TYPE: Работа с окнами
  DESC:
    Поиск похожих окон (с одинаковым классом). Возвращает окно, заданное своими координатами
    на экране (например 2й сверху и 3й слева.)
  RESULT:
  REMARK:
    Если у объекта недоступно свойство WndClass, то используется свойство VCLClass,
    если недоступно WndCaption, то используется Caption (например, у кнопок на тулбарах).
}
function FindSimilarWindow( 
  const parentWindow : OleVariant; // окно, где лежат похожие окна 
  const propNames : OleVariant;
  const propValues : OleVariant;  
  const HOrder, VOrder : integer; // горизонтальный и вертикальный порядок (0 - не важно; 1 - первый и т.д. )
  const deep : integer = 1 // глубина поиска окошек
) : OleVariant;
  var
    arrVert, arrHor, Vert, Hor, Res : OleVariant;                           
    i, k, order, lowBound, highBound : integer;
begin
  try
    if NOT IsExists(parentWindow) then 
      Raise('Родительский объект не существует!');
    parentWindow.Refresh;
    arrVert := parentWindow.FindAll(propNames, propValues, deep);
    arrHor := arrVert;
    lowBound := VarArrayLowBound(arrVert, 1);
    highBound := VarArrayHighBound(arrVert, 1);
    // теперь сортируем окна по горизонтали и по вертикали по возрастанию координат
    SortArrayEx(arrVert, 'y.ScreenTop > x.ScreenTop');
    SortArrayEx(arrHor, 'y.ScreenLeft > x.ScreenLeft');
    // теперь заполняем выборки
      // сначала заполняем массив окон, одинаковых по порядку, по горизонтали
    Vert := nil;
    if VOrder > 0 then 
    begin
  		//Vert := CreateVariantArray(0,0);
  	  order := 1; // порядок текущего элемента
  	  for i := lowBound to highBound do
  	  begin
      	if i > lowBound then                         
  		  	if arrVert[i].ScreenTop > arrVert[i-1].ScreenTop then
  		    	order := order + 1;
  	    if VOrder = order then
  	    	AddToArray(Vert, arrVert[i]);
  	  end;
    end;
      // теперь заполняем массив окон, одинаковых по порядку, по вертикали
    Hor := nil;
    if HOrder > 0 then 
    begin
  		//Hor := CreateVariantArray(0,0);
  	  order := 1; // порядок текущего элемента
  	  for i := lowBound to highBound do
  	  begin
      	if i > lowBound then
  		  	if arrHor[i].ScreenLeft > arrHor[i-1].ScreenLeft then
  		    	order := order + 1;
  	    if HOrder = order then
  	    	AddToArray(Hor, arrHor[i]);
  	  end;
    end;
    // формируем результат
    if IsArray(Vert) AND IsArray(Hor) then
    	Res := Intersection(Vert, Hor) // если массивы заполнены, то пересекаем их
    else if IsArray(Vert) then
    	Res := Vert
    else if IsArray(Hor) then
    	Res := Hor;
    if IsArray(Res) then 
  	  Result := Res[ VarArrayLowBound(Res,1) ] // отдаем первый элемент результата
    else
    	Result := nil; // если Res не массив, значит нифига не найдено
  except
    Log.Message('FindSimilarWindow: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;     
end;

{
  TYPE: Работа с окнами
  DESC: Ищет окно по параметрам
  RESULT: Окно или пустой объект
  REMARK: 
    Строка параметров имеет вид: Name:=ИМЯ_ОКНА;WndClass:=КЛАСС_ОКНА;INDEX:=1;WndCaption:=НАЗВАНИЕ;Timeout:=10000;SearchesCount:=2
    Неуказанные параметры будут заменены значениями по-умолчанию
    Если окно не найдено, то выбрасывает EX_CANNOT_FIND_WINDOW (а если существует переменная проекта DUMP_WINDOWS, то дампит детей родителя)
    WndClass и WndCaption сравниваются с спосмощью StringCompare -> можно использовать маски
    
    !!! В СКРИПТАХ ЭТУ ФУНКЦИЮ НЕ ИСПОЛЬЗОВАТЬ !!!
    
    Параметр IsThrowException служебный, явно его не задавать
}
function FindWindowByParams(
  const parent : OleVariant; // объект, среди детей которого ищем
  const paramString : OleVariant; // строка параметров
  const paramDelimiter : String = ';' // разделитель групп Параметр:=Значение
) : OleVariant;
  const
    DEFAULT_STR = '__NULL__';
  var
    name, wndClass, wndCaption, hint, str, vclClass, caption, text, emptyHint, helpKeyword, typeName, ownerName : String;
    wndIndex, maxDepth : Integer;
    visible, enabled, mainWnd, activeWnd : OleVariant;     
    i, j, searchesCount, timeOut, timeOutEl, timeToWait, timeElapsed : integer;
    paramList : OleVariant;
    isSelected, isChecked, isWaitWindowOnly, isNotUseWaitWindow, isDumpWindows, res, isThrowException, isRefresh, isAddCheckInfo, visibleOnScreen : boolean;
    propNames, propValues : OleVariant;
begin
  try
    Result := NonExObj;

    if NOT IsExists(parent) then Raise('Родительский объект не найден');
            
    try    
      if NOT IsMap(paramString) then
      begin // стандартный пользовательский вызов        
        paramList := ParseParamString(paramString, true, paramDelimiter);
        isThrowException := VarConvert( GetParam(paramList, 'IsThrowException', true ), varBoolean );
     
        // параметры окон 
        name := GetParam(paramList, 'Name', DEFAULT_STR);
        if (name <> DEFAULT_STR) AND (Pos('VCLObject(', name) = 0) then                          
          name := 'VCLObject(''' + name + '*'')';          
        wndClass := GetParam(paramList, 'WndClass', DEFAULT_STR);
        wndCaption := GetParam(paramList, 'WndCaption', DEFAULT_STR);
        wndIndex := GetParam(paramList, 'Index', DEFAULT_STR);
        vclClass := GetParam(paramList, 'VCLClass', DEFAULT_STR);
        caption := GetParam(paramList, 'Caption', DEFAULT_STR);
        text := GetParam(paramList, 'Text', DEFAULT_STR);
        hint := GetParam(paramList, 'Hint', DEFAULT_STR);
        emptyHint := GetParam(paramList, 'EmptyHint', DEFAULT_STR);
        helpKeyword := GetParam(paramList, 'HelpKeyword', DEFAULT_STR);
        isSelected := GetParam(paramList, 'IsSelected', DEFAULT_STR);        
        isChecked := GetParam(paramList, 'IsChecked', DEFAULT_STR);
        visible := GetParam(paramList, 'Visible', DEFAULT_STR);
        enabled := GetParam(paramList, 'Enabled', DEFAULT_STR);
        visibleOnScreen := GetParam(paramList, 'VisibleOnScreen', DEFAULT_STR);
        typeName := GetParam(paramList, 'type', DEFAULT_STR);
        ownerName := GetParam(paramList, 'OwnerName', DEFAULT_STR);

        // заполянем массивы имен свойств и их значений
        if name <> DEFAULT_STR then begin       AddToArray(propNames, 'Name');      AddToArray(propValues, name); end;
        if wndClass <> DEFAULT_STR then begin   AddToArray(propNames, 'WndClass');  AddToArray(propValues, wndClass); end;
        if wndCaption <> DEFAULT_STR then begin AddToArray(propNames, 'WndCaption');AddToArray(propValues, wndCaption); end;    
        if hint <> DEFAULT_STR then begin       AddToArray(propNames, 'hint');      AddToArray(propValues, hint); end;    
        if emptyHint <> DEFAULT_STR then begin  AddToArray(propNames, 'EmptyHint'); AddToArray(propValues, emptyHint); end;    
        if helpKeyword <> DEFAULT_STR then begin  AddToArray(propNames, 'HelpKeyword'); AddToArray(propValues, helpKeyword); end;        
        if vclClass <> DEFAULT_STR then begin   AddToArray(propNames, 'VCLClass');  AddToArray(propValues, vclClass); end;    
        if caption <> DEFAULT_STR then begin    AddToArray(propNames, 'Caption');   AddToArray(propValues, caption); end;    
        if text <> DEFAULT_STR then begin       AddToArray(propNames, 'Text');      AddToArray(propValues, text); end;
        if isSelected <> DEFAULT_STR then begin  AddToArray(propNames, 'IsSelected');   AddToArray(propValues, VarConvert(isSelected, varBoolean)); end;
        if isChecked <> DEFAULT_STR then begin  AddToArray(propNames, 'IsChecked');   AddToArray(propValues, VarConvert(isChecked, varBoolean)); end;
        if visible <> DEFAULT_STR then begin    AddToArray(propNames, 'Visible');   AddToArray(propValues, VarConvert(visible, varBoolean)); end;
        if visibleOnScreen <> DEFAULT_STR then begin    AddToArray(propNames, 'VisibleOnScreen');   AddToArray(propValues, VarConvert(visibleOnScreen, varBoolean)); end;
        if enabled <> DEFAULT_STR then begin    AddToArray(propNames, 'Enabled');   AddToArray(propValues, VarConvert(enabled, varBoolean)); end;
        if wndIndex <> DEFAULT_STR then begin   AddToArray(propNames, 'Index');     AddToArray(propValues, VarConvert(wndIndex, varInteger)); end;
        if typeName <> DEFAULT_STR then begin   AddToArray(propNames, 'TypeName');      AddToArray(propValues, typeName); end;
        if ownerName <> DEFAULT_STR then begin   AddToArray(propNames, 'OwnerName');      AddToArray(propValues, ownerName); end;

        SetParam(paramList, 'PropNames', propNames);
        SetParam(paramList, 'PropValues', propValues);
      
        // параметры для функции
        isDumpWindows := VarConvert( GetParam(paramList, 'DumpWindows', true), varBoolean );
      end  
      else // функция вызывает саму себя
      begin
        isThrowException := false;
        isDumpWindows := false;
        paramList := paramString;
        propNames := GetParam(paramList, 'PropNames');
        propValues := GetParam(paramList, 'PropValues');      
      end;
    except
      Log.Message('FindWindowByParams.Исключение при заполнении параметров: ' + ExceptionMessage, DbgVarValue(paramString, 'paramString'),  pmNormal, GetLogAttr('EXCEPTION'));
    end;      
        
    // параметры для функции
    maxDepth := VarConvert( GetParam(paramList, 'MaxDepth', 1 ), varInteger );
    isRefresh := VarConvert( GetParam(paramList, 'IsRefresh', true ), varBoolean );
    searchesCount := VarConvert( GetParam(paramList, 'SearchesCount', 1 ), varInteger );
    timeOut := VarConvert( GetParam(paramList, 'TimeOut', 0 ), varInteger );
    isAddCheckInfo := BuiltIn.VarToBool( GetParam(paramList, 'IsAddCheckInfo', false ) );     
    SetParam(paramList, 'IsAddCheckInfo', false ); // это чтобы дальнейшие вызовы самой себя не сглючили      
    
    timeOutEl := timeOut div Max(1, (searchesCount-1));
    
    try
      for j := 1 to searchesCount do
      begin 
        timeElapsed := Win32API.GetTickCount;

        if (maxDepth > 0) then
        begin // ищем среди детей
          if isRefresh then parent.Refresh;
          Result := parent.Find(propNames, propValues, maxDepth);
        end //if
        else if (maxDepth < 0) then
        begin // ищем родителя
          if NOT IsSupported(parent, 'Parent') then Raise('Хотим получить Parent у объекта, который его не поддерживает!');
          parent := parent.Parent;
          // проверяем родителя
          SetParam(paramList, 'MaxDepth', 0);
          SetParam(paramList, 'SearchesCount', 1);                    
          if IsExists(parent) then
            Result := FindWindowByParams(parent, paramList);
                                
          if IsExists(Result) then
            break;                  
          
          // если не нашли то ищем на уровень выше                    
          SetParam(paramList, 'MaxDepth', maxDepth+1);
          SetParam(paramList, 'SearchesCount', searchesCount);            
          Result := FindWindowByParams(parent, paramList);                                                          
        end // else if    
        else if (maxDepth = 0) then 
        begin // проверяем только родительский объект на соответствие
          if CheckObjectParams(parent, propNames, propValues) then
            Result := parent;
        end; //else if    
      
        if IsExists(Result) then
          break;
      
        timeElapsed := Win32API.GetTickCount - timeElapsed;
        timeToWait := timeOutEl - timeElapsed;
        if (j <> searchesCount) AND (timeToWait > 0) AND (maxDepth > 0) then
          Delay(timeToWait);
      end; //for
    except
      Log.Message('FindWindowByParams.Исключение при поиске: ' + ExceptionMessage, DbgVarValue(paramString, 'paramString'),  LOG_PRIORITY_INTERNAL, GetLogAttr('EXCEPTION'));
    end;  
      
    if NOT IsExists(Result) then
      if isThrowException then
        Raise(EX_CANNOT_FIND_WINDOW)       
      else
      begin
        Result := NonExObj;
        Exit;
      end;
            
    // до этой строки Result всегда представляет собой окно
    if isAddCheckInfo then
    begin
      SetParam(Result, 'OBJECT', Result);
      SetParam(Result, 'ID', CACHE_CHECK_INFO_ID);
      SetParam(Result, 'PROPNAMES', propNames);
      SetParam(Result, 'PROPVALUES', propValues);            
    end;  
                       
  except
    Log.Message('FindWindowByParams: ' + ExceptionMessage, DbgVarValue(paramString, 'paramString'),  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;

{
  TYPE: Работа с окнами
  DESC: Возвращает окно по пути, составленному из параметров окон, к нему ведущих
  RESULT:
  REMARK: Путь типа: NAME:=cfFolders;WNDCLASS:=TcfFolders|NAME:=enFoldersTree;WNDCLASS:=TenFoldersTree|NAME:=FoldersTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop
    Внутри вызывает FindWindowByParams.
    Если окно не найдено, то выбрасывает EX_CANNOT_FIND_WINDOW.
    
    Параметр IsThrowException служебный для функции FindWindowByParams, в пути path явно его не задавать!
}
function FindWindowByPath(
  const parent : OleVariant; 
  const path : String;
  const isThrowException : boolean = true;
  paramString : String = '';
  const paramGroupDelimiter : String = '|'
): OleVariant;
  const
    FUNCTION_NAME = 'FindWindowByPath';
  var 
    arr : OleVariant;
    i, j : integer;
    paramList, commonParams, params4FWBP, resultWnd, parentProcess;
    searchesCount, timeOut, timeOutEl, timeElapsed, timeToWait : integer;
    parentFullName, resultFullName : String;
    isAddCheckInfo : boolean;
begin
  try  
    params4FWBP := '';
    //if (commonParams <> '') AND (commonParams[1] <> ';') then Insert(';', commonParams, 1);
    if NOT IsExists(parent) then Raise('Родительский объект не найден');
    arr := String2Array(path, paramGroupDelimiter);
    parentProcess := GetProcessFromWnd(parent);
      
    paramList := ParseParamString(paramString);
    
    searchesCount := BuiltIn.VarToInteger( GetParam(paramList, 'SearchesCount', 2 ) );
    timeOut := BuiltIn.VarToInteger( GetParam(paramList, 'TimeOut', Options.Run.Timeout div 2 ) );    
    isAddCheckInfo := BuiltIn.VarToBool( GetParam(paramList, 'IsAddCheckInfo', false ) );
    //          
    ProcessKiller(FUNCTION_NAME, 'START', Max(Options.Run.Timeout, timeOut*4), parent);
    try      
      timeOutEl := timeOut div Max(1, (searchesCount-1));   
      commonParams := 
        'TIMEOUT:=' + IntToStr(timeOutEl div ArrayLength(arr) ) +
        ';SEARCHESCOUNT:=' + IntToStr( Choose(searchesCount <= 2, searchesCount + 1, searchesCount*2) ) +
        ';IsThrowException:=' + VarToString(isThrowException) + ';';

      if (VarType(arr) = VAR_VARIANT_ARRAY) then
        for j := 1 to searchesCount do
        begin
          resultWnd := parent;
        
          timeElapsed := Win32API.GetTickCount;
          for i := VarArrayLowBound(arr, 1) to VarArrayHighBound(arr, 1) do
          begin
            params4FWBP := commonParams + arr[i];
            if isAddCheckInfo AND (i = VarArrayHighBound(arr, 1)) then
              params4FWBP := 'IsAddCheckInfo:=true;' + params4FWBP;
              
            Result := FindWindowByParams(resultWnd, params4FWBP);
         
            // проверяем, может нам вернули данные для проверки в кэше          
            if IsCheckInfoAdded(Result) then            
              resultWnd := GetParam(Result, 'Object', NonExObj)
            else
              resultWnd := Result;
          
            if (NOT isThrowException) AND (NOT IsExists(resultWnd)) then
            begin
              Result := NonExObj;
              Exit;
            end;            
          end; // for i := VarArrayLowBound(arr, 1) to VarArrayHighBound(arr, 1)
          timeElapsed := Win32API.GetTickCount - timeElapsed;
          timeToWait := timeOutEl - timeElapsed;
        
          // считаем что если id=0 то объект не валидный
          if IsSupported(resultWnd, 'Id') AND (resultWnd.Id = 0) then
          begin // пытаемся что-то сделать с этим объектом
            Log.Message(FUNCTION_NAME + ': Нашли невалидное окно, будем ждать валидного в течение ' + VarToString(timeToWait) + ' мсек.');          
            repeat
              resultWnd.Parent.Refresh;
              timeElapsed := Win32API.GetTickCount;
              resultWnd   := Evaluate(resultWnd.FullName);
              timeElapsed := Win32API.GetTickCount - timeElapsed;
              timeToWait  := timeToWait - timeElapsed;
            until (resultWnd.Id <> 0) OR (timeToWait < 0);
          end;
          if IsSupported(resultWnd, 'Id') AND (resultWnd.Id = 0) then
            Raise(EX_NOT_VALID_WINDOW);

          if IsCheckInfoAdded(Result) then 
            SetParam(Result, 'Object', resultWnd)
          else
            Result := resultWnd;                      
        
          if IsExists(resultWnd) then break;
        
          if (j <> searchesCount) AND (timeToWait > 0) then
            Delay(timeToWait);  
        end // for j := 1 to searchesCount      
      else
        Raise('Неверно заданы параметры!'); 
    finally
      ProcessKiller(FUNCTION_NAME, 'STOP');
    end;     
  except
    if IsExists(parent) then  parentFullName := GetValueIfSupported(parent, 'FullName', 'объект не существует или свойство FullName не поддерживается');
    if IsExists(resultWnd) then  resultFullName := GetValueIfSupported(resultWnd, 'FullName', 'объект не существует или свойство FullName не поддерживается');    
    Log.Message(
      FUNCTION_NAME + ': ' + ExceptionMessage,
      'Path: "' + path + '"' + EndOfLine + EndOfLine +
        'commonParams: "' + VarToStr(commonParams) + '"; ' + EndOfLine + EndOfLine +
        'Исключение произошло когда обрабатывали: "' + params4FWBP + '"' + EndOfLine + EndOfLine +
        'Родитель: "' + parentFullName  + '"' + EndOfLine + EndOfLine +
        'Объект: "' + resultFullName  + '"',
      pmNormal, GetLogAttr('EXCEPTION') );

    if (ExceptionMessage = EX_NOT_VALID_WINDOW) then 
    begin
      Log.Message(FUNCTION_NAME + ': Так как объект невалидный, то возвращать будем non-existent объект.');
      Result := NonExObj;
    end;    
            
    if isThrowException then Raise else Result := NonExObj;
    CommonExceptionHandler;
  end;
end;


procedure _____PRIME_CONTROLS;begin;end;

{
  TYPE: Общие
  DESC: Возвращает главное окно прайма.
  RESULT: Окно оболочки или пустой объект.
  REMARK: 
}
function F1Prime_GetMainWindow(
  const additionalParams : String = ''
) : OleVariant;
  var 
    p, i : OleVariant;
begin
  try
    p := GetF1PrimeProcess;
    Result := FindWindowByPath(p, 'NAME:=MonitoringsMainForm;WndClass:=TMonitoringsMainForm;' + additionalParams);
  except
    Log.Message('F1Prime_GetMainWindow: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Возвращает главное окно интерфейса Админа.
  RESULT: Окно оболочки или пустой объект.
  REMARK: 
}
function F1Admin_GetMainWindow(
  const additionalParams : String = ''
) : OleVariant;
const
  FUNCTION_NAME = 'F1Admin_GetMainWindow';
  var 
    p, i : OleVariant;
begin
  try
    p := GetF1AdminProcess;               
    Result := FindWindowByPath(p, 'NAME:=AdminMainForm;WndClass:=TAdminMainForm;' + additionalParams);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты Прайма/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
}
function F1Prime_GetFromMainWindow(
  whatToGet : String;
  const addParams : String = '';
  parent : OleVariant = nil
) : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    if not IsExists(GetF1PrimeProcess) then
      Raise('Процесс "' + PRIME_PROCESS_NAME + '" не найден!'); 
    if (parent = nil) then parent := F1Prime_GetMainWindow(addParams);
    
    case whatToGet of
      'СТАТУСБАР' :
        Result := FindWindowByPath(parent, 'NAME:=nscDock_for_nscStatusbar;WNDCLASS:=TnscStatusBarDock|NAME:=StatusBar;WNDCLASS:=TnscStatusBar', true, addParams
        );
      'ПРЕВЬЮ', 'ПРЕДВАРИТЕЛЬНЫЙ ПРОСМОТР' :
        Result := FindWindowByPath(parent, 'NAME:=efPreviewForm;WNDCLASS:=TefPreviewForm;MAXDEPTH:=7|NAME:=PreviewPanel;WNDCLASS:=TnscPreviewPanel'
        );
      'ФОРМА КАРТОЧКИ ЗАПРОСА':
        Result := FindWindowByPath(parent, 'NAME:=ParentForm;WNDCLASS:=TParentForm;MAXDEPTH:=5|NAME:=cfSaveLoad;WNDCLASS:=TcfSaveLoad;MAXDEPTH:=2|WNDCLASS:=TenQueryCard;MAXDEPTH:=2', true, addParams
        );
      'ЗАГОЛОВОК КЗ' :
        Result := FindWindowByPath(parent, 'NAME:=ParentForm;WNDCLASS:=TParentForm;MAXDEPTH:=5|NAME:=cfSaveLoad;WNDCLASS:=TcfSaveLoad;MAXDEPTH:=2|NAME:=lbHeader;VCLCLASS:=TvtLabel;Caption:=Создание индивидуальной ленты', true, addParams
        );
      'КАРТОЧКА ЗАПРОСА':
        Result := FindWindowByPath(
          F1Prime_GetFromMainWindow('ФОРМА КАРТОЧКИ ЗАПРОСА', addParams, parent),
          'NAME:=Editor;WNDCLASS:=TevQueryCardEditor', true, addParams
        );
      'ТУЛБАР "МОЯ НОВОСТНАЯ ЛЕНТА"' :
        Result := FindWindowByPath(
          F1Prime_GetFromMainWindow('ФОРМА СПИСКА РАССЫЛОК', addParams, parent),
          'NAME:=tbenPostingsListTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4', true, addParams
        );
      'НИЖНИЙ ТУЛБАР КАРТОЧКИ ЗАПРОСА' :
        Result := FindWindowByPath(parent, 'NAME:=ParentForm;WNDCLASS:=TParentForm;MAXDEPTH:=5|NAME:=cfSaveLoad;WNDCLASS:=TcfSaveLoad;MAXDEPTH:=2|NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4', true, addParams
        );
      'ВЕРХНИЙ ТУЛБАР КАРТОЧКИ ЗАПРОСА' :
        Result := FindWindowByPath(
          F1Prime_GetFromMainWindow('ФОРМА КАРТОЧКИ ЗАПРОСА', addParams, parent),
          'NAME:=tbenQueryCardTop;WNDCLASS:=TvcmToolbar', true, addParams
        );
      'ФОРМА "ОБЗОР ПАПОК"':
        Result := FindWindowByPath(GetF1PrimeProcess, 'WNDCLASS:=Static;WNDCAPTION:=Выберите каталог для сохранения файла индивидуальных настроек*;MAXDEPTH:=2|WNDCLASS:=#32770;MAXDEPTH:=-1', true, addParams
        );
      'ФОРМА СПИСКА РАССЫЛОК' :
        Result := FindWindowByPath(parent, 'NAME:=LeftNavigator;WNDCLASS:=TnscNavigator;MAXDEPTH:=3|NAME:=enPostingsList;WNDCLASS:=TenPostingsList;MAXDEPTH:=5', true, addParams
        );
      'СПИСОК РАССЫЛОК' :
        Result := FindWindowByPath(
          F1Prime_GetFromMainWindow('ФОРМА СПИСКА РАССЫЛОК', addParams, parent),
          'NAME:=tvPostings;WNDCLASS:=TeeTreeView', true, addParams
        );
    else
      Raise('Параметр не распознан!');
    end;    
  except
    Log.Message('F1Prime_GetFromMainWindow: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;


procedure _____F1SHELL_AND_TABBED_CONTROLS;begin;end;

{
  TYPE: Общие
  DESC: Возвращает главный контейнер окон оболочки. Работает только в режиме вкладок.
  RESULT: Контейнер (окно) процесса оболочки или пустой объект.
  REMARK: В случае неудачи выбрасывает исключение EX_CANNOT_FIND_WINDOW.
    'ContainerIndex' - используется только внутри функции, для определения окна контейнера, индекс 1 - активный контейнер, проще говоря активное окно с вкладками
}
function GetMainContainer(
  const additionalParams : String = ''
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetMainContainer';
  var 
    p, searchPath : OleVariant;
    cacheKey, rawWindow, paramList;
    containerIndexNum, timeOut : integer;
begin
  try
    paramList := ParseParamString(additionalParams);
    containerIndexNum := VarToInteger( GetParam(paramList, 'ContainerIndex', -1) );
    timeOut := VarToInteger( GetParam(paramList, 'TimeOut', Options.Run.Timeout div 3) );

    //CACHE
    cacheKey := FUNCTION_NAME + 'MainContainer' + IntToStr(containerIndexNum);
    
    p := GetActiveProcess(timeOut);
    
    if NOT Cache_Check(p, cacheKey, Result) then
    begin
      // получаем по-нормальному
      searchPath := 'WndClass:=TvcmTabbedContainerForm';
      if containerIndexNum <> -1 then
        searchPath := searchPath + ';Index:=' + IntToStr(containerIndexNum);
      Result := FindWindowByPath(p, searchPath, true, additionalParams);

{
      // получаем как простое окно
      if NOT IsExists(Result) then
      begin
        ProcessKiller(FUNCTION_NAME, 'start', Options.Run.Timeout, p);
        try
          rawWindow := p.WaitWindow('TvcmTabbedContainerForm', '*', containerIndexNum, 0);
          if IsExists(rawWindow) then
            Result := rawWindow;
        finally
          ProcessKiller(FUNCTION_NAME, 'stop');        
        end;
      end;
}
      Result := Cache_Put(p, cacheKey, Result);
    end;
   
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);  
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Возвращает главное окно оболочки
  RESULT: Окно оболочки или пустой объект
  REMARK: В случае неудачи выбрасывает исключение EX_CANNOT_FIND_WINDOW
    Параметры:
    'ContainerIndex' - используется только внутри функции, для определения окна 
    'TabIndex' - используется только внутри функции, для определения вкладки, индекс 1 - активное окно, то что на активной вкладке
                (!) НО индексы вкладок и окон НЕ совпадают
}
function GetMainWindow(
  const additionalParams : String = ''
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetMainWindow';
  var 
    p, i, fullName, searchPath : OleVariant;
    cacheKey, rawWindow, paramList;
    tabIndexNum, containerIndexNum : integer;
begin
  try
    paramList := ParseParamString(additionalParams);
    tabIndexNum := VarToInteger( GetParam(paramList, 'TabIndex', -1) );
    containerIndexNum := VarToInteger( GetParam(paramList, 'ContainerIndex', -1) );

    //CACHE
    cacheKey := FUNCTION_NAME + 'MainWindow';
    if VarToBool(gbl_F1ShellTabsEnabled) then
      cacheKey := cacheKey + IntToStr(containerIndexNum)
    else 
      cacheKey := cacheKey + IntToStr(tabIndexNum);

    p := GetActiveProcess(Options.Run.Timeout div 3);
    if not IsExists(p) then
      Raise(EX_CANNOT_FIND_WINDOW);
    
    if NOT Cache_Check(p, cacheKey, Result) then
    begin
      fullName := p.FullName;
      if StringCompare('*' + SHELL_PROCESS_NAME + '*', fullName) then
      begin // оболочка
        if VarToBool(gbl_F1ShellTabsEnabled) then
        begin
          // режим вкладок
          // получаем по-нормальному
          searchPath := 'WndClass:=TvcmTabbedContainerForm';
          if containerIndexNum <> -1 then
            searchPath := searchPath + ';Index:=' + IntToStr(containerIndexNum);

          searchPath := searchPath + '|WndClass:=TvtPanel|WndClass:=TnsMainWindow;Visible:=true';
          if tabIndexNum <> -1 then
            searchPath := searchPath + ';Index:=' + IntToStr(tabIndexNum);
          
          Result := FindWindowByPath(p, searchPath, true, additionalParams);
          
{
          // получаем как простое окно
          if NOT IsExists(Result) then
          begin
            ProcessKiller(FUNCTION_NAME, 'start', Options.Run.Timeout, p);
            try        
              rawWindow := p.WaitWindow('TvtPanel', '*', -1, 0).WaitWindow('TnsMainWindow', '*', tabIndexNum, 0);
              if (IsExists(rawWindow)) AND (rawWindow.Visible) then
                Result := rawWindow;
            finally
              ProcessKiller(FUNCTION_NAME, 'stop');
            end;
          end;
}          
        end
        else
        begin
          // обычный режим без вкладок
          // получаем по-нормальному
          searchPath := 'NAME:=nsMainWindow;WndClass:=TnsMainWindow';
          if tabIndexNum <> -1 then
            searchPath := searchPath + ';Index:=' + IntToStr(tabIndexNum);
          Result := FindWindowByPath(p, searchPath, true, additionalParams);

{
          // получаем как простое окно
          if NOT IsExists(Result) then
          begin
            ProcessKiller(FUNCTION_NAME, 'start', Options.Run.Timeout, p);
            try        
              rawWindow := p.WaitWindow('TnsMainWindow', '*', tabIndexNum, 0);
              if IsExists(rawWindow) then
                Result := rawWindow;
            finally
              ProcessKiller(FUNCTION_NAME, 'stop');
            end;
          end;
}            
        end;
      end
      else if StringCompare('*' + PRIME_PROCESS_NAME + '*', fullName) then
      begin // Прайм
        Result := F1Prime_GetMainWindow;
      end
      else if StringCompare('*' + ADMIN_PROCESS_NAME + '*', fullName) then
      begin // Админ
        Result := F1Admin_GetMainWindow;
      end;
      Result := Cache_Put(p, cacheKey, Result);      
    end;
   
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);  
  except
    Log.Message('GetMainWindow: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Возвращает индекс активной вкладки
  RESULT: Integer
  REMARK: Вспомогательная функция, принудительно выбрасывает исключение в случае ошибки
}
function GetIndexOfActiveTab(
  parent : OleVariant
) : Integer;
var
  i;
begin
  Result := -1;

  for i := 0 to parent.TabCount - 1 do
    if parent.Tabs[i].IsSelected then
    begin
      Result := i;
      break; 
    end;

  if Result = -1 then
    Raise('Активная вкладка не найдена!');
end;

{
  TYPE: Общие
  DESC: Возвращает индекс НЕактивной вкладки
  RESULT: Integer
  REMARK: Вспомогательная функция, принудительно выбрасывает исключение в случае ошибки
}
function GetIndexOfInactiveTab(
  parent : OleVariant
) : Integer;
var
  i;
begin
  Result := -1;

  for i := 0 to parent.TabCount - 1 do
    if not parent.Tabs[i].IsSelected then
    begin
      Result := i;
      break; 
    end;

  if Result = -1 then
    Raise('Неактивная вкладка не найдена!');
end;

{
  TYPE: Общие
  DESC: Возвращает индекс вкладки, найденной по ее заголовку
  RESULT: Integer
  REMARK: Вспомогательная функция, принудительно выбрасывает исключение в случае ошибки
}
function GetIndexOfTabByCaption(
  parent : OleVariant;
  tabName: String
) : Integer;
var
  i;
begin
  Result := -1;

  for i := 0 to parent.TabCount - 1 do
    if StringCompare(tabName, parent.Tabs[i].Text) then
    begin
      Result := i;
      break; 
    end;

  if Result = -1 then
    Raise('Вкладка с заголовком "' + tabName + '" не найдена!');
end;

{
  TYPE: Общие
  DESC: Возвращает объект с вкладками
  RESULT: Окно
  REMARK: Вспомогательная функция, принудительно выбрасывает исключение в случае ошибки
}
function GetTabSetControl(
  parent : OleVariant
) : OleVariant;
begin
  Result := NonExObj;
  if not IsExists(parent) then
    Raise('Родитель для объекта TabSetControl не найден!');
    
  Result := FindWindowByPath(parent, 'WndClass:=TFormFrameDecorator|WndClass:=TChromeLikeTabSetControl', true);
  if not IsExists(Result) then
    Raise('Не получилось найти объект TabSetControl!');
    
  if not (IsSupported(Result, 'TabCount') and IsSupported(Result, 'Tabs')) then
    Raise('Не найдено свойство "TabCount" или "Tabs", считаем невалидным объект TabSetControl!');    
end;

{
  TYPE: Общие
  DESC: Возвращает название активной вкладки
  RESULT: Строка
  REMARK:
    'ContainerIndex' - используется для определения окна 
    'TabIndex' - если не задано, то находится текст названия активной вкладки, иначе определеяет индекс вкладки
}
function GetTabCaption(
  const additionalParams : String = ''
) : String;
  const 
    FUNCTION_NAME = 'GetTabCaption';
  var 
    w, paramList : OleVariant;
    tabIndexNum : Integer;
begin
  try
    paramList := ParseParamString(additionalParams);
    tabIndexNum := VarToInteger(GetParam(paramList, 'TabIndex', -1));

    w := GetTabSetControl(GetMainContainer(additionalParams));

    if tabIndexNum = -1 then
      tabIndexNum := GetIndexOfActiveTab(w)
    else
      if tabIndexNum >= w.TabCount then
        Raise('Индекс вкладки больше количества вкладок!');

    Result := w.Tabs[tabIndexNum].Text;
  except
    Result := '';
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Возвращает количество окон оболочки
  RESULT: Integer
  REMARK:
}
function GetContainerWindowCount(
  const additionalParams : String = ''
) : Integer;
  const 
    FUNCTION_NAME = 'GetContainerWindowCount';
  var 
    p, w;
    i, beg_index;
begin
  try
    for beg_index := 0 to MAX_WINDOWS do
    begin
      w := GetMainContainer('TimeOut:=10;ContainerIndex:=' + IntToStr(beg_index));
      if IsExists(w) then
      begin
        for i := beg_index + 1 to beg_index + MAX_WINDOWS + 1 do
        begin
          w := GetMainContainer('TimeOut:=10;ContainerIndex:=' + IntToStr(i));
          if not IsExists(w) then
          begin
            Result := i - beg_index;
            Exit; 
          end;
        end;
        Raise('Ошибка, количество окон оболочки превышает максимальное значение "' + IntToStr(MAX_WINDOWS) + '"');
      end;
    end;
    Raise('Ни одного окна не найдено!');    
  except
    Result := -1;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Возвращает количество вкладок
  RESULT: Integer
  REMARK:
    'ContainerIndex' - используется для определения окна
}
function GetTabsCount(
  const additionalParams : String = ''
) : Integer;
  const 
    FUNCTION_NAME = 'GetTabsCount';
  var 
    w;
begin
  try
    w := GetTabSetControl(GetMainContainer(additionalParams));
    Result := w.TabCount;
  except
    Result := -1;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Возвращает Index вкладки по имени заголовка вкладки
  RESULT: Integer
  REMARK:
    'TabName' - имя в заголовке вкладки, если имя пустое, определяем индекс активной вкладки
    'ContainerIndex' - используется для определения окна
}
function GetTabIndexByCaption(
  const additionalParams : String = ''
) : Integer;
  const 
    FUNCTION_NAME = 'GetTabIndexByCaption';
  var 
    w, paramList : OleVariant;
    tabName: String;
    tabIndexNum: Integer;
begin
  try
    paramList := ParseParamString(additionalParams);
    tabName := GetParam(paramList, 'TabName', '');

    w := GetTabSetControl(GetMainContainer(additionalParams));

    if tabName <> '' then
      tabIndexNum := GetIndexOfTabByCaption(w, tabName) 
    else
      tabIndexNum := GetIndexOfActiveTab(w);    

    Result := tabIndexNum;
  except
    Result := -1;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Переключает на заданную вкладку
  RESULT: Boolean
  REMARK:
    'TabName' - имя в заголовке вкладки, если имя пустое, ищем по индексу
    'ContainerIndex' - используется для определения окна 
    'TabIndex' - если не задано и 'TabName' пуст, то переключаемся на активную вкладку, иначе определеяет индекс вкладки
}
function SwitchToTab(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'SwitchToTab';
  var 
    p, w, paramList : OleVariant;
    tabName: String;
    tabIndexNum: Integer;
begin
  try
    Result := true;    
    paramList := ParseParamString(additionalParams);
    tabIndexNum := VarToInteger(GetParam(paramList, 'TabIndex', -1));
    tabName := GetParam(paramList, 'TabName', '');

    p := GetMainContainer(additionalParams);    
    w := GetTabSetControl(p);

    if tabName <> '' then
      tabIndexNum := GetIndexOfTabByCaption(w, tabName)
    else
    if tabIndexNum = -1 then    
      tabIndexNum := GetIndexOfActiveTab(w);    
      
    w.Click(
            (w.Tabs[tabIndexNum].PositionRect.Left + w.Tabs[tabIndexNum].PositionRect.Right) div 2,
            (w.Tabs[tabIndexNum].PositionRect.Top + w.Tabs[tabIndexNum].PositionRect.Bottom) div 2
    );
      
    ClearWindowCache(true);
    
    Result := tabIndexNum = GetIndexOfActiveTab(w);
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Открывает новое окно оболочки.
  RESULT: Boolean
  REMARK:
}                                            
function OpenNewContainerWindow(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'OpenNewContainerWindow';
  var 
    w, paramList, how, count : OleVariant;
begin
  try
    Result := true;

    paramList := ParseParamString(additionalParams);
    how := AnsiUpperCase(GetParam(paramList, 'How', 'keyboard'));    

    count := GetContainerWindowCount;
    w := GetMainWindow;
    if not IsExists(w) then
      Raise('Окно не найдено!');
    w.SetFocus;

    case how of
      'KEYBOARD' :
        begin 
          Sys.Keys('^n');
        end;
      'MAINMENU' :
        begin 
          ClickByMainMenuItem('Окна\Новое');
        end;
    else
      Raise('Параметр How не распознан!');    
    end;
    ClearWindowCache(true);
    
    Result := GetContainerWindowCount > count;  
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Открывает новую вкладку оболочки.
  RESULT: Boolean
  REMARK:
}                                            
function OpenNewTab(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'OpenNewTab';
  var 
    paramList, how, isCheckTabsCount; 
    count, count_new : integer;
begin
  try
    Result := true;

    paramList := ParseParamString(additionalParams);
    how := AnsiUpperCase(GetParam(paramList, 'How', 'keyboard'));    
    isCheckTabsCount := AnsiUpperCase(GetParam(paramList, 'IsCheckTabsCount', 'true'));
  
    if isCheckTabsCount then 
      count := GetTabsCount;
      
    case how of
      'KEYBOARD' :
        begin 
          Sys.Keys('^T');
        end;
      'PRIME' :
        begin 
          if GoToPrime then
            GoToMainmenu;
        end;
    else
      Raise('Параметр How не распознан!');    
    end;
    ClearWindowCache(true);
    
    if isCheckTabsCount then
    begin
      count_new := GetTabsCount;
      if count_new <= count then
      begin
        Result := false;
        Log.Message(FUNCTION_NAME + ': Количество вкладок после открытия не стало больше, количество = ' + IntToStr(count_new));
      end;
    end
    else
      Result := true;
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Закрывает заданное окно оболочки
  RESULT: Boolean
  REMARK:
    'ContainerIndex' - используется для определения окна, либо закрываем фоновое окно (с индексом 2)   
    'IsClearCache' - чистить ли оконный кэш, false может понадобиться для ускорения процесса
    'IsForceClose' - закрывать ли 1 единственную вклакду, в этом случае будет обрабатываться диалог выхода    
}
function CloseContainerWindow(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'CloseContainerWindow';
  var 
    w, paramList;
    isClearCache, isForceClose;
    containerIndex: integer;
begin
  try
    Result := true;

    paramList := ParseParamString(additionalParams);
    containerIndex := VarToInteger(GetParam(paramList, 'ContainerIndex', 2));
    isClearCache :=  VarToBool(GetParam(paramList, 'IsClearCache', 'true'));
    isForceClose :=  VarToBool(GetParam(paramList, 'IsForceClose', 'false'));

    if VarToBool(gbl_F1ShellTabsEnabled) then
      w := GetMainContainer('ContainerIndex:=' + IntToStr(containerIndex))
    else
      w := GetMainWindow('TabIndex:=' + IntToStr(containerIndex));
    if not IsExists(w) then
      Raise('Нечего не закрываем, окно (контейнер) с индексом ' + IntToStr(containerIndex) + ' не найдено!');
    
    //w.SetFocus;
    //w.Close;
    w.Keys('~[F4]');

    if isForceClose then
      WaitForConfirmationWindow(Options.Run.Timeout div 10, '#Выйти*');

    if isClearCache then
      ClearWindowCache(true);
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Закрывает все окна кроме последнего
  RESULT: Boolean
  REMARK:
    'IsGoToMainMenu' - переходить ли в ОМ после закрытия вкладок 
}                                            
function CloseContainerWindowExceptOne(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'CloseContainerWindowExceptOne';
  var 
    paramList, isGoToMainMenu : OleVariant;
    i;
begin
  try
    Result := true;
    paramList := ParseParamString(additionalParams);    
    isGoToMainMenu := VarToBool(GetParam(paramList, 'IsGoToMainMenu', 'true'));

    if GetContainerWindowCount > 1 then   
      for i := 1 to MAX_WINDOWS do
        if not CloseContainerWindow(additionalParams + ';ContainerIndex:=2') then
          break;
    Log.Message(FUNCTION_NAME + ': Все окна оболочки кроме первого закрыты');

    if isGoToMainMenu and (not GoToMainMenu) then
      Raise('Не получилось открыть ОМ!'); 
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Закрывает заданную вкладку
  RESULT: Boolean
  REMARK:
    'How' - способы закрытия вкладки
    'ContainerIndex' - используется для определения окна 
    'TabIndex' - если не задано (-1), то находится активная вкладка; (0) - находится неактивная вкладка
    'IsClearCache' - чистить ли оконный кэш, false может понадобиться для ускорения процесса
    'IsForceClose' - закрывать ли 1 единственную вклакду, в этом случае будет обрабатываться диалог выхода
}
function CloseTab(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'CloseTab';
  var 
    p, w, paramList : OleVariant;
    how, isClearCache, isForceClose;
    tabIndexNum, x, y, width: integer;
begin
  try
    Result := true;    
    paramList := ParseParamString(additionalParams);
    how := AnsiUpperCase(GetParam(paramList, 'How', 'mouse')); // можно веруть на mouse как исправятся вкладки    
    tabIndexNum := VarToInteger(GetParam(paramList, 'TabIndex', -1));
    isClearCache :=  VarToBool(GetParam(paramList, 'IsClearCache', 'true'));
    isForceClose :=  VarToBool(GetParam(paramList, 'IsForceClose', 'false'));    

    p := GetMainContainer(additionalParams);    
    w := GetTabSetControl(p);

    if tabIndexNum = -1 then
      tabIndexNum := GetIndexOfActiveTab(w)
    else
    if tabIndexNum = 0 then
      tabIndexNum := GetIndexOfInactiveTab(w);

    if Pos('MOUSE', how) > 0 then
    begin
      x := w.Tabs[tabIndexNum].PositionRect.Left;
      y := w.Tabs[tabIndexNum].PositionRect.Top;
      width := w.Tabs[tabIndexNum].PositionRect.Right - w.Tabs[tabIndexNum].PositionRect.Left;
    end;

    case how of
      'MOUSE' : // клик по крестику
        begin 
          x := x + width - 12;
          y := y + 12;  
          w.Click(x, y);
        end;
      'MOUSE-MIDDLE' : // клик средней кнопкой по центру
        begin 
          x := x + width div 2;
          y := y + 12;
          w.ClickM(x, y);
        end;
      'MOUSE-POPUPMENU' :
        begin 
          x := x + width div 2;
          y := y + 12;  
          w.ClickR(x, y);
          w.Keys(KeyPause + '[Up]' + KeyPause + '[Enter]');
        end;
      'KEYBOARD' :
        begin 
          Sys.Keys('^w');          
        end;
      'KEYBOARD2' :
        begin 
          Sys.Keys('^[F4]');
        end;
    else
      Raise('Параметр How не распознан!');    
    end;  

    if isForceClose then
      WaitForConfirmationWindow(Options.Run.Timeout div 10, '#Выйти*');

    if isClearCache then
      ClearWindowCache(true);
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Закрывает заданную вкладку
  RESULT: Boolean
  REMARK: Аналогична CloseTab, но более универсальна, для текущей вкладки просто отдает true
          Можно использовать в скриптах, чтобы не делать дополнительные проверки     
}
function CloseTabIfNeeded(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'CloseTabIfNeeded';
begin
  try
    if VarToBool(gbl_F1ShellTabsEnabled) and VarToBool(gbl_F1ShellOpenDocsInNewTab) then
      Result := CloseTab(additionalParams)
    else
      Result := true;
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Закрывает вкладку или возвращается по истории для режима текущей вкладки
  RESULT: Boolean
  REMARK: Аналогична CloseTab, но более универсальна, для текущей вкладки делает возврат по истории
}
function CloseTabOrGoBackByHistory(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'CloseTabOrGoBackByHistory';
begin
 try
    if VarToBool(gbl_F1ShellTabsEnabled) and VarToBool(gbl_F1ShellOpenDocsInNewTab) then
      Result := CloseTab(additionalParams)
    else
      Result := GoByHistory('НАЗАД');
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Закрывает все вкладки кроме последней (первой)
  RESULT: Boolean
  REMARK:
    'ContainerIndex' - используется для определения окна
    'IsGoToMainMenu' - переходить ли в ОМ после закрытия вкладок 
}
function CloseTabsExceptOne(
  const additionalParams : String = ''
) : Boolean;
  const 
    FUNCTION_NAME = 'CloseTabsExceptOne';
  var 
    paramList, isGoToMainMenu, isClearCache: OleVariant;
    i;
begin
  try
    Result := true;
    paramList := ParseParamString(additionalParams);
    isGoToMainMenu := VarToBool(GetParam(paramList, 'IsGoToMainMenu', 'true'));
    isClearCache :=  VarToBool(GetParam(paramList, 'IsClearCache', 'true'));    

    for i := 1 to GetTabsCount(additionalParams) - 1 do
      if not CloseTab(additionalParams + ';IsClearCache:=false;TabIndex:=0') then
        break;
    Log.Message(FUNCTION_NAME + ': Все вкладки кроме первой закрыты');

    if isClearCache then
      ClearWindowCache(true);

    if isGoToMainMenu and (not GoToMainMenu) then
      Raise('Не получилось открыть ОМ!');
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

procedure SC_____LIST;begin;end;

{
  TYPE: Работа со вкладками; Работа со списками
  DESC: Возвращает список вкладки "Фильтры"
  RESULT:
  REMARK: Так как для разных условий списки фильтров лежат по разным путям, то желательно
    указать, какой именно список фильтров нужен. Иначе будеь попытка поискать все
    В случае неуспеха выбросит EX_CANNOT_FIND_WINDOW

    оставлена для совместимости
}
function GetFilterTree: Window;
  var i : integer;
begin
  try
    Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"');
  except
    Log.Message('GetFilterTree: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
} 
function GetFromList(
   whatToGet : String;
   parent : OleVariant = nil; // объект списка, если хочется получать объекты с конкретного списка
   mainWnd : OleVariant = nil 
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromList';  
  var
    oldParent, cacheObj, cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);

    if (mainWnd = nil) then 
      mainWnd := GetMainWindow;   
    
    if (whatToGet = 'СПИСОК ФИЛЬТРОВ') OR (whatToGet = 'ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"') OR (whatToGet = 'СПИСОК РУБРИКАТОРА') OR (whatToGet = 'ЗАКЛАДКИ') then
    begin // нам здесь parent вообще не нужен
      // эта группа относится к данной функции исторически и логически. Хотя для поиска используются совем другие обхекты
      cacheKey := FUNCTION_NAME + whatToGet;
      if NOT Cache_Check(mainWnd, cacheKey, Result) then
      begin
        case whatToGet of
          'СПИСОК РУБРИКАТОРА' :       
            Result := FindWindowByPath(
              GetFromMainWindow('PARENT ZONE', '', mainWnd),
              'NAME:=RubricatorList;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=5'
            );
          'ЗАКЛАДКИ' : // pagecontrol переключения нижних вкладок
            Result := GetFromMainWindow('CHILD ZONE', '', mainWnd);// FindWindowByPath(mainWnd, 'NAME:=ParentForm;WNDCLASS:=TParentForm|NAME:=ChildForm;WNDCLASS:=TChildForm|NAME:=ChildZone;WNDCLASS:=TElPageControl');
          'СПИСОК ФИЛЬТРОВ', 'ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"' :
            Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"', mainWnd);            
          else
            Raise('Параметр не распознан!');             
        end;      
        Result := Cache_Put(mainWnd, cacheKey, Result);
      end;
    end
    else // а здесь нужен
    begin
            
      if (parent = nil) then
      begin // вычисляем дефолтный parent
        cacheKey := FUNCTION_NAME + 'DefaultParent';
        if NOT Cache_Check(mainWnd, cacheKey, parent ) then
        begin
          parent := FindWindowByPath( GetFromMainWindow('PARENT ZONE', '', mainWnd), 'NAME:=efList;WNDCLASS:=TefList;MAXDEPTH:=5', false);
          parent := Cache_Put(mainWnd, cacheKey, parent);
        end;  
      end                                                                                                                                                      
      else 
      begin // приводим данный parent к дефолтному
        oldParent := parent;
        cacheKey := FUNCTION_NAME + 'SubParent';
        if (oldParent.WndClass = 'TnscTreeViewWithAdapterDragDrop')
          or (oldParent.WndClass = 'TnscTreeView') // этот класс наверное можно будет удалить, т.к. вместо него стал TnscTreeViewWithAdapterDragDrop
          or (oldParent.WndClass = 'TnscTreeViewHotTruck')          
          or (oldParent.WndClass = 'TnscDocumentListTreeView')
        then
          if NOT Cache_Check(parent, cacheKey, parent ) then
            parent := Cache_Put(parent, cacheKey, FindWindowByPath(oldParent, 'NAME:=efList;MAXDEPTH:=-5', false));            
      end;
      
      cacheKey := FUNCTION_NAME + whatToGet;      
      if NOT Cache_Check(parent, cacheKey, Result) then
      begin
        case whatToGet of           
          'ТУЛБАР "СПИСОК"', 'ТУЛБАР СПИСКА ДОКУМЕНТОВ':
            Result := FindWindowByPath(
              GetFromMainWindow('ROOT OBJECT', '', mainWnd),
              'NAME:=TopDock;MAXDEPTH:=5|NAME:=tbefListTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Список'
            );
          'СПИСОК ДОКУМЕНТОВ':
            Result := FindWindowByPath(parent, 'WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=3');         
          'ПУСТОЙ СПИСОК ДОКУМЕНТОВ':
            Result := FindWindowByPath(parent, 'WNDCLASS:=TnscEditor;NAME:=EmptyListEditor;MAXDEPTH:=3');
          'СПРАВКА К СПИСКУ', 'ВКЛАДКА "СПРАВКА К СПИСКУ"' :
            Result := FindWindowByPath(
              GetFromMainWindow('CHILD ZONE', '', mainWnd),
              'WNDCLASS:=TefListInfo;WNDCAPTION:=Справка к списку;MAXDEPTH:=5;Visible:=true|WNDCLASS:=TnscEditor'
            );          
          'ОБЛАСТЬ СИНХРОННОГО ПРОСМОТРА' :
            Result := FindWindowByPath(
              GetFromMainWindow('CHILD ZONE', '', mainWnd),
              'WNDCLASS:=TfcSynchroView;WNDCAPTION:=Синхронный просмотр;Visible:=true;MAXDEPTH:=5'
            );
          'ОБЛАСТЬ СПИСКА' :
            Result := parent;
          'ЗНАЧОК: СПИСОК БЫЛ ИЗМЕНЕН':
            Result := FindWindowByPath(GetF1ShellProcess, 'NAME:=efList*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage_2;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true');
          'ТУЛБАР ВЕРХНИЙ ПРАВЫЙ' : //например tolBar списка ССЫЛОК НА ДОКУМЕНТ\ССЫЛОК ИЗ ДОКУМЕНТОВ
            Result := FindWindowByPath( parent, 'WNDCLASS:=TToolBar;MAXDEPTH:=3');
          'ОБЛАСТЬ ПУСТОГО РЕЗУЛЬТАТА ФИЛЬТРА':
            Result := FindWindowByPath(parent, 'WNDCLASS:=TvtPanel|WNDCLASS:=TnscEditor;VISIBLE:=TRUE');
          'КОНТЕКСТНЫЙ ФИЛЬТР': // например он присутствует после поиска по КЗ Инфарма
            Result := FindWindowByPath(parent, 'WNDCLASS:=TvtPanel|WNDCLASS:=TnscContextFilter|NAME:=InternalEditor;WNDCLASS:=TnscComboBoxWithFilter;VISIBLE:=TRUE');  
          else
            Raise('Параметр не распознан!');             
        end; 
             
        Result := Cache_Put(parent, cacheKey, Result);
      end;
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);       
  except
    Log.Message(FUNCTION_NAME + ' : ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками
  DESC: Возвращает список из основной области
  RESULT:
  REMARK: оставлена для совместимости
}
function GetList: Window;
var
  i: integer;
begin
  try
    try
      for i := 1 to 2 do 
      begin
        Result := GetFromList('СПИСОК ДОКУМЕНТОВ');
        if not IsExists(Result) then
          Delay(Options.Run.Timeout div 10)
        else
          break;
      end; 
    except
      Result := NonExObj;
      CommonExceptionHandler;
    end;  
  except
    Log.Message('GetList: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

procedure SC_____TIME_MACHINE;begin;end;

{
  TYPE: Объекты оболочки/Синхронный просмотр
  DESC: Отдает объект синхронного просмотра, если не находит выбрасывает исключение
  RESULT:
  REMARK:
}
function GetFromTimeMachine(
  whatToGet : String;
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromTimeMachine';
  var 
    i : integer;
    cacheObj, cacheKey : OleVariant;
    isCanCache : boolean;
begin
  Result := NonExObj;   
  try
    isCanCache := true;
    whatToGet := AnsiUpperCase(whatToGet);
        
    if (parent = nil) then
      parent :=GetFromShell('ФОРМА МАШИНЫ ВРЕМЕНИ', Options.Run.Timeout div 10);
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin   
      case whatToGet of
        'КНОПКА "ОК"':
          Result := FindWindowByPath(parent, 'NAME:=btnOk;WNDCLASS:=TvtButton');
        'КНОПКА "ОТМЕНА"':
          Result := FindWindowByPath(parent, 'NAME:=btnCancel;WNDCLASS:=TvtButton');    
        'РАДИОКНОПКА "ВКЛЮЧИТЬ МВ С КАЛЕНДАРНОЙ ДАТЫ"':
          Result := FindWindowByPath(parent, 'NAME:=rb_totmOnDate;WNDCLASS:=TvtRadioButton');    
        'РАДИОКНОПКА "ВКЛЮЧИТЬ МВ С НАЧАЛА ДЕЙСТВИЯ ТЕКУЩЕЙ РЕДАКЦИИ"':
          Result := FindWindowByPath(parent, 'NAME:=rb_totmOnCurrentRedation;WNDCLASS:=TvtRadioButton');    
        'РАДИОКНОПКА "ВЫКЛЮЧИТЬ МВ И ПЕРЕЙТИ В АКТУАЛЬНУЮ РЕДАКЦИЮ"':
          Result := FindWindowByPath(parent, 'NAME:=rb_totmGotoActualRedaction;WNDCLASS:=TvtRadioButton');    
        'РАДИОКНОПКА "ВЫКЛЮЧИТЬ МВ И ОСТАТЬСЯ В ДАННОЙ РЕДАКЦИИ"':
          Result := FindWindowByPath(parent, 'NAME:=rb_totmStayInCurrentRedaction;WNDCLASS:=TvtRadioButton');    
        'РАДИОКНОПКА "ИЗМЕНИТЬ ДАТУ МВ"':
          Result := FindWindowByPath(parent, 'NAME:=rb_totmChangeDate;WNDCLASS:=TvtRadioButton');    
        'ПОЛЕ ВВОДА ДАТЫ':
          Result := FindWindowByPath(parent, 'NAME:=de*Date;WNDCLASS:=TvtDblClickDateEdit');
        else
          Raise('Параметр не распознан!');   
      end;
      
      if isCanCache then Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);    
  except
    Log.Message('GetFromSynchroView: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____SYNCHRO_VIEW;begin;end;

{
  TYPE: Объекты оболочки/Синхронный просмотр
  DESC: Отдает объект синхронного просмотра, если не находит выбрасывает исключение
  RESULT:
  REMARK:
}
function GetFromSynchroView(
  whatToGet : String;
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromSynchroView';
  var 
    i : integer;
    cacheObj, cacheKey : OleVariant;
    isCanCache : boolean;
begin
  Result := NonExObj;   
  try
    isCanCache := true;
    whatToGet := AnsiUpperCase(whatToGet);
        
    if (parent = nil) then
      parent :=GetFromList('Область синхронного просмотра');
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin   
      case whatToGet of
        'ОБЛАСТЬ РЕДАКТОРА', 'ОБЛАСТЬ ТЕКСТА ДОКУМЕНТА' :
          Result := FindWindowByPath(
            parent,
            'NAME:=DocView;WNDCLASS:=TvtPanel|NAME:=TextForm;WNDCLASS:=TTextForm'
          );    
        'ЗАКЛАДКИ' : // pagecontrol переключения нижних вкладок
          Result := FindWindowByPath(
            parent,
            'NAME:=ChildZone;WNDCLASS:=TnscPageControl;MAXDEPTH:=-3'
          );
        'ТЕКСТ ДОКУМЕНТА', '1' :
          Result := FindWindowByPath(
            GetFromSynchroView('ОБЛАСТЬ РЕДАКТОРА', parent),
            'NAME:=Text;WNDCLASS:=TnscEditor'
          );
        'ТЕКСТ АННОТАЦИИ':
          Result := FindWindowByPath(
            GetFromSynchroView('ОБЛАСТЬ РЕДАКТОРА', parent),
            'WNDCAPTION:=Аннотация*;MAXDEPTH:=0|NAME:=Text;WNDCLASS:=TnscEditor'
          );
        'СПРАВКА К ДОКУМЕНТУ', '3' :
          Result := FindWindowByPath(
            GetFromSynchroView('ОБЛАСТЬ РЕДАКТОРА', parent),
            'WNDCAPTION:=Справка к документу*;MAXDEPTH:=0|NAME:=Text;WNDCLASS:=TnscEditor'
          );
        'ТУЛБАР "СИНХРОННЫЙ ПРОСМОТР"':
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Синхронный просмотр;MAXDEPTH:=5'
          );           
        'ТУЛБАР "ТЕКСТ ДОКУМЕНТА"':
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Текст документа (синхронный просмотр);MAXDEPTH:=5'
          );            
        'ТУЛБАР ВЕРХНИЙ ПРАВЫЙ' :
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=TToolBar;MAXDEPTH:=5'
          );                  
        'ОБЛАСТЬ СПИСКА' :
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=TefList;MAXDEPTH:=3'
          );         
        'СПИСОК', '2' :
          Result := FindWindowByPath(
            GetFromSynchroView('ОБЛАСТЬ СПИСКА', parent),
            'WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=3'
          );
        'ПУСТОЙ СПИСОК ДОКУМЕНТОВ':
          Result := FindWindowByPath(
            GetFromSynchroView('ОБЛАСТЬ СПИСКА', parent),
            'WNDCLASS:=TnscEditor;MAXDEPTH:=3');
        'СПИСОК ССЫЛОК НА ДОКУМЕНТ' :
          Result := FindWindowByPath(
            GetFromSynchroView('ОБЛАСТЬ СПИСКА', parent),
            'CAPTION:=*ССЫЛКИ НА ДОКУМЕНТ*;MAXDEPTH:=0|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=3'
          );        
        'СПИСОК ССЫЛОК ИЗ ДОКУМЕНТА' :
          Result := FindWindowByPath(
            GetFromSynchroView('ОБЛАСТЬ СПИСКА', parent),
            'CAPTION:=*ССЫЛКИ ИЗ ДОКУМЕНТ*;MAXDEPTH:=0|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=3'
          );
        'АТТРИБУТЫ', '4' :
          Result := FindWindowByPath(
            parent,
            'NAME:=AttributesForm;WNDCLASS:=TAttributesForm;MAXDEPTH:=3|NAME:=tvAttributes;WNDCLASS:=TnscTreeViewWithAdapterDragDrop'
          );
        'АКТИВНЫЙ' : // пытается вернуть активный элемент
          begin
            isCanCache := false;
            for i := 1 to 4 do
              try
                Result := GetFromSynchroView( IntToStr(i), parent );
                if IsExists(Result) then Exit;
              except
                continue;
                if i = 4 then Raise; // типа если ничего не нашли то пробрасываем исключение дальше
              end;
          end;  
        else
          Raise('Параметр не распознан!');   
      end;
      
      if isCanCache then Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);    
  except
    Log.Message('GetFromSynchroView: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Синхронный просмотр
  DESC: Возвращает текст в окне синхронного просмотра
  RESULT:
  REMARK: оставлена для совместимости
}
function GetEditorInSynchroView: Window;
begin
  try
    Result := GetFromSynchroView('ТЕКСТ ДОКУМЕНТА');
  except
    Log.Message('GetEditorInSynchroView: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;


procedure SC_____SYNCHRO_VIEW_INFARM;begin;end;

{
  TYPE: Объекты оболоонного просмотра, если не находит выбрасывает исключение
  RESULT:
  REMARK:
}
function GetFromSynchroViewInfarmListFirms(
  whatToGet : String;
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromSynchroViewInfarmListFirms';
  var 
    i : integer;
    cacheObj, cacheKey : OleVariant;
    isCanCache : boolean;
begin
  Result := NonExObj;   
  try
    isCanCache := true;
    whatToGet := AnsiUpperCase(whatToGet);
        
    if (parent = nil) then
      parent :=GetFromInfarmListFirms('Область синхронного просмотра');
    
    cacheKey := FUNCTION_NAME + whatToGet;    
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin     
      case whatToGet of
        'ОБЛАСТЬ РЕДАКТОРА' :
          Result := FindWindowByPath(
            parent,
            'NAME:=ztChild;WNDCLASS:=TvtPanel|TextForm;WNDCLASS:=TTextForm|NAME:=Text;WNDCLASS:=TnscEditor'
          );
          
        'ТУЛБАР "СИНХРОННЫЙ ПРОСМОТР ОПИСАНИЕ ФИРМЫ"':
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Описание фирмы (синхронный просмотр);MAXDEPTH:=4'
          );   
        else
          Raise('Параметр не распознан!');
      end;     
      if isCanCache then Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);    
  except
    Log.Message('GetFromSynchroViewInfarmListFirms: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____DICTIONARY;begin;end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
} 
function GetFromDictionary(
  whatToGet : String;  
  const addParams : String = ''
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromDictionary';
  var
    parent : OleVariant;
    strTimeOut : String;
    cacheKey : OleVariant;
    mainWnd : OleVariant;
begin
  try                                                               
    whatToGet := AnsiUpperCase(whatToGet);
    
    mainWnd := GetMainWindow(addParams);     
    parent := GetFromMainWindow('ROOT OBJECT', '', mainWnd);

    cacheKey := FUNCTION_NAME + whatToGet;    
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'WORK AREA':        
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', '', mainWnd),
            'NAME:=DictionContainerForm;WNDCLASS:=TDictionContainerForm|NAME:=pnBackground;WNDCLASS:=TvtProportionalPanel|NAME:=pnWorkArea;WNDCLASS:=TvtProportionalPanel', true, addParams
          );
        'PARENT ZONE':
          Result := FindWindowByPath(
            GetFromDictionary('WORK AREA', addParams),
            'NAME:=ParentZone;WNDCLASS:=TvtPanel', true, addParams
          );
       'ЗАГОЛОВОК ТС':
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', '', mainWnd),
            'NAME:=DictionContainerForm;WNDCLASS:=TDictionContainerForm|NAME:=lbHeader;VCLClass:=TvtLabel;Caption:=Толковый словарь', true, addParams
          );
       'ВЕРХНЯЯ ФОРМА НАЗВАНИЯ': 
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', '', mainWnd),
            'NAME:=DictionContainerForm;WNDCLASS:=TDictionContainerForm|NAME:=pnHeader;WNDCLASS:=TvtPanel', true, addParams
          );                
        'ТЕКСТ СТАТЬИ', 'РЕДАКТОР' :
          Result := FindWindowByPath(
            GetFromDictionary('PARENT ZONE', addParams),
            'HelpKeyword:=dftDictEntry;WNDCLASS:=TTextForm|NAME:=Text;WNDCLASS:=TnscEditor', true, addParams
          );
        'ПЕРЕВОД СТАТЬИ', 'РЕДАКТОР 2' :
          Result := FindWindowByPath(
            GetFromDictionary('WORK AREA', addParams),
            'HelpKeyword:=dftDictSubEntry;WNDCLASS:=TTextForm;MAXDEPTH:=5|NAME:=Text;WNDCLASS:=TnscEditor', true, addParams
          );        
        'САБ ПАНЕЛЬ ТЕКСТ':
          Result := FindWindowByPath(
            GetFromDictionary('PARENT ZONE', addParams),
            'HelpKeyword:=dftDictEntry;WNDCLASS:=TTextForm|NAME:=SubPanel;WNDCLASS:=TeeSubPanel', true, addParams
          );        
        'САБ ПАНЕЛЬ ПЕРЕВОД':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'NAME:=SubPanel;WNDCLASS:=TeeSubPanel;MAXDEPTH:=5', true, addParams
          );
        'ВКЛАДКА ТС "ИНФОРМАЦИЯ О ДОКУМЕНТЕ"' :
          Result := FindWindowByPath(
            GetFromDictionary('WORK AREA', addParams),
            'NAME:=AttributesForm;WNDCLASS:=TAttributesForm;MAXDEPTH:=5|NAME:=tvAttributes;WNDCLASS:=TnscTreeViewWithAdapterDragDrop'
          );
        'ВКЛАДКА НАВИГАТОРА "ТОЛКОВЫЙ СЛОВАРЬ"', 'СПИСОК ТЕРМИНОВ' :
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', '', mainWnd),
            'WNDCLASS:=TDictionContainerForm|NAME:=pnBackground;WNDCLASS:=TvtProportionalPanel|WNDCLASS:=TenDiction;MAXDEPTH:=2|NAME:=WordsTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=2', true, addParams
          );
        'ТУЛБАР ВЫБОРА ЯЗЫКА ТЕРМИНА' :
           Result := FindWindowByPath(
            GetFromDictionary('ВКЛАДКА НАВИГАТОРА "ТОЛКОВЫЙ СЛОВАРЬ"', addParams),
            'WNDCLASS:=TenDiction;MAXDEPTH:=-1|NAME:=tbenDictionBottom;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Толковый словарь;MAXDEPTH:=5', true, addParams
          );
        'ТУЛБАР СПИСКА ТЕРМИНОВ' :
           Result := FindWindowByPath(
            GetFromDictionary('ВКЛАДКА НАВИГАТОРА "ТОЛКОВЫЙ СЛОВАРЬ"', addParams),
            'WNDCLASS:=TenDiction;MAXDEPTH:=-1|NAME:=tbenDictionTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Толковый словарь;MAXDEPTH:=5', true, addParams
          );        
        'ТУЛБАР ТЕКСТ СТАТЬИ' :
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Текст словарной статьи;MAXDEPTH:=4', true, addParams
          );        
        'ТУЛБАР ПЕРЕВОД СТАТЬИ' :
          Result := FindWindowByPath(
            GetFromDictionary('WORK AREA', addParams),
            'NAME:=ChildZone;WNDCLASS:=TvtSizeablePanel|WNDCLASS:=TvcmToolbar;WNDCAPTION:=Перевод словарной статьи;MAXDEPTH:=8', true, addParams
          );        
        'ЗАКЛАДКИ' : // pagecontrol переключения вкладок русский/английский
          Result := FindWindowByPath(
            GetFromDictionary('WORK AREA', addParams),
            'NAME:=ChildZone;WNDCLASS:=TvtSizeablePanel|NAME:=ChildZone;WNDCLASS:=TnscFormsPageControl;MAXDEPTH:=2', true, addParams
          );        
        'ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(
            GetFromDictionary('ВКЛАДКА НАВИГАТОРА "ТОЛКОВЫЙ СЛОВАРЬ"', addParams),
            'WNDCLASS:=TenDiction;MAXDEPTH:=-1|NAME:=BackgroundPanel;WNDCLASS:=TvtPanel|NAME:=ContextFilter;WNDCLASS:=TnscContextFilter', true, addParams
          );
        'ПОЛЕ "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(
            GetFromDictionary('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"', addParams),
            'NAME:=InternalEditor;WNDCLASS:=TnscComboBoxWithFilter;MAXDEPTH:=1', true, addParams
          );  
        'КНОПКА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(
            GetFromDictionary('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"', addParams),
            'NAME:=ContextFilterButton;MAXDEPTH:=1', true, addParams
          );  
        else
          Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result);
    end;
 
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);   
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____INFARM_DICTIONARY;begin;end;

{
  TYPE: Объекты оболочки/Инфарм/Словарь медицинских терминов
  DESC: Отдает объект словаря, если не находит выбрасывает исключение
  RESULT:
  REMARK:
}
function GetFromInfarmDictionary(
  whatToGet : String;
  const addParams : String = ''
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromInfarmDictionary';
  var
    parent : OleVariant;
    strTimeOut : String;
    cacheKey : OleVariant;
    mainWnd : OleVariant;
begin
  try                                                               
    whatToGet := AnsiUpperCase(whatToGet);
    
    mainWnd := GetMainWindow(addParams);     
    parent := GetFromMainWindow('ROOT OBJECT', '', mainWnd);

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of        
        'ТЕКСТ СТАТЬИ' :
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', '', mainWnd),
            'HelpWord:=dftMedDictEntry;WNDCLASS:=TTextForm;MAXDEPTH:=5|NAME:=Text;WNDCLASS:=TnscEditor', true, addParams
          );                
        'САБ ПАНЕЛЬ ТЕКСТ':
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', '', mainWnd),
            'HelpWord:=dftMedDictEntry;WNDCLASS:=TTextForm|NAME:=SubPanel;WNDCLASS:=TeeSubPanel', true, addParams
          );      
        'ВКЛАДКА НАВИГАТОРА "СПИСОК МЕДИЦИНСКИХ ТЕРМИНОВ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', '', mainWnd),
            'NAME:=pnBackground;MAXDEPTH:=2|NAME:=BackgroundPanel;MAXDEPTH:=3|NAME:=WordsTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop', true, addParams
          );                        
        'ТУЛБАР ТЕКСТ СТАТЬИ' :
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Описание медицинского термина;MAXDEPTH:=4', true, addParams
          );       
        'ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(
            GetFromInfarmDictionary('ВКЛАДКА НАВИГАТОРА "СПИСОК МЕДИЦИНСКИХ ТЕРМИНОВ"', addParams),
            'WNDCLASS:=TvtPanel;MAXDEPTH:=-1|NAME:=ContextFilter;WNDCLASS:=TnscContextFilter', true, addParams
          );
        'ПОЛЕ "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(
            GetFromInfarmDictionary('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"', addParams),
            'NAME:=InternalEditor;WNDCLASS:=TnscComboBox;MAXDEPTH:=1', true, addParams
          );  
        'КНОПКА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(
            GetFromInfarmDictionary('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"', addParams),
            'NAME:=ContextFilterButton;MAXDEPTH:=1', true, addParams
          );  
        else
          Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result);
    end;
 
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);   
  except
    Log.Message('GetFromInfarmDictionary: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____EDITOR;begin;end;

{
  TYPE: Объекты оболочки/Редакции документа
  DESC: Отдает объекты с форм редакций (левой и правой)
  RESULT:
  REMARK:
}
function GetFromEditions(
  whatToGet : String;
  parent : OleVariant = nil
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromEditions';
  var cacheObj, cacheKey, mainWnd: OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    mainWnd := GetMainWindow;
    
    if (parent = nil) then
    begin // вычисляем дефолтный parent
      cacheKey := FUNCTION_NAME + 'DefaultParent';
      if NOT Cache_Check(mainWnd, cacheKey, parent) then
        parent := Cache_Put(mainWnd, cacheKey, FindWindowByPath(GetFromMainWindow('PARENT ZONE', '', mainWnd), 'WNDCLASS:=TEditionsContainerForm;MAXDEPTH:=2'));
    end
    else
      if not IsExists(parent) then
        Raise('Передан несуществующий "parent"!'); 

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result) then    
    begin 
      case whatToGet of                  
        'ФОРМА РЕДАКЦИИ СЛЕВА' :
          Result := FindWindowByPath(
            parent,
            'NAME:=LeftEditionForm;WNDCLASS:=TLeftEditionForm;MAXDEPTH:=3'
          );
        'ФОРМА РЕДАКЦИИ СПРАВА' :
          Result := FindWindowByPath(
            parent,
            'NAME:=RightEditionForm;WNDCLASS:=TRightEditionForm;MAXDEPTH:=3'
          );
        'ТЕКСТ ДОКУМЕНТА СЛЕВА' :
          Result := FindWindowByPath(
            GetFromEditions('ФОРМА РЕДАКЦИИ СЛЕВА'),
            'NAME:=Text;WNDCLASS:=TnscEditor'
          );
        'ТЕКСТ ДОКУМЕНТА СПРАВА' :
          Result := FindWindowByPath(
            GetFromEditions('ФОРМА РЕДАКЦИИ СПРАВА'),
            'NAME:=Text;WNDCLASS:=TnscEditor'
          );
        'ССЫЛКА РЕДАКЦИИ СЛЕВА' :
          Result := FindWindowByPath(
            GetFromEditions('ФОРМА РЕДАКЦИИ СЛЕВА'),
            'NAME:=Header;WNDCLASS:=TvtPanel|NAME:=EditionLink;WNDCAPTION:=Редакция:;WNDCLASS:=TvtFocusLabel;MAXDEPTH:=2'
          );
        'ССЫЛКА РЕДАКЦИИ СПРАВА' :
          Result := FindWindowByPath(
            GetFromEditions('ФОРМА РЕДАКЦИИ СПРАВА'),
            'NAME:=Header;WNDCLASS:=TvtPanel|NAME:=EditionLink;WNDCAPTION:=Редакция:;WNDCLASS:=TvtFocusLabel;MAXDEPTH:=2'
          );
        'КОМБОБОКС ВЫБОРА ДАТЫ РЕДАКЦИИ СЛЕВА' :
          Result := FindWindowByPath(
            GetFromEditions('ФОРМА РЕДАКЦИИ СЛЕВА'),
            'NAME:=Header;WNDCLASS:=TvtPanel|NAME:=EditionChoose;WNDCLASS:=TvtComboBoxQS;MAXDEPTH:=2'
          );
        'КОМБОБОКС ВЫБОРА ДАТЫ РЕДАКЦИИ СПРАВА' :
          Result := FindWindowByPath(
            GetFromEditions('ФОРМА РЕДАКЦИИ СПРАВА'),
            'NAME:=Header;WNDCLASS:=TvtPanel|NAME:=EditionChoose;WNDCLASS:=TvtComboBoxQS;MAXDEPTH:=2'
          );
        'ТУЛБАР РЕДАКЦИИ СЛЕВА' :
          Result := FindWindowByPath(
            GetFromEditions('ФОРМА РЕДАКЦИИ СЛЕВА'),
            'NAME:=tbRightEditionFormTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
          );
        'ТУЛБАР РЕДАКЦИИ СПРАВА' :
          Result := FindWindowByPath(
            GetFromEditions('ФОРМА РЕДАКЦИИ СПРАВА'),
            'NAME:=tbRightEditionFormTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
          );
        else
          Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result);     
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);           
  except
    Log.Message(FUNCTION_NAME + ' : ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Текст документа
  DESC: Служебная функция. Для конвертации объекта "редактор с текстом документа" в объект для передачи а GetFromEditor
  RESULT:
  REMARK:
}
function _ConvertEditorToEditorParent(
  editorWnd : OleVariant
) : OleVariant;
  var
    parentObj : OleVariant;
begin
  try
    Result := NonExObj;
    if NOT IsExists(editorWnd) then Raise('Неверный объект!');
    if IsSupported(editorWnd, 'WndClass') AND StringCompare('TnscEditor', editorWnd.WndClass) then
    begin
      parentObj := GetParentObject(editorWnd);
      if IsSupported(parentObj, 'WndClass') AND StringCompare('TTextForm', parentObj.WndClass) then Result := parentObj;
    end;  
  except
    Log.Message('_ConvertEditorToEditorParent: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
} 
function GetFromEditor(
   whatToGet : String;
   parent : OleVariant = nil;
   mainWnd : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromEditor';
  var arr : OleVariant;
    cacheObj, cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    if mainWnd = nil then
      mainWnd := GetMainWindow;
    
    if (parent = nil) then
    begin // вычисляем дефолтный parent
      cacheKey := FUNCTION_NAME + 'DefaultParent';
      if NOT Cache_Check(mainWnd, cacheKey, parent) then
        parent := Cache_Put(mainWnd, cacheKey, FindWindowByPath(GetFromMainWindow('PARENT ZONE', '', mainWnd), 'WNDCLASS:=TTextForm;MAXDEPTH:=5'));
    end;

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result) then    
    begin 
      case whatToGet of                  
        'ЗАКЛАДКИ' : // pagecontrol переключения нижних вкладок
          Result := GetFromMainWindow('CHILD ZONE', '', mainWnd);
        'ТЕКСТ ДОКУМЕНТА', 'РЕДАКТОР', 'ВКЛАДКА "ТЕКСТ"' :
          Result := FindWindowByPath(
            parent,
            'NAME:=Text;WNDCLASS:=TnscEditor'
          );
        'ТЕКСТ ДОКУМЕНТА "ФЛЭШ"':
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', '', mainWnd), 
            'WNDCLASS:=Ten_DocumentWithFlash|NAME:=MacromediaFlashPlayerActiveX;WNDCLASS:=MacromediaFlashPlayerActiveX'
          );            
        'СПРАВКА ВО ВСЕ ОКНО' :
          Result := FindWindowByPath(
            parent,
            'NAME:=Text;WNDCLASS:=TnscEditor'
          );
          
        'ВКЛАДКА "ССЫЛКИ НА ДОКУМЕНТ КОММЕНТАРИИ"':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;CAPTION:=Комментарии*;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          );
          
        'ВКЛАДКА "ССЫЛКИ НА ДОКУМЕНТ СУДЕБНАЯ ПРАКТИКА"':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;CAPTION:=Судебная практика*;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          ); 
           
        'ТУЛБАР "СПИСОК: ССЫЛКИ НА ДОКУМЕНТ КОММЕНТАРИИ"' :
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "ССЫЛКИ НА ДОКУМЕНТ КОММЕНТАРИИ"', parent, mainWnd),
            'WNDCLASS:=TefList;MAXDEPTH:=-2|WNDCLASS:=TvcmToolbar;WNDCAPTION:=Настраиваемая вкладка связанных документов*;MAXDEPTH:=5'
          );        
        'ТУЛБАР "СПИСОК: ССЫЛКИ НА ДОКУМЕНТ СУДЕБНАЯ ПРАКТИКА"' :
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "ССЫЛКИ НА ДОКУМЕНТ СУДЕБНАЯ ПРАКТИКА"', parent, mainWnd),
            'WNDCLASS:=TefList;MAXDEPTH:=-2|WNDCLASS:=TvcmToolbar;WNDCAPTION:=Настраиваемая вкладка связанных документов*;MAXDEPTH:=5'
          );
            
        'ВКЛАДКА "ССЫЛКИ НА ДОКУМЕНТ"', 'СПИСОК ССЫЛОК НА ДОКУМЕНТ' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;WNDCAPTION:=ССЫЛКИ НА ДОКУМЕНТ*;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          );            
        'ВКЛАДКА "ССЫЛКИ НА ФРАГМЕНТ"':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;CAPTION:=ССЫЛКИ НА ФРАГМЕНТ;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          );          
        'ТУЛБАР "СПИСОК: ССЫЛКИ НА ДОКУМЕНТ"' :
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "ССЫЛКИ НА ДОКУМЕНТ"', parent, mainWnd),
            'WNDCLASS:=TefList;MAXDEPTH:=-2|WNDCLASS:=TvcmToolbar;WNDCAPTION:=ССЫЛКИ НА ДОКУМЕНТ*;MAXDEPTH:=5'
          );          
        'ВКЛАДКА "ССЫЛКИ ИЗ ДОКУМЕНТА"', 'СПИСОК ССЫЛОК ИЗ ДОКУМЕНТА':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;WNDCAPTION:=Ссылки из документа*;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          );
        'ВКЛАДКА "ССЫЛКИ ИЗ ФРАГМЕНТА"':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;CAPTION:=ССЫЛКИ ИЗ ФРАГМЕНТА;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          );
        'ПУСТОЙ СПИСОК СКР':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;MAXDEPTH:=2|NAME:=EmptyListEditor;MAXDEPTH:=2'
          );                     
        'ТУЛБАР "СПИСОК: ССЫЛКИ ИЗ ДОКУМЕНТА"' :
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "ССЫЛКИ ИЗ ДОКУМЕНТА"', parent, mainWnd),
            'WNDCLASS:=TefList;MAXDEPTH:=-2|WNDCLASS:=TvcmToolbar;WNDCAPTION:=ССЫЛКИ ИЗ ДОКУМЕНТА*;MAXDEPTH:=5'
          );
            
        'ТУЛБАР "ДОКУМЕНТ: ТЕКСТ ДОКУМЕНТА"', 'ТУЛБАР ТЕКСТА ДОКУМЕНТА' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', '', mainWnd),
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Текст;MAXDEPTH:=5'
          );
          
        'ВКЛАДКА НАВИГАТОРА "СТРУКТУРА ДОКУМЕНТА"', 'СТРУКТУРА ДОКУМЕНТА', 'СТРУКТУРА ДОКУМЕНТА "ОГЛАВЛЕНИЕ"'  :
          Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "СТРУКТУРА ДОКУМЕНТА"', mainWnd);
                
        'ВКЛАДКА НАВИГАТОРА "РЕДАКЦИИ"', 'СПИСОК РЕДАКЦИЙ' :
          Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "РЕДАКЦИИ"', mainWnd);
          
        'ВКЛАДКА "СПРАВКА"' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TTextForm;WNDCAPTION:=Справка;MAXDEPTH:=5|NAME:=Text;WNDCLASS:=TnscEditor;MAXDEPTH:=2'
          );
        'ТУЛБАР "ДОКУМЕНТ: СПРАВКА К ДОКУМЕНТУ"':  
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "СПРАВКА"', parent, mainWnd),
            'WNDCLASS:=TTextForm;MAXDEPTH:=-2|WNDCLASS:=TvcmToolbar;WNDCAPTION:=Справка;MAXDEPTH:=5'
          );
        'САБ ПАНЕЛЬ "ДОКУМЕНТ: СПРАВКА К ДОКУМЕНТУ"':  
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "СПРАВКА"', parent, mainWnd),
            'WNDCLASS:=TTextForm;MAXDEPTH:=-2|NAME:=SubPanel;WNDCLASS:=TeeSubPanel;MAXDEPTH:=2'
          );        
                 
        'ВКЛАДКА "ИНФОРМАЦИЯ О ДОКУМЕНТЕ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'NAME:=AttributesForm;WNDCLASS:=TAttributesForm;MAXDEPTH:=2|NAME:=tvAttributes;WNDCLASS:=TnscTreeViewWithAdapterDragDrop'
          );
        'ТУЛБАР "ДОКУМЕНТ: ИНФОРМАЦИЯ О ДОКУМЕНТЕ"':   
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "ИНФОРМАЦИЯ О ДОКУМЕНТЕ"', parent, mainWnd),
            'WNDCLASS:=TAttributesForm;MAXDEPTH:=-2|WNDCLASS:=TvcmToolbar;WNDCAPTION:=Информация о документе;MAXDEPTH:=4'
          );    
                  
        'ВКЛАДКА "ССЫЛКИ НА ДОКУМЕНТ СУДЕБНАЯ ПРАКТИКА"':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;CAPTION:=Судебная*Практика*;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          );        

        'ВКЛАДКА "ПРЕДУПРЕЖДЕНИЕ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Предупреждение|WNDCLASS:=TWarningForm|NAME:=Viewer;WNDCLASS:=TnscEditor'
          );        
        'ТУЛБАР ВЕРХНИЙ ПРАВЫЙ ВКЛАДКА "ПРЕДУПРЕЖДЕНИЕ"' :
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "ПРЕДУПРЕЖДЕНИЕ"', parent, mainWnd),
            'WNDCLASS:=TWarningForm;MAXDEPTH:=-2|WNDCLASS:=TToolBar;MAXDEPTH:=4'
          );

        'ВКЛАДКА "ПЕРЕВОД"' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Перевод|WNDCLASS:=TTextForm;WNDCAPTION:=Перевод|NAME:=Text;WNDCLASS:=TnscEditor;MAXDEPTH:=2'
          );        
          
        'ТУЛБАР ВЕРХНИЙ ПРАВЫЙ ВКЛАДКА "ПЕРЕВОД"' :
          Result := FindWindowByPath(
            GetFromEditor('ВКЛАДКА "ПЕРЕВОД"', parent, mainWnd),
            'WNDCLASS:=TTextForm;MAXDEPTH:=-2|WNDCLASS:=TToolBar;MAXDEPTH:=4'
          );  

        'ВКЛАДКА "АННОТАЦИЯ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Аннотация|WNDCLASS:=TTextForm;WNDCAPTION:=Аннотация|NAME:=Text;WNDCLASS:=TnscEditor;MAXDEPTH:=2'
          ); 
        
        'САБ ПАНЕЛЬ','БОКОВАЯ ПАНЕЛЬ':
          Result := FindWindowByPath(parent, 'NAME:=SubPanel;WNDCLASS:=TeeSubPanel');
        'ВКЛАДКА "ПОХОЖИЕ ДОКУМЕНТЫ"':
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;WNDCAPTION:=Похожие документы*;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          );               
        'ВИДИМЫЙ СПИСОК' :
          begin
            arr := FindWindowByPath(
              GetFromMainWindow('CHILD ZONE', '', mainWnd),
              'WNDCLASS:=TefList;MAXDEPTH:=8;Visible:=true'
            ); 
            if IsExists(arr) then
              dffdfdfdResult := arr
            else
              Raise(EX_CANNOT_FIND_WINDOW);  
          end;

        'ЗНАЧОК: ЛИНИЯ ЗНАЧКОВ':
          Result := FindWindowByPath(GetF1ShellProcess, 'NAME:=TextForm*RemindersLineForm;Visible:=true;Enabled:=true', true, 'TimeOut:=5000;IsAddCheckInfo:=true');
                 
        'ЗНАЧОК: РЕДАКЦИЯ НЕ ДЕЙСТВУЕТ':           
          Result := FindWindowByPath(GetF1ShellProcess, 'NAME:=TextForm*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage_7;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true');
        'ЗНАЧОК: НАСТОЯЩИЙ ДОКУМЕНТ УТРАТИЛ СИЛУ':      
          Result := FindWindowByPath(GetF1ShellProcess, 'NAME:=TextForm*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage_2;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true');
        'ЗНАЧОК: ДОКУМЕНТ НА КОНТРОЛЕ ИЗМЕНИЛСЯ':
          Result := FindWindowByPath(GetF1ShellProcess, 'NAME:=TextForm*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage_5;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true');
        'ЗНАЧОК: ПРЕДУПРЕЖДЕНИЕ ДЛЯ ДЕЙСТВУЮЩЕЙ РЕДАКЦИИ':
          Result := FindWindowByPath(GetF1ShellProcess, 'NAME:=TextForm*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage_6;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true');
        'ЗНАЧОК: МАШИНА ВРЕМЕНИ ВКЛЮЧЕНА'://;Visible:=true
          Result := FindWindowByPath(GetF1ShellProcess, 'NAME:=TextForm*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage_9;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true');
        'ЗНАЧОК: НАСТОЯЩИЙ ДОКУМЕНТ НЕ ПОДКЛЮЧЕН К МАШИНЕ ВРЕМЕНИ':
          Result := FindWindowByPath(GetF1ShellProcess, 'NAME:=TextForm*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage;Index:=1;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true');

         else
          Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result);     
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);           
  except
    Log.Message(FUNCTION_NAME + ' : ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Текст документа
  DESC: Отдает объекты документа с флэшом
  RESULT:
  REMARK:
}
function GetFromFlashEditor(
  whatToGet : String;
  parent : OleVariant = nil;
  mainWnd : OleVariant = nil
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromFlashEditor';
  var arr : OleVariant;
    cacheObj, cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    if mainWnd = nil then
      mainWnd := GetMainWindow;
    
    if (parent = nil) then
    begin // вычисляем дефолтный parent
      cacheKey := FUNCTION_NAME + 'DefaultParent';
      if NOT Cache_Check(mainWnd, cacheKey, parent) then
        parent := Cache_Put(mainWnd, cacheKey, FindWindowByPath( GetFromMainWindow('PARENT ZONE', '', mainWnd), 'WNDCLASS:=TDocumentWithFlashForm'));
    end;

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result) then    
    begin 
      case whatToGet of             
        'ТЕКСТ ДОКУМЕНТА "ФЛЭШ"':
          Result := FindWindowByPath(parent, 'WNDCLASS:=MacromediaFlashPlayerActiveX');    
        'ТУЛБАР ТЕКСТА ДОКУМЕНТА "ФЛЭШ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', '', mainWnd),
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Схема;MAXDEPTH:=5'
          );
        'ТЕКСТ ДОКУМЕНТА "ФЛЭШ" ПРИ ОТСУТСТВИИ ФЛЭШ ПЛЕЕРА':
          Result := FindWindowByPath(parent, 'WNDCLASS:=TnscEditor');  
        'ВКЛАДКА "ИНФОРМАЦИЯ О ДОКУМЕНТЕ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'NAME:=AttributesForm;WNDCLASS:=TAttributesForm;MAXDEPTH:=2|NAME:=tvAttributes;WNDCLASS:=TnscTreeViewWithAdapterDragDrop'
          );
        'ВКЛАДКА "ССЫЛКИ НА ДОКУМЕНТ"', 'СПИСОК ССЫЛОК НА ДОКУМЕНТ' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TefList;WNDCAPTION:=ССЫЛКИ НА ДОКУМЕНТ*;MAXDEPTH:=2|WNDCLASS:=TnscDocumentListTreeView;MAXDEPTH:=2'
          );
        'ВКЛАДКА "СПРАВКА"' :
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'WNDCLASS:=TTextForm;WNDCAPTION:=Справка;MAXDEPTH:=5|NAME:=Text;WNDCLASS:=TnscEditor;MAXDEPTH:=2'
          );    
        else
          Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result);     
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);           
  except
    Log.Message('GetFromFlashEditor: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;


{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
} 
function GetFromAAK(
   whatToGet : String;
   parent : OleVariant = nil;
   mainWnd : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromAAK';
  var arr : OleVariant;
    cacheObj, cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    if mainWnd = nil then
      mainWnd := GetMainWindow;
    
    if (parent = nil) then
    begin // вычисляем дефолтный parent
      cacheKey := FUNCTION_NAME + 'DefaultParent';
      if NOT Cache_Check(mainWnd, cacheKey, parent) then
        parent := Cache_Put(mainWnd, cacheKey, FindWindowByPath( GetFromMainWindow('PARENT ZONE', '', mainWnd), 'WNDCLASS:=TAACContentsContainerForm'));
    end;

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result) then    
    begin 
      case whatToGet of
        'ФОРМА ААК':
          Result := parent;        
        'ОГЛАВЛЕНИЕ ААК ЛЕВАЯ ЧАСТЬ':
          Result := FindWindowByPath(
            parent,
            'NAME:=pnBack;WNDCLASS:=TvtProportionalPanel|NAME:=pnLeftEx;WNDCLASS:=TvtSizeablePanel|WNDCLASS:=TTextForm;MAXDEPTH:=3|NAME:=Text;WNDCLASS:=TnscEditor'
          );        
        'ОГЛАВЛЕНИЕ ААК ПРАВАЯ ЧАСТЬ':
          Result := FindWindowByPath(
            parent,
            'NAME:=pnBack;WNDCLASS:=TvtProportionalPanel|NAME:=pnRightEx;WNDCLASS:=TvtPanel|WNDCLASS:=TTextForm;MAXDEPTH:=3|NAME:=Text;WNDCLASS:=TnscEditor'
          );

         else
          Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result);     
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);           
  except
    Log.Message(FUNCTION_NAME + ' : ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;



procedure SC_____ANALYTIC_REVIEW;begin;end;

{
  TYPE: Объекты оболочки/Карточка ППР
  DESC:
  RESULT:
  REMARK:
}
function GetFromAnalyticReview(
  whatToGet : String
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromAnalyticReview';
  var 
    parent : OleVariant;
    cacheKey : OleVariant;
begin   
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    parent := GetFromMainWindow('ROOT OBJECT');
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ЗАГОЛОВОК КЗ' :
          Result := FindWindowByPath(parent, 'NAME:=lbHeader;VCLCLASS:=TvtLabel;Caption:=Обзор изменений законодательства;MAXDEPTH:=7');
        'КАРТОЧКА ЗАПРОСА', 'КЗ' :
          Result := FindWindowByPath(parent, 'NAME:=enQueryCard;WNDCLASS:=TenQueryCard;WNDCAPTION:=Обзор изменений законодательства;MAXDEPTH:=10|NAME:=Editor;WNDCLASS:=TevQueryCardEditor');
        'ТУЛБАР "ПОИСК: ПРАЙМ. ОБЗОР ИЗМЕНЕНИЙ ЗАКОНОДАТЕЛЬСТВА"' :
          Result := FindWindowByPath(parent, 'NAME:=tbcfSaveLoadTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=ПОИСК: ПРАЙМ. ОБЗОР ИЗМЕНЕНИЙ ЗАКОНОДАТЕЛЬСТВА;MAXDEPTH:=10');
        'НИЖНИЙ ТУЛБАР КАРТОЧКИ ЗАПРОСА' :
          Result := FindWindowByPath(parent, 'NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: ПРАЙМ. Обзор изменений законодательства;MAXDEPTH:=10');
        else
          Raise('Параметр не распознан!');   
      end;
      Result := Cache_Put(parent, cacheKey, Result );
    end;

    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);    
  except
    Log.Message('GetFromAnalyticReview: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____PPR;begin;end;

{
  TYPE: Объекты оболочки/Карточка ППР
  DESC:
  RESULT:
  REMARK:
}
function GetFromPPR(
  whatToGet : String
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromPPR';
  var 
    parent : OleVariant;
    cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    parent := GetFromMainWindow('ROOT OBJECT') ;
    
    cacheKey := FUNCTION_NAME + whatToGet;
    
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin        
      case whatToGet of
        'ФОРМА КАРТОЧКИ ЗАПРОСА' :
          Result := FindWindowByPath( GetFromMainWindow('PARENT ZONE'), 'NAME:=cfSaveLoad;WNDCLASS:=TcfSaveLoad');          
          
        'КАРТОЧКА ЗАПРОСА', 'КЗ' :
          Result := FindWindowByPath(
            GetFromPPR('ФОРМА КАРТОЧКИ ЗАПРОСА'),
            'NAME:=enQueryCard;WNDCLASS:=TenQueryCard;WNDCAPTION:=Поиск по реквизитам;MAXDEPTH:=10|NAME:=Editor;WNDCLASS:=TevQueryCardEditor'
          );
        'ВЕРХНЯЯ ФОРМА НАЗВАНИЯ КЗ': 
          Result := FindWindowByPath(
            GetFromPPR('ФОРМА КАРТОЧКИ ЗАПРОСА'),
            'NAME:=pnHeader;WNDCLASS:=TvtPanel'
          );
        'ЗАГОЛОВОК КЗ':
          Result := FindWindowByPath(GetFromPPR('ФОРМА КАРТОЧКИ ЗАПРОСА'), 'NAME:=lbHeader;VCLCLASS:=TvtLabel;Caption:=Поиск по реквизитам');
        'ТУЛБАР "ПОИСК: ПО РЕКВИЗИТАМ"' :
          Result := FindWindowByPath(parent, 'NAME:=tbcfSaveLoadTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: По реквизитам;MAXDEPTH:=5');
        'НИЖНИЙ ТУЛБАР КАРТОЧКИ ЗАПРОСА' :
          Result := FindWindowByPath(
            GetFromPPR('ФОРМА КАРТОЧКИ ЗАПРОСА'),
            'NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: По реквизитам;MAXDEPTH:=5'
          );
        'СПИСОК ФИЛЬТРОВ', 'ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"' :
          Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"');
         else
          Raise('Параметр не распознан!');   
      end;
      Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);    
  except
    Log.Message('GetFromPPR: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____PLP;begin;end;

{
  TYPE: Объекты оболочки/Карточка ПЛП (поиск лекарственного препарата)
  DESC:
  RESULT:
  REMARK:
}
function GetFromPLP(
  whatToGet : String
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromPLP';
  var 
    parent : OleVariant;
    cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    parent := GetFromMainWindow('ROOT OBJECT') ;
    
    cacheKey := FUNCTION_NAME + whatToGet;
    
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin        
      case whatToGet of
        'ФОРМА КАРТОЧКИ ЗАПРОСА' :
          Result := FindWindowByPath( GetFromMainWindow('PARENT ZONE'), 'WNDCLASS:=TcfSaveLoad');          
          
        'КАРТОЧКА ЗАПРОСА':
          Result := FindWindowByPath(
            GetFromPPR('ФОРМА КАРТОЧКИ ЗАПРОСА'),
            'WNDCLASS:=TenQueryCard;WNDCAPTION:=Поиск лекарственных средств;MAXDEPTH:=2|NAME:=Editor;WNDCLASS:=TevQueryCardEditor'
          );              
        'ТУЛБАР "ПОИСК: ПО РЕКВИЗИТАМ"' :
          Result := FindWindowByPath(parent, 'NAME:=tbcfSaveLoadTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск лекарственных средств;MAXDEPTH:=5');
        'НИЖНИЙ ТУЛБАР КАРТОЧКИ ЗАПРОСА' :
          Result := FindWindowByPath(
            GetFromPPR('ФОРМА КАРТОЧКИ ЗАПРОСА'),
            'NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск лекарственных средств;MAXDEPTH:=5'
          );
        'СПИСОК ФИЛЬТРОВ', 'ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"' :
          Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"');          
         else
          Raise('Параметр не распознан!');   
      end;
      Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);    
  except
    Log.Message(FUNCTION_NAME + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____CONSULTATIONS;begin;end;

{
  TYPE: Объекты оболочки/Карточка ППО
  DESC:
  RESULT:
  REMARK:
}
function GetFromLawSupport(
  whatToGet : String
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromLawSupport';
  var 
    parent : OleVariant;
    cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);

    parent := GetFromMainWindow('ROOT OBJECT');

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ЗАГОЛОВОК КЗ' :
          Result := FindWindowByPath(parent, 'NAME:=ParentForm;WNDCLASS:=TParentForm;MAXDEPTH:=4|NAME:=cfSaveLoad;WNDCLASS:=TcfSaveLoad;MAXDEPTH:=2|NAME:=lbHeader;VCLCLASS:=TvtLabel;Caption:=Правовая поддержка онлайн');
        'КАРТОЧКА ЗАПРОСА', 'КЗ' :
          Result := FindWindowByPath(parent, 'NAME:=enQueryCard;WNDCLASS:=TenQueryCard;WndCaption:=Правовая поддержка*;MAXDEPTH:=10|NAME:=Editor;WNDCLASS:=TevQueryCardEditor');
        'НИЖНИЙ ТУЛБАР КАРТОЧКИ ЗАПРОСА' :
          Result := FindWindowByPath(parent, 'NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Правовая поддержка*;MAXDEPTH:=10');
        else
          Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);
  except
    Log.Message('GetFromLawSupport: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{

  TYPE: Объекты оболочки/Консультации
  DESC:
  RESULT:
  REMARK:
}
function GetFromConsultations(
  whatToGet : String;
  parent : OleVariant = nil;
  mainWnd : OleVariant = nil
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromConsultations';
  var 
    arr : OleVariant;
    cacheKey, subParent : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    if mainWnd = nil then
      mainWnd := GetMainWindow;
    
    if (parent = nil) then
    begin
      cacheKey := FUNCTION_NAME + 'DefaultParent';
      subParent := GetFromMainWindow('PARENT ZONE', '', mainWnd);
      if NOT Cache_Check(subParent, cacheKey, parent) then
      begin
        parent := FindWindowByPath(subParent, 'WNDCLASS:=TTextForm;WNDCAPTION:=Текст консультации*');      
        Cache_Put(subParent, cacheKey, parent );
      end;
    end;  
    
    cacheKey := FUNCTION_NAME + whatToGet;      
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin    
      case whatToGet of         
        'ЗАКЛАДКИ' : // pagecontrol переключения нижних вкладок
          Result := GetFromMainWindow('CHILD ZONE', '', mainWnd);
        'ТЕКСТ КОНСУЛЬТАЦИИ', 'ВКЛАДКА "ТЕКСТ"' :
          Result := FindWindowByPath(parent, 'NAME:=Text;WNDCLASS:=TnscEditor');
        'ТУЛБАР "ДОКУМЕНТ: КОНСУЛЬТАЦИЯ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', '', mainWnd),
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Консультация;MAXDEPTH:=5'
          );
        'ФОРМА СПИСКА' : // скорее служебный параметр
          Result := FindWindowByPath(
            GetFromMainWindow('CHILD ZONE', '', mainWnd),
            'NAME:=efList;WNDCLASS:=TefList;WNDCAPTION:=Список;MAXDEPTH:=4'
          );
        'ПУСТОЙ СПИСОК':
          Result := FindWindowByPath(
            GetFromConsultations('ФОРМА СПИСКА', parent, mainWnd),
            'WNDCLASS:=TvtPanel|WNDCLASS:=TnscEditor;WNDCAPTION:=EmptyListEditor'
          );
        'СПИСОК' :
          Result := FindWindowByPath(
            GetFromConsultations('ФОРМА СПИСКА', parent, mainWnd),
            'WNDCLASS:=TvtPanel|WNDCLASS:=TnscDocumentListTreeView'
          );
        'ТУЛБАР "СПИСОК: КОНСУЛЬТАЦИЯ"' :
          Result := FindWindowByPath(
            GetFromConsultations('ФОРМА СПИСКА', parent, mainWnd),
            'NAME:=tbefListTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Консультация;MAXDEPTH:=4'
          );
      else
        Raise('Параметр не распознан!');   
      end;
    
    	Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);  
  except
    Log.Message('GetFromConsultations: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Консультации
  DESC:
  RESULT:
  REMARK:
}
function GetFromConsRateForm(
  whatToGet : String;
  parent : OleVariant = nil
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromConsRateForm';
  var 
    arr : OleVariant;
    cacheKey, shellProc : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    if (parent = nil) then
    begin
      cacheKey := FUNCTION_NAME + 'DefaultParent';
      shellProc := GetF1ShellProcess;
      if NOT Cache_Check(shellProc, cacheKey, parent) then
      begin
        parent := FindWindowByPath(shellProc, 'NAME:=en_ConsultationMark;WNDCLASS:=Ten_ConsultationMark');      
        Cache_Put(shellProc, cacheKey, parent );
      end;
    end;  
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin      
      case whatToGet of
        'ФОРМА ОЦЕНКИ' : 
          Result := parent;
        'ПОЛЕ КОММЕНТАРИЯ' : 
          Result := FindWindowByPath(parent, 'NAME:=mComment;WNDCLASS:=TeeMemoWithEditOperations;MAXDEPTH:=2');
        'НИЖНИЙ ТУЛБАР' :
          Result := FindWindowByPath(parent, 'NAME:=tben_ConsultationMarkBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4');
        'ЧЕКБОКС "ЗАТРУДНЯЮСЬ ОЦЕНИТЬ"' :
          Result := FindWindowByPath(parent, 'NAME:=rbNotSure;MAXDEPTH:=3');
        'ЧЕКБОКС "ОТЛИЧНО"' :
          Result := FindWindowByPath(parent, 'NAME:=rbFive;MAXDEPTH:=3');
        'ЧЕКБОКС "ХОРОШО"' :
          Result := FindWindowByPath(parent, 'NAME:=rbFour;MAXDEPTH:=3');
        'ЧЕКБОКС "УДОВЛЕТВОРИТЕЛЬНО"' :
          Result := FindWindowByPath(parent, 'NAME:=rbThree;MAXDEPTH:=3');
        'ЧЕКБОКС "НЕУДОВЛЕТВОРИТЕЛЬНО"' :
          Result := FindWindowByPath(parent, 'NAME:=rbTwo;MAXDEPTH:=3');
      else
        Raise('Параметр не распознан!');
      end;

      Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);
  except
    Log.Message('GetFromConsultations: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____PPS;begin;end;

{
  TYPE: Объекты оболочки/Карточка ППC (Стандартная)
  DESC:
  RESULT:
  REMARK:
}
function GetFromPPS_Std(
  whatToGet : String
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromPPS_Std';
  var 
    parent, cacheKey, parentZone : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);

    cacheKey := FUNCTION_NAME + 'DefaultParent';
    parentZone := GetFromMainWindow('PARENT ZONE');
    if NOT Cache_Check(parentZone, cacheKey, parent) then
    begin
      parent := FindWindowByPath(parentZone, 'NAME:=cfAttributeSelect;WNDCLASS:=TcfAttributeSelect;MAXDEPTH:=3;TIMEOUT:=' + IntToStr(Options.Run.Timeout div 10));
      parent := Cache_Put(parentZone, cacheKey, parent );
    end; 
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ФОРМА КАРТОЧКИ ЗАПРОСА' :
          Result := FindWindowByPath(parentZone, 'NAME:=cfSaveLoad;WNDCLASS:=TcfSaveLoad');
        'ЗАГОЛОВОК КЗ' :
          Result := FindWindowByPath(GetFromPPS_Std('ФОРМА КАРТОЧКИ ЗАПРОСА'), 'NAME:=lbHeader;VCLCLASS:=TvtLabel;Caption:=Поиск по ситуации');
        'СИТУАЦИИ ДОПОЛНИТЕЛЬНОГО УРОВНЯ': // дерево атрибутов основной области 
          Result := GetFromAttributeSelect('ДЕРЕВО АТТРИБУТОВ', parent);
        'ВЫБРАННЫЕ СИТУАЦИИ' :
          Result := GetFromAttributeSelect('ВЫБРАННЫЕ АТТРИБУТЫ', parent);          
        'СИТУАЦИИ ОСНОВНОГО УРОВНЯ', 'ВКЛАДКА НАВИГАТОРА "СИТУАЦИИ"' : // список ситуаций в навигаторе 
          Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "СИТУАЦИИ"');
        'СПИСОК ФИЛЬТРОВ', 'ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"':
          Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"');
        'НИЖНИЙ ТУЛБАР' :
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE'),
            'NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: По ситуации;MAXDEPTH:=5'
          );
        'ТУЛБАР "ПОИСК: ВЫБОР РЕКВИЗИТА"' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT'),
            'NAME:=tbefTreeAttributeSelectTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: Выбор реквизита;MAXDEPTH:=4'
          );        
        'ТУЛБАР "ПОИСК: ПО СИТУАЦИИ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT'),
            'NAME:=tbcfSaveLoadTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: По ситуации;MAXDEPTH:=4'
          );        
        'ТУЛБАР "ПОИСК: ВЫБРАННЫЕ ЗНАЧЕНИЯ РЕКВИЗИТА"' :
          Result := FindWindowByPath(
            GetFromPPS_Std('ВЫБРАННЫЕ СИТУАЦИИ'),
            'WNDCLASS:=TenSelectedAttributes;MAXDEPTH:=-1|NAME:=tbenSelectedAttributesTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
          );
        'ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := GetFromAttributeSelect('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"', parent);
        'ПОЛЕ "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := GetFromAttributeSelect('ПОЛЕ "КОНТЕКСТНЫЙ ФИЛЬТР"', parent);  
      else
        Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки
  DESC:
  RESULT:
  REMARK: 
} 
function GetFromPPS_Light(
  whatToGet : String  
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromPPS_Light';
  var 
    parent, cacheKey, parentZone : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);

    cacheKey := FUNCTION_NAME + 'DefaultParent';
    parentZone := GetFromMainWindow('PARENT ZONE');
    if NOT Cache_Check(parentZone, cacheKey, parent) then
    begin
      parent := FindWindowByPath(parentZone, 'NAME:=ZoneContainer;WNDCLASS:=TvtProportionalPanel;MAXDEPTH:=6;TIMEOUT:=' + IntToStr(Options.Run.Timeout div 3));
      parent := Cache_Put(parentZone, cacheKey, parent );
    end; 
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of      
        'ФОРМА КАРТОЧКИ ЗАПРОСА' :
          Result := FindWindowByPath(parentZone, 'NAME:=cfSaveLoad;WNDCLASS:=TcfSaveLoad');        
        'ВЕРХНЯЯ ФОРМА НАЗВАНИЯ КЗ': 
          Result := FindWindowByPath(
            GetFromPPS_Light('ФОРМА КАРТОЧКИ ЗАПРОСА'),
            'NAME:=pnHeader;WNDCLASS:=TvtPanel'
          );
        'ЗАГОЛОВОК КЗ' :
          Result := FindWindowByPath(GetFromPPS_Light('ФОРМА КАРТОЧКИ ЗАПРОСА'), 'NAME:=lbHeader;VCLCLASS:=TvtLabel;Caption:=Поиск по ситуации');
        'СИТУАЦИИ ДОПОЛНИТЕЛЬНОГО УРОВНЯ': // дерево атрибутов основной области 
          Result := FindWindowByPath(parent, 'NAME:=ChildZone;WNDCLASS:=TvtPanel|NAME:=AttributeTree;WNDCLASS:=TnscTreeViewHotTruck;MAXDEPTH:=3');
        'СИТУАЦИИ ОСНОВНОГО УРОВНЯ', 'ВКЛАДКА НАВИГАТОРА "СИТУАЦИИ"' : // список ситуаций в навигаторе
          Result := FindWindowByPath(parent, 'NAME:=MainZone;WNDCLASS:=TvtSizeablePanel|NAME:=AttributeTree;WNDCLASS:=TnscTreeViewHotTruck;MAXDEPTH:=3');
        'ВЫБРАННЫЕ СИТУАЦИИ' :
          Result := FindWindowByPath(parentZone, 'NAME:=BotomPanel;WNDCLASS:=TvtSizeablePanel;MAXDEPTH:=7|NAME:=SelectedTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=3');
        'НИЖНИЙ ТУЛБАР' :
          Result := FindWindowByPath(GetFromMainWindow('PARENT ZONE'),
            'NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: По ситуации;MAXDEPTH:=5');                
        'ТУЛБАР "ПОИСК: ПО СИТУАЦИИ (ПРЕЕМСТВЕННЫЙ)"' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT'),
            'NAME:=tbcfSaveLoadTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: По ситуации;MAXDEPTH:=4');
        'ТУЛБАР "ПОИСК: ВЫБРАННЫЕ ЗНАЧЕНИЯ РЕКВИЗИТА"' :
          Result := FindWindowByPath(
            GetFromPPS_Light('ВЫБРАННЫЕ СИТУАЦИИ'),
            'WNDCLASS:=TenSelectedAttributes;MAXDEPTH:=-1|NAME:=tbenSelectedAttributesTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
          );
        'ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(parentZone, 'NAME:=ContextFilter;WNDCLASS:=TnscContextFilter;MAXDEPTH:=5');
        'ПОЛЕ "КОНТЕКСТНЫЙ ФИЛЬТР"' :        
          Result := FindWindowByPath(
            GetFromPPS_Light('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"'),
            'NAME:=ContextFilter;WNDCLASS:=TnscContextFilter;MAXDEPTH:=5|NAME:=InternalEditor'
        );    
      else
        Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Карточка ППC
  DESC:
  RESULT:
  REMARK:
}
function GetFromPPS(
  whatToGet : String
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromPPS';            
begin
  try   
    if IsExists(GetFromPPS_Std('СИТУАЦИИ ДОПОЛНИТЕЛЬНОГО УРОВНЯ')) then
      Result := GetFromPPS_Std(whatToGet)//Если ППС стандартная
    else
      Result := GetFromPPS_Light(whatToGet);//Если ППС приемственная
      
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;


procedure SC_____PPIO;begin;end;

{
  TYPE: Объекты оболочки/Карточка ППИО
  DESC:
  RESULT:
  REMARK:
}
function GetFromPPIO(
  whatToGet : String
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromPPIO';
  var 
    cacheKey, parent, parentZone : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    cacheKey := FUNCTION_NAME + 'DefaultParent';
    parentZone := GetFromMainWindow('PARENT ZONE');
    if NOT Cache_Check(parentZone, cacheKey, parent) then
    begin
      parent := FindWindowByPath(parentZone, 'NAME:=cfAttributeSelect;WNDCLASS:=TcfAttributeSelect;MAXDEPTH:=3');
      parent := Cache_Put(parentZone, cacheKey, parent );
    end;  
    
    cacheKey := FUNCTION_NAME + whatToGet;    
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin 
      case whatToGet of
      'ДЕРЕВО ИЗДАНИЙ', 'ДЕРЕВО АТТРИБУТОВ' :
        Result := GetFromAttributeSelect('ДЕРЕВО АТТРИБУТОВ', parent);
      'ВЫБРАННЫЕ ИЗДАНИЯ', 'ВЫБРАННЫЕ АТТРИБУТЫ' :
        Result := GetFromAttributeSelect('ВЫБРАННЫЕ АТТРИБУТЫ', parent);      
      'СПИСОК ФИЛЬТРОВ', 'ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"' :
        Result := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"');
      'ТУЛБАР "ФИЛЬТРЫ"', 'ТУЛБАР СПИСКА ФИЛЬТРОВ' :  
        Result := GetFromNavigator('ТУЛБАР "ФИЛЬТРЫ (ВКЛАДКА)"');
      'ТУЛБАР "ПОИСК: ВЫБОР РЕКВИЗИТА"' :
        Result :=
          FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT'),
            'NAME:=tbefTreeAttributeSelectTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
          );
      'ТУЛБАР "ПОИСК: ПО ИСТОЧНИКУ ОПУБЛИКОВАНИЯ"', 'ТУЛБАР ППИО' :
        Result := FindWindowByPath(
          GetFromMainWindow('ROOT OBJECT'),
          'NAME:=tbcfSaveLoadTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Поиск: По источнику опубликования;MAXDEPTH:=4'
        );
      'НИЖНИЙ ТУЛБАР ППИО' :
        Result :=
          FindWindowByPath(
            GetFromMainWindow('PARENT ZONE'),
            'NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=5'
          );      
      'ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
        Result := GetFromAttributeSelect('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"', parent);
      'ПОЛЕ "КОНТЕКСТНЫЙ ФИЛЬТР"' :
        Result := GetFromAttributeSelect('ПОЛЕ "КОНТЕКСТНЫЙ ФИЛЬТР"', parent);  
      else
        Raise('Параметр не распознан!');   
      end;

	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____TB_SETTINGS;begin;end;

{
  TYPE: Объекты оболочки
  DESC:
  RESULT:
  REMARK:
}
function GetFromTbSettings(
  whatToGet : String;
  parent : OleVariant = nil
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromTbSettings';
  var
    cacheKey : OleVariant;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    if (parent = nil) then
      parent := GetFromShell('НАСТРОЙКА ПАНЕЛЕЙ ИНСТРУМЕНТОВ', -1);

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin 
      case whatToGet of
        'КОМБОБОКС ВЫБОРА ТУЛБАРА', 'КОМБОБОКС "ОБЪЕКТ СИСТЕМЫ"' :
          Result := FindWindowByPath(parent, 'NAME:=TopPanel|NAME:=MultipleTopPanel|NAME:=cbObject;WNDCLASS:=TvtComboBoxQS');
        'ЗАКЛАДКИ' :
          Result := FindWindowByPath(parent, 'NAME:=PageControl;WNDCLASS:=TnscPageControl');
        '_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('ЗАКЛАДКИ', parent),
            'NAME:=ToolBarsTabSheet'
          );
        '_ЗАКЛАДКА "БЫСТРЫЙ ВЫЗОВ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('ЗАКЛАДКИ', parent),
            'NAME:=ShortCutsTabSheet'
          );
        '_ЗАКЛАДКА "ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('ЗАКЛАДКИ', parent),
            'NAME:=MiscTabSheet'
          );
          
        'СПИСОК "ТЕКУЩИЕ ОПЕРАЦИИ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"', parent),
            'WNDCLASS:=TvtOutlinerWithDragDrop;INDEX:=1;MAXDEPTH:=2'
          );        
        'СПИСОК "ДОСТУПНЫЕ ОПЕРАЦИИ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"', parent),
            'WNDCLASS:=TvtOutlinerWithDragDrop;INDEX:=2;MAXDEPTH:=2'
          );        
        'КНОПКА "ОК"' :
          Result := FindWindowByPath(parent, 'NAME:=BottomPanel|NAME:=btOk;WNDCLASS:=TvtButton');  
        'КНОПКА "ОТМЕНА"' :
          Result := FindWindowByPath(parent, 'NAME:=BottomPanel|NAME:=btCancel;WNDCLASS:=TvtButton');    
        'КНОПКА "ПРИМЕНИТЬ"' :
          Result := FindWindowByPath(parent, 'NAME:=BottomPanel|NAME:=btApply;WNDCLASS:=TvtButton');      
        'КНОПКА "ВОССТАНОВИТЬ ВСЁ"' :
          Result := FindWindowByPath(parent, 'NAME:=BottomPanel|NAME:=ResetAllToDefaultButton;WNDCLASS:=TvtButton');        
        'КНОПКА "СТРЕЛКА ВЛЕВО"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"', parent),
            'NAME:=RemoveBitBtn;WNDCLASS:=TBitBtn;MAXDEPTH:=2'
          );  
        'КНОПКА "СТРЕЛКА ВПРАВО"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"', parent),
            'NAME:=AddBitBtn;WNDCLASS:=TBitBtn;MAXDEPTH:=2'
          );        
        'КНОПКА "СТРЕЛКА ВНИЗ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"', parent),
            'NAME:=DownBitBtn;WNDCLASS:=TBitBtn;MAXDEPTH:=2'
          );        
        'КНОПКА "СТРЕЛКА ВВЕРХ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"', parent),
            'NAME:=UpBitBtn;WNDCLASS:=TBitBtn;MAXDEPTH:=2'
          );        
        'РАДИОКНОПКА "ЗНАЧОК"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"', parent), 
            'WNDCAPTION:=Значок;WNDCLASS:=TvtRadioButton;MAXDEPTH:=3'
          ); 
        'РАДИОКНОПКА "ЗНАЧОК И ПОДПИСЬ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ПАНЕЛИ ИНСТРУМЕНТОВ"', parent),
            'WNDCAPTION:=Текст и значок;WNDCLASS:=TvtRadioButton;MAXDEPTH:=3'
          ); 
        'ВКЛАДКА БЫСТРЫЙ ВЫЗОВ: ОПЕРАЦИИ' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "БЫСТРЫЙ ВЫЗОВ"', parent),
            'WNDCLASS:=TvtOutliner'
          );
        'ВКЛАДКА БЫСТРЫЙ ВЫЗОВ: "СПИСОК ШОТКАТОВ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "БЫСТРЫЙ ВЫЗОВ"', parent),
            'NAME:=lwShortCuts;WNDCLASS:=TListView'
          );  
        'ВКЛАДКА БЫСТРЫЙ ВЫЗОВ: "ШОТКАТ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "БЫСТРЫЙ ВЫЗОВ"', parent),
            'NAME:=ShortCutEdit;WNDCLASS:=TeeShortCutEdit'
          );        
        'ВКЛАДКА БЫСТРЫЙ ВЫЗОВ: КНОПКА "ДОБАВИТЬ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "БЫСТРЫЙ ВЫЗОВ"', parent),
            'NAME:=AddButton;WNDCLASS:=TvtButton'
          ); 
        'ВКЛАДКА БЫСТРЫЙ ВЫЗОВ: КНОПКА "УДАЛИТЬ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "БЫСТРЫЙ ВЫЗОВ"', parent),
            'NAME:=RemoveButton;WNDCLASS:=TvtButton'
          );         
        'ВКЛАДКА БЫСТРЫЙ ВЫЗОВ: КНОПКА "ОЧИСТИТЬ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "БЫСТРЫЙ ВЫЗОВ"', parent),
            'NAME:=ClearShortcutButton;WNDCLASS:=TvtButton'
          );         
        'ВКЛАДКА ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ: РАДИОКНОПКА "МАЛЕНЬКИЕ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ"', parent),
            'WNDCAPTION:=маленькие;WNDCLASS:=TvtRadioButton;MAXDEPTH:=2'
          );         
        'ВКЛАДКА ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ: РАДИОКНОПКА "БОЛЬШИЕ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ"', parent),
            'WNDCAPTION:=большие;WNDCLASS:=TvtRadioButton;MAXDEPTH:=2'
          );        
        'ВКЛАДКА ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ: РАДИОКНОПКА "АВТОМАТИЧЕСКИ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ"', parent),
            'WNDCAPTION:=автоматически;WNDCLASS:=TvtRadioButton;MAXDEPTH:=2'
          );        
        'ВКЛАДКА ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ: РАДИОКНОПКА "16 ЦВЕТОВ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ"', parent),
            'WNDCAPTION:=16 цветов;WNDCLASS:=TvtRadioButton;MAXDEPTH:=2'
          );        
        'ВКЛАДКА ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ: РАДИОКНОПКА "256 ЦВЕТОВ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ"', parent),
            'WNDCAPTION:=256 цветов;WNDCLASS:=TvtRadioButton;MAXDEPTH:=2'
          );        
        'ВКЛАДКА ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ: РАДИОКНОПКА "ПОЛНОЦВЕТНЫЕ"' :
          Result := FindWindowByPath(
            GetFromTbSettings('_ЗАКЛАДКА "ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ"', parent),
            'WNDCAPTION:=полноцветные;WNDCLASS:=TvtRadioButton;MAXDEPTH:=2'
          );        
      else
        Raise('Параметр не распознан!');   
      end;  
    
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки
  DESC:
  RESULT:
  REMARK:
}
function GetFromAccessibleOperationTB(
  whatToGet : String;
  parent : OleVariant = nil
) : OleVariant;
  const 
    FUNCTION_NAME = 'GetFromAccessibleOperationTB';
  var
    cacheKey : OleVariant;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    if (parent = nil) then
      parent := GetFromShell('НАСТРОЙКА ДОСТУПНЫХ ОПЕРАЦИЙ', -1);

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin 
      case whatToGet of        
        '_ГРУППЫ':
          Result := FindWindowByPath(parent, 'NAME:=pnlRep|NAME:=gbAvailableGroups;WNDCLASS:=TvtGroupBox');  
        '_ТЕКУЩИЕ':
          Result := FindWindowByPath(parent, 'NAME:=pnlMain|NAME:=pnlTasksPanel|NAME:=gbTasksPanel;WNDCLASS:=TvtGroupBox');          
        //
        'ДЕРЕВО "ДОСТУПНЫЕ ОПЕРАЦИИ"':
          Result := FindWindowByPath(parent, 'NAME:=pnlRep|NAME:=gbAvailableOperations|NAME:=tvRepOps;WNDCLASS:=TeeTreeView');  
        'ДЕРЕВО "ДОСТУПНЫЕ ГРУППЫ"':
          Result := FindWindowByPath(GetFromAccessibleOperationTB('_ГРУППЫ'), 'NAME:=tvRepGroups;WNDCLASS:=TeeTreeView');
        'ДЕРЕВО "ТЕКУЩАЯ ПАНЕЛЬ ЗАДАЧ"':
          Result := FindWindowByPath(GetFromAccessibleOperationTB('_ТЕКУЩИЕ'), 'NAME:=tvTasksPanel;WNDCLASS:=TeeTreeView');
          
        'КНОПКА "ДОБАВИТЬ ГРУППУ"':    
          Result := FindWindowByPath(GetFromAccessibleOperationTB('_ГРУППЫ'), 'WNDCLASS:=TvtPanel|NAME:=btnAddGroup;WNDCLASS:=TeeButton');
        'ПОЛЕ ВВОДА ИМЕНИ ГРУППЫ':
          Result := FindWindowByPath(GetFromAccessibleOperationTB('_ГРУППЫ'), 'WNDCLASS:=TvtPanel|NAME:=cbGroupName;WNDCLASS:=TvtComboBox');
        'КНОПКА "ВКЛЮЧИТЬ ГРУППУ В ТЕКУЩИЕ"':
          Result := FindWindowByPath(parent, 'NAME:=pnlLeft;WNDCLASS:=TvtPanel;MAXDEPTH:=2|NAME:=btnMoveGroupToPane;WNDCLASS:=TBitBtn');
        'КНОПКА "ВКЛЮЧИТЬ ОПЕРАЦИЮ В ТЕКУЩИЕ"':
          Result := FindWindowByPath(parent, 'NAME:=pnlLeft;WNDCLASS:=TvtPanel;MAXDEPTH:=2|NAME:=btnMoveOpToPane;WNDCLASS:=TBitBtn');    
        'КНОПКА "ИСКЛЮЧИТЬ ГРУППУ ИЗ ТЕКУЩИХ"':
          Result := FindWindowByPath(parent, 'NAME:=pnlLeft;WNDCLASS:=TvtPanel;MAXDEPTH:=2|NAME:=btnMoveGroupToRep;WNDCLASS:=TBitBtn');
        'КНОПКА "ИСКЛЮЧИТЬ ОПЕРАЦИЮ ИЗ ТЕКУЩИХ"':
          Result := FindWindowByPath(parent, 'NAME:=pnlLeft;WNDCLASS:=TvtPanel;MAXDEPTH:=2|NAME:=btnMoveOpToRep;WNDCLASS:=TBitBtn');  
        'КНОПКА "OK"':
          Result := FindWindowByPath(parent, 'NAME:=pnlBottom;WNDCLASS:=TvtPanel;MAXDEPTH:=2|NAME:=btOk;WNDCLASS:=TvtButton');
        'КНОПКА "ПРИМЕНИТЬ"':
          Result := FindWindowByPath(parent, 'NAME:=pnlBottom;WNDCLASS:=TvtPanel;MAXDEPTH:=2|NAME:=btApply;WNDCLASS:=TvtButton');    
          
      else
        Raise('Параметр не распознан!');   
      end;  
    
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;
procedure SC_____NAVIGATOR;begin;end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
} 
function GetFromFolderForm(
  whatToGet : String;
  parent : OleVariant;   
  const addParams : String = ''
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromFolderForm';
  var 
    isModalDialog : boolean;
    w, paramList, cacheKey : OleVariant;
    hOrder, vOrder : integer;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    if NOT IsExists(parent) then
      Raise('Родительский объект не существует!');
    
    // проверяем вход и приводим его к нужному
    if NOT( IsSupported(parent, 'WndClass') AND StringCompare(parent.WndClass, 'TcfFoldersInfo')) then
    begin // если parent не задан, либо он не модальное окно
      if NOT StringCompare(parent.WndClass, 'TcfFolders') then
        parent := FindWindowByPath(parent, 'WNDCLASS:=TcfFolders;MAXDEPTH:=-5');
      if NOT StringCompare(parent.WndClass, 'TcfFolders') then
        Raise('Объект parent неправильный!');

      // обработка ситуации с новым окном ввода параметров при создании новой папки из диалога сохранения 
      isModalDialog := (NOT parent.Enabled) AND parent.Visible;
      if isModalDialog then 
        parent := FindWindowByPath(
          GetF1ShellProcess,
          'NAME:=cfFoldersInfo;WNDCLASS:=TcfFoldersInfo;Enabled:=true;Visible:=true'
        );
    end; 
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if (whatToGet = 'КНОПКА ДОСТУПА') OR (whatToGet = 'КОМБОБОКС ВЫБОРА ПОЛЬЗОВАТЕЛЯ') then
      cacheKey := cacheKey + addParams; 
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin 
      case whatToGet of
        'PARENT ZONE' :
          Result := FindWindowByPath(parent, 'NAME:=ParentZone;WNDCLASS:=TvtPanel;MAXDEPTH:=3');
        'CHILD ZONE' :
          Result := FindWindowByPath(parent, 'NAME:=ChildZone;MAXDEPTH:=3');
          
        'ДЕРЕВО ПАПОК' :
          Result := FindWindowByPath(
            GetFromFolderForm('PARENT ZONE', parent),
            'NAME:=FoldersTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=3'
          );
        'ТУЛБАР "МОИ ДОКУМЕНТЫ"' :  
          Result := FindWindowByPath(
            parent,
            'NAME:=tbenFoldersTreeTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Мои документы*;MAXDEPTH:=4'
          );
        'НИЖНИЙ ТУЛБАР' :
          if isModalDialog then
            Result := FindWindowByPath(parent, 'NAME:=tbcfFoldersInfoBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4')
          else
            Result := FindWindowByPath(parent, 'NAME:=tbcfFoldersBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4');
        'ВЕРХНИЙ ТУЛБАР' : // ЭТОТ ТУЛБАР ОБЫЧНО ПУСТОЙ!!! НЕ ПУТАТЬ С ТУЛБАРОМ "МОИ ДОКУМЕНТЫ"!!! 
          Result := FindWindowByPath(
            parent,
            'NAME:=tbcfFoldersTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
          );          
        'КНОПКА "ЗАКРЫТЬ ВКЛАДКУ"' ://Находится на верхнем правом тулбаре "крестик"  
          Result := FindWindowByPath(
            parent,
            'NAME:=tbenFoldersTreeTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Мои документы*;MAXDEPTH:=4'
          );
        'КОМБОБОКС "ТИПИЗИРОВАННЫЙ ФИЛЬТР"' :  
          Result := FindWindowByPath(
            parent,
            'NAME:=tbenFoldersTreeTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4|NAME:=bt_enFolders_opFiltrate;WNDCLASS:=TvcmComboBox'
          );      
        'ЗАГОЛОВОК' :
          Result := FindWindowByPath(
            GetFromFolderForm('CHILD ZONE', parent),
            'NAME:=InfoName;VCLCLASS:=TvtLabel;Visible:=true;MAXDEPTH:=3'
          );
        // объекты вкладки "Свойства"
        'ПОЛЕ "ИМЯ"' :          
        Result := FindWindowByPath(
            GetFromFolderForm('CHILD ZONE', parent),
            'NAME:=ElementName;WNDCLASS:=TnscComboBoxWithReadOnly*;Visible:=true;MAXDEPTH:=4'
          );  
        'ПОЛЕ "ПРИМЕЧАНИЕ"' :
          Result := FindWindowByPath(
            GetFromFolderForm('CHILD ZONE', parent),
            'NAME:=ElementComment;WNDCLASS:=TeeMemoWithEditOperations;Visible:=true;MAXDEPTH:=3'
          );          
        'ДАТА СОЗДАНИЯ' :
          Result := FindWindowByPath(
            GetFromFolderForm('CHILD ZONE', parent),
            'NAME:=lblDate;Visible:=true;MAXDEPTH:=3'
          );
        'ЧЕКБОКС "ОТКРЫТЬ ОБЩИЙ ДОСТУП"' :
          Result := FindWindowByPath(
             GetFromFolderForm('CHILD ZONE', parent),
            'NAME:=cbShared;WNDCAPTION:=Общий доступ*;Visible:=true;MAXDEPTH:=4'
          );      
        
      else
        Raise('Параметр не распознан!');   
      end;
 
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

const
  _NAV_DELIM = ':|:';
  NAV_LEFT  = 'ЛЕВЫЙ НАВИГАТОР'   + _NAV_DELIM;
  NAV_RIGHT = 'ПРАВЫЙ НАВИГАТОР'  + _NAV_DELIM;
  NAV_ALL   = 'ЛЮБОЙ НАВИГАТОР'   + _NAV_DELIM;
  NAV_FLOATING = 'ПЛАВАЮЩИЙ НАВИГАТОР' + _NAV_DELIM; 

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: Объекты, единые для всех состояний оболочки (ППР, ППИО, словарь ... )
    По-умолчанию функция разыскивает указанные объекты на обоих навигаторах, чтобы искать объект на конкретном навигаторе надо
    к имени объекта спереди прибавить одну из констант, например, NAV_RIGHT+'ВКЛАДКА НАВИГАТОРА "МЕНЮ"' чтобы искать
    вкладку "меню" на правом навигаторе.
}   
function GetFromNavigator(
  whatToGet : String;
  mainWnd : OleVariant = nil // Главное Окно оболочки
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromNavigator';
  var
    cacheKey : OleVariant;
    navigatorForm, rootObj : OleVariant;
    whichNav, commonNavTimeout : string;
begin
  // CACHE
  try
    whatToGet := AnsiUpperCase(whatToGet);      
    // бремя совместимости    
    case whatToGet of
      'PAGECONTROL ЛЕВОГО НАВИГАТОРА', 'ЗАКЛАДКИ ЛЕВОГО НАВИГАТОРА' :
        whatToGet := NAV_LEFT  + 'PAGECONTROL';
      'PAGECONTROL ПРАВОГО НАВИГАТОРА', 'ЗАКЛАДКИ ПРАВОГО НАВИГАТОРА' :
        whatToGet := NAV_RIGHT + 'PAGECONTROL';
      'ФОРМА ЛЕВОГО НАВИГАТОРА' :
        whatToGet := NAV_LEFT + 'ФОРМА НАВИГАТОРА';
      'ФОРМА ПРАВОГО НАВИГАТОРА' :
        whatToGet := NAV_RIGHT + 'ФОРМА НАВИГАТОРА';
      'ФОРМА ПЛАВАЮЩЕГО НАВИГАТОРА':
        whatToGet := NAV_FLOATING + 'ФОРМА НАВИГАТОРА';
    end;             
        
    // дробим wgatToGet на целевой навигатор и собственно нужный объект
    if Pos(_NAV_DELIM, whatToGet) <> 0 then
    begin
      whichNav := GetSubStr(whatToGet, '', _NAV_DELIM) + _NAV_DELIM;
      whatToGet := GetSubStr(whatToGet, _NAV_DELIM, '');       
    end
    else
      whichNav := NAV_ALL;
    
    commonNavTimeout := 'TIMEOUT:=' + IntToStr(Options.Run.Timeout div 3);
    if (mainWnd = nil) then
      mainWnd := GetMainWindow(commonNavTimeout);                  
    rootObj := GetFromMainWindow('CLIENT ZONE', commonNavTimeout, mainWnd); 

    cacheKey := FUNCTION_NAME + whichNav;        
    case whichNav of
      NAV_LEFT : // нужен объект с левого навигатора
        if NOT Cache_Check(rootObj, cacheKey, navigatorForm) then
          navigatorForm := Cache_Put(rootObj, cacheKey, FindWindowByPath(rootObj, 'NAME:=LeftNavigator;WNDCLASS:=TnscNavigator;' + commonNavTimeout) );
      NAV_RIGHT: // нужен объект с правого навигатора
        if NOT Cache_Check(rootObj, cacheKey, navigatorForm) then
          navigatorForm := Cache_Put(rootObj, cacheKey, FindWindowByPath(rootObj, 'NAME:=RightNavigator;WNDCLASS:=TnscNavigator;' + commonNavTimeout) );
      NAV_FLOATING :
        if NOT Cache_Check(GetF1ShellProcess, cacheKey, navigatorForm) then
          navigatorForm := Cache_Put(GetF1ShellProcess, cacheKey, FindWindowByPath(GetF1ShellProcess, 'WNDCLASS:=TnscFloatingWindow;WNDCAPTION:=Плавающий навигатор|WNDCLASS:=TnscNavigator;' + commonNavTimeout) );
      NAV_ALL: // нужен объект с любого навигатора
        begin
          Result := GetFromNavigator(NAV_LEFT + whatToGet, mainWnd); // сначала пытаемся получить с левого навигатора
          if NOT IsExists(Result) then 
            Result := GetFromNavigator(NAV_RIGHT + whatToGet, mainWnd); // а если не получилось, то с правого
            if NOT IsExists(Result) then 
              Result := GetFromNavigator(NAV_FLOATING + whatToGet, mainWnd); // а если ещё раз не получилось, то с плавающего
          Exit;              
        end;  
    end;  
    
    cacheKey := FUNCTION_NAME + whatToGet;      
    if NOT Cache_Check(navigatorForm, cacheKey, Result ) then
    begin
      case whatToGet of
        'ФОРМА НАВИГАТОРА':
          Result := navigatorForm;        
            
        'PAGECONTROL' :
          Result := FindWindowByPath(
            navigatorForm,
            'WNDCLASS:=TnscNavigatorPageControl;MAXDEPTH:=4;' + commonNavTimeout
          );        
      
        'ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'NAME:=enFilters;WNDCLASS:=TenFilters;MAXDEPTH:=5|NAME:=FiltersList;' + commonNavTimeout
          );          
        'ВКЛАДКА НАВИГАТОРА "МЕНЮ"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'NAME:=en_Navigator;WNDCLASS:=Ten_Navigator;MAXDEPTH:=5|NAME:=BackgroundPanel|NAME:=NavigatorTree;' + commonNavTimeout
          );
          
        'ФОРМА ВКЛАДКИ НАВИГАТОРА "МОИ ДОКУМЕНТЫ"' :              
           Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'NAME:=cfFolders;WNDCLASS:=TcfFolders;MAXDEPTH:=5;' + commonNavTimeout
          );
        'ВКЛАДКА НАВИГАТОРА "МОИ ДОКУМЕНТЫ"' : 
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'ФОРМА ВКЛАДКИ НАВИГАТОРА "МОИ ДОКУМЕНТЫ"', mainWnd),
            'NAME:=FoldersTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=5;' + commonNavTimeout
          );
        'ВКЛАДКА НАВИГАТОРА "ЖУРНАЛ РАБОТЫ"' : 
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'NAME:=WorkJournalForm;WNDCLASS:=TWorkJournalForm;MAXDEPTH:=5|NAME:=JournalTree;' + commonNavTimeout
          );                          
        'ВКЛАДКА НАВИГАТОРА "РЕДАКЦИИ"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'NAME:=RedactionsForm;WNDCLASS:=TRedactionsForm;MAXDEPTH:=5|NAME:=RedactionTree;' + commonNavTimeout
          );
        'БЛОК НАВИГАТОРА "ОГЛАВЛЕНИЕ"' :  
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Структура документа|NAME:=ContentsForm;WNDCLASS:=TContentsForm|NAME:=BackgroundPanel|NAME:=Tasks|WNDCLASS:=TnscTasksPanelHideField;' + commonNavTimeout
          );        
        'ВКЛАДКА НАВИГАТОРА "СТРУКТУРА ДОКУМЕНТА"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Структура документа|NAME:=ContentsForm;WNDCLASS:=TContentsForm|NAME:=BackgroundPanel|NAME:=Tasks|NAME:=ContentsTree;MAXDEPTH:=2;' + commonNavTimeout
          ); 
        'ДЕРЕВО "ВСТРОЕННЫЕ ОБЪЕКТЫ" СО ВКЛАДКИ НАВИГАТОРА "СТРУКТУРА ДОКУМЕНТА"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Структура документа|NAME:=ContentsForm;WNDCLASS:=TContentsForm|NAME:=BackgroundPanel|NAME:=Tasks|NAME:=lstExternalObjects;MAXDEPTH:=2'            
          );        
        'ДЕРЕВО "ЗАКЛАДКИ" СО ВКЛАДКИ НАВИГАТОРА "СТРУКТУРА ДОКУМЕНТА"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Структура документа|NAME:=ContentsForm;WNDCLASS:=TContentsForm|NAME:=BackgroundPanel|NAME:=Tasks|NAME:=lstBookmarks;MAXDEPTH:=2'            
          ); 
        'ДЕРЕВО "МОИ КОММЕНТАРИИ" СО ВКЛАДКИ НАВИГАТОРА "СТРУКТУРА ДОКУМЕНТА"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Структура документа|NAME:=ContentsForm;WNDCLASS:=TContentsForm|NAME:=BackgroundPanel|NAME:=Tasks|NAME:=lstComments;WNDCLASS:=TvtLister;MAXDEPTH:=2'
          );
        'ВКЛАДКА НАВИГАТОРА "СТРУКТУРА ПРЕПАРАТА"' :            
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Структура препарата|NAME:=ContentsForm;WNDCLASS:=TContentsForm|NAME:=BackgroundPanel|NAME:=Tasks|NAME:=ContentsTree;MAXDEPTH:=2;' + commonNavTimeout
          );
        'ДЕРЕВО "МОИ КОММЕНТАРИИ" СО ВКЛАДКИ НАВИГАТОРА "СТРУКТУРА ПРЕПАРАТА"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TElTabSheet;CAPTION:=Структура препарата|NAME:=ContentsForm;WNDCLASS:=TContentsForm|NAME:=BackgroundPanel|NAME:=Tasks|NAME:=lstComments;WNDCLASS:=TvtLister;MAXDEPTH:=2'
          );  
        'ВКЛАДКА НАВИГАТОРА "КОНФИГУРАЦИИ"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=Ten_ConfigurationList;MAXDEPTH:=5|NAME:=tvConfs;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;' + commonNavTimeout
          ); 
                 
        'ВКЛАДКА НАВИГАТОРА "ДОКУМЕНТЫ НА КОНТРОЛЕ"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TenUnderControl;MAXDEPTH:=5|NAME:=UnderControlList;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;' + commonNavTimeout
          );

        'ВКЛАДКА НАВИГАТОРА "СИТУАЦИИ"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TefTreeAttributeFirstLevel;MAXDEPTH:=5|NAME:=FirstLevelContent;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;' + commonNavTimeout
          );                    
          
        'ВКЛАДКА НАВИГАТОРА "МОЯ НОВОСТНАЯ ЛЕНТА"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TenNewsLine;MAXDEPTH:=5|NAME:=DateList;WNDCLASS:=TnscTreeViewForNewsLine;' + commonNavTimeout
          );
          
        'ВКЛАДКА НАВИГАТОРА "ТОЛКОВЫЙ СЛОВАРЬ"' : 
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TenDiction;MAXDEPTH:=5|NAME:=BackgroundPanel|NAME:=WordsTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;' + commonNavTimeout
          );        
        'ВКЛАДКА НАВИГАТОРА "ПАНЕЛЬ ЗАДАЧ"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=Ten_TasksPanel;MAXDEPTH:=5|NAME:=tpvMain;WNDCLASS:=TnscTasksPanelView;' + commonNavTimeout
          );              

        'ТУЛБАР "СТРУКТУРА ДОКУМЕНТА"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'NAME:=tbContentsFormTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=6'
          );          
        'ТУЛБАР "ФИЛЬТРЫ (ВКЛАДКА)"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'ВКЛАДКА НАВИГАТОРА "ФИЛЬТРЫ"', mainWnd),
            'NAME:=enFilters;MAXDEPTH:=-1|NAME:=tbenFiltersTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
          );          
        'ТУЛБАР "МОИ ДОКУМЕНТЫ"', 'ТУЛБАР "МОИ ДОКУМЕНТЫ (ВКЛАДКА)"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'ФОРМА ВКЛАДКИ НАВИГАТОРА "МОИ ДОКУМЕНТЫ"', mainWnd),
            'WNDCLASS:=TvcmToolbar;WNDCAPTION:=Мои документы*вкладка*;MAXDEPTH:=5'
          );                 
        'ТУЛБАР "МЕНЮ"', 'ТУЛБАР "МЕНЮ (ВКЛАДКА)"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'NAME:=en_Navigator;WNDCLASS:=Ten_Navigator;MAXDEPTH:=5|NAME:=tben_NavigatorTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=5'
          );        
        'ТУЛБАР "ДОКУМЕНТЫ НА КОНТРОЛЕ"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TenUnderControl;MAXDEPTH:=5|NAME:=tbenUnderControlTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=5'
          );        
        'ТУЛБАР "МОЯ НОВОСТНАЯ ЛЕНТА"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=TenNewsLine;MAXDEPTH:=5|WNDCAPTION:=ПРАЙМ*Моя новостная лента*;WNDCLASS:=TvcmToolbar;MAXDEPTH:=5'
          );
        'ТУЛБАР "КОНФИГУРАЦИИ (ВКЛАДКА)"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'WNDCLASS:=Ten_ConfigurationList;MAXDEPTH:=5|WNDCAPTION:=Конфигурац*;NAME:=tben_ConfigurationListTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=5'
          ); 
        'КНОПКА "СВЕРНУТЬ/РАЗВЕРНУТЬ"' :
          begin
            Result := 
              FindWindowByPath(
                navigatorForm, 'WNDCLASS:=TnpHeader;MAXDEPTH:=3|NAME:=TnpButton_2;VCLCLASS:=TnpButton;Visible:=True;VisibleOnScreen:=true;IsAddCheckInfo:=true'
            );
            {//старый хитрый способ
             Result := FindSimilarWindow(
              FindWindowByPath(navigatorForm, 'WNDCLASS:=TnpHeader;MAXDEPTH:=3'),
              ['VCLClass', 'Visible', 'VisibleOnScreen'], ['TnpButton', true, true],
              Choose(whichNav = NAV_LEFT, 2, 1), 0);
            }  
          end;
        'КНОПКА "ЗАКРЫТЬ"' :
          begin
            Result := 
              FindWindowByPath(
                navigatorForm, 
                'WNDCLASS:=TnpHeader;MAXDEPTH:=3|NAME:=CLOSE;HINT:=Закрыть;VCLCLASS:=TnpButton;Visible:=True;VisibleOnScreen:=true;IsAddCheckInfo:=true'
            );
          end;  
        'КНОПКА "ПРИКРЕПИТЬ НАВИГАТОР"' :
          begin
             Result :=              
               FindWindowByPath(
                navigatorForm, 
                  'WNDCLASS:=TnpHeader;MAXDEPTH:=3|NAME:=HIDELEFT;VCLCLASS:=TnpButton;Visible:=True;VisibleOnScreen:=true;IsAddCheckInfo:=true'
            );    
          end;
        'ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(
            GetFromNavigator(whichNav + 'PAGECONTROL', mainWnd),
            'NAME:=BackgroundPanel;WNDCLASS:=TvtPanel;Visible:=True;MAXDEPTH:=3|NAME:=ContextFilter;WNDCLASS:=TnscContextFilter'
          );        
      else
        Raise('Параметр не распознан!');   
      end;
      
      Result := Cache_Put(navigatorForm, cacheKey, Result);
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"' + EndOfLine + 'whichNav: "' +  whichNav + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со списками; Работа со вкладками
  DESC: Возвращает дерево вкладки "Мои документы"
  RESULT:
  REMARK: оставлена для совместимости
}
function GetFolderTree: Window;
begin
  try
    Result := GetFromNavigator('Вкладка навигатора "Мои документы"');
  except
    Log.Message('GetFolderTree: '+ ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____MAIN_WINDOW;begin;end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
}
function GetFromMainWindow(
  whatToGet : String;
  const addParams : String = '';
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromMainWindow';
  var
    dontCache : boolean;
    cacheKey : OleVariant;
begin
  try
    dontCache := false;
    whatToGet := AnsiUpperCase(whatToGet);
    if (parent = nil) then
      parent := GetMainWindow(addParams);
    
    cacheKey := FUNCTION_NAME + whatToGet;             
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        // начало.служебные объекты
        'ROOT OBJECT' :
          Result := FindWindowByPath(
            parent,
            'NAME:=vcmDockContainer;WNDCLASS:=TvcmDockContainer'
          );
        'CLIENT ZONE' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', addParams, parent),
            'NAME:=ClientZone;WNDCLASS:=TvtPanel'
          );
        'PARENT ZONE' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', addParams, parent),
            'NAME:=MainZone;WNDCLASS:=TvtProportionalPanel;MAXDEPTH:=2|NAME:=ParentZonePanel;WNDCLASS:=TvtPanel|NAME:=ParentForm;WNDCLASS:=TParentForm|NAME:=ParentZone;WNDCLASS:=TvtPanel'
          );
        'CHILD ZONE' :
          Result := FindWindowByPath(
            GetFromMainWindow('CLIENT ZONE', addParams, parent),                                                                                             
            'NAME:=MainZone;WNDCLASS:=TvtProportionalPanel|NAME:=ChildZonePanel;WNDCLASS:=TvtSizeablePanel|NAME:=ChildForm;WNDCLASS:=TChildForm|NAME:=ChildZone;WNDCLASS:=TnscFormsPageControl'
          );
        // конец.служебные объекты      
        'ТУЛБАР', 'ТУЛБАР "ГЛАВНАЯ ПАНЕЛЬ ИНСТРУМЕНТОВ"' :
          begin
            Result := FindWindowByPath(
              GetFromMainWindow('ROOT OBJECT', addParams, parent),
              'NAME:=tbnsMainWindowTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4;Timeout:=10',
              false
            );
            if NOT IsExists(Result) then
              Result := FindWindowByPath(
                GetF1ShellProcess,
                'NAME:=tbnsMainWindowTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=1;Timeout:=10'
              );            
          end;
        'ОБЛАСТЬ ОСНОВНОГО МЕНЮ' :
          // в 7.6 одна форма для основной и расширенной конфигурации
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', addParams, parent),
            'NAME:=en_MainMenuNew;WNDCLASS:=Ten_MainMenuNew;TimeOut:=10'
          );
        'ОБЛАСТЬ ОСНОВНОГО МЕНЮ ИНФАРМА' :
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', addParams, parent),
            'NAME:=en_MedicMainMenu;WNDCLASS:=Ten_MedicMainMenu;TimeOut:=10'
          );
        'ИНФОРМАЦИЯ О КОМПЛЕКТЕ' :  
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', addParams, parent),
            'NAME:=tvComplectInfo;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=3'
          );
        'ГЛАВНОЕ МЕНЮ' :
          begin
            // начиная с 7.12 ГМ parent.Menu теперь нет, http://mdp.garant.ru/pages/viewpage.action?pageId=611211969&focusedCommentId=611820353#comment-611820353
            dontCache := true;
            if VarToBool(gbl_F1ShellTabsEnabled) then
              Result := nil
            else
              Result := parent.Menu;
          end;  
        'ПРЕВЬЮ', 'ПРЕДВАРИТЕЛЬНЫЙ ПРОСМОТР' :
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', addParams, parent),
            'NAME:=PreviewPanel;WNDCLASS:=TnscPreviewPanel;MAXDEPTH:=3'
          );
        'ВЕРХНЯЯ ЗОНА ДОКИНГА' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', addParams, parent),
            'NAME:=TopDock;WNDCLASS:=TvcmDockDef;MAXDEPTH:=4'
          );
        'НИЖНЯЯ ЗОНА ДОКИНГА' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', addParams, parent),
            'NAME:=BottomDock;WNDCLASS:=TvcmDockDef;MAXDEPTH:=4'
          );
        'ЛЕВАЯ ЗОНА ДОКИНГА' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', addParams, parent),
            'NAME:=LeftDock;WNDCLASS:=TvcmDockDef;MAXDEPTH:=4'
          );
        'ПРАВАЯ ЗОНА ДОКИНГА' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', addParams, parent),
            'NAME:=RightDock;WNDCLASS:=TvcmDockDef;MAXDEPTH:=4'
          );    
        'ФОРМА ПРОСМОТРА ГРАФИЧЕСКОГО ОБЪЕКТА' : // это надо будет потом переименовать
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', addParams, parent),
            'NAME:=PictureForm;WNDCLASS:=TPictureForm;MAXDEPTH:=3'
          );
        'СТАТУСБАР' :
          Result := FindWindowByPath(parent, 'NAME:=nscDock_for_nscStatusbar;WNDCLASS:=TnscStatusBarDock|NAME:=StatusBar;WNDCLASS:=TnscStatusBar');
        'СТАТУСБАР: КНОПКА ПРЕДЫДУЩИЙ ДОКУМЕНТ В СПИСКЕ' :
          Result := FindWindowByPath(
            GetFromMainWindow('СТАТУСБАР', addParams, parent),
            'HINT:=Предыдущий*;VCLCLASS:=TnscStatusBarButton'
          );  
        'СТАТУСБАР: КНОПКА ВЕРНУТЬСЯ В СПИСОК' :
          Result := FindWindowByPath(
            GetFromMainWindow('СТАТУСБАР', addParams, parent),
            'HINT:=Вернуться*;VCLCLASS:=TnscStatusBarButton'
          );  
        'СТАТУСБАР: КНОПКА СЛЕДУЮЩИЙ ДОКУМЕНТ В СПИСКЕ' :        
          Result := FindWindowByPath(
            GetFromMainWindow('СТАТУСБАР', addParams, parent),
            'HINT:=Следующий*;VCLCLASS:=TnscStatusBarButton'
          );  
        'СТАТУСБАР: КНОПКА НРАВИТСЯ' :
          Result := FindWindowByPath(
            GetFromMainWindow('СТАТУСБАР', addParams, parent),
            'HINT:=Нравится*;VCLCLASS:=TnscStatusBarButton'
          );
        'СТАТУСБАР: КНОПКА НЕ НРАВИТСЯ' :
          Result := FindWindowByPath(
            GetFromMainWindow('СТАТУСБАР', addParams, parent),
            'HINT:=Не нравится*;VCLCLASS:=TnscStatusBarButton'
          );  
        'ГРАФИЧЕСКИЙ ОБЪЕКТ' :
          Result := FindWindowByPath(
            GetFromMainWindow('ФОРМА ПРОСМОТРА ГРАФИЧЕСКОГО ОБЪЕКТА', addParams, parent ),
            'NAME:=ieViewer;WNDCLASS:=TImageEnView'
          );  
        'ТУЛБАР "ДОКУМЕНТ: ГРАФИЧЕСКИЙ ОБЪЕКТ"':   
          Result := FindWindowByPath(
            GetFromMainWindow('ВЕРХНЯЯ ЗОНА ДОКИНГА', addParams, parent ),
            'NAME:=tbPictureFormTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Просмотр графического объекта'
          );
        'ТУЛБАР "ДЕРЕВО ПОЛЬЗОВАТЕЛЕЙ И ГРУПП"':           
          Result := FindWindowByPath(
            GetFromMainWindow('ВЕРХНЯЯ ЗОНА ДОКИНГА', addParams, parent ),
            'NAME:=tbefUserListTop;WNDCLASS:=TvcmToolbar;WNDCAPTION:=Список пользователей*'
          );
        'ПАНЕЛЬ "БАЗОВЫЙ ПОИСК"':
        begin
          Result := FindWindowByPath(
            GetFromMainWindow('CLIENT ZONE', addParams, parent),
            'NAME:=BaseSearchPanel;WNDCLASS:=TvtPanel|NAME:=NewBaseSearchForm;WNDCLASS:=TNewBaseSearchForm',
            false, 'TimeOut:=' + IntToStr(Options.Run.Timeout div 3) 
          );
          if not IsExists(Result) then
          begin
            Result := FindWindowByPath(
              GetFromMainWindow('ОБЛАСТЬ ОСНОВНОГО МЕНЮ', addParams, parent),
              'NAME:=pnlBaseSearch;WNDCLASS:=TvtPanel;MAXDEPTH:=2|WNDCLASS:=TNewBaseSearchForm;MAXDEPTH:=2',
              false, 'TimeOut:=' + IntToStr(Options.Run.Timeout div 5)
            );
            if not IsExists(Result) then
              Result := FindWindowByPath(
                GetFromMainWindow('PARENT ZONE', addParams, parent),
                'NAME:=ChildZone;WNDCLASS:=TvtPanel;MAXDEPTH:=2|NAME:=NewBaseSearchForm;WNDCLASS:=TNewBaseSearchForm',
                true, 'TimeOut:=' + IntToStr(Options.Run.Timeout div 5)
              );
          end;
        end;
        
        'ЗНАЧОК: ИНФОРМАЦИОННЫЙ БАНК УСТАРЕЛ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'NAME:=nsMainWindow*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage_6;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true;' + addParams
          );
        'ЗНАЧОК: ОТВЕТ НА КОНСУЛЬТАЦИИ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'NAME:=nsMainWindow*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage_2;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true;' + addParams
          );
        'ЗНАЧОК: ДОКУМЕНТЫ НА КОНТРОЛЕ ИЗМЕНИЛИСЬ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'NAME:=nsMainWindow*RemindersLineForm;Visible:=true;Enabled:=true|NAME:=TvgImage;Index:=1;Visible:=true;MAXDEPTH:=3', true, 'TimeOut:=5000;IsAddCheckInfo:=true;' + addParams
          );
        'ОКНО СООБЩЕНИЯ ЛЮБОГО ЗНАЧКА':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TWarningBaloonForm;Visible:=true;MAXDEPTH:=4|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true;MAXDEPTH:=2', true, 'IsAddCheckInfo:=true;' + addParams
          );
        'ОКНО СООБЩЕНИЯ ЗНАЧКА ИНФОРМАЦИОННЫЙ БАНК УСТАРЕЛ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TWarningBaloonForm;HelpKeyword:=OldBaseWarning;MAXDEPTH:=4|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true;MAXDEPTH:=2', true, 'IsAddCheckInfo:=true;' + addParams
          );
        'ОКНО СООБЩЕНИЯ ЗНАЧКА ОТВЕТ НА КОНСУЛЬТАЦИИ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TWarningBaloonForm;HelpKeyword:=remUnreadConsultations;MAXDEPTH:=4|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true;MAXDEPTH:=2', true, 'IsAddCheckInfo:=true;' + addParams
          );
        'ОКНО СООБЩЕНИЯ ЗНАЧКА ПРЕДУПРЕЖДЕНИЯ':
         Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TvtPopupFormModelPart;INDEX:=1|WNDCLASS:=TWarningBaloonForm;HelpKeyword:=WarnJuror;MAXDEPTH:=3|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true', true, 'IsAddCheckInfo:=true;' + addParams
          );        
        'ОКНО СООБЩЕНИЯ ЗНАЧКА ДОКУМЕНТЫ НА КОНТРОЛЕ ИЗМЕНИЛИСЬ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TWarningBaloonForm;HelpKeyword:=ControlledChangingWarning;MAXDEPTH:=4|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true;MAXDEPTH:=2', true, 'IsAddCheckInfo:=true;' + addParams
          );
        'ОКНО СООБЩЕНИЯ ЗНАЧКА ДОКУМЕНТ НА КОНТРОЛЕ ИЗМЕНИЛСЯ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TWarningBaloonForm;HelpKeyword:=WarnOnControl;MAXDEPTH:=4|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true;MAXDEPTH:=2', true, 'IsAddCheckInfo:=true;' + addParams
          );
        'ОКНО СООБЩЕНИЯ ЗНАЧКА МАШИНА ВРЕМЕНИ ВКЛЮЧЕНА':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TWarningBaloonForm;HelpKeyword:=WarnTimeMachineOn;MAXDEPTH:=4|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true;MAXDEPTH:=2', true, 'IsAddCheckInfo:=true;' + addParams
          );
        'ОКНО СООБЩЕНИЯ ЗНАЧКА ЮРИДИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TTranslation_WarningBaloonForm;HelpKeyword:=WarnJuror;MAXDEPTH:=4|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true;MAXDEPTH:=2', true, 'IsAddCheckInfo:=true;' + addParams
          );          
        'ОКНО СООБЩЕНИЯ ЗНАЧКА ПРЕДУПРЕЖДЕНИЕ ДЛЯ ДЕЙСТВУЮЩЕЙ РЕДАКЦИИ':
          Result := FindWindowByPath(
            GetF1ShellProcess,
            'WNDCLASS:=TWarningBaloonForm;HelpKeyword:=WarnIsAbolished;MAXDEPTH:=4|WNDCLASS:=TnscEditor;Enabled:=true;Visible:=true;MAXDEPTH:=2', true, 'IsAddCheckInfo:=true;' + addParams
          );
      else
        Raise('Параметр не распознан!');   
      end;
      
      if NOT dontCache then
        Result := Cache_Put(parent, cacheKey, Result );
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Объекты предварительной печати
  DESC:
  RESULT:
  REMARK: 
}
function GetFromPreview(
  whatToGet : String;
  const addParams : String = '';
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromPreview';
  var
    cacheKey : OleVariant;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    if (parent = nil) then parent := GetMainWindow(addParams);
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ТУЛБАР "ПРЕДВАРИТЕЛЬНЫЙ ПРОСМОТР ПЕЧАТИ"' :
          Result := FindWindowByPath(
            GetFromMainWindow('ROOT OBJECT', addParams, parent),
            'NAME:=tbefPreviewFormTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
          );        
        'ПРЕВЬЮ', 'ПРЕДВАРИТЕЛЬНЫЙ ПРОСМОТР' :
          Result := FindWindowByPath(
            GetFromMainWindow('PARENT ZONE', addParams, parent),
            'NAME:=PreviewPanel;WNDCLASS:=TnscPreviewPanel;MAXDEPTH:=3'
          );          
      else
        Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
  except
    Log.Message(FUNCTION_NAME+ ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Объекты  печати
  DESC:
  RESULT:
  REMARK: 
}
function GetFromPrintDialog(
  whatToGet : String;
  const addParams : String = '';
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromPrintDialog';
  var
    cacheKey : OleVariant;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    if (parent = nil) then parent := GetFromShell('ДИАЛОГ ПЕЧАТИ');
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ТУЛБАР "ДИАЛОГ ПЕЧАТЬ"' :
          Result := FindWindowByPath(
            parent,
            'NAME:=BottomDock;WNDCLASS:=TvcmDockDef;MAXDEPTH:=3|NAME:=tben_PrintDialogBottom;WNDCLASS:=TvcmToolbar'
          );        
        'КНОПКА "ПЕЧАТЬ"':
          Result := FindWindowByPath(
            GetFromPrintDialog( 'ТУЛБАР "ДИАЛОГ ПЕЧАТЬ"', addParams, parent),
            'NAME:=bt_enResult_opOk;VCLCLASS:=TvcmToolButtonDef;CAPTION:=Печать'
          );          
      else
        Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
  except
    Log.Message(FUNCTION_NAME+ ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
}
function GetFromMainMenu(
  whatToGet : String
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromMainMenu';
  var
    cacheKey : OleVariant;
    parent : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    parent := GetFromMainWindow('ОБЛАСТЬ ОСНОВНОГО МЕНЮ');

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin    
      case whatToGet of
        // для Облегченной конфигурации
        'КНОПКА "ЗАДАТЬ ВОПРОС ЭКСПЕРТУ"' :
          Result := FindWindowByPath(parent, 'NAME:=pbExpert;VCLCLASS:=TPaintBox;MAXDEPTH:=1');
        'КНОПКА "НОВОСТИ ОНЛАЙН"' :
          Result := FindWindowByPath(parent, 'NAME:=pbOnLine;VCLCLASS:=TPaintBox;MAXDEPTH:=1');

        'СПИСОК: СПРАВКИ', 'СПИСОК: БИЗНЕС СПРАВКИ':
          Result := FindWindowByPath(parent, 'NAME:=tvReferences;WNDCLASS:=TnscTreeViewHotTruck;MAXDEPTH:=3');          
        'СПИСОК: ИЗМЕНЕНИЯ В ЗАКОНОДАТЕЛЬСТВЕ' :
          Result := FindWindowByPath(parent, 'NAME:=tvLawNews;WNDCLASS:=TnscTreeViewHotTruck;MAXDEPTH:=3');
        'СПИСОК: ПРАВОВАЯ ПОДДЕРЖКА' :
          Result := FindWindowByPath(parent, 'NAME:=tvLastOpenDocs;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=3');
        'СПИСОК: РАСШИРЕННЫЙ ПОИСК' :
          Result := FindWindowByPath(parent, 'NAME:=tvLawSupport;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=3');
        'СПИСОК: ПОСЛЕДНИЕ ОТКРЫТЫЕ ДОКУМЕНТЫ' :
          Result := FindWindowByPath(parent, 'NAME:=tvLastOpenDocs;WNDCLASS:=TnscTreeViewHotTruck;MAXDEPTH:=3');                   
        // для Стандартной(Расширенной) конфигурации
        'СПИСОК: ПРАВОВОЙ НАВИГАТОР' :
          Result := FindWindowByPath(parent, 'NAME:=tvLawNav;WNDCLASS:=TeeTreeView;MAXDEPTH:=3');         
        'СПИСОК: ПОИСК ПО РЕКВИЗИТАМ' :
          Result := FindWindowByPath(parent, 'NAME:=lrAttribute;WNDCLASS:=TnscLister;MAXDEPTH:=3');
        'СПИСОК: ПОИСК ПО СИТУАЦИИ' :
          Result := FindWindowByPath(parent, 'NAME:=lrSituation;WNDCLASS:=TnscLister;MAXDEPTH:=3');
        'СПИСОК: ПОИСК ПО ИСТОЧНИКУ ОПУБЛИКОВАНИЯ' :
          Result := FindWindowByPath(parent, 'NAME:=lrPublish;WNDCLASS:=TnscLister;MAXDEPTH:=3'); 
        'СПИСОК: ОБЗОР ИЗМЕНЕНИЙ ЗАКОНОДАТЕЛЬСТВА' :
          Result := FindWindowByPath(parent, 'NAME:=lrReview;WNDCLASS:=TnscLister;MAXDEPTH:=3');
        'СПИСОК: СПРАВОЧНАЯ ИНФОРМАЦИЯ' :
          Result := FindWindowByPath(parent, 'NAME:=tvHelpInfo;WNDCLASS:=TeeTreeView;MAXDEPTH:=3');  

        'ГРУППА: ОБЗОР ИЗМЕНЕНИЙ ЗАКОНОДАТЕЛЬСТВА' :
          Result := FindWindowByPath(parent, 'NAME:=hfReview;WNDCLASS:=TnscHideField;MAXDEPTH:=2');
                  
      else
          Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parent, cacheKey, Result );
    end;

  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
}
function GetFromMainMenu_Infarm(
  whatToGet : String
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromMainMenu_Infarm';
  var
    cacheKey : OleVariant;
    parent : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    parent := GetFromMainWindow('ОБЛАСТЬ ОСНОВНОГО МЕНЮ ИНФАРМА');

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin    
      case whatToGet of
        'СПИСОК: СПРАВОЧНИКИ И СЛОВАРИ' :
          Result := FindWindowByPath(parent, 'NAME:=hfReferencesAndDictionaries;WNDCLASS:=TnscHideField;CAPTION:=Справочники и словари;MAXDEPTH:=3|NAME:=tvReferencesAndDictionaries');               
        'СПИСОК: ОСНОВНЫЕ ВОЗМОЖНОСТИ' :
          Result := FindWindowByPath(parent, 'NAME:=hfMainFeatures;WNDCLASS:=TnscHideField;CAPTION:=Основные возможности;MAXDEPTH:=3|NAME:=tvMainFeatures');          
        
        'ОБЛАСТЬ: ПОСЛЕДНИЕ ОТКРЫТЫЕ ПРЕПАРАТЫ':
          Result := FindWindowByPath(parent, 'NAME:=hfLastOpenDocs;WNDCLASS:=TnscHideField;CAPTION:=Последние открытые препараты;MAXDEPTH:=3'); 
        'СПИСОК: ПОСЛЕДНИЕ ОТКРЫТЫЕ ПРЕПАРАТЫ' :
          Result := FindWindowByPath(GetFromMainMenu_Infarm('ОБЛАСТЬ: ПОСЛЕДНИЕ ОТКРЫТЫЕ ПРЕПАРАТЫ'), 'NAME:=tvLastOpenDocs');
        'СПИСОК: СПРАВОЧНАЯ ФАРМАВЦЕВТИЧЕСКАЯ ИНФОРМАЦИЯ' :
          Result := FindWindowByPath(parent, 'NAME:=hfReferencePharmaceuticalInformation;WNDCLASS:=TnscHideField;CAPTION:=Справочная фармацевтическая информация;MAXDEPTH:=3|NAME:=tvReferencePharmaceuticalInformation');
        'СПИСОК: НОРМАТИВНАЯ ИНФОРМАЦИЯ' :
          Result := FindWindowByPath(parent, 'NAME:=hfRegulatoryInformation;WNDCLASS:=TnscHideField;CAPTION:=Нормативная информация;MAXDEPTH:=3|NAME:=tvRegulatoryInformation');
      else
          Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parent, cacheKey, Result );
    end;

  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;
procedure SC_____BASE_SEARCH;begin;end;

{
  DESK: Возвращает объекты из формы БАЗОВОГО Поиска  
} 
function GetFromBaseSearch(
  whatToGet : String;  
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromBaseSearch';
  var
    cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);     
    if parent = nil then
      parent := GetFromMainWindow('ПАНЕЛЬ "БАЗОВЫЙ ПОИСК"');

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ПАНЕЛЬ "БАЗОВЫЙ ПОИСК"': 
          result := GetFromMainWindow('ПАНЕЛЬ "БАЗОВЫЙ ПОИСК"');
        'КОМБОБОКС "БАЗОВЫЙ ПОИСК"':
          result := FindWindowByPath(parent,
            'NAME:=ContextEdit;WNDCLASS:=TnscTreeComboWithHistoryAndOperations'
          );
        'ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ':
          Result := FindWindowByPath(parent,
            'NAME:=vgScene1;VCLCLASS:=TvgScene|NAME:=Root1;VCLCLASS:=TvgBackground|NAME:=Rectangle1;VCLCLASS:=TvgRectangle'
          );   
        'КНОПКА "НАЙТИ"':
          result := FindWindowByPath(
           GetFromBaseSearch('ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ', parent),
           'NAME:=FindBtn;VCLCLASS:=TvgPathButton' 
          );
        'КНОПКА "НАЙТИ ВВЕРХ"':
          result := FindWindowByPath(
            GetFromBaseSearch('ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ', parent),
           'NAME:=FindBackBtn;VCLCLASS:=TvgPathButton'
          );
        'КНОПКА "ЗАКРЫТЬ"':
          result := FindWindowByPath(
           GetFromBaseSearch('ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ', parent),
           'NAME:=CloseBtn;VCLCLASS:=TvgCloseButton',
           true,
           'TimeOut:=' + IntToStr(Options.Run.Timeout div 5) 
          );
        'КНОПКА "ИСТОРИЯ ПОИСКА"':
          result := FindWindowByPath(
            GetFromBaseSearch('ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ', parent),
           'NAME:=MostOuterRectangle|NAME:=DropButton;MAXDEPTH:=3'
          );
        'КНОПКА-ССЫЛКА "ЕЩЕ"':
          result := FindWindowByPath(
            GetFromBaseSearch('ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ', parent),
           'NAME:=MoreTab;VCLCLASS:=TvgComboBox;Visible:=true'
          );
        'НАДПИСЬ "КОЛИЧЕСТВО НАЙДЕННЫХ"':
          result := FindWindowByPath(
           GetFromBaseSearch('ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ', parent),
           'NAME:=FoundCountLabel;VCLCLASS:=TvgText;MAXDEPTH:=5'
          );
        'КОМБОБОКС "ОБЛАСТЬ ПОИСКА"':
          result := FindWindowByPath(
           GetFromBaseSearch('ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ', parent),
           'NAME:=MostOuterRectangle;VCLCLASS:=TvgRectangle|NAME:=AreaCombo;VCLCLASS:=TvgComboBox;IsAddCheckInfo:=true'
          );
        'ЭЛЕМЕНТ КОМБОБОКСА ОБЛАСТЬ ПОИСКА "ВЕЗДЕ"':
          result := FindWindowByPath(
            GetFromBaseSearch('КОМБОБОКС "ОБЛАСТЬ ПОИСКА"', parent),
            'VCLCLASS:=TvgScrollContent;MAXDEPTH:=3|VCLCLASS:=TvgText;Text:=Везде;MAXDEPTH:=3|VCLCLASS:=TvgListBoxItem;MAXDEPTH:=-2;IsAddCheckInfo:=true'
          );
        'ЭЛЕМЕНТ КОМБОБОКСА ОБЛАСТЬ ПОИСКА "В ДОКУМЕНТЕ"':
          result := FindWindowByPath(
            GetFromBaseSearch('КОМБОБОКС "ОБЛАСТЬ ПОИСКА"', parent),
            'VCLCLASS:=TvgScrollContent;MAXDEPTH:=3|VCLCLASS:=TvgText;Text:=В документе;MAXDEPTH:=3|VCLCLASS:=TvgListBoxItem;MAXDEPTH:=-2;IsAddCheckInfo:=true'
          );    
        'ЭЛЕМЕНТ КОМБОБОКСА ОБЛАСТЬ ПОИСКА "СПИСОК: В ДОКУМЕНТАХ"':
          result := FindWindowByPath(
            GetFromBaseSearch('КОМБОБОКС "ОБЛАСТЬ ПОИСКА"', parent),
            'VCLCLASS:=TvgScrollContent;MAXDEPTH:=3|VCLCLASS:=TvgText;Text:=Список*в*документах;MAXDEPTH:=3|VCLCLASS:=TvgListBoxItem;MAXDEPTH:=-2;IsAddCheckInfo:=true'
          );    
        'ЭЛЕМЕНТ КОМБОБОКСА ОБЛАСТЬ ПОИСКА "СПИСОК: В НАЗВАНИЯХ"':
          result := FindWindowByPath(
            GetFromBaseSearch('КОМБОБОКС "ОБЛАСТЬ ПОИСКА"', parent),
            'VCLCLASS:=TvgScrollContent;MAXDEPTH:=3|VCLCLASS:=TvgText;Text:=Список*в*названиях;MAXDEPTH:=3|VCLCLASS:=TvgListBoxItem;MAXDEPTH:=-2;IsAddCheckInfo:=true'
          );
        'ССЫЛКА "ПРИМЕР"':
          result := FindWindowByPath( 
           GetFromBaseSearch('ОБЛАСТЬ ОБЪЕКТОВ ФОРМЫ', parent),
           'NAME:=QueryExampleLabel;VCLCLASS:=TvgText;MAXDEPTH:=5'
          );     
        'ПОДСКАЗКА':
          result := FindWindowByPath( 
            GetFromMainWindow('PARENT ZONE'),
            'NAME:=CardTextLabel;WNDCLASS:=TnscSimpleEditor;MAXDEPTH:=5'
          );
        'ИСТОРИЯ ЗАПРОСОВ БАЗОВОГО ПОИСКА' :
            Result := FindWindowByPath(
              GetFromMainWindow('PARENT ZONE'),
              'WNDCLASS:=Ten_BaseSearchCard;MAXDEPTH:=3|NAME:=lrBaseSearch;WNDCLASS:=TnscLister;MAXDEPTH:=3'
            );   
      else
        Raise('Параметр "' + whatToGet+ '" не распознан');     
      end;
      Result := Cache_Put(parent, cacheKey, Result );
    end;
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);        
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  DESK: Возвращает объекты из Панели Задак
}
function GetFromTasksPanel(
  whatToGet: string;
  parent : OleVariant = nil
): OleVariant;
const
    FUNCTION_NAME = 'GetFromTasksPanel';
var
  cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet); 
    if parent = nil then parent := GetFromNavigator('ВКЛАДКА НАВИГАТОРА "ПАНЕЛЬ ЗАДАЧ"');
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of            
        //основные параметры
        'ДЕРЕВО "ДОКУМЕНТ"':
          result := FindWindowByPath( 
            parent,
            'WNDCLASS:=TnscTasksPanelHideField;CAPTION:=Документ|WNDCLASS:=TnscTasksPanelTreeView'
          );
        'ДЕРЕВО "ПУТЕВОДИТЕЛЬ"':
          result := FindWindowByPath( 
            parent,
            'WNDCLASS:=TnscTasksPanelHideField;CAPTION:=Путеводитель|WNDCLASS:=TnscTasksPanelTreeView'
          ); 
        'ДЕРЕВО "ЗАПРОС"':
          result := FindWindowByPath( 
            parent,
            'WNDCLASS:=TnscTasksPanelHideField;CAPTION:=Запрос|WNDCLASS:=TnscTasksPanelTreeView'
          ); 
              
      else
        Raise('Параметр "' + whatToGet+ '" не распознан');     
      end;
      Result := Cache_Put(parent, cacheKey, Result );
    end;
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);        
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;


procedure SC_____CONTEXT_FILTER;begin;end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
}
function GetFromContextFilterForm(
  whatToGet : String;
  parent : OleVariant
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromContextFilterForm';
  var
    cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    if not IsExists(parent) then 
      Raise('Не найдена существующая Форма контекстного фильтра!');

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin 
      case whatToGet of
        'КОМБОБОКС "КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=TnscComboBoxWithFilter');
        'КНОПКА "ВКЛЮЧИТЬ КОНТЕКСТНЫЙ ФИЛЬТР"' :
          Result := FindWindowByPath(parent, 'NAME:=ContextFilterButton');
      else
        Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);        
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;


procedure SC_____SHELL_WINDOW;begin;end;

{
  TYPE: Объекты оболочки/Объекты процесса
  DESC:
  RESULT:
  REMARK: Всякие отдельные объекты, типа диалога сохранения
}
function GetFromShell(
  whatToGet : String;
  timeOut : integer =-1;
  const addParams : String = ''
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromShell';
  var 
    paramList, parent, cacheKey : OleVariant;
    isThrowException : boolean;
    strTimeOut : String;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    
    paramList := ParseParamString(addParams);
    if timeOut = -1 then 
      timeOut := StrToInt( GetParam(paramList, 'TIMEOUT', '-1' ) );
    isThrowException := BuiltIn.VarToBool( GetParam(paramList, 'IsThrowException', 'true' ) );

    parent := GetF1ShellProcess(timeOut, 2, isThrowException);
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result) then
    begin 
      case whatToGet of
        'КНОПКА "ОК" ФОРМЫ СООБЩЕНИЯ' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=TMessageForm|WNDCLASS:=TvgScene|VCLCLASS:=TvtEffectiveDialogButton;Name:=OK;MAXDEPTH:=2', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО ХИНТА' :
          Result := FindWindowByPath(parent, 'Visible:=true;WNDCLASS:=TvtMultilineHint', true,  addParams + ';IsAddCheckInfo:=true;TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout div 15, timeOut) ) );
        'ДИАЛОГ СОХРАНЕНИЯ В ПАПКИ':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*Сохранить как*;SEARCHESCOUNT:=4', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );

        'ДИАЛОГ СОХРАНЕНИЯ ФИЛЬТРА':
          Result := FindWindowByPath(parent, 'NAME:=CreateFilterForm;WNDCLASS:=TCreateFilterForm', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'КНОПКА "ОК" ДИАЛОГА СОХРАНЕНИЯ ФИЛЬТРА' :
          Result := FindWindowByPath(parent, 'NAME:=CreateFilterForm;WNDCLASS:=TCreateFilterForm|NAME:=bt_enResult_opOkExt;MAXDEPTH:=5', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'КНОПКА "ОТМЕНА" ДИАЛОГА СОХРАНЕНИЯ ФИЛЬТРА' :
          Result := FindWindowByPath(parent, 'NAME:=CreateFilterForm;WNDCLASS:=TCreateFilterForm|NAME:=bt_enResult_opCancel;MAXDEPTH:=5', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ПОЛЕ ИМЕНИ ДИАЛОГА СОХРАНЕНИЯ ФИЛЬТРА' :
          Result := FindWindowByPath(parent, 'NAME:=CreateFilterForm;WNDCLASS:=TCreateFilterForm|NAME:=FilterName;WNDCLASS:=TnscEdit', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );

        'ДИАЛОГ УСТАНОВКИ ЗАКЛАДКИ':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*Сохранить как*;SEARCHESCOUNT:=4', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ДИАЛОГ УСТАНОВКИ ГИПЕРССЫЛКИ':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*Установить ссылку*;SEARCHESCOUNT:=4', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );  
        'ДИАЛОГ ИЗМЕНЕНИЯ ГИПЕРССЫЛКИ':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*Изменить ссылку*;SEARCHESCOUNT:=4', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );    
        'ДИАЛОГ ОТКРЫТИЯ ИЗ ПАПОК':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*;SEARCHESCOUNT:=2', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );  
        'ДИАЛОГ "ДОПОЛНИТЬ СПИСОК"':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*Дополнить список*;SEARCHESCOUNT:=2', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );  
        'ДИАЛОГ ПОСТАНОВКИ НА КОНТРОЛЬ':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*Поставить на контроль*;SEARCHESCOUNT:=2', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ДИАЛОГ "ВЫЧЕСТЬ СПИСОК"':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*Вычесть список*;SEARCHESCOUNT:=2', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );  
        'ДИАЛОГ "ПЕРЕСЕЧЬ СО СПИСКОМ"':
          Result := FindWindowByPath(parent, 'NAME:=cfFolders;WNDCLASS:=TcfFolders;CAPTION:=*Мои документы*Пересечь со списком*;SEARCHESCOUNT:=2', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'О ПРОГРАММЕ' :
          Result := FindWindowByPath(parent, 'NAME:=efAbout;WNDCLASS:=TefAbout', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ФОРМА ЛОГИНА' :
          Result := FindWindowByPath(parent, 'NAME:=' + LOGINFORM_NAME + ';SEARCHESCOUNT:=5', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout * 3, timeOut) ) );  
        'ВЫБОР ЗНАЧЕНИЙ РЕКВИЗИТА' :
          Result := FindWindowByPath(parent, 'NAME:=cfAttributeSelect;WNDCLASS:=TcfAttributeSelect', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'СОХРАНЕНИЕ ФИЛЬТРА' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=TcfSaveLoad;CAPTION:=Фильтр', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'НАСТРОЙКИ':
          Result := FindWindowByPath(parent, 'NAME:=cf_Settings;WNDCLASS:=Tcf_Settings', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'НАСТРОЙКИ СТРАНИЦЫ' :  
          Result := FindWindowByPath(parent, 'NAME:=en_PageSetup;WNDCLASS:=Ten_PageSetup', true, 'TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'РЕДАКТОР СТИЛЕЙ' :
          Result := FindWindowByPath(parent, 'NAME:=StyleEditorContainerForm;WNDCLASS:=TStyleEditorContainerForm', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'НАСТРОЙКА ПАНЕЛЕЙ ИНСТРУМЕНТОВ' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=TCustomizeToolsForm', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'НАСТРОЙКА ДОСТУПНЫХ ОПЕРАЦИЙ' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=TCustomizeTasksPanelForm', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );  
        'ДИАЛОГ ПЕЧАТИ' :
          Result := FindWindowByPath(parent, 'NAME:=en_PrintDialog;WNDCLASS:=Ten_PrintDialog', true, 'TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО ПРОГРЕСС ИНДИКАТОРА ПОИСКА' :
          Result := FindWindowByPath(parent, 'NAME:=efProgressIndicator;WNDCLASS:=TefProgressIndicator', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'КНОПКА "ОТМЕНА" ОКНА ПРОГРЕССА ИНДИКАТОРА ПОИСКА' :
          Result := FindWindowByPath(parent, 'NAME:=efProgressIndicator;WNDCLASS:=TefProgressIndicator|VCLCLASS:=TvgScene|NAME:=CancelButton;VCLCLASS:=TvtVGButton;MAXDEPTH:=2', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО АНАЛИЗ СПИСКА' :
          Result := FindWindowByPath(parent, 'NAME:=ListAnalizerForm|NAME:=ListTree;MAXDEPTH:=2', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'КНОПКА "ПОСТРОИТЬ" ОКНА АНАЛИЗА СПИСКА' :
          Result := FindWindowByPath(parent, 'NAME:=ListAnalizerForm|NAME:=bt_enResult_opOk;MAXDEPTH:=5', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'КНОПКА "ОТМЕНА" ОКНА АНАЛИЗА СПИСКА' :
          Result := FindWindowByPath(parent, 'NAME:=ListAnalizerForm|NAME:=bt_enResult_opCancel;MAXDEPTH:=5', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО ПРОЦЕССА СРАВНЕНИЯ' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=l3AsincMessageWindow', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО СПИСКА ПОЛЬЗОВАТЕЛЕЙ' :
          Result := FindWindowByPath(parent, 'NAME:=en_UsersDefineAccess;WNDCLASS:=Ten_UsersDefineAccess', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО "ИНФОРМАЦИЯ ОБ ОБНОВЛЕНИИ"' :
          Result := FindWindowByPath(parent, 'CAPTION:=Информация об обновлении;WNDCLASS:=TLongProcessForm', isThrowException, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ФОРМА ВВОДА ДАТЫ В КЗ ППР' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=Ten_DefineSearchDate', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );   
        'ФОРМА МАШИНЫ ВРЕМЕНИ' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=Ten_TurnO*TimeMachine', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );   
        'ФОРМА ОЦЕНКИ ОТВЕТА' :
          Result := FindWindowByPath(parent, 'NAME:=en_ConsultationMark;WNDCLASS:=Ten_ConsultationMark', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ДИАЛОГ "SAVE AS"':
          Result := FindWindowByPath(parent, 'WNDCAPTION:=Sav*;ENABLED:=true;INDEX:=1;WNDCLASS:=#32770|WNDCLASS:=Static;INDEX:=4;|WNDCLASS:=#32770;ENABLED:=true;INDEX:=1;MAXDEPTH:=-1;IsAddCheckInfo:=true', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ДИАЛОГ "СОХРАНИТЬ КАК"':
          Result := FindWindowByPath(parent, 'WNDCAPTION:=Сохран*;ENABLED:=true;INDEX:=1;WNDCLASS:=#32770|WNDCLASS:=Static;INDEX:=4;|WNDCLASS:=#32770;ENABLED:=true;INDEX:=1;MAXDEPTH:=-1;IsAddCheckInfo:=true', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ВЫПАДАЮЩИЙ СПИСОК КОМБОБОКСА БП':
          Result := FindWindowByPath(parent, 'WNDCLASS:=TnscSubTree;INDEX:=1;Visible:=true', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ВЫПАДАЮЩИЙ СПИСОК КОМБОБОКСА КНОПКИ-ССЫЛКИ ЕЩЕ':
          Result := FindWindowByPath(parent, 'WNDCLASS:=TvgPopupForm|WNDCLASS:=TvgScene;Visible:=true', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ВЫПАДАЮЩИЙ СПИСОК КОМБОБОКСА КЗ ППР':
          Result := FindWindowByPath(parent, 'WNDCLASS:=TevDropTree;INDEX:=1', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ВЫПАДАЮЩИЙ СПИСОК КОМБОБОКСА НА ВКЛАДКЕ ССЫЛКИ НА ДОКУМЕНТ':
          Result := FindWindowByPath(parent, 'WNDCLASS:=TSubTree;INDEX:=1', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ВЫПАДАЮЩИЙ СПИСОК КОМБОБОКСА НА ВКЛАДКЕ ССЫЛКИ ИЗ ДОКУМЕНТА':
          Result := FindWindowByPath(parent, 'WNDCLASS:=TSubTree;INDEX:=1', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО КАЛЕНДАРЯ':
          Result := FindWindowByPath(parent, 'WNDCLASS:=TevDropCalendar', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );  
        'ОКНО ХЕЛПА':
          Result := FindWindowByPath(parent, 'WNDCLASS:=HH Parent', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ДИАЛОГ ЭКСПОРТА ИЗ ПАПКИ':
          Result := FindWindowByPath(parent, 'WNDCLASS:=#32770;WNDCAPTION:=*Экспорт информации из папки*;SEARCHESCOUNT:=4', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ДИАЛОГ ИМПОРТА В ПАПКУ':
          Result := FindWindowByPath(parent, 'WNDCLASS:=#32770;WNDCAPTION:=*Импорт информации в папку*;SEARCHESCOUNT:=4', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );  
        'ДИАЛОГ ПЕЧАТИ':
          Result := FindWindowByPath(parent, 'WNDCLASS:=Ten_PrintDialog;WNDCAPTION:=*Печать*;SEARCHESCOUNT:=4', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО ОШИБКИ IE':
          Result := FindWindowByPath(parent, 'WNDCLASS:=I*;WNDCAPTION:=Internet Explorer Script Error;SEARCHESCOUNT:=3', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО SECURITY ALERT':
          Result := FindWindowByPath(parent, 'WNDCLASS:=#32770;WNDCAPTION:=*Security Alert*;SEARCHESCOUNT:=3', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ОКНО АВТОРИЗАЦИИ ПРОКСИ':
          Result := FindWindowByPath(parent, 'WNDCLASS:=#32770;WNDCAPTION:=*proxy.garant.ru*;SEARCHESCOUNT:=3', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ФОРМА ОКНА СПРАВКИ' :
          Result := FindWindowByPath(parent, 'WNDCLASS:=HH Parent;WNDCAPTION:=ГАРАНТ*Руководство пользователя', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
        'ФОРМА ОКНА СПРАВКИ, СОДЕРЖАНИЕ' :
          Result := FindWindowByPath(GetFromShell('ФОРМА ОКНА СПРАВКИ'), 'WNDCLASS:=SysTreeView32;MAXDEPTH:=3', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
      else
        Raise('Параметр не распознан!');   
      end;
    
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if IsExists(Result) AND (NOT Result.Visible) then
    begin
      Log.Warning(FUNCTION_NAME + ': Объект существует, но НЕ виден! Возвращаем несуществующий объект.',
                 'whatToGet: "' + whatToGet + '".' + EndOfLine +
                 'FullName: "' + Result.FullName + '"',
                 pmNormal, GetLogAttr('YELLOW'));
      Result := NonExObj;
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Объекты процесса
  DESC:
  RESULT:
  REMARK: Объекты стандартного Windows-диалога "Сохранить как"
}
function GetFromStdSaveDialog(
  whatToGet : String;
  timeOut : integer =-1;
  const addParams : String = ''
) : OleVariant;
  var 
    paramList, parent : OleVariant;
    strTimeOut : String;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    paramList := ParseParamString(addParams);
    if timeOut = -1 then 
      timeOut := StrToInt( GetParam(paramList, 'TIMEOUT', '-1' ) );

    parent := GetF1ShellProcess(timeOut);

    case whatToGet of
      'КОМБОБОКС "ИМЯ ФАЙЛА"':
        Result := FindWindowByPath(GetFromShell('ДИАЛОГ "СОХРАНИТЬ КАК"'),
                   'INDEX:=1;WNDCLASS:=ComboBoxEx32|INDEX:=1;WNDCLASS:=ComboBox', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
      'КОМБОБОКС "ТИП ФАЙЛА"':
        Result := FindWindowByPath(GetFromShell('ДИАЛОГ "СОХРАНИТЬ КАК"'),
                   'INDEX:=2;WNDCLASS:=ComboBox', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
      'ЧЕКБОКС "ТОЛЬКО ВЫДЕЛЕННЫЙ ФРАГМЕНТ"':
        Result := FindWindowByPath(GetFromShell('ДИАЛОГ "СОХРАНИТЬ КАК"'),
                   'WNDCAPTION:=Только выделенный фрагмент;WNDCLASS:=TCheckBox', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
      'КНОПКА "ОТМЕНА"':
        Result := FindWindowByPath(GetFromShell('ДИАЛОГ "СОХРАНИТЬ КАК"'),
                   'INDEX:=3;WNDCLASS:=Button', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );                   
      'КНОПКА "СОХРАНИТЬ"':
        Result := FindWindowByPath(GetFromShell('ДИАЛОГ "СОХРАНИТЬ КАК"'),
                   'INDEX:=2;WNDCLASS:=Button', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
      'ПОДТВЕРЖДЕНИЕ "СОХРАНИТЬ КАК"':
        if not IsExists(FindWindowByPath(parent, 'WNDCAPTION:=Сохранить как...;ENABLED:=true;INDEX:=1;WNDCLASS:=#32770|WNDCLASS:=Static;INDEX:=4;|WNDCLASS:=#32770;ENABLED:=true;INDEX:=1;MAXDEPTH:=-1;IsAddCheckInfo:=true', false, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) ) ) then
          Result := FindWindowByPath(parent, 'ENABLED:=true;INDEX:=1;WNDCLASS:=#32770', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) )
        else
          Result := NonExObj;
      'КНОПКА ПОДТВЕРЖДЕНИЕ "ДА"':
        Result := FindWindowByPath(GetFromStdSaveDialog('ПОДТВЕРЖДЕНИЕ "СОХРАНИТЬ КАК"'),
                   'INDEX:=1;WNDCLASS:=Button;MAXDEPTH:=3', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );                   
      'КНОПКА ПОДТВЕРЖДЕНИЕ "НЕТ"':
        Result := FindWindowByPath(GetFromStdSaveDialog('ПОДТВЕРЖДЕНИЕ "СОХРАНИТЬ КАК"'),
                   'INDEX:=2;WNDCLASS:=Button;MAXDEPTH:=3', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
      'КНОПКА НА ТУЛБАРЕ "СОЗДАТЬ НОВУЮ ПАПКУ"':
        Result := FindWindowByPath(GetFromShell('ДИАЛОГ "СОХРАНИТЬ КАК"'),
                   'INDEX:=1;WNDCLASS:=ToolbarWindow32', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
      'КНОПКА НА ТУЛБАРЕ "СОЗДАТЬ НОВУЮ ПАПКУ"':
        Result := FindWindowByPath(GetFromShell('ДИАЛОГ "СОХРАНИТЬ КАК"'),
                   'INDEX:=1;WNDCLASS:=ToolbarWindow32', true, addParams + ';TIMEOUT:=' + IntToStr( Choose(timeOut=-1, Options.Run.Timeout, timeOut) ) );
    else
      Raise('Параметр не распознан!');   
    end;
    
    if IsExists(Result) AND (NOT Result.Visible) then
    begin
      Log.Warning('GetFromStdSaveDialog' + ': Объект существует, но НЕ виден! Возвращаем несуществующий объект.',
                 'whatToGet: "' + whatToGet + '".' + EndOfLine +
                 'FullName: "' + Result.FullName + '"',
                 pmNormal, GetLogAttr('YELLOW'));
      Result := NonExObj;
    end;
  except
    Log.Message('GetFromStdSaveDialog: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____FILTER_DIALOG;begin;end;


function GetFromFilterList(
  whatToGet : String;
  parent : OleVariant;
  const addParams : String = ''
) : OleVariant;
begin
  try
    if not IsExists(parent) then
      Raise('Окно-родитель не найдено!');

    if parent.Name <> 'enFilters' then
      parent := GetParentObject(parent);

    whatToGet := AnsiUpperCase(whatToGet);

    case whatToGet of
      'ТУЛБАР "ФИЛЬТРЫ (ВКЛАДКА)"':
      Result := FindWindowByPath(parent, 'NAME:=tbenFiltersTop;WNDCLASS:=TvcmToolbar', true, addParams);
      'СПИСОК ФИЛЬТРОВ':
      Result := FindWindowByPath(parent, 'NAME:=FiltersList;WNDCLASS:=TnscTreeViewWithAdapterDragDrop', true, addParams);
      else
        Raise('Параметр не распознан!');
    end;

  except
    Log.Message('GetFromFilterList: ' + ExceptionMessage, '"' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;


{
  TYPE: Объекты оболочки/Объекты процесса
  DESC:
  RESULT:
  REMARK: 
}
function GetFromFilterDialog(
  whatToGet : String;
  const addParams : String = ''
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromFilterDialog';
  var 
    parent, cacheKey : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    parent := GetFromShell('СОХРАНЕНИЕ ФИЛЬТРА');

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin 
      case whatToGet of
        'ЗАГОЛОВОК КЗ' :
          Result := FindWindowByPath(parent, 'NAME:=lbHeader;VCLCLASS:=TvtLabel;Caption:=Фильтр', true, addParams);
        'КАРТОЧКА ЗАПРОСА' :
          Result := FindWindowByPath(parent, 'NAME:=Editor;WNDCLASS:=TevQueryCardEditor;MAXDEPTH:=3', true, addParams);
        'НИЖНИЙ ТУЛБАР' :
          Result := FindWindowByPath(parent, 'NAME:=tbcfSaveLoadBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4', true, addParams);
      else
        Raise('Параметр не распознан!');   
      end;
       
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if IsExists(Result) AND (NOT Result.Visible) then 
    begin
      Log.Warning('GetFromFilterDialog: ' + ': Объект существует, но НЕ виден! Возвращаем несуществующий объект.',
                 'whatToGet: "' + whatToGet + '".' + EndOfLine +
                 'FullName: "' + Result.FullName + '"',
                 pmNormal, GetLogAttr('YELLOW'));
      Result := NonExObj;
    end;
  except
    Log.Message('GetFromFilterDialog: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____SETTINGS;begin;end;

{
  TYPE: Настройки
  DESC:
  RESULT:
  REMARK: 
}
function GetFromSettings(
  whatToGet : String;
  const addParams : String = ''
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromSettings';
  var 
    cacheKey, parent : OleVariant;
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    parent := GetFromShell('НАСТРОЙКИ', -1, addParams);

    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin 
      case whatToGet of
        'СПИСОК НАСТРОЕК' :    
          //Result := FindWindowByPath(parent, 'NAME:=TreeFrame;WNDCLASS:=TTreeFrame|WNDCLASS:=TTreeView;MAXDEPTH:=3', true, addParams);
          Result := FindWindowByPath(parent, 'NAME:=TreeFrame;WNDCLASS:=TTreeFrame|WNDCLASS:=TvtCustomOutliner;MAXDEPTH:=2', true, addParams);
        'НИЖНИЙ ТУЛБАР' :
          Result := FindWindowByPath(
                      parent,
                    //  'WNDCLASS:=TvcmDockPanel;INDEX:=3|NAME:=tbcf_SettingsBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4',//По умолчаню считаем INDEX=3, так как всегда тулбар прилеплен снизу
                      'NAME:=tbcf_SettingsBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4',
                      true,
                      addParams
                    ); 
        'ФОРМА "НАСТРОЙКИ"':
          Result := parent;
      else
        Raise('Параметр не распознан!');   
      end; 
      
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);
    
    if IsExists(Result) AND (NOT Result.Visible) then 
    begin
      Log.Warning('GetFromSettings' + ': Объект существует, но НЕ виден! Возвращаем несуществующий объект.',
                 'whatToGet: "' + whatToGet + '".' + EndOfLine +
                 'FullName: "' + Result.FullName + '"',
                 pmNormal, GetLogAttr('YELLOW'));
      Result := NonExObj;
    end;
  except
    Log.Message('GetFromSettings: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Редактор стилей
  DESC:
  RESULT:
  REMARK: 
}
function GetFromStyleEditor(
  whatToGet : string;
  parent : OleVariant = nil
): OleVariant;
  const 
    FUNCTION_NAME = 'GetFromStyleEditor';
  var
    cacheKey;
begin
try
  whatToGet := AnsiUpperCase(whatToGet);  
  if parent = nil then parent := GetFromShell('РЕДАКТОР СТИЛЕЙ');

  cacheKey := FUNCTION_NAME + whatToGet;
  if NOT Cache_Check(parent, cacheKey, Result) then
  begin
    case whatToGet of
      'ОКНО "РЕДАКТОР СТИЛЕЙ"' :
        Result := parent;      
      'MAIN_ZONE' :
        Result := FindWindowByPath(
            parent,
            'NAME:=BackgroundPanel;WNDCLASS:=TvtProportionalPanel|NAME:=MainZone;WNDCLASS:=TvtPanel'
          );        
      'STYLE_EDITOR_FONT_FORM' :
        Result := FindWindowByPath(
            GetFromStyleEditor('MAIN_ZONE'),
            'NAME:=ParentZone;WNDCLASS:=TvtSizeablePanel|NAME:=StyleEditorFontForm;WNDCLASS:=TStyleEditorFontForm'
          );
      'ДЕРЕВО СТИЛЕЙ' :
        Result := FindWindowByPath(
            parent,
            'NAME:=BackgroundPanel;WNDCLASS:=TvtProportionalPanel|NAME:=NavigatorZone;WNDCLASS:=TvtSizeablePanel|NAME:=StyleTreeView;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=2'
          );
      'ТЕКСТОВОЕ ОКНО' :
        Result := FindWindowByPath(
            GetFromStyleEditor('MAIN_ZONE'),
            'WNDCLASS:=TvtPanel|NAME:=ChildZone;WNDCLASS:=TvtPanel|NAME:=StyleEditorExampleForm;WNDCLASS:=TStyleEditorExampleForm|NAME:=EditorPanel;WNDCLASS:=TvtPanel|NAME:=Editor;WNDCLASS:=TeeEditorWithoutOperations'
          );  
      'ФОРМА "ПАРАМЕТРЫ ШРИФТА"' :
        Result := FindWindowByPath(
             GetFromStyleEditor('STYLE_EDITOR_FONT_FORM'),
            'NAME:=FontScrollBox;WNDCLASS:=TScrollBox'
          );    
      'НИЖНИЙ ТУЛБАР' :
        Result := FindWindowByPath(
            parent,
            'NAME:=BottomDock;WNDCLASS:=TvcmDockDef;MAXDEPTH:=3|NAME:=tbStyleEditorContainerFormBottom;WNDCLASS:=TvcmToolbar'
          );
      'ЛЭЙБЛ "НАЗВАНИЕ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('STYLE_EDITOR_FONT_FORM'),
            'NAME:=FontNameLabel;VCLCLASS:=TvtLabel'
          );            
      'КОМБОБОКС "НАЗВАНИЕ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontNameComboBox;WNDCLASS:=TvtComboBoxQS'
          );
      'КНОПКА ТИПА НАСЛЕДОВАНИЯ "НАЗВАНИЕ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontNameInheritanceButton;WNDCLASS:=TElPopupButton'
          );
      'ЛЭЙБЛ "ЦВЕТ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('STYLE_EDITOR_FONT_FORM'),
            'NAME:=FontForeColorLabel;VCLCLASS:=TvtLabel'
          );    
      'КОМБОБОКС "ЦВЕТ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontForeColorBox;WNDCLASS:=TvtColorBox'
          );
      'КНОПКА ТИПА НАСЛЕДОВАНИЯ "ЦВЕТ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontForeColorInheritanceButton;WNDCLASS:=TElPopupButton'
          );
      'ЛЭЙБЛ "ФОН"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('STYLE_EDITOR_FONT_FORM'),
            'NAME:=FontBackColorLabel;VCLCLASS:=TvtLabel'
          );            
      'КОМБОБОКС "ФОН"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontBackColorBox;WNDCLASS:=TvtColorBox'
          );
      'КНОПКА ТИПА НАСЛЕДОВАНИЯ "ФОН"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontBackColorInheritanceButton;WNDCLASS:=TElPopupButton'
          );    
      'КОМБОБОКС "РАЗМЕР"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontSizeComboBox;WNDCLASS:=TvtComboBoxQS'
          );
      'КНОПКА ТИПА НАСЛЕДОВАНИЯ "РАЗМЕР"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontSizeInheritanceButton;WNDCLASS:=TElPopupButton'
          );
      'ЧЕКБОКС "ЖИРНЫЙ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontBoldCheckBox;WNDCLASS:=TvtCheckBox'
          );
      'КНОПКА ТИПА НАСЛЕДОВАНИЯ "ЖИРНЫЙ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontBoldInheritanceButton;WNDCLASS:=TElPopupButton'
          );    
      'ЧЕКБОКС "НАКЛОННЫЙ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontItalicCheckBox;WNDCLASS:=TvtCheckBox'
          );
      'КНОПКА ТИПА НАСЛЕДОВАНИЯ "НАКЛОННЫЙ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontItalicInheritanceButton;WNDCLASS:=TElPopupButton'
          );
      'ЧЕКБОКС "ПОДЧЁРКНУТЫЙ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontUnderlineCheckBox;WNDCLASS:=TvtCheckBox'
          );
      'КНОПКА ТИПА НАСЛЕДОВАНИЯ "ПОДЧЁРКНУТЫЙ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontUnderlineInheritanceButton;WNDCLASS:=TElPopupButton'
          );    
      'ЧЕКБОКС "ПЕРЕЧЁРКНУТЫЙ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontStrikeoutCheckBox;WNDCLASS:=TvtCheckBox'
          );
      'КНОПКА ТИПА НАСЛЕДОВАНИЯ "ПЕРЕЧЁРКНУТЫЙ"' :
        Result := FindWindowByPath(
            GetFromStyleEditor('ФОРМА "ПАРАМЕТРЫ ШРИФТА"'),
            'NAME:=FontStrikeoutInheritanceButton;WNDCLASS:=TElPopupButton'
          );
      else
        Raise('whatToGet передан неправильно : ' + whatToGet);        
    end;//case
    Result := Cache_Put(parent, cacheKey, Result );
  end;
      
  if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);  
except
  Log.Message( FUNCTION_NAME + ': ' + ExceptionMessage , '' , pmNormal, GetLogAttr('EXCEPTION'));
  Result := NonExObj;
  CommonExceptionHandler; 
end;
end;
{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC: Настройки
  RESULT:
  REMARK: 
}
function GetSettingsElement(
  page : String; // название страницы с натсроками
  element : String = ''; // название элемента (контрола) настроек
  parent : OleVariant = nil; // форма страницы, на которой лежат нужнае контролы
  const addParams : String = ''
) : OleVariant;
  const
    FUNCTION_NAME = 'GetSettingsElement';
var
    parentForm : OleVariant;
begin
  try
    page := AnsiUpperCase(page);
    element := AnsiUpperCase(element);
    if (parent = nil) then
    begin
      parentForm := GetFromSettings('ФОРМА "НАСТРОЙКИ"');
      if IsExists(parentForm) then parentForm := FindWindowByPath(parentForm, 'NAME:=WorkFrame|NAME:=ComponentsPanel');
      if NOT IsExists(parentForm) then Raise('ParentForm для страницы не существует!');      
    end;  
        
    case page of
      'КОНФИГУРАЦИЯ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'WndClass:=TFrame;Index:=17;Visible:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'НАЗВАНИЕ КОНФИГУРАЦИИ [EDIT]' : Result := FindWindowByPath(parent, 'Index:=2;WndClass:=TnscComboBoxWithReadOnly');
            'ОПИСАНИЕ КОНФИГУРАЦИИ [EDIT]' : Result := FindWindowByPath(parent, 'Index:=1;WndClass:=TnscComboBoxWithReadOnly');
          else
            Raise('Неизвестное значение element');  
          end;  
        end;
      
      'НАСТРОЙКИ ИНТЕРФЕЙСА' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=UIOptions;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'ПАНЕЛЬ НАВИГАЦИИ\С ЛЕВОЙ СТОРОНЫ\ПОЛОЖЕНИЕ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Панель навигации*;MAXDEPTH:=2|WNDCLASS:=TvtGroupBox;WNDCAPTION:=*С левой стороны*|WNDCLASS:=TvtComboBoxQS');
            'ПАНЕЛЬ НАВИГАЦИИ\С ПРАВОЙ СТОРОНЫ\ПОЛОЖЕНИЕ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Панель навигации*;MAXDEPTH:=2|WNDCLASS:=TvtGroupBox;WNDCAPTION:=*С правой стороны*|WNDCLASS:=TvtComboBoxQS');  
            'ПАНЕЛЬ НАВИГАЦИИ\С ПРАВОЙ СТОРОНЫ\В РЕЖИМЕ АВТОСКРЫТИЯ СКРЫВАТЬ/ПОКАЗЫВАТЬ ПЛАВНО [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Панель навигации*;MAXDEPTH:=2|WNDCLASS:=TvtGroupBox;WNDCAPTION:=*С правой стороны*|WNDCLASS:=TvtCheckBox');
              
            'ВКЛАДКИ ОСНОВНОГО ОКНА\ОТКРЫВАТЬ ДОКУМЕНТЫ ИЗ СПИСКОВ\В ТЕКУЩЕЙ ВКЛАДКЕ [GROUPBUTTON]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*окна*;MAXDEPTH:=2|WNDCLASS:=TRadioGroup;WNDCAPTION:=*документы*списков*|WNDCLASS:=TGroupButton;WNDCAPTION:=в текущей вкладке');
            'ВКЛАДКИ ОСНОВНОГО ОКНА\ОТКРЫВАТЬ ДОКУМЕНТЫ ИЗ СПИСКОВ\В НОВОЙ ВКЛАДКЕ [GROUPBUTTON]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*окна*;MAXDEPTH:=2|WNDCLASS:=TRadioGroup;WNDCAPTION:=*документы*списков*|WNDCLASS:=TGroupButton;WNDCAPTION:=в новой вкладке');            
            'ВКЛАДКИ ОСНОВНОГО ОКНА\ОТКРЫВАТЬ ДОКУМЕНТЫ ИЗ СПИСКОВ\В НОВОМ ОКНЕ [GROUPBUTTON]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*окна*;MAXDEPTH:=2|WNDCLASS:=TRadioGroup;WNDCAPTION:=*документы*списков*|WNDCLASS:=TGroupButton;WNDCAPTION:=в новом окне');            
            'ВКЛАДКИ ОСНОВНОГО ОКНА\ОТКРЫВАТЬ ССЫЛКИ ИЗ ДОКУМЕНТОВ\В ТЕКУЩЕЙ ВКЛАДКЕ [GROUPBUTTON]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*окна*;MAXDEPTH:=2|WNDCLASS:=TRadioGroup;WNDCAPTION:=*ссылки*документов*|WNDCLASS:=TGroupButton;WNDCAPTION:=в текущей вкладке');
            'ВКЛАДКИ ОСНОВНОГО ОКНА\ОТКРЫВАТЬ ССЫЛКИ ИЗ ДОКУМЕНТОВ\В НОВОЙ ВКЛАДКЕ [GROUPBUTTON]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*окна*;MAXDEPTH:=2|WNDCLASS:=TRadioGroup;WNDCAPTION:=*ссылки*документов*|WNDCLASS:=TGroupButton;WNDCAPTION:=в новой вкладке');
            'ВКЛАДКИ ОСНОВНОГО ОКНА\ОТКРЫВАТЬ ССЫЛКИ ИЗ ДОКУМЕНТОВ\В НОВОМ ОКНЕ [GROUPBUTTON]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*окна*;MAXDEPTH:=2|WNDCLASS:=TRadioGroup;WNDCAPTION:=*ссылки*документов*|WNDCLASS:=TGroupButton;WNDCAPTION:=в новом окне');

            'КОЛИЧЕСТВО ЭЛЕМЕНТОВ В ИСТОРИИ [EDIT]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtSpinEdit;INDEX:=2;MAXDEPTH:=2');
            'КОЛИЧЕСТВО ДНЕЙ В ЖУРНАЛЕ РАБОТЫ [EDIT]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtSpinEdit;INDEX:=1;MAXDEPTH:=2');  
            'КОЛИЧЕСТВО ПОСЛЕДНИХ ОТКРЫТЫХ ДОКУМЕНТОВ [EDIT]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Основное меню*;MAXDEPTH:=2|WNDCLASS:=TvtSpinEdit;INDEX:=1');  
            'ВИД ОСНОВНОГО МЕНЮ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtComboBoxQS;INDEX:=1;MAXDEPTH:=2');
            'КНОПКА "ПАНЕЛИ ИНСТРУМЕНТОВ"' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtButton;INDEX:=1;MAXDEPTH:=2');
            'КНОПКА "РЕДАКТОР СТИЛЕЙ"' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtButton;INDEX:=2;MAXDEPTH:=2');
            'КНОПКА "НАСТРОЙКА СТРАНИЦЫ"' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtButton;INDEX:=3;MAXDEPTH:=2');
          else
            Raise('Неизвестное значение element');
          end;  
        end;
        
      'ПОВЕДЕНИЕ СИСТЕМЫ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=BehaviourSystem;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'НАЧАЛО РАБОТЫ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtComboBoxQS;INDEX:=1;MAXDEPTH:=2');
            'ВКЛАДКИ\ОСНОВНОЕ МЕНЮ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Основное меню');
            'ВКЛАДКИ\"МОИ ДОКУМЕНТЫ" [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:="Мои документы"');
            'ВКЛАДКИ\"МОИ ДОКУМЕНТЫ"\ПОКАЗЫВАТЬ [COMBOBOX]' :
              Result := FindSimilarWindow(
                FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=Вкладки;MAXDEPTH:=2'),
                ['WndClass'],
                ['TvtComboBoxQS'], 0, 2
              );
            'ВКЛАДКИ\КОНФИГУРАЦИИ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Конфигурации');
            'ВКЛАДКИ\НА КОНТРОЛЕ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=На контроле');              
            'ФИЛЬТРЫ\КАРТОЧКИ ПОИСКА [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Фильтры*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Карточки поиска');
            'ФИЛЬТРЫ\СПИСОК ДОКУМЕНТОВ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Фильтры*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Список документов');
            'ПЕЧАТЬ И ЭКСПОРТ\ИСПОЛЬЗОВАТЬ ДЛЯ ЭКСПОРТА И ПЕЧАТИ РАЗМЕР ШРИФТА ОТОБРАЖАЕМОГО НА ЭКРАНЕ [RADIOBUTTON]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Печать и экспорт*;MAXDEPTH:=2|WNDCLASS:=TvtRadioButton;WNDCAPTION:=Использовать для экспорта и печати размер шрифта, отображаемого на экране');
            'ПЕЧАТЬ И ЭКСПОРТ\ИСПОЛЬЗОВАТЬ ДЛЯ ЭКСПОРТА И ПЕЧАТИ СЛЕДУЮЩИЙ РАЗМЕР ШРИФТА [RADIOBUTTON]' :
               Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Печать и экспорт*;MAXDEPTH:=2|WNDCLASS:=TvtRadioButton;WNDCAPTION:=Использовать для экспорта и печати следующий размер шрифта');
            'ПЕЧАТЬ И ЭКСПОРТ\РАЗМЕР ШРИФТА [COMBOBOX]' :
               Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Печать и экспорт*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS');               
                            
          else
            Raise('Неизвестное значение element');
          end;  
        end;        
      'ПОИСК' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=Search;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'КАРТОЧКА ЗАПРОСА\ПОИСК ПО СИТУАЦИИ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Карточки запроса*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=1');
            'СПИСОК ПОСЛЕ БАЗОВОГО ПОИСКА [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtComboBoxQS;MAXDEPTH:=2;INDEX:=1');            
          else
            Raise('Неизвестное значение element');              
          end;  
        end;
        
      'ПОИСК\ПОДТВЕРЖДЕНИЯ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'ПОСТРОЕНИЕ СПИСКА\ПОДТВЕРЖДАТЬ ПОСТРОЕНИЕ СПИСКА [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Построение списка*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Подтверждать построение списка');
            'ПОСТРОЕНИЕ СПИСКА\ПРИ КОЛИЧЕСТВЕ ДОКУМЕНТОВ БОЛЕЕ [EDIT]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Построение списка*;MAXDEPTH:=2|WNDCLASS:=TvtSpinEdit;INDEX:=1');
            'ПОСТРОЕНИЕ АВТОРЕФЕРАТА\ПОДТВЕРЖДАТЬ ПОСТРОЕНИЕ АВТОРЕФЕРАТА [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Построение автореферата*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Подтверждать построение автореферата');
            'УДАЛЕНИЕ ФИЛЬТРА [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtCheckBox;WNDCAPTION:=Удаление фильтра;MAXDEPTH:=2');
          else
            Raise('Неизвестное значение element');              
          end;  
        end;

      'СПИСКИ ДОКУМЕНТОВ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=List;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'АВТОМАТИЧЕСКИЙ ПЕРЕХОД [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtCheckBox;WNDCAPTION:=Автоматический переход;MAXDEPTH:=2');
            'ЭКСПОРТИРОВАТЬ БЕЗ ВХОЖДЕНИЙ\ДОКУМЕНТЫ [CHECKBOX]' :
               Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Экспортировать и печатать списки без вхождений*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Документы');
            'ЭКСПОРТИРОВАТЬ БЕЗ ВХОЖДЕНИЙ\ПРЕПАРАТЫ [CHECKBOX]' :
               Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Экспортировать и печатать списки без вхождений*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Препараты');            
            'ОТКРЫВАТЬ ДОКУМЕНТЫ В НОВОМ ОКНЕ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtCheckBox;WNDCAPTION:=Открывать документы в новом окне;MAXDEPTH:=2');
            'СОРТИРОВКА ПО УМОЛЧАНИЮ\ТИП СОРТИРОВКИ [COMBOBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Сортировка по умолчанию*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=2');
            'СОРТИРОВКА ПО УМОЛЧАНИЮ\ПОРЯДОК СОРТИРОВКИ [COMBOBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Сортировка по умолчанию*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=1');
            'ЭКСПОРТИРОВАТЬ СПИСКИ ПОЛНОСТЬЮ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtCheckBox;WNDCAPTION:=Экспортировать списки полностью;MAXDEPTH:=2');
          else
            Raise('Неизвестное значение element');              
          end;  
        end;
                
      'ДОКУМЕНТ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=Document;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'ПОКАЗ ССЫЛОК НА ДОКУМЕНТ/ССЫЛОК ИЗ ДОКУМЕНТА\ПЕРВАЯ ВКЛАДКА [COMBOBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*ПОКАЗ ССЫЛОК НА ДОКУМЕНТ/ССЫЛОК ИЗ ДОКУМЕНТА*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=4');
            'ПОКАЗ ССЫЛОК НА ДОКУМЕНТ/ССЫЛОК ИЗ ДОКУМЕНТА\ПЕРВАЯ ВКЛАДКА\ТИП [COMBOBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*ПОКАЗ ССЫЛОК НА ДОКУМЕНТ/ССЫЛОК ИЗ ДОКУМЕНТА*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=3');
            'ПОКАЗ ССЫЛОК НА ДОКУМЕНТ/ССЫЛОК ИЗ ДОКУМЕНТА\ВТОРАЯ ВКЛАДКА [COMBOBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*ПОКАЗ ССЫЛОК НА ДОКУМЕНТ/ССЫЛОК ИЗ ДОКУМЕНТА*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=2');
            'ПОКАЗ ССЫЛОК НА ДОКУМЕНТ/ССЫЛОК ИЗ ДОКУМЕНТА\ВТОРАЯ ВКЛАДКА\ТИП [COMBOBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*ПОКАЗ ССЫЛОК НА ДОКУМЕНТ/ССЫЛОК ИЗ ДОКУМЕНТА*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=1');
            'ОТОБРАЖЕНИЕ В ТЕКСТЕ\КОММЕНТАРИИ ГАРАНТА [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Отображение в тексте*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Комментарии Гаранта');
            'ОТОБРАЖЕНИЕ В ТЕКСТЕ\МОИ КОММЕНТАРИИ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Отображение в тексте*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Мои комментарии');
            'ОТКРЫВАТЬ ССЫЛКИ В НОВОМ ОКНЕ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtCheckBox;WNDCAPTION:=*Открывать ссылки в новом окне*;MAXDEPTH:=2');
            'ПОКАЗЫВАТЬ ВКЛАДКУ С ТЕКСТОМ ПРЕДУПРЕЖДЕНИЙ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtCheckBox;WNDCAPTION:=*Показывать вкладку с текстом предупреждений*;MAXDEPTH:=2');
            'ПОКАЗЫВАТЬ ВКЛАДКУ С ИНФОРМАЦИЕЙ О ДОКУМЕНТЕ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtCheckBox;WNDCAPTION:=*Показывать вкладку с информацией о документе*;MAXDEPTH:=2');
            'МАСШТАБ ГРАФИЧЕСКИХ ИЗОБРАЖЕНИЙ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'INDEX:=2;WNDCLASS:=TvtComboBoxQS;MAXDEPTH:=2');
            'ВЫДЕЛЕНИЕ ТЕКСТА [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'INDEX:=1;WNDCLASS:=TvtComboBoxQS;MAXDEPTH:=2');
            'ВКЛАДКИ\РЕДАКЦИИ [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Редакции');
            'ВКЛАДКИ\СТРУКТУРА ДОКУМЕНТА [CHECKBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Вкладки*;MAXDEPTH:=2|WNDCLASS:=TvtCheckBox;WNDCAPTION:=Структура документа');
          else
            Raise('Неизвестное значение element');              
          end;  
        end;
      
      'ДОКУМЕНТ\МЕТКИ НА ПОЛЯХ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'КОММЕНТАРИИ ГАРАНТА [CHECKBOX]':
              Result := FindWindowByPath(parent, 'CAPTION:=Комментарии Гаранта;WNDCLASS:=TvtCheckBox;MAXDEPTH:=2');
            'КОММЕНТРАРИИ ПОЛЬЗОВАТЕЛЯ [CHECKBOX]':
              Result := FindWindowByPath(parent, 'CAPTION:=Комментарии пользователя;WNDCLASS:=TvtCheckBox;MAXDEPTH:=2');
          else
            Raise('Неизвестное значение element');              
          end;  
        end;

      'МОИ ДОКУМЕНТЫ\ПОДТВЕРЖДЕНИЯ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=AliasName27;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'УДАЛЕНИЕ ПУСТОЙ ПАПКИ [CHECKBOX]':
              Result := FindWindowByPath(parent, 'CAPTION:=Удаление пустой папки;WNDCLASS:=TvtCheckBox;MAXDEPTH:=2');
            'УДАЛЕНИЕ ОБЪЕКТА [CHECKBOX]':
              Result := FindWindowByPath(parent, 'CAPTION:=Удаление объекта;WNDCLASS:=TvtCheckBox;MAXDEPTH:=2');
          else
            Raise('Неизвестное значение element');              
          end;  
        end;
                    
      'ДОКУМЕНТЫ НА КОНТРОЛЕ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=DocOnControl;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'СБРОС СТАТУСА [COMBOBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtComboBoxQS;INDEX:=1;MAXDEPTH:=2');
          else
            Raise('Неизвестное значение element');              
          end;  
        end;

      'ДОКУМЕНТЫ НА КОНТРОЛЕ\ПОДТВЕРЖДЕНИЯ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=AliasName28;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'ДЕЙСТВИЕ ПРИ ВЫБОРЕ ИЗМЕНЕННОГО ДОКУМЕНТА НА КОНТРОЛЕ [COMBOBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtComboBoxQS;INDEX:=1;MAXDEPTH:=2');
          else
            Raise('Неизвестное значение element');              
          end;  
        end;
              
      'КОНТЕКСТНАЯ ФИЛЬТРАЦИЯ' :
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=ContextParamsNode;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'ПАРАМЕТРЫ ДЛЯ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=1');
            'ПОЛОЖЕНИЕ КОНТЕКСТА [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=4');
            'ПОРЯДОК СЛОВ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=3');
            'ОБЛАСТЬ ПОИСКА [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=2');
          else
            Raise('Неизвестное значение element');
          end;
        end;
      'ПРАВОВАЯ ПОДДЕРЖКА ОНЛАЙН':
        begin
          if (parent = nil) then
            parent := FindWindowByPath(parentForm, 'Name:=Consultations;WndClass:=TFrame;VisibleOnScreen:=true');
          if NOT IsExists(parent) then Raise('Страница не существует!');
          case element of
            '', 'СТРАНИЦА' : Result := parent;
            'ПОДТВЕРЖДЕНИЯ\ОТПРАВКА ЗАПРОСА ПО ЛИНИИ ПРАВОВОЙ ПОДДЕРЖКИ ОНЛАЙН [CHECKBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Подтверждения*;MAXDEPTH:=2|CAPTION:=Отправка запроса по линии Правовой поддержки онлайн;WNDCLASS:=TvtCheckBox');
            'ПОДТВЕРЖДЕНИЯ\ПОДТВЕРЖДЕНИЕ ОПЛАТЫ [CHECKBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Подтверждения*;MAXDEPTH:=2|CAPTION:=Подтверждение оплаты;WNDCLASS:=TvtCheckBox');
            'ПОДТВЕРЖДЕНИЯ\ОТКАЗ ОТ ОПЛАТЫ [CHECKBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Подтверждения*;MAXDEPTH:=2|CAPTION:=Отказ от оплаты;WNDCLASS:=TvtCheckBox');
            'ПОДТВЕРЖДЕНИЯ\ПОКАЗ ПЕРВОГО НЕПРОЧИТАННОГО ОТВЕТА ИЛИ УВЕДОМЛЕНИЯ СЛУЖБЫ ПРАВОВОЙ ПОДДЕРЖКИ ОНЛАЙН [CHECKBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Подтверждения*;MAXDEPTH:=2|CAPTION:=Показ первого непрочитанного ответа или уведомления службы Правовой поддержки онлайн;WNDCLASS:=TvtCheckBox');
            'ПОДТВЕРЖДЕНИЯ\ПОДТВЕРЖДЕНИЕ ОТПРАВКИ ЗАПРОСА НА ПРОВЕРКУ УСЛОВИЙ ПОДКЛЮЧЕНИЯ [CHECKBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Подтверждения*;MAXDEPTH:=2|CAPTION:=Подтверждение отправки запроса на проверку условий подключения;WNDCLASS:=TvtCheckBox');
            'ПОДТВЕРЖДЕНИЯ\ПОДТВЕРЖДЕНИЕ ЗАПРОСА НА ПРОВЕРКУ СТАТУСА ПОДКЛЮЧЕНИЯ [CHECKBOX]':
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Подтверждения*;MAXDEPTH:=2|CAPTION:=Подтверждение запроса на проверку статуса подключения;WNDCLASS:=TvtCheckBox');
            'ПОДТВЕРЖДЕНИЯ\ПОКАЗЫВАТЬ ДИАЛОГ ОЦЕНКИ ОТВЕТА ПРИ ВЫХОДЕ ИЗ КОНСУЛЬТАЦИИ [COMBOBOX]' :
              Result := FindWindowByPath(parent, 'WNDCLASS:=TvtGroupBox;WNDCAPTION:=*Подтверждения*;MAXDEPTH:=2|WNDCLASS:=TvtComboBoxQS;INDEX:=1');
          else
            Raise('Неизвестное значение element');
          end;
        end;  
    end;
    if IsExists(Result) AND (NOT Result.Visible) then 
    begin
      Log.Warning(FUNCTION_NAME + ': Объект существует, но НЕ виден! Возвращаем несуществующий объект.',
                 'whatToGet: "' + element + '".' + EndOfLine +
                 'FullName: "' + Result.FullName + '"',
                 pmNormal, GetLogAttr('YELLOW'));
      Result := NonExObj;
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'page: "' + VarToStr(page) + '"; ' + EndOfLine + 'element: "' + VarToStr(element) + '"; ',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____ATTRIBUTE_SELECT;begin;end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC:
  RESULT:
  REMARK: 
}
function GetFromAttributeSelect(
  whatToGet : String;
  parent : OleVariant = nil;
  const addParams : String = ''
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromAttributeSelect';
  var
    cacheKey, activeProc : OleVariant;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    if (parent = nil) then 
    begin
      activeProc := GetActiveProcess(Options.Run.Timeout div 30);
      cacheKey := FUNCTION_NAME + 'DefaultParent';
      if NOT Cache_Check(activeProc, cacheKey, parent) then
      begin
        parent := FindWindowByPath(activeProc ,'NAME:=cfAttributeSelect;WNDCLASS:=TcfAttributeSelect;VISIBLE:=true');      
        parent := Cache_Put(activeProc, cacheKey, parent );
      end;
    end;      
    
    if NOT IsExists(parent) then Raise('Родительский объект не существует!');
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin 
      case whatToGet of
      'ВЫБОР ЗНАЧЕНИЙ РЕКВИЗИТА' :
        Result := parent;
      'VALUES ZONE' :
        Result := FindWindowByPath(parent, 'NAME:=BackgroundPanel|NAME:=ValuesZone;WNDCLASS:=TvtPanel;VISIBLE:=true');
      'SELECTED ZONE' :
        Result := FindWindowByPath(parent, 'NAME:=BackgroundPanel|NAME:=SelectedZone;WNDCLASS:=TvtSizeablePanel');   
             
      'ТУЛБАР "ПОИСК: ВЫБОР РЕКВИЗИТА"' :
        Result := FindWindowByPath(parent, 'NAME:=tbefTreeAttributeSelectTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4');
      'ДЕРЕВО АТТРИБУТОВ' :
        Result := FindWindowByPath(
          GetFromAttributeSelect('VALUES ZONE', parent, addParams),
          'NAME:=AttributeTree;WNDCLASS:=TnscTreeViewHotTruck;MAXDEPTH:=4'
        );
      'ВЫБРАННЫЕ АТТРИБУТЫ' :
        Result := FindWindowByPath(
          GetFromAttributeSelect('SELECTED ZONE', parent, addParams),
          'NAME:=SelectedTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=4'
        );      
      'ТУЛБАР "ПОИСК: ВЫБРАННЫЕ ЗНАЧЕНИЯ РЕКВИЗИТА"' :
        Result := FindWindowByPath(
          GetFromAttributeSelect('SELECTED ZONE', parent, addParams),
          'NAME:=tbenSelectedAttributesTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=7'
        );
      'НИЖНИЙ ТУЛБАР' :
        Result := FindWindowByPath(parent, 'NAME:=tbcfAttributeSelectBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4');
       
      'ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"' :
        Result := FindWindowByPath(
          GetFromAttributeSelect('VALUES ZONE', parent, addParams),
          'NAME:=ContextFilter;WNDCLASS:=TnscContextFilter;MAXDEPTH:=4'
        );
      'ПОЛЕ "КОНТЕКСТНЫЙ ФИЛЬТР"' :
        Result := FindWindowByPath(
          GetFromAttributeSelect('ФОРМА "КОНТЕКСТНЫЙ ФИЛЬТР"', parent, addParams),
          'NAME:=InternalEditor;WNDCLASS:=TnscComboBoxWithFilter'
        );  
           
      else
        Raise('Параметр не распознан!');   
      end;
    
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
    
    if NOT IsExists(Result) then
      Raise(EX_CANNOT_FIND_WINDOW);    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"' + EndOfLine + 'addParams: "' + VarToStr(addParams) + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____ACCESS_DIALOG; begin end;
{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC: Объекты для формы с папками ("Мои документы", диалог сохранения)
  RESULT:
  REMARK: Объекты, единые для всех состояний оболочки (ППР, ППИО, словарь ... )
}
function GetFromUserForm(
  whatToGet : String;
  parent : OleVariant // путь к форме списка пользователей
) : OleVariant;     
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    case whatToGet of
      'ДЕРЕВО ПОЛЬЗОВАТЕЛЕЙ' :
        Result := FindWindowByPath(parent, 'NAME:=stUserRightAccess;WNDCLASS:=TvtStatesTree;MAXDEPTH:=2');
      'НИЖНИЙ ТУЛБАР' :
        Result := FindWindowByPath(parent, 'NAME:=tben_UsersDefineAccessBottom;WNDCLASS:=TvcmToolbar;MAXDEPTH:=5');
      'ВЕРХНИЙ ТУЛБАР' :
        Result := FindWindowByPath(parent, 'NAME:=tben_UsersDefineAccessTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=5');
    else
      Raise('Параметр не распознан!');   
    end;
  except
    Log.Message('GetFromUserForm: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure SC_____INFARM; begin end;
{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC: Объекты для списка Фирмы производители из Инфарма
  RESULT:
  REMARK:
}
function GetFromInfarmListFirms(
  whatToGet : String;
  const addParams : String = ''
) : OleVariant;
var
  mainWnd;
  parent;
begin
  try
    mainWnd := GetMainWindow(addParams);    
    whatToGet := AnsiUpperCase(whatToGet);
    case whatToGet of
      
      'ЗАКЛАДКИ' : // pagecontrol переключения нижних вкладок        
        Result := GetFromMainWindow('CHILD ZONE', '', mainWnd);
      'СПИСОК ФИРМ ПРОИЗВОДИТЕЛЕЙ' :
        Result := FindWindowByPath(
          GetFromMainWindow('PARENT ZONE', '', mainWnd),
          'NAME:=en_MedicFirmList;WNDCLASS:=Ten_MedicFirmList|NAME:=ListTree;WNDCLASS:=TnscTreeViewWithAdapterDragDrop;MAXDEPTH:=2'
        );        
      'ПОЛЕ КОНТЕКСТНЫЙ ФИЛЬТР' :
        Result := FindWindowByPath(
          GetFromMainWindow('PARENT ZONE', '', mainWnd),
          'NAME:=en_MedicFirmList;WNDCLASS:=Ten_MedicFirmList|NAME:=ContextFilter;WNDCLASS:=TnscContextFilter;MAXDEPTH:=2|NAME:=InternalEditor;WNDCLASS:=TnscEdit'
        );
      'ВЕРХНИЙ ТУЛБАР' :
        Result := FindWindowByPath(
          GetFromMainWindow('ROOT OBJECT', '', mainWnd), 
          'NAME:=tben_MedicFirmListTop;WNDCLASS:=TvcmToolbar;MAXDEPTH:=4'
        );
      'ОБЛАСТЬ СИНХРОННОГО ПРОСМОТРА' :
        Result := FindWindowByPath(
          GetFromMainWindow('CHILD ZONE', '', mainWnd),
          'WNDCLASS:=Ten_MedicListSynchroView;WNDCAPTION:=Описание;Visible:=true;MAXDEPTH:=2'
      );      
    else
      Raise('Параметр не распознан!');   
    end;
  except
    Log.Message('GetFromInfarmListFirms: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

procedure CW_____TOOLBAR;begin;end;

{
  TYPE: Работа с окнами
  DESC: Возвращает объект на тулбаре по его названию
  RESULT:
  REMARK: Если кнопка не найдена, то выбрасывает EX_BUTTON_NOT_FOUND.
          Комбобокс и поле рдактирования ищутся по Hint (он обычно совпадает с названием объекта в панели настроек)
}
function GetToolbarObject(
  const toolBarWindow : OleVariant; // окно тулбара
  objType : String; // тип искомого объекта: BUTTON | COMBOBOX | EDIT
  const objCaption : String; // название объекта
  const isThrowException : boolean = true // бросать ли исключение, если объект не найден (не работает сейчас)
)  : boolean;
  var
    arr, buttonWnd, obj : OleVariant;
    wndClass : String;
begin
  Result := NonExObj;
  try
    objType := AnsiUpperCase(objType);
    case objType of
      'BUTTON':
        begin
          case AnsiUpperCase( toolBarWindow.WndClass ) of
            'TTOOLBAR' : // тулбар в углу, с кнопками "открыть в новом окне...", "закрыть" и т.д.
              begin
                obj := FindWindowByPath(toolBarWindow, 'VCLClass:=TvcmDockPanelButton;Hint:=' + objCaption);
                if IsExists(obj) then Result := obj;
              end;
            'TVCMTOOLBAR': // обычныые тулбары
              begin
                obj := FindWindowByPath(toolBarWindow, 'VCLClass:=TvcmToolButtonDef;Caption:=' + objCaption);
                if IsExists(obj) then Result := obj;
              end;
          else
            Log.Warning('Неизвестный класс тулбара: ' + toolBarWindow.WndClass);
          end;    
          if (NOT IsExists(Result)) AND isThrowException then Raise(EX_BUTTON_NOT_FOUND);
        end;
      'COMBOBOX':
        try
          Result := FindWindowByPath(toolBarWindow, 'WndClass:=TvcmComboBox;Hint:=*' + objCaption);
        except
          Log.Warning('Комбобокс не найден!');
          if isThrowException then Raise(EX_COMBOBOX_NOT_FOUND);
          CommonExceptionHandler;
        end;
      'EDIT':
        try
          Result := FindWindowByPath(toolBarWindow, 'WndClass:=TvcmEdit;EmptyHint:=*' + objCaption);
        except
          Log.Warning('Поле не найдено!');
          if isThrowException then Raise(EX_EDIT_NOT_FOUND);
          CommonExceptionHandler;
        end;
      'DATEEDIT' :
        try
          Result := FindWindowByPath(toolBarWindow, 'WndClass:=TvcmDateEdit;Hint:=*');
        except
          Log.Warning('Поле календаря не найдено!');
          if isThrowException then Raise(EX_DATEEDIT_NOT_FOUND);
          CommonExceptionHandler;
        end; 
    else    
      Raise('Неизвестный параметр!');
    end;
  except
    Log.Message('GetToolbarObject: ' + ExceptionMessage, 'objType: "' + objType + '"; objCaption: "' + objCaption + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с окнами
  DESC: Возвращает кнопку на тулбаре по названию кнопки
  RESULT:
  REMARK: Если кнопка не найдена, то выбрасывает EX_BUTTON_NOT_FOUND.
          Если выброс исключений выключен, то возвращает NonExObj.
}
function GetToolbarButton(
  const toolBarWindow : OleVariant;
  const buttonCaption : String;
  const isThrowException : boolean = true
)  : boolean;
  var arr, buttonWnd : OleVariant;
begin
  try
    Result := GetToolbarObject(toolBarWindow, 'BUTTON', buttonCaption, isThrowException);
  except
    Log.Message('GetToolbarButton: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с окнами
  DESC: Кликает на кнопку на тулбаре по названию кнопки
  RESULT: True, если кнопка будет нажата, false, если она не найдена/задизейблена
          Если сказано кликать на области со стрелочкой, то возвращает объект меню, для передачи в ClickByPopupMenuItem
  REMARK: Если кнопка не найдена, то пробрасывает EX_BUTTON_NOT_FOUND.
          Если кнопка задизейблена, то выбрасывает EX_BUTTON_DISABLED.
          Если выброс исключений выключен, то возвращает false.
     
          paramString:
            ClickForPopupMenu - кликает на полосе прокрутки (false|true)
              default: false - кликаем на кнопке
            SetToState - установить кнопку в нужное состояние (pressed,нажато|released,отжато|)
              default: '' - кликаем всегда
}
function ClickToolbarButton(
  const toolBarWindow : OleVariant; // окно тулбара, детьми которого, являются кнопки
  const buttonCaption : String; // название (Caption) кнопки
  const paramString : String = '';
  const isThrowException : boolean = true // выбрасывать исключение
)  : OleVariant;
  var 
    buttonWnd, paramList, setToState : OleVariant;
    isEnabled, isClickForPopupMenu : boolean;
    oldRunTimeout : Integer;
begin
  Result := false;
  try
    // парсим параметры
    paramList := ParseParamString(paramString);
    isClickForPopupMenu := VarToBool( GetParam(paramList, 'ClickForPopupMenu', 'false') );
    setToState := AnsiUpperCase( GetParam(paramList, 'SetToState', '') );

    if NOT IsExists(toolBarWindow) then Raise('Тулбар не существует!');
    if NOT toolBarWindow.VisibleOnScreen then Raise('Тулбар не виден на экране, невозможно кликнуть по такому тулбару!');
        
    buttonWnd := GetToolbarButton(toolBarWindow, buttonCaption, isThrowException);
    if NOT IsExists(buttonWnd) then Raise(EX_BUTTON_NOT_FOUND);
    try // пытаемся получить свойство Native.Enabled , проверить его наличие IsSupported не получается
      isEnabled := buttonWnd.NativeDelphiObject.Enabled;
    except
      isEnabled := buttonWnd.Enabled; // если будет глючить, надо будет поправить на true
      CommonExceptionHandler;
    end;  
    if NOT isEnabled then
      if isThrowException then Raise(EX_BUTTON_DISABLED)
                          else Exit;
    // если тулбар узкий и кнопка не видна, то сначала кликаем на кнопке раскрытия                      
    if (buttonWnd.Top < 0) OR (buttonWnd.Left < 0) then
      toolBarWindow.VCLObject('Ttb97MoreButton').Click;                         

    // а теперь уже кликаем по кнопке
    if isClickForPopupMenu then
    begin // кликаем по полосе "прокрутки"            
      //if NOT StringCompare('*TvcmButtonPopupMenu*', buttonWnd.ChildList) then
      if NOT IsExists(buttonWnd.FindChild(['VCLClass'], ['*ButtonPopupMenu*'], 1)) then
      begin
        Log.Error('У кнопки нет всплывающего меню.');
        Raise('У кнопки нет всплывающего меню!');
      end;  
      buttonWnd.Click(buttonWnd.Width - 4, buttonWnd.Height div 2);
      Result := buttonWnd.VCLObject('TvcmButtonPopupMenu');
    end
    else // кликаем просто по кнопке
      case setToState of
        'PRESSED', 'НАЖАТО' :
          begin
            if (buttonWnd.Down = false) then buttonWnd.Click;
            Result := (buttonWnd.Down = true);
          end;
        'RELEASED', 'ОТЖАТО' :
          begin
            if (buttonWnd.Down = true) then buttonWnd.Click;
            Result := (buttonWnd.Down = false);
          end;
        '' :
          begin
            // Вероятно, при клике по кнопке которая закроет форму тесткомплит как-то хочет 
            // к ней обратится после клика, когда ее уже нет и ждет таймаут. Поэтому на время клика таймаут обнуляем.
            oldRunTimeout := Options.Run.Timeout;
            Options.Run.Timeout := 0;
            try 
              buttonWnd.Click;
            finally  
              Options.Run.Timeout := oldRunTimeout;
            end;  
            Result := true;
          end;
      else
        Raise('Параметр setToState не распознан!');
      end;
  except
    Log.Message('ClickToolbarButton: ' + ExceptionMessage, DbgVarValue(buttonCaption, 'buttonCaption') + DbgVarValue(toolBarWindow, 'toolBarWindow'),  pmNormal, GetLogAttr('EXCEPTION'));
    if isClickForPopupMenu then Result := NonExObj else Result := false;
    CommonExceptionHandler;
  end;
end;

procedure CW_____PAGECONTROL;begin;end;

{
  TYPE: Общие/Работа с вкладками
  DESC: Возвращает название активной вкладки
  RESULT:
  REMARK:
}
function GetActivePageName(
  const pageControl : OleVariant
) : String;
begin
  try
    Result := '';
    Result := pageControl.ActivePage.Caption;
  except
    Log.Message('GetActivePageName: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := '';
    CommonExceptionHandler;
  end;
end;  

{
  TYPE: Общие/Работа с вкладками
  DESC: Переключается на указанную вкладку
  RESULT: True если переключились на вкладку, иначе False.
  REMARK: Если не нашли вкладку - выбрасываем EX_CANNOT_FIND_TAB
          Если не смогли переключиться, то EX_CANNOT_SWITCH_TAB
          Используются параметры в строке:
            NextKey : String - кнопка, которую надо жать для переключения на следующую закладку
            PreviousKey : String - кнопка, которую надо жать для переключения на предыдущую закладк
            SelfDetermineKeys : boolean - сам определяет кнопки, исходя из ориентации PageControl'а
}
function SwitchToPage(
  const pageControl : OleVariant; 
  const pageName : String; // название закладки, на которую надо переключиться
  const isUseTabIndex : boolean = true; // использовать для переключения свойство TabIndex pagecontrol'a (true), либо переключаться, переходя по закладкам кнопками (false)
  const paramString : String = ''; // строка параметров
  const paramDelimiter : String = ';'
) : boolean;
  var tabsArray, tab, paramList : OleVariant;
      i, tabIndex : integer;
      nextKey, previousKey, key, currentPage : String;
begin
  try
    Result := false;
    
    if not IsExists(pageControl) then
      Raise('Переданный "PageControl" не найден!');
      
    tabIndex := -1;
    
    case AnsiUpperCase(pageControl.WndClass) of
      'TPAGECONTROL' :
        begin
          // перебираем названия вкладок
          for i:= 0 to pageControl.wTabCount do
            if StringCompare(pageName, pageControl.wTabCaption[i]) then
            begin
              tabIndex := i; 
              break;
            end; 
          if tabIndex = -1 then Raise(EX_CANNOT_FIND_TAB);
        end;
        
      'TNSCFORMSPAGECONTROL',
      'TNSCNAVIGATORPAGECONTROL',
      'TNPPAGECONTROL',
      'TELPAGECONTROL',
      'TNSCPAGECONTROL':
        begin
          tab := FindWindowByPath(pageControl, 'WNDCLASS:=TElTabSheet;CAPTION:=' + pageName, false);
          if NOT IsExists(tab) then Raise(EX_CANNOT_FIND_TAB);
          tabIndex := tab.PageIndex;
        end;
        
      'TNSCFULLPAGECONTROL':
        begin
          tab := FindWindowByPath(pageControl, 'WNDCLASS:=TElTabSheet;CAPTION:=' + pageName, false);
          if IsExists(tab) then
            tabIndex := tab.PageIndex            
          else  
            isUseTabIndex := false;          
        end;  
    else
      Raise('Неизвестный класс пэйджконтроллера: ' + pageControl.WndClass);
    end; // case


    // переключаемся
    if isUseTabIndex then 
      // ЧЕРЕЗ СВОЙCТВА ОБЪЕКТА
      pageControl.TabIndex := tabIndex
    else
    begin 
      // КНОПКАМИ
      paramList := ParseParamString(paramString, true, paramDelimiter);
      // определяем кнопки
      if VarToBool( GetParam(paramList, 'SelfDetermineKeys', 'true')) then
      begin // по ориентации пэйджконтрола
        if (pageControl.TabPosition = 0) OR (pageControl.TabPosition = 1) then 
        begin // если пэйджконтрол горизонтальный
          nextKey := '[Right]';
          previousKey := '[Left]';
        end
        else if (pageControl.TabPosition = 2) OR (pageControl.TabPosition = 3) then 
        begin // если пэйджконтрол вертикальный
          nextKey := '[Down]';
          previousKey := '[Up]';
        end;
      end
      else
      begin // из параметров
        nextKey := GetParam(paramList, 'NextKey', '[Right]');
        previousKey := GetParam(paramList, 'PreviousKey', '[Left]');
      end;
      // переключаемся, используя кнопки
      key := nextKey;
      pageControl.SetFocus;
      while NOT StringCompare(pageName, pageControl.ActivePage.Caption) do
      begin
      	currentPage := pageControl.ActivePage.Caption;
      	Sys.Keys(key);
        if (pageControl.ActivePage.Caption = currentPage) then 
          break;
      end;
    end;
     
    // проверяем, совпадает ли название активной вкладки с заданным
    if NOT StringCompare(pageName, pageControl.ActivePage.Caption) then
      Raise(EX_CANNOT_SWITCH_TAB);  
    Result := true;   
  except
    Log.Message('SwitchToPage: ' + ExceptionMessage, 'PageName: "' + pageName + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие/Работа с вкладками
  DESC: Переключает вкладку на навигаторе.
  RESULT:
  REMARK:
}
function SwitchToNavigatorPage(
  const pageName : String; // название закладки, на которую надо переключиться
  const isUseTabIndex : boolean = true; // использовать для переключения свойство TabIndex pagecontrol'a (true), либо переключаться, переходя по закладкам кнопками (false)
  const paramString : String = ''; // строка параметров
  const paramDelimiter : String = ';'
): boolean;
  var
    pageControl, button, pageWnd : OleVariant;
    whichNav : OleVariant;
    i : Integer;
begin
  try
    whichNav := [NAV_LEFT, NAV_RIGHT];
    for i:= VarArrayLowBound(whichNav, 1) to VarArrayHighBound(whichNav, 1) do
    begin
      pageControl := GetFromNavigator(whichNav[i] + 'PAGECONTROL'); 
      Result := SwitchToPage(pageControl, pageName, isUseTabIndex, paramString, paramDelimiter);
      if Result then 
      begin
        pageWnd := GetFromNavigator(whichNav[i] + 'ВКЛАДКА НАВИГАТОРА "' + pageName + '"');      
        if NOT pageWnd.VisibleOnScreen then
        begin
          button := GetFromNavigator(whichNav[i] + 'КНОПКА "СВЕРНУТЬ/РАЗВЕРНУТЬ"');
          if NOT IsExists(button) then
            Raise('Вкладка навигатора не видна. А кнопка "Развернуть" не найдена.');
          button.Click;
          Result := pageWnd.VisibleOnScreen;          
        end;  
        break;  
      end;    
    end;
  except
    Log.Message('SwitchToNavigatorPage: ' + ExceptionMessage, 'PageName: "' + pageName + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со вкладками
  DESC: Активируем закладку внизу по имени
  RESULT:
  REMARK: оставлена для совместимости
}
function ActivatePage(
  const PageName; // имя закладки
  const pageControlWnd : OleVariant = nil; // окно контрола с закладками, если nil, то используется по умолчанию
  const KeyNext: string = '[Right]'; // кнопка, которую надо нажать для перехода на следующую закладку (например, если понадобиться переходить Вниз)
  const KeyPrev: string = '[Left]' // кнопка, которую надо нажать для перехода на предыдущую закладку
): Boolean; // перешли или нет
var
  p, w;
  PageCtrl;
begin
  try
  	Result := false;
    w := GetMainWindow;
    if pageControlWnd = nil then
    begin
    	w.SetFocus;  
  	  PageCtrl := w.ParentForm.ChildForm.WaitWindow('TElPageControl', '*', -1, 0);
    end
    else
    	PageCtrl := pageControlWnd;
      
    Result := SwitchToPage(PageCtrl, PageName, false, 'SelfDetermineKeys:=true;NextKey:=' + KeyNext + ';PreviousKey:='+ KeyPrev);  
    
    Result := (PageCtrl.ActivePage.Caption = PageName);
  except
    Log.Message('ActivatePage: ' + ExceptionMessage, 'PageName: "' + PageName + '"; KeyNext: "' + KeyNext + '"; KeyPrev: "' +  KeyPrev + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;  
end;

procedure _____SPECIAL_WORKS;begin;end; 

{
  TYPE: Поиски; Работа со списками
  DESC: Процедура для построения списка всех документов
  RESULT:
  REMARK:
  TODO: Должна возвращать список
}
function GetListOfAllDocuments : OleVariant;
begin
  try
    if not GoToPPR then
      Raise('Не получилось открыть ППР');
    Sys.Keys('^[Enter]');
    WaitForConfirmationWindow(Options.Run.Timeout div 10);
    Result := GetFromList('СПИСОК ДОКУМЕНТОВ');
  except
    Result := NonExObj;
    Log.Message('GetListOfAllDocuments: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Запускает процесс, возвращает управление только после отработки или истечения
    таймаута. True - если процесс запустился. если таймаут = -1, то ждем окончания процесса
    !  Может глючить
  RESULT:
  REMARK:
}
function RunProcess(
  exeFile : String ; // путь к exe-файлу
  comStr : String = '' ; // параметры
  runTimeout : integer = 60000 // таймайт работы программы
) : boolean; // вышли нормально или по таймауту
var
	proc : OleVariant;
	time, i : integer;
	procName : String;
	a, b, forever : boolean;
begin
  try
  	// выделяем из полного имени файла его имя
  	procName := Utilities.AnsiStrRScan(exeFile, '\');
  	if procName = '' then
  		procName := exeFile
  	else
  	procName := Copy( procName, 2, 1024 );
    	// теперь отрезаем ".exe", если оно есть
  	if PosCI('.exe', procName) <> 0 then
  		procName := Copy(procName, 1, PosCI('.exe', procName) - 1 );
  	i := 0;
  	while IsExists(Sys.WaitProcess(procName, 0, i + 1)) do i := i + 1; // пересчитываем одноименные процессы
  	Result := Win32API.WinExec( exeFile + ' ' + comStr , Win32API.SW_HIDE) >= 32; // WinExec возвращает число меньше 32 если возникла ошибка при запуске.
  	if NOT Result then // какой-то баг при запуске
  		Log.Error('Ошибка запуска ' + procName, 'Строка запуска: ' + exeFile + ' ' + comStr )
  	else
  	begin
    	// сюда попадаем, только если процесс успешно запустился
    	proc := Sys.WaitProcess( procName, 5000, i+1 ); // ждем процесс, можем и не дождаться, если он завершился слишком быстро, но это неважно
  		forever := ( runTimeout = -1 );
  		time := Win32API.GetTickCount + runTimeout;
  		repeat
  			Delay( 500 );
  			a := NOT IsExists(proc);
  			b := ( NOT forever ) AND ( time < Win32API.GetTickCount ); // если forever = true, то b всегда false, и выйдем только после окончания процесса
  		until ( a or b );
  		if b and NOT a then
  			proc.Terminate;  // если время истекло а процесс еще работает, то прибиваем его
  	end;
  except
    Log.Message('RunProcess: ' + ExceptionMessage, 'exeFile: "' + VarToStr(exeFile) + '"; comStr: "' + VarToStr(comStr) + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Обвертка вокруг виндовой GetVersion 
  RESULT:
  REMARK:
}
function GetVersion : LongWord;
var
  Def_DLL, Lib;  
begin
  Def_DLL := DLL.DefineDLL('KERNEL32');
  Def_DLL.DefineProc('GetVersion', vt_ui4);
  Lib := DLL.Load('KERNEL32');
  Result := Lib.GetVersion;
end;
 
{
  TYPE: Общие
  DESC: Отдает название ОС Windows  
  RESULT:
  REMARK:
}
function GetWindowsProductName: String;
begin  
  try
    Result := Storages.Registry('Software\Microsoft\Windows NT\CurrentVersion', HKEY_LOCAL_MACHINE).GetOption('ProductName', '');
  except
    Log.Message('GetWindowsName: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Говорит, является ли ОС типа Win9x
  RESULT:
  REMARK:
}
function IsWin9x : boolean;
begin
	Result := ( Sys.OSInfo.Name = 'Win95' ) OR ( Sys.OSInfo.Name = 'Win98' ) OR ( Sys.OSInfo.Name = 'WinME' );
end;

{
  TYPE: Общие
  DESC: Говорит, является ли ОС типа Win10
  RESULT:
  REMARK:
}
function IsWin10x : boolean;
begin
  Result := Pos('10', GetWindowsProductName) > 0;
end;

{
  TYPE: Общие
  DESC: Нажимает кнопку key count раз.
  RESULT:
  REMARK: Формирует целую строку, а потом сует ее в Sys.Keys, замечено, что так работает быстрее, чем через цикл.
}
procedure PressKeyNCount(
  key : string; // что жмем
  count : integer // сколько раз жмем
);
var
	i : integer;
  str : string;
begin  
  try
  	str := '';
  	if count > 0 then
  		for i := 1 to count do
    		str := str + key;
    Sys.Keys(str);
  except
    Log.Message('PressKeyNCount: ' + ExceptionMessage, 'key: "' + VarToStr(key) + '"; count: "' + VarToStr(count) + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Пересечение массивов.
  RESULT: Возвращает массив элементов, которые есть в обоих массивах. Если множество пустое, то возвращает nil.
  REMARK: 
}
function Intersection(
  arr1 : OleVariant; // первый массив
  arr2 : OleVariant // второй массив
) : OleVariant; // результирующий массив
	var 
    i, j, vt1, vt2 : integer;
    tmp, mapArr2 : OleVariant;
    isEqual : Boolean;
begin
  try
  	Result := nil;
    if IsArray(arr1) AND IsArray(arr2) then
    begin
      // выбираем самый длинный массив, чтобы его засунуть в мапу
      if ArrayLength(arr1) > ArrayLength(arr2) then
      begin 
        tmp := arr1;
        arr1 := arr2;
        arr2 := tmp;
        tmp := nil;
      end;
      //запихиваем элементы второго массива в мапу
      for j := VarArrayLowBound(arr2, 1) to VarArrayHighBound(arr2, 1) do
        if (VarType(arr2[j]) <> VAR_VARIANT_ARRAY) then
          Map(mapArr2, 'put', arr2[j], nil);
            
  	  for i := VarArrayLowBound(arr1, 1) to VarArrayHighBound(arr1, 1) do
      begin
        isEqual := false;
        if (VarType(arr1[i]) = VAR_VARIANT_ARRAY) then
        begin // элемент - массив, а мапа с массивами не работает, поэтому ищем по старинке
          for j := VarArrayLowBound(arr2, 1) to VarArrayHighBound(arr2, 1) do
            if (VarType(arr2[j]) = VAR_VARIANT_ARRAY) AND CompareArray(arr1[i], arr2[j], false) then
            begin
              isEqual := true;
              break;
            end;
        end
        else // элемент не массив, поэтому можем быстро проверить его наличие через мапу
          isEqual := NOT IsEmpty( Map(mapArr2, 'get', arr1[i]) );
        //
        if isEqual then
          AddToArray(Result, arr1[i]);
      end;  
      
      
//  	  	for j := VarArrayLowBound(arr2, 1) to VarArrayHighBound(arr2, 1) do
//        begin
//          isEqual := false;
//          vt1 := VarType(arr1[i]);
//          vt2 := VarType(arr2[j]);
//          if (vt1 = vt2) AND (vt1 <> varEmpty) then
//            if (vt1 = VAR_VARIANT_ARRAY) then
//              isEqual := CompareArray(arr1[i], arr2[j], false)
//            else
//              isEqual := arr1[i] = arr2[j];  
//		    	if isEqual then
//          begin
//            AddToArray(Result, arr1[i]);
//            break;
//          end;  
//        end;
     end;                  
  except
    Log.Message('Intersection: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Cортировка вставками.
  RESULT:
  REMARK:
    Можно задавать критерии сортировки: например 'y > x' - по возрастанию;
    'y < x' - по убыванию. Сортируется не обязательно числа, можно объекты, например 'y.STop > x.STop'.
}
procedure SortArrayEx(
  var inArray: OleVariant; // входной/выходной массив
  const Criteria : String = 'y > x' // критерий сортировки
);
var
  i , j, hiB, loB : integer;
  x, y : OleVariant;
begin
  try
  	if IsArray(inArray) then
    begin
      loB := VarArrayLowBound(inArray, 1);
    	hiB := VarArrayHighBound(inArray, 1);
    	for i := loB to hiB do
      begin
      	x := inArray[i];
        j := i-1;
        if j >= loB then y := inArray[j];
        while (j >= loB ) AND ( Evaluate(Criteria) ) do
        begin
        	inArray[j+1] := y;
          j := j-1;
          if j >= loB then y := inArray[j];
        end;
        inArray[j+1] := x;
      end;
    end;
  except
    Log.Message('SortArrayEx: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со клавиатурой
  DESC: Нажимаем клавишу до тех пор, пока не изменится экран
  RESULT: True, если после нажатия клавиши экран изменился
  REMARK:
}
function PressKeyWithCheck(
  keysArray;                      //одномерный массив типа [s1, s2, ... sn] или строка, если строка, то она будет преобразована в такой массив посимвольно, поэтому всякие ![End] вставлять не получиться
  wnd: OleVariant = nil;          //окно за которым следим
  const paramString : String = '' // параметры  Count:=<количество>
): boolean;
const 
  MAX_PRESS_COUNT = 5;
  TEMP_FILE = 'KEYSCHECK.BMP';
var
  i, j, k;
  pathToImage;
  paramList, checked, p_Count, numText;
begin
  try
    Result := false;
    if NOT IsArray(keysArray) then Raise('keysArray должен быть массивом!');
    //
    paramList := ParseParamString(paramString);
    p_Count := StrToInt( GetParam(paramList, 'Count', '1') );
    if (wnd = nil) then
      wnd := GetMainWindow;
    if not IsExists(wnd) then
      Raise('Переданное окно не существует!');
    pathToImage := GetTempDirectory + '\' + TEMP_FILE;
    //
    Result := true;
    for i := VarArrayLowBound(keysArray,1) to VarArrayHighBound(keysArray,1) do
    begin
      for j := 1 to p_Count do
      begin
        if not IsExists(wnd) then
          Raise('Пропало окно, странно... но факт!');
        wnd.Picture.SaveToFile(pathToImage);
        k := 0;
        repeat
          wnd.SetFocus;
          Sys.Keys(keysArray[i] + keypause);
          inc(k);
        until (not Regions.Compare(wnd, pathToImage, false, false, false, 0)) or (k >= MAX_PRESS_COUNT);
        if k >= MAX_PRESS_COUNT then
        begin
          Result := false;
          Log.Error('PressKeyWithCheck: При нажатии клавиши "' + keysArray[i] + '"  ' + IntToStr(k) + ' раз(а) не было замечено изменений на экране');
        end;
        Log.Message('PressKeyWithCheck: Клавиша "' + keysArray[i] + '", нажатие №: ' + IntToStr(j) + '. Попыток: ' + IntToStr(k), '' ,  pmNormal, GetLogAttr('EXCEPTION'));        
      end;
    end;
  except
    Result := false;
    Log.Error('PressKeyWithCheck: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end;               
end;


{
  TYPE: Общие
  DESC: Копируем выделенный текст в буфер, буфер в результат функции и очищаем буфер.
  RESULT: То что скопировалось в буфер или пустая строка.
  REMARK:
    Возможные значения параметров
      whatToCopy: 'ПЕРВАЯ СТРОКА В ДОКУМЕНТЕ'; 'ВТОРАЯ СТРОКА В ДОКУМЕНТЕ'; 'ПОСЛЕДНЯЯ СТРОКА В ДОКУМЕНТЕ'; STRING - строку ; ALL - все. '' - то что уже выделено
        по-умолчанию : ''
      paramString (содержит список параметров в виде par1:=val1;par2:=val2):
        Trim := (true|false) - обрезать ли пробелы и контрольные символы
          по-умолчанию : true
        HowToCopy := (keyboard|popupmenu|mainmenu) - через что копировать
          по-умолчанию : keyboard
        MaxDelay - максимальное время задержки (в мс), которое выжидаем, пока в буфере не появится непустая строка
          по-умолчанию : 500
        IsCleanClipboard  - очищать ли буфер после копирования
          по-умолчанию : true
}
function CopyToClipboard(
  const wnd : OleVariant; // окно из которого копировать
  whatToCopy : String = ''; // что копировать
  paramString : String = '' // параметры
): String;
  const
    FUNC_NAME = 'CopyToClipboard: ';
    EMPTY_CLIPBOARD = 'vjhdfhjuyerjhf'; // строка, при обнаружении которой в клипборде будем считать, что еще ничего не скопировано
  var 
    paramList : OleVariant;
    howToCopy, keyPause : String;
    isTrim, flag, isCleanClipboard, isMustBeString : boolean;
    timeOut, maxDelay, i : integer;
    tempResult: string;
    regEx : OleVariant;
begin
	Result := '';
  try
    flag := false;
    keyPause := '[P' + IntToStr(Options.Run.Timeout div 16) + ']';
    { парсим параметры }
    paramList := ParseParamString(paramString);
    isTrim := VarToBool(GetParam(paramList, 'Trim', 'true'));
    howToCopy := AnsiUpperCase( GetParam(paramList, 'HowToCopy', 'keyboard') );
    isCleanClipboard := VarToBool(GetParam(paramList, 'IsCleanClipboard', 'true'));
    isMustBeString := VarToBool(GetParam(paramList, 'IsMustBeString', 'true')); 
    maxDelay := VarToInteger( GetParam(paramList, 'MaxDelay', IntToStr(Options.Run.Timeout div 15) ) );
    if (howToCopy = 'POPUPMENU') AND (NOT IsExists(wnd)) then Raise('Окно не существует или не указано, однако оно необходимо для работы!');
    if (wnd <> nil) then
      if IsExists(wnd) then 
        wnd.SetFocus
      else
        Raise('Окно, из которого собираемся копировать, не существует!');  
    Sys.Keys(keyPause);
    {}
    for i := 1 to 4 do 
    begin
    	Sys.Clipboard := EMPTY_CLIPBOARD;
      { выделяем то что надо скопировать }
      case AnsiUpperCase(whatToCopy) of
        'ПЕРВАЯ СТРОКА В ДОКУМЕНТЕ'     :
          begin
            Sys.Keys('^[Home]' + keyPause);
            if ( i<= 2 ) then
              Sys.Keys('[Home]' + keyPause + '![End]' + keyPause)
            else if (i > 2) then
            begin // используем выделение строки через мышь только если 2 раза не удалось через клавиатуру
              if NOT SelectStringByMouse(wnd) then Log.Warning('Не удалось выделить строку мышью!');
            end;
          end;
        'ВТОРАЯ СТРОКА В ДОКУМЕНТЕ'     :
          begin
            Sys.Keys('^[Home]' + keyPause + '[Down]' + keyPause);
            if ( i<= 2 ) then
              Sys.Keys('[Home]' + keyPause + '![End]' + keyPause)
            else if (i > 2) then
            begin // используем выделение строки через мышь только если 2 раза не удалось через клавиатуру
              if NOT SelectStringByMouse(wnd) then Log.Warning('Не удалось выделить строку мышью!');
            end;
          end;             
        'ПОСЛЕДНЯЯ СТРОКА В ДОКУМЕНТЕ'  :
          begin
            Sys.Keys('^[End]' + keyPause);
            if ( i <= 2 ) then
              Sys.Keys('[Home]' + keyPause + '![End]' + keyPause)
            else if (i > 2) then
            begin // используем выделение строки через мышь только если 2 раза не удалось через клавиатуру
              if NOT SelectStringByMouse(wnd) then Log.Warning('Не удалось выделить строку мышью!');
            end;
          end;  
        'STRING', 'СТРОКА В ДОКУМЕНТЕ'  :
          if ( i <= 2 ) then
            Sys.Keys('[Home]' + keyPause + '![End]' + keyPause) 
            
          else if (i > 2) then
          begin // используем выделение строки через мышь только если 2 раза не удалось через клавиатуру
            if NOT SelectStringByMouse(wnd) then Log.Warning('Не удалось выделить строку мышью!');
          end;  
        'ALL'   : 
          case howToCopy of
            'KEYBOARD'  : 
              begin
                Sys.Keys(keyPause + '^a');
                //PressKeyWithCheck(['^a']);
                {Log.Event('^a', 'keybd_event');
                keybd_event(Win32API.VK_LCONTROL, 0, 0, 0);
                keybd_event( $41 , 0, 0, 0);
                keybd_event(Win32API.VK_LCONTROL, 0, Win32API.KEYEVENTF_KEYUP, 0);
                keybd_event( $41 , 0, Win32API.KEYEVENTF_KEYUP, 0);}                
              end;  
            'POPUPMENU' : begin Sys.Keys('[Apps]'); ClickByPopupMenuItem(wnd, 'Выделить все'); end;
            'MAINMENU'  : ClickByMainMenuItem('Правка\Выделить все');
          else
            Raise('Параметр HowToCopy не распознан!');    
          end;  
        '' :;
      else
        Raise('Параметр whatToCopy не распознан!');  
      end;  
      { теперь копируем }
      case howToCopy of
        'KEYBOARD'  : Sys.Keys(keyPause + '^c');
        'POPUPMENU' : begin Sys.Keys('[Apps]'); ClickByPopupMenuItem(wnd, 'Копировать'); end;
        'MAINMENU'  : ClickByMainMenuItem('Правка\Копировать');
      else
        Raise('Параметр HowToCopy не распознан!');
      end;
      { задерживаемся пока не истечет время или не получим из буфера непустую строку }
      timeOut := Win32API.GetTickCount + maxDelay;
      Result := Sys.Clipboard;
      while (Result = EMPTY_CLIPBOARD) AND (Win32API.GetTickCount < timeOut) do
      begin
        Delay(Options.Run.Timeout div 500);
        Result := Sys.Clipboard;
      end;

      if isMustBeString AND (VarType(Result) <> varOleStr) then
      begin
        Log.Message(FUNC_NAME + 'Result не является строковым типом. Пробуем привести его к строке.', VarToString(VarType(Result)) );        
        Result := VarConvert(Result, varOleStr);
        if VarType(Result) <> varOleStr then
        begin
          Log.Error(FUNC_NAME + 'Не удалось привести Result к строке, поэтому cчитаем, что ничего не скопировалось. Вероятно, дальнейшая работа скрипта будет неверной.');
          Result := EMPTY_CLIPBOARD;
        end;            
      end;

    	if isCleanClipboard then ClipboardClean;

      if Result <> EMPTY_CLIPBOARD then
      begin // нифига не скопировалось
        if flag then
          Log.Message(FUNC_NAME + 'Попытка копирования через клавиатуру не удалась, а через ' + howToCopy + ' удалась!', '',  pmNormal, GetLogAttr('EXCEPTION'));
        if (whatToCopy = '') OR (Result <> '') then // это такая небольшая заточечка, чтобы обойти глюк оболочки: если ничего не выделить и скопировать, то скопируется пустая строка.
          break;
      end  
      else
      begin // что-то скопировалось
        flag := ((i>=2) AND (howToCopy = 'KEYBOARD'));
        if flag then howToCopy := 'MAINMENU';
      end;
    end;  

    // финальные действия
    if Result = EMPTY_CLIPBOARD then
    begin
      Log.Message(FUNC_NAME + 'Ничего не скопировалось (не обнаружены изменения буфера обмена).');
      ClipboardClean;
      Result := '';
    end
    else
    begin
      if isTrim then Result := Utilities.Trim(Result);
      if (Result = '') then
        Log.Message(FUNC_NAME + 'Скопировали пустую строку.', '', pmNormal, GetLogAttr('SILVER'))        
      else
        Log.Message(FUNC_NAME + 'Скопировали НЕпустую строку.', 'Result (первые 1024 символа) : "' + Copy(Result, 1, 1024) + '"' + EndOfLine + EndOfLine + 'Sys.Clipboard (первые 1024 символа) : "' + Copy( VarToStr(Sys.Clipboard), 1, 1024) + '"', pmNormal, GetLogAttr('SILVER'));
   
      //Сделано для того, что при копированиии комментария в буфер стали попадать обрамляющие символы "Мои комментарии ....____" и их надо отбрасывать
      if (whatToCopy = 'STRING') or (whatToCopy = '') then
      begin     
        regEx := HISUtils.RegExpr;                       
        regEx.Expression := '(?ms)Мой комментарий\s*(.*)';
        if regEx.Exec(Result) then
        begin 
          Result := regEx.Substitute('$1');
          Result := StringReplace(Result, endOfLine + '  ', endOfLine, 1);
        end; 
      end;
      //    
    end;
  except
    Result := '';
    Log.Message(FUNC_NAME + ExceptionMessage, DbgVarValue(whatToCopy, 'whatToCopy') + DbgVarValue(wnd, 'wnd') + DbgVarValue(paramString, 'paramString'),  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Вставка из буфера.
  RESULT: То что скопировалось в буфер или пустая строка.
  REMARK:
    Возможные значения параметров
      paramString (содержит список параметров в виде par1:=val1;par2:=val2):
        HowToCopy := (keyboard|popupmenu|mainmenu) - через что вставлять
          по-умолчанию : keyboard
        IsCleanClipboard  - очищать ли буфер после вставки
          по-умолчанию : false
}
function PasteFromClipboard(
  const wnd : OleVariant = nil; // окно в которое вставить
  paramString : String = '' // параметры
): boolean;
  var 
    paramList : OleVariant;
    howToPaste : String;
    isCleanClipboard : boolean;
begin
	Result := false;
  try
    { парсим параметры }
    paramList := ParseParamString(paramString);
    howToPaste := AnsiUpperCase( GetParam(paramList, 'HowToPaste', 'MAINMENU') );
    isCleanClipboard := VarToBool(GetParam(paramList, 'IsCleanClipboard', 'false'));
    if (howToPaste = 'POPUPMENU') AND (NOT IsExists(wnd)) then Raise('Окно не существует или не указано, однако оно необходимо для работы!');
    if IsExists(wnd) then wnd.SetFocus;
    Sys.Keys(keyPause);
    { вставляем }
    case howToPaste of
      'KEYBOARD'  : begin Sys.Keys(keyPause + '^v'); Result := true; end;
      'POPUPMENU' : begin Sys.Keys('[Apps]'); Result := ClickByPopupMenuItem(wnd, 'Вставить'); end;
      'MAINMENU'  : Result := ClickByMainMenuItem('Правка\Вставить');
    else
      Raise('Параметр HowToPaste не распознан!');
    end;
    if not Result then Raise('Не получилось выполнить операцию Вставить!');
    //
    if isCleanClipboard then
    begin
      ClipboardClean;
      Log.Message('PasteFromClipboard: Очистили буфер обмена');
    end;
    if IsExists(wnd) then wnd.SetFocus;
    Log.Message('PasteFromClipboard: Вставка из буфера завершена');
  except
    Log.Message('PasteFromClipboard: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;
end;


function Copy2Clipboard: String;
begin Result := CopyToClipboard(nil, '', 'Trim:=false'); end;

{
  TYPE: Работа с текстом
  DESC: функция возвращает true если текст в буфере написан курсивом
  RESULT:
  REMARK: Нужен локально установленный Word
}
function IsTextItalic: Boolean;
var
  p, Doc, Range : OleVariant;
begin
  try
  	Result := False;
    ScriptAction('SET ACTION', SA_USE_MSOFFICE);
    Permissions('check', 'use msoffice');
  	p := Sys.OleObject('Word.Application');  
      
    if IsSupported(p, 'Documents') then
    begin
      p.Visible := True;
      Doc := p.Documents.Add;
      Doc.Paragraphs.Add;
      Range := Doc.Paragraphs.Add.Range;
      Range.Paste;
  		Result := VarToBool(Range.Font.Italic);    
      p.Quit(false);
      while (true) do
        try
          p.Version;
          Delay(300);
        except
          break;
      end; 
    end
    else
    	Raise ('Не удалось запустить MS-Word или он не найден!');
  except
    Log.Message('IsTextItalic: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с текстом
  DESC: функция возвращает true если текст в буфере написан жирным
  RESULT:
  REMARK: Нужен локально установленный Word
}
function IsTextBold: Boolean;
var
  p, Doc, Range : OleVariant;
begin
  try
    Result := False;
    ScriptAction('SET ACTION', SA_USE_MSOFFICE);
    Permissions('check', 'use msoffice');
  	p := Sys.OleObject('Word.Application');  
      
    if IsSupported(p, 'Documents') then
    begin
      p.Visible := True;
      Doc := p.Documents.Add;
      Doc.Paragraphs.Add;
      Range := Doc.Paragraphs.Add.Range;
      Range.Paste;
  		Result := VarToBool(Range.Font.Bold);    
      p.Quit(false);
      while (true) do
        try
          p.Version;
          Delay(300);
        except
          break;
      end; 
    end
    else
    	Raise ('Не удалось запустить MS-Word или он не найден!');
  except
    Log.Message('IsTextBold: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));

    Result := false;
    CommonExceptionHandler;
  end;    
end;

{
  TYPE: Работа с текстом
  DESC: функция возвращает true если текст в буфере подчеркнут
  RESULT:
  REMARK: Нужен локально установленный Word
}
function IsTextUnderline: Boolean;
var
  p, Doc, Range : OleVariant;
begin
  try
  	Result := False;
    ScriptAction('SET ACTION', SA_USE_MSOFFICE);
    Permissions('check', 'use msoffice');
  	p := Sys.OleObject('Word.Application');  
      
    if IsSupported(p, 'Documents') then
    begin
      p.Visible := True;
      Doc := p.Documents.Add;
      Doc.Paragraphs.Add;
      Range := Doc.Paragraphs.Add.Range;
      Range.Paste;
  		Result := VarToBool(Range.Font.Underline);    
      p.Quit(false);
      while (true) do
        try
          p.Version;
          Delay(300);
        except
          break;
      end;
    end
    else
    	Raise ('Не удалось запустить MS-Word или он не найден!');
  except
    Log.Message('IsTextUnderline: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;     
end;

{
  TYPE: Работа с текстом
  DESC: функция возвращает true если текст в буфере перечеркнут
  RESULT:
  REMARK: Нужен локально установленный Word
}
function IsTextStrikeThrough: Boolean;
var
  p, Doc, Range : OleVariant;
begin
  try
  	Result := False;
    ScriptAction('SET ACTION', SA_USE_MSOFFICE);
    Permissions('check', 'use msoffice');
  	p := Sys.OleObject('Word.Application');  
      
    if IsSupported(p, 'Documents') then
    begin
      p.Visible := True;
      Doc := p.Documents.Add;
      Doc.Paragraphs.Add;
      Range := Doc.Paragraphs.Add.Range;
      Range.Paste;
  		Result := VarToBool(Range.Font.StrikeThrough);    
      p.Quit(false);
      while (true) do
        try
          p.Version;
          Delay(300);
        except
          break;
      end;
    end
    else
    	Raise ('Не удалось запустить MS-Word или он не найден!');
  except
    Log.Message('IsTextStrikeThrough: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;     
end;

{
  TYPE: Работа с массивами
  DESC: Возвращает элемент массива по индексу
  RESULT:
  REMARK:
    Индексация ВСЕГДА начинается с 0.
    Если вышли за границы массива, возвращает 'index out of bounds'.
    Если index = -1, то возвращаем последний элемент массива.
}
function GetFromArray(
  const arr : OleVariant; // массив
  const index : integer // индекс
) : OleVariant; // элемент массива
begin
  try
  	if VarArrayLowBound(arr,1) + index > VarArrayHighBound(arr, 1) then
    	Result := 'index out of bounds'
    else
      if index = -1 then
     		Result := arr[VarArrayHighBound(arr, 1)]
      else
  			Result := arr[VarArrayLowBound(arr,1) + index];  
  except
    Log.Message('GetFromArray: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Удаляет из массива все элементы, равные заданному
  RESULT: Возвращает результирующий массив или nil если все удалили.
  REMARK: 
}
function DeleteElementFromArrayByValue(
  arr : OleVariant; // массив
  const value : OleVariant // значение, которое нужно удалить
) : OleVariant; // результирующий массив
var i : integer;
begin
  try
  	i := VarArrayLowBound(arr,1);
  	while i <= VarArrayHighBound(arr,1) do
    begin
    	if VarType(arr[i]) <> varEmpty then
  	  	if arr[i] = value then
        begin
        	if ( i = VarArrayHighBound(arr,1) ) AND ( i = VarArrayLowBound(arr,1) ) then
          begin { если удаляем последний элемент, то возвращаем нуль }
          	Result := nil;
            Exit;
          end;	
    	  	DeleteElementFromArray(arr, i);
        	i := i - 1;    
        end;
     	i := i + 1;    
    end;
    Result := arr;
  except
    Log.Message('DeleteElementFromArrayByValue: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами; Работа со строками
  DESC: Конвертирует массив в строку.
  RESULT:
  REMARK:
}
function Array2String(
  const arr : OleVariant; // массив
  const delimiter : String = ';'; // разделитель между элементами массива
  const isSubArrProcess : boolean = false
) : String; // результирующая строка
var i : integer;
		str : String;
begin
  try
  	str := '';
  	for i := VarArrayLowBound(arr, 1) to VarArrayHighBound(arr, 1) do
      if isSubArrProcess AND IsArray(arr[i]) then
        str := str + Array2String(arr[i], delimiter, isSubArrProcess ) + delimiter
      else
      	str := str + BuiltIn.VarToStr(arr[i]) + delimiter;
    if str <> '' then
    	str := Copy(str, 1, Length(str) - Length(delimiter)); { удаляем последний разделитель }
    Result := str;  
  except
    Log.Message('Array2String: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Возвращает длину массива (количество его элементов), или 0, если это не массив
  RESULT:
  REMARK:
}
function ArrayLength(
  const arr : OleVariant; // массив
  const dimension : integer = 1
) : integer; // длина массива
begin
  try
  	if IsArray(arr) then
  		Result := VarArrayHighBound(arr, dimension) - VarArrayLowBound(arr, dimension) + 1
    else
    	Result := 0;
  except
    Log.Message('ArrayLength: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

// методы сравнения
const
  CM_COMPARE = 1;
  CM_STRINGCOMPARE_FIRST_SECOND = 2; // первый - что ищем, второй - где
  CM_STRINGCOMPARE_SECOND_FIRST = 3; // второй - что ищем, первй - где  
  
{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function CustomComparator(
  const compareMethod : OleVariant;
  const first : OleVariant;
  const second : OleVariant
): boolean;
  const
    FUNCTION_NAME = 'CustomComparator';
begin
  try
    case compareMethod of 
      CM_COMPARE : Result := (first = second);
      CM_STRINGCOMPARE_FIRST_SECOND : Result := StringCompare(first, second);
      CM_STRINGCOMPARE_SECOND_FIRST : Result := StringCompare(second, first);
    else
      Raise('compareMethod неизвестен!');        
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage,
      DbgVarValueEx([compareMethod, first, second], ['compareMethod', 'first', 'second']),
      pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE: Работа с массивами
  DESC: Убирает из массива arr1 элементы, которые есть в массиве arr1 и arr2.
  RESULT: Возвращает результирующий массив, если ничего не остается, то возвращает nil.
  REMARK:
}
function Subtraction(
  arr1 : OleVariant; // массив из которого вычитают
  const arr2 : OleVariant; // массив, который вычитают
  const compareMethod : OleVariant = CM_COMPARE
) : OleVariant; // результирующий массив
  var 
    i, ii, arr2HighBound : integer;
    isCopy : boolean;
    mapArr2;
begin
  try
    Result := nil;
    if IsArray(arr1) then
    begin
      if (NOT IsArray(arr2)) AND (arr2 = nil) then 
      begin // типа если второй массив совсем не массив, а вообще nil, то возвращаем первый массив
        Result := arr1;
        Exit; 
      end;
      
      //запихиваем элементы второго массива в мапу, если сравнение простое
      if (compareMethod = CM_COMPARE) then
        for ii := VarArrayLowBound(arr2, 1) to VarArrayHighBound(arr2, 1) do
          if (VarType(arr2[ii]) <> VAR_VARIANT_ARRAY) then
            Map(mapArr2, 'put', arr2[ii], nil);
                  
      for i := VarArrayLowBound(arr1, 1) to VarArrayHighBound(arr1, 1) do
      begin
        isCopy := true;
        if (compareMethod = CM_COMPARE) then
        begin // простое сравнение
          if (VarType(arr1[i]) = VAR_VARIANT_ARRAY) then
          begin // элемент - массив, а мапа с массивами не работает, поэтому ищем по старинке
            for ii := VarArrayLowBound(arr2, 1) to VarArrayHighBound(arr2, 1) do
              if (VarType(arr2[ii]) = VAR_VARIANT_ARRAY) AND CompareArray(arr1[i], arr2[ii], false) then
              begin
                isCopy := false;
                break;
              end;
          end
          else // элемент не массив, поэтому можем быстро проверить его наличие через мапу
            isCopy := IsEmpty( Map(mapArr2, 'get', arr1[i]) );
          end
        else
        begin // расширенное сравнение
          for ii := VarArrayLowBound(arr2, 1) to VarArrayHighBound(arr2, 1) do
            if CustomComparator(compareMethod, arr1[i], arr2[ii]) then 
            begin
              isCopy := false;
              break;
            end;
        end;
        if isCopy then 
          AddToArray(Result, arr1[i]);
      end;
    end;  
  except
    Log.Message('Subtraction: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{function Subtraction(
  arr1 : OleVariant; // массив из которого вычитают
  const arr2 : OleVariant // массив, который вычитают
) : OleVariant; // результирующий массив
var i : integer;
begin
  try
    if IsArray(arr1) AND IsArray(arr2) then
      for i := VarArrayLowBound(arr2, 1) to VarArrayHighBound(arr2, 1) do
      	if IsArray(arr1) then
  	    	arr1 := DeleteElementFromArrayByValue(arr1, arr2[i])
        else 
        	break; // массив кончился
    Result := arr1;
  except
    Log.Message('Subtraction: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end; }

{
  TYPE: Работа с массивами
  DESC: Возвращает массив элементов, которые есть только в каком-либо одном массиве.
  RESULT: nil - если массивы совпадают полностью.
  REMARK: Что-то типа AddArrays, но не будет неуникальных элементов.
}
function Difference(
  arr1 : OleVariant; // первый массив
  arr2 : OleVariant // второй массив
) : OleVariant; // результирующий массив
var isect : OleVariant;
begin 
  try
    if IsArray(arr1) AND IsArray(arr2) then
    begin
    	isect := Intersection(arr1, arr2);
      arr1 := Subtraction(arr1, isect);
      arr2 := Subtraction(arr2, isect);
    end;
    if IsArray(arr1) then
    begin
    	if IsArray(arr2) then
       	Result := AddArrays(arr1, arr2)
      else
      	Result := arr1;
    end
    else 
    	if IsArray(arr2) then
       	Result := arr2
      else
      	Result := nil; // массивы полностью совпали или изначально были не массивами
  except
    Log.Message('Difference: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC:  Сравнение объектов. Равны только тогда, когда совпадают типы и значения
  RESULT:
  REMARK: Можно сравнивать разные объекты, например string и integer. Ошибки не будет
}
function IsEqual(
  const var1 : OleVariant;
  const var2 : OleVariant
) : boolean;
begin
  Result := (VarType(var1) = VarType(var2)) AND (var1 = var2);
end;

procedure _____VGSCENE;begin;end;
{
  TYPE: Работа с окнами
  DESC: Поиск родительского VGSCENE
  RESULT:
  REMARK:
}
function FindParentVgSceneObj(
  const vgObj: OleVariant
) : OleVariant;
  const
    FUNCTION_NAME = 'FindParentVgSceneObj';
  var 
    vgSceneObj : OleVariant;
begin
  try
    Result := NonExObj;

    if not IsExists(vgObj) then
      Raise('Переданный объект VgScene не найден!');

    vgSceneObj := vgObj; 
    while true do
    begin
      if not IsSupported(vgSceneObj, 'Parent') then
        Raise('Хотим получить Parent у объекта, который его не поддерживает!');
      if vgSceneObj.Parent = nil then
        Raise('Не получилось найти родительский VgScene!');
      
      vgSceneObj := vgSceneObj.Parent;
      
      if not IsSupported(vgSceneObj, 'VCLClass') then
        Raise('Не найден VCLClass у родительского объекта!');
      if vgSceneObj.VCLClass = 'TvgScene' then
        break;      
    end;

    Result := vgSceneObj;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа с окнами
  DESC: Высчитывает координаты относительно родительского VGSCENE
  RESULT:
  REMARK:
}
function CalcXYToParentVgSceneObj(
  const vgObj: OleVariant;
  var x: integer;
  var y: integer
) : boolean;
  const
    FUNCTION_NAME = 'CalcXYToParentVgSceneObj';
  var 
    vgSceneObj : OleVariant;
begin
  try
    Result := true;

    if not IsExists(vgObj) then
      Raise('Переданный объект VgScene не найден!');

    Log.Message(FUNCTION_NAME +  ': Пытаемся получить оносительные координаты объекта VgScene');
          
    vgSceneObj := vgObj;
    x := 0; y := 0; 
    while true do
    begin
      if not IsSupported(vgSceneObj, 'Parent') then
        Raise('Хотим получить Parent у объекта, который его не поддерживает!');
      if not IsSupported(vgSceneObj, 'Position') then
        Raise('Хотим получить Position у объекта, который его не поддерживает!');

      x := x + vgSceneObj.Position.X;
      y := y + vgSceneObj.Position.Y;

      if vgSceneObj.Parent = nil then
        Raise('Не получилось найти родительский VgScene!');
      vgSceneObj := vgSceneObj.Parent;
      if not IsSupported(vgSceneObj, 'VCLClass') then
        Raise('Не найден VCLClass у родительского объекта!');
      if vgSceneObj.VCLClass = 'TvgScene' then
        break;      
    end;
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа с окнами
  DESC: Закрывает балонные сообщения VGSCENE, появляющиеся по клику на медальках
  RESULT:
  REMARK:
}
function CloseBalloonVgSceneMessage(const obj: OleVariant) : boolean;
  const
    FUNCTION_NAME = 'CloseBalloonVgSceneMessage';
  var 
    vgSceneObj : OleVariant;
    x, y: Integer;
begin
  try
    if not IsExists(obj) then
      Raise('Переданный объект не найден!');
    vgSceneObj := FindParentVgSceneObj(obj);
    if not IsExists(vgSceneObj) then
      Raise('Родительский объект VgScene не найден!');   

    x := obj.ScreenLeft + obj.Width + 11;
    y := obj.ScreenTop;  
    common.ScreenToClient(vgSceneObj, x, y);
    vgSceneObj.Click(x, y);

    Result := not (IsExists(obj) and obj.Visible);
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа с окнами
  DESC: Кликает по кординате X:Y. Если переданный объект не VgScene, ищет родственный VgScene
  RESULT:
  REMARK:
}
function ClickXYOnVgSceneObject(
  const obj: OleVariant;
  x, y: integer
) : boolean;
  const
    FUNCTION_NAME = 'CloseBalloonVgSceneMessage';
  var 
    vgSceneObj, oldRunTimeout : OleVariant;
begin
  try
    if not IsExists(obj) then
      Raise('Переданный объект не найден!');
    if IsSupported(vgSceneObj, 'VCLClass') and (obj.VCLClass = 'TvgScene') then
      vgSceneobj := obj
    else
      vgSceneObj := FindParentVgSceneObj(obj);
    if not IsExists(vgSceneObj) then
      Raise('Объект VgScene не найден!');

    oldRunTimeout := Options.Run.Timeout;
    Options.Run.Timeout := 0;
    try 
      vgSceneObj.Click(x, y);
    finally  
      Options.Run.Timeout := oldRunTimeout;
    end;  

    Result := true;
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа с окнами
  DESC: Нажимает на переданный объект VGSCENE
  RESULT:
  REMARK:
}
function ClickOnVgSceneObject(
  const vgObj : OleVariant;
  const paramString : String = ''
) : boolean;
  const
    FUNCTION_NAME = 'ClickOnVgSceneObject';
  var 
    vgSceneObj, w, oldRunTimeout: OleVariant;
    paramList, clickKey, msgCode, doClick, X, Y, mX, mY, sX, sY, sW, sH : OleVariant;
    isClickBySendMsg, isNotClickIfOutWidth, isClickByAbsXY : boolean;
begin
  try
    Result := false;

    // парсим список параметров
    paramList := ParseParamString(paramString);
    clickKey :=          AnsiUpperCase(GetParam(paramList, 'ClickKey', 'left'));
    isClickBySendMsg :=     VarToBool( GetParam(paramList, 'IsClickBySendMsg', 'false') );
    isClickByAbsXY :=       VarToBool( GetParam(paramList, 'IsClickByAbsXY', 'true') );
    isNotClickIfOutWidth := VarToBool( GetParam(paramList, 'IsNotClickIfOutWidth', 'false') );    

    if not IsExists(vgObj) then
      Raise('Переданный объект VgScene не найден!');
    if not IsSupported(vgObj, 'Position') then
      Raise('Свойство "Position" отсутствует у переданного объекта VgScene!');    

    vgSceneObj := FindParentVgSceneObj(vgObj);
    if not IsExists(vgSceneObj) then
      Raise('Родительский объект VgScene не найден!');

    if NOT vgObj.Enabled then 
      Log.Warning(FUNCTION_NAME +  ': Объект VgScene задизейблен!');
    Log.Picture(vgSceneObj, FUNCTION_NAME + ': Кликаем по объекту VgScene', 'vgObj.FullName: "' + VarToStr(vgObj.FullName) + '"; ' );
    
    if isClickByAbsXY then
    begin
      sX := vgObj.Position.X;
      sY := vgObj.Position.Y;
    end
    else
      if not CalcXYToParentVgSceneObj(vgObj, sX, sY) then
        Raise('Не получилось высчитать относительные координаты объекта VgScene');

    X := sX + vgObj.Width div 2;
    Y := sY + vgObj.Height div 2;
    if isClickBySendMsg then
    begin
      //клик через посыл сообщения
      case clickKey of
        'LEFT': msgCode := 513;
        'RIGHT': msgCode := 516;
        'MIDDLE': msgCode := 519;
      else
        Raise('Указана неизвестная клавиша для клика "' + clickKey + '"');
      end;    
      Win32API.SendMessage(vgSceneObj.Handle, msgCode, 1, (Y shl 16) + X);
      if IsExists(vgSceneObj) then
        Win32API.SendMessage(vgSceneObj.Handle, msgCode+1, 1, (Y shl 16) + X);
    end
    else
    begin
      doClick := false;
      if isNotClickIfOutWidth then
      begin
        if VarToBool(gbl_F1ShellTabsEnabled) then
          w := GetMainContainer 
        else
          w := GetMainWindow;
        if not IsExists(w) then
          Raise('Не найдено основное окно оболочки');                                                     

        mX := X + vgObj.Width div 2; mY := Y + vgObj.Height div 2;
        ClientToScreen(vgSceneObj, mX, mY);
        
        sW := Win32API.GetSystemMetrics(SM_CXSCREEN);
        sH := Win32API.GetSystemMetrics(SM_CYSCREEN);
        if (mX > w.Left + w.Width) or (mY > w.Top + w.Height) or (mX > sW) or (mY > sH) then
          Raise('Не кликаем, позиция клика находится за пределами окна или экрана (' + Format('mX:=%d, mY:=%d, w.Left:=d%, w.Top:=d%, w.Width:=d%, w.Height:=d%, ScreenW:=d%, ScreenH:=d%', mX, mY, w.Left, w.Top, w.Width, w.Height, sW, sH) + ')')
        else
          doClick := true;
      end
      else
        doClick := true;
    end;

    //кликаем
    if doClick then
    begin
      oldRunTimeout := Options.Run.Timeout;
      Options.Run.Timeout := 0;
      try 
        case clickKey of
          'LEFT': vgSceneObj.Click(X, Y);
          'LEFT_LL': 
          begin
            X := vgObj.ScreenLeft + vgObj.Width div 2;
            Y := vgObj.ScreenTop + vgObj.Height div 2;
            LLPlayer.MouseDown(MK_LBUTTON, X, Y, 10);
            LLPlayer.MouseUp(MK_LBUTTON, X, Y, 10);
          end;
          'RIGHT': vgSceneObj.ClickR(X, Y);
          'MIDDLE': vgSceneObj.ClickM(X, Y);
        else
          Raise('Указана неизвестная клавиша для клика "' + clickKey + '"');
        end;
      finally  
        Options.Run.Timeout := oldRunTimeout;
      end;  
    end;

    Result := true;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;               
end;



procedure _____MESSAGE_FORM;begin;end;

{
  TYPE: Работа с окнами
  DESC: Нажимает на кнопку на MessageForm'е
  RESULT:
  REMARK: Для клика по TvtFocusLabel, передаваемое имя должно начинаться с символа #
}
function ClickButtonOnMessageForm(
  const messageForm : OleVariant; // окно MessageForm'ы
  const buttonName : String; // название кнопки, т.к. передается в WaitWindow то *регистрозависимо*
  const isPredefinedButton : boolean = true // если TRUE, то проводится предварительный анализ названия кнопки
) : boolean;
  const
    FUNCTION_NAME = 'ClickButtonOnMessageForm';
  var 
    button: OleVariant;
    clickOnLabel: boolean;
begin
  try
    Result := false;
    if buttonName = '' then Exit;
    if NOT IsExists(messageForm) then Raise('Объект messageForm не существует!');
    
    ProcessKiller(FUNCTION_NAME, 'START', Options.Run.Timeout, messageForm);
    try
      if Pos('#', buttonName) = 1 then
      begin
        clickOnLabel := true;
        Delete(buttonName, 1, 1);
        button := FindWindowByPath(messageForm, 'WndClass:=TvtFocusLabel;Caption:=' + buttonName, true);
      end
      else
      begin
        clickOnLabel := false;
        if isPredefinedButton then // нужно для упрощения использования
          case AnsiUpperCase(buttonName) of
            'ДА'        : buttonName := '&Да';
            'НЕТ'       : buttonName := '&Нет';
            'OK', 'ОК'  : buttonName := 'OK';
          end;
        button := FindWindowByPath(messageForm, 'WNDCLASS:=TvgScene|VCLCLASS:=TvtEffectiveDialogButton;Text:=' + buttonName + ';MAXDEPTH:=2', true);
      end;
    finally
      ProcessKiller(FUNCTION_NAME, 'STOP');
    end;  

    if NOT IsExists(button) then Raise('Кнопка не найдена!');
    if NOT button.Enabled then Raise('Кнопка задизейблена!');
    Log.Picture(messageForm, 'ClickButtonOnMessageForm: Кликаем по форме', 'buttonName: "' + VarToStr(buttonName) + '"' + EndOfLine + 'button.FullName: "' + VarToStr(button.FullName) + '"; ' );

    if clickOnLabel then
      button.Click
    else
      ClickOnVgSceneObject(button);
      
    Result := true;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'buttonName: "' + VarToStr(buttonName) + '"' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;               
end;

procedure _____MFT_AND_WFMF_CONSTANTS; begin end;

// Значения констант конечно совпадают с заголовком форм, но это так получилось. НЕ СТОИТ НА ЭТО РАССЧИТЫВАТЬ!!!!
const
  // MFT - MessageFormType
  MFT_ERROR = 'Ошибка';
  MFT_WARNING = 'Предупреждение';
  MFT_CONFIRMATION = 'Подтверждение';
  MFT_INFO = 'Информация';
  MFT_UNKNOWN = 'Неизвестен';
  MFT_NOT_FOUND = 'Форма не найдена';

// параметры, которые будут содержаться в возвращаемой структуре. WFMF - WaitForMessageForm
  WFMF_RES_MSGTYPE = 'Тип сообщения'; // константы MFT_*
  WFMF_RES_MSGTEXT = 'Текст сообщения';
  WFMF_RES_WINDOW = 'Окно MessageForm';
  WFMF_RES_CHECKBOX_TEXT = 'Название чекбокса';
  WFMF_RES_CHECKBOX_STATE = 'Состояние чекбокса';
  WFMF_RES_CHECKBOX_WINDOW = 'Окно чекбокса';
  WFMF_RES_FOOTERTEXT = 'Текст в нижней части формы';
  
{
  TYPE: Работа с окнами
  DESC: Функция ждет сообщение с указанным заголовком и подстрокой в сообщении и может кликнуть по кнопке
  RESULT: Структуру, значения полей которой надо получать с помощью GetParam
     WFMF_RES_MSGTYPE : тип сообщения (MFT_ERROR|MFT_WARNING|MFT_CONFIRMATION|MFT_INFO)
      Если форма не найдена, то MFT_NOT_FOUND
     WFMF_RES_MSGTEXT : текст сообщения
     WFMF_RES_FOOTERTEXT :Текст в нижней части формы
  REMARK:
    НЕ ИСПОЛЬЗОВАТЬ НАПРЯМУЮ В ТЕСТАХ. !!!СЛУЖЕБНАЯ!!!
}
function WaitForMessageForm(
  const wndCaption : String = '';
  timeOut : integer = -1;
  const messageSubstring : String = ''; // подстрока, которая должна содержаться в тексте сообщения, если не содержиться, то окно проигнориуем (не закроем и текст не вернем)
  const buttonName : String = ''; // если пустая строка, то кнопку никакую не нажимаем
  const setCheckbox : String = '' // если пустая строка, то ничего не делаем, либо 'true'/'false'
) : OleVariant; //
  const
    FUNCTION_NAME = 'WaitForMessageForm'; 
  var
    p, w, checkBox, footer, vgScene;
begin
  try
    SetParam(Result, WFMF_RES_MSGTYPE, MFT_NOT_FOUND);
    if timeOut = -1 then 
      timeOut := Options.Run.Timeout div 3;
    p := GetActiveProcess(timeOut, 2, false);//GetF1ShellProcess(-1, 2, false);
    ProcessKiller(FUNCTION_NAME, 'START', timeOut*8, p);
    try
      if IsExists(p) then 
        w := p.WaitWindow('TMessageForm', Choose( wndCaption <> '', wndCaption , '*' ), -1, timeOut);
    finally
      ProcessKiller(FUNCTION_NAME, 'STOP');
    end;                                                                               
    if IsExists(w) then
    begin
      if (messageSubstring <> '') AND (NOT StringCompare(messageSubstring, w.Message.Buffer)) then Exit;
      //
      case w.WndCaption of
        MFT_ERROR, MFT_WARNING, MFT_CONFIRMATION, MFT_INFO: SetParam(Result, WFMF_RES_MSGTYPE, w.WndCaption);
      else
        SetParam(Result, WFMF_RES_MSGTYPE, MFT_UNKNOWN);
      end;
      if (GetParam(Result, WFMF_RES_MSGTYPE) = MFT_CONFIRMATION) then
      begin // у окошка подтверждения ищем чекбокс
        checkBox := w.WaitVCLObject('Check', Options.Run.Timeout div 30);        
        if IsExists(checkBox) then
        begin           
          SetParam(Result, WFMF_RES_CHECKBOX_TEXT, checkBox.Caption);
          SetParam(Result, WFMF_RES_CHECKBOX_STATE, checkBox.wState);
          SetParam(Result, WFMF_RES_CHECKBOX_WINDOW, checkBox);
        end
        else
        begin
          vgScene := w.WaitWindow('TvgScene', '*', -1, 0);
          if IsExists(vgScene) then
          begin
            vgScene.Refresh;
            checkBox := vgScene.VCLObject('TvgBackground').WaitVCLObject('Check', 0);
            if IsExists(checkBox) then
            begin
              SetParam(Result, WFMF_RES_CHECKBOX_TEXT, checkBox.Text);
              SetParam(Result, WFMF_RES_CHECKBOX_STATE, checkBox.IsChecked);
              SetParam(Result, WFMF_RES_CHECKBOX_WINDOW, checkBox);
            end;
          end;
        end;
        // выставляем чекбокс
        if (setCheckbox <> '') and IsExists(checkBox) then
        begin
          if IsSupported(checkBox, 'IsChecked') then
          case AnsiUpperCase(setCheckbox) of
            'TRUE'  : checkBox.IsChecked := true;
            'FALSE' : checkBox.IsChecked := false;
            else
              Raise('Неизвестное значение чексбокса "' + VarToString(setCheckbox) + '"');
          end
          else
            Raise('Чексбокс не содержит параметр "IsChecked"');
        end;      
      end;    
      footer := w.WaitVCLObject('Footer', 0);
      if IsExists(footer) then
        SetParam(Result, WFMF_RES_FOOTERTEXT, footer.Buffer);
      SetParam(Result, WFMF_RES_MSGTEXT, w.VCLObject('Message').Buffer);
      SetParam(Result, WFMF_RES_WINDOW, w);
      w.Activate;
      if buttonName <> '' then 
        ClickButtonOnMessageForm(w, buttonName, false);
    end;      
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

procedure WaitForMessageForm_Test;
  var
    oWMFData, paramsArr, i;
begin
  paramsArr := [
    WFMF_RES_MSGTYPE,
    WFMF_RES_MSGTEXT,
    WFMF_RES_WINDOW,
    WFMF_RES_CHECKBOX_TEXT,
    WFMF_RES_CHECKBOX_STATE,
    WFMF_RES_CHECKBOX_WINDOW,
    WFMF_RES_FOOTERTEXT
  ];

  oWMFData := WaitForMessageForm;

  for i := VarArrayLowBound(paramsArr,1) to VarArrayHighBound(paramsArr, 1) do 
    Log.Message(paramsArr[i], GetParam(oWMFData, paramsArr[i], ''));  
end;


{
  TYPE:
  DESC: Ждет и возвращает параметры MessageForm'ы
  RESULT:
  REMARK:
    Возвращает массив, доступ к которому проихводится с помощью GetParam, в нем могут лежать следующие параметры (описание и возможные значения - см. перед функций WaitForMessageForm):
      WFMF_RES_MSGTYPE - 'Тип сообщения'
      WFMF_RES_MSGTEXT - 'Текст сообщения'
      WFMF_RES_WINDOW - 'Окно MessageForm'
      WFMF_RES_CHECKBOX_TEXT - 'Название чекбокса'
      WFMF_RES_CHECKBOX_STATE - 'Состояние чекбокса'
      WFMF_RES_CHECKBOX_WINDOW - 'Окно чекбокса'
      WFMF_RES_FOOTERTEXT - 'Текст нижней части сообщения'
}
function WaitForAnyMessageWindow(
  const wndCaption : String = '';
  timeOut : integer = -1;
  const messageSubstring : String = ''; // подстрока, которая должна содержаться в тексте сообщения, если не содержиться, то окно проигнориуем (не закроем и текст не вернем)
  const buttonName : String = '' // если пустая строка, то кнопку никакую не нажимаем
) : OleVariant;
begin
  try
    Result := WaitForMessageForm(wndCaption, timeOut, messageSubstring, buttonName);
  except
    Log.Message('WaitForAnyMessageWindow: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end;               
end;

{
  TYPE: Работа с окнами
  DESC: Нажатие кнопки Да или Нет в окне подтверждения
  RESULT: Возвращает текст сообщения
  REMARK: Обработка окон подтверждений и ошибок т.е. окна при перезаписи объектоа в папках и сохранении с существующим именем
}
function WaitForConfirmationWindow(
  timeOut : integer = -1; // таймаут ожидания окна подтверждения
  buttonName: OleVariant = 'Да'; // имя кнопки (если пустая строка, то не кликаем)
  const messageSubstring : String = ''; // подстрока, которая должна содержаться в тексте сообщения, если не содержиться, то окно проигнориуем (не закроем и текст не вернем)
  const setCheckbox : String = '' // если пустая строка, то ничего не делаем, либо 'true'/'false'  
) : String; // текст сообщения
var
  btName: String;
begin
  try
    Result := '';
    if timeOut = -1 then timeOut := Options.Run.Timeout div 2;
    if (VarType(buttonName) = varOleStr) then
    // если кнопка задана строкой
    case AnsiUpperCase(buttonName) of
      'ДА' : btName := '&Да';
      'НЕТ' : btName := '&Нет';
      'ОТМЕНА' : btName := '&Отмена';
      '' : btName := '';
    else
      btName := buttonName;
    end   
    else if (VarType(buttonName) = varBoolean) then // если нет
      case buttonName of
        true : btName := '&Да';
        false : btName := '&Нет';
      end;  

    Result := GetParam( WaitForMessageForm(MFT_CONFIRMATION, timeOut, messageSubstring, btName, setCheckbox), WFMF_RES_MSGTEXT, '');
  except
    Log.Message('WaitForConfirmationWindow: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end; 

{
  TYPE: Работа с окнами
  DESC: Функция закрывает окно с ошибкой (жмет ОК) и возвращет текст сообщения
  RESULT:
  REMARK:
}
function WaitForErrorWindow(
  timeOut : integer = -1;
  const messageSubstring : String = ''; // подстрока, которая должна содержаться в тексте сообщения, если не содержиться, то окно проигнориуем (не закроем и текст не вернем)
  const isCloseWindow : boolean = true
) : String; // текст сообщения
begin
  try
    Result := GetParam( WaitForMessageForm(MFT_ERROR, timeOut, messageSubstring, Choose(isCloseWindow, 'OK', '') ), WFMF_RES_MSGTEXT, '');
  except
    Log.Message('WaitForErrorWindow: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с окнами
  DESC: Ждет окно предупреждения и нажимает кнопку "Ок".
  RESULT: Возвращает текст сообщения.
  REMARK:
}
function WaitForWarningWindow(
  timeOut : integer = -1;
  const messageSubstring : String = ''; // подстрока, которая должна содержаться в тексте сообщения, если не содержиться, то окно проигнориуем (не закроем и текст не вернем)
  const isCloseWindow : boolean = true;
  const butName : String = 'OK';  //название нажимаемой кнопки
  const isFullText : BOolean = false // возвращает текст сообщения вместе с нижней частью
) : String;
  var
    mfData : OleVariant; 
    footerText : String; 
begin
  try
    mfData := WaitForMessageForm(MFT_WARNING, timeOut, messageSubstring, Choose(isCloseWindow, butName, '') );
    Result := GetParam( mfData, WFMF_RES_MSGTEXT, '');
    if isFullText then
    begin
      footerText := GetParam( mfData, WFMF_RES_FOOTERTEXT, '');
      if footerText <> '' then
        Result := Result + EndOfLine + footerText;
    end;   
  except
    Log.Message('WaitForWarningWindow: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с окнами
  DESC: Ждет окно информации и нажимает кнопку "Ок".
  RESULT: Возвращает текст сообщения.
  REMARK:
}
function WaitForInfoWindow(
  timeOut : integer = -1;
  const messageSubstring : String = ''; // подстрока, которая должна содержаться в тексте сообщения, если не содержиться, то окно проигнориуем (не закроем и текст не вернем)
  const isCloseWindow : boolean = true
) : String;
begin
  try
    Result := GetParam( WaitForMessageForm(MFT_INFO, timeOut, messageSubstring, Choose(isCloseWindow, 'OK', '') ), WFMF_RES_MSGTEXT, ''); 
  except
    Log.Message('WaitForInfoWindow: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с окнами
  DESC: Нажатие кнопки Да или Нет в окне подтверждения
  RESULT:
  REMARK: Обработка окон подтверждений и ошибок т.е. окна при перезаписи объектоа в папках и сохранении с существующим именем
}
function ConfirmWindow(
  const buttonName: String = 'Да' // имя кнопки
): Boolean; // нашли ли окно подтверждения
begin
  try
    Result := WaitForConfirmationWindow(-1, buttonName) <> '';
  except
    Log.Message('ConfirmWindow: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с окнами
  DESC: Получает MessageFormу и обрабатывает ее
  RESULT: Обработана ли форма (есть ли она среди найденных)
  REMARK:
    arrOfKnownForms - массив массивов типа [тип_формы, текст_формы, кнопка_которую_нужно_нажать_на_форме <, ID>]
      например:
      [
        ([MFT_ERROR, '*не удалось распознать контекст*', 'ОК']),
        ([MFT_WARNING, 'Информация*запрос*отсутствует*', SEARCH_CONTINUE_NAME])
      ];
    Если для формы указан ID, то если такая форма будет найдена, то в messageFormData будет добавлен параметр CFKMF_ID
    со значением этого ID, если не указан (или форма не найдена), то будет присвоено -1.
}
function CheckForKnownMessageForms(
  const arrOfKnownForms : OleVariant; // массив
  var messageFormData : OleVariant; // сюда вернутся данные формы (в любом случае)  
  const timeOut : integer = -1 // в течение этого времени будем ожидать MessageFormу
) : boolean;
  var 
    kfType, kfText, kfCloseButton, kfID, mfType, mfText, mfWindow : OleVariant;
    i : integer;
begin
  try
    Result := false;
    if timeOut = -1 then timeOut := Options.Run.Timeout;
    messageFormData := WaitForMessageForm('', timeOut);
    mfType := GetParam(messageFormData, WFMF_RES_MSGTYPE);
    if mfType <> MFT_NOT_FOUND then
    begin
      mfText := GetParam(messageFormData, WFMF_RES_MSGTEXT);
      mfWindow := GetParam(messageFormData, WFMF_RES_WINDOW);
      for i := VarArrayLowBound(arrOfKnownForms,1) to VarArrayHighBound(arrOfKnownForms,1) do
      begin
        kfType := arrOfKnownForms[i][0];
        kfText := arrOfKnownForms[i][1];
        kfCloseButton := arrOfKnownForms[i][2];        
        if VarArrayHighBound(arrOfKnownForms[i], 1) > 2 then
          kfID := arrOfKnownForms[i][3]
        else
          kfID := -1;  
        SetParam(messageFormData, 'CFKMF_ID', kfID);
                
        if (kfType = mfType) AND StringCompare(kfText, mfText) then
        begin
          ClickButtonOnMessageForm(mfWindow, kfCloseButton);
          Result := true; // типа форма обработана
          Exit;
        end;  
      end;
      // если нам встретилась форма, которая не совпадает ни с одной из найденных, то сообщаем об этом
      Log.Message(
        'CheckForKnownMessageForms: Обнаруженное окно не совпадает ни с одним из известных.',
        'Массив известных окон: ' + EndOfLine + ConvertArrayToString(arrOfKnownForms)
      );
      Log.Picture(mfWindow, 'CheckForKnownMessageForms: Скриншот обнаруженного окна.');
      
    end;
  except
    Log.Message('CheckForKnownMessageForms: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;               
end;

procedure _____OTHER_WORKS;begin;end;   

{
  TYPE: Общие
  DESC: Говорит, является ли параметр empty (то есть вообще никаким) объектом
  RESULT:
  REMARK:
}
function IsEmpty(const obj : OleVariant) : boolean;
begin
  try
  	Result := ( VarType(obj) = varEmpty );
  except
    Log.Message('IsEmpty: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Удаляет из массива неуникальные элементы
  RESULT:
  REMARK:
    Удаляет из массива неуникальные элементы (оставляет только один из них), исходный массив не меняет. массив возвращается отсортированным
}
function GetUniqueArray(
  arr : OleVariant // исходный массив
) : OleVariant; // обработанный массив
var i : integer;
begin
  try
  	Result := nil;
  	if ArrayLength(arr) > 1 then
    begin
  		SortArray(arr);
      i := VarArrayLowBound(arr,1);
    	while i <= VarArrayHighBound(arr,1)-1 do
      begin
      	if (NOT IsEmpty(arr[i])) AND (NOT IsEmpty(arr[i+1])) then
    	  	if arr[i] = arr[i+1] then
          begin
      	  	DeleteElementFromArray(arr, i+1);
          	i := i - 1;    
          end;
       	i := i + 1;    
      end;
      Result := arr;
    end;
  except
    Log.Message('GetUniqueArray: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Возвращает массив неуникальных элементов.
  RESULT:
  REMARK:
    Возвращает массив неуникальных элементов. Если в исходном массиве было n экземпляров неуникального элемента х, то в результирующем их будет n-1 штук. 
    Массив возвращается отсортированным
}
function GetNonUniqueArray(
  arr : OleVariant // исходный массив
) : OleVariant; // обработанный массив
var i : integer;
begin
  try
  	Result := nil;
  	if ArrayLength(arr) > 1 then
    begin
  		SortArray(arr);
      for i := VarArrayLowBound(arr,1) to VarArrayHighBound(arr,1)-1 do
      	if (NOT IsEmpty(arr[i])) AND (NOT IsEmpty(arr[i+1])) then
    	  	if arr[i] = arr[i+1] then
          	AddToArray(Result, arr[i]);
    end;
  except
    Log.Message('GetNonUniqueArray: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;


{
  TYPE: Запуск
  DESC: Функция возвращает путь, где установлена Ф1
  RESULT: Путь, где установлена Ф1
  REMARK: Берет из реестра
}
function GetF1Directory(
  target : String = 'client'
): string;
  var
  	Section, f1RegKey, root;
    path;
    regExp;
begin
  try
    target := AnsiUpperCase(target);
    case target of
      'CLIENT' : begin
        f1RegKey := F1REGKEY_CLIENT;
        root := HKEY_CURRENT_USER;
      end;
      'SERVER' : begin
        f1RegKey := F1REGKEY_SERVER;
        root := HKEY_LOCAL_MACHINE;
      end;
    else
      Raise('Параметр target не распознан!');
    end;
    //
  	Section := Storages.Registry(F1REGBRANCH, root);
    path := Section.GetOption(f1RegKey, '');
    
    regExp := HISUtils.RegExpr; 
    regExp.Expression := '(?-g)-GCMConfigFile "(.*)(?i)\\garant.ini"';
    if regExp.Exec(path) then
      Result := regExp.Match[1]
    else  
    begin 
      Log.Message('Не удалось получить значение параметра "-GCMConfigFile"! Ключ реестра ' + f1RegKey + ' : '+  path, '',  pmNormal, GetLogAttr('RED'));
      Result := '';
    end;       
  except
    Log.Message('GetF1Directory: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := '';
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Запуск
  DESC: Функция выставляет путь к папке с ini-файлом в реестре.
  RESULT: Получилось или нет
  REMARK:
}
function SetF1Directory(
  const newPath : String; // новый путь к папке, где лежит garant.ini
  target : String = 'client'
) : boolean;
  var
    section, value, oldPath, f1RegKey, root : OleVariant;
    regExp;
begin
  try
    Result := false;
    newPath := IncludeTrailingBackslash(newPath);
    // получаем значение ключа
    target := AnsiUpperCase(target);
    case target of
      'CLIENT' : begin
        f1RegKey := F1REGKEY_CLIENT;
        root := HKEY_CURRENT_USER;
      end;  
      'SERVER' : begin
        f1RegKey := F1REGKEY_SERVER;
        root := HKEY_LOCAL_MACHINE;
      end;
    else
      Raise('Параметр target не распознан!');
    end;      

    section := Storages.Registry(F1REGBRANCH, root);
    value := section.GetOption(f1RegKey, '');
    // формируем новое значение
    if value = '' then
      value := F1GCMCONFIGFILEPARAMNAME + newPath + 'garant.ini"' // ключ не существует или кривой
    else
    begin    
      regExp := HISUtils.RegExpr; 
      regExp.Expression := '(?-g)-GCMConfigFile "(.*)garant.ini"';
      if NOT regExp.Exec(value) then Raise('Не удалось получить значение параметра "-GCMConfigFile"');
      value := regExp.Replace(value, '-GCMConfigFile "' + newPath + 'garant.ini"');        
    end;  
    // пишем обратно
    section.SetOption(f1RegKey, value);
    // проверяем
    Result := StringCompare(IncludeTrailingBackslash(GetF1Directory(target)),  newPath);
  except
    Result := false;
    Log.Message('SetF1Directory: ' + ExceptionMessage, 'newPath: "' + VarToStr(newPath) + '"' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Работа с файлами
  DESC: Возвращает значение из гарантовского INI-файла
  RESULT:
  REMARK: Регистрочувствительная!!!
}
function GetValueFromGarantINI(
  const section : String; // секция
  const key : String; // параметр
  pathToFile : String = '' // опциональный путь к ини-файлу, по умолчанию берется из реестра
) : String;
  var 
    fileHandle, i, j : integer;
  	buf, afterSemicolon : String;
begin
  try
  	VarClear(Result);
  	if pathToFile = '' then
    	pathToFile := GetF1Directory + '\garant.ini';
    if NOT Utilities.FileExists(pathToFile) then Exit; { файл не найден }
    buf := GetFileBody(pathToFile) + EndOfLine;
    if PosAnyChar('[]', section) = 0 then section := '[' + section + ']' ;
    i := Pos(section, buf);
    if i = 0 then Exit; { секция не найдена  }
    i := i + Length(section);
    j := PosN('[', buf, i);
    if j = 0 then j := 1000000;
    buf := Copy(buf, i, j - i );
    key := key + '=';
    i:= 0;
    repeat
      i := PosN(key, buf, i+1);
      afterSemicolon := AnsiStrRScan( Copy(buf, 1, i), ';');
    until (i = 0) OR (afterSemicolon = '') OR (Pos(EndOfLine, afterSemicolon) <> 0);
    if i = 0 then Exit; { значение не найдено }
    i := i + Length(key);
    Result := Copy(buf, i, PosN(EndOfLine, buf, i) - i );
  except
    Log.Message('GetValueFromGarantINI: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с файлами
  DESC: Сохраняет значение в Garant.ini
  RESULT:
  REMARK: Регистрочувствительная!!!
}
function SetValueToGarantINI(
  const section : String; // секция
  const key : String;  // параметр
  const value : String; // значение параметра
  const createIfAbsent : boolean = false; // создавать секцию/параметр, если они отсутствуют
  pathToFile : String = '' // путь к ини-файлу
) : boolean; 
  var 
    fileHandle, i, j, k : integer;
		buf, toWrite, tmp, _key, _val, afterSemicolon : String;
    mapSection : OleVariant;
begin
  try
  	Result := false;
  	if pathToFile = '' then
    	pathToFile := GetF1Directory + '\garant.ini';
    if NOT Utilities.FileExists(pathToFile) then Exit; {  файл не найден }
    buf := GetFileBody(pathToFile);
    {  разбиваем по секциям }
    i := Pos('[', buf);
    while i <> 0 do
    begin
    	j := PosN(']', buf, i);
      if j <> 0 then 
      begin
      	k := PosN('[', buf, j);
        if k = 0 then k := 100000;
        _key := Copy(buf, i+1, j-2);
        _val := Copy(buf, j+1, k - Length(_key) - 3);
      	Map(mapSection, 'add', _key, _val);
        buf := Copy(buf, k, 1000000);
      end;
   	  i := Pos('[', buf);
    end; 
    toWrite := key + '=' + value + EndOfLine;
    {  ищем секцию и ключ }
    buf := Map(mapSection, 'get', section);
    if IsEmpty(buf) then
    begin
     	if (NOT createIfAbsent) then
      begin
        Log.Warning('Указана несуществующая секция, а создание новых запрещено!', section);
        Exit; {  секция не найдена и создавать нельзя }
      end;  
    	Map(mapSection, 'add', section, EndOfLine + toWrite); {  создаем }
    end
    else
    begin
    	{  нашли секцию, иищем ключ }
      i := 0;
      repeat
        i := PosN(key, buf, i+1);
        afterSemicolon := AnsiStrRScan( Copy(buf, 1, i), ';');
      until (i = 0) OR (afterSemicolon = '') OR (Pos(EndOfLine, afterSemicolon) <> 0);
      if i = 0 then
      begin
      	if NOT createIfAbsent then
        begin
          Log.Warning('Указан несуществующий ключ, а создание новых запрещено!', key);
          Exit; {  не найдено и создавать нельзя }
        end;  
        {  создаем новый ключ }
      	k := PosN(EndOfLine + EndOfLine, buf, 2);
        if k = 0 then k := 1000000;
      	buf := Copy(buf, 1, k + Length(EndOfLine) - 1) + toWrite + EndOfLine;
      end
      else {  меняем старое значение на новое }
      	buf := StringReplace(buf, EndOfLine + Copy(buf, i, PosN(EndOfLine, buf, i) - i + 2 ), EndOfLine + toWrite, 2);
      Map(mapSection, 'add', section, buf);
    end;
    toWrite := '';
    {  обратно из секций в строку }
    for i := 0 to Map(mapSection, 'length', nil) do
    	toWrite := toWrite + '[' + Map(mapSection, 'key by index', i) + ']' + Map(mapSection, 'value by index', i);
    {  и обратно в файл ... }
    SaveStrToFile(pathToFile, toWrite);
    Result := true;  
  except
    Log.Message('SetValueToGarantINI: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Закрывает все процессы. возвращает их количество
  RESULT: Количество закрытых процессов.
  REMARK:
}
function CloseAllProcess(
  const prcName : String; // имя процесса
  const isTerminate : boolean = true; // убивать, или давать процессу возможность выйти самому, посылая ему Close
  const waitTime : integer = 0 // сколько ждать после каждого закрытия
) : integer; // сколько процессов закрыли
var i, j : integer;
		p : OleVariant;
begin
  try
  	i := 1;
    p := Sys.WaitProcess(prcName);
    while IsExists(p) do
    begin
    	i := i + 1;
      if isTerminate then p.Terminate
  								   else p.Close;
  		Delay(waitTime);                    
      p := Sys.WaitProcess(prcName);
    end;
    Result := ( i - 1 );
  except
    Log.Message('CloseAllProcess: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Если value1 не пустое, то возвращает его. Если пустое, то value2.
}
function GetNonEmpty(
  const value1 : OleVariant; // первое значение
  const value2 : OleVariant // второе значение
) : OleVariant;
begin
  try
  	if VarType(value1) = varEmpty then Result := value2	else Result := value1;
  except
    Log.Message('GetNonEmpty: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа со строками; Работа с массивами
  DESC: Конвертирует строку с параметрами в соответствующий map-массив
  RESULT: Возвращает двумерный массив, который может обрабатываться функцией Map
  REMARK: Функция принимает строку вида параметр1:=значение1;параметр2:=значение2 и преобразует ее в двумерный массив
}
function ParseParamString(
  const paramString : String; // строка с параметрами
  const upCaseParamNames : boolean = true; // преобразовывать имена параметров к верхнему регистру (для регистронечувствительности)
  const paramDelimiter : String = ';'; // разделитель групп параметр:=значение
  const paramValueDelimiter : String = ':=' // разделитель параметра и значения
) : OleVariant; // map массив
var
  paramArr, recArr, paramName, value, temp, str : OleVariant;
  i, j : integer;
begin
  try
    str := paramString;
    if (paramDelimiter <> EndOfLine) then
      repeat { чуть более сложный алгоритм разбора строки, нужен для того чтобы строки типа a:=1;2;c:=3 делить на "a:=1;2" и "c:=3" }
        i := Pos(paramDelimiter, str);
        if (i <> 0) then
        begin
          j := i;
          repeat
            i := j;
            j := PosN(paramDelimiter, str, j+1);
          until (j = 0) OR ( Pos(paramValueDelimiter, Copy(str, i+1, j-i-1)) <> 0  );
        end;
        if (i <> 0) then 
        begin
          AddToArray(paramArr, Copy(str, 1, i-1));
          Delete(str, 1, i);
        end
        else 
          if (str <> '') then
            AddToArray(paramArr, str);
      until i = 0
    else { старый метод }
      paramArr := String2Array(paramString, paramDelimiter);
    { разбиваем группы на параметр-значение }
    for i := 0 to ArrayLength(paramArr)-1 do
    begin
    	recArr := String2Array(GetFromArray(paramArr, i), paramValueDelimiter);
      paramName := Utilities.Trim( GetFromArray(recArr, 0) );
      if paramName = '' then continue;
      value := Utilities.Trim( GetFromArray(recArr, 1) );
      if upCaseParamNames then paramName := Utilities.AnsiUpperCase(paramName);
    	Map(Result, 'add',  paramName, value);
    end;
  except
    Log.Message('ParseParamString: ' + ExceptionMessage, 'paramString: "' + paramString + '"; paramDelimiter: "' + paramDelimiter + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end; 
end;

{
  TYPE: Работа со строками; Работа с массивами
  DESC: Вытаскивает из массива, сформированного ParseParamString или SetParam значение параметра
  RESULT: Возвращает значение(строку) по параметру
}
function GetParam( 
  paramList : OleVariant; // map массив, сформированный ParseParamString
  paramName : String;  // имя параметра
  const defaultValue : OleVariant = ''; // значение, которое будет возвращено, если параметр не найден
  const upCaseParamNames : boolean = true // преобразовывать имена параметров к верхнему регистру (для регистронечувствительности)
) : OleVariant; // значение
begin
  try 
    if IsQCPluginEnabled then
      Result := gbl_QCPlugin.GetParam( paramList, paramName, defaultValue)
    else
    begin  
      if upCaseParamNames then paramName := Utilities.AnsiUpperCase(paramName);
      Result := Map(paramList, 'get', paramName);
      if (BuiltIn.VarType(Result) = varEmpty) then
        Result := defaultValue; 
    end;
  except
    Log.Message('GetParam: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;

{
  TYPE: Работа со строками; Работа с массивами
  DESC: Добавляем в массив, (сформированный ParseParamString, или создает его сама), значение параметра
  RESULT: Возвращает paramList
}
function SetParam(
  var paramList : OleVariant; // map массив, сформированный ParseParamString
  paramName : String;  // имя параметра
  const value : OleVariant = ''; // значение, которое будет присвоено параметру
  const upCaseParamNames : boolean = true // преобразовывать имена параметров к верхнему регистру (для регистронечувствительности)
) : OleVariant; 
begin
  try
    if IsQCPluginEnabled then
      gbl_QCPlugin.SetParam( paramList, paramName, value)
    else
    begin  
      if upCaseParamNames then paramName := Utilities.AnsiUpperCase(paramName);
      Map(paramList, 'add', paramName, value);
     end;
    Result:= value;   
  except
    Log.Message('SetParam: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;  
end;

var gbl_ComputerNameVariable : String;
{
  TYPE: Общие
  DESC: Возвращает имя машины (DNS), на которой работает скрипт
  RESULT:
  REMARK:
}
function CompName : String;
  var 
    kernel32, kernel32Lib, LpStr, res, bufSize : OleVariant;
begin
  try
//    if VarType(gbl_ComputerNameVariable) = varEmpty then
//    begin
//      {
//      try
//        gbl_ComputerNameVariable := Log.Results.Items(Log.Results.Count - 1).Data.ValueByName('Computer');
//      except
//        gbl_ComputerNameVariable := '';
//      end;}
//      bufSize := 1024;
//      kernel32 := DLL.DefineDLL('KERNEL32');
//      kernel32.DefineProc('GetComputerNameExA', vt_i4, vt_lpstr, vt_byref or vt_i4, vt_bool);
//      LpStr := DLL.New('LPSTR', bufSize);
//      kernel32Lib := DLL.Load('KERNEL32');
//      res := kernel32Lib.GetComputerNameExA(1, LpStr, bufSize);
//      if res <> 0 then 
//        gbl_ComputerNameVariable := LpStr.Text
//      else
//      begin
//        gbl_ComputerNameVariable := '';
//        Log.Warning('CompName: Не удалось получить имя машины');
//      end;
//    end;
//    Result := gbl_ComputerNameVariable;
    if (VarType(gbl_ComputerNameVariable) = varEmpty) then
      gbl_ComputerNameVariable := Sys.HostName;
    Result := gbl_ComputerNameVariable;               
  except
    Log.Message('CompName: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

const
  SO_ALL_SHARED_PATH = 'SharedPath';
  SO_SP_QUORUM_DELTA = 'QuorumDelta';
  SO_SP_MIN_QUORUM = 'MinQuorum';
{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function SynchroObjectsParams(
  whatToDo : String;  
  paramName : String;
  value : OleVariant = '___NOT_INITIALIZED___'   // если 'get' - то играет роль параметра по-умолчанию, 'set' - устанавливаемое значение   
): OleVariant;
  const
    FUNCTION_NAME = 'SynchroObjectsParams';
    NOT_INIT = '___NOT_INITIALIZED___';  
  var
    paramList;
    p_sharedPath;    
begin
  try
    case AnsiUpperCase(whatToDo) of
      'GET' : 
        begin
          Result := GetGlobalParam(FUNCTION_NAME + paramName, value);
          if IsEqual(Result, NOT_INIT) then Raise('Параметр не проинициализирован!');
        end;  
      'SET' : SetGlobalParam(FUNCTION_NAME + paramName, value);
    end;                      
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(paramName, 'paramName'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

function IsMap(
  const mapObject : OleVariant
) : boolean;
begin
  Result := (VarType(mapObject) = varDispatch) AND IsSupported(mapObject, 'CompareMode');
end;


{
  TYPE: Работа с массивами; Общие
  DESC: Работа с ассоциативным массивом.
  RESULT:
  REMARK:
    Операции: put, get, clear by key, clear by value, length, key by index, value by index.
    Если при удалении от массива ничего не осталось, то возвращает emptyObject.
    Если при get ключ не найден, то возвращает emptyObject.
    Индекс начинается с 0
}
function Map(
  var mapObject : OleVariant; // объект массива
  const whatToDo : String; // операция
  const key : OleVariant; // ключ
  const value : OleVariant = ''; // значение
  const isUsePlugin : boolean = true
) : OleVariant; // результат
  var 
    i : integer;
		isValidMap : boolean;
    fileVar, items, keys, keysToDel, str : OleVariant;
begin
  try
    VarClear(Result);
             
    isValidMap := (VarType(mapObject) = varDispatch) AND IsSupported(mapObject, 'CompareMode');
     
  	case whatToDo of
  {**}	'put', 'add' : // добавляет элемент по ключу. Ключи всегда уникальны.
          if IsQCPluginEnabled then
            Result := gbl_QCPlugin.Map(mapObject, 'put', key, value)
          else
          begin                     
            if NOT isValidMap then mapObject := Sys.OleObject('Scripting.Dictionary');            
            if mapObject.Exists(key) then
              mapObject.Remove(key);                          
            mapObject.Add(key, value);    
          end;
                 
  {**}  'get' :  // выдает значение соответствующее ключу
          if IsQCPluginEnabled then
            Result := gbl_QCPlugin.Map(mapObject, 'get', key, nil)
          else
            if isValidMap AND mapObject.Exists(key) then
              Result := mapObject.Item(key);
                                                         
  {**}  'clear by key' :  // удаляет элемент по ключу
          if isValidMap AND mapObject.Exists(key) then
            mapObject.Remove(key);
                      
  {**}  'clear by value' : // удаляет все элементы, со значением value
          if isValidMap then
          begin
            items :=  mapObject.Items;
            keys  :=  mapObject.Keys;
            for i := 0 to mapObject.Count-1 do
              if (items[i] = value) then
                mapObject.Remove(keys[i]);             
          end;
        'clear' :
          if isValidMap then
            mapObject.RemoveAll;          
  {**}  'length', 'max index' :      
  		 	  if isValidMap then
            Result := mapObject.Count-1
          else
            Result := -1;    
  {**}  'key by index' :
          if isValidMap then
          begin
            keys  :=  mapObject.Keys;
            Result := keys[key];
          end;
        'elements count' :
          if isValidMap then
            Result := mapObject.Count
          else
            Result := 0;
        'create empty map' :
          mapObject := Sys.OleObject('Scripting.Dictionary');    
  {**}  'value by index' :
          if isValidMap then
          begin
            items  :=  mapObject.Items;
            Result := items[key];
          end;
        'values array' :
          if isValidMap then
            Result := mapObject.Items;
        'keys array' :
          if isValidMap then
            Result := mapObject.Keys;
        'serialize' :
          if IsQCPluginEnabled then
            Result := gbl_QCPlugin.Map(mapObject, 'serialize', nil, nil)
          else
            Raise('Для этой операции необходим QCPlugin!');
          {if isValidMap then
          begin
            items :=  mapObject.Items;
            keys  :=  mapObject.Keys;
            Result := 'ddd' + EndOfLine + VarToStr(mapObject.Count-1);
            for i := 0 to mapObject.Count-1 do Result := Result +  EndOfLine + IntToStr(VarType(keys[i])) + EndOfLine + VarToStr(keys[i]) + EndOfLine + IntToStr(VarType(items[i])) + EndOfLine + VarToStr(items[i]);
          end;}             
        'unserialize' :
          if IsQCPluginEnabled then
            gbl_QCPlugin.Map(mapObject, 'unserialize', key, nil)
          else
            Raise('Для этой операции необходим QCPlugin!');
        'save to file' :
          if IsQCPluginEnabled then
            try
              if (Pos('\', key) = 0) then
                key := IncludeTrailingBackslash(SynchroObjectsParams('get', SO_ALL_SHARED_PATH)) + key + '.map_file';
              WriteTextToFile(key, Map(mapObject, 'serialize', nil, nil) );
            except
              Log.Error('Исключение при записи мапы: ' + ExceptionMessage);
            end
          else
            Raise('Для этой операции необходим QCPlugin!');  
        'load from file' :
          begin
            try
              if (Pos('\', key) = 0) then
                key := IncludeTrailingBackslash(SynchroObjectsParams('get', SO_ALL_SHARED_PATH)) + key + '.map_file';            
              str := ReadTextFromFile(key); //GetFileBody(key);
            except
              Log.Warning('Exception: ' + ExceptionMessage);
              str := '';
            end;  
            if IsQCPluginEnabled then
            begin
              if (str <> '') then
                Map(mapObject, 'unserialize', str, nil);
            end  
            else
              Raise('Для этой операции необходим QCPlugin!');  
          end;
        'copy':
          begin
            items :=  mapObject.Items;
            keys  :=  mapObject.Keys;
            for i := 0 to mapObject.Count-1 do
              Map(Result, 'put', keys[i], items[i]);
          end;                                                                    
    end;
  except
    Log.Message('Map: ' + ExceptionMessage, DbgVarValue(whatToDo, 'whatToDo') + DbgVarValue(key, 'key') + DbgVarValue(value, 'value') + DbgVarValue(str, 'str'),  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;

{
  TYPE:
  DESC: Производит измененеие содержимого файла.
    Проверяет что оно соответствует исходному в начале операции и конечному в конце
  RESULT:
  REMARK:
}
function _CS_TryChangeFileText(
  const fileName : String;
  const srcText : String;
  const dstText : String
): Boolean;
  const
    FUNCTION_NAME = '_CS_TryChangeFileText';
  var
    fileHandle, writedBytes, readedBytes : Integer;
    buf : String;  
begin
  try
    Result := false;
    if NOT Utilities.FileExists( fileName ) then
      Raise('Файл не найден!');
    //
    fileHandle := Utilities.FileOpen( fileName, fmShareDenyWrite OR fmOpenReadWrite );
    if (fileHandle = -1) then Exit;
    //
    try
      // в начале проверяем, что содержимое файла равно исходному
      Utilities.FileRead(fileHandle, buf, FileWork.GetFileSize(fileName));
      if (buf <> srcText) then
        Exit; // видимо файл уже был кем-то изменен, мы его трогать не будем
      
      // теперь меняем содержимое файла на заданное
      Utilities.FileSeek(fileHandle, 0, 0);
      writedBytes := Utilities.FileWrite( fileHandle, dstText, Length(dstText) );
      Win32API.SetEndOfFile( fileHandle );        
      if (writedBytes = -1) then
        Raise('Произошла ошибка при записи!')
      else if (writedBytes < Length(dstText)) then
        Raise( Format('Записано меньше (%d) чем надо(%d)!', [writedBytes, Length(dstText)]) );
      
      // теперь проверяем, что после записи содержимое файла равно заданному (по идее это не нужно, но мы имеем дело с ТестКомплитом...)
      Utilities.FileSeek(fileHandle, 0, 0);
      readedBytes := Utilities.FileRead(fileHandle, buf, FileWork.GetFileSize(fileName)); 
      if (readedBytes <> writedBytes) then
        Raise( Format('Прочитано не столько же (%d) сколько записано (%d)!!', [readedBytes, writedBytes]) );
      if (buf <> dstText) then
        Raise('То что прочитали и то что записали не совпадает!');
      Result := true;            
    finally
      Utilities.FileClose( fileHandle );
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 
      DbgVarValueEx([fileName, srcText, dstText, fileHandle, writedBytes, readedBytes, buf], ['fileName', 'srcText', 'dstText', 'fileHandle', 'writedBytes', 'readedBytes', 'buf']),
      pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE: Общие
  TYPE: Общие  DESC: Синхронизация, типа критической секции на основе лок-файлв
  RESULT:
  REMARK:
}
function EnterCriticalSectionByFile(
  const sectionName : String; // имя секции, будет в имени файла, значит недолжно использоваться всяких спецсимволов
  const timeOut : integer = -1; // таймаут, после которого возвращаетсяуправление (-1 - ждем бесконечно)
  const timeToWait : integer = 300
) : boolean;
  const
    FUNCTION_NAME = 'EnterCriticalSectionByFile';      
  var
    fileName, fileVar, str, LOCK_STR, UNLOCK_STR, pathToFile : String;
    endTime : integer;
begin
  try
    Result := false;
    LOCK_STR := 'Critical section is locked by ' + CompName;
    UNLOCK_STR := 'Critical section is unlocked';
    pathToFile := IncludeTrailingBackslash(SynchroObjectsParams('GET', SO_ALL_SHARED_PATH));
    fileName := pathToFile + sectionName + '.tc_lock_file';
    //
    {  если файла нет то создаем его разлоченным }
    if NOT FSO.FileExists(fileName) then
      try
        WriteTextToFile(fileName, UNLOCK_STR);
      except
        Log.Message(FUNCTION_NAME + ': Исключение при создании файла', ExceptionMessage, pmNormal, GetLogAttr('EXCEPTION'));
      end;  

    endTime := Win32API.GetTickCount + timeOut;
    {  крутимся пока не истекло время или пока не залочили файл }
    repeat
      try 
        str := GetFileBody(fileName);        
      except
        Log.Message(FUNCTION_NAME + ': Исключение в цикле. Блок 1', ExceptionMessage, pmNormal, GetLogAttr('EXCEPTION'));
      end;    
      if (str = UNLOCK_STR) then
      begin  {  пытаемся залочить файл }
        try         
          Result := _CS_TryChangeFileText(fileName, UNLOCK_STR, LOCK_STR);
        except
          Log.Message(FUNCTION_NAME + ': Исключение в цикле. Блок 2', ExceptionMessage, pmNormal, GetLogAttr('EXCEPTION'));
        end;
      end  
      else 
        Result := (str = LOCK_STR); 
      if NOT Result then Delay(timeToWait);
    until ((timeOut <> -1) AND (Win32API.GetTickCount > endTime)) OR Result;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Синхронизация, типа критической секции на основе лок-файлв
  RESULT:
  REMARK:
}
function LeaveCriticalSectionByFile(
  const sectionName : String // имя секции, будет в имени файла, значит недолжно использоваться всяких спецсимволов
) : boolean;
  const
    TIME_TO_UNLOCK = 5*60*1000;
    TIME_TO_WAIT = 500;
    FUNCTION_NAME = 'LeaveCriticalSectionByFile'; 
  var
    fileName, fileVar, UNLOCK_STR, LOCK_STR, pathToFile : String;
    endTime : integer;
begin
  try
    Result := false;
    LOCK_STR := 'Critical section is locked by ' + CompName;
    UNLOCK_STR := 'Critical section is unlocked';    
    pathToFile := IncludeTrailingBackslash(SynchroObjectsParams('GET', SO_ALL_SHARED_PATH));
    fileName := pathToFile + sectionName + '.tc_lock_file';
    //
    if EnterCriticalSectionByFile(sectionName, 0) then
    begin {пытаемся разлочить файл }
      endTime := Win32API.GetTickCount + TIME_TO_UNLOCK;
      repeat
        try          
          Result := _CS_TryChangeFileText(fileName, LOCK_STR, UNLOCK_STR);        
        except
          Log.Warning(FUNCTION_NAME + ': Исключение при разлочке файла', ExceptionMessage);
        end;
        if NOT Result then Delay(TIME_TO_WAIT);  
      until Result OR (Win32API.GetTickCount > endTime);  
    end;  
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function SynchroEvent(
  whatToDo : String;  
  eventName : String; // bvz event'а НЕ должно быть знаков, недопустимых в нимени файла!!!
  waitTimeOut : integer = -1
): OleVariant;
  const
    FUNCTION_NAME = 'SynchroEvent';
    DELAY_TIME = 500;
  var
    sharedPath;
    eventFileName1, eventFileName2;
    endTime;
    is1Exists, is2Exists;    
begin
  try
    whatToDo := AnsiUpperCase(whatToDo);
  
    sharedPath := IncludeTrailingBackslash(SynchroObjectsParams('get', SO_ALL_SHARED_PATH));
    eventFileName1 := sharedPath + eventName + '.event_file_1';
    eventFileName2 := sharedPath + eventName + '.event_file_2';
    is1Exists := Utilities.FileExists(eventFileName1);
    is2Exists := Utilities.FileExists(eventFileName2);
    
    case whatToDo of
      'SET': 
        begin
          if NOT is1Exists then
          begin
            AppendFile(eventFileName1, '');
            Delay((DELAY_TIME*3) div 2);
          end;
          if NOT is2Exists then AppendFile(eventFileName2, '');          
        end;
      'RESET': 
        begin
          if is1Exists then Utilities.DeleteFile(eventFileName1);
          if is2Exists then Utilities.DeleteFile(eventFileName2);
        end;
      'WAIT':
        begin
          endTime := Win32API.GetTickCount() + waitTimeOut; 
          repeat
            if NOT is1Exists then
            begin
              is1Exists := Utilities.FileExists(eventFileName1);
              if NOT is1Exists then Delay(DELAY_TIME);
            end;
            if is1Exists AND (NOT is2Exists) then
              is2Exists := Utilities.FileExists(eventFileName2);
            //   
            Result := is1Exists AND is2Exists;                      
          until Result OR ((waitTimeOut <> -1) AND (Win32API.GetTickCount() > endTime));                      
        end;
    else
      Raise('whatToDo не распознан!');
    end;    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function SynchroPoint(
  whatToDo : String;
  syncPointName : String; // Имя точки синхронизации, НЕ должно быть знаков, недопустимых в нимени файла!!!
  param : OleVariant = -1 // если операция SYNCHRONIZE - то таймаут; ечли SET MIN QUORUM - то значение
): OleVariant;
  const
    FUNCTION_NAME = 'SynchroPoint';
    SP_SYNCHRONIZING = 1;
    SP_NOT_SYNCHRONIZING = 2;
    SP_QUORUM_DELTA_IGNORED = -1;
    SP_MIN_QUORUM_IGNORED = -1;
  var
    sharedPath : String;
    csName : String;
    mapComps;
    mapFileName : String;
    eventName, forceQuorumEvent, forcingQuorumCompleteEvent : String;
    compStates, compNames;
    i, notSyncedYet, alwaysSynced, waitTimeOut : integer;
    isAllSynchronized, isForceQuorum : boolean;
    quorumDelta, minQuorum, minQuorumParamName;
    isUsingQuorumDelta, isUsingMinQuorum;
begin
  try
    Result := false;
    isForceQuorum := false;
    whatToDo := AnsiUpperCase(whatToDo);
    syncPointName := AnsiUpperCase(syncPointName);
    waitTimeOut := param; 
  
    sharedPath := IncludeTrailingBackslash(SynchroObjectsParams('get', SO_ALL_SHARED_PATH));
    csName := FUNCTION_NAME + '.cs_for_' + syncPointName;
    mapFileName := sharedPath + FUNCTION_NAME + '.map_for_' + syncPointName;
    eventName := FUNCTION_NAME + '.event_for_' + syncPointName;
    
    quorumDelta := SynchroObjectsParams('get', SO_SP_QUORUM_DELTA, SP_QUORUM_DELTA_IGNORED);
    isUsingQuorumDelta := (quorumDelta <> SP_QUORUM_DELTA_IGNORED);     
    forceQuorumEvent := FUNCTION_NAME + '.event_for_force_quorum_for' + syncPointName;
    forcingQuorumCompleteEvent := FUNCTION_NAME + '.event_for_forcing_quorum_complete_for' + syncPointName;
    minQuorumParamName := FUNCTION_NAME + '_minQuorumParamName_' + syncPointName;
    
    minQuorum := GetGlobalParam(
      minQuorumParamName,
      SynchroObjectsParams('get', SO_SP_MIN_QUORUM, SP_MIN_QUORUM_IGNORED)
    );
    isUsingMinQuorum := (minQuorum <> SP_MIN_QUORUM_IGNORED);   
    
    case whatToDo of
      'SET MIN QUORUM' :
        begin
          SetGlobalParam(minQuorumParamName, param);
        end;
      'IS REGISTERED' :
        begin
          if EnterCriticalSectionByFile(csName) then
            try
              Map(mapComps, 'load from file', mapFileName);
            finally
              LeaveCriticalSectionByFile(csName);
            end;
          Result := VarType(Map(mapComps, 'get', CompName)) <> varEmpty;
        end;
      'REGISTER' : // регистрация машины для участия точке синхронизации
        // выполняем проверку "а не регистрировались мы уже?"
        if NOT GetGlobalParam(FUNCTION_NAME + syncPointName, false) then
        begin
          if EnterCriticalSectionByFile(csName) then
            try
              Map(mapComps, 'load from file', mapFileName);
              Map(mapComps, 'put', CompName, SP_NOT_SYNCHRONIZING);
              Map(mapComps, 'save to file', mapFileName);
              SetGlobalParam(FUNCTION_NAME + syncPointName, true);
              Result := true;
            finally
              LeaveCriticalSectionByFile(csName);
            end;
        end
        else
          Result := true;  
      'UNREGISTER' :
        if GetGlobalParam(FUNCTION_NAME + syncPointName, false) then
        begin
          if EnterCriticalSectionByFile(csName) then
            try
              Map(mapComps, 'load from file', mapFileName);
              Map(mapComps, 'clear by key', CompName);
              Map(mapComps, 'save to file', mapFileName);
              SetGlobalParam(FUNCTION_NAME + syncPointName, false);
              Result := true;
            finally
              LeaveCriticalSectionByFile(csName);
            end;
        end
        else
          Result := true;          
      'SYNCHRONIZE' : // ждем пока все зарегистрировавшиеся не войдут в точку синхронизации
        if GetGlobalParam(FUNCTION_NAME + syncPointName, false) then          
        begin // если мы уже зарегистрировались
          repeat
            if EnterCriticalSectionByFile(csName) then
              try
                // считываем мапу состояний машин
                Map(mapComps, 'load from file', mapFileName);
                // для текущей машины устанавливаем состояние синхронизируется
                Map(mapComps, 'put', CompName, SP_SYNCHRONIZING);
                
                if isForceQuorum then
                begin // необходимо форсировать достижение кворума                  
                  compStates := Map(mapComps, 'values array', nil);
                  // подсчитываем количество машин, которые еще не достигли точки синхронизации
                  notSyncedYet := 0;
                  for i := VarArrayLowBound(compStates, 1) to VarArrayHighBound(compStates, 1) do
                    if (compStates[i] = SP_NOT_SYNCHRONIZING) then
                      Inc(notSyncedYet);
                  if (notSyncedYet <= quorumDelta) 
                  then // если количество несинхронизирующихся меньше или равно количеству, которое можно выкинуть для достижения кворума, то выкидываем из точки синхронизации всех кто не достиг синхронизации                  
                    Map(mapComps, 'clear by value', nil, SP_NOT_SYNCHRONIZING)
                  else // а если нет, то значит форсирование не удалось, и все машины сбрасываем в состояние "несинхронизируется"
                  begin
                    compNames := Map(mapComps, 'keys array', nil);
                    for i := VarArrayLowBound(compNames, 1) to VarArrayHighBound(compNames, 1) do
                      Map(mapComps, 'put', compNames[i], SP_NOT_SYNCHRONIZING);                    
                  end;     
                end
                else
                  if isUsingQuorumDelta then
                    SynchroEvent('SET', forceQuorumEvent);
                
                // определяем, все ли в настоящий момент ожидают синхронизации
                compStates := Map(mapComps, 'values array', 1);                
                isAllSynchronized := true;
                alwaysSynced := 0;
                for i := VarArrayLowBound(compStates, 1) to VarArrayHighBound(compStates, 1) do
                  if (compStates[i] = SP_SYNCHRONIZING) then
                    Inc(alwaysSynced)
                  else                
                    isAllSynchronized := false;
                // достигли ли минимального кворума (если задано такое понятие)                
                if isUsingMinQuorum then
                  isAllSynchronized := (alwaysSynced >= minQuorum); 
                // если все синхронизировались ...
                if isAllSynchronized then
                begin
                  // ... то сбрасываем тех, кто синхронизировался
                  compNames := Map(mapComps, 'keys array', nil);
                  compStates := Map(mapComps, 'values array', nil);
                  for i := VarArrayLowBound(compNames, 1) to VarArrayHighBound(compNames, 1) do
                    if (compStates[i] = SP_SYNCHRONIZING) then
                      Map(mapComps, 'put', compNames[i], SP_NOT_SYNCHRONIZING);                                   
                end; 
                // пишем мапу опять в файл
                Map(mapComps, 'save to file', mapFileName);

                // дергаем event если все синхронизированы, иначе сбрасываем
                if isAllSynchronized then
                  SynchroEvent('SET', eventName)
                else
                  SynchroEvent('RESET', eventName);
                 
                if isForceQuorum then
                  SynchroEvent('SET', forcingQuorumCompleteEvent); // форсирование кворума завершено
              finally
                LeaveCriticalSectionByFile(csName);
              end;

            if (NOT isForceQuorum) then
            begin // стандартный вызов  
              // ждем ...          
              if NOT isAllSynchronized then
                Result := SynchroEvent('WAIT', eventName, waitTimeOut) // ждем на event пока его не дернут
              else // типа оптимизация, зачем нам ждать на event'е который сами только что дернули
                Result := isAllSynchronized;
            
              if (NOT Result) AND (isUsingQuorumDelta) then
                if SynchroEvent('WAIT', forceQuorumEvent, 0) AND EnterCriticalSectionByFile(csName, 0) then 
                begin // тот кто сюда попал будет форсировать достижение кворума
                  SynchroEvent('RESET', forceQuorumEvent);
                  SynchroEvent('RESET', forcingQuorumCompleteEvent);
                  isForceQuorum := true;            
                end
                else // а тот кто попал сюда будет ждать результатов форсирования достижения кворума
                  Result := 
                    SynchroEvent('WAIT', forcingQuorumCompleteEvent, Options.Run.Timeout) AND
                    SynchroEvent('WAIT', eventName, 0);
            end
            else
            begin // это вызов того, кто совершает форсирование
              isForceQuorum := false;
              Result := SynchroEvent('WAIT', eventName, 0);
            end;  
          until Result OR (NOT isForceQuorum);

          // если синхронизация не удалась и quorumDelta = 0, то переводим машину в состояние "несинхронизируется", т.к. в таком слуаче никто кроме нее самой это не сделает          
          if (NOT Result) AND (NOT isUsingQuorumDelta) then
            if EnterCriticalSectionByFile(csName) then
            try
              Map(mapComps, 'load from file', mapFileName);
              Map(mapComps, 'put', CompName, SP_NOT_SYNCHRONIZING);
              Map(mapComps, 'save to file', mapFileName);
            finally
              LeaveCriticalSectionByFile(csName);
            end;
          
        end
        else
          Raise('Не зарегистрировались в точке синхронизации!');
    else
      Raise('whatToDo не распознан!');
    end;    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE: Работа с комбобоксом
  DESC: Устанавливает нужное значение в комбобоксе тулбара 
  RESULT: True, если установили
  REMARK: Перебирает всe значения пока не найдет нужное
    !!!!!!!МОЖЕТ БЫТЬ РЕГИСТРОЧУВСТВИТЕЛЬНА!!!!!!!!!
}
function SelectInCombobox(
  const comboBoxWnd : OleVariant;
  const itemName : String
) : boolean;
  const
    FUNCTION_NAME = 'SelectInCombobox';
  var
    oldItemIndex, handle, i, countOfRetries : integer;
    cbElem, vgSceneObj, currValue, oldValue, treeWnd : OleVariant;
begin
  try
    Result := false;
    if NOT IsExists(comboBoxWnd) then Raise('Комбобокс не существует');
    if IsSupported(comboBoxWnd.NativeDelphiObject, 'Enabled') then
    begin
      if NOT comboBoxWnd.NativeDelphiObject.Enabled then 
        Raise('Комбобокс задизейблен');
    end
    else
      if NOT comboBoxWnd.Enabled then 
        Raise('Комбобокс задизейблен');

    if IsSupported(comboBoxWnd, 'VCLClass') and StringCompare('TvgComboBox', comboBoxWnd.VCLClass) then
    begin // комбобокс VgScene
      cbElem := FindWindowByPath(comboBoxWnd, 'VCLCLASS:=TvgScrollContent;MAXDEPTH:=3|VCLCLASS:=TvgText;Text:=' + itemName + ';MAXDEPTH:=3|VCLCLASS:=TvgListBoxItem;MAXDEPTH:=-2', false);
      if not IsExists(cbElem) then
        Raise('В списке комбобокса не найден выбираемый элемент "' + itemName + '"');

      vgSceneObj := FindParentVgSceneObj(comboBoxWnd);
      if not IsExists(vgSceneObj) then
        Raise('Родительский объект VgScene не найден');

      oldItemIndex := -1;
      if not ClickOnVgSceneObject(comboBoxWnd, 'IsClickByAbsXY:=false') then
        Raise('Не получилось кликнуть по комбобоксу VgScene');

      Sys.Keys('[Home]');
      while (comboBoxWnd.ItemIndex <> cbElem.Index) and (comboBoxWnd.ItemIndex <> oldItemIndex) do
      begin  
        oldItemIndex := comboBoxWnd.ItemIndex;
        Sys.Keys('[Down]');
      end;
      Sys.Keys('[Enter]');

      Result := comboBoxWnd.ItemIndex = cbElem.Index;
    end
    else
    if StringCompare('TComboBox', comboBoxWnd.WndClass ) then
    begin // комбобокс со стандартными методами
      if NOT StringCompare('*' + EndOfLine + itemName + EndOfLine + '*', EndOfLine + comboBoxWnd.wItemList + EndOfLine) then
      begin
        Log.Error('Не найден такой элемент', itemName + EndOfLine + EndOfLine + comboBoxWnd.wItemList);
        Exit;
      end;
      comboBoxWnd.ClickItem(itemName);
      Result := true;
    end
    else
    if StringCompare('TvtComboBoxQS', comboBoxWnd.WndClass) then
    begin
      // раскрываем комбобокс
      comboBoxWnd.Click(comboBoxWnd.Width-8, comboBoxWnd.Height div 2);
      // ищем дерево со значениями
      ProcessKiller(FUNCTION_NAME, 'START', Options.Run.Timeout, comboBoxWnd);
      try  
        treeWnd := GetProcessFromWnd(comboBoxWnd).WaitWindow('TSubTree', '*', -1, Options.Run.Timeout div 100);
      finally
        ProcessKiller(FUNCTION_NAME, 'STOP');
      end;
      if NOT IsExists(treeWnd) then Raise('Не смогли раскрыть комбобокс!');
      // позиционируемся
      Result := Position_Internal(treeWnd, itemName, DELIM_CHAR, true, 'IsFocusFolderTree:=false;IsPressHome:=true');
      // выбираем
      if Result then
        Sys.Keys('[Enter]');      
    end
    else
    if(StringCompare('TvcmComboBox', comboBoxWnd.WndClass ) AND IsSupported(comboBoxWnd, 'IsList') AND (NOT comboBoxWnd.IsList)) then
    begin // комбобокс оболочки, скорее всего с деревом
      // раскрываем комбобокс
      comboBoxWnd.Click(comboBoxWnd.Width-8, comboBoxWnd.Height div 2);
      // ищем дерево со значениями
      ProcessKiller(FUNCTION_NAME, 'START', Options.Run.Timeout, comboBoxWnd);
      try  
        treeWnd := GetProcessFromWnd(comboBoxWnd).WaitWindow('TnscSubTree', '*', -1, Options.Run.Timeout div 100);
      finally
        ProcessKiller(FUNCTION_NAME, 'STOP');
      end;
      if NOT IsExists(treeWnd) then Raise('Не смогли раскрыть комбобокс!');
      // позиционируемся
      Result := Position_Internal(treeWnd, itemName, DELIM_CHAR, true, 'IsPressHome:=true');
      // выбираем
      if Result then
        Sys.Keys('[Enter]');      
    end
    else
    if StringCompare('TnscTreeComboWithHistoryAndOperations', comboBoxWnd.WndClass) then
    begin//Комбобокс БП
      // раскрываем комбобокс
      comboBoxWnd.SetFocus;
      Sys.Keys('[Down]');
      // ищем дерево со значениями
      ProcessKiller(FUNCTION_NAME, 'START', Options.Run.Timeout, comboBoxWnd);
      try  
        treeWnd := GetProcessFromWnd(comboBoxWnd).WaitWindow('TnscSubTree', '*', -1, Options.Run.Timeout div 100);
      finally
        ProcessKiller(FUNCTION_NAME, 'STOP');
      end;
      if NOT IsExists(treeWnd) then Raise('Не смогли раскрыть комбобокс!');
      // позиционируемся
      Result := Position_Internal(treeWnd, itemName, DELIM_CHAR, true, 'IsPressHome:=true;IsFocusFolderTree:=false');
      // выбираем
      if Result then
        Sys.Keys('[Enter]');    
    end
    else // оболочечный извратный комбобокс
    begin
      i := 0;
      oldItemIndex := comboBoxWnd.ItemIndex;
      comboBoxWnd.SetFocus;
      handle := comboBoxWnd.Handle;
      if (oldItemIndex = -1) AND (common.GetWindowText(handle) = '') then Raise('Неправильный индекс, или комбобокс, видимо, пуст.');
      comboBoxWnd.ItemIndex := 1;
      comboBoxWnd.ItemIndex := 0;
      comboBoxWnd.ItemIndex := 1;
      comboBoxWnd.ItemIndex := 0;
      currValue := '';
      countOfRetries := 0;
      repeat
        oldValue := currValue;
        currValue := common.GetWindowText(handle);
        Result := StringCompare(itemName, currValue ); 
        if Result then Exit;
        i := i + 1;
        comboBoxWnd.ItemIndex := i;
        if (currValue = oldValue) then
          Inc(countOfRetries)
        else
          countOfRetries := 0;
      until (comboBoxWnd.ItemIndex=0) OR (countOfRetries > 4);
      comboBoxWnd.ItemIndex := oldItemIndex;
    end;  
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, 'itemName: "' + itemName + '"' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Общие
  DESC: Посылает письмо с помощью blat.exe
  RESULT: True, если blat был найден и удалось его запустить (но не факт что письмо ушло)
  REMARK:
}
function SendMailByBlat(
  const fromAddr : String; // от чьего адреса будет послано письмо
  const toAddr : String; // кому будет послано письмо (список, разделенный запятыми)
  const subject : String; // тема письма
  const messageBody : String; // тело сообщения (в кодировке win-1251)
  const attachment : String = ''; // список файлов, разделенных запятой (имена с путями лучше заключать в кавычки, чтобы не было проблем с пробелами)  
  const isHTMLMessage : boolean = false;
  const smtpServer : String = 'smtp.garant.ru'; // smtp-server
  pathToBlat : String = 'default' // полный путь к blat.exe
) : boolean;
  var 
    commandStr, fileWithMessage : String;
begin
  try
    Result := false; 
    if (toAddr = '') then Raise('Адрес получателя пуст!');
    if pathToBlat = 'default' then
      pathToBlat := GetPathTo(PATH_TO_UTILS) + 'Blat\Blat.exe';
    if NOT Utilities.FileExists(pathToBlat) then
      Raise('Blat.exe не найден по пути "' + pathToBlat + '"');
    fileWithMessage := IncludeTrailingBackslash(GetTempDirectory) + GetRandomString(16);
    BuiltIn.SaveStrToFile(fileWithMessage, messageBody);
    commandStr := '"' + fileWithMessage + '" -to ' + toAddr + ' -f ' + fromAddr + ' -subject "' + subject + '" -server ' + smtpServer + ' -charset windows-1251';
    if attachment <> '' then commandStr := commandStr + ' -attach ' + attachment;
    if isHTMLMessage then commandStr := commandStr + ' -html';
    Result := Win32API.WinExec('"' + pathToBlat + '" ' + commandStr, Win32API.SW_HIDE) >= 32;
    //ShellExecute(nil, 'open', pathToBlat, commandStr, ExtractFilePath(pathToBlat), Win32API.SW_HIDE) >= 32;      
  except
    Log.Message('SendMailByBlat: ' + ExceptionMessage, 'fromAddr: "' + VarToStr(fromAddr) + '"; ' + EndOfLine + 'toAddr: "' + VarToStr(toAddr) + '"; ' + EndOfLine + 'subject: "' + VarToStr(subject) + '"; ' + EndOfLine + 'messageBody: "' + VarToStr(messageBody) + '"; '+ EndOfLine + 'attachment: "' + VarToStr(attachment) + '"; ' + EndOfLine + 'smtpServer: "' + VarToStr(smtpServer) + '"; ' +  'pathToBlat: "' + VarToStr(pathToBlat) + '";',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;               
end;


var timeMeasureVariable794272479 : OleVariant; // глобальная переменная для меряния временных задержек операций
{
  TYPE: Общие 
  DESC: Засекает время выполнения операции
  RESULT:
  REMARK:
}
procedure StartTimeMeasure(
  const opName : String; // имя операции
  const isLogMessage : boolean = true // писать ли в лог результат  
);
  var currTime : integer;
begin
  try
    if isLogMessage then 
      Log.Message('Засекаем время выполнения операции "' + opName + '", операция началась в ' + Utilities.FormatDateTime('dd-mm-yyyy hh:nn:ss' , Utilities.Now));
    Map(timeMeasureVariable794272479, 'put', opName, Win32API.GetTickCount);  
  except
    Log.Message('StartTimeMeasure: ' + ExceptionMessage, 'opName: "' + VarToStr(opName) + '"' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие 
  DESC: Оканчивает засекать время выполнения операции
  RESULT:
  REMARK:
}
function EndTimeMeasure(
  const opName : String; // имя операции
  const isLogMessage : boolean = true; // писать ли в лог результат
  const comment : String = '';  
  const csvFileName : String = ''
) : integer;
  const
    CSV_HEADER = 'Время окончания измерения;Название операции;Длительность операции (мсек);Примечание';
  var
    res : OleVariant;
    prevRes : integer;
begin
  prevRes := Win32API.GetTickCount;
  try
    { вычисляем время операции } 
    res := Map(timeMeasureVariable794272479, 'get', opName);
    if NOT IsEmpty(res) then
    begin
      Map(timeMeasureVariable794272479, 'clear by key', opName );
      res := prevRes - res;
      Result := res;
      if isLogMessage then
        Log.Message('Операция "' + opName + '" заняла ' + IntToStr(res) + ' мсек. (' + IntToStr(res div 60000) + ' мин ' + IntToStr((res mod 60000) div 1000) + ' сек), операция завершилась в ' + Utilities.FormatDateTime('dd-mm-yyyy hh:nn:ss' , Utilities.Now), comment);
      if csvFileName <> '' then
        AppendFile(csvFileName, Utilities.FormatDateTime('dd-mm-yyyy hh:nn:ss,zzz' , Utilities.Now) + ';' + opName + ';' + IntToStr(res) + ';' + comment, CSV_HEADER );
    end
    else
      Result := -1;  
  except
    Log.Message('EndTimeMeasure: ' + ExceptionMessage, 'opName: "' + VarToStr(opName) + '"' ,  pmNormal, GetLogAttr('EXCEPTION'));
  	Result := -1;
    CommonExceptionHandler;    
  end;
end;

{
  TYPE:
  DESC: Выполняет операцию над каждым элементом массива
  RESULT:
  REMARK: Для каждого элемента массива (и подмассивов) выполняется operation
      Если isApply=true, то вычисленное operation присваивается элементу массива
      иначе просто выполняется.
      operation выполняется над arr[i]
      Например:
        ForEachElement(x, 'Log.Message(arr[i])' );  - распечатает все элементы массива
        ForEachElement(x, ' AnsiUpperCase(arr[i])', true ); - приведет все элементы массива к верхнему регистру
}
function ForEachElement(
  var arr : OleVariant;
  const operation : String;
  const isApply : boolean = true
) : OleVariant;
  var
    i : integer;
    temp : OleVariant;
begin
  try
    if IsArray(arr) then
      for i := VarArrayLowBound(arr, 1) to VarArrayHighBound(arr, 1) do
        if IsArray(arr[i]) then
        begin
          temp := arr[i];
          arr[i] := ForEachElement(temp, operation, isApply);
        end  
        else
          if isApply then 
            arr[i] := Evaluate(operation)
          else
            Evaluate(operation);
    Result := arr;      
  except
    Log.Message('ForEachElement: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Общие
  DESC: 
  RESULT: Формирует результирующую строку виде суммы исходной строки count раз 
  REMARK:
}
function RepeatString(
  const str: String;
  const count : integer
);
  var i : integer;
begin
  try
    Result := '';
    for i := 1 to count do Result := Result + str;
  except
    Log.Message('RepeatString: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

{
  TYPE: Общие
  DESC: 
  RESULT: Заменяет 2 строки кода.
  REMARK:
}
function ErrorResult(errorstring: string = ''): boolean;
begin
  if errorstring <> '' then
    Log.Error(errorstring, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  Result := false;
end;

{
  TYPE: Общие
  DESC: 
  RESULT: Формирует паузу для функции Sys.Keys
  REMARK:
}
function KeyPause: string;         
begin
  Result := '[P300]';
end;

{
  TYPE: Общие
  DESC: 
  RESULT: Отдает текстовое содержимое текущего поля ввода в фокусе   
  REMARK:
}
function GetValueFromEdit: string;
begin
  Result := CopyToClipboard(nil, 'ALL');
  if Result = '' then
    Log.Warning('Возможно НЕ работает копирование в буфер, буфер обмена пуст!');
end;

{
  TYPE: Общие
  DESC: 
  RESULT: Отдает текстовое содержимое поля ввода контекста БП, если БП закрыт вернет пустую строку
  REMARK:
}
function GetValueFromBaseSearch: string;
var w;
begin
  try
    Result := '';
    w := GetFromBaseSearch('КОМБОБОКС "БАЗОВЫЙ ПОИСК"');
    if not IsExists(w) then
      Raise('Не найден КОМБОБОКС "БАЗОВЫЙ ПОИСК"');
    Result := common.GetWindowText(w);      
  except
    Log.Message('GetValueFromBaseSearch: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;   
end;

var gbl_GlobalParamList : OleVariant;
{
  TYPE: Работа со строками; Работа с массивами
  DESC: Вытаскивает из глобального массива значение параметра
  RESULT: Возвращает значение по параметру
}
function GetGlobalParam(
  const paramName : String;  // имя параметра
  const defaultValue : OleVariant = '' // значение, которое будет возвращено, если параметр не найден
) : OleVariant; // значение 
begin
  try
    Result := GetNonEmpty(Map(gbl_GlobalParamList, 'get', Utilities.AnsiUpperCase(paramName) ), defaultValue);
  except
    Log.Message('GetGlobalParam: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;   
end;

{
  TYPE: Работа со строками; Работа с массивами
  DESC: Добавляем в глобальный массив значение параметра
  RESULT: 
}
function SetGlobalParam(
  const paramName : String;  // имя параметра
  const value : OleVariant = '' // значение, которое будет присвоено параметру
) : OleVariant; 
begin
  try
    Map(gbl_GlobalParamList, 'add', Utilities.AnsiUpperCase(paramName), value);
    Result := gbl_GlobalParamList;
  except
    Log.Message('SetGlobalParam: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
    CommonExceptionHandler;
  end;   
end;

var 
  gbl_Perm_ChangeDatabase;
  gbl_Perm_StopServer;
  gbl_Perm_UseMSOffice;
  gbl_Perm_ShareGarantFolders;      
  gbl_PermFlag : boolean;
{
  TYPE:
  DESC: 
  RESULT:
  REMARK:
}
function Permissions(
  whatToDo : String;
  name : String;
  const value : OleVariant = false
) : boolean;
begin
  try
    Result := false;    
    whatToDo := AnsiUpperCase(whatToDo);
    name := AnsiUpperCase(name);

    case whatToDo of
      'RESET FLAG' : gbl_PermFlag := false;
      'RAISE FLAG' : gbl_PermFlag := false;
      'GET FLAG'   : Result := GetNonEmpty(gbl_PermFlag, false);
      
      'GET' :
        case name of
          'CHANGE DATABASE'       : Result := GetNonEmpty(gbl_Perm_ChangeDatabase,      true);
          'STOP SERVER'           : Result := GetNonEmpty(gbl_Perm_StopServer,          true);
          'USE MSOFFICE'          : Result := GetNonEmpty(gbl_Perm_UseMSOffice,         true);
          'SHARE GARANT FOLDERS'  : Result := GetNonEmpty(gbl_Perm_ShareGarantFolders,  true);
        else
          Raise('Неизвестное разрешение!');
        end;
      'SET' :
        case name of
          'CHANGE DATABASE'       : gbl_Perm_ChangeDatabase := value;
          'STOP SERVER'           : gbl_Perm_StopServer := value;
          'USE MSOFFICE'          : gbl_Perm_UseMSOffice := value;
          'SHARE GARANT FOLDERS'  : gbl_Perm_ShareGarantFolders := value;
        else
          Raise('Неизвестное разрешение!');
        end;      
      'CHECK' :
        if Permissions('GET', name) = false then
        begin
          Permissions('RAISE FLAG', name);
          Raise(EX_PERMISSSIONS_CHECK_FAILED_PREFIX + '"' + name + '"');
        end;
        
      {'SOFT CHECK' :
        if Permissions('GET', name) = false then
        begin
          Permissions('RAISE FLAG', name);
          Raise(EX_PERMISSIONS_CHECK_FAILED_SOFT + '"' + name + '"');
        end;}
    else
      Raise('Неизвестный параметр whatToDo!');  
    end;  
  except
    Log.Message('Permissions: ' + ExceptionMessage, 'whatToDo: "' + VarToStr(whatToDo) + '"; ' + EndOfLine + 'name: "' + VarToStr(name) + '"; ' ,  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;    
  end;               
end;


{
  TYPE: Работа со профилями
  DESC: Возвращает элемент массива профилей по p_index
  RESULT:
  REMARK: По хорошему, надо передавать константы, т.к. при запросе
  профайлера с 
}
// Константы для профайлеров
const
  PR_DOCUMENT = 0; // Профайлер документа
  PR_PPR = 1; // Профайлер КЗ ППР
  PR_LIST = 2; //Профайлер списка

function GetProfiler (
  p_index : Integer // Индекс профайлера
): OleVariant;
var
  w;
begin
  try
    Result := NonExObj;
    w := GetMainWindow;
    if IsExists(w) then
      Result := w.Profilers.Profiler[p_index];
  except
    Result := NonExObj;
    Log.Error('GetProfiler: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end;          
end;

{
  TYPE: Общие
  DESC: Позиционируется в win32 дереве. От стандартной отличается регистронечувствительностью
  RESULT: Удалось или не удалось позиционироваться на указанном пути
  REMARK:
}
function PositionInWin32Tree(
  const tree : OleVariant; // дерево
  const path : String // путь
) : boolean; // удалось или нет
  var
    elements : OleVariant;
    currElement, clickPath : String;
    i, j : integer;
    flag : boolean;
begin
  try
    Result := false;
    clickPath := '';
    elements := String2Array(path, '\');
    
    // перебираем элементы пути
    for i := VarArrayLowBound(elements,1) to VarArrayHighBound(elements,1) do
    begin
      currElement := elements[i];
      flag := false;
      if i = VarArrayLowBound(elements,1) then
      begin        // позиционируемся на корневом элементе
        for j := 0 to tree.wRootItemCount do
          if StringCompare( currElement, tree.wRootItem[j] ) then
          begin
            flag := true;
            clickPath := clickPath + '|[' + IntToStr(j) + ']';
            break;
          end;
      end
      else
      begin // позиционируемся на промежуточном элементе
        for j := 0 to tree.wItemCount do
          if StringCompare( currElement, tree.wItem[j] ) then
          begin
            flag := true;
            clickPath := clickPath + '|[' + IntToStr(j) + ']';
            break;
          end;                
      end;
      if NOT flag then Exit;
      tree.ClickItem(clickPath);          
    end;
    Result := flag;    
  except
    Log.Message('PositionInWin32Tree: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;  

{
  TYPE: Общие
  DESC: Проверка наличия голубой рамки в указаном окне
  RESULT:
  REMARK:
}
function IsBlueRectExists(
  sourceWnd: OleVariant = nil  
): boolean;
var
  x, y;
begin
  try
    Result := true;
    if not FindPicture(sourceWnd, 'blue_rect_left_up.bmp', x, y) then
      Raise('Не найден левый верхний угол голубой рамки!');
    if not FindPicture(sourceWnd, 'blue_rect_right_down.bmp', x, y) then
      Raise('Не найден правый нижний угол голубой рамки!');
  except
    Result := false;
    Log.Message('IsBlueRectExists: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  end;          
end;

{
  TYPE: Общие
  DESC: Корректное получение свойства buttonWnd.Enabled
  RESULT:
  REMARK:
}
function IsButtonEnabled(
  const buttonWnd: OleVariant 
): Boolean;
var 
  itemPathToClick : String;
begin
  Result := false;
  if NOT IsExists(buttonWnd) then
    Log.Error('Кнопка не найдена!')
  else
  try
    // пытаемся получить свойство Native.Enabled , проверить его наличие IsSupported не получается
    Result := buttonWnd.NativeDelphiObject.Enabled;
  except
    Result := IsSupported(buttonWnd, 'Enabled') and buttonWnd.Enabled; // если будет глючить, надо будет поправить на true
  end;  
end; 

{
  TYPE: Общие
  DESC: Ф-ция возвращает текст статусбара, если что то неудалось, то возвращается пустая строка;
  RESULT:
  REMARK:
}
function GetStatusBarText: string;
var
  statusBar;
begin
  try
    statusBar := GetFromMainWindow('СТАТУСБАР');
    if NOT IsExists(statusBar) then Raise('Не удалось получить СТАТУСБАР');
    result := common.GetWindowText(statusBar.Handle);  
  except
    result := '';
    Log.Message('GetStatusBarText: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Общие
  DESC: Ф-ция возвращает текст статусбара, если что то неудалось, то возвращается пустая строка;
  RESULT:
  REMARK:
}
function GetPrimeStatusBarText: string;
var
  statusBar;
begin
  try
    statusBar :=  F1Prime_GetFromMainWindow('СТАТУСБАР');
    if NOT IsExists(statusBar) then Raise('Не удалось получить СТАТУСБАР в ПРАЙМЕ');
    result := common.GetWindowText(statusBar.Handle);  
  except
    result := '';
    Log.Message('GetStatusBarText: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Работа с массивами
  DESC: Конвертирует массив в строковое представление
  RESULT:
  REMARK:
      Работает только с одномерными массивами
}
function ConvertArrayToString(
  arr : OleVariant; // массив
  format : String = 'ВСЕ В ОДНУ СТРОКУ';
  indent : String = '' // служебная переменная!!!!
) : String;
  const
    ELEM_DELIM = ', ';
  var
    i, currVarType, highBound, lowBound : integer;
    curr : OleVariant;
    oldIndent, elemDelim : String;
    fmtArrBegin, fmtArrEnd, fmtSubArrBegin, fmtSubArrEnd, fmtElemEnd, fmtBeforeFirstElem, fmtAfterLastElem : String;
    isSubArray : boolean;
begin
  try
    if NOT IsArray(arr) then Raise('Параметр arr должен быть массивом!');

    lowBound := VarArrayLowBound(arr, 1);    
    highBound := VarArrayHighBound(arr, 1);
    isSubArray := indent <> '';
    oldIndent := indent;
    indent := oldIndent + '  ';        
    elemDelim := ELEM_DELIM;
    
    case AnsiUpperCase(format) of
      'ВСЕ В ОДНУ СТРОКУ' :
        begin
          fmtArrBegin     := '[';
          fmtArrEnd       := ']';
          fmtSubArrBegin  := '([';
          fmtSubArrEnd    := '])';
          fmtElemEnd      := '';
          fmtBeforeFirstElem := '';
          fmtAfterLastElem := '';
        end;
      'ВЫДЕЛИТЬ ВНЕШНИЙ МАССИВ' :
        begin
          fmtArrBegin     := '[' + EndOfLine + indent;
          fmtArrEnd       := EndOfLine + ']';
          fmtSubArrBegin  := '([';
          fmtSubArrEnd    := '])';
          fmtElemEnd      := '';
          fmtBeforeFirstElem := '';
          fmtAfterLastElem := '';          
        end;
      '1' :
        begin
          fmtArrBegin     := '[';
          fmtArrEnd       := ']';
          fmtSubArrBegin  := '([';
          fmtSubArrEnd    := '])';
          fmtElemEnd      := '';
          fmtBeforeFirstElem := EndOfLine + indent;
          fmtAfterLastElem := EndOfLine + oldIndent;          
        end;                
    else
      Raise('Неизвестный формат');    
    end;    
    if isSubArray then
      Result := fmtSubArrBegin
    else  
      Result := fmtArrBegin;
    for i := lowBound to highBound  do
    begin
      if i = highBound then 
        elemDelim := ''    
      else if i = lowBound then 
        Result := fmtBeforeFirstElem + Result;
        
      curr := arr[i];
      
      case VarType(curr) of
        varInteger, varDouble, varVariant :
          Result := Result + VarConvert(curr, varOleStr) + elemDelim;
        varBoolean :
          Result := Result + Bool2Str(curr) + elemDelim;
        varOleStr  : 
          Result := Result + '''' + StringReplace(curr, '''', '''''', 1) + '''' + elemDelim;
        VAR_VARIANT_ARRAY :
          Result := Result + ConvertArrayToString(curr, format, indent) + elemDelim;
      else
        begin
          Log.Error('Неизвестный тип элемента:' + VarType(curr), 'i= ' + VarToString(i));
          Raise('Неизвестный тип элемента!');
        end;  
      end;
      Result := Result  + fmtElemEnd;
      if i = highBound then Result := Result + fmtAfterLastElem;        
    end;
    if isSubArray then
      Result := Result + fmtSubArrEnd
    else  
      Result := Result + fmtArrEnd;      
       
  except
    Log.Message('ConvertArrayToString: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
    CommonExceptionHandler;
  end;               
end;

function VarConvert(
  const source : OleVariant;
  const toWhat : OleVariant   
) : OleVariant;
  var str;
begin
  try
    VarClear(Result);  
    case toWhat of
      varInteger : Result := VarToInteger(source);
      varOleStr  : Result := VarToString(source);
      varBoolean : Result := VarToBool(source);
    else
      Raise('Неизвестное направление конвертации');          
    end;
  except
    try
      str := 'строковое представление source: ' + VarToString(source);
    except
      str := '';
    end;
    Log.Message('VariantConvert: ' + ExceptionMessage, 'VarType(source): ' + VarToString(VarType(source)) + EndOfLine + 'toWhat: ' + VarToString(toWhat) + EndOfLine + str,  pmNormal, GetLogAttr('EXCEPTION'));
  end;
end;

function DbgVarValue(
  const value : OleVariant;
  const varName : String;
  const isStrValue : boolean = true
) : String;
  var
    vt, valueStr : OleVariant;
begin
  try
    Result := '';
    valueStr := '';
    vt := VarType(value);

    // получаем строковое представление переменной
    if isStrValue then
      try
        case vt of
          varSmallint, 
          varInteger,
          varSingle,
          varDouble,
          varOleStr,
          varVariant,
          varByte :
            valueStr := VarToString(value);
          varBoolean:
            valueStr := Bool2Str(value);
          VAR_VARIANT_ARRAY:
            valueStr := ConvertArrayToString(value);
          varDispatch : // здесь мы считаем что передано окно
            if IsExists(value) AND IsSupported(value, 'FullName') then
              valueStr := GetValue(value, 'FullName');              
        end;
      except    
        valueStr := 'exception while converting :-( . ExceptionMessage: "' + ExceptionMessage + '"';
      end;
    
    if ((vt AND varArray) = varArray) then
    begin
      vt := vt - varArray;
      Result := 'varArray of ';
    end  
    else if ((vt AND varByRef) = varByRef) then
    begin
      vt := vt - varByref;
      Result := 'varByRef to ';
    end;  
      
    case vt of
      varEmpty    : Result := Result + 'varEmpty';
      varNull     : Result := Result + 'varNull';
      varSmallint : Result := Result + 'varSmallint';
      varInteger  : Result := Result + 'varInteger';
      varDouble   : Result := Result + 'varDouble';
      varCurrency : Result := Result + 'varCurrency';    
      varDate     : Result := Result + 'varDate';
      varOleStr   : Result := Result + 'varOleStr';
      varDispatch : Result := Result + 'varDispatch';
      varError    : Result := Result + 'varError';
      varBoolean  : Result := Result + 'varBoolean';
      varVariant  : Result := Result + 'varVariant';
      varUnknown  : Result := Result + 'varUnknown';
      varByte     : Result := Result + 'varByte';
    else
      Result := Result + VarToString(vt);                        
    end;
    
    Result := 
      'Имя: "' + varName + '". '+
      'Тип: "' + Result + '". ' +
      Choose(isStrValue, 'Значение: "' + valueStr + '"', '') + EndOfLine;
  except
    Result := '';
    Log.Message('DbgVarValue: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
  end;
end;

function DbgVarValueEx(
  const values : OleVariant;
  const varNames : OleVariant;
  const isStrValue : boolean = true
) : String;
  const
    FUNCTION_NAME = 'DbgVarValueEx';
  var
    i;    
begin
  try
    Result := '';
    //
    if NOT IsArray(values) then Raise('values должно быть массивом!');
    if NOT IsArray(varNames) then Raise('varNames должно быть массивом!');
    if ArrayLength(values) <> ArrayLength(varNames) then Raise('values и varNames Должны иметь одинаковую длину!');
    //
    for i := 0 to ArrayLength(values)-1 do
      Result := Result + DbgVarValue( GetFromArray(values, i), GetFromArray(varNames, i), isStrValue );
  except
    Result := '';
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
  end;
end;

function CheckObjectParams(
  const obj : OleVariant;
  const propNames : OleVariant;
  const propValues : OleVariant
) : boolean;
  var 
    i : integer;
begin
  try
    Result := true;
    for i := VarArrayLowBound(propNames, 1) to VarArrayHighBound(propNames, 1) do
      Result := Result AND IsSupported(obj, propNames[i]) AND ( ( (VarType(propValues[i]) = varOleStr) AND StringCompare(propValues[i], GetValue(obj, propNames[i])) ) OR ( (VarType(propValues[i]) <> varOleStr) AND (propValues[i] = GetValue(obj, propNames[i])) ) );
  except
    Log.Message('CheckObjectParams: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION')); 
    Result := false;
  end;      
end;

var
  gbl_oTS : integer;
  gbl_MapOfScriptActions;
  gbl_SALockCount : integer;

    
function ScriptAction(
  whatToDo : String;
  param : OleVariant = nil
): OleVariant;
  const
    FUNCTION_NAME = 'ScriptAction';
  var
    actionsArr, action, actionStatus, actionsToUnsetArr : OleVariant;
    i : integer;  
begin
  try
    whatToDo := AnsiUpperCase(whatToDo);
    
    if (VarType(gbl_SALockCount) <> varInteger) then gbl_SALockCount := 0;
    if (VarType(gbl_oTS) <> varDispatch) then VarClear(gbl_oTS);     
      
    
    case whatToDo of
      'RESET' :
        begin
          gbl_SALockCount := 0;
          VarClear(gbl_oTS);
          gbl_MapOfScriptActions := nil;        
        end;
        
      'BEGIN SCRIPT': // перед началом работы скрипта
        begin
          ScriptAction('RESET');
          if IsEqual(param, nil) then Raise('Для этой операции нужно указывать параметр!!!');
          gbl_oTS := param;
                    
          actionsArr := Runner.CallMethod('MDP.GetActions', gbl_oTS);
          if IsArray(actionsArr) then
            for i := VarArrayLowBound(actionsArr, 1) to VarArrayHighBound(actionsArr, 1) do
              if actionsArr[i] = SA_LONG_SCRIPT then // нужно для работы нагрузочных тестов в режиме большой базы
                Map(gbl_MapOfScriptActions, 'put', actionsArr[i], 'REFRESHED')
              else
                Map(gbl_MapOfScriptActions, 'put', actionsArr[i], 'NEED REFRESH');              
        end;
        
      'END SCRIPT' :  // после окончания работы скрипта
        begin
          if IsEmpty(gbl_oTS) OR (gbl_SALockCount > 0) then Exit;
          
          // выключаем сброс actionов, не тратим лишнее время и не мучаем К, т.к. скрипты можно считать, не меняются          
{          
          actionsArr := Map(gbl_MapOfScriptActions, 'keys array', nil, nil);
          if IsArray(actionsArr) then
          begin
            actionsToUnsetArr := nil;
            for i := VarArrayLowBound(actionsArr, 1) to VarArrayHighBound(actionsArr, 1) do
              if (Map(gbl_MapOfScriptActions, 'get', actionsArr[i], nil) = 'NEED REFRESH') then
                AddToArray(actionsToUnsetArr, actionsArr[i]);
            if IsArray(actionsToUnsetArr) then                
                Runner.CallMethod('MDP.UnsetActions', gbl_oTS, actionsToUnsetArr);
          end;
}          
          ScriptAction('RESET');                                                     
        end;
      
      'SET ACTION' : // вызываем при исполнении действия
        begin
          if IsEmpty(gbl_oTS) OR (gbl_SALockCount > 0) then Exit;
          if IsEqual(param, nil) then Raise('Для этой операции нужно указывать параметр!!!');          
          action := param;
          
          actionStatus := GetNonEmpty( Map(gbl_MapOfScriptActions, 'get', action, nil), 'NEED SET');
          
          case actionStatus of
            'NEED SET' :
              begin
                Runner.CallMethod('MDP.SetActions', gbl_oTS, [action]);
                Map(gbl_MapOfScriptActions, 'put', action, 'REFRESHED');
              end;    
            'NEED REFRESH' :
              Map(gbl_MapOfScriptActions, 'put', action, 'REFRESHED');
            'REFRESHED' :;
          else
            Raise('Неизвестный статус действия: ' + actionStatus);
          end;  
        end;
        
      'LOCK' : // блокируем занесение действий
        gbl_SALockCount := gbl_SALockCount + 1;
      'UNLOCK' :
        gbl_SALockCount := gbl_SALockCount - 1;
    else
      Raise('Неизвестное значение параметра whatToDo!');                      
    end;
  
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(whatToDo, 'whatToDo') + DbgVarValue(param, 'param'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC: Прибивает процессы, находящиеся на локальной или удаленной машине
  RESULT:
  REMARK:
}
function RemoteKillProcesses(
  computerName : String; // имя машины (или пустая строка - если локально)
  userName : String; // имя пользователя (в случае локального вызова игнорируется)
  password : String; // пароль (в случае локального вызова игнорируется) 
  processNames : OleVariant; // массив имен процессов (с расширением!!!) можно использовать маску '*'
  killDelay : integer = 0 // задержка между прибиванием процессов  
): boolean; // true - если процессы не существуют
  const
    FUNCTION_NAME = 'RemoteKillProcesses';
  var    
    connOptions, scope, query, searcher, queryCollection, enumerator, currProc : OleVariant;
    queryText : String;
    i, res : integer;    
begin
  try
    // устанавливаем параметры подключения
    connOptions := dotNET.System_Management.ConnectionOptions.zctor();
    if (computerName = '') OR (StringCompare(CompName + '.*', computerName + '.')) then
      computerName := '.'
    else
    begin
      if (userName <> '') then connOptions.Username := userName;  
      if (password <> '') then connOptions.Password := password;
    end;  
    connOptions.Impersonation := dotNET.System_Management.ImpersonationLevel.Impersonate;
    // устанавливаем область обзора
    scope := dotNET.System_Management.ManagementScope.zctor_4('\\' + computerName + '\root\cimv2', connOptions);
    scope.Connect();
    // формируем запрос     
    if NOT IsArray(processNames) then
      Raise('Параметр processNames должен быть массивом!!!');
    for i := VarArrayLowBound(processNames, 1) to VarArrayHighBound(processNames, 1) do
      processNames[i] := 'Name LIKE ''' + Utilities.StringReplace(processNames[i], '*', '%', 1 or 2) + '''';
    queryText := 'SELECT * FROM Win32_Process WHERE ' + Array2String(processNames, ' OR ');              
    query := dotNET.System_Management.ObjectQuery.zctor_2(queryText);
    // создаем объект-искалку  
    searcher := dotNET.System_Management.ManagementObjectSearcher.zctor_5(scope, query);
    // получаем коллекцию объектов, согласно запроса  
    queryCollection := searcher.Get();
    enumerator := queryCollection.System_Collections_IEnumerable_GetEnumerator;

    Result := (queryCollection.Count = 0);    
    if NOT Result then
    begin
      // прибиваем процессы
      while (enumerator.MoveNext) do
      begin
        currProc := enumerator.Current;
        res := VarToInteger( currProc.InvokeMethod('Terminate', [0]).ToString().OleValue );
        if (res <> 0) then
          Log.Error(FUNCTION_NAME + ': Не можем прибить процесс ' + VarToString(currProc.Name.OleValue), DbgVarValue(res, 'Результат Terminate') + DbgVarValue(computerName, 'computerName') + DbgVarValue(userName, 'UserName') + DbgVarValue(password, 'Password') + DbgVarValue(processNames, 'ProcessNames'));
        if (killDelay <> 0) then Delay(killDelay);
      end;
      // проверяем
      Result := (searcher.Get().Count = 0);
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(computerName, 'computerName') + DbgVarValue(userName, 'UserName') + DbgVarValue(password, 'Password') + DbgVarValue(processNames, 'ProcessNames'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;

{
  TYPE:
  DESC: Удаленной запускает процессы
  RESULT:
  REMARK:
    В связи с политиками безопасности, могут быть большие проблемы с запуском интерактивынх процессов
}
function RemoteStartProcesses(
  computerName : String; // имя машины (или пустая строка - если локально)
  userName : String; // имя пользователя (в случае локального вызова игнорируется)
  password : String; // пароль (в случае локального вызова игнорируется) 
  processNames : OleVariant; // массив имен процессов (с расширением!!!)
  startDelay : integer = 0 // задержка между прибиванием процессов  
): boolean ;
  const
    FUNCTION_NAME = 'RemoteStartProcesses';
  var    
    connOptions, scope, mgmtPath, mgmtClass : OleVariant;
    i, res : integer;    
begin
  try
    // устанавливаем параметры подключения
    connOptions := dotNET.System_Management.ConnectionOptions.zctor();
    if (computerName = '') OR (StringCompare(CompName + '.*', computerName + '.')) then
      computerName := '.'
    else
    begin    
      if (userName <> '') then connOptions.Username := userName;
      if (password <> '') then connOptions.Password := password;
    end;  
    connOptions.Impersonation := dotNET.System_Management.ImpersonationLevel.Impersonate;
    // устанавливаем область обзора
    scope := dotNET.System_Management.ManagementScope.zctor_4('\\' + computerName + '\root\cimv2', connOptions);
    scope.Connect();
    // путь
    mgmtPath := dotNET.System_Management.ManagementPath.zctor_2('Win32_Process');
    //
    mgmtClass := dotNET.System_Management.ManagementClass.zctor_6(scope, mgmtPath, EmptyVar);
    //
    if NOT IsArray(processNames) then
      Raise('Параметр processNames должен быть массивом!!!');
    
    Result := true;
    for i := VarArrayLowBound(processNames, 1) to VarArrayHighBound(processNames, 1) do
    begin
      res := VarToInteger( mgmtClass.InvokeMethod('Create', [processNames[i], EmptyVar, EmptyVar, 0]).ToString().OleValue );
      if (res <> 0) then
      begin
        Log.Error('Не удалось запустить процесс ' + processNames[i]);
        Result := false;
      end;
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(computerName, 'computerName') + DbgVarValue(userName, 'UserName') + DbgVarValue(password, 'Password') + DbgVarValue(processNames, 'ProcessNames'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;

{
  TYPE:
  DESC: Возвращает .NET обертку вокруг WMI-объекта Win32_Process с удаленной машины
  RESULT:
  REMARK:
}
function RemoteGetProcessObject(
  computerName : String;
  userName : String;
  password : String;
  processName : String // имя процесса (с расширением!!!)  
): OleVariant ;
  const
    FUNCTION_NAME = 'RemoteGetProcessObject';
  var    
    connOptions, scope, query, searcher, queryCollection, enumerator : OleVariant;
    queryText, cacheKey : String;
    i : integer;   
begin
  try
    VarClear(Result);

    // устанавливаем параметры подключения
    connOptions := dotNET.System_Management.ConnectionOptions.zctor();
    if (computerName = '') OR (StringCompare(CompName + '.*', computerName + '.')) then
      computerName := '.'
    else
    begin  
      if (userName <> '') then connOptions.Username := userName;  
      if (password <> '') then connOptions.Password := password;
    end;  
    connOptions.Impersonation := dotNET.System_Management.ImpersonationLevel.Impersonate;
    // устанавливаем область обзора
    scope := dotNET.System_Management.ManagementScope.zctor_4('\\' + computerName + '\root\cimv2', connOptions);
    scope.Connect();
    // формируем запрос             
    queryText := 'SELECT * FROM Win32_Process WHERE name=''' + processName + '''';              
    query := dotNET.System_Management.ObjectQuery.zctor_2(queryText);
    // создаем объект-искалку  
    searcher := dotNET.System_Management.ManagementObjectSearcher.zctor_5(scope, query);
    // получаем коллекцию объектов, согласно запроса  
    queryCollection := searcher.Get();
    enumerator := queryCollection.System_Collections_IEnumerable_GetEnumerator;
  
    if (queryCollection.Count = 1) AND (enumerator.MoveNext) then
      Result := enumerator.Current
    else if (queryCollection.Count > 1) then
      Raise('Найдено более одного процесса!');     
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(computerName, 'CompName') + DbgVarValue(userName, 'UserName') + DbgVarValue(password, 'Password') + DbgVarValue(processName, 'ProcessNames'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;

{
  TYPE:
  DESC: Возвращает .NET обертку вокруг WMI-объекта Win32_Service
  RESULT:
  REMARK:
}
function GetWMIServiceObject(
  serviceName : String // имя сервиса
): OleVariant ;
  const
    FUNCTION_NAME = 'GetWMIServiceObject';
  var    
    connOptions, scope, query, searcher, queryCollection, enumerator : OleVariant;
    queryText, cacheKey : String;
    i : integer;   
begin
  try
    VarClear(Result);

    // устанавливаем параметры подключения
    connOptions := dotNET.System_Management.ConnectionOptions.zctor();
    connOptions.Impersonation := dotNET.System_Management.ImpersonationLevel.Impersonate;
    // устанавливаем область обзора
    scope := dotNET.System_Management.ManagementScope.zctor_4('\\.\root\cimv2', connOptions);
    scope.Connect();
    // формируем запрос             
    queryText := 'SELECT * FROM Win32_Service WHERE name=''' + serviceName + '''';              
    query := dotNET.System_Management.ObjectQuery.zctor_2(queryText);
    // создаем объект-искалку  
    searcher := dotNET.System_Management.ManagementObjectSearcher.zctor_5(scope, query);
    // получаем коллекцию объектов, согласно запроса  
    queryCollection := searcher.Get();
    enumerator := queryCollection.System_Collections_IEnumerable_GetEnumerator;
  
    if (queryCollection.Count = 1) AND (enumerator.MoveNext) then
      Result := enumerator.Current
    else if (queryCollection.Count > 1) then
      Raise('Найдено более одного сервиса!');     
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(CompName, 'CompName') + DbgVarValue(serviceName, 'ServiceName'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;

{
  TYPE:
  DESC: Удаляет указанную службу 
  RESULT:
  REMARK:
}    
function DeleteSystemService(
  serviceName: string    
): boolean;
  const
    FUNCTION_NAME = 'DeleteSystemService';
  var
    obj, res;      
begin
  try
    Result := false;
    obj := GetWMIServiceObject(serviceName);
    if IsEmpty(obj) then
      Raise('Служба "' + serviceName + '" не найдена!');

    res := obj.InvokeMethod('StopService', [0]).ToString().OleValue;
    if res <> '0' then
      Log.Message('Не получилось остановить службу: "' + serviceName + '". Код ошибки: "' + res)
    else
      Log.Message('Служба: "' + serviceName + '" остановлена."', pmNormal, GetLogAttr('YELLOW'));
    
    res := obj.InvokeMethod('Delete', [0]).ToString().OleValue;
    Result := res = '0';
    if not Result then
      Raise('Не получилось удалить службу: "' + serviceName + '". Код ошибки: "' + res)
    else
      Log.Message('Служба: "' + serviceName + '" удалена."', pmNormal, GetLogAttr('YELLOW'));
  except
    Result := false;
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
  end;   
end;

{
DESK:  Открывает нужную операцию из нужной группы на панели задач
RESULT: Если передан соответствующий параметр(isOpenForPopupMenu ), тогда возвращаем объект PopUp меню
}
function OpenItemInTasksPanel(
  groupName: string;
  itemName: string;
  const paramString : string = ''
): boolean;
var
  tasksTree;
  paramList, isOpenForPopupMenu;
  obj;
begin  
try
  paramList := ParseParamString(paramString);
  isOpenForPopupMenu := VarToBool( GetParam(paramList, 'OpenForPopupMenu', 'false') );//Если мы хотим вернуть после нажатия на item Контекстное меню

  itemName := AnsiUpperCase(itemName);
  groupName := AnsiUpperCase(groupName);
    
  case groupName of
    'ДОКУМЕНТ': tasksTree := GetFromTasksPanel('ДЕРЕВО "ДОКУМЕНТ"');
    'ПУТЕВОДИТЕЛЬ': tasksTree := GetFromTasksPanel('ДЕРЕВО "ПУТЕВОДИТЕЛЬ"');
    'ЗАПРОС' : tasksTree := GetFromTasksPanel('ДЕРЕВО "ЗАПРОС"');
    else  Raise('Переданный параметр не распознан: ' + groupName);    
  end;
  if NOT IsExists(tasksTree) then Raise('Не удалось получить "дерево ' + groupName);
  if NOT Position_Internal(tasksTree, itemName, DELIM_CHAR, true, 'isPressHome:=true') then
    Raise('Не удалось спозиционироваться на операцию "' + itemName + '" в группе "' + groupName + '" на панели задач');
  Sys.Keys('[Enter]');
  if isOpenForPopupMenu then
  begin
    obj := GetFromTasksPanel('ДЕРЕВО "ДОКУМЕНТ"');
    if NOT IsExists(obj) then Raise('Не удалось получить ДЕРЕВО "ДОКУМЕНТ"');
    obj.Refresh; 
    if NOT IsExists(obj.FindChild(['VCLClass'], ['*TvcmPopupMenuPrim*'], 1)) then
    begin
      Log.Error('У дерева нет всплывающего меню.');
      Raise('У дерева нет всплывающего меню.');
    end; 
    result := obj.VCLObject('TvcmPopupMenuPrim');
  end
  else     
    result := true;
except
  Log.Message('OpenItemInTasksPanel: ' + ExceptionMessage, '' ,  pmNormal, GetLogAttr('EXCEPTION'));
  if isOpenForPopupMenu then result := NonExObj else result := false;
  CommonExceptionHandler;
end;  
end;

var gbl_Sys950950954490;
{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function Sys_: OleVariant;
  const
    FUNCTION_NAME = 'Sys_';
begin
  try
    if (VarType(gbl_Sys950950954490) = varEmpty) then gbl_Sys950950954490 := Sys;
    Result := gbl_Sys950950954490;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

var gbl_Sys_Desktop : OleVariant;  
{
  TYPE:
  DESC: Функций для доступа к Sys.Desktop - для того чтобы обойти глюки с множественным вызовом Sys.Desktop
  RESULT:
  REMARK:
}
function Sys_Desktop : OleVariant;
begin
  if (VarType(gbl_Sys_Desktop) = varEmpty) then gbl_Sys_Desktop := Sys.Desktop;
  Result := gbl_Sys_Desktop;
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function GetRegRootKeyByRootName(
  rootName : String
): integer;
  const
    FUNCTION_NAME = 'GetRegRootKeyByRootName';
begin
  try
    rootName := AnsiUpperCase(rootName);
    case rootName of
      'HKEY_CLASSES_ROOT'             : Result := HKEY_CLASSES_ROOT;
      'HKEY_CURRENT_USER', 'HKCU'     : Result := HKEY_CURRENT_USER;
      'HKEY_LOCAL_MACHINE', 'HKLM'    : Result := HKEY_LOCAL_MACHINE;
      'HKEY_USERS'                    : Result := HKEY_USERS;
      'HKEY_PERFORMANCE_DATA'         : Result := HKEY_PERFORMANCE_DATA;
      'HKEY_CURRENT_CONFIG'           : Result := HKEY_CURRENT_CONFIG;
      'HKEY_DYN_DATA'                 : Result := HKEY_DYN_DATA;
    else
      Raise('Неизвестное значение rootName');    
    end;  
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(rootName, 'rootName'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

var
  gbl_WSHShell;
{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function WSHShell : OleVariant ;
  const
    FUNCTION_NAME = 'WSHShell';
begin
  try
    if (VarType(gbl_WSHShell) = varEmpty) then
      gbl_WSHShell := Sys.OleObject('WScript.Shell');
    Result := gbl_WSHShell;  
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
procedure GetRegBranchParamsFromPath(
  regPath;    // HKLM\Software\Garant
  var regRoot;//   -|     |      |
  var regKey; //         -|      |
  var parName //                -|
);
  const
    FUNCTION_NAME = 'GetRegBranchParamsFromPath';
  var rexp;    
begin
  try
    rexp := HISUtils.RegExpr;
    rexp.Expression := '(.*?)\\(.*?)\\*([^\\]*)$';
    if rexp.Exec(regPath) then
    begin
      regRoot := rexp.Substitute('$1');
      regKey := rexp.Substitute('$2');
      parName := rexp.Substitute('$3');  
    end
    else
      Raise('Некорректно задан путь!');
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
    копирует ветку реестра 
  RESULT:
  REMARK:
}
function CopyRegistryBranch(
  srcPath : String; // путь к ветке, которую нужно скопировать
  dstPath : String // путь, под которым она будет скопирована (по этому пути не должно существовать секции)
): boolean;
  const
    FUNCTION_NAME = 'CopyRegistryBranch';
  var
    rexp;
    srcRoot, dstRoot, srcSectionName, dstSectionName, srcKey, dstKey;
    srcSection, dstSection;
    i;  
begin
  try
    // разбиваем полученные пути на элементы: корень, путь к секции, имя секции
    GetRegBranchParamsFromPath(srcPath, srcRoot, srcKey, srcSectionName);
    srcRoot := GetRegRootKeyByRootName(srcRoot);
    //
    GetRegBranchParamsFromPath(dstPath, dstRoot, dstKey, dstSectionName);
    dstRoot := GetRegRootKeyByRootName(dstRoot);
    // проверяем что существует источник
    if (NOT Storages.Registry(srcKey, srcRoot).SubSectionExists(srcSectionName)) then
      Raise('Источник не существует!');
    // проверяем что отсутствует назначение
    if Storages.Registry(dstKey, dstRoot).SubSectionExists(dstSectionName) OR  Storages.Registry(dstKey, dstRoot).OptionExists(dstSectionName) then
      Raise('По пути назначения уже существует секция или ключ!');    
    
    //    
    Result := RunProgramByShell('"' + GetPathTo(PATH_TO_UTILS) + 'reg\reg.exe" copy ' + srcPath + ' ' + dstPath + ' /s /f', true);    
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(srcPath, 'srcPath') + DbgVarValue(dstPath, 'dstPath'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function IsRegistryBranchExists(
  regBranch
):  boolean;
  const
    FUNCTION_NAME = 'IsRegistryBranchExists';
  var
    root, key, name;    
begin
  try
    GetRegBranchParamsFromPath(regBranch, root, key, name);
    root := GetRegRootKeyByRootName(root);
    Result := Storages.Registry(key, root).SubSectionExists(name);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function DeleteRegistryBranch(
  regBranch
): boolean;
  const
    FUNCTION_NAME = 'DeleteRegistryBranch';
  var
    root, key, name;    
begin
  try
    GetRegBranchParamsFromPath(regBranch, root, key, name);
    root := GetRegRootKeyByRootName(root);
    Result := (NOT IsRegistryBranchExists(regBranch));
    if (NOT Result) then
    begin
      Storages.Registry(key, root).DeleteSubSection(name);
      Result := (NOT IsRegistryBranchExists(regBranch));
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
  RESULT:
  REMARK:
}
function WaitForProgressIndicatorAbsence(
  timeOut : integer = -1;   // в течении этого времени ждем пропадания прогресс-индикатора. -1 - ждем вечно.
  paramString : String = '' // строка параметров  
) : boolean; // true - если по окончании работы функции прогресс-индикатор отсутствует
  const
    FUNCTION_NAME = 'WaitForProgressIndicatorAbsence';
  var 
    progrInd, isPIFounded, paramList, pi_timeout;
    isResultIfIndicatorExists; 
begin
  try
    paramList := ParseParamString(paramString);
    // ResultIfIndicatorExists = false - возвращать результат true, если окно пропало
    // ResultIfIndicatorExists = true - возвращать результат true, в случае, если окно было, а потом пропало
    isResultIfIndicatorExists := VarToBool( GetParam(paramList, 'ResultIfIndicatorExists', false) ); 

    if isResultIfIndicatorExists then
      pi_timeout := Options.Run.Timeout
    else
      pi_timeout := Options.Run.Timeout div 40;
    ProcessKiller(FUNCTION_NAME, 'START', 2*Options.Run.Timeout, GetF1ShellProcess);
    
    // находим прогресс индикатор и ждем его пропадания
    try
      progrInd := GetF1ShellProcess.WaitVCLObject('efProgressIndicator', pi_timeout);
    finally
      ProcessKiller(FUNCTION_NAME, 'STOP');
    end;      
    isPIFounded := IsExists(progrInd);
    if isPIFounded then
    begin
      Log.Picture(Sys_Desktop, FUNCTION_NAME + ': ' + 'Найдено окно прогресс индикатора.');
      Delay(3000);
    end
    else
      Log.Message(FUNCTION_NAME + ': ' + 'Не найдено окно прогресс индикатора.');    

    // ждем пропадания прогресс-индикатора
    if (timeOut <> -1) then
      timeOut := timeOut + Win32API.GetTickCount();
    while IsExists(progrInd) AND ((timeOut = -1) OR (timeOut <= Win32API.GetTickCount())) do Delay(200);
    if (isPIFounded) AND (NOT IsExists(progrInd)) then
      Log.Picture(Sys_Desktop, FUNCTION_NAME + ': ' + 'Окно прогресс индикатора пропало.');
    Delay(1000);

    if isResultIfIndicatorExists then
      Result := (isPIFounded) AND (NOT IsExists(progrInd))
    else
      Result := (NOT IsExists(progrInd));   
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE: Объекты оболочки/Объекты главного окна
  DESC: Объекты для формы с папками ("О программе")
  RESULT:
  REMARK:
}
function GetFromAboutForm(
  whatToGet : String   
) : OleVariant;
var
  parent;     
begin
  try
    parent := GetFromShell('О ПРОГРАММЕ');
    if NOT IsExists(parent) then Raise('Не удалось получить окно "О программе"'); 
    whatToGet := AnsiUpperCase(whatToGet);
    case whatToGet of
      'ПОЛЕ "РЕГИСТРАЦИОННОЕ ИМЯ"' :        
        Result := FindWindowByPath(parent, 'NAME:=LoginLabel;VCLCLASS:=TvtLabel;MAXDEPTH:=1');  
      'ПОЛЕ "ПОЛЬЗОВАТЕЛЬ"' :        
        Result := FindWindowByPath(parent, 'NAME:=UserNameLabe;VCLCLASS:=TvtLabel;MAXDEPTH:=1');  
      'ПОЛЕ "E-MAIL"' :
        Result := FindWindowByPath(parent, 'NAME:=EMailLabel;VCLCLASS:=TvtLabel;MAXDEPTH:=1');
      'КНОПКА "OK"' :
        Result := FindWindowByPath(parent, 'NAME:=OkButton;WNDCLASS:=TeeButton;MAXDEPTH:=1');  
    else
      Raise('Параметр не распознан!');   
    end;
  except
    Log.Message('GetFromAboutForm: ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

const
  GEP_EMPTY_VALUE = 'c5b563ba-ccfe-4c3a-9b36-1d1f579bc109';
  
{
  TYPE:
  DESC:
    Сохраняет/возвращает/удаляет значения параметров. Данные хранятся в реестре, поэтому сохраняются 
    между перезапусками тесткомплита
  RESULT:
  REMARK:
    GET - по имени секции и имени параметра возвращаем значение параметра
      Возвращает значение параметра или emptyvalue если параметр не существует и не задано paramValue.
    SET - по имени секции и имени параметра устанавливаем значение параметра
      Возвращает значение параметра, переданное в функцию      
    IS EXISTS - если задано только имя секции, то говорим существует ли секция, если задано еще и и мя параметра,
      то говорим существует ли параметр      
    DELETE - если ничего не задано, то очищаем все дерево параметров
      если задано только имя секции то удаляем секцию со всем содержимым
      еси задано имя секции и имя параметра, то удаляем только параметр
      Ничего не возвращает
    DUMP TO STRING
      Возвращаем состояние дерева параметров в строку    
}
function GlobalExtParams(
  opName : String; // название операции
  sectionName : String = ''; // имя секции
  paramName : String = ''; // имя параметра
  paramValue : OleVariant = GEP_EMPTY_VALUE // значение параметра (при SET) значение параметра, которое вернем если параметра не существует (при GET)
): OleVariant; // результат зависит от типа операции
  const
    FUNCTION_NAME = 'GlobalExtParams';
    REG_BRANCH = 'Software\TCScripts\' + FUNCTION_NAME;
  var
    baseRegBranch, i, j, currSection;    
begin
  try
    baseRegBranch := Storages.Registry(REG_BRANCH, HKEY_CURRENT_USER);
    //     
    opName := AnsiUpperCase(opName);
    sectionName := AnsiUpperCase(sectionName);
    paramName := AnsiUpperCase(paramName);     
    //
    case opName of
      'SET' :
        begin
          if (sectionName = '') then Raise('Имя секции должно быть задано!');
          if (paramName = '') then Raise('Имя параметра должно быть задано!');
          if IsEqual(paramValue, GEP_EMPTY_VALUE) then Raise('Значение параметра должно быть заданным!');
          baseRegBranch.GetSubSection(sectionName).SetOption(paramName, paramValue);
          Result := paramValue;
        end;
      'GET' :
        begin
          if (sectionName = '') then Raise('Имя секции должно быть задано!');
          if (paramName = '') then Raise('Имя параметра должно быть задано!');
          if baseRegBranch.SubSectionExists(sectionName) then
            Result := baseRegBranch.GetSubSection(sectionName).GetOption(paramName, paramValue)
          else
            Result := paramValue;  
          if IsEqual(Result, GEP_EMPTY_VALUE) then VarClear(Result);
        end;
      'DELETE' :
        begin
          if (sectionName = '') then
            baseRegBranch.Clear
          else if (paramName = '') then
            baseRegBranch.GetSubSection(sectionName).Clear
          else if baseRegBranch.SubSectionExists(sectionName) then
            baseRegBranch.GetSubSection(sectionName).RemoveOption(paramName);
        end;
      'IS EXISTS' :
        begin
          if (sectionName = '') then Raise('Имя секции должно быть задано!');         
          Result := baseRegBranch.SubSectionExists(sectionName);
          if Result AND (paramName <> '') then            
            Result := baseRegBranch.GetSubSection(sectionName).OptionExists(paramName);
        end;
      'DUMP TO STRING' :
        begin
          Result := '';
                    
          if (sectionName <> '') then
            if baseRegBranch.SubSectionExists(sectionName) then
              baseRegBranch := baseRegBranch.GetSubSection(sectionName)
            else
              Exit;

          // выводим имя секции          
          Result := 'Секция "' + baseRegBranch.Name + '"' + EndOfLine;
          // выводим значения опций
          if (baseRegBranch.OptionCount <> 0) then
          begin
            for j := 0 to baseRegBranch.OptionCount-1 do
              Result := Result + '  ' + DbgVarValue( baseRegBranch.GetOptionByIndex(j, GEP_EMPTY_VALUE), baseRegBranch.GetOptionName(j) );
            Result := Result + EndOfLine;              
          end
          else
            Result := Result + '  <опций нет>' + EndOfLine;
          // выводим содержимое подсекций
          for i := 0 to baseRegBranch.SectionCount-1 do
            Result := Result + GlobalExtParams(opName, sectionName + '\' + baseRegBranch.GetSectionName(i));
//          for i := 0 to baseRegBranch.SectionCount-1 do
//          begin
//            currSection := baseRegBranch.GetSubSectionByIndex(i);
//            Result := Result + 'Секция "' + baseRegBranch.GetSectionName(i) + '"' + EndOfLine;
//            for j := 0 to currSection.OptionCount-1 do
//              Result := Result + '  ' + DbgVarValue( currSection.GetOptionByIndex(j, GEP_EMPTY_VALUE), currSection.GetOptionName(j) );
//            Result := Result + EndOfLine;
//          end;
        end;
    else
      Raise('opName не распознан!');
    end;            
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValue(opName, 'opName') + DbgVarValue(sectionName, 'sectionName') + DbgVarValue(paramName, 'paramName') + DbgVarValue(paramValue, 'paramValue'), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;
 
{
  TYPE:
  DESC: Работа с типом версии (хэд или ветка)
  RESULT:
  REMARK:
}
function ProductVersion(
  whatToDo : String = 'get'; // что делать
  const value : integer = PRODUCT_VERSION_DEFAULT
): OleVariant;
  const
    FUNCTION_NAME = 'ProductVersion';
begin
  try
    // Инициализируем по-умолчанию
    if VarType(gbl_ProductVersion) = varEmpty then gbl_ProductVersion := PRODUCT_VERSION_DEFAULT;
    
    whatToDo := AnsiUpperCase(whatToDo);
    case whatToDo of
      'GET': 
        Result := gbl_ProductVersion;
      'SET':
        gbl_ProductVersion := value;
      'RESET TO DEFAULT' :
        gbl_ProductVersion := PRODUCT_VERSION_DEFAULT;
    else
      Raise('Значение WhatToDo не распознано!');
    end;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

{
  TYPE:
  DESC:
    делает табуляцию текста на указанное число табов
  RESULT:
  REMARK:
}
function TabText(
  srcStr : String;
  tabCount : integer = 1
): String;
  const
    FUNCTION_NAME = 'TabText';
  var
    rexp;
    tabStr;    
begin
  try
    Result := '';
    tabStr := RepeatString(#9, tabCount);    
    rexp := HISUtils.RegExpr;
    rexp.Expression := '(?m-s)^.*\r{0,1}\n{0,1}';
    if rexp.Exec(srcStr) then
      repeat
        Result := Result + tabStr + rexp.Substitute('$0');        
      until NOT rexp.ExecNext;
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

const
  FF_TIMES = 'Times New Roman';

{
  TYPE:
  DESC:
    Рисует заданный текст шрифтом заданного вида в возвращаемый объект Picture
  RESULT:
  REMARK:
    строка параметров:
      TextColor - цвет шрифта (по-умолчанию черный), можно использовать стандартные константы типа clRed, или передавать числовое значение
      BkColor - цвет фона (по-умолчанию белый)
      IsItalic - курсив
      IsBold - жирный
      IsStrikeout - перечеркнутый
      IsUnderline - подчеркнутый
}     
function RenderTextToPicture(
  text : String; // текст
  fontFamily : String; // тип шрифта, например 'Times New Roman'  
  fontSize : integer; // размер шрифта    
  paramString : String // строка параметров 
) : OleVariant; // объект Picture, или emptyValue
  const
    FUNCTION_NAME = 'RenderTextToPicture';
  var
    hDC, hFont, hBitmap, memDC;
    fontHeight;
    textSize, bmpFileName;
    paramList;
    textColor, bkColor;
    isItalic, isBold, isStrikeout, isUnderline;      
begin
  try
    paramList := ParseParamString(paramString);
    textColor := Evaluate( GetParam(paramList, 'TextColor', 'clBlack') );
    bkColor := Evaluate( GetParam(paramList, 'BKColor', 'clWhite') );
    isItalic := VarToBool( GetParam(paramList, 'IsItalic', false) );
    isBold := VarToBool( GetParam(paramList, 'IsBold', false) );
    isUnderline := VarToBool( GetParam(paramList, 'IsUnderline', false) );
    isStrikeout := VarToBool( GetParam(paramList, 'IsStrikeout', false) );   
    //
    bmpFileName := IncludeTrailingBackslash(GetTempDirectory) + FUNCTION_NAME + '.bmp';
    // исходный контекст берем от десктопа
    hDC := Win32API.GetDC(0);
    memDC := Win32API.CreateCompatibleDC(hDC);  
    // создаем шрифт    
    fontHeight := -Win32API.MulDiv(fontSize, Win32API.GetDeviceCaps(memDC, LOGPIXELSY), 72);
    hFont := Win32API.CreateFont(
      fontHeight, 0,
      0, 0,
      Choose(isBold, Win32API.FW_BOLD, Win32API.FW_NORMAL), isItalic, isUnderline, isStrikeout,
      Win32API.DEFAULT_CHARSET,
      Win32API.OUT_DEFAULT_PRECIS, Win32API.CLIP_DEFAULT_PRECIS, Win32API.DEFAULT_QUALITY, Win32API.FF_DONTCARE or Win32API.DEFAULT_PITCH,
      fontFamily
    );
    // выбираем шрифт в контекст
    Win32API.SelectObject(memDC, hFont);
    // устанавливаем цвета шрифта и фона
    Win32API.SetTextColor(memDC, textColor);
    Win32API.SetBkColor(memDC, bkColor);
    // вычисляем размер текста
    textSize := Win32API.TSize;
    Win32API.GetTextExtentPoint32(memDC, text, Length(text), textSize);
    // создаем битмап
    hBitmap := Win32API.CreateCompatibleBitmap(hDC, textSize.cx, textSize.cy);
    Win32API.SelectObject(memDC, hBitmap);  
    // выводим текст в контекст
    Win32API.TextOut(memDC, 0, 0, text, Length(text) );
    // сохраняем в файл картинку
    if QCPlugin.SaveBMPFile(bmpFileName, memDC, hBitmap) then
    begin
      Result := Utils.Picture;
      Result.LoadFromFile(bmpFileName);
      DeleteFile(bmpFileName);
    end;    
    //
    WIN32API.ReleaseDC(Win32API.WindowFromDC(hDC), hDC);
    Win32API.DeleteObject(hBitmap);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValueEx([text, fontFamily, fontSize, paramString], ['text', 'fontFamily', 'fontSize', 'paramString']),  pmNormal, GetLogAttr('EXCEPTION'));
  end;   
end;

{
  DESK: Кликаем по кнопкам статусбара: ПРЕДЫДУЩИЙ ДОКУМЕНТ В СПИСКЕ\НАЗАД В СПИСКЕ\К СЛЕДУЮЩЕМУ ДОКУМЕНТУ В СПИСКЕ
  REMARK: Только в том случае, если мы находимся в документе, открытом из списка
}
function ClickStatusBarButton(  
  const buttonCaption : String // название  кнопки    
) : boolean;
var 
  statusBarButton;
begin  
  try
    Result := true;
    
    Delay(Options.Run.Timeout div 10);
    try
      GetMainWindow.Refresh;
    except
    end;
    statusBarButton := GetFromMainWindow('СТАТУСБАР: КНОПКА ' + AnsiUpperCase(buttonCaption));
    if NOT IsExists(statusBarButton)then 
      Raise('Не удалось найти кнопку статусбара: ' + buttonCaption);
    statusBarButton.Click;
    Delay(Options.Run.Timeout div 10);
  except
    Log.Message('ClickStatusBarButton: ' + ExceptionMessage, '',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := false;
    CommonExceptionHandler;
  end;
end;

{
  TYPE:
  DESC: Устанавливает размеры главного окна оболочки
  RESULT:
  REMARK:
}    
procedure SetMainWindowSize(
  x, y: integer    
);
  const
    FUNCTION_NAME = 'SetMainWindowSize';
  var
    w;      
begin
  try
    if VarToBool(gbl_F1ShellTabsEnabled) then
      w := GetMainContainer
    else 
      w := GetMainWindow;

    if not IsExists(w) then
      Raise('Не найдено окно оболочки!');
            
    if IsSupported(w, 'ClientHeight') and IsSupported(w, 'ClientWidth') then
    begin
      w.ClientWidth := x;
      w.ClientHeight := y; 
    end
    else
      Raise('Не найдено свойство главного окна оболочки "ClientHeight" или "ClientWidth"');
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
  end;   
end;

{
  DESK: Функция проверяет версию установленного ФлэшПлеера
  RES: true - если версии больше шестой (удовлетворяющая нам)
}
function IsFlashSupported : boolean;
var
  p;
  v;
begin
  p := Sys.OleObject('ShockWaveFlash.ShockWaveFlash');
  Result := IsSupported(p, 'FlashVersion'); 
  if Result then
  begin  
    v := p.FlashVersion; 
    Log.Message(Utilities.Format('Установлена %x -я версии ФЛЭШ-плеера', [p.FlashVersion]) );
    Result :=  (v > 393216); //393216 - в HEX это 60000 (6 версия)
  end
  else
    Log.Message('IsFlashSupported: Не удалось получить версию Флэш плеера, возможно он вообще не установлен!');
end;


const
  NPR_BASE_SEARCH = 'NPR_BASE_SEARCH';

var
  gbl_NamedProfilersData : OleVariant;
function NamedProfilers(  
  profName : String; // название
  opCode : String // код операции (START | STOP | GET)
): integer; // результат
  const
    FUNCTION_NAME = 'NamedProfilers';
  var
    profData;        
begin
  try    
    opCode := AnsiUpperCase(opCode);
    // получаем 
    profData := GetParam(gbl_NamedProfilersData, profName, -1);  
    //
    case opCode of
      'STOP' : 
        begin
          profData := profData + EndTimeMeasure(FUNCTION_NAME + profName, false);
          Result := profData;
        end;
      'START': 
        begin
          if (profData = -1) then profData := 0;
          StartTimeMeasure(FUNCTION_NAME + profName, false);
        end;        
      'RESET': 
        begin
          profData := -1;
          EndTimeMeasure(FUNCTION_NAME + profName, false);
        end;              
      'GET' : 
        begin
          profData := NamedProfilers('STOP', profName);          
          NamedProfilers('START', profName);
          Result := profData;
        end;  
    else
      Raise('Неизвестный opCode!');      
    end;
    SetParam(gbl_NamedProfilersData, profName, profData);
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, DbgVarValueEx([opCode, profName, profData], ['opCode', 'profName', 'profData']), pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end; 
end;

var gbl_GetSyncedAutoincrementIndexMap;
{
  TYPE: 
  DESC: 
    возвращает новое значение автоинкрементного значения
  RESULT:
  REMARK:
    для локального запуска необходимо
    SynchroObjectsParams('set', SO_ALL_SHARED_PATH, <путь к файловому каталогу, где будут храниться значения>);
}
function GetSyncedAutoincrementIndex(
  indexID : OleVariant; // идентификатор автоинкремента (строка, число ...)
  defaultValue : Integer = 0 // начальное значение, с которого начнем автоувеличение  
) : Integer;
  const
    FUNCTION_NAME = 'GetSyncedAutoincrementIndex';
    KEY_INDEX = 'index';
  var
    csName, mapFileName, prefix, indexMap, currValue;    
begin
  try 
    // определяем уникальный префикс имени критической секции и файла с мапой
    prefix := Map(gbl_GetSyncedAutoincrementIndexMap, 'get', indexID);
    if IsEmpty(prefix) then
    begin
      if NOT IsMap(gbl_GetSyncedAutoincrementIndexMap) then
        Map(gbl_GetSyncedAutoincrementIndexMap, 'create empty map', nil);
      prefix := FUNCTION_NAME + VarToStr(Map(gbl_GetSyncedAutoincrementIndexMap, 'length', nil)+1);
      Map(gbl_GetSyncedAutoincrementIndexMap, 'put', indexID, prefix);
    end;
    
    // определяем имена критической секции и файла с мапой
    csName := prefix + '.cs';
    mapFileName := IncludeTrailingBackslash(SynchroObjectsParams('get', SO_ALL_SHARED_PATH)) + prefix + '.map';
    
    // получаем следующее значение    
    if EnterCriticalSectionByFile(csName) then
      try
        // загружаем мапу с индексом из файла
        Map(indexMap, 'load from file', mapFileName);
        // получаем значение индекса
        currValue := Map(indexMap, 'get', KEY_INDEX);
        if IsEmpty(currValue) then currValue := defaultValue;
        //
        Result := currValue;
        // увеличиваем значение индекса и кладем его в мапу
        Inc(currValue);
        Map(indexMap, 'put', KEY_INDEX, currValue);
        Map(indexMap, 'save to file', mapFileName);               
      finally
        LeaveCriticalSectionByFile(csName);
      end;     
  except
    Log.Message(FUNCTION_NAME + ': ' + ExceptionMessage, '', pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;


{
  TYPE: Объекты оболочки/Импорт из папки
  DESC:
  RESULT:
  REMARK: 
}
function GetFromImportInFolderDialog(
  whatToGet : String;
  const addParams : String = '';
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromImportInFolderDialog';
  var
    cacheKey : OleVariant;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    if (parent = nil) then parent := GetFromShell('ДИАЛОГ ИМПОРТА В ПАПКУ');
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ДИАЛОГ "ИМПОРТ ИНФОРМАЦИИ В ПАПКУ"' :
          Result := parent;
        'ПОЛЕ "ИМЯ ФАЙЛА"':
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=ComboBoxEx32;INDEX:=1|WNDCLASS:=ComboBox|WNDCLASS:=Edit' 
          );        
        'КНОПКА "ОТКРЫТЬ"':
          Result := FindWindowByPath(
            parent,
            'WNDCAPTION:=*Open*;WNDCLASS:=Button' 
          );          
      else
        Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
  except
    Log.Message(FUNCTION_NAME+ ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Экспорт в папку
  DESC:
  RESULT:
  REMARK: 
}
function GetFromExportFromFolderDialog(
  whatToGet : String;
  const addParams : String = '';
  parent : OleVariant = nil
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromExportFromFolderDialog';
  var
    cacheKey : OleVariant;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    if (parent = nil) then parent := GetFromShell('ДИАЛОГ ЭКСПОРТА ИЗ ПАПКИ');
    
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ДИАЛОГ "ЭКСПОРТ ИНФОРМАЦИИ ИЗ ПАПКИ"' :
          Result := parent;
        'ПОЛЕ "ИМЯ ФАЙЛА"':
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=ComboBoxEx32;INDEX:=1|WNDCLASS:=ComboBox|WNDCLASS:=Edit' 
          );        
        'КНОПКА "СОХРАНИТЬ"':
          Result := FindWindowByPath(
            parent,
            'WNDCAPTION:=*Save*;WNDCLASS:=Button' 
          );          
      else
        Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
  except
    Log.Message(FUNCTION_NAME+ ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/Интернет Агент
  DESC:
  RESULT:
  REMARK: 
}
function GetFromInternetAgent(
  whatToGet : String;
  parentZone : OleVariant = nil    
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromInternetAgent';
  var
    cacheKey : OleVariant;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    if parentZone=nil then parentZone := GetFromMainWindow('PARENT ZONE');     
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parentZone, cacheKey, Result ) then
    begin
      case whatToGet of
        'ОСНОВНАЯ ОБЛАСТЬ' :
          Result := FindWindowByPath(
            parentZone,
            'WNDCLASS:=Internet Explorer_Server;MAXDEPTH:=5'
          )
      else
        Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parentZone, cacheKey, Result );
    end;
  except
    Log.Message(FUNCTION_NAME+ ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: 
  DESC: Отдаём машины, на которых настроен  Outlook Express
  RESULT:
  REMARK: 
}
function  IsOutlookExpressSupported: boolean;
var
  name;
begin
  name := CompName; 
  Result := 
    (name = 'TESTCLIENT-10') OR 
    (name = 'TESTCLIENT-20') OR 
    (name = 'TESTCLIENT-22');       
end;

{
  TYPE: Объекты оболочки/OutlookExpress
  DESC:
  RESULT:
  REMARK: 
}
function GetFromOutlookExpress(
  whatToGet : String      
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromOutlookExpress';
  var
    cacheKey : OleVariant;
    parent;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    parent := GetF1ShellProcess;     
    cacheKey := FUNCTION_NAME + whatToGet;
    if NOT Cache_Check(parent, cacheKey, Result ) then
    begin
      case whatToGet of
        'ОСНОВНОЕ ОКНО' :
          Result := FindWindowByPath(
            parent,
            'WNDCLASS:=ATH_Note;MAXDEPTH:=1'
          );
        'ПОЛЕ "ВЛОЖЕНИЕ"' :
          Result := FindWindowByPath(
            GetFromOutlookExpress( 'ОСНОВНОЕ ОКНО'),
            'WNDCLASS:=SysListView32;MAXDEPTH:=2'
          ); 
                              
      else
        Raise('Параметр не распознан!');   
      end;
	    Result := Cache_Put(parent, cacheKey, Result );
    end;
  except
    Log.Message(FUNCTION_NAME+ ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;

{
  TYPE: Объекты оболочки/OutlookExpress
  DESC:
  RESULT:
  REMARK: 
}
function GetFromOutlookExpressConfirmationForm(
  whatToGet : String      
) : OleVariant;
  const
    FUNCTION_NAME = 'GetFromOutlookExpressConfirmationForm';
  var
    cacheKey : OleVariant;
    parent;  
begin
  try
    whatToGet := AnsiUpperCase(whatToGet);
    parent := GetF1ShellProcess.WaitWindow('TMessageForm', 'Подтверждение',-1, Options.Run.Timeout div 3);     
    cacheKey := FUNCTION_NAME + whatToGet;    
      case whatToGet of
        'ОКНО ФОРМЫ' :
          Result := parent;
        'КОНТРОЛ "ВЫДЕЛЕННЫЙ ФРАГМЕНТ"':
          Result := FindWindowByPath(
            GetFromOutlookExpressConfirmationForm( 'ОКНО ФОРМЫ'),
            'WNDCLASS:=TvtFocusLabel;CAPTION:=Выделенный фрагмент'
          ); 
        'КОНТРОЛ "ДОКУМЕНТ ЦЕЛИКОМ"':
          Result := FindWindowByPath(
            GetFromOutlookExpressConfirmationForm( 'ОКНО ФОРМЫ'),
            'WNDCLASS:=TvtFocusLabel;CAPTION:=Документ целиком'
          );        
      else
        Raise('Параметр не распознан!');   
      end;    
  except
    Log.Message(FUNCTION_NAME+ ': ' + ExceptionMessage, 'whatToGet: "' + whatToGet + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Result := NonExObj;
    CommonExceptionHandler;
  end;
end;


{
  TYPE: Общее
  DESC: Положить в стек значение
  RESULT:
  REMARK: 
}
function StackPush(
  var stack : OleVariant; // хранилище для стека (любая переменная)
  const value : OleVariant // сохраняемое значение
) : OleVariant; // сохраненное значение
begin
  stack := [value, stack];
  Result := value;
end;


{
  TYPE: Общее
  DESC: Вытащить из стека последнее значение
  RESULT:
  REMARK: 
}
function StackPop(
  var stack : OleVariant; // хранилище для стека (любая переменная)
  var value : OleVariant  // переменная в которую будет сохранено значение
) : Boolean; // достигнут ли конец стека (возвращено ли что-нибудь)?
  const
    VAR_VARIANT_ARRAY = varArray OR varVariant;
begin
	Result := VarType(stack) = VAR_VARIANT_ARRAY;
  if Result then
  begin
    value := stack[0];
    stack := stack[1];
  end;  
end;


{
  TYPE: Работа со строками
  DESC: Форматирует текст так чтобы он состоял из строк длиной не более чем заданной
  RESULT:
  REMARK: 
}
function WrapTextS(
  const sText : String; // текст
  const sBreak : String; // разделитель
  const iLineLength : Integer // максимальная длниа отдельной строки
) : String;
  const
    FUNCTION_NAME = 'WrapTextS';  
  var
    iBreakLength, iCurrPos, iLineStart,  iLastBreakPos, iNewBreakPos : Integer;
    isBreak : Boolean;
begin
  try
    Result := sText;    
  
    iCurrPos := 1;
    iLineStart := 1;
    iLastBreakPos := 1;
    while iCurrPos < Length(Result) do
    begin
      isBreak := false;
    
      if (Result[iCurrPos] = EndOfLine[1]) AND ((iCurrPos+1 < Length(Result)) AND (Result[iCurrPos+1] = EndOfLine[2])) then
      begin
        iLineStart := iCurrPos + Length(EndOfLine);
        iLastBreakPos := iLineStart;
      end
      else if Result[iCurrPos] = ' ' then
        begin
          if ((iCurrPos - iLineStart) < iLineLength) then
            iLastBreakPos := iCurrPos + 1
          else
            isBreak := true;
        end    
      else if (iCurrPos - iLineStart) = iLineLength then
      begin
        isBreak := true;
        if iLastBreakPos = iLineStart then
          iLastBreakPos := iCurrPos;
      end;        
    
      if isBreak then
      begin
        Result := aqString.Insert(Result, sBreak, iLastBreakPos-1);
        iLineStart := iLastBreakPos + Length(sBreak);
        iLastBreakPos := iLineStart;
        Inc(iCurrPos, Length(sBreak));      
      end;         
      //
      Inc(iCurrPos);
    end;
  except
    Log.Message(FUNCTION_NAME+ ': ' + ExceptionMessage, 'sText: "' + VarToString(sText) + '"; sBreak: "' + VarToString(sBreak) + '"; iLineLength: "' + VarToString(iLineLength) + '"',  pmNormal, GetLogAttr('EXCEPTION'));
    Raise;
  end;
end;
